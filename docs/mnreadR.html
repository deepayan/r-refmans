<!DOCTYPE html><html><head><title>Help for package mnreadR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mnreadR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accIndex'><p>Reading ACCessibility Index (ACC) calculation</p></a></li>
<li><a href='#curveParam_RS'><p>Standard estimation of Maximum Reading Speed (MRS) and Critical Print Size (CPS) using reading speed values.</p></a></li>
<li><a href='#curveParam_RT'><p>Standard estimation of Maximum Reading Speed (MRS) and Critical Print Size (CPS)</p>
using individual data of reading time and number of errors.</a></li>
<li><a href='#data_low_vision'><p>MNREAD data collected in subjects with low vision.</p></a></li>
<li><a href='#data_normal_vision'><p>MNREAD data collected in subjects with normal vision.</p></a></li>
<li><a href='#logMARcorrect'><p>Print size correction for non-standard viewing distance</p></a></li>
<li><a href='#mnreadCurve'><p>MNREAD curve plotting.</p></a></li>
<li><a href='#mnreadParam'><p>Standard MNREAD parameters' estimation</p></a></li>
<li><a href='#mnreadR'><p>mnreadR: An R package for analyzing MNREAD data</p></a></li>
<li><a href='#nlmeCurve'><p>Plot individual MNREAD fitted curves as estimated by a nonlinear mixed-effect (NLME) modeling.</p></a></li>
<li><a href='#nlmeModel'><p>MNREAD data fitting using a nonlinear mixed-effect (NLME) modeling.</p></a></li>
<li><a href='#nlmeParam'><p>Maximum Reading Speed (MRS) and Critical Print Size (CPS) estimation using a nonlinear mixed-effect (NLME) modeling.</p></a></li>
<li><a href='#nlmePredict_PS'><p>Estimation of the print size value necessary to achieve a given reading speed.</p></a></li>
<li><a href='#nlmePredict_RS'><p>Estimation of the reading speed achieved for a given print size.</p></a></li>
<li><a href='#readingAcuity'><p>Reading Acuity (RA) calculation</p></a></li>
<li><a href='#readingSpeed'><p>Reading speed calculation corrected for the number of errors</p></a></li>
<li><a href='#readingSpeed_nonCorrected'><p>Reading speed calculation not corrected for the number of errors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>MNREAD Parameters Estimation and Curve Plotting</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows to analyze the reading data obtained with the MNREAD Acuity 
    Chart, a continuous-text reading acuity chart for normal and low vision. 
    Provides the necessary functions to plot the MNREAD curve and estimate 
    automatically the four MNREAD parameters: Maximum Reading Speed, 
    Critical Print Size, Reading Acuity and Reading Accessibility Index.
    Parameters can be estimated either with the standard method 
    or with a nonlinear mixed-effects (NLME) modeling. 
    See Calabrese et al. 2018 for more details &lt;<a href="https://doi.org/10.1167%2F18.1.8">doi:10.1167/18.1.8</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), dplyr, tidyr, ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, nlme, tibble</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://legge.psych.umn.edu/mnread-acuity-charts">https://legge.psych.umn.edu/mnread-acuity-charts</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-18 12:56:57 UTC; Aurelie</td>
</tr>
<tr>
<td>Author:</td>
<td>Aurélie Calabrèse [aut, cre],
  J. Steve Mansfield [aut],
  Gordon E. Legge [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aurélie Calabrèse &lt;aurelie.calabrese@univ-amu.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-18 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='accIndex'>Reading ACCessibility Index (ACC) calculation</h2><span id='topic+accIndex'></span>

<h3>Description</h3>

<p>This function calculates the Reading Accessibility Index, while applying suited rules for missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accIndex(data, print_size, reading_time, errors, ... = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accIndex_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="accIndex_+3A_print_size">print_size</code></td>
<td>
<p>The variable that contains print size values for each sentence (print size uncorrected for viewing distance)</p>
</td></tr>
<tr><td><code id="accIndex_+3A_reading_time">reading_time</code></td>
<td>
<p>The variable that contains the reading time for each sentence</p>
</td></tr>
<tr><td><code id="accIndex_+3A_errors">errors</code></td>
<td>
<p>The variable that contains the number of errors for each sentence</p>
</td></tr>
<tr><td><code id="accIndex_+3A_...">...</code></td>
<td>
<p>Optional grouping arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a new dataframe with a variable called &quot;ACC&quot; that contains the Reading Accessibility Index estimate.
</p>


<h3>Notes</h3>

<p>The Reading ACCessibility Index (ACC) is a new measure representing an individual's access to text over the range of print sizes found in everyday life.
Its calculation does not rely on curve fitting and gives a direct comparison with the performance of normally sighted individuals.
The ACC calculation uses the print size values non corrected for non-standard viewing distance.
</p>
<p>For more details on the Reading Accessibility Index, see http://doi.org/10.1001/jamaophthalmol.2015.6097
</p>


<h3>Warning</h3>

<p>To ensure that missing data are handled properly and that ACC calculation is correct, data need to be entered along certain rules:
</p>

<ul>
<li><p> For the smallest print size that is presented but not read, right before the test is stopped: <strong>reading_time = NA, errors = 10</strong>
</p>
</li>
<li><p> For all the small sentences that are not presented because the test was stopped before them: <strong>reading_time = NA, errors = NA</strong>
</p>
</li>
<li><p> If a sentence is presented, and read, but the time was not recorded by the experimenter: <strong>reading_time = NA, errors = actual number of errors</strong> (cf. s5-regular in low vision data sample)
</p>
</li>
<li><p> If a large sentence was skipped to save time but would have been read well: <strong>reading_time = NA, errors = NA</strong> (cf. s1-regular in normal vision data sample)
</p>
</li>
<li><p> If a large sentence was skipped to save time because the subject cannot read large print: <strong>reading_time = NA, errors = 10</strong> (cf. s7 in low vision data sample)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mnreadParam">mnreadParam</a></code> for all MNREAD parameters estimation
</p>
<p><code><a href="#topic+curveParam_RT">curveParam_RT</a></code> for MRS and CPS estimation using values of reading time (instead of reading speed)
</p>
<p><code><a href="#topic+curveParam_RS">curveParam_RS</a></code> for MRS and CPS estimation using values of reading speed (instead of reading time)
</p>
<p><code><a href="#topic+readingAcuity">readingAcuity</a></code> for Reading Acuity calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test only (subject s1, regular polarity)
data_s1 &lt;- data_low_vision %&gt;%
   filter (subject == "s1", polarity == "regular")

# run the reading accessibility index calculation
data_low_vision_ACC &lt;- accIndex(data_s1, ps, rt, err)

# inspect the newly created dataframe
data_low_vision_ACC

#------

# run the reading accessibility index calculation
# on the whole dataset grouped by subject and polarity
data_low_vision_ACC &lt;- accIndex(data_low_vision, ps, rt, err,
                               subject, polarity)

# inspect the structure of the newly created dataframe
head(data_low_vision_ACC, 10)

</code></pre>

<hr>
<h2 id='curveParam_RS'>Standard estimation of Maximum Reading Speed (MRS) and Critical Print Size (CPS) using reading speed values.</h2><span id='topic+curveParam_RS'></span>

<h3>Description</h3>

<p>This function estimates simultaneously:
</p>

<ul>
<li><p> Maximum Reading Speed (MRS)
</p>
</li>
<li><p> Critical Print Size (CPS)
</p>
</li></ul>

<p>while performing print size correction for non-standard testing viewing distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curveParam_RS(data, print_size, viewing_distance, reading_speed, ... = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curveParam_RS_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="curveParam_RS_+3A_print_size">print_size</code></td>
<td>
<p>The variable that contains print size values for each sentence (print size uncorrected for viewing distance)</p>
</td></tr>
<tr><td><code id="curveParam_RS_+3A_viewing_distance">viewing_distance</code></td>
<td>
<p>The variable that contains the viewing distance value used for testing</p>
</td></tr>
<tr><td><code id="curveParam_RS_+3A_reading_speed">reading_speed</code></td>
<td>
<p>The variable that contains the reading speed for each sentence</p>
</td></tr>
<tr><td><code id="curveParam_RS_+3A_...">...</code></td>
<td>
<p>Optional grouping arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a new dataframe with two variables:
</p>

<ul>
<li><p> &quot;CPS&quot; -&gt; contains the Critical Print Size estimate (in logMAR)
</p>
</li>
<li><p> &quot;MRS&quot; -&gt; contains the Maximum Reading Speed estimate (in words/min)
</p>
</li></ul>



<h3>Notes</h3>

<p>This function uses the original algorithm described in Legge (2007) to estimate Maximum Reading Speed (MRS) and Critical Print Size (CPS).
This algorithm searches for a reading speed plateau in the data. A plateau is defined as a range of print sizes
that supports reading speed at a significantly faster rate than the print sizes smaller or larger than the plateau range.
Concretely, the plateau is determined as print sizes which reading speed is at least 1.96 SD faster than the other print sizes.
The Maximum Reading Speed is estimated as the mean reading speed for print sizes included in the plateau.
The Critical Print Size is defined as the smallest print size on the plateau.
</p>
<p>For more details on the original algorithm, see Chapter 5 of this book:\
Legge, G.E. (2007). Psychophysics of Reading in Normal and Low Vision. Mahwah, NJ &amp; London: Lawrence Erlbaum Associates. ISBN 0-8058-4328-0
<a href="https://books.google.fr/books/about/Psychophysics_of_Reading_in_Normal_and_L.html?id=BGTHS8zANiUC&amp;redir_esc=y">https://books.google.fr/books/about/Psychophysics_of_Reading_in_Normal_and_L.html?id=BGTHS8zANiUC&amp;redir_esc=y</a>
</p>
<p>To ensure proper estimation of the MRS and CPS, individual MNREAD curves should be plotted using <code><a href="#topic+mnreadCurve">mnreadCurve</a></code> and inspected visually.
</p>


<h3>Warning</h3>

<p>To run the function properly, one needs to make sure that the variables are of the class:
</p>

<ul>
<li> <p><strong>print_size</strong> -&gt; numeric
</p>
</li>
<li> <p><strong>viewing_distance</strong> -&gt; integer
</p>
</li>
<li> <p><strong>reading_speed</strong> -&gt; numeric
</p>
</li></ul>

<p>In cases where only 3 or less sentences were read during a test,
the function won't be able to estimate the MRS and CPS
and will return NA values instead.
The ACC should be used to estimate the MNREAD score in such cases
where there are not enough data points to fit the MNREAD curve.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curveParam_RT">curveParam_RT</a></code> for standard MRS and CPS estimation using values of reading time (instead of reading speed)
</p>
<p><code><a href="#topic+nlmeParam">nlmeParam</a></code> for MRS and CPS estimation using a nonlinear mixed-effect model (NLME)
</p>
<p><code><a href="#topic+mnreadParam">mnreadParam</a></code> for all MNREAD parameters estimation
</p>
<p><code><a href="#topic+readingAcuity">readingAcuity</a></code> for Reading Acuity calculation
</p>
<p><code><a href="#topic+accIndex">accIndex</a></code> for Reading Accessibility Index calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

# create the reading speed variable 
data_low_vision &lt;- data_low_vision %&gt;% 
  mutate (rs = (10 - replace (err, err &gt; 10, 10)) / rt * 60)

#------

# restrict dataset to one MNREAD test only (subject s1, regular polarity)
data_s1 &lt;- data_low_vision %&gt;%
   filter (subject == "s1", polarity == "regular")

# run the parameters estimation
data_low_vision_MRS_CPS &lt;- curveParam_RS(data_s1, ps, vd, rs)

# inspect the newly created dataframe
data_low_vision_MRS_CPS

#------

# run the parameters estimation on the whole dataset grouped by subject and polarity
data_low_vision_MRS_CPS &lt;- curveParam_RS(data_low_vision, ps, vd, rs,
                                           subject, polarity)

# inspect the structure of the newly created dataframe
head(data_low_vision_MRS_CPS, 10)

</code></pre>

<hr>
<h2 id='curveParam_RT'>Standard estimation of Maximum Reading Speed (MRS) and Critical Print Size (CPS) 
using individual data of reading time and number of errors.</h2><span id='topic+curveParam_RT'></span>

<h3>Description</h3>

<p>This function estimates simultaneously:
</p>

<ul>
<li><p> Maximum Reading Speed (MRS)
</p>
</li>
<li><p> Critical Print Size (CPS)
</p>
</li></ul>

<p>while performing print size correction for non-standard testing viewing distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curveParam_RT(
  data,
  print_size,
  viewing_distance,
  reading_time,
  errors,
  ... = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curveParam_RT_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="curveParam_RT_+3A_print_size">print_size</code></td>
<td>
<p>The variable that contains print size values for each sentence (print size uncorrected for viewing distance)</p>
</td></tr>
<tr><td><code id="curveParam_RT_+3A_viewing_distance">viewing_distance</code></td>
<td>
<p>The variable that contains the viewing distance value used for testing</p>
</td></tr>
<tr><td><code id="curveParam_RT_+3A_reading_time">reading_time</code></td>
<td>
<p>The variable that contains the reading time for each sentence</p>
</td></tr>
<tr><td><code id="curveParam_RT_+3A_errors">errors</code></td>
<td>
<p>The variable that contains the number of errors for each sentence</p>
</td></tr>
<tr><td><code id="curveParam_RT_+3A_...">...</code></td>
<td>
<p>Optional grouping arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a new dataframe with two variables:
</p>

<ul>
<li><p> &quot;CPS&quot; -&gt; contains the Critical Print Size estimate (in logMAR)
</p>
</li>
<li><p> &quot;MRS&quot; -&gt; contains the Maximum Reading Speed estimate (in words/min)
</p>
</li></ul>



<h3>Notes</h3>

<p>This function uses the original algorithm described in Legge (2007) to estimate Maximum Reading Speed (MRS) and Critical Print Size (CPS).
This algorithm searches for a reading speed plateau in the data. A plateau is defined as a range of print sizes
that supports reading speed at a significantly faster rate than the print sizes smaller or larger than the plateau range.
Concretely, the plateau is determined as print sizes which reading speed is at least 1.96 SD faster than the other print sizes.
The Maximum Reading Speed is estimated as the mean reading speed for print sizes included in the plateau.
The Critical Print Size is defined as the smallest print size on the plateau.
</p>
<p>For more details on the original algorithm, see Chapter 5 of this book:\
Legge, G.E. (2007). Psychophysics of Reading in Normal and Low Vision. Mahwah, NJ &amp; London: Lawrence Erlbaum Associates. ISBN 0-8058-4328-0
<a href="https://books.google.fr/books/about/Psychophysics_of_Reading_in_Normal_and_L.html?id=BGTHS8zANiUC&amp;redir_esc=y">https://books.google.fr/books/about/Psychophysics_of_Reading_in_Normal_and_L.html?id=BGTHS8zANiUC&amp;redir_esc=y</a>
</p>
<p>To ensure proper estimation of the MRS and CPS, individual MNREAD curves should be plotted using <code><a href="#topic+mnreadCurve">mnreadCurve</a></code> and inspected visually.
</p>


<h3>Warning</h3>

<p>For the function to run properly, one needs to make sure that the variables are of the class:
</p>

<ul>
<li> <p><strong>print_size</strong> -&gt; numeric
</p>
</li>
<li> <p><strong>viewing_distance</strong> -&gt; integer
</p>
</li>
<li> <p><strong>reading_time</strong> -&gt; numeric
</p>
</li>
<li> <p><strong>errors</strong> -&gt; integer
</p>
</li></ul>

<p>In cases where only 3 or less sentences were read during a test,
the function won't be able to estimate the MRS and CPS
and will return NA values instead.
The ACC should be used to estimate the MNREAD score in such cases
where there are not enough data points to fit the MNREAD curve.
</p>
<p>To ensure proper parameters estimation, the data should be entered along certain rules:
</p>

<ul>
<li><p> For the smallest print size that is presented but not read, right before the test is stopped: <strong>reading_time = NA, errors = 10</strong>
</p>
</li>
<li><p> For all the small sentences that are not presented because the test was stopped before them: <strong>reading_time = NA, errors = NA</strong>
</p>
</li>
<li><p> If a sentence is presented, and read, but the time was not recorded by the experimenter: <strong>reading_time = NA, errors = actual number of errors</strong> (cf. s5-regular in low vision data sample)
</p>
</li>
<li><p> If a large sentence was skipped to save time but would have been read well: <strong>reading_time = NA, errors = NA</strong> (cf. s1-regular in normal vision data sample)
</p>
</li>
<li><p> If a large sentence was skipped to save time because the subject cannot read large print: <strong>reading_time = NA, errors = 10</strong> (cf. s7 in low vision data sample)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+curveParam_RS">curveParam_RS</a></code> for standard MRS and CPS estimation using values of reading speed (instead of reading time)
</p>
<p><code><a href="#topic+nlmeParam">nlmeParam</a></code> for MRS and CPS estimation using nonlinear mixed-effect (NLME) modeling
</p>
<p><code><a href="#topic+mnreadParam">mnreadParam</a></code> for all MNREAD parameters estimation (using standard calculation)
</p>
<p><code><a href="#topic+readingAcuity">readingAcuity</a></code> for Reading Acuity calculation
</p>
<p><code><a href="#topic+accIndex">accIndex</a></code> for Reading Accessibility Index calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test only (subject s1, regular polarity)
data_s1 &lt;- data_low_vision %&gt;%
   filter (subject == "s1", polarity == "regular")

# run the parameters estimation
data_low_vision_MRS_CPS &lt;- curveParam_RT(data_s1, ps, vd, rt, err)

# inspect the newly created dataframe
data_low_vision_MRS_CPS

#------

# run the parameters estimation on the whole dataset grouped by subject and polarity
data_low_vision_MRS_CPS &lt;- curveParam_RT(data_low_vision, ps, vd, rt, err,
                                           subject, polarity)

# inspect the structure of the newly created dataframe
head(data_low_vision_MRS_CPS, 10)

</code></pre>

<hr>
<h2 id='data_low_vision'>MNREAD data collected in subjects with low vision.</h2><span id='topic+data_low_vision'></span>

<h3>Description</h3>

<p>A dataset containing raw MNREAD data for 12 subjects with low vision. 
6 subjects were treated with treatment A while the other 6 were given treatment B.
Each subject was tested twice on the MNREAD:
</p>

<ul>
<li><p> once on the regular polarity of the test (black print on white background)
</p>
</li>
<li><p> once on the reverse polarity of the test (white print on black background)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data_low_vision
</code></pre>


<h3>Format</h3>

<p>A data frame with 437 rows and 7 variables, where each line stores data for one sentence:
</p>

<dl>
<dt>subject</dt><dd><p>subject ID code</p>
</dd>
<dt>polarity</dt><dd><p>test polarity used (regular or reverse)</p>
</dd>
<dt>treatment</dt><dd><p>treatment given to the subject (A or B)</p>
</dd>
<dt>vd</dt><dd><p>viewing distance in cm</p>
</dd>
<dt>ps</dt><dd><p>print size in logMAR, as written on the chart (print size uncorrected for viewing distance)</p>
</dd>
<dt>rt</dt><dd><p>reading time in seconds</p>
</dd>
<dt>err</dt><dd><p>number of errors</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Data collected at the Minnesota Laboratory for Low-Vision Research (UMN)
</p>

<hr>
<h2 id='data_normal_vision'>MNREAD data collected in subjects with normal vision.</h2><span id='topic+data_normal_vision'></span>

<h3>Description</h3>

<p>A dataset containing raw MNREAD data for 18 young adults with normal vision. Each subject was tested twice:
</p>

<ul>
<li><p> once on the regular polarity of the test (black print on white background)
</p>
</li>
<li><p> once on the reverse polarity of the test (white print on black background)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data_normal_vision
</code></pre>


<h3>Format</h3>

<p>A data frame with 684 rows and 6 variables, where each line stores data for one sentence:
</p>

<dl>
<dt>subject</dt><dd><p>subject ID code</p>
</dd>
<dt>polarity</dt><dd><p>test polarity used (regular or reverse)</p>
</dd>
<dt>vd</dt><dd><p>viewing distance in cm</p>
</dd>
<dt>ps</dt><dd><p>print size in logMAR, as written on the chart (print size uncorrected for viewing distance)</p>
</dd>
<dt>rt</dt><dd><p>reading time in seconds</p>
</dd>
<dt>err</dt><dd><p>number of errors</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Data collected at the Minnesota Laboratory for Low-Vision Research (UMN)
</p>

<hr>
<h2 id='logMARcorrect'>Print size correction for non-standard viewing distance</h2><span id='topic+logMARcorrect'></span>

<h3>Description</h3>

<p>The logMAR scale allows simple conversion of print size between different viewing distances.
When the MNREAD test is not run at the standard distance (ie. 40 cm - 16 inches),
the angular print size (in logMAR) must be adjusted to compensate for the change in viewing distance.
This function allows to correct the print size accordingly to the viewing distance used for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logMARcorrect(data, print_size, viewing_distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logMARcorrect_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="logMARcorrect_+3A_print_size">print_size</code></td>
<td>
<p>The variable that contains print size values (print size uncorrected for viewing distance)</p>
</td></tr>
<tr><td><code id="logMARcorrect_+3A_viewing_distance">viewing_distance</code></td>
<td>
<p>The variable that contains the viewing distance value used for testing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the original dataframe with an added variable called &quot;correct_ps&quot; that contains corrected print size values (in logMAR).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the strucutre of the dataframe
head(data_low_vision, 10)

# run the correction
data_low_vision_new &lt;- logMARcorrect(data_low_vision, ps, vd)

# inspect the structure of the newly created dataframe
head(data_low_vision_new, 10)

</code></pre>

<hr>
<h2 id='mnreadCurve'>MNREAD curve plotting.</h2><span id='topic+mnreadCurve'></span>

<h3>Description</h3>

<p>This function plots individual MNREAD curves, while showing the estimated MNREAD parameters:
</p>

<ul>
<li><p> Maximum Reading Speed (MRS)
</p>
</li>
<li><p> Critical Print Size (CPS)
</p>
</li>
<li><p> Reading Acuity (RA)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mnreadCurve(
  data,
  print_size,
  viewing_distance,
  reading_time,
  errors,
  ... = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnreadCurve_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="mnreadCurve_+3A_print_size">print_size</code></td>
<td>
<p>The variable that contains print size values for each sentence (print size uncorrected for viewing distance)</p>
</td></tr>
<tr><td><code id="mnreadCurve_+3A_viewing_distance">viewing_distance</code></td>
<td>
<p>The variable that contains the viewing distance value used for testing</p>
</td></tr>
<tr><td><code id="mnreadCurve_+3A_reading_time">reading_time</code></td>
<td>
<p>The variable that contains the reading time for each sentence</p>
</td></tr>
<tr><td><code id="mnreadCurve_+3A_errors">errors</code></td>
<td>
<p>The variable that contains the number of errors for each sentence</p>
</td></tr>
<tr><td><code id="mnreadCurve_+3A_...">...</code></td>
<td>
<p>Optional grouping arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a plot of reading speed (in words/min) as a function of print size (in logMAR). 
Reading Acuity is marked as a triangle, Maximum Reading Speed and Critical Print Size are shown with dashed lines. 
When using two grouping arguments, a colored diamond is added for clarification.
Highlighted data points represent the range of print sizes included in the Reading Accessibility Index calculation.
</p>


<h3>Notes</h3>

<p>This function can't take more that two grouping arguments. 
The first grouping argument is used to draw sub-plots (using facet_wrap from ggplot2). 
The second grouping argument is color-coded.
</p>
<p>This function performs print size correction for non-standard testing viewing distance before plotting the curve.
</p>
<p>This function uses the original algorithm described in Legge (2007) to estimate Maximum Reading Speed (MRS) and Critical Print Size (CPS).
For more details on the parameters estimation, see <code><a href="#topic+curveParam_RT">curveParam_RT</a></code>.
</p>


<h3>Warning</h3>

<p>For the function to run properly, one needs to make sure that the variables are of the class:
</p>

<ul>
<li> <p><strong>print_size</strong> -&gt; numeric
</p>
</li>
<li> <p><strong>viewing_distance</strong> -&gt; integer
</p>
</li>
<li> <p><strong>reading_time</strong> -&gt; numeric
</p>
</li>
<li> <p><strong>errors</strong> -&gt; integer
</p>
</li></ul>

<p>In cases where only 3 or less sentences were read during a test,
MRS and CPS cannot be estimated and won't be displayed on the plot.
In such cases, the Reading Accessibility Index (ACC) can be used to estimate the MNREAD score instead (cf. <code><a href="#topic+accIndex">accIndex</a></code>).
</p>
<p>To ensure proper plotting, the data should be entered along certain rules:
</p>

<ul>
<li><p> For the smallest print size that is presented but not read, right before the test is stopped: <strong>reading_time = NA, errors = 10</strong>
</p>
</li>
<li><p> For all the small sentences that are not presented because the test was stopped before them: <strong>reading_time = NA, errors = NA</strong>
</p>
</li>
<li><p> If a sentence is presented, and read, but the time was not recorded by the experimenter: <strong>reading_time = NA, errors = actual number of errors</strong> (cf. s5-regular in low vision data sample)
</p>
</li>
<li><p> If a large sentence was skipped to save time but would have been read well: <strong>reading_time = NA, errors = NA</strong> (cf. s1-regular in normal vision data sample)
</p>
</li>
<li><p> If a large sentence was skipped to save time because the subject cannot read large print: <strong>reading_time = NA, errors = 10</strong> (cf. s7 in low vision data sample)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+curveParam_RT">curveParam_RT</a></code> for standard estimation of MRS and CPS using values of reading time (instead of reading speed)
</p>
<p><code><a href="#topic+readingAcuity">readingAcuity</a></code> for Reading Acuity calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test only (subject s1, regular polarity)
data_s1_reg &lt;- data_low_vision %&gt;%
   filter (subject == "s1", polarity == "regular")

# plot the MNREAD curve 
 mnreadCurve(data_s1_reg, ps, vd, rt, err)  

#------

# restrict dataset to one subject (s1) and plot the MNREAD curves using ONE GROUPING ARGUMENT 
# (ie. polarity) 
data_s1 &lt;- data_low_vision %&gt;%
   filter (subject == "s1")

# plot the MNREAD curve using ONE GROUPING ARGUMENT (ie. polarity)
  mnreadCurve(data_s1, ps, vd, rt, err, polarity)  

#------

# restrict dataset to two subject (s1 &amp; s2) and plot the MNREAD curves using TWO GROUPING ARGUMENTS 
# (ie. subject and polarity) 
data_s2 &lt;- data_low_vision %&gt;%
   filter (subject == "s1" | subject == "s2")

  mnreadCurve(data_s2, ps, vd, rt, err, subject, polarity)  

#------

# Once created, the MNREAD curve can be customized as needed using ggplot2, 
# for ex., by adding the number of errors for each sentence on top of the curve

# plot the MNREAD curve 
my.plot &lt;- mnreadCurve(data_s1, ps, vd, rt, err, polarity)

# display my.plot
print(my.plot)

# calculate reading speed and perform print size correction
data_s1_new &lt;- as.data.frame(
data_s1 %&gt;%
    filter (err != "NA" &amp; rt &gt; 0) %&gt;%
    mutate (errors10 = replace (err, err &gt; 10, 10) ) %&gt;%
    mutate (rs = 60 * (10 - errors10) / rt ) %&gt;%
    mutate (correct_ps = ps + round(log10(40/(vd)), 2)) ) 

# add the number of errors for each sentence 
my.new.plot &lt;- my.plot + geom_text(aes(x = correct_ps, y = rs + 5, label = errors10),
                                   alpha = 0.5,
                                   data = data_s1_new %&gt;% filter (errors10 != 0) )

# display my.new.plot                                                                        
print(my.new.plot)

#------

# MNREAD curves can also be saved in a pdf file, with each page showing a different subject
 
# count the number of subjects to define the number of pages
num_pages = length(unique(data_s2$subject))

# create a pdf file 
 
pdf ("MNREAD_curves.pdf", width = 10.5, height = 8, paper = "special", useDingbats = TRUE)

# wrap the plots over several pages
for (i in seq(num_pages)){
    p &lt;- mnreadCurve(data_s2 %&gt;% filter (subject == sort(unique(data_s2$subject))[i]),
                     ps, vd, rt, err, subject, polarity) 
    print(p)
}

dev.off()  



</code></pre>

<hr>
<h2 id='mnreadParam'>Standard MNREAD parameters' estimation</h2><span id='topic+mnreadParam'></span>

<h3>Description</h3>

<p>This function calculates simultaneously all four MNREAD parameters:
</p>

<ul>
<li><p> Maximum Reading Speed (MRS)
</p>
</li>
<li><p> Critical Print Size (CPS)
</p>
</li>
<li><p> Reading Acuity (RA)
</p>
</li>
<li><p> Reading ACCessibility Index (ACC)
</p>
</li></ul>

<p>while performing print size correction for non-standard testing viewing distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mnreadParam(
  data,
  print_size,
  viewing_distance,
  reading_time,
  errors,
  ... = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnreadParam_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="mnreadParam_+3A_print_size">print_size</code></td>
<td>
<p>The variable that contains print size values for each sentence (print size uncorrected for viewing distance)</p>
</td></tr>
<tr><td><code id="mnreadParam_+3A_viewing_distance">viewing_distance</code></td>
<td>
<p>The variable that contains the viewing distance value used for testing</p>
</td></tr>
<tr><td><code id="mnreadParam_+3A_reading_time">reading_time</code></td>
<td>
<p>The variable that contains the reading time for each sentence</p>
</td></tr>
<tr><td><code id="mnreadParam_+3A_errors">errors</code></td>
<td>
<p>The variable that contains the number of errors for each sentence</p>
</td></tr>
<tr><td><code id="mnreadParam_+3A_...">...</code></td>
<td>
<p>Optional grouping arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a new dataframe with four variables:
</p>

<ul>
<li><p> &quot;RA&quot; -&gt; contains the Reading Acuity estimate (in logMAR)
</p>
</li>
<li><p> &quot;CPS&quot; -&gt; contains the Critical Print Size estimate (in logMAR)
</p>
</li>
<li><p> &quot;MRS&quot; -&gt; contains the Maximum Reading Speed estimate (in words/min)
</p>
</li>
<li><p> &quot;ACC&quot; -&gt; contains the Reading Accessibility Index estimate
</p>
</li></ul>



<h3>Notes</h3>

<p>This function uses the original algorithm described in Legge (2007) to estimate Maximum Reading Speed (MRS) and Critical Print Size (CPS).
This algorithm searches for a reading speed plateau in the data. A plateau is defined as a range of print sizes
that supports reading speed at a significantly faster rate than the print sizes smaller or larger than the plateau range.
Concretely, the plateau is determined as print sizes which reading speed is at least 1.96 SD faster than the other print sizes.
The Maximum Reading Speed is estimated as the mean reading speed for print sizes included in the plateau.
The Critical Print Size is defined as the smallest print size on the plateau.
</p>
<p>For more details on the parameters estimation, see  <a href="https://legge.psych.umn.edu/mnread-acuity-charts">https://legge.psych.umn.edu/mnread-acuity-charts</a>
</p>
<p>For more details on the original algorithm, see Chapter 5 of this book:\
Legge, G.E. (2007). Psychophysics of Reading in Normal and Low Vision. Mahwah, NJ &amp; London: Lawrence Erlbaum Associates. ISBN 0-8058-4328-0
<a href="https://books.google.fr/books/about/Psychophysics_of_Reading_in_Normal_and_L.html?id=BGTHS8zANiUC&amp;redir_esc=y">https://books.google.fr/books/about/Psychophysics_of_Reading_in_Normal_and_L.html?id=BGTHS8zANiUC&amp;redir_esc=y</a>
</p>
<p>To ensure proper estimation of the MRS and CPS, individual MNREAD curves should be plotted using <code><a href="#topic+mnreadCurve">mnreadCurve</a></code> and inspected visually.
</p>


<h3>Warning</h3>

<p>For the function to run properly, one needs to make sure that the variables are of the class:
</p>

<ul>
<li> <p><strong>print_size</strong> -&gt; numeric
</p>
</li>
<li> <p><strong>viewing_distance</strong> -&gt; integer
</p>
</li>
<li> <p><strong>reading_time</strong> -&gt; numeric
</p>
</li>
<li> <p><strong>errors</strong> -&gt; integer
</p>
</li></ul>

<p>In cases where only 3 or less sentences were read during a test,
the function won't be able to estimate the MRS and CPS
and will return NA values instead.
The ACC should be used to estimate the MNREAD score in such cases
where there are not enough data points to fit the MNREAD curve.
</p>
<p>To ensure proper ACC calculation, the data should be entered along certain rules:
</p>

<ul>
<li><p> For the smallest print size that is presented but not read, right before the test is stopped: <strong>reading_time = NA, errors = 10</strong>
</p>
</li>
<li><p> For all the small sentences that are not presented because the test was stopped before them: <strong>reading_time = NA, errors = NA</strong>
</p>
</li>
<li><p> If a sentence is presented, and read, but the time was not recorded by the experimenter: <strong>reading_time = NA, errors = actual number of errors</strong> (cf. s5-regular in low vision data sample)
</p>
</li>
<li><p> If a large sentence was skipped to save time but would have been read well: <strong>reading_time = NA, errors = NA</strong> (cf. s1-regular in normal vision data sample)
</p>
</li>
<li><p> If a large sentence was skipped to save time because the subject cannot read large print: <strong>reading_time = NA, errors = 10</strong> (cf. s7 in low vision data sample)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+curveParam_RT">curveParam_RT</a></code> for standard MRS and CPS estimation using values of reading time (instead of reading speed)
</p>
<p><code><a href="#topic+curveParam_RS">curveParam_RS</a></code> for standard MRS and CPS estimation using values of reading speed (instead of reading time)
</p>
<p><code><a href="#topic+nlmeParam">nlmeParam</a></code> for MRS and CPS estimation using a nonlinear mixed-effect model (NLME)
</p>
<p><code><a href="#topic+readingAcuity">readingAcuity</a></code> for Reading Acuity calculation
</p>
<p><code><a href="#topic+accIndex">accIndex</a></code> for Reading Accessibility Index calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test only (subject s1, regular polarity)
data_s1 &lt;- data_low_vision %&gt;%
   filter (subject == "s1", polarity == "regular")

# run the parameters estimation
data_low_vision_param &lt;- mnreadParam(data_s1, ps, vd, rt, err)

# inspect the newly created dataframe
data_low_vision_param

#------

# run the parameters estimation on the whole dataset grouped by subject and polarity
data_low_vision_param &lt;- mnreadParam(data_low_vision, ps, vd, rt, err,
                                           subject, polarity)

# inspect the structure of the newly created dataframe
head(data_low_vision_param, 10)

</code></pre>

<hr>
<h2 id='mnreadR'>mnreadR: An R package for analyzing MNREAD data</h2><span id='topic+mnreadR'></span>

<h3>Description</h3>

<p>mnreadR provides simple functions to estimate the four MNREAD parameters:
</p>

<ul>
<li> <p><strong>Maximum Reading Speed</strong> (MRS) 
-&gt; can be estimated with the standard method: alone with <code><a href="#topic+curveParam_RT">curveParam_RT</a></code> and <code><a href="#topic+curveParam_RS">curveParam_RS</a></code> 
or simultaneously with the other MNREAD parameters with <code><a href="#topic+mnreadParam">mnreadParam</a></code>. 
-&gt; Alternatively, it can be estimated with NLME modeling using <code><a href="#topic+nlmeParam">nlmeParam</a></code>.
</p>
</li>
<li> <p><strong>Critical Print Size</strong> (CPS) 
-&gt; can be estimated with the standard method: alone with <code><a href="#topic+curveParam_RT">curveParam_RT</a></code> and <code><a href="#topic+curveParam_RS">curveParam_RS</a></code> 
or simultaneously with the other MNREAD parameters with <code><a href="#topic+mnreadParam">mnreadParam</a></code>.
-&gt; Alternatively, it can be estimated with NLME modeling using <code><a href="#topic+nlmeParam">nlmeParam</a></code>.
</p>
</li>
<li> <p><strong>Reading Acuity</strong> (RA) 
-&gt; can be estimated alone with <code><a href="#topic+readingAcuity">readingAcuity</a></code> 
or simultaneously with the other MNREAD parameters with <code><a href="#topic+mnreadParam">mnreadParam</a></code>.
</p>
</li>
<li> <p><strong>Reading ACCessibility Index</strong> (ACC) 
-&gt; can be estimated alone with <code><a href="#topic+accIndex">accIndex</a></code> 
or simultaneously with the other MNREAD parameters with <code><a href="#topic+mnreadParam">mnreadParam</a></code>.
</p>
</li></ul>

<p>mnreadR also provides functions for graphical display:
</p>

<ul>
<li><p> Raw data can be plotted with <code><a href="#topic+mnreadCurve">mnreadCurve</a></code> 
</p>
</li>
<li><p> Estimates from the NLME fit can be plotted with <code><a href="#topic+nlmeCurve">nlmeCurve</a></code>
</p>
</li></ul>


<hr>
<h2 id='nlmeCurve'>Plot individual MNREAD fitted curves as estimated by a nonlinear mixed-effect (NLME) modeling.</h2><span id='topic+nlmeCurve'></span>

<h3>Description</h3>

<p>This function uses the NLME model created from <code><a href="#topic+nlmeModel">nlmeModel</a></code> to plot individual curves and Critical Print Size (CPS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlmeCurve(nlme.model, displayCPS = TRUE, CPScriterion = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlmeCurve_+3A_nlme.model">nlme.model</code></td>
<td>
<p>The object returned by <code><a href="#topic+nlmeModel">nlmeModel</a></code></p>
</td></tr>
<tr><td><code id="nlmeCurve_+3A_displaycps">displayCPS</code></td>
<td>
<p>Optional argument to display the CPS on the individuals curves. Default is TRUE. If set to FALSE, the CPS won't be plotted.</p>
</td></tr>
<tr><td><code id="nlmeCurve_+3A_cpscriterion">CPScriterion</code></td>
<td>
<p>Optional argument to specify a criterion for CPS estimation. The default criterion value is '90 of MRS'. This criterion can vary from 75 to 95 of MRS and should only be modified for specific purposes, as discussed in Cheung et al. 2008</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a plot of reading speed (in log words/min) as a function of print size (in logMAR). 
If displayCPS is not specified, the Critical Print Size will be marked as an inverted triangle.
</p>


<h3>Notes</h3>

<p>Print size shown on the plot(s) have been corrected for non-standard testing viewing distance.
</p>
<p>For more details on the nlme fit, see:\
Cheung SH, Kallie CS, Legge GE, Cheong AM. Nonlinear mixed-effects modeling of MNREAD data. 
Invest Ophthalmol Vis Sci. 2008;49:828–835. doi: 10.1167/iovs.07-0555.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlmeModel">nlmeModel</a></code> to fit MNREAD data using a nonlinear mixed-effect (NLME) modeling
</p>
<p><code><a href="#topic+nlmeParam">nlmeParam</a></code> to estimate Maximum Reading Speed (MRS) and Critical Print Size (CPS) from the NLME model
</p>
<p><code><a href="#topic+mnreadCurve">mnreadCurve</a></code> for standard MNREAD curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test per subject (regular polarity only)
data_regular &lt;- data_low_vision %&gt;%
    filter (polarity == "regular")

# run the NLME model for data grouped by subject
 nlme_model &lt;- nlmeModel(data_regular, ps, vd, rt, err, subject) 

#------

# plot MNREAD curves and CPS with a default CPS criterion of '90 of MRS' 
 nlmeCurve(nlme_model) 

# plot MNREAD curves without the CPS for a default CPS criterion of '90 of MRS' 
 nlmeCurve(nlme_model, FALSE) 

# plot MNREAD curves and CPS with a specific CPS criterion of '80 of MRS'
 nlmeCurve(nlme_model, TRUE, 0.8) 

#------

# Once created, the NLME curve can be further customized using ggplot2 

# plot the NLME curve 
 my_plot &lt;- nlmeCurve(nlme_model) 

# display my.plot
 print(my_plot) 

# modify my.plot
 my_new_plot &lt;- my_plot + 
 # overwrites the raw data points
    geom_point(data = nlme_model[[1]], aes(x=correct_ps, y = rs), size = 4) + 
 # changes the colors of the curve and raw data (effective only for nested designs)
    scale_color_brewer(palette="Set1") + 
 # changes the colors of the CPS diamond (effective only for nested designs)
    scale_fill_brewer(palette="Set1")  + 
 # modifies the aspect of the x-axis
    scale_x_continuous(breaks = seq (-0.5,2.5,0.4))  

# display my.new.plot                                                                        
 print(my_new_plot) 


#------

# For very large datasets, it can be usefull to plot only selected facets to inspect individual fit
# To do so, one needs to restrict the dataframe called in each of the three layers of the plot

# list of subject names to keep
subjects_to_keep &lt;- paste ("s", 1:4, sep = "")

# first filter the original data points (data called in the first layer)
 my_plot$data &lt;- my_plot$data %&gt;%
    filter(subject %in% subjects_to_keep) %&gt;%
    droplevels() 
    
# then filter the fitted data points (data called in the second layer)
 my_plot$layers[[2]]$data &lt;- my_plot$layers[[2]]$data %&gt;% 
    filter(subject %in% subjects_to_keep) %&gt;% 
    droplevels() 
  
# and finally, if 'displayCPS' was set to TRUE, filter the data used to display the CPS
 my_plot$layers[[4]]$data &lt;- my_plot$layers[[4]]$data %&gt;% 
    filter(subject %in% subjects_to_keep) %&gt;%
    droplevels() 
    
# plot the restricted my.plot
 my_plot 

#------

# It is also possible to export the curves in a pdf file running over several pages 
# and select the desired number of curves per page 

# set the desired number of subjects by page 
facet_nb = 4

# count the resulting number of pages 
num_pages = ceiling(length(unique(data_low_vision$subject))/facet_nb)

# identify the list of subject names
subjects_to_plot &lt;- unique(as.character(data_low_vision$subject))

# split the list into chunks the same size as the number of subjects per page
subjects_to_plot_splitted &lt;- split(subjects_to_plot, ceiling(seq_along(subjects_to_plot)/facet_nb))

# create a pdf and wrap plots over several pages
 pdf("nlme-MNREAD-curves.pdf",
              width = 10.5, height = 8,
              paper="USr", useDingbats=T)
              
              for (i in seq(num_pages))
              {
                 my.plot &lt;- nlmeCurve(nlme_model, displayCPS = F) 
                 
                 # filter the original data points for the selected chunk of subjects
                 my.plot$data &lt;- my.plot$data %&gt;%
                 filter(subject %in% subjects_to_plot_splitted[[i]]) %&gt;%
                 droplevels()
                 
                 # filter the fitted data points for the selected chunk of subjects
                 my.plot$layers[[2]]$data &lt;- my.plot$layers[[2]]$data %&gt;%
                 filter(subject %in% subjects_to_plot_splitted[[i]]) %&gt;%
                 droplevels()
                 
                 print (my.plot + geom_line(colour = "red"))
              }
              
              dev.off()  
              
              

</code></pre>

<hr>
<h2 id='nlmeModel'>MNREAD data fitting using a nonlinear mixed-effect (NLME) modeling.</h2><span id='topic+nlmeModel'></span>

<h3>Description</h3>

<p>This function uses a nonlinear mixed effects model (NLME), as described in Cheung et al. 2008, 
where variations across individuals are modeled as random effects. 
This function estimates and returns the NLME model while performing print size correction for non-standard testing viewing distance (ie. different than 40 cm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlmeModel(
  data,
  print_size,
  viewing_distance,
  reading_time,
  errors,
  subjectID,
  nested = NULL,
  group = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlmeModel_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="nlmeModel_+3A_print_size">print_size</code></td>
<td>
<p>The variable that contains print size values for each sentence (print size uncorrected for viewing distance)</p>
</td></tr>
<tr><td><code id="nlmeModel_+3A_viewing_distance">viewing_distance</code></td>
<td>
<p>The variable that contains the viewing distance value used for testing</p>
</td></tr>
<tr><td><code id="nlmeModel_+3A_reading_time">reading_time</code></td>
<td>
<p>The variable that contains the reading time for each sentence</p>
</td></tr>
<tr><td><code id="nlmeModel_+3A_errors">errors</code></td>
<td>
<p>The variable that contains the number of errors for each sentence</p>
</td></tr>
<tr><td><code id="nlmeModel_+3A_subjectid">subjectID</code></td>
<td>
<p>The variable that contains the subject identifiers</p>
</td></tr>
<tr><td><code id="nlmeModel_+3A_nested">nested</code></td>
<td>
<p>Optional argument to build a model with a nested structure. 'nested' specifies which variable should be nested within subject. Default is NULL.</p>
</td></tr>
<tr><td><code id="nlmeModel_+3A_group">group</code></td>
<td>
<p>Optional argument to build a model with a grouped structure. 'group' specifies which variable should be used as grouping argument. Default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of two objects: 
</p>

<ul>
<li><p> an object of class dataframe which is a cleaned version of the dataset called by the function to fit the model
</p>
</li>
<li><p> an object of class nlme returned by the function <code><a href="nlme.html#topic+nlme">nlme</a></code> 
</p>
</li></ul>



<h3>Notes</h3>

<p>For subjects with incomplete data, warning messages might appear in the console. However, the NLME model will run, 
using supporting data from the rest of the population.
</p>
<p>This functions supports nested, grouped and nested + grouped structures. 
</p>
<p>If needed, the nlme object returned can be further explored using generic functions from the nlme package.
</p>
<p>This function implements several functions from the nlme package to build the NLME model:
</p>

<ul>
<li><p> it first calls groupedData() to format the dataset in order to match the desired structure
</p>
</li>
<li><p> it then uses nlsList() to generate starting values
</p>
</li>
<li><p> it finally calls nlme() to build the model 
</p>
</li></ul>

<p>For more details on the nlme fit, see:\
Cheung SH, Kallie CS, Legge GE, Cheong AM. Nonlinear mixed-effects modeling of MNREAD data. 
Invest Ophthalmol Vis Sci. 2008;49:828–835. doi: 10.1167/iovs.07-0555.
</p>


<h3>Warning</h3>

<p>For the function to run properly, please make sure that variables are of the following classes:
</p>

<ul>
<li> <p><strong>print_size</strong> -&gt; numeric
</p>
</li>
<li> <p><strong>viewing_distance</strong> -&gt; integer
</p>
</li>
<li> <p><strong>reading_time</strong> -&gt; numeric
</p>
</li>
<li> <p><strong>errors</strong> -&gt; integer
</p>
</li></ul>

<p>The optional arguments &quot;nested&quot; and &quot;group&quot; should only be specified when they are needed. 
In case they are called and set to NULL, the function will not run and will return an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlmeParam">nlmeParam</a></code> to estimate Maximum Reading Speed (MRS) and Critical Print Size (CPS) from the NLME model
</p>
<p><code><a href="#topic+nlmeCurve">nlmeCurve</a></code> to plot the individual MNREAD curves estimated from the NLME model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test per subject (regular polarity only)
data_regular &lt;- data_low_vision %&gt;%
    filter (polarity == "regular")

# run the NLME model for data grouped by subject
 model_simple &lt;- nlmeModel(data_regular, ps, vd, rt, err, subject) 

# to print the model summary
 summary(model_simple[[2]]) 

# to print the first 3 rows of the cleaned dataset containing the raw data and used to run the model
 head(model_simple[[1]], 3) 

#------

# run the NLME model on the whole dataset with polarity nested within subject
 model_nested &lt;- lmeModel(data_low_vision, ps, vd, rt, err, subject,
                                   nested = polarity) 

#------

# run theNLME model on the whole dataset with polarity nested within subject 
# and grouped based on treatment
 model_nested_grouped &lt;- nlmeModel(data_low_vision, ps, vd, rt, err, subject,
                                            nested = polarity, group = treatment) 



</code></pre>

<hr>
<h2 id='nlmeParam'>Maximum Reading Speed (MRS) and Critical Print Size (CPS) estimation using a nonlinear mixed-effect (NLME) modeling.</h2><span id='topic+nlmeParam'></span>

<h3>Description</h3>

<p>This function uses the NLME model created from <code><a href="#topic+nlmeModel">nlmeModel</a></code> to extract the following MNREAD parameters:
</p>

<ul>
<li><p> Maximum Reading Speed (MRS)
</p>
</li>
<li><p> Critical Print Size (CPS)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>nlmeParam(nlme.model, CPScriterion = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlmeParam_+3A_nlme.model">nlme.model</code></td>
<td>
<p>The object returned by <code><a href="#topic+nlmeModel">nlmeModel</a></code></p>
</td></tr>
<tr><td><code id="nlmeParam_+3A_cpscriterion">CPScriterion</code></td>
<td>
<p>Optional argument to specify a criterion for CPS estimation. The default criterion value is '90 of MRS'. This criterion can vary from 75 to 95 of MRS and should only be modified for specific purposes, as discussed in Cheung et al. 2008</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a new dataframe with two variables:
</p>

<ul>
<li><p> &quot;CPS&quot; -&gt; contains the Critical Print Size estimate (in logMAR)
</p>
</li>
<li><p> &quot;MRS&quot; -&gt; contains the Maximum Reading Speed estimate (in words/min)
</p>
</li></ul>



<h3>Notes</h3>

<p>To ensure proper estimation of the MRS and CPS, individual MNREAD fit should be plotted using <code><a href="#topic+nlmeCurve">nlmeCurve</a></code> and inspected visually.
If some of the estimated values of MRS and CPS seem off given the actual data, we advise you to run <code><a href="#topic+mnreadCurve">mnreadCurve</a></code> 
and overwrite these estimates with values estimated visually from the actual MNREAD curve.
</p>
<p>For more details on the nlme fit, see:\
Cheung SH, Kallie CS, Legge GE, Cheong AM. Nonlinear mixed-effects modeling of MNREAD data. 
Invest Ophthalmol Vis Sci. 2008;49:828–835. doi: 10.1167/iovs.07-0555.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlmeModel">nlmeModel</a></code> to fit MNREAD data using a nonlinear mixed-effect (NLME) modeling
</p>
<p><code><a href="#topic+nlmeCurve">nlmeCurve</a></code> to plot the individual MNREAD curves estimated from the NLME model
</p>
<p><code><a href="#topic+curveParam_RT">curveParam_RT</a></code> for standard estimation of MRS and CPS 
</p>
<p><code><a href="#topic+mnreadParam">mnreadParam</a></code> for all MNREAD parameters estimation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test per subject (regular polarity only)
data_regular &lt;- data_low_vision %&gt;%
    filter (polarity == "regular")

# run the NLME model for data grouped by subject
 nlme_model &lt;- nlmeModel(data_regular, ps, vd, rt, err, subject) 

#------

# run the parameters' estimation for a default CPS criterion of '90 of MRS' 
 nlmeParam(nlme_model) 

# run the parameters' estimation for a specific CPS criterion of '80 of MRS'
 nlmeParam(nlme_model, 0.8) 



</code></pre>

<hr>
<h2 id='nlmePredict_PS'>Estimation of the print size value necessary to achieve a given reading speed.</h2><span id='topic+nlmePredict_PS'></span>

<h3>Description</h3>

<p>This function uses results from the NLME model created with <code><a href="#topic+nlmeModel">nlmeModel</a></code> to estimate the print size value required to achieve a specific reading speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlmePredict_PS(nlme.model, reading.speed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlmePredict_PS_+3A_nlme.model">nlme.model</code></td>
<td>
<p>The object returned by <code><a href="#topic+nlmeModel">nlmeModel</a></code></p>
</td></tr>
<tr><td><code id="nlmePredict_PS_+3A_reading.speed">reading.speed</code></td>
<td>
<p>A specific value of reading speed in words/minute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a dataframe with a with two variables:
</p>

<ul>
<li><p> &quot;reading_speed&quot; -&gt; the reading speed value passed to the function (in words/min)
</p>
</li>
<li><p> &quot;required_print_size&quot; -&gt; the print size required to achieve the reading speed value passed to the function (in logMAR)
</p>
</li></ul>



<h3>Notes</h3>

<p>The values of print size returned have been corrected for non-standard testing viewing distance.
</p>
<p>For more details on the nlme fit, see:\
Cheung SH, Kallie CS, Legge GE, Cheong AM. Nonlinear mixed-effects modeling of MNREAD data. 
Invest Ophthalmol Vis Sci. 2008;49:828–835. doi: 10.1167/iovs.07-0555.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlmeModel">nlmeModel</a></code> to fit MNREAD data using a nonlinear mixed-effect (NLME) modeling
</p>
<p><code><a href="#topic+nlmeParam">nlmeParam</a></code> to estimate Maximum Reading Speed (MRS) and Critical Print Size (CPS) from the NLME model
</p>
<p><code><a href="#topic+nlmeCurve">nlmeCurve</a></code> to plot the individual MNREAD curves estimated from the NLME model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test per subject (regular polarity only)
data_regular &lt;- data_low_vision %&gt;%
    filter (polarity == "regular")

# run the NLME model for data grouped by subject
 nlme_model &lt;- nlmeModel(data_regular, ps, vd, rt, err, subject) 

#------

# extract the critical print size required 
# to achieve 40 words/min (ie. spot reading) according to the NLME fit 
 nlmePredict_PS(nlme_model, 40) 

#------

# extract the critical print size required 
# to achieve 80 words/min (ie. fluent reading) according to the NLME fit 
 nlmePredict_PS(nlme_model, 80) 



</code></pre>

<hr>
<h2 id='nlmePredict_RS'>Estimation of the reading speed achieved for a given print size.</h2><span id='topic+nlmePredict_RS'></span>

<h3>Description</h3>

<p>This function uses results from the NLME model created with <code><a href="#topic+nlmeModel">nlmeModel</a></code> to estimate the reading speed achieved for a specific print size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlmePredict_RS(nlme.model, print.size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlmePredict_RS_+3A_nlme.model">nlme.model</code></td>
<td>
<p>The object returned by <code><a href="#topic+nlmeModel">nlmeModel</a></code></p>
</td></tr>
<tr><td><code id="nlmePredict_RS_+3A_print.size">print.size</code></td>
<td>
<p>A specific value of print size in logMAR</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a dataframe with a with two variables:
</p>

<ul>
<li><p> &quot;print_size&quot; -&gt; the print size value passed to the function (in logMAR) 
</p>
</li>
<li><p> &quot;estimated_reading_speed&quot; -&gt; the reading speed achieved at the specified print size as estimated by the NLME model (in words/min)
</p>
</li></ul>



<h3>Notes</h3>

<p>The values of print size returned have been corrected for non-standard testing viewing distance.
</p>
<p>For more details on the nlme fit, see:\
Cheung SH, Kallie CS, Legge GE, Cheong AM. Nonlinear mixed-effects modeling of MNREAD data. 
Invest Ophthalmol Vis Sci. 2008;49:828–835. doi: 10.1167/iovs.07-0555.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlmeModel">nlmeModel</a></code> to fit MNREAD data using a nonlinear mixed-effect (NLME) modeling
</p>
<p><code><a href="#topic+nlmeParam">nlmeParam</a></code> to estimate Maximum Reading Speed (MRS) and Critical Print Size (CPS) from the NLME model
</p>
<p><code><a href="#topic+nlmeCurve">nlmeCurve</a></code> to plot the individual MNREAD curves estimated from the NLME model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test per subject (regular polarity only)
data_regular &lt;- data_low_vision %&gt;%
    filter (polarity == "regular")

# run the NLME model for data grouped by subject
 nlme_model &lt;- nlmeModel(data_regular, ps, vd, rt, err, subject) 

#------

# extract reading speed achieved at 1.6 logMAR according to the NLME fit 
 nlmePredict_RS(nlme_model, 1.6) 



</code></pre>

<hr>
<h2 id='readingAcuity'>Reading Acuity (RA) calculation</h2><span id='topic+readingAcuity'></span>

<h3>Description</h3>

<p>Reading Acuity (RA) is defined as the smallest print size at which one can read without making significant errors.
This function measures Reading Acuity to the nearest 0.1 logMAR, while performing print size correction for non-standard testing viewing distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readingAcuity(
  data,
  print_size,
  viewing_distance,
  reading_time,
  errors,
  ... = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readingAcuity_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="readingAcuity_+3A_print_size">print_size</code></td>
<td>
<p>The variable that contains print size values for each sentence (print size uncorrected for viewing distance)</p>
</td></tr>
<tr><td><code id="readingAcuity_+3A_viewing_distance">viewing_distance</code></td>
<td>
<p>The variable that contains the viewing distance value used for testing</p>
</td></tr>
<tr><td><code id="readingAcuity_+3A_reading_time">reading_time</code></td>
<td>
<p>The variable that contains the reading time for each sentence</p>
</td></tr>
<tr><td><code id="readingAcuity_+3A_errors">errors</code></td>
<td>
<p>The variable that contains the number of errors for each sentence</p>
</td></tr>
<tr><td><code id="readingAcuity_+3A_...">...</code></td>
<td>
<p>Optional grouping arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a new dataframe with a variable called &quot;RA&quot; that contains the Reading Acuity estimate (in logMAR).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mnreadParam">mnreadParam</a></code> for all MNREAD parameters estimation
</p>
<p><code><a href="#topic+curveParam_RT">curveParam_RT</a></code> for MRS and CPS estimation using values of reading time (instead of reading speed)
</p>
<p><code><a href="#topic+curveParam_RS">curveParam_RS</a></code> for MRS and CPS estimation using values of reading speed (instead of reading time)
</p>
<p><code><a href="#topic+accIndex">accIndex</a></code> for Reading Accessibility Index calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the structure of the dataframe
head(data_low_vision, 10)

#------

# restrict dataset to one MNREAD test only (subject s1, regular polarity)
data_s1 &lt;- data_low_vision %&gt;% filter (subject == "s1" &amp; polarity == "regular")

# run the reading acuity calculation
data_low_vision_RA &lt;- readingAcuity(data_s1, ps, vd, rt, err)

# inspect the newly created dataframe
data_low_vision_RA

#------

# run the reading acuity calculation on the whole dataset grouped by subject and polarity
data_low_vision_RA &lt;- readingAcuity(data_low_vision, ps, vd, rt, err,
                                    subject, polarity)

# inspect the structure of the newly created dataframe
head(data_low_vision_RA, 10)

</code></pre>

<hr>
<h2 id='readingSpeed'>Reading speed calculation corrected for the number of errors</h2><span id='topic+readingSpeed'></span>

<h3>Description</h3>

<p>This function calculates reading speed (in words per minute) for each sentence tested.
This calculation takes into account the number of misread words and gives a more precise reading speed measurement than <code><a href="#topic+readingSpeed_nonCorrected">readingSpeed_nonCorrected</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readingSpeed(data, reading_time, errors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readingSpeed_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="readingSpeed_+3A_reading_time">reading_time</code></td>
<td>
<p>The variable that contains the reading time for each sentence</p>
</td></tr>
<tr><td><code id="readingSpeed_+3A_errors">errors</code></td>
<td>
<p>The variable that contains the number of errors for each sentence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the original dataframe with an added variable called &quot;reading_speed&quot; that contains reading speed (in words/min) for each sentence tested.
</p>


<h3>Notes</h3>

<p>For general purposes, this method of reading speed calculation should be used preferentially over the less precise <code><a href="#topic+readingSpeed_nonCorrected">readingSpeed_nonCorrected</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readingSpeed_nonCorrected">readingSpeed_nonCorrected</a></code> for reading speed non corrected for errors
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the strucutre of the dataframe
head(data_low_vision, 10)

# run the reading speed calculation
data_low_vision_new &lt;- readingSpeed(data_low_vision, rt, err)

# inspect the structure of the newly created dataframe
head(data_low_vision_new, 10)

</code></pre>

<hr>
<h2 id='readingSpeed_nonCorrected'>Reading speed calculation not corrected for the number of errors</h2><span id='topic+readingSpeed_nonCorrected'></span>

<h3>Description</h3>

<p>This function calculates reading speed (in words per minute) using reading time (in seconds) only.
This calculation provides a simplified value of reading speed, that does not take into account the number of misread words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readingSpeed_nonCorrected(data, reading_time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readingSpeed_nonCorrected_+3A_data">data</code></td>
<td>
<p>The name of your dataframe</p>
</td></tr>
<tr><td><code id="readingSpeed_nonCorrected_+3A_reading_time">reading_time</code></td>
<td>
<p>The variable that contains the reading time for each sentence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the original dataframe with an added variable called &quot;reading_speed_nonCorrected&quot; that contains reading speed (in words/min) for each sentence tested.
</p>


<h3>Notes</h3>

<p>This function gives a less precise reading speed measurement than <code><a href="#topic+readingSpeed">readingSpeed</a></code>.
Unless you know what you are doing, consider using <code><a href="#topic+readingSpeed">readingSpeed</a></code> instead of this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readingSpeed">readingSpeed</a></code> for reading speed corrected for errors
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inspect the strucutre of the dataframe
head(data_low_vision, 10)

# run the reading speed calculation
data_low_vision_new &lt;- readingSpeed_nonCorrected(data_low_vision, rt)

# inspect the structure of the newly created dataframe
head(data_low_vision_new, 10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
