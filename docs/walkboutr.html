<!DOCTYPE html><html><head><title>Help for package walkboutr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {walkboutr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#walkboutr-package'><p>walkboutr: Generate Walk Bouts from GPS and Accelerometry Data</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_date_and_format'><p>Add date and format to activity counts</p></a></li>
<li><a href='#assign_epoch_start_time'><p>Assign Epoch Start Time</p></a></li>
<li><a href='#collate_arguments'><p>Collate Arguments</p>
This function collates user-provided arguments with pre-defined parameters and constants.</a></li>
<li><a href='#constants'><p>List of Constants</p>
<code>non_wearing_min_threshold_epochs</code> Number of consecutive epochs with activity counts of 0 that constitute a non_wearing period.
<code>min_wearing_hours_per_day</code> Minimum number of hours in a day an individual must wear an accelerometer for the day to be considered complete.
<code>min_gps_obs_within_bout</code> Minimum number of GPS observations within a bout for that bout to be considered to have complete GPS data.
<code>min_gps_coverage_ratio</code> Minimum ratio of data points with versus without GPS data for the bout to be considered to have complete GPS data.
<code>dwellbout_radii_quantile</code> Threshold for outliering GPS data points - any data points above the 95th percentile are outliered.
<code>max_dwellbout_radii_ft</code> Maximum radius, in feet, of a bounding circle that would be considered a dwell bout (rather than a potential walk bout).
<code>min_dwellbout_obs</code> Minimum number of observations to consider something a potential dwell bout.
<code>max_walking_cpe</code> Maxiumum CPE value before the accelerometer is considered to be picking up on an activity other than walking.
<code>min_walking_speed_km_h</code> Minimum speed considered walking.
<code>max_walking_speed_km_h</code> Maximum speed considered walking.</a></li>
<li><a href='#evaluate_gps_completeness'><p>Evaluate GPS completeness for each walking bout</p></a></li>
<li><a href='#generate_bout_category'><p>Generate bout categories</p></a></li>
<li><a href='#generate_bout_plot'><p>Generate Bout Plot</p></a></li>
<li><a href='#generate_bout_radius'><p>Generate Bounding Circle Radius for Walking Bouts</p></a></li>
<li><a href='#generate_gps_data'><p>Generate a dataset with date-time, speed, and latitude and longitude of someone moving through space on a walk in Seattle</p></a></li>
<li><a href='#generate_walking_in_seattle_gps_data'><p>Generate GPS data for a walking activity in Seattle, WA</p></a></li>
<li><a href='#identify_bouts'><p>Identify Bouts:</p></a></li>
<li><a href='#identify_complete_days'><p>Identify complete wearing days</p>
This function identifies complete days based on accelerometry data by
calculating the total number of epochs worn per day and comparing it to the
minimum number of wearing epochs per day required to consider a day complete.</a></li>
<li><a href='#identify_non_wearing_periods'><p>Identify non-wearing periods:</p>
This function identifies non-wearing periods in accelerometry data based on a
threshold of consecutive epochs with activity counts of 0.</a></li>
<li><a href='#identify_walk_bouts_in_gps_and_accelerometry_data'><p>Identify walking bouts in GPS and accelerometry data:</p></a></li>
<li><a href='#make_active_period'><p>Generate accelerometry datasets</p></a></li>
<li><a href='#make_full_day_bout'><p>Create activity counts for a full day bout</p></a></li>
<li><a href='#make_full_day_bout_without_metadata'><p>Create activity counts for a full day bout without metadata</p></a></li>
<li><a href='#make_full_walk_bout_df'><p>Create a data frame of walking bouts with GPS data</p></a></li>
<li><a href='#make_inactive_period'><p>Create an inactive period</p></a></li>
<li><a href='#make_non_bout_window'><p>Create a non-bout window</p></a></li>
<li><a href='#make_smallest_bout'><p>Make the smallest bout dataset</p></a></li>
<li><a href='#make_smallest_bout_window'><p>Create the smallest bout window</p></a></li>
<li><a href='#make_smallest_bout_with_largest_inactive_period'><p>Generate a sequence of accelerometer counts representing the smallest bout with the largest inactive period</p></a></li>
<li><a href='#make_smallest_bout_with_smallest_non_wearing_period'><p>Generate the smallest bout with the smallest non-wearing period dataset</p></a></li>
<li><a href='#make_smallest_bout_without_metadata'><p>Create the smallest bout window without metadata</p></a></li>
<li><a href='#make_smallest_complete_day_activity'><p>Generate an activity sequence for a complete day with minimal activity</p></a></li>
<li><a href='#make_smallest_nonwearing_window'><p>Create smallest non-wearing window</p></a></li>
<li><a href='#next_lat_long'><p>Calculate next latitude and longitude based on current location, speed, direction, and time elapsed.</p></a></li>
<li><a href='#outlier_gps_points'><p>Outlier GPS data points</p>
This function identifies outlier GPS points for the bout radius calculation from a given set of latitude and longitude coordinates.</a></li>
<li><a href='#parameters'><p>Global parameters and constants</p></a></li>
<li><a href='#process_accelerometry_counts_into_bouts'><p>Process Accelerometry Counts into Bouts</p></a></li>
<li><a href='#process_bouts_and_gps_epochs_into_walkbouts'><p>Process bouts and GPS epochs into walk bouts</p></a></li>
<li><a href='#process_gps_data_into_gps_epochs'><p>Convert GPS data into GPS epochs</p></a></li>
<li><a href='#run_length_encode'><p>Run Length Encoding:</p></a></li>
<li><a href='#summarize_walk_bouts'><p>Summarize walking bouts:</p>
This function summarizes walking bouts and calculates the median speed, complete day, non-wearing, bout start, and duration of each bout.</a></li>
<li><a href='#validate_accelerometry_data'><p>Validate accelerometry input data</p></a></li>
<li><a href='#validate_gps_data'><p>Validate GPS data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generate Walk Bouts from GPS and Accelerometry Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Process GPS and accelerometry data to generate walk bouts. A walk bout is a period of activity with accelerometer movement matching the patterns of walking with corresponding GPS measurements that confirm travel. The inputs of the 'walkboutr' package are individual-level accelerometry and GPS data. The outputs of the model are walk bouts with corresponding times, duration, and summary statistics on the sample population, which collapse all personally identifying information. These bouts can be used to measure walking both as an outcome of a change to the built environment or as a predictor of health outcomes such as a cardioprotective behavior. Kang B, Moudon AV, Hurvitz PM, Saelens BE (2017) &lt;<a href="https://doi.org/10.1016%2Fj.trd.2017.09.026">doi:10.1016/j.trd.2017.09.026</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rwalkbout/walkboutr">https://github.com/rwalkbout/walkboutr</a>,
<a href="https://rwalkbout.github.io/walkboutr/">https://rwalkbout.github.io/walkboutr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rwalkbout/walkboutr/issues">https://github.com/rwalkbout/walkboutr/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, dplyr, geosphere, ggforce, ggplot2, lubridate,
lwgeom, magrittr, measurements, sf, sp, stats, tidyr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, tinytest, utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 23:56:40 UTC; laurenwilner</td>
</tr>
<tr>
<td>Author:</td>
<td>Lauren Blair Wilner
    <a href="https://orcid.org/0000-0003-4439-3734"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Stephen J Mooney [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lauren Blair Wilner &lt;wilnerl@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='walkboutr-package'>walkboutr: Generate Walk Bouts from GPS and Accelerometry Data</h2><span id='topic+walkboutr'></span><span id='topic+walkboutr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Process GPS and accelerometry data to generate walk bouts. A walk bout is a period of activity with accelerometer movement matching the patterns of walking with corresponding GPS measurements that confirm travel. The inputs of the 'walkboutr' package are individual-level accelerometry and GPS data. The outputs of the model are walk bouts with corresponding times, duration, and summary statistics on the sample population, which collapse all personally identifying information. These bouts can be used to measure walking both as an outcome of a change to the built environment or as a predictor of health outcomes such as a cardioprotective behavior. Kang B, Moudon AV, Hurvitz PM, Saelens BE (2017) <a href="https://doi.org/10.1016/j.trd.2017.09.026">doi:10.1016/j.trd.2017.09.026</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lauren Blair Wilner <a href="mailto:wilnerl@uw.edu">wilnerl@uw.edu</a> (<a href="https://orcid.org/0000-0003-4439-3734">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Stephen J Mooney <a href="mailto:sjm2186@uw.edu">sjm2186@uw.edu</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/rwalkbout/walkboutr">https://github.com/rwalkbout/walkboutr</a>
</p>
</li>
<li> <p><a href="https://rwalkbout.github.io/walkboutr/">https://rwalkbout.github.io/walkboutr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rwalkbout/walkboutr/issues">https://github.com/rwalkbout/walkboutr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_date_and_format'>Add date and format to activity counts</h2><span id='topic+add_date_and_format'></span>

<h3>Description</h3>

<p>This function takes a data frame of activity counts and adds a column of time stamps in POSIXct format.
The time stamps start at &quot;2012-04-07 00:00:30&quot; and increase by 30 seconds for each row of the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_date_and_format(counts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_date_and_format_+3A_counts">counts</code></td>
<td>
<p>a data frame containing activity counts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with time stamps added in POSIXct format
</p>

<hr>
<h2 id='assign_epoch_start_time'>Assign Epoch Start Time</h2><span id='topic+assign_epoch_start_time'></span>

<h3>Description</h3>

<p>Assign Epoch Start Time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_epoch_start_time(gps_data, epoch_length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_epoch_start_time_+3A_gps_data">gps_data</code></td>
<td>
<p>A data frame with GPS data including a column of timestamps and columns for latitude and longitude</p>
</td></tr>
<tr><td><code id="assign_epoch_start_time_+3A_epoch_length">epoch_length</code></td>
<td>
<p>The duration of an epoch in seconds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selects the closest 30 second increment to assign epoch start time and takes the GPS coordinates associated with the latest time if there are multiple GPS data points in a given 30 second increment. This function returns a data frame of GPS data with a column of epoch times.
</p>


<h3>Value</h3>

<p>A data frame of GPS data with an additional column indicating epoch start time
</p>

<hr>
<h2 id='collate_arguments'>Collate Arguments
This function collates user-provided arguments with pre-defined parameters and constants.</h2><span id='topic+collate_arguments'></span>

<h3>Description</h3>

<p>Collate Arguments
This function collates user-provided arguments with pre-defined parameters and constants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collate_arguments(..., collated_arguments = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collate_arguments_+3A_...">...</code></td>
<td>
<p>named arguments passed by the user</p>
</td></tr>
<tr><td><code id="collate_arguments_+3A_collated_arguments">collated_arguments</code></td>
<td>
<p>NULL or previously collated arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of all arguments, including both pre-defined parameters and constants and any user-provided arguments.
</p>

<hr>
<h2 id='constants'>List of Constants
<code>non_wearing_min_threshold_epochs</code> Number of consecutive epochs with activity counts of 0 that constitute a non_wearing period.
<code>min_wearing_hours_per_day</code> Minimum number of hours in a day an individual must wear an accelerometer for the day to be considered complete.
<code>min_gps_obs_within_bout</code> Minimum number of GPS observations within a bout for that bout to be considered to have complete GPS data.
<code>min_gps_coverage_ratio</code> Minimum ratio of data points with versus without GPS data for the bout to be considered to have complete GPS data.
<code>dwellbout_radii_quantile</code> Threshold for outliering GPS data points - any data points above the 95th percentile are outliered.
<code>max_dwellbout_radii_ft</code> Maximum radius, in feet, of a bounding circle that would be considered a dwell bout (rather than a potential walk bout).
<code>min_dwellbout_obs</code> Minimum number of observations to consider something a potential dwell bout.
<code>max_walking_cpe</code> Maxiumum CPE value before the accelerometer is considered to be picking up on an activity other than walking.
<code>min_walking_speed_km_h</code> Minimum speed considered walking.
<code>max_walking_speed_km_h</code> Maximum speed considered walking.</h2><span id='topic+constants'></span>

<h3>Description</h3>

<p>List of Constants
<code>non_wearing_min_threshold_epochs</code> Number of consecutive epochs with activity counts of 0 that constitute a non_wearing period.
<code>min_wearing_hours_per_day</code> Minimum number of hours in a day an individual must wear an accelerometer for the day to be considered complete.
<code>min_gps_obs_within_bout</code> Minimum number of GPS observations within a bout for that bout to be considered to have complete GPS data.
<code>min_gps_coverage_ratio</code> Minimum ratio of data points with versus without GPS data for the bout to be considered to have complete GPS data.
<code>dwellbout_radii_quantile</code> Threshold for outliering GPS data points - any data points above the 95th percentile are outliered.
<code>max_dwellbout_radii_ft</code> Maximum radius, in feet, of a bounding circle that would be considered a dwell bout (rather than a potential walk bout).
<code>min_dwellbout_obs</code> Minimum number of observations to consider something a potential dwell bout.
<code>max_walking_cpe</code> Maxiumum CPE value before the accelerometer is considered to be picking up on an activity other than walking.
<code>min_walking_speed_km_h</code> Minimum speed considered walking.
<code>max_walking_speed_km_h</code> Maximum speed considered walking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constants
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 10.
</p>

<hr>
<h2 id='evaluate_gps_completeness'>Evaluate GPS completeness for each walking bout</h2><span id='topic+evaluate_gps_completeness'></span>

<h3>Description</h3>

<p>This function evaluates the completeness of GPS data for each walking bout. For each bout, it checks if the number of valid GPS records (with speed, latitude, and longitude data) is greater than a specified threshold, and if the ratio of valid GPS records to total records is greater than a specified minimum. If both of these conditions are met, the function considers the GPS data for the bout to be complete. The function also calculates the median speed for each bout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_gps_completeness(
  walk_bouts,
  min_gps_obs_within_bout,
  min_gps_coverage_ratio
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_gps_completeness_+3A_walk_bouts">walk_bouts</code></td>
<td>
<p>A data frame containing information about walking bouts, including GPS data.</p>
</td></tr>
<tr><td><code id="evaluate_gps_completeness_+3A_min_gps_obs_within_bout">min_gps_obs_within_bout</code></td>
<td>
<p>The minimum number of GPS observations required for a bout to be considered to have complete GPS data.</p>
</td></tr>
<tr><td><code id="evaluate_gps_completeness_+3A_min_gps_coverage_ratio">min_gps_coverage_ratio</code></td>
<td>
<p>The minimum ratio of GPS observations with valid data to total GPS observations for a bout to be considered to have complete GPS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing information about the GPS completeness and median speed for each bout.
</p>

<hr>
<h2 id='generate_bout_category'>Generate bout categories</h2><span id='topic+generate_bout_category'></span>

<h3>Description</h3>

<p>Given accelerometer bout data, this function generates bout categories, which includes dwell bouts, non-walk bouts that are either too slow, too fast, or too vigorous, and bouts with an unknown lack of GPS data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_bout_category(
  walk_bouts,
  bout_radii,
  gps_completeness,
  max_dwellbout_radii_ft,
  max_walking_cpe,
  min_walking_speed_km_h,
  max_walking_speed_km_h
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_bout_category_+3A_walk_bouts">walk_bouts</code></td>
<td>
<p>a data frame that contains bout information for walking bouts.</p>
</td></tr>
<tr><td><code id="generate_bout_category_+3A_bout_radii">bout_radii</code></td>
<td>
<p>a data frame that contains bout radii information.</p>
</td></tr>
<tr><td><code id="generate_bout_category_+3A_gps_completeness">gps_completeness</code></td>
<td>
<p>a data frame that contains GPS data completeness information.</p>
</td></tr>
<tr><td><code id="generate_bout_category_+3A_max_dwellbout_radii_ft">max_dwellbout_radii_ft</code></td>
<td>
<p>a numeric scalar that specifies the maximum radius, in feet, of a bounding circle that would be considered a dwell bout.</p>
</td></tr>
<tr><td><code id="generate_bout_category_+3A_max_walking_cpe">max_walking_cpe</code></td>
<td>
<p>a numeric scalar that specifies the maximum activity counts per epoch value before the accelerometer is considered to be picking up on an activity other than walking.</p>
</td></tr>
<tr><td><code id="generate_bout_category_+3A_min_walking_speed_km_h">min_walking_speed_km_h</code></td>
<td>
<p>a numeric scalar that specifies the minimum speed considered walking.</p>
</td></tr>
<tr><td><code id="generate_bout_category_+3A_max_walking_speed_km_h">max_walking_speed_km_h</code></td>
<td>
<p>a numeric scalar that specifies the maximum speed considered walking.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the bout information for walking bouts, bout radii information, and GPS data completeness information to generate the bout categories.
</p>
<p>The function first generates dwell bouts by joining the bout radii information and GPS data completeness information on the bout column, and then filters out the rows that have bout values that are missing using the filter function. Then, it calculates the dwell bout values as TRUE if the complete_gps column is TRUE and the bout_radius column is less than max_dwellbout_radii_ft. The resulting data frame only contains the bout and dwell_bout columns.
The function then joins the resulting data frame with the walking bout data frame using the bout column. Then, for the non-walk bouts, the function calculates whether they are too vigorous, too slow, or too fast. For the non-walk bouts that are too vigorous, the function calculates the mean activity_counts for each bout, and then sets the non_walk_too_vigorous value as TRUE if the mean activity_counts value is greater than max_walking_cpe. For the non-walk bouts that are too slow or too fast, the function calculates the median speed for each bout, and then sets the non_walk_slow or non_walk_fast value as TRUE if the median speed value is less than min_walking_speed_km_h or greater than max_walking_speed_km_h, respectively. Finally, the function generates a non_walk_incomplete_gps value as TRUE if the complete_gps value is FALSE for the bout.
The resulting data frame contains the following columns: bout, dwell_bout (T/F), non_walk_too_vigorous (T/F), non_walk_slow (T/F), non_walk_fast (T/F), non_walk_incomplete_gps (T/F).
</p>


<h3>Value</h3>

<p>a data frame with the following columns: bout, dwell_bout (T/F), non_walk_too_vigorous (T/F), non_walk_slow (T/F), non_walk_fast (T/F), non_walk_incomplete_gps (T/F)
</p>

<hr>
<h2 id='generate_bout_plot'>Generate Bout Plot</h2><span id='topic+generate_bout_plot'></span>

<h3>Description</h3>

<p>This function generates a plot of accelerometry counts and GPS radius for a specific bout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_bout_plot(
  accelerometry_counts,
  gps_data,
  bout_number,
  leading_minutes = 8,
  trailing_minutes = 12,
  gps_target_size = 0.25,
  ...,
  collated_arguments = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_bout_plot_+3A_accelerometry_counts">accelerometry_counts</code></td>
<td>
<p>A data frame or tibble containing accelerometry counts.</p>
</td></tr>
<tr><td><code id="generate_bout_plot_+3A_gps_data">gps_data</code></td>
<td>
<p>A data frame or tibble containing GPS data.</p>
</td></tr>
<tr><td><code id="generate_bout_plot_+3A_bout_number">bout_number</code></td>
<td>
<p>The number of the bout to be plotted.</p>
</td></tr>
<tr><td><code id="generate_bout_plot_+3A_leading_minutes">leading_minutes</code></td>
<td>
<p>number of minutes before a bout starts that we want to plot</p>
</td></tr>
<tr><td><code id="generate_bout_plot_+3A_trailing_minutes">trailing_minutes</code></td>
<td>
<p>number of minutes after a bout ends that we want to plot</p>
</td></tr>
<tr><td><code id="generate_bout_plot_+3A_gps_target_size">gps_target_size</code></td>
<td>
<p>proportional size of circle plot</p>
</td></tr>
<tr><td><code id="generate_bout_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
<tr><td><code id="generate_bout_plot_+3A_collated_arguments">collated_arguments</code></td>
<td>
<p>A list of collated arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object representing the bout plot.
</p>

<hr>
<h2 id='generate_bout_radius'>Generate Bounding Circle Radius for Walking Bouts</h2><span id='topic+generate_bout_radius'></span>

<h3>Description</h3>

<p>This function generates a bounding circle radius for each walking bout identified in the input data. The bounding circle is defined as the smallest circle that fully contains all GPS locations observed during a walking bout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_bout_radius(walk_bouts, dwellbout_radii_quantile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_bout_radius_+3A_walk_bouts">walk_bouts</code></td>
<td>
<p>A data frame containing GPS locations for each walking bout, with columns &quot;longitude&quot;, &quot;latitude&quot;, and &quot;bout&quot; (a unique identifier for each bout)</p>
</td></tr>
<tr><td><code id="generate_bout_radius_+3A_dwellbout_radii_quantile">dwellbout_radii_quantile</code></td>
<td>
<p>A quantile (between 0 and 1) used to filter outlying GPS data points before generating the bounding circle. GPS points with a distance from the center greater than the radius of the circle that contains (1 - dwellbout_radii_quantile) of the GPS points are considered outliers and are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the bout identifier and the radius of the bounding circle for each walking bout.
</p>

<hr>
<h2 id='generate_gps_data'>Generate a dataset with date-time, speed, and latitude and longitude of someone moving through space on a walk in Seattle</h2><span id='topic+generate_gps_data'></span>

<h3>Description</h3>

<p>Generate a dataset with date-time, speed, and latitude and longitude of someone moving through space on a walk in Seattle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_gps_data(
  start_lat,
  start_long,
  start_time,
  n_epochs = 110,
  time_interval = 30,
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_gps_data_+3A_start_lat">start_lat</code></td>
<td>
<p>The starting latitude of the walk.</p>
</td></tr>
<tr><td><code id="generate_gps_data_+3A_start_long">start_long</code></td>
<td>
<p>The starting longitude of the walk.</p>
</td></tr>
<tr><td><code id="generate_gps_data_+3A_start_time">start_time</code></td>
<td>
<p>The start time of a series of data</p>
</td></tr>
<tr><td><code id="generate_gps_data_+3A_n_epochs">n_epochs</code></td>
<td>
<p>The number of epochs in the series</p>
</td></tr>
<tr><td><code id="generate_gps_data_+3A_time_interval">time_interval</code></td>
<td>
<p>The time interval between points in seconds.</p>
</td></tr>
<tr><td><code id="generate_gps_data_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with four columns: &quot;timestamp&quot;, &quot;lat&quot;, &quot;lon&quot;, and &quot;speed&quot;.
</p>

<hr>
<h2 id='generate_walking_in_seattle_gps_data'>Generate GPS data for a walking activity in Seattle, WA</h2><span id='topic+generate_walking_in_seattle_gps_data'></span>

<h3>Description</h3>

<p>This function generates a data frame containing GPS data for a walking activity in Seattle, WA on April 7th, 2012. It calls the function generate_gps_data to create a series of GPS locations and speeds. The resulting data frame has columns for time, latitude, longitude, and speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_walking_in_seattle_gps_data(start_lat, start_long, start_time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_walking_in_seattle_gps_data_+3A_start_lat">start_lat</code></td>
<td>
<p>The starting latitude of the walk.</p>
</td></tr>
<tr><td><code id="generate_walking_in_seattle_gps_data_+3A_start_long">start_long</code></td>
<td>
<p>The starting longitude of the walk.</p>
</td></tr>
<tr><td><code id="generate_walking_in_seattle_gps_data_+3A_start_time">start_time</code></td>
<td>
<p>The start time of a series of data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>time</code>, <code>latitude</code>, <code>longitude</code>, <code>speed</code>
</p>

<hr>
<h2 id='identify_bouts'>Identify Bouts:</h2><span id='topic+identify_bouts'></span>

<h3>Description</h3>

<p>Identify Bouts:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_bouts(
  accelerometry_counts,
  maximum_number_consec_inactive_epochs_in_bout,
  active_counts_per_epoch_min,
  minimum_bout_length
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_bouts_+3A_accelerometry_counts">accelerometry_counts</code></td>
<td>
<p>A data frame containing accelerometry counts and times</p>
</td></tr>
<tr><td><code id="identify_bouts_+3A_maximum_number_consec_inactive_epochs_in_bout">maximum_number_consec_inactive_epochs_in_bout</code></td>
<td>
<p>Maximum number of consecutive inactive epochs in a bout without ending the bout</p>
</td></tr>
<tr><td><code id="identify_bouts_+3A_active_counts_per_epoch_min">active_counts_per_epoch_min</code></td>
<td>
<p>Minimum accelerometer counts for an epoch to be considered active (vs. inactive)</p>
</td></tr>
<tr><td><code id="identify_bouts_+3A_minimum_bout_length">minimum_bout_length</code></td>
<td>
<p>Minimum number of epochs for a period of activity to be considered as a potential bout</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function partitions the accelerometry data into bouts of activity and non-bouts by
first identifying all epochs that are definitely not part of bouts. Then, it uses run length encoding to
partition the data into potential bouts and non-bouts, and labels each potential bout as a bout or non-bout
based on whether it meets the criteria for bout length and the number of consecutive inactive epochs allowed.
Finally, the function adds a new column to the input data frame <code>accelerometry_counts</code> named <code>bout</code>
that indicates whether each epoch is part of a bout (1) or not (0).
</p>


<h3>Value</h3>

<p>A data frame with the same columns as the input data frame <code>accelerometry_counts</code>,
but with a new column named <code>bout</code> that indicates whether each epoch is part of a bout
(in which case it gets a bout number assigned) or not (0)
</p>

<hr>
<h2 id='identify_complete_days'>Identify complete wearing days
This function identifies complete days based on accelerometry data by
calculating the total number of epochs worn per day and comparing it to the
minimum number of wearing epochs per day required to consider a day complete.</h2><span id='topic+identify_complete_days'></span>

<h3>Description</h3>

<p>Identify complete wearing days
This function identifies complete days based on accelerometry data by
calculating the total number of epochs worn per day and comparing it to the
minimum number of wearing epochs per day required to consider a day complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_complete_days(
  accelerometry_counts,
  min_wearing_hours_per_day,
  epoch_length,
  local_time_zone
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_complete_days_+3A_accelerometry_counts">accelerometry_counts</code></td>
<td>
<p>A data frame containing accelerometry counts and non-wearing epochs.</p>
</td></tr>
<tr><td><code id="identify_complete_days_+3A_min_wearing_hours_per_day">min_wearing_hours_per_day</code></td>
<td>
<p>Minimum number of hours of wearing time required for a day to be considered complete.</p>
</td></tr>
<tr><td><code id="identify_complete_days_+3A_epoch_length">epoch_length</code></td>
<td>
<p>The duration of an epoch in seconds.</p>
</td></tr>
<tr><td><code id="identify_complete_days_+3A_local_time_zone">local_time_zone</code></td>
<td>
<p>The local time zone of the data. The data come in and are returned in UTC, but the local time zone is used to compute complete_days.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing accelerometer counts, non-wearing epochs, and a binary variable indicating if the day is complete or not.
</p>

<hr>
<h2 id='identify_non_wearing_periods'>Identify non-wearing periods:
This function identifies non-wearing periods in accelerometry data based on a
threshold of consecutive epochs with activity counts of 0.</h2><span id='topic+identify_non_wearing_periods'></span>

<h3>Description</h3>

<p>Identify non-wearing periods:
This function identifies non-wearing periods in accelerometry data based on a
threshold of consecutive epochs with activity counts of 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_non_wearing_periods(
  accelerometry_counts,
  non_wearing_min_threshold_epochs
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_non_wearing_periods_+3A_accelerometry_counts">accelerometry_counts</code></td>
<td>
<p>a data frame containing columns for time
(in POSIXct format) and activity_counts</p>
</td></tr>
<tr><td><code id="identify_non_wearing_periods_+3A_non_wearing_min_threshold_epochs">non_wearing_min_threshold_epochs</code></td>
<td>
<p>an integer value indicating the
minimum number of consecutive epochs with 0 activity counts that constitute a non-wearing period</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Identify periods where the accelerometer is not being worn based on the activity counts and a minimum threshold value.
</p>


<h3>Value</h3>

<p>a data frame with the same columns as the input data frame <code>accelerometry_counts</code>,
but with a new column named <code>non_wearing</code> that indicates whether the
individual was wearing their accelerometer during a given period.
</p>

<hr>
<h2 id='identify_walk_bouts_in_gps_and_accelerometry_data'>Identify walking bouts in GPS and accelerometry data:</h2><span id='topic+identify_walk_bouts_in_gps_and_accelerometry_data'></span>

<h3>Description</h3>

<p>This function identifies walking bouts in GPS and accelerometry data.
It processes the GPS data and accelerometry counts to create walk bouts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_walk_bouts_in_gps_and_accelerometry_data(
  gps_data,
  accelerometry_counts,
  ...,
  collated_arguments = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_walk_bouts_in_gps_and_accelerometry_data_+3A_gps_data">gps_data</code></td>
<td>
<p>A data frame containing GPS data</p>
</td></tr>
<tr><td><code id="identify_walk_bouts_in_gps_and_accelerometry_data_+3A_accelerometry_counts">accelerometry_counts</code></td>
<td>
<p>A data frame containing accelerometry counts</p>
</td></tr>
<tr><td><code id="identify_walk_bouts_in_gps_and_accelerometry_data_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
<tr><td><code id="identify_walk_bouts_in_gps_and_accelerometry_data_+3A_collated_arguments">collated_arguments</code></td>
<td>
<p>A list of collated arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing identified walk bouts
</p>

<hr>
<h2 id='make_active_period'>Generate accelerometry datasets</h2><span id='topic+make_active_period'></span>

<h3>Description</h3>

<p>This function generates a list of activity epochs with specified minimum active counts per epoch, minimum bout length,
maximum number of consecutive inactive epochs in a bout, minimum non-wearing length, and minimum complete day length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_active_period(
  length = 1,
  is_bout = TRUE,
  non_wearing = FALSE,
  complete_day = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_active_period_+3A_length">length</code></td>
<td>
<p>Length of the active period</p>
</td></tr>
<tr><td><code id="make_active_period_+3A_is_bout">is_bout</code></td>
<td>
<p>Logical indicating if the active period is a bout</p>
</td></tr>
<tr><td><code id="make_active_period_+3A_non_wearing">non_wearing</code></td>
<td>
<p>Logical indicating if the active period is a non-wearing period</p>
</td></tr>
<tr><td><code id="make_active_period_+3A_complete_day">complete_day</code></td>
<td>
<p>Logical indicating if the active period is a complete day</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of activity epochs
</p>

<hr>
<h2 id='make_full_day_bout'>Create activity counts for a full day bout</h2><span id='topic+make_full_day_bout'></span>

<h3>Description</h3>

<p>This function creates a data frame with activity counts for a full day bout. A full day bout is defined as an uninterrupted period of activity with a length of at least <code>min_complete_day</code>. The function calls the <code>make_non_bout_window()</code>, <code>make_smallest_bout_window()</code>, and <code>make_smallest_complete_day_activity()</code> functions to generate the activity counts for the non-bout window, smallest bout window, and smallest complete day activity, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_full_day_bout()
</code></pre>


<h3>Value</h3>

<p>A data frame with activity counts for a full day bout
</p>

<hr>
<h2 id='make_full_day_bout_without_metadata'>Create activity counts for a full day bout without metadata</h2><span id='topic+make_full_day_bout_without_metadata'></span>

<h3>Description</h3>

<p>This function creates a data frame with activity counts for a full day bout. A full day bout is defined as an uninterrupted period of activity with a length of at least <code>min_complete_day</code>. The function calls the <code>make_non_bout_window()</code>, <code>make_smallest_bout_window()</code>, and <code>make_smallest_complete_day_activity()</code> functions to generate the activity counts for the non-bout window, smallest bout window, and smallest complete day activity, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_full_day_bout_without_metadata()
</code></pre>


<h3>Value</h3>

<p>A data frame with activity counts for a full day bout without metadata
</p>

<hr>
<h2 id='make_full_walk_bout_df'>Create a data frame of walking bouts with GPS data</h2><span id='topic+make_full_walk_bout_df'></span>

<h3>Description</h3>

<p>This function combines accelerometer and GPS data to create a data frame of walking bouts.
It generates a full day of activity with bouts of minimum and non-bout periods, and GPS data for walking in Seattle.
The accelerometer data is processed into bouts using the <code><a href="#topic+process_accelerometry_counts_into_bouts">process_accelerometry_counts_into_bouts</a></code> function.
The GPS data is processed into epochs using the <code><a href="#topic+process_gps_data_into_gps_epochs">process_gps_data_into_gps_epochs</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_full_walk_bout_df()
</code></pre>


<h3>Value</h3>

<p>A data frame of walking bouts with GPS data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_full_walk_bout_df()
</code></pre>

<hr>
<h2 id='make_inactive_period'>Create an inactive period</h2><span id='topic+make_inactive_period'></span>

<h3>Description</h3>

<p>This function creates an inactive period with a given length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_inactive_period(
  length = 1,
  is_bout = FALSE,
  non_wearing = FALSE,
  complete_day = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_inactive_period_+3A_length">length</code></td>
<td>
<p>The length of the inactive period.</p>
</td></tr>
<tr><td><code id="make_inactive_period_+3A_is_bout">is_bout</code></td>
<td>
<p>Logical value indicating whether this period is part of a bout of inactivity.</p>
</td></tr>
<tr><td><code id="make_inactive_period_+3A_non_wearing">non_wearing</code></td>
<td>
<p>Logical value indicating whether this period is due to non-wearing of the accelerometer.</p>
</td></tr>
<tr><td><code id="make_inactive_period_+3A_complete_day">complete_day</code></td>
<td>
<p>Logical value indicating whether this period occurs during a complete day of wearing the accelerometer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns activity_counts, bout, non_wearing, and complete_day, where activity_counts is set to 0 for the entire length, and bout, non_wearing, and complete_day are set according to the input values.
</p>

<hr>
<h2 id='make_non_bout_window'>Create a non-bout window</h2><span id='topic+make_non_bout_window'></span>

<h3>Description</h3>

<p>This function creates a non-bout window, which is a period of inactivity that is not long enough to be considered as an inactive bout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_non_bout_window(maximum_number_consec_inactive_epochs_in_bout = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_non_bout_window_+3A_maximum_number_consec_inactive_epochs_in_bout">maximum_number_consec_inactive_epochs_in_bout</code></td>
<td>
<p>maximum number of consecutive inactive epochs in a bout before it is terminated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with columns &quot;activity_counts&quot;, &quot;bout&quot;, &quot;non_wearing&quot;, &quot;complete_day&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_non_bout_window()

</code></pre>

<hr>
<h2 id='make_smallest_bout'>Make the smallest bout dataset</h2><span id='topic+make_smallest_bout'></span>

<h3>Description</h3>

<p>Generates a dataset representing the smallest bout, consisting of a sequence of inactive periods followed by the smallest active period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_smallest_bout()
</code></pre>


<h3>Value</h3>

<p>A data frame containing the activity counts and bout information for the smallest bout.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_smallest_bout()
</code></pre>

<hr>
<h2 id='make_smallest_bout_window'>Create the smallest bout window</h2><span id='topic+make_smallest_bout_window'></span>

<h3>Description</h3>

<p>This function creates an active period of minimum length defined by the parameter <code>minimum_bout_length</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_smallest_bout_window(
  minimum_bout_length = 10,
  is_bout = TRUE,
  non_wearing = FALSE,
  complete_day = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_smallest_bout_window_+3A_minimum_bout_length">minimum_bout_length</code></td>
<td>
<p>is the minimum number of epochs for something to be considered a bout</p>
</td></tr>
<tr><td><code id="make_smallest_bout_window_+3A_is_bout">is_bout</code></td>
<td>
<p>Logical indicating if the active period is a bout</p>
</td></tr>
<tr><td><code id="make_smallest_bout_window_+3A_non_wearing">non_wearing</code></td>
<td>
<p>Logical indicating if the active period is a non-wearing period</p>
</td></tr>
<tr><td><code id="make_smallest_bout_window_+3A_complete_day">complete_day</code></td>
<td>
<p>Logical indicating if the active period is a complete day</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns <code>activity_counts</code>, <code>bout</code>, <code>non_wearing</code>, and <code>complete_day</code> representing the smallest bout window.
</p>

<hr>
<h2 id='make_smallest_bout_with_largest_inactive_period'>Generate a sequence of accelerometer counts representing the smallest bout with the largest inactive period</h2><span id='topic+make_smallest_bout_with_largest_inactive_period'></span>

<h3>Description</h3>

<p>This function generates a sequence of accelerometer counts representing the smallest bout with the largest inactive period.
The length of the inactive period is determined by the value of <code>maximum_number_consec_inactive_epochs_in_bout</code> variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_smallest_bout_with_largest_inactive_period(
  maximum_number_consec_inactive_epochs_in_bout = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_smallest_bout_with_largest_inactive_period_+3A_maximum_number_consec_inactive_epochs_in_bout">maximum_number_consec_inactive_epochs_in_bout</code></td>
<td>
<p>maximum number of consecutive inactive epochs in a bout before it is terminated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>activity_counts</code> and <code>time</code>, representing the accelerometer counts and the corresponding time stamps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_smallest_bout_with_largest_inactive_period()
</code></pre>

<hr>
<h2 id='make_smallest_bout_with_smallest_non_wearing_period'>Generate the smallest bout with the smallest non-wearing period dataset</h2><span id='topic+make_smallest_bout_with_smallest_non_wearing_period'></span>

<h3>Description</h3>

<p>This function creates a dataset consisting of the smallest bout and the smallest non-wearing period. The bout length, non-wearing period length, and epoch length are defined in the global variables: minimum_bout_length, maximum_number_consec_inactive_epochs_in_bout, and min_non_wearing_length, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_smallest_bout_with_smallest_non_wearing_period()
</code></pre>


<h3>Value</h3>

<p>A data frame with columns for activity counts and date-time stamps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_smallest_bout_with_smallest_non_wearing_period()
</code></pre>

<hr>
<h2 id='make_smallest_bout_without_metadata'>Create the smallest bout window without metadata</h2><span id='topic+make_smallest_bout_without_metadata'></span>

<h3>Description</h3>

<p>This function creates the smallest bout window without the metadata columns. It calls the <code><a href="#topic+make_smallest_bout">make_smallest_bout</a></code> function and then removes the columns &quot;non_wearing&quot;, &quot;complete_day&quot;, and &quot;bout&quot; using <code>dplyr::select</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_smallest_bout_without_metadata()
</code></pre>


<h3>Value</h3>

<p>A data frame containing the smallest bout window without metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_smallest_bout_without_metadata()
</code></pre>

<hr>
<h2 id='make_smallest_complete_day_activity'>Generate an activity sequence for a complete day with minimal activity</h2><span id='topic+make_smallest_complete_day_activity'></span>

<h3>Description</h3>

<p>This function generates an activity sequence for a complete day with a minimal activity count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_smallest_complete_day_activity(min_complete_day = 8602)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_smallest_complete_day_activity_+3A_min_complete_day">min_complete_day</code></td>
<td>
<p>minimum number of epochs for something to be a complete day</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An activity sequence data frame with minimum activity counts for a complete day.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_smallest_complete_day_activity()

</code></pre>

<hr>
<h2 id='make_smallest_nonwearing_window'>Create smallest non-wearing window</h2><span id='topic+make_smallest_nonwearing_window'></span>

<h3>Description</h3>

<p>Create an inactive period that represents the smallest non-wearing window.
This function uses the <code>make_inactive_period()</code> function to create the non-wearing window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_smallest_nonwearing_window(min_non_wearing_length = 20 * 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_smallest_nonwearing_window_+3A_min_non_wearing_length">min_non_wearing_length</code></td>
<td>
<p>minimum non_wearing time before a bout is terminated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An inactive period data frame that represents the smallest non-wearing window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_smallest_nonwearing_window()
</code></pre>

<hr>
<h2 id='next_lat_long'>Calculate next latitude and longitude based on current location, speed, direction, and time elapsed.</h2><span id='topic+next_lat_long'></span>

<h3>Description</h3>

<p>Given a current location (latitude and longitude), speed, direction (in radians), and time elapsed (in seconds),
this function calculates the next latitude and longitude. The calculations are based on the assumption of a constant
speed and direction during the elapsed time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_lat_long(latitude, longitude, speed, direction, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next_lat_long_+3A_latitude">latitude</code></td>
<td>
<p>The current latitude in decimal degrees.</p>
</td></tr>
<tr><td><code id="next_lat_long_+3A_longitude">longitude</code></td>
<td>
<p>The current longitude in decimal degrees.</p>
</td></tr>
<tr><td><code id="next_lat_long_+3A_speed">speed</code></td>
<td>
<p>The speed in kilometers per hour.</p>
</td></tr>
<tr><td><code id="next_lat_long_+3A_direction">direction</code></td>
<td>
<p>The direction of movement in radians from due north (0 radians).</p>
</td></tr>
<tr><td><code id="next_lat_long_+3A_dt">dt</code></td>
<td>
<p>The elapsed time in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2 containing the next latitude and longitude in decimal degrees.
</p>

<hr>
<h2 id='outlier_gps_points'>Outlier GPS data points
This function identifies outlier GPS points for the bout radius calculation from a given set of latitude and longitude coordinates.</h2><span id='topic+outlier_gps_points'></span>

<h3>Description</h3>

<p>Outlier GPS data points
This function identifies outlier GPS points for the bout radius calculation from a given set of latitude and longitude coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier_gps_points(lat_long, dwellbout_radii_quantile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlier_gps_points_+3A_lat_long">lat_long</code></td>
<td>
<p>A data frame containing the latitude and longitude coordinates for the GPS points.</p>
</td></tr>
<tr><td><code id="outlier_gps_points_+3A_dwellbout_radii_quantile">dwellbout_radii_quantile</code></td>
<td>
<p>The threshold for outliering GPS data points - any data points above the specified percentile are outliered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the latitude and longitude coordinates for the non-outlier GPS points.
</p>

<hr>
<h2 id='parameters'>Global parameters and constants</h2><span id='topic+parameters'></span>

<h3>Description</h3>

<p>List of Parameters
<code>epoch_length</code> The duration of an epoch in seconds.
<code>active_counts_per_epoch_min</code> Minimum accelerometer counts for an epoch to be considered active (vs. inactive).
<code>minimum_bout_length</code> Minimum number of epochs for a period of activity to be considered as a potential bout.
<code>local_time_zone</code> Local time zone of the data - data come in and are returned in UTC, but local time zone is used to compute complete_days.
<code>maximum_number_consec_inactive_epochs_in_bout</code> Number of consecutive epochs that can be labeled as inactive during a bout without ending the bout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>

<hr>
<h2 id='process_accelerometry_counts_into_bouts'>Process Accelerometry Counts into Bouts</h2><span id='topic+process_accelerometry_counts_into_bouts'></span>

<h3>Description</h3>

<p>This function processes accelerometry counts into bouts of activity and
returns those bouts as well as flags for whether the individual was wearing
their device and if the wearing day can be considered complete
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_accelerometry_counts_into_bouts(
  accelerometry_counts,
  ...,
  collated_arguments = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_accelerometry_counts_into_bouts_+3A_accelerometry_counts">accelerometry_counts</code></td>
<td>
<p>A data frame with two columns: time and activity counts (CPE, counts per epoch)</p>
</td></tr>
<tr><td><code id="process_accelerometry_counts_into_bouts_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function.</p>
</td></tr>
<tr><td><code id="process_accelerometry_counts_into_bouts_+3A_collated_arguments">collated_arguments</code></td>
<td>
<p>An optional list of previously collated arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input schema for the accelerometry data is <code>time</code> and <code>activity_counts</code>.
</p>

<ul>
<li> <p><code>time</code> should be a column in date-time format, in the UTC time zone, with no null values.
</p>
</li>
<li> <p><code>activity_counts</code> should be a positive numeric column with no null values.
</p>
</li></ul>

<p>This function processes accelerometry counts into bouts of activity.
The function first validates the input data in the first step.
In the second step, the function identifies bouts of activity based on a
specified minimum number of active counts per epoch, a maximum number of
consecutive inactive epochs allowed within a bout, and a minimum bout length.
In the third step, the function identifies non-wearing periods based on a
specified threshold of consecutive epochs with 0 activity counts.
In the fourth step, the function identifies complete days of wearing the
accelerometer based on a specified minimum number of hours of wearing and
the epoch length. The returned list includes information about each complete
day, including the start and end times of each day, the duration of the day
in seconds, the number of epochs, the total number of cpm for the day, and
the bouts of activity within the day.
</p>


<h3>Value</h3>

<p>A list of processed data frames containing identified walk bouts, non-wearing periods,
and complete days, based on the provided accelerometry counts and processing parameters.
</p>

<hr>
<h2 id='process_bouts_and_gps_epochs_into_walkbouts'>Process bouts and GPS epochs into walk bouts</h2><span id='topic+process_bouts_and_gps_epochs_into_walkbouts'></span>

<h3>Description</h3>

<p>This function processes bouts and GPS epochs into walk bouts. It uses a set of parameters and constants to determine whether an epoch is active or inactive, the minimum number of epochs for a period of activity to be considered as a potential bout, the local time zone of the data, and other relevant information. It takes in two data frames, &quot;bouts&quot; and &quot;gps_epochs&quot;, and returns a processed data frame, &quot;walk_bouts&quot;, with added columns &quot;bout&quot;, &quot;bout_radius&quot;, &quot;bout_category&quot;, &quot;complete_days&quot;, &quot;non_wearing&quot;, and &quot;speed&quot;.#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_bouts_and_gps_epochs_into_walkbouts(
  bouts,
  gps_epochs,
  ...,
  collated_arguments = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_bouts_and_gps_epochs_into_walkbouts_+3A_bouts">bouts</code></td>
<td>
<p>a data frame containing bout information</p>
</td></tr>
<tr><td><code id="process_bouts_and_gps_epochs_into_walkbouts_+3A_gps_epochs">gps_epochs</code></td>
<td>
<p>a data frame containing GPS information</p>
</td></tr>
<tr><td><code id="process_bouts_and_gps_epochs_into_walkbouts_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to other functions</p>
</td></tr>
<tr><td><code id="process_bouts_and_gps_epochs_into_walkbouts_+3A_collated_arguments">collated_arguments</code></td>
<td>
<p>a list of arguments collated from other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first collates the arguments passed to it with the collate_arguments() function. It then merges &quot;gps_epochs&quot; and &quot;bouts&quot; data frames by &quot;time&quot; column, and orders the resulting data frame by &quot;time&quot;. Then, it generates the &quot;bout_radius&quot; using the generate_bout_radius() function, which calculates the radius of a bounding circle that would be considered a dwell bout. Next, the function evaluates the completeness of GPS data using the evaluate_gps_completeness() function, which determines the number of GPS observations within a bout and the ratio of data points with versus without GPS data. Finally, the function generates the &quot;bout_category&quot; using the generate_bout_category() function, which determines whether a bout is a walk bout or a dwell bout, and calculates the complete days, non-wearing periods, and speed.
The function categorizes bouts into the following categories:
</p>

<ul>
<li><p> dwell bout
</p>
</li>
<li><p> non-walk too vigorous
</p>
</li>
<li><p> non-walk too slow
</p>
</li>
<li><p> non-walk too fast
</p>
</li>
<li><p> unknown lack of gps
</p>
</li></ul>

<p>NOTE: If there are multiple GPS points associated with a given epoch interval,
we use the latest possible GPS data point within that epoch. As such,
median walking speed is calculated for only the latest available GPS data point in each epoch.
</p>
<p>NOTE: The median speed is calculated using only the GPS data points that remain after
GPS data processing. All GPS data points that are outliered for the calculation of a bout
radius, are, however, included in the assessment of GPS completeness as they are outliers
but are still present GPS data points.
</p>
<p>NOTE: Outliered data points are excluded from the radius calculation but are included in
subsequent functions that assess GPS completeness. They are also returned from
these functions with the original data and all new variables.
</p>


<h3>Value</h3>

<p>a processed data frame, &quot;walk_bouts&quot;, with added columns &quot;bout&quot;, &quot;bout_radius&quot;, &quot;bout_category&quot;, &quot;complete_days&quot;, &quot;non_wearing&quot;, and &quot;speed&quot;#'
</p>

<hr>
<h2 id='process_gps_data_into_gps_epochs'>Convert GPS data into GPS epochs</h2><span id='topic+process_gps_data_into_gps_epochs'></span>

<h3>Description</h3>

<p>The input schema for the accelerometry data is <code>time</code>, <code>latitude</code>, <code>longitude</code>, and <code>speed</code>.
</p>

<ul>
<li> <p><code>time</code> should be a column in date-time format, in the UTC time zone, with no null values.
</p>
</li>
<li> <p><code>latitude</code> should be a numeric, non-null latitude coordinate between -90 and 90
</p>
</li>
<li> <p><code>longitude</code> should be a numeric, non-null longitude coordinate between -180 and 180
</p>
</li>
<li> <p><code>speed</code> should be a numeric, non-null value in kilometers per hour
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>process_gps_data_into_gps_epochs(gps_data, ..., collated_arguments = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_gps_data_into_gps_epochs_+3A_gps_data">gps_data</code></td>
<td>
<p>A data frame containing GPS data. Must have columns &quot;Latitude&quot;, &quot;Longitude&quot;</p>
</td></tr>
<tr><td><code id="process_gps_data_into_gps_epochs_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function.</p>
</td></tr>
<tr><td><code id="process_gps_data_into_gps_epochs_+3A_collated_arguments">collated_arguments</code></td>
<td>
<p>A named list of arguments, used to avoid naming conflicts when calling this function as part of a pipeline. Optional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function processes GPS data into GPS epochs, with each epoch having a duration specified by <code>epoch_length</code>.
</p>


<h3>Value</h3>

<p>A data frame with columns latitude, longitude, time, and speed, where time is now the nearest epoch start time
</p>

<hr>
<h2 id='run_length_encode'>Run Length Encoding:</h2><span id='topic+run_length_encode'></span>

<h3>Description</h3>

<p>A function that runs a normal run length encoding and adds some extra variables for use in calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_length_encode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_length_encode_+3A_x">x</code></td>
<td>
<p>a vector to run the function on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with columns for lengths, values, end, and begin
</p>

<hr>
<h2 id='summarize_walk_bouts'>Summarize walking bouts:
This function summarizes walking bouts and calculates the median speed, complete day, non-wearing, bout start, and duration of each bout.</h2><span id='topic+summarize_walk_bouts'></span>

<h3>Description</h3>

<p>Summarize walking bouts:
This function summarizes walking bouts and calculates the median speed, complete day, non-wearing, bout start, and duration of each bout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_walk_bouts(walk_bouts, ..., collated_arguments = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_walk_bouts_+3A_walk_bouts">walk_bouts</code></td>
<td>
<p>A data frame containing identified walk bouts</p>
</td></tr>
<tr><td><code id="summarize_walk_bouts_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
<tr><td><code id="summarize_walk_bouts_+3A_collated_arguments">collated_arguments</code></td>
<td>
<p>A list of collated arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame summarizing identified walk bouts
</p>

<hr>
<h2 id='validate_accelerometry_data'>Validate accelerometry input data</h2><span id='topic+validate_accelerometry_data'></span>

<h3>Description</h3>

<p>The input schema for the accelerometry data is <code>time</code> and <code>activity_counts</code>.
</p>

<ul>
<li> <p><code>time</code> should be a column in date-time format, in the UTC time zone, with no null values.
</p>
</li>
<li> <p><code>activity_counts</code> should be a positive numeric column with no null values.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_accelerometry_data(accelerometry_counts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_accelerometry_data_+3A_accelerometry_counts">accelerometry_counts</code></td>
<td>
<p>Raw accelerometry data with the expected schema.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks the schema of the accelerometry input data
and raises an error if any schema constraints are violated.
</p>
<p>The following schema validations are performed on the input data:
</p>

<ul>
<li><p> The input data must contain two columns, named <code>time</code> and <code>activity_counts</code>.
</p>
</li>
<li><p> The <code>time</code> column must be in date-time format, in the UTC time zone, with no null values.
</p>
</li>
<li><p> The <code>activity_counts</code> column must be a positive numeric column with no null values.
</p>
</li></ul>



<h3>Value</h3>

<p>This function does not return anything. It throws an error if the accelerometry data fails any of the validation checks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
data &lt;- data.frame(
  time = seq(
    as.POSIXct("2021-01-01 00:00:00", tz = "UTC"),
    as.POSIXct("2021-01-01 23:59:59", tz = "UTC"),
    by = "5 mins"
  )) %&gt;%
  dplyr::mutate(activity_counts = sample(0:100, length(time), replace = TRUE))
validate_accelerometry_data(data)

</code></pre>

<hr>
<h2 id='validate_gps_data'>Validate GPS data</h2><span id='topic+validate_gps_data'></span>

<h3>Description</h3>

<p>This function validates GPS data for required variables, correct variable class, and correct data range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_gps_data(gps_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_gps_data_+3A_gps_data">gps_data</code></td>
<td>
<p>A data frame containing GPS data with the following variables: time, latitude, longitude, and speed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything. It throws an error if the GPS data fails any of the validation checks.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
