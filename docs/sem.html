<!DOCTYPE html><html><head><title>Help for package sem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bollen'>
<p>Bollen's Data on Industrialization and Political Democracy</p></a></li>
<li><a href='#bootSem'><p>Bootstrap a Structural Equation Model</p></a></li>
<li><a href='#CNES'><p>Variables from the 1997 Canadian National Election Study</p></a></li>
<li><a href='#effects.sem'>
<p>Total, Direct, and Indirect Effects for Structural Equation Models</p></a></li>
<li><a href='#fscores'><p>Factor Scores for Latent Variables</p></a></li>
<li><a href='#HS.data'>
<p>Holizinger and Swineford's Data</p></a></li>
<li><a href='#information.criteria'>
<p>Additional Information Criteria</p></a></li>
<li><a href='#Klein'><p>Klein's Data on the U. S. Economy</p></a></li>
<li><a href='#Kmenta'><p>Partly Artificial Data on the U. S. Economy</p></a></li>
<li><a href='#miSem'>
<p>Estimate a Structural Equation Model By Multiple Imputation</p></a></li>
<li><a href='#ML.methods'>
<p>Methods for sem Objects Fit Using the <code>objectiveML</code>, <code>objectiveGLS</code>, <code>objectiveFIML</code>, <code>msemObjectiveML</code>,</p>
and <code>msemObjectiveGLS</code> Objective Functions</a></li>
<li><a href='#modIndices'><p>Modification Indices for Structural Equation Models</p></a></li>
<li><a href='#objective.functions'>
<p>sem Objective-Function Builders</p></a></li>
<li><a href='#optimizers'><p>sem Optimizers</p></a></li>
<li><a href='#pathDiagram'><p>Draw Path Diagram</p></a></li>
<li><a href='#ram'><p>RAM Matrix for a Structural-Equation Model</p></a></li>
<li><a href='#rawMoments'><p>Compute Raw Moments Matrix</p></a></li>
<li><a href='#readMoments'><p>Input a Covariance, Correlation, or Raw Moment Matrix</p></a></li>
<li><a href='#residuals.sem'><p>Residual Covariances for a Structural Equation Model</p></a></li>
<li><a href='#sem'><p>General Structural Equation Models</p></a></li>
<li><a href='#sem-deprecated'><p>Deprecated Functions in the sem Package</p></a></li>
<li><a href='#specifyModel'><p>Specify a Structural Equation Model</p></a></li>
<li><a href='#standardizedCoefficients'><p>Standardized Coefficients for Structural Equation Models</p></a></li>
<li><a href='#Tests'>
<p>Six Mental Tests</p></a></li>
<li><a href='#tsls'><p>Two-Stage Least Squares</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.1-15</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-09</td>
</tr>
<tr>
<td>Title:</td>
<td>Structural Equation Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, boot, mi (&ge; 0.9-99), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>polycor, DiagrammeR (&ge; 1.0.9)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for fitting general linear structural
    equation models (with observed and latent variables) using the RAM approach, 
    and for fitting structural equations in observed-variable models by two-stage least squares.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>,
<a href="https://socialsciences.mcmaster.ca/jfox/">https://socialsciences.mcmaster.ca/jfox/</a></td>
</tr>
<tr>
<td>Author:</td>
<td>John Fox [aut, cre],
  Zhenghua Nie [aut],
  Jarrett Byrnes [aut],
  Michael Culbertson [ctb],
  Saikat DebRoy [ctb],
  Michael Friendly [ctb],
  Benjamin Goodrich [ctb],
  Richard H. Jones [ctb],
  Adam Kramer [ctb],
  Georges Monette [ctb],
  Frederick Novomestky [ctb],
  R-Core [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Fox &lt;jfox@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>sem</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>185</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2022-04-09 16:13:00</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-10 21:40:06 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-09 16:31:08 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='Bollen'>
Bollen's Data on Industrialization and Political Democracy
</h2><span id='topic+Bollen'></span>

<h3>Description</h3>

<p>This data set includes four measures of democracy at two points in
time, 1960 and 1965, and three measures of industrialization in 1960,
for 75 developing countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bollen</code></pre>


<h3>Format</h3>

<p>A data frame with 75 observations on the following 11 variables.
</p>

<dl>
<dt><code>y1</code></dt><dd><p>freedom of the press, 1960</p>
</dd>
<dt><code>y2</code></dt><dd><p>freedom of political opposition, 1960</p>
</dd>
<dt><code>y3</code></dt><dd><p>fairness of elections, 1960</p>
</dd>
<dt><code>y4</code></dt><dd><p>effectivness of elected legislature, 1960</p>
</dd>
<dt><code>y5</code></dt><dd><p>freedom of the press, 1965</p>
</dd>
<dt><code>y6</code></dt><dd><p>freedom of political opposition, 1965</p>
</dd>
<dt><code>y7</code></dt><dd><p>fairness of elections, 1965</p>
</dd>
<dt><code>y8</code></dt><dd><p>effectivness of elected legislature, 1965</p>
</dd>
<dt><code>x1</code></dt><dd><p>GNP per capita, 1960</p>
</dd>
<dt><code>x2</code></dt><dd><p>energy consumption per capita, 1960</p>
</dd>
<dt><code>x3</code></dt><dd><p>percentage of labor force in industry, 1960</p>
</dd>
</dl>



<h3>Details</h3>

<p>Variables <code>y1</code> through <code>y4</code> are intended to be indicators of the latent variable <em>political democracy in 1960</em>;
<code>y5</code> through <code>y8</code> indicators of <em>political democracy in 1965</em>; and
<code>x1</code> through <code>x3</code> indicators of <em>industrialization in 1960</em>.
</p>


<h3>Source</h3>

<p>personal communication from Ken Bollen.
</p>


<h3>References</h3>

<p>Bollen, K. A. (1989) <em>Structural Equations With Latent Variables</em>. Wiley. 
</p>

<hr>
<h2 id='bootSem'>Bootstrap a Structural Equation Model</h2><span id='topic+bootSem'></span><span id='topic+bootSem.sem'></span><span id='topic+bootSem.msem'></span><span id='topic+print.bootsem'></span><span id='topic+summary.bootsem'></span><span id='topic+print.summary.bootsem'></span>

<h3>Description</h3>

<p>Bootstraps a structural equation model in an <code>sem</code> object (as returned by
the <code><a href="#topic+sem">sem</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootSem(model, ...)

## S3 method for class 'sem'
bootSem(model, R=100, Cov=cov, data=model$data, 
    max.failures=10, show.progress=TRUE, ...)

## S3 method for class 'msem'
bootSem(model, R=100, Cov=cov, data=model$data, 
    max.failures=10, show.progress=TRUE, ...)

## S3 method for class 'bootsem'
print(x, digits=getOption("digits"), ...)

## S3 method for class 'bootsem'
summary(object,
    type=c("perc", "bca", "norm", "basic", "none"), level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootSem_+3A_model">model</code></td>
<td>
<p>an <code>sem</code> or <code>msem</code> object, produced by the <code>sem</code> function.</p>
</td></tr>
<tr><td><code id="bootSem_+3A_r">R</code></td>
<td>
<p>the number of bootstrap replications; the default is 100, which should
be enough for computing standard errors, but not confidence intervals
(except for the normal-theory intervals).</p>
</td></tr>
<tr><td><code id="bootSem_+3A_cov">Cov</code></td>
<td>
<p>a function to compute the input covariance or moment matrix; the default is
<code><a href="stats.html#topic+cov">cov</a></code>. Use <code><a href="stats.html#topic+cor">cor</a></code> if the model is fit
to the correlation matrix. The function <code><a href="polycor.html#topic+hetcor">hetcor</a></code> in the 
<code>polycor</code> package will compute product-moment, polychoric, and
polyserial correlations among mixed continuous and ordinal variables
(see the first example below for an illustration).</p>
</td></tr>
<tr><td><code id="bootSem_+3A_data">data</code></td>
<td>
<p>in the case of a <code>sem</code> (i.e., single-group) <code>model</code>, a data set in a form suitable for <code>Cov</code>;
for example, for the default <code>Cov=cov</code>, <code>data</code> may be a numeric data frame or a numeric matrix.
In the case of an <code>msem</code> (i.e., multi-group) <code>model</code>, a list of data sets (again in the appropriate form),
one for each group; in this case, bootstrapping is done within each group, treating the groups as strata.
Note that the original observations are required, not just the covariance 
matrix of the observed variables in the model. The default is the data set stored in the
<code>sem</code> object, which will be present only if the model was fit to a data set rather than to
a covariance or moment matrix, and may not be in a form suitable for <code>Cov</code>.</p>
</td></tr>
<tr><td><code id="bootSem_+3A_max.failures">max.failures</code></td>
<td>
<p>maximum number of consecutive convergence failures before <code>bootSem</code> gives up.</p>
</td></tr>
<tr><td><code id="bootSem_+3A_show.progress">show.progress</code></td>
<td>
<p>display a text progress bar on the console tracing the bootstrap replications.</p>
</td></tr>
<tr><td><code id="bootSem_+3A_x">x</code>, <code id="bootSem_+3A_object">object</code></td>
<td>
<p>an object of class <code>bootsem</code>.</p>
</td></tr>
<tr><td><code id="bootSem_+3A_digits">digits</code></td>
<td>
<p>controls the number of digits to print.</p>
</td></tr>
<tr><td><code id="bootSem_+3A_type">type</code></td>
<td>
<p>type of bootstrapped confidence intervals to compute; the
default is <code>"perc"</code> (percentile); see 
<code><a href="boot.html#topic+boot.ci">boot.ci</a></code> for details.</p>
</td></tr>
<tr><td><code id="bootSem_+3A_level">level</code></td>
<td>
<p>level for confidence intervals; default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="bootSem_+3A_...">...</code></td>
<td>
<p>in <code>bootSem</code>, arguments to be passed to 
<code><a href="#topic+sem">sem</a></code>; otherwise ignored.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>bootSem</code> implements the nonparametric bootstrap, assuming an
independent random sample. Convergence failures in the bootstrap resamples
are discarded (and a warning printed); more than <code>max.failures</code> consecutive convergence failures (default, 10)
result in an error. You can use the <code><a href="boot.html#topic+boot">boot</a></code> function
in the <span class="pkg">boot</span> package for more complex sampling schemes and additional options.
</p>
<p>Bootstrapping is implemented by resampling the observations in
<code>data</code>, recalculating the input covariance matrix with <code>Cov</code>,
and refitting the model with <code><a href="#topic+sem">sem</a></code>, using the
parameter estimates from the original sample as start-values.
</p>
<p><b>Warning:</b> the bootstrapping process can be very time-consuming.
</p>


<h3>Value</h3>

<p><code>bootSem</code> returns an object of class <code>bootsem</code>, which inherits
from class <code>boot</code>, supported by the <span class="pkg">boot</span> package. The returned
object contains the following components:
</p>
<table>
<tr><td><code>t0</code></td>
<td>
<p>the estimated parameters in the model fit to the original data set.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>a matrix containing the bootstrapped estimates, one bootstrap
replication per row.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the data to which the model was fit.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the value of <code>.Random.seed</code> when <code>bootSem</code> was called.</p>
</td></tr>  
<tr><td><code>statistic</code></td>
<td>
<p>the function used to produce the bootstrap replications;
this is always the local function <code>refit</code> from <code>bootSem</code>.</p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p>always set to <code>"ordinary"</code>; see the documentation for the
<code><a href="boot.html#topic+boot">boot</a></code> function.</p>
</td></tr>
<tr><td><code>stype</code></td>
<td>
<p>always set to <code>"i"</code>; see the documentation for the
<code><a href="boot.html#topic+boot">boot</a></code> function.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call of the <code>bootSem</code> function.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>a vector of length equal to the number of observations <code class="reqn">N</code>,
with entries <code class="reqn">1/N</code>. For a multi-group model, the weights in group <code class="reqn">j</code> are <code class="reqn">1/N_j</code>,
the inverse of the number of observations in the group.</p>
</td></tr>
<tr><td><code>strata</code></td>
<td>
<p>a vector of length <code class="reqn">N</code> containing the number of the stratum
to which each observation belongs; for a single-group model, all entries
are 1.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Davison, A. C., and Hinkley, D. V. (1997)
<em>Bootstrap Methods and their Application.</em> Cambridge.
</p>
<p>Efron, B., and Tibshirani, R. J. (1993)
<em>An Introduction to the Bootstrap.</em> Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code>, <code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run:  # because of long execution time

# A simple confirmatory factor-analysis model using polychoric correlations.
#  The polycor package is required for the hetcor function.

if (require(polycor)){

# The following function returns correlations computed by hetcor,
#   and is used for the bootstrapping.

hcor &lt;- function(data) hetcor(data, std.err=FALSE)$correlations

model.cnes &lt;- specifyModel(text="
F -&gt; MBSA2, lam1
F -&gt; MBSA7, lam2
F -&gt; MBSA8, lam3
F -&gt; MBSA9, lam4
F &lt;-&gt; F, NA, 1
MBSA2 &lt;-&gt; MBSA2, the1
MBSA7 &lt;-&gt; MBSA7, the2
MBSA8 &lt;-&gt; MBSA8, the3
MBSA9 &lt;-&gt; MBSA9, the4
")

R.cnes &lt;- hcor(CNES)

sem.cnes &lt;- sem(model.cnes, R.cnes, N=1529)
summary(sem.cnes)
}

#  Note: this can take a minute:

set.seed(12345) # for reproducibility

system.time(boot.cnes &lt;- bootSem(sem.cnes, R=100, Cov=hcor, data=CNES))
summary(boot.cnes, type="norm")  
# cf., standard errors to those computed by summary(sem.cnes)
    
## End(Not run)
    
    ## Not run:   # because of long execution time

# An example bootstrapping a multi-group model

mod.hs &lt;- cfa(text="
spatial: visual, cubes, paper, flags
verbal: general, paragrap, sentence, wordc, wordm
memory: wordr, numberr, figurer, object, numberf, figurew
math: deduct, numeric, problemr, series, arithmet
")

mod.mg &lt;- multigroupModel(mod.hs, groups=c("Female", "Male")) 

sem.mg &lt;- sem(mod.mg, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
              general + paragrap + sentence + wordc + wordm +
              wordr + numberr + figurer + object + numberf + figurew +
              deduct + numeric + problemr + series + arithmet
              )

# Note: this example can take several minutes or more;
#       you can decrease R if you just want to see how it works:

set.seed(12345) # for reproducibility

system.time(boot.mg &lt;- bootSem(sem.mg, R=100))
summary(boot.mg, type="norm")
# cf., standard errors to those computed by summary(sem.mg)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='CNES'>Variables from the 1997 Canadian National Election Study</h2><span id='topic+CNES'></span>

<h3>Description</h3>

<p>These variables are from the mailback questionnaire to the 1997 Canadian
National Election Study, and are intended to tap attitude towards &ldquo;traditional
values.&rdquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CNES</code></pre>


<h3>Format</h3>

<p>A data frame with 1529 observations on the following 4 variables.
</p>

<dl>
<dt><code>MBSA2</code></dt><dd><p>an ordered factor with levels <code>StronglyDisagree</code>, 
<code>Disagree</code>, <code>Agree</code>, and <code>StronglyAgree</code>, in response to the statement,
&ldquo;We should be more tolerant of people who choose to live according to their own standards, 
even if they are very different from our own.&rdquo;</p>
</dd>
<dt><code>MBSA7</code></dt><dd><p>an ordered factor with levels <code>StronglyDisagree</code>, 
<code>Disagree</code>, <code>Agree</code>, and <code>StronglyAgree</code>, in response to the statement,
&ldquo;Newer lifestyles are contributing to the breakdown of our society.&rdquo;</p>
</dd>
<dt><code>MBSA8</code></dt><dd><p>an ordered factor with levels <code>StronglyDisagree</code>, 
<code>Disagree</code>, <code>Agree</code>, and <code>StronglyAgree</code>, in response to the statement,
&ldquo;The world is always changing and we should adapt our view of moral behaviour to
these changes.&rdquo;</p>
</dd>
<dt><code>MBSA9</code></dt><dd><p>an ordered factor with levels <code>StronglyDisagree</code>, 
<code>Disagree</code>, <code>Agree</code>, and <code>StronglyAgree</code>, in response to the statement,
&ldquo;This country would have many fewer problems if there were more emphasis on
traditional family values.&rdquo;</p>
</dd>
</dl>



<h3>Source</h3>

<p>York University Institute for Social Research.
</p>

<hr>
<h2 id='effects.sem'>
Total, Direct, and Indirect Effects for Structural Equation Models
</h2><span id='topic+effects.sem'></span><span id='topic+effects.msem'></span><span id='topic+print.semeffects'></span><span id='topic+print.semeffectsList'></span>

<h3>Description</h3>

<p>The <code>sem</code> method for the standard generic function <code>effects</code> computes total, direct, 
and indirect effects for a fitted structural equation model according to the method described in Fox (1980).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sem'
effects(object, ...)
## S3 method for class 'msem'
effects(object, ...)

## S3 method for class 'semeffects'
print(x, digits = getOption("digits"), ...)
## S3 method for class 'semeffectsList'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effects.sem_+3A_object">object</code></td>
<td>
<p>a fitted structural-equation model object produced by the <code><a href="#topic+sem">sem</a></code> function.</p>
</td></tr>
<tr><td><code id="effects.sem_+3A_x">x</code></td>
<td>
<p>an object of class <code>semeffects</code> or <code>semeffectsList</code>, produced by <code>effects</code>.</p>
</td></tr>
<tr><td><code id="effects.sem_+3A_digits">digits</code></td>
<td>
<p>digits to print.</p>
</td></tr>
<tr><td><code id="effects.sem_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>effect.sem</code> returns an object of class <code>semeffects</code> with <code>Total</code>, <code>Direct</code>, and <code>Indirect</code> elements.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. (1980)
Effect analysis in structural equation models: Extensions and simplified methods of computation.
<em>Sociological Methods and Research</em>
<b>9</b>, 3&ndash;28.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run: 

# These examples are from Fox (1980)

# In the first pair of examples, readMoments() and specifyModel() read from the
# input stream. These examples cannot be executed via example() but can be entered
# at the command prompt. The Blau and Duncan example is repeated using file input;
# this example can be executed via example(). 

# The recursive Blau and Duncan basic stratification model:
#  x1 is father's education, x2 father's SES, y3 respondent's education,
#  y4 SES of respondent's first job, y5 respondent's SES in 1962

R.bd &lt;- readMoments(names=c("x1", "x2", "y3", "y4", "y5"))
1
.516 1
.453 .438 1
.332 .417 .538 1
.322 .405 .596 .541 1

mod.bd &lt;- specifyModel()
y3 &lt;- x1, gam31
y3 &lt;- x2, gam32
y4 &lt;- x2, gam42
y4 &lt;- y3, beta43
y5 &lt;- x2, gam52
y5 &lt;- y3, beta53
y5 &lt;- y4, beta54

sem.bd &lt;- sem(mod.bd, R.bd, N=20700, fixed.x=c("x1", "x2"))
summary(sem.bd)
effects(sem.bd)


# The nonrecursive Duncan, Haller, and Portes peer-influences model for observed variables:

R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
"FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"))
.6247     
.3269  .3669       
.4216  .3275  .6404
.2137  .2742  .1124  .0839
.4105  .4043  .2903  .2598  .1839
.3240  .4047  .3054  .2786  .0489  .2220
.2930  .2407  .4105  .3607  .0186  .1861  .2707
.2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950
.0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087

model.dhp &lt;- specifyModel()
RIQ      -&gt; ROccAsp, gam51,  NA
RSES     -&gt; ROccAsp, gam52,  NA
FSES     -&gt; FOccAsp, gam63,  NA
FIQ      -&gt; FOccAsp, gam64,  NA
FOccAsp  -&gt; ROccAsp, beta56, NA
ROccAsp  -&gt; FOccAsp, beta65, NA
ROccAsp &lt;-&gt; ROccAsp, ps55,   NA
FOccAsp &lt;-&gt; FOccAsp, ps66,   NA
ROccAsp &lt;-&gt; FOccAsp, ps56,   NA


# Note: The following generates a warning because not all of the variables
#       in the correlation matrix are used
sem.dhp &lt;- sem(model.dhp, R.DHP, 329,
                fixed.x=c('RIQ', 'RSES', 'FSES', 'FIQ'))
summary(sem.dhp)
effects(sem.dhp)
    
## End(Not run)
    
## the following example may be executed via example()

etc &lt;- system.file(package="sem", "etc") # path to data and model files

# The recursive Blau and Duncan basic stratification model:
#  x1 is father's education, x2 father's SES, y3 respondent's education,
#  y4 SES of respondent's first job, y5 respondent's SES in 1962

(R.bd &lt;- readMoments(file=file.path(etc, "R-Blau-Duncan.txt"),
					names=c("x1", "x2", "y3", "y4", "y5")))
(mod.bd &lt;- specifyModel(file=file.path(etc, "model-Blau-Duncan.txt")))
sem.bd &lt;- sem(mod.bd, R.bd, N=20700, fixed.x=c("x1", "x2"))
summary(sem.bd)
effects(sem.bd)
</code></pre>

<hr>
<h2 id='fscores'>Factor Scores for Latent Variables</h2><span id='topic+fscores'></span><span id='topic+fscores.sem'></span><span id='topic+fscores.msem'></span>

<h3>Description</h3>

<p>Calculate factor scores or factor-score coefficients for the latent variables
in a structural-equation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sem'
fscores(model, data=model$data, center=TRUE, scale=FALSE, ...)
## S3 method for class 'msem'
fscores(model, data=model$data, center=TRUE, scale=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fscores_+3A_model">model</code></td>
<td>
<p>an object of class <code>"sem"</code> or <code>"msem"</code>, produced by the <code><a href="#topic+sem">sem</a></code>
function.</p>
</td></tr>
<tr><td><code id="fscores_+3A_data">data</code></td>
<td>
<p>an optional numeric data frame or matrix containing the observed variables
in the model; if not <code>NULL</code>, the estimated factor scores are returned; if <code>NULL</code>, the
factor-score <em>coefficients</em> are returned. The default is the <code>data</code> element of <code>model</code>,
which is non-<code>NULL</code> if the model was fit to a data set rather than a covariance or moment matrix.</p>
</td></tr>
<tr><td><code id="fscores_+3A_center">center</code></td>
<td>
<p>if <code>TRUE</code>, the default, the means of the observed variables are
subtracted prior to computing factor scores. One would normally use this option
if the model is estimated from a covariance or correlation matrix among the
observed variables.</p>
</td></tr>
<tr><td><code id="fscores_+3A_scale">scale</code></td>
<td>
<p>if <code>TRUE</code>, the possibly centered variables are divided by their
root-mean-squares; the default is <code>FALSE</code>.
One would normally use this option if the model is estimated
from a correlation matrix among the observed variables. Centering and scaling 
are performed by the <code><a href="base.html#topic+scale">scale</a></code> function.</p>
</td></tr>
<tr><td><code id="fscores_+3A_...">...</code></td>
<td>
<p>arguments to pass down.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Factor-score coefficients are computed by the &ldquo;regression&rdquo; method as
<code class="reqn">B = C^{-1} C^{*}</code>, where <code class="reqn">C</code> is the model-implied covariance or
moment matrix among the observed variables and  <code class="reqn">C^{*}</code> is the matrix
of model-implied covariances or moments between the observed and latent variables.
</p>


<h3>Value</h3>

<p>Either a matrix of estimated factor scores (if the <code>data</code> argument is
supplied) or a matrix of factor-score coefficients (otherwise). In the case of an <code>"msem"</code>
argument, a list of matrices is returned.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Bollen, K. A. (1989) 
<em>Structural Equations With Latent Variables.</em> Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code>, <code><a href="base.html#topic+scale">scale</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# In the first example, readMoments() and specifyModel() read from the
# input stream. This example cannot be executed via example() but can be entered
# at the command prompt. The example is repeated using file input;
# this example can be executed via example(). 
	   ## Not run: 

S.wh &lt;- readMoments(names=c('Anomia67','Powerless67','Anomia71',
                                    'Powerless71','Education','SEI'))
   11.834                                    
    6.947    9.364                            
    6.819    5.091   12.532                    
    4.783    5.028    7.495    9.986            
   -3.839   -3.889   -3.841   -3.625   9.610     
  -21.899  -18.831  -21.748  -18.775  35.522  450.288

# This model in the SAS manual for PROC CALIS

model.wh.1 &lt;- specifyModel()
    Alienation67   -&gt;  Anomia67,      NA,     1
    Alienation67   -&gt;  Powerless67,   NA,     0.833
    Alienation71   -&gt;  Anomia71,      NA,     1
    Alienation71   -&gt;  Powerless71,   NA,     0.833 
    SES            -&gt;  Education,     NA,     1     
    SES            -&gt;  SEI,           lamb,   NA
    SES            -&gt;  Alienation67,  gam1,   NA
    Alienation67   -&gt;  Alienation71,  beta,   NA
    SES            -&gt;  Alienation71,  gam2,   NA
    Anomia67       &lt;-&gt; Anomia67,      the1,   NA
    Anomia71       &lt;-&gt; Anomia71,      the1,   NA
    Powerless67    &lt;-&gt; Powerless67,   the2,   NA
    Powerless71    &lt;-&gt; Powerless71,   the2,   NA
    Education      &lt;-&gt; Education,     the3,   NA
    SEI            &lt;-&gt; SEI,           the4,   NA
    Anomia67       &lt;-&gt; Anomia71,      the5,   NA
    Powerless67    &lt;-&gt; Powerless71,   the5,   NA
    Alienation67   &lt;-&gt; Alienation67,  psi1,   NA
    Alienation71   &lt;-&gt; Alienation71,  psi2,   NA
    SES            &lt;-&gt; SES,           phi,    NA
    
                        
sem.wh.1 &lt;- sem(model.wh.1, S.wh, 932)

fscores(sem.wh.1)
   
## End(Not run)

# The following example can be executed via example():

etc &lt;- system.file(package="sem", "etc") # path to data and model files
   
(S.wh &lt;- readMoments(file=file.path(etc, "S-Wheaton.txt"),
					names=c('Anomia67','Powerless67','Anomia71',
                            'Powerless71','Education','SEI')))
(model.wh.1 &lt;- specifyModel(file=file.path(etc, "model-Wheaton-1.txt")))        
(sem.wh.1 &lt;- sem(model.wh.1, S.wh, 932))
fscores(sem.wh.1)
</code></pre>

<hr>
<h2 id='HS.data'>
Holizinger and Swineford's Data
</h2><span id='topic+HS.data'></span>

<h3>Description</h3>

<p>This data set, for scores on a variety of tests, was originally in the MBESS package. A new version of the data set in that package doesn't appear to be identical to this one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HS.data</code></pre>


<h3>Format</h3>

<p>A data frame with 301 observations on the following 32 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Gender</code></dt><dd><p>a factor with levels <code>Female</code> <code>Male</code></p>
</dd>
<dt><code>grade</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>agey</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>agem</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>school</code></dt><dd><p>a factor with levels <code>Grant-White</code> <code>Pasteur</code></p>
</dd>
<dt><code>visual</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>cubes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>paper</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>flags</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>general</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>paragrap</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>sentence</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>wordc</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>wordm</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>addition</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>code</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>counting</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>straight</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>wordr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>numberr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>figurer</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>object</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>numberf</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>figurew</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>deduct</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>numeric</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>problemr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>series</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>arithmet</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>paperrev</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>flagssub</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Originally from Holzinger and Swineford (1939). This copy is originally from version 4.6.0 of the MBESS package.
</p>


<h3>References</h3>

<p>Holzinger, K. J. and Swineford, F. A. (1939). 
A study in factor analysis: The stability of a bi-factor solution. 
Supplementary Education Monographs, 48. University of Chicago.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(HS.data)
</code></pre>

<hr>
<h2 id='information.criteria'>
Additional Information Criteria
</h2><span id='topic+information.criteria'></span><span id='topic+AICc'></span><span id='topic+CAIC'></span>

<h3>Description</h3>

<p>These are generic functions for computing, respectively, the AICc (second-order corrected Akaike Information Criterion) and CAIC (consistent Akaike Information Criterion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICc(object, ...)

CAIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="information.criteria_+3A_object">object</code></td>
<td>
<p>an object for which an appropriate <code>AICc</code> or <code>CAIC</code> method exists.</p>
</td></tr>
<tr><td><code id="information.criteria_+3A_...">...</code></td>
<td>
<p>possible additional arguments for methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarrett Byrnes and John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Burnham, K. P., and Anderson, D. R. (1998)
<em>Model Selection and Inference: A Practical Information-Theoretical Approach.</em> Springer.
</p>
<p>Bozdogan, H. (1987)
Model selection and Akaike's information criterion (AIC).
<em>Psychometrika</em>  bold52, 345&ndash;370.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICc.objectiveML">AICc.objectiveML</a></code>, <code><a href="#topic+CAIC.objectiveML">CAIC.objectiveML</a></code>
</p>

<hr>
<h2 id='Klein'>Klein's Data on the U. S. Economy</h2><span id='topic+Klein'></span>

<h3>Description</h3>

<p>Data for Klein's (1950) simple econometric model of the U. S. economy.
</p>
<p>The <code>Klein</code> data frame has 22 rows and 10 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Klein</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Year</dt><dd><p>1921&ndash;1941</p>
</dd>
<dt>C</dt><dd><p>consumption.</p>
</dd>
<dt>P</dt><dd><p>private profits.</p>
</dd>
<dt>Wp</dt><dd><p>private wages.</p>
</dd>
<dt>I</dt><dd><p>investment.</p>
</dd>
<dt>K.lag</dt><dd><p>capital stock, lagged one year.</p>
</dd>
<dt>X</dt><dd><p>equilibrium demand.</p>
</dd>
<dt>Wg</dt><dd><p>government wages.</p>
</dd>
<dt>G</dt><dd><p>government non-wage spending.</p>
</dd>
<dt>T</dt><dd><p>indirect business taxes and net exports.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Greene, W. H. (1993)
<em>Econometric Analysis, Second Edition.</em>
Macmillan.
</p>


<h3>References</h3>

<p>Klein, L. (1950)
<em>Economic Fluctuations in the United States 1921&ndash;1941.</em>
Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Klein$P.lag &lt;- c(NA, Klein$P[-22])
Klein$X.lag &lt;- c(NA, Klein$X[-22])

summary(tsls(C ~ P + P.lag + I(Wp + Wg), 
    instruments=~1 + G + T + Wg + I(Year - 1931) + K.lag + P.lag + X.lag,
    data=Klein))
    
summary(tsls(I ~ P + P.lag + K.lag,
    instruments=~1 + G + T + Wg + I(Year - 1931) + K.lag + P.lag + X.lag,
    data=Klein))
    
summary(tsls(Wp ~ X + X.lag + I(Year - 1931),
    instruments=~1 + G + T + Wg + I(Year - 1931) + K.lag + P.lag + X.lag,
    data=Klein))
</code></pre>

<hr>
<h2 id='Kmenta'>Partly Artificial Data on the U. S. Economy</h2><span id='topic+Kmenta'></span>

<h3>Description</h3>

<p>These are partly contrived data from Kmenta (1986), constructed
to illustrate estimation of a simultaneous-equation model.
</p>
<p>The <code>Kmenta</code> data frame has 20 rows and 5 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kmenta</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Q</dt><dd>
<p>food consumption per capita.
</p>
</dd>
<dt>P</dt><dd>
<p>ratio of food prices to general consumer prices.
</p>
</dd>
<dt>D</dt><dd>
<p>disposable income in constant dollars.
</p>
</dd>
<dt>F</dt><dd>
<p>ratio of preceding year's prices received by farmers
to general consumer prices.
</p>
</dd>
<dt>A</dt><dd>
<p>time in years.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The exogenous variables <code>D</code>, <code>F</code>, and <code>A</code> are based on
real data; the endogenous variables <code>P</code> and <code>Q</code> were generated
by simulation.
</p>


<h3>Source</h3>

<p>Kmenta, J. (1986)
<em>Elements of Econometrics, Second Edition</em>, Macmillan.
</p>

<hr>
<h2 id='miSem'>
Estimate a Structural Equation Model By Multiple Imputation
</h2><span id='topic+miSem'></span><span id='topic+miSem.semmod'></span><span id='topic+miSem.semmodList'></span><span id='topic+print.miSem'></span><span id='topic+summary.miSem'></span>

<h3>Description</h3>

<p><code>miSem</code> uses the <code>mi</code> function in the <span class="pkg">mi</span> package to generate multiple imputations of missing
data, fitting the specified model to each completed data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miSem(model, ...)

## S3 method for class 'semmod'
miSem(model, ..., data, formula = ~., raw=FALSE, 
        fixed.x=NULL, objective=objectiveML,
        n.imp=5, n.chains=n.imp, n.iter=30, seed=sample(1e6, 1), mi.args=list(), 
        show.progress=TRUE)
    
## S3 method for class 'semmodList'
miSem(model, ..., data, formula = ~., group, raw=FALSE, 
        fixed.x=NULL, objective=msemObjectiveML,
        n.imp=5, n.chains=n.imp, n.iter=30, seed=sample(1e6, 1), mi.args=list(),
        show.progress=TRUE)

## S3 method for class 'miSem'
print(x, ...)

## S3 method for class 'miSem'
summary(object, digits=max(3, getOption("digits") - 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miSem_+3A_model">model</code></td>
<td>

<p>an SEM model-description object of class <code>semmod</code> or <code>semmodList</code>, created by <code><a href="#topic+specifyEquations">specifyEquations</a></code>
<code><a href="#topic+cfa">cfa</a></code>, or <code><a href="#topic+specifyModel">specifyModel</a></code>, in the case of a multi-group model 
in combination with <code><a href="#topic+multigroupModel">multigroupModel</a></code>.
</p>
</td></tr>
<tr><td><code id="miSem_+3A_...">...</code>, <code id="miSem_+3A_formula">formula</code>, <code id="miSem_+3A_raw">raw</code>, <code id="miSem_+3A_fixed.x">fixed.x</code>, <code id="miSem_+3A_objective">objective</code>, <code id="miSem_+3A_group">group</code></td>
<td>

<p>arguments to be passed to <code><a href="#topic+sem">sem</a></code>.
</p>
</td></tr>
<tr><td><code id="miSem_+3A_data">data</code></td>
<td>

<p>an R data frame, presumably with some missing data (encoded as <code>NA</code>), containing the data for fitting
the SEM, possibly along with other variables to use to obtain multiple imputations of missing values. In
the case of a multi-group model, this must be a <em>single</em> data frame.
</p>
</td></tr>
<tr><td><code id="miSem_+3A_n.imp">n.imp</code></td>
<td>

<p>number of imputations (default <code>5</code>).
</p>
</td></tr>
<tr><td><code id="miSem_+3A_n.chains">n.chains</code></td>
<td>

<p>number of Markov chains (default is the number of imputations).
</p>
</td></tr>
<tr><td><code id="miSem_+3A_n.iter">n.iter</code></td>
<td>

<p>number of iterations for the multiple-imputation process (default <code>30</code>).
</p>
</td></tr>
<tr><td><code id="miSem_+3A_seed">seed</code></td>
<td>

<p>seed for the random-number generator (default is an integer sampled from 1 to 1E6); stored in the resulting object.
</p>
</td></tr>
<tr><td><code id="miSem_+3A_mi.args">mi.args</code></td>
<td>

<p>other arguments to be passed to <code>mi</code>.
</p>
</td></tr>
<tr><td><code id="miSem_+3A_show.progress">show.progress</code></td>
<td>

<p>show a text progress bar on the console tracking model fitting to the multiple imputations; this is distinct from
the progress of the multiple-imputation process, which is controlled by the <code>verbose</code> argument to <code>mi</code>
(and which, although it defaults to <code>TRUE</code>, <em>fails</em> to produce verbose output on Windows system, as of <span class="pkg">mi</span> version
1.0).
</p>
</td></tr>
<tr><td><code id="miSem_+3A_x">x</code>, <code id="miSem_+3A_object">object</code></td>
<td>

<p>an object of class <code>"miSem"</code>.
</p>
</td></tr>
<tr><td><code id="miSem_+3A_digits">digits</code></td>
<td>

<p>for printing numbers.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>miSem</code> returns an object of class <code>"miSem"</code> with the following components:
</p>
<table>
<tr><td><code>initial.fit</code></td>
<td>
<p>an <code>sem</code> model object produced using <code><a href="#topic+objectiveFIML">objectiveFIML</a></code> if <code>raw=TRUE</code>,
or the objective function given by the <code>objective</code> argument otherwise.</p>
</td></tr>
<tr><td><code>mi.fits</code></td>
<td>
<p>a list of <code>sem</code> model objects, one for each imputed data set.</p>
</td></tr>
<tr><td><code>imputation</code></td>
<td>
<p>the object produced by <code><a href="RCurl.html#topic+complete">complete</a></code>, containing the completed imputed data sets.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the seed used for the random number generator.</p>
</td></tr>
<tr><td><code>mi.data</code></td>
<td>
<p>the object returned by <code>mi</code>, containing the multiple imputations, and useful, e.g., for diagnostic checking of the imputation process.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>References</h3>

<p>Yu-Sung Su, Andrew Gelman, Jennifer Hill, Masanao Yajima. (2011). 
&ldquo;Multiple imputation with diagnostics (mi) in R: Opening windows into the black box.&rdquo; 
<em>Journal of Statistical Software</em> 45(2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code>, <code>mi</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run:  # because of long execution time
mod.cfa.tests &lt;- cfa(raw=TRUE, text="
verbal: x1, x2, x3
math: y1, y2, y3
")
imps &lt;- miSem(mod.cfa.tests, data=Tests, fixed.x="Intercept", 
              raw=TRUE, seed=12345)
summary(imps, digits=3) 


# introduce some missing data to the HS.data data set:
HS &lt;- HS.data[, c(2,7:10,11:15,20:25,26:30)]
set.seed(12345)
r &lt;- sample(301, 100, replace=TRUE)
c &lt;- sample(2:21, 100, replace=TRUE)
for (i in 1:100) HS[r[i], c[i]] &lt;- NA

mod.hs &lt;- cfa(text="
spatial: visual, cubes, paper, flags
verbal: general, paragrap, sentence, wordc, wordm
memory: wordr, numberr, figurer, object, numberf, figurew
math: deduct, numeric, problemr, series, arithmet
")

mod.mg &lt;- multigroupModel(mod.hs, groups=c("Female", "Male")) 
system.time( # relatively time-consuming!
  imps.mg &lt;- miSem(mod.mg, data=HS, group="Gender", seed=12345)
)
summary(imps.mg, digits=3)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='ML.methods'>
Methods for sem Objects Fit Using the <code>objectiveML</code>, <code>objectiveGLS</code>, <code>objectiveFIML</code>, <code>msemObjectiveML</code>,
and <code>msemObjectiveGLS</code> Objective Functions
</h2><span id='topic+ML.methods'></span><span id='topic+GLS.methods'></span><span id='topic+anova.objectiveML'></span><span id='topic+anova.objectiveFIML'></span><span id='topic+logLik.objectiveML'></span><span id='topic+logLik.objectiveFIML'></span><span id='topic+AIC.objectiveML'></span><span id='topic+AIC.objectiveFIML'></span><span id='topic+AICc.objectiveML'></span><span id='topic+AICc.objectiveFIML'></span><span id='topic+BIC.objectiveML'></span><span id='topic+BIC.objectiveFIML'></span><span id='topic+CAIC.objectiveML'></span><span id='topic+CAIC.objectiveFIML'></span><span id='topic+deviance.objectiveML'></span><span id='topic+deviance.objectiveFIML'></span><span id='topic+print.objectiveML'></span><span id='topic+print.objectiveGLS'></span><span id='topic+print.objectiveFIML'></span><span id='topic+summary.objectiveML'></span><span id='topic+summary.objectiveGLS'></span><span id='topic+summary.objectiveFIML'></span><span id='topic+print.summary.objectiveML'></span><span id='topic+print.msemObjectiveML'></span><span id='topic+print.msemObjectiveGLS'></span><span id='topic+summary.msemObjectiveML'></span><span id='topic+summary.msemObjectiveGLS'></span><span id='topic+deviance.msemObjectiveML'></span><span id='topic+AIC.msemObjectiveML'></span><span id='topic+AICc.msemObjectiveML'></span><span id='topic+BIC.msemObjectiveML'></span><span id='topic+deviance.msemObjectiveML'></span><span id='topic+anova.msemObjectiveML'></span><span id='topic+logLik.msemObjectiveML'></span>

<h3>Description</h3>

<p>These functions are for objects fit by <code><a href="#topic+sem">sem</a></code> using the <code><a href="#topic+objectiveML">objectiveML</a></code> (multivariate-normal full-information maximum-likelihood), <code>link{objectiveFIML}</code> (multivariate-normal full-information maximum-likihood in
the presence of missing data),
<code><a href="#topic+objectiveGLS">objectiveGLS</a></code> (generalized least squares), and <code><a href="#topic+msemObjectiveML">msemObjectiveML</a></code> (multigroup multivariate-normal FIML) objective functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'objectiveML'
anova(object, model.2, robust=FALSE, ...)
## S3 method for class 'objectiveFIML'
anova(object, model.2, ...)

## S3 method for class 'objectiveML'
logLik(object, ...)
## S3 method for class 'objectiveFIML'
logLik(object, saturated=FALSE, 
    intercept="Intercept", iterlim=1000, ...)
## S3 method for class 'objectiveML'
deviance(object, ...)
## S3 method for class 'objectiveFIML'
deviance(object, saturated.logLik, ...)
## S3 method for class 'msemObjectiveML'
deviance(object, ...) 
## S3 method for class 'objectiveML'
AIC(object, ..., k)
## S3 method for class 'objectiveFIML'
AIC(object, saturated.logLik, ..., k)
## S3 method for class 'msemObjectiveML'
AIC(object, ..., k)
## S3 method for class 'objectiveML'
AICc(object, ...)
## S3 method for class 'objectiveFIML'
AICc(object, saturated.logLik, ...)
## S3 method for class 'msemObjectiveML'
AICc(object, ...)
## S3 method for class 'objectiveML'
BIC(object, ...)
## S3 method for class 'objectiveFIML'
BIC(object, saturated.logLik, ...)
## S3 method for class 'msemObjectiveML'
BIC(object, ...)
## S3 method for class 'objectiveML'
CAIC(object, ...)
## S3 method for class 'objectiveFIML'
CAIC(object, saturated.logLik, ...)

## S3 method for class 'objectiveML'
print(x, ...)
## S3 method for class 'objectiveGLS'
print(x, ...)
## S3 method for class 'objectiveFIML'
print(x, saturated=FALSE, ...)
## S3 method for class 'msemObjectiveML'
print(x, ...)
## S3 method for class 'msemObjectiveGLS'
print(x, ...)

## S3 method for class 'objectiveML'
summary(object, digits=getOption("digits"), 
    conf.level=.90, robust=FALSE, analytic.se=object$t &lt;= 500, 
    fit.indices=c("GFI", "AGFI", "RMSEA", "NFI", "NNFI", "CFI", "RNI",
      "IFI", "SRMR", "AIC", "AICc", "BIC", "CAIC"), ...)
## S3 method for class 'objectiveFIML'
summary(object, digits=getOption("digits"), conf.level=.90,
    fit.indices=c("AIC", "AICc", "BIC", "CAIC"),
    saturated=FALSE, intercept="Intercept", saturated.logLik, ...)
## S3 method for class 'objectiveGLS'
summary(object, digits=getOption("digits"), conf.level=.90, 
    fit.indices=c("GFI", "AGFI", "RMSEA", "NFI", "NNFI", "CFI", "RNI", "IFI", "SRMR"),
    ...)
## S3 method for class 'msemObjectiveML'
summary(object, digits=getOption("digits"), 
    conf.level=.90, robust=FALSE, 
    analytic.se=object$t &lt;= 500,
    fit.indices=c("GFI", "AGFI", "RMSEA", "NFI", "NNFI", "CFI", "RNI", 
      "IFI", "SRMR", "AIC", "AICc", "BIC"), ...)
## S3 method for class 'msemObjectiveGLS'
summary(object, digits=getOption("digits"), 
    conf.level=.90,
    fit.indices=c("GFI", "AGFI", "RMSEA", "NFI", "NNFI", 
      "CFI", "RNI", "IFI", "SRMR"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ML.methods_+3A_object">object</code>, <code id="ML.methods_+3A_model.2">model.2</code>, <code id="ML.methods_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>objectiveML</code>, <code>objectiveGLS</code>, 
<code>objectiveFIML</code>, <code>msemObjectiveML</code>, or <code>msemObjectiveGLS</code>.</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code>, compute robust standard errors or test.</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_fit.indices">fit.indices</code></td>
<td>
<p>a character vector of &ldquo;fit indices&rdquo; to report; the allowable values are those given in <b>Usage</b>
above, and vary by the objective function. If the argument isn't given then the fit indices reported are taken
from the R <code>fit.indices</code> option; if this option isn't set, then only the AIC and BIC are reported for models fit
with <code>objectiveML</code>, <code>objectiveFIML</code>, or <code>msemObjectiveML</code>, and no fit indices are reported for
models fit with <code>objectiveGLS</code> or <code>msemObjectiveGLS</code>.</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_k">k</code>, <code id="ML.methods_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_digits">digits</code></td>
<td>
<p>digits to be printed.</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_conf.level">conf.level</code></td>
<td>
<p>level for confidence interval for the RMSEA index (default is .9).</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_analytic.se">analytic.se</code></td>
<td>
<p>use analytic (as opposed to numeric) coefficient standard errors; default is <code>TRUE</code>
where analytic standard errors are available if there are no more than
100 parameters in the model and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_saturated">saturated</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>); compute the log-likelihood (and statistics that
depend on it) for the saturated model when the objective function is FIML in the presence of missing data. 
This can be computationally costly.</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_intercept">intercept</code></td>
<td>
<p>the name of the intercept regressor in the raw data, to be used in calculating the
saturated log-likelihood for the FIML estimator; the default is <code>"Intercept"</code>.</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_saturated.loglik">saturated.logLik</code></td>
<td>
<p>the log-likelihood for the saturated model, as returned by <code>logLik</code>
with <code>saturated=TRUE</code>; if absent, this will be computed and the computation can be time-consuming.</p>
</td></tr>
<tr><td><code id="ML.methods_+3A_iterlim">iterlim</code></td>
<td>
<p>iteration limit used by the <code>nlm</code> optimizer to compute the saturated log-likelihood for
the FIML estimator with missing data; defaults to <code>1000</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a> and Jarrett Byrnes</p>


<h3>References</h3>

<p>See <code><a href="#topic+sem">sem</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code>, <code><a href="#topic+objective.functions">objective.functions</a></code>, <code><a href="#topic+modIndices.objectiveML">modIndices.objectiveML</a></code> 
</p>

<hr>
<h2 id='modIndices'>Modification Indices for Structural Equation Models</h2><span id='topic+modIndices'></span><span id='topic+modIndices.objectiveML'></span><span id='topic+modIndices.msemObjectiveML'></span><span id='topic+print.modIndices'></span><span id='topic+print.msemModIndices'></span><span id='topic+summary.modIndices'></span><span id='topic+summary.msemModIndices'></span>

<h3>Description</h3>

<p><code>mod.indices</code> calculates modification indices (score tests) 
and estimated parameter changes for the fixed and constrained 
parameters in a structural equation model fit by multinormal maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'objectiveML'
modIndices(model, duplicated, deviance=NULL, ...)
## S3 method for class 'msemObjectiveML'
modIndices(model, ...)

## S3 method for class 'modIndices'
print(x, n.largest=5, ...)
## S3 method for class 'msemModIndices'
print(x, ...)

## S3 method for class 'modIndices'
summary(object, round=2, 
    print.matrices=c("both", "par.change", "mod.indices"), ...)
## S3 method for class 'msemModIndices'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modIndices_+3A_model">model</code></td>
<td>
<p>an object of class <code>objectiveML</code> or <code>msemObjectiveML</code>,
produced by the <code><a href="#topic+sem">sem</a></code> function.</p>
</td></tr>
<tr><td><code id="modIndices_+3A_object">object</code>, <code id="modIndices_+3A_x">x</code></td>
<td>
<p>an object of class <code>modIndices</code> or <code>msemModIndices</code>, produced by the 
<code>modIndices</code> function.</p>
</td></tr>
<tr><td><code id="modIndices_+3A_n.largest">n.largest</code></td>
<td>
<p>number of modification indices to print in each of the <code class="reqn">A</code> and
<code class="reqn">P</code> matrices of the RAM model.</p>
</td></tr>
<tr><td><code id="modIndices_+3A_round">round</code></td>
<td>
<p>number of places to the right of the decimal point in printing 
modification indices.</p>
</td></tr>
<tr><td><code id="modIndices_+3A_print.matrices">print.matrices</code></td>
<td>
<p>which matrices to print: estimated changes in the fixed parameters,
modification indices, or both (the default).</p>
</td></tr>
<tr><td><code id="modIndices_+3A_duplicated">duplicated</code>, <code id="modIndices_+3A_deviance">deviance</code></td>
<td>
<p>for internal use.</p>
</td></tr>
<tr><td><code id="modIndices_+3A_...">...</code></td>
<td>
<p>arguments to be passed down.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modification indices are one-df chi-square score (&ldquo;Lagrange-multiplier&rdquo;) test statistics for the fixed and constrained
parameters in a structural equation model. They may be regarded as an estimate of the improvement
in the likelihood-ratio chi-square statistic for the model if the corresponding parameter is
respecified as a free parameter. The <code>modIndices</code> function also estimates the change in the
value of a fixed or constrained parameter if the parameter is respecified as free. When several
parameters are set equal, modification indices and estimated changes are given for all but the first.
Modification indices and estimated parameter changes for currently free parameters are given as
<code>NA</code>.
</p>
<p>The method employed is described in Saris, Satorra, and Sorbom (1987) and Sorbom (1989).
</p>


<h3>Value</h3>

<p><code>modIndices</code> returns an object of class <code>modIndices</code> with the following elements:
</p>
<table>
<tr><td><code>mod.A</code></td>
<td>
<p>modification indices for the elements of the <code class="reqn">A</code> matrix.</p>
</td></tr>
<tr><td><code>mod.P</code></td>
<td>
<p>modification indices for the elements of the <code class="reqn">P</code> matrix.</p>
</td></tr>
<tr><td><code>par.A</code></td>
<td>
<p>estimated parameter changes for the elements of the <code class="reqn">A</code> matrix.</p>
</td></tr>
<tr><td><code>par.P</code></td>
<td>
<p>estimated parameter changes for the elements of the <code class="reqn">P</code> matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a> and Michael Culbertson</p>


<h3>References</h3>

<p>Sarris, W. E., Satorra, A., and Sorbom, D. (1987)
The detection and correction of specification errors in structural
equation models. Pp. 105&ndash;129 in Clogg, C. C. (ed.), <em>Sociological Methodology 1987.</em>
American Sociological Association.
</p>
<p>Sorbom, D. (1989)
Model modification.
<em>Psychometrika</em> <b>54</b>, 371&ndash;384.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># In the first example, readMoments() and specifyModel() read from the
# input stream. This example cannot be executed via example() but can be entered
# at the command prompt. The example is repeated using file input;
# this example can be executed via example(). 
	## Not run: 
# This example is adapted from the SAS manual

S.wh &lt;- readMoments(names=c('Anomia67','Powerless67','Anomia71',
                                    'Powerless71','Education','SEI'))
   11.834                                    
    6.947    9.364                            
    6.819    5.091   12.532                    
    4.783    5.028    7.495    9.986            
   -3.839   -3.889   -3.841   -3.625   9.610     
  -21.899  -18.831  -21.748  -18.775  35.522  450.288

model.wh &lt;- specifyModel()
    Alienation67   -&gt;  Anomia67,      NA,   1
    Alienation67   -&gt;  Powerless67,   NA,   0.833
    Alienation71   -&gt;  Anomia71,      NA,   1
    Alienation71   -&gt;  Powerless71,   NA,   0.833
    SES            -&gt;  Education,     NA,   1     
    SES            -&gt;  SEI,           lamb, NA
    SES            -&gt;  Alienation67,  gam1, NA
    Alienation67   -&gt;  Alienation71,  beta, NA
    SES            -&gt;  Alienation71,  gam2, NA
    Anomia67       &lt;-&gt; Anomia67,      the1, NA
    Anomia71       &lt;-&gt; Anomia71,      the1, NA
    Powerless67    &lt;-&gt; Powerless67,   the2, NA
    Powerless71    &lt;-&gt; Powerless71,   the2, NA
    Education      &lt;-&gt; Education,     the3, NA
    SEI            &lt;-&gt; SEI,           the4, NA
    Anomia67       &lt;-&gt; Anomia71,      the5, NA
    Powerless67    &lt;-&gt; Powerless71,   the5, NA
    Alienation67   &lt;-&gt; Alienation67,  psi1, NA
    Alienation71   &lt;-&gt; Alienation71,  psi2, NA
    SES            &lt;-&gt; SES,           phi,  NA

sem.wh &lt;- sem(model.wh, S.wh, 932)
modIndices(sem.wh)
	
## End(Not run)
	
# The following example can be executed via example():

etc &lt;- system.file(package="sem", "etc") # path to data and model files

(S.wh &lt;- readMoments(file=file.path(etc, "S-Wheaton.txt"),
					names=c('Anomia67','Powerless67','Anomia71',
                            'Powerless71','Education','SEI')))
(model.wh &lt;- specifyModel(file=file.path(etc, "model-Wheaton-1.txt")))                    
(sem.wh &lt;- sem(model.wh, S.wh, 932))
modIndices(sem.wh)
</code></pre>

<hr>
<h2 id='objective.functions'>
sem Objective-Function Builders
</h2><span id='topic+objective.functions'></span><span id='topic+objectiveML'></span><span id='topic+objectiveGLS'></span><span id='topic+objectiveFIML'></span><span id='topic+objectiveML2'></span><span id='topic+objectiveGLS2'></span><span id='topic+objectiveFIML2'></span><span id='topic+msemObjectiveML'></span><span id='topic+msemObjectiveML2'></span><span id='topic+msemObjectiveGLS'></span>

<h3>Description</h3>

<p>These functions return objective functions suitable for use with <code><a href="#topic+optimizers">optimizers</a></code> called by <code><a href="#topic+sem">sem</a></code>. The user would not
normally call these functions directly, but rather supply one of them in the <code>objective</code> argument to
<code>sem</code>. Users may also write their own objective functions. <code>objectiveML</code> and <code>objectiveML2</code> are for multinormal maximum-likelihood
estimation; <code>objectiveGLS</code> and <code>objectiveGLS2</code> are for generalized least squares; and <code>objectiveFIML2</code>
is for so-called &ldquo;full-information maximum-likelihood&rdquo; estimation in the presence of missing data. The FIML estimator
provides the same estimates as the ML estimator when there is no missing data; it can be slow because it iterates over
the unique patterns of missing data that occur in the data set.
<code>objectiveML</code> and <code>objectiveGLS</code> use
compiled code and are therefore substantially faster. <code>objectiveML2</code> and <code>objectiveGLS2</code> are provided primarily to illustrate
how to write <code>sem</code> objective functions in R. <code>msemObjectiveML</code> uses compiled code is for fitting multi-group models by 
multinormal maximum likelihood; <code>msemObjectiveML2</code> is similar but doesn't use compiled code. <code>msemObjectiveGLS</code> uses compiled
code and is for fitting multi-group models by generalized least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectiveML(gradient=TRUE, hessian=FALSE)
objectiveML2(gradient=TRUE)

objectiveGLS(gradient=FALSE)
objectiveGLS2(gradient=FALSE)

objectiveFIML(gradient=TRUE, hessian=FALSE)
objectiveFIML2(gradient=TRUE, hessian=FALSE)

msemObjectiveML(gradient=TRUE)
msemObjectiveML2(gradient=TRUE)

msemObjectiveGLS(gradient=FALSE)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objective.functions_+3A_gradient">gradient</code></td>
<td>
<p>If <code>TRUE</code>, the object that's returned includes a function for computing an analytic gradient; there is at present no
analytic gradient available for <code>objectiveFIML</code>, <code>objectiveGLS</code>, <code>objectiveGLS2</code>, or <code>msemObjectiveGL</code>.</p>
</td></tr>
<tr><td><code id="objective.functions_+3A_hessian">hessian</code></td>
<td>
<p>If <code>TRUE</code>, the objected returned includes a function to compute an analytic Hessian; only avaiable for <code>objectiveML</code>
and not generally recommended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return an object of class <code>"semObjective"</code>, with up to two elements:
</p>
<table>
<tr><td><code>objective</code></td>
<td>
<p>an objective function.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>a gradient function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>See <code><a href="#topic+sem">sem</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code>, <code><a href="#topic+optimizers">optimizers</a></code>
</p>

<hr>
<h2 id='optimizers'>sem Optimizers</h2><span id='topic+optimizers'></span><span id='topic+optimizerSem'></span><span id='topic+optimizerNlm'></span><span id='topic+optimizerOptim'></span><span id='topic+optimizerNlminb'></span><span id='topic+optimizerMsem'></span><span id='topic+msemOptimizerNlm'></span>

<h3>Description</h3>

<p>The default optimizer used by <code><a href="#topic+sem">sem</a></code> is <code>optimizerSem</code>, which employs compiled code and is integrated with
the <code><a href="#topic+objectiveML">objectiveML</a></code> and <code><a href="#topic+objectiveGLS">objectiveGLS</a></code> objective functions; 
<code>optimizerSem</code>, written by Zhenghua Nie, is a modified
version of the standard R <code>nlm</code> optimizer, which was written by Saikat DebRoy, R-core, and Richard H. Jones.
The other functions call optimizers (<code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, or <code><a href="stats.html#topic+nlminb">nlminb</a></code>), 
to fit structural equation models, and are called by the <code><a href="#topic+sem">sem</a></code> function. 
The user would not normally call these functions directly, but rather supply one of them in the <code>optimizer</code> argument to
<code>sem</code>. Users may also write them own optimizer functions. <code>msemOptimizerNlm</code> is for fitting multigroup models, and also adapts the <code>nlm</code> code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizerSem(start, objective=objectiveML,  
	gradient=TRUE, maxiter, debug, par.size, model.description, warn, ...)
	
optimizerMsem(start, objective=msemObjectiveML, gradient=TRUE,
	maxiter, debug, par.size, model.description, warn=FALSE, ...)
	
optimizerNlm(start, objective=objectiveML, gradient=TRUE, 
	maxiter, debug, par.size, model.description, warn, ...)
	
optimizerOptim(start, objective=objectiveML, gradient=TRUE, 
	maxiter, debug, par.size, model.description, warn, method="CG", ...)

optimizerNlminb(start, objective=objectiveML, gradient=TRUE, maxiter, 
	debug, par.size, model.description, warn, ...)

msemOptimizerNlm(start, objective=msemObjectiveML, gradient=TRUE,
		maxiter, debug, par.size, model.description, warn=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizers_+3A_start">start</code></td>
<td>
<p>a vector of start values for the parameters.</p>
</td></tr>
<tr><td><code id="optimizers_+3A_objective">objective</code></td>
<td>
<p>the objective function to be optimized; see <a href="#topic+objective.functions">objective.functions</a>.</p>
</td></tr>
<tr><td><code id="optimizers_+3A_gradient">gradient</code></td>
<td>
<p><code>TRUE</code> if an analytic gradient is to be used (if one is available).</p>
</td></tr>
<tr><td><code id="optimizers_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="optimizers_+3A_debug">debug</code></td>
<td>
<p><code>TRUE</code> to show the iteration history and other available information about the optimization.</p>
</td></tr>
<tr><td><code id="optimizers_+3A_par.size">par.size</code></td>
<td>
<p><code>"startvalues"</code> to have the optimizer scale the problem according to the magitudes of the start values (ignored by <code>optimizerNlminb</code>).</p>
</td></tr>
<tr><td><code id="optimizers_+3A_model.description">model.description</code></td>
<td>
<p>a list with elements describing the structural-equation model (see the code for details).</p>
</td></tr>
<tr><td><code id="optimizers_+3A_warn">warn</code></td>
<td>
<p>if <code>FALSE</code>, suppress warnings during the optimization.</p>
</td></tr>
<tr><td><code id="optimizers_+3A_method">method</code></td>
<td>
<p>the method to be employed by the <code><a href="stats.html#topic+optim">optim</a></code> optimizer; the default is <code>"CG"</code> (conjugate-gradient).</p>
</td></tr>
<tr><td><code id="optimizers_+3A_...">...</code></td>
<td>
<p>additional arguments for the <code>nlm</code>, <code>optim</code>, or <code>nlminb</code> optimizer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"semResult"</code>, with elements:
</p>
<table>
<tr><td><code>convergence</code></td>
<td>
<p><code>TRUE</code> if the optimization apparently converged.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations required.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>the vector of parameter estimates.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the estimated covariance matrix of the parameter estimates, based on a numeric Hessian; not supplied by <code>optimizerNlminb</code>.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>the optimized value of the objective function.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>the model-implied covariance or moment matrix at the parameter estimates.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>the estimated <code class="reqn">A</code> matrix.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>the estimated <code class="reqn">P</code> matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, and Zhenghua Nie, in part adapting work by
Saikat DebRoy, R-core, and Richard H. Jones.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code>, <code><a href="#topic+objective.functions">objective.functions</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code></p>

<hr>
<h2 id='pathDiagram'>Draw Path Diagram</h2><span id='topic+pathDiagram'></span><span id='topic+pathDiagram.sem'></span><span id='topic+pathDiagram.semmod'></span><span id='topic+math'></span>

<h3>Description</h3>

<p><code>pathDiagram</code> creates a description of the path diagram
for a structural-equation-model or SEM-specification object to be processed by the
graph-drawing program <em>dot</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathDiagram(model, ...)

## S3 method for class 'sem'
pathDiagram(model, file = "pathDiagram", 
    style = c("ram", "traditional"),
    output.type = c("html", "graphics", "dot"), graphics.fmt = "pdf", 
    dot.options = NULL,
    size = c(8, 8), node.font = c("Helvetica", 14),
    edge.font = c("Helvetica", 10), digits = 2, 
    rank.direction = c("LR", "TB"),
    min.rank = NULL, max.rank = NULL, same.rank = NULL,
    variables = model$var.names, var.labels, parameters, par.labels,
    ignore.double = TRUE, ignore.self = FALSE, error.nodes = TRUE,
    edge.labels = c("names", "values", "both"),  
    edge.colors = c("black", "black"),
    edge.weight = c("fixed", "proportional"),
    node.colors = c("transparent", "transparent", "transparent"),
    standardize = FALSE, ...)

## S3 method for class 'semmod'
pathDiagram(model, obs.variables, ...)

math(text, html.only=FALSE, hat=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathDiagram_+3A_model">model</code></td>
<td>
<p>a structural-equation-model or SEM-specification object produced by <code>sem</code>, 
or, respectively, <code>specifyEquations</code>, <code>specifyModel</code>, or <code>cfa</code>.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_...">...</code></td>
<td>
<p>arguments passed down, e.g., from the <code>semmod</code> method to the <code>sem</code> method.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_file">file</code></td>
<td>
<p>a file name, by default <code>"pathDiagram"</code>, 
given <em>without</em> an extension, to which to write the <em>dot</em> description of the
path diagram if <code>output.type</code> <code>"graphics"</code> or <code>"dot"</code> is selected, and for the
graphics output file (with appropriate extension) if <code>"graphics"</code> output is selected, in which case
a &quot;<code>.dot</code>&quot; file and a graphics file of type specified by the <code>graphics.fmt</code> argument (below);
<code>file</code> may include a path specification.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_style">style</code></td>
<td>
<p><code>"ram"</code> (the default) for a RAM path diagram including self-directed double-headed arrows
representing variances, including error variances; or <code>"traditional"</code> for a path diagram 
including nodes representing error variables.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_output.type">output.type</code></td>
<td>
<p>if <code>"html"</code> (the default), the path diagram will open in the user&quot;s default 
web browser; if <code>"dot"</code>, a file containing <em>dot</em> commands will be written; if <code>"graphics"</code>,
both <code>.dot</code> and graphics files will be written.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_graphics.fmt">graphics.fmt</code></td>
<td>
<p>a graphics format recognized by the <em>dot</em> program; the default is <code>"pdf"</code>;
<code>graphics.fmt</code> is also used for the extension of the graphics file that is created.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_dot.options">dot.options</code></td>
<td>
<p>options to be passed to the <em>dot</em> program, given as a character string.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_size">size</code></td>
<td>
<p>the size of the graph, in inches.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_node.font">node.font</code></td>
<td>
<p>font name and point-size for printing variable names.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_edge.font">edge.font</code></td>
<td>
<p>font name and point-size for printing arrow names or values.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_digits">digits</code></td>
<td>
<p>number of digits after the decimal point (default, 2) to which 
to round parameter estimates.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_rank.direction">rank.direction</code></td>
<td>
<p>draw graph left-to-right, <code>"LR"</code>, the default, 
or top-to-bottom, <code>"TB"</code>.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_min.rank">min.rank</code></td>
<td>
<p>a character string listing names of variables to be assigned
minimum rank (order) in the graph; the names should be separated by commas.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_max.rank">max.rank</code></td>
<td>
<p>a character string listing names of variables to be assigned
maximum rank in the graph; the names should be separated by commas.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_same.rank">same.rank</code></td>
<td>
<p>a character string or vector of character strings of variables
to be assigned equivalent rank in the graph; names in each string should be
separated by commas.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_variables">variables</code></td>
<td>
<p>variable names; defaults to the variable names in <code>model</code>.
If specified, the variable names should be in the same order as in <code>model</code>.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_var.labels">var.labels</code></td>
<td>
<p>a character vector with labels to be used 
in lieu of (some of) the variables names, for greater flexibility
in labelling nodes in the graph &mdash; e.g., the labels can be created with the <code>math</code>
function. The elements of the vector must have names corresponding to variables in the model.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_parameters">parameters</code></td>
<td>
<p>parameter names; defaults to the parameter names in 
<code>model</code>. If specified, the parameter names should be in the same order 
as in <code>model</code>.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_par.labels">par.labels</code></td>
<td>
<p>a character vector with labels to be used 
in lieu of (some of) the parameter names, for greater flexibility
in labelling edges in the graph &mdash; e.g., the labels can be created with the <code>math</code>
function. The elements of the vector must have names corresponding to parameters in the model.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_ignore.double">ignore.double</code></td>
<td>
<p>if <code>TRUE</code>, the default, double-headed arrows, representing
variances and covariances, are not graphed.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_ignore.self">ignore.self</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), and <code>ignore.double=FALSE</code>,
self-directed double-headed arrows representing error variances are suppressed; note that
if <code>ignore.double=TRUE</code>, <em>all</em> double-headed arrows, including self-directed arrows,
are suppressed.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_error.nodes">error.nodes</code></td>
<td>
<p>if <code>TRUE</code> (the default) and <code>style="traditional"</code>, show the nodes
representing error variables.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_edge.labels">edge.labels</code></td>
<td>
<p><code>"names"</code> to label arrows with parameter names; 
<code>"values"</code> to label arrows with parameter estimates, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_edge.colors">edge.colors</code></td>
<td>
<p>two-element character vector giving colors of positive
and negative arrows respectively; the default is <code>c("black", "black")</code>.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_edge.weight">edge.weight</code></td>
<td>
<p>if <code>"proportional"</code> (the default is <code>"fixed"</code>), the thickness of
edges is proportional to the absolute size of the corresponding parameter estimate;
this is generally sensible only if <code>standardize=TRUE</code>.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_node.colors">node.colors</code></td>
<td>
<p>a two- or three-element character vector giving colors of nodes representing
exogenous, endogenous, and error variables (for traditional path diagrams) consecutively; 
the default is <code>"transparent"</code> for all three; if a two colors are given, error variables
are colored as exogenous (the first color.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_standardize">standardize</code></td>
<td>
<p>if <code>TRUE</code>, display standardized coefficients; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_obs.variables">obs.variables</code></td>
<td>
<p>a character vector with the names of the observed variables in the model.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_text">text</code></td>
<td>
<p>a character string or vector of character strings to be translated into node or edge label symbols.
If a vector of character strings is supplied, then the elements of the vector should be named with the
corresponding variable (node) or parameter (edge) name.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_html.only">html.only</code></td>
<td>
<p>If <code>TRUE</code> (the default is <code>FALSE</code>), the
character strings in <code>text</code> are to be treated as an HTML character codes, in
which case the prefix <code>"#"</code> and suffix <code>";"</code> are appended to each. Otherwise, <code>text</code> should
only contain the names of lowercase or uppercase Greek letters, such as <code>"alpha"</code> or <code>"Alpha"</code>.
The full set of Greek letters recognized is given in the file <code>Greek.txt</code> in the package's
<code>etc</code> subdirectory &ndash; or type <code>sem:::Greek</code> at the R command prompt.
In either case, the symbols may be followed by numeric subscripts in curly braces consisting of numerals 
(e.g., <code>"beta_{12}"</code>),
and/or numeric superscripts (e.g., <code>"sigma^{2}"</code>,
<code>"sigma_{1}^{2}"</code>). Depending upon your OS, subscripts and superscripts may only work properly with HTML output
from <code>pathDiagram</code>, not with graphics output produced by <em>dot</em>.</p>
</td></tr>
<tr><td><code id="pathDiagram_+3A_hat">hat</code></td>
<td>
<p>If <code>TRUE</code> (the default is <code>FALSE</code>), a hat (circumflex) is placed over the
symbols in <code>text</code>; this feature doesn't produce a visually appealing result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pathDiagram</code> creates a description of the path diagram
for a structural-equation-model or SEM-specification object to be processed by the
graph-drawing program <em>dot</em>, which can be called
automatically; see Koutsofios and North (2002)
and <a href="http://www.graphviz.org/">http://www.graphviz.org/</a>. To obtain graphics output
directly, the <em>dot</em> program must be on the system search path. 
</p>
<p>Alternatively, <em>HTML</em> output can be created in a web browser without an independent installation
of <code>dot</code> using facilities in the <span class="pkg">DiagrammeR</span> package.
</p>
<p>The <code>math</code> function can be used to create node (variable) and edge (arrow) labels with
symbols such as Greek letters, subscripts, and superscripts.
</p>
<p>The <code>semmod</code> method of <code>pathDiagram</code> sets up a call to the <code>sem</code> method. 
</p>
<p>The various
arguments to <code>pathDiagram</code> can be used to customize the diagram, but if there are too many constraints
on node placement, <em>dot</em> may fail to produce a graph or may produce a distorted graph. 
<code>pathDiagram</code> can create both RAM-style diagrams, in which variances are represented as self-directed
arrows, and traditional path diagrams, in which error variables appear explicitly as nodes. As is conventional,
latent variables (including error variables) are represented as ellipses and observed variables as 
rectangles; double-headed arrows represent covariances (and in RAM diagrams, variances) and single-headed
arrows represent structural coefficients.
</p>


<h3>Value</h3>

<p><code>pathDiagram</code> invisibly returns a character vector containing <em>dot</em> commands.
<code>math</code> returns a character vector containing suitable <code>HTML</code> markup.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, Adam Kramer, and Michael Friendly</p>


<h3>References</h3>

<p>Koutsofios, E., and North, S. C. (2002)
Drawing graphs with <em>dot</em>.
<a href="https://graphviz.org/documentation/">https://graphviz.org/documentation/</a>.    
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code>, <code><a href="#topic+specifyEquations">specifyEquations</a></code>, <code><a href="#topic+specifyModel">specifyModel</a></code>, <code><a href="#topic+cfa">cfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	if (interactive()) {
# The Duncan, Haller, and Portes Peer-Influences Model

R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"),
                text="
    .6247                                                              
    .3269  .3669                                                        
    .4216  .3275  .6404                                      
    .2137  .2742  .1124  .0839                                
    .4105  .4043  .2903  .2598  .1839                          
    .3240  .4047  .3054  .2786  .0489  .2220                    
    .2930  .2407  .4105  .3607  .0186  .1861  .2707              
    .2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950        
    .0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087  
")

model.dhp &lt;- specifyModel(text="
    RParAsp  -&gt; RGenAsp, gam11,  NA
    RIQ      -&gt; RGenAsp, gam12,  NA
    RSES     -&gt; RGenAsp, gam13,  NA
    FSES     -&gt; RGenAsp, gam14,  NA
    RSES     -&gt; FGenAsp, gam23,  NA
    FSES     -&gt; FGenAsp, gam24,  NA
    FIQ      -&gt; FGenAsp, gam25,  NA
    FParAsp  -&gt; FGenAsp, gam26,  NA
    FGenAsp  -&gt; RGenAsp, beta12, NA
    RGenAsp  -&gt; FGenAsp, beta21, NA
    RGenAsp  -&gt; ROccAsp,  NA,       1
    RGenAsp  -&gt; REdAsp,  lam21,  NA
    FGenAsp  -&gt; FOccAsp,  NA,       1
    FGenAsp  -&gt; FEdAsp,  lam42,  NA
    RGenAsp &lt;-&gt; RGenAsp, ps11,   NA
    FGenAsp &lt;-&gt; FGenAsp, ps22,   NA
    RGenAsp &lt;-&gt; FGenAsp, ps12,   NA
    ROccAsp &lt;-&gt; ROccAsp, theta1, NA
    REdAsp  &lt;-&gt; REdAsp,  theta2, NA
    FOccAsp &lt;-&gt; FOccAsp, theta3, NA
    FEdAsp  &lt;-&gt; FEdAsp,  theta4, NA
")

sem.dhp &lt;- sem(model.dhp, R.DHP, 329,
    fixed.x=c("RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"))
    
pathDiagram(sem.dhp, min.rank="RIQ, RSES, RParAsp, FParAsp, FSES, FIQ", 
                     max.rank="ROccAsp, REdAsp, FEdAsp, FOccAsp",
                     same.rank="RGenAsp, FGenAsp",
                     edge.labels="values")
    
pathDiagram(model.dhp,
    obs.variables=c("RParAsp", "RIQ", "RSES", "FSES", "FIQ", 
        "FParAsp", "ROccAsp", "REdAsp", "FOccAsp", "FEdAsp"),
    style="traditional", 
    node.colors=c("pink", "lightblue", "lightgreen"),
    min.rank="RIQ, RSES, RParAsp, FParAsp, FSES, FIQ",
    max.rank="ROccAsp, REdAsp, FEdAsp, FOccAsp",
    same.rank="RGenAsp, FGenAsp",
    var.labels=c(RParAsp="Respondent Parental Aspiration", 
        RIQ="Respondent IQ",
        RSES="Respondent SES",
        FSES="Friend SES",
        FIQ="Friend IQ",
        FParAsp="Friend Parental Aspiration",
        ROccAsp="Respondent Occupational Aspiration",
        REdAsp="Respondent Educational Aspiration",
        RGenAsp="Respondent General Aspiration",
        FOccAsp="Friend Occupational Aspiration",
        FEdAsp="Friend Educational Aspiration",
        FGenAsp="Friend General Aspiration",
        math(c(RGenAsp.error="xi_{1}",
        FGenAsp.error="xi_{2}",
        ROccAsp.error="epsilon_{1}",
        REdAsp.error="epsilon_{2}",
        FOccAsp.error="epsilon_{3}",
        FEdAsp.error="epsilon_{4}"))),
    par.labels=math(c(gam11="gamma_{11}",
        gam12="gamma_{12}",
        gam13="gamma_{13}",
        gam14="gamma_{14}",
        gam23="gamma_{23}",
        gam24="gamma_{24}",
        gam25="gamma_{25}",
        gam26="gamma_{26}",
        beta12="beta_{12}",
        beta21="beta_{21}",
        lam21="lambda_{21}",
        lam42="lambda_{42}",
        ps11="psi_{11}",
        ps22="psi_{22}",
        ps12="psi_{12}",
        theta1="theta_{1}",
        theta2="theta_{2}",
        theta3="theta_{3}",
        theta4="theta_{4}")))
        
    # the following example contributed by Michael Friendly:
    
union &lt;- readMoments(diag=TRUE,
    names=c('y1', 'y2', 'y3', 'x1', 'x2'), text="
14.610
-5.250  11.017
-8.057  11.087   31.971
-0.482   0.677    1.559   1.021
-18.857  17.861   28.250   7.139  215.662
")

union.mod &lt;- specifyEquations(covs=c("x1, x2"), text="
y1 = gam12*x2
y2 = beta21*y1 + gam22*x2
y3 = beta31*y1 + beta32*y2 + gam31*x1
")

union.sem &lt;- sem(union.mod, union, N=173)

dot &lt;- pathDiagram(union.sem, style="traditional",  
    ignore.double=FALSE, error.nodes=FALSE,
    edge.labels="values", 
    min.rank=c("Years", "Age"), 
    max.rank=c("Sentiment", "Sentiment.error"),
    same.rank=c("Deference, Deference.error", "Activism, Activism.error"),
    variables=c("Deference", "Activism", "Sentiment", "Years", "Age"),
    edge.colors=c("black", "red"),
    node.colors = c("pink", "lightblue"))

cat(paste(dot, collapse="\n")) # dot commands

    }
</code></pre>

<hr>
<h2 id='ram'>RAM Matrix for a Structural-Equation Model</h2><span id='topic+ram'></span>

<h3>Description</h3>

<p>Print the labelled RAM definition matrix for a structural-equation
model fit by <code>sem</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ram(object, digits=getOption("digits"), startvalues=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ram_+3A_object">object</code></td>
<td>
<p>an object of class <code>sem</code> returned by the <code>sem</code> function.</p>
</td></tr>
<tr><td><code id="ram_+3A_digits">digits</code></td>
<td>
<p>number of digits for printed output.</p>
</td></tr>
<tr><td><code id="ram_+3A_startvalues">startvalues</code></td>
<td>
<p>if <code>TRUE</code>, start values for parameters are printed;
otherwise, the parameter estimates are printed; the default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the labelled RAM definition matrix, which is normally
just printed.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ------------- assumes that Duncan, Haller and Portes peer-influences model
# -------------     has been fit and is in sem.dhp

    ## Not run: 
ram(sem.dhp)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='rawMoments'>Compute Raw Moments Matrix</h2><span id='topic+rawMoments'></span><span id='topic+rawMoments.formula'></span><span id='topic+rawMoments.default'></span><span id='topic+cov2raw'></span><span id='topic+print.rawmoments'></span>

<h3>Description</h3>

<p>Computes the &ldquo;uncorrected&rdquo; sum-of-squares-and-products matrix divided by the
number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
rawMoments(formula, data, subset, na.action, 
    contrasts=NULL, ...)

## Default S3 method:
rawMoments(object, na.rm=FALSE, ...)

cov2raw(cov, mean, N, sd)

## S3 method for class 'rawmoments'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawMoments_+3A_object">object</code></td>
<td>
<p>a one-sided model formula or an object coercible to a
numeric matrix.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_formula">formula</code></td>
<td>
<p>a one-sided model formula specifying the model matrix for
which raw moments are to be computed; note that a constant is included
if it is not explicitly suppressed by putting <code>-1</code> in the formula.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the formula. 
By default the variables are taken from the environment from which 
<code>rawMoments</code> is called.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be 
used in computing moments.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the data 
contain <code>NA</code>s. The default is set by the <code>na.action</code> option.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> argument of 
<code><a href="stats.html#topic+model.matrix">model.matrix.default</a></code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="rawMoments_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code>, any data rows with missing data will be removed.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_cov">cov</code></td>
<td>
<p>a covariance or correlation matrix.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_mean">mean</code></td>
<td>
<p>a vector of means.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_n">N</code></td>
<td>
<p>the number of observations on which the covariances or correlations 
are based.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_sd">sd</code></td>
<td>
<p>an optional vector of standard deviations, to be given if <code>cov</code> is a
correlation matrix.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_x">x</code></td>
<td>
<p>an object of class <code>rawmoments</code> to print.</p>
</td></tr>
<tr><td><code id="rawMoments_+3A_...">...</code></td>
<td>
<p>arguments passed down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rawMoments</code> and <code>cov2raw</code> return an object of class <code>rawmoments</code>, 
which is simply a matrix
with an attribute <code>"N"</code> that contains the number of observations on
which the moments are based.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># the following are all equivalent (with the exception of the name of the intercept):

rawMoments(cbind(1, Kmenta))

rawMoments(~ Q + P + D + F + A, data=Kmenta)

Cov &lt;- with(Kmenta, cov(cbind(Q, P, D, F, A)))
cov2raw(Cov, colMeans(Kmenta), nrow(Kmenta))
</code></pre>

<hr>
<h2 id='readMoments'>Input a Covariance, Correlation, or Raw Moment Matrix</h2><span id='topic+readMoments'></span>

<h3>Description</h3>

<p>This functions makes it simpler to input covariance, correlation, and raw-moment 
matrices to be analyzed by the <code><a href="#topic+sem">sem</a></code> function. The matrix
is input in lower-triangular form on as many lines as is convenient, 
omitting the above-diagonal elements. The
elements on the diagonal may also optionally be omitted, in which case they
are taken to be 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMoments(file="", text, diag=TRUE, 
    names=as.character(paste("X", 1:n, sep = "")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMoments_+3A_file">file</code></td>
<td>
<p>The (quoted) file from which to read the moment matrix,
including the path to the file if it is not in the current directory. If
<code>""</code> (the default) and the <code>text</code> argument is absent, 
then the moment matrix is read from the standard
input stream, and is terminated by a blank line.</p>
</td></tr>
<tr><td><code id="readMoments_+3A_text">text</code></td>
<td>
<p>The moment matrix given as a character string, as an alternative
to specifying the <code>file</code> argument or reading the moments from
the input stream &mdash; e.g., when the session is not interactive and there is no
standard input.</p>
</td></tr>
<tr><td><code id="readMoments_+3A_diag">diag</code></td>
<td>
<p>If <code>TRUE</code> (the default), then the input matrix includes
diagonal elements.</p>
</td></tr>
<tr><td><code id="readMoments_+3A_names">names</code></td>
<td>
<p>a character vector containing the names of the variables, to
label the rows and columns of the moment matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a lower-triangular matrix (i.e., with zeroes above the main diagonal)
suitable for input to <code>sem</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"),
                text="
    .6247     
    .3269  .3669       
    .4216  .3275  .6404
    .2137  .2742  .1124  .0839
    .4105  .4043  .2903  .2598  .1839
    .3240  .4047  .3054  .2786  .0489  .2220
    .2930  .2407  .4105  .3607  .0186  .1861  .2707
    .2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950
    .0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087
")   
R.DHP

#the following will work only in an interactive sessions:
    ## Not run: 
R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"))
    .6247     
    .3269  .3669       
    .4216  .3275  .6404
    .2137  .2742  .1124  .0839
    .4105  .4043  .2903  .2598  .1839
    .3240  .4047  .3054  .2786  .0489  .2220
    .2930  .2407  .4105  .3607  .0186  .1861  .2707
    .2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950
    .0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087
    
R.DHP
    
## End(Not run)
</code></pre>

<hr>
<h2 id='residuals.sem'>Residual Covariances for a Structural Equation Model</h2><span id='topic+residuals.sem'></span><span id='topic+residuals.msem'></span><span id='topic+standardizedResiduals'></span><span id='topic+standardizedResiduals.sem'></span><span id='topic+standardizedResiduals.msem'></span><span id='topic+normalizedResiduals'></span><span id='topic+normalizedResiduals.objectiveML'></span><span id='topic+normalizedResiduals.objectiveGLS'></span><span id='topic+normalizedResiduals.msemObjectiveML'></span>

<h3>Description</h3>

<p>These functions compute residual covariances, variance-standardized
residual covariances, and normalized residual covariances
for the observed variables in a structural-equation
model fit by <code>sem</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sem'
residuals(object, ...)
## S3 method for class 'msem'
residuals(object, ...)

## S3 method for class 'sem'
standardizedResiduals(object, ...)
## S3 method for class 'msem'
standardizedResiduals(object, ...)

## S3 method for class 'objectiveML'
normalizedResiduals(object, ...)
## S3 method for class 'objectiveGLS'
normalizedResiduals(object, ...)
## S3 method for class 'msemObjectiveML'
normalizedResiduals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.sem_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>sem</code> or <code>msem</code> returned by the <code><a href="#topic+sem">sem</a></code> function.</p>
</td></tr>
<tr><td><code id="residuals.sem_+3A_...">...</code></td>
<td>
<p>not for the user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals are defined as <code class="reqn">S - C</code>, where <code class="reqn">S</code> is the sample covariance matrix
of the observed variables and <code class="reqn">C</code> is the model-reproduced covariance matrix.
The <em>standardized</em> residual covariance for a pair of variables divides the
residual covariance by the product of the sample standard deviations of the 
two variables, <code class="reqn">(s_{ij} - c_{ij})/(s_{ii}s_{jj})^{1/2}</code>. The <em>normalized</em> residual
is given by
</p>
<p style="text-align: center;"><code class="reqn">\frac{s_{ij}-c_{ij}} {[(c_{ii}c_{jj}-c_{ij}^2)/N^{*}]^{1/2}}</code>
</p>

<p>where <code class="reqn">N^{*}</code> is the number of observations minus one if the model is fit to a
covariance matrix, or the number of observations if it is fit to a raw moment matrix.
</p>


<h3>Value</h3>

<p>Each function returns a matrix of residuals.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Bollen, K. A. (1989) 
<em>Structural Equations With Latent Variables.</em> Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># In the first example, readMoments() and specifyModel() read from the
# input stream. This example cannot be executed via example() but can be entered
# at the command prompt. The example is repeated using file input;
# this example can be executed via example(). 
    ## Not run: 
# Duncan, Haller, and Portes peer-influences model

R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"))
    .6247     
    .3269  .3669       
    .4216  .3275  .6404
    .2137  .2742  .1124  .0839
    .4105  .4043  .2903  .2598  .1839
    .3240  .4047  .3054  .2786  .0489  .2220
    .2930  .2407  .4105  .3607  .0186  .1861  .2707
    .2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950
    .0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087
            
model.dhp &lt;- specifyModel()
    RParAsp  -&gt; RGenAsp, gam11,  NA
    RIQ      -&gt; RGenAsp, gam12,  NA
    RSES     -&gt; RGenAsp, gam13,  NA
    FSES     -&gt; RGenAsp, gam14,  NA
    RSES     -&gt; FGenAsp, gam23,  NA
    FSES     -&gt; FGenAsp, gam24,  NA
    FIQ      -&gt; FGenAsp, gam25,  NA
    FParAsp  -&gt; FGenAsp, gam26,  NA
    FGenAsp  -&gt; RGenAsp, beta12, NA
    RGenAsp  -&gt; FGenAsp, beta21, NA
    RGenAsp  -&gt; ROccAsp,  NA,     1
    RGenAsp  -&gt; REdAsp,  lam21,  NA
    FGenAsp  -&gt; FOccAsp,  NA,     1
    FGenAsp  -&gt; FEdAsp,  lam42,  NA
    RGenAsp &lt;-&gt; RGenAsp, ps11,   NA
    FGenAsp &lt;-&gt; FGenAsp, ps22,   NA
    RGenAsp &lt;-&gt; FGenAsp, ps12,   NA
    ROccAsp &lt;-&gt; ROccAsp, theta1, NA
    REdAsp  &lt;-&gt; REdAsp,  theta2, NA
    FOccAsp &lt;-&gt; FOccAsp, theta3, NA
    FEdAsp  &lt;-&gt; FEdAsp,  theta4, NA

sem.dhp &lt;- sem(model.dhp, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))
residuals(sem.dhp)
normalizedResiduals(sem.dhp) 
standardizedResiduals(sem.dhp) # same as residuals because model is fit to correlations
    
## End(Not run)
# The following example can be executed via example():

etc &lt;- system.file(package="sem", "etc") # path to data and model files
   
(R.DHP &lt;- readMoments(file=file.path(etc, "R-DHP.txt"),
				diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp")))
(model.dhp &lt;- specifyModel(file=file.path(etc, "model-DHP.txt")))
(sem.dhp &lt;- sem(model.dhp, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp')))

residuals(sem.dhp)

normalizedResiduals(sem.dhp) 

standardizedResiduals(sem.dhp)  # same as residuals because model is fit to correlations
</code></pre>

<hr>
<h2 id='sem'>General Structural Equation Models</h2><span id='topic+sem'></span><span id='topic+sem.semmod'></span><span id='topic+sem.default'></span><span id='topic+sem.semmodList'></span><span id='topic+sem.msemmod'></span><span id='topic+startvalues'></span><span id='topic+startvalues2'></span><span id='topic+coef.sem'></span><span id='topic+vcov.sem'></span><span id='topic+df.residual.sem'></span><span id='topic+coef.msem'></span><span id='topic+vcov.msem'></span><span id='topic+df.residual.msem'></span>

<h3>Description</h3>

<p><code>sem</code> fits general structural equation models (with both observed and
unobserved variables). Observed variables are also called <em>indicators</em> or 
<em>manifest variables</em>; unobserved variables are also called <em>factors</em>
or <em>latent variables</em>. Normally, the generic function (<code>sem</code>) is
called directly with a <code>semmod</code> first argument produced by <code><a href="#topic+specifyModel">specifyModel</a></code>,
<code><a href="#topic+specifyEquations">specifyEquations</a></code>, or <code><a href="#topic+cfa">cfa</a></code>, invoking the <code>sem.semmod</code>
method, which in turn sets up a call to the <code>sem.default</code> method; thus, the user
may wish to specify arguments accepted by the <code>semmod</code> and <code>default</code> methods.
Similarly, for a multigroup model, <code>sem</code> would normally be called with a
<code>semmodList</code> object produced by <code><a href="#topic+multigroupModel">multigroupModel</a></code> as its first argument,
and would then generate a call to the code <code>msemmod</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'semmod'
sem(model, S, N, data, 
    raw=identical(na.action, na.pass), obs.variables=rownames(S), 
  	fixed.x=NULL, formula= ~ ., na.action=na.omit, 
    robust=!missing(data), debug=FALSE, 
    optimizer=optimizerSem, objective=objectiveML, ...)
    
## Default S3 method:
sem(model, S, N, raw=FALSE, data=NULL, start.fn=startvalues,
    pattern.number=NULL, valid.data.patterns=NULL,
    use.means=TRUE, param.names, 
  	var.names, fixed.x=NULL, robust=!is.null(data), semmod=NULL, debug=FALSE,
		analytic.gradient=!identical(objective, objectiveFIML), 
        warn=FALSE, maxiter=1000, par.size=c("ones", "startvalues"), 
		start.tol=1E-6, optimizer=optimizerSem, objective=objectiveML, cls, ...)
		
## S3 method for class 'semmodList'
sem(model, S, N, data, raw=FALSE, fixed.x=NULL, 
		robust=!missing(data), formula, group="Group", debug=FALSE, ...)
		
## S3 method for class 'msemmod'
sem(model, S, N, start.fn=startvalues,
        group="Group", groups=names(model), raw=FALSE, fixed.x, 
		param.names, var.names, debug=FALSE, analytic.gradient=TRUE, warn=FALSE,
		maxiter=5000, par.size = c("ones", "startvalues"), start.tol = 1e-06, 
		start=c("initial.fit", "startvalues"), initial.maxiter=1000,
		optimizer = optimizerMsem, objective = msemObjectiveML, ...)
    
startvalues(S, ram, debug=FALSE, tol=1E-6)
startvalues2(S, ram, debug=FALSE, tol=1E-6)

## S3 method for class 'sem'
coef(object, standardized=FALSE, ...)
## S3 method for class 'msem'
coef(object, ...)
## S3 method for class 'sem'
vcov(object, robust=FALSE, 
	analytic=inherits(object, "objectiveML") &amp;&amp; object$t &lt;= 500, ...)
## S3 method for class 'msem'
vcov(object, robust=FALSE, 
    analytic=inherits(object, "msemObjectiveML") &amp;&amp; object$t &lt;= 500, ...)
## S3 method for class 'sem'
df.residual(object, ...)
## S3 method for class 'msem'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sem_+3A_model">model</code></td>
<td>
<p>RAM specification, which is a simple encoding of the path
diagram for the model. The model may be given either in symbolic 
form (as a <code>semmod</code> object, as returned by the <code><a href="#topic+specifyModel">specifyModel</a></code>,  
<code><a href="#topic+specifyEquations">specifyEquations</a></code>, or <code><a href="#topic+cfa">cfa</a></code> function,
or as a character matrix), invoking <code>sem.semmod</code>, which calls <code>sem.default</code> 
after setting up the model,
or (less conveniently) in numeric form, invoking <code>sem.default</code> directly, which is
not recommended (see <b>Details</b> below). The <code>model</code> argument may also be a
multigroup-model specification, as produced by <code><a href="#topic+multigroupModel">multigroupModel</a></code>.</p>
</td></tr>
<tr><td><code id="sem_+3A_s">S</code></td>
<td>
<p>covariance matrix among observed variables; may be input as a symmetric matrix,
or as a lower- or upper-triangular matrix. <code>S</code> may also be a raw (i.e., &ldquo;uncorrected&rdquo;)
moment matrix &mdash; that is, a sum-of-squares-and-products matrix divided by <code>N</code>. This
form of input is useful for fitting models with intercepts, in which case the moment matrix
should include the mean square and cross-products for a unit variable all of whose entries are 1;
of course, the raw mean square for the unit variable is 1. Raw-moment matrices may be computed
by <code><a href="#topic+rawMoments">rawMoments</a></code>. If the <code>ram</code> argument is given in symbolic form, then
the observed-variable covariance or raw-moment matrix may contain variables that do not appear in the model,
in which case a warning is printed. <code>S</code> may also be a list of covariance or moment matrices for each
group in a multigroup model.
As an alternative to specifying <code>S</code> the user may
supply a data frame containing the data for the model (see the argument <code>data</code>).</p>
</td></tr>
<tr><td><code id="sem_+3A_n">N</code></td>
<td>
<p>number of observations on which the covariance matrix is based; for a multigroup model, a vector
of group <code class="reqn">N</code>s.</p>
</td></tr>
<tr><td><code id="sem_+3A_data">data</code></td>
<td>
<p>As a generally preferable alternative to specifying <code>S</code> and 
<code>N</code>, the user may supply a data frame containing the data to which the model is to be fit.
In a multigroup model, the <code>data</code> argument may be a list of data frames or a single data frame;
in the later event, the factor given as the <code>group</code> argument is used to split the data into groups.</p>
</td></tr>
<tr><td><code id="sem_+3A_start.fn">start.fn</code></td>
<td>
<p>a function to compute startvalues for the free parameters of the model;
two functions are supplied, <code>startvalues</code> and a older version, <code>startvalues2</code>,
the first of which is the default.</p>
</td></tr>
<tr><td><code id="sem_+3A_na.action">na.action</code></td>
<td>
<p>a function to process missing data, if raw data are supplied in the <code>data</code> argument.
The default is <code>na.omit</code>, which returns only complete cases; specify <code>na.action=na.pass</code> to
get FIML estimates in the presence of missing data from the <code>objectiveFIML</code> 
and <code>objectiveFIML2</code> objective functions.</p>
</td></tr>
<tr><td><code id="sem_+3A_raw">raw</code></td>
<td>
<p><code>TRUE</code> if <code>S</code> is a raw moment matrix or if a raw moment matrix &mdash;  as
opposed to a covariance matrix &mdash; is to be
computed from <code>data</code>; the default is <code>FALSE</code> unless the <code>na.action</code> argument
is set to <code>na.pass</code>.</p>
</td></tr>
<tr><td><code id="sem_+3A_pattern.number">pattern.number</code>, <code id="sem_+3A_valid.data.patterns">valid.data.patterns</code></td>
<td>
<p>these arguments pass information about valid (i.e.,
non-missing) data patterns and normally would not be specified directly by the user.</p>
</td></tr>
<tr><td><code id="sem_+3A_use.means">use.means</code></td>
<td>
<p>When raw data are supplied and intercepts are included in the model, use the
observed-variable means as start values for the intercepts; the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sem_+3A_obs.variables">obs.variables</code></td>
<td>
<p>names of observed variables, by default taken from the row names of
the covariance or moment matrix <code>S</code>, which may be given directly or generated according to the
<code>data</code> and <code>formula</code> arguments.</p>
</td></tr>
<tr><td><code id="sem_+3A_fixed.x">fixed.x</code></td>
<td>
<p>names (if the <code>ram</code> matrix is given in symbolic form) or indices 
(if it is in numeric form) of fixed exogenous variables. Specifying these obviates
the necessity of having to fix the variances and covariances among these 
variables (and produces correct degrees of freedom for the model chisquare).</p>
</td></tr>
<tr><td><code id="sem_+3A_formula">formula</code></td>
<td>
<p>a one-sided formula, to be applied to <code>data</code> to generate the variables for
which covariances or raw moments are computed. The default formula is <code>~.</code>, i.e., all of the
variables in the data, including an implied intercept; if a covariance matrix is to be computed,
the constant is suppressed. In a multigroup model, alternatively a list one one-sided formulas as be
given, to be applied individually to the groups.</p>
</td></tr>
<tr><td><code id="sem_+3A_robust">robust</code></td>
<td>
<p>In <code>sem</code>: if <code>TRUE</code>, then quantities are calculated that can be used to compute robust
estimates of coefficient standard errors and robust tests when the model is fit by multinormal maximum likelihood;
the default is <code>TRUE</code> when the <code>data</code> argument is <code>TRUE</code>, and this option is only
available when the <code>data</code> argument is given. In <code>vcov</code>: if <code>TRUE</code>, return a robust coefficient covariance matrix
(if <code>object</code> contains the requisite information).</p>
</td></tr>
<tr><td><code id="sem_+3A_semmod">semmod</code></td>
<td>
<p>a <code>semmod</code> object containing the description of the model; optional, and normally supplied
not directly by the user but via the <code>semmod</code> method for <code>sem</code>.</p>
</td></tr>
<tr><td><code id="sem_+3A_debug">debug</code></td>
<td>
<p>if <code>TRUE</code>, some information is printed to help you debug the symbolic
model specification; for example, if a variable name is misspelled, <code>sem</code> will
assume that the variable is a (new) latent variable. Information about
the optimization will also be printed, but details will vary with the optimizer employed. 
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sem_+3A_...">...</code></td>
<td>
<p>arguments to be passed down, including from <code>sem.default</code> to the 
optimizer.</p>
</td></tr>
<tr><td><code id="sem_+3A_param.names">param.names</code></td>
<td>
<p>names of the <code class="reqn">t</code> free parameters, given in their numerical order;
default names are <code>Param1</code>, ..., <code>Param</code><em>t</em>. Note: Should not be
specified when the model is given in symbolic form.</p>
</td></tr>
<tr><td><code id="sem_+3A_var.names">var.names</code></td>
<td>
<p>names of the <code class="reqn">m</code> entries of the <code class="reqn">v</code> vector
(typically the observed and latent variables &mdash; see below), given in their
numerical order; default names are <code>Var1</code>, ..., <code>Var</code><em>m</em>.
Note: Should not be specified when the model is given in symbolic form.</p>
</td></tr>
<tr><td><code id="sem_+3A_analytic.gradient">analytic.gradient</code></td>
<td>
<p>if <code>TRUE</code> (the default, except for the <code>objectiveFIML</code> objective function,
where, at present, an analytic gradient slows down the computation), then analytic first derivatives are
used in the maximization of the likelihood if the optimzer employed will accept them; 
otherwise numeric derivatives are used, again if the optimizer will compute them.</p>
</td></tr>
<tr><td><code id="sem_+3A_warn">warn</code></td>
<td>
<p>if <code>TRUE</code>, warnings produced by the optimization function will be printed.
This should generally not be necessary, since <code>sem</code> prints its own warning, and saves
information about convergence. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sem_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations for the optimization of the objective function,
to be passed to the optimizer.</p>
</td></tr>
<tr><td><code id="sem_+3A_par.size">par.size</code></td>
<td>
<p>the anticipated size of the free parameters; if <code>"ones"</code>,
a vector of ones is used; if <code>"startvalues"</code>, taken from the start values.
You can try changing this argument if you encounter convergence problems.
The default is <code>"startvalues"</code> if the largest input variance is at
least 100 times the smallest, and <code>"ones"</code> otherwise. Whether this argument is actually
used depends upon the optimizer employed.</p>
</td></tr>
<tr><td><code id="sem_+3A_start.tol">start.tol</code>, <code id="sem_+3A_tol">tol</code></td>
<td>
<p>if the magnitude of an automatic start value is less than <code>start.tol</code>, then
it is set to <code>start.tol</code>; defaults to 1E-6.</p>
</td></tr>
<tr><td><code id="sem_+3A_optimizer">optimizer</code></td>
<td>
<p>a function to be used to minimize the objective function; the default for single-group models is 
<code><a href="#topic+optimizerSem">optimizerSem</a></code>.
Alternatives are <code><a href="stats.html#topic+nlm">nlm</a></code>, which employs the standard R optimizer <code><a href="stats.html#topic+nlm">nlm</a></code>;
<code><a href="#topic+optimizerOptim">optimizerOptim</a></code>, which employs <code><a href="stats.html#topic+optim">optim</a></code>;
and <code><a href="#topic+optimizerNlminb">optimizerNlminb</a></code>, which uses <code><a href="stats.html#topic+nlminb">nlminb</a></code> &mdash; or
the user can supply an optimizer. For multigroup model, the default is <code><a href="#topic+optimizerMsem">optimizerMsem</a></code>, and
<code><a href="#topic+msemOptimizerNlm">msemOptimizerNlm</a></code>, based on <code>nlm</code>, is provided as an alternative.</p>
</td></tr>
<tr><td><code id="sem_+3A_objective">objective</code></td>
<td>
<p>An objective function to be minimized, sometimes called a &ldquo;fit&rdquo; function 
in the SEM literature. The default for single-group models is <code><a href="#topic+objectiveML">objectiveML</a></code>,
which produces maximum-likelihood estimates assuming multinormality. An alternative is 
<code><a href="#topic+objectiveGLS">objectiveGLS</a></code>, which produced generalized least squares estimates &mdash; or the user
can supply an objective function to be minimized. For multigroup models, the default is
available is <code><a href="#topic+msemObjectiveML">msemObjectiveML</a></code> for ML estimates and an alternative is <code><a href="#topic+msemObjectiveGLS">msemObjectiveGLS</a></code>
for GLS estiamtes.</p>
</td></tr>
<tr><td><code id="sem_+3A_cls">cls</code></td>
<td>
<p>primary class to be assigned to the result; normally this is not specified directly, but
raither is inferred from the objective function.</p>
</td></tr>
<tr><td><code id="sem_+3A_ram">ram</code></td>
<td>
<p>numeric RAM matrix.</p>
</td></tr>
<tr><td><code id="sem_+3A_object">object</code></td>
<td>
<p>an object of class <code>"sem"</code> or <code>"msem"</code>, returned by <code>sem</code>.</p>
</td></tr>
<tr><td><code id="sem_+3A_standardized">standardized</code></td>
<td>
<p>if <code>TRUE</code>, return standardized coefficients.</p>
</td></tr>
<tr><td><code id="sem_+3A_analytic">analytic</code></td>
<td>
<p>return an analytic (as opposed to numeric) estimate of the coefficient covariance matrix;
at present only available for the <code><a href="#topic+objectiveML">objectiveML</a></code> objective function. The default is <code>FALSE</code>
for this objective function if there are no more than 100 parameters and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="sem_+3A_group">group</code></td>
<td>
<p>for a multigroup model, the quoted name of the group variable; if the <code>data</code> argument is given,
snd is a single data frame, then this should be a factor in the data set or a variable coercible to a factor,
to be used to split the data into groups; otherwise, the name is arbitrary.</p>
</td></tr>
<tr><td><code id="sem_+3A_groups">groups</code></td>
<td>
<p>a character vector giving the names of the groups; will be ignored if <code>group</code> is a factor
in <code>data</code>.</p>
</td></tr>
<tr><td><code id="sem_+3A_start">start</code></td>
<td>
<p>if <code>"initial.fit"</code> (the default), start values 
for a multi-group model are computed by first fitting the intra-group models separately by group;
if <code>"startvalues"</code>, then start values are computed as for a single-group model.
In some cases, the intra-group models may not be identified even if the multi-group model is, and
then <code>start="initial.fit"</code> should not be used.</p>
</td></tr>
<tr><td><code id="sem_+3A_initial.maxiter">initial.maxiter</code></td>
<td>
<p>if <code>start="initial.fit"</code> for a multi-group model, then
<code>initial.maxiter</code> gives the maximum number of iterations for each initial intra-group fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is set up using either RAM (&ldquo;reticular action model&rdquo; &ndash; don't ask!) 
notation &ndash; a simple format
for specifying general structural equation models by coding the
&ldquo;arrows&rdquo; in the path diagram for the model (see, e.g., McArdle and McDonald, 1984) &ndash;
typically using the <code><a href="#topic+specifyModel">specifyModel</a></code> function; in equation format using the
<code><a href="#topic+specifyEquations">specifyEquations</a></code> function; or, for a simple confirmatory factor analysis model,
via the <code><a href="#topic+cfa">cfa</a></code> function. In any case, the model is represented internally in RAM format.
</p>
<p>The variables in the <code class="reqn">v</code> vector in the model (typically, the observed and
unobserved variables, but not error variables) are numbered from 1 to <code class="reqn">m</code>.  
the RAM matrix contains one row for each (free or constrained) parameter of the model, and
may be specified either in symbolic format or in numeric format.
</p>
<p>A symbolic <code>ram</code> matrix consists of three columns, as follows:
</p>

<dl>
<dt>1. Arrow specification:</dt><dd><p>This is a simple formula, of the form
<code>"A -&gt; B"</code> or, equivalently, <code>"B &lt;- A"</code> for a regression
coefficient (i.e., a single-headed or directional arrow); 
<code>"A &lt;-&gt; A"</code> for a variance or <code>"A &lt;-&gt; B"</code> for a covariance
(i.e., a double-headed or bidirectional arrow). Here, <code>A</code> and
<code>B</code> are variable names in the model. If a name does not correspond
to an observed variable, then it is assumed to be a latent variable.
Spaces can appear freely in an arrow specification, and
there can be any number of hyphens in the arrows, including zero: Thus,
e.g., <code>"A-&gt;B"</code>, <code>"A --&gt; B"</code>, and <code>"A&gt;B"</code> are all legitimate
and equivalent.</p>
</dd>
<dt>2. Parameter name:</dt><dd><p>The name of the regression coefficient, variance,
or covariance specified by the arrow. Assigning the same name to two or
more arrows results in an equality constraint. Specifying the parameter name
as <code>NA</code> produces a fixed parameter.</p>
</dd>
<dt>3. Value:</dt><dd><p>start value for a free parameter or value of a fixed parameter.
If given as <code>NA</code>, <code>sem</code> will compute the start value.</p>
</dd>
</dl>

<p>It is simplest to construct the RAM matrix with the <code><a href="#topic+specifyModel">specifyModel</a></code>, <code><a href="#topic+specifyEquations">specifyEquations</a></code>,
or <code><a href="#topic+cfa">cfa</a></code> function,
all of which return an object of class <code>semmod</code>, and also incorporate some model-specification
convenience shortcuts. This process is illustrated in the examples below. 
</p>
<p>A numeric <code>ram</code> matrix consists of five columns, as follows:
</p>

<dl>
<dt>1. Number of arrow heads:</dt><dd><p>1 (directed arrow) or 2 (covariance).</p>
</dd>
<dt>2. Arrow <em>to</em>:</dt><dd><p>index of the variable at the head of
a directional arrow, or at one end of a bidirectional arrow.
Observed variables should be assigned the numbers 1 to <code class="reqn">n</code>, where
<code class="reqn">n</code> is the number of rows/columns in the covariance matrix <code>S</code>,
with the indices corresponding to the variables' positions in <code>S</code>.
Variable indices above <code class="reqn">n</code> represent latent variables.</p>
</dd>
<dt>3. Arrow <em>from</em>:</dt><dd><p>the index of the variable at the tail of 
a directional arrow, or at the other end of a bidirectional arrow.</p>
</dd>
<dt>4. Parameter number:</dt><dd><p>free parameters are numbered from 1 to <code class="reqn">t</code>,
but do not necessarily appear in consecutive order. Fixed parameters are given
the number 0. Equality contraints are specified by assigning two or more 
parameters the same number.</p>
</dd>
<dt>5. Value:</dt><dd><p>start value for a free parameter, or value of a fixed parameter. If given
as <code>NA</code>, the program will compute a start value, by a slight modification of the
method described by McDonald and Hartmann (1992). <em>Note:</em> In some circumstances,
some start values are selected randomly; this might produce small differences in
the parameter estimates when the program is rerun.</p>
</dd>
</dl>

<p>The numeric <code>ram</code> matrix is normally generated automatically, not specified directly by the user.
</p>
<p>For <code>specifyEquations</code>, each input line is either a regression equation or the specification
of a variance or covariance. Regression equations are of the form
</p>
<p><code>y = par1*x1 + par2*x2 + ... + park*xk</code>
</p>
<p>where <code>y</code> and the <code>x</code>s are variables in the model (either observed or latent),
and the <code>par</code>s are parameters. If a parameter is given as a numeric value (e.g.,
<code>1</code>) then it is treated as fixed. Note that no &ldquo;error&rdquo; variable is included in
the equation; &ldquo;error variances&rdquo; are specified via either the <code>covs</code> argument,
via <code>V(y) = par</code> (see immediately below), or are added automatically to the model
when, as by default, <code>endog.variances=TRUE</code>.
</p>
<p>Variances are specified in the form <code>V(var) = par</code> and covariances in the form
<code>C(var1, var2) = par</code>, where the <code>var</code>s are variables (observed or unobserved) in
the model. The symbols <code>V</code> and <code>C</code> may be in either lower- or upper-case. If <code>par</code>
is a numeric value (e.g., <code>1</code>) then it is treated as fixed. In conformity with the RAM model,
a variance or covariance for an endogenous variable in the model is an &ldquo;error&rdquo; variance or
covariance.
</p>
<p>To set a start value for a free parameter, enclose the numeric start value in parentheses after the
parameter name, as <code>parameter(value)</code>.
</p>
<p><code>sem</code> fits the model by calling the optimizer specified in the <code>optimizer</code> argument
to minimize the objective function specified in the <code>objective</code> argument.
If the optimization fails to converge, a warning message is printed.
</p>
<p>The RAM formulation of the general structural equation model is given by the basic equation
</p>
<p style="text-align: center;"><code class="reqn">v = Av + u</code>
</p>

<p>where <code class="reqn">v</code> and <code class="reqn">u</code> are vectors of random variables (observed or unobserved), and
the parameter matrix <code class="reqn">A</code> contains regression coefficients, symbolized by single-headed arrows
in a path diagram. Another parameter matrix, 
</p>
<p style="text-align: center;"><code class="reqn">P = E(uu')</code>
</p>

<p>contains covariances among the elements of <code class="reqn">u</code> (assuming that the elements of <code class="reqn">u</code> have zero
means). Usually <code class="reqn">v</code> contains endogenous and exogenous observed and unobserved variables, but not
error variables (see the examples below).
</p>
<p>The <code>startvalues</code> function may be called directly, but is usually called by <code>sem.default</code>; <code>startvalues2</code> is an older version of this function that may be used alternatively; see the <code>startvalues</code> argument to <code>sem</code>.
</p>


<h3>Value</h3>

<p><code>sem</code> returns an object of class <code>c(</code><em>objective</em><code>, "sem")</code>, where <em>objective</em>
is the name of the objective function that was optimized (e.g., <code>"objectiveML"</code>), with the following elements:
</p>
<table>
<tr><td><code>var.names</code></td>
<td>
<p>vector of variable names.</p>
</td></tr>
<tr><td><code>ram</code></td>
<td>
<p>RAM matrix, including any rows generated for covariances
among fixed exogenous variables; column 5 includes computed start values.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>observed covariance matrix.</p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>RAM selection matrix, <code class="reqn">J</code>, which picks out observed variables.</p>
</td></tr>
<tr><td><code>n.fix</code></td>
<td>
<p>number of fixed exogenous variables.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observed variables.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of variables (observed plus unobserved).</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>number of free parameters.</p>
</td></tr>
<tr><td><code>raw</code></td>
<td>
<p><code>TRUE</code> if the model is fit to a raw moment matrix, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the observed-variable data matrix, or <code>NULL</code> if data are not supplied.</p>
</td></tr>
<tr><td><code>semmod</code></td>
<td>
<p>the <code>semmod</code> specification object for the model, if one was supplied; otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>optimizer</code></td>
<td>
<p>the optimizer function.</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>the objective function.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>estimates of free parameters.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>estimated asymptotic covariance matrix of parameter estimates, based on a numeric Hessian,
if supplied by the optimizer; otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>par.posn</code></td>
<td>
<p>indices of free parameters.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, depending upon whether the optimization apparently converged.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations performed.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>value of the objective function at the minimum.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>model-reproduced covariance matrix.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>RAM <code class="reqn">A</code> matrix.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>RAM <code class="reqn">P</code> matrix.</p>
</td></tr>
<tr><td><code>adj.obj</code></td>
<td>
<p>robust adjusted value of the objective function; <code>NULL</code> if
<code>robust</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>robust.vcov</code></td>
<td>
<p>robust estimated coefficient covariance matrix; <code>NULL</code> if
<code>robust</code> is <code>FALSE</code>.</p>
</td></tr>
</table>
<p>For multigroup models, <code>sem</code> returns an object of class <code>c("msemObjectiveML", "msem")</code>.
</p>


<h3>Warning</h3>

<p>A common error is to fail to specify variance or covariance terms in the model, which are denoted 
by double-headed arrows, <code>&lt;-&gt;</code>.
</p>
<p>In general, every observed or latent variable in the model should be associated 
with a variance or error variance. 
This may be
a free parameter to estimate or a fixed constant (as in the case of a latent exogenous 
variable for which you wish to fix the variance, e.g.,
to 1). Again in general, there will be an <em>error variance</em> associated with each 
endogenous variable in the model (i.e., each variable
to which at least one single-headed arrow points &mdash; including observed indicators of latent variables), 
and a <em>variance</em> associated with each exogenous variable (i.e., each variable that
appears only at the tail of single-headed arrows, never at the head).
</p>
<p>To my knowledge, the only <em>apparent</em> exception to this rule is for observed variables that 
are declared to be fixed exogenous variables.
In this case, the program generates the necessary (fixed-constant) variances and covariances automatically.
</p>
<p>If there are missing variances, a warning message will be printed, and estimation will almost surely 
fail in some manner. Missing
variances might well indicate that there are missing covariances too, but it is not possible 
to deduce this in a mechanical manner. The <code><a href="#topic+specifyModel">specifyModel</a></code> funciton will by default supply
error-variance parameters if these are missing.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, Zhenghua Nie, and Jarrett Byrnes</p>


<h3>References</h3>

<p>Fox, J. (2006)
Structural equation modeling with the sem package in R.
<em>Structural Equation Modeling</em> 
<b>13</b>:465&ndash;486.
</p>
<p>Bollen, K. A. (1989) 
<em>Structural Equations With Latent Variables.</em> Wiley.
</p>
<p>Bollen, K. A. and Long, J. S. (eds.)
<em>Testing Structural Equation Models</em>, Sage.
</p>
<p>McArdle, J. J. and Epstein, D. (1987)
Latent growth curves within developmental structural equation models.
<em>Child Development</em>
<b>58</b>, 110&ndash;133.
</p>
<p>McArdle, J. J. and McDonald, R. P. (1984)
Some algebraic properties of the reticular action model.
<em>British Journal of Mathematical and Statistical Psychology</em>
<b>37</b>, 234&ndash;251.
</p>
<p>McDonald, R. P. and Hartmann, W. M. (1992)
A procedure for obtaining initial values of parameters in
the RAM model. <em>Multivariate Behavioral Research</em>
<b>27</b>, 57&ndash;76.
</p>
<p>Raftery, A. E. (1993)
Bayesian model selection in structural equation models.
In Bollen, K. A. and Long, J. S. (eds.)
<em>Testing Structural Equation Models</em>, Sage.
</p>
<p>Raftery, A. E. (1995)
Bayesian model selection in social research (with discussion).
<em>Sociological Methodology</em> <b>25</b>, 111&ndash;196.
</p>
<p>Satorra, A. (2000)
Scaled and adjusted restricted tests in multi-sample analysis of moment structures. 
pp. 233&ndash;247 in Heijmans, R.D.H., Pollock, D.S.G. &amp; Satorra, A. (eds.)
<em>Innovations in Multivariate Statistical Analysis. A Festschrift for Heinz Neudecker </em>, Kluwer. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rawMoments">rawMoments</a></code>, <code><a href="#topic+startvalues">startvalues</a></code>, 
<code><a href="#topic+objectiveML">objectiveML</a></code>, <code><a href="#topic+objectiveGLS">objectiveGLS</a></code>,  
<code><a href="#topic+optimizerNlm">optimizerNlm</a></code>, <code><a href="#topic+optimizerOptim">optimizerOptim</a></code>, <code><a href="#topic+optimizerNlminb">optimizerNlminb</a></code>,
<code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>,
<code><a href="#topic+specifyModel">specifyModel</a></code>, <code><a href="#topic+specifyEquations">specifyEquations</a></code>, <code><a href="#topic+cfa">cfa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following example illustrates the use the text argument to 
#   readMoments() and specifyEquations():

R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"),
                text="
    .6247     
    .3269  .3669       
    .4216  .3275  .6404
    .2137  .2742  .1124  .0839
    .4105  .4043  .2903  .2598  .1839
    .3240  .4047  .3054  .2786  .0489  .2220
    .2930  .2407  .4105  .3607  .0186  .1861  .2707
    .2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950
    .0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087
")

model.dhp.1 &lt;- specifyEquations(covs="RGenAsp, FGenAsp", text="
RGenAsp = gam11*RParAsp + gam12*RIQ + gam13*RSES + gam14*FSES + beta12*FGenAsp
FGenAsp = gam23*RSES + gam24*FSES + gam25*FIQ + gam26*FParAsp + beta21*RGenAsp
ROccAsp = 1*RGenAsp
REdAsp = lam21(1)*RGenAsp  # to illustrate setting start values
FOccAsp = 1*FGenAsp
FEdAsp = lam42(1)*FGenAsp
")

sem.dhp.1 &lt;- sem(model.dhp.1, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))
summary(sem.dhp.1)

# Note: The following set of examples can't be run via example() because the default file
#  argument of specifyeEquations, specifyModel(), and readMoments() requires that the model 
#  specification and covariances, correlations, or raw moments be entered in an interactive
#  session at the command prompt. The examples can be copied and run in the R console,
#  however. See ?specifyModel and ?readMoments for further information.
#  These examples are repeated below using file input to specifyModel() and
#  readMoments(). The second version of the examples may be executed through example().

    ## Not run: 

# ------------- Duncan, Haller and Portes peer-influences model ----------------------
# A nonrecursive SEM with unobserved endogenous variables and fixed exogenous variables

R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"))
    .6247     
    .3269  .3669       
    .4216  .3275  .6404
    .2137  .2742  .1124  .0839
    .4105  .4043  .2903  .2598  .1839
    .3240  .4047  .3054  .2786  .0489  .2220
    .2930  .2407  .4105  .3607  .0186  .1861  .2707
    .2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950
    .0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087
            
# Fit the model using a symbolic ram specification

model.dhp &lt;- specifyModel()
    RParAsp  -&gt; RGenAsp, gam11,  NA
    RIQ      -&gt; RGenAsp, gam12,  NA
    RSES     -&gt; RGenAsp, gam13,  NA
    FSES     -&gt; RGenAsp, gam14,  NA
    RSES     -&gt; FGenAsp, gam23,  NA
    FSES     -&gt; FGenAsp, gam24,  NA
    FIQ      -&gt; FGenAsp, gam25,  NA
    FParAsp  -&gt; FGenAsp, gam26,  NA
    FGenAsp  -&gt; RGenAsp, beta12, NA
    RGenAsp  -&gt; FGenAsp, beta21, NA
    RGenAsp  -&gt; ROccAsp,  NA,     1
    RGenAsp  -&gt; REdAsp,  lam21,  NA
    FGenAsp  -&gt; FOccAsp,  NA,     1
    FGenAsp  -&gt; FEdAsp,  lam42,  NA
    RGenAsp &lt;-&gt; RGenAsp, ps11,   NA
    FGenAsp &lt;-&gt; FGenAsp, ps22,   NA
    RGenAsp &lt;-&gt; FGenAsp, ps12,   NA
    ROccAsp &lt;-&gt; ROccAsp, theta1, NA
    REdAsp  &lt;-&gt; REdAsp,  theta2, NA
    FOccAsp &lt;-&gt; FOccAsp, theta3, NA
    FEdAsp  &lt;-&gt; FEdAsp,  theta4, NA
    
# an equivalent specification, allowing specifyModel() to generate
#  variance parameters for endogenous variables (and suppressing the
#  unnecessary NAs):
 
model.dhp &lt;- specifyModel()
RParAsp  -&gt; RGenAsp, gam11
RIQ      -&gt; RGenAsp, gam12
RSES     -&gt; RGenAsp, gam13
FSES     -&gt; RGenAsp, gam14
RSES     -&gt; FGenAsp, gam23
FSES     -&gt; FGenAsp, gam24
FIQ      -&gt; FGenAsp, gam25
FParAsp  -&gt; FGenAsp, gam26
FGenAsp  -&gt; RGenAsp, beta12
RGenAsp  -&gt; FGenAsp, beta21
RGenAsp  -&gt; ROccAsp,  NA,     1
RGenAsp  -&gt; REdAsp,  lam21
FGenAsp  -&gt; FOccAsp,  NA,     1
FGenAsp  -&gt; FEdAsp,  lam42
RGenAsp &lt;-&gt; FGenAsp, ps12

# Another equivalent specification, telling specifyModel to add paths for 
#   variances and covariance of RGenAsp and FGenAsp:
 
model.dhp &lt;- specifyModel(covs="RGenAsp, FGenAsp")
RParAsp  -&gt; RGenAsp, gam11
RIQ      -&gt; RGenAsp, gam12
RSES     -&gt; RGenAsp, gam13
FSES     -&gt; RGenAsp, gam14
RSES     -&gt; FGenAsp, gam23
FSES     -&gt; FGenAsp, gam24
FIQ      -&gt; FGenAsp, gam25
FParAsp  -&gt; FGenAsp, gam26
FGenAsp  -&gt; RGenAsp, beta12
RGenAsp  -&gt; FGenAsp, beta21
RGenAsp  -&gt; ROccAsp,  NA,     1
RGenAsp  -&gt; REdAsp,  lam21
FGenAsp  -&gt; FOccAsp,  NA,     1
FGenAsp  -&gt; FEdAsp,  lam42

# Yet another equivalent specification using specifyEquations():

model.dhp.1 &lt;- specifyEquations(covs="RGenAsp, FGenAsp")
RGenAsp = gam11*RParAsp + gam12*RIQ + gam13*RSES + gam14*FSES + beta12*FGenAsp
FGenAsp = gam23*RSES + gam24*FSES + gam25*FIQ + gam26*FParAsp + beta21*RGenAsp
ROccAsp = 1*RGenAsp
REdAsp = lam21(1)*RGenAsp  # to illustrate setting start values
FOccAsp = 1*FGenAsp
FEdAsp = lam42(1)*FGenAsp
 
sem.dhp.1 &lt;- sem(model.dhp.1, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))
summary(sem.dhp.1)

# Fit the model using a numerical ram specification (not recommended!)

ram.dhp &lt;- matrix(c(
#               heads   to      from    param  start
                1,       1,     11,      0,     1,
                1,       2,     11,      1,     NA, # lam21
                1,       3,     12,      0,     1,
                1,       4,     12,      2,     NA, # lam42
                1,      11,      5,      3,     NA, # gam11
                1,      11,      6,      4,     NA, # gam12
                1,      11,      7,      5,     NA, # gam13
                1,      11,      8,      6,     NA, # gam14
                1,      12,      7,      7,     NA, # gam23
                1,      12,      8,      8,     NA, # gam24
                1,      12,      9,      9,     NA, # gam25
                1,      12,     10,     10,     NA, # gam26
                1,      11,     12,     11,     NA, # beta12
                1,      12,     11,     12,     NA, # beta21
                2,       1,      1,     13,     NA, # theta1
                2,       2,      2,     14,     NA, # theta2
                2,       3,      3,     15,     NA, # theta3
                2,       4,      4,     16,     NA, # theta4
                2,      11,     11,     17,     NA, # psi11
                2,      12,     12,     18,     NA, # psi22
                2,      11,     12,     19,     NA  # psi12
                ), ncol=5, byrow=TRUE)

params.dhp &lt;- c('lam21', 'lam42', 'gam11', 'gam12', 'gam13', 'gam14',
                 'gam23',  'gam24',  'gam25',  'gam26',
                 'beta12', 'beta21', 'theta1', 'theta2', 'theta3', 'theta4',
                 'psi11', 'psi22', 'psi12')
                 
vars.dhp &lt;- c('ROccAsp', 'REdAsp', 'FOccAsp', 'FEdAsp', 'RParAsp', 'RIQ',
                'RSES', 'FSES', 'FIQ', 'FParAsp', 'RGenAsp', 'FGenAsp')
                
sem.dhp.2 &lt;- sem(ram.dhp, R.DHP, 329, param.names=params.dhp, var.names=vars.dhp, 
	fixed.x=5:10)
summary(sem.dhp.2)


# -------------------- Wheaton et al. alienation data ----------------------
    

S.wh &lt;- readMoments(names=c('Anomia67','Powerless67','Anomia71',
                                    'Powerless71','Education','SEI'))
   11.834                                    
    6.947    9.364                            
    6.819    5.091   12.532                    
    4.783    5.028    7.495    9.986            
   -3.839   -3.889   -3.841   -3.625   9.610     
  -21.899  -18.831  -21.748  -18.775  35.522  450.288

# This is the model in the SAS manual for PROC CALIS: A Recursive SEM with
# latent endogenous and exogenous variables.
# Curiously, both factor loadings for two of the latent variables are fixed.

model.wh.1 &lt;- specifyModel()
    Alienation67   -&gt;  Anomia67,      NA,     1
    Alienation67   -&gt;  Powerless67,   NA,     0.833
    Alienation71   -&gt;  Anomia71,      NA,     1
    Alienation71   -&gt;  Powerless71,   NA,     0.833 
    SES            -&gt;  Education,     NA,     1     
    SES            -&gt;  SEI,           lamb,   NA
    SES            -&gt;  Alienation67,  gam1,   NA
    Alienation67   -&gt;  Alienation71,  beta,   NA
    SES            -&gt;  Alienation71,  gam2,   NA
    Anomia67       &lt;-&gt; Anomia67,      the1,   NA
    Anomia71       &lt;-&gt; Anomia71,      the1,   NA
    Powerless67    &lt;-&gt; Powerless67,   the2,   NA
    Powerless71    &lt;-&gt; Powerless71,   the2,   NA
    Education      &lt;-&gt; Education,     the3,   NA
    SEI            &lt;-&gt; SEI,           the4,   NA
    Anomia67       &lt;-&gt; Anomia71,      the5,   NA
    Powerless67    &lt;-&gt; Powerless71,   the5,   NA
    Alienation67   &lt;-&gt; Alienation67,  psi1,   NA
    Alienation71   &lt;-&gt; Alienation71,  psi2,   NA
    SES            &lt;-&gt; SES,           phi,    NA
                           
sem.wh.1 &lt;- sem(model.wh.1, S.wh, 932)
summary(sem.wh.1)

# The same model in equation format:

model.wh.1 &lt;- specifyEquations()
Anomia67 = 1*Alienation67
Powerless67 = 0.833*Alienation67
Anomia71 = 1*Alienation71
Powerless71 = 0.833*Alienation71
Education = 1*SES
SEI = lamb*SES
Alienation67 = gam1*SES
Alienation71 = gam2*SES + beta*Alienation67
V(Anomia67) = the1
V(Anomia71) = the1
V(Powerless67) = the2
V(Powerless71) = the2
V(SES) = phi
C(Anomia67, Anomia71) = the5
C(Powerless67, Powerless71) = the5

# The same model, but treating one loading for each latent variable as free
# (and equal to each other).

model.wh.2 &lt;- specifyModel()
    Alienation67   -&gt;  Anomia67,      NA,        1
    Alienation67   -&gt;  Powerless67,   lamby,    NA
    Alienation71   -&gt;  Anomia71,      NA,        1
    Alienation71   -&gt;  Powerless71,   lamby,    NA 
    SES            -&gt;  Education,     NA,        1     
    SES            -&gt;  SEI,           lambx,    NA
    SES            -&gt;  Alienation67,  gam1,     NA
    Alienation67   -&gt;  Alienation71,  beta,     NA
    SES            -&gt;  Alienation71,  gam2,     NA
    Anomia67       &lt;-&gt; Anomia67,      the1,     NA
    Anomia71       &lt;-&gt; Anomia71,      the1,     NA
    Powerless67    &lt;-&gt; Powerless67,   the2,     NA
    Powerless71    &lt;-&gt; Powerless71,   the2,     NA
    Education      &lt;-&gt; Education,     the3,     NA
    SEI            &lt;-&gt; SEI,           the4,     NA
    Anomia67       &lt;-&gt; Anomia71,      the5,     NA
    Powerless67    &lt;-&gt; Powerless71,   the5,     NA
    Alienation67   &lt;-&gt; Alienation67,  psi1,     NA
    Alienation71   &lt;-&gt; Alienation71,  psi2,     NA
    SES            &lt;-&gt; SES,           phi,      NA 


sem.wh.2 &lt;- sem(model.wh.2, S.wh, 932)
summary(sem.wh.2)

# And again, in equation format:

model.wh &lt;- specifyEquations()
Anomia67 = 1*Alienation67
Powerless67 = lamby*Alienation67
Anomia71 = 1*Alienation71
Powerless71 = lamby*Alienation71
Education = 1*SES
SEI = lambx*SES
Alienation67 = gam1*SES
Alienation71 = gam2*SES + beta*Alienation67
V(Anomia67) = the1
V(Anomia71) = the1
V(Powerless67) = the2
V(Powerless71) = the2
V(SES) = phi
C(Anomia67, Anomia71) = the5
C(Powerless67, Powerless71) = the5


# Compare the two models by a likelihood-ratio test:

anova(sem.wh.1, sem.wh.2)


# ----------------------- Thurstone data ---------------------------------------
#  Second-order confirmatory factor analysis, from the SAS manual for PROC CALIS

R.thur &lt;- readMoments(diag=FALSE, names=c('Sentences','Vocabulary',
        'Sent.Completion','First.Letters','4.Letter.Words','Suffixes',
        'Letter.Series','Pedigrees', 'Letter.Group'))
    .828                                              
    .776   .779                                        
    .439   .493    .46                                 
    .432   .464    .425   .674                           
    .447   .489    .443   .59    .541                    
    .447   .432    .401   .381    .402   .288              
    .541   .537    .534   .35    .367   .32   .555        
    .38   .358    .359   .424    .446   .325   .598   .452  
            
model.thur &lt;- specifyModel()
    F1 -&gt; Sentences,                      lam11
    F1 -&gt; Vocabulary,                     lam21
    F1 -&gt; Sent.Completion,                lam31
    F2 -&gt; First.Letters,                  lam42
    F2 -&gt; 4.Letter.Words,                 lam52
    F2 -&gt; Suffixes,                       lam62
    F3 -&gt; Letter.Series,                  lam73
    F3 -&gt; Pedigrees,                      lam83
    F3 -&gt; Letter.Group,                   lam93
    F4 -&gt; F1,                             gam1
    F4 -&gt; F2,                             gam2
    F4 -&gt; F3,                             gam3
    F1 &lt;-&gt; F1,                            NA,     1
    F2 &lt;-&gt; F2,                            NA,     1
    F3 &lt;-&gt; F3,                            NA,     1
    F4 &lt;-&gt; F4,                            NA,     1

sem.thur &lt;- sem(model.thur, R.thur, 213)
summary(sem.thur)

# The model in equation format:

model.thur &lt;- specifyEquations()
Sentences = lam11*F1
Vocabulary = lam21*F1
Sent.Completion = lam31*F1
First.Letters = lam42*F2
4.Letter.Words = lam52*F2
Suffixes = lam62*F2
Letter.Series = lam73*F3
Pedigrees = lam83*F3
Letter.Group = lam93*F3
F1 = gam1*F4
F2 = gam2*F4
F3 = gam3*F4
V(F1) = 1
V(F2) = 1
V(F3) = 1
V(F4) = 1


#------------------------- Kerchoff/Kenney path analysis ---------------------
# An observed-variable recursive SEM from the LISREL manual

R.kerch &lt;- readMoments(diag=FALSE, names=c('Intelligence','Siblings',
                        'FatherEd','FatherOcc','Grades','EducExp','OccupAsp'))
    -.100                                
     .277  -.152                          
     .250  -.108  .611                     
     .572  -.105  .294   .248               
     .489  -.213  .446   .410   .597         
     .335  -.153  .303   .331   .478   .651   
    
model.kerch &lt;- specifyModel()
    Intelligence -&gt; Grades,       gam51
    Siblings -&gt; Grades,           gam52
    FatherEd -&gt; Grades,           gam53
    FatherOcc -&gt; Grades,          gam54
    Intelligence -&gt; EducExp,      gam61
    Siblings -&gt; EducExp,          gam62
    FatherEd -&gt; EducExp,          gam63
    FatherOcc -&gt; EducExp,         gam64
    Grades -&gt; EducExp,            beta65
    Intelligence -&gt; OccupAsp,     gam71
    Siblings -&gt; OccupAsp,         gam72
    FatherEd -&gt; OccupAsp,         gam73
    FatherOcc -&gt; OccupAsp,        gam74
    Grades -&gt; OccupAsp,           beta75
    EducExp -&gt; OccupAsp,          beta76
                       
sem.kerch &lt;- sem(model.kerch, R.kerch, 737, 
    fixed.x=c('Intelligence', 'Siblings', 'FatherEd', 'FatherOcc'))
summary(sem.kerch)

# The model in equation format:

model.kerch &lt;- specifyEquations()
Grades = gam51*Intelligence + gam52*Siblings + gam53*FatherEd 
           + gam54*FatherOcc
EducExp = gam61*Intelligence + gam62*Siblings + gam63*FatherEd 
            + gam64*FatherOcc + beta65*Grades
OccupAsp = gam71*Intelligence + gam72*Siblings + gam73*FatherEd 
            + gam74*FatherOcc + beta75*Grades + beta76*EducExp


#------------------- McArdle/Epstein latent-growth-curve model -----------------
# This model, from McArdle and Epstein (1987, p.118), illustrates the use of a 
# raw moment matrix to fit a model with an intercept. (The example was suggested
# by Mike Stoolmiller.)

M.McArdle &lt;- readMoments(
    names=c('WISC1', 'WISC2', 'WISC3', 'WISC4', 'UNIT'))
    365.661                                      
    503.175     719.905                           
    675.656     958.479    1303.392                
    890.680    1265.846    1712.475    2278.257     
     18.034      25.819      35.255      46.593     1.000
 
mod.McArdle &lt;- specifyModel()
    C -&gt; WISC1, NA, 6.07
    C -&gt; WISC2, B2, NA
    C -&gt; WISC3, B3, NA
    C -&gt; WISC4, B4, NA
    UNIT -&gt; C, Mc, NA
    C &lt;-&gt; C, Vc, NA,
    WISC1 &lt;-&gt; WISC1, Vd, NA
    WISC2 &lt;-&gt; WISC2, Vd, NA
    WISC3 &lt;-&gt; WISC3, Vd, NA
    WISC4 &lt;-&gt; WISC4, Vd, NA

sem.McArdle &lt;- sem(mod.McArdle, M.McArdle, 204, fixed.x="UNIT", raw=TRUE)
summary(sem.McArdle)

# The model in equation format:

mod.McArdle &lt;- specifyEquations()
WISC1 = 6.07*C
WISC2 = B2*C
WISC3 = B3*C
WISC4 = b4*C
C = Mc*UNIT
v(C) = Vc
v(WISC1) = Vd
v(WISC2) = Vd
v(WISC3) = Vd
v(WISC4) = Vd

    
#------------ Bollen industrialization and democracy example -----------------
# This model, from Bollen (1989, Ch. 8), illustrates the use in sem() of a
# case-by-variable data (see ?Bollen) set rather than a covariance or moment matrix

model.bollen &lt;- specifyModel()
	Demo60 -&gt; y1, NA, 1
	Demo60 -&gt; y2, lam2, 
	Demo60 -&gt; y3, lam3, 
	Demo60 -&gt; y4, lam4, 
	Demo65 -&gt; y5, NA, 1
	Demo65 -&gt; y6, lam2, 
	Demo65 -&gt; y7, lam3, 
	Demo65 -&gt; y8, lam4, 
	Indust -&gt; x1, NA, 1
	Indust -&gt; x2, lam6, 
	Indust -&gt; x3, lam7, 
	y1 &lt;-&gt; y5, theta15
	y2 &lt;-&gt; y4, theta24
	y2 &lt;-&gt; y6, theta26
	y3 &lt;-&gt; y7, theta37
	y4 &lt;-&gt; y8, theta48
	y6 &lt;-&gt; y8, theta68
	Indust -&gt; Demo60, gamma11, 
	Indust -&gt; Demo65, gamma21, 
	Demo60 -&gt; Demo65, beta21, 
	Indust &lt;-&gt; Indust, phi
	
sem.bollen &lt;- sem(model.bollen, data=Bollen)
summary(sem.bollen)
summary(sem.bollen, robust=TRUE) # robust SEs and tests
summary(sem.bollen, analytic.se=FALSE) # uses numeric rather than analytic Hessian

  # GLS rather than ML estimator:
sem.bollen.gls &lt;- sem(model.bollen, data=Bollen, objective=objectiveGLS) 
summary(sem.bollen.gls)

# The model in equation format:

model.bollen &lt;- specifyEquations()
y1 = 1*Demo60
y2 = lam2*Demo60
y3 = lam3*Demo60
y4 = lam4*Demo60
y5 = 1*Demo65
y6 = lam2*Demo65
y7 = lam3*Demo65
y8 = lam4*Demo65
x1 = 1*Indust
x2 = lam6*Indust
x3 = lam7*Indust
c(y1, y5) = theta15
c(y2, y4) = theta24
c(y2, y6) = theta26
c(y3, y7) = theta37
c(y4, y8) = theta48
c(y6, y8) = theta68
Demo60 = gamma11*Indust
Demo65 = gamma21*Indust + beta21*Demo60
v(Indust) = phi


# -------------- A simple CFA model for the Thurstone mental tests data --------------

R.thur &lt;- readMoments(diag=FALSE, 
  names=c('Sentences','Vocabulary',
          'Sent.Completion','First.Letters','4.Letter.Words','Suffixes',
          'Letter.Series','Pedigrees', 'Letter.Group'))
.828                                              
.776   .779                                        
.439   .493    .46                                 
.432   .464    .425   .674                           
.447   .489    .443   .59    .541                    
.447   .432    .401   .381    .402   .288              
.541   .537    .534   .35    .367   .32   .555        
.38   .358    .359   .424    .446   .325   .598   .452

	#  (1) in CFA format:

mod.cfa.thur.c &lt;- cfa(reference.indicators=FALSE)
FA: Sentences, Vocabulary, Sent.Completion
FB: First.Letters, 4.Letter.Words, Suffixes
FC: Letter.Series, Pedigrees, Letter.Group

cfa.thur.c &lt;- sem(mod.cfa.thur.c, R.thur, 213)
summary(cfa.thur.c)

	#  (2) in equation format:

mod.cfa.thur.e &lt;- specifyEquations(covs="F1, F2, F3")
Sentences = lam11*F1
Vocabulary = lam21*F1
Sent.Completion = lam31*F1
First.Letters = lam42*F2
4.Letter.Words = lam52*F2
Suffixes = lam62*F2
Letter.Series = lam73*F3
Pedigrees = lam83*F3
Letter.Group = lam93*F3
V(F1) = 1
V(F2) = 1
V(F3) = 1

cfa.thur.e &lt;- sem(mod.cfa.thur.e, R.thur, 213)
summary(cfa.thur.e)

	#  (3) in path format:

mod.cfa.thur.p &lt;- specifyModel(covs="F1, F2, F3")
F1 -&gt; Sentences,                      lam11
F1 -&gt; Vocabulary,                     lam21
F1 -&gt; Sent.Completion,                lam31
F2 -&gt; First.Letters,                  lam41
F2 -&gt; 4.Letter.Words,                 lam52
F2 -&gt; Suffixes,                       lam62
F3 -&gt; Letter.Series,                  lam73
F3 -&gt; Pedigrees,                      lam83
F3 -&gt; Letter.Group,                   lam93
F1 &lt;-&gt; F1,                            NA,     1
F2 &lt;-&gt; F2,                            NA,     1
F3 &lt;-&gt; F3,                            NA,     1

cfa.thur.p &lt;- sem(mod.cfa.thur.p, R.thur, 213)
summary(cfa.thur.p)

# -----  a CFA model fit by FIML to the mental-tests dataset with missing data -----

mod.cfa.tests &lt;- cfa(raw=TRUE)
verbal: x1, x2, x3
math: y1, y2, y3

cfa.tests &lt;- sem(mod.cfa.tests, data=Tests, na.action=na.pass, 
                objective=objectiveFIML, fixed.x="Intercept")
summary(cfa.tests)
summary(cfa.tests, saturated=TRUE) # takes time to fit saturated model for comparison


# ---  a multigroup CFA model fit to the Holzinger-Swineford mental-tests data  -----

mod.hs &lt;- cfa()
spatial: visual, cubes, paper, flags
verbal: general, paragrap, sentence, wordc, wordm
memory: wordr, numberr, figurer, object, numberf, figurew
math: deduct, numeric, problemr, series, arithmet

mod.mg &lt;- multigroupModel(mod.hs, groups=c("Female", "Male")) 

sem.mg &lt;- sem(mod.mg, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
              general + paragrap + sentence + wordc + wordm +
              wordr + numberr + figurer + object + numberf + figurew +
              deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg)

	# with cross-group equality constraints:
	
mod.mg.eq &lt;- multigroupModel(mod.hs, groups=c("Female", "Male"), allEqual=TRUE)

sem.mg.eq &lt;- sem(mod.mg.eq, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
                general + paragrap + sentence + wordc + wordm +
                wordr + numberr + figurer + object + numberf + figurew +
                deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg.eq)

anova(sem.mg, sem.mg.eq) # test equality constraints
	
## End(Not run)

## ===============================================================================
	
# The following examples use file input and may be executed via example():

etc &lt;- system.file(package="sem", "etc") # path to data and model files

#   to get all fit indices (not recommended, but for illustration):

opt &lt;- options(fit.indices = c("GFI", "AGFI", "RMSEA", "NFI", "NNFI", 
         "CFI", "RNI", "IFI", "SRMR", "AIC", "AICc", "BIC", "CAIC"))

# ------------- Duncan, Haller and Portes peer-influences model ----------------------
# A nonrecursive SEM with unobserved endogenous variables and fixed exogenous variables

(R.DHP &lt;- readMoments(file=file.path(etc, "R-DHP.txt"),
				diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp")))
(model.dhp &lt;- specifyModel(file=file.path(etc, "model-DHP.txt")))
sem.dhp.1 &lt;- sem(model.dhp, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))
summary(sem.dhp.1)


# -------------------- Wheaton et al. alienation data ----------------------

(S.wh &lt;- readMoments(file=file.path(etc, "S-Wheaton.txt"),
					names=c('Anomia67','Powerless67','Anomia71',
                            'Powerless71','Education','SEI')))

# This is the model in the SAS manual for PROC CALIS: A Recursive SEM with
# latent endogenous and exogenous variables.
# Curiously, both factor loadings for two of the latent variables are fixed.

(model.wh.1 &lt;- specifyModel(file=file.path(etc, "model-Wheaton-1.txt")))                    
sem.wh.1 &lt;- sem(model.wh.1, S.wh, 932)
summary(sem.wh.1)

# The same model, but treating one loading for each latent variable as free
# (and equal to each other).

(model.wh.2 &lt;- specifyModel(file=file.path(etc, "model-Wheaton-2.txt")))
sem.wh.2 &lt;- sem(model.wh.2, S.wh, 932)
summary(sem.wh.2)

# Compare the two models by a likelihood-ratio test:

anova(sem.wh.1, sem.wh.2)


# ----------------------- Thurstone data ---------------------------------------

#  Second-order confirmatory factor analysis, from the SAS manual for PROC CALIS

(R.thur &lt;- readMoments(file=file.path(etc, "R-Thurstone.txt"),
		diag=FALSE, names=c('Sentences','Vocabulary',
        'Sent.Completion','First.Letters','4.Letter.Words','Suffixes',
        'Letter.Series','Pedigrees', 'Letter.Group')))
(model.thur &lt;- specifyModel(file=file.path(etc, "model-Thurstone.txt")))
sem.thur &lt;- sem(model.thur, R.thur, 213)
summary(sem.thur)


#------------------------- Kerchoff/Kenney path analysis ---------------------

# An observed-variable recursive SEM from the LISREL manual

(R.kerch &lt;- readMoments(file=file.path(etc, "R-Kerchoff.txt"),
					   diag=FALSE, names=c('Intelligence','Siblings',
                        'FatherEd','FatherOcc','Grades','EducExp','OccupAsp')))
(model.kerch &lt;- specifyModel(file=file.path(etc, "model-Kerchoff.txt")))
sem.kerch &lt;- sem(model.kerch, R.kerch, 737, 
    fixed.x=c('Intelligence', 'Siblings', 'FatherEd', 'FatherOcc'))
summary(sem.kerch)


#------------------- McArdle/Epstein latent-growth-curve model -----------------

# This model, from McArdle and Epstein (1987, p.118), illustrates the use of a 
# raw moment matrix to fit a model with an intercept. (The example was suggested
# by Mike Stoolmiller.)

(M.McArdle &lt;- readMoments(file=file.path(etc, "M-McArdle.txt"),
    names=c('WISC1', 'WISC2', 'WISC3', 'WISC4', 'UNIT')))
(mod.McArdle &lt;- specifyModel(file=file.path(etc, "model-McArdle.txt")))
sem.McArdle &lt;- sem(mod.McArdle, M.McArdle, 204, fixed.x="UNIT", raw=TRUE)
summary(sem.McArdle)


#------------ Bollen industrialization and democracy example -----------------

# This model, from Bollen (1989, Ch. 8), illustrates the use in sem() of a
# case-by-variable data set (see ?Bollen) rather than a covariance or moment matrix

(model.bollen &lt;- specifyModel(file=file.path(etc, "model-Bollen.txt")))
sem.bollen &lt;- sem(model.bollen, data=Bollen)
summary(sem.bollen)
summary(sem.bollen, robust=TRUE) # robust SEs and tests
summary(sem.bollen, analytic.se=FALSE) # uses numeric rather than analytic Hessian

  # GLS rather than ML estimator:
sem.bollen.gls &lt;- sem(model.bollen, data=Bollen, objective=objectiveGLS) 
summary(sem.bollen.gls)

# -----  a CFA model fit by FIML to the mental-tests dataset with missing data -----

(mod.cfa.tests &lt;- cfa(file=file.path(etc, "model-Tests.txt"), raw=TRUE))
cfa.tests &lt;- sem(mod.cfa.tests, data=Tests, na.action=na.pass, 
                optimizer=optimizerNlm, objective=objectiveFIML, fixed.x="Intercept")
summary(cfa.tests)

#------------ Holzinger and Swineford muiltigroup CFA example ----------------

mod.hs &lt;- cfa(file=file.path(etc, "model-HS.txt"))

mod.mg &lt;- multigroupModel(mod.hs, groups=c("Female", "Male")) 

sem.mg &lt;- sem(mod.mg, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
              general + paragrap + sentence + wordc + wordm +
              wordr + numberr + figurer + object + numberf + figurew +
              deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg)

	# with cross-group equality constraints:
	
mod.mg.eq &lt;- multigroupModel(mod.hs, groups=c("Female", "Male"), allEqual=TRUE)

sem.mg.eq &lt;- sem(mod.mg.eq, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
                general + paragrap + sentence + wordc + wordm +
                wordr + numberr + figurer + object + numberf + figurew +
                deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg.eq)

anova(sem.mg, sem.mg.eq) # test equality constraints

options(opt) # restore fit.indices option

</code></pre>

<hr>
<h2 id='sem-deprecated'>Deprecated Functions in the sem Package</h2><span id='topic+sem-deprecated'></span><span id='topic+boot.sem'></span><span id='topic+mod.indices'></span><span id='topic+normalized.residuals'></span><span id='topic+path.diagram'></span><span id='topic+raw.moments'></span><span id='topic+read.moments'></span><span id='topic+specify.model'></span><span id='topic+standardized.coefficients'></span><span id='topic+standardized.residuals'></span><span id='topic+std.coef'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of the <span class="pkg">sem</span> package only, 
and may be removed eventually. Although an effort has been made to insure backwards-compatibility,
commands that worked in versions of the <span class="pkg">sem</span> package prior to version 2.0-0
will not necessarily work in version 2.0-0 and beyond, or may not work in the same manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.sem(...)
mod.indices(...)
normalized.residuals(...)
path.diagram(...)
raw.moments(...)
read.moments(...)
specify.model(...)
standardized.coefficients(...)
standardized.residuals(...)
std.coef(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sem-deprecated_+3A_...">...</code></td>
<td>
<p>pass arguments down to replacements for deprecated functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>boot.sem</code> is now a synonym for the <code><a href="#topic+bootSem">bootSem</a></code> function.
</p>
<p><code>mod.indices</code> is now a synonym for <code><a href="#topic+modIndices">modIndices</a></code>.
</p>
<p><code>normalized.residuals</code> is now a synonym for <code><a href="#topic+normalizedResiduals">normalizedResiduals</a></code>.
</p>
<p><code>path.diagram</code> is now a synonym for <code><a href="#topic+pathDiagram">pathDiagram</a></code>.
</p>
<p><code>raw.moments</code> is now a synonym for <code><a href="#topic+rawMoments">rawMoments</a></code>.
</p>
<p><code>read.moments</code> is now a synonym for <code><a href="#topic+readMoments">readMoments</a></code>.
</p>
<p><code>specify.model</code> is now a synonym for <code><a href="#topic+specifyModel">specifyModel</a></code>.
</p>
<p><code>standardized.coefficients</code> and <code>std.coef</code> are now synonyms for the <code><a href="#topic+standardizedCoefficients">standardizedCoefficients</a></code> and <code><a href="#topic+stdCoef">stdCoef</a></code> 
functions.
</p>
<p><code>standardized.residuals</code> is now a synonym for <code><a href="#topic+standardizedResiduals">standardizedResiduals</a></code>.
</p>

<hr>
<h2 id='specifyModel'>Specify a Structural Equation Model</h2><span id='topic+specifyModel'></span><span id='topic+specifyEquations'></span><span id='topic+cfa'></span><span id='topic+multigroupModel'></span><span id='topic+print.semmod'></span><span id='topic+print.semmodList'></span><span id='topic+classifyVariables'></span><span id='topic+removeRedundantPaths'></span><span id='topic+combineModels'></span><span id='topic+combineModels.semmod'></span><span id='topic+update.semmod'></span><span id='topic+edit.semmod'></span>

<h3>Description</h3>

<p>Create the RAM specification of a structural equation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specifyModel(file="", text, exog.variances=FALSE, endog.variances=TRUE, covs, 
	suffix="", quiet=FALSE)

specifyEquations(file="", text, ...)

cfa(file="", text, covs=paste(factors, collapse=","), 
    reference.indicators=TRUE, raw=FALSE, 
    subscript=c("name", "number"), ...)

multigroupModel(..., groups=names(models), allEqual=FALSE)

classifyVariables(model)

removeRedundantPaths(model, warn=TRUE)
## S3 method for class 'semmod'
combineModels(..., warn=TRUE)
## S3 method for class 'semmod'
update(object, file = "", text, ...)
## S3 method for class 'semmod'
edit(name, ...)

## S3 method for class 'semmod'
print(x, ...)
## S3 method for class 'semmodList'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specifyModel_+3A_file">file</code></td>
<td>
<p>The (quoted) file from which to read the model specification,
including the path to the file if it is not in the current directory. If
<code>""</code> (the default) and the <code>text</code> argument is not supplied,
then the specification is read from the standard
input stream, and is terminated by a blank line.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_text">text</code></td>
<td>
<p>The model specification given as a character string, as an alternative
to specifying the ]codefile argument or reading the model specification from
the input stream &mdash; e.g., when the session is not interactive and there is no
standard input.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_exog.variances">exog.variances</code></td>
<td>
<p>If <code>TRUE</code> (the default is <code>FALSE</code>), free variance
parameters are added for the exogenous variables that lack them.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_endog.variances">endog.variances</code></td>
<td>
<p>If <code>TRUE</code> (the default), free error-variance parameters
are added for the endogenous variables that lack them.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_covs">covs</code></td>
<td>
<p>optional: a character vector of one or more elements, with each element
giving a string of variable names, separated by commas. Variances and covariances
among all variables in each such string are added to the model. For confirmatory
factor analysis models specified via <code>cfa</code>, <code>covs</code> defaults to all of
the factors in the model, thus specifying all variances and covariances among these factors.
<em>Warning</em>: <code>covs="x1, x2"</code> and <code>covs=c("x1", "x2")</code> are <em>not</em>
equivalent: <code>covs="x1, x2"</code> specifies the variance of <code>x1</code>, the variance
of <code>x2</code>, <em>and</em> their covariance, while <code>covs=c("x1", "x2")</code> specifies
the variance of <code>x1</code> and the variance of <code>x2</code> <em>but not</em> their covariance.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_suffix">suffix</code></td>
<td>
<p>a character string (defaulting to an empty string) to be 
appended to each parameter name; this can be convenient for specifying multiple-group models.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_reference.indicators">reference.indicators</code></td>
<td>
<p>if <code>FALSE</code>, the default, variances of factors are
set to 1 by <code>cfa</code>; if <code>TRUE</code>, variances of factors are free parameters
to estimate from the data, and instead the first factor loading for each factor is set
to 1 to identify the model.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_raw">raw</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), a path from <code>Intercept</code> to each
observed variable is added to the model, and the raw second moment for <code>Intercept</code> is
fixed to <code>1</code>. The <code>sem</code> function should then be called with <code>raw=TRUE</code>, and either
supplied with a data set (via the <code>data</code> argument) or a raw-moment matrix (via the <code>S</code>
argument).</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_subscript">subscript</code></td>
<td>
<p>The &ldquo;subscripts&rdquo; to be appended to <code>lam</code> to name factor-loading parameters,
either <code>"name"</code> (the default) to use the names of observed variables, or <code>"number"</code> to
number the parameters serially within each factor. Using <code>"number"</code> produces shorter parameter
names.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code>, the default, then the number of input lines is reported and
a message is printed suggesting that <code>specifyEquations</code> or <code>cfa</code> be used.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_x">x</code>, <code id="specifyModel_+3A_model">model</code>, <code id="specifyModel_+3A_object">object</code>, <code id="specifyModel_+3A_name">name</code></td>
<td>
<p>An object of class <code>semmod</code> or <code>semmodList</code>, as produced by
<code>specifyModel</code> or <code>multigroupModel</code>.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_warn">warn</code></td>
<td>
<p>print a warning if redundant paths are detected.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_...">...</code></td>
<td>
<p>For <code>multigroupModel</code>, one or more optionally named arguments each of
which is a <code>semmod</code> object produced, e.g., by <code>specifyModel</code>, <code>specifyEquations</code>,
or <code>cfa</code>; if only one such model is given, then it will be used for all groups defined by
the <code>groups</code> argument. If parameters have the same name in different groups, then they will
be constrained to be equal.
For <code>specifyEquations</code> and <code>cfa</code>, arguments (such as <code>covs</code>,
in the case of <code>specifyEquations</code>) to be 
passed to <code>specifyModel</code>; for <code>combineModels</code>, <code>sem</code> objects; 
ignored in the <code>update</code> and <code>print</code> methods.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_groups">groups</code></td>
<td>
<p>a character vector of names for the groups in a multigroup model; taken by default from
the names of the <code>...</code> arguments.</p>
</td></tr>
<tr><td><code id="specifyModel_+3A_allequal">allEqual</code></td>
<td>
<p>if <code>FALSE</code> (the default), then if only one model object is given for
a multigroup model, all corresponding parameters in the groups will be distinct; if <code>TRUE</code>,
all corresponding parameters will be constrained to be equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The principal functions for model specification are <code>specifyModel</code>,
to specify a model in RAM (path) format via single- and double-headed arrows;
<code>specifyEquations</code>, to specify a model in equation format, which is then
translated by the function into RAM format; and <code>cfa</code>, for compact
specification of simple confirmatory factor analysis models.
</p>
<p><code>specifyModel</code>:
</p>
<p>Each line of the RAM specification for <code>specifyModel</code> consists of three (unquoted) entries, 
separated by commas:
</p>

<dl>
<dt>1. Arrow specification:</dt><dd><p>This is a simple formula, of the form
<code>A -&gt; B</code> or, equivalently, <code>B &lt;- A</code> for a regression
coefficient (i.e., a single-headed or directional arrow); 
<code>A &lt;-&gt; A</code> for a variance or <code>A &lt;-&gt; B</code> for a covariance
(i.e., a double-headed or bidirectional arrow). Here, <code>A</code> and
<code>B</code> are variable names in the model. If a name does not correspond
to an observed variable, then it is assumed to be a latent variable.
Spaces can appear freely in an arrow specification, and
there can be any number of hyphens in the arrows, including zero: Thus,
e.g., <code>A-&gt;B</code>, <code>A --&gt; B</code>, and <code>A&gt;B</code> are all legitimate
and equivalent.</p>
</dd>
<dt>2. Parameter name:</dt><dd><p>The name of the regression coefficient, variance,
or covariance specified by the arrow. Assigning the same name to two or
more arrows results in an equality constraint. Specifying the parameter name
as <code>NA</code> produces a fixed parameter.</p>
</dd>
<dt>3. Value:</dt><dd><p>start value for a free parameter or value of a fixed parameter.
If given as <code>NA</code> (or simply omitted), <code>sem</code> will compute the start value.</p>
</dd>
</dl>

<p>Lines may end in a comment following <code>#</code>.
</p>
<p><code>specifyEquations</code>:
</p>
<p>For <code>specifyEquations</code>, each input line is either a regression equation or the specification
of a variance or covariance. Regression equations are of the form
</p>
<p><code>y = par1*x1 + par2*x2 + ... + park*xk</code>
</p>
<p>where <code>y</code> and the <code>x</code>s are variables in the model (either observed or latent),
and the <code>par</code>s are parameters. If a parameter is given as a numeric value (e.g.,
<code>1</code>) then it is treated as fixed. Note that no &ldquo;error&rdquo; variable is included in
the equation; &ldquo;error variances&rdquo; are specified via either the <code>covs</code> argument,
via <code>V(y) = par</code> (see immediately below), or are added automatically to the model
when, as by default, <code>endog.variances=TRUE</code>. A regression equation may be split over more
than one input by breaking at a <code>+</code>, so that <code>+</code> is either the last non-blank character
on a line or the first non-blank character on the subsequent line.
</p>
<p>Variances are specified in the form <code>V(var) = par</code> and covariances in the form
<code>C(var1, var2) = par</code>, where the <code>var</code>s are variables (observed or unobserved) in
the model. The symbols <code>V</code> and <code>C</code> may be in either lower- or upper-case. If <code>par</code>
is a numeric value (e.g., <code>1</code>) then it is treated as fixed. In conformity with the RAM model,
a variance or covariance for an endogenous variable in the model is an &ldquo;error&rdquo; variance or
covariance.
</p>
<p><em>Warning</em>: If the <code>covs</code> argument to <code>specifyEquations</code> is used to specify
variances and covariances, please be aware that
<code>covs="x1, x2"</code> and <code>covs=c("x1", "x2")</code> are <em>not</em>
equivalent: <code>covs="x1, x2"</code> specifies the variance of <code>x1</code>, the variance
of <code>x2</code>, <em>and</em> their covariance, while <code>covs=c("x1", "x2")</code> specifies
the variance of <code>x1</code> and the variance of <code>x2</code> <em>but not</em> their covariance.
</p>
<p>To set a start value for a free parameter, enclose the numeric start value in parentheses after the
parameter name, as <code>parameter(value)</code>.
</p>
<p><code>cfa</code>:
</p>
<p>For <code>cfa</code>, each input line includes the names of the variables, separated by commas, 
that load on the corresponding factor; the name of the factor is given optionally at the beginning
of the line, followed by a colon. If necessary, the variables that load on a factor may be continued
across two or more input lines; in this case, each such line but the last must end in a comma. A
variable may load on more than one factor (as long as the resulting model is identified, of course),
but each factor may appear in only one input line (or set of input lines, if the variable list
is continued onto the next line). 
</p>
<p>Equality constraints for factor loadings can be set by using equal-signs (<code>=</code>) rather than commas 
to separate observed variable names. For example, <code>fac1: x1=x2=x3, x4=x5</code> sets the loadings
for <code>x1</code>, <code>x2</code>, and <code>x3</code> equal to each other, and the loadings for <code>x4</code> and <code>x5</code>
equal to each other. 
</p>
<p>Equality constraints among error variances can similarly be specified by using <code>var:</code> or <code>variance:</code>
at the beginning of a line (actually, any character string beginning with <code>var</code> will do, and thus
no factor name may begin with the characters <code>var</code>). For example, <code>var: x1=x2=x3, x4=x5</code> sets the
error variances for <code>x1</code>, <code>x2</code>, and <code>x3</code> equal to each other, and the 
error variances for <code>x4</code> and <code>x5</code> equal to each other. There may be several lines beginning with
<code>var:</code>.
</p>
<p>If the argument <code>reference.indicators=FALSE</code>, the default,
<code>cfa</code> will fix the variance of each factor to 1, and by
default include covariances (i.e., correlations) among all pairs of factors. Alternatively,
if <code>reference.indicators=TRUE</code>, then the factor variances are free parameters to be estimated
from the data, and the first loading for each factor is set to 1 to identify the model. These two
approaches produce equivalent models, with the same fit to the data, but alternative parametrizations.
Specifying the argument <code>covs=NULL</code> implicitly fixes the factor intercorrelations to 0.
</p>
<p>See <code><a href="#topic+sem">sem</a></code> and the examples for further details on model specification.
</p>
<p>Other Functions:
</p>
<p><code>classifyVariables</code> classifies the variables in a model as endogenous or exogenous.
</p>
<p><code>combineModels</code> and <code>removeRedundantPaths</code> take <code>semmod</code> objects as arguments and do what their names imply.
</p>
<p>The <code>file</code> input argument to the <code>update</code> method for <code>semmod</code> objects, which by default comes from
standard input, is a set of update directives, one per line. There are five kinds of directives. In each case
the directive begins with the directive name, followed by one or more fields separated by commas.
</p>

<dl>
<dt>1. delete:</dt><dd><p>Remove a path from the model. Example: <code>delete, RSES -&gt; FGenAsp</code></p>
</dd>
<dt>2. add:</dt><dd><p>Add a path to the model. Example (the <code>NA</code> for the start value is optional): <code>add, RSES -&gt; FGenAsp, gam14,  NA</code></p>
</dd>
<dt>3. replace:</dt><dd><p>Replace every occurrence of the first string with the second in the variables and
parameters of the model. This directive may be used, for example, to change one variable to
another or to rename a parameter. Example: <code>replace, gam, gamma</code>, substitutes the string <code>"gamma"</code>
for <code>"gam"</code> wherever the latter appears, presumably in parameter names.</p>
</dd>
<dt>4. fix:</dt><dd><p>Fix a parameter that was formerly free. Example: <code>fix, RGenAsp  -&gt; REdAsp, 1</code></p>
</dd>
<dt>5. free:</dt><dd><p>Free a parameter that was formerly fixed. Example (the <code>NA</code> for the start value is optional): 
<code>free, RGenAsp  -&gt; ROccAsp, lam11, NA</code></p>
</dd>
</dl>

<p>The <code>edit</code> method for <code>semmod</code> objects opens the model in the R editor.
</p>


<h3>Value</h3>

<p><code>specifyModel</code>, <code>specifyEquations</code>, <code>cfa</code>, <code>removeRedundantPaths</code>, <code>combineModels</code>, 
<code>update</code>, and <code>edit</code> return an object of class <code>semmod</code>, suitable as input for <code><a href="#topic+sem">sem</a></code>.
</p>
<p><code>multigroupModel</code> returns an object of class <code>semmodList</code>, also suitable as input for <code><a href="#topic+sem">sem</a></code>.
</p>
<p><code>classifyVariables</code> returns a list with two character vectors: <code>endogenous</code>, containing the names of endogenous
variables in the model; and <code>exogenous</code>, containing the names of exogenous variables.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a> and Jarrett Byrnes</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example using the text argument:

model.dhp &lt;- specifyModel(text="
    RParAsp  -&gt; RGenAsp, gam11,  NA
    RIQ      -&gt; RGenAsp, gam12,  NA
    RSES     -&gt; RGenAsp, gam13,  NA
    FSES     -&gt; RGenAsp, gam14,  NA
    RSES     -&gt; FGenAsp, gam23,  NA
    FSES     -&gt; FGenAsp, gam24,  NA
    FIQ      -&gt; FGenAsp, gam25,  NA
    FParAsp  -&gt; FGenAsp, gam26,  NA
    FGenAsp  -&gt; RGenAsp, beta12, NA
    RGenAsp  -&gt; FGenAsp, beta21, NA
    RGenAsp  -&gt; ROccAsp,  NA,     1
    RGenAsp  -&gt; REdAsp,  lam21,  NA
    FGenAsp  -&gt; FOccAsp,  NA,     1
    FGenAsp  -&gt; FEdAsp,  lam42,  NA
    RGenAsp &lt;-&gt; RGenAsp, ps11,   NA
    FGenAsp &lt;-&gt; FGenAsp, ps22,   NA
    RGenAsp &lt;-&gt; FGenAsp, ps12,   NA
    ROccAsp &lt;-&gt; ROccAsp, theta1, NA
    REdAsp  &lt;-&gt; REdAsp,  theta2, NA
    FOccAsp &lt;-&gt; FOccAsp, theta3, NA
    FEdAsp  &lt;-&gt; FEdAsp,  theta4, NA
")    
model.dhp

   # same model in equation form:
model.dhp.1 &lt;- specifyEquations(covs="RGenAsp, FGenAsp", text="
RGenAsp = gam11*RParAsp + gam12*RIQ + gam13*RSES + gam14*FSES + beta12*FGenAsp
FGenAsp = gam23*RSES + gam24*FSES + gam25*FIQ + gam26*FParAsp + beta21*RGenAsp
ROccAsp = 1*RGenAsp
REdAsp = lam21(1)*RGenAsp  # to illustrate setting start values
FOccAsp = 1*FGenAsp
FEdAsp = lam42(1)*FGenAsp
")
model.dhp

# Note: The following examples can't be run via example() because the 
#  default file argument requires that the model specification be entered
#  at the command prompt. The examples can be copied and run in an interactive 
#  session in the R console, however.

    ## Not run: 
model.dhp &lt;- specifyModel()
    RParAsp  -&gt; RGenAsp, gam11,  NA
    RIQ      -&gt; RGenAsp, gam12,  NA
    RSES     -&gt; RGenAsp, gam13,  NA
    FSES     -&gt; RGenAsp, gam14,  NA
    RSES     -&gt; FGenAsp, gam23,  NA
    FSES     -&gt; FGenAsp, gam24,  NA
    FIQ      -&gt; FGenAsp, gam25,  NA
    FParAsp  -&gt; FGenAsp, gam26,  NA
    FGenAsp  -&gt; RGenAsp, beta12, NA
    RGenAsp  -&gt; FGenAsp, beta21, NA
    RGenAsp  -&gt; ROccAsp,  NA,     1
    RGenAsp  -&gt; REdAsp,  lam21,  NA
    FGenAsp  -&gt; FOccAsp,  NA,     1
    FGenAsp  -&gt; FEdAsp,  lam42,  NA
    RGenAsp &lt;-&gt; RGenAsp, ps11,   NA
    FGenAsp &lt;-&gt; FGenAsp, ps22,   NA
    RGenAsp &lt;-&gt; FGenAsp, ps12,   NA
    ROccAsp &lt;-&gt; ROccAsp, theta1, NA
    REdAsp  &lt;-&gt; REdAsp,  theta2, NA
    FOccAsp &lt;-&gt; FOccAsp, theta3, NA
    FEdAsp  &lt;-&gt; FEdAsp,  theta4, NA
    
model.dhp
    
# an equivalent specification, allowing specifyModel() to generate
#  variance parameters for endogenous variables (and suppressing
#  the unnecessary trailing NAs):
 
model.dhp &lt;- specifyModel()
RParAsp  -&gt; RGenAsp, gam11
RIQ      -&gt; RGenAsp, gam12
RSES     -&gt; RGenAsp, gam13
FSES     -&gt; RGenAsp, gam14
RSES     -&gt; FGenAsp, gam23
FSES     -&gt; FGenAsp, gam24
FIQ      -&gt; FGenAsp, gam25
FParAsp  -&gt; FGenAsp, gam26
FGenAsp  -&gt; RGenAsp, beta12
RGenAsp  -&gt; FGenAsp, beta21
RGenAsp  -&gt; ROccAsp,  NA,     1
RGenAsp  -&gt; REdAsp,  lam21
FGenAsp  -&gt; FOccAsp,  NA,     1
FGenAsp  -&gt; FEdAsp,  lam42
RGenAsp &lt;-&gt; FGenAsp, ps12

model.dhp

# Another equivalent specification, telling specifyModel to add paths for 
#   variances and covariance of RGenAsp and FGenAsp:
 
model.dhp &lt;- specifyModel(covs="RGenAsp, FGenAsp")
RParAsp  -&gt; RGenAsp, gam11
RIQ      -&gt; RGenAsp, gam12
RSES     -&gt; RGenAsp, gam13
FSES     -&gt; RGenAsp, gam14
RSES     -&gt; FGenAsp, gam23
FSES     -&gt; FGenAsp, gam24
FIQ      -&gt; FGenAsp, gam25
FParAsp  -&gt; FGenAsp, gam26
FGenAsp  -&gt; RGenAsp, beta12
RGenAsp  -&gt; FGenAsp, beta21
RGenAsp  -&gt; ROccAsp,  NA,     1
RGenAsp  -&gt; REdAsp,  lam21
FGenAsp  -&gt; FOccAsp,  NA,     1
FGenAsp  -&gt; FEdAsp,  lam42

model.dhp

# The same model in equation format:

model.dhp.1 &lt;- specifyEquations(covs="RGenAsp, FGenAsp")
RGenAsp = gam11*RParAsp + gam12*RIQ + gam13*RSES + gam14*FSES + beta12*FGenAsp
FGenAsp = gam23*RSES + gam24*FSES + gam25*FIQ + gam26*FParAsp + beta21*RGenAsp
ROccAsp = 1*RGenAsp
REdAsp = lam21(1)*RGenAsp  # to illustrate setting start values
FOccAsp = 1*FGenAsp
FEdAsp = lam42(1)*FGenAsp

model.dhp

classifyVariables(model.dhp)

# updating the model to impose equality constraints
#  and to rename the latent variables and gamma parameters

model.dhp.eq &lt;- update(model.dhp)
delete, RSES -&gt; FGenAsp
delete, FSES -&gt; FGenAsp
delete, FIQ  -&gt; FGenAsp
delete, FParAsp -&gt; FGenAs
delete, RGenAsp  -&gt; FGenAsp
add, RSES     -&gt; FGenAsp, gam14,  NA
add, FSES     -&gt; FGenAsp, gam13,  NA
add, FIQ      -&gt; FGenAsp, gam12,  NA
add, FParAsp  -&gt; FGenAsp, gam26,  NA
add, RGenAsp  -&gt; FGenAsp, beta12, NA
replace, gam, gamma
replace, Gen, General

model.dhp.eq

# A three-factor CFA model for the Thurstone mental-tests data, 
#    specified three equivalent ways:

R.thur &lt;- readMoments(diag=FALSE, 
    names=c('Sentences','Vocabulary',
            'Sent.Completion','First.Letters','4.Letter.Words','Suffixes',
            'Letter.Series','Pedigrees', 'Letter.Group'))
.828                                              
.776   .779                                        
.439   .493    .46                                 
.432   .464    .425   .674                           
.447   .489    .443   .59    .541                    
.447   .432    .401   .381    .402   .288              
.541   .537    .534   .35    .367   .32   .555        
.38   .358    .359   .424    .446   .325   .598   .452

	#  (1a) in CFA format:

mod.cfa.thur.c &lt;- cfa(reference.indicators=FALSE)
FA: Sentences, Vocabulary, Sent.Completion
FB: First.Letters, 4.Letter.Words, Suffixes
FC: Letter.Series, Pedigrees, Letter.Group

cfa.thur.c &lt;- sem(mod.cfa.thur.c, R.thur, 213)
summary(cfa.thur.c)

	#  (1b) in CFA format, using reference indicators:
	
mod.cfa.thur.r &lt;- cfa()
FA: Sentences, Vocabulary, Sent.Completion
FB: First.Letters, 4.Letter.Words, Suffixes
FC: Letter.Series, Pedigrees, Letter.Group

cfa.thur.r &lt;- sem(mod.cfa.thur.r, R.thur, 213)
summary(cfa.thur.r)

	#  (2) in equation format:

mod.cfa.thur.e &lt;- specifyEquations(covs="F1, F2, F3")
Sentences = lam11*F1
Vocabulary = lam21*F1
Sent.Completion = lam31*F1
First.Letters = lam42*F2
4.Letter.Words = lam52*F2
Suffixes = lam62*F2
Letter.Series = lam73*F3
Pedigrees = lam83*F3
Letter.Group = lam93*F3
V(F1) = 1
V(F2) = 1
V(F3) = 1

cfa.thur.e &lt;- sem(mod.cfa.thur.e, R.thur, 213)
summary(cfa.thur.e)

	#  (3) in path format:

mod.cfa.thur.p &lt;- specifyModel(covs="F1, F2, F3")
F1 -&gt; Sentences,                      lam11
F1 -&gt; Vocabulary,                     lam21
F1 -&gt; Sent.Completion,                lam31
F2 -&gt; First.Letters,                  lam41
F2 -&gt; 4.Letter.Words,                 lam52
F2 -&gt; Suffixes,                       lam62
F3 -&gt; Letter.Series,                  lam73
F3 -&gt; Pedigrees,                      lam83
F3 -&gt; Letter.Group,                   lam93
F1 &lt;-&gt; F1,                            NA,     1
F2 &lt;-&gt; F2,                            NA,     1
F3 &lt;-&gt; F3,                            NA,     1

cfa.thur.p &lt;- sem(mod.cfa.thur.p, R.thur, 213)
summary(cfa.thur.p)

# The Thursstone CFA model with equality constraints on the
#  factor loadings and error variances

mod.cfa.thur.ceq &lt;- cfa(reference.indicators=FALSE)
FA: Sentences = Vocabulary = Sent.Completion
FB: First.Letters = 4.Letter.Words = Suffixes
FC: Letter.Series = Pedigrees = Letter.Group
var: Sentences = Vocabulary = Sent.Completion
var: First.Letters = 4.Letter.Words = Suffixes
var: Letter.Series = Pedigrees = Letter.Group

cfa.thur.ceq &lt;- sem(mod.cfa.thur.ceq, R.thur, 213)
summary(cfa.thur.ceq)
anova(cfa.thur.c, cfa.thur.ceq)
pathDiagram(cfa.thur.ceq, ignore.double=FALSE, ignore.self=TRUE,
    min.rank="FA, FB, FC", edge.labels="values")

# a multigroup CFA model fit to the Holzinger-Swineford
#   mental-tests data 

mod.hs &lt;- cfa()
spatial: visual, cubes, paper, flags
verbal: general, paragrap, sentence, wordc, wordm
memory: wordr, numberr, figurer, object, numberf, figurew
math: deduct, numeric, problemr, series, arithmet

mod.mg &lt;- multigroupModel(mod.hs, groups=c("Female", "Male")) 

sem.mg &lt;- sem(mod.mg, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
              general + paragrap + sentence + wordc + wordm +
              wordr + numberr + figurer + object + numberf + figurew +
              deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg)

	# with cross-group equality constraints:
	
mod.mg.eq &lt;- multigroupModel(mod.hs, groups=c("Female", "Male"), allEqual=TRUE)

sem.mg.eq &lt;- sem(mod.mg.eq, data=HS.data, group="Gender",
              formula = ~ visual + cubes + paper + flags +
                general + paragrap + sentence + wordc + wordm +
                wordr + numberr + figurer + object + numberf + figurew +
                deduct + numeric + problemr + series + arithmet
              )
summary(sem.mg.eq)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='standardizedCoefficients'>Standardized Coefficients for Structural Equation Models</h2><span id='topic+standardizedCoefficients'></span><span id='topic+standardizedCoefficients.sem'></span><span id='topic+standardizedCoefficients.msem'></span><span id='topic+stdCoef'></span>

<h3>Description</h3>

<p>These functions calculate standardized regression coefficients
for structural equation models. The function <code>stdCoef</code> is
simply an abbreviation for <code>standardizedCoefficients</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizedCoefficients(object, ...)
## S3 method for class 'sem'
standardizedCoefficients(object, 
    digits = getOption("digits"), oneheaded = TRUE, twoheaded = TRUE, ...)
## S3 method for class 'msem'
standardizedCoefficients(object, ...)

stdCoef(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardizedCoefficients_+3A_object">object</code></td>
<td>
<p>an object of class <code>sem</code> or <code>msem</code> returned by the 
<code><a href="#topic+sem">sem</a></code> function.</p>
</td></tr>
<tr><td><code id="standardizedCoefficients_+3A_digits">digits</code></td>
<td>
<p>number of digits for printed output.</p>
</td></tr>
<tr><td><code id="standardizedCoefficients_+3A_oneheaded">oneheaded</code></td>
<td>
<p>standardize path coefficients? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="standardizedCoefficients_+3A_twoheaded">twoheaded</code></td>
<td>
<p>standardize variances and covariances? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="standardizedCoefficients_+3A_...">...</code></td>
<td>
<p>arguments to pass down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the coefficients, labelled 
both by parameter names and by arrows in the path diagram for the
model. The <code>msem</code> (multigroup) method computes and prints the
standardized coefficients for each group; it does not return a useful result.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a> and Adam Kramer</p>


<h3>References</h3>

<p>Bollen, K. A. (1989) 
<em>Structural Equations With Latent Variables.</em> Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># In the first example, readMoments() and specifyModel() read from the
# input stream. This example cannot be executed via example() but can be entered
# at the command prompt. The example is repeated using file input;
# this example can be executed via example(). 
    ## Not run: 
# Duncan, Haller, and Portes peer-influences model

R.DHP &lt;- readMoments(diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp"))
    .6247     
    .3269  .3669       
    .4216  .3275  .6404
    .2137  .2742  .1124  .0839
    .4105  .4043  .2903  .2598  .1839
    .3240  .4047  .3054  .2786  .0489  .2220
    .2930  .2407  .4105  .3607  .0186  .1861  .2707
    .2995  .2863  .5191  .5007  .0782  .3355  .2302  .2950
    .0760  .0702  .2784  .1988  .1147  .1021  .0931 -.0438  .2087
            
model.dhp &lt;- specifyModel()
    RParAsp  -&gt; RGenAsp, gam11,  NA
    RIQ      -&gt; RGenAsp, gam12,  NA
    RSES     -&gt; RGenAsp, gam13,  NA
    FSES     -&gt; RGenAsp, gam14,  NA
    RSES     -&gt; FGenAsp, gam23,  NA
    FSES     -&gt; FGenAsp, gam24,  NA
    FIQ      -&gt; FGenAsp, gam25,  NA
    FParAsp  -&gt; FGenAsp, gam26,  NA
    FGenAsp  -&gt; RGenAsp, beta12, NA
    RGenAsp  -&gt; FGenAsp, beta21, NA
    RGenAsp  -&gt; ROccAsp,  NA,     1
    RGenAsp  -&gt; REdAsp,  lam21,  NA
    FGenAsp  -&gt; FOccAsp,  NA,     1
    FGenAsp  -&gt; FEdAsp,  lam42,  NA
    RGenAsp &lt;-&gt; RGenAsp, ps11,   NA
    FGenAsp &lt;-&gt; FGenAsp, ps22,   NA
    RGenAsp &lt;-&gt; FGenAsp, ps12,   NA
    ROccAsp &lt;-&gt; ROccAsp, theta1, NA
    REdAsp  &lt;-&gt; REdAsp,  theta2, NA
    FOccAsp &lt;-&gt; FOccAsp, theta3, NA
    FEdAsp  &lt;-&gt; FEdAsp,  theta4, NA

sem.dhp &lt;- sem(model.dhp, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp'))
standardizedCoefficients(sem.dhp) 
	
## End(Not run)
# The following example can be executed via example():

etc &lt;- system.file(package="sem", "etc") # path to data and model files
   
(R.DHP &lt;- readMoments(file=file.path(etc, "R-DHP.txt"),
				diag=FALSE, names=c("ROccAsp", "REdAsp", "FOccAsp", 
                "FEdAsp", "RParAsp", "RIQ", "RSES", "FSES", "FIQ", "FParAsp")))
(model.dhp &lt;- specifyModel(file=file.path(etc, "model-DHP.txt")))
(sem.dhp &lt;- sem(model.dhp, R.DHP, 329,
    fixed.x=c('RParAsp', 'RIQ', 'RSES', 'FSES', 'FIQ', 'FParAsp')))
standardizedCoefficients(sem.dhp) 
</code></pre>

<hr>
<h2 id='Tests'>
Six Mental Tests
</h2><span id='topic+Tests'></span>

<h3>Description</h3>

<p>These data are from the SAS manual and consist of six mental tests for 32 students,
with some missing data. The three <code>x</code> variables are intended to load on a verbal
factor, and the three <code>y</code> variables on a math factor. The data can be used to
illustrate the estimation of a confirmatory factor analysis model by multinormal full-information
maximum-likelihood in the presence of missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tests</code></pre>


<h3>Format</h3>

<p>A data frame with 32 observations on the following 6 variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>score on verbal test 1.</p>
</dd>
<dt><code>x2</code></dt><dd><p>score on verbal test 2.</p>
</dd>
<dt><code>x3</code></dt><dd><p>score on verbal test 3.</p>
</dd>
<dt><code>y1</code></dt><dd><p>score on math test 1.</p>
</dd>
<dt><code>y2</code></dt><dd><p>score on math test 2.</p>
</dd>
<dt><code>y3</code></dt><dd><p>score on math test 3.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Example 25.13 from <em>SAS/STAT 9.22 User's Guide</em>, SAS Institute, 2010.
</p>

<hr>
<h2 id='tsls'>Two-Stage Least Squares</h2><span id='topic+tsls'></span><span id='topic+tsls.formula'></span><span id='topic+tsls.default'></span><span id='topic+fitted.tsls'></span><span id='topic+residuals.tsls'></span><span id='topic+coef.tsls'></span><span id='topic+vcov.tsls'></span><span id='topic+anova.tsls'></span><span id='topic+print.tsls'></span><span id='topic+summary.tsls'></span><span id='topic+print.summary.tsls'></span>

<h3>Description</h3>

<p>Fits a regression equation, such as an equation in a structural-equation model, by two-stage least squares. This
is equivalent to direct instrumental-variables estimation when the number of
instruments is equal to the number of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
tsls(formula, instruments, data, subset, weights, 
	na.action, contrasts=NULL, ...)
## Default S3 method:
tsls(y, X, Z, w, names=NULL, ...)

## S3 method for class 'tsls'
print(x, ...)
## S3 method for class 'tsls'
summary(object, digits=getOption("digits"), ...)
## S3 method for class 'summary.tsls'
print(x, ...)
## S3 method for class 'tsls'
anova(object, model.2, s2, dfe, ...)

## S3 method for class 'tsls'
fitted(object, ...)
## S3 method for class 'tsls'
residuals(object, ...)
## S3 method for class 'tsls'
coef(object, ...)
## S3 method for class 'tsls'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsls_+3A_formula">formula</code></td>
<td>
<p>model formula for structural equation to be estimated; a regression
constant is implied if not explicitly omitted.</p>
</td></tr>
<tr><td><code id="tsls_+3A_instruments">instruments</code></td>
<td>
<p>one-sided model formula specifying instrumental variables.</p>
</td></tr>
<tr><td><code id="tsls_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model. 
By default the variables are taken from the environment from which <code>tsls</code> is
called.</p>
</td></tr>
<tr><td><code id="tsls_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in 
fitting the model.</p>
</td></tr>
<tr><td><code id="tsls_+3A_weights">weights</code>, <code id="tsls_+3A_w">w</code></td>
<td>
<p>an optional vector of weights to be used in the fitting process; 
if specified should be a non-negative numeric vector with one entry for each
observation, to be used to compute weighted 2SLS estimates.</p>
</td></tr>
<tr><td><code id="tsls_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the 
data contain <code>NA</code>s. 
The default is set by the <code>na.action</code> option.</p>
</td></tr>
<tr><td><code id="tsls_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> argument of 
<code><a href="stats.html#topic+model.matrix">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="tsls_+3A_y">y</code></td>
<td>
<p>Response-variable vector.</p>
</td></tr>
<tr><td><code id="tsls_+3A_x">X</code></td>
<td>
<p>Matrix of predictors, including a constant (if one is in the model).</p>
</td></tr>
<tr><td><code id="tsls_+3A_z">Z</code></td>
<td>
<p>Matrix of instrumental variables, including a constant (if one is in the model).</p>
</td></tr>
<tr><td><code id="tsls_+3A_names">names</code></td>
<td>
<p>optional character vector of names for the columns of the <code>X</code> matrix.</p>
</td></tr>
<tr><td><code id="tsls_+3A_x">x</code>, <code id="tsls_+3A_object">object</code>, <code id="tsls_+3A_model.2">model.2</code></td>
<td>
<p>objects of class <code>tsls</code> returned by <code>tsls.formula</code> 
(or of class <code>summary.tsls</code>), for <code>anova</code> 
containing nested models
to be compared by an incremental <code class="reqn">F</code>-test. One model should be nested in the other; the
order of models is immaterial.</p>
</td></tr>
<tr><td><code id="tsls_+3A_s2">s2</code></td>
<td>
<p>an optional estimate of error variance for the denominator of the <code class="reqn">F</code>-test. 
If missing, the error-variance estimate is taken from the larger model.</p>
</td></tr>
<tr><td><code id="tsls_+3A_dfe">dfe</code></td>
<td>
<p>optional error degrees of freedom, to be specified when an estimate of error
variance is given.</p>
</td></tr>
<tr><td><code id="tsls_+3A_digits">digits</code></td>
<td>
<p>number of digits for summary output.</p>
</td></tr>
<tr><td><code id="tsls_+3A_...">...</code></td>
<td>
<p>arguments to be passed down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tsls.formula</code> returns an object of class <code>tsls</code>, with the following components:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>number of parameters.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>parameter estimates.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>estimated covariance matrix of coefficients.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>residual standard error.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>vector of residuals.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>vector of response values.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>model matrix.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>instrumental-variables matrix.</p>
</td></tr>
<tr><td><code>response.name</code></td>
<td>
<p>name of response variable, or expression evaluating to response.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>model formula.</p>
</td></tr>
<tr><td><code>instruments</code></td>
<td>
<p>one-sided formula for instrumental variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

    
<p>Fox, J. (1979)
Simultaneous equation models and two-stage least-squares.
In Schuessler, K. F. (ed.)
<em>Sociological Methodology 1979</em>, Jossey-Bass.
</p>
<p>Greene, W. H. (1993)
<em>Econometric Analysis, Second Edition</em>, Macmillan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sem">sem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(tsls(Q ~ P + D, ~ D + F + A, data=Kmenta))     # demand equation

summary(tsls(Q ~ P + F + A, ~ D + F + A, data=Kmenta)) # supply equation

anova(tsls(Q ~ P + F + A, ~ D + F + A, data=Kmenta),
    tsls(Q ~ 1, ~ D + F + A, data=Kmenta))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
