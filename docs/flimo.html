<!DOCTYPE html><html><head><title>Help for package flimo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flimo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_simulator'><p>Check if simulator with fixed quantiles is well implemented</p></a></li>
<li><a href='#flimobjective'><p>Objective function minimized by flimo</p></a></li>
<li><a href='#flimoptim'><p>Main function to use flimo inference</p></a></li>
<li><a href='#flimoptim_Julia'><p>Internal flimoptim function in Julia mode</p></a></li>
<li><a href='#flimoptim_R'><p>Internal flimoptim function in R mode</p></a></li>
<li><a href='#julia_load'><p>Load Julia</p></a></li>
<li><a href='#julia_setup'><p>Check Julia setup</p></a></li>
<li><a href='#plot_objective'><p>Plot the objective to be minimized using flimo</p></a></li>
<li><a href='#plot.flimo_result'><p>Plot main flimo results</p></a></li>
<li><a href='#print.flimo_result'><p>Print flimo results</p></a></li>
<li><a href='#sampleQ'><p>Sample function with fixed quantiles</p></a></li>
<li><a href='#summary.flimo_result'><p>Summary of flimo results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fixed Landscape Inference Method</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Likelihood-free inference method for stochastic models.
    Uses a deterministic optimizer on simple simulations of the model
    that are performed with a prior drawn randomness by applying the inverse transform method.
    Is designed to work on its own and also by using the Julia package 'Jflimo'
    available on the git page of the project: <a href="https://metabarcoding.org/flimo">https://metabarcoding.org/flimo</a>.</td>
</tr>
<tr>
<td>Imports:</td>
<td>compiler, ggplot2, JuliaConnectoR</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL version 2</a> | <a href="https://www.cecill.info/licences/Licence_CeCILL_V2.1-en.txt">CECILL-2.1</a> [expanded from: CeCILL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-14 22:33:51 UTC; sylvainmoi</td>
</tr>
<tr>
<td>Author:</td>
<td>Sylvain Moinard [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sylvain Moinard &lt;sylvain.moinard@univ-grenoble-alpes.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-14 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_simulator'>Check if simulator with fixed quantiles is well implemented</h2><span id='topic+check_simulator'></span>

<h3>Description</h3>

<p>Run simulations to catch random variations.
Warning : does not check it formally.
Warning : does not check if quantiles are used several times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_simulator(
  simulatorQ,
  ndraw,
  Theta_lower = 0,
  Theta_upper = 1,
  ntheta = 5,
  nruns = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_simulator_+3A_simulatorq">simulatorQ</code></td>
<td>
<p>Function of type simulatorQ(Theta, quantiles)
where Theta is the parameter set for the simulations and
quantiles are drawn in U(0,1).</p>
</td></tr>
<tr><td><code id="check_simulator_+3A_ndraw">ndraw</code></td>
<td>
<p>Integer. Number of random variables to draw
for one simulation of the model.</p>
</td></tr>
<tr><td><code id="check_simulator_+3A_theta_lower">Theta_lower</code></td>
<td>
<p>1D numeric array. Lower bounds of Theta parameters.</p>
</td></tr>
<tr><td><code id="check_simulator_+3A_theta_upper">Theta_upper</code></td>
<td>
<p>1D numeric array. Upper bounds of Theta parameters.</p>
</td></tr>
<tr><td><code id="check_simulator_+3A_ntheta">ntheta</code></td>
<td>
<p>Integer. Number of Theta parameters to test.</p>
</td></tr>
<tr><td><code id="check_simulator_+3A_nruns">nruns</code></td>
<td>
<p>Integer. For each Theta, number of simulations to run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean. True if no random effect was detected, False else.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulatorQ &lt;- function(Theta, quantiles){
qpois(quantiles, lambda = Theta)
}
check_simulator(simulatorQ, 5,
Theta_lower = 50, Theta_upper = 150)

</code></pre>

<hr>
<h2 id='flimobjective'>Objective function minimized by flimo</h2><span id='topic+flimobjective'></span>

<h3>Description</h3>

<p>Computes the summary statistics between simulations w.r.t.
Theta and data. This function is to be minimized by flimoptim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flimobjective(Theta, quantiles, data, dsumstats, simulatorQ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flimobjective_+3A_theta">Theta</code></td>
<td>
<p>1D array. parameters for the simulations.</p>
</td></tr>
<tr><td><code id="flimobjective_+3A_quantiles">quantiles</code></td>
<td>
<p>2D array containing values drawn in U(0,1).
Row number = number of simulations.
Column number = number of random variables to draw in one simulation.</p>
</td></tr>
<tr><td><code id="flimobjective_+3A_data">data</code></td>
<td>
<p>1D array containing the observations.</p>
</td></tr>
<tr><td><code id="flimobjective_+3A_dsumstats">dsumstats</code></td>
<td>
<p>Function computing the distance between simulations and data
of form dsumstats(simulations, data) where
simulations : 2D array and data : 1D array.
ncol(simulations) = length(data) mandatory.</p>
</td></tr>
<tr><td><code id="flimobjective_+3A_simulatorq">simulatorQ</code></td>
<td>
<p>Function of type simulatorQ(Theta, quantiles)
where Theta is the parameter set for the simulations
and quantiles are drawn in U(0,1).
See README for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value. Distance between summary statistics of data
and simulations w.r.t. Theta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
quantiles &lt;- matrix(runif(50), nrow = 10)

data &lt;- rep(100, 5)

dsumstats &lt;- function(simulations, data){
mean_simu &lt;- mean(rowMeans(simulations))
mean_data &lt;- mean(data)
(mean_simu-mean_data)^2
}

simulatorQ &lt;- function(Theta, quantiles){
qpois(quantiles, lambda = Theta)
}

flimobjective(100, quantiles, data, dsumstats, simulatorQ)

</code></pre>

<hr>
<h2 id='flimoptim'>Main function to use flimo inference</h2><span id='topic+flimoptim'></span>

<h3>Description</h3>

<p>Computes several parameter inferences with R optimizer or
Julia optimizer in a full Julia mode.
In R mode (default) : L-BFGS-B optimization or other methods available for
the base::optim function.
In Julia mode : either IPNewton with or without Automatic Differentiation,
Nelder-Mead or Brent optimization.
Argument ndraw is mandatory.
You need either to provide data, dsumstats AND simulatorQ
OR obj.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flimoptim(
  ndraw,
  data = NULL,
  dsumstats = NULL,
  simulatorQ = NULL,
  obj = NULL,
  nsim = 10,
  ninfer = 1,
  lower = 0,
  upper = 1,
  Theta0 = (lower + upper)/2,
  randomTheta0 = FALSE,
  mode = c("R", "Julia"),
  AD = TRUE,
  method = "",
  obj_threshold = Inf,
  number_tries = 1,
  maxit = 1000,
  time_limit = NaN,
  factr = 1e+07,
  pgtol = 0,
  xtol = 0,
  ftol = 0,
  gtol = 1e-08,
  reltol = sqrt(.Machine$double.eps),
  abstol = .Machine$double.eps,
  show_trace = FALSE,
  store_trace = FALSE,
  store_quantiles = FALSE,
  par_names = NULL,
  load_julia = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flimoptim_+3A_ndraw">ndraw</code></td>
<td>
<p>Integer. Number of random variables to draw
for one simulation of the model.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_data">data</code></td>
<td>
<p>1D array containing the observations.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_dsumstats">dsumstats</code></td>
<td>
<p>Summary statistics to measure distance
between simulations and data.
In R mode : R function of type dsumstats(simulations, data)
where simulations : 2D array and data : 1D array.
ncol(simulations) = length(data) mandatory.
In Julia mode : a string containing the script of the Julia function
dsumstats(simulations, data). The name &quot;dsumstats&quot; is mandatory.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_simulatorq">simulatorQ</code></td>
<td>
<p>Simulator of the stochastic process with fixed quantiles
(see README).
or a string (in mode &quot;Julia&quot;) containing the script of the Julia function
simulatorQ(Theta, quantiles).
In Julia mode, the name &quot;simulatorQ&quot; is mandatory.
Theta is the parameter set for the simulations and
quantiles are drawn in U(0,1).</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_obj">obj</code></td>
<td>
<p>Objective function to minimize.
Default : is directly computed from dsumstats and simulatorQ.
Either an R function of type objective(Theta, quantiles) (in mode &quot;R&quot;)
or a string (in mode &quot;Julia&quot;) containing the script of the Julia function
julia_obj(Theta, quantiles).
Warning : could be tricky if mode = &quot;Julia&quot; to call data.
In Julia mode, the name &quot;julia_obj&quot; is mandatory.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_nsim">nsim</code></td>
<td>
<p>Integer. Number of simulations to run for each step
of the optimization algorithm.
Computation time grows linearly with this number. Default to 10.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_ninfer">ninfer</code></td>
<td>
<p>Integer. Number of independent inferences to run. Default to 1.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_lower">lower</code></td>
<td>
<p>1D array. Lower bounds for parameters. Same length as upper.
With Nelder-Mead in Julia mode: only used for starting point.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_upper">upper</code></td>
<td>
<p>1D array. Upper bounds for parameters. Same length as lower.
With Nelder-Mead in Julia mode: only used for starting point.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_theta0">Theta0</code></td>
<td>
<p>1D array. Initial values of the parameters.
Default : mean(lower, upper).</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_randomtheta0">randomTheta0</code></td>
<td>
<p>Boolean.
If True, Theta0 is randomly drawn between lower and upper bounds.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_mode">mode</code></td>
<td>
<p>String. &quot;R&quot; (default) or &quot;Julia&quot;. See README.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_ad">AD</code></td>
<td>
<p>Boolean.
Only in Julia mode, uses Automatic Differentiation with IPNewton method.
Default to true.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_method">method</code></td>
<td>
<p>String.
In Julia mode, allows to choose the optimization method :
&quot;IPNewton&quot;, &quot;Brent&quot; or &quot;NelderMead&quot;. Default : IPNewton.
In R mode, allows to choose any of the optimization methods used by
base::optim. Default is L-BFGS-B. Random methods do not work with flimo.
Bounded methods are L-BFGS-B and Brent.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_obj_threshold">obj_threshold</code></td>
<td>
<p>Float. Threshold score. If final value of objective is
bigger, relaunch the inference if number_tries is not reached.
The purpose is to avoid local minima. Default to Inf (no threshold).</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_number_tries">number_tries</code></td>
<td>
<p>Integer. Number of tries (inferences) for the objective
value to reach a point lower than obj_threshold. Default to 1.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_maxit">maxit</code></td>
<td>
<p>Integer. Max number of iterations during optimization.
Default to 1000.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_time_limit">time_limit</code></td>
<td>
<p>Float. Time limit in second for each inference.
Default to no limit. Not available for R mode and Brent method in Julia mode.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_factr">factr</code></td>
<td>
<p>Float.
In R-mode : control parameter for L-BFGS-B method in stats::optim.
Default to 1e7.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_pgtol">pgtol</code></td>
<td>
<p>Float.
In R-mode : control parameter for L-BFGS-B method in stats::optim.
Default to 0.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_xtol">xtol</code></td>
<td>
<p>Float.
In Julia mode with IPNewton method : xtol option in Optim.Options.
Default to 0.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_ftol">ftol</code></td>
<td>
<p>Float.
In Julia mode with IPNewton method : ftol option in Optim.Options.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_gtol">gtol</code></td>
<td>
<p>Float.
In Julia mode with IPNewton method : gtol option in Optim.Options.
Default to 1e-8.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_reltol">reltol</code></td>
<td>
<p>Float.
In Julia mode with Brent method : reltol of Optim.optimize.
Default is sqrt(.Machine$double.eps), about 1e-8.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_abstol">abstol</code></td>
<td>
<p>Float.
In Julia mode with Brent method : abstol of Optim.optimize.
Default is .Machine$double.eps, about 1e-16.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_show_trace">show_trace</code></td>
<td>
<p>Boolean. If true, shows standard trace. Default to false.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_store_trace">store_trace</code></td>
<td>
<p>Boolean.
If true, stores standard trace as an array of strings.
Default to false. Not available for R mode.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_store_quantiles">store_quantiles</code></td>
<td>
<p>Boolean.
If true, stores every quantiles used for inference, to reproduce the results.
Default to false.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_par_names">par_names</code></td>
<td>
<p>vector of names for parameters.
Default is &quot;par1&quot;, ..., &quot;parn&quot;.</p>
</td></tr>
<tr><td><code id="flimoptim_+3A_load_julia">load_julia</code></td>
<td>
<p>Boolean. If true, run julia_load.
It can take few seconds. Default to False.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class flimo_result (list)
(converted from Julia object in Julia mode) containing every information
about convergence results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rep(100, 5)

simulatorQ &lt;- function(Theta, quantiles){
qpois(quantiles, lambda = Theta)
}
dsumstats &lt;- function(simulations, data){
mean_simu &lt;- mean(rowMeans(simulations))
mean_data &lt;- mean(data)
(mean_simu-mean_data)^2
}

flimoptim(5, data, dsumstats, simulatorQ,
lower = 50,
upper = 150)

</code></pre>

<hr>
<h2 id='flimoptim_Julia'>Internal flimoptim function in Julia mode</h2><span id='topic+flimoptim_Julia'></span>

<h3>Description</h3>

<p>Computes several parameter inferences with Julia optimizer and
either IPNewton with or without Automatic Differentiation, Nelder-Mead
or Brent method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flimoptim_Julia(
  ndraw,
  data = NULL,
  dsumstats = NULL,
  simulatorQ = NULL,
  julia_obj = NULL,
  nsim = 10,
  ninfer = 1,
  lower = 0,
  upper = 1,
  Theta0 = (lower + upper)/2,
  randomTheta0 = FALSE,
  AD = TRUE,
  method = "",
  obj_threshold = Inf,
  number_tries = 1,
  maxit = 1000,
  time_limit = NULL,
  xtol = 0,
  ftol = 0,
  gtol = 1e-08,
  reltol = sqrt(.Machine$double.eps),
  abstol = .Machine$double.eps,
  show_trace = FALSE,
  store_trace = FALSE,
  store_quantiles = FALSE,
  par_names = NULL,
  load_julia = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flimoptim_Julia_+3A_ndraw">ndraw</code></td>
<td>
<p>Integer. Number of random variables to draw
for one simulation of the model.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_data">data</code></td>
<td>
<p>1D array containing the observations.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_dsumstats">dsumstats</code></td>
<td>
<p>Summary statistics to measure distance
between simulations and data.
String containing the script of the Julia function
dsumstats(simulations, data).
The name &quot;dsumstats&quot; is mandatory.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_simulatorq">simulatorQ</code></td>
<td>
<p>Simulator of the stochastic process
with fixed quantiles (see README).
simulatorQ(Theta, quantiles).
The name &quot;simulatorQ&quot; is mandatory.
Theta is the parameter set for the simulations and
quantiles are drawn in U(0,1).</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_julia_obj">julia_obj</code></td>
<td>
<p>Objective function to minimize.
Default : is directly computed from dsumstats and simulatorQ.
String containing the script of the Julia function
julia_obj(Theta, quantiles).
Warning : can be tricky to call data.
The name &quot;julia_obj&quot; is mandatory.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_nsim">nsim</code></td>
<td>
<p>Integer. Number of simulations to run for each step
of the optimization algorithm.
Computation time grows linearly with this number. Default to 10.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_ninfer">ninfer</code></td>
<td>
<p>Integer. Number of independent inferences to run. Default to 1.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_lower">lower</code></td>
<td>
<p>1D array. Lower bounds for parameters. Same length as upper.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_upper">upper</code></td>
<td>
<p>1D array. Upper bounds for parameters. Same length as lower.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_theta0">Theta0</code></td>
<td>
<p>1D array. Initial values of the parameters.
Default : mean(lower, upper).</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_randomtheta0">randomTheta0</code></td>
<td>
<p>Boolean.
If True, Theta0 is randomly drawn between lower and upper bounds.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_ad">AD</code></td>
<td>
<p>Boolean.
Only in Julia mod, uses Automatic Differentiation with IPNewton method.
Default to true.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_method">method</code></td>
<td>
<p>String.
Allows to choose the optimization method :
&quot;Brent&quot;, &quot;IPNewton&quot; or &quot;NelderMead&quot;. Default : IPNewton.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_obj_threshold">obj_threshold</code></td>
<td>
<p>Float. Threshold score. If Final value of objective is
bigger, relaunch the inference if number_tries is not reached.
The purpose is to avoid local minima. Default to Inf (no threshold).</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_number_tries">number_tries</code></td>
<td>
<p>Integer. Number of tries (inferences) for the objective
value to reach a point lower than obj_threshold. Default to 1.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_maxit">maxit</code></td>
<td>
<p>Integer. Max number of iterations during optimization.
Default to 1000.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_time_limit">time_limit</code></td>
<td>
<p>Float. Time limit in second for each inference.
Default to no limit. Not available for Brent method.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_xtol">xtol</code></td>
<td>
<p>Float. With IPNewton method : xtol option in Optim.Options.
Default to 0.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_ftol">ftol</code></td>
<td>
<p>Float. With IPNewton method : ftol option in Optim.Options.
Default to 0.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_gtol">gtol</code></td>
<td>
<p>Float. With IPNewton method : gtol option in Optim.Options.
Default to 1e-8.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_reltol">reltol</code></td>
<td>
<p>Float. With Brent method : reltol of Optim.optimize.
Default is sqrt(.Machine$double.eps), about 1e-8.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_abstol">abstol</code></td>
<td>
<p>Float. With Brent method : abstol of Optim.optimize.
Default is .Machine$double.eps, about 1e-16.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_show_trace">show_trace</code></td>
<td>
<p>Boolean. If true, shows standard trace. Default to false.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_store_trace">store_trace</code></td>
<td>
<p>Boolean.
If true, stores standard trace as an array of strings.
Default to false. Not available for R mod.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_store_quantiles">store_quantiles</code></td>
<td>
<p>Boolean.
If true, stores every quantiles used for inference, to reproduce the results.
Default to false.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_par_names">par_names</code></td>
<td>
<p>vector of names for parameters.
Default is &quot;par1&quot;, ..., &quot;parn&quot;.</p>
</td></tr>
<tr><td><code id="flimoptim_Julia_+3A_load_julia">load_julia</code></td>
<td>
<p>Boolean. If true, run julia_load. It can take few seconds.
Default to False.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class flimo_result (list) converted from Julia object
containing every information about convergence results.
</p>

<hr>
<h2 id='flimoptim_R'>Internal flimoptim function in R mode</h2><span id='topic+flimoptim_R'></span>

<h3>Description</h3>

<p>Computes several parameter inferences with R optimizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flimoptim_R(
  ndraw,
  data = NULL,
  dsumstats = NULL,
  simulatorQ = NULL,
  obj = NULL,
  nsim = 10,
  ninfer = 1,
  lower = 0,
  upper = 1,
  Theta0 = (lower + upper)/2,
  randomTheta0 = FALSE,
  obj_threshold = Inf,
  method = "L-BFGS-B",
  number_tries = 1,
  maxit = 1000,
  factr = 1e+07,
  pgtol = 0,
  show_trace = FALSE,
  store_quantiles = FALSE,
  par_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flimoptim_R_+3A_ndraw">ndraw</code></td>
<td>
<p>Integer. Number of random variables to draw
for one simulation of the model.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_data">data</code></td>
<td>
<p>1D array containing the observations.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_dsumstats">dsumstats</code></td>
<td>
<p>Summary statistics to measure distance
between simulations and data.
R function of type dsumstats(simulations, data)
where simulations : 2D array and data : 1D array.
ncol(simulations) = length(data) mandatory.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_simulatorq">simulatorQ</code></td>
<td>
<p>Simulator of the stochastic process with fixed quantiles
(see README).
Theta is the parameter set for the simulations and
quantiles are drawn in U(0,1).</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_obj">obj</code></td>
<td>
<p>Objective function to minimize.
Default : is directly computed from dsumstats and simulatorQ.
R function of type objective(Theta, quantiles)</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_nsim">nsim</code></td>
<td>
<p>Integer. Number of simulations to run for each step
of the optimization algorithm.
Computation time grows linearly with this number. Default to 10.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_ninfer">ninfer</code></td>
<td>
<p>Integer. Number of independent inferences to run. Default to 1.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_lower">lower</code></td>
<td>
<p>1D array. Lower bounds for parameters. Same length as upper.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_upper">upper</code></td>
<td>
<p>1D array. Upper bounds for parameters. Same length as lower.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_theta0">Theta0</code></td>
<td>
<p>1D array. Initial values of the parameters.
Default : mean(lower, upper).</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_randomtheta0">randomTheta0</code></td>
<td>
<p>Boolean.
If True, Theta0 is randomly drawn between lower and upper bounds.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_obj_threshold">obj_threshold</code></td>
<td>
<p>Float. Threshold score. If Final value of objective is
bigger, relaunch the inference if number_tries is not reached.
The purpose is to avoid local minima. Default to Inf (no threshold).</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_method">method</code></td>
<td>
<p>String. Either &quot;L-BFGS-B&quot; (default) or any other method used by
the base function optim. Stochastic methods do not work with flimo.
If you want to provide bounds, you need to use L-BFGS-B or Brent.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_number_tries">number_tries</code></td>
<td>
<p>Integer. Number of tries (inferences) for the objective
value to reach a point lower than obj_threshold. Default to 1.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_maxit">maxit</code></td>
<td>
<p>Integer. Max number of iterations during optimization.
Default to 1000.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_factr">factr</code></td>
<td>
<p>Float. Control parameter for L-BFGS-B method in stats::optim.
Default to 1e7.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_pgtol">pgtol</code></td>
<td>
<p>Float. Control parameter for L-BFGS-B method in stats::optim.
Default to 0.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_show_trace">show_trace</code></td>
<td>
<p>Boolean. If true, shows standard trace. Default to false.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_store_quantiles">store_quantiles</code></td>
<td>
<p>Boolean.
If true, stores every quantiles used for inference, to reproduce the results.</p>
</td></tr>
<tr><td><code id="flimoptim_R_+3A_par_names">par_names</code></td>
<td>
<p>vector of names for parameters.
Default is &quot;par1&quot;, ..., &quot;parn&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class flimo_result (list) containing every information
about convergence results.
</p>

<hr>
<h2 id='julia_load'>Load Julia</h2><span id='topic+julia_load'></span>

<h3>Description</h3>

<p>Load needed Julia packages. Run to use Jflimo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>julia_load()
</code></pre>


<h3>Value</h3>

<p>Boolean. True if load is done correctly
</p>

<hr>
<h2 id='julia_setup'>Check Julia setup</h2><span id='topic+julia_setup'></span>

<h3>Description</h3>

<p>Checks installation of Julia and install the needed packages.
May take little time to run.Only run the first time you use Jflimo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>julia_setup()
</code></pre>


<h3>Value</h3>

<p>Boolean. True if correct setup, False else.
</p>

<hr>
<h2 id='plot_objective'>Plot the objective to be minimized using flimo</h2><span id='topic+plot_objective'></span>

<h3>Description</h3>

<p>Plot of the objective function with one parameter moving
(objective = f(theta_index)).
You need either to provide data, dsumstats AND simulatorQ
OR obj.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_objective(
  ndraw,
  data = NULL,
  dsumstats = NULL,
  simulatorQ = NULL,
  obj = NULL,
  quantiles = NULL,
  index = NULL,
  other_param = NULL,
  nsim = 10,
  lower = 0,
  upper = 1,
  dim2 = TRUE,
  visualize_min = TRUE,
  plot_legend = TRUE,
  npoints = 300,
  add_to_plot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_objective_+3A_ndraw">ndraw</code></td>
<td>
<p>Integer.Number of random variables to draw
for one simulation of the model.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_data">data</code></td>
<td>
<p>1D array containing the observations.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_dsumstats">dsumstats</code></td>
<td>
<p>Function computing the distance
between simulations and data of form dsumstats(simulations, data)
where simulations : 2D array and data : 1D array.
ncol(simulations) = length(data) mandatory.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_simulatorq">simulatorQ</code></td>
<td>
<p>Function of type simulatorQ(Theta, quantiles)
where Theta is the parameter set for the simulations and
quantiles are drawn in U(0,1).</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_obj">obj</code></td>
<td>
<p>objective function of type objective(Theta, quantiles).
Default : directly computed with &quot;dsumstats&quot; and &quot;simulatorQ&quot;.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_quantiles">quantiles</code></td>
<td>
<p>2D array containing values drawn in U(0,1).
Row number = number of simulations. Default: simulated within the function.
Column number = number of random variables to draw in one simulation.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_index">index</code></td>
<td>
<p>Integer. Index of the moving parameter.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_other_param">other_param</code></td>
<td>
<p>Other parameters of the model. If NULL : assume 1D-model.
If numeric : 2D-model, one curve.
If 1D-array and dim2 is True (default) :
2D-model, one curve by value in other_param.
If 1D-array and dim2 is False or 2D-array : (n&gt;2)D-model,
one curve by row in other_param.
If your model has n&gt;2 dimensions,
you should define other_param as a matrix even if
you have only one parameter set to test
(with as.matrix(t(vect_param)) where vect_param is a 1D-array).</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_nsim">nsim</code></td>
<td>
<p>Integer. Number of simulations to run for each step
of the optimization algorithm.
Computation time grows linearly with this number. Default to 10.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_lower">lower</code></td>
<td>
<p>Numeric. Lower value of the plot.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_upper">upper</code></td>
<td>
<p>Numeric. Upper value of the plot.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_dim2">dim2</code></td>
<td>
<p>Boolean. True if model is 2-dimensional.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_visualize_min">visualize_min</code></td>
<td>
<p>Boolean. If True, show explicitly the minimum point.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_plot_legend">plot_legend</code></td>
<td>
<p>Boolean. If True (default), plots the legend.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_npoints">npoints</code></td>
<td>
<p>Integer. Number of points evaluated. Default = 300.</p>
</td></tr>
<tr><td><code id="plot_objective_+3A_add_to_plot">add_to_plot</code></td>
<td>
<p>ggplot object. If not NULL,
will add all curves/points on previous plot instead of creating a new one.
Does not change title/labels/limits defined in previous plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object representing the objective function to be minimized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rep(100, 5)

dsumstats &lt;- function(simulations, data){
mean_simu &lt;- mean(rowMeans(simulations))
mean_data &lt;- mean(data)
(mean_simu-mean_data)^2
}

simulatorQ &lt;- function(Theta, quantiles){
qpois(quantiles, lambda = Theta)
}

plot_objective(5, data, dsumstats, simulatorQ,
lower = 0, upper = 200)

</code></pre>

<hr>
<h2 id='plot.flimo_result'>Plot main flimo results</h2><span id='topic+plot.flimo_result'></span>

<h3>Description</h3>

<p>Shows the plots for most important inference results.
Default only shows normalized boxplots for each inferred parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flimo_result'
plot(
  x,
  y,
  ...,
  hist = FALSE,
  bins = 1 + as.integer(nrow(x$minimizer)^(1/3)),
  par_minimum = FALSE,
  pairwise_par = FALSE,
  boxplot = TRUE,
  par_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.flimo_result_+3A_x">x</code></td>
<td>
<p>Object of class flimo_result.</p>
</td></tr>
<tr><td><code id="plot.flimo_result_+3A_y">y</code></td>
<td>
<p>unused generic argument.</p>
</td></tr>
<tr><td><code id="plot.flimo_result_+3A_...">...</code></td>
<td>
<p>optional args for generic method</p>
</td></tr>
<tr><td><code id="plot.flimo_result_+3A_hist">hist</code></td>
<td>
<p>Boolean. If True, plots the histogram of each inferred parameter.
Default to false.</p>
</td></tr>
<tr><td><code id="plot.flimo_result_+3A_bins">bins</code></td>
<td>
<p>Integer. Number of bins if hist is True.</p>
</td></tr>
<tr><td><code id="plot.flimo_result_+3A_par_minimum">par_minimum</code></td>
<td>
<p>Boolean.
If True, plots each inferred parameter by reached minimum. Default to false.</p>
</td></tr>
<tr><td><code id="plot.flimo_result_+3A_pairwise_par">pairwise_par</code></td>
<td>
<p>Boolean.
If True, plots each pairs of inferred parameters.Default to false.</p>
</td></tr>
<tr><td><code id="plot.flimo_result_+3A_boxplot">boxplot</code></td>
<td>
<p>Boolean.
If True, plots the boxplots of each inferred parameter scaled by their mean.
Default to true.</p>
</td></tr>
<tr><td><code id="plot.flimo_result_+3A_par_names">par_names</code></td>
<td>
<p>Vector of names for parameters.
Default is &quot;par1&quot;, ..., &quot;parn&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Prints the asked ggplot objects.
</p>

<hr>
<h2 id='print.flimo_result'>Print flimo results</h2><span id='topic+print.flimo_result'></span>

<h3>Description</h3>

<p>Prints most important information about inference results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flimo_result'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.flimo_result_+3A_x">x</code></td>
<td>
<p>Object of class flimo_result from any mod/method algorithm
of the flimo package.</p>
</td></tr>
<tr><td><code id="print.flimo_result_+3A_...">...</code></td>
<td>
<p>optional args for generic method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String containing most important information about argument
of class flimo_result.
</p>

<hr>
<h2 id='sampleQ'>Sample function with fixed quantiles</h2><span id='topic+sampleQ'></span>

<h3>Description</h3>

<p>Replace the sample function in the context of fixed quantiles.
Warning : first argument has less features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleQ(x, size, quantiles, replace = FALSE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleQ_+3A_x">x</code></td>
<td>
<p>a vector of one or more elements from which to choose.</p>
</td></tr>
<tr><td><code id="sampleQ_+3A_size">size</code></td>
<td>
<p>a non-negative integer giving the number of items to choose.</p>
</td></tr>
<tr><td><code id="sampleQ_+3A_quantiles">quantiles</code></td>
<td>
<p>1D array containing values drawn in U(0,1).
Length has to be equal to size.</p>
</td></tr>
<tr><td><code id="sampleQ_+3A_replace">replace</code></td>
<td>
<p>should sampling be with replacement ?</p>
</td></tr>
<tr><td><code id="sampleQ_+3A_prob">prob</code></td>
<td>
<p>a vector of probability weights for obtaining
the elements of the vector being sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length size with elements drawn from x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
quantiles &lt;- runif(40)
sampleQ(1:10, 10, quantiles[1:10])
sampleQ(1:10, 10, quantiles[11:20])
sampleQ(11:20, 10, quantiles[1:10])
sampleQ(1:10, 20, quantiles[21:40], replace = TRUE)

</code></pre>

<hr>
<h2 id='summary.flimo_result'>Summary of flimo results</h2><span id='topic+summary.flimo_result'></span>

<h3>Description</h3>

<p>Most important information about inference results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flimo_result'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.flimo_result_+3A_object">object</code></td>
<td>
<p>Object of class flimo_result from any mode/method algorithm
of the Jflimo package.</p>
</td></tr>
<tr><td><code id="summary.flimo_result_+3A_...">...</code></td>
<td>
<p>optional args for generic method summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing most important information about argument
of class flimo_result.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
