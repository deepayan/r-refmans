<!DOCTYPE html><html><head><title>Help for package tempdisagg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tempdisagg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tempdisagg-package'><p>Methods for Temporal Disaggregation and Interpolation of Time Series</p></a></li>
<li><a href='#exports.m'><p>Trade and Sales of Chemical and Pharmaceutical Industry</p></a></li>
<li><a href='#gdp.q'><p>Gross Domestic Product</p></a></li>
<li><a href='#plot.td'><p>Residual Plot for Temporal Disaggregation</p></a></li>
<li><a href='#predict.td'><p>Predict Method for Temporal Disaggregation</p></a></li>
<li><a href='#spi.d'><p>SPI Swiss Performance Index</p></a></li>
<li><a href='#summary.td'><p>Summary of a Temporal Disaggregation</p></a></li>
<li><a href='#ta'><p>Temporal Aggregation of Time Series</p></a></li>
<li><a href='#td'><p>Temporal Disaggregation of Time Series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Temporal Disaggregation and Interpolation of Time
Series</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://journal.r-project.org/archive/2013-2/sax-steiner.pdf">https://journal.r-project.org/archive/2013-2/sax-steiner.pdf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/christophsax/tempdisagg">https://github.com/christophsax/tempdisagg</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>tsbox, testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>Description:</td>
<td>Temporal disaggregation methods are used to disaggregate and
    interpolate a low frequency time series to a higher frequency series, where
    either the sum, the mean, the first or the last value of the resulting
    high frequency series is consistent with the low frequency series. Temporal
    disaggregation can be performed with or without one or more high frequency
    indicator series. Contains the methods of Chow-Lin, Santos-Silva-Cardoso,
    Fernandez, Litterman, Denton and Denton-Cholette, summarized in Sax and
    Steiner (2013) &lt;<a href="https://doi.org/10.32614%2FRJ-2013-028">doi:10.32614/RJ-2013-028</a>&gt;. Supports most R time series
    classes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 15:07:00 UTC; christophsax</td>
</tr>
<tr>
<td>Author:</td>
<td>Christoph Sax <a href="https://orcid.org/0000-0002-7192-7044"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Peter Steiner [aut],
  Tommaso Di Fonzo [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christoph Sax &lt;christoph.sax@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tempdisagg-package'>Methods for Temporal Disaggregation and Interpolation of Time Series</h2><span id='topic+tempdisagg-package'></span><span id='topic+tempdisagg'></span>

<h3>Description</h3>

<p>Temporal disaggregation methods are used to disaggregate or
interpolate a low frequency time series to higher frequency series, where
either the sum, the average, the first or the last value of the resulting
high frequency series is consistent with the low frequency series. Temporal
disaggregation can be performed with or without one or more high frequency
indicator series.
</p>
<p>A good way to start is the introductory vignette:
</p>
<p><code>vignette("intro", "tempdisagg")</code>
</p>
<p>Our article on temporal disaggregation of time series
(<a href="https://doi.org/10.32614/RJ-2013-028">doi:10.32614/RJ-2013-028</a>) in the R-Journal describes the
package and the theory of temporal disaggregation in more detail.
</p>


<h3>Author(s)</h3>

<p>Christoph Sax <a href="mailto:christoph.sax@gmail.com">christoph.sax@gmail.com</a>, Peter Steiner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+td">td()</a></code> for more information on usage.
</p>

<hr>
<h2 id='exports.m'>Trade and Sales of Chemical and Pharmaceutical Industry</h2><span id='topic+exports.m'></span><span id='topic+exports.q'></span><span id='topic+imports.q'></span><span id='topic+sales.a'></span><span id='topic+sales.q'></span>

<h3>Description</h3>

<p>This data set contains the monthly and quarterly imports and exports of the
chemical and pharmaceutical industry in Switzerland (in in millions of Swiss
Francs) as well as their quarterly and annual sales (Index).
</p>


<h3>Format</h3>

<p>Each time series is an object of class <code>"ts"</code>. The number of
observations depends on the frequency.
</p>


<h3>Source</h3>

<p>Import and Export Data are from the Swiss Federal Customs
Administration. Sales Data are from the Swiss Federal Statistical Office.
</p>

<hr>
<h2 id='gdp.q'>Gross Domestic Product</h2><span id='topic+gdp.q'></span>

<h3>Description</h3>

<p>Qarterly real GDP, not seasonally adjusted, in millions of Swiss Francs
(2010 prices).
</p>


<h3>Format</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Source</h3>

<p>State Secretariat for Economic Affairs (SECO).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# recreate the series with latest data
library(tsbox)
library(dplyr)
library(dataseries)
library(imputeTS)
dataseries::ds("ch_seco_gdp.nsa.real.gdp") %&gt;%
  ts_default() %&gt;%
  ts_span(start = 2005)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.td'>Residual Plot for Temporal Disaggregation</h2><span id='topic+plot.td'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"td"</code>. Plot the fitted and actual low
frequency series, and residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'td'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.td_+3A_x">x</code></td>
<td>
<p>an object of class <code>"td"</code>, usually, a result of a
call to <code><a href="#topic+td">td()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.td_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a a two panel plot as its side effect, showing
the fitted and actual low frequency series, and the residuals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+td">td()</a></code> for the main function for temporal disaggregation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swisspharma)

mod2 &lt;- td(sales.a ~ imports.q + exports.q)
plot(mod2)
</code></pre>

<hr>
<h2 id='predict.td'>Predict Method for Temporal Disaggregation</h2><span id='topic+predict.td'></span>

<h3>Description</h3>

<p>Compute the disaggregated or interpolated (and extrapolated) high frequency
series of a temporal disaggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'td'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.td_+3A_object">object</code></td>
<td>
<p>an object of class <code>"td"</code>, usually, a result of a
call to <code><a href="#topic+td">td()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.td_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.td</code> returns a vector or a <code>"ts"</code> object,
containing the disaggregated or interpolated high frequency series of a
temporal disaggregation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+td">td()</a></code> for the main function for temporal disaggregation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swisspharma)

mod1 &lt;- td(sales.a ~ imports.q + exports.q)
predict(mod1)
</code></pre>

<hr>
<h2 id='spi.d'>SPI Swiss Performance Index</h2><span id='topic+spi.d'></span>

<h3>Description</h3>

<p>Daily values of stock market index.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Source</h3>

<p>Swiss National Bank (SNB)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# recreate the series with latest data
library(tsbox)
library(dplyr)
library(dataseries)
library(imputeTS)
dataseries::ds("ch_snb_capchstocki.gdr") %&gt;%
  ts_default() %&gt;%
  ts_regular() %&gt;%
  imputeTS::na_interpolation(option = "spline") %&gt;%
  ts_span(start = 2005)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.td'>Summary of a Temporal Disaggregation</h2><span id='topic+summary.td'></span><span id='topic+print.summary.td'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;td&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'td'
summary(object, ...)

## S3 method for class 'summary.td'
print(
  x,
  digits = max(3, getOption("digits") - 3),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.td_+3A_object">object</code></td>
<td>
<p>an object of class <code>"td"</code>, usually, a result of a
call to <code><a href="#topic+td">td()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.td_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.td_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.td"</code>, usually, a result
of a call to <code>summary.td</code>.</p>
</td></tr>
<tr><td><code id="summary.td_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.td_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, 'significance stars' are printed
for each coefficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.td</code> returns a list containing the summary statistics
included in <code>object</code>, and computes the following additional
statistics:
</p>
<table>
<tr><td><code>n_l</code></td>
<td>
<p>number of low frequency observations</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of high frequency observations</p>
</td></tr>
<tr><td><code>ar_l</code></td>
<td>
<p>empirical auto-correlation of the low frequency series</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named matrix containing coefficients, standard
deviations, t-values and p-values</p>
</td></tr>
</table>
<p>The <code>print</code> method prints the summary output in a similar way as the method for <code>"lm"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+td">td()</a></code> for the main function for temporal disaggregation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swisspharma)

mod1 &lt;- td(sales.a ~ imports.q + exports.q)
summary(mod1)

mod2 &lt;- td(sales.a ~ 0, to = "quarterly", method = "uniform")
summary(mod2)
</code></pre>

<hr>
<h2 id='ta'>Temporal Aggregation of Time Series</h2><span id='topic+ta'></span><span id='topic+ta.ts'></span>

<h3>Description</h3>

<p>Performs temporal aggregation of high to low frequency time series.
Currently, <code>ta</code> only works with <code>ts</code> or <code>mts</code> time series
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ta(x, ...)

## S3 method for class 'ts'
ta(x, conversion = "sum", to = "annual", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ta_+3A_x">x</code></td>
<td>
<p>a time series object of class <code>"ts"</code> or <code>"mts"</code>.</p>
</td></tr>
<tr><td><code id="ta_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to the methods.</p>
</td></tr>
<tr><td><code id="ta_+3A_conversion">conversion</code></td>
<td>
<p>type of conversion: <code>"sum"</code>, <code>"average"</code>,
<code>"first"</code> or <code>"last"</code>.</p>
</td></tr>
<tr><td><code id="ta_+3A_to">to</code></td>
<td>
<p>(low-frequency) destination frequency as a character
string (<code>"annual"</code> or <code>"quarterly"</code>) or as a
scalar (e.g. <code>1</code>, <code>2</code>, <code>4</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ta</code> is used to aggregate a high frequency time series into a low
frequency series, while the latter is either the sum, the average, the first
or the last value of the high-frequency series. <code>ta</code> is the inverse
function of <code><a href="#topic+td">td()</a></code>. If applied to an output series of <code>td</code>,
<code>ta</code> yields the original series.
</p>


<h3>Value</h3>

<p><code>ta</code> returns an object of class <code>"ts"</code> or <code>"mts"</code>,
depending on the class of the input series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+td">td()</a></code> for the main function for temporal disaggregation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swisspharma)

sales.q.a &lt;- ta(sales.q, conversion = "sum", to = "annual")
all.equal(sales.a, sales.q.a)
</code></pre>

<hr>
<h2 id='td'>Temporal Disaggregation of Time Series</h2><span id='topic+td'></span>

<h3>Description</h3>

<p>Perform temporal disaggregation or interpolation of low frequency to high
frequency time series. <code>td</code> can be used with objects of class
<code>"ts"</code>, with numeric vectors or with any
<a href="https://docs.ropensci.org/tsbox/">ts-boxable</a> time series object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>td(
  formula,
  conversion = "sum",
  to = "quarterly",
  method = "chow-lin-maxlog",
  truncated.rho = 0,
  fixed.rho = 0.5,
  criterion = "proportional",
  h = 1,
  start = NULL,
  end = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="td_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"formula"</code>: a symbolic
description of the the temporal disaggregation model. The details of model
specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="td_+3A_conversion">conversion</code></td>
<td>
<p>type of conversion: <code>"sum"</code>, <code>"mean"</code> (or: <code>"average"</code>),
<code>"first"</code> or <code>"last"</code>.</p>
</td></tr>
<tr><td><code id="td_+3A_to">to</code></td>
<td>
<p>high-frequency destination frequency as a character string
(<code>"quarter"</code> (or <code>"quarterly"</code>), <code>"month"</code> (or <code>"monthly"</code>), <code>"day"</code>,
<code>"hour"</code>, <code>"minute"</code>, <code>"second"</code>, or <code>"year"</code>)
or as a scalar (e.g. <code>2</code>, <code>4</code>, <code>7</code>, <code>12</code>). Required if no right hand side
indicator series is provided. The <a href="https://docs.ropensci.org/tsbox/">tsbox</a> package must
be installed to deal with frequencies other than monthly or quarterly. If
the input series are numeric, <code>to</code> is a scalar indicating the
frequency ratio.</p>
</td></tr>
<tr><td><code id="td_+3A_method">method</code></td>
<td>
<p>method of temporal disaggregation:
<code>"chow-lin-maxlog"</code>, <code>"chow-lin-minrss-ecotrim"</code>,
<code>"chow-lin-minrss-quilis"</code>, <code>"chow-lin-fixed"</code>,
<code>"dynamic-maxlog"</code> (experimental), <code>"dynamic-minrss"</code> (experimental), <code>"dynamic-fixed"</code> (experimental),
<code>"fernandez"</code>, <code>"litterman-maxlog"</code>, <code>"litterman-minrss"</code>,
<code>"litterman-fixed"</code>, <code>"denton-cholette"</code>, <code>"denton"</code>, <code>"fast"</code>,
<code>"uniform"</code> or <code>"ols"</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="td_+3A_truncated.rho">truncated.rho</code></td>
<td>
<p>lower bound for the autoregressive parameter
<code class="reqn">\rho</code>. If set to <code>0</code> (default), no negative values are allowed.
If set to <code>-1</code>, truncation is disabled.</p>
</td></tr>
<tr><td><code id="td_+3A_fixed.rho">fixed.rho</code></td>
<td>
<p>set a predefined autoregressive parameter <code class="reqn">\rho</code>. Only
works with the methods <code>"chow-lin-fixed"</code> and
<code>"litterman-fixed"</code>.</p>
</td></tr>
<tr><td><code id="td_+3A_criterion">criterion</code></td>
<td>
<p>minimzation criterion for Denton methods:
<code>"proportional"</code> or <code>"additive"</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="td_+3A_h">h</code></td>
<td>
<p>degree of differencing for Denton methods. See 'Details'.</p>
</td></tr>
<tr><td><code id="td_+3A_start">start</code></td>
<td>
<p>(optional) start date. Similar to pre-processing the input
series with <code><a href="stats.html#topic+window">window()</a></code>.</p>
</td></tr>
<tr><td><code id="td_+3A_end">end</code></td>
<td>
<p>(optional) end date. Similar to pre-processing the input
series with <code><a href="stats.html#topic+window">window()</a></code>.</p>
</td></tr>
<tr><td><code id="td_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level
subfunctions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>td</code> is used to disaggregate or interpolate a low frequency to a higher
frequency time series, while either the sum, the average, the first or the
last value of the resulting high-frequency series is consistent with the low
frequency series. Disaggregation can be performed with or without the help of
one or more right hand side indicator series. It can deal with both with
a regular disaggregation setting (e.g. quarters to months) but also with
an irregular disaggregation setting (e.g. months to days), where it respects
the the different lengths of the months.
</p>
<p>If the high-frequency indicator(s) cover(s) a longer time span than the
low-frequency series, an extrapolation or retropolation (Wei, 1994, p. 138)
is performed, using the same model as for interpolation.
</p>
<p>The selection of a temporal disaggregation model is similar to the selection
of a linear regression model. Thus, <code>td</code> closely mirrors the working of
the <code><a href="stats.html#topic+lm">lm()</a></code> function. The left hand side of the
<code><a href="stats.html#topic+formula">formula()</a></code> denotes the low-frequency series, the right hand side
the indicators. If no indicator is specified, the right hand side must be set
equal to <code>1</code> (see examples). Unlike <code>lm</code>, <code>td</code> handles
<code><a href="stats.html#topic+ts">ts()</a></code> and <code>mts</code> time-series objects, as a typical application
involves the use of these objects. Alternatively, If used with basic vectors,
the <code>to</code> argument specifies the ratio between the high and the low
frequency series.
</p>
<p>For the generalized least squares (GLS) methods <code>"chow-lin-maxlog"</code>,
<code>"chow-lin-minrss-ecotrim"</code>, <code>"chow-lin-minrss-quilis"</code>,
<code>"litterman-maxlog"</code> and <code>"litterman-minrss"</code>, an autoregressive
parameter <code class="reqn">\rho</code> is estimated. Default (and recommended) method is
<code>chow-lin-maxlog</code>. With <code>truncated.rho = 0</code> (default), it produces
good results for a wide range of applications.
</p>
<p>There are two variants of the <code>chow-lin-minrss</code> approach that lead to
different results: Ecotrim by Barcellan (2003) uses a correlation matrix
instead of the variance covariance matrix (implemented in
<code>"chow-lin-minrss-ecotrim"</code>), the Matlab library by Quilis (2009)
multiplies the correlation matrix with <code class="reqn">1/(1-\rho^2)</code> (implemented in
<code>"chow-lin-minrss-quilis"</code>).
</p>
<p>The methods <code>"dynamic-maxlog"</code>, <code>"dynamic-minrss"</code> and
<code>"dynamic-fixed"</code> are dynamic extensions of Chow-Lin (Santos Silva and
Cardoso, 2001). If the autoregressive parameter <code class="reqn">\rho</code> is equal to 0, no
truncation remainder is added.
</p>
<p>The Denton methods <code>"denton"</code> and <code>"denton-cholette"</code> can be
specified with one or without an indicator. The parameter <code>h</code> can be set
equal to <code>0</code>, <code>1</code>, or <code>2</code>. Depending on the value, the
<code>denton</code> procedure minimizes the sum of squares of the deviations
between the levels (<code>0</code>), the first differences (<code>1</code>) or the second
differences (<code>2</code>) of the indicator and the resulting series.
Additionally, <code>criterion</code> can be set equal to <code>"proportional"</code> or
<code>"additive"</code>, depending on whether the proportional or the absolute
deviations should be considered for minimzation. <code>"denton-cholette"</code>
removes the transient movement of the original <code>"denton"</code> method at the
beginning of the resulting series.  <code>"fast"</code> is a shortcut for
<code>"chow-lin-fixed"</code> with <code>fixed.rho = 0.99999</code>. It returns approximately the
same results as &quot;denton-cholette&quot; with <code>h = 1</code>, but is much faster.
</p>
<p><code>"uniform"</code> is a special case of the <code>"denton"</code> approach, with
<code>h</code> equals  <code>0</code> and <code>criterion</code> equals  <code>"additive"</code>.
It distributes the residuals uniformly. If no indicator is used, this leads
to a step-shaped series.
</p>
<p><code>"ols"</code> performs an ordinary least squares regression (OLS) and
distributes the residuals uniformly. It is especially useful for comparing
the estimators of GLS and OLS regressions.
</p>


<h3>Value</h3>

<p><code>td</code> returns an object of class <code>"td"</code>.
</p>
<p>The function <code><a href="#topic+predict.td">predict()</a></code> computes the interpolated
high frequency series. If the high-frequency indicator series are longer
than the low-frequency series, the resulting series will be extrapolated.
The function <code>coefficients</code> extracts the coefficients. The function
<code>residuals</code> extracts the low frequency residuals. The function
<code><a href="#topic+summary.td">summary()</a></code> prints a summary of the estimation.
</p>
<p>An object of class <code>"td"</code> is a list containing the following
components: </p>
<table>
<tr><td><code>values</code></td>
<td>
<p>disaggregated or interpolated (and extrapolated)
high frequency series</p>
</td></tr> <tr><td><code>fitted.values</code></td>
<td>
<p>low frequency fitted values of
the regression; low frequency indicator for the Denton methods.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>preliminary high frequency series</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>low-frequency
residuals</p>
</td></tr> <tr><td><code>rho</code></td>
<td>
<p>autoregressive parameter, <code class="reqn">\rho</code></p>
</td></tr>
<tr><td><code>truncated</code></td>
<td>
<p>logical, whether <code class="reqn">\rho</code> has been truncated</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients</p>
</td></tr> <tr><td><code>se</code></td>
<td>
<p>standard
errors of the coefficients</p>
</td></tr> <tr><td><code>s_2</code></td>
<td>
<p>ML-estimator of the variance of the
high-frequency residuals</p>
</td></tr> <tr><td><code>s_2_gls</code></td>
<td>
<p>GLS-estimator of the variance of
the high-frequency residuals</p>
</td></tr> <tr><td><code>tss</code></td>
<td>
<p>weighted (low frequency) total sum
of squares</p>
</td></tr> <tr><td><code>rss</code></td>
<td>
<p>weighted (low frequency) residual sum of squares</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared</p>
</td></tr> <tr><td><code>adj.r.squared</code></td>
<td>
<p>adjusted R squared</p>
</td></tr>
<tr><td><code>logl</code></td>
<td>
<p>log-likelihood</p>
</td></tr> <tr><td><code>aic</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>Schwarz information criterion</p>
</td></tr> <tr><td><code>rank</code></td>
<td>
<p>number of right hand
variables (including intercept)</p>
</td></tr> <tr><td><code>df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>method of temporal disaggregation</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>name of the low frequency variable</p>
</td></tr> <tr><td><code>fr</code></td>
<td>
<p>the ratio of high
to low-frequency series</p>
</td></tr> <tr><td><code>conversion</code></td>
<td>
<p>type of temporal conversion</p>
</td></tr>
<tr><td><code>actual</code></td>
<td>
<p>actual values of the low frequeny series</p>
</td></tr> <tr><td><code>model</code></td>
<td>
<p>a
matrix containing the indicators (and a constant if present)</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>minimization criterion in Denton methods</p>
</td></tr> <tr><td><code>h</code></td>
<td>
<p>order
of differencing in Denton methods</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chow, G. C., &amp; Lin, A. L. (1971). Best linear unbiased
interpolation, distribution, and extrapolation of time series by related
series. <em>The review of Economics and Statistics</em>, 372-375.
</p>
<p>Denton, F. T. (1971). Adjustment of monthly or quarterly series to annual
totals: an approach based on quadratic minimization. <em>Journal of the
American Statistical Association</em>, 66(333), 99-102.
</p>
<p>Santos Silva, J. M. C. &amp; Cardoso, F. N. (2001). The Chow-Lin method using
dynamic models. <em>Economomic Modelling</em>, 18, 269-280.
</p>
<p>Wei, W. W. S. (1994). Time series analysis. Addison-Wesley publ.
</p>
<p>Sax, C. und Steiner, P. (2013). Temporal Disaggregation of Time Series.
<em>The R Journal</em>, 5(2), 80-88. <a href="https://doi.org/10.32614/RJ-2013-028">doi:10.32614/RJ-2013-028</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ta">ta()</a></code> for temporal aggregation, the inverse function of
<code>td</code>.
</p>
<p><code><a href="#topic+summary.td">summary()</a></code> is used to obtain and print a summary of
the results.
</p>
<p><code><a href="#topic+predict.td">predict()</a></code> is used to extract the disaggregated or
interpolated high frequency series.
</p>
<p><code><a href="#topic+plot.td">plot()</a></code> is used to plot the fitted and actual low
frequency series, as well as the residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tempdisagg)

# one indicator, no intercept
mod1 &lt;- td(sales.a ~ 0 + exports.q)
summary(mod1)  # summary statistics
plot(mod1)  # residual plot of regression
plot(predict(mod1))

# interpolated quarterly series

# temporally aggregated series is equal to the annual value
all.equal(window(
  ta(predict(mod1), conversion = "sum", to = "annual"),
  start = 1975), sales.a)

# several indicators, including an intercept
mod2 &lt;- td(sales.a ~ imports.q + exports.q)

# no indicator (Denton-Cholette)
mod3 &lt;- td(sales.a ~ 1, to = "quarterly", method = "denton-cholette")

# no indicator (uniform)
mod4 &lt;- td(sales.a ~ 1, to = "quarterly", method = "uniform")

# Dynamic Chow-Lin (Santos Silva and Cardoso, 2001)
# (no truncation parameter added, because rho = 0)
mod5 &lt;- td(sales.a ~ exports.q, method = "dynamic-maxlog")

# Example from Denton (1971), see references.
d.q &lt;- ts(rep(c(50, 100, 150, 100), 5), frequency = 4)
d.a &lt;- ts(c(500, 400, 300, 400, 500))

a1 &lt;- predict(td(d.a ~ 0 + d.q, method = "denton",
                 criterion = "additive", h = 0))
a2 &lt;- predict(td(d.a ~ 0 + d.q, method = "denton",
                 criterion = "additive", h = 1))
a3 &lt;- predict(td(d.a ~ 0 + d.q, method = "denton",
                 criterion = "additive", h = 2))
a4 &lt;- predict(td(d.a ~ 0 + d.q, method = "denton",
                 criterion = "additive", h = 3))

p1 &lt;- predict(td(d.a ~ 0 + d.q, method = "denton",
                 criterion = "proportional", h = 0))
p2 &lt;- predict(td(d.a ~ 0 + d.q, method = "denton",
                 criterion = "proportional", h = 1))
p3 &lt;- predict(td(d.a ~ 0 + d.q, method = "denton",
                 criterion = "proportional", h = 2))
p4 &lt;- predict(td(d.a ~ 0 + d.q, method = "denton",
                 criterion = "proportional", h = 3))

# Table in Denton (1971), page 101:
round(cbind(d.q, a1, a2, a3, a4, p1, p2, p3, p4))

## Not run: 

# Using altvernative time series classes (see https://docs.ropensci.org/tsbox/)
library(tsbox)
sales.a.xts &lt;- ts_xts(window(sales.a, start = 2000))
exports.q.xts &lt;- ts_xts(window(exports.q, start = 2000))
mod1b &lt;- td(sales.a.xts ~ 0 + exports.q.xts)
predict(mod1b)  # class 'xts'

# non-standard frequencies: decades to years
predict(td(ts_xts(uspop) ~ 1, "mean", to = "year", method = "fast"))

# quarter to daily (no indicator)
m.d.noind &lt;- td(gdp.q ~ 1, to = "daily", method = "fast")
predict(m.d.noind)

# quarter to daily (one indicator)
m.d.stocks &lt;- td(gdp.q ~ spi.d, method = "chow-lin-fixed", fixed.rho = 0.9)
predict(m.d.stocks)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
