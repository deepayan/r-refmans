<!DOCTYPE html><html><head><title>Help for package LHD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LHD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AvgAbsCor'><p>Calculate the Average Absolute Correlation</p></a></li>
<li><a href='#dij'><p>Calculate the Inter-site Distance</p></a></li>
<li><a href='#exchange'><p>Exchange two random elements in a matrix</p></a></li>
<li><a href='#FastMmLHD'><p>Fast Maximin Distance LHD</p></a></li>
<li><a href='#GA'><p>Genetic Algorithm for LHD</p></a></li>
<li><a href='#GLP'><p>Good Lattice Point Design</p></a></li>
<li><a href='#LaPSO'><p>Particle Swarm Optimization for LHD</p></a></li>
<li><a href='#MaxAbsCor'><p>Calculate the Maximum Absolute Correlation</p></a></li>
<li><a href='#MaxProCriterion'><p>Calculate the Maximum Projection Criterion</p></a></li>
<li><a href='#OA2LHD'><p>Transfer an Orthogonal Array (OA) into an LHD</p></a></li>
<li><a href='#OASA'><p>Orthogonal-Array-Based Simulated Annealing</p></a></li>
<li><a href='#OLHD.B2001'><p>Orthogonal Latin Hypercube Design</p></a></li>
<li><a href='#OLHD.C2007'><p>Orthogonal Latin Hypercube Design</p></a></li>
<li><a href='#OLHD.L2009'><p>Orthogonal Latin Hypercube Design</p></a></li>
<li><a href='#OLHD.S2010'><p>Orthogonal Latin Hypercube Design</p></a></li>
<li><a href='#OLHD.Y1998'><p>Orthogonal Latin Hypercube Design</p></a></li>
<li><a href='#phi_p'><p>Calculate the phi_p Criterion</p></a></li>
<li><a href='#rLHD'><p>Generate a random Latin Hypercube Design (LHD)</p></a></li>
<li><a href='#SA'><p>Simulated Annealing for LHD</p></a></li>
<li><a href='#SA2008'><p>Simulated Annealing for LHD with Multi-objective Optimization Approach</p></a></li>
<li><a href='#SLHD'><p>Sliced Latin Hypercube Design (SLHD)</p></a></li>
<li><a href='#WT'><p>Williams Transformation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Latin Hypercube Designs (LHDs)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains different algorithms and construction methods for optimal Latin hypercube designs (LHDs) with flexible sizes. Our package is comprehensive since it is capable of generating maximin distance LHDs, maximum projection LHDs, and orthogonal and nearly orthogonal LHDs. Detailed comparisons and summary of all the algorithms and construction methods in this package can be found at Hongzhi Wang, Qian Xiao and Abhyuday Mandal (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2010.09154">doi:10.48550/arXiv.2010.09154</a>&gt;. This package is particularly useful in the area of Design and Analysis of Experiments (DAE). More specifically, design of computer experiments.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, devtools</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, numbers, utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-31 17:56:56 UTC; wangh</td>
</tr>
<tr>
<td>Author:</td>
<td>Hongzhi Wang [aut, cre],
  Qian Xiao [aut],
  Abhyuday Mandal [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hongzhi Wang &lt;hw34508@uga.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-31 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AvgAbsCor'>Calculate the Average Absolute Correlation</h2><span id='topic+AvgAbsCor'></span>

<h3>Description</h3>

<p><code>AvgAbsCor</code> returns the average absolute correlation of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AvgAbsCor(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AvgAbsCor_+3A_x">X</code></td>
<td>
<p>A matrix object. In general, <code>X</code> stands for the design matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a positive number indicating the average absolute correlation of input matrix.
<code>average absolute correlation = \frac{2 \sum_{i=1}^{k-1} \sum_{j=i+1}^{k}|q_{ij}|}{k(k-1)}</code>
</p>


<h3>References</h3>

<p>Georgiou, S. D. (2009) Orthogonal Latin hypercube designs from generalized orthogonal designs. <em>Journal of Statistical Planning and Inference</em>, <strong>139</strong>, 1530-1540.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a toy LHD with 5 rows and 3 columns
toy=rLHD(n=5,k=3);toy

#Calculate the average absolute correlation of toy
AvgAbsCor(X=toy)

</code></pre>

<hr>
<h2 id='dij'>Calculate the Inter-site Distance</h2><span id='topic+dij'></span>

<h3>Description</h3>

<p><code>dij</code> returns the inter-site distance of two design points of an LHD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dij(X, i, j, q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dij_+3A_x">X</code></td>
<td>
<p>A matrix object. In general, <code>X</code> stands for the design matrix.</p>
</td></tr>
<tr><td><code id="dij_+3A_i">i</code></td>
<td>
<p>A positive integer, which stands for the i^th row of <code>X</code>.</p>
</td></tr>
<tr><td><code id="dij_+3A_j">j</code></td>
<td>
<p>A positive integer, which stands for the j^th row of <code>X</code>. Both <code>i</code> and <code>j</code> should be in [1,nrow(X)] and they should not be equal to each other.</p>
</td></tr>
<tr><td><code id="dij_+3A_q">q</code></td>
<td>
<p>The default is set to be 1, and it could be either 1 or 2. If <code>q</code> is 1, <code>dij</code> is the Manhattan (rectangular) distance. If <code>q</code> is 2, <code>dij</code> is the Euclidean distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a positive number indicating the distance. <code>dij =  \left\{ \sum_{k=1}^{m} \vert x_{ik}-x_{jk}\vert ^q \right\}^{1/q}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a toy LHD with 5 rows and 3 columns
toy=rLHD(n=5,k=3);toy

#Calculate the inter-site distance of the 2nd and the 4th row of toy (with default q)
dij(X=toy,i=2,j=4)

#Calculate the inter-site distance of the 2nd and the 4th row of toy (with q=2)
dij(X=toy,i=2,j=4,q=2)
</code></pre>

<hr>
<h2 id='exchange'>Exchange two random elements in a matrix</h2><span id='topic+exchange'></span>

<h3>Description</h3>

<p><code>exchange</code> returns a new matrix by switching two randomly selected elements from a user-defined matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exchange(X, j, type = "col")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exchange_+3A_x">X</code></td>
<td>
<p>A matrix object. In general, <code>X</code> stands for a design matrix.</p>
</td></tr>
<tr><td><code id="exchange_+3A_j">j</code></td>
<td>
<p>A positive integer, which stands for the j^th column (or row) of <code>X</code>, and it should be within [1,ncol(X)] (or [1,nrow(X)]).</p>
</td></tr>
<tr><td><code id="exchange_+3A_type">type</code></td>
<td>
<p>An exchange type. If <code>type</code> is &quot;col&quot; (the default setting), two random elements will be exchanged within column <code>j</code>. If <code>type</code> is &quot;row&quot;, two random elements will be exchanged within row <code>j</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a new design matrix after the exchange.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a toy LHD with 5 rows and 3 columns
toy=rLHD(n=5,k=3);toy

#Choose the first column of toy and exchange two randomly selected elements.
try.col=exchange(X=toy,j=1,type="col")
toy;try.col

#Choose the first row of toy and exchange two randomly selected elements.
try.row=exchange(X=toy,j=1,type="row")
toy;try.row
</code></pre>

<hr>
<h2 id='FastMmLHD'>Fast Maximin Distance LHD</h2><span id='topic+FastMmLHD'></span>

<h3>Description</h3>

<p><code>FastMmLHD</code> returns a <code>n</code> by <code>k</code> maximin distance LHD matrix generated by the construction method of Wang, L., Xiao, Q., and Xu, H. (2018)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FastMmLHD(n, k, method = "manhattan", t1 = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FastMmLHD_+3A_n">n</code></td>
<td>
<p>A positive integer, which stands for the number of rows (or run size).</p>
</td></tr>
<tr><td><code id="FastMmLHD_+3A_k">k</code></td>
<td>
<p>A positive integer, which stands for the number of columns (or factor size).</p>
</td></tr>
<tr><td><code id="FastMmLHD_+3A_method">method</code></td>
<td>
<p>A distance measure method. The default setting is &quot;manhattan&quot;, and it could be one of the following: &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot;. Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="FastMmLHD_+3A_t1">t1</code></td>
<td>
<p>A tunning parameter, which determines how many repeats will be implemented to search for the optimal design. The default is set to be 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a <code>n</code> by <code>k</code> maximin distance LHD under under the maximin L_1 distance criterion..
</p>


<h3>References</h3>

<p>Wang, L., Xiao, Q., and Xu, H. (2018)  Optimal maximin $L_1$-distance Latin hypercube designs based on good lattice point designs. <em>The Annals of Statistics</em>, <strong>46</strong>(6B), 3741-3766.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#n by n design when 2n+1 is prime
try=FastMmLHD(8,8)
try
phi_p(try)   #calculate the phi_p of "try".

#n by n design when n+1 is prime
try2=FastMmLHD(12,12)
try2
phi_p(try2)   #calculate the phi_p of "try2".

#n by n-1 design when n is prime
try3=FastMmLHD(7,6)
try3
phi_p(try3)   #calculate the phi_p of "try3".

#General cases
try4=FastMmLHD(24,8)
try4
phi_p(try4)   #calculate the phi_p of "try4".

</code></pre>

<hr>
<h2 id='GA'>Genetic Algorithm for LHD</h2><span id='topic+GA'></span>

<h3>Description</h3>

<p><code>GA</code> returns a <code>n</code> by <code>k</code> LHD matrix generated by genetic algorithm (GA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GA(
  n,
  k,
  m = 10,
  N = 10,
  pmut = 1/(k - 1),
  OC = "phi_p",
  p = 15,
  q = 1,
  maxtime = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GA_+3A_n">n</code></td>
<td>
<p>A positive integer, which stands for the number of rows (or run size).</p>
</td></tr>
<tr><td><code id="GA_+3A_k">k</code></td>
<td>
<p>A positive integer, which stands for the number of columns (or factor size).</p>
</td></tr>
<tr><td><code id="GA_+3A_m">m</code></td>
<td>
<p>A positive even integer, which stands for the population size and it must be an even number. The default is set to be 10. A large value of <code>m</code> will result a high CPU time, and it is recommended to be no greater than 100.</p>
</td></tr>
<tr><td><code id="GA_+3A_n">N</code></td>
<td>
<p>A positive integer, which stands for the number of iterations. The default is set to be 10. A large value of <code>N</code> will result a high CPU time, and it is recommended to be no greater than 500.</p>
</td></tr>
<tr><td><code id="GA_+3A_pmut">pmut</code></td>
<td>
<p>A probability, which stands for the probability of mutation. The default is set to be 1/(<code>k</code> - 1).</p>
</td></tr>
<tr><td><code id="GA_+3A_oc">OC</code></td>
<td>
<p>An optimality criterion. The default setting is &quot;phi_p&quot;, and it could be one of the following: &quot;phi_p&quot;, &quot;AvgAbsCor&quot;, &quot;MaxAbsCor&quot;, &quot;MaxProCriterion&quot;.</p>
</td></tr>
<tr><td><code id="GA_+3A_p">p</code></td>
<td>
<p>A positive integer, which is the parameter in the phi_p formula, and <code>p</code> is prefered to be large. The default is set to be 15.</p>
</td></tr>
<tr><td><code id="GA_+3A_q">q</code></td>
<td>
<p>The default is set to be 1, and it could be either 1 or 2. If <code>q</code> is 1, <code>dij</code> is the Manhattan (rectangular) distance. If <code>q</code> is 2, <code>dij</code> is the Euclidean distance.</p>
</td></tr>
<tr><td><code id="GA_+3A_maxtime">maxtime</code></td>
<td>
<p>A positive number, which indicates the expected maximum CPU time given by user, and it is measured by minutes. For example, maxtime=3.5 indicates the CPU time will be no greater than three and half minutes. The default is set to be 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a <code>n</code> by <code>k</code> LHD.
</p>


<h3>References</h3>

<p>Liefvendahl, M., and Stocki, R. (2006) A study on algorithms for optimization of Latin hypercubes. <em>Journal of Statistical Planning and Inference</em>, <strong>136</strong>, 3231-3247.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate a 5 by 3 maximin distance LHD with the default setting
try=GA(n=5,k=3)
try
phi_p(try)   #calculate the phi_p of "try".

#Another example
#generate a 8 by 4 nearly orthogonal LHD
try2=GA(n=8,k=4,OC="AvgAbsCor")
try2
AvgAbsCor(try2)  #calculate the average absolute correlation.
</code></pre>

<hr>
<h2 id='GLP'>Good Lattice Point Design</h2><span id='topic+GLP'></span>

<h3>Description</h3>

<p><code>GLP</code> returns a <code>n</code> by <code>k</code> design matrix generated by good lattice point (GLP)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLP(n, k, h = sample(seq(from = 1, to = (n - 1)), k))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLP_+3A_n">n</code></td>
<td>
<p>A positive integer, which stands for the number of rows (or run size).</p>
</td></tr>
<tr><td><code id="GLP_+3A_k">k</code></td>
<td>
<p>A positive integer, which stands for the number of columns (or factor size). <code>k</code> must be smaller than <code>n</code>. In GLP designs, <code>k</code> &lt;= the total number of positive integers that are smaller than and coprime to <code>n</code>.</p>
</td></tr>
<tr><td><code id="GLP_+3A_h">h</code></td>
<td>
<p>A vector whose length is <code>k</code>, with its elements that are smaller than and coprime to <code>n</code>. The default is set to be a random sample of <code>k</code> elements between 1 and <code>n-1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a <code>n</code> by <code>k</code> GLP design matrix.
</p>


<h3>References</h3>

<p>Korobov, A.N. (1959) The approximate computation of multiple integrals. <em>Dokl. Akad. Nauk SSSR</em>, <strong>124</strong>, 1207-1210.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate a 5 by 3 GLP design with the default setting
try=GLP(n=5,k=3)
try

#Another example
#generate a 8 by 4 GLP design with given h vector
try2=GLP(n=8,k=4,h=c(1,3,5,7))
try2
</code></pre>

<hr>
<h2 id='LaPSO'>Particle Swarm Optimization for LHD</h2><span id='topic+LaPSO'></span>

<h3>Description</h3>

<p><code>LaPSO</code> returns a <code>n</code> by <code>k</code> LHD matrix generated by particle swarm optimization algorithm (PSO)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LaPSO(
  n,
  k,
  m = 10,
  N = 10,
  SameNumP = 0,
  SameNumG = n/4,
  p0 = 1/(k - 1),
  OC = "phi_p",
  p = 15,
  q = 1,
  maxtime = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LaPSO_+3A_n">n</code></td>
<td>
<p>A positive integer, which stands for the number of rows (or run size).</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_k">k</code></td>
<td>
<p>A positive integer, which stands for the number of columns (or factor size).</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_m">m</code></td>
<td>
<p>A positive integer, which stands for the number of particles. The default is set to be 10. A large value of <code>m</code> will result a high CPU time, and it is recommended to be no greater than 100.</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_n">N</code></td>
<td>
<p>A positive integer, which stands for the number of iterations. The default is set to be 10. A large value of <code>N</code> will result a high CPU time, and it is recommended to be no greater than 500.</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_samenump">SameNumP</code></td>
<td>
<p>A non-negative integer, which stands for how many elements in current column of current particle LHD should be the same as corresponding Personal Best. SameNumP=0, 1, 2, ..., n, and 0 means to skip the &quot;exchange&quot;.  The default is set to be 0.</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_samenumg">SameNumG</code></td>
<td>
<p>A non-negative integer, which stands for how many elements in current column of current particle LHD should be the same as corresponding Global Best. SameNumP=0, 1, 2, ..., n, and 0 means to skip the &quot;exchange&quot;.  The default is set to be <code>n</code>/4. <code>SameNumP</code> and <code>SameNumG</code> cannot be 0 at the same time.</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_p0">p0</code></td>
<td>
<p>A probability of exchanging two randomly selected elements in current column of current particle LHD. The default is set to be 1/(<code>k</code> - 1).</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_oc">OC</code></td>
<td>
<p>An optimality criterion. The default setting is &quot;phi_p&quot;, and it could be one of the following: &quot;phi_p&quot;, &quot;AvgAbsCor&quot;, &quot;MaxAbsCor&quot;, &quot;MaxProCriterion&quot;.</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_p">p</code></td>
<td>
<p>A positive integer, which is the parameter in the phi_p formula, and <code>p</code> is prefered to be large. The default is set to be 15.</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_q">q</code></td>
<td>
<p>The default is set to be 1, and it could be either 1 or 2. If <code>q</code> is 1, <code>dij</code> is the Manhattan (rectangular) distance. If <code>q</code> is 2, <code>dij</code> is the Euclidean distance.</p>
</td></tr>
<tr><td><code id="LaPSO_+3A_maxtime">maxtime</code></td>
<td>
<p>A positive number, which indicates the expected maximum CPU time given by user, and it is measured by minutes. For example, maxtime=3.5 indicates the CPU time will be no greater than three and half minutes. The default is set to be 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a <code>n</code> by <code>k</code> LHD. Here are some general suggestions about the parameters: </p>

<ul>
<li> <p><code>SameNumP</code> is approximately <code>n</code>/2 when <code>SameNumG</code> is 0.
</p>
</li>
<li> <p><code>SameNumG</code> is approximately <code>n</code>/4 when <code>SameNumP</code> is 0.
</p>
</li>
<li> <p><code>p0</code> * (<code>k</code> - 1) = 1 to 2 is often sufficient. So <code>p0</code> = 1/(<code>k</code> - 1) to 2/(<code>k</code> - 1).
</p>
</li></ul>



<h3>References</h3>

<p>Chen, R.-B., Hsieh, D.-N., Hung, Y., and Wang, W. (2013) Optimizing Latin hypercube designs by particle swarm. <em>Stat. Comput.</em>, <strong>23</strong>, 663-676.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate a 5 by 3 maximin distance LHD with the default setting
try=LaPSO(n=5,k=3)
try
phi_p(try)   #calculate the phi_p of "try".

#Another example
#generate a 8 by 4 nearly orthogonal LHD
try2=LaPSO(n=8,k=4,OC="AvgAbsCor")
try2
AvgAbsCor(try2)  #calculate the average absolute correlation.
</code></pre>

<hr>
<h2 id='MaxAbsCor'>Calculate the Maximum Absolute Correlation</h2><span id='topic+MaxAbsCor'></span>

<h3>Description</h3>

<p><code>MaxAbsCor</code> returns the maximum absolute correlation of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxAbsCor(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaxAbsCor_+3A_x">X</code></td>
<td>
<p>A matrix object. In general, <code>X</code> stands for the design matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a positive number indicating maximum absolute correlation.
<code>maximum absolute correlation = max_{ij} |q_{ij}|</code>
</p>


<h3>References</h3>

<p>Georgiou, S. D. (2009) Orthogonal Latin hypercube designs from generalized orthogonal designs. <em>Journal of Statistical Planning and Inference</em>, <strong>139</strong>, 1530-1540.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a toy LHD with 5 rows and 3 columns
toy=rLHD(n=5,k=3);toy

#Calculate the maximum absolute correlation of toy
MaxAbsCor(X=toy)

</code></pre>

<hr>
<h2 id='MaxProCriterion'>Calculate the Maximum Projection Criterion</h2><span id='topic+MaxProCriterion'></span>

<h3>Description</h3>

<p><code>MaxProCriterion</code> returns the maximum projection criterion of an LHD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxProCriterion(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaxProCriterion_+3A_x">X</code></td>
<td>
<p>A matrix object. In general, <code>X</code> stands for the design matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a positive number indicating maximum projection criterion.
<code>maximum projection criterion = \Bigg{ \frac{1}{{n \choose 2}} \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} \frac{1}{\Pi_{l=1}^{k}(x_{il}-x_{jl})^2}  \Bigg}^{1/k}</code>
</p>


<h3>References</h3>

<p>Joseph, V. R., Gul, E., and Ba, S. (2015) Maximum projection designs for computer experiments. <em>Biometrika</em>, <strong>102</strong>, 371-380.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a toy LHD with 5 rows and 3 columns
toy=rLHD(n=5,k=3);toy

#Calculate the maximum projection criterion of toy
MaxProCriterion(X=toy)

</code></pre>

<hr>
<h2 id='OA2LHD'>Transfer an Orthogonal Array (OA) into an LHD</h2><span id='topic+OA2LHD'></span>

<h3>Description</h3>

<p><code>OA2LHD</code> transfers an OA into an LHD with corresponding size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OA2LHD(OA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OA2LHD_+3A_oa">OA</code></td>
<td>
<p>An orthogonal array matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input is logical, then the output will be an LHD whose sizes are the same as input OA. The assumption is that the elements of OAs must be positive.
</p>


<h3>References</h3>

<p>Tang, B. (1993) Orthogonal-array-based latin hypercubes. <em>Journal of the Americal Statistical Association</em>, <strong>88</strong>, 1392-1397.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create an OA(9,2,3,2)
OA=matrix(c(rep(1:3,each=3),rep(1:3,times=3)),ncol=2,nrow=9,byrow = FALSE);OA

#Transfer the "OA" above into a LHD according to Tang (1993)
tryOA=OA2LHD(OA)
OA;tryOA
</code></pre>

<hr>
<h2 id='OASA'>Orthogonal-Array-Based Simulated Annealing</h2><span id='topic+OASA'></span>

<h3>Description</h3>

<p><code>OASA</code> returns an LHD matrix generated by orthogonal-array-based simulated annealing algorithm (OASA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OASA(
  OA,
  N = 10,
  T0 = 10,
  rate = 0.1,
  Tmin = 1,
  Imax = 5,
  OC = "phi_p",
  p = 15,
  q = 1,
  maxtime = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OASA_+3A_oa">OA</code></td>
<td>
<p>An orthogonal array matrix.</p>
</td></tr>
<tr><td><code id="OASA_+3A_n">N</code></td>
<td>
<p>A positive integer, which stands for the number of iterations. The default is set to be 10. A large value of <code>N</code> will result a high CPU time, and it is recommended to be no greater than 500.</p>
</td></tr>
<tr><td><code id="OASA_+3A_t0">T0</code></td>
<td>
<p>A positive number, which stands for the user-defined initial temperature. The default is set to be 10.</p>
</td></tr>
<tr><td><code id="OASA_+3A_rate">rate</code></td>
<td>
<p>A positive percentage, which stands for temperature decrease rate, and it should be in (0,1). For example, rate=0.25 means the temperature decreases by 25% each time. The default is set to be 10%.</p>
</td></tr>
<tr><td><code id="OASA_+3A_tmin">Tmin</code></td>
<td>
<p>A positive number, which stands for the minimium temperature allowed. When current temperature becomes smaller or equal to <code>Tmin</code>, the stopping criterion for current loop is met. The default is set to be 1.</p>
</td></tr>
<tr><td><code id="OASA_+3A_imax">Imax</code></td>
<td>
<p>A positive integer, which stands for the maximum perturbations the algorithm will try without improvements before temperature is reduced. The default is set to be 5. For the computation complexity consideration, <code>Imax</code> is recommended to be smaller or equal to 5.</p>
</td></tr>
<tr><td><code id="OASA_+3A_oc">OC</code></td>
<td>
<p>An optimality criterion. The default setting is &quot;phi_p&quot;, and it could be one of the following: &quot;phi_p&quot;, &quot;AvgAbsCor&quot;, &quot;MaxAbsCor&quot;, &quot;MaxProCriterion&quot;.</p>
</td></tr>
<tr><td><code id="OASA_+3A_p">p</code></td>
<td>
<p>A positive integer, which is the parameter in the phi_p formula, and <code>p</code> is prefered to be large. The default is set to be 15.</p>
</td></tr>
<tr><td><code id="OASA_+3A_q">q</code></td>
<td>
<p>The default is set to be 1, and it could be either 1 or 2. If <code>q</code> is 1, <code>dij</code> is the Manhattan (rectangular) distance. If <code>q</code> is 2, <code>dij</code> is the Euclidean distance.</p>
</td></tr>
<tr><td><code id="OASA_+3A_maxtime">maxtime</code></td>
<td>
<p>A positive number, which indicates the expected maximum CPU time given by user, and it is measured by minutes. For example, maxtime=3.5 indicates the CPU time will be no greater than three and half minutes. The default is set to be 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be an LHD whose sizes are the same as input OA. The assumption is that the elements of OAs must be positive.
</p>


<h3>References</h3>

<p>Leary, S., Bhaskar, A., and Keane, A. (2003) Optimal orthogonal-array-based latin hypercubes. <em>Journal of Applied Statistics</em>, <strong>30</strong>, 585-598.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create an OA(9,2,3,2)
OA=matrix(c(rep(1:3,each=3),rep(1:3,times=3)),ncol=2,nrow=9,byrow = FALSE)

#Use above "OA" as the input OA to generate a 9 by 2 maximin distance LHD
#with the default setting
try=OASA(OA=OA)
try
phi_p(try)   #calculate the phi_p of "try".

#Another example
#generate a 9 by 2 nearly orthogonal LHD
try2=OASA(OA=OA,OC="MaxAbsCor")
try2
MaxAbsCor(try2)  #calculate the maximum absolute correlation.
</code></pre>

<hr>
<h2 id='OLHD.B2001'>Orthogonal Latin Hypercube Design</h2><span id='topic+OLHD.B2001'></span>

<h3>Description</h3>

<p><code>OLHD.B2001</code> returns a <code>n</code> by <code>k</code> orthogonal Latin hypercube design generated by the construction method of Butler (2001)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OLHD.B2001(n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OLHD.B2001_+3A_n">n</code></td>
<td>
<p>An odd prime number that is greater than or equal to 3.</p>
</td></tr>
<tr><td><code id="OLHD.B2001_+3A_k">k</code></td>
<td>
<p>A positive integer that is smaller than or equal to n-1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a <code>n</code> by <code>k</code> orthogonal LHD.
</p>


<h3>References</h3>

<p>Butler, N.A. (2001) Optimal and orthogonal Latin hypercube designs for computer experiments. <em>Biometrika</em>, <strong>88</strong>(3), 847-857.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create an orthogonal LHD with n=11 and k=5
OLHD.B2001(n=11,k=5)

#create an orthogonal LHD with n=7 and k=6
OLHD.B2001(n=7,k=6)

</code></pre>

<hr>
<h2 id='OLHD.C2007'>Orthogonal Latin Hypercube Design</h2><span id='topic+OLHD.C2007'></span>

<h3>Description</h3>

<p><code>OLHD.C2007</code> returns a <code>2^m+1</code> by <code>m+{m-1 \choose 2}</code> orthogonal Latin hypercube design generated by the construction method of Cioppa and Lucas (2007)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OLHD.C2007(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OLHD.C2007_+3A_m">m</code></td>
<td>
<p>A positive integer, and it must be greater than or equal to 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be an orthogonal LHD with the following run size: <code>n=2^m+1</code> and the following factor size: <code>k=m+{m-1 \choose 2}</code>.
</p>


<h3>References</h3>

<p>Cioppa, T.M., and Lucas, T.W. (2007) Efficient nearly orthogonal and space-filling Latin hypercubes. <em>Technometrics</em>, <strong>49</strong>(1), 45-55.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create an orthogonal LHD with m=4. So n=2^m+1=17 and k=4+3=7
OLHD.C2007(m=4)

#create an orthogonal LHD with m=5. So n=2^m+1=33 and k=5+6=11
OLHD.C2007(m=5)

</code></pre>

<hr>
<h2 id='OLHD.L2009'>Orthogonal Latin Hypercube Design</h2><span id='topic+OLHD.L2009'></span>

<h3>Description</h3>

<p><code>OLHD.L2009</code> returns a <code>n^2</code> by <code>2fp</code> orthogonal Latin hypercube design generated by the construction method of Lin et al. (2009)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OLHD.L2009(OLHD, OA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OLHD.L2009_+3A_olhd">OLHD</code></td>
<td>
<p>An orthogonal Latin hypercube design with run size <code>n</code> and factor size <code>p</code>, and it will be coupled with the input orthogonal array.</p>
</td></tr>
<tr><td><code id="OLHD.L2009_+3A_oa">OA</code></td>
<td>
<p>An orthogonal array, with <code>n^2</code> rows, <code>2f</code> columns, <code>n</code> symbols, strength two and index unity is available, which can be denoted as <code>OA(n^2,2f,n,2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, e,g. a <code>n</code> by <code>p</code> orthogonal Latin hypercube design and an <code>OA(n^2,2f,n,2)</code> orthogonal array, then the output will be an orthogonal Latin hypercube design with the following run size: <code>n^2</code> and the following factor size: <code>2fp</code>.
</p>


<h3>References</h3>

<p>Lin, C.D., Mukerjee, R., and Tang, B. (2009) Construction of orthogonal and nearly orthogonal Latin hypercubes. <em>Biometrika</em>, <strong>96</strong>(1), 243-247.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a 5 by 2 OLHD
OLHD=OLHD.C2007(m=2)

#create an OA(25,6,5,2)
OA=matrix(c(2,2,2,2,2,1,2,1,5,4,3,5,3,2,1,5,4,5,1,5,4,3,2,5,
4,1,3,5,2,3,1,2,3,4,5,2,1,3,5,2,4,3,1,1,1,1,1,1,4,3,2,1,5,5,
5,5,5,5,5,1,4,4,4,4,4,1,3,1,4,2,5,4,3,3,3,3,3,1,3,5,2,4,1,3,
3,4,5,1,2,2,5,4,3,2,1,5,2,3,4,5,1,2,2,5,3,1,4,4,1,4,2,5,3,4,
4,2,5,3,1,4,2,4,1,3,5,3,5,3,1,4,2,4,5,2,4,1,3,3,5,1,2,3,4,2,
4,5,1,2,3,2),ncol=6,nrow=25,byrow=TRUE)

#Construct a 25 by 12 OLHD
OLHD.L2009(OLHD,OA)

</code></pre>

<hr>
<h2 id='OLHD.S2010'>Orthogonal Latin Hypercube Design</h2><span id='topic+OLHD.S2010'></span>

<h3>Description</h3>

<p><code>OLHD.S2010</code> returns a <code>r2^{C+1}+1</code> or <code>r2^{C+1}</code> by <code>2^C</code> orthogonal Latin hypercube design generated by the construction method of Sun et al. (2010)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OLHD.S2010(C, r, type = "odd")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OLHD.S2010_+3A_c">C</code></td>
<td>
<p>A positive integer.</p>
</td></tr>
<tr><td><code id="OLHD.S2010_+3A_r">r</code></td>
<td>
<p>A positive integer.</p>
</td></tr>
<tr><td><code id="OLHD.S2010_+3A_type">type</code></td>
<td>
<p>Design run size type, and it could be either odd or even. If <code>type</code> is odd (the default setting), <code>OLHD.S2010</code> returns an OLHD with run size <code>r2^{C+1}+1</code>. If <code>type</code> is even, <code>OLHD.S2010</code> returns an OLHD with run size <code>r2^{C+1}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be an orthogonal LHD with the following run size: <code>n=r2^{C+1}+1</code> or <code>n=r2^{C+1}</code> and the following factor size: <code>k=2^C</code>.
</p>


<h3>References</h3>

<p>Sun, F., Liu, M.Q., and Lin, D.K. (2010) Construction of orthogonal Latin hypercube designs with flexible run sizes. <em>Journal of Statistical Planning and Inference</em>, <strong>140</strong>(11), 3236-3242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create an orthogonal LHD with C=3, r=3, type="odd".
#So n=3*2^4+1=49 and k=2^3=8
OLHD.S2010(C=3,r=3,type="odd")

#create an orthogonal LHD with C=3, r=3, type="even".
#So n=3*2^4=48 and k=2^3=8
OLHD.S2010(C=3,r=3,type="even")

</code></pre>

<hr>
<h2 id='OLHD.Y1998'>Orthogonal Latin Hypercube Design</h2><span id='topic+OLHD.Y1998'></span>

<h3>Description</h3>

<p><code>OLHD.Y1998</code> returns a <code>2^m+1</code> by <code>2m-2</code> orthogonal Latin hypercube design generated by the construction method of Ye (1998)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OLHD.Y1998(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OLHD.Y1998_+3A_m">m</code></td>
<td>
<p>A positive integer, and it must be greater than or equal to 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be an orthogonal LHD with the following run size: <code>n=2^m+1</code> and the following factor size: <code>k=2m-2</code>.
</p>


<h3>References</h3>

<p>Ye, K.Q. (1998) Orthogonal column Latin hypercubes and their application in computer experiments. <em>Journal of the American Statistical Association</em>, <strong>93</strong>(444), 1430-1439.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create an orthogonal LHD with m=3. So n=2^m+1=9 and k=2*m-2=4
OLHD.Y1998(m=3)

#create an orthogonal LHD with m=4. So n=2^m+1=17 and k=2*m-2=6
OLHD.Y1998(m=4)

</code></pre>

<hr>
<h2 id='phi_p'>Calculate the phi_p Criterion</h2><span id='topic+phi_p'></span>

<h3>Description</h3>

<p><code>phi_p</code> returns the phi_p criterion of an LHD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi_p(X, p = 15, q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_p_+3A_x">X</code></td>
<td>
<p>A matrix object. In general, <code>X</code> stands for the design matrix.</p>
</td></tr>
<tr><td><code id="phi_p_+3A_p">p</code></td>
<td>
<p>A positive integer, which is the parameter in the phi_p formula, and <code>p</code> is prefered to be large. The default is set to be 15.</p>
</td></tr>
<tr><td><code id="phi_p_+3A_q">q</code></td>
<td>
<p>The default is set to be 1, and it could be either 1 or 2. If <code>q</code> is 1, <code>dij</code> is the Manhattan (rectangular) distance. If <code>q</code> is 2, <code>dij</code> is the Euclidean distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a positive number indicating phi_p. <code>\phi_p = (\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}dij^{-p})^{1/p}</code>, where <code>dij =  \left\{ \sum_{k=1}^{m} \vert x_{ik}-x_{jk}\vert ^q \right\}^{1/q}</code>
</p>


<h3>References</h3>

<p>Jin, R., Chen, W., and Sudjianto, A. (2005) An efficient algorithm for constructing optimal design of computer experiments. <em>Journal of Statistical Planning and Inference</em>, <strong>134</strong>, 268-287.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a toy LHD with 5 rows and 3 columns
toy=rLHD(n=5,k=3);toy

#Calculate the phi_p criterion of toy with default setting
phi_p(X=toy)

#Calculate the phi_p criterion of toy with p=50 and q=2
phi_p(X=toy,p=50,q=2)
</code></pre>

<hr>
<h2 id='rLHD'>Generate a random Latin Hypercube Design (LHD)</h2><span id='topic+rLHD'></span>

<h3>Description</h3>

<p><code>rLHD</code> returns a random <code>n</code> by <code>k</code> Latin hypercube design matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rLHD(n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rLHD_+3A_n">n</code></td>
<td>
<p>A positive integer, which stands for the number of rows (or run size).</p>
</td></tr>
<tr><td><code id="rLHD_+3A_k">k</code></td>
<td>
<p>A positive integer, which stands for the number of columns (or factor size).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are positive integer, then the output will be a <code>n</code> by <code>k</code> design matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a toy LHD with 5 rows and 3 columns
toy=rLHD(n=5,k=3);toy

#another example with 9 rows and 2 columns
rLHD(9,2)
</code></pre>

<hr>
<h2 id='SA'>Simulated Annealing for LHD</h2><span id='topic+SA'></span>

<h3>Description</h3>

<p><code>SA</code> returns a <code>n</code> by <code>k</code> LHD matrix generated by simulated annealing algorithm (SA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SA(
  n,
  k,
  N = 10,
  T0 = 10,
  rate = 0.1,
  Tmin = 1,
  Imax = 5,
  OC = "phi_p",
  p = 15,
  q = 1,
  maxtime = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SA_+3A_n">n</code></td>
<td>
<p>A positive integer, which stands for the number of rows (or run size).</p>
</td></tr>
<tr><td><code id="SA_+3A_k">k</code></td>
<td>
<p>A positive integer, which stands for the number of columns (or factor size).</p>
</td></tr>
<tr><td><code id="SA_+3A_n">N</code></td>
<td>
<p>A positive integer, which stands for the number of iterations. The default is set to be 10. A large value of <code>N</code> will result a high CPU time, and it is recommended to be no greater than 500.</p>
</td></tr>
<tr><td><code id="SA_+3A_t0">T0</code></td>
<td>
<p>A positive number, which stands for the user-defined initial temperature. The default is set to be 10.</p>
</td></tr>
<tr><td><code id="SA_+3A_rate">rate</code></td>
<td>
<p>A positive percentage, which stands for temperature decrease rate, and it should be in (0,1). For example, rate=0.25 means the temperature decreases by 25% each time. The default is set to be 10%.</p>
</td></tr>
<tr><td><code id="SA_+3A_tmin">Tmin</code></td>
<td>
<p>A positive number, which stands for the minimium temperature allowed. When current temperature becomes smaller or equal to <code>Tmin</code>, the stopping criterion for current loop is met. The default is set to be 1.</p>
</td></tr>
<tr><td><code id="SA_+3A_imax">Imax</code></td>
<td>
<p>A positive integer, which stands for the maximum perturbations the algorithm will try without improvements before temperature is reduced. The default is set to be 5. For the computation complexity consideration, <code>Imax</code> is recommended to be smaller or equal to 5.</p>
</td></tr>
<tr><td><code id="SA_+3A_oc">OC</code></td>
<td>
<p>An optimality criterion. The default setting is &quot;phi_p&quot;, and it could be one of the following: &quot;phi_p&quot;, &quot;AvgAbsCor&quot;, &quot;MaxAbsCor&quot;, &quot;MaxProCriterion&quot;.</p>
</td></tr>
<tr><td><code id="SA_+3A_p">p</code></td>
<td>
<p>A positive integer, which is the parameter in the phi_p formula, and <code>p</code> is prefered to be large. The default is set to be 15.</p>
</td></tr>
<tr><td><code id="SA_+3A_q">q</code></td>
<td>
<p>The default is set to be 1, and it could be either 1 or 2. If <code>q</code> is 1, <code>dij</code> is the Manhattan (rectangular) distance. If <code>q</code> is 2, <code>dij</code> is the Euclidean distance.</p>
</td></tr>
<tr><td><code id="SA_+3A_maxtime">maxtime</code></td>
<td>
<p>A positive number, which indicates the expected maximum CPU time given by user, and it is measured by minutes. For example, maxtime=3.5 indicates the CPU time will be no greater than three and half minutes. The default is set to be 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a <code>n</code> by <code>k</code> LHD.
</p>


<h3>References</h3>

<p>Morris, M.D., and Mitchell, T.J. (1995) Exploratory designs for computer experiments. <em>Journal of Statistical Planning and Inference</em>, <strong>43</strong>, 381-402.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate a 5 by 3 maximin distance LHD with the default setting
try=SA(n=5,k=3)
try
phi_p(try)   #calculate the phi_p of "try".

#Another example
#generate a 8 by 4 nearly orthogonal LHD
try2=SA(n=8,k=4,OC="AvgAbsCor")
try2
AvgAbsCor(try2)  #calculate the average absolute correlation.

</code></pre>

<hr>
<h2 id='SA2008'>Simulated Annealing for LHD with Multi-objective Optimization Approach</h2><span id='topic+SA2008'></span>

<h3>Description</h3>

<p><code>SA2008</code> returns a <code>n</code> by <code>k</code> LHD matrix generated by simulated annealing algorithm with multi-objective optimization approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SA2008(
  n,
  k,
  N = 10,
  T0 = 10,
  rate = 0.1,
  Tmin = 1,
  Imax = 5,
  OC = "phi_p",
  p = 15,
  q = 1,
  maxtime = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SA2008_+3A_n">n</code></td>
<td>
<p>A positive integer, which stands for the number of rows (or run size).</p>
</td></tr>
<tr><td><code id="SA2008_+3A_k">k</code></td>
<td>
<p>A positive integer, which stands for the number of columns (or factor size).</p>
</td></tr>
<tr><td><code id="SA2008_+3A_n">N</code></td>
<td>
<p>A positive integer, which stands for the number of iterations. The default is set to be 10. A large value of <code>N</code> will result a high CPU time, and it is recommended to be no greater than 500.</p>
</td></tr>
<tr><td><code id="SA2008_+3A_t0">T0</code></td>
<td>
<p>A positive number, which stands for the user-defined initial temperature. The default is set to be 10.</p>
</td></tr>
<tr><td><code id="SA2008_+3A_rate">rate</code></td>
<td>
<p>A positive percentage, which stands for temperature decrease rate, and it should be in (0,1). For example, rate=0.25 means the temperature decreases by 25% each time. The default is set to be 10%.</p>
</td></tr>
<tr><td><code id="SA2008_+3A_tmin">Tmin</code></td>
<td>
<p>A positive number, which stands for the minimium temperature allowed. When current temperature becomes smaller or equal to <code>Tmin</code>, the stopping criterion for current loop is met. The default is set to be 1.</p>
</td></tr>
<tr><td><code id="SA2008_+3A_imax">Imax</code></td>
<td>
<p>A positive integer, which stands for the maximum perturbations the algorithm will try without improvements before temperature is reduced. The default is set to be 5. For the computation complexity consideration, <code>Imax</code> is recommended to be smaller or equal to 5.</p>
</td></tr>
<tr><td><code id="SA2008_+3A_oc">OC</code></td>
<td>
<p>An optimality criterion. The default setting is &quot;phi_p&quot;, and it could be one of the following: &quot;phi_p&quot;, &quot;AvgAbsCor&quot;, &quot;MaxAbsCor&quot;, &quot;MaxProCriterion&quot;.</p>
</td></tr>
<tr><td><code id="SA2008_+3A_p">p</code></td>
<td>
<p>A positive integer, which is the parameter in the phi_p formula, and <code>p</code> is prefered to be large. The default is set to be 15.</p>
</td></tr>
<tr><td><code id="SA2008_+3A_q">q</code></td>
<td>
<p>The default is set to be 1, and it could be either 1 or 2. If <code>q</code> is 1, <code>dij</code> is the Manhattan (rectangular) distance. If <code>q</code> is 2, <code>dij</code> is the Euclidean distance.</p>
</td></tr>
<tr><td><code id="SA2008_+3A_maxtime">maxtime</code></td>
<td>
<p>A positive number, which indicates the expected maximum CPU time given by user, and it is measured by minutes. For example, maxtime=3.5 indicates the CPU time will be no greater than three and half minutes. The default is set to be 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a <code>n</code> by <code>k</code> LHD. This modified simulated annealing algorithm reduces columnwise correlations and maximizes minimum distance between design points simultaneously, with a cost of more computational complexity.
</p>


<h3>References</h3>

<p>Joseph, V.R., and Hung, Y. (2008) Orthogonal-maximin Latin hypercube designs. <em>Statistica Sinica</em>, <strong>18</strong>, 171-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate a 5 by 3 maximin distance LHD with the default setting
try=SA2008(n=5,k=3)
try
phi_p(try)   #calculate the phi_p of "try".

#Another example
#generate a 8 by 4 nearly orthogonal LHD
try2=SA2008(n=8,k=4,OC="AvgAbsCor")
try2
AvgAbsCor(try2)  #calculate the average absolute correlation.
</code></pre>

<hr>
<h2 id='SLHD'>Sliced Latin Hypercube Design (SLHD)</h2><span id='topic+SLHD'></span>

<h3>Description</h3>

<p><code>SLHD</code> returns a <code>n</code> by <code>k</code> LHD matrix generated by improved two-stage algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SLHD(
  n,
  k,
  t = 1,
  N = 10,
  T0 = 10,
  rate = 0.1,
  Tmin = 1,
  Imax = 3,
  OC = "phi_p",
  p = 15,
  q = 1,
  stage2 = FALSE,
  maxtime = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SLHD_+3A_n">n</code></td>
<td>
<p>A positive integer, which stands for the number of rows (or run size).</p>
</td></tr>
<tr><td><code id="SLHD_+3A_k">k</code></td>
<td>
<p>A positive integer, which stands for the number of columns (or factor size).</p>
</td></tr>
<tr><td><code id="SLHD_+3A_t">t</code></td>
<td>
<p>A positive integer, which stands for the number of slices. <code>n</code>/<code>t</code> must be a positive integer, that is, n is divisible by t. <code>t</code> must be smaller or equal to <code>k</code> when <code>n</code> is 9 or larger. <code>t</code> must be smaller than <code>k</code> when <code>n</code> is smaller than 9. Otherwise, the funtion will never stop. The default is set to be 1.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_n">N</code></td>
<td>
<p>A positive integer, which stands for the number of iterations. The default is set to be 10. A large value of <code>N</code> will result a high CPU time, and it is recommended to be no greater than 500.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_t0">T0</code></td>
<td>
<p>A positive number, which stands for the user-defined initial temperature. The default is set to be 10.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_rate">rate</code></td>
<td>
<p>A positive percentage, which stands for temperature decrease rate, and it should be in (0,1). For example, rate=0.25 means the temperature decreases by 25% each time. The default is set to be 10%.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_tmin">Tmin</code></td>
<td>
<p>A positive number, which stands for the minimium temperature allowed. When current temperature becomes smaller or equal to <code>Tmin</code>, the stopping criterion for current loop is met. The default is set to be 1.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_imax">Imax</code></td>
<td>
<p>A positive integer, which stands for the maximum perturbations the algorithm will try without improvements before temperature is reduced. The default is set to be 5. For the computation complexity consideration, <code>Imax</code> is recommended to be smaller or equal to 5.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_oc">OC</code></td>
<td>
<p>An optimality criterion. The default setting is &quot;phi_p&quot;, and it could be one of the following: &quot;phi_p&quot;, &quot;AvgAbsCor&quot;, &quot;MaxAbsCor&quot;, &quot;MaxProCriterion&quot;.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_p">p</code></td>
<td>
<p>A positive integer, which is the parameter in the phi_p formula, and <code>p</code> is prefered to be large. The default is set to be 15.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_q">q</code></td>
<td>
<p>The default is set to be 1, and it could be either 1 or 2. If <code>q</code> is 1, <code>dij</code> is the Manhattan (rectangular) distance. If <code>q</code> is 2, <code>dij</code> is the Euclidean distance.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_stage2">stage2</code></td>
<td>
<p>A logic input argument, and it could be either FALSE or TRUE. If <code>stage2</code> is FALSE (the default setting), <code>SLHD</code> will only implement the first stage of the algorithm. If <code>stage2</code> is TRUE, <code>SLHD</code> will implement the whole algorithm.</p>
</td></tr>
<tr><td><code id="SLHD_+3A_maxtime">maxtime</code></td>
<td>
<p>A positive number, which indicates the expected maximum CPU time given by user, and it is measured by minutes. For example, maxtime=3.5 indicates the CPU time will be no greater than three and half minutes. The default is set to be 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a <code>n</code> by <code>k</code> LHD. As mentioned from the original paper, the first stage plays a much more important role since it optimizes the slice level. More resources should be given to the first stage if computational budgets are limited. Let m=n/t, where m is the number of rows for each slice, if (m)^k &gt;&gt; n, the second stage becomes optional. That is the reason why we add a <code>stage2</code> parameter to let users decide if the second stage is needed.
</p>


<h3>References</h3>

<p>Ba, S., Myers, W.R., and Brenneman, W.A. (2015) Optimal Sliced Latin Hypercube Designs. <em>Technometrics</em>, <strong>57</strong>, 479-487.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate a 5 by 3 maximin distance LHD with the default setting
try=SLHD(n=5,k=3)
try
phi_p(try)   #calculate the phi_p of "try".

#generate a 5 by 3 maximin distance LHD with stage II
#let stage2=TRUE and other input are the same as above
try2=SLHD(n=5,k=3,stage2=TRUE)
try2
phi_p(try2)   #calculate the phi_p of "try2".

#Another example
#generate a 8 by 4 nearly orthogonal LHD
try3=SLHD(n=8,k=4,OC="AvgAbsCor",stage2=TRUE)
try3
AvgAbsCor(try3)  #calculate the average absolute correlation.
</code></pre>

<hr>
<h2 id='WT'>Williams Transformation</h2><span id='topic+WT'></span>

<h3>Description</h3>

<p><code>WT</code> returns a matrix after implementing the Williams transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WT(X, baseline = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WT_+3A_x">X</code></td>
<td>
<p>A matrix object. In general, <code>X</code> stands for the design matrix, e.g. an LHD or a GLP design.</p>
</td></tr>
<tr><td><code id="WT_+3A_baseline">baseline</code></td>
<td>
<p>A integer, which defines the minimum value for each column of the matrix. The default is set to be 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are logical, then the output will be a matrix whose sizes are the same as input matrix.
</p>


<h3>References</h3>

<p>Williams, E. J. (1949) Experimental designs balanced for the estimation of residual effects of treatments. <em>Australian Journal of Chemistry</em>, <strong>2</strong>, 149-168.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a toy LHD with 5 rows and 3 columns
toy=rLHD(n=5,k=3);toy
toy2=toy-1;toy2  #make elements of "toy" become 0,1,2,3,4

#Implementing Williams transformation on both toy and toy2:
#The result shows that "WT" function is able to detect the
#elements of input matrix and make adjustments.
WT(toy)
WT(toy2)

#Change the baseline
WT(toy,baseline=5)
WT(toy,baseline=10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
