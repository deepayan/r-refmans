<!DOCTYPE html><html><head><title>Help for package fmesher</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fmesher}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fmesher-package'><p>fmesher: Triangle Meshes and Related Geometry Tools</p></a></li>
<li><a href='#call-stack'><p>Call stack utility functions</p></a></li>
<li><a href='#fm_as_dgCMatrix'><p>Conversion between sparse matrix types</p></a></li>
<li><a href='#fm_as_fm'><p>Convert objects to fmesher objects</p></a></li>
<li><a href='#fm_as_lattice_2d'><p>Convert objects to <code>fm_lattice_2d</code></p></a></li>
<li><a href='#fm_as_mesh_1d'><p>Convert objects to <code>fm_segm</code></p></a></li>
<li><a href='#fm_as_mesh_2d'><p>Convert objects to <code>fm_mesh_2d</code></p></a></li>
<li><a href='#fm_as_segm'><p>Convert objects to <code>fm_segm</code></p></a></li>
<li><a href='#fm_as_sfc'><p>Conversion methods from mesh related objects to sfc</p></a></li>
<li><a href='#fm_as_tensor'><p>Convert objects to <code>fm_tensor</code></p></a></li>
<li><a href='#fm_bary'><p>Compute barycentric coordinates</p></a></li>
<li><a href='#fm_basis'><p>Compute mapping matrix between mesh function space and points</p></a></li>
<li><a href='#fm_bbox'><p>Bounding box class</p></a></li>
<li><a href='#fm_block'><p>Blockwise aggregation matrices</p></a></li>
<li><a href='#fm_centroids'><p>Extract triangle centroids from an <code>fm_mesh_2d</code></p></a></li>
<li><a href='#fm_contains'><p>Check which mesh triangles are inside a polygon</p></a></li>
<li><a href='#fm_cprod'><p>(Blockwise) cross product of integration points</p></a></li>
<li><a href='#fm_crs'><p>Obtain coordinate reference system object</p></a></li>
<li><a href='#fm_CRS'><p>Create a coordinate reference system object</p></a></li>
<li><a href='#fm_CRS_as_list'><p>Show expanded CRS arguments</p></a></li>
<li><a href='#fm_crs_is_identical'><p>Check if two CRS objects are identical</p></a></li>
<li><a href='#fm_crs_is_null'><p>Check if a crs is NULL or NA</p></a></li>
<li><a href='#fm_crs_wkt'><p>Handling CRS/WKT</p></a></li>
<li><a href='#fm_crs&lt;-'><p>Assignment operators for crs information objects</p></a></li>
<li><a href='#fm_detect_manifold'><p>Detect manifold type</p></a></li>
<li><a href='#fm_diameter'><p>Diameter bound for a geometric object</p></a></li>
<li><a href='#fm_dof'><p>Function spece degrees of freedom</p></a></li>
<li><a href='#fm_evaluate'><p>Methods for projecting to/from mesh objects</p></a></li>
<li><a href='#fm_evaluator_helpers'><p>Internal helper functions for mesh field evaluation</p></a></li>
<li><a href='#fm_fem'><p>Compute finite element matrices</p></a></li>
<li><a href='#fm_generate_colors'><p>Generate text RGB color specifications.</p></a></li>
<li><a href='#fm_gmrf'><p>SPDE, GMRF, and Mat√©rn process methods</p></a></li>
<li><a href='#fm_int'><p>Multi-domain integration</p></a></li>
<li><a href='#fm_int_mesh_2d'><p>Subset integration on a mesh</p></a></li>
<li><a href='#fm_int_mesh_2d_core'><p>Integration scheme for mesh triangle interiors</p></a></li>
<li><a href='#fm_int_multi_sampler'><p>Multi-domain sampler integration</p></a></li>
<li><a href='#fm_is_within'><p>Query if points are inside a mesh</p></a></li>
<li><a href='#fm_lattice_2d'><p>Make a lattice object</p></a></li>
<li><a href='#fm_list'><p>Handle lists of fmesher objects</p></a></li>
<li><a href='#fm_manifold'><p>Query the mesh manifold type</p></a></li>
<li><a href='#fm_mesh_1d'><p>Make a 1D mesh object</p></a></li>
<li><a href='#fm_mesh_2d'><p>Make a 2D mesh object</p></a></li>
<li><a href='#fm_mesh_2d_map'><p>Special coordinate mappings for <code>fm_mesh_2d</code> projections.</p></a></li>
<li><a href='#fm_mesh_intersection'><p>Construct the intersection mesh of a mesh and a polygon</p></a></li>
<li><a href='#fm_nonconvex_hull'><p>Compute an extension of a spatial object</p></a></li>
<li><a href='#fm_nonconvex_hull_inla'><p>Non-convex hull computation</p></a></li>
<li><a href='#fm_pixels'><p>Generate lattice points covering a mesh</p></a></li>
<li><a href='#fm_raw_basis'><p>Basis functions for mesh manifolds</p></a></li>
<li><a href='#fm_rcdt_2d'><p>Refined Constrained Delaunay Triangulation</p></a></li>
<li><a href='#fm_refine'><p>Refine a 2d mesh</p></a></li>
<li><a href='#fm_row_kron'><p>Row-wise Kronecker products</p></a></li>
<li><a href='#fm_safe_sp'><p>Check for potential <code>sp</code> version compatibility issues</p></a></li>
<li><a href='#fm_segm'><p>Make a spatial segment object</p></a></li>
<li><a href='#fm_segm_contour_helper'><p>Contour segment</p></a></li>
<li><a href='#fm_segm_list'><p>Methods for fm_segm lists</p></a></li>
<li><a href='#fm_simplify'><p>Recursive curve simplification.</p></a></li>
<li><a href='#fm_simplify_helper'><p>Recursive curve simplification.</p></a></li>
<li><a href='#fm_split_lines'><p>Split lines at triangle edges</p></a></li>
<li><a href='#fm_store_points'><p>Store points in different formats</p></a></li>
<li><a href='#fm_tensor'><p>Make a tensor product function space</p></a></li>
<li><a href='#fm_transform'><p>Object coordinate transformation</p></a></li>
<li><a href='#fm_unify_coords'><p>Unify coordinates to 3-column matrix</p></a></li>
<li><a href='#fm_vertex_projection'><p>Project integration points to mesh vertices</p></a></li>
<li><a href='#fm_vertices'><p>Extract vertex locations from an <code>fm_mesh_2d</code></p></a></li>
<li><a href='#fm_wkt_as_wkt_tree'><p>Internal WKT handling</p></a></li>
<li><a href='#fmesher_bary'><p>Barycentric coordinate computation</p></a></li>
<li><a href='#fmesher_fem'><p>Finite element matrix computation</p></a></li>
<li><a href='#fmesher_globe_points'><p>Globe points</p></a></li>
<li><a href='#fmesher_rcdt'><p>Refined Constrained Delaunay Triangulation</p></a></li>
<li><a href='#fmesher_spherical_bsplines1'><p>Rotationally invariant spherical B-splines</p></a></li>
<li><a href='#fmesher_split_lines'><p>Split lines at triangle edges</p></a></li>
<li><a href='#fmesher-deprecated'><p>Deprecated functions in fmesher</p></a></li>
<li><a href='#fmesher-print'><p>Print objects</p></a></li>
<li><a href='#fmexample'><p>Example mesh data</p></a></li>
<li><a href='#geom_fm'><p>ggplot2 geomes for fmesher related objects</p></a></li>
<li><a href='#globeproj'><p>Old globe projection methods</p></a></li>
<li><a href='#local_testthat'><p>Unit test helpers</p></a></li>
<li><a href='#plot_globeproj'><p>Plot a globeproj object</p></a></li>
<li><a href='#plot_PolySet'><p>Plot a projected PolySet</p></a></li>
<li><a href='#plot_rgl'><p>Low level triangulation mesh plotting</p></a></li>
<li><a href='#plot.fm_mesh_2d'><p>Draw a triangulation mesh object</p></a></li>
<li><a href='#plot.fm_segm'><p>Draw <code>fm_segm</code> objects.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Triangle Meshes and Related Geometry Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate planar and spherical triangle meshes,
    compute finite element calculations for 1- and 2-dimensional flat and curved
    manifolds with associated basis function spaces, methods for lines and
    polygons, and transparent handling of coordinate reference systems and
    coordinate transformation, including 'sf' and 'sp' geometries. The core
    'fmesher' library code was originally part of the 'INLA' package, and
    implements parts of "Triangulations and Applications" by
    Hjelle and Daehlen (2006) &lt;<a href="https://doi.org/10.1007%2F3-540-33261-8">doi:10.1007/3-540-33261-8</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, graphics, grDevices, lifecycle, Matrix, rlang, sf, sp
(&ge; 1.6-1), stats, tibble, utils, withr, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, ggpolypath, inlabru (&ge; 2.8.0), knitr, testthat (&ge;
3.0.0), terra, tidyterra, rgl, rmarkdown, splancs, gsl</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://inlabru-org.github.io/fmesher/">https://inlabru-org.github.io/fmesher/</a>,
<a href="https://github.com/inlabru-org/fmesher">https://github.com/inlabru-org/fmesher</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/inlabru-org/fmesher/issues">https://github.com/inlabru-org/fmesher/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL-2.0</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>2010-2023 Finn Lindgren, except src/predicates.cc by
Jonathan Richard Shewchuk, 1996</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'deprecated.R' 'bary.R' 'bbox.R' 'print.R'
'crs.R' 'data-fmexample.R' 'diameter.R' 'evaluator.R' 'fem.R'
'fm.R' 'fmesher-package.R' 'fmesher.R' 'ggplot.R'
'integration.R' 'lattice_2d.R' 'list.R' 'local.R' 'manifold.R'
'mapping.R' 'matern.R' 'mesh.R' 'mesh_1d.R' 'mesh_2d.R'
'nonconvex_hull.R' 'onload.R' 'plot.R' 'segm.R' 'sf_mesh.R'
'sf_utils.R' 'simplify.R' 'sp_mesh.R' 'split_lines.R'
'tensor.R' 'utils.R'</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-20 20:30:03 UTC; flindgre</td>
</tr>
<tr>
<td>Author:</td>
<td>Finn Lindgren <a href="https://orcid.org/0000-0002-5833-2011"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph] (Finn Lindgren wrote the main code),
  Seaton Andy [ctb] (Andy Seaton constributed features to the sf support),
  Suen Man Ho [ctb] (Man Ho Suen contributed features and code structure
    design for the integration methods),
  Fabian E. Bachl [ctb] (Fabian Bachl co-developed precursors of
    fm_pixels and fm_split_lines in inlabru)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Finn Lindgren &lt;finn.lindgren@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-20 21:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='fmesher-package'>fmesher: Triangle Meshes and Related Geometry Tools</h2><span id='topic+fmesher'></span><span id='topic+fmesher-package'></span>

<h3>Description</h3>

<p>Generate planar and spherical triangle meshes, compute finite element calculations for 1- and 2-dimensional flat and curved manifolds with associated basis function spaces, methods for lines and polygons, and transparent handling of coordinate reference systems and coordinate transformation, including 'sf' and 'sp' geometries. The core 'fmesher' library code was originally part of the 'INLA' package, and implements parts of &quot;Triangulations and Applications&quot; by Hjelle and Daehlen (2006) <a href="https://doi.org/10.1007/3-540-33261-8">doi:10.1007/3-540-33261-8</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a> (<a href="https://orcid.org/0000-0002-5833-2011">ORCID</a>) (Finn Lindgren wrote the main code) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Seaton Andy <a href="mailto:andy.e.seaton@gmail.com">andy.e.seaton@gmail.com</a> (Andy Seaton constributed features to the sf support) [contributor]
</p>
</li>
<li><p> Suen Man Ho <a href="mailto:M.H.Suen@sms.ed.ac.uk">M.H.Suen@sms.ed.ac.uk</a> (Man Ho Suen contributed features and code structure design for the integration methods) [contributor]
</p>
</li>
<li><p> Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a> (Fabian Bachl co-developed precursors of fm_pixels and fm_split_lines in inlabru) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://inlabru-org.github.io/fmesher/">https://inlabru-org.github.io/fmesher/</a>
</p>
</li>
<li> <p><a href="https://github.com/inlabru-org/fmesher">https://github.com/inlabru-org/fmesher</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/inlabru-org/fmesher/issues">https://github.com/inlabru-org/fmesher/issues</a>
</p>
</li></ul>


<hr>
<h2 id='call-stack'>Call stack utility functions</h2><span id='topic+call-stack'></span><span id='topic+fm_caller_name'></span><span id='topic+fm_call_stack'></span><span id='topic+fm_try_callstack'></span>

<h3>Description</h3>

<p>Helper functions for displaying call stack information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_caller_name(which = 0L, override = NULL)

fm_call_stack(start = 0L, end = 0L, with_numbers = TRUE, ...)

fm_try_callstack(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call-stack_+3A_which">which</code></td>
<td>
<p>The number of frames to go back from the caller</p>
</td></tr>
<tr><td><code id="call-stack_+3A_override">override</code></td>
<td>
<p>character; Overrides the automated function name logic</p>
</td></tr>
<tr><td><code id="call-stack_+3A_start">start</code></td>
<td>
<p>The stack starting point</p>
</td></tr>
<tr><td><code id="call-stack_+3A_end">end</code></td>
<td>
<p>The stack end point</p>
</td></tr>
<tr><td><code id="call-stack_+3A_with_numbers">with_numbers</code></td>
<td>
<p>INclude call stack location numbers</p>
</td></tr>
<tr><td><code id="call-stack_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
<tr><td><code id="call-stack_+3A_expr">expr</code></td>
<td>
<p>An <code>expression</code> to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_caller_name</code> returns a string with the the name of a calling function
</p>
<p><code>fm_call_stack</code> returns a character vector
</p>
<p><code>fm_try_callstack</code> If successful, returns (invisibly) the value from the
evaluated expression, otherwise an error object with call stack information attached
to the error message.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_call_stack()</code>: 
</p>
</li>
<li> <p><code>fm_try_callstack()</code>: Inspired by <code>berryFunctions::tryStack</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- function() {
  print(fm_caller_name())
  nm &lt;- fm_caller_name()
  print(nm)
}
fun()
</code></pre>

<hr>
<h2 id='fm_as_dgCMatrix'>Conversion between sparse matrix types</h2><span id='topic+fm_as_dgCMatrix'></span><span id='topic+fm_as_dgTMatrix'></span><span id='topic+fm_as_unpackedMatrix'></span><span id='topic+fm_as_fmesher_sparse'></span><span id='topic+fm_as_dgCMatrix.default'></span><span id='topic+fm_as_dgCMatrix.fmesher_sparse'></span><span id='topic+fm_as_dgTMatrix.default'></span><span id='topic+fm_as_unpackedMatrix.default'></span><span id='topic+fm_as_unpackedMatrix.fmesher_sparse'></span><span id='topic+fm_as_dgTMatrix.fmesher_sparse'></span>

<h3>Description</h3>

<p>Conversion between sparse matrix types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_dgCMatrix(x)

fm_as_dgTMatrix(x, unique = TRUE, ...)

fm_as_unpackedMatrix(x)

fm_as_fmesher_sparse(x)

## Default S3 method:
fm_as_dgCMatrix(x)

## S3 method for class 'fmesher_sparse'
fm_as_dgCMatrix(x)

## Default S3 method:
fm_as_dgTMatrix(x, unique = TRUE, ...)

## Default S3 method:
fm_as_unpackedMatrix(x)

## S3 method for class 'fmesher_sparse'
fm_as_unpackedMatrix(x)

## S3 method for class 'fmesher_sparse'
fm_as_dgTMatrix(x, unique = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_as_dgCMatrix_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_dgCMatrix_+3A_unique">unique</code></td>
<td>
<p>logical; if <code>TRUE</code>, ensures that the sparse triplet
representation has a single entry for each non-zero matrix element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_as_dgCMatrix</code> returns a <a href="Matrix.html#topic+dgCMatrix-class">Matrix::dgCMatrix</a> object.
</p>
<p><code>fm_as_dgTMatrix</code> returns a <a href="Matrix.html#topic+dgTMatrix-class">Matrix::dgTMatrix</a> object.
</p>
<p><code>fm_as_unpackedMatrix</code> returns an object of virtual class
<a href="Matrix.html#topic+unpackedMatrix-class">Matrix::unpackedMatrix</a>.
</p>
<p><code>fm_as_fmesher_sparse</code> returns an <code>fmesher_sparse</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
str(A &lt;- fm_as_dgCMatrix(matrix(c(1, 2, 0, 0, 0, 3, 4, 0, 5), 3, 3)))
str(fm_as_dgTMatrix(A))
str(fm_as_unpackedMatrix(A))
str(fm_as_fmesher_sparse(A))
</code></pre>

<hr>
<h2 id='fm_as_fm'>Convert objects to fmesher objects</h2><span id='topic+fm_as_fm'></span><span id='topic+fm_as_fm.NULL'></span><span id='topic+fm_as_fm.fm_mesh_1d'></span><span id='topic+fm_as_fm.fm_mesh_2d'></span><span id='topic+fm_as_fm.fm_segm'></span><span id='topic+fm_as_fm.fm_lattice_2d'></span><span id='topic+fm_as_fm.fm_bbox'></span><span id='topic+fm_as_fm.crs'></span><span id='topic+fm_as_fm.CRS'></span><span id='topic+fm_as_fm.fm_crs'></span><span id='topic+fm_as_fm.inla.CRS'></span><span id='topic+fm_as_fm.inla.mesh.1d'></span><span id='topic+fm_as_fm.inla.mesh'></span><span id='topic+fm_as_fm.inla.mesh.segment'></span><span id='topic+fm_as_fm.inla.mesh.lattice'></span>

<h3>Description</h3>

<p>Used for conversion from general objects
(usually <code>inla.mesh</code> and other INLA specific classes)
to <code>fmesher</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_fm(x, ...)

## S3 method for class 'NULL'
fm_as_fm(x, ...)

## S3 method for class 'fm_mesh_1d'
fm_as_fm(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_as_fm(x, ...)

## S3 method for class 'fm_segm'
fm_as_fm(x, ...)

## S3 method for class 'fm_lattice_2d'
fm_as_fm(x, ...)

## S3 method for class 'fm_bbox'
fm_as_fm(x, ...)

## S3 method for class 'crs'
fm_as_fm(x, ...)

## S3 method for class 'CRS'
fm_as_fm(x, ...)

## S3 method for class 'fm_crs'
fm_as_fm(x, ...)

## S3 method for class 'inla.CRS'
fm_as_fm(x, ...)

## S3 method for class 'inla.mesh.1d'
fm_as_fm(x, ...)

## S3 method for class 'inla.mesh'
fm_as_fm(x, ...)

## S3 method for class 'inla.mesh.segment'
fm_as_fm(x, ...)

## S3 method for class 'inla.mesh.lattice'
fm_as_fm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_as_fm_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_fm_+3A_...">...</code></td>
<td>
<p>Arguments forwarded to submethods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of some <code style="white-space: pre;">&#8288;fm_*&#8288;</code> class
</p>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_fm(NULL)

</code></pre>

<hr>
<h2 id='fm_as_lattice_2d'>Convert objects to <code>fm_lattice_2d</code></h2><span id='topic+fm_as_lattice_2d'></span><span id='topic+fm_as_lattice_2d_list'></span><span id='topic+fm_as_lattice_2d.fm_lattice_2d'></span><span id='topic+fm_as_lattice_2d.inla.mesh.lattice'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_lattice_2d</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_lattice_2d(...)

fm_as_lattice_2d_list(x, ...)

## S3 method for class 'fm_lattice_2d'
fm_as_lattice_2d(x, ...)

## S3 method for class 'inla.mesh.lattice'
fm_as_lattice_2d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_as_lattice_2d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_as_lattice_2d_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_lattice_2d</code> or <code>fm_lattice_2d_list</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_lattice_2d()</code>: Convert an object to <code>fm_lattice_2d</code>.
</p>
</li>
<li> <p><code>fm_as_lattice_2d_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_as_lattice_2d_list(list(fm_lattice_2d(), fm_lattice_2d())))

</code></pre>

<hr>
<h2 id='fm_as_mesh_1d'>Convert objects to <code>fm_segm</code></h2><span id='topic+fm_as_mesh_1d'></span><span id='topic+fm_as_mesh_1d_list'></span><span id='topic+fm_as_mesh_1d.fm_mesh_1d'></span><span id='topic+fm_as_mesh_1d.inla.mesh.1d'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_segm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_mesh_1d(x, ...)

fm_as_mesh_1d_list(x, ...)

## S3 method for class 'fm_mesh_1d'
fm_as_mesh_1d(x, ...)

## S3 method for class 'inla.mesh.1d'
fm_as_mesh_1d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_as_mesh_1d_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_mesh_1d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_1d</code> or <code>fm_mesh_1d_list</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_mesh_1d()</code>: Convert an object to <code>fm_mesh_1d</code>.
</p>
</li>
<li> <p><code>fm_as_mesh_1d_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_mesh_1d_list(list(fm_mesh_1d(1:4)))
</code></pre>

<hr>
<h2 id='fm_as_mesh_2d'>Convert objects to <code>fm_mesh_2d</code></h2><span id='topic+fm_as_mesh_2d'></span><span id='topic+fm_as_mesh_2d_list'></span><span id='topic+fm_as_mesh_2d.fm_mesh_2d'></span><span id='topic+fm_as_mesh_2d.inla.mesh'></span><span id='topic+fm_as_mesh_2d.sfg'></span><span id='topic+fm_as_mesh_2d.sfc_MULTIPOLYGON'></span><span id='topic+fm_as_mesh_2d.sfc_POLYGON'></span><span id='topic+fm_as_mesh_2d.sf'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_mesh_2d</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_mesh_2d(x, ...)

fm_as_mesh_2d_list(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_as_mesh_2d(x, ...)

## S3 method for class 'inla.mesh'
fm_as_mesh_2d(x, ...)

## S3 method for class 'sfg'
fm_as_mesh_2d(x, ...)

## S3 method for class 'sfc_MULTIPOLYGON'
fm_as_mesh_2d(x, ...)

## S3 method for class 'sfc_POLYGON'
fm_as_mesh_2d(x, ...)

## S3 method for class 'sf'
fm_as_mesh_2d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_as_mesh_2d_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_mesh_2d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_2d</code> or <code>fm_mesh_2d_list</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_mesh_2d()</code>: Convert an object to <code>fm_mesh_2d</code>.
</p>
</li>
<li> <p><code>fm_as_mesh_2d_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_mesh_2d_list(list(fm_mesh_2d(cbind(2, 1))))
</code></pre>

<hr>
<h2 id='fm_as_segm'>Convert objects to <code>fm_segm</code></h2><span id='topic+fm_as_segm'></span><span id='topic+fm_as_segm_list'></span><span id='topic+fm_as_segm.fm_segm'></span><span id='topic+fm_as_segm.inla.mesh.segment'></span><span id='topic+fm_as_segm.sfg'></span><span id='topic+fm_as_segm.sfc_POINT'></span><span id='topic+fm_as_segm.sfc_LINESTRING'></span><span id='topic+fm_as_segm.sfc_MULTILINESTRING'></span><span id='topic+fm_as_segm.sfc_POLYGON'></span><span id='topic+fm_as_segm.sfc_MULTIPOLYGON'></span><span id='topic+fm_as_segm.sfc_GEOMETRY'></span><span id='topic+fm_as_segm.sf'></span><span id='topic+fm_as_segm.matrix'></span><span id='topic+fm_as_segm.SpatialPoints'></span><span id='topic+fm_as_segm.SpatialPointsDataFrame'></span><span id='topic+fm_as_segm.Line'></span><span id='topic+fm_as_segm.Lines'></span><span id='topic+fm_as_segm.SpatialLines'></span><span id='topic+fm_as_segm.SpatialLinesDataFrame'></span><span id='topic+fm_as_segm.SpatialPolygons'></span><span id='topic+fm_as_segm.SpatialPolygonsDataFrame'></span><span id='topic+fm_as_segm.Polygons'></span><span id='topic+fm_as_segm.Polygon'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_segm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_segm(x, ...)

fm_as_segm_list(x, ...)

## S3 method for class 'fm_segm'
fm_as_segm(x, ...)

## S3 method for class 'inla.mesh.segment'
fm_as_segm(x, ...)

## S3 method for class 'sfg'
fm_as_segm(x, ...)

## S3 method for class 'sfc_POINT'
fm_as_segm(x, reverse = FALSE, grp = NULL, is.bnd = TRUE, ...)

## S3 method for class 'sfc_LINESTRING'
fm_as_segm(x, join = TRUE, grp = NULL, reverse = FALSE, ...)

## S3 method for class 'sfc_MULTILINESTRING'
fm_as_segm(x, join = TRUE, grp = NULL, reverse = FALSE, ...)

## S3 method for class 'sfc_POLYGON'
fm_as_segm(x, join = TRUE, grp = NULL, ...)

## S3 method for class 'sfc_MULTIPOLYGON'
fm_as_segm(x, join = TRUE, grp = NULL, ...)

## S3 method for class 'sfc_GEOMETRY'
fm_as_segm(x, grp = NULL, join = TRUE, ...)

## S3 method for class 'sf'
fm_as_segm(x, ...)

## S3 method for class 'matrix'
fm_as_segm(
  x,
  reverse = FALSE,
  grp = NULL,
  is.bnd = FALSE,
  crs = NULL,
  closed = FALSE,
  ...
)

## S3 method for class 'SpatialPoints'
fm_as_segm(x, reverse = FALSE, grp = NULL, is.bnd = TRUE, closed = FALSE, ...)

## S3 method for class 'SpatialPointsDataFrame'
fm_as_segm(x, ...)

## S3 method for class 'Line'
fm_as_segm(x, reverse = FALSE, grp = NULL, crs = NULL, ...)

## S3 method for class 'Lines'
fm_as_segm(x, join = TRUE, grp = NULL, crs = NULL, ...)

## S3 method for class 'SpatialLines'
fm_as_segm(x, join = TRUE, grp = NULL, ...)

## S3 method for class 'SpatialLinesDataFrame'
fm_as_segm(x, ...)

## S3 method for class 'SpatialPolygons'
fm_as_segm(x, join = TRUE, grp = NULL, ...)

## S3 method for class 'SpatialPolygonsDataFrame'
fm_as_segm(x, ...)

## S3 method for class 'Polygons'
fm_as_segm(x, join = TRUE, crs = NULL, grp = NULL, ...)

## S3 method for class 'Polygon'
fm_as_segm(x, crs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_as_segm_+3A_x">x</code></td>
<td>
<p>Object to be converted.</p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_reverse">reverse</code></td>
<td>
<p>logical; When TRUE, reverse the order of the input points.
Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_grp">grp</code></td>
<td>
<p>if non-null, should be an integer vector of grouping labels for
one for each segment.
Default <code>NULL</code></p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_is.bnd">is.bnd</code></td>
<td>
<p>logical; if <code>TRUE</code>, set the boundary flag for the segments.
Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_join">join</code></td>
<td>
<p>logical; if <code>TRUE</code>, join input segments with common vertices.
Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_crs">crs</code></td>
<td>
<p>A crs object</p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_closed">closed</code></td>
<td>
<p>logical; whether to treat a point sequence as a closed polygon.
Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_segm</code> or <code>fm_segm_list</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_segm()</code>: Convert an object to <code>fm_segm</code>.
</p>
</li>
<li> <p><code>fm_as_segm_list()</code>: Convert each element, making a <code>fm_segm_list</code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+c.fm_segm">c.fm_segm()</a></code>, <code><a href="#topic+c.fm_segm_list">c.fm_segm_list()</a></code>,
<code><a href="#topic++5B.fm_segm_list">[.fm_segm_list()</a></code>
</p>
<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_segm_list(list(
  fm_segm(fmexample$mesh),
  fm_segm(fmexample$mesh, boundary = FALSE)
))

(segm &lt;- fm_segm(fmexample$mesh, boundary = FALSE))
(segm_sfc &lt;- fm_as_sfc(segm))
(fm_as_segm(segm_sfc))

</code></pre>

<hr>
<h2 id='fm_as_sfc'>Conversion methods from mesh related objects to sfc</h2><span id='topic+fm_as_sfc'></span><span id='topic+fm_as_sfc.inla.mesh'></span><span id='topic+fm_as_sfc.fm_mesh_2d'></span><span id='topic+fm_as_sfc.inla.mesh.segment'></span><span id='topic+fm_as_sfc.fm_segm'></span><span id='topic+fm_as_sfc.sfc'></span><span id='topic+fm_as_sfc.sf'></span>

<h3>Description</h3>

<p>Conversion methods from mesh related objects to sfc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_sfc(x, ...)

## S3 method for class 'inla.mesh'
fm_as_sfc(x, ..., multi = FALSE)

## S3 method for class 'fm_mesh_2d'
fm_as_sfc(x, ..., multi = FALSE)

## S3 method for class 'inla.mesh.segment'
fm_as_sfc(x, ..., multi = FALSE)

## S3 method for class 'fm_segm'
fm_as_sfc(x, ..., multi = FALSE)

## S3 method for class 'sfc'
fm_as_sfc(x, ...)

## S3 method for class 'sf'
fm_as_sfc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_as_sfc_+3A_x">x</code></td>
<td>
<p>An object to be coerced/transformed/converted into another class</p>
</td></tr>
<tr><td><code id="fm_as_sfc_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="fm_as_sfc_+3A_multi">multi</code></td>
<td>
<p>logical; if <code>TRUE</code>, attempt to a <code>sfc_MULTIPOLYGON</code>, otherwise
a set of <code>sfc_POLYGON</code>. Default <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>fm_as_sfc</code>: An <code>sfc_MULTIPOLYGON</code> or <code>sfc_POLYGON</code> object
</p>
</li></ul>


<ul>
<li> <p><code>fm_as_sfc</code>: An <code>sfc_MULTIPOLYGON</code> or <code>sfc_POLYGON</code> object
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_as_sfc(inla.mesh)</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
</li>
<li> <p><code>fm_as_sfc(fm_mesh_2d)</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
</li>
<li> <p><code>fm_as_sfc(inla.mesh.segment)</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
</li>
<li> <p><code>fm_as_sfc(fm_segm)</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_sfc(fmexample$mesh)
fm_as_sfc(fmexample$mesh, multi = TRUE)

</code></pre>

<hr>
<h2 id='fm_as_tensor'>Convert objects to <code>fm_tensor</code></h2><span id='topic+fm_as_tensor'></span><span id='topic+fm_as_tensor_list'></span><span id='topic+fm_as_tensor.fm_tensor'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_tensor</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_tensor(x, ...)

fm_as_tensor_list(x, ...)

## S3 method for class 'fm_tensor'
fm_as_tensor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_as_tensor_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_tensor_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_tensor</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_tensor()</code>: Convert an object to <code>fm_tensor</code>.
</p>
</li>
<li> <p><code>fm_as_tensor_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_tensor_list(list(fm_tensor(list())))

</code></pre>

<hr>
<h2 id='fm_bary'>Compute barycentric coordinates</h2><span id='topic+fm_bary'></span><span id='topic+fm_bary.fm_mesh_1d'></span><span id='topic+fm_bary.fm_mesh_2d'></span><span id='topic+fm_bary.inla.mesh'></span><span id='topic+fm_bary.inla.mesh.1d'></span>

<h3>Description</h3>

<p>Identify knot intervals or triangles and compute barycentric coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_bary(mesh, loc, ...)

## S3 method for class 'fm_mesh_1d'
fm_bary(mesh, loc, method = c("linear", "nearest"), restricted = FALSE, ...)

## S3 method for class 'fm_mesh_2d'
fm_bary(mesh, loc, crs = NULL, ...)

## S3 method for class 'inla.mesh'
fm_bary(mesh, ...)

## S3 method for class 'inla.mesh.1d'
fm_bary(mesh, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_bary_+3A_mesh">mesh</code></td>
<td>
<p><code>fm_mesh_1d</code> or <code>fm_mesh_2d</code> object</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_loc">loc</code></td>
<td>
<p>Points for which to identify the containing triangle, and
corresponding barycentric coordinates. May be a vector (for 1d) or
raw matrix coordinates, <code>sf</code>, or <code>sp</code> point information (for 2d).</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_...">...</code></td>
<td>
<p>Arguments forwarded to sub-methods.</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_method">method</code></td>
<td>
<p>character; method for defining the barycentric coordinates,
&quot;linear&quot; (default) or &quot;nearest&quot;</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_restricted">restricted</code></td>
<td>
<p>logical, used for <code>method="linear"</code>.
If <code>FALSE</code> (default), points outside the mesh interval will be given
barycentric weights less than 0 and greater than 1, according to linear
extrapolation. If <code>TRUE</code>, the barycentric weights are clamped to the (0, 1)
interval.</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_crs">crs</code></td>
<td>
<p>Optional crs information for <code>loc</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>t</code> (vector of triangle indices or matrix of
interval knot indices), and <code>bary</code>, a matrix of barycentric coordinates.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_bary(fm_mesh_1d)</code>: Return a list with elements
<code>t</code> (start and endpoint knot indices) and <code>bary</code> (barycentric coordinates), both
2-column matrices.
</p>
<p>For <code>method = "nearest"</code>, <code>t[,1]</code> contains the index of the nearest mesh knot,
and each row of <code>bary</code> contains <code>c(1, 0)</code>.
</p>
</li>
<li> <p><code>fm_bary(fm_mesh_2d)</code>: A list with elements <code>t</code> (vector of triangle indices) and <code>bary</code>
(3-column matrix of barycentric coordinates). Points that were not found
give <code>NA</code> entries in <code>t</code> and <code>bary</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_bary(fmexample$mesh, fmexample$loc_sf))
str(fm_bary(fm_mesh_1d(1:4), seq(0, 5, by = 0.5)))
</code></pre>

<hr>
<h2 id='fm_basis'>Compute mapping matrix between mesh function space and points</h2><span id='topic+fm_basis'></span><span id='topic+fm_basis.default'></span><span id='topic+fm_basis.fm_mesh_1d'></span><span id='topic+fm_basis.fm_mesh_2d'></span><span id='topic+fm_basis.inla.mesh.1d'></span><span id='topic+fm_basis.inla.mesh'></span><span id='topic+fm_basis.fm_evaluator'></span>

<h3>Description</h3>

<p>Computes the basis mapping matrix between a function space on a mesh, and locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_basis(x, ...)

## Default S3 method:
fm_basis(x, loc, ...)

## S3 method for class 'fm_mesh_1d'
fm_basis(x, loc, weights = NULL, derivatives = NULL, ...)

## S3 method for class 'fm_mesh_2d'
fm_basis(x, loc, weights = NULL, derivatives = NULL, ...)

## S3 method for class 'inla.mesh.1d'
fm_basis(x, loc, ...)

## S3 method for class 'inla.mesh'
fm_basis(x, loc, ...)

## S3 method for class 'fm_evaluator'
fm_basis(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_basis_+3A_x">x</code></td>
<td>
<p>An object supported by the <code><a href="#topic+fm_evaluator">fm_evaluator()</a></code> class</p>
</td></tr>
<tr><td><code id="fm_basis_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
<tr><td><code id="fm_basis_+3A_loc">loc</code></td>
<td>
<p>A set of points of a class supported by <code>fm_evaluator(x, loc = loc)</code></p>
</td></tr>
<tr><td><code id="fm_basis_+3A_weights">weights</code></td>
<td>
<p>Optional weight matrix to apply (from the left)</p>
</td></tr>
<tr><td><code id="fm_basis_+3A_derivatives">derivatives</code></td>
<td>
<p>If non-NULL and logical, return a list, optionally
including derivative matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sparseMatrix</code>
</p>
<p>For <code>fm_mesh_1d</code>, a list with elements
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>The projection matrix, <code style="white-space: pre;">&#8288;u(loc_i)=sum_j A_ij w_i&#8288;</code></p>
</td></tr>
<tr><td><code>d1A</code>, <code>d2A</code></td>
<td>
<p>Derivative weight matrices,
<code style="white-space: pre;">&#8288;du/dx(loc_i)=sum_j dx_ij w_i&#8288;</code>, etc.</p>
</td></tr>
</table>
<p>For <code>fm_mesh_2d</code>, a list with elements
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>The projection matrix, <code style="white-space: pre;">&#8288;u(loc_i)=sum_j A_ij w_i&#8288;</code></p>
</td></tr>
<tr><td><code>dx</code>, <code>dy</code>, <code>dz</code></td>
<td>
<p>Derivative weight matrices, <code style="white-space: pre;">&#8288;du/dx(loc_i)=sum_j dx_ij w_i&#8288;</code>, etc.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fm_raw_basis">fm_raw_basis()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute basis mapping matrix
str(fm_basis(fmexample$mesh, fmexample$loc))
</code></pre>

<hr>
<h2 id='fm_bbox'>Bounding box class</h2><span id='topic+fm_bbox'></span><span id='topic+fm_bbox.list'></span><span id='topic+fm_bbox.NULL'></span><span id='topic+fm_bbox.matrix'></span><span id='topic+fm_bbox.fm_bbox'></span><span id='topic+fm_bbox.fm_mesh_2d'></span><span id='topic+fm_bbox.fm_segm'></span><span id='topic+fm_bbox.fm_lattice_2d'></span><span id='topic+fm_bbox.sf'></span><span id='topic+fm_bbox.sfg'></span><span id='topic+fm_bbox.sfc'></span><span id='topic+fm_bbox.bbox'></span><span id='topic+fm_bbox.inla.mesh'></span><span id='topic+fm_bbox.inla.mesh.segment'></span><span id='topic+fm_as_bbox'></span><span id='topic++5B.fm_bbox'></span><span id='topic+c.fm_bbox'></span>

<h3>Description</h3>

<p>Simple class for handling bounding box information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_bbox(...)

## S3 method for class 'list'
fm_bbox(x, ...)

## S3 method for class 'NULL'
fm_bbox(...)

## S3 method for class 'matrix'
fm_bbox(x, ...)

## S3 method for class 'fm_bbox'
fm_bbox(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_bbox(x, ...)

## S3 method for class 'fm_segm'
fm_bbox(x, ...)

## S3 method for class 'fm_lattice_2d'
fm_bbox(x, ...)

## S3 method for class 'sf'
fm_bbox(x, ...)

## S3 method for class 'sfg'
fm_bbox(x, ...)

## S3 method for class 'sfc'
fm_bbox(x, ...)

## S3 method for class 'bbox'
fm_bbox(x, ...)

## S3 method for class 'inla.mesh'
fm_bbox(x, ...)

## S3 method for class 'inla.mesh.segment'
fm_bbox(x, ...)

fm_as_bbox(x, ...)

## S3 method for class 'fm_bbox'
x[i]

## S3 method for class 'fm_bbox'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_bbox_+3A_...">...</code></td>
<td>
<p>Passed on to sub-methods</p>
</td></tr>
<tr><td><code id="fm_bbox_+3A_x">x</code></td>
<td>
<p><code>fm_bbox</code> object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="fm_bbox_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fm_bbox_list</code> object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_bbox(list)</code>: Construct a bounding box from
precomputed interval information, stored as a list of 2-vector ranges,
<code>list(xlim, ylim, ...)</code>.
</p>
</li></ul>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>[</code>: Extract sub-list
</p>
</li>
<li> <p><code>c(fm_bbox)</code>: The <code>...</code> arguments should be <code>fm_bbox</code>
objects, or coercible with <code>fm_as_bbox(list(...))</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fm_bbox(matrix(1:6, 3, 2))
m &lt;- c(A = fm_bbox(cbind(1, 2), B = fm_bbox(cbind(3, 4))))
str(m)
str(m[2])
</code></pre>

<hr>
<h2 id='fm_block'>Blockwise aggregation matrices</h2><span id='topic+fm_block'></span><span id='topic+fm_block_eval'></span><span id='topic+fm_block_logsumexp_eval'></span><span id='topic+fm_block_weights'></span><span id='topic+fm_block_log_weights'></span><span id='topic+fm_block_log_shift'></span><span id='topic+fm_block_prep'></span>

<h3>Description</h3>

<p>Creates an aggregation matrix for blockwise aggregation, with optional
weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_block(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL
)

fm_block_eval(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL,
  values = NULL
)

fm_block_logsumexp_eval(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL,
  values = NULL,
  log = TRUE
)

fm_block_weights(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL
)

fm_block_log_weights(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL
)

fm_block_log_shift(block = NULL, log_weights = NULL, n_block = NULL)

fm_block_prep(
  block = NULL,
  log_weights = NULL,
  weights = NULL,
  n_block = NULL,
  values = NULL,
  n_values = NULL,
  force_log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_block_+3A_block">block</code></td>
<td>
<p>integer vector; block information. If <code>NULL</code>,
<code>rep(1L, block_len)</code> is used, where <code>block_len</code> is determined by
<code style="white-space: pre;">&#8288;length(log_weights)))&#8288;</code> or <code style="white-space: pre;">&#8288;length(weights)))&#8288;</code>.
A single scalar is also repeated
to a vector of corresponding length to the weights.</p>
</td></tr>
<tr><td><code id="fm_block_+3A_weights">weights</code></td>
<td>
<p>Optional weight vector</p>
</td></tr>
<tr><td><code id="fm_block_+3A_log_weights">log_weights</code></td>
<td>
<p>Optional <code>log(weights)</code> vector. Overrides <code>weights</code> when
non-NULL.</p>
</td></tr>
<tr><td><code id="fm_block_+3A_rescale">rescale</code></td>
<td>
<p>logical; If <code>TRUE</code>, normalise the weights by <code>sum(weights)</code>
or <code>sum(exp(log_weights))</code> within each block.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fm_block_+3A_n_block">n_block</code></td>
<td>
<p>integer; The number of conceptual blocks. Only needs to be
specified if it's larger than <code>max(block)</code>, or to keep the output of
consistent size for different inputs.</p>
</td></tr>
<tr><td><code id="fm_block_+3A_values">values</code></td>
<td>
<p>Vector to be blockwise aggregated</p>
</td></tr>
<tr><td><code id="fm_block_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code> (default), return log-sum-exp. If <code>FALSE</code>,
return sum-exp.</p>
</td></tr>
<tr><td><code id="fm_block_+3A_n_values">n_values</code></td>
<td>
<p>When supplied, used instead of <code>length(values)</code> to determine
the value vector input length.</p>
</td></tr>
<tr><td><code id="fm_block_+3A_force_log">force_log</code></td>
<td>
<p>When <code>FALSE</code> (default),
passes either <code>weights</code> and <code>log_weights</code> on, if provided, with <code>log_weights</code>
taking precedence. If <code>TRUE</code>, forces the computation of <code>log_weights</code>,
whether given in the input or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (sparse) matrix
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_block()</code>: A (sparse) matrix of size <code>n_block</code> times <code>length(block)</code>.
</p>
</li>
<li> <p><code>fm_block_eval()</code>: Evaluate aggregation. More efficient alternative to to
<code>as.vector(fm_block(...) %*% values)</code>.
</p>
</li>
<li> <p><code>fm_block_logsumexp_eval()</code>: Evaluate log-sum-exp aggregation.
More efficient and numerically stable alternative to to
<code>log(as.vector(fm_block(...) %*% exp(values)))</code>.
</p>
</li>
<li> <p><code>fm_block_weights()</code>: Computes (optionally) blockwise renormalised weights
</p>
</li>
<li> <p><code>fm_block_log_weights()</code>: Computes (optionally) blockwise renormalised log-weights
</p>
</li>
<li> <p><code>fm_block_log_shift()</code>: Computes shifts for stable blocked log-sum-exp.
To compute <code class="reqn">\log(\sum_{i; \textrm{block}_i=k} \exp(v_i) w_i)</code> for
each block <code>k</code>, first compute combined values and weights, and a shift:
</p>
<div class="sourceCode"><pre>w_values &lt;- values + fm_block_log_weights(block, log_weights = log_weights)
shift &lt;- fm_block_log_shift(block, log_weights = w_values)
</pre></div>
<p>Then aggregate the values within each block:
</p>
<div class="sourceCode"><pre>agg &lt;- aggregate(exp(w_values - shift[block]),
                 by = list(block = block),
                 \(x) log(sum(x)))
agg$x &lt;- agg$x + shift[agg$block]
</pre></div>
<p>The implementation uses a faster method:
</p>
<div class="sourceCode"><pre>as.vector(
  Matrix::sparseMatrix(
    i = block,
    j = rep(1L, length(block)),
    x = exp(w_values - shift[block]),
    dims = c(n_block, 1))
) + shift
</pre></div>
</li>
<li> <p><code>fm_block_prep()</code>: Helper function for preparing <code>block</code>, <code>weights</code>, and
<code>log_weights</code>, <code>n_block</code> inputs.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>block &lt;- rep(1:2, 3:2)
fm_block(block)
fm_block(block, rescale = TRUE)
fm_block(block, log_weights = -2:2, rescale = TRUE)
fm_block_eval(
  block,
  weights = 1:5,
  rescale = TRUE,
  values = 11:15
)
fm_block_logsumexp_eval(
  block,
  weights = 1:5,
  rescale = TRUE,
  values = log(11:15),
  log = FALSE
)
</code></pre>

<hr>
<h2 id='fm_centroids'>Extract triangle centroids from an <code>fm_mesh_2d</code></h2><span id='topic+fm_centroids'></span>

<h3>Description</h3>

<p>Computes the centroids of the triangles of an <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_centroids(x, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_centroids_+3A_x">x</code></td>
<td>
<p>An <code>fm_mesh_2d</code> or <code>inla.mesh</code> object.</p>
</td></tr>
<tr><td><code id="fm_centroids_+3A_format">format</code></td>
<td>
<p>character; <code>"sf"</code>, <code>"df"</code>, <code>"sp"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code>, <code>data.frame</code>, or <code>SpatialPointsDataFrame</code> object, with the vertex
coordinates, and a <code>.triangle</code> column with the triangle indices.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_vertices">fm_vertices()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE)) {
  vrt &lt;- fm_centroids(fmexample$mesh, format = "sf")
  ggplot() +
    geom_sf(data = fm_as_sfc(fmexample$mesh)) +
    geom_sf(data = vrt, color = "red")
}

</code></pre>

<hr>
<h2 id='fm_contains'>Check which mesh triangles are inside a polygon</h2><span id='topic+fm_contains'></span><span id='topic+fm_contains.Spatial'></span><span id='topic+fm_contains.sf'></span><span id='topic+fm_contains.sfc'></span>

<h3>Description</h3>

<p>Wrapper for the <code><a href="sf.html#topic+geos_binary_pred">sf::st_contains()</a></code> (previously <code>sp::over()</code>) method to find triangle centroids
or vertices inside <code>sf</code> or <code>sp</code> polygon objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_contains(x, y, ...)

## S3 method for class 'Spatial'
fm_contains(x, y, ...)

## S3 method for class 'sf'
fm_contains(x, y, ...)

## S3 method for class 'sfc'
fm_contains(x, y, ..., type = c("centroid", "vertex"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_contains_+3A_x">x</code></td>
<td>
<p>geometry (typically an <code>sf</code> or <code>sp::SpatialPolygons</code> object) for the queries</p>
</td></tr>
<tr><td><code id="fm_contains_+3A_y">y</code></td>
<td>
<p>an <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> or <code>inla.mesh</code> object</p>
</td></tr>
<tr><td><code id="fm_contains_+3A_...">...</code></td>
<td>
<p>Passed on to other methods</p>
</td></tr>
<tr><td><code id="fm_contains_+3A_type">type</code></td>
<td>
<p>the query type; either <code>'centroid'</code> (default, for triangle centroids),
or <code>'vertex'</code> (for mesh vertices)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of vectors of triangle indices (when <code>type</code> is <code>'centroid'</code>) or
vertex indices (when <code>type</code> is <code>'vertex'</code>). The list has one entry per row of the <code>sf</code> object.
Use <code>unlist(fm_contains(...))</code> if the combined union is needed.
</p>


<h3>Author(s)</h3>

<p>Haakon Bakka, <a href="mailto:bakka@r-inla.org">bakka@r-inla.org</a>, and Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (TRUE &amp;&amp;
  fm_safe_sp()) {
  # Create a polygon and a mesh
  obj &lt;- sp::SpatialPolygons(
    list(sp::Polygons(
      list(sp::Polygon(rbind(
        c(0, 0),
        c(50, 0),
        c(50, 50),
        c(0, 50)
      ))),
      ID = 1
    )),
    proj4string = fm_CRS("longlat_globe")
  )
  mesh &lt;- fm_rcdt_2d_inla(globe = 2, crs = fm_crs("sphere"))

  ## 3 vertices found in the polygon
  fm_contains(obj, mesh, type = "vertex")

  ## 3 triangles found in the polygon
  fm_contains(obj, mesh)

  ## Multiple transformations can lead to slightly different results due to edge cases
  ## 4 triangles found in the polygon
  fm_contains(
    obj,
    fm_transform(mesh, crs = fm_crs("mollweide_norm"))
  )
}

</code></pre>

<hr>
<h2 id='fm_cprod'>(Blockwise) cross product of integration points</h2><span id='topic+fm_cprod'></span>

<h3>Description</h3>

<p>Calculates the groupwise cross product of integration points in different
dimensions and multiplies their weights accordingly.
If the object defining points in a particular dimension has no
weights attached to it all weights are assumed to be 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_cprod(..., na.rm = NULL, .blockwise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_cprod_+3A_...">...</code></td>
<td>
<p><code>data.frame</code>, <code>sf</code>, or <code>SpatialPointsDataFrame</code> objects, each one
usually obtained by a call to an <code><a href="#topic+fm_int">fm_int()</a></code> method.</p>
</td></tr>
<tr><td><code id="fm_cprod_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, the rows with weight <code>NA</code> from the
non-overlapping full_join will be removed; if <code>FALSE</code>, set the undefined weights to <code>NA</code>.
If <code>NULL</code> (default), act as <code>TRUE</code>, but warn if any elements needed removing.</p>
</td></tr>
<tr><td><code id="fm_cprod_+3A_.blockwise">.blockwise</code></td>
<td>
<p>logical; if <code>FALSE</code>, computes full tensor product integration.
If <code>TRUE</code>, computes within-block tensor product integration (used internally
by <code><a href="#topic+fm_int">fm_int()</a></code>).
Default <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, <code>sf</code>, or <code>SpatialPointsDataFrame</code> of multidimensional
integration points and their weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fm_int needs INLA
if (TRUE &amp;&amp;
  require("ggplot2")) {
  # Create integration points in dimension 'myDim' and 'myDiscreteDim'
  ips1 &lt;- fm_int(fm_mesh_1d(1:20),
    rbind(c(0, 3), c(3, 8)),
    name = "myDim"
  )
  ips2 &lt;- fm_int(domain = c(1, 2, 4), name = "myDiscreteDim")

  # Calculate the cross product
  ips &lt;- fm_cprod(ips1, ips2)

  # Plot the integration points
  ggplot(ips) +
    geom_point(aes(myDim, myDiscreteDim, size = weight)) +
    scale_size_area()
}


</code></pre>

<hr>
<h2 id='fm_crs'>Obtain coordinate reference system object</h2><span id='topic+fm_crs'></span><span id='topic+fm_crs_oblique'></span><span id='topic+st_crs.fm_crs'></span><span id='topic++24.fm_crs'></span><span id='topic+fm_crs.default'></span><span id='topic+fm_crs.crs'></span><span id='topic+fm_crs.fm_crs'></span><span id='topic+fm_crs.fm_CRS'></span><span id='topic+fm_crs.character'></span><span id='topic+fm_crs.Spatial'></span><span id='topic+fm_crs.SpatVector'></span><span id='topic+fm_crs.SpatRaster'></span><span id='topic+fm_crs.sf'></span><span id='topic+fm_crs.sfc'></span><span id='topic+fm_crs.sfg'></span><span id='topic+fm_crs.fm_mesh_2d'></span><span id='topic+fm_crs.fm_lattice_2d'></span><span id='topic+fm_crs.fm_segm'></span><span id='topic+fm_crs.fm_list'></span><span id='topic+fm_crs.matrix'></span><span id='topic+fm_CRS.fm_list'></span><span id='topic+fm_wkt_predef'></span><span id='topic+fm_crs.inla.CRS'></span><span id='topic+fm_crs.inla.mesh'></span><span id='topic+fm_crs.inla.mesh.lattice'></span><span id='topic+fm_crs.inla.mesh.segment'></span>

<h3>Description</h3>

<p>Obtain an <code>sf::crs</code> or <code>fm_crs</code> object from a spatial object, or
convert crs information to construct a new <code>sf::crs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_crs(x, oblique = NULL, ..., crsonly = deprecated())

fm_crs_oblique(x)

## S3 method for class 'fm_crs'
st_crs(x, ...)

## S3 method for class 'fm_crs'
x$name

## Default S3 method:
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'crs'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_crs'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_CRS'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'character'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'Spatial'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'SpatVector'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'SpatRaster'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'sf'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'sfc'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'sfg'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_mesh_2d'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_lattice_2d'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_segm'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_list'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'matrix'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_list'
fm_CRS(x, oblique = NULL, ...)

fm_wkt_predef()

## S3 method for class 'inla.CRS'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'inla.mesh'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'inla.mesh.lattice'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'inla.mesh.segment'
fm_crs(x, oblique = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_crs_+3A_x">x</code></td>
<td>
<p>Object to convert to <code>crs</code> or  to extract <code>crs</code> information from.
If <code>character</code>, a string suitable for <code>sf::st_crs(x)</code>, or the name of a
predefined <code>wkt</code> string from &ldquo;names(fm_wkt_predef())'.</p>
</td></tr>
<tr><td><code id="fm_crs_+3A_oblique">oblique</code></td>
<td>
<p>Numeric vector of length at most 4 of rotation angles (in degrees)
for an oblique projection, all values defaulting to zero. The values
indicate (longitude, latitude, orientation, orbit), as explained in the
Details section below. When
<code>oblique</code> is non-NULL, used to override the obliqueness parameters of a
<code>fm_crs</code> object. When <code>NA</code>, remove obliqueness from the object, resulting
in a return class of <code>sf::st_crs()</code>. When <code>NULL</code>, pass though any oblique
information in the object, returning an <code>fm_crs()</code> object if needed.</p>
</td></tr>
<tr><td><code id="fm_crs_+3A_...">...</code></td>
<td>
<p>Additional parameters. Not currently in use.</p>
</td></tr>
<tr><td><code id="fm_crs_+3A_crsonly">crsonly</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> logical;
if TRUE, remove <code>oblique</code> information from <code>fm_crs</code>
objects and return a plain <code>crs</code> object instead. For <code>crsonly = TRUE</code>, use
<code>oblique = NA</code> instead. For <code>crsonly = FALSE</code>, use default, NULL, or non-NA
<code>oblique</code>.</p>
</td></tr>
<tr><td><code id="fm_crs_+3A_name">name</code></td>
<td>
<p>element name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two
elements of the <code>oblique</code> vector are the (longitude, latitude)
coordinates for the oblique centre point. The third value (orientation) is a
counter-clockwise rotation angle for an observer looking at the centre point
from outside the sphere. The fourth value is the quasi-longitude (orbit
angle) for a rotation along the oblique observers equator.
</p>
<p>Simple oblique: <code>oblique=c(0, 45)</code>
</p>
<p>Polar: <code>oblique=c(0, 90)</code>
</p>
<p>Quasi-transversal: <code>oblique=c(0, 0, 90)</code>
</p>
<p>Satellite orbit viewpoint: <code>oblique=c(lon0-time*v1, 0, orbitangle, orbit0+time*v2)</code>, where <code>lon0</code> is the longitude at which a satellite
orbit crosses the equator at <code>time=0</code>, when the satellite is at an
angle <code>orbit0</code> further along in its orbit.  The orbital angle relative
to the equatorial plane is <code>orbitangle</code>, and <code>v1</code> and <code>v2</code>
are the angular velocities of the planet and the satellite, respectively.
Note that &quot;forward&quot; from the satellite's point of view is &quot;to the right&quot; in
the projection.
</p>
<p>When <code>oblique[2]</code> or <code>oblique[3]</code> are non-zero, the resulting
projection is only correct for perfect spheres.
</p>


<h3>Value</h3>

<p>Either an <code>sf::crs</code> object or an <code>fm_crs</code> object,
depending on if the coordinate reference system described by the parameters
can be expressed with a pure <code>crs</code> object or not.
</p>
<p>A <code>crs</code> object (<code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>) or a <code>fm_crs</code> object.
An S3 <code>fm_crs</code> object is a list with elements <code>crs</code> and <code>oblique</code>.
</p>
<p><code>fm_wkt_predef</code> returns a WKT2 string defining a projection
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_crs(fm_list)</code>: returns a list of 'crs' objects, one for each list element
</p>
</li></ul>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>st_crs(fm_crs)</code>: <code>st_crs(x, ...)</code> is equivalent to
<code style="white-space: pre;">&#8288;fm_crs(x, ... oblique = NA)&#8288;</code>
when <code>x</code> is a <code>fm_crs</code> object.
</p>
</li>
<li> <p><code>$</code>: For a <code>fm_crs</code> object <code>x</code>, <code>x$name</code> calls the accessor method for the
<code>crs</code> object inside it. If <code>name</code> is &quot;crs&quot;, the internal crs object itself is returned.
If <code>name</code> is &quot;oblique&quot;, the internal oblique angle parameter vector is returned.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_crs_oblique()</code>: Return <code>NA</code> for object with no oblique information,
and otherwise a length 4 numeric vector.
</p>
</li>
<li> <p><code>fm_CRS(fm_list)</code>: returns a list of 'CRS' objects, one for each list element
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>, <code><a href="#topic+fm_crs_wkt">fm_crs_wkt</a></code>
</p>
<p>fm_crs_is_null
</p>
<p><code><a href="#topic+fm_crs+3C-">fm_crs&lt;-()</a></code>, <code><a href="#topic+fm_crs_oblique+3C-">fm_crs_oblique&lt;-()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crs1 &lt;- fm_crs("longlat_globe")
crs2 &lt;- fm_crs("lambert_globe")
crs3 &lt;- fm_crs("mollweide_norm")
crs4 &lt;- fm_crs("hammer_globe")
crs5 &lt;- fm_crs("sphere")
crs6 &lt;- fm_crs("globe")
names(fm_wkt_predef())
</code></pre>

<hr>
<h2 id='fm_CRS'>Create a coordinate reference system object</h2><span id='topic+fm_CRS'></span><span id='topic+is.na.fm_CRS'></span><span id='topic+fm_CRS.crs'></span><span id='topic+fm_CRS.fm_crs'></span><span id='topic+fm_CRS.Spatial'></span><span id='topic+fm_CRS.fm_CRS'></span><span id='topic+fm_CRS.sf'></span><span id='topic+fm_CRS.sfc'></span><span id='topic+fm_CRS.sfg'></span><span id='topic+fm_CRS.fm_mesh_2d'></span><span id='topic+fm_CRS.fm_lattice'></span><span id='topic+fm_CRS.fm_segm'></span><span id='topic+fm_CRS.matrix'></span><span id='topic+fm_CRS.CRS'></span><span id='topic+fm_CRS.default'></span><span id='topic+is.na.inla.CRS'></span><span id='topic+fm_CRS.inla.CRS'></span><span id='topic+fm_CRS.inla.mesh'></span><span id='topic+fm_CRS.inla.mesh.lattice'></span><span id='topic+fm_CRS.inla.mesh.segment'></span>

<h3>Description</h3>

<p>Creates either a CRS object or an inla.CRS object, describing a coordinate
reference system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_CRS'
is.na(x)

## S3 method for class 'crs'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_crs'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'Spatial'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_CRS'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'sf'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'sfc'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'sfg'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_mesh_2d'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_lattice'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_segm'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'matrix'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'CRS'
fm_CRS(x, oblique = NULL, ...)

## Default S3 method:
fm_CRS(
  x,
  oblique = NULL,
  projargs = NULL,
  doCheckCRSArgs = NULL,
  args = NULL,
  SRS_string = NULL,
  ...
)

## S3 method for class 'inla.CRS'
is.na(x)

## S3 method for class 'inla.CRS'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'inla.mesh'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'inla.mesh.lattice'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'inla.mesh.segment'
fm_CRS(x, oblique = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_CRS_+3A_x">x</code></td>
<td>
<p>Object to convert to CRS or to extract CRS information from.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_oblique">oblique</code></td>
<td>
<p>Vector of length at most 4 of rotation angles (in degrees)
for an oblique projection, all values defaulting to zero. The values
indicate (longitude, latitude, orientation, orbit), as explained in the
Details section for <code><a href="#topic+fm_crs">fm_crs()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_...">...</code></td>
<td>
<p>Additional parameters, passed on to sub-methods.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_projargs">projargs</code></td>
<td>
<p>Either 1) a projection argument string suitable as input to
<code>sp::CRS</code>, or 2) an existing <code>CRS</code> object, or 3) a shortcut
reference string to a predefined projection; run
<code>names(fm_wkt_predef())</code> for valid predefined projections. (projargs is a
compatibility parameter that can be used for the default <code>fm_CRS()</code> method)</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_docheckcrsargs">doCheckCRSArgs</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_args">args</code></td>
<td>
<p>An optional list of name/value pairs to add to and/or override
the PROJ4 arguments in <code>projargs</code>.  <code>name=value</code> is converted to
<code>"+name=value"</code>, and <code>name=NA</code> is converted to <code>"+name"</code>.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_srs_string">SRS_string</code></td>
<td>
<p>a WKT2 string defining the coordinate system;
see <code>sp::CRS</code>. This takes precedence over <code>projargs</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two
elements of the <code>oblique</code> vector are the (longitude, latitude)
coordinates for the oblique centre point. The third value (orientation) is a
counterclockwise rotation angle for an observer looking at the centre point
from outside the sphere. The fourth value is the quasi-longitude (orbit
angle) for a rotation along the oblique observers equator.
</p>
<p>Simple oblique: <code>oblique=c(0, 45)</code>
</p>
<p>Polar: <code>oblique=c(0, 90)</code>
</p>
<p>Quasi-transversal: <code>oblique=c(0, 0, 90)</code>
</p>
<p>Satellite orbit viewpoint: <code>oblique=c(lon0-time*v1, 0, orbitangle, orbit0+time*v2)</code>, where <code>lon0</code> is the longitude at which a satellite
orbit crosses the equator at <code>time=0</code>, when the satellite is at an
angle <code>orbit0</code> further along in its orbit.  The orbital angle relative
to the equatorial plane is <code>orbitangle</code>, and <code>v1</code> and <code>v2</code>
are the angular velocities of the planet and the satellite, respectively.
Note that &quot;forward&quot; from the satellite's point of view is &quot;to the right&quot; in
the projection.
</p>
<p>When <code>oblique[2]</code> or <code>oblique[3]</code> are non-zero, the resulting
projection is only correct for perfect spheres.
</p>


<h3>Value</h3>

<p>Either an <code>sp::CRS</code> object or an <code>inla.CRS</code> object,
depending on if the coordinate reference system described by the parameters
can be expressed with a pure <code>sp::CRS</code> object or not.
</p>
<p>An S3 <code>inla.CRS</code> object is a list, usually (but not necessarily)
containing at least one element: </p>
<table>
<tr><td><code>crs</code></td>
<td>
<p>The basic <code>sp::CRS</code>
object</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>is.na(fm_CRS)</code>: Check if a <code>fm_CRS</code> has <code>NA</code> crs information and <code>NA</code>
obliqueness
</p>
</li>
<li> <p><code>is.na(inla.CRS)</code>: Check if a <code>inla.CRS</code> has <code>NA</code> crs information and <code>NA</code>
obliqueness
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>, <code><a href="sp.html#topic+CRS-class">sp::CRS()</a></code>, <code><a href="#topic+fm_crs_wkt">fm_crs_wkt</a></code>,
<code><a href="#topic+fm_sp_get_crs">fm_sp_get_crs()</a></code>, <code><a href="#topic+fm_crs_is_identical">fm_crs_is_identical()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crs1 &lt;- fm_CRS("longlat_globe")
crs2 &lt;- fm_CRS("lambert_globe")
crs3 &lt;- fm_CRS("mollweide_norm")
crs4 &lt;- fm_CRS("hammer_globe")
crs5 &lt;- fm_CRS("sphere")
crs6 &lt;- fm_CRS("globe")
</code></pre>

<hr>
<h2 id='fm_CRS_as_list'>Show expanded CRS arguments</h2><span id='topic+fm_CRS_as_list'></span><span id='topic+fm_list_as_CRS'></span><span id='topic+fm_CRSargs'></span><span id='topic+fm_CRSargs_as_list'></span><span id='topic+fm_list_as_CRSargs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Wrappers for <code>sp::CRS</code> and <code>inla.CRS</code> objects to handle the
coordinate reference system argument string.
These methods should no longer be used with PROJ6/rgdal3;
see <code><a href="#topic+fm_wkt">fm_wkt()</a></code> and <code><a href="#topic+fm_proj4string">fm_proj4string()</a></code> for a new approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_CRS_as_list(x, ...)

fm_list_as_CRS(x, ...)

fm_CRSargs(x, ...)

fm_list_as_CRSargs(x, ...)

fm_CRSargs_as_list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_CRS_as_list_+3A_x">x</code></td>
<td>
<p>An <code>sp::CRS</code> or <code>inla.CRS</code> object (for
<code>fm_CRSargs</code> and <code>fm_CRS_as_list</code>), a character string (for
<code>fm_CRSargs_as_list</code>), or a list (for <code>fm_list_as_CRS</code> and
<code>fm_list_as_CRSargs</code>).</p>
</td></tr>
<tr><td><code id="fm_CRS_as_list_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>fm_CRSargs</code> and <code>fm_list_as_CRSargs</code>, a character
string with PROJ.4 arguments.
</p>
<p>For <code>fm_CRS_as_list</code> and <code>fm_CRSargs_as_list</code>, a list of
name/value pairs.
</p>
<p>For <code>fm_list_as_CRS</code>, a <code>CRS</code> or <code>inla.CRS</code> object.
</p>
<p>For <code>fm_list_as_CRSargs()</code>, a CRS proj4 string for name=value pair list
</p>
<p>For <code>fm_CRSargs_as_list()</code>, a list of name=value pairs from CRS proj4 string
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_CRS">fm_CRS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
crs0 &lt;- fm_CRS("longlat_norm")
p4s &lt;- fm_proj4string(crs0)
lst &lt;- fm_CRSargs_as_list(p4s)
crs1 &lt;- fm_list_as_CRS(lst)
lst$a &lt;- 2
crs2 &lt;- fm_CRS(p4s, args = lst)
print(fm_proj4string(crs0))
print(fm_proj4string(crs1))
print(fm_proj4string(crs2))
</code></pre>

<hr>
<h2 id='fm_crs_is_identical'>Check if two CRS objects are identical</h2><span id='topic+fm_crs_is_identical'></span><span id='topic+fm_identical_CRS'></span>

<h3>Description</h3>

<p>Check if two CRS objects are identical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_crs_is_identical(crs0, crs1, crsonly = FALSE)

fm_identical_CRS(crs0, crs1, crsonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_crs_is_identical_+3A_crs0">crs0</code>, <code id="fm_crs_is_identical_+3A_crs1">crs1</code></td>
<td>
<p>Two <code>sf::crs</code>, <code>sp::CRS</code>, <code>fm_crs</code> or <code>inla.CRS</code> objects to be compared.</p>
</td></tr>
<tr><td><code id="fm_crs_is_identical_+3A_crsonly">crsonly</code></td>
<td>
<p>logical. If <code>TRUE</code> and any of <code>crs0</code> and <code>crs1</code> are <code>fm_crs</code> or <code>inla.CRS</code>
objects, extract and compare only the <code>sf::crs</code> or <code>sp::CRS</code> aspects. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, indicating if the two crs objects are identical in the
specified sense (see the <code>crsonly</code> argument)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_identical_CRS()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
by <code>fm_crs_is_identical()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>, <a href="#topic+fm_crs">fm_CRS()</a>, <code><a href="#topic+fm_crs_is_null">fm_crs_is_null()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
crs0 &lt;- crs1 &lt;- fm_crs("longlat_globe")
fm_crs_oblique(crs1) &lt;- c(0, 90)
print(c(
  fm_crs_is_identical(crs0, crs0),
  fm_crs_is_identical(crs0, crs1),
  fm_crs_is_identical(crs0, crs1, crsonly = TRUE)
))
</code></pre>

<hr>
<h2 id='fm_crs_is_null'>Check if a crs is NULL or NA</h2><span id='topic+fm_crs_is_null'></span><span id='topic+is.na.fm_crs'></span>

<h3>Description</h3>

<p>Methods of checking whether various kinds of CRS objects are <code>NULL</code> or <code>NA</code>.
Logically equivalent to either <code>is.na(fm_crs(x))</code> or
<code>is.na(fm_crs(x, oblique = NA))</code>, but with a short-cut pre-check for <code>is.null(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_crs_is_null(x, crsonly = FALSE)

## S3 method for class 'fm_crs'
is.na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_crs_is_null_+3A_x">x</code></td>
<td>
<p>An object supported by <code>fm_crs(x)</code></p>
</td></tr>
<tr><td><code id="fm_crs_is_null_+3A_crsonly">crsonly</code></td>
<td>
<p>For crs objects with extended functionality, such as
<code><a href="#topic+fm_crs">fm_crs()</a></code> objects with <code>oblique</code> information, <code>crsonly = TRUE</code> only checks
the plain CRS part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_crs_is_null()</code>: Check if an object is or has <code>NULL</code> or <code>NA</code> CRS information.
If not <code>NULL</code>, <code>is.na(fm_crs(x))</code> is returned. This allows the input to be e.g.
a proj4string or epsg number, since the default <code><a href="#topic+fm_crs">fm_crs()</a></code> method passes
its argument on to <code>sf::st_crs()</code>.
</p>
</li>
<li> <p><code>is.na(fm_crs)</code>: Check if a <code>fm_crs</code> has <code>NA</code> crs information and <code>NA</code>
obliqueness
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>, <a href="#topic+fm_crs">fm_CRS()</a>, <code><a href="#topic+fm_crs_is_identical">fm_crs_is_identical()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_crs_is_null(NULL)
fm_crs_is_null(27700)
fm_crs_is_null(fm_crs())
fm_crs_is_null(fm_crs(27700))
fm_crs_is_null(fm_crs(oblique = c(1, 2, 3, 4)))
fm_crs_is_null(fm_crs(oblique = c(1, 2, 3, 4)), crsonly = TRUE)
fm_crs_is_null(fm_crs(27700, oblique = c(1, 2, 3, 4)))
fm_crs_is_null(fm_crs(27700, oblique = c(1, 2, 3, 4)), crsonly = TRUE)

</code></pre>

<hr>
<h2 id='fm_crs_wkt'>Handling CRS/WKT</h2><span id='topic+fm_crs_wkt'></span><span id='topic+fm_wkt_is_geocent'></span><span id='topic+fm_crs_is_geocent'></span><span id='topic+fm_wkt_get_ellipsoid_radius'></span><span id='topic+fm_crs_get_ellipsoid_radius'></span><span id='topic+fm_ellipsoid_radius'></span><span id='topic+fm_ellipsoid_radius.default'></span><span id='topic+fm_ellipsoid_radius.character'></span><span id='topic+fm_wkt_set_ellipsoid_radius'></span><span id='topic+fm_ellipsoid_radius+3C-'></span><span id='topic+fm_ellipsoid_radius+3C-.character'></span><span id='topic+fm_ellipsoid_radius+3C-.CRS'></span><span id='topic+fm_ellipsoid_radius+3C-.fm_CRS'></span><span id='topic+fm_ellipsoid_radius+3C-.crs'></span><span id='topic+fm_ellipsoid_radius+3C-.fm_crs'></span><span id='topic+fm_crs_set_ellipsoid_radius'></span><span id='topic+fm_wkt_unit_params'></span><span id='topic+fm_wkt_get_lengthunit'></span><span id='topic+fm_wkt_set_lengthunit'></span><span id='topic+fm_crs_get_lengthunit'></span><span id='topic+fm_crs_set_lengthunit'></span><span id='topic+fm_length_unit'></span><span id='topic+fm_length_unit.default'></span><span id='topic+fm_length_unit.character'></span><span id='topic+fm_length_unit+3C-'></span><span id='topic+fm_length_unit+3C-.character'></span><span id='topic+fm_length_unit+3C-.CRS'></span><span id='topic+fm_length_unit+3C-.fm_CRS'></span><span id='topic+fm_length_unit+3C-.crs'></span><span id='topic+fm_length_unit+3C-.fm_crs'></span><span id='topic+fm_wkt'></span><span id='topic+fm_proj4string'></span><span id='topic+fm_crs_get_wkt'></span><span id='topic+fm_wkt_tree_projection_type'></span><span id='topic+fm_wkt_projection_type'></span><span id='topic+fm_crs_projection_type'></span><span id='topic+fm_crs_bounds'></span><span id='topic+fm_ellipsoid_radius+3C-.inla.CRS'></span><span id='topic+fm_length_unit+3C-.inla.CRS'></span>

<h3>Description</h3>

<p>Get and set CRS object or WKT string properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_wkt_is_geocent(wkt)

fm_crs_is_geocent(crs)

fm_wkt_get_ellipsoid_radius(wkt)

fm_crs_get_ellipsoid_radius(crs)

fm_ellipsoid_radius(x)

## Default S3 method:
fm_ellipsoid_radius(x)

## S3 method for class 'character'
fm_ellipsoid_radius(x)

fm_wkt_set_ellipsoid_radius(wkt, radius)

fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'character'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'CRS'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'fm_CRS'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'crs'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'fm_crs'
fm_ellipsoid_radius(x) &lt;- value

fm_crs_set_ellipsoid_radius(crs, radius)

fm_wkt_unit_params()

fm_wkt_get_lengthunit(wkt)

fm_wkt_set_lengthunit(wkt, unit, params = NULL)

fm_crs_get_lengthunit(crs)

fm_crs_set_lengthunit(crs, unit)

fm_length_unit(x)

## Default S3 method:
fm_length_unit(x)

## S3 method for class 'character'
fm_length_unit(x)

fm_length_unit(x) &lt;- value

## S3 replacement method for class 'character'
fm_length_unit(x) &lt;- value

## S3 replacement method for class 'CRS'
fm_length_unit(x) &lt;- value

## S3 replacement method for class 'fm_CRS'
fm_length_unit(x) &lt;- value

## S3 replacement method for class 'crs'
fm_length_unit(x) &lt;- value

## S3 replacement method for class 'fm_crs'
fm_length_unit(x) &lt;- value

fm_wkt(crs)

fm_proj4string(crs)

fm_crs_get_wkt(crs)

fm_wkt_tree_projection_type(wt)

fm_wkt_projection_type(wkt)

fm_crs_projection_type(crs)

fm_crs_bounds(crs, warn.unknown = FALSE)

## S3 replacement method for class 'inla.CRS'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'inla.CRS'
fm_length_unit(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_crs_wkt_+3A_wkt">wkt</code></td>
<td>
<p>A WKT2 character string</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_crs">crs</code></td>
<td>
<p>An <code>sf::crs</code>, <code>sp::CRS</code>, <code>fm_crs</code> or <code>inla.CRS</code> object</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_x">x</code></td>
<td>
<p>crs object to extract value from or assign values in</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_radius">radius</code></td>
<td>
<p>numeric; The new radius value</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_value">value</code></td>
<td>
<p>Value to assign</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_unit">unit</code></td>
<td>
<p>character, name of a unit. Supported names are
&quot;metre&quot;, &quot;kilometre&quot;, and the aliases &quot;meter&quot;, &quot;m&quot;, International metre&quot;,
&quot;kilometer&quot;, and &quot;km&quot;, as defined by <code>fm_wkt_unit_params</code> or the
<code>params</code> argument. (For legacy PROJ4 use, only &quot;m&quot; and &quot;km&quot; are
supported)</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_params">params</code></td>
<td>
<p>Length unit definitions, in the list format produced by
<code>fm_wkt_unit_params()</code>, Default: NULL, which invokes
<code>fm_wkt_unit_params()</code></p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_wt">wt</code></td>
<td>
<p>A parsed wkt tree, see <code><a href="#topic+fm_wkt_as_wkt_tree">fm_wkt_as_wkt_tree()</a></code></p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_warn.unknown">warn.unknown</code></td>
<td>
<p>logical, default <code>FALSE</code>. Produce warning if the shape
of the projection bounds is unknown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>fm_wkt_unit_params</code>, a
list of named unit definitions
</p>
<p>For <code>fm_wkt_get_lengthunit</code>, a
list of length units used in the wkt string, excluding the ellipsoid radius
unit.
</p>
<p>For <code>fm_wkt_set_lengthunit</code>, a
WKT2 string with altered length units.
Note that the length unit for the ellipsoid radius is unchanged.
</p>
<p>For <code>fm_crs_get_lengthunit</code>, a
list of length units used in the wkt string, excluding the ellipsoid radius
unit. (For legacy PROJ4 code, the raw units from the proj4string are
returned, if present.)
</p>
<p>For <code style="white-space: pre;">&#8288;fm_length_unit&lt;-&#8288;</code>, a crs object with
altered length units.
Note that the length unit for the ellipsoid radius is unchanged.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_wkt()</code>: Returns a WKT2 string, for any input supported by <code><a href="#topic+fm_crs">fm_crs()</a></code>.
</p>
</li>
<li> <p><code>fm_proj4string()</code>: Returns a proj4 string, for any input supported by <code><a href="#topic+fm_crs">fm_crs()</a></code>.
</p>
</li>
<li> <p><code>fm_crs_get_wkt()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code><a href="#topic+fm_wkt">fm_wkt()</a></code>
instead.
</p>
</li>
<li> <p><code>fm_wkt_tree_projection_type()</code>: Returns &quot;longlat&quot;, &quot;lambert&quot;, &quot;mollweide&quot;, &quot;hammer&quot;, &quot;tmerc&quot;, or <code>NULL</code>
</p>
</li>
<li> <p><code>fm_wkt_projection_type()</code>: See <code>fm_wkt_tree_projection_type</code>
</p>
</li>
<li> <p><code>fm_crs_projection_type()</code>: See <code>fm_wkt_tree_projection_type</code>
</p>
</li>
<li> <p><code>fm_crs_bounds()</code>: Returns bounds information for a projection, as
a list with elements <code>type</code> (&quot;rectangle&quot; or &quot;ellipse&quot;), <code>xlim</code>, <code>ylim</code>, and
<code>polygon</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1 &lt;- fm_crs("globe")
fm_crs_get_lengthunit(c1)
c2 &lt;- fm_crs_set_lengthunit(c1, "m")
fm_crs_get_lengthunit(c2)

</code></pre>

<hr>
<h2 id='fm_crs+26lt+3B-'>Assignment operators for crs information objects</h2><span id='topic+fm_crs+3C-'></span><span id='topic+fm_crs_oblique+3C-'></span><span id='topic+fm_crs+3C-.NULL'></span><span id='topic+fm_crs_oblique+3C-.NULL'></span><span id='topic+fm_crs+3C-.fm_segm'></span><span id='topic+fm_crs+3C-.fm_list'></span><span id='topic+fm_crs+3C-.fm_mesh_2d'></span><span id='topic+fm_crs+3C-.fm_lattice_2d'></span><span id='topic+fm_crs+3C-.sf'></span><span id='topic+fm_crs+3C-.sfg'></span><span id='topic+fm_crs+3C-.sfc'></span><span id='topic+fm_crs+3C-.Spatial'></span><span id='topic+fm_crs_oblique+3C-.crs'></span><span id='topic+fm_crs_oblique+3C-.CRS'></span><span id='topic+fm_crs_oblique+3C-.fm_CRS'></span><span id='topic+fm_crs_oblique+3C-.fm_crs'></span><span id='topic+fm_crs_oblique+3C-.fm_segm'></span><span id='topic+fm_crs_oblique+3C-.fm_mesh_2d'></span><span id='topic+fm_crs_oblique+3C-.fm_lattice_2d'></span><span id='topic+fm_crs_oblique+3C-.inla.CRS'></span>

<h3>Description</h3>

<p>Assigns new crs information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_crs(x) &lt;- value

fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'NULL'
fm_crs(x) &lt;- value

## S3 replacement method for class 'NULL'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_segm'
fm_crs(x) &lt;- value

## S3 replacement method for class 'fm_list'
fm_crs(x) &lt;- value

## S3 replacement method for class 'fm_mesh_2d'
fm_crs(x) &lt;- value

## S3 replacement method for class 'fm_lattice_2d'
fm_crs(x) &lt;- value

## S3 replacement method for class 'sf'
fm_crs(x) &lt;- value

## S3 replacement method for class 'sfg'
fm_crs(x) &lt;- value

## S3 replacement method for class 'sfc'
fm_crs(x) &lt;- value

## S3 replacement method for class 'Spatial'
fm_crs(x) &lt;- value

## S3 replacement method for class 'crs'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'CRS'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_CRS'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_crs'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_segm'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_mesh_2d'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_lattice_2d'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'inla.CRS'
fm_crs_oblique(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_crs+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>Object to assign crs information to</p>
</td></tr>
<tr><td><code id="fm_crs+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>For <code style="white-space: pre;">&#8288;fm_crs&lt;-()&#8288;</code>, object supported by <code>fm_crs(value)</code>.
</p>
<p>For <code style="white-space: pre;">&#8288;fm_crs_oblique&lt;-()&#8288;</code>, <code>NA</code> or a numeric vector, see
the <code>oblique</code> argument for <code><a href="#topic+fm_crs">fm_crs()</a></code>. For assignment, <code>NULL</code> is treated as <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_crs(x) &lt;- value</code>: Automatically converts the input value with
<code>fm_crs(value)</code>, <code>fm_crs(value, oblique = NA)</code>,
<code>fm_CRS(value)</code>, or <code>fm_CRS(value, oblique = NA)</code>, depending on the type of <code>x</code>.
</p>
</li>
<li> <p><code>fm_crs_oblique(x) &lt;- value</code>: Assigns new <code>oblique</code> information.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- fm_segm()
fm_crs(x) &lt;- fm_crs("+proj=longlat")
fm_crs(x)$proj4string
</code></pre>

<hr>
<h2 id='fm_detect_manifold'>Detect manifold type</h2><span id='topic+fm_detect_manifold'></span><span id='topic+fm_crs_detect_manifold'></span><span id='topic+fm_detect_manifold.crs'></span><span id='topic+fm_detect_manifold.CRS'></span><span id='topic+fm_detect_manifold.numeric'></span><span id='topic+fm_detect_manifold.matrix'></span><span id='topic+fm_detect_manifold.fm_mesh_2d'></span>

<h3>Description</h3>

<p>Detect if a 2d object is on &quot;R2&quot;, &quot;S2&quot;, or &quot;M2&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_detect_manifold(x)

fm_crs_detect_manifold(x)

## S3 method for class 'crs'
fm_detect_manifold(x)

## S3 method for class 'CRS'
fm_detect_manifold(x)

## S3 method for class 'numeric'
fm_detect_manifold(x)

## S3 method for class 'matrix'
fm_detect_manifold(x)

## S3 method for class 'fm_mesh_2d'
fm_detect_manifold(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_detect_manifold_+3A_x">x</code></td>
<td>
<p>Object to investigate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the detected manifold classification
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_crs_detect_manifold()</code>: Detect if a crs is on &quot;R2&quot; or &quot;S2&quot;
(if <code>fm_crs_is_geocent(crs)</code> is <code>TRUE</code>). Returns <code>NA_character_</code> if the crs
is NULL or NA.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fm_detect_manifold(1:4)
fm_detect_manifold(rbind(c(1, 0, 0), c(0, 1, 0), c(1, 1, 0)))
fm_detect_manifold(rbind(c(1, 0, 0), c(0, 1, 0), c(0, 0, 1)))

</code></pre>

<hr>
<h2 id='fm_diameter'>Diameter bound for a geometric object</h2><span id='topic+fm_diameter'></span><span id='topic+fm_diameter.matrix'></span><span id='topic+fm_diameter.sf'></span><span id='topic+fm_diameter.sfg'></span><span id='topic+fm_diameter.sfc'></span><span id='topic+fm_diameter.fm_lattice_2d'></span><span id='topic+fm_diameter.fm_segm'></span><span id='topic+fm_diameter.fm_mesh_2d'></span><span id='topic+fm_diameter.fm_mesh_1d'></span><span id='topic+fm_diameter.inla.mesh.1d'></span><span id='topic+fm_diameter.inla.mesh.segment'></span><span id='topic+fm_diameter.inla.mesh.lattice'></span><span id='topic+fm_diameter.inla.mesh'></span>

<h3>Description</h3>

<p>Find an upper bound to the convex hull of a point set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_diameter(x, ...)

## S3 method for class 'matrix'
fm_diameter(x, manifold = NULL, ...)

## S3 method for class 'sf'
fm_diameter(x, ...)

## S3 method for class 'sfg'
fm_diameter(x, ...)

## S3 method for class 'sfc'
fm_diameter(x, ...)

## S3 method for class 'fm_lattice_2d'
fm_diameter(x, ...)

## S3 method for class 'fm_segm'
fm_diameter(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_diameter(x, ...)

## S3 method for class 'fm_mesh_1d'
fm_diameter(x, ...)

## S3 method for class 'inla.mesh.1d'
fm_diameter(x, ...)

## S3 method for class 'inla.mesh.segment'
fm_diameter(x, ...)

## S3 method for class 'inla.mesh.lattice'
fm_diameter(x, ...)

## S3 method for class 'inla.mesh'
fm_diameter(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_diameter_+3A_x">x</code></td>
<td>
<p>A point set as an <code class="reqn">n\times d</code> matrix, or an
<code>fm_mesh_2d</code>/<code style="white-space: pre;">&#8288;1d&#8288;</code>/<code>sf</code> related object.</p>
</td></tr>
<tr><td><code id="fm_diameter_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the submethods.</p>
</td></tr>
<tr><td><code id="fm_diameter_+3A_manifold">manifold</code></td>
<td>
<p>Character string specifying the manifold type. Default is to
treat the point set with Euclidean <code class="reqn">R^d</code> metrics. Use
<code>manifold="S2"</code> for great circle distances on the unit sphere (this is
set automatically for <code>fm_fmesh_2d</code> objects).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, upper bound for the diameter of the convex hull of the
point set.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm_diameter(matrix(c(0, 1, 1, 0, 0, 0, 1, 1), 4, 2))
</code></pre>

<hr>
<h2 id='fm_dof'>Function spece degrees of freedom</h2><span id='topic+fm_dof'></span><span id='topic+fm_dof.fm_mesh_1d'></span><span id='topic+fm_dof.fm_mesh_2d'></span><span id='topic+fm_dof.fm_tensor'></span>

<h3>Description</h3>

<p>Obtain the degrees of freedom of a function space, i.e.
the number of basis functions it uses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_dof(x)

## S3 method for class 'fm_mesh_1d'
fm_dof(x)

## S3 method for class 'fm_mesh_2d'
fm_dof(x)

## S3 method for class 'fm_tensor'
fm_dof(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_dof_+3A_x">x</code></td>
<td>
<p>A function space object, such as <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> or
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_dof(fmexample$mesh)

</code></pre>

<hr>
<h2 id='fm_evaluate'>Methods for projecting to/from mesh objects</h2><span id='topic+fm_evaluate'></span><span id='topic+fm_evaluate.default'></span><span id='topic+fm_evaluate.fm_evaluator'></span><span id='topic+fm_evaluator'></span><span id='topic+fm_evaluator.fm_mesh_2d'></span><span id='topic+fm_evaluator.fm_mesh_1d'></span><span id='topic+fm_evaluator.fm_tensor'></span><span id='topic+fm_evaluator_lattice'></span><span id='topic+fm_evaluator.inla.mesh'></span><span id='topic+fm_evaluator.inla.mesh.1d'></span>

<h3>Description</h3>

<p>Calculate evaluation information and/or evaluate a function
defined on a mesh or function space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_evaluate(...)

## Default S3 method:
fm_evaluate(mesh, field, ...)

## S3 method for class 'fm_evaluator'
fm_evaluate(projector, field, ...)

fm_evaluator(...)

## S3 method for class 'fm_mesh_2d'
fm_evaluator(mesh, loc = NULL, lattice = NULL, crs = NULL, ...)

## S3 method for class 'fm_mesh_1d'
fm_evaluator(mesh, loc = NULL, xlim = mesh$interval, dims = 100, ...)

## S3 method for class 'fm_tensor'
fm_evaluator(x, loc, ...)

fm_evaluator_lattice(
  mesh,
  xlim = NULL,
  ylim = NULL,
  dims = c(100, 100),
  projection = NULL,
  crs = NULL,
  ...
)

## S3 method for class 'inla.mesh'
fm_evaluator(mesh, loc = NULL, lattice = NULL, crs = NULL, ...)

## S3 method for class 'inla.mesh.1d'
fm_evaluator(mesh, loc = NULL, xlim = mesh$interval, dims = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_evaluate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code> or <code>inla.mesh.1d</code> object.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_field">field</code></td>
<td>
<p>Basis function weights, one per mesh basis function, describing
the function to be evaluated at the projection locations</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_projector">projector</code></td>
<td>
<p>An <code>fm_evaluator</code> object.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_loc">loc</code></td>
<td>
<p>Projection locations.  Can be a matrix, <code>SpatialPoints</code>,
<code>SpatialPointsDataFrame</code>, <code>sf</code>, <code>sfc</code>, or <code>sfg</code> object.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_lattice">lattice</code></td>
<td>
<p>An <code><a href="#topic+fm_lattice_2d">fm_lattice_2d()</a></code> object.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_crs">crs</code></td>
<td>
<p>An optional CRS or inla.CRS object associated with <code>loc</code>
and/or <code>lattice</code>.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_xlim">xlim</code></td>
<td>
<p>X-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_dims">dims</code></td>
<td>
<p>Lattice dimensions.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+fm_tensor">fm_tensor()</a></code> object</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_projection">projection</code></td>
<td>
<p>One of <code>c("default", "longlat", "longsinlat", "mollweide")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix of the evaluated function
</p>
<p>An <code>fm_evaluator</code> object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_evaluate(default)</code>: The default method calls
<code>proj = fm_evaluator(mesh, ...)</code>, followed by <code>fm_evaluate(proj, field)</code>.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_evaluate()</code>: Returns the field function evaluated at the locations determined by an
<code>fm_evaluator</code> object. <code>fm_evaluate(mesh, field = field, ...)</code> is a
shortcut to <code>fm_evaluate(fm_evaluator(mesh, ...), field = field)</code>.
</p>
</li>
<li> <p><code>fm_evaluator()</code>: Returns an <code>fm_evaluator</code> list object with evaluation information.
The <code>proj</code> element contains a mapping matrix <code>A</code> and a logical vector <code>ok</code>,
that indicates which locations were mappable to the input mesh.
For <code>fm_mesh_2d</code> and <code>inla.mesh</code>
input, <code>proj</code> also contains a matrix <code>bary</code> and vector <code>t</code>, with the
barycentric coordinates within the triangle each input location falls in.
</p>
</li>
<li> <p><code>fm_evaluator(fm_mesh_2d)</code>: The <code>...</code> arguments are passed on to <code>fm_evaluator_lattice()</code>
if no <code>loc</code> or <code>lattice</code> is provided.
</p>
</li>
<li> <p><code>fm_evaluator_lattice()</code>: Creates an <code><a href="#topic+fm_lattice_2d">fm_lattice_2d()</a></code> object, by default covering the input mesh.
</p>
</li>
<li> <p><code>fm_evaluator(inla.mesh)</code>: The <code>...</code> arguments are passed on to <code>fm_evaluator_lattice()</code>
if no <code>loc</code> or <code>lattice</code> is provided.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (TRUE) {
  n &lt;- 20
  loc &lt;- matrix(runif(n * 2), n, 2)
  mesh &lt;- fm_rcdt_2d_inla(loc, refine = list(max.edge = 0.05))
  proj &lt;- fm_evaluator(mesh)
  field &lt;- cos(mesh$loc[, 1] * 2 * pi * 3) * sin(mesh$loc[, 2] * 2 * pi * 7)
  image(proj$x, proj$y, fm_evaluate(proj, field))
}

# if (require("ggplot2") &amp;&amp;
#  require("ggpolypath")) {
#  ggplot() +
#    gg(data = fm_as_sfc(mesh), col = field)
# }


</code></pre>

<hr>
<h2 id='fm_evaluator_helpers'>Internal helper functions for mesh field evaluation</h2><span id='topic+fm_evaluator_helpers'></span><span id='topic+fm_evaluator_mesh_2d'></span><span id='topic+fm_evaluator_mesh_1d'></span>

<h3>Description</h3>

<p>Methods called internally by <code><a href="#topic+fm_evaluator">fm_evaluator()</a></code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_evaluator_mesh_2d(
  mesh,
  loc = NULL,
  weights = NULL,
  derivatives = NULL,
  crs = NULL,
  ...
)

fm_evaluator_mesh_1d(
  mesh,
  loc,
  weights = NULL,
  derivatives = NULL,
  method = deprecated(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_evaluator_helpers_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code> or <code>inla.mesh.1d</code> object.</p>
</td></tr>
<tr><td><code id="fm_evaluator_helpers_+3A_loc">loc</code></td>
<td>
<p>Projection locations.  Can be a matrix, <code>SpatialPoints</code>,
<code>SpatialPointsDataFrame</code>, <code>sf</code>, <code>sfc</code>, or <code>sfg</code> object.</p>
</td></tr>
<tr><td><code id="fm_evaluator_helpers_+3A_weights">weights</code></td>
<td>
<p>Optional weight vector, one weight for each location</p>
</td></tr>
<tr><td><code id="fm_evaluator_helpers_+3A_derivatives">derivatives</code></td>
<td>
<p>logical; If true, also return matrices <code>dA</code> and <code>d2A</code>
for <code>fm_mesh_1d</code> objects, and <code>dx</code>, <code>dy</code>, <code>dz</code> for <code>fm_mesh_2d</code>.</p>
</td></tr>
<tr><td><code id="fm_evaluator_helpers_+3A_crs">crs</code></td>
<td>
<p>An optional CRS or inla.CRS object associated with <code>loc</code>
and/or <code>lattice</code>.</p>
</td></tr>
<tr><td><code id="fm_evaluator_helpers_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="fm_evaluator_helpers_+3A_method">method</code></td>
<td>
<p>character; either &quot;default&quot;, &quot;nearest&quot;, &quot;linear&quot;, or
&quot;quadratic&quot;. With <code>NULL</code> or &quot;default&quot;, uses the object definition of the
function space. Otherwise overrides the object definition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of evaluator information objects, at least a matrix <code>A</code> and
logical vector <code>ok</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_evaluator_mesh_2d(fmexample$mesh, loc = fmexample$loc))

</code></pre>

<hr>
<h2 id='fm_fem'>Compute finite element matrices</h2><span id='topic+fm_fem'></span><span id='topic+fm_fem.fm_mesh_1d'></span><span id='topic+fm_fem.fm_mesh_2d'></span><span id='topic+fm_fem.inla.mesh.1d'></span><span id='topic+fm_fem.inla.mesh'></span>

<h3>Description</h3>

<p>(...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_fem(mesh, order = 2, ...)

## S3 method for class 'fm_mesh_1d'
fm_fem(mesh, order = 2, ...)

## S3 method for class 'fm_mesh_2d'
fm_fem(mesh, order = 2, aniso = NULL, ...)

## S3 method for class 'inla.mesh.1d'
fm_fem(mesh, order = 2, ...)

## S3 method for class 'inla.mesh'
fm_fem(mesh, order = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_fem_+3A_mesh">mesh</code></td>
<td>
<p><code>inla.mesh</code> object</p>
</td></tr>
<tr><td><code id="fm_fem_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="fm_fem_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
<tr><td><code id="fm_fem_+3A_aniso">aniso</code></td>
<td>
<p>If non-NULL, a <code>list(gamma, v)</code>. Calculates anisotropic structure
matrices (in addition to the regular) for <code class="reqn">\gamma</code> and <code class="reqn">v</code> for
an anisotropic operator <code class="reqn">\nabla\cdot H \nabla</code>, where
<code class="reqn">H=\gamma I + v v^\top</code>.
Currently (2023-08-05) the fields need to be given per vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_fem.fm_mesh_1d</code>: A list with elements <code>c0</code>, <code>c1</code>, <code>g1</code>, <code>g2</code>.
When <code>mesh$degree == 2</code>, also <code>g01</code>, <code>g02</code>, and <code>g12</code>.
</p>
<p><code>fm_fem.fm_mesh_2d</code>: A list with elements <code>c0</code>, <code>c1</code>, <code>g1</code>, <code>va</code>, <code>ta</code>,
and more if <code>order &gt; 1</code>. When <code>aniso</code> is non-NULL, also <code>g1aniso</code> matrices, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_fem(fmexample$mesh))

</code></pre>

<hr>
<h2 id='fm_generate_colors'>Generate text RGB color specifications.</h2><span id='topic+fm_generate_colors'></span>

<h3>Description</h3>

<p>Generates a text RGB color specification matrix based on a color palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_generate_colors(
  color,
  color.axis = NULL,
  color.n = 512,
  color.palette = cm.colors,
  color.truncate = FALSE,
  alpha = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_generate_colors_+3A_color">color</code></td>
<td>
<p><code>character</code>, <code>matrix</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_color.axis">color.axis</code></td>
<td>
<p>The min/max limit values for the color mapping.</p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_color.n">color.n</code></td>
<td>
<p>The number of colors to use in the color palette.</p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_color.palette">color.palette</code></td>
<td>
<p>A color palette function.</p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_color.truncate">color.truncate</code></td>
<td>
<p>If <code>TRUE</code>, truncate the colors at the color axis
limits.</p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_alpha">alpha</code></td>
<td>
<p>Transparency/opaqueness values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with character vector <code>colors</code> and numeric vector <code>alpha</code>
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_generate_colors(1:4, color.axis = c(1, 4))

</code></pre>

<hr>
<h2 id='fm_gmrf'>SPDE, GMRF, and Mat√©rn process methods</h2><span id='topic+fm_gmrf'></span><span id='topic+fm_matern_precision'></span><span id='topic+fm_matern_sample'></span><span id='topic+fm_covariance'></span><span id='topic+fm_sample'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Methods for SPDEs and GMRFs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_matern_precision(x, alpha, rho, sigma)

fm_matern_sample(x, alpha = 2, rho, sigma, n = 1, loc = NULL)

fm_covariance(Q, A1 = NULL, A2 = NULL, partial = FALSE)

fm_sample(n, Q, mu = 0, constr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_gmrf_+3A_x">x</code></td>
<td>
<p>A mesh object, e.g. from <code>fm_mesh_1d()</code> or <code>fm_mesh_2d()</code>.</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_alpha">alpha</code></td>
<td>
<p>The SPDE operator order. The resulting smoothness index
is <code>nu = alpha - dim / 2</code>.</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_rho">rho</code></td>
<td>
<p>The Mat√©rn range parameter
(scale parameter <code>kappa = sqrt(8 * nu) / rho</code>)</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_sigma">sigma</code></td>
<td>
<p>The nominal Mat√©rn std.dev. parameter</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_n">n</code></td>
<td>
<p>The number of samples to generate</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_loc">loc</code></td>
<td>
<p>locations to evaluate the random field, compatible with
<code>fm_evaluate(x, loc = loc, field = ...)</code></p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_q">Q</code></td>
<td>
<p>A precision matrix</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_a1">A1</code>, <code id="fm_gmrf_+3A_a2">A2</code></td>
<td>
<p>Matrices, typically obtained from <code><a href="#topic+fm_basis">fm_basis()</a></code> and/or <code><a href="#topic+fm_block">fm_block()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_partial">partial</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> If <code>TRUE</code>, compute the
partial inverse of <code>Q</code>, i.e. the elements of the inverse corresponding to
the non-zero pattern of <code>Q</code>. (Note: This can be done efficiently with
the Takahashi recursion method, but to avoid an RcppEigen dependency this
is currently disabled, and a slower method is used until the efficient method
is reimplemented.)</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_mu">mu</code></td>
<td>
<p>Optional mean vector</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_constr">constr</code></td>
<td>
<p>Optional list of constraint information, with elements
<code>A</code> and <code>e</code>. Should only be used for a small number of exact constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_matern_sample()</code> returns a matrix, where each column is a sampled
field. If <code>loc</code> is <code>NULL</code>, the <code>fm_dof(mesh)</code> basis weights are given.
Otherwise, the evaluated field at the <code>nrow(loc)</code> locations <code>loc</code> are given
(from version <code style="white-space: pre;">&#8288;0.1.4.9001&#8288;</code>)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_matern_precision()</code>: Construct the (sparse) precision matrix for the basis weights for
Whittle-Mat√©rn SPDE models.  The boundary behaviour is determined by the
provided mesh function space.
</p>
</li>
<li> <p><code>fm_matern_sample()</code>: Simulate a Mat√©rn field given a mesh and
covariance function parameters, and optionally evaluate at given locations.
</p>
</li>
<li> <p><code>fm_covariance()</code>: Compute the covariance between &quot;A1 x&quot; and &quot;A2 x&quot;, when
x is a basis vector with precision matrix <code>Q</code>.
</p>
</li>
<li> <p><code>fm_sample()</code>: Generate <code>n</code> samples based on a sparse precision matrix <code>Q</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
mesh &lt;- fm_mesh_1d(-20:120, degree = 2)
Q &lt;- fm_matern_precision(mesh, alpha = 2, rho = 15, sigma = 1)
x &lt;- seq(0, 100, length.out = 601)
A &lt;- fm_basis(mesh, x)
plot(x,
  as.vector(Matrix::diag(fm_covariance(Q, A))),
  type = "l",
  ylab = "marginal variances"
)

plot(x,
  fm_evaluate(mesh, loc = x, field = fm_sample(1, Q)[, 1]),
  type = "l",
  ylab = "process sample"
)

</code></pre>

<hr>
<h2 id='fm_int'>Multi-domain integration</h2><span id='topic+fm_int'></span><span id='topic+fm_int.list'></span><span id='topic+fm_int.numeric'></span><span id='topic+fm_int.character'></span><span id='topic+fm_int.factor'></span><span id='topic+fm_int.SpatRaster'></span><span id='topic+fm_int.fm_lattice_2d'></span><span id='topic+fm_int.fm_mesh_1d'></span><span id='topic+fm_int.fm_mesh_2d'></span><span id='topic+fm_int.inla.mesh.lattice'></span><span id='topic+fm_int.inla.mesh.1d'></span><span id='topic+fm_int.inla.mesh'></span>

<h3>Description</h3>

<p>Construct integration points on tensor product spaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_int(domain, samplers = NULL, ...)

## S3 method for class 'list'
fm_int(domain, samplers = NULL, ...)

## S3 method for class 'numeric'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'character'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'factor'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'SpatRaster'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'fm_lattice_2d'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'fm_mesh_1d'
fm_int(domain, samplers = NULL, name = "x", int.args = NULL, ...)

## S3 method for class 'fm_mesh_2d'
fm_int(
  domain,
  samplers = NULL,
  name = NULL,
  int.args = NULL,
  format = NULL,
  ...
)

## S3 method for class 'inla.mesh.lattice'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'inla.mesh.1d'
fm_int(domain, samplers = NULL, name = "x", int.args = NULL, ...)

## S3 method for class 'inla.mesh'
fm_int(
  domain,
  samplers = NULL,
  name = NULL,
  int.args = NULL,
  format = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_int_+3A_domain">domain</code></td>
<td>
<p>Functional space specification; single domain or a named list
of domains</p>
</td></tr>
<tr><td><code id="fm_int_+3A_samplers">samplers</code></td>
<td>
<p>For single domain <code>fm_int</code> methods, an object specifying one or more
subsets of the domain, and optional weighting in a <code>weight</code> variable.
For <code>fm_int.list</code>, a list of sampling definitions, where data frame elements
may contain information for multiple domains, in which case each row represent
a separate tensor product integration subspace.</p>
</td></tr>
<tr><td><code id="fm_int_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="fm_int_+3A_name">name</code></td>
<td>
<p>For single-domain methods, the variable name to use for the
integration points. Default 'x'</p>
</td></tr>
<tr><td><code id="fm_int_+3A_int.args">int.args</code></td>
<td>
<p>List of arguments passed to line and integration methods.
</p>

<ul>
<li> <p><code>method</code>: &quot;stable&quot; (to aggregate integration weights onto mesh nodes)
or &quot;direct&quot; (to construct a within triangle/segment integration scheme
without aggregating onto mesh nodes)
</p>
</li>
<li> <p><code>nsub1</code>, <code>nsub2</code>: integers controlling the number of internal integration
points before aggregation. Points per triangle: <code>(nsub2+1)^2</code>.
Points per knot segment: <code>nsub1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="fm_int_+3A_format">format</code></td>
<td>
<p>character; determines the output format, as either &quot;sf&quot;
(default when the sampler is <code>NULL</code>) or &quot;sp&quot;. When <code>NULL</code>, determined by
the sampler type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, <code>tibble</code>, <code>sf</code>, or <code>SpatialPointsDataFrame</code> of 1D and
2D integration points, including a <code>weight</code> column and <code>.block</code> column.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_int(list)</code>: Multi-domain integration
</p>
</li>
<li> <p><code>fm_int(numeric)</code>: Discrete double or integer space integration
</p>
</li>
<li> <p><code>fm_int(character)</code>: Discrete character space integration
</p>
</li>
<li> <p><code>fm_int(factor)</code>: Discrete factor space integration
</p>
</li>
<li> <p><code>fm_int(SpatRaster)</code>: <code>SpatRaster</code> integration. Not yet implemented.
</p>
</li>
<li> <p><code>fm_int(fm_lattice_2d)</code>: <code>fm_lattice_2d</code> integration. Not yet implemented.
</p>
</li>
<li> <p><code>fm_int(fm_mesh_1d)</code>: <code>fm_mesh_1d</code> integration. Supported samplers:
</p>

<ul>
<li> <p><code>NULL</code> for integration over the entire domain;
</p>
</li>
<li><p> A length 2 vector defining an interval;
</p>
</li>
<li><p> A 2-column matrix with a single interval in each row;
</p>
</li>
<li><p> A tibble with a named column containing a matrix, and optionally a
<code>weight</code> column.
</p>
</li></ul>

</li>
<li> <p><code>fm_int(fm_mesh_2d)</code>: <code>fm_mesh_2d</code> integration. Any sampler class with an
associated <code><a href="#topic+fm_int_mesh_2d">fm_int_mesh_2d()</a></code> method is supported.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Integration on the interval (2, 3.5) with Simpson's rule
ips &lt;- fm_int(fm_mesh_1d(0:4), samplers = cbind(2, 3.5))
plot(ips$x, ips$weight)

# Create integration points for the two intervals [0,3] and [5,10]

ips &lt;- fm_int(
  fm_mesh_1d(0:10),
  matrix(c(0, 3, 5, 10), nrow = 2, byrow = TRUE)
)
plot(ips$x, ips$weight)

# Convert a 1D mesh into integration points
mesh &lt;- fm_mesh_1d(seq(0, 10, by = 1))
ips &lt;- fm_int(mesh, name = "time")
plot(ips$time, ips$weight)

if (require("ggplot2", quietly = TRUE)) {
  #' Integrate on a 2D mesh with polygon boundary subset
  ips &lt;- fm_int(fmexample$mesh, fmexample$boundary_sf[[1]])
  ggplot() +
    geom_sf(data = fm_as_sfc(fmexample$mesh, multi = TRUE), alpha = 0.5) +
    geom_sf(data = fmexample$boundary_sf[[1]], fill = "red", alpha = 0.5) +
    geom_sf(data = ips, aes(size = weight)) +
    scale_size_area()
}

ips &lt;- fm_int(
  fm_mesh_1d(0:10, boundary = "cyclic"),
  rbind(c(0, 3), c(5, 10))
)
plot(ips$x, ips$weight)

</code></pre>

<hr>
<h2 id='fm_int_mesh_2d'>Subset integration on a mesh</h2><span id='topic+fm_int_mesh_2d'></span><span id='topic+fm_int_mesh_2d_NULL'></span><span id='topic+fm_int_mesh_2d.sf'></span><span id='topic+fm_int_mesh_2d.sfc_POINT'></span><span id='topic+fm_int_mesh_2d.sfc_MULTIPOINT'></span><span id='topic+fm_int_mesh_2d.sfc_LINESTRING'></span><span id='topic+fm_int_mesh_2d.sfc_MULTILINESTRING'></span><span id='topic+fm_int_mesh_2d.sfc_POLYGON'></span><span id='topic+fm_int_mesh_2d.sfc_MULTIPOLYGON'></span><span id='topic+fm_int_mesh_2d.sfc_GEOMETRY'></span><span id='topic+fm_int_mesh_2d.Spatial'></span>

<h3>Description</h3>

<p>Integration methods for spatial samplers on <code>fm_mesh_2d</code> meshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_int_mesh_2d(samplers, domain, name = NULL, int.args = NULL, ...)

fm_int_mesh_2d_NULL(samplers, domain, name = NULL, int.args = NULL, ...)

## S3 method for class 'sf'
fm_int_mesh_2d(samplers, domain, name = NULL, int.args = NULL, ...)

## S3 method for class 'sfc_POINT'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_MULTIPOINT'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_LINESTRING'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_MULTILINESTRING'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_POLYGON'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_MULTIPOLYGON'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_GEOMETRY'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'Spatial'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  format = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_int_mesh_2d_+3A_samplers">samplers</code></td>
<td>
<p>For single domain <code>fm_int</code> methods, an object specifying one or more
subsets of the domain, and optional weighting in a <code>weight</code> variable.
For <code>fm_int.list</code>, a list of sampling definitions, where data frame elements
may contain information for multiple domains, in which case each row represent
a separate tensor product integration subspace.</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_domain">domain</code></td>
<td>
<p>Functional space specification; single domain or a named list
of domains</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_name">name</code></td>
<td>
<p>For single-domain methods, the variable name to use for the
integration points. Default 'x'</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_int.args">int.args</code></td>
<td>
<p>List of arguments passed to line and integration methods.
</p>

<ul>
<li> <p><code>method</code>: &quot;stable&quot; (to aggregate integration weights onto mesh nodes)
or &quot;direct&quot; (to construct a within triangle/segment integration scheme
without aggregating onto mesh nodes)
</p>
</li>
<li> <p><code>nsub1</code>, <code>nsub2</code>: integers controlling the number of internal integration
points before aggregation. Points per triangle: <code>(nsub2+1)^2</code>.
Points per knot segment: <code>nsub1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_format">format</code></td>
<td>
<p>character; determines the output format, as either &quot;sf&quot;
(default when the sampler is <code>NULL</code>) or &quot;sp&quot;. When <code>NULL</code>, determined by
the sampler type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code>, <code>sf</code>, or <code>Spatial</code> object with
point coordinate information and additional columns <code>weight</code> and <code>.block</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_int_mesh_2d(sf)</code>: <code>sf</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_POINT)</code>: <code>sfc_POINT</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_MULTIPOINT)</code>: <code>sfc_MULTIPOINT</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_LINESTRING)</code>: <code>sfc_LINESTRING</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_MULTILINESTRING)</code>: <code>sfc_MULTILINESTRING</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_POLYGON)</code>: <code>sfc_POLYGON</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_MULTIPOLYGON)</code>: <code>sfc_MULTIPOLYGON</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_GEOMETRY)</code>: <code>sfc_GEOMERY</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(Spatial)</code>: <code>Spatial</code> integration
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_int_mesh_2d_NULL()</code>: Full domain integration
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_int_mesh_2d(samplers = NULL, domain = fmexample$mesh))
</code></pre>

<hr>
<h2 id='fm_int_mesh_2d_core'>Integration scheme for mesh triangle interiors</h2><span id='topic+fm_int_mesh_2d_core'></span>

<h3>Description</h3>

<p>Integration scheme for mesh triangle interiors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_int_mesh_2d_core(mesh, tri_subset = NULL, nsub = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_int_mesh_2d_core_+3A_mesh">mesh</code></td>
<td>
<p>Mesh on which to integrate</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_core_+3A_tri_subset">tri_subset</code></td>
<td>
<p>Optional triangle index vector for integration on a subset
of the mesh triangles (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_core_+3A_nsub">nsub</code></td>
<td>
<p>number of subdivision points along each triangle edge, giving
<code>(nsub + 1)^2</code> proto-integration points used to compute
the vertex weights
(default <code>NULL=9</code>, giving 100 integration points for each triangle)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> with elements <code>loc</code> and <code>weight</code> with
integration points for the mesh
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_int_mesh_2d_core(fmexample$mesh))

</code></pre>

<hr>
<h2 id='fm_int_multi_sampler'>Multi-domain sampler integration</h2><span id='topic+fm_int_multi_sampler'></span>

<h3>Description</h3>

<p>Combine integration over different domains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_int_multi_sampler(domain, samplers, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_int_multi_sampler_+3A_domain">domain</code></td>
<td>
<p>A list of named domains</p>
</td></tr>
<tr><td><code id="fm_int_multi_sampler_+3A_samplers">samplers</code></td>
<td>
<p>A named list of samplers</p>
</td></tr>
<tr><td><code id="fm_int_multi_sampler_+3A_...">...</code></td>
<td>
<p>Passed on to each <code><a href="#topic+fm_int">fm_int()</a></code> call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with integration points and weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_int_multi_sampler(
  domain = list(x = fm_mesh_1d(1:4), y = 11:12),
  samplers = tibble::tibble(
    x = rbind(c(1, 3), c(2, 4)),
    y = c(12, 11)
  )
)
</code></pre>

<hr>
<h2 id='fm_is_within'>Query if points are inside a mesh</h2><span id='topic+fm_is_within'></span><span id='topic+fm_is_within.default'></span>

<h3>Description</h3>

<p>Queries whether each input point is within a mesh or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_is_within(x, y, ...)

## Default S3 method:
fm_is_within(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_is_within_+3A_x">x</code></td>
<td>
<p>A set of points of a class supported by <code>fm_evaluator(y, loc = x)</code></p>
</td></tr>
<tr><td><code id="fm_is_within_+3A_y">y</code></td>
<td>
<p>An <code>inla.mesh</code></p>
</td></tr>
<tr><td><code id="fm_is_within_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all(fm_is_within(fmexample$loc, fmexample$mesh))
</code></pre>

<hr>
<h2 id='fm_lattice_2d'>Make a lattice object</h2><span id='topic+fm_lattice_2d'></span><span id='topic+fm_lattice_2d.default'></span>

<h3>Description</h3>

<p>Construct a lattice grid for <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_lattice_2d(...)

## Default S3 method:
fm_lattice_2d(
  x = seq(0, 1, length.out = 2),
  y = seq(0, 1, length.out = 2),
  z = NULL,
  dims = if (is.matrix(x)) {
     dim(x)
 } else {
     c(length(x), length(y))
 },
  units = NULL,
  crs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_lattice_2d_+3A_...">...</code></td>
<td>
<p>Currently passed on to <code>inla.mesh.lattice</code></p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_x">x</code></td>
<td>
<p>vector or grid matrix of x-values</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_y">y</code></td>
<td>
<p>vector of grid matrix of y-values</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_z">z</code></td>
<td>
<p>if x is a matrix, a grid matrix of z-values</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_dims">dims</code></td>
<td>
<p>the size of the grid, length 2 vector</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_units">units</code></td>
<td>
<p>One of <code>c("default", "longlat", "longsinlat", "mollweide")</code>
or NULL (equivalent to <code>"default"</code>).</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_crs">crs</code></td>
<td>
<p>An optional <code>fm_crs</code>, <code>sf::st_crs</code>, or <code>sp::CRS</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_lattice_2d</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>
</p>
<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lattice &lt;- fm_lattice_2d(
  seq(0, 1, length.out = 17),
  seq(0, 1, length.out = 10)
)

## Use the lattice "as-is", without refinement:
mesh &lt;- fm_rcdt_2d_inla(lattice = lattice, boundary = lattice$segm)
mesh &lt;- fm_rcdt_2d_inla(lattice = lattice, extend = FALSE)

## Refine the triangulation, with limits on triangle angles and edges:
mesh &lt;- fm_rcdt_2d(
  lattice = lattice,
  refine = list(max.edge = 0.08),
  extend = FALSE
)

## Add an extension around the lattice, but maintain the lattice edges:
mesh &lt;- fm_rcdt_2d(
  lattice = lattice,
  refine = list(max.edge = 0.08),
  interior = lattice$segm
)

## Only add extension:
mesh &lt;- fm_rcdt_2d(lattice = lattice, refine = list(max.edge = 0.08))
</code></pre>

<hr>
<h2 id='fm_list'>Handle lists of fmesher objects</h2><span id='topic+fm_list'></span><span id='topic+fm_as_list'></span><span id='topic+c.fm_list'></span><span id='topic++5B.fm_list'></span>

<h3>Description</h3>

<p>Methods for constructing and manipulating <code>fm_list</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_list(x, ..., .class_stub = NULL)

fm_as_list(x, ..., .class_stub = NULL)

## S3 method for class 'fm_list'
c(...)

## S3 method for class 'fm_list'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_list_+3A_x">x</code></td>
<td>
<p><code>fm_list</code> object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="fm_list_+3A_...">...</code></td>
<td>
<p>Arguments passed to each individual conversion call.</p>
</td></tr>
<tr><td><code id="fm_list_+3A_.class_stub">.class_stub</code></td>
<td>
<p>character; class stub name of class to convert each list
element to. If <code>NULL</code>, uses <code>fm_as_fm</code> and auto-detects if the resulting
list has consistent class, and then adds that to the class list.  If
non-null, uses <code>paste0("fm_as_", .class_stub)</code> for conversion, and verifies
that the resulting list has elements consistent with that class.</p>
</td></tr>
<tr><td><code id="fm_list_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_list</code> object, potentially with <code style="white-space: pre;">&#8288;fm_{class_stub}_list&#8288;</code>
added.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>c(fm_list)</code>: The <code>...</code> arguments should be coercible to <code>fm_list</code>
objects.
</p>
</li>
<li> <p><code>[</code>: Extract sub-list
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_list()</code>: Convert each element of a list, or convert a single
non-list object and return in a list
</p>
</li>
<li> <p><code>fm_as_list()</code>: Convert each element of a list, or convert a single
non-list object and return in a list
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_list(list(fmexample$mesh, fm_segm_join(fmexample$boundary_fm)))

</code></pre>

<hr>
<h2 id='fm_manifold'>Query the mesh manifold type</h2><span id='topic+fm_manifold'></span><span id='topic+fm_manifold_type'></span><span id='topic+fm_manifold_dim'></span>

<h3>Description</h3>

<p>Extract a manifold definition string, or a logical for matching
manifold type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_manifold(x, type = NULL)

fm_manifold_type(x)

fm_manifold_dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_manifold_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+fm_mesh_1d">fm_mesh_1d</a> or <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> object (or other object containing a
<code>manifold</code> element)</p>
</td></tr>
<tr><td><code id="fm_manifold_+3A_type">type</code></td>
<td>
<p><code>character</code>; if <code>NULL</code> (the default), returns the manifold definition string.
If <code>character</code>, returns <code>TRUE</code> if the manifold type of <code>x</code> matches at least
one of the character vector elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_manifold()</code>: Either logical (matching manifold type yes/no),
or character (the stored manifold, when <code>is.null(type)</code> is <code>TRUE</code>)
</p>
<p><code>fm_manifold_type()</code>: character or NULL; &quot;M&quot;, &quot;R&quot;, or &quot;S&quot;
</p>
<p><code>fm_manifold_dim()</code>: integer or NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_manifold(fmexample$mesh)
fm_manifold_type(fmexample$mesh)
fm_manifold_dim(fmexample$mesh)
</code></pre>

<hr>
<h2 id='fm_mesh_1d'>Make a 1D mesh object</h2><span id='topic+fm_mesh_1d'></span>

<h3>Description</h3>

<p>Create a <code>fm_mesh_1d</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_mesh_1d(
  loc,
  interval = range(loc),
  boundary = NULL,
  degree = 1,
  free.clamped = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_mesh_1d_+3A_loc">loc</code></td>
<td>
<p>B-spline knot locations.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_interval">interval</code></td>
<td>
<p>Interval domain endpoints.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_boundary">boundary</code></td>
<td>
<p>Boundary condition specification.  Valid conditions are
<code>c('neumann', 'dirichlet', 'free', 'cyclic')</code>.  Two separate values can
be specified, one applied to each endpoint.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_degree">degree</code></td>
<td>
<p>The B-spline basis degree.  Supported values are 0, 1, and 2.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_free.clamped">free.clamped</code></td>
<td>
<p>If <code>TRUE</code>, for <code>'free'</code> boundaries, clamp the
basis functions to the interval endpoints.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_...">...</code></td>
<td>
<p>Additional options, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_1d</code> object
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2")) {
  m &lt;- fm_mesh_1d(c(1, 2, 3, 5, 8, 10),
    boundary = c("neumann", "free"),
    degree = 2
  )
  ggplot() +
    geom_fm(data = m, xlim = c(0.5, 10.5))
}

</code></pre>

<hr>
<h2 id='fm_mesh_2d'>Make a 2D mesh object</h2><span id='topic+fm_mesh_2d'></span><span id='topic+fm_mesh_2d_inla'></span>

<h3>Description</h3>

<p>Make a 2D mesh object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_mesh_2d(...)

fm_mesh_2d_inla(
  loc = NULL,
  loc.domain = NULL,
  offset = NULL,
  n = NULL,
  boundary = NULL,
  interior = NULL,
  max.edge = NULL,
  min.angle = NULL,
  cutoff = 1e-12,
  max.n.strict = NULL,
  max.n = NULL,
  plot.delay = NULL,
  crs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_mesh_2d_+3A_...">...</code></td>
<td>
<p>Currently passed on to <code>fm_mesh_2d_inla</code></p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_loc">loc</code></td>
<td>
<p>Matrix of point locations to be used as initial triangulation
nodes.  Can alternatively be a <code>sf</code>, <code>sfc</code>, <code>SpatialPoints</code> or
<code>SpatialPointsDataFrame</code> object.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_loc.domain">loc.domain</code></td>
<td>
<p>Matrix of point locations used to determine the domain
extent.  Can alternatively be a <code>SpatialPoints</code> or
<code>SpatialPointsDataFrame</code> object.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_offset">offset</code></td>
<td>
<p>The automatic extension distance.  One or two values, for an
inner and an optional outer extension.  If negative, interpreted as a factor
relative to the approximate data diameter (default=-0.10???)</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_n">n</code></td>
<td>
<p>The number of initial nodes in the automatic extensions
(default=16)</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_boundary">boundary</code></td>
<td>
<p>one or more (as list) of <code><a href="#topic+fm_segm">fm_segm()</a></code> objects, or objects
supported by <code><a href="#topic+fm_as_segm">fm_as_segm()</a></code></p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_interior">interior</code></td>
<td>
<p>one object supported by <code><a href="#topic+fm_as_segm">fm_as_segm()</a></code></p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_max.edge">max.edge</code></td>
<td>
<p>The largest allowed triangle edge length.  One or two
values.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_min.angle">min.angle</code></td>
<td>
<p>The smallest allowed triangle angle.  One or two values.
(Default=21)</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_cutoff">cutoff</code></td>
<td>
<p>The minimum allowed distance between points.  Point at most as
far apart as this are replaced by a single vertex prior to the mesh
refinement step.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_max.n.strict">max.n.strict</code></td>
<td>
<p>The maximum number of vertices allowed, overriding
<code>min.angle</code> and <code>max.edge</code> (default=-1, meaning no limit).  One or
two values, where the second value gives the number of additional vertices
allowed for the extension.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_max.n">max.n</code></td>
<td>
<p>The maximum number of vertices allowed, overriding
<code>max.edge</code> only (default=-1, meaning no limit).  One or two values,
where the second value gives the number of additional vertices allowed for
the extension.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_plot.delay">plot.delay</code></td>
<td>
<p>If logical <code>TRUE</code> or a negative numeric value,
activates displaying the
result after each step of the multi-step domain extension algorithm.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_crs">crs</code></td>
<td>
<p>An optional <code><a href="#topic+fm_crs">fm_crs()</a></code>, <code>sf::crs</code> or <code>sp::CRS</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>inla.mesh</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_mesh_2d_inla()</code>: Legacy method for <code>INLA::inla.mesh.2d()</code>
Create a triangle mesh based on initial point locations, specified or
automatic boundaries, and mesh quality parameters.
</p>
</li></ul>


<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code><a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla()</a></code>, <code><a href="#topic+fm_mesh_2d_inla">fm_mesh_2d_inla()</a></code>,
and <code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, and <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> interfaces may be
different, and potentially change in the future.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, <code><a href="#topic+fm_delaunay_2d">fm_delaunay_2d()</a></code>,
<code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code>, <code><a href="#topic+fm_extensions">fm_extensions()</a></code>, <code><a href="#topic+fm_refine">fm_refine()</a></code>
</p>
<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_mesh_2d_inla(boundary = fm_extensions(cbind(2, 1), convex = 1, 2))

</code></pre>

<hr>
<h2 id='fm_mesh_2d_map'>Special coordinate mappings for <code>fm_mesh_2d</code> projections.</h2><span id='topic+fm_mesh_2d_map'></span><span id='topic+fm_mesh_2d_map_lim'></span>

<h3>Description</h3>

<p>Calculates coordinate mappings for spherical <code>fm_mesh_2d</code> projections.
This is an internal function not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_mesh_2d_map(
  loc,
  projection = c("default", "longlat", "longsinlat", "mollweide"),
  inverse = TRUE
)

fm_mesh_2d_map_lim(
  loc = NULL,
  projection = c("default", "longlat", "longsinlat", "mollweide")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_mesh_2d_map_+3A_loc">loc</code></td>
<td>
<p>Coordinates to be mapped.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_map_+3A_projection">projection</code></td>
<td>
<p>The projection type.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_map_+3A_inverse">inverse</code></td>
<td>
<p>If <code>TRUE</code>, <code>loc</code> are map coordinates and
coordinates in the spherical domain are calculated.  If <code>FALSE</code>, <code>loc</code>
are coordinates in the spherical domain and the forward map projection is
calculated. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>fm_mesh_2d_map_lim</code>, a list:
</p>
<table>
<tr><td><code>xlim</code></td>
<td>
<p>X axis limits in the map domain</p>
</td></tr>
<tr><td><code>ylim</code></td>
<td>
<p>Y axis limits in the map domain</p>
</td></tr>
</table>
<p>No attempt is
made to find minimal limits for partial spherical domains.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_mesh_2d_map_lim()</code>: Projection extent limit calculations
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_evaluator">fm_evaluator()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(loc &lt;- fm_mesh_2d_map(cbind(20, 10), "longlat"))
fm_mesh_2d_map(loc, "longlat", inverse = FALSE)

</code></pre>

<hr>
<h2 id='fm_mesh_intersection'>Construct the intersection mesh of a mesh and a polygon</h2><span id='topic+fm_mesh_intersection'></span>

<h3>Description</h3>

<p>Construct the intersection mesh of a mesh and a polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_mesh_intersection(mesh, poly)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_mesh_intersection_+3A_mesh">mesh</code></td>
<td>
<p><code>fm_mesh_2d</code> object to be intersected</p>
</td></tr>
<tr><td><code id="fm_mesh_intersection_+3A_poly">poly</code></td>
<td>
<p><code>fm_segm</code> object with a closed polygon
to intersect with the mesh</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> object
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>segm &lt;- fm_segm(rbind(c(-4, -4), c(4, -4), c(0, 4)),
  is.bnd = TRUE
)
str(m &lt;- fm_mesh_intersection(fmexample$mesh, segm))
plot(fmexample$mesh)
lines(segm, col = 4)
plot(m, edge.color = 2, add = TRUE)
</code></pre>

<hr>
<h2 id='fm_nonconvex_hull'>Compute an extension of a spatial object</h2><span id='topic+fm_nonconvex_hull'></span><span id='topic+fm_nonconvex_hull.sfc'></span><span id='topic+fm_extensions'></span><span id='topic+fm_nonconvex_hull.matrix'></span><span id='topic+fm_nonconvex_hull.sf'></span><span id='topic+fm_nonconvex_hull.Spatial'></span><span id='topic+fm_nonconvex_hull.sfg'></span>

<h3>Description</h3>

<p>Constructs a potentially nonconvex extension of a spatial object by
performing dilation by <code>convex + concave</code> followed by
erosion by <code>concave</code>. This is equivalent to dilation by <code>convex</code> followed
by closing (dilation + erosion) by <code>concave</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_nonconvex_hull(x, ...)

## S3 method for class 'sfc'
fm_nonconvex_hull(
  x,
  convex = -0.15,
  concave = convex,
  preserveTopology = TRUE,
  dTolerance = NULL,
  crs = fm_crs(x),
  ...
)

fm_extensions(x, convex = -0.15, concave = convex, dTolerance = NULL, ...)

## S3 method for class 'matrix'
fm_nonconvex_hull(x, ...)

## S3 method for class 'sf'
fm_nonconvex_hull(x, ...)

## S3 method for class 'Spatial'
fm_nonconvex_hull(x, ...)

## S3 method for class 'sfg'
fm_nonconvex_hull(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_nonconvex_hull_+3A_x">x</code></td>
<td>
<p>A spatial object</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> sub-methods</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_convex">convex</code></td>
<td>
<p>numeric vector; How much to extend</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_concave">concave</code></td>
<td>
<p>numeric vector; The minimum allowed reentrant curvature. Default equal to <code>convex</code></p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_preservetopology">preserveTopology</code></td>
<td>
<p>logical; argument to <code>sf::st_simplify()</code></p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_dtolerance">dTolerance</code></td>
<td>
<p>If not zero, controls the <code>dTolerance</code> argument to <code>sf::st_simplify()</code>.
The default is <code>pmin(convex, concave) / 40</code>, chosen to
give approximately 4 or more subsegments per circular quadrant.</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_crs">crs</code></td>
<td>
<p>Options crs object for the resulting polygon</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Morphological dilation by <code>convex</code>, followed by closing by
<code>concave</code>, with minimum concave curvature radius <code>concave</code>.  If
the dilated set has no gaps of width between </p>
<p style="text-align: center;"><code class="reqn">2 \textrm{convex} (\sqrt{1+2
\textrm{concave}/\textrm{convex}} - 1)</code>
</p>

<p>and <code class="reqn">2\textrm{concave}</code>, then the minimum convex curvature radius is
<code>convex</code>.
</p>
<p>The implementation is based on the identity </p>
<p style="text-align: center;"><code class="reqn">\textrm{dilation}(a) \&amp;
\textrm{closing}(b) = \textrm{dilation}(a+b) \&amp; \textrm{erosion}(b)</code>
</p>
<p> where all operations
are with respect to disks with the specified radii.
</p>
<p>When <code>convex</code>, <code>concave</code>, or <code>dTolerance</code> are negative,
<code>fm_diameter * abs(...)</code> is used instead.
</p>
<p>Differs from <code>sf::st_buffer(x, convex)</code> followed by
<code>sf::st_concave_hull()</code> (available from GEOS 3.11)
in how the amount of allowed concavity is controlled.
</p>


<h3>Value</h3>

<p><code>fm_nonconvex_hull()</code> returns an extended object as an <code>sfc</code>
polygon object (regardless of the <code>x</code> class).
</p>
<p><code>fm_extensions()</code> returns a list of <code>sfc</code> objects.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_nonconvex_hull()</code>: Basic nonconvex hull method.
</p>
</li>
<li> <p><code>fm_extensions()</code>: Constructs a potentially nonconvex extension of a spatial object by
performing dilation by <code>convex + concave</code> followed by
erosion by <code>concave</code>. This is equivalent to dilation by <code>convex</code> followed
by closing (dilation + erosion) by <code>concave</code>.
</p>
</li></ul>


<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code><a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla()</a></code>, <code><a href="#topic+fm_mesh_2d_inla">fm_mesh_2d_inla()</a></code>,
and <code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, and <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> interfaces may be
different, and potentially change in the future.
</p>


<h3>References</h3>

<p>Gonzalez and Woods (1992), Digital Image Processing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inp &lt;- matrix(rnorm(20), 10, 2)
out &lt;- fm_nonconvex_hull(inp, convex = 1)
plot(out)
points(inp, pch = 20)
if (TRUE) {
  inp &lt;- sf::st_as_sf(as.data.frame(matrix(1:6, 3, 2)), coords = 1:2)
  bnd &lt;- fm_extensions(inp, convex = c(0.75, 2))
  plot(fm_mesh_2d(boundary = bnd, max.edge = c(0.25, 1)), asp = 1)
}
</code></pre>

<hr>
<h2 id='fm_nonconvex_hull_inla'>Non-convex hull computation</h2><span id='topic+fm_nonconvex_hull_inla'></span><span id='topic+fm_nonconvex_hull_inla_basic'></span>

<h3>Description</h3>

<p>Legacy method for <code>INLA::inla.nonconvex.hull()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_nonconvex_hull_inla(
  x,
  convex = -0.15,
  concave = convex,
  resolution = 40,
  eps = NULL,
  eps_rel = NULL,
  crs = NULL,
  ...
)

fm_nonconvex_hull_inla_basic(
  x,
  convex = -0.15,
  resolution = 40,
  eps = NULL,
  crs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_x">x</code></td>
<td>
<p>A spatial object</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_convex">convex</code></td>
<td>
<p>numeric vector; How much to extend</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_concave">concave</code></td>
<td>
<p>numeric vector; The minimum allowed reentrant curvature. Default equal to <code>convex</code></p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_resolution">resolution</code></td>
<td>
<p>The internal computation resolution.  A warning will be
issued when this needs to be increased for higher accuracy, with the
required resolution stated.</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_eps">eps</code>, <code id="fm_nonconvex_hull_inla_+3A_eps_rel">eps_rel</code></td>
<td>
<p>The polygonal curve simplification tolerances used for
simplifying the resulting boundary curve.  See <code><a href="#topic+fm_simplify_helper">fm_simplify_helper()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_crs">crs</code></td>
<td>
<p>Options crs object for the resulting polygon</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires <code>splancs::nndistF()</code>
</p>


<h3>Value</h3>

<p><code>fm_nonconvex_hull_inla()</code> returns an <code>fm_segm</code>/<code>inla.mesh.segment</code>
object, for compatibility with <code>inla.nonconvex.hull()</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_nonconvex_hull_inla_basic()</code>: Special method for <code>convex = 0</code>.
</p>
</li></ul>


<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code><a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla()</a></code>, <code><a href="#topic+fm_mesh_2d_inla">fm_mesh_2d_inla()</a></code>,
and <code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, and <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> interfaces may be
different, and potentially change in the future.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code>
</p>
<p>Other nonconvex inla legacy support: 
<code><a href="#topic+fm_segm_contour_helper">fm_segm_contour_helper</a>()</code>,
<code><a href="#topic+fm_simplify_helper">fm_simplify_helper</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm_nonconvex_hull_inla(cbind(0, 0), convex = 1)

</code></pre>

<hr>
<h2 id='fm_pixels'>Generate lattice points covering a mesh</h2><span id='topic+fm_pixels'></span>

<h3>Description</h3>

<p>Generate <code>terra</code>, <code>sf</code>, or <code>sp</code> lattice locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_pixels(
  mesh,
  dims = c(150, 150),
  xlim = NULL,
  ylim = NULL,
  mask = TRUE,
  format = "sf",
  minimal = TRUE,
  nx = deprecated(),
  ny = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_pixels_+3A_mesh">mesh</code></td>
<td>
<p>An <code>fm_mesh_2d</code> object</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_dims">dims</code></td>
<td>
<p>A length 2 integer vector giving the dimensions of
the target lattice.</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_xlim">xlim</code>, <code id="fm_pixels_+3A_ylim">ylim</code></td>
<td>
<p>Length 2 numeric vectors of x- and y- axis limits.
Defaults taken from the range of the mesh or mask; see <code>minimal</code>.</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_mask">mask</code></td>
<td>
<p>If logical and TRUE, remove pixels that are outside the mesh.
If <code>mask</code> is an <code>sf</code> or <code>Spatial</code> object, only return pixels covered by this
object.</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_format">format</code></td>
<td>
<p>character; &quot;sf&quot;, &quot;terra&quot; or &quot;sp&quot;</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_minimal">minimal</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the default range is determined
by the minimum of the ranges of the mesh and mask, otherwise only the mesh.</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_nx">nx</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Number of pixels in x direction,
or a numeric vector of x-values</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_ny">ny</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Number of pixels in y direction,
or a numeric vector of y-values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code>, <code>SpatRaster</code>, or <code>SpatialPixelsDataFrame</code> covering the mesh or
mask.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE)) {
  dims &lt;- c(50, 50)
  pxl &lt;- fm_pixels(
    fmexample$mesh,
    dims = dims,
    mask = fmexample$boundary_sf[[1]],
    minimal = TRUE
  )
  pxl$val &lt;- rnorm(NROW(pxl)) +
    fm_evaluate(fmexample$mesh, pxl, field = 2 * fmexample$mesh$loc[, 1])
  ggplot() +
    geom_tile(
      data = pxl,
      aes(geometry = geometry, fill = val),
      stat = "sf_coordinates"
    ) +
    geom_sf(data = fm_as_sfc(fmexample$mesh), alpha = 0.2)
}


if (require("ggplot2", quietly = TRUE) &amp;&amp;
  require("terra", quietly = TRUE) &amp;&amp;
  require("tidyterra", quietly = TRUE)) {
  pxl &lt;- fm_pixels(fmexample$mesh,
    dims = c(50, 50), mask = fmexample$boundary_sf[[1]],
    format = "terra"
  )
  pxl$val &lt;- rnorm(NROW(pxl) * NCOL(pxl))
  pxl &lt;-
    terra::mask(
      pxl,
      mask = pxl$.mask,
      maskvalues = c(FALSE, NA),
      updatevalue = NA
    )
  ggplot() +
    geom_spatraster(data = pxl, aes(fill = val)) +
    geom_sf(data = fm_as_sfc(fmexample$mesh), alpha = 0.2)
}

</code></pre>

<hr>
<h2 id='fm_raw_basis'>Basis functions for mesh manifolds</h2><span id='topic+fm_raw_basis'></span>

<h3>Description</h3>

<p>Calculate basis functions on <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> or <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>,
without necessarily matching the default function space of the given mesh
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_raw_basis(
  mesh,
  type = "b.spline",
  n = 3,
  degree = 2,
  knot.placement = "uniform.area",
  rot.inv = TRUE,
  boundary = "free",
  free.clamped = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_raw_basis_+3A_mesh">mesh</code></td>
<td>
<p>An <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> or <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_type">type</code></td>
<td>
<p><code>b.spline</code> (default) for B-spline basis functions,
<code>sph.harm</code> for spherical harmonics (available only for meshes on the
sphere)</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_n">n</code></td>
<td>
<p>For B-splines, the number of basis functions in each direction (for
1d meshes <code>n</code> must be a scalar, and for planar 2d meshes a 2-vector).
For spherical harmonics, <code>n</code> is the maximal harmonic order.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_degree">degree</code></td>
<td>
<p>Degree of B-spline polynomials.  See
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_knot.placement">knot.placement</code></td>
<td>
<p>For B-splines on the sphere, controls the latitudinal
placements of knots. <code>"uniform.area"</code> (default) gives uniform spacing
in <code>sin(latitude)</code>, <code>"uniform.latitude"</code> gives uniform spacing in
latitudes.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_rot.inv">rot.inv</code></td>
<td>
<p>For spherical harmonics on a sphere, <code>rot.inv=TRUE</code>
gives the rotationally invariant subset of basis functions.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_boundary">boundary</code></td>
<td>
<p>Boundary specification, default is free boundaries.  See
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_free.clamped">free.clamped</code></td>
<td>
<p>If <code>TRUE</code> and <code>boundary</code> is <code>"free"</code>, the
boundary basis functions are clamped to 0/1 at the interval boundary by
repeating the boundary knots. See
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with evaluated basis function
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, <code><a href="#topic+fm_basis">fm_basis()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
loc &lt;- rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1))
mesh &lt;- fm_mesh_2d(loc, max.edge = 0.15)
basis &lt;- fm_raw_basis(mesh, n = c(4, 5))

proj &lt;- fm_evaluator(mesh, dims = c(10, 10))
image(proj$x, proj$y, fm_evaluate(proj, basis[, 7]), asp = 1)

if (interactive() &amp;&amp; require("rgl")) {
  plot_rgl(mesh, col = basis[, 7], draw.edges = FALSE, draw.vertices = FALSE)
}


</code></pre>

<hr>
<h2 id='fm_rcdt_2d'>Refined Constrained Delaunay Triangulation</h2><span id='topic+fm_rcdt_2d'></span><span id='topic+fm_rcdt_2d_inla'></span><span id='topic+fm_delaunay_2d'></span>

<h3>Description</h3>

<p>Computes a refined constrained Delaunay triangulation on R2 or S2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_rcdt_2d(...)

fm_rcdt_2d_inla(
  loc = NULL,
  tv = NULL,
  boundary = NULL,
  interior = NULL,
  extend = (missing(tv) || is.null(tv)),
  refine = FALSE,
  lattice = NULL,
  globe = NULL,
  cutoff = 1e-12,
  quality.spec = NULL,
  crs = NULL,
  ...
)

fm_delaunay_2d(loc, crs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_rcdt_2d_+3A_...">...</code></td>
<td>
<p>Currently passed on to <code>fm_mesh_2d_inla</code> or converted to
<code><a href="#topic+fmesher_rcdt">fmesher_rcdt()</a></code> options.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_loc">loc</code></td>
<td>
<p>Input coordinates that should be part of the mesh. Can be a matrix, <code>sf</code>, <code>sfc</code>, <code>SpatialPoints</code>,
or other object supported by <code><a href="#topic+fm_unify_coords">fm_unify_coords()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_tv">tv</code></td>
<td>
<p>Initial triangulation, as a N-by-3 index vector into <code>loc</code></p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_boundary">boundary</code>, <code id="fm_rcdt_2d_+3A_interior">interior</code></td>
<td>
<p>Objects supported by <code><a href="#topic+fm_as_segm">fm_as_segm()</a></code>.
If <code>boundary</code> is <code>numeric</code>, <code>fm_nonconvex_hull(loc, convex = boundary)</code> is
used.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_extend">extend</code></td>
<td>
<p><code>logical</code> or <code>list</code> specifying whether to extend the
data region, with parameters </p>
 <dl>
<dt>list(&quot;n&quot;)</dt><dd><p>the number of edges
in the extended boundary (default=16)</p>
</dd> <dt>list(&quot;offset&quot;)</dt><dd><p>the extension
distance.  If negative, interpreted as a factor relative to the approximate
data diameter (default=-0.10)</p>
</dd> </dl>
<p> Setting to <code>FALSE</code> is only useful in
combination <code>lattice</code> or <code>boundary</code>.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_refine">refine</code></td>
<td>
<p><code>logical</code> or <code>list</code> specifying whether to refine the
triangulation, with parameters </p>
 <dl>
<dt>list(&quot;min.angle&quot;)</dt><dd><p>the
minimum allowed interior angle in any triangle.  The algorithm is guaranteed
to converge for <code>min.angle</code> at most 21 (default=<code>21</code>)</p>
</dd>
<dt>list(&quot;max.edge&quot;)</dt><dd><p>the maximum allowed edge length in any triangle.  If
negative, interpreted as a relative factor in an ad hoc formula depending on
the data density (default=<code>Inf</code>)</p>
</dd> <dt>list(&quot;max.n.strict&quot;)</dt><dd><p>the
maximum number of vertices allowed, overriding <code>min.angle</code> and
<code>max.edge</code> (default=-1, meaning no limit)</p>
</dd> <dt>list(&quot;max.n&quot;)</dt><dd><p>the
maximum number of vertices allowed, overriding <code>max.edge</code> only
(default=-1, meaning no limit)</p>
</dd> </dl>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_lattice">lattice</code></td>
<td>
<p>An <code>fm_lattice_2d</code> object, generated by
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d()</a></code>, specifying points on a regular lattice.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_globe">globe</code></td>
<td>
<p>If non-NULL, an integer specifying the level of subdivision
for global mesh points, used with <code><a href="#topic+fmesher_globe_points">fmesher_globe_points()</a></code></p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_cutoff">cutoff</code></td>
<td>
<p>The minimum allowed distance between points.  Point at most as
far apart as this are replaced by a single vertex prior to the mesh
refinement step.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_quality.spec">quality.spec</code></td>
<td>
<p>List of vectors of per vertex <code>max.edge</code> target
specification for each location in <code>loc</code>, <code>boundary/interior</code>
(<code>segm</code>), and <code>lattice</code>.  Only used if refining the mesh.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_crs">crs</code></td>
<td>
<p>Optional crs object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_2d</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_rcdt_2d_inla()</code>: Legacy method for the <code>INLA::inla.mesh.create()</code>
interface
</p>
</li>
<li> <p><code>fm_delaunay_2d()</code>: Construct a plain Delaunay triangulation.
</p>
</li></ul>


<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code><a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla()</a></code>, <code><a href="#topic+fm_mesh_2d_inla">fm_mesh_2d_inla()</a></code>,
and <code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, and <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> interfaces may be
different, and potentially change in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- fm_rcdt_2d_inla(
  boundary = fm_nonconvex_hull(cbind(0, 0), convex = 5)
))

fm_delaunay_2d(matrix(rnorm(30), 15, 2))

</code></pre>

<hr>
<h2 id='fm_refine'>Refine a 2d mesh</h2><span id='topic+fm_refine'></span>

<h3>Description</h3>

<p>Refine an existing mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_refine(mesh, refine = list(max.edge = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_refine_+3A_mesh">mesh</code></td>
<td>
<p>An <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object</p>
</td></tr>
<tr><td><code id="fm_refine_+3A_refine">refine</code></td>
<td>
<p>A list of refinement options passed on to
<a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A refined <code>fm_mesh_2d</code> object
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_dof(fmexample$mesh)
fm_dof(fm_refine(fmexample$mesh, refine = list(max.edge = 1)))

</code></pre>

<hr>
<h2 id='fm_row_kron'>Row-wise Kronecker products</h2><span id='topic+fm_row_kron'></span>

<h3>Description</h3>

<p>Takes two Matrices and computes the row-wise Kronecker product.  Optionally
applies row-wise weights and/or applies an additional 0/1 row-wise Kronecker
matrix product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_row_kron(M1, M2, repl = NULL, n.repl = NULL, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_row_kron_+3A_m1">M1</code></td>
<td>
<p>A matrix that can be transformed into a sparse Matrix.</p>
</td></tr>
<tr><td><code id="fm_row_kron_+3A_m2">M2</code></td>
<td>
<p>A matrix that can be transformed into a sparse Matrix.</p>
</td></tr>
<tr><td><code id="fm_row_kron_+3A_repl">repl</code></td>
<td>
<p>An optional index vector.  For each entry, specifies which
replicate the row belongs to, in the sense used in
<code>INLA::inla.spde.make.A</code></p>
</td></tr>
<tr><td><code id="fm_row_kron_+3A_n.repl">n.repl</code></td>
<td>
<p>The maximum replicate index, in the sense used in
<code>INLA::inla.spde.make.A()</code>.</p>
</td></tr>
<tr><td><code id="fm_row_kron_+3A_weights">weights</code></td>
<td>
<p>Optional scaling weights to be applied row-wise to the
resulting matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Matrix::sparseMatrix</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_row_kron(rbind(c(1, 1, 0), c(0, 1, 1)), rbind(c(1, 2), c(3, 4)))

</code></pre>

<hr>
<h2 id='fm_safe_sp'>Check for potential <code>sp</code> version compatibility issues</h2><span id='topic+fm_safe_sp'></span>

<h3>Description</h3>

<p>Loads the sp package with <code>requireNamespace("sp", quietly = TRUE)</code>, and
checks and optionally sets the <code>sp</code> evolution status flag if <code>rgdal</code> is unavailable.
This function is only needed for backwards compatibility with <code>sp</code> versions
before <code>2.0-0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_safe_sp(quietly = FALSE, force = FALSE, minimum_version = "1.4-5")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_safe_sp_+3A_quietly">quietly</code></td>
<td>
<p>logical; if <code>TRUE</code>, prints diagnostic messages. Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fm_safe_sp_+3A_force">force</code></td>
<td>
<p>logical; If <code>rgdal</code> is unavailable
and evolution status is less that <code>2L</code>, return <code>FALSE</code> if <code>force</code> is <code>FALSE</code>.
If <code>force</code> is <code>TRUE</code>, return <code>TRUE</code> if the package configuration is safe,
potentially after forcing the evolution status to <code>2L</code>.
Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fm_safe_sp_+3A_minimum_version">minimum_version</code></td>
<td>
<p>character; the minimum required sp version.
Default 1.4-5 (should always match the requirement in the package
DESCRIPTION)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (invisibly) <code>FALSE</code> if a potential issue is detected, and give a
message if <code>quietly</code> is <code>FALSE</code>. Otherwise returns <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (fm_safe_sp()) {
  # Run sp dependent calculations
}
</code></pre>

<hr>
<h2 id='fm_segm'>Make a spatial segment object</h2><span id='topic+fm_segm'></span><span id='topic+fm_segm.default'></span><span id='topic+fm_segm.fm_segm'></span><span id='topic+fm_segm.fm_segm_list'></span><span id='topic+fm_segm_join'></span><span id='topic+fm_segm_split'></span><span id='topic+fm_segm.inla.mesh.segment'></span><span id='topic+fm_segm.inla.mesh'></span><span id='topic+fm_segm.fm_mesh_2d'></span><span id='topic+fm_is_bnd'></span><span id='topic+fm_is_bnd+3C-'></span>

<h3>Description</h3>

<p>Make a spatial segment object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_segm(...)

## Default S3 method:
fm_segm(loc = NULL, idx = NULL, grp = NULL, is.bnd = TRUE, crs = NULL, ...)

## S3 method for class 'fm_segm'
fm_segm(..., grp = NULL, grp.default = 0L, is.bnd = NULL)

## S3 method for class 'fm_segm_list'
fm_segm(x, grp = NULL, grp.default = 0L, ...)

fm_segm_join(x, grp = NULL, grp.default = 0L, is.bnd = NULL)

fm_segm_split(x, grp = NULL, grp.default = 0L)

## S3 method for class 'inla.mesh.segment'
fm_segm(..., grp.default = 0)

## S3 method for class 'inla.mesh'
fm_segm(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_segm(x, boundary = TRUE, grp = NULL, ...)

fm_is_bnd(x)

fm_is_bnd(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_segm_+3A_...">...</code></td>
<td>
<p>Passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_loc">loc</code></td>
<td>
<p>Matrix of point locations, or <code>SpatialPoints</code>, or <code>sf</code>/<code>sfc</code> point
object.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_idx">idx</code></td>
<td>
<p>Segment index sequence vector or index pair matrix.  The indices
refer to the rows of <code>loc</code>.  If <code>loc==NULL</code>, the indices will be
interpreted as indices into the point specification supplied to
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>.  If <code>is.bnd==TRUE</code>, defaults to linking
all the points in <code>loc</code>, as <code>c(1:nrow(loc),1L)</code>, otherwise
<code>1:nrow(loc)</code>.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_grp">grp</code></td>
<td>
<p>When joining segments, use these group labels for segments
instead of the original group labels.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_is.bnd">is.bnd</code></td>
<td>
<p><code>TRUE</code> if the segments are boundary segments, otherwise
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_crs">crs</code></td>
<td>
<p>An optional <code>fm_crs()</code>, <code>sf::st_crs()</code> or <code>sp::CRS()</code> object</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_grp.default">grp.default</code></td>
<td>
<p>If <code>grp.default</code> is <code>NULL</code>, use these group labels for segments
with NULL group.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_x">x</code></td>
<td>
<p>Mesh to extract segments from</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_boundary">boundary</code></td>
<td>
<p>logical; if <code>TRUE</code>, extract the boundary segments,
otherwise interior constrain segments.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_value">value</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_segm</code> or <code>fm_segm_list</code> object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_segm(fm_segm)</code>: Join multiple <code>fm_segm</code> objects into a single <code>fm_segm</code>
object. If <code>is.bnd</code> is non-NULL, it overrides the input segment information.
Otherwise, it checks if the inputs are consistent.
</p>
</li>
<li> <p><code>fm_segm(fm_segm_list)</code>: Join <code>fm_segm</code> objects from a <code>fm_segm_list</code> into
a single <code>fm_segm</code> object. Equivalent to <code>fm_segm_join(x)</code>
</p>
</li>
<li> <p><code>fm_segm(fm_mesh_2d)</code>: Extract the boundary or interior segments of a 2d mesh.
If <code>grp</code> is non-NULL, extracts only segments matching the matching the set
of groups given by <code>grp</code>.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_segm()</code>: Create a new <code>fm_segm</code> object.
</p>
</li>
<li> <p><code>fm_segm_join()</code>: Join multiple <code>fm_segm</code> objects into a single <code>fm_segm</code>
object. If <code>is.bnd</code> is non-NULL, it overrides the segment information.
Otherwise it checks for consistency.
</p>
</li>
<li> <p><code>fm_segm_split()</code>: Split an <code>fm_segm</code> object by <code>grp</code> into an <code>fm_segm_list</code>
object, optionally keeping only some groups.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_segm(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1)), is.bnd = FALSE)
fm_segm(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1)), is.bnd = TRUE)

fm_segm_join(fmexample$boundary_fm)

fm_segm(fmexample$mesh, boundary = TRUE)
fm_segm(fmexample$mesh, boundary = FALSE)

</code></pre>

<hr>
<h2 id='fm_segm_contour_helper'>Contour segment</h2><span id='topic+fm_segm_contour_helper'></span>

<h3>Description</h3>

<p>Helper from legacy <code>INLA::inla.contour.segment()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_segm_contour_helper(
  x = seq(0, 1, length.out = nrow(z)),
  y = seq(0, 1, length.out = ncol(z)),
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  groups = seq_len(length(levels)),
  positive = TRUE,
  eps = NULL,
  eps_rel = NULL,
  crs = NULL
)
</code></pre>


<h3>Value</h3>

<p>An <code>fm_segm</code> object
</p>


<h3>See Also</h3>

<p>Other nonconvex inla legacy support: 
<code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla</a>()</code>,
<code><a href="#topic+fm_simplify_helper">fm_simplify_helper</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_segm_contour_helper(z = matrix(1:16, 4, 4))

</code></pre>

<hr>
<h2 id='fm_segm_list'>Methods for fm_segm lists</h2><span id='topic+fm_segm_list'></span><span id='topic+c.fm_segm'></span><span id='topic+c.fm_segm_list'></span><span id='topic++5B.fm_segm_list'></span>

<h3>Description</h3>

<p><code>fm_segm</code> lists can be combined into <code>fm_segm_list</code> list objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_segm'
c(...)

## S3 method for class 'fm_segm_list'
c(...)

## S3 method for class 'fm_segm_list'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_segm_list_+3A_...">...</code></td>
<td>
<p>Objects to be combined.</p>
</td></tr>
<tr><td><code id="fm_segm_list_+3A_x">x</code></td>
<td>
<p><code>fm_segm_list</code> object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="fm_segm_list_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fm_segm_list</code> object
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>c(fm_segm_list)</code>: The <code>...</code> arguments should be coercible to <code>fm_segm_list</code>
objects.
</p>
</li>
<li> <p><code>[</code>: Extract sub-list
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>c(fm_segm)</code>: The <code>...</code> arguments should be <code>fm_segm</code>
objects, or coercible with <code>fm_as_segm_list(list(...))</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_as_segm_list">fm_as_segm_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- c(A = fm_segm(1:2), B = fm_segm(3:4))
str(m)
str(m[2])
</code></pre>

<hr>
<h2 id='fm_simplify'>Recursive curve simplification.</h2><span id='topic+fm_simplify'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Simplifies polygonal curve segments by joining nearly
co-linear segments.
</p>
<p>Uses a variation of the binary splitting Ramer-Douglas-Peucker algorithm,
with an ellipse of half-width <code>eps</code> ellipse instead of a rectangle, motivated by
prediction ellipse for Brownian bridge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_simplify(x, eps = NULL, eps_rel = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_simplify_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+fm_segm">fm_segm()</a></code> object.</p>
</td></tr>
<tr><td><code id="fm_simplify_+3A_eps">eps</code></td>
<td>
<p>Absolute straightness tolerance. Default <code>NULL</code>, no constraint.</p>
</td></tr>
<tr><td><code id="fm_simplify_+3A_eps_rel">eps_rel</code></td>
<td>
<p>Relative straightness tolerance. Default <code>NULL</code>, no constraint.</p>
</td></tr>
<tr><td><code id="fm_simplify_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variation of Ramer-Douglas-Peucker.
Uses width epsilon ellipse instead of rectangle,
motivated by prediction ellipse for Brownian bridge.
</p>


<h3>Value</h3>

<p>The simplified <code><a href="#topic+fm_segm">fm_segm()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>References</h3>

<p>Ramer, Urs (1972). &quot;An iterative procedure for the polygonal approximation
of plane curves&quot;. <em>Computer Graphics and Image Processing</em>. <strong>1</strong> (3): 244‚Äì256.
<a href="https://doi.org/10.1016/S0146-664X%2872%2980017-0">doi:10.1016/S0146-664X(72)80017-0</a>
</p>
<p>Douglas, David; Peucker, Thomas (1973). &quot;Algorithms for the reduction of
the number of points required to represent a digitized line or its
caricature&quot;. <em>The Canadian Cartographer</em>. <strong>10</strong> (2): 112‚Äì122.
<a href="https://doi.org/10.3138/FM57-6770-U75U-7727">doi:10.3138/FM57-6770-U75U-7727</a>
</p>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- seq(0, 2 * pi, length.out = 1000)
(segm &lt;- fm_segm(cbind(cos(theta), sin(theta)),
  idx = seq_along(theta)
))
(segm1 &lt;- fm_simplify(segm, eps_rel = 0.1))
(segm2 &lt;- fm_simplify(segm, eps_rel = 0.2))
plot(segm)
lines(segm1, col = 2)
lines(segm2, col = 3)

(segm &lt;- fm_segm(cbind(theta, sin(theta * 4)),
  idx = seq_along(theta)
))
(segm1 &lt;- fm_simplify(segm, eps_rel = 0.1))
(segm2 &lt;- fm_simplify(segm, eps_rel = 0.2))
plot(segm)
lines(segm1, col = 2)
lines(segm2, col = 3)
</code></pre>

<hr>
<h2 id='fm_simplify_helper'>Recursive curve simplification.</h2><span id='topic+fm_simplify_helper'></span>

<h3>Description</h3>

<p>Helper from legacy <code>INLA::inla.simplify.curve()</code>
</p>
<p>Attempts to simplify a polygonal curve by joining nearly colinear segments.
</p>
<p>Uses a variation of the binary splitting Ramer-Douglas-Peucker algorithm,
with an ellipse of half-width <code>eps</code> ellipse instead of a rectangle, motivated by
prediction ellipse for Brownian bridge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_simplify_helper(loc, idx, eps = NULL, eps_rel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_simplify_helper_+3A_loc">loc</code></td>
<td>
<p>Coordinate matrix.</p>
</td></tr>
<tr><td><code id="fm_simplify_helper_+3A_idx">idx</code></td>
<td>
<p>Index vector into <code>loc</code> specifying a polygonal curve.</p>
</td></tr>
<tr><td><code id="fm_simplify_helper_+3A_eps">eps</code></td>
<td>
<p>Absolute straightness tolerance. Default <code>NULL</code>, no constraint.</p>
</td></tr>
<tr><td><code id="fm_simplify_helper_+3A_eps_rel">eps_rel</code></td>
<td>
<p>Relative straightness tolerance. Default <code>NULL</code>, no constraint.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variation of Ramer-Douglas-Peucker.
Uses width epsilon ellipse instead of rectangle,
motivated by prediction ellipse for Brownian bridge.
</p>


<h3>Value</h3>

<p>An index vector into <code>loc</code> specifying the simplified polygonal
curve.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other nonconvex inla legacy support: 
<code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla</a>()</code>,
<code><a href="#topic+fm_segm_contour_helper">fm_segm_contour_helper</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
theta &lt;- seq(0, 2 * pi, length.out = 1000)
loc &lt;- cbind(cos(theta), sin(theta))
idx &lt;- fm_simplify_helper(loc = loc, idx = 1:nrow(loc), eps = 0.01)
print(c(nrow(loc), length(idx)))
plot(loc, type = "l")
lines(loc[idx, ], col = "red")
</code></pre>

<hr>
<h2 id='fm_split_lines'>Split lines at triangle edges</h2><span id='topic+fm_split_lines'></span><span id='topic+fm_split_lines.fm_mesh_2d'></span><span id='topic+fm_split_lines.inla.mesh'></span>

<h3>Description</h3>

<p>Compute intersections between line segments and triangle edges,
and filter out segment of length zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_split_lines(mesh, ...)

## S3 method for class 'fm_mesh_2d'
fm_split_lines(mesh, segm, ...)

## S3 method for class 'inla.mesh'
fm_split_lines(mesh, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_split_lines_+3A_mesh">mesh</code></td>
<td>
<p>An <code>fm_mesh_2d</code> or <code>inla.mesh</code> object</p>
</td></tr>
<tr><td><code id="fm_split_lines_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="fm_split_lines_+3A_segm">segm</code></td>
<td>
<p>An <code><a href="#topic+fm_segm">fm_segm()</a></code> object with segments to be split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+fm_segm">fm_segm()</a></code> object with the same crs as the mesh,
with an added field <code>origin</code>, that for each new segment gives the
originator index into to original <code>segm</code> object for each new line segment.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mesh &lt;- fm_mesh_2d(
  boundary = fm_segm(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1)), is.bnd = TRUE)
)
splitter &lt;- fm_segm(rbind(c(0.8, 0.2), c(0.2, 0.8)))
segm_split &lt;- fm_split_lines(mesh, splitter)

plot(mesh)
lines(splitter)
points(segm_split$loc)
</code></pre>

<hr>
<h2 id='fm_store_points'>Store points in different formats</h2><span id='topic+fm_store_points'></span>

<h3>Description</h3>

<p>Convert a matrix of points into different formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_store_points(loc, crs = NULL, info = NULL, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_store_points_+3A_loc">loc</code></td>
<td>
<p>a coordinate matrix</p>
</td></tr>
<tr><td><code id="fm_store_points_+3A_crs">crs</code></td>
<td>
<p>CRS information to associate with the coordinates</p>
</td></tr>
<tr><td><code id="fm_store_points_+3A_info">info</code></td>
<td>
<p>An optional data.frame of additional data</p>
</td></tr>
<tr><td><code id="fm_store_points_+3A_format">format</code></td>
<td>
<p>character; <code>"sf"</code>, <code>"df"</code>, <code>"sp"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code>, <code>data.frame</code>, or <code>SpatialPointsDataFrame</code> object, with
optional added information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_store_points(fmexample$loc, format = "sf")

</code></pre>

<hr>
<h2 id='fm_tensor'>Make a tensor product function space</h2><span id='topic+fm_tensor'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Tensor product function spaces. The interface and object storage model
is experimental and may change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_tensor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_tensor_+3A_x">x</code></td>
<td>
<p>list of function space objects, such as <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_tensor_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fm_tensor</code> or <code>fm_tensor_list</code> object
</p>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fm_tensor(list(
  space = fmexample$mesh,
  time = fm_mesh_1d(1:5)
))
m2 &lt;- fm_as_tensor(m)
m3 &lt;- fm_as_tensor_list(list(m, m))
c(fm_dof(m$fun_spaces$space) * fm_dof(m$fun_spaces$time), fm_dof(m))
str(fm_evaluator(m, loc = list(space = cbind(0, 0), time = 2.5)))
</code></pre>

<hr>
<h2 id='fm_transform'>Object coordinate transformation</h2><span id='topic+fm_transform'></span><span id='topic+fm_transform.default'></span><span id='topic+fm_transform.NULL'></span><span id='topic+fm_transform.matrix'></span><span id='topic+fm_transform.sf'></span><span id='topic+fm_transform.sfc'></span><span id='topic+fm_transform.sfg'></span><span id='topic+fm_transform.Spatial'></span><span id='topic+fm_transform.fm_mesh_2d'></span><span id='topic+fm_transform.fm_lattice_2d'></span><span id='topic+fm_transform.fm_segm'></span><span id='topic+fm_transform.fm_list'></span><span id='topic+fm_transform.inla.mesh'></span><span id='topic+fm_transform.inla.mesh.lattice'></span><span id='topic+fm_transform.inla.mesh.segment'></span>

<h3>Description</h3>

<p>Handle transformation of various inla objects according to coordinate
reference systems of <code>crs</code> (from <code>sf::st_crs()</code>), <code>fm_crs</code>, <code>sp::CRS</code> or
<code>INLA::inla.CRS</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_transform(x, crs, ...)

## Default S3 method:
fm_transform(x, crs, ..., crs0 = NULL)

## S3 method for class 'NULL'
fm_transform(x, crs, ...)

## S3 method for class 'matrix'
fm_transform(x, crs, ..., passthrough = FALSE, crs0 = NULL)

## S3 method for class 'sf'
fm_transform(x, crs, ..., passthrough = FALSE)

## S3 method for class 'sfc'
fm_transform(x, crs, ..., passthrough = FALSE)

## S3 method for class 'sfg'
fm_transform(x, crs, ..., passthrough = FALSE)

## S3 method for class 'Spatial'
fm_transform(x, crs, ..., passthrough = FALSE)

## S3 method for class 'fm_mesh_2d'
fm_transform(x, crs = fm_crs(x), ..., passthrough = FALSE, crs0 = fm_crs(x))

## S3 method for class 'fm_lattice_2d'
fm_transform(x, crs = fm_crs(x), ..., passthrough = FALSE, crs0 = fm_crs(x))

## S3 method for class 'fm_segm'
fm_transform(x, crs = fm_crs(x), ..., passthrough = FALSE, crs0 = fm_crs(x))

## S3 method for class 'fm_list'
fm_transform(x, crs, ...)

## S3 method for class 'inla.mesh'
fm_transform(x, crs = fm_crs(x), ...)

## S3 method for class 'inla.mesh.lattice'
fm_transform(x, crs, ...)

## S3 method for class 'inla.mesh.segment'
fm_transform(x, crs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_transform_+3A_x">x</code></td>
<td>
<p>The object that should be transformed from it's current CRS to a new CRS</p>
</td></tr>
<tr><td><code id="fm_transform_+3A_crs">crs</code></td>
<td>
<p>The target crs object</p>
</td></tr>
<tr><td><code id="fm_transform_+3A_...">...</code></td>
<td>
<p>Potential additional arguments</p>
</td></tr>
<tr><td><code id="fm_transform_+3A_crs0">crs0</code></td>
<td>
<p>The source crs object for spatial classes without crs information</p>
</td></tr>
<tr><td><code id="fm_transform_+3A_passthrough">passthrough</code></td>
<td>
<p>Default is FALSE.
Setting to TRUE allows objects with no CRS information to be passed
through without transformation. Use with care!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transformed object, normally of the same class as
the input object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_CRS">fm_CRS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_transform(
  rbind(c(0, 0), c(0, 90)),
  crs = fm_crs("sphere"),
  crs0 = fm_crs("longlat_norm")
)

</code></pre>

<hr>
<h2 id='fm_unify_coords'>Unify coordinates to 3-column matrix</h2><span id='topic+fm_unify_coords'></span><span id='topic+fm_unify_coords.NULL'></span><span id='topic+fm_unify_coords.default'></span><span id='topic+fm_unify_coords.Spatial'></span><span id='topic+fm_unify_coords.sf'></span><span id='topic+fm_unify_coords.sfc'></span>

<h3>Description</h3>

<p>Convert coordinate information to a 3-column matrix.
This is mainly an internal function, and the interface may change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_unify_coords(x, crs = NULL)

## S3 method for class 'NULL'
fm_unify_coords(x, crs = NULL)

## Default S3 method:
fm_unify_coords(x, crs = NULL)

## S3 method for class 'Spatial'
fm_unify_coords(x, crs = NULL)

## S3 method for class 'sf'
fm_unify_coords(x, crs = NULL)

## S3 method for class 'sf'
fm_unify_coords(x, crs = NULL)

## S3 method for class 'sfc'
fm_unify_coords(x, crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_unify_coords_+3A_x">x</code></td>
<td>
<p>A object with coordinate information</p>
</td></tr>
<tr><td><code id="fm_unify_coords_+3A_crs">crs</code></td>
<td>
<p>A optional crs object to convert the coordinates to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A coordinate matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_unify_coords(fmexample$loc_sf)

</code></pre>

<hr>
<h2 id='fm_vertex_projection'>Project integration points to mesh vertices</h2><span id='topic+fm_vertex_projection'></span>

<h3>Description</h3>

<p>Compute information for assigning points to the vertices of the covering triangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_vertex_projection(points, mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_vertex_projection_+3A_points">points</code></td>
<td>
<p>A <code>SpatialPointsDataFrame</code>, <code>sf</code>, or <code>list</code> object</p>
</td></tr>
<tr><td><code id="fm_vertex_projection_+3A_mesh">mesh</code></td>
<td>
<p>An <code>fm_mesh_2d</code> or <code>inla.mesh</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatialPointsDataFrame</code>, <code>sf</code>, or <code>list</code> of mesh vertices with
projected data attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(fm_vertex_projection(list(loc = fmexample$loc), fmexample$mesh))
head(fm_vertex_projection(fmexample$loc_sf, fmexample$mesh))

</code></pre>

<hr>
<h2 id='fm_vertices'>Extract vertex locations from an <code>fm_mesh_2d</code></h2><span id='topic+fm_vertices'></span>

<h3>Description</h3>

<p>Extracts the vertices of an <code>fm_mesh_2d</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_vertices(x, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_vertices_+3A_x">x</code></td>
<td>
<p>An <code>fm_mesh_2d</code> object.</p>
</td></tr>
<tr><td><code id="fm_vertices_+3A_format">format</code></td>
<td>
<p>character; <code>"sf"</code>, <code>"df"</code>, <code>"sp"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code>, <code>data.frame</code>, or <code>SpatialPointsDataFrame</code> object, with the vertex
coordinates, and a <code>.vertex</code> column with the vertex indices.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_centroids">fm_centroids()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE)) {
  vrt &lt;- fm_vertices(fmexample$mesh, format = "sf")
  ggplot() +
    geom_sf(data = fm_as_sfc(fmexample$mesh)) +
    geom_sf(data = vrt, color = "red")
}

</code></pre>

<hr>
<h2 id='fm_wkt_as_wkt_tree'>Internal WKT handling</h2><span id='topic+fm_wkt_as_wkt_tree'></span><span id='topic+fm_wkt_tree_as_wkt'></span><span id='topic+fm_wkt_tree_get_item'></span><span id='topic+fm_wkt_tree_set_item'></span>

<h3>Description</h3>

<p>Conversion between WKT and a tree representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_wkt_as_wkt_tree(x, ...)

fm_wkt_tree_as_wkt(x, pretty = FALSE, ...)

fm_wkt_tree_get_item(x, item, duplicate = 1)

fm_wkt_tree_set_item(x, item_tree, duplicate = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_x">x</code></td>
<td>
<p>A WKT2 string, or a <code>wkt_tree</code> list structure</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_pretty">pretty</code></td>
<td>
<p>logical; If TRUE, use pretty formatting. Default: FALSE</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_item">item</code></td>
<td>
<p>character vector with item labels identifying a parameter item
entry.</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_duplicate">duplicate</code></td>
<td>
<p>For items that have more than one match, <code>duplicate</code>
indicates the index number of the desired version. Default: 1</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_item_tree">item_tree</code></td>
<td>
<p>An item tree identifying a parameter item entry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A hierarchical list, describing WKT information as a tree
</p>
<p><code>fm_wkt_tree_as_wkt</code> character; the WKT corresponding to the tree.
</p>
<p><code>fm_wkt_tree_get_item</code> returns the value of an item found in the tree
</p>
<p><code>fm_wkt_tree_set_item</code> returns the modified tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_wkt_as_wkt_tree(fm_crs("longlat_norm")$wkt))

</code></pre>

<hr>
<h2 id='fmesher_bary'>Barycentric coordinate computation</h2><span id='topic+fmesher_bary'></span>

<h3>Description</h3>

<p>Locate points and compute triangular barycentric coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_bary(mesh_loc, mesh_tv, loc, options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmesher_bary_+3A_mesh_loc">mesh_loc</code></td>
<td>
<p>numeric matrix; mesh vertex coordinates</p>
</td></tr>
<tr><td><code id="fmesher_bary_+3A_mesh_tv">mesh_tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_bary_+3A_loc">loc</code></td>
<td>
<p>numeric matrix; coordinates of points to locate in the mesh</p>
</td></tr>
<tr><td><code id="fmesher_bary_+3A_options">options</code></td>
<td>
<p>list of triangulation options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with vector <code>t</code> and matrix <code>bary</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fmesher_rcdt(list(cet_margin = 1), matrix(0, 1, 2))
b &lt;- fmesher_bary(m$s,
                  m$tv,
                  matrix(c(0.5, 0.5), 1, 2),
                  list())
</code></pre>

<hr>
<h2 id='fmesher_fem'>Finite element matrix computation</h2><span id='topic+fmesher_fem'></span>

<h3>Description</h3>

<p>Construct finite element structure matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_fem(mesh_loc, mesh_tv, fem_order_max, aniso, options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmesher_fem_+3A_mesh_loc">mesh_loc</code></td>
<td>
<p>numeric matrix; mesh vertex coordinates</p>
</td></tr>
<tr><td><code id="fmesher_fem_+3A_mesh_tv">mesh_tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_fem_+3A_fem_order_max">fem_order_max</code></td>
<td>
<p>integer; the highest operator order to compute</p>
</td></tr>
<tr><td><code id="fmesher_fem_+3A_aniso">aniso</code></td>
<td>
<p>If non-NULL, a <code>list(gamma, v)</code>. Calculates anisotropic structure
matrices (in addition to the regular) for <code class="reqn">\gamma</code> and <code class="reqn">v</code> for
an anisotropic operator <code class="reqn">\nabla\cdot H \nabla</code>, where
<code class="reqn">H=\gamma I + v v^\top</code>.
Currently (2023-08-05) the fields need to be given per vertex.</p>
</td></tr>
<tr><td><code id="fmesher_fem_+3A_options">options</code></td>
<td>
<p>list of triangulation options (<code>sphere_tolerance</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fmesher_rcdt(list(cet_margin = 1), matrix(0, 1, 2))
b &lt;- fmesher_fem(m$s, m$tv, fem_order_max = 2, aniso = NULL, options = list())
</code></pre>

<hr>
<h2 id='fmesher_globe_points'>Globe points</h2><span id='topic+fmesher_globe_points'></span>

<h3>Description</h3>

<p>Create points on a globe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_globe_points(globe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmesher_globe_points_+3A_globe">globe</code></td>
<td>
<p>integer; the number of edge subdivision segments, 1 or higher.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of points on a unit radius globe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fmesher_globe_points(1)
</code></pre>

<hr>
<h2 id='fmesher_rcdt'>Refined Constrained Delaunay Triangulation</h2><span id='topic+fmesher_rcdt'></span>

<h3>Description</h3>

<p>(...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_rcdt(
  options,
  loc,
  tv = NULL,
  boundary = NULL,
  interior = NULL,
  boundary_grp = NULL,
  interior_grp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmesher_rcdt_+3A_options">options</code></td>
<td>
<p>list of triangulation options</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_loc">loc</code></td>
<td>
<p>numeric matrix; initial points to include</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_tv">tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_boundary">boundary</code></td>
<td>
<p>2-column integer matrix with 0-based vertex indices for each
boundary edge constraint</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_interior">interior</code></td>
<td>
<p>2-column integer matrix with 0-based vertex indices for each
interior edge constraint</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_boundary_grp">boundary_grp</code></td>
<td>
<p>integer vector with group labels</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_interior_grp">interior_grp</code></td>
<td>
<p>integer vector with group labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of information objects for a generated triangulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fmesher_rcdt(list(cet_margin = 1), matrix(0, 1, 2))
</code></pre>

<hr>
<h2 id='fmesher_spherical_bsplines1'>Rotationally invariant spherical B-splines</h2><span id='topic+fmesher_spherical_bsplines1'></span><span id='topic+fmesher_spherical_bsplines'></span>

<h3>Description</h3>

<p>Compute rotationally invariant spherical B-splines on the unit sphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_spherical_bsplines1(loc, n, degree, uniform)

fmesher_spherical_bsplines(loc, n, degree, uniform)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmesher_spherical_bsplines1_+3A_loc">loc</code></td>
<td>
<p>numeric vector/matrix; coordinates of points to locate in the mesh,
only the z-coordinates are used (<code>sin(latitude)</code>)</p>
</td></tr>
<tr><td><code id="fmesher_spherical_bsplines1_+3A_n">n</code></td>
<td>
<p>The number of basis functions</p>
</td></tr>
<tr><td><code id="fmesher_spherical_bsplines1_+3A_degree">degree</code></td>
<td>
<p>The polynomial basis degree</p>
</td></tr>
<tr><td><code id="fmesher_spherical_bsplines1_+3A_uniform">uniform</code></td>
<td>
<p>logical; If <code>TRUE</code>, the knots are spaced uniformly by latitude,
if <code>FALSE</code>, the knots are spaced uniformly by <code>sin(latitude)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of evaluated b-spline basis functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fm_rcdt_2d(globe = 1)
fmesher_spherical_bsplines(m$loc, n = 3, degree = 2, uniform = FALSE)
fmesher_spherical_bsplines1(m$loc[, 3], n = 3, degree = 2, uniform = FALSE)
</code></pre>

<hr>
<h2 id='fmesher_split_lines'>Split lines at triangle edges</h2><span id='topic+fmesher_split_lines'></span>

<h3>Description</h3>

<p>Split a sequence of line segments at triangle edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_split_lines(mesh_loc, mesh_tv, loc, idx, options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmesher_split_lines_+3A_mesh_loc">mesh_loc</code></td>
<td>
<p>numeric matrix; mesh vertex coordinates</p>
</td></tr>
<tr><td><code id="fmesher_split_lines_+3A_mesh_tv">mesh_tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_split_lines_+3A_loc">loc</code></td>
<td>
<p>numeric coordinate matrix</p>
</td></tr>
<tr><td><code id="fmesher_split_lines_+3A_idx">idx</code></td>
<td>
<p>2-column integer matrix</p>
</td></tr>
<tr><td><code id="fmesher_split_lines_+3A_options">options</code></td>
<td>
<p>list of triangulation options (<code>sphere_tolerance</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of line splitting information objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_split_lines">fm_split_lines()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mesh &lt;- fm_mesh_2d(
  boundary = fm_segm(rbind(c(0,0), c(1,0), c(1,1), c(0, 1)), is.bnd = TRUE)
)
splitter &lt;- fm_segm(rbind(c(0.8, 0.2), c(0.2, 0.8)))
segm_split &lt;- fm_split_lines(mesh, splitter)
</code></pre>

<hr>
<h2 id='fmesher-deprecated'>Deprecated functions in fmesher</h2><span id='topic+fmesher-deprecated'></span><span id='topic+fm_spTransform'></span><span id='topic+fm_spTransform.default'></span><span id='topic+fm_spTransform.SpatialPoints'></span><span id='topic+fm_spTransform.SpatialPointsDataFrame'></span><span id='topic+fm_spTransform.inla.mesh.lattice'></span><span id='topic+fm_spTransform.inla.mesh.segment'></span><span id='topic+fm_spTransform.inla.mesh'></span><span id='topic+fm_has_PROJ6'></span><span id='topic+fm_not_for_PROJ6'></span><span id='topic+fm_not_for_PROJ4'></span><span id='topic+fm_fallback_PROJ6'></span><span id='topic+fm_requires_PROJ6'></span><span id='topic+fm_as_sp_crs'></span><span id='topic+fm_sp_get_crs'></span><span id='topic+fm_as_inla_mesh_segment'></span><span id='topic+fm_as_inla_mesh'></span><span id='topic+fm_sp2segment'></span>

<h3>Description</h3>

<p>These functions still attempt to do their job, but will be removed in a
future version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_spTransform(x, ...)

## Default S3 method:
fm_spTransform(x, crs0 = NULL, crs1 = NULL, passthrough = FALSE, ...)

## S3 method for class 'SpatialPoints'
fm_spTransform(x, CRSobj, passthrough = FALSE, ...)

## S3 method for class 'SpatialPointsDataFrame'
fm_spTransform(x, CRSobj, passthrough = FALSE, ...)

## S3 method for class 'inla.mesh.lattice'
fm_spTransform(x, CRSobj, passthrough = FALSE, ...)

## S3 method for class 'inla.mesh.segment'
fm_spTransform(x, CRSobj, passthrough = FALSE, ...)

## S3 method for class 'inla.mesh'
fm_spTransform(x, CRSobj, passthrough = FALSE, ...)

fm_has_PROJ6()

fm_not_for_PROJ6(fun = NULL)

fm_not_for_PROJ4(fun = NULL)

fm_fallback_PROJ6(fun = NULL)

fm_requires_PROJ6(fun = NULL)

fm_as_sp_crs(x, ...)

fm_sp_get_crs(x)

fm_as_inla_mesh_segment(...)

fm_as_inla_mesh(...)

fm_sp2segment(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmesher-deprecated_+3A_x">x</code></td>
<td>
<p>A <code>sp::Spatial</code> object</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_...">...</code></td>
<td>
<p>Potential additional arguments</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_crs0">crs0</code></td>
<td>
<p>The source sp::CRS or inla.CRS object</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_crs1">crs1</code></td>
<td>
<p>The target sp::CRS or inla.CRS object</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_passthrough">passthrough</code></td>
<td>
<p>Default is FALSE.
Setting to TRUE allows objects with no CRS information to be passed
through without transformation.</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_crsobj">CRSobj</code></td>
<td>
<p>The target sp::CRS or inla.CRS object</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_fun">fun</code></td>
<td>
<p>The name of the function that requires PROJ6. Default: NULL,
which uses the name of the calling function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience method to workaround PROJ4/PROJ6
differences, and the lack of a crs extraction method for Spatial objects.
For newer code, use <code><a href="#topic+fm_crs">fm_crs()</a></code> instead, that returns <code>crs</code> objects,
and use <a href="#topic+fm_crs">fm_CRS()</a> to extract/construct/convert to old style <code>sp::CRS</code> objects.
</p>


<h3>Value</h3>

<p>A <code>CRS</code> object, or NULL if no valid CRS identified
</p>
<p>An <code>fm_segm</code> object
</p>
<p>An <code>fm_mesh_2d</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_spTransform()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> (See <code><a href="#topic+fm_transform">fm_transform()</a></code> instead)
Handle transformation of various inla objects according to coordinate
reference systems of <code>sp::CRS</code> or <code>INLA::inla.CRS</code> class.
</p>
</li>
<li> <p><code>fm_spTransform(default)</code>: The default method handles low level transformation of raw
coordinates.
</p>
</li>
<li> <p><code>fm_has_PROJ6()</code>: Detect whether PROJ6 is available
</p>
</li>
<li> <p><code>fm_not_for_PROJ6()</code>: <code>fm_not_for_PROJ6</code> is called to warn about using old PROJ4
features even though PROJ6 is available
</p>
</li>
<li> <p><code>fm_not_for_PROJ4()</code>: <code>fm_not_for_PROJ4</code> is called to give an error when
calling methods that are only available for PROJ6
</p>
</li>
<li> <p><code>fm_fallback_PROJ6()</code>: Called to warn about falling back
to using old PROJ4 methods when a PROJ6 method hasn't been implemented
</p>
</li>
<li> <p><code>fm_requires_PROJ6()</code>: Called to give an error when PROJ6
is required but not available
</p>
</li>
<li> <p><code>fm_as_sp_crs()</code>: Wrapper for <code><a href="#topic+fm_CRS">fm_CRS()</a></code>
<code>sp::Spatial</code> and <code>sp::CRS</code> objects.
</p>
</li>
<li> <p><code>fm_sp_get_crs()</code>: Wrapper for CRS(projargs) (PROJ4) and CRS(wkt) for
<code>sp::Spatial</code> objects.
</p>
</li>
<li> <p><code>fm_as_inla_mesh_segment()</code>: Conversion to inla.mesh.segment
<a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour of <code><a href="#topic+fm_as_segm">fm_as_segm()</a></code>.
</p>
</li>
<li> <p><code>fm_as_inla_mesh()</code>: Conversion to inla.mesh.
<a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour of <code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d()</a></code>.
</p>
</li>
<li> <p><code>fm_sp2segment()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour of
<code><a href="#topic+fm_as_segm">fm_as_segm()</a></code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_transform">fm_transform()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (fm_safe_sp()) {
  s &lt;- sp::SpatialPoints(matrix(1:6, 3, 2), proj4string = fm_CRS("sphere"))
  fm_CRS(s)
}
</code></pre>

<hr>
<h2 id='fmesher-print'>Print objects</h2><span id='topic+fmesher-print'></span><span id='topic+print.fm_segm'></span><span id='topic+print.fm_segm_list'></span><span id='topic+print.fm_mesh_2d'></span><span id='topic+print.fm_mesh_1d'></span><span id='topic+print.fm_bbox'></span><span id='topic+print.fm_crs'></span><span id='topic+print.fm_CRS'></span>

<h3>Description</h3>

<p>Print objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_segm'
print(x, ..., digits = NULL, verbose = TRUE, newline = TRUE)

## S3 method for class 'fm_segm_list'
print(x, ..., digits = NULL, verbose = FALSE, newline = TRUE)

## S3 method for class 'fm_mesh_2d'
print(x, ..., digits = NULL, verbose = FALSE)

## S3 method for class 'fm_mesh_1d'
print(x, ..., digits = NULL, verbose = FALSE)

## S3 method for class 'fm_bbox'
print(x, ..., digits = NULL, verbose = TRUE, newline = TRUE)

## S3 method for class 'fm_crs'
print(x, ...)

## S3 method for class 'fm_CRS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmesher-print_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="fmesher-print_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="fmesher-print_+3A_digits">digits</code></td>
<td>
<p>a positive integer indicating how many significant digits are
to be used for numeric and complex x. The default, NULL, uses <code>getOption("digits")</code>.</p>
</td></tr>
<tr><td><code id="fmesher-print_+3A_verbose">verbose</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="fmesher-print_+3A_newline">newline</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), end the printing with <code style="white-space: pre;">&#8288;\n&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_bbox(matrix(1:6, 3, 2))
print(fm_bbox(matrix(1:6, 3, 2)), verbose = FALSE)

print(fmexample$mesh)
print(fmexample$boundary_fm)

print(fm_mesh_1d(c(1, 2, 3, 5, 7), degree = 2))
</code></pre>

<hr>
<h2 id='fmexample'>Example mesh data</h2><span id='topic+fmexample'></span>

<h3>Description</h3>

<p>This is an example data set used for <code>fmesher</code> package examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmexample
</code></pre>


<h3>Format</h3>

<p>The data is a list containing these elements:
</p>

<dl>
<dt><code>loc</code>:</dt><dd><p> A <code>matrix</code> of points.</p>
</dd>
<dt><code>loc_sf</code>:</dt><dd><p> An <code>sfc</code> version of <code>loc</code>.</p>
</dd>
<dt><code>loc_sp</code>:</dt><dd><p> A <code>SpatialPoints</code> version of <code>loc</code>.</p>
</dd>
<dt><code>boundary_fm</code>:</dt><dd><p> A <code>fm_segm_list</code> of two <code>fm_segm</code> objects used in the mesh construction.</p>
</dd>
<dt><code>boundary_sf</code>:</dt><dd><p> An <code>sfc</code> list version of <code>boundary</code>.</p>
</dd>
<dt><code>boundary_sp</code>:</dt><dd><p> An <code>SpatialPolygons</code> list version of <code>boundary</code>.</p>
</dd>
<dt><code>mesh</code>:</dt><dd><p> An <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Generated by <code>data-raw/fmexample.R</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(ggplot2, quietly = TRUE)) {
  ggplot() +
    geom_sf(data = fm_as_sfc(fmexample$mesh)) +
    geom_sf(data = fmexample$boundary_sf[[1]], fill = "red", alpha = 0.5)
}
</code></pre>

<hr>
<h2 id='geom_fm'>ggplot2 geomes for fmesher related objects</h2><span id='topic+geom_fm'></span><span id='topic+geom_fm.fm_mesh_2d'></span><span id='topic+geom_fm.fm_segm'></span><span id='topic+geom_fm.fm_mesh_1d'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>geom_fm</code> is a generic function for generating geomes from various kinds of
<code>fmesher</code> objects, e.g. <code>fm_segm</code> and <code>fm_mesh_2d</code>.
The function invokes particular methods which depend
on the <a href="base.html#topic+class">class</a> of the <code>data</code> argument.
Requires the <code>ggplot2</code> package.
</p>
<p>Note: <code>geom_fm</code> is not yet a &quot;proper&quot; <code>ggplot2</code> geom method; the interface
may therefore change in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_fm(mapping = NULL, data = NULL, ...)

## S3 method for class 'fm_mesh_2d'
geom_fm(
  mapping = NULL,
  data = NULL,
  mapping_int = NULL,
  mapping_bnd = NULL,
  defs_int = NULL,
  defs_bnd = NULL,
  ...,
  crs = NULL
)

## S3 method for class 'fm_segm'
geom_fm(mapping = NULL, data = NULL, ..., crs = NULL)

## S3 method for class 'fm_mesh_1d'
geom_fm(
  mapping = NULL,
  data = NULL,
  ...,
  xlim = NULL,
  basis = TRUE,
  knots = TRUE,
  derivatives = FALSE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_fm_+3A_mapping">mapping</code></td>
<td>
<p>an object for which to generate a geom.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_data">data</code></td>
<td>
<p>an object for which to generate a geom.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the geom method.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_mapping_int">mapping_int</code></td>
<td>
<p><code>aes</code> for interior constraint edges.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_mapping_bnd">mapping_bnd</code></td>
<td>
<p><code>aes</code> for boundary edges.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_defs_int">defs_int</code></td>
<td>
<p>additional settings for interior constraint edges.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_defs_bnd">defs_bnd</code></td>
<td>
<p>additional settings for boundary edges.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_crs">crs</code></td>
<td>
<p>Optional crs to transform the object to before plotting.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_xlim">xlim</code></td>
<td>
<p>numeric 2-vector; specifies the interval for which to compute
functions. Default is <code>data$interval</code></p>
</td></tr>
<tr><td><code id="geom_fm_+3A_basis">basis</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), show the spline basis functions</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_knots">knots</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), show the spline knot locations</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_derivatives">derivatives</code></td>
<td>
<p>logical; if <code>TRUE</code> (not default), draw first order
derivatives instead of function values</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_weights">weights</code></td>
<td>
<p>numeric vector; if provided, draw weighted basis functions and
the resulting weighted sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combination of <code>ggplot2</code> geoms.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>geom_fm(fm_mesh_2d)</code>: Converts an <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object to <code>sf</code> with <code><a href="#topic+fm_as_sfc">fm_as_sfc()</a></code> and uses
<code>geom_sf</code> to visualize the triangles and edges.
</p>
</li>
<li> <p><code>geom_fm(fm_segm)</code>: Converts an <code><a href="#topic+fm_segm">fm_segm()</a></code> object to <code>sf</code> with <code><a href="#topic+fm_as_sfc">fm_as_sfc()</a></code> and uses
<code>geom_sf</code> to visualize it.
</p>
</li>
<li> <p><code>geom_fm(fm_mesh_1d)</code>: Evaluates and plots the basis functions defined by an <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> object.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
ggplot() +
  geom_fm(data = fmexample$mesh)


m &lt;- fm_mesh_2d(
  cbind(10, 20),
  boundary = fm_extensions(cbind(10, 20), c(25, 65)),
  max.edge = c(4, 10),
  crs = fm_crs("+proj=longlat")
)
ggplot() +
  geom_fm(data = m)
ggplot() +
  geom_fm(data = m, crs = fm_crs("epsg:27700"))

# Compute a mesh vertex based function on a different grid
px &lt;- fm_pixels(fm_transform(m, fm_crs("mollweide_globe")))
px$fun &lt;- fm_evaluate(m,
  loc = px,
  field = sin(m$loc[, 1] / 5) * sin(m$loc[, 2] / 5)
)
ggplot() +
  geom_tile(aes(geometry = geometry, fill = fun),
    data = px,
    stat = "sf_coordinates"
  ) +
  geom_fm(
    data = m, alpha = 0.2, linewidth = 0.05,
    crs = fm_crs("mollweide_globe")
  )



m &lt;- fm_mesh_1d(c(1, 2, 4, 6, 10), boundary = c("n", "d"), degree = 2)
ggplot() +
  geom_fm(data = m, weights = c(4, 2, 4, -1))


m &lt;- fm_mesh_1d(
  c(1, 2, 3, 5, 7),
  boundary = c("dirichlet", "neumann"),
  degree = 2
)
ggplot() +
  geom_fm(data = m)

</code></pre>

<hr>
<h2 id='globeproj'>Old globe projection methods</h2><span id='topic+globeproj'></span><span id='topic+old_globeproj'></span><span id='topic+.globeproj.types'></span><span id='topic+old_outline'></span><span id='topic+outline'></span><span id='topic+old_graticule'></span><span id='topic+graticule'></span><span id='topic+old_tissot'></span><span id='topic+tissot'></span><span id='topic+old_limits'></span><span id='topic+limits'></span><span id='topic+old_project'></span><span id='topic+project'></span>

<h3>Description</h3>

<p>Deprecated globe projection methods that may be removed in the
future
</p>


<h3>Usage</h3>

<pre><code class='language-R'>old_globeproj(
  type = NULL,
  orient = NULL,
  xlim = NULL,
  ylim = NULL,
  scale = NULL
)

.globeproj.types(x, ...)

old_outline(x, add = FALSE, do.plot = TRUE, ...)

old_graticule(x, n = c(24, 12), add = FALSE, do.plot = TRUE, ...)

old_tissot(x, n = c(12, 6), add = FALSE, do.plot = TRUE, ...)

old_limits(x, loc = NULL, ...)

old_project(x, loc, inverse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="globeproj_+3A_type">type</code></td>
<td>
<p>Projection type, see <code><a href="#topic+.globeproj.types">.globeproj.types()</a></code></p>
</td></tr>
<tr><td><code id="globeproj_+3A_orient">orient</code></td>
<td>
<p>long,lat,rotation</p>
</td></tr>
<tr><td><code id="globeproj_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits</p>
</td></tr>
<tr><td><code id="globeproj_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="globeproj_+3A_scale">scale</code></td>
<td>
<p>x- and y- scaling factors</p>
</td></tr>
<tr><td><code id="globeproj_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+globeproj">globeproj</a> object</p>
</td></tr>
<tr><td><code id="globeproj_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to other methods</p>
</td></tr>
<tr><td><code id="globeproj_+3A_add">add</code></td>
<td>
<p>logical; If TRUE, add to existing plot</p>
</td></tr>
<tr><td><code id="globeproj_+3A_do.plot">do.plot</code></td>
<td>
<p>logical; If TRUE, do plotting</p>
</td></tr>
<tr><td><code id="globeproj_+3A_n">n</code></td>
<td>
<p>The number of Tissot indicatrices (n-long, n-lat) to compute</p>
</td></tr>
<tr><td><code id="globeproj_+3A_loc">loc</code></td>
<td>
<p>Coordinates to be mapped.</p>
</td></tr>
<tr><td><code id="globeproj_+3A_inverse">inverse</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of names of available projection types; &quot;longlat&quot;,
&quot;mollweide&quot;, &quot;hammer&quot;, &quot;orthocyl&quot;, &quot;lambert&quot;, &quot;gall-peters&quot;
</p>
<p>A
</p>
<p>A
</p>
<p>A
</p>
<p>A list:
</p>
<table>
<tr><td><code>xlim</code></td>
<td>
<p>X axis limits in the map domain</p>
</td></tr>
<tr><td><code>ylim</code></td>
<td>
<p>Y axis limits in the map domain</p>
</td></tr>
</table>
<p>B
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>.globeproj.types()</code>: Types of globe projections
</p>
</li>
<li> <p><code>old_limits()</code>: Calculates projection axis limits
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old_globeproj("mollweide")

</code></pre>

<hr>
<h2 id='local_testthat'>Unit test helpers</h2><span id='topic+local_testthat'></span><span id='topic+local_fm_testthat_assign'></span><span id='topic+local_fm_testthat_tolerances'></span><span id='topic+local_fm_testthat_setup'></span>

<h3>Description</h3>

<p>Local helper functions for package unit tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_fm_testthat_assign(x, values, envir = parent.frame())

local_fm_testthat_tolerances(
  tolerances = c(1e-04, 0.01, 0.1),
  envir = parent.frame()
)

local_fm_testthat_setup(envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_testthat_+3A_x">x</code></td>
<td>
<p>character; Name of variable to assign to</p>
</td></tr>
<tr><td><code id="local_testthat_+3A_values">values</code></td>
<td>
<p>the object to assign to <code>x</code></p>
</td></tr>
<tr><td><code id="local_testthat_+3A_envir">envir</code></td>
<td>
<p>environment for exit handlers</p>
</td></tr>
<tr><td><code id="local_testthat_+3A_tolerances">tolerances</code></td>
<td>
<p>numeric vector of length 3; <code style="white-space: pre;">&#8288;[lowtol, midtol, hitol]&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>local_fm_testthat_assign()</code>: Assign local variable. Useful for easy cleanup
of global workspace with <code>withr::deferred_run()</code> when running tests
interactively.
</p>
</li>
<li> <p><code>local_fm_testthat_tolerances()</code>: Assign test tolerances
Assign local tolerance variables. Useful for easy cleanup
of global workspace with <code>withr::deferred_run()</code> when running tests
interactively.
</p>
</li>
<li> <p><code>local_fm_testthat_setup()</code>: Initialise environment for tests.
To be called either at the top of a testfile, or inside tests.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>outer_fun &lt;- function() {
  fun &lt;- function(envir = parent.frame()) {
    local_fm_testthat_assign("local_var_name", 1:4, envir = envir)
  }
  fun()
  local_var_name
}
exists("local_var_name")
outer_fun()
exists("local_var_name")

</code></pre>

<hr>
<h2 id='plot_globeproj'>Plot a globeproj object</h2><span id='topic+plot_globeproj'></span>

<h3>Description</h3>

<p>Plot a globeproj object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_globeproj(
  x,
  xlim = NULL,
  ylim = NULL,
  outline = TRUE,
  graticule = c(24, 12),
  tissot = c(12, 6),
  asp = 1,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_globeproj_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+globeproj">globeproj</a> object</p>
</td></tr>
<tr><td><code id="plot_globeproj_+3A_xlim">xlim</code>, <code id="plot_globeproj_+3A_ylim">ylim</code></td>
<td>
<p>The x- and y-axis limits</p>
</td></tr>
<tr><td><code id="plot_globeproj_+3A_outline">outline</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="plot_globeproj_+3A_graticule">graticule</code></td>
<td>
<p>The number of graticules (n-long, n-lat) to compute</p>
</td></tr>
<tr><td><code id="plot_globeproj_+3A_tissot">tissot</code></td>
<td>
<p>The number of Tissot indicatrices (n-long, n-lat) to compute</p>
</td></tr>
<tr><td><code id="plot_globeproj_+3A_asp">asp</code></td>
<td>
<p>the aspect ratio. Default = 1</p>
</td></tr>
<tr><td><code id="plot_globeproj_+3A_add">add</code></td>
<td>
<p>logical; If <code>TRUE</code>, add to existing plot. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot_globeproj_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proj &lt;- old_globeproj("moll", orient = c(0, 0, 45))
plot_globeproj(proj, graticule = c(24, 12), add = FALSE, asp = 1, lty = 2, lwd = 0.5)
</code></pre>

<hr>
<h2 id='plot_PolySet'>Plot a projected PolySet</h2><span id='topic+plot_PolySet'></span>

<h3>Description</h3>

<p>Plot a projected PolySet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_PolySet(x, projection, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_PolySet_+3A_x">x</code></td>
<td>
<p>A PolySet (see <code>PBSmapping</code>)</p>
</td></tr>
<tr><td><code id="plot_PolySet_+3A_projection">projection</code></td>
<td>
<p>a <code>globeproj</code> objcet</p>
</td></tr>
<tr><td><code id="plot_PolySet_+3A_add">add</code></td>
<td>
<p>logical; If TRUE, add to existing plot</p>
</td></tr>
<tr><td><code id="plot_PolySet_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to <code>sp::plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a legacy method for plotting data from the
<code>PBSmapping</code> package, with
</p>
<div class="sourceCode"><pre>data(worldLL, package = "PBSmapping")
plot_PolySet(worldLL, old_globeproj("longlat"), add = FALSE)
</pre></div>
<p>To avoid a dependency on the <code>PBSmapping</code> package, the example below
constructs a synthetic object of the same format.
</p>


<h3>Value</h3>

<p>An (invisible) <code>sp</code> object of projected lines
</p>


<h3>See Also</h3>

<p><code><a href="#topic+old_globeproj">old_globeproj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>world_example &lt;- data.frame(
  PID = c(0L, 0L, 0L, 1L, 1L),
  POS = c(1L, 2L, 3L, 1L, 2L),
  X = c(10, 20, 30, 15, 25),
  Y = c(10, 15, 70, -40, -50)
)
plot_PolySet(world_example, old_globeproj("longlat"), add = FALSE)
</code></pre>

<hr>
<h2 id='plot_rgl'>Low level triangulation mesh plotting</h2><span id='topic+plot_rgl'></span><span id='topic+lines_rgl'></span><span id='topic+lines_rgl.fm_segm'></span><span id='topic+plot_rgl.fm_mesh_2d'></span><span id='topic+plot_rgl.fm_segm'></span><span id='topic+plot_rgl.fm_segm_list'></span><span id='topic+lines_rgl.fm_segm_list'></span>

<h3>Description</h3>

<p>Plots a triangulation mesh using <code>rgl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rgl(x, ...)

lines_rgl(x, ..., add = TRUE)

## S3 method for class 'fm_segm'
lines_rgl(
  x,
  loc = NULL,
  col = NULL,
  colors = c("black", "blue", "red", "green"),
  ...,
  add = TRUE
)

## S3 method for class 'fm_mesh_2d'
plot_rgl(
  x,
  col = "white",
  color.axis = NULL,
  color.n = 512,
  color.palette = cm.colors,
  color.truncate = FALSE,
  alpha = NULL,
  lwd = 1,
  specular = "black",
  draw.vertices = TRUE,
  draw.edges = TRUE,
  draw.faces = TRUE,
  draw.segments = draw.edges,
  size = 2,
  edge.color = rgb(0.3, 0.3, 0.3),
  t.sub = seq_len(nrow(x$graph$tv)),
  visibility = "",
  S = deprecated(),
  add = FALSE,
  ...
)

## S3 method for class 'fm_segm'
plot_rgl(x, ..., add = FALSE)

## S3 method for class 'fm_segm_list'
plot_rgl(x, ...)

## S3 method for class 'fm_segm_list'
lines_rgl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_rgl_+3A_x">x</code></td>
<td>
<p>A <code>fm_mesh_2d()</code> object</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to and from other methods.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, adds to the current plot instead of starting a
new one.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_loc">loc</code></td>
<td>
<p>Point locations to be used if <code>x$loc</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_col">col</code></td>
<td>
<p>Segment color specification.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_colors">colors</code></td>
<td>
<p>Colors to cycle through if <code>col</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_color.axis">color.axis</code></td>
<td>
<p>The min/max limit values for the color mapping.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_color.n">color.n</code></td>
<td>
<p>The number of colors to use in the color palette.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_color.palette">color.palette</code></td>
<td>
<p>A color palette function.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_color.truncate">color.truncate</code></td>
<td>
<p>If <code>TRUE</code>, truncate the colors at the color axis
limits.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_alpha">alpha</code></td>
<td>
<p>Transparency/opaqueness values. See <code>rgl.material</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_lwd">lwd</code></td>
<td>
<p>Line width for edges. See <code>rgl.material</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_specular">specular</code></td>
<td>
<p>Specular color. See <code>rgl.material</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_draw.vertices">draw.vertices</code></td>
<td>
<p>If <code>TRUE</code>, draw triangle vertices.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_draw.edges">draw.edges</code></td>
<td>
<p>If <code>TRUE</code>, draw triangle edges.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_draw.faces">draw.faces</code></td>
<td>
<p>If <code>TRUE</code>, draw triangles.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_draw.segments">draw.segments</code></td>
<td>
<p>If <code>TRUE</code>, draw boundary and interior constraint
edges more prominently.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_size">size</code></td>
<td>
<p>Size for vertex points.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_edge.color">edge.color</code></td>
<td>
<p>Edge color specification.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_t.sub">t.sub</code></td>
<td>
<p>Optional triangle index subset to be drawn.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_visibility">visibility</code></td>
<td>
<p>If &quot;front&quot; only display mesh faces with normal pointing
towards the camera.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_s">S</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rgl device identifier, invisibly.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fm_mesh_2d">plot.fm_mesh_2d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive() &amp;&amp; require("rgl")) {
  mesh &lt;- fm_rcdt_2d(globe = 10)
  plot_rgl(mesh, col = mesh$loc[, 1])
}

</code></pre>

<hr>
<h2 id='plot.fm_mesh_2d'>Draw a triangulation mesh object</h2><span id='topic+plot.fm_mesh_2d'></span><span id='topic+lines.fm_mesh_2d'></span>

<h3>Description</h3>

<p>Plots an <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object using standard graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_mesh_2d'
lines(x, ..., add = TRUE)

## S3 method for class 'fm_mesh_2d'
plot(
  x,
  col = "white",
  t.sub = seq_len(nrow(x$graph$tv)),
  add = FALSE,
  lwd = 1,
  xlim = range(x$loc[, 1]),
  ylim = range(x$loc[, 2]),
  main = NULL,
  size = 1,
  draw.vertices = FALSE,
  vertex.color = "black",
  draw.edges = TRUE,
  edge.color = rgb(0.3, 0.3, 0.3),
  draw.segments = draw.edges,
  rgl = deprecated(),
  visibility = "front",
  asp = 1,
  axes = FALSE,
  xlab = "",
  ylab = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fm_mesh_2d_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_...">...</code></td>
<td>
<p>Further graphics parameters, interpreted by the respective
plotting systems.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, adds to the current plot instead of starting a
new one.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_col">col</code></td>
<td>
<p>Color specification.  A single named color, a vector of scalar
values, or a matrix of RGB values.  Requires <code>rgl=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_t.sub">t.sub</code></td>
<td>
<p>Optional triangle index subset to be drawn.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_lwd">lwd</code></td>
<td>
<p>Line width for triangle edges.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_xlim">xlim</code></td>
<td>
<p>X-axis limits.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_main">main</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_size">size</code></td>
<td>
<p>argument <code>cex</code> for vertex points.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_draw.vertices">draw.vertices</code></td>
<td>
<p>If <code>TRUE</code>, draw triangle vertices.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Color specification for all vertices.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_draw.edges">draw.edges</code></td>
<td>
<p>If <code>TRUE</code>, draw triangle edges.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_edge.color">edge.color</code></td>
<td>
<p>Color specification for all edges.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_draw.segments">draw.segments</code></td>
<td>
<p>If <code>TRUE</code>, draw boundary and interior constraint
edges more prominently.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_rgl">rgl</code></td>
<td>
<p>Deprecated</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_visibility">visibility</code></td>
<td>
<p>If &quot;front&quot; only display mesh faces with normal pointing
towards the camera.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio for new plots. Default 1.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_axes">axes</code></td>
<td>
<p>logical; whether axes should be drawn on the plot.
Default FALSE.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_xlab">xlab</code>, <code id="plot.fm_mesh_2d_+3A_ylab">ylab</code></td>
<td>
<p>character; labels for the axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fm_segm">plot.fm_segm()</a></code>, <code><a href="#topic+plot_rgl.fm_mesh_2d">plot_rgl.fm_mesh_2d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mesh &lt;- fm_rcdt_2d(globe = 10)
plot(mesh)

mesh &lt;- fm_mesh_2d(cbind(0, 1), offset = c(1, 1.5), max.edge = 0.5)
plot(mesh)
</code></pre>

<hr>
<h2 id='plot.fm_segm'>Draw <code>fm_segm</code> objects.</h2><span id='topic+plot.fm_segm'></span><span id='topic+lines.fm_segm'></span><span id='topic+plot.fm_segm_list'></span><span id='topic+lines.fm_segm_list'></span>

<h3>Description</h3>

<p>Draws a <code><a href="#topic+fm_segm">fm_segm()</a></code> object with generic or <code>rgl</code>
graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_segm'
plot(x, ..., add = FALSE)

## S3 method for class 'fm_segm'
lines(
  x,
  loc = NULL,
  col = NULL,
  colors = c("black", "blue", "red", "green"),
  add = TRUE,
  xlim = NULL,
  ylim = NULL,
  rgl = FALSE,
  asp = 1,
  axes = FALSE,
  xlab = "",
  ylab = "",
  ...
)

## S3 method for class 'fm_segm_list'
plot(x, ...)

## S3 method for class 'fm_segm_list'
lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fm_segm_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+fm_segm">fm_segm()</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_...">...</code></td>
<td>
<p>Additional parameters, passed on to graphics methods.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, add to the current plot, otherwise start a new
plot.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_loc">loc</code></td>
<td>
<p>Point locations to be used if <code>x$loc</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_col">col</code></td>
<td>
<p>Segment color specification.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_colors">colors</code></td>
<td>
<p>Colors to cycle through if <code>col</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_xlim">xlim</code>, <code id="plot.fm_segm_+3A_ylim">ylim</code></td>
<td>
<p>X and Y axis limits for a new plot.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_rgl">rgl</code></td>
<td>
<p>If <code>TRUE</code>, use <code>rgl</code> for plotting.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio for new plots. Default 1.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_axes">axes</code></td>
<td>
<p>logical; whether axes should be drawn on the plot.
Default FALSE.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_xlab">xlab</code>, <code id="plot.fm_segm_+3A_ylab">ylab</code></td>
<td>
<p>character; labels for the axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_segm">fm_segm()</a></code>, <a href="#topic+plot.fm_mesh_2d">plot.fm_mesh_2d</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(fm_segm(fmexample$mesh, boundary = TRUE))
lines(fm_segm(fmexample$mesh, boundary = FALSE), col = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
