<!DOCTYPE html><html lang="en"><head><title>Help for package fmesher</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fmesher}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fmesher-package'><p>fmesher: Triangle Meshes and Related Geometry Tools</p></a></li>
<li><a href='#as.triangles3d.fm_mesh_3d'><p>Convert a 3D mesh to a 3D rgl triangulation</p></a></li>
<li><a href='#call-stack'><p>Call stack utility functions</p></a></li>
<li><a href='#fm_as_dgCMatrix'><p>Conversion between sparse matrix types</p></a></li>
<li><a href='#fm_as_fm'><p>Convert objects to fmesher objects</p></a></li>
<li><a href='#fm_as_lattice_2d'><p>Convert objects to <code>fm_lattice_2d</code></p></a></li>
<li><a href='#fm_as_lattice_Nd'><p>Convert objects to <code>fm_lattice_Nd</code></p></a></li>
<li><a href='#fm_as_mesh_1d'><p>Convert objects to <code>fm_segm</code></p></a></li>
<li><a href='#fm_as_mesh_2d'><p>Convert objects to <code>fm_mesh_2d</code></p></a></li>
<li><a href='#fm_as_mesh_3d'><p>Convert objects to <code>fm_mesh_3d</code></p></a></li>
<li><a href='#fm_as_segm'><p>Convert objects to <code>fm_segm</code></p></a></li>
<li><a href='#fm_as_sfc'><p>Conversion methods from mesh related objects to sfc</p></a></li>
<li><a href='#fm_as_tensor'><p>Convert objects to <code>fm_tensor</code></p></a></li>
<li><a href='#fm_assess'><p>Interactive mesh building and diagnostics</p></a></li>
<li><a href='#fm_bary'><p>Compute barycentric coordinates</p></a></li>
<li><a href='#fm_bary_loc'><p>Extract Euclidean Sgeometry from Barycentric coordinates</p></a></li>
<li><a href='#fm_bary_simplex'><p>Extract Simplex information for Barycentric coordinates</p></a></li>
<li><a href='#fm_basis'><p>Compute mapping matrix between mesh function space and points</p></a></li>
<li><a href='#fm_basis_helpers'><p>Internal helper functions for mesh field evaluation</p></a></li>
<li><a href='#fm_bbox'><p>Bounding box class</p></a></li>
<li><a href='#fm_block'><p>Blockwise aggregation matrices</p></a></li>
<li><a href='#fm_centroids'><p>Extract triangle centroids from an <code>fm_mesh_2d</code></p></a></li>
<li><a href='#fm_contains'><p>Check which mesh triangles are inside a polygon</p></a></li>
<li><a href='#fm_cprod'><p>(Blockwise) cross product of integration points</p></a></li>
<li><a href='#fm_crs'><p>Obtain coordinate reference system object</p></a></li>
<li><a href='#fm_CRS'><p>Create a coordinate reference system object</p></a></li>
<li><a href='#fm_CRS_as_list'><p>Show expanded CRS arguments</p></a></li>
<li><a href='#fm_crs_is_identical'><p>Check if two CRS objects are identical</p></a></li>
<li><a href='#fm_crs_is_null'><p>Check if a crs is NULL or NA</p></a></li>
<li><a href='#fm_crs_plot'><p>Plot CRS and fm_crs objects</p></a></li>
<li><a href='#fm_crs_wkt'><p>Handling CRS/WKT</p></a></li>
<li><a href='#fm_crs+26lt+3B-'><p>Assignment operators for crs information objects</p></a></li>
<li><a href='#fm_detect_manifold'><p>Detect manifold type</p></a></li>
<li><a href='#fm_diameter'><p>Diameter bound for a geometric object</p></a></li>
<li><a href='#fm_dof'><p>Function spece degrees of freedom</p></a></li>
<li><a href='#fm_evaluate'><p>Methods for projecting to/from mesh objects</p></a></li>
<li><a href='#fm_fem'><p>Compute finite element matrices</p></a></li>
<li><a href='#fm_generate_colors'><p>Generate text RGB color specifications.</p></a></li>
<li><a href='#fm_gmrf'><p>SPDE, GMRF, and Mat√©rn process methods</p></a></li>
<li><a href='#fm_int'><p>Multi-domain integration</p></a></li>
<li><a href='#fm_int_mesh_2d'><p>Subset integration on a mesh</p></a></li>
<li><a href='#fm_int_mesh_2d_core'><p>Integration scheme for mesh triangle interiors</p></a></li>
<li><a href='#fm_int_multi_sampler'><p>Multi-domain sampler integration</p></a></li>
<li><a href='#fm_is_within'><p>Query if points are inside a mesh</p></a></li>
<li><a href='#fm_lattice_2d'><p>Make a lattice object</p></a></li>
<li><a href='#fm_lattice_Nd'><p>Lattice grids for N dimensions</p></a></li>
<li><a href='#fm_list'><p>Handle lists of fmesher objects</p></a></li>
<li><a href='#fm_manifold'><p>Query the mesh manifold type</p></a></li>
<li><a href='#fm_mesh_1d'><p>Make a 1D mesh object</p></a></li>
<li><a href='#fm_mesh_2d'><p>Make a 2D mesh object</p></a></li>
<li><a href='#fm_mesh_2d_map'><p>Special coordinate mappings for <code>fm_mesh_2d</code> projections.</p></a></li>
<li><a href='#fm_mesh_3d'><p>Construct a 3D tetrahedralisation</p></a></li>
<li><a href='#fm_mesh_intersection'><p>Construct the intersection mesh of a mesh and a polygon</p></a></li>
<li><a href='#fm_nonconvex_hull'><p>Compute an extension of a spatial object</p></a></li>
<li><a href='#fm_nonconvex_hull_inla'><p>Non-convex hull computation</p></a></li>
<li><a href='#fm_pixels'><p>Generate lattice points covering a mesh</p></a></li>
<li><a href='#fm_qinv'><p>Sparse partial inverse</p></a></li>
<li><a href='#fm_raw_basis'><p>Basis functions for mesh manifolds</p></a></li>
<li><a href='#fm_rcdt_2d'><p>Refined Constrained Delaunay Triangulation</p></a></li>
<li><a href='#fm_refine'><p>Refine a 2d mesh</p></a></li>
<li><a href='#fm_row_kron'><p>Row-wise Kronecker products</p></a></li>
<li><a href='#fm_safe_sp'><p>Check for potential <code>sp</code> version compatibility issues</p></a></li>
<li><a href='#fm_segm'><p>Make a spatial segment object</p></a></li>
<li><a href='#fm_segm_contour_helper'><p>Contour segment</p></a></li>
<li><a href='#fm_segm_list'><p>Methods for fm_segm lists</p></a></li>
<li><a href='#fm_simplify'><p>Recursive curve simplification.</p></a></li>
<li><a href='#fm_simplify_helper'><p>Recursive curve simplification.</p></a></li>
<li><a href='#fm_split_lines'><p>Split lines at triangle edges</p></a></li>
<li><a href='#fm_store_points'><p>Store points in different formats</p></a></li>
<li><a href='#fm_subdivide'><p>Split triangles of a mesh into subtriangles</p></a></li>
<li><a href='#fm_tensor'><p>Make a tensor product function space</p></a></li>
<li><a href='#fm_transform'><p>Object coordinate transformation</p></a></li>
<li><a href='#fm_unify_coords'><p>Unify coordinates to 3-column matrix</p></a></li>
<li><a href='#fm_vertex_projection'><p>Project integration points to mesh vertices</p></a></li>
<li><a href='#fm_vertices'><p>Extract vertex locations from an <code>fm_mesh_2d</code></p></a></li>
<li><a href='#fm_wkt_as_wkt_tree'><p>Internal WKT handling</p></a></li>
<li><a href='#fmesher_bary'><p>Barycentric coordinate computation</p></a></li>
<li><a href='#fmesher_bary3d'><p>Barycentric coordinate computation</p></a></li>
<li><a href='#fmesher_fem'><p>Finite element matrix computation</p></a></li>
<li><a href='#fmesher_globe_points'><p>Globe points</p></a></li>
<li><a href='#fmesher_mesh3d'><p>3D tetrahedralisation storage</p></a></li>
<li><a href='#fmesher_qinv'><p>Compute sparse matrix inverse</p></a></li>
<li><a href='#fmesher_rcdt'><p>Refined Constrained Delaunay Triangulation</p></a></li>
<li><a href='#fmesher_spherical_bsplines1'><p>Rotationally invariant spherical B-splines</p></a></li>
<li><a href='#fmesher_split_lines'><p>Split lines at triangle edges</p></a></li>
<li><a href='#fmesher_subdivide'><p>Subdivide triangles</p></a></li>
<li><a href='#fmesher-deprecated'><p>Deprecated functions in fmesher</p></a></li>
<li><a href='#fmesher-print'><p>Print objects</p></a></li>
<li><a href='#fmexample'><p>Example mesh data</p></a></li>
<li><a href='#fmexample_sp'><p>Add sp data to fmexample</p></a></li>
<li><a href='#geom_fm'><p>ggplot2 geomes for fmesher related objects</p></a></li>
<li><a href='#local_testthat'><p>Unit test helpers</p></a></li>
<li><a href='#plot_rgl'><p>Low level triangulation mesh plotting</p></a></li>
<li><a href='#plot.fm_mesh_2d'><p>Draw a triangulation mesh object</p></a></li>
<li><a href='#plot.fm_segm'><p>Draw <code>fm_segm</code> objects.</p></a></li>
<li><a href='#print.fm_basis'><p>Print method for <code>fm_basis</code></p></a></li>
<li><a href='#print.fm_evaluator'><p>Print method for <code>fm_evaluator()</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Triangle Meshes and Related Geometry Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate planar and spherical triangle meshes,
    compute finite element calculations for 1- and 2-dimensional flat and curved
    manifolds with associated basis function spaces, methods for lines and
    polygons, and transparent handling of coordinate reference systems and
    coordinate transformation, including 'sf' and 'sp' geometries. The core
    'fmesher' library code was originally part of the 'INLA' package, and
    implements parts of "Triangulations and Applications" by
    Hjelle and Daehlen (2006) &lt;<a href="https://doi.org/10.1007%2F3-540-33261-8">doi:10.1007/3-540-33261-8</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, graphics, grDevices, lifecycle, Matrix, rlang, sf,
stats, tibble, utils, withr, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>geometry, ggplot2, knitr, testthat (&ge; 3.0.0), terra,
tidyterra, rgl, rmarkdown, sp (&ge; 1.6-1), splancs, gsl</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://inlabru-org.github.io/fmesher/">https://inlabru-org.github.io/fmesher/</a>,
<a href="https://github.com/inlabru-org/fmesher">https://github.com/inlabru-org/fmesher</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/inlabru-org/fmesher/issues">https://github.com/inlabru-org/fmesher/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL-2.0</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>2010-2024 Finn Lindgren, except src/predicates.cc by
Jonathan Richard Shewchuk, 1996</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'deprecated.R' 'bary.R' 'basis.R' 'bbox.R'
'print.R' 'crs.R' 'data-fmexample.R' 'diameter.R' 'evaluator.R'
'fem.R' 'fm.R' 'fmesher-package.R' 'fmesher.R' 'ggplot.R'
'integration.R' 'lattice_2d.R' 'lattice_Nd.R' 'list.R'
'local.R' 'manifold.R' 'mapping.R' 'matern.R' 'mesh.R'
'mesh_1d.R' 'mesh_2d.R' 'mesh_3d.R' 'mesh_assessment.R'
'nonconvex_hull.R' 'onload.R' 'plot.R' 'segm.R' 'sf_mesh.R'
'sf_utils.R' 'simplify.R' 'sp_mesh.R' 'split_lines.R'
'tensor.R' 'utils.R'</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-17 14:52:46 UTC; flindgre</td>
</tr>
<tr>
<td>Author:</td>
<td>Finn Lindgren <a href="https://orcid.org/0000-0002-5833-2011"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph] (Finn Lindgren wrote the main code),
  Seaton Andy [ctb] (Andy Seaton constributed features to the sf support),
  Suen Man Ho [ctb] (Man Ho Suen contributed features and code structure
    design for the integration methods),
  Fabian E. Bachl [ctb] (Fabian Bachl co-developed precursors of
    fm_pixels and fm_split_lines in inlabru)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Finn Lindgren &lt;finn.lindgren@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-18 07:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='fmesher-package'>fmesher: Triangle Meshes and Related Geometry Tools</h2><span id='topic+fmesher'></span><span id='topic+fmesher-package'></span>

<h3>Description</h3>

<p>Generate planar and spherical triangle meshes, compute finite element calculations for 1- and 2-dimensional flat and curved manifolds with associated basis function spaces, methods for lines and polygons, and transparent handling of coordinate reference systems and coordinate transformation, including 'sf' and 'sp' geometries. The core 'fmesher' library code was originally part of the 'INLA' package, and implements parts of &quot;Triangulations and Applications&quot; by Hjelle and Daehlen (2006) <a href="https://doi.org/10.1007/3-540-33261-8">doi:10.1007/3-540-33261-8</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a> (<a href="https://orcid.org/0000-0002-5833-2011">ORCID</a>) (Finn Lindgren wrote the main code) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Seaton Andy <a href="mailto:andy.e.seaton@gmail.com">andy.e.seaton@gmail.com</a> (Andy Seaton constributed features to the sf support) [contributor]
</p>
</li>
<li><p> Suen Man Ho <a href="mailto:M.H.Suen@sms.ed.ac.uk">M.H.Suen@sms.ed.ac.uk</a> (Man Ho Suen contributed features and code structure design for the integration methods) [contributor]
</p>
</li>
<li><p> Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a> (Fabian Bachl co-developed precursors of fm_pixels and fm_split_lines in inlabru) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://inlabru-org.github.io/fmesher/">https://inlabru-org.github.io/fmesher/</a>
</p>
</li>
<li> <p><a href="https://github.com/inlabru-org/fmesher">https://github.com/inlabru-org/fmesher</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/inlabru-org/fmesher/issues">https://github.com/inlabru-org/fmesher/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as.triangles3d.fm_mesh_3d'>Convert a 3D mesh to a 3D rgl triangulation</h2><span id='topic+as.triangles3d.fm_mesh_3d'></span>

<h3>Description</h3>

<p>Extracts a matrix of coordinates of triangles, suitable for
passing to <code>rgl::triangles3d()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_mesh_3d'
as.triangles3d(obj, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.triangles3d.fm_mesh_3d_+3A_obj">obj</code></td>
<td>
<p>An <code>fm_mesh_3d</code> object</p>
</td></tr>
<tr><td><code id="as.triangles3d.fm_mesh_3d_+3A_subset">subset</code></td>
<td>
<p>Character string specifying which triangles to extract. Either
&quot;all&quot; (default) or &quot;boundary&quot;.</p>
</td></tr>
<tr><td><code id="as.triangles3d.fm_mesh_3d_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-column matrix of coordinates of triangles, suitable for
passing to <code>rgl::triangles3d()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("geometry", quietly = TRUE) &amp;&amp;
  requireNamespace("rgl", quietly = TRUE)) {
  (m &lt;- fm_delaunay_3d(matrix(rnorm(30), 10, 3)))
  rgl::open3d()
  rgl::triangles3d(as.triangles3d(m, "boundary"), col = "blue")
}

</code></pre>

<hr>
<h2 id='call-stack'>Call stack utility functions</h2><span id='topic+call-stack'></span><span id='topic+fm_caller_name'></span><span id='topic+fm_call_stack'></span><span id='topic+fm_try_callstack'></span>

<h3>Description</h3>

<p>Helper functions for displaying call stack information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_caller_name(which = 0L, override = NULL)

fm_call_stack(start = 0L, end = 0L, with_numbers = TRUE, ...)

fm_try_callstack(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call-stack_+3A_which">which</code></td>
<td>
<p>The number of frames to go back from the caller</p>
</td></tr>
<tr><td><code id="call-stack_+3A_override">override</code></td>
<td>
<p>character; Overrides the automated function name logic</p>
</td></tr>
<tr><td><code id="call-stack_+3A_start">start</code></td>
<td>
<p>The stack starting point</p>
</td></tr>
<tr><td><code id="call-stack_+3A_end">end</code></td>
<td>
<p>The stack end point</p>
</td></tr>
<tr><td><code id="call-stack_+3A_with_numbers">with_numbers</code></td>
<td>
<p>INclude call stack location numbers</p>
</td></tr>
<tr><td><code id="call-stack_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
<tr><td><code id="call-stack_+3A_expr">expr</code></td>
<td>
<p>An <code>expression</code> to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_caller_name</code> returns a string with the the name of a calling
function
</p>
<p><code>fm_call_stack</code> returns a character vector
</p>
<p><code>fm_try_callstack</code> If successful, returns (invisibly) the value from
the evaluated expression, otherwise an error object with call stack
information attached to the error message.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_call_stack()</code>: 
</p>
</li>
<li> <p><code>fm_try_callstack()</code>: Inspired by <code>berryFunctions::tryStack</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- function() {
  print(fm_caller_name())
  nm &lt;- fm_caller_name()
  print(nm)
}
fun()
</code></pre>

<hr>
<h2 id='fm_as_dgCMatrix'>Conversion between sparse matrix types</h2><span id='topic+fm_as_dgCMatrix'></span><span id='topic+fm_as_dgTMatrix'></span><span id='topic+fm_as_unpackedMatrix'></span><span id='topic+fm_as_fmesher_sparse'></span><span id='topic+fm_as_dgCMatrix.default'></span><span id='topic+fm_as_dgCMatrix.fmesher_sparse'></span><span id='topic+fm_as_dgTMatrix.default'></span><span id='topic+fm_as_unpackedMatrix.default'></span><span id='topic+fm_as_unpackedMatrix.fmesher_sparse'></span><span id='topic+fm_as_dgTMatrix.fmesher_sparse'></span>

<h3>Description</h3>

<p>Conversion between sparse matrix types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_dgCMatrix(x)

fm_as_dgTMatrix(x, unique = TRUE, ...)

fm_as_unpackedMatrix(x)

fm_as_fmesher_sparse(x)

## Default S3 method:
fm_as_dgCMatrix(x)

## S3 method for class 'fmesher_sparse'
fm_as_dgCMatrix(x)

## Default S3 method:
fm_as_dgTMatrix(x, unique = TRUE, ...)

## Default S3 method:
fm_as_unpackedMatrix(x)

## S3 method for class 'fmesher_sparse'
fm_as_unpackedMatrix(x)

## S3 method for class 'fmesher_sparse'
fm_as_dgTMatrix(x, unique = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_dgCMatrix_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_dgCMatrix_+3A_unique">unique</code></td>
<td>
<p>logical; if <code>TRUE</code>, ensures that the sparse triplet
representation has a single entry for each non-zero matrix element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_as_dgCMatrix</code> returns a <a href="Matrix.html#topic+dgCMatrix-class">Matrix::dgCMatrix</a> object.
</p>
<p><code>fm_as_dgTMatrix</code> returns a <a href="Matrix.html#topic+dgTMatrix-class">Matrix::dgTMatrix</a> object.
</p>
<p><code>fm_as_unpackedMatrix</code> returns an object of virtual class
<a href="Matrix.html#topic+unpackedMatrix-class">Matrix::unpackedMatrix</a>.
</p>
<p><code>fm_as_fmesher_sparse</code> returns an <code>fmesher_sparse</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
str(A &lt;- fm_as_dgCMatrix(matrix(c(1, 2, 0, 0, 0, 3, 4, 0, 5), 3, 3)))
str(fm_as_dgTMatrix(A))
str(fm_as_unpackedMatrix(A))
str(fm_as_fmesher_sparse(A))
</code></pre>

<hr>
<h2 id='fm_as_fm'>Convert objects to fmesher objects</h2><span id='topic+fm_as_fm'></span><span id='topic+fm_as_fm.NULL'></span><span id='topic+fm_as_fm.fm_mesh_1d'></span><span id='topic+fm_as_fm.fm_mesh_2d'></span><span id='topic+fm_as_fm.fm_mesh_3d'></span><span id='topic+fm_as_fm.fm_tensor'></span><span id='topic+fm_as_fm.fm_segm'></span><span id='topic+fm_as_fm.fm_lattice_Nd'></span><span id='topic+fm_as_fm.fm_lattice_2d'></span><span id='topic+fm_as_fm.fm_bbox'></span><span id='topic+fm_as_fm.crs'></span><span id='topic+fm_as_fm.CRS'></span><span id='topic+fm_as_fm.fm_crs'></span><span id='topic+fm_as_fm.inla.CRS'></span><span id='topic+fm_as_fm.inla.mesh.1d'></span><span id='topic+fm_as_fm.inla.mesh'></span><span id='topic+fm_as_fm.inla.mesh.segment'></span><span id='topic+fm_as_fm.inla.mesh.lattice'></span>

<h3>Description</h3>

<p>Used for conversion from general objects
(usually <code>inla.mesh</code> and other legacy INLA specific classes)
to <code>fmesher</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_fm(x, ...)

## S3 method for class 'NULL'
fm_as_fm(x, ...)

## S3 method for class 'fm_mesh_1d'
fm_as_fm(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_as_fm(x, ...)

## S3 method for class 'fm_mesh_3d'
fm_as_fm(x, ...)

## S3 method for class 'fm_tensor'
fm_as_fm(x, ...)

## S3 method for class 'fm_segm'
fm_as_fm(x, ...)

## S3 method for class 'fm_lattice_Nd'
fm_as_fm(x, ...)

## S3 method for class 'fm_lattice_2d'
fm_as_fm(x, ...)

## S3 method for class 'fm_bbox'
fm_as_fm(x, ...)

## S3 method for class 'crs'
fm_as_fm(x, ...)

## S3 method for class 'CRS'
fm_as_fm(x, ...)

## S3 method for class 'fm_crs'
fm_as_fm(x, ...)

## S3 method for class 'inla.CRS'
fm_as_fm(x, ...)

## S3 method for class 'inla.mesh.1d'
fm_as_fm(x, ...)

## S3 method for class 'inla.mesh'
fm_as_fm(x, ...)

## S3 method for class 'inla.mesh.segment'
fm_as_fm(x, ...)

## S3 method for class 'inla.mesh.lattice'
fm_as_fm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_fm_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_fm_+3A_...">...</code></td>
<td>
<p>Arguments forwarded to submethods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of some <code style="white-space: pre;">&#8288;fm_*&#8288;</code> class
</p>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_fm(NULL)

</code></pre>

<hr>
<h2 id='fm_as_lattice_2d'>Convert objects to <code>fm_lattice_2d</code></h2><span id='topic+fm_as_lattice_2d'></span><span id='topic+fm_as_lattice_2d_list'></span><span id='topic+fm_as_lattice_2d.fm_lattice_2d'></span><span id='topic+fm_as_lattice_2d.inla.mesh.lattice'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_lattice_2d</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_lattice_2d(...)

fm_as_lattice_2d_list(x, ...)

## S3 method for class 'fm_lattice_2d'
fm_as_lattice_2d(x, ...)

## S3 method for class 'inla.mesh.lattice'
fm_as_lattice_2d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_lattice_2d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_as_lattice_2d_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_lattice_2d</code> or <code>fm_lattice_2d_list</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_lattice_2d()</code>: Convert an object to <code>fm_lattice_2d</code>.
</p>
</li>
<li> <p><code>fm_as_lattice_2d_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_as_lattice_2d_list(list(fm_lattice_2d(), fm_lattice_2d())))

</code></pre>

<hr>
<h2 id='fm_as_lattice_Nd'>Convert objects to <code>fm_lattice_Nd</code></h2><span id='topic+fm_as_lattice_Nd'></span><span id='topic+fm_as_lattice_Nd_list'></span><span id='topic+fm_as_lattice_Nd.fm_lattice_Nd'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_lattice_Nd</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_lattice_Nd(...)

fm_as_lattice_Nd_list(x, ...)

## S3 method for class 'fm_lattice_Nd'
fm_as_lattice_Nd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_lattice_Nd_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_as_lattice_Nd_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_lattice_Md</code> or <code>fm_lattice_Nd_list</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_lattice_Nd()</code>: Convert an object to <code>fm_lattice_Nd</code>.
</p>
</li>
<li> <p><code>fm_as_lattice_Nd_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(fm_as_lattice_Nd_list(list(
  fm_lattice_Nd(list(1:3, 1:2)),
  fm_lattice_Nd(list(1:4))
)))

</code></pre>

<hr>
<h2 id='fm_as_mesh_1d'>Convert objects to <code>fm_segm</code></h2><span id='topic+fm_as_mesh_1d'></span><span id='topic+fm_as_mesh_1d_list'></span><span id='topic+fm_as_mesh_1d.fm_mesh_1d'></span><span id='topic+fm_as_mesh_1d.inla.mesh.1d'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_segm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_mesh_1d(x, ...)

fm_as_mesh_1d_list(x, ...)

## S3 method for class 'fm_mesh_1d'
fm_as_mesh_1d(x, ...)

## S3 method for class 'inla.mesh.1d'
fm_as_mesh_1d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_mesh_1d_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_mesh_1d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_1d</code> or <code>fm_mesh_1d_list</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_mesh_1d()</code>: Convert an object to <code>fm_mesh_1d</code>.
</p>
</li>
<li> <p><code>fm_as_mesh_1d_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_mesh_1d_list(list(fm_mesh_1d(1:4)))
</code></pre>

<hr>
<h2 id='fm_as_mesh_2d'>Convert objects to <code>fm_mesh_2d</code></h2><span id='topic+fm_as_mesh_2d'></span><span id='topic+fm_as_mesh_2d_list'></span><span id='topic+fm_as_mesh_2d.fm_mesh_2d'></span><span id='topic+fm_as_mesh_2d.inla.mesh'></span><span id='topic+fm_as_mesh_2d.fm_mesh_3d'></span><span id='topic+fm_as_mesh_2d.sfg'></span><span id='topic+fm_as_mesh_2d.sfc_MULTIPOLYGON'></span><span id='topic+fm_as_mesh_2d.sfc_POLYGON'></span><span id='topic+fm_as_mesh_2d.sf'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_mesh_2d</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_mesh_2d(x, ...)

fm_as_mesh_2d_list(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_as_mesh_2d(x, ...)

## S3 method for class 'inla.mesh'
fm_as_mesh_2d(x, ...)

## S3 method for class 'fm_mesh_3d'
fm_as_mesh_2d(x, ...)

## S3 method for class 'sfg'
fm_as_mesh_2d(x, ...)

## S3 method for class 'sfc_MULTIPOLYGON'
fm_as_mesh_2d(x, ...)

## S3 method for class 'sfc_POLYGON'
fm_as_mesh_2d(x, ...)

## S3 method for class 'sf'
fm_as_mesh_2d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_mesh_2d_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_mesh_2d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_2d</code> or <code>fm_mesh_2d_list</code> object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_as_mesh_2d(fm_mesh_3d)</code>: Construct a 2D mesh of the boundary of a 3D mesh
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_mesh_2d()</code>: Convert an object to <code>fm_mesh_2d</code>.
</p>
</li>
<li> <p><code>fm_as_mesh_2d_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_mesh_2d_list(list(fm_mesh_2d(cbind(2, 1))))
</code></pre>

<hr>
<h2 id='fm_as_mesh_3d'>Convert objects to <code>fm_mesh_3d</code></h2><span id='topic+fm_as_mesh_3d'></span><span id='topic+fm_as_mesh_3d_list'></span><span id='topic+fm_as_mesh_3d.fm_mesh_3d'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_mesh_3d</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_mesh_3d(x, ...)

fm_as_mesh_3d_list(x, ...)

## S3 method for class 'fm_mesh_3d'
fm_as_mesh_3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_mesh_3d_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_mesh_3d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_3d</code> or <code>fm_mesh_3d_list</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_mesh_3d()</code>: Convert an object to <code>fm_mesh_3d</code>.
</p>
</li>
<li> <p><code>fm_as_mesh_3d_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>

<hr>
<h2 id='fm_as_segm'>Convert objects to <code>fm_segm</code></h2><span id='topic+fm_as_segm'></span><span id='topic+fm_as_segm_list'></span><span id='topic+fm_as_segm.fm_segm'></span><span id='topic+fm_as_segm.inla.mesh.segment'></span><span id='topic+fm_as_segm.sfg'></span><span id='topic+fm_as_segm.sfc_POINT'></span><span id='topic+fm_as_segm.sfc_LINESTRING'></span><span id='topic+fm_as_segm.sfc_MULTILINESTRING'></span><span id='topic+fm_as_segm.sfc_POLYGON'></span><span id='topic+fm_as_segm.sfc_MULTIPOLYGON'></span><span id='topic+fm_as_segm.sfc_GEOMETRY'></span><span id='topic+fm_as_segm.sf'></span><span id='topic+fm_as_segm.matrix'></span><span id='topic+fm_as_segm.SpatialPoints'></span><span id='topic+fm_as_segm.SpatialPointsDataFrame'></span><span id='topic+fm_as_segm.Line'></span><span id='topic+fm_as_segm.Lines'></span><span id='topic+fm_as_segm.SpatialLines'></span><span id='topic+fm_as_segm.SpatialLinesDataFrame'></span><span id='topic+fm_as_segm.SpatialPolygons'></span><span id='topic+fm_as_segm.SpatialPolygonsDataFrame'></span><span id='topic+fm_as_segm.Polygons'></span><span id='topic+fm_as_segm.Polygon'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_segm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_segm(x, ...)

fm_as_segm_list(x, ...)

## S3 method for class 'fm_segm'
fm_as_segm(x, ...)

## S3 method for class 'inla.mesh.segment'
fm_as_segm(x, ...)

## S3 method for class 'sfg'
fm_as_segm(x, ...)

## S3 method for class 'sfc_POINT'
fm_as_segm(x, reverse = FALSE, grp = NULL, is.bnd = TRUE, ...)

## S3 method for class 'sfc_LINESTRING'
fm_as_segm(x, join = TRUE, grp = NULL, reverse = FALSE, ...)

## S3 method for class 'sfc_MULTILINESTRING'
fm_as_segm(x, join = TRUE, grp = NULL, reverse = FALSE, ...)

## S3 method for class 'sfc_POLYGON'
fm_as_segm(x, join = TRUE, grp = NULL, ...)

## S3 method for class 'sfc_MULTIPOLYGON'
fm_as_segm(x, join = TRUE, grp = NULL, ...)

## S3 method for class 'sfc_GEOMETRY'
fm_as_segm(x, grp = NULL, join = TRUE, ...)

## S3 method for class 'sf'
fm_as_segm(x, ...)

## S3 method for class 'matrix'
fm_as_segm(
  x,
  reverse = FALSE,
  grp = NULL,
  is.bnd = FALSE,
  crs = NULL,
  closed = FALSE,
  ...
)

## S3 method for class 'SpatialPoints'
fm_as_segm(x, reverse = FALSE, grp = NULL, is.bnd = TRUE, closed = FALSE, ...)

## S3 method for class 'SpatialPointsDataFrame'
fm_as_segm(x, ...)

## S3 method for class 'Line'
fm_as_segm(x, reverse = FALSE, grp = NULL, crs = NULL, ...)

## S3 method for class 'Lines'
fm_as_segm(x, join = TRUE, grp = NULL, crs = NULL, ...)

## S3 method for class 'SpatialLines'
fm_as_segm(x, join = TRUE, grp = NULL, ...)

## S3 method for class 'SpatialLinesDataFrame'
fm_as_segm(x, ...)

## S3 method for class 'SpatialPolygons'
fm_as_segm(x, join = TRUE, grp = NULL, ...)

## S3 method for class 'SpatialPolygonsDataFrame'
fm_as_segm(x, ...)

## S3 method for class 'Polygons'
fm_as_segm(x, join = TRUE, crs = NULL, grp = NULL, ...)

## S3 method for class 'Polygon'
fm_as_segm(x, crs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_segm_+3A_x">x</code></td>
<td>
<p>Object to be converted.</p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_reverse">reverse</code></td>
<td>
<p>logical; When TRUE, reverse the order of the input points.
Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_grp">grp</code></td>
<td>
<p>if non-null, should be an integer vector of grouping labels for
one for each segment.
Default <code>NULL</code></p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_is.bnd">is.bnd</code></td>
<td>
<p>logical; if <code>TRUE</code>, set the boundary flag for the segments.
Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_join">join</code></td>
<td>
<p>logical; if <code>TRUE</code>, join input segments with common vertices.
Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_crs">crs</code></td>
<td>
<p>A crs object</p>
</td></tr>
<tr><td><code id="fm_as_segm_+3A_closed">closed</code></td>
<td>
<p>logical; whether to treat a point sequence as a closed polygon.
Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_segm</code> or <code>fm_segm_list</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_segm()</code>: Convert an object to <code>fm_segm</code>.
</p>
</li>
<li> <p><code>fm_as_segm_list()</code>: Convert each element, making a <code>fm_segm_list</code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+c.fm_segm">c.fm_segm()</a></code>, <code><a href="#topic+c.fm_segm_list">c.fm_segm_list()</a></code>,
<code><a href="#topic++5B.fm_segm_list">[.fm_segm_list()</a></code>
</p>
<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_segm_list(list(
  fm_segm(fmexample$mesh),
  fm_segm(fmexample$mesh, boundary = FALSE)
))

(segm &lt;- fm_segm(fmexample$mesh, boundary = FALSE))
(segm_sfc &lt;- fm_as_sfc(segm))
(fm_as_segm(segm_sfc))

</code></pre>

<hr>
<h2 id='fm_as_sfc'>Conversion methods from mesh related objects to sfc</h2><span id='topic+fm_as_sfc'></span><span id='topic+fm_as_sfc.fm_mesh_2d'></span><span id='topic+fm_as_sfc.fm_segm'></span><span id='topic+fm_as_sfc.sfc'></span><span id='topic+fm_as_sfc.sf'></span>

<h3>Description</h3>

<p>Conversion methods from mesh related objects to sfc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_sfc(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_as_sfc(x, ..., format = NULL, multi = FALSE)

## S3 method for class 'fm_segm'
fm_as_sfc(x, ..., multi = FALSE)

## S3 method for class 'sfc'
fm_as_sfc(x, ...)

## S3 method for class 'sf'
fm_as_sfc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_sfc_+3A_x">x</code></td>
<td>
<p>An object to be coerced/transformed/converted into another class</p>
</td></tr>
<tr><td><code id="fm_as_sfc_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="fm_as_sfc_+3A_format">format</code></td>
<td>
<p>One of &quot;mesh&quot;, &quot;int&quot;, &quot;bnd&quot;, or &quot;loc&quot;. Default
&quot;mesh&quot;.</p>
</td></tr>
<tr><td><code id="fm_as_sfc_+3A_multi">multi</code></td>
<td>
<p>logical; if <code>TRUE</code>, attempt to a
<code>sfc_MULTIPOLYGON/LINESTRING/POINT</code>, otherwise a set of
<code>sfc_POLYGON/LINESTRING/POINT</code>. Default <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>fm_as_sfc</code>: An <code>sfc_MULTIPOLYGON/LINESTRING/POINT</code> or
<code>sfc_POLYGON/LINESTRING/POINT</code> object
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_as_sfc(fm_mesh_2d)</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
</li>
<li> <p><code>fm_as_sfc(fm_segm)</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_sfc(fmexample$mesh)
fm_as_sfc(fmexample$mesh, multi = TRUE)
fm_as_sfc(fmexample$mesh, format = "loc")

# Boundary edge conversion currently only supports (multi)linestring output,
# and does not convert to polygons.
suppressWarnings(
  fm_as_sfc(fmexample$mesh, format = "bnd")
)

</code></pre>

<hr>
<h2 id='fm_as_tensor'>Convert objects to <code>fm_tensor</code></h2><span id='topic+fm_as_tensor'></span><span id='topic+fm_as_tensor_list'></span><span id='topic+fm_as_tensor.fm_tensor'></span>

<h3>Description</h3>

<p>Convert objects to <code>fm_tensor</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_as_tensor(x, ...)

fm_as_tensor_list(x, ...)

## S3 method for class 'fm_tensor'
fm_as_tensor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_as_tensor_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="fm_as_tensor_+3A_...">...</code></td>
<td>
<p>Arguments passed on to submethods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_tensor</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_tensor()</code>: Convert an object to <code>fm_tensor</code>.
</p>
</li>
<li> <p><code>fm_as_tensor_list()</code>: Convert each element of a list
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_tensor_list(list(fm_tensor(list())))

</code></pre>

<hr>
<h2 id='fm_assess'>Interactive mesh building and diagnostics</h2><span id='topic+fm_assess'></span>

<h3>Description</h3>

<p>Assess the finite element approximation errors in a mesh for interactive R
sessions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_assess(mesh, spatial.range, alpha = 2, dims = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_assess_+3A_mesh">mesh</code></td>
<td>
<p>An <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> object</p>
</td></tr>
<tr><td><code id="fm_assess_+3A_spatial.range">spatial.range</code></td>
<td>
<p>numeric; the spatial range parameter to use for the
assessment</p>
</td></tr>
<tr><td><code id="fm_assess_+3A_alpha">alpha</code></td>
<td>
<p>numeric; A valid <code><a href="#topic+fm_matern_precision">fm_matern_precision()</a></code> <code>alpha</code> parameter</p>
</td></tr>
<tr><td><code id="fm_assess_+3A_dims">dims</code></td>
<td>
<p>2-numeric; the grid size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> object with gridded mesh assessment information
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, <a href="#topic+fm_rcdt_2d">fm_rcdt_2d</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bnd &lt;- fm_segm(cbind(
  c(0, 10, 10, 0, 0),
  c(0, 0, 10, 10, 0)
), is.bnd = TRUE)
mesh &lt;- fm_rcdt_2d_inla(boundary = bnd, max.edge = 1)
out &lt;- fm_assess(mesh, spatial.range = 3, alpha = 2)

</code></pre>

<hr>
<h2 id='fm_bary'>Compute barycentric coordinates</h2><span id='topic+fm_bary'></span><span id='topic+fm_bary.fm_bary'></span><span id='topic+fm_bary.list'></span><span id='topic+fm_bary.tbl_df'></span><span id='topic+fm_bary.fm_mesh_1d'></span><span id='topic+fm_bary.fm_mesh_2d'></span><span id='topic+fm_bary.fm_mesh_3d'></span><span id='topic+fm_bary.fm_lattice_2d'></span><span id='topic+fm_bary.fm_lattice_Nd'></span>

<h3>Description</h3>

<p>Identify knot intervals or triangles and compute barycentric
coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_bary(...)

## S3 method for class 'fm_bary'
fm_bary(bary, ..., extra_class = NULL)

## S3 method for class 'list'
fm_bary(bary, ..., extra_class = NULL)

## S3 method for class 'tbl_df'
fm_bary(bary, ..., extra_class = NULL)

## S3 method for class 'fm_mesh_1d'
fm_bary(mesh, loc, method = c("linear", "nearest"), restricted = FALSE, ...)

## S3 method for class 'fm_mesh_2d'
fm_bary(mesh, loc, crs = NULL, ..., max_batch_size = NULL)

## S3 method for class 'fm_mesh_3d'
fm_bary(mesh, loc, ..., max_batch_size = NULL)

## S3 method for class 'fm_lattice_2d'
fm_bary(mesh, loc, crs = NULL, ...)

## S3 method for class 'fm_lattice_Nd'
fm_bary(mesh, loc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_bary_+3A_...">...</code></td>
<td>
<p>Arguments forwarded to sub-methods.</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_bary">bary</code></td>
<td>
<p>An <code>fm_bary</code> object, or an object that can be converted to
<code>fm_bary</code>.</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_extra_class">extra_class</code></td>
<td>
<p>character; If non-<code>NULL</code> and not already in the class
vector of <code>bary</code>, add it to the front of the class vector.</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_mesh">mesh</code></td>
<td>
<p><code>fm_mesh_1d</code> or <code>fm_mesh_2d</code> object</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_loc">loc</code></td>
<td>
<p>Points for which to identify the containing interval/triangle, and
corresponding barycentric coordinates. May be a vector (for 1d) or a matrix
of raw coordinates, <code>sf</code>, or <code>sp</code> point information (for 2d).</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_method">method</code></td>
<td>
<p>character; method for defining the barycentric coordinates,
&quot;linear&quot; (default) or &quot;nearest&quot;</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_restricted">restricted</code></td>
<td>
<p>logical, used for <code>method="linear"</code>.
If <code>FALSE</code> (default), points outside the mesh interval will be given
barycentric weights less than 0 and greater than 1, according to linear
extrapolation. If <code>TRUE</code>, the barycentric weights are clamped to the (0, 1)
interval.</p>
</td></tr>
<tr><td><code id="fm_bary_+3A_crs">crs</code></td>
<td>
<p>Optional crs information for <code>loc</code></p>
</td></tr>
<tr><td><code id="fm_bary_+3A_max_batch_size">max_batch_size</code></td>
<td>
<p>integer; maximum number of points to process in a
single batch. This speeds up calculations by avoiding repeated large
internal memory allocations and data copies. The default, <code>NULL</code>, uses
<code>max_batch_size = 2e5L</code>, chosen based on empirical time measurements to
give an approximately optimal runtime.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fm_bary</code> object, a <code>tibble</code> with columns <code>index</code>; either
</p>

<ul>
<li><p>vector of triangle indices (triangle meshes),
</p>
</li>
<li><p>vector of knot indices (1D meshes, either for edges or individual
knots), or
</p>
</li>
<li><p>vector of lower left box indices (2D lattices),
</p>
</li></ul>

<p>and <code>where</code>, a matrix of barycentric coordinates.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_bary(fm_bary)</code>: Returns the <code>bary</code> input unchanged
</p>
</li>
<li> <p><code>fm_bary(list)</code>: Converts a <code>list</code> <code>bary</code> to <code>fm_bary</code>.
In the list elements are unnamed, the names <code>index</code> and <code>where</code> are assumed.
</p>
</li>
<li> <p><code>fm_bary(tbl_df)</code>: Converts a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> <code>bary</code> to <code>fm_bary</code>
</p>
</li>
<li> <p><code>fm_bary(fm_mesh_1d)</code>: Return an <code>fm_bary</code> object with elements <code>index</code>
(edge index vector pointing to the first knot of each edge) and
<code>where</code> (barycentric coordinates,
2-column matrices). Use <code><a href="#topic+fm_bary_simplex">fm_bary_simplex()</a></code> to obtain the corresponding
endpoint knot indices.
</p>
<p>For <code>method = "nearest"</code>, <code>index</code> contains the index of the nearest mesh
knot, and <code>where</code> is a single-column all-ones matrix.
</p>
</li>
<li> <p><code>fm_bary(fm_mesh_2d)</code>: An <code>fm_bary</code> object with columns <code>index</code> (vector of
triangle indices) and <code>where</code> (3-column matrix of barycentric coordinates).
Points that were not found give <code>NA</code> entries in <code>index</code> and <code>where</code>.
</p>
</li>
<li> <p><code>fm_bary(fm_mesh_3d)</code>: An <code>fm_bary</code> object with columns <code>index</code> (vector of
triangle indices) and <code>where</code> (4-column matrix of barycentric coordinates).
Points that were not found give <code>NA</code> entries in <code>index</code> and <code>where</code>.
</p>
</li>
<li> <p><code>fm_bary(fm_lattice_2d)</code>: An <code>fm_bary</code> object with columns <code>index</code> (vector of
lattice cell indices) and <code>where</code> (4-column matrix of barycentric
coordinates). Points that are outside the lattice are given <code>NA</code> entries in
<code>index</code> and <code>where</code>.
</p>
</li>
<li> <p><code>fm_bary(fm_lattice_Nd)</code>: An <code>fm_bary</code> object with columns <code>index</code> (vector of
lattice cell indices) and <code>where</code> <code>2^d</code>-column matrix of barycentric
coordinates). Points that are outside the lattice are given <code>NA</code> entries in
<code>index</code> and <code>where</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_bary_simplex">fm_bary_simplex()</a></code>, <code><a href="#topic+fm_bary_loc">fm_bary_loc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bary &lt;- fm_bary(fm_mesh_1d(1:4), seq(0, 5, by = 0.5))
bary
str(fm_bary(fmexample$mesh, fmexample$loc_sf))
m &lt;- fm_mesh_3d(
  rbind(
    c(1, 0, 0),
    c(0, 1, 0),
    c(0, 0, 1),
    c(0, 0, 0)
  ),
  matrix(c(1, 2, 3, 4), 1, 4)
)
b &lt;- fm_bary(m, matrix(c(1, 1, 1) / 4, 1, 3))
str(fm_bary(fmexample$mesh, fmexample$loc_sf))
</code></pre>

<hr>
<h2 id='fm_bary_loc'>Extract Euclidean Sgeometry from Barycentric coordinates</h2><span id='topic+fm_bary_loc'></span><span id='topic+fm_bary_loc.fm_mesh_2d'></span><span id='topic+fm_bary_loc.fm_mesh_3d'></span><span id='topic+fm_bary_loc.fm_mesh_1d'></span><span id='topic+fm_bary_loc.fm_lattice_2d'></span><span id='topic+fm_bary_loc.fm_lattice_Nd'></span>

<h3>Description</h3>

<p>Extract the Euclidean coordinates for location identified by an <a href="#topic+fm_bary">fm_bary</a>
object. This acts as the inverse of <code>fm_bary()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_bary_loc(mesh, bary = NULL, ..., format = NULL)

## S3 method for class 'fm_mesh_2d'
fm_bary_loc(mesh, bary = NULL, ..., format = NULL)

## S3 method for class 'fm_mesh_3d'
fm_bary_loc(mesh, bary = NULL, ..., format = NULL)

## S3 method for class 'fm_mesh_1d'
fm_bary_loc(mesh, bary = NULL, ..., format = NULL)

## S3 method for class 'fm_lattice_2d'
fm_bary_loc(mesh, bary = NULL, ..., format = NULL)

## S3 method for class 'fm_lattice_Nd'
fm_bary_loc(mesh, bary = NULL, ..., format = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_bary_loc_+3A_mesh">mesh</code></td>
<td>
<p>A mesh object, e.g. <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> or <a href="#topic+fm_mesh_1d">fm_mesh_1d</a>.</p>
</td></tr>
<tr><td><code id="fm_bary_loc_+3A_bary">bary</code></td>
<td>
<p>An <code>fm_bary</code> object. If <code>NULL</code>, return the mesh nodes is the mesh
class supports it, otherwise gives an error.</p>
</td></tr>
<tr><td><code id="fm_bary_loc_+3A_...">...</code></td>
<td>
<p>Further arguments potentially used by sub-methods.</p>
</td></tr>
<tr><td><code id="fm_bary_loc_+3A_format">format</code></td>
<td>
<p>Optional format for the output. If <code>NULL</code>, the output format
is determined by the default for the mesh object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output format depends on the mesh <code>class</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_bary_loc(fm_mesh_2d)</code>: Extract points on a triangle mesh. Implemented
formats are <code>"matrix"</code> (default) and <code>"sf"</code>.
</p>
</li>
<li> <p><code>fm_bary_loc(fm_mesh_3d)</code>: Extract points on a tetrahedron mesh. Implemented
format is <code>"matrix"</code> (default).
</p>
</li>
<li> <p><code>fm_bary_loc(fm_mesh_1d)</code>: Extract points on a 1D mesh. Implemented
formats are <code>"numeric"</code> (default).
</p>
</li>
<li> <p><code>fm_bary_loc(fm_lattice_2d)</code>: Extract points on a 2D lattice. Implemented
formats are <code>"matrix"</code> (default) and <code>"sf"</code>.
</p>
</li>
<li> <p><code>fm_bary_loc(fm_lattice_Nd)</code>: Extract points on a ND lattice.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_bary">fm_bary()</a></code>, <code><a href="#topic+fm_bary_simplex">fm_bary_simplex()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(fm_bary_loc(fmexample$mesh))
bary &lt;- fm_bary(fmexample$mesh, fmexample$loc_sf)
fm_bary_loc(fmexample$mesh, bary, format = "matrix")
fm_bary_loc(fmexample$mesh, bary, format = "sf")
mesh1 &lt;- fm_mesh_1d(1:4)
fm_bary_loc(mesh1)
(bary1 &lt;- fm_bary(mesh1, seq(0, 5, by = 0.5)))
fm_bary_loc(mesh1, bary1)
(bary1 &lt;- fm_bary(mesh1, seq(0, 5, by = 0.5), restricted = TRUE))
fm_bary_loc(mesh1, bary1)
fm_basis(mesh1, bary1)
(bary1 &lt;- fm_bary(mesh1, bary1, method = "nearest"))
fm_bary_loc(mesh1, bary1)
fm_basis(mesh1, bary1)
(bary1 &lt;- fm_bary(mesh1, bary1, method = "linear"))
fm_bary_loc(mesh1, bary1)
fm_basis(mesh1, bary1)
m &lt;- fm_lattice_2d(x = 1:3, y = 1:4)
head(fm_bary_loc(m))
(bary &lt;- fm_bary(m, cbind(1.5, 3.2)))
fm_bary_loc(m, bary, format = "matrix")
fm_bary_loc(m, bary, format = "sf")
m &lt;- fm_lattice_Nd(list(x = 1:3, y = 1:4, z = 1:2))
head(fm_bary_loc(m))
(bary &lt;- fm_bary(m, cbind(1.5, 3.2, 1.5)))
fm_bary_loc(m, bary)
</code></pre>

<hr>
<h2 id='fm_bary_simplex'>Extract Simplex information for Barycentric coordinates</h2><span id='topic+fm_bary_simplex'></span><span id='topic+fm_bary_simplex.fm_mesh_2d'></span><span id='topic+fm_bary_simplex.fm_mesh_3d'></span><span id='topic+fm_bary_simplex.fm_mesh_1d'></span><span id='topic+fm_bary_simplex.fm_lattice_2d'></span><span id='topic+fm_bary_simplex.fm_lattice_Nd'></span>

<h3>Description</h3>

<p>Extract the simplex vertex information for a combination of a mesh
and <a href="#topic+fm_bary">fm_bary</a> coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_bary_simplex(mesh, bary = NULL, ...)

## S3 method for class 'fm_mesh_2d'
fm_bary_simplex(mesh, bary = NULL, ...)

## S3 method for class 'fm_mesh_3d'
fm_bary_simplex(mesh, bary = NULL, ...)

## S3 method for class 'fm_mesh_1d'
fm_bary_simplex(mesh, bary = NULL, ...)

## S3 method for class 'fm_lattice_2d'
fm_bary_simplex(mesh, bary = NULL, ...)

## S3 method for class 'fm_lattice_Nd'
fm_bary_simplex(mesh, bary = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_bary_simplex_+3A_mesh">mesh</code></td>
<td>
<p>A mesh object, e.g. <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> or <a href="#topic+fm_mesh_1d">fm_mesh_1d</a>.</p>
</td></tr>
<tr><td><code id="fm_bary_simplex_+3A_bary">bary</code></td>
<td>
<p>An <a href="#topic+fm_bary">fm_bary</a> object. If NULL, return the full simplex
information for the mesh.</p>
</td></tr>
<tr><td><code id="fm_bary_simplex_+3A_...">...</code></td>
<td>
<p>Further arguments potentially used by sub-methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of vertex indices, one row per point in <code>bary</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_bary_simplex(fm_mesh_2d)</code>: Extract the triangle vertex indices for a 2D mesh
</p>
</li>
<li> <p><code>fm_bary_simplex(fm_mesh_3d)</code>: Extract the tetrahedron vertex indices for a 3D
mesh
</p>
</li>
<li> <p><code>fm_bary_simplex(fm_mesh_1d)</code>: Extract the edge vertex indices for a 1D mesh
</p>
</li>
<li> <p><code>fm_bary_simplex(fm_lattice_2d)</code>: Extract the cell vertex indices for a 2D lattice
</p>
</li>
<li> <p><code>fm_bary_simplex(fm_lattice_Nd)</code>: Extract the cell vertex indices for a ND lattice
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_bary">fm_bary()</a></code>, <code><a href="#topic+fm_bary_loc">fm_bary_loc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bary &lt;- fm_bary(fmexample$mesh, fmexample$loc_sf)
fm_bary_simplex(fmexample$mesh, bary)
mesh1 &lt;- fm_mesh_1d(1:4)
(bary1 &lt;- fm_bary(mesh1, seq(0, 5, by = 0.5)))
(bary1 &lt;- fm_bary(mesh1, seq(0, 5, by = 0.5), restricted = TRUE))
fm_bary_simplex(mesh1, bary1)
m &lt;- fm_lattice_2d(x = 1:3, y = 1:4)
bary &lt;- fm_bary(m, cbind(1.5, 3.2))
fm_bary_simplex(m, bary)
m &lt;- fm_lattice_Nd(list(x = 1:3, y = 1:4, z = 1:2))
(bary &lt;- fm_bary(m, cbind(1.5, 3.2, 1.5)))
(fm_bary_simplex(m, bary))
fm_bary_loc(m, bary)
</code></pre>

<hr>
<h2 id='fm_basis'>Compute mapping matrix between mesh function space and points</h2><span id='topic+fm_basis'></span><span id='topic+fm_basis.default'></span><span id='topic+fm_basis.fm_mesh_1d'></span><span id='topic+fm_basis.fm_mesh_2d'></span><span id='topic+fm_basis.fm_mesh_3d'></span><span id='topic+fm_basis.fm_lattice_2d'></span><span id='topic+fm_basis.fm_lattice_Nd'></span><span id='topic+fm_basis.fm_tensor'></span><span id='topic+fm_basis.matrix'></span><span id='topic+fm_basis.Matrix'></span><span id='topic+fm_basis.list'></span><span id='topic+fm_basis.fm_basis'></span><span id='topic+fm_basis.fm_evaluator'></span>

<h3>Description</h3>

<p>Computes the basis mapping matrix between a function space on a
mesh, and locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_basis(x, ..., full = FALSE)

## Default S3 method:
fm_basis(x, ..., full = FALSE)

## S3 method for class 'fm_mesh_1d'
fm_basis(x, loc, weights = NULL, derivatives = NULL, ..., full = FALSE)

## S3 method for class 'fm_mesh_2d'
fm_basis(x, loc, weights = NULL, derivatives = NULL, ..., full = FALSE)

## S3 method for class 'fm_mesh_3d'
fm_basis(x, loc, weights = NULL, ..., full = FALSE)

## S3 method for class 'fm_lattice_2d'
fm_basis(x, loc, weights = NULL, ..., full = FALSE)

## S3 method for class 'fm_lattice_Nd'
fm_basis(x, loc, weights = NULL, ..., full = FALSE)

## S3 method for class 'fm_tensor'
fm_basis(x, loc, weights = NULL, ..., full = FALSE)

## S3 method for class 'matrix'
fm_basis(x, ok = NULL, weights = NULL, ..., full = FALSE)

## S3 method for class 'Matrix'
fm_basis(x, ok = NULL, weights = NULL, ..., full = FALSE)

## S3 method for class 'list'
fm_basis(x, weights = NULL, ..., full = FALSE)

## S3 method for class 'fm_basis'
fm_basis(x, ..., full = FALSE)

## S3 method for class 'fm_evaluator'
fm_basis(x, ..., full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_basis_+3A_x">x</code></td>
<td>
<p>An function space object, or other supported object
(<code>matrix</code>, <code>Matrix</code>, <code>list</code>)</p>
</td></tr>
<tr><td><code id="fm_basis_+3A_...">...</code></td>
<td>
<p>Passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_basis_+3A_full">full</code></td>
<td>
<p>logical; if <code>TRUE</code>, return a <code>fm_basis</code> object, containing at
least a projection matrix <code>A</code> and logical vector <code>ok</code> indicating which
evaluations are valid. If <code>FALSE</code>, return only the projection matrix <code>A</code>.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fm_basis_+3A_loc">loc</code></td>
<td>
<p>A location/value information object (<code>numeric</code>, <code>matrix</code>, <code>sf</code>,
<code>fm_bary</code>, etc, depending on the class of <code>x</code>)</p>
</td></tr>
<tr><td><code id="fm_basis_+3A_weights">weights</code></td>
<td>
<p>Optional weight vector to apply (from the left, one
weight for each row of the basis matrix)</p>
</td></tr>
<tr><td><code id="fm_basis_+3A_derivatives">derivatives</code></td>
<td>
<p>If non-NULL and logical, include derivative matrices
in the output. Forces <code>full = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fm_basis_+3A_ok">ok</code></td>
<td>
<p>numerical of length <code>NROW(x)</code>, indicating which rows of <code>x</code> are
valid/successful basis evaluations. If <code>NULL</code>, inferred as
<code>rep(TRUE, NROW(x))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sparseMatrix</code> object (if <code>full = FALSE</code>), or a <code>fm_basis</code> object
(if <code>full = TRUE</code> or <code>isTRUE(derivatives)</code>). The <code>fm_basis</code> object contains
at least the projection matrix <code>A</code> and logical vector <code>ok</code>; If <code>x_j</code>
denotes the latent basis coefficient for basis function <code>j</code>, the field is
defined as <code style="white-space: pre;">&#8288;u(loc_i)=sum_j A_ij x_j&#8288;</code> for all <code>i</code> where <code>ok[i]</code> is <code>TRUE</code>,
and <code>u(loc_i)=0.0</code> where <code>ok[i]</code> is <code>FALSE</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_basis(fm_mesh_1d)</code>: If <code>derivatives=TRUE</code>, the <code>fm_basis</code> object contains
additional derivative weight matrices, <code>d1A</code> and <code>d2A</code>, <code style="white-space: pre;">&#8288;du/dx(loc_i)=sum_j dx_ij w_i&#8288;</code>.
</p>
</li>
<li> <p><code>fm_basis(fm_mesh_2d)</code>: If <code>derivatives=TRUE</code>, additional derivative weight
matrices are included in the <code>full=TRUE</code> output: Derivative weight matrices
<code>dx</code>, <code>dy</code>, <code>dz</code>; <code style="white-space: pre;">&#8288;du/dx(loc_i)=sum_j dx_ij w_i&#8288;</code>, etc.
</p>
</li>
<li> <p><code>fm_basis(fm_mesh_3d)</code>: <code>fm_mesh_3d</code> basis functions.
</p>
</li>
<li> <p><code>fm_basis(fm_lattice_2d)</code>: <code>fm_lattice_2d</code> bilinear basis functions.
</p>
</li>
<li> <p><code>fm_basis(fm_lattice_Nd)</code>: <code>fm_lattice_Nd</code> multilinear basis functions.
</p>
</li>
<li> <p><code>fm_basis(fm_tensor)</code>: Evaluates a basis matrix for a <code>fm_tensor</code> function
space.
</p>
</li>
<li> <p><code>fm_basis(matrix)</code>: Creates a new <code>fm_basis</code> object with elements <code>A</code> and
<code>ok</code>, from a pre-evaluated basis matrix, including optional additional
elements in the <code>...</code> arguments. If a <code>ok</code> is <code>NULL</code>, it is inferred as
<code>rep(TRUE, NROW(x))</code>, indicating that all rows correspond to successful
basis evaluations. If <code>full = FALSE</code>,
returns the matrix unchanged.
</p>
</li>
<li> <p><code>fm_basis(Matrix)</code>: Creates a new <code>fm_basis</code> object with elements <code>A</code> and
<code>ok</code>, from a pre-evaluated basis matrix, including optional additional
elements in the <code>...</code> arguments. If a <code>ok</code> is <code>NULL</code>, it is inferred as
<code>rep(TRUE, NROW(x))</code>, indicating that all rows correspond to successful
basis evaluations. If <code>full = FALSE</code>,
returns the matrix unchanged.
</p>
</li>
<li> <p><code>fm_basis(list)</code>: Creates a new <code>fm_basis</code> object from a plain list
containing at least an element <code>A</code>. If an <code>ok</code> element is missing,
it is inferred as <code>rep(TRUE, NROW(x$A))</code>. If <code>full = FALSE</code>,
extracts the <code>A</code> matrix.
</p>
</li>
<li> <p><code>fm_basis(fm_basis)</code>: If <code>full</code> is <code>TRUE</code>, returns <code>x</code> unchanged, otherwise
returns the <code>A</code> matrix contained in <code>x</code>.
</p>
</li>
<li> <p><code>fm_basis(fm_evaluator)</code>: Extract <code>fm_basis</code> information from an <code>fm_evaluator</code>
object. If <code>full = FALSE</code>, returns the <code>A</code> matrix contained in the
<code>fm_basis</code> object.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_raw_basis">fm_raw_basis()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute basis mapping matrix
dim(fm_basis(fmexample$mesh, fmexample$loc))
print(fm_basis(fmexample$mesh, fmexample$loc, full = TRUE))

# From precomputed `fm_bary` information:
bary &lt;- fm_bary(fmexample$mesh, fmexample$loc)
print(fm_basis(fmexample$mesh, bary, full = TRUE))
</code></pre>

<hr>
<h2 id='fm_basis_helpers'>Internal helper functions for mesh field evaluation</h2><span id='topic+fm_basis_helpers'></span><span id='topic+fm_basis_mesh_2d'></span><span id='topic+fm_basis_mesh_1d'></span>

<h3>Description</h3>

<p>Methods called internally by <code><a href="#topic+fm_basis">fm_basis()</a></code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_basis_mesh_2d(
  mesh,
  loc = NULL,
  weights = NULL,
  derivatives = NULL,
  crs = NULL,
  ...
)

fm_basis_mesh_1d(
  mesh,
  loc,
  weights = NULL,
  derivatives = NULL,
  method = deprecated(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_basis_helpers_+3A_loc">loc</code></td>
<td>
<p>A location/value information object (<code>numeric</code>, <code>matrix</code>, <code>sf</code>,
<code>fm_bary</code>, etc, depending on the class of <code>x</code>)</p>
</td></tr>
<tr><td><code id="fm_basis_helpers_+3A_weights">weights</code></td>
<td>
<p>Optional weight vector, one weight for each location</p>
</td></tr>
<tr><td><code id="fm_basis_helpers_+3A_derivatives">derivatives</code></td>
<td>
<p>logical; If true, also return matrices <code>dA</code> and <code>d2A</code>
for <code>fm_mesh_1d</code> objects, and <code>dx</code>, <code>dy</code>, <code>dz</code> for <code>fm_mesh_2d</code>.</p>
</td></tr>
<tr><td><code id="fm_basis_helpers_+3A_...">...</code></td>
<td>
<p>Passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_basis_helpers_+3A_method">method</code></td>
<td>
<p>character; either &quot;default&quot;, &quot;nearest&quot;, &quot;linear&quot;, or
&quot;quadratic&quot;. With <code>NULL</code> or &quot;default&quot;, uses the object definition of the
function space. Otherwise overrides the object definition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fm_basis</code> object; a list of evaluator information objects,
at least a matrix <code>A</code> and logical vector <code>ok</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_basis_mesh_2d(fmexample$mesh, loc = fmexample$loc))

</code></pre>

<hr>
<h2 id='fm_bbox'>Bounding box class</h2><span id='topic+fm_bbox'></span><span id='topic+fm_bbox.list'></span><span id='topic+fm_bbox.NULL'></span><span id='topic+fm_bbox.numeric'></span><span id='topic+fm_bbox.matrix'></span><span id='topic+fm_bbox.Matrix'></span><span id='topic+fm_bbox.fm_bbox'></span><span id='topic+fm_bbox.fm_mesh_1d'></span><span id='topic+fm_bbox.fm_mesh_2d'></span><span id='topic+fm_bbox.fm_mesh_3d'></span><span id='topic+fm_bbox.fm_segm'></span><span id='topic+fm_bbox.fm_lattice_2d'></span><span id='topic+fm_bbox.fm_lattice_Nd'></span><span id='topic+fm_bbox.fm_tensor'></span><span id='topic+fm_bbox.sf'></span><span id='topic+fm_bbox.sfg'></span><span id='topic+fm_bbox.sfc'></span><span id='topic+fm_bbox.bbox'></span><span id='topic+fm_as_bbox'></span><span id='topic++5B.fm_bbox'></span><span id='topic+c.fm_bbox'></span><span id='topic+fm_as_bbox_list'></span>

<h3>Description</h3>

<p>Simple class for handling bounding box information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_bbox(...)

## S3 method for class 'list'
fm_bbox(x, ...)

## S3 method for class 'NULL'
fm_bbox(...)

## S3 method for class 'numeric'
fm_bbox(x, ...)

## S3 method for class 'matrix'
fm_bbox(x, ...)

## S3 method for class 'Matrix'
fm_bbox(x, ...)

## S3 method for class 'fm_bbox'
fm_bbox(x, ...)

## S3 method for class 'fm_mesh_1d'
fm_bbox(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_bbox(x, ...)

## S3 method for class 'fm_mesh_3d'
fm_bbox(x, ...)

## S3 method for class 'fm_segm'
fm_bbox(x, ...)

## S3 method for class 'fm_lattice_2d'
fm_bbox(x, ...)

## S3 method for class 'fm_lattice_Nd'
fm_bbox(x, ...)

## S3 method for class 'fm_tensor'
fm_bbox(x, ...)

## S3 method for class 'sf'
fm_bbox(x, ...)

## S3 method for class 'sfg'
fm_bbox(x, ...)

## S3 method for class 'sfc'
fm_bbox(x, ...)

## S3 method for class 'bbox'
fm_bbox(x, ...)

fm_as_bbox(x, ...)

## S3 method for class 'fm_bbox'
x[i]

## S3 method for class 'fm_bbox'
c(..., .join = FALSE)

fm_as_bbox_list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_bbox_+3A_...">...</code></td>
<td>
<p>Passed on to sub-methods</p>
</td></tr>
<tr><td><code id="fm_bbox_+3A_x">x</code></td>
<td>
<p><code>fm_bbox</code> object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="fm_bbox_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
<tr><td><code id="fm_bbox_+3A_.join">.join</code></td>
<td>
<p>logical; if <code>TRUE</code>, concatenate the bounding boxes into a single
multi-dimensional bounding box. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code><a href="#topic+c.fm_bbox">c.fm_bbox()</a></code>, a <code>fm_bbox_list</code> object if <code>.join = FALSE</code> (the
default) or an <code>fm_bbox</code> object if <code>.join = TRUE</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_bbox(list)</code>: Construct a bounding box from
precomputed interval information, stored as a list of 2-vector ranges,
<code>list(xlim, ylim, ...)</code>.
</p>
</li></ul>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>[</code>: Extract sub-list
</p>
</li>
<li> <p><code>c(fm_bbox)</code>: The <code>...</code> arguments should be <code>fm_bbox</code> objects, or
coercible with <code>fm_as_bbox(list(...))</code>.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_as_bbox_list()</code>: Convert a list to a <code>fm_bbox_list</code> object, with
each element converted to an <code>fm_bbox</code> object.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fm_bbox(matrix(1:6, 3, 2))
m &lt;- c(A = fm_bbox(cbind(1, 2)), B = fm_bbox(cbind(3, 4)))
str(m)
str(m[2])
m &lt;- fm_as_bbox_list(list(
  A = fm_bbox(cbind(1, 2)),
  B = fm_bbox(cbind(3, 4))
))
str(fm_as_bbox_list(m))
</code></pre>

<hr>
<h2 id='fm_block'>Blockwise aggregation matrices</h2><span id='topic+fm_block'></span><span id='topic+fm_block_eval'></span><span id='topic+fm_block_logsumexp_eval'></span><span id='topic+fm_block_weights'></span><span id='topic+fm_block_log_weights'></span><span id='topic+fm_block_log_shift'></span><span id='topic+fm_block_prep'></span>

<h3>Description</h3>

<p>Creates an aggregation matrix for blockwise aggregation, with optional
weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_block(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL
)

fm_block_eval(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL,
  values = NULL
)

fm_block_logsumexp_eval(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL,
  values = NULL,
  log = TRUE
)

fm_block_weights(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL
)

fm_block_log_weights(
  block = NULL,
  weights = NULL,
  log_weights = NULL,
  rescale = FALSE,
  n_block = NULL
)

fm_block_log_shift(block = NULL, log_weights = NULL, n_block = NULL)

fm_block_prep(
  block = NULL,
  log_weights = NULL,
  weights = NULL,
  n_block = NULL,
  values = NULL,
  n_values = NULL,
  force_log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_block_+3A_block">block</code></td>
<td>
<p>integer vector; block information. If <code>NULL</code>,
<code>rep(1L, block_len)</code> is used, where <code>block_len</code> is determined by
<code style="white-space: pre;">&#8288;length(log_weights)))&#8288;</code> or <code style="white-space: pre;">&#8288;length(weights)))&#8288;</code>. A single scalar is also
repeated to a vector of corresponding length to the weights. 'character'
input is converted to integer with <code>as.integer(factor(block))</code> (from
<code style="white-space: pre;">&#8288;0.2.0.9017&#8288;</code>).</p>
</td></tr>
<tr><td><code id="fm_block_+3A_weights">weights</code></td>
<td>
<p>Optional weight vector</p>
</td></tr>
<tr><td><code id="fm_block_+3A_log_weights">log_weights</code></td>
<td>
<p>Optional <code>log(weights)</code> vector. Overrides <code>weights</code> when
non-NULL.</p>
</td></tr>
<tr><td><code id="fm_block_+3A_rescale">rescale</code></td>
<td>
<p>logical; If <code>TRUE</code>, normalise the weights by <code>sum(weights)</code>
or <code>sum(exp(log_weights))</code> within each block.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fm_block_+3A_n_block">n_block</code></td>
<td>
<p>integer; The number of conceptual blocks. Only needs to be
specified if it's larger than <code>max(block)</code>, or to keep the output of
consistent size for different inputs.</p>
</td></tr>
<tr><td><code id="fm_block_+3A_values">values</code></td>
<td>
<p>Vector to be blockwise aggregated</p>
</td></tr>
<tr><td><code id="fm_block_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code> (default), return log-sum-exp. If <code>FALSE</code>,
return sum-exp.</p>
</td></tr>
<tr><td><code id="fm_block_+3A_n_values">n_values</code></td>
<td>
<p>When supplied, used instead of <code>length(values)</code> to determine
the value vector input length.</p>
</td></tr>
<tr><td><code id="fm_block_+3A_force_log">force_log</code></td>
<td>
<p>When <code>FALSE</code> (default),
passes either <code>weights</code> and <code>log_weights</code> on, if provided, with <code>log_weights</code>
taking precedence. If <code>TRUE</code>, forces the computation of <code>log_weights</code>,
whether given in the input or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (sparse) matrix
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_block()</code>: A (sparse) matrix of size <code>n_block</code> times
<code>length(block)</code>.
</p>
</li>
<li> <p><code>fm_block_eval()</code>: Evaluate aggregation. More efficient alternative to to
<code>as.vector(fm_block(...) %*% values)</code>.
</p>
</li>
<li> <p><code>fm_block_logsumexp_eval()</code>: Evaluate log-sum-exp aggregation.
More efficient and numerically stable alternative to to
<code>log(as.vector(fm_block(...) %*% exp(values)))</code>.
</p>
</li>
<li> <p><code>fm_block_weights()</code>: Computes (optionally) blockwise renormalised weights
</p>
</li>
<li> <p><code>fm_block_log_weights()</code>: Computes (optionally) blockwise renormalised log-weights
</p>
</li>
<li> <p><code>fm_block_log_shift()</code>: Computes shifts for stable blocked log-sum-exp.
To compute <code class="reqn">\log(\sum_{i; \textrm{block}_i=k} \exp(v_i) w_i)</code> for
each block <code>k</code>, first compute combined values and weights, and a shift:
</p>
<div class="sourceCode"><pre>w_values &lt;- values + fm_block_log_weights(block, log_weights = log_weights)
shift &lt;- fm_block_log_shift(block, log_weights = w_values)
</pre></div>
<p>Then aggregate the values within each block:
</p>
<div class="sourceCode"><pre>agg &lt;- aggregate(exp(w_values - shift[block]),
                 by = list(block = block),
                 \(x) log(sum(x)))
agg$x &lt;- agg$x + shift[agg$block]
</pre></div>
<p>The implementation uses a faster method:
</p>
<div class="sourceCode"><pre>as.vector(
  Matrix::sparseMatrix(
    i = block,
    j = rep(1L, length(block)),
    x = exp(w_values - shift[block]),
    dims = c(n_block, 1))
) + shift
</pre></div>
</li>
<li> <p><code>fm_block_prep()</code>: Helper function for preparing <code>block</code>, <code>weights</code>, and
<code>log_weights</code>, <code>n_block</code> inputs.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>block &lt;- rep(1:2, 3:2)
fm_block(block)
fm_block(block, rescale = TRUE)
fm_block(block, log_weights = -2:2, rescale = TRUE)
fm_block_eval(
  block,
  weights = 1:5,
  rescale = TRUE,
  values = 11:15
)
fm_block_logsumexp_eval(
  block,
  weights = 1:5,
  rescale = TRUE,
  values = log(11:15),
  log = FALSE
)
</code></pre>

<hr>
<h2 id='fm_centroids'>Extract triangle centroids from an <code>fm_mesh_2d</code></h2><span id='topic+fm_centroids'></span>

<h3>Description</h3>

<p>Computes the centroids of the triangles of an <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_centroids(x, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_centroids_+3A_x">x</code></td>
<td>
<p>An <code>fm_mesh_2d</code> object.</p>
</td></tr>
<tr><td><code id="fm_centroids_+3A_format">format</code></td>
<td>
<p>character; <code>"sf"</code>, <code>"df"</code>, <code>"sp"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code>, <code>data.frame</code>, or <code>SpatialPointsDataFrame</code> object, with the vertex
coordinates, and a <code>.triangle</code> column with the triangle indices.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_vertices">fm_vertices()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE)) {
  vrt &lt;- fm_centroids(fmexample$mesh, format = "sf")
  ggplot() +
    geom_sf(data = fm_as_sfc(fmexample$mesh)) +
    geom_sf(data = vrt, color = "red")
}

</code></pre>

<hr>
<h2 id='fm_contains'>Check which mesh triangles are inside a polygon</h2><span id='topic+fm_contains'></span><span id='topic+fm_contains.Spatial'></span><span id='topic+fm_contains.sf'></span><span id='topic+fm_contains.sfc'></span>

<h3>Description</h3>

<p>Wrapper for the <code><a href="sf.html#topic+geos_binary_pred">sf::st_contains()</a></code> (previously <code>sp::over()</code>) method to find
triangle centroids or vertices inside <code>sf</code> or <code>sp</code> polygon objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_contains(x, y, ...)

## S3 method for class 'Spatial'
fm_contains(x, y, ...)

## S3 method for class 'sf'
fm_contains(x, y, ...)

## S3 method for class 'sfc'
fm_contains(x, y, ..., type = c("centroid", "vertex"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_contains_+3A_x">x</code></td>
<td>
<p>geometry (typically an <code>sf</code> or <code>sp::SpatialPolygons</code> object) for the
queries</p>
</td></tr>
<tr><td><code id="fm_contains_+3A_y">y</code></td>
<td>
<p>an <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object</p>
</td></tr>
<tr><td><code id="fm_contains_+3A_...">...</code></td>
<td>
<p>Passed on to other methods</p>
</td></tr>
<tr><td><code id="fm_contains_+3A_type">type</code></td>
<td>
<p>the query type; either <code>'centroid'</code> (default, for triangle
centroids), or <code>'vertex'</code> (for mesh vertices)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of vectors of triangle indices (when <code>type</code> is <code>'centroid'</code>) or
vertex indices (when <code>type</code> is <code>'vertex'</code>). The list has one entry per row
of the <code>sf</code> object. Use <code>unlist(fm_contains(...))</code> if the combined union is
needed.
</p>


<h3>Author(s)</h3>

<p>Haakon Bakka, <a href="mailto:bakka@r-inla.org">bakka@r-inla.org</a>, and Finn Lindgren
<a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (TRUE &amp;&amp;
  fm_safe_sp()) {
  # Create a polygon and a mesh
  obj &lt;- sp::SpatialPolygons(
    list(sp::Polygons(
      list(sp::Polygon(rbind(
        c(0, 0),
        c(50, 0),
        c(50, 50),
        c(0, 50)
      ))),
      ID = 1
    )),
    proj4string = fm_CRS("longlat_globe")
  )
  mesh &lt;- fm_rcdt_2d_inla(globe = 2, crs = fm_crs("sphere"))

  ## 3 vertices found in the polygon
  fm_contains(obj, mesh, type = "vertex")

  ## 3 triangles found in the polygon
  fm_contains(obj, mesh)

  ## Multiple transformations can lead to slightly different results
  ## due to edge cases:
  ## 4 triangles found in the polygon
  fm_contains(
    obj,
    fm_transform(mesh, crs = fm_crs("mollweide_norm"))
  )
}

</code></pre>

<hr>
<h2 id='fm_cprod'>(Blockwise) cross product of integration points</h2><span id='topic+fm_cprod'></span>

<h3>Description</h3>

<p>Calculates the groupwise cross product of integration points in different
dimensions and multiplies their weights accordingly.
If the object defining points in a particular dimension has no
weights attached to it all weights are assumed to be 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_cprod(..., na.rm = NULL, .blockwise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_cprod_+3A_...">...</code></td>
<td>
<p><code>tibble</code>, <code>data.frame</code>, <code>sf</code>, or <code>SpatialPointsDataFrame</code> objects,
each one usually obtained by a call to an <code><a href="#topic+fm_int">fm_int()</a></code> method.</p>
</td></tr>
<tr><td><code id="fm_cprod_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, the rows with weight <code>NA</code> from the
non-overlapping full_join will be removed; if <code>FALSE</code>, set the undefined
weights to <code>NA</code>. If <code>NULL</code> (default), act as <code>TRUE</code>, but warn if any
elements needed removing.</p>
</td></tr>
<tr><td><code id="fm_cprod_+3A_.blockwise">.blockwise</code></td>
<td>
<p>logical; if <code>FALSE</code>, computes full tensor product
integration. If <code>TRUE</code>, computes within-block tensor product integration
(used internally by <code><a href="#topic+fm_int">fm_int()</a></code>). Default <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, <code>sf</code>, or <code>SpatialPointsDataFrame</code> of
multidimensional integration points and their weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2")) {
  # Create integration points in dimension 'myDim' and 'myDiscreteDim'
  ips1 &lt;- fm_int(fm_mesh_1d(1:20),
    rbind(c(0, 3), c(3, 8)),
    name = "myDim"
  )
  ips2 &lt;- fm_int(domain = c(1, 2, 4), name = "myDiscreteDim")

  # Calculate the cross product
  ips &lt;- fm_cprod(ips1, ips2)

  # Plot the integration points
  ggplot(ips) +
    geom_point(aes(myDim, myDiscreteDim, size = weight)) +
    scale_size_area()
}

</code></pre>

<hr>
<h2 id='fm_crs'>Obtain coordinate reference system object</h2><span id='topic+fm_crs'></span><span id='topic+fm_crs_oblique'></span><span id='topic+st_crs.fm_crs'></span><span id='topic++24.fm_crs'></span><span id='topic+fm_crs.default'></span><span id='topic+fm_crs.crs'></span><span id='topic+fm_crs.fm_crs'></span><span id='topic+fm_crs.fm_CRS'></span><span id='topic+fm_crs.character'></span><span id='topic+fm_crs.Spatial'></span><span id='topic+fm_crs.SpatVector'></span><span id='topic+fm_crs.SpatRaster'></span><span id='topic+fm_crs.sf'></span><span id='topic+fm_crs.sfc'></span><span id='topic+fm_crs.sfg'></span><span id='topic+fm_crs.fm_mesh_2d'></span><span id='topic+fm_crs.fm_mesh_1d'></span><span id='topic+fm_crs.fm_mesh_3d'></span><span id='topic+fm_crs.fm_lattice_2d'></span><span id='topic+fm_crs.fm_segm'></span><span id='topic+fm_crs.fm_list'></span><span id='topic+fm_crs.matrix'></span><span id='topic+fm_CRS.fm_list'></span><span id='topic+fm_wkt_predef'></span><span id='topic+fm_crs.inla.CRS'></span>

<h3>Description</h3>

<p>Obtain an <code>sf::crs</code> or <code>fm_crs</code> object from a spatial object, or
convert crs information to construct a new <code>sf::crs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_crs(x, oblique = NULL, ..., crsonly = deprecated())

fm_crs_oblique(x)

## S3 method for class 'fm_crs'
st_crs(x, ...)

## S3 method for class 'fm_crs'
x$name

## Default S3 method:
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'crs'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_crs'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_CRS'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'character'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'Spatial'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'SpatVector'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'SpatRaster'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'sf'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'sfc'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'sfg'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_mesh_2d'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_mesh_1d'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_mesh_3d'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_lattice_2d'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_segm'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_list'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'matrix'
fm_crs(x, oblique = NULL, ...)

## S3 method for class 'fm_list'
fm_CRS(x, oblique = NULL, ...)

fm_wkt_predef()

## S3 method for class 'inla.CRS'
fm_crs(x, oblique = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_crs_+3A_x">x</code></td>
<td>
<p>Object to convert to <code>crs</code> or  to extract <code>crs</code> information from.
If <code>character</code>, a string suitable for <code>sf::st_crs(x)</code>, or the name of a
predefined <code>wkt</code> string from &ldquo;names(fm_wkt_predef())'.</p>
</td></tr>
<tr><td><code id="fm_crs_+3A_oblique">oblique</code></td>
<td>
<p>Numeric vector of length at most 4 of rotation angles (in
degrees) for an oblique projection, all values defaulting to zero. The
values indicate (longitude, latitude, orientation, orbit), as explained in
the Details section below. When <code>oblique</code> is non-NULL, used to override the
obliqueness parameters of a <code>fm_crs</code> object. When <code>NA</code>, remove obliqueness
from the object, resulting in a return class of <code>sf::st_crs()</code>. When
<code>NULL</code>, pass though any oblique information in the object, returning an
<code>fm_crs()</code> object if needed.</p>
</td></tr>
<tr><td><code id="fm_crs_+3A_...">...</code></td>
<td>
<p>Additional parameters. Not currently in use.</p>
</td></tr>
<tr><td><code id="fm_crs_+3A_crsonly">crsonly</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> logical;
if TRUE, remove <code>oblique</code> information from <code>fm_crs</code>
objects and return a plain <code>crs</code> object instead. For <code>crsonly = TRUE</code>, use
<code>oblique = NA</code> instead. For <code>crsonly = FALSE</code>, use default, NULL, or non-NA
<code>oblique</code>.</p>
</td></tr>
<tr><td><code id="fm_crs_+3A_name">name</code></td>
<td>
<p>element name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two
elements of the <code>oblique</code> vector are the (longitude, latitude)
coordinates for the oblique centre point. The third value (orientation) is a
counter-clockwise rotation angle for an observer looking at the centre point
from outside the sphere. The fourth value is the quasi-longitude (orbit
angle) for a rotation along the oblique observers equator.
</p>
<p>Simple oblique: <code>oblique=c(0, 45)</code>
</p>
<p>Polar: <code>oblique=c(0, 90)</code>
</p>
<p>Quasi-transversal: <code>oblique=c(0, 0, 90)</code>
</p>
<p>Satellite orbit viewpoint: <code>oblique=c(lon0-time*v1, 0, orbitangle, orbit0+time*v2)</code>, where <code>lon0</code> is the longitude at which a satellite
orbit crosses the equator at <code>time=0</code>, when the satellite is at an
angle <code>orbit0</code> further along in its orbit.  The orbital angle relative
to the equatorial plane is <code>orbitangle</code>, and <code>v1</code> and <code>v2</code>
are the angular velocities of the planet and the satellite, respectively.
Note that &quot;forward&quot; from the satellite's point of view is &quot;to the right&quot; in
the projection.
</p>
<p>When <code>oblique[2]</code> or <code>oblique[3]</code> are non-zero, the resulting
projection is only correct for perfect spheres.
</p>


<h3>Value</h3>

<p>Either an <code>sf::crs</code> object or an <code>fm_crs</code> object,
depending on if the coordinate reference system described by the parameters
can be expressed with a pure <code>crs</code> object or not.
</p>
<p>A <code>crs</code> object (<code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>) or a <code>fm_crs</code> object.
An S3 <code>fm_crs</code> object is a list with elements <code>crs</code> and <code>oblique</code>.
</p>
<p><code>fm_wkt_predef</code> returns a WKT2 string defining a projection
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_crs(fm_list)</code>: returns a list of 'crs' objects, one for each list element
</p>
</li></ul>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>st_crs(fm_crs)</code>: <code>st_crs(x, ...)</code> is equivalent to
<code style="white-space: pre;">&#8288;fm_crs(x, ... oblique = NA)&#8288;</code>
when <code>x</code> is a <code>fm_crs</code> object.
</p>
</li>
<li> <p><code>$</code>: For a <code>fm_crs</code> object <code>x</code>, <code>x$name</code> calls the accessor
method for the <code>crs</code> object inside it. If <code>name</code> is &quot;crs&quot;, the internal crs
object itself is returned. If <code>name</code> is &quot;oblique&quot;, the internal oblique
angle parameter vector is returned.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_crs_oblique()</code>: Return <code>NA</code> for object with no oblique information,
and otherwise a length 4 numeric vector.
</p>
</li>
<li> <p><code>fm_CRS(fm_list)</code>: returns a list of 'CRS' objects, one for each list element
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>, <code><a href="#topic+fm_crs_wkt">fm_crs_wkt</a></code>
</p>
<p>fm_crs_is_null
</p>
<p><code><a href="#topic+fm_crs+3C-">fm_crs&lt;-()</a></code>, <code><a href="#topic+fm_crs_oblique+3C-">fm_crs_oblique&lt;-()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crs1 &lt;- fm_crs("longlat_globe")
crs2 &lt;- fm_crs("lambert_globe")
crs3 &lt;- fm_crs("mollweide_norm")
crs4 &lt;- fm_crs("hammer_globe")
crs5 &lt;- fm_crs("sphere")
crs6 &lt;- fm_crs("globe")
names(fm_wkt_predef())
</code></pre>

<hr>
<h2 id='fm_CRS'>Create a coordinate reference system object</h2><span id='topic+fm_CRS'></span><span id='topic+is.na.fm_CRS'></span><span id='topic+fm_CRS.crs'></span><span id='topic+fm_CRS.fm_crs'></span><span id='topic+fm_CRS.Spatial'></span><span id='topic+fm_CRS.fm_CRS'></span><span id='topic+fm_CRS.SpatVector'></span><span id='topic+fm_CRS.SpatRaster'></span><span id='topic+fm_CRS.sf'></span><span id='topic+fm_CRS.sfc'></span><span id='topic+fm_CRS.sfg'></span><span id='topic+fm_CRS.fm_mesh_2d'></span><span id='topic+fm_CRS.fm_lattice'></span><span id='topic+fm_CRS.fm_segm'></span><span id='topic+fm_CRS.matrix'></span><span id='topic+fm_CRS.CRS'></span><span id='topic+fm_CRS.default'></span><span id='topic+is.na.inla.CRS'></span><span id='topic+fm_CRS.inla.CRS'></span>

<h3>Description</h3>

<p>Creates either a CRS object or an inla.CRS object, describing a coordinate
reference system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_CRS'
is.na(x)

## S3 method for class 'crs'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_crs'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'Spatial'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_CRS'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'SpatVector'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'SpatRaster'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'sf'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'sfc'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'sfg'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_mesh_2d'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_lattice'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'fm_segm'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'matrix'
fm_CRS(x, oblique = NULL, ...)

## S3 method for class 'CRS'
fm_CRS(x, oblique = NULL, ...)

## Default S3 method:
fm_CRS(
  x,
  oblique = NULL,
  projargs = NULL,
  doCheckCRSArgs = NULL,
  args = NULL,
  SRS_string = NULL,
  ...
)

## S3 method for class 'inla.CRS'
is.na(x)

## S3 method for class 'inla.CRS'
fm_CRS(x, oblique = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_CRS_+3A_x">x</code></td>
<td>
<p>Object to convert to CRS or to extract CRS information from.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_oblique">oblique</code></td>
<td>
<p>Vector of length at most 4 of rotation angles (in degrees)
for an oblique projection, all values defaulting to zero. The values
indicate (longitude, latitude, orientation, orbit), as explained in the
Details section for <code><a href="#topic+fm_crs">fm_crs()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_...">...</code></td>
<td>
<p>Additional parameters, passed on to sub-methods.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_projargs">projargs</code></td>
<td>
<p>Either 1) a projection argument string suitable as input to
<code>sp::CRS</code>, or 2) an existing <code>CRS</code> object, or 3) a shortcut
reference string to a predefined projection; run
<code>names(fm_wkt_predef())</code> for valid predefined projections. (projargs is a
compatibility parameter that can be used for the default <code>fm_CRS()</code> method)</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_docheckcrsargs">doCheckCRSArgs</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_args">args</code></td>
<td>
<p>An optional list of name/value pairs to add to and/or override
the PROJ4 arguments in <code>projargs</code>.  <code>name=value</code> is converted to
<code>"+name=value"</code>, and <code>name=NA</code> is converted to <code>"+name"</code>.</p>
</td></tr>
<tr><td><code id="fm_CRS_+3A_srs_string">SRS_string</code></td>
<td>
<p>a WKT2 string defining the coordinate system;
see <code>sp::CRS</code>. This takes precedence over <code>projargs</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two
elements of the <code>oblique</code> vector are the (longitude, latitude)
coordinates for the oblique centre point. The third value (orientation) is a
counterclockwise rotation angle for an observer looking at the centre point
from outside the sphere. The fourth value is the quasi-longitude (orbit
angle) for a rotation along the oblique observers equator.
</p>
<p>Simple oblique: <code>oblique=c(0, 45)</code>
</p>
<p>Polar: <code>oblique=c(0, 90)</code>
</p>
<p>Quasi-transversal: <code>oblique=c(0, 0, 90)</code>
</p>
<p>Satellite orbit viewpoint: <code>oblique=c(lon0-time*v1, 0, orbitangle, orbit0+time*v2)</code>, where <code>lon0</code> is the longitude at which a satellite
orbit crosses the equator at <code>time=0</code>, when the satellite is at an
angle <code>orbit0</code> further along in its orbit.  The orbital angle relative
to the equatorial plane is <code>orbitangle</code>, and <code>v1</code> and <code>v2</code>
are the angular velocities of the planet and the satellite, respectively.
Note that &quot;forward&quot; from the satellite's point of view is &quot;to the right&quot; in
the projection.
</p>
<p>When <code>oblique[2]</code> or <code>oblique[3]</code> are non-zero, the resulting
projection is only correct for perfect spheres.
</p>


<h3>Value</h3>

<p>Either an <code>sp::CRS</code> object or an <code>inla.CRS</code> object,
depending on if the coordinate reference system described by the parameters
can be expressed with a pure <code>sp::CRS</code> object or not.
</p>
<p>An S3 <code>inla.CRS</code> object is a list, usually (but not necessarily)
containing at least one element: </p>
<table role = "presentation">
<tr><td><code>crs</code></td>
<td>
<p>The basic <code>sp::CRS</code>
object</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>is.na(fm_CRS)</code>: Check if a <code>fm_CRS</code> has <code>NA</code> crs information and <code>NA</code>
obliqueness
</p>
</li>
<li> <p><code>is.na(inla.CRS)</code>: Check if a <code>inla.CRS</code> has <code>NA</code> crs information and <code>NA</code>
obliqueness
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>, <code><a href="sp.html#topic+CRS-class">sp::CRS()</a></code>, <code><a href="#topic+fm_crs_wkt">fm_crs_wkt</a></code>,
<code><a href="#topic+fm_sp_get_crs">fm_sp_get_crs()</a></code>, <code><a href="#topic+fm_crs_is_identical">fm_crs_is_identical()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (fm_safe_sp()) {
  crs1 &lt;- fm_CRS("longlat_globe")
  crs2 &lt;- fm_CRS("lambert_globe")
  crs3 &lt;- fm_CRS("mollweide_norm")
  crs4 &lt;- fm_CRS("hammer_globe")
  crs5 &lt;- fm_CRS("sphere")
  crs6 &lt;- fm_CRS("globe")
}
</code></pre>

<hr>
<h2 id='fm_CRS_as_list'>Show expanded CRS arguments</h2><span id='topic+fm_CRS_as_list'></span><span id='topic+fm_list_as_CRS'></span><span id='topic+fm_CRSargs'></span><span id='topic+fm_CRSargs_as_list'></span><span id='topic+fm_list_as_CRSargs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Wrappers for <code>sp::CRS</code> and <code>inla.CRS</code> objects to handle the
coordinate reference system argument string.
These methods should no longer be used with PROJ6/rgdal3;
see <code><a href="#topic+fm_wkt">fm_wkt()</a></code> and <code><a href="#topic+fm_proj4string">fm_proj4string()</a></code> for a new approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_CRS_as_list(x, ...)

fm_list_as_CRS(x, ...)

fm_CRSargs(x, ...)

fm_list_as_CRSargs(x, ...)

fm_CRSargs_as_list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_CRS_as_list_+3A_x">x</code></td>
<td>
<p>An <code>sp::CRS</code> or <code>inla.CRS</code> object (for
<code>fm_CRSargs</code> and <code>fm_CRS_as_list</code>), a character string (for
<code>fm_CRSargs_as_list</code>), or a list (for <code>fm_list_as_CRS</code> and
<code>fm_list_as_CRSargs</code>).</p>
</td></tr>
<tr><td><code id="fm_CRS_as_list_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>fm_CRSargs</code> and <code>fm_list_as_CRSargs</code>, a character
string with PROJ.4 arguments.
</p>
<p>For <code>fm_CRS_as_list</code> and <code>fm_CRSargs_as_list</code>, a list of
name/value pairs.
</p>
<p>For <code>fm_list_as_CRS</code>, a <code>CRS</code> or <code>inla.CRS</code> object.
</p>
<p>For <code>fm_list_as_CRSargs()</code>, a CRS proj4 string for name=value pair
list
</p>
<p>For <code>fm_CRSargs_as_list()</code>, a list of name=value pairs from CRS
proj4string
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_CRS">fm_CRS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (fm_safe_sp()) {
  crs0 &lt;- fm_CRS("longlat_norm")
  p4s &lt;- fm_proj4string(crs0)
  lst &lt;- fm_CRSargs_as_list(p4s)
  crs1 &lt;- fm_list_as_CRS(lst)
  lst$a &lt;- 2
  crs2 &lt;- fm_CRS(p4s, args = lst)
  print(fm_proj4string(crs0))
  print(fm_proj4string(crs1))
  print(fm_proj4string(crs2))
}
</code></pre>

<hr>
<h2 id='fm_crs_is_identical'>Check if two CRS objects are identical</h2><span id='topic+fm_crs_is_identical'></span><span id='topic+fm_identical_CRS'></span>

<h3>Description</h3>

<p>Check if two CRS objects are identical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_crs_is_identical(crs0, crs1, crsonly = FALSE)

fm_identical_CRS(crs0, crs1, crsonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_crs_is_identical_+3A_crs0">crs0</code>, <code id="fm_crs_is_identical_+3A_crs1">crs1</code></td>
<td>
<p>Two <code>sf::crs</code>, <code>sp::CRS</code>, <code>fm_crs</code> or <code>inla.CRS</code> objects to
be compared.</p>
</td></tr>
<tr><td><code id="fm_crs_is_identical_+3A_crsonly">crsonly</code></td>
<td>
<p>logical. If <code>TRUE</code> and any of <code>crs0</code> and <code>crs1</code> are <code>fm_crs</code>
or <code>inla.CRS</code> objects, extract and compare only the <code>sf::crs</code> or <code>sp::CRS</code>
aspects. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, indicating if the two crs objects are identical in the
specified sense (see the <code>crsonly</code> argument)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_identical_CRS()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
by <code>fm_crs_is_identical()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>, <a href="#topic+fm_crs">fm_CRS()</a>, <code><a href="#topic+fm_crs_is_null">fm_crs_is_null()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
crs0 &lt;- crs1 &lt;- fm_crs("longlat_globe")
fm_crs_oblique(crs1) &lt;- c(0, 90)
print(c(
  fm_crs_is_identical(crs0, crs0),
  fm_crs_is_identical(crs0, crs1),
  fm_crs_is_identical(crs0, crs1, crsonly = TRUE)
))
</code></pre>

<hr>
<h2 id='fm_crs_is_null'>Check if a crs is NULL or NA</h2><span id='topic+fm_crs_is_null'></span><span id='topic+is.na.fm_crs'></span>

<h3>Description</h3>

<p>Methods of checking whether various kinds of CRS objects are <code>NULL</code> or <code>NA</code>.
Logically equivalent to either <code>is.na(fm_crs(x))</code> or
<code>is.na(fm_crs(x, oblique = NA))</code>, but with a short-cut pre-check for
<code>is.null(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_crs_is_null(x, crsonly = FALSE)

## S3 method for class 'fm_crs'
is.na(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_crs_is_null_+3A_x">x</code></td>
<td>
<p>An object supported by <code>fm_crs(x)</code></p>
</td></tr>
<tr><td><code id="fm_crs_is_null_+3A_crsonly">crsonly</code></td>
<td>
<p>For crs objects with extended functionality, such as
<code><a href="#topic+fm_crs">fm_crs()</a></code> objects with <code>oblique</code> information, <code>crsonly = TRUE</code> only checks
the plain CRS part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_crs_is_null()</code>: Check if an object is or has <code>NULL</code> or <code>NA</code> CRS
information. If not <code>NULL</code>, <code>is.na(fm_crs(x))</code> is returned. This allows the
input to be e.g. a proj4string or epsg number, since the default <code><a href="#topic+fm_crs">fm_crs()</a></code>
method passes its argument on to <code>sf::st_crs()</code>.
</p>
</li>
<li> <p><code>is.na(fm_crs)</code>: Check if a <code>fm_crs</code> has <code>NA</code> crs information and
<code>NA</code> obliqueness
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>, <a href="#topic+fm_crs">fm_CRS()</a>, <code><a href="#topic+fm_crs_is_identical">fm_crs_is_identical()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_crs_is_null(NULL)
fm_crs_is_null(27700)
fm_crs_is_null(fm_crs())
fm_crs_is_null(fm_crs(27700))
fm_crs_is_null(fm_crs(oblique = c(1, 2, 3, 4)))
fm_crs_is_null(fm_crs(oblique = c(1, 2, 3, 4)), crsonly = TRUE)
fm_crs_is_null(fm_crs(27700, oblique = c(1, 2, 3, 4)))
fm_crs_is_null(fm_crs(27700, oblique = c(1, 2, 3, 4)), crsonly = TRUE)

</code></pre>

<hr>
<h2 id='fm_crs_plot'>Plot CRS and fm_crs objects</h2><span id='topic+fm_crs_plot'></span><span id='topic+fm_crs_graticule'></span><span id='topic+fm_crs_tissot'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Plot the outline of a <code>crs</code>
or <code><a href="#topic+fm_crs">fm_crs()</a></code> projection, with optional graticules (transformed parallels
and meridians) and Tissot indicatrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_crs_plot(
  x,
  xlim = NULL,
  ylim = NULL,
  outline = TRUE,
  graticule = c(15, 15, 45),
  tissot = c(30, 30, 30),
  asp = 1,
  add = FALSE,
  eps = 0.05,
  ...
)

fm_crs_graticule(
  x,
  by = c(15, 15, 45),
  add = FALSE,
  do.plot = TRUE,
  eps = 0.05,
  ...
)

fm_crs_tissot(
  x,
  by = c(30, 30, 30),
  add = FALSE,
  do.plot = TRUE,
  eps = 0.05,
  diff.eps = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_crs_plot_+3A_x">x</code></td>
<td>
<p>A <code>crs</code> or <code><a href="#topic+fm_crs">fm_crs()</a></code> object.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_xlim">xlim</code></td>
<td>
<p>Optional x-axis limits.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_ylim">ylim</code></td>
<td>
<p>Optional y-axis limits.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_outline">outline</code></td>
<td>
<p>Logical, if <code>TRUE</code>, draw the outline of the projection.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_graticule">graticule</code></td>
<td>
<p>Vector of length at most 3, to plot meridians with spacing
<code>graticule[1]</code> degrees and parallels with spacing <code>graticule[2]</code>
degrees. <code>graticule[3]</code> optionally specifies the spacing above and
below the first and last parallel.  When <code>graticule[1]==0</code> no meridians
are drawn, and when <code>graticule[2]==0</code> no parallels are drawn. Use
<code>graticule=NULL</code> to skip drawing a graticule.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_tissot">tissot</code></td>
<td>
<p>Vector of length at most 3, to plot Tissot's indicatrices with
spacing <code>tissot[1]</code> degrees and parallels with spacing <code>tissot[2]</code>
degrees. <code>tissot[3]</code> specifices a scaling factor.  Use
<code>tissot=NULL</code> to skip drawing a Tissot's indicatrices.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_asp">asp</code></td>
<td>
<p>The aspect ratio for the plot, default 1.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, add the projecton plot to an existing plot.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_eps">eps</code></td>
<td>
<p>Clipping tolerance for rudimentary boundary clipping</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the internal calls to
<code>plot</code> and <code>lines</code>.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_by">by</code></td>
<td>
<p>The spacing between <code style="white-space: pre;">&#8288;(long, lat, long_at_poles)&#8288;</code>
graticules/indicatrices, see the <code>graticule</code> and <code>tissot</code> arguments.</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_do.plot">do.plot</code></td>
<td>
<p>logical; If TRUE, do plotting</p>
</td></tr>
<tr><td><code id="fm_crs_plot_+3A_diff.eps">diff.eps</code></td>
<td>
<p>Pre-scaling</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_crs_graticule()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Constructs graticule
information for a given <code>CRS</code> or <code><a href="#topic+fm_crs">fm_crs()</a></code> and optionally plots the
graticules.
Returns a list with two elements, <code>meridians</code> and <code>parallels</code>, which are
<code>SpatialLines</code> objects.
</p>
</li>
<li> <p><code>fm_crs_tissot()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Constructs Tissot indicatrix information
for a given <code>CRS</code> or <code><a href="#topic+fm_crs">fm_crs()</a></code> and optionally plots the indicatrices.
Returns a list with one element, <code>tissot</code>, which is a <code>SpatialLines</code> object.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("sf") &amp;&amp; require("sp")) {
  for (projtype in c(
    "longlat_norm",
    "lambert_norm",
    "mollweide_norm",
    "hammer_norm"
  )) {
    fm_crs_plot(fm_crs(projtype), main = projtype)
  }
}

if (require("sf") &amp;&amp; require("sp")) {
  oblique &lt;- c(0, 45, 45, 0)
  for (projtype in c(
    "longlat_norm",
    "lambert_norm",
    "mollweide_norm",
    "hammer_norm"
  )) {
    fm_crs_plot(
      fm_crs(projtype, oblique = oblique),
      main = paste("oblique", projtype)
    )
  }
}

</code></pre>

<hr>
<h2 id='fm_crs_wkt'>Handling CRS/WKT</h2><span id='topic+fm_crs_wkt'></span><span id='topic+fm_wkt_is_geocent'></span><span id='topic+fm_crs_is_geocent'></span><span id='topic+fm_wkt_get_ellipsoid_radius'></span><span id='topic+fm_crs_get_ellipsoid_radius'></span><span id='topic+fm_ellipsoid_radius'></span><span id='topic+fm_ellipsoid_radius.default'></span><span id='topic+fm_ellipsoid_radius.character'></span><span id='topic+fm_wkt_set_ellipsoid_radius'></span><span id='topic+fm_ellipsoid_radius+3C-'></span><span id='topic+fm_ellipsoid_radius+3C-.character'></span><span id='topic+fm_ellipsoid_radius+3C-.CRS'></span><span id='topic+fm_ellipsoid_radius+3C-.fm_CRS'></span><span id='topic+fm_ellipsoid_radius+3C-.crs'></span><span id='topic+fm_ellipsoid_radius+3C-.fm_crs'></span><span id='topic+fm_crs_set_ellipsoid_radius'></span><span id='topic+fm_wkt_unit_params'></span><span id='topic+fm_wkt_get_lengthunit'></span><span id='topic+fm_wkt_set_lengthunit'></span><span id='topic+fm_crs_get_lengthunit'></span><span id='topic+fm_crs_set_lengthunit'></span><span id='topic+fm_length_unit'></span><span id='topic+fm_length_unit.default'></span><span id='topic+fm_length_unit.character'></span><span id='topic+fm_length_unit+3C-'></span><span id='topic+fm_length_unit+3C-.character'></span><span id='topic+fm_length_unit+3C-.CRS'></span><span id='topic+fm_length_unit+3C-.fm_CRS'></span><span id='topic+fm_length_unit+3C-.crs'></span><span id='topic+fm_length_unit+3C-.fm_crs'></span><span id='topic+fm_wkt'></span><span id='topic+fm_proj4string'></span><span id='topic+fm_crs_get_wkt'></span><span id='topic+fm_wkt_tree_projection_type'></span><span id='topic+fm_wkt_projection_type'></span><span id='topic+fm_crs_projection_type'></span><span id='topic+fm_crs_bounds'></span><span id='topic+fm_ellipsoid_radius+3C-.inla.CRS'></span><span id='topic+fm_length_unit+3C-.inla.CRS'></span>

<h3>Description</h3>

<p>Get and set CRS object or WKT string properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_wkt_is_geocent(wkt)

fm_crs_is_geocent(crs)

fm_wkt_get_ellipsoid_radius(wkt)

fm_crs_get_ellipsoid_radius(crs)

fm_ellipsoid_radius(x)

## Default S3 method:
fm_ellipsoid_radius(x)

## S3 method for class 'character'
fm_ellipsoid_radius(x)

fm_wkt_set_ellipsoid_radius(wkt, radius)

fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'character'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'CRS'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'fm_CRS'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'crs'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'fm_crs'
fm_ellipsoid_radius(x) &lt;- value

fm_crs_set_ellipsoid_radius(crs, radius)

fm_wkt_unit_params()

fm_wkt_get_lengthunit(wkt)

fm_wkt_set_lengthunit(wkt, unit, params = NULL)

fm_crs_get_lengthunit(crs)

fm_crs_set_lengthunit(crs, unit)

fm_length_unit(x)

## Default S3 method:
fm_length_unit(x)

## S3 method for class 'character'
fm_length_unit(x)

fm_length_unit(x) &lt;- value

## S3 replacement method for class 'character'
fm_length_unit(x) &lt;- value

## S3 replacement method for class 'CRS'
fm_length_unit(x) &lt;- value

## S3 replacement method for class 'fm_CRS'
fm_length_unit(x) &lt;- value

## S3 replacement method for class 'crs'
fm_length_unit(x) &lt;- value

## S3 replacement method for class 'fm_crs'
fm_length_unit(x) &lt;- value

fm_wkt(crs)

fm_proj4string(crs)

fm_crs_get_wkt(crs)

fm_wkt_tree_projection_type(wt)

fm_wkt_projection_type(wkt)

fm_crs_projection_type(crs)

fm_crs_bounds(crs, warn.unknown = FALSE)

## S3 replacement method for class 'inla.CRS'
fm_ellipsoid_radius(x) &lt;- value

## S3 replacement method for class 'inla.CRS'
fm_length_unit(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_crs_wkt_+3A_wkt">wkt</code></td>
<td>
<p>A WKT2 character string</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_crs">crs</code></td>
<td>
<p>An <code>sf::crs</code>, <code>sp::CRS</code>, <code>fm_crs</code> or <code>inla.CRS</code> object</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_x">x</code></td>
<td>
<p>crs object to extract value from or assign values in</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_radius">radius</code></td>
<td>
<p>numeric; The new radius value</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_value">value</code></td>
<td>
<p>Value to assign</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_unit">unit</code></td>
<td>
<p>character, name of a unit. Supported names are
&quot;metre&quot;, &quot;kilometre&quot;, and the aliases &quot;meter&quot;, &quot;m&quot;, International metre&quot;,
&quot;kilometer&quot;, and &quot;km&quot;, as defined by <code>fm_wkt_unit_params</code> or the
<code>params</code> argument. (For legacy PROJ4 use, only &quot;m&quot; and &quot;km&quot; are
supported)</p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_params">params</code></td>
<td>
<p>Length unit definitions, in the list format produced by
<code>fm_wkt_unit_params()</code>, Default: NULL, which invokes
<code>fm_wkt_unit_params()</code></p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_wt">wt</code></td>
<td>
<p>A parsed wkt tree, see <code><a href="#topic+fm_wkt_as_wkt_tree">fm_wkt_as_wkt_tree()</a></code></p>
</td></tr>
<tr><td><code id="fm_crs_wkt_+3A_warn.unknown">warn.unknown</code></td>
<td>
<p>logical, default <code>FALSE</code>. Produce warning if the shape
of the projection bounds is unknown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>fm_wkt_unit_params</code>, a
list of named unit definitions
</p>
<p>For <code>fm_wkt_get_lengthunit</code>, a
list of length units used in the wkt string, excluding the ellipsoid radius
unit.
</p>
<p>For <code>fm_wkt_set_lengthunit</code>, a
WKT2 string with altered length units.
Note that the length unit for the ellipsoid radius is unchanged.
</p>
<p>For <code>fm_crs_get_lengthunit</code>, a
list of length units used in the wkt string, excluding the ellipsoid radius
unit. (For legacy PROJ4 code, the raw units from the proj4string are
returned, if present.)
</p>
<p>For <code style="white-space: pre;">&#8288;fm_length_unit&lt;-&#8288;</code>, a crs object with
altered length units.
Note that the length unit for the ellipsoid radius is unchanged.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_wkt()</code>: Returns a WKT2 string, for any input supported by
<code><a href="#topic+fm_crs">fm_crs()</a></code>.
</p>
</li>
<li> <p><code>fm_proj4string()</code>: Returns a proj4 string, for any input supported by
<code><a href="#topic+fm_crs">fm_crs()</a></code>.
</p>
</li>
<li> <p><code>fm_crs_get_wkt()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code><a href="#topic+fm_wkt">fm_wkt()</a></code>
instead.
</p>
</li>
<li> <p><code>fm_wkt_tree_projection_type()</code>: Returns &quot;longlat&quot;, &quot;lambert&quot;, &quot;mollweide&quot;, &quot;hammer&quot;,
&quot;tmerc&quot;, or <code>NULL</code>
</p>
</li>
<li> <p><code>fm_wkt_projection_type()</code>: See <code>fm_wkt_tree_projection_type</code>
</p>
</li>
<li> <p><code>fm_crs_projection_type()</code>: See <code>fm_wkt_tree_projection_type</code>
</p>
</li>
<li> <p><code>fm_crs_bounds()</code>: Returns bounds information for a projection, as
a list with elements <code>type</code> (&quot;rectangle&quot; or &quot;ellipse&quot;), <code>xlim</code>, <code>ylim</code>, and
<code>polygon</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1 &lt;- fm_crs("globe")
fm_crs_get_lengthunit(c1)
c2 &lt;- fm_crs_set_lengthunit(c1, "m")
fm_crs_get_lengthunit(c2)

</code></pre>

<hr>
<h2 id='fm_crs+26lt+3B-'>Assignment operators for crs information objects</h2><span id='topic+fm_crs+3C-'></span><span id='topic+fm_crs_oblique+3C-'></span><span id='topic+fm_crs+3C-.NULL'></span><span id='topic+fm_crs_oblique+3C-.NULL'></span><span id='topic+fm_crs+3C-.fm_segm'></span><span id='topic+fm_crs+3C-.fm_list'></span><span id='topic+fm_crs+3C-.fm_mesh_2d'></span><span id='topic+fm_crs+3C-.fm_lattice_2d'></span><span id='topic+fm_crs+3C-.sf'></span><span id='topic+fm_crs+3C-.sfg'></span><span id='topic+fm_crs+3C-.sfc'></span><span id='topic+fm_crs+3C-.Spatial'></span><span id='topic+fm_crs_oblique+3C-.crs'></span><span id='topic+fm_crs_oblique+3C-.CRS'></span><span id='topic+fm_crs_oblique+3C-.fm_CRS'></span><span id='topic+fm_crs_oblique+3C-.fm_crs'></span><span id='topic+fm_crs_oblique+3C-.fm_segm'></span><span id='topic+fm_crs_oblique+3C-.fm_mesh_2d'></span><span id='topic+fm_crs_oblique+3C-.fm_lattice_2d'></span><span id='topic+fm_crs_oblique+3C-.inla.CRS'></span>

<h3>Description</h3>

<p>Assigns new crs information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_crs(x) &lt;- value

fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'NULL'
fm_crs(x) &lt;- value

## S3 replacement method for class 'NULL'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_segm'
fm_crs(x) &lt;- value

## S3 replacement method for class 'fm_list'
fm_crs(x) &lt;- value

## S3 replacement method for class 'fm_mesh_2d'
fm_crs(x) &lt;- value

## S3 replacement method for class 'fm_lattice_2d'
fm_crs(x) &lt;- value

## S3 replacement method for class 'sf'
fm_crs(x) &lt;- value

## S3 replacement method for class 'sfg'
fm_crs(x) &lt;- value

## S3 replacement method for class 'sfc'
fm_crs(x) &lt;- value

## S3 replacement method for class 'Spatial'
fm_crs(x) &lt;- value

## S3 replacement method for class 'crs'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'CRS'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_CRS'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_crs'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_segm'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_mesh_2d'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'fm_lattice_2d'
fm_crs_oblique(x) &lt;- value

## S3 replacement method for class 'inla.CRS'
fm_crs_oblique(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_crs+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>Object to assign crs information to</p>
</td></tr>
<tr><td><code id="fm_crs+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>For <code style="white-space: pre;">&#8288;fm_crs&lt;-()&#8288;</code>, object supported by <code>fm_crs(value)</code>.
</p>
<p>For <code style="white-space: pre;">&#8288;fm_crs_oblique&lt;-()&#8288;</code>, <code>NA</code> or a numeric vector, see the <code>oblique</code>
argument for <code><a href="#topic+fm_crs">fm_crs()</a></code>. For assignment, <code>NULL</code> is treated as <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_crs(x) &lt;- value</code>: Automatically converts the input value with
<code>fm_crs(value)</code>, <code>fm_crs(value, oblique = NA)</code>,
<code>fm_CRS(value)</code>, or <code>fm_CRS(value, oblique = NA)</code>,
depending on the type of <code>x</code>.
</p>
</li>
<li> <p><code>fm_crs_oblique(x) &lt;- value</code>: Assigns new <code>oblique</code> information.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_crs">fm_crs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- fm_segm()
fm_crs(x) &lt;- fm_crs("+proj=longlat")
fm_crs(x)$proj4string
</code></pre>

<hr>
<h2 id='fm_detect_manifold'>Detect manifold type</h2><span id='topic+fm_detect_manifold'></span><span id='topic+fm_crs_detect_manifold'></span><span id='topic+fm_detect_manifold.crs'></span><span id='topic+fm_detect_manifold.CRS'></span><span id='topic+fm_detect_manifold.numeric'></span><span id='topic+fm_detect_manifold.matrix'></span><span id='topic+fm_detect_manifold.fm_mesh_2d'></span>

<h3>Description</h3>

<p>Detect if a 2d object is on &quot;R2&quot;, &quot;S2&quot;, or &quot;M2&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_detect_manifold(x)

fm_crs_detect_manifold(x)

## S3 method for class 'crs'
fm_detect_manifold(x)

## S3 method for class 'CRS'
fm_detect_manifold(x)

## S3 method for class 'numeric'
fm_detect_manifold(x)

## S3 method for class 'matrix'
fm_detect_manifold(x)

## S3 method for class 'fm_mesh_2d'
fm_detect_manifold(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_detect_manifold_+3A_x">x</code></td>
<td>
<p>Object to investigate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the detected manifold classification
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_crs_detect_manifold()</code>: Detect if a crs is on &quot;R2&quot; or &quot;S2&quot;
(if <code>fm_crs_is_geocent(crs)</code> is <code>TRUE</code>). Returns <code>NA_character_</code> if the crs
is NULL or NA.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fm_detect_manifold(1:4)
fm_detect_manifold(rbind(c(1, 0, 0), c(0, 1, 0), c(1, 1, 0)))
fm_detect_manifold(rbind(c(1, 0, 0), c(0, 1, 0), c(0, 0, 1)))

</code></pre>

<hr>
<h2 id='fm_diameter'>Diameter bound for a geometric object</h2><span id='topic+fm_diameter'></span><span id='topic+fm_diameter.matrix'></span><span id='topic+fm_diameter.sf'></span><span id='topic+fm_diameter.sfg'></span><span id='topic+fm_diameter.sfc'></span><span id='topic+fm_diameter.fm_lattice_2d'></span><span id='topic+fm_diameter.fm_mesh_1d'></span><span id='topic+fm_diameter.fm_mesh_2d'></span><span id='topic+fm_diameter.fm_segm'></span><span id='topic+fm_diameter.fm_mesh_3d'></span>

<h3>Description</h3>

<p>Find an upper bound to the convex hull of a point set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_diameter(x, ...)

## S3 method for class 'matrix'
fm_diameter(x, manifold = NULL, ...)

## S3 method for class 'sf'
fm_diameter(x, ...)

## S3 method for class 'sfg'
fm_diameter(x, ...)

## S3 method for class 'sfc'
fm_diameter(x, ...)

## S3 method for class 'fm_lattice_2d'
fm_diameter(x, ...)

## S3 method for class 'fm_mesh_1d'
fm_diameter(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_diameter(x, ...)

## S3 method for class 'fm_segm'
fm_diameter(x, ...)

## S3 method for class 'fm_mesh_3d'
fm_diameter(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_diameter_+3A_x">x</code></td>
<td>
<p>A point set as an <code class="reqn">n\times d</code> matrix, or an
<code>fm_mesh_2d</code>/<code style="white-space: pre;">&#8288;1d&#8288;</code>/<code>sf</code> related object.</p>
</td></tr>
<tr><td><code id="fm_diameter_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the submethods.</p>
</td></tr>
<tr><td><code id="fm_diameter_+3A_manifold">manifold</code></td>
<td>
<p>Character string specifying the manifold type. Default is to
treat the point set with Euclidean <code class="reqn">R^d</code> metrics. Use
<code>manifold="S2"</code> for great circle distances on the unit sphere (this is
set automatically for <code>fm_fmesh_2d</code> objects).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, upper bound for the diameter of the convex hull of the
point set.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm_diameter(matrix(c(0, 1, 1, 0, 0, 0, 1, 1), 4, 2))
</code></pre>

<hr>
<h2 id='fm_dof'>Function spece degrees of freedom</h2><span id='topic+fm_dof'></span><span id='topic+fm_dof.fm_mesh_1d'></span><span id='topic+fm_dof.fm_mesh_2d'></span><span id='topic+fm_dof.fm_mesh_3d'></span><span id='topic+fm_dof.fm_tensor'></span><span id='topic+fm_dof.fm_lattice_2d'></span><span id='topic+fm_dof.fm_lattice_Nd'></span>

<h3>Description</h3>

<p>Obtain the degrees of freedom of a function space, i.e.
the number of basis functions it uses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_dof(x)

## S3 method for class 'fm_mesh_1d'
fm_dof(x)

## S3 method for class 'fm_mesh_2d'
fm_dof(x)

## S3 method for class 'fm_mesh_3d'
fm_dof(x)

## S3 method for class 'fm_tensor'
fm_dof(x)

## S3 method for class 'fm_lattice_2d'
fm_dof(x)

## S3 method for class 'fm_lattice_Nd'
fm_dof(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_dof_+3A_x">x</code></td>
<td>
<p>A function space object, such as <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> or
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_dof(fmexample$mesh)

</code></pre>

<hr>
<h2 id='fm_evaluate'>Methods for projecting to/from mesh objects</h2><span id='topic+fm_evaluate'></span><span id='topic+fm_evaluate.default'></span><span id='topic+fm_evaluate.fm_evaluator'></span><span id='topic+fm_evaluate.fm_basis'></span><span id='topic+fm_evaluator'></span><span id='topic+fm_evaluator.default'></span><span id='topic+fm_evaluator.fm_mesh_3d'></span><span id='topic+fm_evaluator.fm_mesh_2d'></span><span id='topic+fm_evaluator.fm_mesh_1d'></span><span id='topic+fm_evaluator_lattice'></span><span id='topic+fm_evaluator_lattice.default'></span><span id='topic+fm_evaluator_lattice.fm_bbox'></span><span id='topic+fm_evaluator_lattice.fm_mesh_2d'></span>

<h3>Description</h3>

<p>Calculate evaluation information and/or evaluate a function
defined on a mesh or function space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_evaluate(...)

## Default S3 method:
fm_evaluate(mesh, field, ...)

## S3 method for class 'fm_evaluator'
fm_evaluate(projector, field, ...)

## S3 method for class 'fm_basis'
fm_evaluate(basis, field, ...)

fm_evaluator(...)

## Default S3 method:
fm_evaluator(...)

## S3 method for class 'fm_mesh_3d'
fm_evaluator(mesh, loc = NULL, lattice = NULL, dims = NULL, ...)

## S3 method for class 'fm_mesh_2d'
fm_evaluator(mesh, loc = NULL, lattice = NULL, crs = NULL, ...)

## S3 method for class 'fm_mesh_1d'
fm_evaluator(mesh, loc = NULL, xlim = mesh$interval, dims = 100, ...)

fm_evaluator_lattice(mesh, ...)

## Default S3 method:
fm_evaluator_lattice(mesh, dims = 100, ...)

## S3 method for class 'fm_bbox'
fm_evaluator_lattice(mesh, dims = 100, ...)

## S3 method for class 'fm_mesh_2d'
fm_evaluator_lattice(
  mesh,
  xlim = NULL,
  ylim = NULL,
  dims = c(100, 100),
  projection = NULL,
  crs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_evaluate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_mesh">mesh</code></td>
<td>
<p>An <a href="#topic+fm_mesh_1d">fm_mesh_1d</a>, <a href="#topic+fm_mesh_2d">fm_mesh_2d</a>, or other object supported by a
sub-method.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_field">field</code></td>
<td>
<p>Basis function weights, one per mesh basis function, describing
the function to be evaluated at the projection locations</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_projector">projector</code></td>
<td>
<p>An <code>fm_evaluator</code> object.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_basis">basis</code></td>
<td>
<p>An <a href="#topic+fm_basis">fm_basis</a> object.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_loc">loc</code></td>
<td>
<p>Projection locations.  Can be a matrix, <code>SpatialPoints</code>,
<code>SpatialPointsDataFrame</code>, <code>sf</code>, <code>sfc</code>, or <code>sfg</code> object.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_lattice">lattice</code></td>
<td>
<p>An <code><a href="#topic+fm_lattice_2d">fm_lattice_2d()</a></code> object.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_dims">dims</code></td>
<td>
<p>Lattice dimensions.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_crs">crs</code></td>
<td>
<p>An optional CRS or inla.CRS object associated with <code>loc</code>
and/or <code>lattice</code>.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_xlim">xlim</code></td>
<td>
<p>X-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td></tr>
<tr><td><code id="fm_evaluate_+3A_projection">projection</code></td>
<td>
<p>One of <code>c("default", "longlat", "longsinlat", "mollweide")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix of the evaluated function
</p>
<p>An <code>fm_evaluator</code> object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_evaluate(default)</code>: The default method calls
<code>proj = fm_evaluator(mesh, ...)</code>, followed by <code>fm_evaluate(proj, field)</code>.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_evaluate()</code>: Returns the field function evaluated at the locations determined by an
<code>fm_evaluator</code> object. <code>fm_evaluate(mesh, field = field, ...)</code> is a
shortcut to <code>fm_evaluate(fm_evaluator(mesh, ...), field = field)</code>.
</p>
</li>
<li> <p><code>fm_evaluator()</code>: Returns an <code>fm_evaluator</code> list object with evaluation information.
The <code>proj</code> element is a <code>fm_basis</code> object, containing (at least)
a mapping matrix <code>A</code> and a logical vector <code>ok</code>, that indicates which
locations were mappable to the input mesh.
For <code>fm_mesh_2d</code>
input, <code>proj</code> also contains a <code>bary</code> <a href="#topic+fm_bary">fm_bary</a> object, with the
barycentric coordinates within the triangle each input location falls in.
</p>
</li>
<li> <p><code>fm_evaluator(default)</code>: The default method calls <code>fm_basis</code> and creates
a basic <code>fm_evaluator</code> object
</p>
</li>
<li> <p><code>fm_evaluator(fm_mesh_3d)</code>: The <code>...</code> arguments are passed on to
<code>fm_evaluator_lattice()</code> if no <code>loc</code> or <code>lattice</code> is provided.
</p>
</li>
<li> <p><code>fm_evaluator(fm_mesh_2d)</code>: The <code>...</code> arguments are passed on to
<code>fm_evaluator_lattice()</code> if no <code>loc</code> or <code>lattice</code> is provided.
</p>
</li>
<li> <p><code>fm_evaluator_lattice()</code>: Create a lattice object by default covering the input mesh.
</p>
</li>
<li> <p><code>fm_evaluator_lattice(default)</code>: Creates an <code><a href="#topic+fm_lattice_2d">fm_lattice_2d()</a></code> object, by default covering the input mesh.
</p>
</li>
<li> <p><code>fm_evaluator_lattice(fm_bbox)</code>: Creates an <code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd()</a></code> object, by default covering the input mesh.
</p>
</li>
<li> <p><code>fm_evaluator_lattice(fm_mesh_2d)</code>: Creates an <code><a href="#topic+fm_lattice_2d">fm_lattice_2d()</a></code> object, by default covering the input mesh.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (TRUE) {
  n &lt;- 20
  loc &lt;- matrix(runif(n * 2), n, 2)
  mesh &lt;- fm_rcdt_2d_inla(loc, refine = list(max.edge = 0.05))
  proj &lt;- fm_evaluator(mesh)
  field &lt;- cos(mesh$loc[, 1] * 2 * pi * 3) * sin(mesh$loc[, 2] * 2 * pi * 7)
  image(proj$x, proj$y, fm_evaluate(proj, field))
}

# if (require("ggplot2") &amp;&amp;
#  require("ggpolypath")) {
#  ggplot() +
#    gg(data = fm_as_sfc(mesh), col = field)
# }


</code></pre>

<hr>
<h2 id='fm_fem'>Compute finite element matrices</h2><span id='topic+fm_fem'></span><span id='topic+fm_fem.fm_mesh_1d'></span><span id='topic+fm_fem.fm_mesh_2d'></span><span id='topic+fm_fem.fm_tensor'></span><span id='topic+fm_fem.fm_mesh_3d'></span>

<h3>Description</h3>

<p>(...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_fem(mesh, order = 2, ...)

## S3 method for class 'fm_mesh_1d'
fm_fem(mesh, order = 2, ...)

## S3 method for class 'fm_mesh_2d'
fm_fem(mesh, order = 2, aniso = NULL, ...)

## S3 method for class 'fm_tensor'
fm_fem(mesh, order = 2, ...)

## S3 method for class 'fm_mesh_3d'
fm_fem(mesh, order = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_fem_+3A_mesh">mesh</code></td>
<td>
<p><code>fm_mesh_1d</code> or other supported mesh class object</p>
</td></tr>
<tr><td><code id="fm_fem_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="fm_fem_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
<tr><td><code id="fm_fem_+3A_aniso">aniso</code></td>
<td>
<p>If non-NULL, a <code>list(gamma, v)</code>. Calculates anisotropic
structure matrices (in addition to the regular) for <code class="reqn">\gamma</code> and
<code class="reqn">v</code> for an anisotropic operator <code class="reqn">\nabla\cdot H \nabla</code>, where <code class="reqn">H=\gamma I + v v^\top</code>. Currently
(2023-08-05) the fields need to be given per vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_fem.fm_mesh_1d</code>: A list with elements <code>c0</code>, <code>c1</code>, <code>g1</code>, <code>g2</code>.
When <code>mesh$degree == 2</code>, also <code>g01</code>, <code>g02</code>, and <code>g12</code>.
</p>
<p><code>fm_fem.fm_mesh_2d</code>: A list with elements <code>c0</code>, <code>c1</code>, <code>g1</code>, <code>va</code>,
<code>ta</code>, and more if <code>order &gt; 1</code>. When <code>aniso</code> is non-NULL, also <code>g1aniso</code>
matrices, etc.
</p>
<p><code>fm_fem.fm_tensor</code>: A list with elements <code>cc</code>, <code>g1</code>, <code>g2</code>.
</p>
<p><code>fm_fem.fm_mesh_3d</code>: A list with elements <code>c0</code>, <code>c1</code>, <code>g1</code>, <code>g2</code>,
<code>va</code>, <code>ta</code>, and more if <code>order &gt; 2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_fem(fmexample$mesh))

</code></pre>

<hr>
<h2 id='fm_generate_colors'>Generate text RGB color specifications.</h2><span id='topic+fm_generate_colors'></span>

<h3>Description</h3>

<p>Generates a text RGB color specification matrix based on a color palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_generate_colors(
  color,
  color.axis = NULL,
  color.n = 512,
  color.palette = cm.colors,
  color.truncate = FALSE,
  alpha = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_generate_colors_+3A_color">color</code></td>
<td>
<p><code>character</code>, <code>matrix</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_color.axis">color.axis</code></td>
<td>
<p>The min/max limit values for the color mapping.</p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_color.n">color.n</code></td>
<td>
<p>The number of colors to use in the color palette.</p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_color.palette">color.palette</code></td>
<td>
<p>A color palette function.</p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_color.truncate">color.truncate</code></td>
<td>
<p>If <code>TRUE</code>, truncate the colors at the color axis
limits.</p>
</td></tr>
<tr><td><code id="fm_generate_colors_+3A_alpha">alpha</code></td>
<td>
<p>Transparency/opaqueness values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with character vector <code>colors</code> and numeric vector <code>alpha</code>
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_generate_colors(1:4, color.axis = c(1, 4))

</code></pre>

<hr>
<h2 id='fm_gmrf'>SPDE, GMRF, and Mat√©rn process methods</h2><span id='topic+fm_gmrf'></span><span id='topic+fm_matern_precision'></span><span id='topic+fm_matern_sample'></span><span id='topic+fm_covariance'></span><span id='topic+fm_sample'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Methods for SPDEs and GMRFs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_matern_precision(x, alpha, rho, sigma)

fm_matern_sample(x, alpha = 2, rho, sigma, n = 1, loc = NULL)

fm_covariance(Q, A1 = NULL, A2 = NULL, partial = FALSE)

fm_sample(n, Q, mu = 0, constr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_gmrf_+3A_x">x</code></td>
<td>
<p>A mesh object, e.g. from <code>fm_mesh_1d()</code>, <code>fm_mesh_2d()</code>, or
other object with supporting <code><a href="#topic+fm_fem">fm_fem()</a></code> and <code><a href="#topic+fm_manifold_dim">fm_manifold_dim()</a></code> methods.</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_alpha">alpha</code></td>
<td>
<p>The SPDE operator order. The resulting smoothness index
is <code>nu = alpha - dim / 2</code>.</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_rho">rho</code></td>
<td>
<p>The Mat√©rn range parameter
(scale parameter <code>kappa = sqrt(8 * nu) / rho</code>)</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_sigma">sigma</code></td>
<td>
<p>The nominal Mat√©rn std.dev. parameter</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_n">n</code></td>
<td>
<p>The number of samples to generate</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_loc">loc</code></td>
<td>
<p>locations to evaluate the random field, compatible with
<code>fm_evaluate(x, loc = loc, field = ...)</code></p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_q">Q</code></td>
<td>
<p>A precision matrix</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_a1">A1</code>, <code id="fm_gmrf_+3A_a2">A2</code></td>
<td>
<p>Matrices, typically obtained from <code><a href="#topic+fm_basis">fm_basis()</a></code> and/or
<code><a href="#topic+fm_block">fm_block()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_partial">partial</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> If <code>TRUE</code>, compute the
partial inverse of <code>Q</code>, i.e. the elements of the inverse corresponding to
the non-zero pattern of <code>Q</code>. (Note: This can be done efficiently with
the Takahashi recursion method, but to avoid an RcppEigen dependency this
is currently disabled, and a slower method is used until the efficient method
is reimplemented.)</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_mu">mu</code></td>
<td>
<p>Optional mean vector</p>
</td></tr>
<tr><td><code id="fm_gmrf_+3A_constr">constr</code></td>
<td>
<p>Optional list of constraint information, with elements
<code>A</code> and <code>e</code>. Should only be used for a small number of exact constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_matern_sample()</code> returns a matrix, where each column is a
sampled field. If <code>loc</code> is <code>NULL</code>, the <code>fm_dof(mesh)</code> basis weights are
given. Otherwise, the evaluated field at the <code>nrow(loc)</code> locations <code>loc</code>
are given (from version <code style="white-space: pre;">&#8288;0.1.4.9001&#8288;</code>)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_matern_precision()</code>: Construct the (sparse) precision matrix for the basis weights for
Whittle-Mat√©rn SPDE models.  The boundary behaviour is determined by the
provided mesh function space.
</p>
</li>
<li> <p><code>fm_matern_sample()</code>: Simulate a Mat√©rn field given a mesh and
covariance function parameters, and optionally evaluate at given locations.
</p>
</li>
<li> <p><code>fm_covariance()</code>: Compute the covariance between &quot;A1 x&quot; and &quot;A2 x&quot;, when
x is a basis vector with precision matrix <code>Q</code>.
</p>
</li>
<li> <p><code>fm_sample()</code>: Generate <code>n</code> samples based on a sparse precision matrix <code>Q</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
mesh &lt;- fm_mesh_1d(-20:120, degree = 2)
Q &lt;- fm_matern_precision(mesh, alpha = 2, rho = 15, sigma = 1)
x &lt;- seq(0, 100, length.out = 601)
A &lt;- fm_basis(mesh, x)
plot(x,
  as.vector(Matrix::diag(fm_covariance(Q, A))),
  type = "l",
  ylab = "marginal variances"
)

plot(x,
  fm_evaluate(mesh, loc = x, field = fm_sample(1, Q)[, 1]),
  type = "l",
  ylab = "process sample"
)

</code></pre>

<hr>
<h2 id='fm_int'>Multi-domain integration</h2><span id='topic+fm_int'></span><span id='topic+fm_int.list'></span><span id='topic+fm_int.numeric'></span><span id='topic+fm_int.character'></span><span id='topic+fm_int.factor'></span><span id='topic+fm_int.SpatRaster'></span><span id='topic+fm_int.fm_lattice_2d'></span><span id='topic+fm_int.fm_mesh_1d'></span><span id='topic+fm_int.fm_mesh_2d'></span>

<h3>Description</h3>

<p>Construct integration points on tensor product spaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_int(domain, samplers = NULL, ...)

## S3 method for class 'list'
fm_int(domain, samplers = NULL, ...)

## S3 method for class 'numeric'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'character'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'factor'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'SpatRaster'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'fm_lattice_2d'
fm_int(domain, samplers = NULL, name = "x", ...)

## S3 method for class 'fm_mesh_1d'
fm_int(
  domain,
  samplers = NULL,
  name = "x",
  int.args = NULL,
  format = NULL,
  ...
)

## S3 method for class 'fm_mesh_2d'
fm_int(
  domain,
  samplers = NULL,
  name = NULL,
  int.args = NULL,
  format = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_int_+3A_domain">domain</code></td>
<td>
<p>Functional space specification; single domain or a named list
of domains</p>
</td></tr>
<tr><td><code id="fm_int_+3A_samplers">samplers</code></td>
<td>
<p>For single domain <code>fm_int</code> methods, an object specifying one
or more subsets of the domain, and optional weighting in a <code>weight</code>
variable. For <code>fm_int.list</code>, a list of sampling definitions, where data
frame elements may contain information for multiple domains, in which case
each row represent a separate tensor product integration subspace.</p>
</td></tr>
<tr><td><code id="fm_int_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="fm_int_+3A_name">name</code></td>
<td>
<p>For single-domain methods, the variable name to use for the
integration points. Default 'x'</p>
</td></tr>
<tr><td><code id="fm_int_+3A_int.args">int.args</code></td>
<td>
<p>List of arguments passed to line and integration methods.
</p>

<ul>
<li> <p><code>method</code>: &quot;stable&quot; (to aggregate integration weights onto mesh nodes)
or &quot;direct&quot; (to construct a within triangle/segment integration scheme
without aggregating onto mesh nodes)
</p>
</li>
<li> <p><code>nsub1</code>, <code>nsub2</code>: integers controlling the number of internal integration
points before aggregation. Points per triangle: <code>(nsub2+1)^2</code>.
Points per knot segment: <code>nsub1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="fm_int_+3A_format">format</code></td>
<td>
<p>character; determines the output format, as either &quot;sf&quot;
(default for <code>fm_mesh_2d</code> when the sampler is <code>NULL</code>),
&quot;numeric&quot; (default for <code>fm_mesh_1d</code>), &quot;bary&quot;, or &quot;sp&quot;.
When <code>NULL</code>, determined by the domain and sampler types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code>, <code>sf</code>, or <code>SpatialPointsDataFrame</code> of 1D
and 2D integration points, including a <code>weight</code> column and <code>.block</code> column.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_int(list)</code>: Multi-domain integration
</p>
</li>
<li> <p><code>fm_int(numeric)</code>: Discrete double or integer space integration
</p>
</li>
<li> <p><code>fm_int(character)</code>: Discrete character space integration
</p>
</li>
<li> <p><code>fm_int(factor)</code>: Discrete factor space integration
</p>
</li>
<li> <p><code>fm_int(SpatRaster)</code>: <code>SpatRaster</code> integration. Not yet implemented.
</p>
</li>
<li> <p><code>fm_int(fm_lattice_2d)</code>: <code>fm_lattice_2d</code> integration. Not yet implemented.
</p>
</li>
<li> <p><code>fm_int(fm_mesh_1d)</code>: <code>fm_mesh_1d</code> integration. Supported samplers:
</p>

<ul>
<li> <p><code>NULL</code> for integration over the entire domain;
</p>
</li>
<li><p> A length 2 vector defining an interval;
</p>
</li>
<li><p> A 2-column matrix with a single interval in each row;
</p>
</li>
<li><p> A tibble with a named column containing a matrix, and optionally a
<code>weight</code> column.
</p>
</li></ul>

</li>
<li> <p><code>fm_int(fm_mesh_2d)</code>: <code>fm_mesh_2d</code> integration. Any sampler class with an
associated <code><a href="#topic+fm_int_mesh_2d">fm_int_mesh_2d()</a></code> method is supported.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Integration on the interval (2, 3.5) with Simpson's rule
ips &lt;- fm_int(fm_mesh_1d(0:4), samplers = cbind(2, 3.5))
plot(ips$x, ips$weight)

# Create integration points for the two intervals [0,3] and [5,10]
ips &lt;- fm_int(
  fm_mesh_1d(0:10),
  rbind(c(0, 3), c(5, 10))
)
plot(ips$x, ips$weight)

# Convert a 1D mesh into integration points
mesh &lt;- fm_mesh_1d(seq(0, 10, by = 1))
ips &lt;- fm_int(mesh, name = "time")
plot(ips$time, ips$weight)

if (require("ggplot2", quietly = TRUE)) {
  #' Integrate on a 2D mesh with polygon boundary subset
  ips &lt;- fm_int(fmexample$mesh, fmexample$boundary_sf[[1]])
  ggplot() +
    geom_sf(data = fm_as_sfc(fmexample$mesh, multi = TRUE), alpha = 0.5) +
    geom_sf(data = fmexample$boundary_sf[[1]], fill = "red", alpha = 0.5) +
    geom_sf(data = ips, aes(size = weight)) +
    scale_size_area()
}

# Individual sampling points:
(ips &lt;- fm_int(0:10, c(0, 3, 5, 6, 10)))
# Sampling blocks:
(ips &lt;- fm_int(0:10, list(c(0, 3), c(5, 6, 10))))

# Continuous integration on intervals
ips &lt;- fm_int(
  fm_mesh_1d(0:10, boundary = "cyclic"),
  rbind(c(0, 3), c(5, 10))
)
plot(ips$x, ips$weight)

</code></pre>

<hr>
<h2 id='fm_int_mesh_2d'>Subset integration on a mesh</h2><span id='topic+fm_int_mesh_2d'></span><span id='topic+fm_int_mesh_2d_NULL'></span><span id='topic+fm_int_mesh_2d.sf'></span><span id='topic+fm_int_mesh_2d.sfc_POINT'></span><span id='topic+fm_int_mesh_2d.sfc_MULTIPOINT'></span><span id='topic+fm_int_mesh_2d.sfc_LINESTRING'></span><span id='topic+fm_int_mesh_2d.sfc_MULTILINESTRING'></span><span id='topic+fm_int_mesh_2d.sfc_POLYGON'></span><span id='topic+fm_int_mesh_2d.sfc_MULTIPOLYGON'></span><span id='topic+fm_int_mesh_2d.sfc_GEOMETRY'></span><span id='topic+fm_int_mesh_2d.Spatial'></span>

<h3>Description</h3>

<p>Integration methods for spatial samplers on <code>fm_mesh_2d</code> meshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_int_mesh_2d(samplers, domain, name = NULL, int.args = NULL, ...)

fm_int_mesh_2d_NULL(samplers, domain, name = NULL, int.args = NULL, ...)

## S3 method for class 'sf'
fm_int_mesh_2d(samplers, domain, name = NULL, int.args = NULL, ...)

## S3 method for class 'sfc_POINT'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_MULTIPOINT'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_LINESTRING'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_MULTILINESTRING'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_POLYGON'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_MULTIPOLYGON'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'sfc_GEOMETRY'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  .weight = rep(1, NROW(samplers)),
  ...
)

## S3 method for class 'Spatial'
fm_int_mesh_2d(
  samplers,
  domain,
  name = NULL,
  int.args = NULL,
  format = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_int_mesh_2d_+3A_samplers">samplers</code></td>
<td>
<p>For single domain <code>fm_int</code> methods, an object specifying one
or more subsets of the domain, and optional weighting in a <code>weight</code>
variable. For <code>fm_int.list</code>, a list of sampling definitions, where data
frame elements may contain information for multiple domains, in which case
each row represent a separate tensor product integration subspace.</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_domain">domain</code></td>
<td>
<p>Functional space specification; single domain or a named list
of domains</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_name">name</code></td>
<td>
<p>For single-domain methods, the variable name to use for the
integration points. Default 'x'</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_int.args">int.args</code></td>
<td>
<p>List of arguments passed to line and integration methods.
</p>

<ul>
<li> <p><code>method</code>: &quot;stable&quot; (to aggregate integration weights onto mesh nodes)
or &quot;direct&quot; (to construct a within triangle/segment integration scheme
without aggregating onto mesh nodes)
</p>
</li>
<li> <p><code>nsub1</code>, <code>nsub2</code>: integers controlling the number of internal integration
points before aggregation. Points per triangle: <code>(nsub2+1)^2</code>.
Points per knot segment: <code>nsub1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_+3A_format">format</code></td>
<td>
<p>character; determines the output format, as either &quot;sf&quot;
(default for <code>fm_mesh_2d</code> when the sampler is <code>NULL</code>),
&quot;numeric&quot; (default for <code>fm_mesh_1d</code>), &quot;bary&quot;, or &quot;sp&quot;.
When <code>NULL</code>, determined by the domain and sampler types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code>, <code>sf</code>, or <code>Spatial</code> object with
point coordinate information and additional columns <code>weight</code> and <code>.block</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_int_mesh_2d(sf)</code>: <code>sf</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_POINT)</code>: <code>sfc_POINT</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_MULTIPOINT)</code>: <code>sfc_MULTIPOINT</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_LINESTRING)</code>: <code>sfc_LINESTRING</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_MULTILINESTRING)</code>: <code>sfc_MULTILINESTRING</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_POLYGON)</code>: <code>sfc_POLYGON</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_MULTIPOLYGON)</code>: <code>sfc_MULTIPOLYGON</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(sfc_GEOMETRY)</code>: <code>sfc_GEOMERY</code> integration
</p>
</li>
<li> <p><code>fm_int_mesh_2d(Spatial)</code>: <code>Spatial</code> integration
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_int_mesh_2d_NULL()</code>: Full domain integration
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_int_mesh_2d(samplers = NULL, domain = fmexample$mesh))
</code></pre>

<hr>
<h2 id='fm_int_mesh_2d_core'>Integration scheme for mesh triangle interiors</h2><span id='topic+fm_int_mesh_2d_core'></span>

<h3>Description</h3>

<p>Integration scheme for mesh triangle interiors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_int_mesh_2d_core(mesh, tri_subset = NULL, nsub = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_int_mesh_2d_core_+3A_mesh">mesh</code></td>
<td>
<p>Mesh on which to integrate</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_core_+3A_tri_subset">tri_subset</code></td>
<td>
<p>Optional triangle index vector for integration on a subset
of the mesh triangles (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="fm_int_mesh_2d_core_+3A_nsub">nsub</code></td>
<td>
<p>number of subdivision points along each triangle edge, giving
<code>(nsub + 1)^2</code> proto-integration points used to compute
the vertex weights
(default <code>nsub=9</code>, giving 100 integration points for each triangle)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tibble</code> with columns <code>loc</code> and <code>weight</code> with
integration points for the mesh
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_int_mesh_2d_core(fmexample$mesh))

</code></pre>

<hr>
<h2 id='fm_int_multi_sampler'>Multi-domain sampler integration</h2><span id='topic+fm_int_multi_sampler'></span>

<h3>Description</h3>

<p>Combine integration over different domains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_int_multi_sampler(domain, samplers, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_int_multi_sampler_+3A_domain">domain</code></td>
<td>
<p>A list of named domains</p>
</td></tr>
<tr><td><code id="fm_int_multi_sampler_+3A_samplers">samplers</code></td>
<td>
<p>A named list of samplers</p>
</td></tr>
<tr><td><code id="fm_int_multi_sampler_+3A_...">...</code></td>
<td>
<p>Passed on to each <code><a href="#topic+fm_int">fm_int()</a></code> call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with integration points and weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_int_multi_sampler(
  domain = list(x = fm_mesh_1d(1:4), y = 11:12),
  samplers = tibble::tibble(
    x = rbind(c(1, 3), c(2, 4)),
    y = c(12, 11)
  )
)
</code></pre>

<hr>
<h2 id='fm_is_within'>Query if points are inside a mesh</h2><span id='topic+fm_is_within'></span>

<h3>Description</h3>

<p>Queries whether each input point is within a mesh or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_is_within(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_is_within_+3A_x">x</code></td>
<td>
<p>A set of points/locations of a class supported by <code>fm_basis(y, loc = x, ..., full = TRUE)</code></p>
</td></tr>
<tr><td><code id="fm_is_within_+3A_y">y</code></td>
<td>
<p>An <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> or other class supported by
<code>fm_basis(y, loc = x, ..., full = TRUE)</code></p>
</td></tr>
<tr><td><code id="fm_is_within_+3A_...">...</code></td>
<td>
<p>Passed on to <code><a href="#topic+fm_basis">fm_basis()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all(fm_is_within(fmexample$loc, fmexample$mesh))
</code></pre>

<hr>
<h2 id='fm_lattice_2d'>Make a lattice object</h2><span id='topic+fm_lattice_2d'></span><span id='topic+fm_lattice_2d.default'></span>

<h3>Description</h3>

<p>Construct a lattice grid for <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_lattice_2d(...)

## Default S3 method:
fm_lattice_2d(
  x = seq(0, 1, length.out = 2),
  y = seq(0, 1, length.out = 2),
  z = NULL,
  dims = if (is.matrix(x)) {
     dim(x)
 } else {
     c(length(x), length(y))
 },
  units = NULL,
  crs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_lattice_2d_+3A_...">...</code></td>
<td>
<p>Passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_x">x</code></td>
<td>
<p>vector or grid matrix of x-values. Vector values are sorted before
use. Matrix input is assumed to be a grid of x-values with the same
ordering convention of <code>as.vector(x)</code> as <code>rep(x, times = dims[2])</code> for
vector input.</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_y">y</code></td>
<td>
<p>vector of grid matrix of y-values. Vector values are sorted before
use. Matrix input is assumed to be a grid of y-values with the same
ordering convention of <code>as.vector(y)</code> as <code>rep(y, each = dims[1])</code> for
vector input.</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_z">z</code></td>
<td>
<p>if x is a matrix, a grid matrix of z-values, with the same ordering
as <code>x</code> and <code>y</code>. If <code>x</code> is a vector, <code>z</code> is ignored.</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_dims">dims</code></td>
<td>
<p>the size of the grid, length 2 vector</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_units">units</code></td>
<td>
<p>One of <code>c("default", "longlat", "longsinlat", "mollweide")</code>
or NULL (equivalent to <code>"default"</code>).</p>
</td></tr>
<tr><td><code id="fm_lattice_2d_+3A_crs">crs</code></td>
<td>
<p>An optional <code>fm_crs</code>, <code>sf::st_crs</code>, or <code>sp::CRS</code> object,
denoting the CRS info for the x-y grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_lattice_2d</code> object with elements
</p>

<dl>
<dt>dims</dt><dd><p>integer vector</p>
</dd>
<dt>x</dt><dd><p>x-values for original vector input</p>
</dd>
<dt>y</dt><dd><p>y-values for original vector input</p>
</dd>
<dt>loc</dt><dd><p>matrix of <code style="white-space: pre;">&#8288;(x, y)&#8288;</code> values or <code style="white-space: pre;">&#8288;(x, y, z)&#8288;</code> values. May be altered by
<code><a href="#topic+fm_transform">fm_transform()</a></code></p>
</dd>
<dt>segm</dt><dd><p><code>fm_segm</code> object</p>
</dd>
<dt>crs</dt><dd><p><code>fm_crs</code> object for <code>loc</code>, or <code>NULL</code></p>
</dd>
<dt>crs0</dt><dd><p><code>fm_crs</code> object for <code style="white-space: pre;">&#8288;(x,y)&#8288;</code>, or <code>NULL</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>
</p>
<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lattice &lt;- fm_lattice_2d(
  seq(0, 1, length.out = 17),
  seq(0, 1, length.out = 10)
)

## Use the lattice "as-is", without refinement:
mesh &lt;- fm_rcdt_2d_inla(lattice = lattice, boundary = lattice$segm)
mesh &lt;- fm_rcdt_2d_inla(lattice = lattice, extend = FALSE)

## Refine the triangulation, with limits on triangle angles and edges:
mesh &lt;- fm_rcdt_2d(
  lattice = lattice,
  refine = list(max.edge = 0.08),
  extend = FALSE
)

## Add an extension around the lattice, but maintain the lattice edges:
mesh &lt;- fm_rcdt_2d(
  lattice = lattice,
  refine = list(max.edge = 0.08),
  interior = lattice$segm
)

## Only add extension:
mesh &lt;- fm_rcdt_2d(lattice = lattice, refine = list(max.edge = 0.08))
</code></pre>

<hr>
<h2 id='fm_lattice_Nd'>Lattice grids for N dimensions</h2><span id='topic+fm_lattice_Nd'></span><span id='topic+fm_lattice_Nd.matrix'></span><span id='topic+fm_lattice_Nd.data.frame'></span><span id='topic+fm_lattice_Nd.list'></span><span id='topic+fm_lattice_Nd.fm_bbox'></span><span id='topic+fm_lattice_Nd.NULL'></span>

<h3>Description</h3>

<p>Construct an N-dimensional lattice grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_lattice_Nd(x = NULL, ...)

## S3 method for class 'matrix'
fm_lattice_Nd(x = NULL, dims = NULL, values = NULL, ...)

## S3 method for class 'data.frame'
fm_lattice_Nd(x = NULL, ...)

## S3 method for class 'list'
fm_lattice_Nd(x = NULL, dims = NULL, ...)

## S3 method for class 'fm_bbox'
fm_lattice_Nd(x = NULL, dims = NULL, ...)

## S3 method for class ''NULL''
fm_lattice_Nd(x = NULL, ..., dims = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_lattice_Nd_+3A_x">x</code></td>
<td>
<p><code>list</code>, <code>data.frame</code>, <code>matrix</code>, <code>fm_bbox</code> or <code>NULL</code>. If a list of
vectors, <code>as.matrix(expand.grid(x))</code> is used to create a full grid
coordinates. <code>data.frame</code> and <code>matrix</code> input is assumed to follow the same
ordering convention as the output of <code>expand.grid()</code>. of length N of
vectors or grid matrices of coordinate values. List vector values are
sorted before use.</p>
</td></tr>
<tr><td><code id="fm_lattice_Nd_+3A_...">...</code></td>
<td>
<p>Passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_lattice_Nd_+3A_dims">dims</code></td>
<td>
<p>numeric; the size of the grid of dimension <code>length(dims)</code></p>
</td></tr>
<tr><td><code id="fm_lattice_Nd_+3A_values">values</code></td>
<td>
<p>list of grid axis values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_lattice_Nd</code> object with elements
</p>

<dl>
<dt>dims</dt><dd><p>integer vector</p>
</dd>
<dt>values</dt><dd><p>the grid coordinate axis values</p>
</dd>
<dt>loc</dt><dd><p>matrix of constructed grid coordinates</p>
</dd>
</dl>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_lattice_Nd(`NULL`)</code>: Ignores the <code>NULL</code> <code>x</code> and creates a lattice
based on <code>values</code> (if non-NULL) and <code>dims</code> unit hypercube
lattice grid with <code>dims</code> dimensions.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_mesh_3d">fm_mesh_3d()</a></code>
</p>
<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(lattice &lt;- fm_lattice_Nd(
  list(
    seq(0, 1, length.out = 3),
    seq(0, 1, length.out = 4),
    seq(0, 1, length.out = 2)
  )
))

if (requireNamespace("geometry", quietly = TRUE)) {
  (mesh &lt;- fm_delaunay_3d(lattice$loc))
}
</code></pre>

<hr>
<h2 id='fm_list'>Handle lists of fmesher objects</h2><span id='topic+fm_list'></span><span id='topic+fm_as_list'></span><span id='topic+c.fm_list'></span><span id='topic++5B.fm_list'></span>

<h3>Description</h3>

<p>Methods for constructing and manipulating <code>fm_list</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_list(x, ..., .class_stub = NULL)

fm_as_list(x, ..., .class_stub = NULL)

## S3 method for class 'fm_list'
c(...)

## S3 method for class 'fm_list'
x[i]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_list_+3A_x">x</code></td>
<td>
<p><code>fm_list</code> object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="fm_list_+3A_...">...</code></td>
<td>
<p>Arguments passed to each individual conversion call.</p>
</td></tr>
<tr><td><code id="fm_list_+3A_.class_stub">.class_stub</code></td>
<td>
<p>character; class stub name of class to convert each list
element to. If <code>NULL</code>, uses <code>fm_as_fm</code> and auto-detects if the resulting
list has consistent class, and then adds that to the class list.  If
non-null, uses <code>paste0("fm_as_", .class_stub)</code> for conversion, and verifies
that the resulting list has elements consistent with that class.</p>
</td></tr>
<tr><td><code id="fm_list_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_list</code> object, potentially with <code style="white-space: pre;">&#8288;fm_{class_stub}_list&#8288;</code>
added.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>c(fm_list)</code>: The <code>...</code> arguments should be coercible to <code>fm_list</code>
objects.
</p>
</li>
<li> <p><code>[</code>: Extract sub-list
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_list()</code>: Convert each element of a list, or convert a single
non-list object and return in a list
</p>
</li>
<li> <p><code>fm_as_list()</code>: Convert each element of a list, or convert a single
non-list object and return in a list
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fm_as_list(list(fmexample$mesh, fm_segm_join(fmexample$boundary_fm)))

</code></pre>

<hr>
<h2 id='fm_manifold'>Query the mesh manifold type</h2><span id='topic+fm_manifold'></span><span id='topic+fm_manifold_get'></span><span id='topic+fm_manifold_get.default'></span><span id='topic+fm_manifold_get.character'></span><span id='topic+fm_manifold_get.fm_lattice_2d'></span><span id='topic+fm_manifold_get.fm_lattice_Nd'></span><span id='topic+fm_manifold_type'></span><span id='topic+fm_manifold_dim'></span>

<h3>Description</h3>

<p>Extract a manifold definition string, or a logical for matching
manifold type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_manifold(x, type = NULL)

fm_manifold_get(x)

## Default S3 method:
fm_manifold_get(x)

## S3 method for class 'character'
fm_manifold_get(x)

## S3 method for class 'fm_lattice_2d'
fm_manifold_get(x)

## S3 method for class 'fm_lattice_Nd'
fm_manifold_get(x)

fm_manifold_type(x)

fm_manifold_dim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_manifold_+3A_x">x</code></td>
<td>
<p>An object with <code>manifold</code> information, or a character string</p>
</td></tr>
<tr><td><code id="fm_manifold_+3A_type">type</code></td>
<td>
<p><code>character</code>; if <code>NULL</code> (the default), returns the manifold
definition string by calling <code>fm_manifold_get(x)</code>.
If <code>character</code>, returns <code>TRUE</code> if the manifold type of <code>x</code> matches at least
one of the character vector elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fm_manifold()</code>: Either logical (matching manifold type yes/no),
or character (the stored manifold, when <code>is.null(type)</code> is <code>TRUE</code>)
</p>
<p><code>fm_manifold_get()</code>: <code>character</code> or <code>NULL</code>
</p>
<p><code>fm_manifold_type()</code>: character or NULL; &quot;M&quot; (curved manifold),
&quot;R&quot; (flat space), &quot;S&quot; (generalised spherical space), &quot;T&quot;
(general tensor product space), or &quot;G&quot; (metric graph)
</p>
<p><code>fm_manifold_dim()</code>: integer or NULL
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_manifold_get()</code>: Method for obtaining a text representation of the
manifold characteristics, e.g. &quot;R1&quot;, &quot;R2&quot;, &quot;M2&quot;, or &quot;T3&quot;. The default
method assumes that the manifold is stored as a <code>character</code> string in a
&quot;manifold&quot; element of the object, so it can be extracted with
<code>x[["manifold"]]</code>.
Object classes that do not store the information in this way need to
implement their own method.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>fm_manifold_get(fmexample$mesh)
fm_manifold(fmexample$mesh)
fm_manifold(fmexample$mesh, "R2")
fm_manifold_type(fmexample$mesh)
fm_manifold_dim(fmexample$mesh)
</code></pre>

<hr>
<h2 id='fm_mesh_1d'>Make a 1D mesh object</h2><span id='topic+fm_mesh_1d'></span>

<h3>Description</h3>

<p>Create a <code>fm_mesh_1d</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_mesh_1d(
  loc,
  interval = range(loc),
  boundary = NULL,
  degree = 1,
  free.clamped = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_mesh_1d_+3A_loc">loc</code></td>
<td>
<p>B-spline knot locations.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_interval">interval</code></td>
<td>
<p>Interval domain endpoints.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_boundary">boundary</code></td>
<td>
<p>Boundary condition specification.  Valid conditions are
<code>c('neumann', 'dirichlet', 'free', 'cyclic')</code>.  Two separate values can
be specified, one applied to each endpoint.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_degree">degree</code></td>
<td>
<p>The B-spline basis degree.  Supported values are 0, 1, and 2.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_free.clamped">free.clamped</code></td>
<td>
<p>If <code>TRUE</code>, for <code>'free'</code> boundaries, clamp the
basis functions to the interval endpoints.</p>
</td></tr>
<tr><td><code id="fm_mesh_1d_+3A_...">...</code></td>
<td>
<p>Additional options, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_1d</code> object
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2")) {
  m &lt;- fm_mesh_1d(c(1, 2, 3, 5, 8, 10),
    boundary = c("neumann", "free"),
    degree = 2
  )
  ggplot() +
    geom_fm(data = m, xlim = c(0.5, 10.5))
}

</code></pre>

<hr>
<h2 id='fm_mesh_2d'>Make a 2D mesh object</h2><span id='topic+fm_mesh_2d'></span><span id='topic+fm_mesh_2d_inla'></span>

<h3>Description</h3>

<p>Make a 2D mesh object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_mesh_2d(...)

fm_mesh_2d_inla(
  loc = NULL,
  loc.domain = NULL,
  offset = NULL,
  n = NULL,
  boundary = NULL,
  interior = NULL,
  max.edge = NULL,
  min.angle = NULL,
  cutoff = 1e-12,
  max.n.strict = NULL,
  max.n = NULL,
  plot.delay = NULL,
  crs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_mesh_2d_+3A_...">...</code></td>
<td>
<p>Currently passed on to <code>fm_mesh_2d_inla</code></p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_loc">loc</code></td>
<td>
<p>Matrix of point locations to be used as initial triangulation
nodes.  Can alternatively be a <code>sf</code>, <code>sfc</code>, <code>SpatialPoints</code> or
<code>SpatialPointsDataFrame</code> object.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_loc.domain">loc.domain</code></td>
<td>
<p>Matrix of point locations used to determine the domain
extent.  Can alternatively be a <code>SpatialPoints</code> or
<code>SpatialPointsDataFrame</code> object.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_offset">offset</code></td>
<td>
<p>The automatic extension distance.  One or two values, for an
inner and an optional outer extension.  If negative, interpreted as a factor
relative to the approximate data diameter (default=-0.10???)</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_n">n</code></td>
<td>
<p>The number of initial nodes in the automatic extensions
(default=16)</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_boundary">boundary</code></td>
<td>
<p>one or more (as list) of <code><a href="#topic+fm_segm">fm_segm()</a></code> objects, or objects
supported by <code><a href="#topic+fm_as_segm">fm_as_segm()</a></code></p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_interior">interior</code></td>
<td>
<p>one object supported by <code><a href="#topic+fm_as_segm">fm_as_segm()</a></code>, or (from version
<code style="white-space: pre;">&#8288;0.2.0.9016&#8288;</code>) a list of such objects.  If a list, the objects are joined
into a single object.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_max.edge">max.edge</code></td>
<td>
<p>The largest allowed triangle edge length.  One or two
values.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_min.angle">min.angle</code></td>
<td>
<p>The smallest allowed triangle angle.  One or two values.
(Default=21)</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_cutoff">cutoff</code></td>
<td>
<p>The minimum allowed distance between points.  Point at most as
far apart as this are replaced by a single vertex prior to the mesh
refinement step.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_max.n.strict">max.n.strict</code></td>
<td>
<p>The maximum number of vertices allowed, overriding
<code>min.angle</code> and <code>max.edge</code> (default=-1, meaning no limit).  One or
two values, where the second value gives the number of additional vertices
allowed for the extension.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_max.n">max.n</code></td>
<td>
<p>The maximum number of vertices allowed, overriding
<code>max.edge</code> only (default=-1, meaning no limit).  One or two values,
where the second value gives the number of additional vertices allowed for
the extension.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_plot.delay">plot.delay</code></td>
<td>
<p>If logical <code>TRUE</code> or a negative numeric value,
activates displaying the
result after each step of the multi-step domain extension algorithm.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_+3A_crs">crs</code></td>
<td>
<p>An optional <code><a href="#topic+fm_crs">fm_crs()</a></code>, <code>sf::crs</code> or <code>sp::CRS</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_2d</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_mesh_2d_inla()</code>: Legacy method for <code>INLA::inla.mesh.2d()</code>
Create a triangle mesh based on initial point locations, specified or
automatic boundaries, and mesh quality parameters.
</p>
</li></ul>


<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code><a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla()</a></code>, <code><a href="#topic+fm_mesh_2d_inla">fm_mesh_2d_inla()</a></code>,
and <code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, and <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> interfaces may be
different, and potentially change in the future.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, <code><a href="#topic+fm_delaunay_2d">fm_delaunay_2d()</a></code>,
<code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code>, <code><a href="#topic+fm_extensions">fm_extensions()</a></code>, <code><a href="#topic+fm_refine">fm_refine()</a></code>
</p>
<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_mesh_2d_inla(boundary = fm_extensions(cbind(2, 1), convex = 1, 2))

</code></pre>

<hr>
<h2 id='fm_mesh_2d_map'>Special coordinate mappings for <code>fm_mesh_2d</code> projections.</h2><span id='topic+fm_mesh_2d_map'></span><span id='topic+fm_mesh_2d_map_lim'></span>

<h3>Description</h3>

<p>Calculates coordinate mappings for spherical <code>fm_mesh_2d</code> projections.
This is an internal function not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_mesh_2d_map(loc, projection = NULL, inverse = TRUE)

fm_mesh_2d_map_lim(loc = NULL, projection = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_mesh_2d_map_+3A_loc">loc</code></td>
<td>
<p>Coordinates to be mapped.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_map_+3A_projection">projection</code></td>
<td>
<p>The projection type. One of <code>NULL</code>,
&quot;default&quot;, &quot;longlat&quot;, &quot;longsinlat&quot;, or &quot;mollweide&quot;.</p>
</td></tr>
<tr><td><code id="fm_mesh_2d_map_+3A_inverse">inverse</code></td>
<td>
<p>If <code>TRUE</code>, <code>loc</code> are map coordinates and
coordinates in the spherical domain are calculated.  If <code>FALSE</code>, <code>loc</code>
are coordinates in the spherical domain and the forward map projection is
calculated. Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>fm_mesh_2d_map_lim</code>, a list:
</p>
<table role = "presentation">
<tr><td><code>xlim</code></td>
<td>
<p>X axis limits in the map domain</p>
</td></tr>
<tr><td><code>ylim</code></td>
<td>
<p>Y axis limits in the map domain</p>
</td></tr>
</table>
<p>No attempt is
made to find minimal limits for partial spherical domains.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_mesh_2d_map_lim()</code>: Projection extent limit calculations
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_evaluator">fm_evaluator()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(loc &lt;- fm_mesh_2d_map(cbind(20, 10), "longlat"))
fm_mesh_2d_map(loc, "longlat", inverse = FALSE)

</code></pre>

<hr>
<h2 id='fm_mesh_3d'>Construct a 3D tetrahedralisation</h2><span id='topic+fm_mesh_3d'></span><span id='topic+fm_delaunay_3d'></span>

<h3>Description</h3>

<p>Constructs a 3D tetrahedralisation object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_mesh_3d(loc = NULL, tv = NULL, ...)

fm_delaunay_3d(loc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_mesh_3d_+3A_loc">loc</code></td>
<td>
<p>Input coordinates that should be part of the mesh. Can be a
matrix, <code>sf</code>, <code>sfc</code>, <code>SpatialPoints</code>, or other object supported by
<code><a href="#topic+fm_unify_coords">fm_unify_coords()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_mesh_3d_+3A_tv">tv</code></td>
<td>
<p>Tetrahedron indices, as a N-by-4 index vector into <code>loc</code></p>
</td></tr>
<tr><td><code id="fm_mesh_3d_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_3d</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_delaunay_3d()</code>: Construct a plain Delaunay triangulation in 3D.
Requires the <code>geometry</code> package.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- fm_mesh_3d(
  matrix(c(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0), 4, 3, byrow = TRUE),
  matrix(c(1, 2, 3, 4), 1, 4, byrow = TRUE)
))

(m &lt;- fm_delaunay_3d(matrix(rnorm(30), 10, 3)))

</code></pre>

<hr>
<h2 id='fm_mesh_intersection'>Construct the intersection mesh of a mesh and a polygon</h2><span id='topic+fm_mesh_intersection'></span>

<h3>Description</h3>

<p>Construct the intersection mesh of a mesh and a polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_mesh_intersection(mesh, poly)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_mesh_intersection_+3A_mesh">mesh</code></td>
<td>
<p><code>fm_mesh_2d</code> object to be intersected</p>
</td></tr>
<tr><td><code id="fm_mesh_intersection_+3A_poly">poly</code></td>
<td>
<p><code>fm_segm</code> object with a closed polygon
to intersect with the mesh</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> object
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>segm &lt;- fm_segm(rbind(c(-4, -4), c(4, -4), c(0, 4)),
  is.bnd = TRUE
)
str(m &lt;- fm_mesh_intersection(fmexample$mesh, segm))
plot(fmexample$mesh)
lines(segm, col = 4)
plot(m, edge.color = 2, add = TRUE)
</code></pre>

<hr>
<h2 id='fm_nonconvex_hull'>Compute an extension of a spatial object</h2><span id='topic+fm_nonconvex_hull'></span><span id='topic+fm_nonconvex_hull.sfc'></span><span id='topic+fm_extensions'></span><span id='topic+fm_nonconvex_hull.matrix'></span><span id='topic+fm_nonconvex_hull.sf'></span><span id='topic+fm_nonconvex_hull.Spatial'></span><span id='topic+fm_nonconvex_hull.sfg'></span>

<h3>Description</h3>

<p>Constructs a potentially nonconvex extension of a spatial object by
performing dilation by <code>convex + concave</code> followed by
erosion by <code>concave</code>. This is equivalent to dilation by <code>convex</code> followed
by closing (dilation + erosion) by <code>concave</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_nonconvex_hull(x, ...)

## S3 method for class 'sfc'
fm_nonconvex_hull(
  x,
  convex = -0.15,
  concave = convex,
  preserveTopology = TRUE,
  dTolerance = NULL,
  crs = fm_crs(x),
  ...
)

fm_extensions(x, convex = -0.15, concave = convex, dTolerance = NULL, ...)

## S3 method for class 'matrix'
fm_nonconvex_hull(x, ...)

## S3 method for class 'sf'
fm_nonconvex_hull(x, ...)

## S3 method for class 'Spatial'
fm_nonconvex_hull(x, ...)

## S3 method for class 'sfg'
fm_nonconvex_hull(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_nonconvex_hull_+3A_x">x</code></td>
<td>
<p>A spatial object</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> sub-methods</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_convex">convex</code></td>
<td>
<p>numeric vector; How much to extend</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_concave">concave</code></td>
<td>
<p>numeric vector; The minimum allowed reentrant curvature.
Default equal to <code>convex</code></p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_preservetopology">preserveTopology</code></td>
<td>
<p>logical; argument to <code>sf::st_simplify()</code></p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_dtolerance">dTolerance</code></td>
<td>
<p>If not zero, controls the <code>dTolerance</code> argument to
<code>sf::st_simplify()</code>. The default is <code>pmin(convex, concave) / 40</code>, chosen to
give approximately 4 or more subsegments per circular quadrant.</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_+3A_crs">crs</code></td>
<td>
<p>Options crs object for the resulting polygon</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Morphological dilation by <code>convex</code>, followed by closing by
<code>concave</code>, with minimum concave curvature radius <code>concave</code>.  If
the dilated set has no gaps of width between </p>
<p style="text-align: center;"><code class="reqn">2 \textrm{convex}
(\sqrt{1+2\textrm{concave}/\textrm{convex}} - 1)
</code>
</p>

<p>and <code class="reqn">2\textrm{concave}</code>, then the minimum convex curvature
radius is <code>convex</code>.
</p>
<p>The implementation is based on the identity </p>
<p style="text-align: center;"><code class="reqn">\textrm{dilation}(a) \&amp;
\textrm{closing}(b) = \textrm{dilation}(a+b) \&amp; \textrm{erosion}(b)</code>
</p>
<p> where all operations
are with respect to disks with the specified radii.
</p>
<p>When <code>convex</code>, <code>concave</code>, or <code>dTolerance</code> are negative,
<code>fm_diameter * abs(...)</code> is used instead.
</p>
<p>Differs from <code>sf::st_buffer(x, convex)</code> followed by
<code>sf::st_concave_hull()</code> (available from GEOS 3.11)
in how the amount of allowed concavity is controlled.
</p>


<h3>Value</h3>

<p><code>fm_nonconvex_hull()</code> returns an extended object as an <code>sfc</code>
polygon object (regardless of the <code>x</code> class).
</p>
<p><code>fm_extensions()</code> returns a list of <code>sfc</code> objects.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_nonconvex_hull()</code>: Basic nonconvex hull method.
</p>
</li>
<li> <p><code>fm_extensions()</code>: Constructs a potentially nonconvex extension of a spatial object by
performing dilation by <code>convex + concave</code> followed by
erosion by <code>concave</code>. This is equivalent to dilation by <code>convex</code> followed
by closing (dilation + erosion) by <code>concave</code>.
</p>
</li></ul>


<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code><a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla()</a></code>, <code><a href="#topic+fm_mesh_2d_inla">fm_mesh_2d_inla()</a></code>,
and <code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, and <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> interfaces may be
different, and potentially change in the future.
</p>


<h3>References</h3>

<p>Gonzalez and Woods (1992), Digital Image Processing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inp &lt;- matrix(rnorm(20), 10, 2)
out &lt;- fm_nonconvex_hull(inp, convex = 1)
plot(out)
points(inp, pch = 20)
if (TRUE) {
  inp &lt;- sf::st_as_sf(as.data.frame(matrix(1:6, 3, 2)), coords = 1:2)
  bnd &lt;- fm_extensions(inp, convex = c(0.75, 2))
  plot(fm_mesh_2d(boundary = bnd, max.edge = c(0.25, 1)), asp = 1)
}
</code></pre>

<hr>
<h2 id='fm_nonconvex_hull_inla'>Non-convex hull computation</h2><span id='topic+fm_nonconvex_hull_inla'></span><span id='topic+fm_nonconvex_hull_inla_basic'></span>

<h3>Description</h3>

<p>Legacy method for <code>INLA::inla.nonconvex.hull()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_nonconvex_hull_inla(
  x,
  convex = -0.15,
  concave = convex,
  resolution = 40,
  eps = NULL,
  eps_rel = NULL,
  crs = NULL,
  ...
)

fm_nonconvex_hull_inla_basic(
  x,
  convex = -0.15,
  resolution = 40,
  eps = NULL,
  crs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_nonconvex_hull_inla_+3A_x">x</code></td>
<td>
<p>A spatial object</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_convex">convex</code></td>
<td>
<p>numeric vector; How much to extend</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_concave">concave</code></td>
<td>
<p>numeric vector; The minimum allowed reentrant curvature.
Default equal to <code>convex</code></p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_resolution">resolution</code></td>
<td>
<p>The internal computation resolution.  A warning will be
issued when this needs to be increased for higher accuracy, with the
required resolution stated.</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_eps">eps</code>, <code id="fm_nonconvex_hull_inla_+3A_eps_rel">eps_rel</code></td>
<td>
<p>The polygonal curve simplification tolerances used for
simplifying the resulting boundary curve.  See <code><a href="#topic+fm_simplify_helper">fm_simplify_helper()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_crs">crs</code></td>
<td>
<p>Options crs object for the resulting polygon</p>
</td></tr>
<tr><td><code id="fm_nonconvex_hull_inla_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires <code>splancs::nndistF()</code>
</p>


<h3>Value</h3>

<p><code>fm_nonconvex_hull_inla()</code> returns an <a href="#topic+fm_segm">fm_segm</a>
object, for compatibility with <code>inla.nonconvex.hull()</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_nonconvex_hull_inla_basic()</code>: Special method for <code>convex = 0</code>.
</p>
</li></ul>


<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code><a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla()</a></code>, <code><a href="#topic+fm_mesh_2d_inla">fm_mesh_2d_inla()</a></code>,
and <code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, and <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> interfaces may be
different, and potentially change in the future.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code>
</p>
<p>Other nonconvex inla legacy support: 
<code><a href="#topic+fm_segm_contour_helper">fm_segm_contour_helper</a>()</code>,
<code><a href="#topic+fm_simplify_helper">fm_simplify_helper</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm_nonconvex_hull_inla(cbind(0, 0), convex = 1)

</code></pre>

<hr>
<h2 id='fm_pixels'>Generate lattice points covering a mesh</h2><span id='topic+fm_pixels'></span>

<h3>Description</h3>

<p>Generate <code>terra</code>, <code>sf</code>, or <code>sp</code> lattice locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_pixels(
  mesh,
  dims = c(150, 150),
  xlim = NULL,
  ylim = NULL,
  mask = TRUE,
  format = "sf",
  minimal = TRUE,
  nx = deprecated(),
  ny = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_pixels_+3A_mesh">mesh</code></td>
<td>
<p>An <code>fm_mesh_2d</code> object</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_dims">dims</code></td>
<td>
<p>A length 2 integer vector giving the dimensions of
the target lattice.</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_xlim">xlim</code>, <code id="fm_pixels_+3A_ylim">ylim</code></td>
<td>
<p>Length 2 numeric vectors of x- and y- axis limits.
Defaults taken from the range of the mesh or mask; see <code>minimal</code>.</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_mask">mask</code></td>
<td>
<p>If logical and TRUE, remove pixels that are outside the mesh.
If <code>mask</code> is an <code>sf</code> or <code>Spatial</code> object, only return pixels covered by this
object.</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_format">format</code></td>
<td>
<p>character; &quot;sf&quot;, &quot;terra&quot; or &quot;sp&quot;</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_minimal">minimal</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), the default range is determined
by the minimum of the ranges of the mesh and mask, otherwise only the mesh.</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_nx">nx</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Number of pixels in x direction,
or a numeric vector of x-values</p>
</td></tr>
<tr><td><code id="fm_pixels_+3A_ny">ny</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Number of pixels in y direction,
or a numeric vector of y-values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code>, <code>SpatRaster</code>, or <code>SpatialPixelsDataFrame</code> covering the mesh or
mask.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE)) {
  dims &lt;- c(50, 50)
  pxl &lt;- fm_pixels(
    fmexample$mesh,
    dims = dims,
    mask = fmexample$boundary_sf[[1]],
    minimal = TRUE
  )
  pxl$val &lt;- rnorm(NROW(pxl)) +
    fm_evaluate(fmexample$mesh, pxl, field = 2 * fmexample$mesh$loc[, 1])
  ggplot() +
    geom_tile(
      data = pxl,
      aes(geometry = geometry, fill = val),
      stat = "sf_coordinates"
    ) +
    geom_sf(data = fm_as_sfc(fmexample$mesh), alpha = 0.2)
}


if (require("ggplot2", quietly = TRUE) &amp;&amp;
  require("terra", quietly = TRUE) &amp;&amp;
  require("tidyterra", quietly = TRUE)) {
  pxl &lt;- fm_pixels(fmexample$mesh,
    dims = c(50, 50), mask = fmexample$boundary_sf[[1]],
    format = "terra"
  )
  pxl$val &lt;- rnorm(NROW(pxl) * NCOL(pxl))
  pxl &lt;-
    terra::mask(
      pxl,
      mask = pxl$.mask,
      maskvalues = c(FALSE, NA),
      updatevalue = NA
    )
  ggplot() +
    geom_spatraster(data = pxl, aes(fill = val)) +
    geom_sf(data = fm_as_sfc(fmexample$mesh), alpha = 0.2)
}

</code></pre>

<hr>
<h2 id='fm_qinv'>Sparse partial inverse</h2><span id='topic+fm_qinv'></span>

<h3>Description</h3>

<p>Compute sparse partial matrix inverse. As of <code style="white-space: pre;">&#8288;0.2.0.9010&#8288;</code>, an R
implementation of the Takahashi recursion method, unless a special build of
the <code>fmesher</code> package is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_qinv(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_qinv_+3A_a">A</code></td>
<td>
<p>A sparse symmetric positive definite matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse symmetric matrix, with the elements of the inverse of <code>A</code>
for the non-zero pattern of <code>A</code> plus potential Cholesky in-fill locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- Matrix::Matrix(
  c(2, -1, 0, 0, -1, 2, -1, 0, 0, -1, 2, -1, 0, 0, -1, 2),
  4,
  4
)
# Partial inverse:
(S &lt;- fm_qinv(A))
# Full inverse (not guaranteed to be symmetric):
(S2 &lt;- solve(A))
# Matrix symmetry:
c(sum((S - Matrix::t(S))^2), sum((S2 - Matrix::t(S2))^2))
# Accuracy (not that S2 is non-symmetric, and S may be more accurate):
sum((S - S2)[S != 0]^2)
</code></pre>

<hr>
<h2 id='fm_raw_basis'>Basis functions for mesh manifolds</h2><span id='topic+fm_raw_basis'></span>

<h3>Description</h3>

<p>Calculate basis functions on <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> or <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>,
without necessarily matching the default function space of the given mesh
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_raw_basis(
  mesh,
  type = "b.spline",
  n = 3,
  degree = 2,
  knot.placement = "uniform.area",
  rot.inv = TRUE,
  boundary = "free",
  free.clamped = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_raw_basis_+3A_mesh">mesh</code></td>
<td>
<p>An <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> or <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_type">type</code></td>
<td>
<p><code>b.spline</code> (default) for B-spline basis functions,
<code>sph.harm</code> for spherical harmonics (available only for meshes on the
sphere)</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_n">n</code></td>
<td>
<p>For B-splines, the number of basis functions in each direction (for
1d meshes <code>n</code> must be a scalar, and for planar 2d meshes a 2-vector).
For spherical harmonics, <code>n</code> is the maximal harmonic order.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_degree">degree</code></td>
<td>
<p>Degree of B-spline polynomials.  See
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_knot.placement">knot.placement</code></td>
<td>
<p>For B-splines on the sphere, controls the latitudinal
placements of knots. <code>"uniform.area"</code> (default) gives uniform spacing
in <code>sin(latitude)</code>, <code>"uniform.latitude"</code> gives uniform spacing in
latitudes.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_rot.inv">rot.inv</code></td>
<td>
<p>For spherical harmonics on a sphere, <code>rot.inv=TRUE</code>
gives the rotationally invariant subset of basis functions.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_boundary">boundary</code></td>
<td>
<p>Boundary specification, default is free boundaries.  See
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_free.clamped">free.clamped</code></td>
<td>
<p>If <code>TRUE</code> and <code>boundary</code> is <code>"free"</code>, the
boundary basis functions are clamped to 0/1 at the interval boundary by
repeating the boundary knots. See
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="fm_raw_basis_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with evaluated basis function
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, <code><a href="#topic+fm_basis">fm_basis()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
loc &lt;- rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1))
mesh &lt;- fm_mesh_2d(loc, max.edge = 0.15)
basis &lt;- fm_raw_basis(mesh, n = c(4, 5))

proj &lt;- fm_evaluator(mesh, dims = c(10, 10))
image(proj$x, proj$y, fm_evaluate(proj, basis[, 7]), asp = 1)

if (interactive() &amp;&amp; require("rgl")) {
  plot_rgl(mesh, col = basis[, 7], draw.edges = FALSE, draw.vertices = FALSE)
}


</code></pre>

<hr>
<h2 id='fm_rcdt_2d'>Refined Constrained Delaunay Triangulation</h2><span id='topic+fm_rcdt_2d'></span><span id='topic+fm_rcdt_2d_inla'></span><span id='topic+fm_delaunay_2d'></span>

<h3>Description</h3>

<p>Computes a refined constrained Delaunay triangulation on R2 or S2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_rcdt_2d(...)

fm_rcdt_2d_inla(
  loc = NULL,
  tv = NULL,
  boundary = NULL,
  interior = NULL,
  extend = (missing(tv) || is.null(tv)),
  refine = FALSE,
  lattice = NULL,
  globe = NULL,
  cutoff = 1e-12,
  quality.spec = NULL,
  crs = NULL,
  ...
)

fm_delaunay_2d(loc, crs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_rcdt_2d_+3A_...">...</code></td>
<td>
<p>Currently passed on to <code>fm_mesh_2d_inla</code> or converted to
<code><a href="#topic+fmesher_rcdt">fmesher_rcdt()</a></code> options.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_loc">loc</code></td>
<td>
<p>Input coordinates that should be part of the mesh. Can be a
matrix, <code>sf</code>, <code>sfc</code>, <code>SpatialPoints</code>, or other object supported by
<code><a href="#topic+fm_unify_coords">fm_unify_coords()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_tv">tv</code></td>
<td>
<p>Initial triangulation, as a N-by-3 index vector into <code>loc</code></p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_boundary">boundary</code>, <code id="fm_rcdt_2d_+3A_interior">interior</code></td>
<td>
<p>Objects supported by <code><a href="#topic+fm_as_segm">fm_as_segm()</a></code>.
If <code>boundary</code> is <code>numeric</code>, <code>fm_nonconvex_hull(loc, convex = boundary)</code> is
used.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_extend">extend</code></td>
<td>
<p><code>logical</code> or <code>list</code> specifying whether to extend the
data region, with parameters </p>
 <dl>
<dt>list(&quot;n&quot;)</dt><dd><p>the number of edges
in the extended boundary (default=16)</p>
</dd> <dt>list(&quot;offset&quot;)</dt><dd><p>the extension
distance.  If negative, interpreted as a factor relative to the approximate
data diameter (default=-0.10)</p>
</dd> </dl>
<p> Setting to <code>FALSE</code> is only useful in
combination <code>lattice</code> or <code>boundary</code>.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_refine">refine</code></td>
<td>
<p><code>logical</code> or <code>list</code> specifying whether to refine the
triangulation, with parameters </p>
 <dl>
<dt>list(&quot;min.angle&quot;)</dt><dd><p>the
minimum allowed interior angle in any triangle.  The algorithm is guaranteed
to converge for <code>min.angle</code> at most 21 (default=<code>21</code>)</p>
</dd>
<dt>list(&quot;max.edge&quot;)</dt><dd><p>the maximum allowed edge length in any triangle.  If
negative, interpreted as a relative factor in an ad hoc formula depending on
the data density (default=<code>Inf</code>)</p>
</dd> <dt>list(&quot;max.n.strict&quot;)</dt><dd><p>the
maximum number of vertices allowed, overriding <code>min.angle</code> and
<code>max.edge</code> (default=-1, meaning no limit)</p>
</dd> <dt>list(&quot;max.n&quot;)</dt><dd><p>the
maximum number of vertices allowed, overriding <code>max.edge</code> only
(default=-1, meaning no limit)</p>
</dd> </dl>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_lattice">lattice</code></td>
<td>
<p>An <code>fm_lattice_2d</code> object, generated by
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d()</a></code>, specifying points on a regular lattice.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_globe">globe</code></td>
<td>
<p>If non-NULL, an integer specifying the level of subdivision
for global mesh points, used with <code><a href="#topic+fmesher_globe_points">fmesher_globe_points()</a></code></p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_cutoff">cutoff</code></td>
<td>
<p>The minimum allowed distance between points.  Point at most as
far apart as this are replaced by a single vertex prior to the mesh
refinement step.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_quality.spec">quality.spec</code></td>
<td>
<p>List of vectors of per vertex <code>max.edge</code> target
specification for each location in <code>loc</code>, <code>boundary/interior</code>
(<code>segm</code>), and <code>lattice</code>.  Only used if refining the mesh.</p>
</td></tr>
<tr><td><code id="fm_rcdt_2d_+3A_crs">crs</code></td>
<td>
<p>Optional crs object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_2d</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_rcdt_2d_inla()</code>: Legacy method for the <code>INLA::inla.mesh.create()</code>
interface
</p>
</li>
<li> <p><code>fm_delaunay_2d()</code>: Construct a plain Delaunay triangulation.
</p>
</li></ul>


<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code><a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla()</a></code>, <code><a href="#topic+fm_mesh_2d_inla">fm_mesh_2d_inla()</a></code>,
and <code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla()</a></code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>, <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>, and <code><a href="#topic+fm_nonconvex_hull">fm_nonconvex_hull()</a></code> interfaces may be
different, and potentially change in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- fm_rcdt_2d_inla(
  boundary = fm_nonconvex_hull(cbind(0, 0), convex = 5)
))

fm_delaunay_2d(matrix(rnorm(30), 15, 2))

</code></pre>

<hr>
<h2 id='fm_refine'>Refine a 2d mesh</h2><span id='topic+fm_refine'></span>

<h3>Description</h3>

<p>Refine an existing mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_refine(mesh, refine = list(max.edge = 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_refine_+3A_mesh">mesh</code></td>
<td>
<p>An <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object</p>
</td></tr>
<tr><td><code id="fm_refine_+3A_refine">refine</code></td>
<td>
<p>A list of refinement options passed on to
<a href="#topic+fm_rcdt_2d_inla">fm_rcdt_2d_inla</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A refined <code>fm_mesh_2d</code> object
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_dof(fmexample$mesh)
fm_dof(fm_refine(fmexample$mesh, refine = list(max.edge = 1)))

</code></pre>

<hr>
<h2 id='fm_row_kron'>Row-wise Kronecker products</h2><span id='topic+fm_row_kron'></span>

<h3>Description</h3>

<p>Takes two Matrices and computes the row-wise Kronecker product.  Optionally
applies row-wise weights and/or applies an additional 0/1 row-wise Kronecker
matrix product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_row_kron(M1, M2, repl = NULL, n.repl = NULL, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_row_kron_+3A_m1">M1</code></td>
<td>
<p>A matrix that can be transformed into a sparse Matrix.</p>
</td></tr>
<tr><td><code id="fm_row_kron_+3A_m2">M2</code></td>
<td>
<p>A matrix that can be transformed into a sparse Matrix.</p>
</td></tr>
<tr><td><code id="fm_row_kron_+3A_repl">repl</code></td>
<td>
<p>An optional index vector.  For each entry, specifies which
replicate the row belongs to, in the sense used in
<code>INLA::inla.spde.make.A</code></p>
</td></tr>
<tr><td><code id="fm_row_kron_+3A_n.repl">n.repl</code></td>
<td>
<p>The maximum replicate index, in the sense used in
<code>INLA::inla.spde.make.A()</code>.</p>
</td></tr>
<tr><td><code id="fm_row_kron_+3A_weights">weights</code></td>
<td>
<p>Optional scaling weights to be applied row-wise to the
resulting matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Matrix::sparseMatrix</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_row_kron(rbind(c(1, 1, 0), c(0, 1, 1)), rbind(c(1, 2), c(3, 4)))

</code></pre>

<hr>
<h2 id='fm_safe_sp'>Check for potential <code>sp</code> version compatibility issues</h2><span id='topic+fm_safe_sp'></span>

<h3>Description</h3>

<p>Loads the sp package with <code>requireNamespace("sp", quietly = TRUE)</code>, and
checks and optionally sets the <code>sp</code> evolution status flag if <code>rgdal</code> is
unavailable.
This function is only needed for backwards compatibility with <code>sp</code> versions
before <code>2.0-0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_safe_sp(quietly = FALSE, force = FALSE, minimum_version = "1.4-5")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_safe_sp_+3A_quietly">quietly</code></td>
<td>
<p>logical; if <code>TRUE</code>, prints diagnostic messages. Default
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="fm_safe_sp_+3A_force">force</code></td>
<td>
<p>logical; If <code>rgdal</code> is unavailable
and evolution status is less that <code>2L</code>, return <code>FALSE</code> if <code>force</code> is <code>FALSE</code>.
If <code>force</code> is <code>TRUE</code>, return <code>TRUE</code> if the package configuration is safe,
potentially after forcing the evolution status to <code>2L</code>.
Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fm_safe_sp_+3A_minimum_version">minimum_version</code></td>
<td>
<p>character; the minimum required sp version.
Default 1.4-5 (should always match the requirement in the package
DESCRIPTION)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (invisibly) <code>FALSE</code> if a potential issue is detected, and
give a message if <code>quietly</code> is <code>FALSE</code>. Otherwise returns <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (fm_safe_sp()) {
  # Run sp dependent calculations
}
</code></pre>

<hr>
<h2 id='fm_segm'>Make a spatial segment object</h2><span id='topic+fm_segm'></span><span id='topic+fm_segm.default'></span><span id='topic+fm_segm.fm_segm'></span><span id='topic+fm_segm.fm_segm_list'></span><span id='topic+fm_segm_join'></span><span id='topic+fm_segm_split'></span><span id='topic+fm_segm.inla.mesh.segment'></span><span id='topic+fm_segm.fm_mesh_2d'></span><span id='topic+fm_is_bnd'></span><span id='topic+fm_is_bnd+3C-'></span>

<h3>Description</h3>

<p>Make a spatial segment object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_segm(...)

## Default S3 method:
fm_segm(loc = NULL, idx = NULL, grp = NULL, is.bnd = TRUE, crs = NULL, ...)

## S3 method for class 'fm_segm'
fm_segm(..., grp = NULL, grp.default = 0L, is.bnd = NULL)

## S3 method for class 'fm_segm_list'
fm_segm(x, grp = NULL, grp.default = 0L, ...)

fm_segm_join(x, grp = NULL, grp.default = 0L, is.bnd = NULL)

fm_segm_split(x, grp = NULL, grp.default = 0L)

## S3 method for class 'inla.mesh.segment'
fm_segm(..., grp.default = 0)

## S3 method for class 'fm_mesh_2d'
fm_segm(x, boundary = TRUE, grp = NULL, ...)

fm_is_bnd(x)

fm_is_bnd(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_segm_+3A_...">...</code></td>
<td>
<p>Passed on to submethods</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_loc">loc</code></td>
<td>
<p>Matrix of point locations, or <code>SpatialPoints</code>, or <code>sf</code>/<code>sfc</code> point
object.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_idx">idx</code></td>
<td>
<p>Segment index sequence vector or index pair matrix.  The indices
refer to the rows of <code>loc</code>.  If <code>loc==NULL</code>, the indices will be
interpreted as indices into the point specification supplied to
<code><a href="#topic+fm_rcdt_2d">fm_rcdt_2d()</a></code>.  If <code>is.bnd==TRUE</code>, defaults to linking
all the points in <code>loc</code>, as <code>c(1:nrow(loc),1L)</code>, otherwise
<code>1:nrow(loc)</code>.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_grp">grp</code></td>
<td>
<p>When joining segments, use these group labels for segments
instead of the original group labels.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_is.bnd">is.bnd</code></td>
<td>
<p><code>TRUE</code> if the segments are boundary segments, otherwise
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_crs">crs</code></td>
<td>
<p>An optional <code>fm_crs()</code>, <code>sf::st_crs()</code> or <code>sp::CRS()</code> object</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_grp.default">grp.default</code></td>
<td>
<p>If <code>grp.default</code> is <code>NULL</code>, use these group labels for
segments with NULL group.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_x">x</code></td>
<td>
<p>Mesh to extract segments from</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_boundary">boundary</code></td>
<td>
<p>logical; if <code>TRUE</code>, extract the boundary segments,
otherwise interior constrain segments.</p>
</td></tr>
<tr><td><code id="fm_segm_+3A_value">value</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_segm</code> or <code>fm_segm_list</code> object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_segm(fm_segm)</code>: Join multiple <code>fm_segm</code> objects into a single <code>fm_segm</code>
object. If <code>is.bnd</code> is non-NULL, it overrides the input segment information.
Otherwise, it checks if the inputs are consistent.
</p>
</li>
<li> <p><code>fm_segm(fm_segm_list)</code>: Join <code>fm_segm</code> objects from a <code>fm_segm_list</code> into
a single <code>fm_segm</code> object. Equivalent to <code>fm_segm_join(x)</code>
</p>
</li>
<li> <p><code>fm_segm(fm_mesh_2d)</code>: Extract the boundary or interior segments of a 2d mesh.
If <code>grp</code> is non-NULL, extracts only segments matching the matching the set
of groups given by <code>grp</code>.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_segm()</code>: Create a new <code>fm_segm</code> object.
</p>
</li>
<li> <p><code>fm_segm_join()</code>: Join multiple <code>fm_segm</code> objects into a single <code>fm_segm</code>
object. If <code>is.bnd</code> is non-NULL, it overrides the segment information.
Otherwise it checks for consistency.
</p>
</li>
<li> <p><code>fm_segm_split()</code>: Split an <code>fm_segm</code> object by <code>grp</code> into an <code>fm_segm_list</code>
object, optionally keeping only some groups.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_segm(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1)), is.bnd = FALSE)
fm_segm(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1)), is.bnd = TRUE)

fm_segm_join(fmexample$boundary_fm)

fm_segm(fmexample$mesh, boundary = TRUE)
fm_segm(fmexample$mesh, boundary = FALSE)

</code></pre>

<hr>
<h2 id='fm_segm_contour_helper'>Contour segment</h2><span id='topic+fm_segm_contour_helper'></span>

<h3>Description</h3>

<p>Helper from legacy <code>INLA::inla.contour.segment()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_segm_contour_helper(
  x = seq(0, 1, length.out = nrow(z)),
  y = seq(0, 1, length.out = ncol(z)),
  z,
  nlevels = 10,
  levels = NULL,
  groups = NULL,
  positive = TRUE,
  eps = NULL,
  eps_rel = NULL,
  crs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_segm_contour_helper_+3A_x">x</code>, <code id="fm_segm_contour_helper_+3A_y">y</code>, <code id="fm_segm_contour_helper_+3A_z">z</code></td>
<td>
<p>The <code>x</code> and <code>y</code> coordinates of the grid, and the <code>z</code> values</p>
</td></tr>
<tr><td><code id="fm_segm_contour_helper_+3A_nlevels">nlevels</code></td>
<td>
<p>Number of contour levels</p>
</td></tr>
<tr><td><code id="fm_segm_contour_helper_+3A_levels">levels</code></td>
<td>
<p>The contour levels. If <code>NULL</code>,
<code>pretty(range(z, na.rm = TRUE), nlevels)</code> is used.</p>
</td></tr>
<tr><td><code id="fm_segm_contour_helper_+3A_groups">groups</code></td>
<td>
<p>The group values for each contour level.
If <code>NULL</code>, <code>seq_len(length(levels))</code> is used.</p>
</td></tr>
<tr><td><code id="fm_segm_contour_helper_+3A_positive">positive</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the contour lines are made to be
CCW around positive excursions</p>
</td></tr>
<tr><td><code id="fm_segm_contour_helper_+3A_eps">eps</code>, <code id="fm_segm_contour_helper_+3A_eps_rel">eps_rel</code></td>
<td>
<p>Polygonal curve simplification tolerances</p>
</td></tr>
<tr><td><code id="fm_segm_contour_helper_+3A_crs">crs</code></td>
<td>
<p>A coordinate reference system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_segm</code> object
</p>


<h3>See Also</h3>

<p>Other nonconvex inla legacy support: 
<code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla</a>()</code>,
<code><a href="#topic+fm_simplify_helper">fm_simplify_helper</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_segm_contour_helper(z = matrix(1:16, 4, 4))

</code></pre>

<hr>
<h2 id='fm_segm_list'>Methods for fm_segm lists</h2><span id='topic+fm_segm_list'></span><span id='topic+c.fm_segm'></span><span id='topic+c.fm_segm_list'></span><span id='topic++5B.fm_segm_list'></span>

<h3>Description</h3>

<p><code>fm_segm</code> lists can be combined into <code>fm_segm_list</code> list objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_segm'
c(...)

## S3 method for class 'fm_segm_list'
c(...)

## S3 method for class 'fm_segm_list'
x[i]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_segm_list_+3A_...">...</code></td>
<td>
<p>Objects to be combined.</p>
</td></tr>
<tr><td><code id="fm_segm_list_+3A_x">x</code></td>
<td>
<p><code>fm_segm_list</code> object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="fm_segm_list_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fm_segm_list</code> object
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>c(fm_segm_list)</code>: The <code>...</code> arguments should be coercible to
<code>fm_segm_list</code> objects.
</p>
</li>
<li> <p><code>[</code>: Extract sub-list
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>c(fm_segm)</code>: The <code>...</code> arguments should be <code>fm_segm</code>
objects, or coercible with <code>fm_as_segm_list(list(...))</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fm_as_segm_list">fm_as_segm_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- c(A = fm_segm(1:2), B = fm_segm(3:4))
str(m)
str(m[2])
</code></pre>

<hr>
<h2 id='fm_simplify'>Recursive curve simplification.</h2><span id='topic+fm_simplify'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Simplifies polygonal curve segments by joining nearly
co-linear segments.
</p>
<p>Uses a variation of the binary splitting Ramer-Douglas-Peucker algorithm,
with an ellipse of half-width <code>eps</code> ellipse instead of a rectangle, motivated
by prediction ellipse for Brownian bridge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_simplify(x, eps = NULL, eps_rel = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_simplify_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+fm_segm">fm_segm()</a></code> object.</p>
</td></tr>
<tr><td><code id="fm_simplify_+3A_eps">eps</code></td>
<td>
<p>Absolute straightness tolerance. Default <code>NULL</code>, no constraint.</p>
</td></tr>
<tr><td><code id="fm_simplify_+3A_eps_rel">eps_rel</code></td>
<td>
<p>Relative straightness tolerance. Default <code>NULL</code>, no
constraint.</p>
</td></tr>
<tr><td><code id="fm_simplify_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variation of Ramer-Douglas-Peucker.
Uses width epsilon ellipse instead of rectangle,
motivated by prediction ellipse for Brownian bridge.
</p>


<h3>Value</h3>

<p>The simplified <code><a href="#topic+fm_segm">fm_segm()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>References</h3>

<p>Ramer, Urs (1972). &quot;An iterative procedure for the polygonal approximation of
plane curves&quot;. <em>Computer Graphics and Image Processing</em>. <strong>1</strong> (3): 244‚Äì256.
<a href="https://doi.org/10.1016/S0146-664X%2872%2980017-0">doi:10.1016/S0146-664X(72)80017-0</a>
</p>
<p>Douglas, David; Peucker, Thomas (1973). &quot;Algorithms for the reduction of
the number of points required to represent a digitized line or its
caricature&quot;. <em>The Canadian Cartographer</em>. <strong>10</strong> (2): 112‚Äì122.
<a href="https://doi.org/10.3138/FM57-6770-U75U-7727">doi:10.3138/FM57-6770-U75U-7727</a>
</p>


<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_tensor">fm_tensor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- seq(0, 2 * pi, length.out = 1000)
(segm &lt;- fm_segm(cbind(cos(theta), sin(theta)),
  idx = seq_along(theta)
))
(segm1 &lt;- fm_simplify(segm, eps_rel = 0.1))
(segm2 &lt;- fm_simplify(segm, eps_rel = 0.2))
plot(segm)
lines(segm1, col = 2)
lines(segm2, col = 3)

(segm &lt;- fm_segm(cbind(theta, sin(theta * 4)),
  idx = seq_along(theta)
))
(segm1 &lt;- fm_simplify(segm, eps_rel = 0.1))
(segm2 &lt;- fm_simplify(segm, eps_rel = 0.2))
plot(segm)
lines(segm1, col = 2)
lines(segm2, col = 3)
</code></pre>

<hr>
<h2 id='fm_simplify_helper'>Recursive curve simplification.</h2><span id='topic+fm_simplify_helper'></span>

<h3>Description</h3>

<p>Helper from legacy <code>INLA::inla.simplify.curve()</code>
</p>
<p>Attempts to simplify a polygonal curve by joining nearly colinear segments.
</p>
<p>Uses a variation of the binary splitting Ramer-Douglas-Peucker algorithm,
with an ellipse of half-width <code>eps</code> ellipse instead of a rectangle, motivated
by prediction ellipse for Brownian bridge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_simplify_helper(loc, idx, eps = NULL, eps_rel = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_simplify_helper_+3A_loc">loc</code></td>
<td>
<p>Coordinate matrix.</p>
</td></tr>
<tr><td><code id="fm_simplify_helper_+3A_idx">idx</code></td>
<td>
<p>Index vector into <code>loc</code> specifying a polygonal curve.</p>
</td></tr>
<tr><td><code id="fm_simplify_helper_+3A_eps">eps</code></td>
<td>
<p>Absolute straightness tolerance. Default <code>NULL</code>, no constraint.</p>
</td></tr>
<tr><td><code id="fm_simplify_helper_+3A_eps_rel">eps_rel</code></td>
<td>
<p>Relative straightness tolerance. Default <code>NULL</code>, no
constraint.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variation of Ramer-Douglas-Peucker.
Uses width epsilon ellipse instead of rectangle,
motivated by prediction ellipse for Brownian bridge.
</p>


<h3>Value</h3>

<p>An index vector into <code>loc</code> specifying the simplified polygonal
curve.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other nonconvex inla legacy support: 
<code><a href="#topic+fm_nonconvex_hull_inla">fm_nonconvex_hull_inla</a>()</code>,
<code><a href="#topic+fm_segm_contour_helper">fm_segm_contour_helper</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
theta &lt;- seq(0, 2 * pi, length.out = 1000)
loc &lt;- cbind(cos(theta), sin(theta))
idx &lt;- fm_simplify_helper(loc = loc, idx = 1:nrow(loc), eps = 0.01)
print(c(nrow(loc), length(idx)))
plot(loc, type = "l")
lines(loc[idx, ], col = "red")
</code></pre>

<hr>
<h2 id='fm_split_lines'>Split lines at triangle edges</h2><span id='topic+fm_split_lines'></span><span id='topic+fm_split_lines.fm_mesh_2d'></span>

<h3>Description</h3>

<p>Compute intersections between line segments and triangle edges,
and filter out segment of length zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_split_lines(mesh, ...)

## S3 method for class 'fm_mesh_2d'
fm_split_lines(mesh, segm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_split_lines_+3A_mesh">mesh</code></td>
<td>
<p>An <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> object</p>
</td></tr>
<tr><td><code id="fm_split_lines_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="fm_split_lines_+3A_segm">segm</code></td>
<td>
<p>An <code><a href="#topic+fm_segm">fm_segm()</a></code> object with segments to be split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+fm_segm">fm_segm()</a></code> object with the same crs as the mesh,
with an added field <code>origin</code>, that for each new segment gives the
originator index into to original <code>segm</code> object for each new line segment.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mesh &lt;- fm_mesh_2d(
  boundary = fm_segm(
    rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1)),
    is.bnd = TRUE
  )
)
splitter &lt;- fm_segm(rbind(c(0.8, 0.2), c(0.2, 0.8)))
segm_split &lt;- fm_split_lines(mesh, splitter)

plot(mesh)
lines(splitter)
points(segm_split$loc)
</code></pre>

<hr>
<h2 id='fm_store_points'>Store points in different formats</h2><span id='topic+fm_store_points'></span>

<h3>Description</h3>

<p>Convert a matrix of points into different formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_store_points(loc, crs = NULL, info = NULL, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_store_points_+3A_loc">loc</code></td>
<td>
<p>a coordinate matrix</p>
</td></tr>
<tr><td><code id="fm_store_points_+3A_crs">crs</code></td>
<td>
<p>CRS information to associate with the coordinates</p>
</td></tr>
<tr><td><code id="fm_store_points_+3A_info">info</code></td>
<td>
<p>An optional data.frame of additional data</p>
</td></tr>
<tr><td><code id="fm_store_points_+3A_format">format</code></td>
<td>
<p>character; <code>"sf"</code>, <code>"df"</code>, <code>"sp"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code>, <code>data.frame</code>, or <code>SpatialPointsDataFrame</code> object, with
optional added information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_store_points(fmexample$loc, format = "sf")

</code></pre>

<hr>
<h2 id='fm_subdivide'>Split triangles of a mesh into subtriangles</h2><span id='topic+fm_subdivide'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Splits each mesh triangle into <code>(n + 1)^2</code> subtriangles.
The current version drops any edge constraint information from the mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_subdivide(mesh, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_subdivide_+3A_mesh">mesh</code></td>
<td>
<p>an <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> object</p>
</td></tr>
<tr><td><code id="fm_subdivide_+3A_n">n</code></td>
<td>
<p>number of added points along each edge. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A refined <a href="#topic+fm_mesh_2d">fm_mesh_2d</a> object
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mesh &lt;- fm_rcdt_2d_inla(
  loc = rbind(c(0, 0), c(1, 0), c(0, 1)),
  tv = rbind(c(1, 2, 3))
)
mesh_sub &lt;- fm_subdivide(mesh, 3)
mesh
mesh_sub

plot(mesh_sub, edge.color = 2)

plot(fm_subdivide(fmexample$mesh, 3), edge.color = 2)
plot(fmexample$mesh, add = TRUE, edge.color = 1)
</code></pre>

<hr>
<h2 id='fm_tensor'>Make a tensor product function space</h2><span id='topic+fm_tensor'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Tensor product function spaces. The interface and object storage model
is experimental and may change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_tensor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_tensor_+3A_x">x</code></td>
<td>
<p>list of function space objects, such as <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code>.</p>
</td></tr>
<tr><td><code id="fm_tensor_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fm_tensor</code> or <code>fm_tensor_list</code> object. Elements of <code>fm_tensor</code>:
</p>

<dl>
<dt>fun_spaces</dt><dd><p><code>fm_list</code> of function space objects</p>
</dd>
<dt>manifold</dt><dd><p>character; manifold type summary. Regular subset of Rd &quot;Rd&quot;,
if all function spaces have type &quot;R&quot;,
torus connected &quot;Td&quot; if all function spaces have type &quot;S&quot;, and otherwise &quot;Md&quot;
In all cases, <code>d</code> is the sum of the manifold dimensions of the function
spaces.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other object creation and conversion: 
<code><a href="#topic+fm_as_fm">fm_as_fm</a>()</code>,
<code><a href="#topic+fm_as_lattice_2d">fm_as_lattice_2d</a>()</code>,
<code><a href="#topic+fm_as_lattice_Nd">fm_as_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_as_mesh_1d">fm_as_mesh_1d</a>()</code>,
<code><a href="#topic+fm_as_mesh_2d">fm_as_mesh_2d</a>()</code>,
<code><a href="#topic+fm_as_mesh_3d">fm_as_mesh_3d</a>()</code>,
<code><a href="#topic+fm_as_segm">fm_as_segm</a>()</code>,
<code><a href="#topic+fm_as_sfc">fm_as_sfc</a>()</code>,
<code><a href="#topic+fm_as_tensor">fm_as_tensor</a>()</code>,
<code><a href="#topic+fm_lattice_2d">fm_lattice_2d</a>()</code>,
<code><a href="#topic+fm_lattice_Nd">fm_lattice_Nd</a>()</code>,
<code><a href="#topic+fm_mesh_1d">fm_mesh_1d</a>()</code>,
<code><a href="#topic+fm_mesh_2d">fm_mesh_2d</a>()</code>,
<code><a href="#topic+fm_segm">fm_segm</a>()</code>,
<code><a href="#topic+fm_simplify">fm_simplify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fm_tensor(list(
  space = fmexample$mesh,
  time = fm_mesh_1d(1:5)
))
m2 &lt;- fm_as_tensor(m)
m3 &lt;- fm_as_tensor_list(list(m, m))
c(fm_dof(m$fun_spaces$space) * fm_dof(m$fun_spaces$time), fm_dof(m))
str(fm_evaluator(m, loc = list(space = cbind(0, 0), time = 2.5)))
str(fm_basis(m, loc = list(space = cbind(0, 0), time = 2.5)))
str(fm_fem(m))
</code></pre>

<hr>
<h2 id='fm_transform'>Object coordinate transformation</h2><span id='topic+fm_transform'></span><span id='topic+fm_transform.default'></span><span id='topic+fm_transform.NULL'></span><span id='topic+fm_transform.matrix'></span><span id='topic+fm_transform.sf'></span><span id='topic+fm_transform.sfc'></span><span id='topic+fm_transform.sfg'></span><span id='topic+fm_transform.Spatial'></span><span id='topic+fm_transform.fm_mesh_2d'></span><span id='topic+fm_transform.fm_lattice_2d'></span><span id='topic+fm_transform.fm_segm'></span><span id='topic+fm_transform.fm_list'></span>

<h3>Description</h3>

<p>Handle transformation of various inla objects according to coordinate
reference systems of <code>crs</code> (from <code>sf::st_crs()</code>), <code>fm_crs</code>, <code>sp::CRS</code>,
<code>fm_CRS</code>, or <code>INLA::inla.CRS</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_transform(x, crs, ...)

## Default S3 method:
fm_transform(x, crs, ..., crs0 = NULL)

## S3 method for class 'NULL'
fm_transform(x, crs, ...)

## S3 method for class 'matrix'
fm_transform(x, crs, ..., passthrough = FALSE, crs0 = NULL)

## S3 method for class 'sf'
fm_transform(x, crs, ..., passthrough = FALSE)

## S3 method for class 'sfc'
fm_transform(x, crs, ..., passthrough = FALSE)

## S3 method for class 'sfg'
fm_transform(x, crs, ..., passthrough = FALSE)

## S3 method for class 'Spatial'
fm_transform(x, crs, ..., passthrough = FALSE)

## S3 method for class 'fm_mesh_2d'
fm_transform(x, crs = fm_crs(x), ..., passthrough = FALSE, crs0 = fm_crs(x))

## S3 method for class 'fm_lattice_2d'
fm_transform(x, crs = fm_crs(x), ..., passthrough = FALSE, crs0 = fm_crs(x))

## S3 method for class 'fm_segm'
fm_transform(x, crs = fm_crs(x), ..., passthrough = FALSE, crs0 = fm_crs(x))

## S3 method for class 'fm_list'
fm_transform(x, crs, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_transform_+3A_x">x</code></td>
<td>
<p>The object that should be transformed from it's current CRS to a new CRS</p>
</td></tr>
<tr><td><code id="fm_transform_+3A_crs">crs</code></td>
<td>
<p>The target crs object</p>
</td></tr>
<tr><td><code id="fm_transform_+3A_...">...</code></td>
<td>
<p>Potential additional arguments</p>
</td></tr>
<tr><td><code id="fm_transform_+3A_crs0">crs0</code></td>
<td>
<p>The source crs object for spatial classes without crs information</p>
</td></tr>
<tr><td><code id="fm_transform_+3A_passthrough">passthrough</code></td>
<td>
<p>Default is FALSE.
Setting to TRUE allows objects with no CRS information to be passed
through without transformation. Use with care!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transformed object, normally of the same class as
the input object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_CRS">fm_CRS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_transform(
  rbind(c(0, 0), c(0, 90), c(0, 91)),
  crs = fm_crs("sphere"),
  crs0 = fm_crs("longlat_norm")
)

</code></pre>

<hr>
<h2 id='fm_unify_coords'>Unify coordinates to 3-column matrix</h2><span id='topic+fm_unify_coords'></span><span id='topic+fm_unify_coords.NULL'></span><span id='topic+fm_unify_coords.default'></span><span id='topic+fm_unify_coords.Spatial'></span><span id='topic+fm_unify_coords.sf'></span><span id='topic+fm_unify_coords.sfc'></span>

<h3>Description</h3>

<p>Convert coordinate information to a 3-column matrix.
This is mainly an internal function, and the interface may change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_unify_coords(x, crs = NULL)

## S3 method for class 'NULL'
fm_unify_coords(x, crs = NULL)

## Default S3 method:
fm_unify_coords(x, crs = NULL)

## S3 method for class 'Spatial'
fm_unify_coords(x, crs = NULL)

## S3 method for class 'sf'
fm_unify_coords(x, crs = NULL)

## S3 method for class 'sfc'
fm_unify_coords(x, crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_unify_coords_+3A_x">x</code></td>
<td>
<p>A object with coordinate information</p>
</td></tr>
<tr><td><code id="fm_unify_coords_+3A_crs">crs</code></td>
<td>
<p>A optional crs object to convert the coordinates to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A coordinate matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_unify_coords(fmexample$loc_sf)

</code></pre>

<hr>
<h2 id='fm_vertex_projection'>Project integration points to mesh vertices</h2><span id='topic+fm_vertex_projection'></span>

<h3>Description</h3>

<p>Compute information for assigning points to the vertices of the covering
triangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_vertex_projection(points, mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_vertex_projection_+3A_points">points</code></td>
<td>
<p>A <code>SpatialPointsDataFrame</code>, <code>sf</code>, <code>tibble</code>, or <code>list</code> object</p>
</td></tr>
<tr><td><code id="fm_vertex_projection_+3A_mesh">mesh</code></td>
<td>
<p>An <code>fm_mesh_2d</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatialPointsDataFrame</code>, <code>sf</code>, <code>tibble</code>, or <code>list</code> of mesh
vertices with projected data attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(fm_vertex_projection(list(loc = fmexample$loc), fmexample$mesh))
head(fm_vertex_projection(fmexample$loc_sf, fmexample$mesh))

</code></pre>

<hr>
<h2 id='fm_vertices'>Extract vertex locations from an <code>fm_mesh_2d</code></h2><span id='topic+fm_vertices'></span>

<h3>Description</h3>

<p>Extracts the vertices of an <code>fm_mesh_2d</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_vertices(x, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_vertices_+3A_x">x</code></td>
<td>
<p>An <code>fm_mesh_2d</code> object.</p>
</td></tr>
<tr><td><code id="fm_vertices_+3A_format">format</code></td>
<td>
<p>character; <code>"sf"</code>, <code>"df"</code>, <code>"sp"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code>, <code>data.frame</code>, or <code>SpatialPointsDataFrame</code> object, with the vertex
coordinates, and a <code>.vertex</code> column with the vertex indices.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_centroids">fm_centroids()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE)) {
  vrt &lt;- fm_vertices(fmexample$mesh, format = "sf")
  ggplot() +
    geom_sf(data = fm_as_sfc(fmexample$mesh)) +
    geom_sf(data = vrt, color = "red")
}

</code></pre>

<hr>
<h2 id='fm_wkt_as_wkt_tree'>Internal WKT handling</h2><span id='topic+fm_wkt_as_wkt_tree'></span><span id='topic+fm_wkt_tree_as_wkt'></span><span id='topic+fm_wkt_tree_get_item'></span><span id='topic+fm_wkt_tree_set_item'></span>

<h3>Description</h3>

<p>Conversion between WKT and a tree representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_wkt_as_wkt_tree(x, ...)

fm_wkt_tree_as_wkt(x, pretty = FALSE, ...)

fm_wkt_tree_get_item(x, item, duplicate = 1)

fm_wkt_tree_set_item(x, item_tree, duplicate = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_x">x</code></td>
<td>
<p>A WKT2 string, or a <code>wkt_tree</code> list structure</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_pretty">pretty</code></td>
<td>
<p>logical; If TRUE, use pretty formatting. Default: FALSE</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_item">item</code></td>
<td>
<p>character vector with item labels identifying a parameter item
entry.</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_duplicate">duplicate</code></td>
<td>
<p>For items that have more than one match, <code>duplicate</code>
indicates the index number of the desired version. Default: 1</p>
</td></tr>
<tr><td><code id="fm_wkt_as_wkt_tree_+3A_item_tree">item_tree</code></td>
<td>
<p>An item tree identifying a parameter item entry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A hierarchical list, describing WKT information as a tree
</p>
<p><code>fm_wkt_tree_as_wkt</code> character; the WKT corresponding to the tree.
</p>
<p><code>fm_wkt_tree_get_item</code> returns the value of an item found in the
tree
</p>
<p><code>fm_wkt_tree_set_item</code> returns the modified tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fm_wkt_as_wkt_tree(fm_crs("longlat_norm")$wkt))

</code></pre>

<hr>
<h2 id='fmesher_bary'>Barycentric coordinate computation</h2><span id='topic+fmesher_bary'></span>

<h3>Description</h3>

<p>Locate points and compute triangular barycentric coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_bary(mesh_loc, mesh_tv, loc, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_bary_+3A_mesh_loc">mesh_loc</code></td>
<td>
<p>numeric matrix; mesh vertex coordinates</p>
</td></tr>
<tr><td><code id="fmesher_bary_+3A_mesh_tv">mesh_tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_bary_+3A_loc">loc</code></td>
<td>
<p>numeric matrix; coordinates of points to locate in the mesh</p>
</td></tr>
<tr><td><code id="fmesher_bary_+3A_options">options</code></td>
<td>
<p>list of triangulation options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with vector <code>index</code> (triangle index) and matrix <code>where</code>
(3-column barycentric matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fmesher_rcdt(list(cet_margin = 1), matrix(0, 1, 2))
b &lt;- fmesher_bary(m$s,
                  m$tv,
                  matrix(c(0.5, 0.5), 1, 2),
                  list())
</code></pre>

<hr>
<h2 id='fmesher_bary3d'>Barycentric coordinate computation</h2><span id='topic+fmesher_bary3d'></span>

<h3>Description</h3>

<p>Locate points and compute triangular barycentric coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_bary3d(mesh_loc, mesh_tv, loc, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_bary3d_+3A_mesh_loc">mesh_loc</code></td>
<td>
<p>numeric matrix; mesh vertex coordinates</p>
</td></tr>
<tr><td><code id="fmesher_bary3d_+3A_mesh_tv">mesh_tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_bary3d_+3A_loc">loc</code></td>
<td>
<p>numeric matrix; coordinates of points to locate in the mesh</p>
</td></tr>
<tr><td><code id="fmesher_bary3d_+3A_options">options</code></td>
<td>
<p>list of triangulation options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with vector <code>index</code> (tetra index) and matrix <code>where</code>
(4-column barycentric matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fmesher_mesh3d(list(cet_margin = 1),
                    matrix(rnorm(15), 5, 3),
                    matrix(c(0,1,2,3), 1, 4))
b &lt;- fmesher_bary3d(m$loc,
                    m$tv,
                    matrix(c(0.5, 0.5, 0.5), 1, 3),
                    list())
</code></pre>

<hr>
<h2 id='fmesher_fem'>Finite element matrix computation</h2><span id='topic+fmesher_fem'></span>

<h3>Description</h3>

<p>Construct finite element structure matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_fem(mesh_loc, mesh_tv, fem_order_max, aniso, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_fem_+3A_mesh_loc">mesh_loc</code></td>
<td>
<p>numeric matrix; mesh vertex coordinates</p>
</td></tr>
<tr><td><code id="fmesher_fem_+3A_mesh_tv">mesh_tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_fem_+3A_fem_order_max">fem_order_max</code></td>
<td>
<p>integer; the highest operator order to compute</p>
</td></tr>
<tr><td><code id="fmesher_fem_+3A_aniso">aniso</code></td>
<td>
<p>If non-NULL, a <code>list(gamma, v)</code>. Calculates anisotropic structure
matrices (in addition to the regular) for <code class="reqn">\gamma</code> and <code class="reqn">v</code> for
an anisotropic operator <code class="reqn">\nabla\cdot H \nabla</code>, where
<code class="reqn">H=\gamma I + v v^\top</code>.
Currently (2023-08-05) the fields need to be given per vertex.</p>
</td></tr>
<tr><td><code id="fmesher_fem_+3A_options">options</code></td>
<td>
<p>list of triangulation options (<code>sphere_tolerance</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fmesher_rcdt(list(cet_margin = 1), matrix(0, 1, 2))
b &lt;- fmesher_fem(m$s, m$tv, fem_order_max = 2, aniso = NULL, options = list())
</code></pre>

<hr>
<h2 id='fmesher_globe_points'>Globe points</h2><span id='topic+fmesher_globe_points'></span>

<h3>Description</h3>

<p>Create points on a globe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_globe_points(globe)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_globe_points_+3A_globe">globe</code></td>
<td>
<p>integer; the number of edge subdivision segments, 1 or higher.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of points on a unit radius globe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fmesher_globe_points(1)
</code></pre>

<hr>
<h2 id='fmesher_mesh3d'>3D tetrahedralisation storage</h2><span id='topic+fmesher_mesh3d'></span>

<h3>Description</h3>

<p>(...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_mesh3d(options, loc, tv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_mesh3d_+3A_options">options</code></td>
<td>
<p>list of triangulation options</p>
</td></tr>
<tr><td><code id="fmesher_mesh3d_+3A_loc">loc</code></td>
<td>
<p>numeric matrix; initial points to include</p>
</td></tr>
<tr><td><code id="fmesher_mesh3d_+3A_tv">tv</code></td>
<td>
<p>4-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of information objects for a generated tetrahedralisation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fmesher_mesh3d(list(),
                    matrix(c(1,0,0,0,1,0,0,0,1,0,0,0), 4, 3, byrow=TRUE),
                    matrix(c(0,1,2,3), 1, 4, byrow=TRUE))
</code></pre>

<hr>
<h2 id='fmesher_qinv'>Compute sparse matrix inverse</h2><span id='topic+fmesher_qinv'></span>

<h3>Description</h3>

<p>Requires RcppEigen which is not compiled in by default. Enable with
<code>PKG_CPPFLAGS=-DFMESHER_WITH_EIGEN</code> in <code>src/Makevars</code> and add <code>RcppEigen</code>
to the <code>DESCRIPTION</code> <code>LinkingTo</code> field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_qinv(AA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_qinv_+3A_aa">AA</code></td>
<td>
<p>A sparse matrix</p>
</td></tr>
</table>

<hr>
<h2 id='fmesher_rcdt'>Refined Constrained Delaunay Triangulation</h2><span id='topic+fmesher_rcdt'></span>

<h3>Description</h3>

<p>(...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_rcdt(
  options,
  loc,
  tv = NULL,
  boundary = NULL,
  interior = NULL,
  boundary_grp = NULL,
  interior_grp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_rcdt_+3A_options">options</code></td>
<td>
<p>list of triangulation options</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_loc">loc</code></td>
<td>
<p>numeric matrix; initial points to include</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_tv">tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_boundary">boundary</code></td>
<td>
<p>2-column integer matrix with 0-based vertex indices for each
boundary edge constraint</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_interior">interior</code></td>
<td>
<p>2-column integer matrix with 0-based vertex indices for each
interior edge constraint</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_boundary_grp">boundary_grp</code></td>
<td>
<p>integer vector with group labels</p>
</td></tr>
<tr><td><code id="fmesher_rcdt_+3A_interior_grp">interior_grp</code></td>
<td>
<p>integer vector with group labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of information objects for a generated triangulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fmesher_rcdt(list(cet_margin = 1), matrix(0, 1, 2))
</code></pre>

<hr>
<h2 id='fmesher_spherical_bsplines1'>Rotationally invariant spherical B-splines</h2><span id='topic+fmesher_spherical_bsplines1'></span><span id='topic+fmesher_spherical_bsplines'></span>

<h3>Description</h3>

<p>Compute rotationally invariant spherical B-splines on the unit sphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_spherical_bsplines1(loc, n, degree, uniform)

fmesher_spherical_bsplines(loc, n, degree, uniform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_spherical_bsplines1_+3A_loc">loc</code></td>
<td>
<p>numeric vector/matrix; coordinates of points to locate in the mesh,
only the z-coordinates are used (<code>sin(latitude)</code>)</p>
</td></tr>
<tr><td><code id="fmesher_spherical_bsplines1_+3A_n">n</code></td>
<td>
<p>The number of basis functions</p>
</td></tr>
<tr><td><code id="fmesher_spherical_bsplines1_+3A_degree">degree</code></td>
<td>
<p>The polynomial basis degree</p>
</td></tr>
<tr><td><code id="fmesher_spherical_bsplines1_+3A_uniform">uniform</code></td>
<td>
<p>logical; If <code>TRUE</code>, the knots are spaced uniformly by latitude,
if <code>FALSE</code>, the knots are spaced uniformly by <code>sin(latitude)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of evaluated b-spline basis functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- fm_rcdt_2d(globe = 1)
fmesher_spherical_bsplines(m$loc, n = 3, degree = 2, uniform = FALSE)
fmesher_spherical_bsplines1(m$loc[, 3], n = 3, degree = 2, uniform = FALSE)
</code></pre>

<hr>
<h2 id='fmesher_split_lines'>Split lines at triangle edges</h2><span id='topic+fmesher_split_lines'></span>

<h3>Description</h3>

<p>Split a sequence of line segments at triangle edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_split_lines(mesh_loc, mesh_tv, loc, idx, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_split_lines_+3A_mesh_loc">mesh_loc</code></td>
<td>
<p>numeric matrix; mesh vertex coordinates</p>
</td></tr>
<tr><td><code id="fmesher_split_lines_+3A_mesh_tv">mesh_tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_split_lines_+3A_loc">loc</code></td>
<td>
<p>numeric coordinate matrix</p>
</td></tr>
<tr><td><code id="fmesher_split_lines_+3A_idx">idx</code></td>
<td>
<p>2-column integer matrix</p>
</td></tr>
<tr><td><code id="fmesher_split_lines_+3A_options">options</code></td>
<td>
<p>list of triangulation options (<code>sphere_tolerance</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of line splitting information objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_split_lines">fm_split_lines()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mesh &lt;- fm_mesh_2d(
  boundary = fm_segm(rbind(c(0,0), c(1,0), c(1,1), c(0, 1)), is.bnd = TRUE)
)
splitter &lt;- fm_segm(rbind(c(0.8, 0.2), c(0.2, 0.8)))
segm_split &lt;- fm_split_lines(mesh, splitter)
</code></pre>

<hr>
<h2 id='fmesher_subdivide'>Subdivide triangles</h2><span id='topic+fmesher_subdivide'></span>

<h3>Description</h3>

<p>Subdivide a mesh with congruent and anti-congruent subtriangles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmesher_subdivide(
  mesh_loc,
  mesh_tv,
  mesh_boundary,
  mesh_interior,
  subdivisions,
  options
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher_subdivide_+3A_mesh_loc">mesh_loc</code></td>
<td>
<p>numeric matrix; mesh vertex coordinates</p>
</td></tr>
<tr><td><code id="fmesher_subdivide_+3A_mesh_tv">mesh_tv</code></td>
<td>
<p>3-column integer matrix with 0-based vertex indices for each triangle</p>
</td></tr>
<tr><td><code id="fmesher_subdivide_+3A_mesh_boundary">mesh_boundary</code></td>
<td>
<p>2-column integer matrix with 0-based vertex indices for
boundary constraints, currently ignored</p>
</td></tr>
<tr><td><code id="fmesher_subdivide_+3A_mesh_interior">mesh_interior</code></td>
<td>
<p>2-column integer matrix with 0-based vertex indices for
interior constraints, currently ignored</p>
</td></tr>
<tr><td><code id="fmesher_subdivide_+3A_subdivisions">subdivisions</code></td>
<td>
<p>integer; number of new points along each edge.</p>
</td></tr>
<tr><td><code id="fmesher_subdivide_+3A_options">options</code></td>
<td>
<p>list of triangulation options (<code>sphere_tolerance</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of new <code>loc</code> and <code>tv</code> information
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_subdivide">fm_subdivide()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mesh &lt;- fm_mesh_2d(
  boundary = fm_segm(rbind(c(0,0), c(1,0), c(1,1), c(0, 1)), is.bnd = TRUE)
)
new_mesh &lt;- fm_subdivide(mesh, n = 3)
plot(new_mesh, edge.color = 2)
plot(mesh, add = TRUE, edge.color = 1)
</code></pre>

<hr>
<h2 id='fmesher-deprecated'>Deprecated functions in fmesher</h2><span id='topic+fmesher-deprecated'></span><span id='topic+fm_spTransform'></span><span id='topic+fm_spTransform.default'></span><span id='topic+fm_spTransform.SpatialPoints'></span><span id='topic+fm_spTransform.SpatialPointsDataFrame'></span><span id='topic+fm_has_PROJ6'></span><span id='topic+fm_as_sp_crs'></span><span id='topic+fm_sp_get_crs'></span><span id='topic+fm_sp2segment'></span>

<h3>Description</h3>

<p>These functions still attempt to do their job, but will be removed in a
future version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm_spTransform(x, ...)

## Default S3 method:
fm_spTransform(x, crs0 = NULL, crs1 = NULL, passthrough = FALSE, ...)

## S3 method for class 'SpatialPoints'
fm_spTransform(x, CRSobj, passthrough = FALSE, ...)

## S3 method for class 'SpatialPointsDataFrame'
fm_spTransform(x, CRSobj, passthrough = FALSE, ...)

fm_has_PROJ6()

fm_as_sp_crs(x, ...)

fm_sp_get_crs(x)

fm_sp2segment(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher-deprecated_+3A_x">x</code></td>
<td>
<p>A <code>sp::Spatial</code> object</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_...">...</code></td>
<td>
<p>Potential additional arguments</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_crs0">crs0</code></td>
<td>
<p>The source sp::CRS or inla.CRS object</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_crs1">crs1</code></td>
<td>
<p>The target sp::CRS or inla.CRS object</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_passthrough">passthrough</code></td>
<td>
<p>Default is FALSE.
Setting to TRUE allows objects with no CRS information to be passed
through without transformation.</p>
</td></tr>
<tr><td><code id="fmesher-deprecated_+3A_crsobj">CRSobj</code></td>
<td>
<p>The target sp::CRS or inla.CRS object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience method to workaround PROJ4/PROJ6
differences, and the lack of a crs extraction method for Spatial objects.
For newer code, use <code><a href="#topic+fm_crs">fm_crs()</a></code> instead, that returns <code>crs</code> objects, and use
<a href="#topic+fm_crs">fm_CRS()</a> to extract/construct/convert to old style <code>sp::CRS</code> objects.
</p>


<h3>Value</h3>

<p>A <code>CRS</code> object, or NULL if no valid CRS identified
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_spTransform()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> (See <code><a href="#topic+fm_transform">fm_transform()</a></code> instead)
Handle transformation of various inla objects according to coordinate
reference systems of <code>sp::CRS</code> or <code>INLA::inla.CRS</code> class.
</p>
</li>
<li> <p><code>fm_spTransform(default)</code>: The default method handles low level
transformation of raw coordinates.
</p>
</li>
<li> <p><code>fm_has_PROJ6()</code>: Old checker for PROJ6.
</p>
</li>
<li> <p><code>fm_as_sp_crs()</code>: Wrapper for <code><a href="#topic+fm_CRS">fm_CRS()</a></code>
<code>sp::Spatial</code> and <code>sp::CRS</code> objects.
</p>
</li>
<li> <p><code>fm_sp_get_crs()</code>: Wrapper for <code>CRS(projargs)</code> (PROJ4) and
<code>CRS(wkt)</code> for <code>sp::Spatial</code> objects.
</p>
</li>
<li> <p><code>fm_sp2segment()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour
of <code><a href="#topic+fm_as_segm">fm_as_segm()</a></code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_transform">fm_transform()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (fm_safe_sp()) {
  s &lt;- sp::SpatialPoints(matrix(1:6, 3, 2), proj4string = fm_CRS("sphere"))
  fm_CRS(s)
}
</code></pre>

<hr>
<h2 id='fmesher-print'>Print objects</h2><span id='topic+fmesher-print'></span><span id='topic+print.fm_segm'></span><span id='topic+print.fm_segm_list'></span><span id='topic+print.fm_list'></span><span id='topic+print.fm_mesh_2d'></span><span id='topic+print.fm_mesh_3d'></span><span id='topic+print.fm_mesh_1d'></span><span id='topic+print.fm_bbox'></span><span id='topic+print.fm_tensor'></span><span id='topic+print.fm_lattice_2d'></span><span id='topic+print.fm_lattice_Nd'></span><span id='topic+print.fm_crs'></span><span id='topic+print.fm_CRS'></span>

<h3>Description</h3>

<p>Print objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_segm'
print(x, ..., digits = NULL, verbose = TRUE, newline = TRUE)

## S3 method for class 'fm_segm_list'
print(x, ..., digits = NULL, verbose = FALSE, newline = TRUE)

## S3 method for class 'fm_list'
print(x, ..., digits = NULL, verbose = FALSE, newline = TRUE)

## S3 method for class 'fm_mesh_2d'
print(x, ..., digits = NULL, verbose = FALSE)

## S3 method for class 'fm_mesh_3d'
print(x, ..., digits = NULL, verbose = FALSE)

## S3 method for class 'fm_mesh_1d'
print(x, ..., digits = NULL, verbose = FALSE)

## S3 method for class 'fm_bbox'
print(x, ..., digits = NULL, verbose = TRUE, newline = TRUE)

## S3 method for class 'fm_tensor'
print(x, ..., digits = NULL, verbose = FALSE)

## S3 method for class 'fm_lattice_2d'
print(x, ..., digits = NULL, verbose = FALSE)

## S3 method for class 'fm_lattice_Nd'
print(x, ..., digits = NULL, verbose = FALSE)

## S3 method for class 'fm_crs'
print(x, ...)

## S3 method for class 'fm_CRS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmesher-print_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="fmesher-print_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="fmesher-print_+3A_digits">digits</code></td>
<td>
<p>a positive integer indicating how many significant digits are
to be used for numeric and complex x. The default, NULL, uses
<code>getOption("digits")</code>.</p>
</td></tr>
<tr><td><code id="fmesher-print_+3A_verbose">verbose</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="fmesher-print_+3A_newline">newline</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), end the printing with <code style="white-space: pre;">&#8288;\n&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm_bbox(matrix(1:6, 3, 2))
print(fm_bbox(matrix(1:6, 3, 2)), verbose = FALSE)

print(fmexample$mesh)
print(fmexample$boundary_fm)

print(fm_mesh_1d(c(1, 2, 3, 5, 7), degree = 2))
</code></pre>

<hr>
<h2 id='fmexample'>Example mesh data</h2><span id='topic+fmexample'></span>

<h3>Description</h3>

<p>This is an example data set used for <code>fmesher</code> package examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmexample
</code></pre>


<h3>Format</h3>

<p>The data is a list containing these elements:
</p>

<dl>
<dt><code>loc</code>:</dt><dd><p> A <code>matrix</code> of points.</p>
</dd>
<dt><code>loc_sf</code>:</dt><dd><p> An <code>sfc</code> version of <code>loc</code>.</p>
</dd>
<dt><code>boundary_fm</code>:</dt><dd><p> A <code>fm_segm_list</code> of two <code>fm_segm</code> objects used in
the mesh construction.</p>
</dd>
<dt><code>boundary_sf</code>:</dt><dd><p> An <code>sfc</code> list version of <code>boundary</code>.</p>
</dd>
<dt><code>mesh</code>:</dt><dd><p> An <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Generated by <code>data-raw/fmexample.R</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmexample_sp">fmexample_sp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(ggplot2, quietly = TRUE)) {
  ggplot() +
    geom_sf(data = fm_as_sfc(fmexample$mesh)) +
    geom_sf(data = fmexample$boundary_sf[[1]], fill = "red", alpha = 0.5)
}
</code></pre>

<hr>
<h2 id='fmexample_sp'>Add sp data to fmexample</h2><span id='topic+fmexample_sp'></span>

<h3>Description</h3>

<p>Adds <code>loc_sp</code> and <code>boundary_sp</code> to <a href="#topic+fmexample">fmexample</a> for use
in <code>sp</code> related code examples and tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmexample_sp()
</code></pre>


<h3>Value</h3>

<p>Returns a copy of <a href="#topic+fmexample">fmexample</a> with <code>loc_sp</code> (<code>SpatialPoints</code>) and
<code>boundary_sp</code> (<code>SpatialPolygons</code>) added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (fm_safe_sp()) {
  fmexample_sp()
}
</code></pre>

<hr>
<h2 id='geom_fm'>ggplot2 geomes for fmesher related objects</h2><span id='topic+geom_fm'></span><span id='topic+geom_fm.fm_mesh_2d'></span><span id='topic+geom_fm.fm_segm'></span><span id='topic+geom_fm.fm_mesh_1d'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>geom_fm</code> is a generic function for generating geomes from various kinds of
<code>fmesher</code> objects, e.g. <code>fm_segm</code> and <code>fm_mesh_2d</code>.
The function invokes particular methods which depend
on the <a href="base.html#topic+class">class</a> of the <code>data</code> argument.
Requires the <code>ggplot2</code> package.
</p>
<p>Note: <code>geom_fm</code> is not yet a &quot;proper&quot; <code>ggplot2</code> geom method; the interface
may therefore change in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_fm(mapping = NULL, data = NULL, ...)

## S3 method for class 'fm_mesh_2d'
geom_fm(
  mapping = NULL,
  data = NULL,
  ...,
  mappings = NULL,
  defs = NULL,
  crs = NULL,
  mapping_int = deprecated(),
  mapping_bnd = deprecated(),
  defs_int = deprecated(),
  defs_bnd = deprecated()
)

## S3 method for class 'fm_segm'
geom_fm(mapping = NULL, data = NULL, ..., crs = NULL)

## S3 method for class 'fm_mesh_1d'
geom_fm(
  mapping = NULL,
  data = NULL,
  ...,
  mappings = NULL,
  defs = NULL,
  xlim = NULL,
  basis = TRUE,
  knots = TRUE,
  derivatives = FALSE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_fm_+3A_mapping">mapping</code></td>
<td>
<p>an object for which to generate a geom.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_data">data</code></td>
<td>
<p>an object for which to generate a geom.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the geom method.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_mappings">mappings</code>, <code id="geom_fm_+3A_defs">defs</code></td>
<td>
<p>optional lists of <code>aes</code> mappings and non-<code>aes</code> settings.
For <code>fm_mesh_2d</code>, the non-triangle parts of
the mesh, named &quot;int&quot; for interior constraint edges, &quot;bnd&quot; for boundary
edges, and &quot;loc&quot; for the vertices. For <code>fm_mesh_1d</code>, the elements are
&quot;knots&quot; and &quot;fun&quot;.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_crs">crs</code></td>
<td>
<p>Optional crs to transform the object to before plotting.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_mapping_int">mapping_int</code>, <code id="geom_fm_+3A_mapping_bnd">mapping_bnd</code>, <code id="geom_fm_+3A_defs_int">defs_int</code>, <code id="geom_fm_+3A_defs_bnd">defs_bnd</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> arguments; see <code>mappings</code> and <code>defs</code>.</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_xlim">xlim</code></td>
<td>
<p>numeric 2-vector; specifies the interval for which to compute
functions. Default is <code>data$interval</code></p>
</td></tr>
<tr><td><code id="geom_fm_+3A_basis">basis</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), show the spline basis functions</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_knots">knots</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), show the spline knot locations</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_derivatives">derivatives</code></td>
<td>
<p>logical; if <code>TRUE</code> (not default), draw first order
derivatives instead of function values</p>
</td></tr>
<tr><td><code id="geom_fm_+3A_weights">weights</code></td>
<td>
<p>numeric vector; if provided, draw weighted basis functions and
the resulting weighted sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combination of <code>ggplot2</code> geoms.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>geom_fm(fm_mesh_2d)</code>: Converts an <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object to <code>sf</code> with <code><a href="#topic+fm_as_sfc">fm_as_sfc()</a></code> and uses
<code>geom_sf</code> to visualize the triangles and edges.
</p>
<p>The mesh vertices are only plotted if <code>mappings$loc</code> or <code>defs$loc</code>
is non-<code>NULL</code>, e.g. <code>defs = list(loc = list())</code>. Default argument settings:
</p>
<div class="sourceCode"><pre>... = linewidth = 0.25, color = "grey" # default for triangle mapping
defs = list(
  int = list(linewidth = 0.5, color = "blue"),
  bnd = list(linewidth = 1, color = "black"),
  loc = list(size = 1, color = "red")
)
</pre></div>
</li>
<li> <p><code>geom_fm(fm_segm)</code>: Converts an <code><a href="#topic+fm_segm">fm_segm()</a></code> object to <code>sf</code> with <code><a href="#topic+fm_as_sfc">fm_as_sfc()</a></code> and uses
<code>geom_sf</code> to visualize it.
</p>
</li>
<li> <p><code>geom_fm(fm_mesh_1d)</code>: Evaluates and plots the basis functions defined by an <code><a href="#topic+fm_mesh_1d">fm_mesh_1d()</a></code> object.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
ggplot() +
  geom_fm(data = fmexample$mesh)


m &lt;- fm_mesh_2d(
  cbind(10, 20),
  boundary = fm_extensions(cbind(10, 20), c(25, 65)),
  max.edge = c(4, 10),
  crs = fm_crs("+proj=longlat")
)
ggplot() +
  geom_fm(data = m)
ggplot() +
  geom_fm(data = m, defs = list(loc = list()))
ggplot() +
  geom_fm(data = m, crs = fm_crs("epsg:27700"))

# Compute a mesh vertex based function on a different grid
px &lt;- fm_pixels(fm_transform(m, fm_crs("mollweide_globe")))
px$fun &lt;- fm_evaluate(m,
  loc = px,
  field = sin(m$loc[, 1] / 5) * sin(m$loc[, 2] / 5)
)
ggplot() +
  geom_tile(aes(geometry = geometry, fill = fun),
    data = px,
    stat = "sf_coordinates"
  ) +
  geom_fm(
    data = m, alpha = 0.2, linewidth = 0.05,
    crs = fm_crs("mollweide_globe")
  )



m &lt;- fm_mesh_1d(c(1, 2, 4, 6, 10), boundary = c("n", "d"), degree = 2)
ggplot() +
  geom_fm(data = m, weights = c(4, 2, 4, -1))


m &lt;- fm_mesh_1d(
  c(1, 2, 3, 5, 7),
  boundary = c("dirichlet", "neumann"),
  degree = 2
)
ggplot() +
  geom_fm(data = m)

</code></pre>

<hr>
<h2 id='local_testthat'>Unit test helpers</h2><span id='topic+local_testthat'></span><span id='topic+local_fm_testthat_assign'></span><span id='topic+local_fm_testthat_tolerances'></span><span id='topic+local_fm_testthat_setup'></span>

<h3>Description</h3>

<p>Local helper functions for package unit tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_fm_testthat_assign(x, values, envir = parent.frame())

local_fm_testthat_tolerances(
  tolerances = c(1e-04, 0.01, 0.1),
  envir = parent.frame()
)

local_fm_testthat_setup(envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_testthat_+3A_x">x</code></td>
<td>
<p>character; Name of variable to assign to</p>
</td></tr>
<tr><td><code id="local_testthat_+3A_values">values</code></td>
<td>
<p>the object to assign to <code>x</code></p>
</td></tr>
<tr><td><code id="local_testthat_+3A_envir">envir</code></td>
<td>
<p>environment for exit handlers</p>
</td></tr>
<tr><td><code id="local_testthat_+3A_tolerances">tolerances</code></td>
<td>
<p>numeric vector of length 3; <code style="white-space: pre;">&#8288;[lowtol, midtol, hitol]&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>local_fm_testthat_assign()</code>: Assign local variable. Useful for easy cleanup
of global workspace with <code>withr::deferred_run()</code> when running tests
interactively.
</p>
</li>
<li> <p><code>local_fm_testthat_tolerances()</code>: Assign test tolerances
Assign local tolerance variables. Useful for easy cleanup
of global workspace with <code>withr::deferred_run()</code> when running tests
interactively.
</p>
</li>
<li> <p><code>local_fm_testthat_setup()</code>: Initialise environment for tests.
To be called either at the top of a testfile, or inside tests.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>outer_fun &lt;- function() {
  fun &lt;- function(envir = parent.frame()) {
    local_fm_testthat_assign("local_var_name", 1:4, envir = envir)
  }
  fun()
  local_var_name
}
exists("local_var_name")
outer_fun()
exists("local_var_name")

</code></pre>

<hr>
<h2 id='plot_rgl'>Low level triangulation mesh plotting</h2><span id='topic+plot_rgl'></span><span id='topic+lines_rgl'></span><span id='topic+lines_rgl.fm_segm'></span><span id='topic+plot_rgl.fm_mesh_2d'></span><span id='topic+plot_rgl.fm_segm'></span><span id='topic+plot_rgl.fm_segm_list'></span><span id='topic+lines_rgl.fm_segm_list'></span>

<h3>Description</h3>

<p>Plots a triangulation mesh using <code>rgl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rgl(x, ...)

lines_rgl(x, ..., add = TRUE)

## S3 method for class 'fm_segm'
lines_rgl(
  x,
  loc = NULL,
  col = NULL,
  colors = c("black", "blue", "red", "green"),
  ...,
  add = TRUE
)

## S3 method for class 'fm_mesh_2d'
plot_rgl(
  x,
  col = "white",
  color.axis = NULL,
  color.n = 512,
  color.palette = cm.colors,
  color.truncate = FALSE,
  alpha = NULL,
  lwd = 1,
  specular = "black",
  draw.vertices = TRUE,
  draw.edges = TRUE,
  draw.faces = TRUE,
  draw.segments = draw.edges,
  size = 2,
  edge.color = rgb(0.3, 0.3, 0.3),
  t.sub = seq_len(nrow(x$graph$tv)),
  visibility = "",
  S = deprecated(),
  add = FALSE,
  ...
)

## S3 method for class 'fm_segm'
plot_rgl(x, ..., add = FALSE)

## S3 method for class 'fm_segm_list'
plot_rgl(x, ...)

## S3 method for class 'fm_segm_list'
lines_rgl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_rgl_+3A_x">x</code></td>
<td>
<p>A <code>fm_mesh_2d()</code> object</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to and from other methods.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, adds to the current plot instead of starting a
new one.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_loc">loc</code></td>
<td>
<p>Point locations to be used if <code>x$loc</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_col">col</code></td>
<td>
<p>Segment color specification.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_colors">colors</code></td>
<td>
<p>Colors to cycle through if <code>col</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_color.axis">color.axis</code></td>
<td>
<p>The min/max limit values for the color mapping.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_color.n">color.n</code></td>
<td>
<p>The number of colors to use in the color palette.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_color.palette">color.palette</code></td>
<td>
<p>A color palette function.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_color.truncate">color.truncate</code></td>
<td>
<p>If <code>TRUE</code>, truncate the colors at the color axis
limits.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_alpha">alpha</code></td>
<td>
<p>Transparency/opaqueness values. See <code>rgl.material</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_lwd">lwd</code></td>
<td>
<p>Line width for edges. See <code>rgl.material</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_specular">specular</code></td>
<td>
<p>Specular color. See <code>rgl.material</code>.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_draw.vertices">draw.vertices</code></td>
<td>
<p>If <code>TRUE</code>, draw triangle vertices.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_draw.edges">draw.edges</code></td>
<td>
<p>If <code>TRUE</code>, draw triangle edges.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_draw.faces">draw.faces</code></td>
<td>
<p>If <code>TRUE</code>, draw triangles.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_draw.segments">draw.segments</code></td>
<td>
<p>If <code>TRUE</code>, draw boundary and interior constraint
edges more prominently.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_size">size</code></td>
<td>
<p>Size for vertex points.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_edge.color">edge.color</code></td>
<td>
<p>Edge color specification.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_t.sub">t.sub</code></td>
<td>
<p>Optional triangle index subset to be drawn.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_visibility">visibility</code></td>
<td>
<p>If &quot;front&quot; only display mesh faces with normal pointing
towards the camera.</p>
</td></tr>
<tr><td><code id="plot_rgl_+3A_s">S</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rgl device identifier, invisibly.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fm_mesh_2d">plot.fm_mesh_2d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive() &amp;&amp; require("rgl")) {
  mesh &lt;- fm_rcdt_2d(globe = 10)
  plot_rgl(mesh, col = mesh$loc[, 1])
}

</code></pre>

<hr>
<h2 id='plot.fm_mesh_2d'>Draw a triangulation mesh object</h2><span id='topic+plot.fm_mesh_2d'></span><span id='topic+lines.fm_mesh_2d'></span>

<h3>Description</h3>

<p>Plots an <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object using standard graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_mesh_2d'
lines(x, ..., add = TRUE)

## S3 method for class 'fm_mesh_2d'
plot(
  x,
  col = "white",
  t.sub = seq_len(nrow(x$graph$tv)),
  add = FALSE,
  lwd = 1,
  xlim = range(x$loc[, 1]),
  ylim = range(x$loc[, 2]),
  main = NULL,
  size = 1,
  draw.vertices = FALSE,
  vertex.color = "black",
  draw.edges = TRUE,
  edge.color = rgb(0.3, 0.3, 0.3),
  draw.segments = draw.edges,
  rgl = deprecated(),
  visibility = "front",
  asp = 1,
  axes = FALSE,
  xlab = "",
  ylab = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fm_mesh_2d_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+fm_mesh_2d">fm_mesh_2d()</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_...">...</code></td>
<td>
<p>Further graphics parameters, interpreted by the respective
plotting systems.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, adds to the current plot instead of starting a
new one.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_col">col</code></td>
<td>
<p>Color specification.  A single named color, a vector of scalar
values, or a matrix of RGB values.  Requires <code>rgl=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_t.sub">t.sub</code></td>
<td>
<p>Optional triangle index subset to be drawn.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_lwd">lwd</code></td>
<td>
<p>Line width for triangle edges.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_xlim">xlim</code></td>
<td>
<p>X-axis limits.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_main">main</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_size">size</code></td>
<td>
<p>argument <code>cex</code> for vertex points.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_draw.vertices">draw.vertices</code></td>
<td>
<p>If <code>TRUE</code>, draw triangle vertices.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Color specification for all vertices.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_draw.edges">draw.edges</code></td>
<td>
<p>If <code>TRUE</code>, draw triangle edges.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_edge.color">edge.color</code></td>
<td>
<p>Color specification for all edges.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_draw.segments">draw.segments</code></td>
<td>
<p>If <code>TRUE</code>, draw boundary and interior constraint
edges more prominently.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_rgl">rgl</code></td>
<td>
<p>Deprecated</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_visibility">visibility</code></td>
<td>
<p>If &quot;front&quot; only display mesh faces with normal pointing
towards the camera.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio for new plots. Default 1.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_axes">axes</code></td>
<td>
<p>logical; whether axes should be drawn on the plot.
Default FALSE.</p>
</td></tr>
<tr><td><code id="plot.fm_mesh_2d_+3A_xlab">xlab</code>, <code id="plot.fm_mesh_2d_+3A_ylab">ylab</code></td>
<td>
<p>character; labels for the axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fm_segm">plot.fm_segm()</a></code>, <code><a href="#topic+plot_rgl.fm_mesh_2d">plot_rgl.fm_mesh_2d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mesh &lt;- fm_rcdt_2d(globe = 10)
plot(mesh)

mesh &lt;- fm_mesh_2d(cbind(0, 1), offset = c(1, 1.5), max.edge = 0.5)
plot(mesh)
</code></pre>

<hr>
<h2 id='plot.fm_segm'>Draw <code>fm_segm</code> objects.</h2><span id='topic+plot.fm_segm'></span><span id='topic+lines.fm_segm'></span><span id='topic+plot.fm_segm_list'></span><span id='topic+lines.fm_segm_list'></span>

<h3>Description</h3>

<p>Draws a <code><a href="#topic+fm_segm">fm_segm()</a></code> object with generic or <code>rgl</code>
graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_segm'
plot(x, ..., add = FALSE)

## S3 method for class 'fm_segm'
lines(
  x,
  loc = NULL,
  col = NULL,
  colors = c("black", "blue", "red", "green"),
  add = TRUE,
  xlim = NULL,
  ylim = NULL,
  rgl = FALSE,
  asp = 1,
  axes = FALSE,
  xlab = "",
  ylab = "",
  visibility = "front",
  ...
)

## S3 method for class 'fm_segm_list'
plot(x, ...)

## S3 method for class 'fm_segm_list'
lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fm_segm_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+fm_segm">fm_segm()</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_...">...</code></td>
<td>
<p>Additional parameters, passed on to graphics methods.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, add to the current plot, otherwise start a new
plot.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_loc">loc</code></td>
<td>
<p>Point locations to be used if <code>x$loc</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_col">col</code></td>
<td>
<p>Segment color specification.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_colors">colors</code></td>
<td>
<p>Colors to cycle through if <code>col</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_xlim">xlim</code>, <code id="plot.fm_segm_+3A_ylim">ylim</code></td>
<td>
<p>X and Y axis limits for a new plot.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_rgl">rgl</code></td>
<td>
<p>If <code>TRUE</code>, use <code>rgl</code> for plotting.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio for new plots. Default 1.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_axes">axes</code></td>
<td>
<p>logical; whether axes should be drawn on the plot.
Default FALSE.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_xlab">xlab</code>, <code id="plot.fm_segm_+3A_ylab">ylab</code></td>
<td>
<p>character; labels for the axes.</p>
</td></tr>
<tr><td><code id="plot.fm_segm_+3A_visibility">visibility</code></td>
<td>
<p>If &quot;front&quot; only display mesh faces with normal pointing
towards the camera.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_segm">fm_segm()</a></code>, <a href="#topic+plot.fm_mesh_2d">plot.fm_mesh_2d</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(fm_segm(fmexample$mesh, boundary = TRUE))
lines(fm_segm(fmexample$mesh, boundary = FALSE), col = 2)

</code></pre>

<hr>
<h2 id='print.fm_basis'>Print method for <code>fm_basis</code></h2><span id='topic+print.fm_basis'></span>

<h3>Description</h3>

<p>Prints information for an <a href="#topic+fm_basis">fm_basis</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_basis'
print(x, ..., prefix = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fm_basis_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+fm_basis">fm_basis()</a></code> object</p>
</td></tr>
<tr><td><code id="print.fm_basis_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="print.fm_basis_+3A_prefix">prefix</code></td>
<td>
<p>a prefix to be used for each line. Default is an empty string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_basis">fm_basis()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(fm_basis(fmexample$mesh, fmexample$loc, full = TRUE))
</code></pre>

<hr>
<h2 id='print.fm_evaluator'>Print method for <code>fm_evaluator()</code></h2><span id='topic+print.fm_evaluator'></span>

<h3>Description</h3>

<p>Prints information for an <a href="#topic+fm_evaluator">fm_evaluator</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_evaluator'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fm_evaluator_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+fm_evaluator">fm_evaluator()</a></code> object</p>
</td></tr>
<tr><td><code id="print.fm_evaluator_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_evaluator">fm_evaluator()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(fm_evaluator(fmexample$mesh, fmexample$loc))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
