<!DOCTYPE html><html lang="en-US"><head><title>Help for package segclust2d</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {segclust2d}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#segclust2d'><p>segclust2d: tools for segmentation of animal GPS movement data</p></a></li>
<li><a href='#add_covariates'><p>Covariate Calculations</p></a></li>
<li><a href='#angular_speed'><p>Calculate angular speed along a path</p></a></li>
<li><a href='#apply_rowSums'><p>apply_rowSums</p></a></li>
<li><a href='#apply_subsampling'><p>Internal function for subsampling</p></a></li>
<li><a href='#argcheck_diag.var'><p>Check for argument 'diag.var'</p></a></li>
<li><a href='#argcheck_Kmax'><p>Check for argument 'Kmax'</p></a></li>
<li><a href='#argcheck_lmin'><p>Check for argument 'lmin'</p></a></li>
<li><a href='#argcheck_ncluster'><p>Check for argument 'ncluster'</p></a></li>
<li><a href='#argcheck_order.var'><p>Check for argument 'order.var'</p></a></li>
<li><a href='#argcheck_ordering'><p>Check for argument 'order'</p></a></li>
<li><a href='#argcheck_scale.variable'><p>Check for argument 'scale.variable'</p></a></li>
<li><a href='#argcheck_seg.var'><p>Check for argument 'seg.var'</p></a></li>
<li><a href='#argcheck_segclust'><p>Check for argument 'ncluster' and 'nseg'</p></a></li>
<li><a href='#argcheck_segmentation'><p>Check for argument 'nseg'</p></a></li>
<li><a href='#argcheck_type_coord'><p>Check for deprecated 'type' and 'coord.names' argument</p></a></li>
<li><a href='#arma_repmat'><p>arma_repmat</p></a></li>
<li><a href='#augment'><p>Generic function for augment</p></a></li>
<li><a href='#bisig_plot'><p>bisig_plot draws the plots of the bivariate signal on the same plot (scale</p>
free)</a></li>
<li><a href='#calc_BIC'><p>Calculate BIC</p></a></li>
<li><a href='#calc_dist'><p>Calculate distance between locations</p></a></li>
<li><a href='#calc_speed'><p>Calculate speed along a path</p></a></li>
<li><a href='#calc_stat_states'><p>Calculate state statistics</p></a></li>
<li><a href='#check_repetition'><p>Check for repetition in the series</p></a></li>
<li><a href='#choose_kmax'><p>Finding best segmentation with a different threshold S</p></a></li>
<li><a href='#chooseseg_lavielle'><p>Internal Function for choosing optimal number of segment</p></a></li>
<li><a href='#colsums_sapply'><p>colsums_sapply</p></a></li>
<li><a href='#cumsum_cpp'><p>cumsum_cpp</p></a></li>
<li><a href='#DynProg'><p>DynProg computes the change points given a cost matrix matD</p>
and a maximum number of segments Kmax</a></li>
<li><a href='#DynProg_algo_cpp'><p>DynProg_algo_cpp</p></a></li>
<li><a href='#EM.algo_simultanee'><p>EM.algo_simultanee calculates the MLE of phi for given change-point instants</p></a></li>
<li><a href='#EM.algo_simultanee_Cpp'><p>EM.algo_simultanee calculates the MLE of phi for given change-point instants</p>
and for a fixed number of clusters</a></li>
<li><a href='#EM.init_simultanee'><p>EM.init_simultanee proposes an initial value for the EM algorithm  based on a</p>
hierarchical clustering  algorithm (ascending)</a></li>
<li><a href='#Estep_simultanee'><p>Estep_simultanee computes posterior probabilities and incomplete-data</p>
log-likelihood for mixture models</a></li>
<li><a href='#find_mu_sd'><p>Find mean and standard deviation of segments</p></a></li>
<li><a href='#Gmean_simultanee'><p>Gmean_simultanee  calculates the cost matrix for a segmentation model with</p>
changes in the mean and variance for all signals</a></li>
<li><a href='#Gmixt_algo_cpp'><p>Gmixt_algo_cpp</p></a></li>
<li><a href='#Gmixt_simultanee'><p>Gmixt_simultanee calculates the cost matrix</p>
for a segmentation/clustering model</a></li>
<li><a href='#Gmixt_simultanee_fullcpp'><p>Gmixt_simultanee_fullcpp</p></a></li>
<li><a href='#hybrid_simultanee'><p><code>hybrid_simultanee</code> performs a simultaneous seg - clustering for</p>
bivariate signals.</a></li>
<li><a href='#initialisePhi'><p>initialisePhi is the constructor for a set of parameters for a segclust model</p></a></li>
<li><a href='#likelihood'><p>Generic function for likelihood</p></a></li>
<li><a href='#logdens_simultanee_cpp'><p>logdens_simultanee_cpp</p></a></li>
<li><a href='#map_segm'><p><code>plot_segm</code> plot segmented movement data on a map.</p></a></li>
<li><a href='#matrixRupt'><p>matrixRupt transforms a vector of change point into a data.frame with start</p>
and end of every segment</a></li>
<li><a href='#Mstep_simultanee'><p>Mstep_simultanee computes the MLE within the EM framework</p></a></li>
<li><a href='#Mstep_simultanee_cpp'><p>Mstep_simultanee computes the MLE within the EM framework</p></a></li>
<li><a href='#neighborsbis'><p>neighbors tests whether neighbors of point k,P can  be used to re-initialize</p>
the EM algorithm and to improve the log-likelihood.</a></li>
<li><a href='#plot_segm'><p>Plot segmentation on time-serie</p></a></li>
<li><a href='#plot_states'><p>Plot states statistics</p></a></li>
<li><a href='#prep_segm'><p>Find segment and states for a Picard model</p></a></li>
<li><a href='#prep_segm_HMM'><p>Internal function for HMM</p></a></li>
<li><a href='#prep_segm_shiftfit'><p>Internal function for HMM</p></a></li>
<li><a href='#prepare_HMM'><p>Prepare HMM output for proper comparison plots</p></a></li>
<li><a href='#prepare_shiftfit'><p>Prepare shiftfit output for proper comparison plots</p></a></li>
<li><a href='#relabel_states'><p>Relabel states of a segmentation/clustering output</p></a></li>
<li><a href='#repmat'><p>repmat repeats a matrix</p></a></li>
<li><a href='#ruptAsMat'><p>ruptAsMat is an internal function to transform a vector giving the change</p>
point to matrix 2 columns matrix in which each line gives the beginning and
the end of a segment</a></li>
<li><a href='#segclust'><p>Segmentation/Clustering of movement data - Generic function</p></a></li>
<li><a href='#segclust_internal'><p>Internal segmentation/clustering function</p></a></li>
<li><a href='#segmap_list'><p><code>segmap_list</code> create maps with a list of object of <code>segmentation</code></p>
class</a></li>
<li><a href='#segmentation'><p>Segmentation of movement data - Generic function</p></a></li>
<li><a href='#segmentation-class'><p>segmentation class description</p></a></li>
<li><a href='#simulmode'><p>Simulations of behavioural mode</p></a></li>
<li><a href='#simulshift'><p>Simulations of home-range shift</p></a></li>
<li><a href='#spatial_angle'><p>Calculate spatial angle along a path</p></a></li>
<li><a href='#stat_segm'><p>Calculate statistics on a given segmentation</p></a></li>
<li><a href='#stat_segm_HMM'><p>Get segment statistic for HMM model</p></a></li>
<li><a href='#stat_segm_shiftfit'><p>Get segment statistic for shiftfit model</p></a></li>
<li><a href='#subsample_rename'><p>Internal function for subsampling</p></a></li>
<li><a href='#test_data'><p>Test function generating fake data</p></a></li>
<li><a href='#wrap_dynprog_cpp'><p>DynProg Rcpp</p>
DynProg computes the change points given a cost matrix matD
and a maximum number of segments Kmax</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bivariate Segmentation/Clustering Methods and Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rpatin/segclust2d">https://github.com/rpatin/segclust2d</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rpatin/segclust2d/issues">https://github.com/rpatin/segclust2d/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides two methods for segmentation and joint segmentation/clustering of
    bivariate time-series. Originally intended for ecological segmentation
    (home-range and behavioural modes) but easily applied on other series,
    the package also provides tools for analysing outputs from R packages 'moveHMM' and 'marcher'.
    The segmentation method is a bivariate extension of  Lavielle's method available in 'adehabitatLT' 
    (Lavielle, 1999 &lt;<a href="https://doi.org/10.1016%2FS0304-4149%2899%2900023-X">doi:10.1016/S0304-4149(99)00023-X</a>&gt; and 2005 &lt;<a href="https://doi.org/10.1016%2Fj.sigpro.2005.01.012">doi:10.1016/j.sigpro.2005.01.012</a>&gt;).
    This method rely on dynamic programming for efficient segmentation.
    The segmentation/clustering method alternates steps of dynamic programming with an Expectation-Maximization algorithm.
    This is an extension of Picard et al (2007) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2006.00729.x">doi:10.1111/j.1541-0420.2006.00729.x</a>&gt; method 
    (formerly available in 'cghseg' package) to the bivariate case.
    The method is fully described in Patin et al (2018) &lt;<a href="https://doi.org/10.1101%2F444794">doi:10.1101/444794</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RColorBrewer (&ge; 1.1-2), dplyr (&ge; 1.0.0), plyr (&ge; 1.8.4),
reshape2 (&ge; 1.4.1), ggplot2(&ge; 2.1.0), magrittr, Rcpp, zoo,
grDevices, graphics, stats, utils, scales, rlang, methods, cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, dygraphs (&ge; 1.1.1-1), xts (&ge;
0.9-7), leaflet (&ge; 1.0.1), sp (&ge; 1.2-3), adehabitatLT,
depmixS4, moveHMM (&ge; 1.2), htmltools, move, devtools, spelling</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-24 07:49:55 UTC; rpatin</td>
</tr>
<tr>
<td>Author:</td>
<td>Remi Patin [aut, cre],
  Marie-Pierre Etienne [aut],
  Emilie Lebarbier [aut],
  Simon Benhamou [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Remi Patin &lt;remi.patin@normale.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-24 08:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='segclust2d'>segclust2d: tools for segmentation of animal GPS movement data</h2><span id='topic+segclust2d-package'></span><span id='topic+segclust2d'></span>

<h3>Description</h3>

<p>Provides two methods for segmentation and joint segmentation/clustering of
bivariate time-series. Originally intended for ecological segmentation
(home-range and behavioural modes) but easily applied on other series, the
package also provides tools for analysing outputs from R packages moveHMM
and marcher.
</p>


<h3>Details</h3>

<p>The segmentation method is a bivariate extension of Lavielle's method
available in adehabitatLT (Lavielle 1999; and 2005). This method rely on
dynamic programming for efficient segmentation.
</p>
<p>The segmentation/clustering method alternates steps of dynamic programming
with an Expectation-Maximization algorithm. This is an extension of Picard et
al (2007) method (formerly available in cghseg package) to the bivariate
case. 
</p>
<p>The full description of the method is published in Patin et al. (2020).
</p>
<p>References:
</p>
<p>Lavielle, M. (1999) Detection of multiple changes in a sequence of dependent
variables. <em>Stochastic Processes and their Applications</em>, <b>83</b>:
79&ndash;102.
</p>
<p>Lavielle, M. (2005) Using penalized contrasts for the change-point problem.
Report number 5339, Institut national de recherche en informatique et en
automatique.
</p>
<p>Patin, R., Etienne, M. P., Lebarbier, E., Chamaille-Jammes, S., 
&amp; Benhamou, S. (2020). Identifying stationary phases in
multivariate time series for highlighting behavioural modes 
and home range settlements. <em>Journal of Animal Ecology</em>, 
89(1), 44-56.
</p>
<p>Picard, F., Robin, S., Lebarbier, E. and Daudin, J.-J. (2007), A
Segmentation/Clustering Model for the Analysis of Array CGH Data.
<em>Biometrics</em>, 63: 758-766. doi:10.1111/j.1541-0420.2006.00729.x
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Remi Patin <a href="mailto:remi.patin@normale.fr">remi.patin@normale.fr</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Marie-Pierre Etienne
</p>
</li>
<li><p> Emilie Lebarbier
</p>
</li>
<li><p> Simon Benhamou
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/rpatin/segclust2d">https://github.com/rpatin/segclust2d</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rpatin/segclust2d/issues">https://github.com/rpatin/segclust2d/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_covariates'>Covariate Calculations</h2><span id='topic+add_covariates'></span><span id='topic+add_covariates.Move'></span><span id='topic+add_covariates.ltraj'></span><span id='topic+add_covariates.data.frame'></span>

<h3>Description</h3>

<p>Add several covariates to movement observations
<code>add_covariates</code> add several covariates to a data frame with movement
information. It adds : distance between location, spatial angle, speed,
smoothed speed, persistence and rotation velocity (calculated with spatial
angle).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_covariates(x, ...)

## S3 method for class 'Move'
add_covariates(x, coord.names = c("x", "y"), ...)

## S3 method for class 'ltraj'
add_covariates(x, coord.names = c("x", "y"), ...)

## S3 method for class 'data.frame'
add_covariates(
  x,
  coord.names = c("x", "y"),
  smoothed = FALSE,
  timecol = "dateTime",
  units = "hour",
  radius = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_covariates_+3A_x">x</code></td>
<td>
<p>movement data</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_coord.names">coord.names</code></td>
<td>
<p>names of coordinates column in <code>x</code></p>
</td></tr>
<tr><td><code id="add_covariates_+3A_smoothed">smoothed</code></td>
<td>
<p>whether speed are smoothed or not</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_timecol">timecol</code></td>
<td>
<p>names of POSIXct time column</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_units">units</code></td>
<td>
<p>units for time calculation. Default &quot;hour&quot;</p>
</td></tr>
<tr><td><code id="add_covariates_+3A_radius">radius</code></td>
<td>
<p>for spatial angle calculations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with additional covariates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: add_covariates(move_object, coord.names = c("x","y"), smoothed = T)
## Not run: 
data(simulmode)
simple_data &lt;- simulmode[,c("dateTime","x","y")]
full_data   &lt;- add_covariates(simple_data, coord.names = c("x","y"),
 timecol = "dateTime",smoothed = TRUE, units ="min")

## End(Not run)
</code></pre>

<hr>
<h2 id='angular_speed'>Calculate angular speed along a path</h2><span id='topic+angular_speed'></span>

<h3>Description</h3>

<p><code>angular_speed</code> calculate turning angle between locations, taking a
dataframe as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angular_speed(x, coord.names = c("x", "y"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angular_speed_+3A_x">x</code></td>
<td>
<p>data.frame with locations</p>
</td></tr>
<tr><td><code id="angular_speed_+3A_coord.names">coord.names</code></td>
<td>
<p>names of coordinates column in <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of turning angle.
</p>


<h3>Author(s)</h3>

<p>Remi Patin, Simon Benhamou.
</p>

<hr>
<h2 id='apply_rowSums'>apply_rowSums</h2><span id='topic+apply_rowSums'></span>

<h3>Description</h3>

<p>Internal function for Expectation-Maximization (EM) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_rowSums(rupt, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_rowSums_+3A_rupt">rupt</code></td>
<td>
<p>current estimated breaks in signal</p>
</td></tr>
<tr><td><code id="apply_rowSums_+3A_x">x</code></td>
<td>
<p>bivariate signal</p>
</td></tr>
</table>

<hr>
<h2 id='apply_subsampling'>Internal function for subsampling</h2><span id='topic+apply_subsampling'></span>

<h3>Description</h3>

<p>if subsample = FALSE do nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_subsampling(x, is_segclust, subsample, subsample_over, subsample_by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_subsampling_+3A_x">x</code></td>
<td>
<p>data.frame to be subsampled</p>
</td></tr>
<tr><td><code id="apply_subsampling_+3A_is_segclust">is_segclust</code></td>
<td>
<p>TRUE or FALSE whether the function was called from
'segclust()' or 'segmentation()'</p>
</td></tr>
<tr><td><code id="apply_subsampling_+3A_subsample">subsample</code></td>
<td>
<p>if FALSE disable subsampling</p>
</td></tr>
<tr><td><code id="apply_subsampling_+3A_subsample_over">subsample_over</code></td>
<td>
<p>maximum number of row accepted</p>
</td></tr>
<tr><td><code id="apply_subsampling_+3A_subsample_by">subsample_by</code></td>
<td>
<p>subsampling parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>else if subsample_by is missing, subsample only 
if nrow(x) &gt; subsample_over,
then it subsample with the minimum needed to get a
data.frame smaller than subsample_over
</p>
<p>if subsample_by is provided, use it to subsample.
</p>


<h3>Value</h3>

<p>a data.frame
</p>

<hr>
<h2 id='argcheck_diag.var'>Check for argument 'diag.var'</h2><span id='topic+argcheck_diag.var'></span>

<h3>Description</h3>

<p>Check whether argument 'diag.var' was provided.
If not, propose default value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_diag.var(diag.var, seg.var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_diag.var_+3A_diag.var">diag.var</code></td>
<td>
<p>names of the variables on which
statistics are calculated.</p>
</td></tr>
<tr><td><code id="argcheck_diag.var_+3A_seg.var">seg.var</code></td>
<td>
<p>for behavioral segmentation: names of the variables used for
segmentation (either one or two names).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character string
</p>

<hr>
<h2 id='argcheck_Kmax'>Check for argument 'Kmax'</h2><span id='topic+argcheck_Kmax'></span>

<h3>Description</h3>

<p>Check whether argument 'Kmax' was provided and is adequate
before subsampling. Propose adequate value if Kmax is not
provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_Kmax(Kmax, lmin, datalength)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_Kmax_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of segments.</p>
</td></tr>
<tr><td><code id="argcheck_Kmax_+3A_lmin">lmin</code></td>
<td>
<p>minimum length of segments.</p>
</td></tr>
<tr><td><code id="argcheck_Kmax_+3A_datalength">datalength</code></td>
<td>
<p>length of data provided</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>

<hr>
<h2 id='argcheck_lmin'>Check for argument 'lmin'</h2><span id='topic+argcheck_lmin'></span>

<h3>Description</h3>

<p>Check whether argument 'lmin' was provided and is adequate
before subsampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_lmin(lmin, is_segclust)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_lmin_+3A_lmin">lmin</code></td>
<td>
<p>minimum length of segments.</p>
</td></tr>
<tr><td><code id="argcheck_lmin_+3A_is_segclust">is_segclust</code></td>
<td>
<p>TRUE if function is called from <code><a href="#topic+segclust">segclust</a></code> ; 
FALSE otherwise, if function is called from <code><a href="#topic+segmentation">segmentation</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a NULL object
</p>

<hr>
<h2 id='argcheck_ncluster'>Check for argument 'ncluster'</h2><span id='topic+argcheck_ncluster'></span>

<h3>Description</h3>

<p>Check whether argument 'ncluster' was provided and is adequate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_ncluster(ncluster, Kmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_ncluster_+3A_ncluster">ncluster</code></td>
<td>
<p>number of cluster into which segments should be grouped. Can
be a vector if one want to test several number of clusters.</p>
</td></tr>
<tr><td><code id="argcheck_ncluster_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of segments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a NULL object
</p>

<hr>
<h2 id='argcheck_order.var'>Check for argument 'order.var'</h2><span id='topic+argcheck_order.var'></span>

<h3>Description</h3>

<p>Check whether argument 'order.var' was provided.
If not, propose default value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_order.var(order.var, diag.var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_order.var_+3A_order.var">order.var</code></td>
<td>
<p>names of the variable with which states are ordered.</p>
</td></tr>
<tr><td><code id="argcheck_order.var_+3A_diag.var">diag.var</code></td>
<td>
<p>names of the variables on which
statistics are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character string
</p>

<hr>
<h2 id='argcheck_ordering'>Check for argument 'order'</h2><span id='topic+argcheck_ordering'></span>

<h3>Description</h3>

<p>Check whether argument 'order' was provided for plot.segmentation
and segmap. If not, propose default value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_ordering(order, seg.type, order.var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_ordering_+3A_order">order</code></td>
<td>
<p>TRUE or FALSE depending on whether cluster be ordered</p>
</td></tr>
<tr><td><code id="argcheck_ordering_+3A_seg.type">seg.type</code></td>
<td>
<p>types of the segmentation</p>
</td></tr>
<tr><td><code id="argcheck_ordering_+3A_order.var">order.var</code></td>
<td>
<p>name of the variable to order the cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean
</p>

<hr>
<h2 id='argcheck_scale.variable'>Check for argument 'scale.variable'</h2><span id='topic+argcheck_scale.variable'></span>

<h3>Description</h3>

<p>Check whether argument 'scale.variable' was provided.
If not, propose default value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_scale.variable(scale.variable, is_segclust)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_scale.variable_+3A_scale.variable">scale.variable</code></td>
<td>
<p>minimum length of segments.</p>
</td></tr>
<tr><td><code id="argcheck_scale.variable_+3A_is_segclust">is_segclust</code></td>
<td>
<p>TRUE if function is called from <code><a href="#topic+segclust">segclust</a></code> ; 
FALSE otherwise, if function is called from <code><a href="#topic+segmentation">segmentation</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean
</p>

<hr>
<h2 id='argcheck_seg.var'>Check for argument 'seg.var'</h2><span id='topic+argcheck_seg.var'></span>

<h3>Description</h3>

<p>Check whether argument 'seg.var' was adequately provided.
If provided, also check for its length (1 or 2) and
for the existence of corresponding column names in x
If unprovided, use default value (segmentation only) and tests
if column names exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_seg.var(x, seg.var, is_segclust)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_seg.var_+3A_x">x</code></td>
<td>
<p>data used for segmentation. Supported: data.frame, Move object,
ltraj object</p>
</td></tr>
<tr><td><code id="argcheck_seg.var_+3A_seg.var">seg.var</code></td>
<td>
<p>for behavioral segmentation: names of the variables used for
segmentation (either one or two names).</p>
</td></tr>
<tr><td><code id="argcheck_seg.var_+3A_is_segclust">is_segclust</code></td>
<td>
<p>TRUE if function is called from <code><a href="#topic+segclust">segclust</a></code> ; 
FALSE otherwise, if function is called from <code><a href="#topic+segmentation">segmentation</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a data.frame and a vector with two character strings
</p>

<hr>
<h2 id='argcheck_segclust'>Check for argument 'ncluster' and 'nseg'</h2><span id='topic+argcheck_segclust'></span>

<h3>Description</h3>

<p>Check whether argument 'ncluster' and 'nseg' were provided.
If not, propose default value based on BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_segclust(ncluster, nseg, ncluster.BIC, Kopt.BIC)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_segclust_+3A_ncluster">ncluster</code></td>
<td>
<p>number of cluster</p>
</td></tr>
<tr><td><code id="argcheck_segclust_+3A_nseg">nseg</code></td>
<td>
<p>number of segment</p>
</td></tr>
<tr><td><code id="argcheck_segclust_+3A_ncluster.bic">ncluster.BIC</code></td>
<td>
<p>optimal number of cluster selected by BIC</p>
</td></tr>
<tr><td><code id="argcheck_segclust_+3A_kopt.bic">Kopt.BIC</code></td>
<td>
<p>optimal number of segment selected by BIC for 
each number of cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two integers
</p>

<hr>
<h2 id='argcheck_segmentation'>Check for argument 'nseg'</h2><span id='topic+argcheck_segmentation'></span>

<h3>Description</h3>

<p>Check whether argument  'nseg' was provided.
If not, propose default value based on Lavielle's criterium
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_segmentation(nseg, Kopt.lavielle)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_segmentation_+3A_nseg">nseg</code></td>
<td>
<p>number of segment</p>
</td></tr>
<tr><td><code id="argcheck_segmentation_+3A_kopt.lavielle">Kopt.lavielle</code></td>
<td>
<p>optimal number of segment selected with 
Lavielle's criterium</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>

<hr>
<h2 id='argcheck_type_coord'>Check for deprecated 'type' and 'coord.names' argument</h2><span id='topic+argcheck_type_coord'></span>

<h3>Description</h3>

<p>Check whether argument 'type' and 'coord.names' 
were provided and communicate adequately if need be.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argcheck_type_coord(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argcheck_type_coord_+3A_...">...</code></td>
<td>
<p>additional parameters transmitted from <code><a href="#topic+segmentation">segmentation</a></code>
or <code><a href="#topic+segclust">segclust</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a NULL object
</p>

<hr>
<h2 id='arma_repmat'>arma_repmat</h2><span id='topic+arma_repmat'></span>

<h3>Description</h3>

<p>C++ Armadillo version for repmat function. Repeat a matrix in bloc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_repmat(A, n, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_repmat_+3A_a">A</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="arma_repmat_+3A_n">n</code></td>
<td>
<p>number of repetition in line</p>
</td></tr>
<tr><td><code id="arma_repmat_+3A_m">m</code></td>
<td>
<p>number of repetition in column</p>
</td></tr>
</table>

<hr>
<h2 id='augment'>Generic function for augment</h2><span id='topic+augment'></span>

<h3>Description</h3>

<p>see broom::augment for more informations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment_+3A_x">x</code></td>
<td>
<p>object to be augmented</p>
</td></tr>
<tr><td><code id="augment_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='bisig_plot'>bisig_plot draws the plots of the bivariate signal on the same plot (scale
free)</h2><span id='topic+bisig_plot'></span>

<h3>Description</h3>

<p>bisig_plot draws the plots of the bivariate signal on the same plot (scale
free)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisig_plot(x, rupt = NULL, mu = NULL, pop = NULL, merge.seg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bisig_plot_+3A_x">x</code></td>
<td>
<p>the signal to be plotted</p>
</td></tr>
<tr><td><code id="bisig_plot_+3A_rupt">rupt</code></td>
<td>
<p>optional, if given add vertical lines at change points (rupt
should a vector)</p>
</td></tr>
<tr><td><code id="bisig_plot_+3A_mu">mu</code></td>
<td>
<p>optional the mean of each class of segment,</p>
</td></tr>
<tr><td><code id="bisig_plot_+3A_pop">pop</code></td>
<td>
<p>optional the cluster to whom each segment belongs to,</p>
</td></tr>
<tr><td><code id="bisig_plot_+3A_merge.seg">merge.seg</code></td>
<td>
<p>should segment be merged ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value
</p>

<hr>
<h2 id='calc_BIC'>Calculate BIC</h2><span id='topic+calc_BIC'></span>

<h3>Description</h3>

<p><code>BIC</code> calculates BIC given log-likelihood, number of segment and number
of class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_BIC(likelihood, ncluster, nseg, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_BIC_+3A_likelihood">likelihood</code></td>
<td>
<p>log-likelihood</p>
</td></tr>
<tr><td><code id="calc_BIC_+3A_ncluster">ncluster</code></td>
<td>
<p>number of cluster</p>
</td></tr>
<tr><td><code id="calc_BIC_+3A_nseg">nseg</code></td>
<td>
<p>number of segment</p>
</td></tr>
<tr><td><code id="calc_BIC_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with BIC, number of cluster and number of segment
</p>

<hr>
<h2 id='calc_dist'>Calculate distance between locations</h2><span id='topic+calc_dist'></span>

<h3>Description</h3>

<p><code>calc_dist</code> calculate distance between locations, taking a dataframe as
input. Distance can also be smoothed over the two steps before and after the
each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_dist(x, coord.names = c("x", "y"), smoothed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_dist_+3A_x">x</code></td>
<td>
<p>data.frame with locations</p>
</td></tr>
<tr><td><code id="calc_dist_+3A_coord.names">coord.names</code></td>
<td>
<p>names of coordinates column in <code>x</code></p>
</td></tr>
<tr><td><code id="calc_dist_+3A_smoothed">smoothed</code></td>
<td>
<p>whether distance are smoothed or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of distance
</p>


<h3>Author(s)</h3>

<p>Remi Patin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: calc_dist(df,coord.names = c("x","y"), smoothed = T)
</code></pre>

<hr>
<h2 id='calc_speed'>Calculate speed along a path</h2><span id='topic+calc_speed'></span>

<h3>Description</h3>

<p><code>calc_dist</code> calculate speed between locations, taking a dataframe as
input. Speed can also be smoothed over the two steps before and after the
each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_speed(
  x,
  coord.names = c("x", "y"),
  timecol = "dateTime",
  smoothed = FALSE,
  units = "hour"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_speed_+3A_x">x</code></td>
<td>
<p>data.frame with locations</p>
</td></tr>
<tr><td><code id="calc_speed_+3A_coord.names">coord.names</code></td>
<td>
<p>names of coordinates column in <code>x</code></p>
</td></tr>
<tr><td><code id="calc_speed_+3A_timecol">timecol</code></td>
<td>
<p>names of POSIXct time column</p>
</td></tr>
<tr><td><code id="calc_speed_+3A_smoothed">smoothed</code></td>
<td>
<p>whether speed are smoothed or not</p>
</td></tr>
<tr><td><code id="calc_speed_+3A_units">units</code></td>
<td>
<p>units for time calculation. Default &quot;hour&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of distance
</p>


<h3>Author(s)</h3>

<p>Remi Patin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: calc_speed(df,coord.names = c("x","y"), timecol = "dateTime",
smoothed = T)
## End(Not run)
</code></pre>

<hr>
<h2 id='calc_stat_states'>Calculate state statistics</h2><span id='topic+calc_stat_states'></span>

<h3>Description</h3>

<p><code>calc_stat_states</code> calculates statistics of a given segmentation : mean
and variance of the different states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_stat_states(data, df.segm, diag.var, order.var = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_stat_states_+3A_data">data</code></td>
<td>
<p>the data.frame with the different variable</p>
</td></tr>
<tr><td><code id="calc_stat_states_+3A_df.segm">df.segm</code></td>
<td>
<p>output of prep_segm function</p>
</td></tr>
<tr><td><code id="calc_stat_states_+3A_diag.var">diag.var</code></td>
<td>
<p>names of the variables on which statistics are calculated</p>
</td></tr>
<tr><td><code id="calc_stat_states_+3A_order.var">order.var</code></td>
<td>
<p>names of the variable with which states are ordered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with mean and variance of the different states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: calc_stat_states(data, diag.var = c("dist","angle"),
order.var='dist', type='hmm',hmm.model=mod1.hmm)
## End(Not run)
</code></pre>

<hr>
<h2 id='check_repetition'>Check for repetition in the series</h2><span id='topic+check_repetition'></span>

<h3>Description</h3>

<p><code>check_repetition</code> checks whether the series have identical or
near-identical repetition larger than lmin. if that is the case, throw an
error, the algorithm cannot yet handle these repetition, because variance on
the segment would be null.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_repetition(x, lmin, rounding = FALSE, magnitude = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_repetition_+3A_x">x</code></td>
<td>
<p>the bivariate series to be tested</p>
</td></tr>
<tr><td><code id="check_repetition_+3A_lmin">lmin</code></td>
<td>
<p>minimum length of segment</p>
</td></tr>
<tr><td><code id="check_repetition_+3A_rounding">rounding</code></td>
<td>
<p>whether or not series are rounded</p>
</td></tr>
<tr><td><code id="check_repetition_+3A_magnitude">magnitude</code></td>
<td>
<p>number of magnitude of standard deviation below which values
are rounded. i.e if magnitude = 3, difference smaller than one thousandth
of the standard deviation are rounded to the same value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean, TRUE if there is any repetition larger or equal to lmin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42) 
dat &lt;- rbind(base::sample(seq(1,10),  size= 100, replace = TRUE),
             base::sample(seq(1,10),  size= 100, replace = TRUE))
check_repetition(dat, lmin = 3)
check_repetition(dat, lmin = 5)             
</code></pre>

<hr>
<h2 id='choose_kmax'>Finding best segmentation with a different threshold S</h2><span id='topic+choose_kmax'></span>

<h3>Description</h3>

<p>Choosing optimal number of segment using Marc Lavielle's method. 
From Emilie Lebarbier. Method based on identifying 
breaks in the slope of the contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose_kmax(x, S = 0.75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choose_kmax_+3A_x">x</code></td>
<td>
<p><code>segmentation-class</code> object</p>
</td></tr>
<tr><td><code id="choose_kmax_+3A_s">S</code></td>
<td>
<p>threshold for choosing the number of segment. See
adehabitatLT::chooseseg</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the optimal number of segment given threshold S.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
res.seg &lt;- segmentation(df, coord.names = c("x","y"), Kmax = 30, lmin = 10)
# find the optimal number of segment according to Lavielle's criterium with a
# different threshold.
choose_kmax(res.seg, S = 0.60) 

## End(Not run)
</code></pre>

<hr>
<h2 id='chooseseg_lavielle'>Internal Function for choosing optimal number of segment</h2><span id='topic+chooseseg_lavielle'></span>

<h3>Description</h3>

<p>Choosing optimal number of segment using Marc Lavielle's method. From Emilie
Lebarbier. Method based on identifying breaks in the slope of the contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseseg_lavielle(J, S = 0.75, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chooseseg_lavielle_+3A_j">J</code></td>
<td>
<p>likelihood for each number of segment</p>
</td></tr>
<tr><td><code id="chooseseg_lavielle_+3A_s">S</code></td>
<td>
<p>threshold for choosing the number of segment. See
adehabitatLT::chooseseg</p>
</td></tr>
<tr><td><code id="chooseseg_lavielle_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with optimal number of segment and full data.frame of the
calculus
</p>

<hr>
<h2 id='colsums_sapply'>colsums_sapply</h2><span id='topic+colsums_sapply'></span>

<h3>Description</h3>

<p>Internal function for Expectation-Maximization (EM) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colsums_sapply(i, rupt, x, mu, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colsums_sapply_+3A_i">i</code></td>
<td>
<p>number of signal</p>
</td></tr>
<tr><td><code id="colsums_sapply_+3A_rupt">rupt</code></td>
<td>
<p>current estimated breaks in signal</p>
</td></tr>
<tr><td><code id="colsums_sapply_+3A_x">x</code></td>
<td>
<p>bivariate signal</p>
</td></tr>
<tr><td><code id="colsums_sapply_+3A_mu">mu</code></td>
<td>
<p>mean parameter for each signal</p>
</td></tr>
<tr><td><code id="colsums_sapply_+3A_tau">tau</code></td>
<td>
<p>tau</p>
</td></tr>
</table>

<hr>
<h2 id='cumsum_cpp'>cumsum_cpp</h2><span id='topic+cumsum_cpp'></span>

<h3>Description</h3>

<p>C++ function for cumulative sum (replacing R cumsum)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumsum_cpp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumsum_cpp_+3A_x">x</code></td>
<td>
<p>Numerical Vector</p>
</td></tr>
</table>

<hr>
<h2 id='DynProg'>DynProg computes the change points given a cost matrix matD
and a maximum number of segments Kmax</h2><span id='topic+DynProg'></span>

<h3>Description</h3>

<p>DynProg computes the change points given a cost matrix matD
and a maximum number of segments Kmax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DynProg(matD, Kmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DynProg_+3A_matd">matD</code></td>
<td>
<p>the cost Matrix os size n x n</p>
</td></tr>
<tr><td><code id="DynProg_+3A_kmax">Kmax</code></td>
<td>
<p>the maximal number of segments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with J.est a vector with Kmax value, the Kth is the minimum
contrast for a model with K segments (-J.est is the log-likelihood) and
with  t.test a matrix, line K are the coordinates of the change points for
a model with K segments
</p>

<hr>
<h2 id='DynProg_algo_cpp'>DynProg_algo_cpp</h2><span id='topic+DynProg_algo_cpp'></span>

<h3>Description</h3>

<p>This function finds the best segmentation given a Cost Matrix using a
dynamic programming algorithm. C++ implementation of <a href="#topic+DynProg">DynProg</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DynProg_algo_cpp(matD, Kmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DynProg_algo_cpp_+3A_matd">matD</code></td>
<td>
<p>Cost Matrix</p>
</td></tr>
<tr><td><code id="DynProg_algo_cpp_+3A_kmax">Kmax</code></td>
<td>
<p>number of segments</p>
</td></tr>
</table>

<hr>
<h2 id='EM.algo_simultanee'>EM.algo_simultanee calculates the MLE of phi for given change-point instants</h2><span id='topic+EM.algo_simultanee'></span>

<h3>Description</h3>

<p>EM.algo_simultanee calculates the MLE of phi for given change-point instants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM.algo_simultanee(x, rupt, P, phi, eps = 1e-06, sameSigma = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM.algo_simultanee_+3A_x">x</code></td>
<td>
<p>bivariate signal</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_+3A_rupt">rupt</code></td>
<td>
<p>the sequence of change points</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_+3A_p">P</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_+3A_phi">phi</code></td>
<td>
<p>starting value for the  parameter</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_+3A_eps">eps</code></td>
<td>
<p>eps</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_+3A_samesigma">sameSigma</code></td>
<td>
<p>TRUE if segments have the same variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with  phi, the MLE, tau =(taukj) the probability for segment k
to belong to class,lvinc = lvinc,empty = empty,dv = dv
</p>

<hr>
<h2 id='EM.algo_simultanee_Cpp'>EM.algo_simultanee calculates the MLE of phi for given change-point instants
and for a fixed number of clusters</h2><span id='topic+EM.algo_simultanee_Cpp'></span>

<h3>Description</h3>

<p>EM.algo_simultanee calculates the MLE of phi for given change-point instants
and for a fixed number of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM.algo_simultanee_Cpp(x, rupt, P, phi, eps = 1e-06, sameSigma = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM.algo_simultanee_Cpp_+3A_x">x</code></td>
<td>
<p>bivariate signal</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_Cpp_+3A_rupt">rupt</code></td>
<td>
<p>the sequence of change points</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_Cpp_+3A_p">P</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_Cpp_+3A_phi">phi</code></td>
<td>
<p>starting value for the  parameter</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_Cpp_+3A_eps">eps</code></td>
<td>
<p>eps</p>
</td></tr>
<tr><td><code id="EM.algo_simultanee_Cpp_+3A_samesigma">sameSigma</code></td>
<td>
<p>TRUE if segments have the same variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with  phi, the MLE, tau =(taukj) the probability for segment k
to belong to class,lvinc = lvinc,empty = empty,dv = dv
</p>

<hr>
<h2 id='EM.init_simultanee'>EM.init_simultanee proposes an initial value for the EM algorithm  based on a
hierarchical clustering  algorithm (ascending)</h2><span id='topic+EM.init_simultanee'></span>

<h3>Description</h3>

<p>EM.init_simultanee proposes an initial value for the EM algorithm  based on a
hierarchical clustering  algorithm (ascending)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM.init_simultanee(x, rupt, K, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM.init_simultanee_+3A_x">x</code></td>
<td>
<p>the bivariate signal</p>
</td></tr>
<tr><td><code id="EM.init_simultanee_+3A_rupt">rupt</code></td>
<td>
<p>the  change point instants, data.frame</p>
</td></tr>
<tr><td><code id="EM.init_simultanee_+3A_k">K</code></td>
<td>
<p>number of segments</p>
</td></tr>
<tr><td><code id="EM.init_simultanee_+3A_p">P</code></td>
<td>
<p>number of clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phi0 : candidate for the EM algorithm
</p>

<hr>
<h2 id='Estep_simultanee'>Estep_simultanee computes posterior probabilities and incomplete-data
log-likelihood for mixture models</h2><span id='topic+Estep_simultanee'></span>

<h3>Description</h3>

<p>Estep_simultanee computes posterior probabilities and incomplete-data
log-likelihood for mixture models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Estep_simultanee(logdensity, phi, eps = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Estep_simultanee_+3A_logdensity">logdensity</code></td>
<td>
<p>is a  K*P matrix containing the conditional log-densities
for each segment</p>
</td></tr>
<tr><td><code id="Estep_simultanee_+3A_phi">phi</code></td>
<td>
<p>a list containing the parameters of the mixture</p>
</td></tr>
<tr><td><code id="Estep_simultanee_+3A_eps">eps</code></td>
<td>
<p>eps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with tau a K*P matrix, tau kj is the posterior probability 
for segment k to belong to class j and
lvinc, the incomplete log likelihood P(X=x)
</p>

<hr>
<h2 id='find_mu_sd'>Find mean and standard deviation of segments</h2><span id='topic+find_mu_sd'></span>

<h3>Description</h3>

<p><code>find_mu_sd</code> calculates statistics of a given segmentation : mean
and variance of the different states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_mu_sd(df.states, diag.var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_mu_sd_+3A_df.states">df.states</code></td>
<td>
<p>a list of data.frame</p>
</td></tr>
<tr><td><code id="find_mu_sd_+3A_diag.var">diag.var</code></td>
<td>
<p>names of the variables on which statistics are calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with mean and variance of the different states
</p>

<hr>
<h2 id='Gmean_simultanee'>Gmean_simultanee  calculates the cost matrix for a segmentation model with
changes in the mean and variance for all signals</h2><span id='topic+Gmean_simultanee'></span>

<h3>Description</h3>

<p>Gmean_simultanee  calculates the cost matrix for a segmentation model with
changes in the mean and variance for all signals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gmean_simultanee(Don, lmin, sameVar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gmean_simultanee_+3A_don">Don</code></td>
<td>
<p>the bivariate signal</p>
</td></tr>
<tr><td><code id="Gmean_simultanee_+3A_lmin">lmin</code></td>
<td>
<p>minimum size for a segment, default value is 2</p>
</td></tr>
<tr><td><code id="Gmean_simultanee_+3A_samevar">sameVar</code></td>
<td>
<p>whether variance is the same for each segment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the cost matrix G(i,j) which contains the variance of the data
between point (i+1) to point j
</p>

<hr>
<h2 id='Gmixt_algo_cpp'>Gmixt_algo_cpp</h2><span id='topic+Gmixt_algo_cpp'></span>

<h3>Description</h3>

<p>Internal C++ algorithm for computing the cost matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gmixt_algo_cpp(zi, lgi, P, mvec, wk, svec, prop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gmixt_algo_cpp_+3A_zi">zi</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="Gmixt_algo_cpp_+3A_lgi">lgi</code></td>
<td>
<p>vector of indices</p>
</td></tr>
<tr><td><code id="Gmixt_algo_cpp_+3A_p">P</code></td>
<td>
<p>number of class</p>
</td></tr>
<tr><td><code id="Gmixt_algo_cpp_+3A_mvec">mvec</code></td>
<td>
<p>vector of means for each class</p>
</td></tr>
<tr><td><code id="Gmixt_algo_cpp_+3A_wk">wk</code></td>
<td>
<p>temporary vector for calculations</p>
</td></tr>
<tr><td><code id="Gmixt_algo_cpp_+3A_svec">svec</code></td>
<td>
<p>vector of standard deviations for each class</p>
</td></tr>
<tr><td><code id="Gmixt_algo_cpp_+3A_prop">prop</code></td>
<td>
<p>mixture vector</p>
</td></tr>
</table>

<hr>
<h2 id='Gmixt_simultanee'>Gmixt_simultanee calculates the cost matrix 
for a segmentation/clustering model</h2><span id='topic+Gmixt_simultanee'></span>

<h3>Description</h3>

<p>Return matrix G(i,j), the mixture density 
for segment between points (i+1) to j :
</p>
<p style="text-align: center;"><code class="reqn">G(i,j) = \sum_{p=1}^P \log (\pi_p f(y^{ij};\theta_p))</code>
</p>

<p>Rq: this density if factorized in order to avoid numerical zeros in
the log
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gmixt_simultanee(Don, lmin, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gmixt_simultanee_+3A_don">Don</code></td>
<td>
<p>the bivariate  signal</p>
</td></tr>
<tr><td><code id="Gmixt_simultanee_+3A_lmin">lmin</code></td>
<td>
<p>the minimum size for a segment</p>
</td></tr>
<tr><td><code id="Gmixt_simultanee_+3A_phi">phi</code></td>
<td>
<p>the  parameters of the mixture</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='Gmixt_simultanee_fullcpp'>Gmixt_simultanee_fullcpp</h2><span id='topic+Gmixt_simultanee_fullcpp'></span>

<h3>Description</h3>

<p>C++ function replacing <a href="#topic+Gmixt_simultanee">Gmixt_simultanee</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gmixt_simultanee_fullcpp(Don, lmin, prop, mu, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gmixt_simultanee_fullcpp_+3A_don">Don</code></td>
<td>
<p>Bivariate Signal</p>
</td></tr>
<tr><td><code id="Gmixt_simultanee_fullcpp_+3A_lmin">lmin</code></td>
<td>
<p>minimum length of segments</p>
</td></tr>
<tr><td><code id="Gmixt_simultanee_fullcpp_+3A_prop">prop</code></td>
<td>
<p>mixture parameters</p>
</td></tr>
<tr><td><code id="Gmixt_simultanee_fullcpp_+3A_mu">mu</code></td>
<td>
<p>mean parameters</p>
</td></tr>
<tr><td><code id="Gmixt_simultanee_fullcpp_+3A_s">s</code></td>
<td>
<p>standard deviation parameters</p>
</td></tr>
</table>

<hr>
<h2 id='hybrid_simultanee'><code>hybrid_simultanee</code> performs a simultaneous seg - clustering for
bivariate signals.</h2><span id='topic+hybrid_simultanee'></span>

<h3>Description</h3>

<p>It is an algorithm which combines dynamic programming
and the EM algorithm to calculate the MLE of phi and T, which
are the mixture parameters and the change point instants.
this algorithm is run for a given number of clusters,
and estimates the parameters for a segmentation/clustering
model with P clusters and 1:Kmax segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hybrid_simultanee(
  x,
  P,
  Kmax,
  lmin = 3,
  sameSigma = TRUE,
  sameVar.init = FALSE,
  eps = 1e-06,
  lissage = TRUE,
  pureR = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hybrid_simultanee_+3A_x">x</code></td>
<td>
<p>the two-dimensional signal, one line per dimension</p>
</td></tr>
<tr><td><code id="hybrid_simultanee_+3A_p">P</code></td>
<td>
<p>the number of classes</p>
</td></tr>
<tr><td><code id="hybrid_simultanee_+3A_kmax">Kmax</code></td>
<td>
<p>the maximal number of segments</p>
</td></tr>
<tr><td><code id="hybrid_simultanee_+3A_lmin">lmin</code></td>
<td>
<p>minimum length of segment</p>
</td></tr>
<tr><td><code id="hybrid_simultanee_+3A_samesigma">sameSigma</code></td>
<td>
<p>should segment have the same variance</p>
</td></tr>
<tr><td><code id="hybrid_simultanee_+3A_samevar.init">sameVar.init</code></td>
<td>
<p>sameVar.init</p>
</td></tr>
<tr><td><code id="hybrid_simultanee_+3A_eps">eps</code></td>
<td>
<p>eps</p>
</td></tr>
<tr><td><code id="hybrid_simultanee_+3A_lissage">lissage</code></td>
<td>
<p>should likelihood be smoothed</p>
</td></tr>
<tr><td><code id="hybrid_simultanee_+3A_purer">pureR</code></td>
<td>
<p>should algorithm run in full R or use Rcpp speed improvements</p>
</td></tr>
<tr><td><code id="hybrid_simultanee_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with Linc, the incomplete loglikelihood =Linc,param=paramtau
posterior probability
</p>

<hr>
<h2 id='initialisePhi'>initialisePhi is the constructor for a set of parameters for a segclust model</h2><span id='topic+initialisePhi'></span>

<h3>Description</h3>

<p>initialisePhi is the constructor for a set of parameters for a segclust model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialisePhi(P, val = -Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initialisePhi_+3A_p">P</code></td>
<td>
<p>number of classes</p>
</td></tr>
<tr><td><code id="initialisePhi_+3A_val">val</code></td>
<td>
<p>the value used for initialisation default is -Inf</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a set of parameter phi
</p>

<hr>
<h2 id='likelihood'>Generic function for likelihood</h2><span id='topic+likelihood'></span>

<h3>Description</h3>

<p>Generic function for likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likelihood_+3A_x">x</code></td>
<td>
<p>object from which likelihood can be extracted</p>
</td></tr>
<tr><td><code id="likelihood_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='logdens_simultanee_cpp'>logdens_simultanee_cpp</h2><span id='topic+logdens_simultanee_cpp'></span><span id='topic+logdens_simultanee'></span>

<h3>Description</h3>

<p>Calculate logdensity of a bivariate signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logdens_simultanee_cpp(xk, mu, sigma, prop)

logdens_simultanee(xk, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logdens_simultanee_cpp_+3A_xk">xk</code></td>
<td>
<p>the bivariate signal</p>
</td></tr>
<tr><td><code id="logdens_simultanee_cpp_+3A_mu">mu</code></td>
<td>
<p>mean parameter for each signal</p>
</td></tr>
<tr><td><code id="logdens_simultanee_cpp_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation parameter for each signal</p>
</td></tr>
<tr><td><code id="logdens_simultanee_cpp_+3A_prop">prop</code></td>
<td>
<p>mixture parameter</p>
</td></tr>
<tr><td><code id="logdens_simultanee_cpp_+3A_phi">phi</code></td>
<td>
<p>parameters of the mixture, P components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the log density
</p>

<hr>
<h2 id='map_segm'><code>plot_segm</code> plot segmented movement data on a map.</h2><span id='topic+map_segm'></span>

<h3>Description</h3>

<p><code>plot_segm</code> plot segmented movement data on a map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_segm(
  data,
  output,
  interactive = FALSE,
  html = FALSE,
  scale = 1,
  UTMstring = "+proj=longlat +datum=WGS84 +no_defs",
  width = 400,
  height = 400,
  order = NULL,
  pointsize = 1,
  linesize = 0.5,
  coord.names = c("x", "y"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_segm_+3A_data">data</code></td>
<td>
<p>the data.frame with the different variable</p>
</td></tr>
<tr><td><code id="map_segm_+3A_output">output</code></td>
<td>
<p>outputs of the segmentation  or segclust algorithm for one
number of segment</p>
</td></tr>
<tr><td><code id="map_segm_+3A_interactive">interactive</code></td>
<td>
<p>should graph be interactive with leaflet ?</p>
</td></tr>
<tr><td><code id="map_segm_+3A_html">html</code></td>
<td>
<p>should the graph be incorporated in a markdown file through
htmltools::tagList()</p>
</td></tr>
<tr><td><code id="map_segm_+3A_scale">scale</code></td>
<td>
<p>for dividing coordinates to have compatibility with leaflet</p>
</td></tr>
<tr><td><code id="map_segm_+3A_utmstring">UTMstring</code></td>
<td>
<p>projection of the coordinates</p>
</td></tr>
<tr><td><code id="map_segm_+3A_width">width</code></td>
<td>
<p>width</p>
</td></tr>
<tr><td><code id="map_segm_+3A_height">height</code></td>
<td>
<p>height</p>
</td></tr>
<tr><td><code id="map_segm_+3A_order">order</code></td>
<td>
<p>should cluster be ordered</p>
</td></tr>
<tr><td><code id="map_segm_+3A_pointsize">pointsize</code></td>
<td>
<p>size of points</p>
</td></tr>
<tr><td><code id="map_segm_+3A_linesize">linesize</code></td>
<td>
<p>size of lines</p>
</td></tr>
<tr><td><code id="map_segm_+3A_coord.names">coord.names</code></td>
<td>
<p>names of coordinates</p>
</td></tr>
<tr><td><code id="map_segm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#res.seg is a result of the segmentation-only algorithm : 
nseg = 10
outputs = res.seg$outputs[[paste(nseg, "segments")]]
map &lt;- map_segm(data=res.seg$data,output=outputs)
#res.segclust is a result of the segmentation-clusturing algorithm : 
nseg = 10; ncluster = 3
outputs = res.segclust$outputs[[paste(ncluster,"class -",nseg, "segments")]]
map &lt;- map_segm(data=res.seg$data,output=outputs)

## End(Not run)

</code></pre>

<hr>
<h2 id='matrixRupt'>matrixRupt transforms a vector of change point into a data.frame with start
and end of every segment</h2><span id='topic+matrixRupt'></span>

<h3>Description</h3>

<p>matrixRupt transforms a vector of change point into a data.frame with start
and end of every segment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixRupt(x, vectorRupt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrixRupt_+3A_x">x</code></td>
<td>
<p>the</p>
</td></tr>
<tr><td><code id="matrixRupt_+3A_vectorrupt">vectorRupt</code></td>
<td>
<p>the vector containing the change point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix of change point
</p>

<hr>
<h2 id='Mstep_simultanee'>Mstep_simultanee computes the MLE within the EM framework</h2><span id='topic+Mstep_simultanee'></span>

<h3>Description</h3>

<p>Mstep_simultanee computes the MLE within the EM framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep_simultanee(x, rupt, tau, phi, sameSigma = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mstep_simultanee_+3A_x">x</code></td>
<td>
<p>the bivariate signal</p>
</td></tr>
<tr><td><code id="Mstep_simultanee_+3A_rupt">rupt</code></td>
<td>
<p>the rupture dataframe</p>
</td></tr>
<tr><td><code id="Mstep_simultanee_+3A_tau">tau</code></td>
<td>
<p>the K*P matrix containing posterior probabilities of membership
to clusters</p>
</td></tr>
<tr><td><code id="Mstep_simultanee_+3A_phi">phi</code></td>
<td>
<p>the parameters of the mixture</p>
</td></tr>
<tr><td><code id="Mstep_simultanee_+3A_samesigma">sameSigma</code></td>
<td>
<p>TRUE if all segment have the same variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phi the updated value of the parameters
</p>

<hr>
<h2 id='Mstep_simultanee_cpp'>Mstep_simultanee computes the MLE within the EM framework</h2><span id='topic+Mstep_simultanee_cpp'></span>

<h3>Description</h3>

<p>Mstep_simultanee computes the MLE within the EM framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep_simultanee_cpp(x, rupt, tau, phi, sameSigma = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mstep_simultanee_cpp_+3A_x">x</code></td>
<td>
<p>the bivariate signal</p>
</td></tr>
<tr><td><code id="Mstep_simultanee_cpp_+3A_rupt">rupt</code></td>
<td>
<p>the rupture dataframe</p>
</td></tr>
<tr><td><code id="Mstep_simultanee_cpp_+3A_tau">tau</code></td>
<td>
<p>the K*P matrix containing posterior probabilities of membership to
clusters</p>
</td></tr>
<tr><td><code id="Mstep_simultanee_cpp_+3A_phi">phi</code></td>
<td>
<p>the parameters of the mixture</p>
</td></tr>
<tr><td><code id="Mstep_simultanee_cpp_+3A_samesigma">sameSigma</code></td>
<td>
<p>whether segments have the same variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phi the updated value of the parameters
</p>

<hr>
<h2 id='neighborsbis'>neighbors tests whether neighbors of point k,P can  be used to re-initialize
the EM algorithm and to improve the log-likelihood.</h2><span id='topic+neighborsbis'></span>

<h3>Description</h3>

<p>neighbors tests whether neighbors of point k,P can  be used to re-initialize
the EM algorithm and to improve the log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborsbis(
  kv.hull,
  x,
  L,
  k,
  param,
  P,
  lmin,
  eps,
  sameSigma = TRUE,
  pureR = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighborsbis_+3A_kv.hull">kv.hull</code></td>
<td>
<p>convex hull of likelihood</p>
</td></tr>
<tr><td><code id="neighborsbis_+3A_x">x</code></td>
<td>
<p>the initial dataset</p>
</td></tr>
<tr><td><code id="neighborsbis_+3A_l">L</code></td>
<td>
<p>the likelihood</p>
</td></tr>
<tr><td><code id="neighborsbis_+3A_k">k</code></td>
<td>
<p>the points of interest</p>
</td></tr>
<tr><td><code id="neighborsbis_+3A_param">param</code></td>
<td>
<p>param outputs of segmentation</p>
</td></tr>
<tr><td><code id="neighborsbis_+3A_p">P</code></td>
<td>
<p>the number of class</p>
</td></tr>
<tr><td><code id="neighborsbis_+3A_lmin">lmin</code></td>
<td>
<p>minimal size of the segment to be implemented</p>
</td></tr>
<tr><td><code id="neighborsbis_+3A_eps">eps</code></td>
<td>
<p>eps</p>
</td></tr>
<tr><td><code id="neighborsbis_+3A_samesigma">sameSigma</code></td>
<td>
<p>should segments have same variance ?</p>
</td></tr>
<tr><td><code id="neighborsbis_+3A_purer">pureR</code></td>
<td>
<p>should algorithm use only R functions or benefit from Rcpp
faster algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothing likelihood
</p>

<hr>
<h2 id='plot_segm'>Plot segmentation on time-serie</h2><span id='topic+plot_segm'></span>

<h3>Description</h3>

<p><code>plot_segm</code> plot segmented time serie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_segm(
  data,
  output,
  interactive = FALSE,
  diag.var,
  x_col = "expectTime",
  html = FALSE,
  order = FALSE,
  stationarity = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_segm_+3A_data">data</code></td>
<td>
<p>the data.frame with the different variable</p>
</td></tr>
<tr><td><code id="plot_segm_+3A_output">output</code></td>
<td>
<p>outputs of the segmentation  or segclust algorithm for one
number of segment</p>
</td></tr>
<tr><td><code id="plot_segm_+3A_interactive">interactive</code></td>
<td>
<p>should graph be interactive through leaflet ?</p>
</td></tr>
<tr><td><code id="plot_segm_+3A_diag.var">diag.var</code></td>
<td>
<p>names of the variables on which statistics are calculated</p>
</td></tr>
<tr><td><code id="plot_segm_+3A_x_col">x_col</code></td>
<td>
<p>column name for time</p>
</td></tr>
<tr><td><code id="plot_segm_+3A_html">html</code></td>
<td>
<p>should the graph be incorporated in a markdown file through
htmltools::tagList()</p>
</td></tr>
<tr><td><code id="plot_segm_+3A_order">order</code></td>
<td>
<p>should cluster be ordered</p>
</td></tr>
<tr><td><code id="plot_segm_+3A_stationarity">stationarity</code></td>
<td>
<p>if TRUE, cut each segment in three and plot each part
with its own mean to assess stationarity of each segment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#res.segclust is the results of the segmentation-clustering algorithm
ncluster = 3
nseg = 10
 g &lt;- plot_segm(data = res.segclust$data, output =
  res.segclust$outputs[[paste(ncluster,"class -",nseg, "segments")]], 
   diag.var = x$`Diagnostic variables`,x_col = 'dateTime)
#res.seg is the results of the segmentation-only algorithm
nseg = 10
 g &lt;- plot_segm(data = res.segclust$data, 
 output = res.segclust$outputs[[paste(nseg, "segments")]], 
  diag.var = x$`Diagnostic variables`,x_col = 'dateTime)
 

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_states'>Plot states statistics</h2><span id='topic+plot_states'></span>

<h3>Description</h3>

<p><code>plot_states</code> plot states statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_states(outputs, diag.var, position_width = 0.3, order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_states_+3A_outputs">outputs</code></td>
<td>
<p>outputs of the segmentation or
segclust algorithm for one number of segment</p>
</td></tr>
<tr><td><code id="plot_states_+3A_diag.var">diag.var</code></td>
<td>
<p>names of the variables on which statistics are calculated</p>
</td></tr>
<tr><td><code id="plot_states_+3A_position_width">position_width</code></td>
<td>
<p>width between different model 
if several models are compared</p>
</td></tr>
<tr><td><code id="plot_states_+3A_order">order</code></td>
<td>
<p>should cluster be ordered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
#res.segclust is the results of the segmentation-clustering algorithm 
ncluster = 3 
nseg = 10 
g &lt;- plot_states(output = res.segclust$outputs[[
  paste(ncluster,"class -",nseg, "segments")
]],
diag.var = c("dist","angle2")
#res.seg is the results of the segmentation-only algorithm 
nseg = 10 
g &lt;- plot_states(output = res.segclust$outputs[[paste(nseg, "segments")]],
diag.var = c("dist","angle2")) 

## End(Not run)
</code></pre>

<hr>
<h2 id='prep_segm'>Find segment and states for a Picard model</h2><span id='topic+prep_segm'></span>

<h3>Description</h3>

<p><code>prep_segm</code> find the different segment and states of a given HMM
model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_segm(data, param, seg.type = NULL, nseg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_segm_+3A_data">data</code></td>
<td>
<p>the data.frame with the different variable</p>
</td></tr>
<tr><td><code id="prep_segm_+3A_param">param</code></td>
<td>
<p>the param output of the segmentation</p>
</td></tr>
<tr><td><code id="prep_segm_+3A_seg.type">seg.type</code></td>
<td>
<p>either 'hybrid' or 'dynprog'</p>
</td></tr>
<tr><td><code id="prep_segm_+3A_nseg">nseg</code></td>
<td>
<p>number of segment chosen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with states of the different segments
</p>

<hr>
<h2 id='prep_segm_HMM'>Internal function for HMM</h2><span id='topic+prep_segm_HMM'></span>

<h3>Description</h3>

<p><code>prep_segm_HMM</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_segm_HMM(data, hmm.model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_segm_HMM_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="prep_segm_HMM_+3A_hmm.model">hmm.model</code></td>
<td>
<p>hmm.model</p>
</td></tr>
</table>

<hr>
<h2 id='prep_segm_shiftfit'>Internal function for HMM</h2><span id='topic+prep_segm_shiftfit'></span>

<h3>Description</h3>

<p><code>prep_segm_shiftfit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_segm_shiftfit(data, shiftfit.model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_segm_shiftfit_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="prep_segm_shiftfit_+3A_shiftfit.model">shiftfit.model</code></td>
<td>
<p>shiftfit.model</p>
</td></tr>
</table>

<hr>
<h2 id='prepare_HMM'>Prepare HMM output for proper comparison plots</h2><span id='topic+prepare_HMM'></span>

<h3>Description</h3>

<p><code>prepare_HMM</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_HMM(data, hmm.model = NULL, diag.var, order.var = diag.var[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_HMM_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="prepare_HMM_+3A_hmm.model">hmm.model</code></td>
<td>
<p>hmm.model</p>
</td></tr>
<tr><td><code id="prepare_HMM_+3A_diag.var">diag.var</code></td>
<td>
<p>diag.var</p>
</td></tr>
<tr><td><code id="prepare_HMM_+3A_order.var">order.var</code></td>
<td>
<p>order.var</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example taken from moveHMM package.
# 1. simulate data
# define all the arguments of simData
nbAnimals &lt;- 1
nbStates &lt;- 2
nbCovs &lt;- 2
mu&lt;-c(15,50)
sigma&lt;-c(10,20)
angleMean &lt;- c(pi,0)
kappa &lt;- c(0.7,1.5)
stepPar &lt;- c(mu,sigma)
anglePar &lt;- c(angleMean,kappa)
stepDist &lt;- "gamma"
angleDist &lt;- "vm"
zeroInflation &lt;- FALSE
obsPerAnimal &lt;- c(50,100)

data &lt;- moveHMM::simData(nbAnimals=nbAnimals,nbStates=nbStates,
                stepDist=stepDist,angleDist=angleDist,
                stepPar=stepPar,anglePar=anglePar,nbCovs=nbCovs,
                zeroInflation=zeroInflation,
                obsPerAnimal=obsPerAnimal)

### 2. fit the model to the simulated data
# define initial values for the parameters
mu0 &lt;- c(20,70)
sigma0 &lt;- c(10,30)
kappa0 &lt;- c(1,1)
stepPar0 &lt;- c(mu0,sigma0) # no zero-inflation, so no zero-mass included
anglePar0 &lt;- kappa0 # the angle mean is not estimated,
# so only the concentration parameter is needed
formula &lt;- ~cov1+cos(cov2)
m &lt;- moveHMM::fitHMM(data=data,nbStates=nbStates,stepPar0=stepPar0,
         anglePar0=anglePar0,formula=formula,
         stepDist=stepDist,angleDist=angleDist,angleMean=angleMean)
         
### 3. Transform into a segmentation-class object
res.hmm &lt;- prepare_HMM(data=data, 
hmm.model = m, diag.var = c("step","angle"))
### 4. you can now apply the same function than for segclust2d outputs
plot(res.hmm)
segmap(res.hmm)

## End(Not run)
</code></pre>

<hr>
<h2 id='prepare_shiftfit'>Prepare shiftfit output for proper comparison plots</h2><span id='topic+prepare_shiftfit'></span>

<h3>Description</h3>

<p><code>prepare_shiftfit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_shiftfit(
  data,
  shiftfit.model = NULL,
  diag.var,
  order.var = diag.var[1]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_shiftfit_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="prepare_shiftfit_+3A_shiftfit.model">shiftfit.model</code></td>
<td>
<p>shiftfit.model</p>
</td></tr>
<tr><td><code id="prepare_shiftfit_+3A_diag.var">diag.var</code></td>
<td>
<p>diag.var</p>
</td></tr>
<tr><td><code id="prepare_shiftfit_+3A_order.var">order.var</code></td>
<td>
<p>order.var</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(simulshift)
# 1. subsample to a reasonable size
subdata &lt;- simulshift[seq(1,30000,by = 100),]
# 2. use algorithm from marcher package
MWN.fit &lt;- with(subdata, 
marcher::estimate_shift(T=indice, X=x, Y=y,n.clust = 3))
# 3. convert output
MWN.segm &lt;- prepare_shiftfit(subdata,MWN.fit,diag.var = c("x","y"))
# 4. use segclust2d functions
plot(MWN.segm)
plot(MWN.segm,stationarity = TRUE)
segmap(MWN.segm)

## End(Not run)
</code></pre>

<hr>
<h2 id='relabel_states'>Relabel states of a segmentation/clustering output</h2><span id='topic+relabel_states'></span>

<h3>Description</h3>

<p><code>relabel_states</code> relabel the states of a segmentation/clustering output.
This allows merging different states into the same if for instance several of
the model states represent the same behavioural states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relabel_states(mode.segclust, newlabel, ncluster, nseg, order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relabel_states_+3A_mode.segclust">mode.segclust</code></td>
<td>
<p>segclust output</p>
</td></tr>
<tr><td><code id="relabel_states_+3A_newlabel">newlabel</code></td>
<td>
<p>a vector with the new names ordered, corresponding to 
state_ordered</p>
</td></tr>
<tr><td><code id="relabel_states_+3A_ncluster">ncluster</code></td>
<td>
<p>the number of cluster for which you want relabeling</p>
</td></tr>
<tr><td><code id="relabel_states_+3A_nseg">nseg</code></td>
<td>
<p>the number of segment for which you want relabeling</p>
</td></tr>
<tr><td><code id="relabel_states_+3A_order">order</code></td>
<td>
<p>boolean, whether this changes the ordered states or not. FALSE 
value obsolete for now</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a segmentation object with state names changed for the segmentation
specified by ncluster and nseg
</p>

<hr>
<h2 id='repmat'>repmat repeats a matrix</h2><span id='topic+repmat'></span>

<h3>Description</h3>

<p>repmat repeats a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repmat(a, n, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repmat_+3A_a">a</code></td>
<td>
<p>the base matrix</p>
</td></tr>
<tr><td><code id="repmat_+3A_n">n</code></td>
<td>
<p>number of repetition in lines</p>
</td></tr>
<tr><td><code id="repmat_+3A_m">m</code></td>
<td>
<p>number of repetition in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with n repeats of a in lines et m in columns
</p>

<hr>
<h2 id='ruptAsMat'>ruptAsMat is an internal function to transform a vector giving the change
point to matrix 2 columns matrix in which each line gives the beginning and
the end of a segment</h2><span id='topic+ruptAsMat'></span>

<h3>Description</h3>

<p>ruptAsMat is an internal function to transform a vector giving the change
point to matrix 2 columns matrix in which each line gives the beginning and
the end of a segment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruptAsMat(vectRupt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ruptAsMat_+3A_vectrupt">vectRupt</code></td>
<td>
<p>the vector of change point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix containing the segments
</p>

<hr>
<h2 id='segclust'>Segmentation/Clustering of movement data - Generic function</h2><span id='topic+segclust'></span><span id='topic+segclust.data.frame'></span><span id='topic+segclust.Move'></span><span id='topic+segclust.ltraj'></span>

<h3>Description</h3>

<p>Joint Segmentation/Clustering of movement data. Method available for
data.frame, move and ltraj objects. The algorithm finds the optimal
segmentation for a given number of cluster and segments using an iterated
alternation of a Dynamic Programming algorithm and an
Expectation-Maximization algorithm. Among the different segmentation found,
the best one can be chosen using the maximum of a BIC penalized likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segclust(x, ...)

## S3 method for class 'data.frame'
segclust(x, ...)

## S3 method for class 'Move'
segclust(x, ...)

## S3 method for class 'ltraj'
segclust(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segclust_+3A_x">x</code></td>
<td>
<p>data.frame with observations</p>
</td></tr>
<tr><td><code id="segclust_+3A_...">...</code></td>
<td>
<p>additional parameters given to <code><a href="#topic+segclust_internal">segclust_internal</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+segmentation-class">segmentation-class</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' @examples
df &lt;-  test_data()$data
#' # data is a data.frame with column 'x' and 'y'
# Simple segmentation with automatic subsampling 
# if data has more than 1000 rows:
res &lt;- segclust(df,
 Kmax = 15, lmin = 10, ncluster = 2:4, 
 seg.var = c("x","y"))
 # Plot results
 plot(res)
 segmap(res, coord.names = c("x","y"))
 # check penalized likelihood of 
 # alternative number of segment possible. 
 # There should be a clear break if the segmentation is good
 plot_BIC(res)
## Not run: 
# Advanced options:
# Run with automatic subsampling if df has more than 500 rows:
res &lt;- segclust(df, Kmax = 30, lmin = 10, ncluster = 2:4,
                seg.var = c("x","y"), subsample_over = 500)
# Run with subsampling by 2:
res &lt;- segclust(df, Kmax = 30, lmin = 10, ncluster = 2:4,
                seg.var = c("x","y"), subsample_by = 2)
# Disable subsampling:
res &lt;- segclust(df, Kmax = 30, lmin = 10, 
                ncluster = 2:4, seg.var = c("x","y"), subsample = FALSE)
# Disabling automatic scaling of variables for segmentation (standardazing
# the variables) :
 res &lt;- segclust(df, Kmax = 30, lmin = 10,
                 seg.var = c("dist","angle"), scale.variable = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='segclust_internal'>Internal segmentation/clustering function</h2><span id='topic+segclust_internal'></span>

<h3>Description</h3>

<p>Internal segmentation/clustering function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segclust_internal(
  x,
  seg.var,
  diag.var,
  order.var,
  Kmax,
  ncluster,
  lmin,
  scale.variable,
  sameSigma = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segclust_internal_+3A_x">x</code></td>
<td>
<p>data.frame with observations</p>
</td></tr>
<tr><td><code id="segclust_internal_+3A_seg.var">seg.var</code></td>
<td>
<p>names of the variables used for
segmentation (either one or two names).</p>
</td></tr>
<tr><td><code id="segclust_internal_+3A_diag.var">diag.var</code></td>
<td>
<p>names of the variables on which
statistics are calculated.</p>
</td></tr>
<tr><td><code id="segclust_internal_+3A_order.var">order.var</code></td>
<td>
<p>names of the variable with which states are ordered.</p>
</td></tr>
<tr><td><code id="segclust_internal_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of segments.</p>
</td></tr>
<tr><td><code id="segclust_internal_+3A_ncluster">ncluster</code></td>
<td>
<p>number of cluster into which segments should be grouped. Can
be a vector if one want to test several number of clusters.</p>
</td></tr>
<tr><td><code id="segclust_internal_+3A_lmin">lmin</code></td>
<td>
<p>minimum length of segments.</p>
</td></tr>
<tr><td><code id="segclust_internal_+3A_scale.variable">scale.variable</code></td>
<td>
<p>TRUE or FALSE for automatic scaling of variables
(reduction and  centering)</p>
</td></tr>
<tr><td><code id="segclust_internal_+3A_samesigma">sameSigma</code></td>
<td>
<p>does segments have same variance ?</p>
</td></tr>
<tr><td><code id="segclust_internal_+3A_...">...</code></td>
<td>
<p>additional arguments given to <code><a href="#topic+chooseseg_lavielle">chooseseg_lavielle</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='segmap_list'><code>segmap_list</code> create maps with a list of object of <code>segmentation</code>
class</h2><span id='topic+segmap_list'></span>

<h3>Description</h3>

<p><code>segmap_list</code> create maps with a list of object of <code>segmentation</code>
class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmap_list(
  x_list,
  ncluster_list = NULL,
  nseg_list = NULL,
  pointsize = 1,
  linesize = 0.5,
  coord.names = c("x", "y")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmap_list_+3A_x_list">x_list</code></td>
<td>
<p>list of segmentation objects for different individuals or path</p>
</td></tr>
<tr><td><code id="segmap_list_+3A_ncluster_list">ncluster_list</code></td>
<td>
<p>list of number of cluster to be selected for each
individual. If empty, the function takes the default one</p>
</td></tr>
<tr><td><code id="segmap_list_+3A_nseg_list">nseg_list</code></td>
<td>
<p>list of number of segment to be selected for each
individual. If empty, the function takes the default one</p>
</td></tr>
<tr><td><code id="segmap_list_+3A_pointsize">pointsize</code></td>
<td>
<p>size of points</p>
</td></tr>
<tr><td><code id="segmap_list_+3A_linesize">linesize</code></td>
<td>
<p>size of lines</p>
</td></tr>
<tr><td><code id="segmap_list_+3A_coord.names">coord.names</code></td>
<td>
<p>names of coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 graph
</p>

<hr>
<h2 id='segmentation'>Segmentation of movement data - Generic function</h2><span id='topic+segmentation'></span><span id='topic+segmentation.data.frame'></span><span id='topic+segmentation.Move'></span><span id='topic+segmentation.ltraj'></span><span id='topic+segmentation_internal'></span>

<h3>Description</h3>

<p>Segmentation of movement data. No clustering. Method available for
data.frame,  move and ltraj object. The algorithm finds for each number of
segment the optimal segmentation using a Dynamic Programming approach. The
number of segment is then chosen using Lavielle's (2005) procedure based on
locating rupture in the penalized likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentation(x, ...)

## S3 method for class 'data.frame'
segmentation(x, ...)

## S3 method for class 'Move'
segmentation(x, ...)

## S3 method for class 'ltraj'
segmentation(x, ...)

segmentation_internal(
  x,
  seg.var,
  diag.var,
  order.var,
  lmin,
  Kmax,
  scale.variable,
  sameSigma = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmentation_+3A_x">x</code></td>
<td>
<p>data.frame with observations</p>
</td></tr>
<tr><td><code id="segmentation_+3A_...">...</code></td>
<td>
<p>additional parameters given to <a href="#topic+chooseseg_lavielle">chooseseg_lavielle</a></p>
</td></tr>
<tr><td><code id="segmentation_+3A_seg.var">seg.var</code></td>
<td>
<p>names of the variables used for
segmentation (either one or two names).</p>
</td></tr>
<tr><td><code id="segmentation_+3A_diag.var">diag.var</code></td>
<td>
<p>names of the variables on which
statistics are calculated.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_order.var">order.var</code></td>
<td>
<p>names of the variable with which states are ordered.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_lmin">lmin</code></td>
<td>
<p>minimum length of segments.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of segments.</p>
</td></tr>
<tr><td><code id="segmentation_+3A_scale.variable">scale.variable</code></td>
<td>
<p>TRUE or FALSE for automatic scaling of variables
(reduction and  centering)</p>
</td></tr>
<tr><td><code id="segmentation_+3A_samesigma">sameSigma</code></td>
<td>
<p>does segments have same variance ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+segmentation-class">segmentation-class</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;-  test_data()$data
#' # data is a data.frame with column 'x' and 'y'
# Simple segmentation with automatic subsampling
# if data has more than 1000 rows:
res &lt;- segmentation(df, Kmax = 30, lmin = 10, seg.var = c("x","y"))
 # Plot results
 plot(res)
 segmap(res)
 # check likelihood of alternative number of segment possible. There should
 # be a clear break if the segmentation is good
 plot_likelihood(res)
## Not run: 
# Advanced options:
# Run with automatic subsampling if df has more than 500 rows:
res &lt;- segmentation(df, Kmax = 30, lmin = 10,
 seg.var = c("x","y"),  subsample_over = 500)

# Run with subsampling by 2:
res &lt;- segmentation(df, Kmax = 30, lmin = 10, 
seg.var = c("x","y"), subsample_by = 2)
 
# Disable subsampling:
res &lt;- segmentation(df, Kmax = 30, lmin = 10,
 seg.var = c("x","y"), subsample = FALSE)

# Run on other kind of variables : 
 res &lt;- segmentation(df, Kmax = 30, lmin = 10, seg.var = c("dist","angle"))
 
# Automatic scaling of variables for segmentation 
(set a mean of 0 and a standard deviation of 1 for both variables)

 res &lt;- segmentation(df, Kmax = 30, lmin = 10, 
 seg.var = c("dist","angle"), scale.variable = TRUE)
 

## End(Not run)
</code></pre>

<hr>
<h2 id='segmentation-class'>segmentation class description</h2><span id='topic+segmentation-class'></span><span id='topic+print.segmentation'></span><span id='topic+plot.segmentation'></span><span id='topic+likelihood.segmentation'></span><span id='topic+plot_likelihood'></span><span id='topic+get_likelihood'></span><span id='topic+logLik.segmentation'></span><span id='topic+plot_BIC'></span><span id='topic+BIC.segmentation'></span><span id='topic+stateplot'></span><span id='topic+states'></span><span id='topic+segment'></span><span id='topic+augment.segmentation'></span><span id='topic+segmap'></span>

<h3>Description</h3>

<p>segmentation class description
</p>
<p><code>print.segmentation</code> prints object of <code>segmentation</code> class
</p>
<p><code>plot.segmentation</code> plot object of <code>segmentation</code> class -
wrapper for <code><a href="#topic+plot_segm">plot_segm</a></code>
</p>
<p><code>likelihood.segmentation</code> deprecated function for plotting likelihood
estimates of <code>segmentation</code> object. Now use <a href="#topic+plot_likelihood">plot_likelihood</a>.
</p>
<p><code>plot_likelihood</code> plot likelihood estimates of a <code>segmentation</code>
object - works only for picard segmentation.
</p>
<p><code>get_likelihood</code> returns 
likelihood estimates of a <code>segmentation</code> object.
Deprecated, now use <a href="#topic+logLik.segmentation">logLik.segmentation</a>.
</p>
<p><code>logLik.segmentation</code> returns 
log-likelihood estimates of a <code>segmentation</code> object
</p>
<p><code>plot_BIC</code> plot BIC estimates of a <code>segmentation</code> object
- works only for segclust algorithm.
</p>
<p><code>BIC</code> returns BIC-based penalized log-likelihood estimates of a
<code>segmentation</code> object when segmentation/clustering has been run.
</p>
<p><code>stateplot</code> plot state distribution of a <code>segmentation</code> object
</p>
<p><code>states</code> return data.frame with states statistics a <code>segmentation</code>
object
</p>
<p><code>segment</code> return data.frame with segment information of a
<code>segmentation</code> object
</p>
<p><code>augment.segmentation</code> return data.frame with original data and state
information of a <code>segmentation</code> object
</p>
<p><code>segmap</code> create maps with object of <code>segmentation</code> class
(interpreting latitude/longitude)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmentation'
print(x, max.level = 1, ...)

## S3 method for class 'segmentation'
plot(x, nseg, ncluster, interactive = FALSE, xcol = "indice", order, ...)

## S3 method for class 'segmentation'
likelihood(x, ...)

plot_likelihood(x)

get_likelihood(x)

## S3 method for class 'segmentation'
logLik(object, ...)

plot_BIC(x)

## S3 method for class 'segmentation'
BIC(object, ...)

stateplot(x, nseg, ncluster, order)

states(x, nseg, ncluster)

segment(x, nseg, ncluster)

## S3 method for class 'segmentation'
augment(x, nseg, ncluster, colname_state = "state", ...)

segmap(
  x,
  interactive = FALSE,
  nseg,
  ncluster,
  html = FALSE,
  scale = 1,
  width = 400,
  height = 400,
  order,
  pointsize = 1,
  linesize = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmentation-class_+3A_x">x</code></td>
<td>
<p>a <code>segmentation</code> object generated by
<code><a href="#topic+segmentation">segmentation</a></code></p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_max.level">max.level</code></td>
<td>
<p>argument to be passed to utils::str()</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_nseg">nseg</code></td>
<td>
<p>number of segment chosen</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_ncluster">ncluster</code></td>
<td>
<p>number of classes chosen</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_interactive">interactive</code></td>
<td>
<p>whether plot are 
interactive (dygraphs/leaflet) or not (ggplot2)</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_xcol">xcol</code></td>
<td>
<p>column for x axis. can be POSIXct</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_order">order</code></td>
<td>
<p>should cluster be ordered</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_object">object</code></td>
<td>
<p>a segmentation-class object, created by segclust.</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_colname_state">colname_state</code></td>
<td>
<p>column name for the added state column</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_html">html</code></td>
<td>
<p>whether htmltools::tagList should be applied on the returned
object object for integrating in html pages</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_scale">scale</code></td>
<td>
<p>for dividing coordinates to have compatibility with leaflet</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_width">width</code></td>
<td>
<p>width</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_height">height</code></td>
<td>
<p>height</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_pointsize">pointsize</code></td>
<td>
<p>size of points</p>
</td></tr>
<tr><td><code id="segmentation-class_+3A_linesize">linesize</code></td>
<td>
<p>size of lines</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(res.segclust)
plot(res.segclust, nseg = 10, ncluster = 3)

## End(Not run)

## Not run: 
plot_likelihood(res.seg)

## End(Not run)

## Not run: 
logLik(res.seg)

## End(Not run)

## Not run: 
plot_BIC(res.segclust)

## End(Not run)

## Not run: 
plot_BIC(res.segclust)

## End(Not run)

## Not run: 
stateplot(res.segclust)
stateplot(res.seg)

## End(Not run)
## Not run: 
states(res.segclust)
states(res.seg)

## End(Not run)

## Not run: 
segment(res.segclust)
segment(res.segclust, ncluster = 3, nseg = 30)
segment(res.seg)
segment(res.seg, nseg = 4)

## End(Not run)
## Not run: 
augment(res.segclust)
augment(res.segclust, ncluster = 3, nseg = 30)
augment(res.seg)
augment(res.seg, nseg = 4)

## End(Not run)
## Not run: 
segmap(res.segclust, coord.names = c("x", "y"))
segmap(res.segclust, ncluster = 3, nseg = 30)
segmap(res.seg)
segmap(res.seg, nseg = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulmode'>Simulations of behavioural mode</h2><span id='topic+simulmode'></span>

<h3>Description</h3>

<p>A dataset containing a simulation of 3 different behavioural mode
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulmode
</code></pre>


<h3>Format</h3>

<p>A data frame with 302 rows and 10 variables:
</p>

<dl>
<dt>indice</dt><dd><p>index of position</p>
</dd>
<dt>x</dt><dd><p>x coordinates</p>
</dd>
<dt>y</dt><dd><p>y coordinates</p>
</dd>
<dt>speed</dt><dd><p>smoothed speed</p>
</dd>
<dt>spatial_angle</dt><dd><p>angle at constant step length</p>
</dd>
<dt>dist</dt><dd><p>raw speed</p>
</dd>
<dt>angle</dt><dd><p>angular speed</p>
</dd>
<dt>vit_p</dt><dd><p>persistence speed</p>
</dd>
<dt>vit_r</dt><dd><p>rotation speed</p>
</dd>
<dt>vit_p_spa</dt><dd><p>persistence speed calculated with spatial angles</p>
</dd>
<dt>vit_r_spa</dt><dd><p>rotation speed calculated with spatial angles</p>
</dd>
<dt>dateTime</dt><dd><p>arbitrary date in POSIXct format</p>
</dd>
</dl>


<hr>
<h2 id='simulshift'>Simulations of home-range shift</h2><span id='topic+simulshift'></span>

<h3>Description</h3>

<p>A dataset containing a simulation of home-range shift
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulshift
</code></pre>


<h3>Format</h3>

<p>A data frame with 53940 rows and 10 variables:
</p>

<dl>
<dt>indice</dt><dd><p>index of position</p>
</dd>
<dt>x</dt><dd><p>x coordinates</p>
</dd>
<dt>y</dt><dd><p>y coordinates</p>
</dd>
<dt>dateTime</dt><dd><p>arbitrary date in POSIXct format</p>
</dd>
</dl>


<hr>
<h2 id='spatial_angle'>Calculate spatial angle along a path</h2><span id='topic+spatial_angle'></span>

<h3>Description</h3>

<p><code>spatial_angle</code> calculate spatial angle between locations, taking a
dataframe as input. Spatial angle is considered as the angle between the
focus point, the first location entering a given circle and the last location
inside.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_angle(x, coord.names = c("x", "y"), radius = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_angle_+3A_x">x</code></td>
<td>
<p>data.frame with locations</p>
</td></tr>
<tr><td><code id="spatial_angle_+3A_coord.names">coord.names</code></td>
<td>
<p>names of coordinates column in <code>x</code></p>
</td></tr>
<tr><td><code id="spatial_angle_+3A_radius">radius</code></td>
<td>
<p>for angle calculation. Default is median of step length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of spatial angle.
</p>


<h3>Author(s)</h3>

<p>Remi Patin, Simon Benhamou.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(simulmode)
spatial_angle(simulmode)

## End(Not run)
</code></pre>

<hr>
<h2 id='stat_segm'>Calculate statistics on a given segmentation</h2><span id='topic+stat_segm'></span>

<h3>Description</h3>

<p><code>stat_segm</code> calculates statistics of a given segmentation : mean and
variance of the different states. it also creates standard objects for plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_segm(
  data,
  diag.var,
  order.var = NULL,
  param = NULL,
  seg.type = NULL,
  nseg
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_segm_+3A_data">data</code></td>
<td>
<p>the data.frame with the different variable</p>
</td></tr>
<tr><td><code id="stat_segm_+3A_diag.var">diag.var</code></td>
<td>
<p>names of the variables on which statistics are calculated</p>
</td></tr>
<tr><td><code id="stat_segm_+3A_order.var">order.var</code></td>
<td>
<p>names of the variable with which states are ordered</p>
</td></tr>
<tr><td><code id="stat_segm_+3A_param">param</code></td>
<td>
<p>parameters of output segmentation</p>
</td></tr>
<tr><td><code id="stat_segm_+3A_seg.type">seg.type</code></td>
<td>
<p>either 'hybrid' or 'dynprog'</p>
</td></tr>
<tr><td><code id="stat_segm_+3A_nseg">nseg</code></td>
<td>
<p>number of segment chosen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list which first element is a data.frame with states of the
different segments and which second element is a data.frame with mean and
variance of the different states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#res.segclust is a result of a segmentation-clustering algorithm
param &lt;- res.segclust$param[["3 class"]]
nseg = 10
out &lt;- stat_segm(data, diag.var = c("dist","angle"),
 order.var = "dist", param = param, nseg=nseg, seg.type = "segclust")


## End(Not run)
</code></pre>

<hr>
<h2 id='stat_segm_HMM'>Get segment statistic for HMM model</h2><span id='topic+stat_segm_HMM'></span>

<h3>Description</h3>

<p><code>stat_segm_HMM</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_segm_HMM(data, hmm.model = NULL, diag.var, order.var = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_segm_HMM_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="stat_segm_HMM_+3A_hmm.model">hmm.model</code></td>
<td>
<p>hmm.model</p>
</td></tr>
<tr><td><code id="stat_segm_HMM_+3A_diag.var">diag.var</code></td>
<td>
<p>diag.var</p>
</td></tr>
<tr><td><code id="stat_segm_HMM_+3A_order.var">order.var</code></td>
<td>
<p>order.var</p>
</td></tr>
</table>

<hr>
<h2 id='stat_segm_shiftfit'>Get segment statistic for shiftfit model</h2><span id='topic+stat_segm_shiftfit'></span>

<h3>Description</h3>

<p><code>stat_segm_shiftfit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_segm_shiftfit(data, shiftfit.model = NULL, diag.var, order.var = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_segm_shiftfit_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="stat_segm_shiftfit_+3A_shiftfit.model">shiftfit.model</code></td>
<td>
<p>shiftfit.model</p>
</td></tr>
<tr><td><code id="stat_segm_shiftfit_+3A_diag.var">diag.var</code></td>
<td>
<p>diag.var</p>
</td></tr>
<tr><td><code id="stat_segm_shiftfit_+3A_order.var">order.var</code></td>
<td>
<p>order.var</p>
</td></tr>
</table>

<hr>
<h2 id='subsample_rename'>Internal function for subsampling</h2><span id='topic+subsample_rename'></span>

<h3>Description</h3>

<p>merge subsampled data.frame df with fulldata to add segmentation information
on the full data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample_rename(df, fulldata, colname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample_rename_+3A_df">df</code></td>
<td>
<p>subsampled data.frame with additional information on segmentation</p>
</td></tr>
<tr><td><code id="subsample_rename_+3A_fulldata">fulldata</code></td>
<td>
<p>full data.frame</p>
</td></tr>
<tr><td><code id="subsample_rename_+3A_colname">colname</code></td>
<td>
<p>column name</p>
</td></tr>
</table>

<hr>
<h2 id='test_data'>Test function generating fake data</h2><span id='topic+test_data'></span>

<h3>Description</h3>

<p>Test function generating fake data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_data()
</code></pre>

<hr>
<h2 id='wrap_dynprog_cpp'>DynProg Rcpp
DynProg computes the change points given a cost matrix matD
and a maximum number of segments Kmax</h2><span id='topic+wrap_dynprog_cpp'></span>

<h3>Description</h3>

<p>DynProg Rcpp
DynProg computes the change points given a cost matrix matD
and a maximum number of segments Kmax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_dynprog_cpp(G, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap_dynprog_cpp_+3A_g">G</code></td>
<td>
<p>the cost Matrix os size n x n</p>
</td></tr>
<tr><td><code id="wrap_dynprog_cpp_+3A_k">K</code></td>
<td>
<p>the number of segments considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with J.est a vector with Kmax value, the Kth is the minimum
contrast for a model with K segments (-J.est is the log-likelihood) and
with  t.test a matrix, line K are the coordinates of the change points for
a model with K segments
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
