<!DOCTYPE html><html><head><title>Help for package USP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {USP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coeffs'><p>Calculate coefficients of a function's series expansion</p></a></li>
<li><a href='#DiscStat'><p>Test statistic for dependence in contingency table</p></a></li>
<li><a href='#FourierBasis'><p>Fourier basis functions</p></a></li>
<li><a href='#FourierKernel'><p>Kernel matrix for Fourier basis</p></a></li>
<li><a href='#InfKern'><p>Kernel for infinite-dimensional example</p></a></li>
<li><a href='#KernStat'><p>Test statistic calculated from two kernel matrices</p></a></li>
<li><a href='#sumbasis'><p>Kernel entries in infinite dimensional case</p></a></li>
<li><a href='#USP'><p>Permutation test of independence.</p></a></li>
<li><a href='#USP.test'><p>Independence test for discrete data</p></a></li>
<li><a href='#USPFourier'><p>Independence test for continuous data</p></a></li>
<li><a href='#USPFourierAdapt'><p>Adaptive permutation test of independence for continuous data.</p></a></li>
<li><a href='#USPFunctional'><p>Independence test for functional data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>U-Statistic Permutation Tests of Independence for all Data Types</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas B. Berrett &lt;tom.berrett@warwick.ac.uk&gt; [aut,cre], Ioannis Kontoyiannis &lt;yiannis@maths.cam.ac.uk&gt; [aut], Richard J. Samworth &lt;r.samworth@statslab.cam.ac.uk&gt; [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas B. Berrett &lt;tom.berrett@warwick.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements various independence tests for discrete, continuous, and infinite-dimensional data. The tests are based on a U-statistic permutation test, the USP of Berrett, Kontoyiannis and Samworth (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2001.05513">doi:10.48550/arXiv.2001.05513</a>&gt;, and shown to be minimax rate optimal in a wide range of settings. As the permutation principle is used, all tests have exact, non-asymptotic Type I error control at the nominal level.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rdpack</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-27 09:06:28 UTC; tomberrett</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-27 09:30:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='coeffs'>Calculate coefficients of a function's series expansion</h2><span id='topic+coeffs'></span>

<h3>Description</h3>

<p>This function is used in InfKern to produce the kernel matrix from functional
data defined on the interval <code class="reqn">[0,1]</code>. For further details see Section 7.4
of (Berrett et al. 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeffs(X, Ntrunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeffs_+3A_x">X</code></td>
<td>
<p>The discretised functions whose coefficients are required.
This should be a matrix with one row per function, and with <code class="reqn">Ndisc</code> columns,
where <code class="reqn">Ndisc</code> is the grid size of the discretisation.</p>
</td></tr>
<tr><td><code id="coeffs_+3A_ntrunc">Ntrunc</code></td>
<td>
<p>The number of coefficients that are required.
The function returns coefficients 1,...,<code class="reqn">Ntrunc</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coefficients of <code class="reqn">X</code> in its expansion in terms of sine functions.
See (Berrett et al. 2021) for more detail.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t=seq(from=0,to=1,length.out=1000); X=t^2
U=coeffs(X,100)[1,]; L=5
plot(t,X,type="l")
approx=rep(0,1000)
for(l in 1:L){
approx=approx+qnorm(U[l])*sqrt(2)*sin((l-1/2)*pi*t)/((l-1/2)*pi)
lines(t,approx,col=l+1)
}
</code></pre>

<hr>
<h2 id='DiscStat'>Test statistic for dependence in contingency table</h2><span id='topic+DiscStat'></span>

<h3>Description</h3>

<p>This function computes the value of the test statistic <code class="reqn">T_n</code> measuring the strength of
dependence in a contingency table. See Section 3.1 of (Berrett et al. 2021)
for a definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiscStat(freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscStat_+3A_freq">freq</code></td>
<td>
<p>Two-way contingency table whose strength of dependence is to be measured.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the value of the test statistic <code class="reqn">T_n</code>, the table of expected
null counts, and the table of contributions to <code class="reqn">T_n</code>.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freq=r2dtable(1,rep(10,5),rep(10,5))[[1]]; DiscStat(freq)

freq=diag(1:5); DiscStat(freq)

freq=r2dtable(1,rep(10,5),rep(10,5))[[1]] + 4*diag(rep(1,5))
DiscStat(freq)
</code></pre>

<hr>
<h2 id='FourierBasis'>Fourier basis functions</h2><span id='topic+FourierBasis'></span>

<h3>Description</h3>

<p>Computes the values of the one-dimensional Fourier basis functions at a vector of locations <code class="reqn">x</code>
and with a vector of frequencies <code class="reqn">m</code>. The scaling factor of <code class="reqn">2\pi</code> is included, so that
the function returns, e.g., <code class="reqn">\sqrt{2} \cos(2\pi m x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FourierBasis(a, m, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FourierBasis_+3A_a">a</code></td>
<td>
<p>Sine or cosine; <code class="reqn">a=0</code> gives cosine and <code class="reqn">a=1</code> gives sine.</p>
</td></tr>
<tr><td><code id="FourierBasis_+3A_m">m</code></td>
<td>
<p>Vector of frequencies <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="FourierBasis_+3A_x">x</code></td>
<td>
<p>Vector of locations <code class="reqn">x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the values of <code class="reqn">\sqrt{2} \cos(2\pi m x)</code>.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e=FourierBasis(1,1:100,0.01); plot(0.01*(1:100),e,type="l")
e=FourierBasis(0,1,0.01*(1:100)); plot(0.01*(1:100),e,type="l")
FourierBasis(1,1:3,0.1*(1:10))

</code></pre>

<hr>
<h2 id='FourierKernel'>Kernel matrix for Fourier basis</h2><span id='topic+FourierKernel'></span>

<h3>Description</h3>

<p>Calculates the kernel matrix, described in (Berrett et al. 2021) for
univariate continuous data when using the Fourier basis.
This function is used in USPFourier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FourierKernel(x, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FourierKernel_+3A_x">x</code></td>
<td>
<p>A vector in <code class="reqn">[0,1]^n</code> for some <code class="reqn">n</code>, containing the observations.</p>
</td></tr>
<tr><td><code id="FourierKernel_+3A_m">M</code></td>
<td>
<p>The maximum frequency of Fourier basis functions to compute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The kernel matrix <code class="reqn">K</code>, to be used in independence testing.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=10; x=runif(n)
FourierKernel(x,5)
</code></pre>

<hr>
<h2 id='InfKern'>Kernel for infinite-dimensional example</h2><span id='topic+InfKern'></span>

<h3>Description</h3>

<p>Function to produce the kernel matrices in the infinite dimensional example described
in Section 7.4 of (Berrett et al. 2021). Here, a random function is converted to a sequence
of coefficients and we use the Fourier basis on these coefficients. This function is
an essential part of USPFunctional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InfKern(X, Ntrunc, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InfKern_+3A_x">X</code></td>
<td>
<p>Matrix giving one of the samples to be tested. Each row corresponds to a
discretised function, with each column giving the values of the functions at the
corresponding grid point.</p>
</td></tr>
<tr><td><code id="InfKern_+3A_ntrunc">Ntrunc</code></td>
<td>
<p>The total number of coefficients to look at in the basis expansion
of the functional data.</p>
</td></tr>
<tr><td><code id="InfKern_+3A_m">M</code></td>
<td>
<p>The maximum frequency to look at in the Fourier basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The kernel matrix for the sample <code class="reqn">X</code>.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=10  #number of observations
Ndisc=1000; t=1/Ndisc #functions represented at grid points 1/Ndisc, 2/Ndisc,...,1
X=matrix(rep(0,Ndisc*n),nrow=n)
for(i in 1:n){
 x=rnorm(Ndisc,mean=0,sd=1)
 X[i,]=cumsum(x*sqrt(t))
}
InfKern(X,2,2)
</code></pre>

<hr>
<h2 id='KernStat'>Test statistic calculated from two kernel matrices</h2><span id='topic+KernStat'></span>

<h3>Description</h3>

<p>Calculate the U-statistic measure of dependence given two kernel matrices <code class="reqn">J</code>
and <code class="reqn">K</code>, as described in Section 7.1 of (Berrett et al. 2021). For the featured
examples considered these matrices can be calculated using FourierKernel or
InfKern. Alternatively, if a different basis is to be used, then the kernels
can be entered separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KernStat(J, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KernStat_+3A_j">J</code></td>
<td>
<p><code class="reqn">n \times n</code> kernel matrix corresponding to first sample.</p>
</td></tr>
<tr><td><code id="KernStat_+3A_k">K</code></td>
<td>
<p><code class="reqn">n \times n</code> kernel matrix corresponding to second sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Test statistic measure the strength of dependence between the two samples.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=runif(100); y=runif(100); M=3
J=FourierKernel(x,M); K=FourierKernel(y,M)
KernStat(J,K)
</code></pre>

<hr>
<h2 id='sumbasis'>Kernel entries in infinite dimensional case</h2><span id='topic+sumbasis'></span>

<h3>Description</h3>

<p>Function to calculate each entry of the kernel matrix in the infinite dimensional
example described in Section 7.4 of (Berrett et al. 2021). Here, a random function is converted
to a sequence of coefficients and we use the Fourier basis on these coefficients. This
function is only used in the function InfKern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumbasis(Ntrunc, M, x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumbasis_+3A_ntrunc">Ntrunc</code></td>
<td>
<p>The total number of coefficients to look at.</p>
</td></tr>
<tr><td><code id="sumbasis_+3A_m">M</code></td>
<td>
<p>The maximum frequency to look at in the Fourier basis.</p>
</td></tr>
<tr><td><code id="sumbasis_+3A_x1">x1</code></td>
<td>
<p>The coefficients of the first data point.</p>
</td></tr>
<tr><td><code id="sumbasis_+3A_x2">x2</code></td>
<td>
<p>The coefficients of the second data point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The entry of the kernel corresponding to the two data points.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1=runif(5); x2=runif(5); sumbasis(5,2,x1,x2)
</code></pre>

<hr>
<h2 id='USP'>Permutation test of independence.</h2><span id='topic+USP'></span>

<h3>Description</h3>

<p>Carry out an independence test of the independence of two samples, give
two kernel matrices <code class="reqn">J</code> and <code class="reqn">K</code>, as described in Section 7.1 of (Berrett et al. 2021).
We calculate the test statistic and null statistics using the function KernStat,
before comparing them to produce a p-value. For the featured
examples considered these matrices can be calculated using FourierKernel or
InfKern. Alternatively, if a different basis is to be used, then the kernels
can be entered separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USP(J, K, B = 999, ties.method = "standard", nullstats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="USP_+3A_j">J</code></td>
<td>
<p><code class="reqn">n \times n </code> kernel matrix corresponding to first sample.</p>
</td></tr>
<tr><td><code id="USP_+3A_k">K</code></td>
<td>
<p><code class="reqn">n \times n </code> kernel matrix corresponding to second sample.</p>
</td></tr>
<tr><td><code id="USP_+3A_b">B</code></td>
<td>
<p>The number of permutation used to calibrate the test.</p>
</td></tr>
<tr><td><code id="USP_+3A_ties.method">ties.method</code></td>
<td>
<p>If &quot;standard&quot; then calculate the p-value as in (5) of (Berrett et al. 2021),
which is slightly conservative. If &quot;random&quot; then break ties randomly. This preserves Type I error
control.</p>
</td></tr>
<tr><td><code id="USP_+3A_nullstats">nullstats</code></td>
<td>
<p>If TRUE, returns a vector of the null statistic values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the p-value for this independence test and the value of the test statistic, <code class="reqn">D_n</code>,
as defined in (Berrett et al. 2021). If nullstats=TRUE is used, then the function also
returns a vector of the null statistics.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=runif(100); y=runif(100); M=3
J=FourierKernel(x,M); K=FourierKernel(y,M)
USP(J,K,999)

n=50; r=0.6; Ndisc=1000; t=1/Ndisc
X=matrix(rep(0,Ndisc*n),nrow=n); Y=matrix(rep(0,Ndisc*n),nrow=n)
for(i in 1:n){
 x = rnorm(Ndisc, mean=0, sd= 1)
 se = sqrt(1 - r^2) #standard deviation of error
 e = rnorm(Ndisc, mean=0, sd=se)
 y = r*x + e
 X[i,] = cumsum(x*sqrt(t))
 Y[i,] = cumsum(y*sqrt(t))
}
J=InfKern(X,2,1); K=InfKern(Y,2,1)
USP(J,K,999)
</code></pre>

<hr>
<h2 id='USP.test'>Independence test for discrete data</h2><span id='topic+USP.test'></span>

<h3>Description</h3>

<p>Carry out a permutation independence test on a two-way contingency table.
The test statistic is <code class="reqn">Tn</code>, as described in Sections 3.1 and 7.1 of (Berrett et al. 2021).
This also appears as <code class="reqn">Un</code> in (Berrett and Samworth 2021).
The critical value is found by sampling null contingency tables,
with the same row and column totals as the input, via Patefield's algorithm, and recomputing
the test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USP.test(freq, B = 999, ties.method = "standard", nullstats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="USP.test_+3A_freq">freq</code></td>
<td>
<p>Two-way contingency table whose independence is to be tested.</p>
</td></tr>
<tr><td><code id="USP.test_+3A_b">B</code></td>
<td>
<p>The number of resampled null tables to be used to calibrate the test.</p>
</td></tr>
<tr><td><code id="USP.test_+3A_ties.method">ties.method</code></td>
<td>
<p>If &quot;standard&quot; then calculate the p-value as in (5) of (Berrett et al. 2021),
which is slightly conservative. If &quot;random&quot; then break ties randomly. This preserves Type I error
control.</p>
</td></tr>
<tr><td><code id="USP.test_+3A_nullstats">nullstats</code></td>
<td>
<p>If TRUE, returns a vector of the null statistic values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the p-value for this independence test and the value of the test statistic, <code class="reqn">T_n</code>,
as defined in (Berrett et al. 2021). The third element of the list is the table of expected counts,
and the final element is the table of contributions to <code class="reqn">T_n</code>. If nullstats=TRUE is used, then the function also
returns a vector of the null statistics.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>
<p>Berrett TB, Samworth RJ (2021).
&ldquo;USP: an independence test that improves on Pearson’s chi-squared and the G-test.&rdquo;
<em>Submitted, available at arXiv:2101.10880</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freq=r2dtable(1,rep(10,5),rep(10,5))[[1]] + 4*diag(rep(1,5))
USP.test(freq,999)

freq=diag(1:5); USP.test(freq,999)

freq=r2dtable(1,rep(10,5),rep(10,5))[[1]];
test=USP.test(freq,999,nullstats=TRUE)
plot(density(test$NullStats,from=0,
to=max(max(test$NullStats),test$TestStat)),
    xlim=c(min(test$NullStats),max(max(test$NullStats),test$TestStat)),
    main="Test Statistics")
abline(v=test$TestStat,col=2); TestStats=c(test$TestStat,test$NullStats)
abline(v=quantile(TestStats,probs=0.95),lty=2)
</code></pre>

<hr>
<h2 id='USPFourier'>Independence test for continuous data</h2><span id='topic+USPFourier'></span>

<h3>Description</h3>

<p>Performs a permutation test of independence between two univariate continuous random
variables, using the Fourier basis to construct the test statistic, as described in
(Berrett et al. 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USPFourier(x, y, M, B = 999, ties.method = "standard", nullstats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="USPFourier_+3A_x">x</code></td>
<td>
<p>A vector containing the first sample, with each entry in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="USPFourier_+3A_y">y</code></td>
<td>
<p>A vector containing the second sample, with each entry in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="USPFourier_+3A_m">M</code></td>
<td>
<p>The maximum frequency to use in the Fourier basis.</p>
</td></tr>
<tr><td><code id="USPFourier_+3A_b">B</code></td>
<td>
<p>The number of permutation to use when calibrating the test.</p>
</td></tr>
<tr><td><code id="USPFourier_+3A_ties.method">ties.method</code></td>
<td>
<p>If &quot;standard&quot; then calculate the p-value as in (5) of (Berrett et al. 2021),
which is slightly conservative. If &quot;random&quot; then break ties randomly. This preserves Type I error
control.</p>
</td></tr>
<tr><td><code id="USPFourier_+3A_nullstats">nullstats</code></td>
<td>
<p>If TRUE, returns a vector of the null statistic values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the p-value for this independence test and the value of the test statistic, <code class="reqn">D_n</code>,
as defined in (Berrett et al. 2021). If nullstats=TRUE is used, then the function also
returns a vector of the null statistics.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=runif(10); y=x^2
USPFourier(x,y,1,999)

n=100; w=2; x=integer(n); y=integer(n); m=300
unifdata=matrix(runif(2*m,min=0,max=1),ncol=2); x1=unifdata[,1]; y1=unifdata[,2]
unif=runif(m); prob=0.5*(1+sin(2*pi*w*x1)*sin(2*pi*w*y1)); accept=(unif&lt;prob);
Data1=unifdata[accept,]; x=Data1[1:n,1]; y=Data1[1:n,2]
plot(x,y)
USPFourier(x,y,2,999)

x=runif(100); y=runif(100)
test=USPFourier(x,y,3,999,nullstats=TRUE)
plot(density(test$NullStats,from=min(test$NullStats),to=max(max(test$NullStats),test$TestStat)),
         xlim=c(min(test$NullStats),max(max(test$NullStats),test$TestStat)),main="Test Statistics")
abline(v=test$TestStat,col=2); TestStats=c(test$TestStat,test$NullStats)
abline(v=quantile(TestStats,probs=0.95),lty=2)
</code></pre>

<hr>
<h2 id='USPFourierAdapt'>Adaptive permutation test of independence for continuous data.</h2><span id='topic+USPFourierAdapt'></span>

<h3>Description</h3>

<p>We implement the adaptive version of the independence test for univariate continuous data
using the Fourier basis, as described in Section 4 of (Berrett et al. 2021). This applies
USPFourier with a range of values of <code class="reqn">M</code>, and a properly corrected significance
level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USPFourierAdapt(x, y, alpha, B = 999, ties.method = "standard")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="USPFourierAdapt_+3A_x">x</code></td>
<td>
<p>The vector of data points from the first sample, each entry belonging to <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="USPFourierAdapt_+3A_y">y</code></td>
<td>
<p>The vector of data points from the second sample, each entry belonging to <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="USPFourierAdapt_+3A_alpha">alpha</code></td>
<td>
<p>The desired significance level of the test.</p>
</td></tr>
<tr><td><code id="USPFourierAdapt_+3A_b">B</code></td>
<td>
<p>Controls the number of permutations to be used. With a sample size of <code class="reqn">n</code>  each
test uses <code class="reqn">B \log_2 n</code> permutations. If <code class="reqn">B+1 &lt; 1/\alpha</code> then it is not possible to reject
the null hypothesis.</p>
</td></tr>
<tr><td><code id="USPFourierAdapt_+3A_ties.method">ties.method</code></td>
<td>
<p>If &quot;standard&quot; then calculate the p-value as in (5) of (Berrett et al. 2021),
which is slightly conservative. If &quot;random&quot; then break ties randomly. This preserves Type I error
control.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an indicator with value 1 if the null hypothesis of independence is rejected and
0 otherwise. If the null hypothesis is rejected, the function also outputs the value of <code class="reqn">M</code>
at the which the null was rejected and the value of the test statistic.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100; w=2; x=integer(n); y=integer(n); m=300
unifdata=matrix(runif(2*m,min=0,max=1),ncol=2); x1=unifdata[,1]; y1=unifdata[,2]
unif=runif(m); prob=0.5*(1+sin(2*pi*w*x1)*sin(2*pi*w*y1)); accept=(unif&lt;prob);
Data1=unifdata[accept,]; x=Data1[1:n,1]; y=Data1[1:n,2]
plot(x,y)
USPFourierAdapt(x,y,0.05,999)
</code></pre>

<hr>
<h2 id='USPFunctional'>Independence test for functional data</h2><span id='topic+USPFunctional'></span>

<h3>Description</h3>

<p>We implement the permutation independence test described in (Berrett et al. 2021)
for functional data taking values in <code class="reqn">L^2([0,1])</code>. The discretised functions are
expressed in a series expansion, and an independence test is carried out between the
coefficients of the functions, using a Fourier basis to define the test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USPFunctional(X, Y, Ntrunc, M, B = 999, ties.method = "standard")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="USPFunctional_+3A_x">X</code></td>
<td>
<p>A matrix of the discretised functional data from the first sample. There are <code class="reqn">n</code> rows,
where <code class="reqn">n</code> is the sample size, and Ndisc columns, where Ndisc is the grid size such
that the values of each function on 1/Ndisc, 2/Ndisc, ..., 1 are given.</p>
</td></tr>
<tr><td><code id="USPFunctional_+3A_y">Y</code></td>
<td>
<p>A matrix of the discretised functional data from the second sample. The discretisation
grid may be different to the grid used for <code class="reqn">X</code>, if required.</p>
</td></tr>
<tr><td><code id="USPFunctional_+3A_ntrunc">Ntrunc</code></td>
<td>
<p>The number of coefficients to retain from the series expansions of <code class="reqn">X</code> and <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="USPFunctional_+3A_m">M</code></td>
<td>
<p>The maximum frequency to use in the Fourier basis when testing the independence of the
coefficients.</p>
</td></tr>
<tr><td><code id="USPFunctional_+3A_b">B</code></td>
<td>
<p>The number of permutations used to calibrate the test.</p>
</td></tr>
<tr><td><code id="USPFunctional_+3A_ties.method">ties.method</code></td>
<td>
<p>If &quot;standard&quot; then calculate the p-value as in (5) of (Berrett et al. 2021),
which is slightly conservative. If &quot;random&quot; then break ties randomly. This preserves Type I error
control.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A p-value for the test of the independence of <code class="reqn">X</code> and <code class="reqn">Y</code>.
</p>


<h3>References</h3>

<p>Berrett TB, Kontoyiannis I, Samworth RJ (2021).
&ldquo;Optimal rates for independence testing via U-statistic permutation tests.&rdquo;
<em>Annals of Statistics, to appear</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=50; r=0.6; Ndisc=1000; t=1/Ndisc
X=matrix(rep(0,Ndisc*n),nrow=n); Y=matrix(rep(0,Ndisc*n),nrow=n)
for(i in 1:n){
 x = rnorm(Ndisc, mean=0, sd= 1)
 se = sqrt(1 - r^2) #standard deviation of error
 e = rnorm(Ndisc, mean=0, sd=se)
 y = r*x + e
 X[i,] &lt;- cumsum(x*sqrt(t))
 Y[i,] &lt;- cumsum(y*sqrt(t))
}
USPFunctional(X,Y,2,1,999)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
