<!DOCTYPE html><html><head><title>Help for package spocc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spocc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.ala'><p>Coerce occurrence keys to ALA id objects</p></a></li>
<li><a href='#as.ecoengine'><p>Coerce occurrence keys to ecoenginekey/occkey objects</p></a></li>
<li><a href='#as.gbif'><p>Coerce occurrence keys to gbifkey/occkey objects</p></a></li>
<li><a href='#as.idigbio'><p>Coerce occurrence keys to idigbio objects</p></a></li>
<li><a href='#as.inat'><p>Coerce occurrence keys to iNaturalist id objects</p></a></li>
<li><a href='#as.obis'><p>Coerce occurrence keys to obis id objects</p></a></li>
<li><a href='#as.vertnet'><p>Coerce occurrence keys to vertnetkey/occkey objects</p></a></li>
<li><a href='#bbox2wkt'><p>Convert a bounding box to a Well Known Text polygon, and a WKT to a</p>
bounding box</a></li>
<li><a href='#fixnames'><p>Change names to be the same for each taxon.</p></a></li>
<li><a href='#inspect'><p>Get more data on individual occurrences</p></a></li>
<li><a href='#obis_search'><p>OBIS search</p></a></li>
<li><a href='#occ'><p>Search for species occurrence data across many data sources.</p></a></li>
<li><a href='#occ_coverage'><p>Automatically generate coverages for a spocc search</p></a></li>
<li><a href='#occ_names'><p>Search for species names across many data sources.</p></a></li>
<li><a href='#occ_names_options'><p>Look up options for parameters passed to each source for occ_names function</p></a></li>
<li><a href='#occ_options'><p>Look up options for parameters passed to each source</p></a></li>
<li><a href='#occ2df'><p>Combine results from occ calls to a single data.frame</p></a></li>
<li><a href='#spocc_capwords'><p>Capitalize the first letter of a character string.</p></a></li>
<li><a href='#spocc_duplicates'><p>A note about duplicate occurrence records</p></a></li>
<li><a href='#spocc_objects'><p>spocc objects and their print, plot, and summary methods</p></a></li>
<li><a href='#spocc-package'><p>Interface to many species occurrence data sources</p></a></li>
<li><a href='#wkt_vis'><p>Visualize well-known text area's on a map.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interface to Species Occurrence Data Sources</td>
</tr>
<tr>
<td>Description:</td>
<td>A programmatic interface to many species occurrence data sources,
    including Global Biodiversity Information Facility ('GBIF'), 'iNaturalist',
    'eBird', Integrated Digitized 'Biocollections' ('iDigBio'), 'VertNet', 
    Ocean 'Biogeographic' Information System ('OBIS'), and 
    Atlas of Living Australia ('ALA'). Includes functionality for retrieving
    species occurrence data, and combining those data.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/spocc">https://github.com/ropensci/spocc</a> (devel),
<a href="https://docs.ropensci.org/spocc/">https://docs.ropensci.org/spocc/</a> (user manual)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/spocc/issues/">https://github.com/ropensci/spocc/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, rgbif, rebird, rvertnet, ridigbio, lubridate, crul,
whisker, jsonlite, data.table, tibble, wk, s2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, taxize, vcr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Biodiversity</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>specimens, API, web-services, occurrences,
species, taxonomy, GBIF, INAT, Vertnet, eBird, iDigBio, OBIS,
ALA</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>ropensci.org</td>
</tr>
<tr>
<td>Config/Needs/sftests:</td>
<td>remotes, silicate, sf, sp, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 14:16:54 UTC; HannahOwens</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannah Owens <a href="https://orcid.org/0000-0003-0071-1745"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Vijay Barve <a href="https://orcid.org/0000-0002-4852-2567"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Karthik Ram [ctb],
  Ted Hart [ctb],
  rOpenSci [fnd] (ropensci.org/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hannah Owens &lt;hannah.owens@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.ala'>Coerce occurrence keys to ALA id objects</h2><span id='topic+as.ala'></span>

<h3>Description</h3>

<p>Coerce occurrence keys to ALA id objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ala(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ala_+3A_x">x</code></td>
<td>
<p>Various inputs, including the output from a call to
<code><a href="#topic+occ">occ()</a></code> (class occdat), <code><a href="#topic+occ2df">occ2df()</a></code> (class data.frame),
or a list, numeric, alakey, or occkey.</p>
</td></tr>
<tr><td><code id="as.ala_+3A_...">...</code></td>
<td>
<p>curl options; named parameters passed on to <code><a href="crul.html#topic+HttpClient">crul::HttpClient()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>One or more in a list of both class alakey and occkey
</p>


<h3>See Also</h3>

<p>Other coercion: 
<code><a href="#topic+as.gbif">as.gbif</a>()</code>,
<code><a href="#topic+as.idigbio">as.idigbio</a>()</code>,
<code><a href="#topic+as.inat">as.inat</a>()</code>,
<code><a href="#topic+as.obis">as.obis</a>()</code>,
<code><a href="#topic+as.vertnet">as.vertnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spnames &lt;- c('Barnardius zonarius', 'Grus rubicunda', 'Cracticus tibicen')
out &lt;- occ(query=spnames, from='ala', limit=2)
(res &lt;- occ2df(out))
(tt &lt;- as.ala(out))
as.ala(x = res$key[1])

## End(Not run)
</code></pre>

<hr>
<h2 id='as.ecoengine'>Coerce occurrence keys to ecoenginekey/occkey objects</h2><span id='topic+as.ecoengine'></span>

<h3>Description</h3>

<p>DEFUNCT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ecoengine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ecoengine_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='as.gbif'>Coerce occurrence keys to gbifkey/occkey objects</h2><span id='topic+as.gbif'></span>

<h3>Description</h3>

<p>Coerce occurrence keys to gbifkey/occkey objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.gbif(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.gbif_+3A_x">x</code></td>
<td>
<p>Various inputs, including the output from a call to
<code><a href="#topic+occ">occ()</a></code> (class occdat), <code><a href="#topic+occ2df">occ2df()</a></code> (class data.frame),
or a list, numeric, character, gbifkey, or occkey.</p>
</td></tr>
<tr><td><code id="as.gbif_+3A_...">...</code></td>
<td>
<p>curl options; named parameters passed on to <code><a href="crul.html#topic+HttpClient">crul::HttpClient()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, we use <code><a href="rgbif.html#topic+occ_get">rgbif::occ_get()</a></code>, whereas
<code><a href="#topic+occ">occ()</a></code> uses <code><a href="rgbif.html#topic+occ_data">rgbif::occ_data()</a></code>. We can use
<code><a href="rgbif.html#topic+occ_get">rgbif::occ_get()</a></code> here because we have the occurrence key to
go directly to the occurrence record.
</p>


<h3>Value</h3>

<p>One or more in a list of both class gbifkey and occkey
</p>


<h3>See Also</h3>

<p>Other coercion: 
<code><a href="#topic+as.ala">as.ala</a>()</code>,
<code><a href="#topic+as.idigbio">as.idigbio</a>()</code>,
<code><a href="#topic+as.inat">as.inat</a>()</code>,
<code><a href="#topic+as.obis">as.obis</a>()</code>,
<code><a href="#topic+as.vertnet">as.vertnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spnames &lt;- c('Accipiter striatus', 'Setophaga caerulescens', 
  'Spinus tristis')
out &lt;- occ(query=spnames, from=c('gbif','ebird'), 
  gbifopts=list(hasCoordinate=TRUE), limit=2)
res &lt;- occ2df(out)
(tt &lt;- as.gbif(out))
(uu &lt;- as.gbif(res))
as.gbif(as.numeric(res$key[1]))
as.gbif(res$key[1])
as.gbif(as.list(res$key[1:2]))
as.gbif(tt[[1]])
as.gbif(uu[[1]])
as.gbif(tt[1:2])

## End(Not run)
</code></pre>

<hr>
<h2 id='as.idigbio'>Coerce occurrence keys to idigbio objects</h2><span id='topic+as.idigbio'></span>

<h3>Description</h3>

<p>Coerce occurrence keys to idigbio objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.idigbio(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.idigbio_+3A_x">x</code></td>
<td>
<p>Various inputs, including the output from a call to <code><a href="#topic+occ">occ()</a></code>
(class occdat), <code><a href="#topic+occ2df">occ2df()</a></code> (class data.frame), or a list, numeric,
character, idigbiokey, or occkey.</p>
</td></tr>
<tr><td><code id="as.idigbio_+3A_...">...</code></td>
<td>
<p>curl options; named parameters passed on to <code>httr::GET()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, we use <code>idig_view_records</code>, whereas we use
<code>idig_search_records()</code> in the <code><a href="#topic+occ">occ()</a></code> function.
</p>


<h3>Value</h3>

<p>One or more in a list of both class idigbiokey and occkey
</p>


<h3>See Also</h3>

<p>Other coercion: 
<code><a href="#topic+as.ala">as.ala</a>()</code>,
<code><a href="#topic+as.gbif">as.gbif</a>()</code>,
<code><a href="#topic+as.inat">as.inat</a>()</code>,
<code><a href="#topic+as.obis">as.obis</a>()</code>,
<code><a href="#topic+as.vertnet">as.vertnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spnames &lt;- c('Accipiter striatus', 'Setophaga caerulescens',
  'Spinus tristis')
out &lt;- occ(query=spnames, from='idigbio', limit=2)
res &lt;- occ2df(out)
(tt &lt;- as.idigbio(out))
(uu &lt;- as.idigbio(res))
as.idigbio(res$key[1])
as.idigbio(as.list(res$key[1:2]))
as.idigbio(tt[[1]])
as.idigbio(uu[[1]])
as.idigbio(tt[1:2])

library("dplyr")
bind_rows(lapply(tt, function(x) data.frame(unclass(x)$data)))

## End(Not run)
</code></pre>

<hr>
<h2 id='as.inat'>Coerce occurrence keys to iNaturalist id objects</h2><span id='topic+as.inat'></span>

<h3>Description</h3>

<p>Coerce occurrence keys to iNaturalist id objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.inat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.inat_+3A_x">x</code></td>
<td>
<p>Various inputs, including the output from a call to
<code><a href="#topic+occ">occ()</a></code> (class occdat), <code><a href="#topic+occ2df">occ2df()</a></code> (class data.frame), or a list, numeric,
character, inatkey, or occkey.</p>
</td></tr>
<tr><td><code id="as.inat_+3A_...">...</code></td>
<td>
<p>curl options; named parameters passed on to <code><a href="crul.html#topic+HttpClient">crul::HttpClient()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>One or more in a list of both class inatkey and occkey
</p>


<h3>See Also</h3>

<p>Other coercion: 
<code><a href="#topic+as.ala">as.ala</a>()</code>,
<code><a href="#topic+as.gbif">as.gbif</a>()</code>,
<code><a href="#topic+as.idigbio">as.idigbio</a>()</code>,
<code><a href="#topic+as.obis">as.obis</a>()</code>,
<code><a href="#topic+as.vertnet">as.vertnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spnames &lt;- c('Accipiter striatus', 'Setophaga caerulescens',
  'Spinus tristis')
out &lt;- occ(query=spnames, from='inat', limit=2)
res &lt;- occ2df(out)
(tt &lt;- as.inat(out))
(uu &lt;- as.inat(res))
as.inat(res$key[1])
as.inat(as.list(res$key[1:2]))
as.inat(tt[[1]])
as.inat(uu[[1]])
as.inat(tt[1:2])

## End(Not run)
</code></pre>

<hr>
<h2 id='as.obis'>Coerce occurrence keys to obis id objects</h2><span id='topic+as.obis'></span>

<h3>Description</h3>

<p>Coerce occurrence keys to obis id objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.obis(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.obis_+3A_x">x</code></td>
<td>
<p>Various inputs, including the output from a call to
<code><a href="#topic+occ">occ()</a></code> (class occdat), <code><a href="#topic+occ2df">occ2df()</a></code> (class data.frame),
or a list, numeric, obiskey, or occkey.</p>
</td></tr>
<tr><td><code id="as.obis_+3A_...">...</code></td>
<td>
<p>curl options; named parameters passed on to <code><a href="crul.html#topic+HttpClient">crul::HttpClient()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>One or more in a list of both class obiskey and occkey
</p>


<h3>See Also</h3>

<p>Other coercion: 
<code><a href="#topic+as.ala">as.ala</a>()</code>,
<code><a href="#topic+as.gbif">as.gbif</a>()</code>,
<code><a href="#topic+as.idigbio">as.idigbio</a>()</code>,
<code><a href="#topic+as.inat">as.inat</a>()</code>,
<code><a href="#topic+as.vertnet">as.vertnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spnames &lt;- c('Mola mola', 'Loligo vulgaris', 'Stomias boa')
out &lt;- occ(query=spnames, from='obis', limit=2)
(res &lt;- occ2df(out))
(tt &lt;- as.obis(out))
(uu &lt;- as.obis(res))
as.obis(x = res$key[1])
as.obis(as.list(res$key[1:2]))
as.obis(tt[[1]])
as.obis(uu[[1]])
as.obis(tt[1:2])

library("data.table")
rbindlist(lapply(tt, "[[", "results"),
  use.names = TRUE, fill = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.vertnet'>Coerce occurrence keys to vertnetkey/occkey objects</h2><span id='topic+as.vertnet'></span>

<h3>Description</h3>

<p>Coerce occurrence keys to vertnetkey/occkey objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.vertnet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.vertnet_+3A_x">x</code></td>
<td>
<p>Various inputs, including the output from a call to <code><a href="#topic+occ">occ()</a></code>
(class occdat), <code><a href="#topic+occ2df">occ2df()</a></code> (class data.frame), or a list, numeric,
character, vertnetkey, or occkey.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, we use <code><a href="rvertnet.html#topic+vert_id">rvertnet::vert_id()</a></code>, whereas <code><a href="#topic+occ">occ()</a></code>
uses <code><a href="rvertnet.html#topic+vertsearch">rvertnet::vertsearch()</a></code>.
</p>


<h3>Value</h3>

<p>One or more in a list of both class vertnetkey and occkey
</p>


<h3>See Also</h3>

<p>Other coercion: 
<code><a href="#topic+as.ala">as.ala</a>()</code>,
<code><a href="#topic+as.gbif">as.gbif</a>()</code>,
<code><a href="#topic+as.idigbio">as.idigbio</a>()</code>,
<code><a href="#topic+as.inat">as.inat</a>()</code>,
<code><a href="#topic+as.obis">as.obis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# spnames &lt;- c('Accipiter striatus', 'Setophaga caerulescens',
#   'Spinus tristis')
# out &lt;- occ(query=spnames, from='vertnet', has_coords=TRUE, limit=2)
# res &lt;- occ2df(out)
# (tt &lt;- as.vertnet(out))
# (uu &lt;- as.vertnet(res))
# keys &lt;- Filter(Negate(is.na), res$key)
# as.vertnet(keys[1])
# as.vertnet(as.list(keys[1:2]))
# as.vertnet(tt[[1]])
# as.vertnet(uu[[1]])
# as.vertnet(tt[1:2])

## End(Not run)
</code></pre>

<hr>
<h2 id='bbox2wkt'>Convert a bounding box to a Well Known Text polygon, and a WKT to a
bounding box</h2><span id='topic+bbox2wkt'></span><span id='topic+wkt2bbox'></span>

<h3>Description</h3>

<p>Convert a bounding box to a Well Known Text polygon, and a WKT to a
bounding box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox2wkt(minx = NA, miny = NA, maxx = NA, maxy = NA, bbox = NULL)

wkt2bbox(wkt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox2wkt_+3A_minx">minx</code></td>
<td>
<p>Minimum x value, or the most western longitude</p>
</td></tr>
<tr><td><code id="bbox2wkt_+3A_miny">miny</code></td>
<td>
<p>Minimum y value, or the most southern latitude</p>
</td></tr>
<tr><td><code id="bbox2wkt_+3A_maxx">maxx</code></td>
<td>
<p>Maximum x value, or the most eastern longitude</p>
</td></tr>
<tr><td><code id="bbox2wkt_+3A_maxy">maxy</code></td>
<td>
<p>Maximum y value, or the most northern latitude</p>
</td></tr>
<tr><td><code id="bbox2wkt_+3A_bbox">bbox</code></td>
<td>
<p>A vector of length 4, with the elements: minx, miny, maxx, maxy</p>
</td></tr>
<tr><td><code id="bbox2wkt_+3A_wkt">wkt</code></td>
<td>
<p>A Well Known Text string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bbox2wkt returns an object of class charactere, a Well Known Text
string of the form
'POLYGON((minx miny, maxx miny, maxx maxy, minx maxy, minx miny))'
</p>
<p>wkt2bbox returns a numeric vector of length 4, like c(minx, miny,
maxx, maxy).
</p>


<h3>See Also</h3>

<p>Other bbox: 
<code><a href="#topic+wkt_vis">wkt_vis</a>()</code>
</p>
<p>Other bbox: 
<code><a href="#topic+wkt_vis">wkt_vis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a bounding box to a WKT

## Pass in a vector of length 4 with all values
bbox2wkt(bbox = c(-125.0,38.4,-121.8,40.9))

## Or pass in each value separately
bbox2wkt(-125.0, 38.4, -121.8, 40.9)

# Convert a WKT object to a bounding box
wkt &lt;- "POLYGON((-125 38.4,-125 40.9,-121.8 40.9,-121.8 38.4,-125 38.4))"
wkt2bbox(wkt)

identical(
 bbox2wkt(-125.0, 38.4, -121.8, 40.9),
 "POLYGON((-125 38.4,-121.8 38.4,-121.8 40.9,-125 40.9,-125 38.4))"
)

identical(
 c(-125.0, 38.4, -121.8, 40.9),
 as.numeric(
   wkt2bbox(
     "POLYGON((-125 38.4,-125 40.9,-121.8 40.9,-121.8 38.4,-125 38.4))"
   )
 )
)
</code></pre>

<hr>
<h2 id='fixnames'>Change names to be the same for each taxon.</h2><span id='topic+fixnames'></span>

<h3>Description</h3>

<p>DEFUNT: This function has moved to <code>scrubr::fix_names</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixnames(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixnames_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='inspect'>Get more data on individual occurrences</h2><span id='topic+inspect'></span><span id='topic+inspect.data.frame'></span><span id='topic+inspect.occdat'></span><span id='topic+inspect.occkey'></span>

<h3>Description</h3>

<p>Fetches the complete record, which may or may not be the same
as requested through <code><a href="#topic+occ">occ()</a></code>. Some data providers have different ways
to retrieve many occurrence records vs. single occurrence records -
and sometimes the results are more verbose when retrieving a
single occurrence record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect(x, from = "gbif")

## S3 method for class 'data.frame'
inspect(x, from = "gbif")

## S3 method for class 'occdat'
inspect(x, from = "gbif")

## S3 method for class 'occkey'
inspect(x, from = "gbif")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect_+3A_x">x</code></td>
<td>
<p>The output from <code><a href="#topic+occ">occ()</a></code> call, output from call to
<code><a href="#topic+occ2df">occ2df()</a></code>, or an occurrence ID as a occkey class.</p>
</td></tr>
<tr><td><code id="inspect_+3A_from">from</code></td>
<td>
<p>(character) The data provider. One of gbif, inat,
or vertnet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, with each slot named for the data source, and then
within data sources is a slot for each taxon, named by it's occurrence ID.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spnames &lt;- c('Accipiter striatus', 'Spinus tristis')
out &lt;- occ(query=spnames, from=c('gbif','idigbio'),
   gbifopts=list(hasCoordinate=TRUE), limit=2)
res &lt;- occ2df(out)
inspect(res)

out &lt;- occ(query=spnames, from='gbif', gbifopts=list(hasCoordinate=TRUE),
  limit=4)
res &lt;- occ2df(out)
inspect(res)

# from occkeys
key &lt;- as.gbif(res$key[1])
inspect(key)

# idigbio
spnames &lt;- c('Accipiter striatus', 'Spinus tristis')
out &lt;- occ(query=spnames, from='idigbio', limit=20)
inspect(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='obis_search'>OBIS search</h2><span id='topic+obis_search'></span>

<h3>Description</h3>

<p>OBIS search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obis_search(
  scientificName = NULL,
  size = 500,
  after = NULL,
  taxonid = NULL,
  aphiaid = NULL,
  areaid = NULL,
  datasetid = NULL,
  instituteid = NULL,
  nodeid = NULL,
  startdate = NULL,
  enddate = NULL,
  startdepth = NULL,
  enddepth = NULL,
  geometry = NULL,
  exclude = NULL,
  fields = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obis_search_+3A_scientificname">scientificName</code></td>
<td>
<p>(character) Scientific name. Leave empty to
include all taxa. This is what we pass your name query to</p>
</td></tr>
<tr><td><code id="obis_search_+3A_size">size</code></td>
<td>
<p>(integer) number of results to fetch</p>
</td></tr>
<tr><td><code id="obis_search_+3A_after">after</code></td>
<td>
<p>(character) Occurrence UUID up to which to skip.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_taxonid">taxonid</code></td>
<td>
<p>(character) Taxon AphiaID.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_areaid">areaid</code></td>
<td>
<p>(character) Area ID.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_datasetid">datasetid</code></td>
<td>
<p>(character) Dataset UUID.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_instituteid">instituteid</code></td>
<td>
<p>(character) Institute ID.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_nodeid">nodeid</code></td>
<td>
<p>(character) Node UUID.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_startdate">startdate</code></td>
<td>
<p>(character) Start date formatted as YYYY-MM-DD.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_enddate">enddate</code></td>
<td>
<p>(character) End date formatted as YYYY-MM-DD.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_startdepth">startdepth</code></td>
<td>
<p>(integer) Start depth, in meters.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_enddepth">enddepth</code></td>
<td>
<p>(integer) End depth, in meters.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_geometry">geometry</code></td>
<td>
<p>(character) Geometry, formatted as WKT.</p>
</td></tr>
<tr><td><code id="obis_search_+3A_exclude">exclude</code></td>
<td>
<p>(character) set of quality flags to be excluded.
one or more in a vector</p>
</td></tr>
<tr><td><code id="obis_search_+3A_fields">fields</code></td>
<td>
<p>(character) Field to be included in the result set.
one or more in a vector</p>
</td></tr>
</table>

<hr>
<h2 id='occ'>Search for species occurrence data across many data sources.</h2><span id='topic+occ'></span>

<h3>Description</h3>

<p>Search on a single species name, or many. And search across a single
or many data sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ(
  query = NULL,
  from = "gbif",
  limit = 500,
  start = NULL,
  page = NULL,
  geometry = NULL,
  has_coords = NULL,
  ids = NULL,
  date = NULL,
  callopts = list(),
  gbifopts = list(),
  inatopts = list(),
  ebirdopts = list(),
  vertnetopts = list(),
  idigbioopts = list(),
  obisopts = list(),
  alaopts = list(),
  throw_warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occ_+3A_query">query</code></td>
<td>
<p>(character) One to many scientific names. See Details for what parameter
in each data source we query. Note: ebird now expects species codes instead of
scientific names - we pass you name through <code><a href="rebird.html#topic+species_code">rebird::species_code()</a></code> internally</p>
</td></tr>
<tr><td><code id="occ_+3A_from">from</code></td>
<td>
<p>(character) Data source to get data from, any combination of gbif,
inat, ebird, vertnet, idigbio, obis, or ala. See <code>vignette(topic = 'spocc introduction')</code>
for more details about these sources.</p>
</td></tr>
<tr><td><code id="occ_+3A_limit">limit</code></td>
<td>
<p>(numeric) Number of records to return. This is passed across all sources.
To specify different limits for each source, use the options for each source (gbifopts,
inatopts, and ebirdopts). See Details for more.
Default: 500 for each source. BEWARE: if you have a lot of species to query for (e.g.,
n = 10), that's 10 * 500 = 5000, which can take a while to collect. So, when you first query,
set the limit to something smallish so that you can get a result quickly, then do more as
needed.</p>
</td></tr>
<tr><td><code id="occ_+3A_start">start</code>, <code id="occ_+3A_page">page</code></td>
<td>
<p>(integer) Record to start at or page to start at. See <code>Paging</code> in
Details for how these parameters are used internally. Optional</p>
</td></tr>
<tr><td><code id="occ_+3A_geometry">geometry</code></td>
<td>
<p>(character or nmeric) One of a Well Known Text (WKT) object, a vector of
length 4 specifying a bounding box, or an sf object (sfg, sfc, or sf). This parameter
searches for occurrences inside a
polygon - converted to a polygon from whatever user input is given. A WKT shape written as
<code style="white-space: pre;">&#8288;POLYGON((30.1 10.1, 20 40, 40 40, 30.1 10.1))&#8288;</code> would be queried as is,
i.e. http://bit.ly/HwUSif. See Details for more examples of WKT objects. The format of a
bounding box is <code style="white-space: pre;">&#8288;min-longitude, min-latitude, max-longitude, max-latitude&#8288;</code>. Geometry
is not possible with vertnet right now, but should be soon. See Details for more info
on geometry inputs.</p>
</td></tr>
<tr><td><code id="occ_+3A_has_coords">has_coords</code></td>
<td>
<p>(logical) Only return occurrences that have lat/long data. This works
for gbif, rinat, idigbio, and vertnet, but is ignored for ebird.
You can easily though remove records without lat/long data.</p>
</td></tr>
<tr><td><code id="occ_+3A_ids">ids</code></td>
<td>
<p>Taxonomic identifiers. This can be a list of length 1 to many. See examples for
usage. Currently, identifiers for only 'gbif' for parameter 'from' supported. If
this parameter is used, query parameter can not be used - if it is, a warning is thrown.</p>
</td></tr>
<tr><td><code id="occ_+3A_date">date</code></td>
<td>
<p>(character/Date) A length 2 vector containing two dates of the form
YYY-MM-DD. These can be character of Date class. These are used to do a date range search.
Of course there are other types of date searches one may want to do but date range
seems like the most common date search use case.</p>
</td></tr>
<tr><td><code id="occ_+3A_callopts">callopts</code></td>
<td>
<p>Options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a>, e.g.,
for debugging curl calls, setting timeouts, etc.</p>
</td></tr>
<tr><td><code id="occ_+3A_gbifopts">gbifopts</code></td>
<td>
<p>(list) List of named options to pass on to
<code><a href="rgbif.html#topic+occ_search">rgbif::occ_search()</a></code>. See also <code><a href="#topic+occ_options">occ_options()</a></code></p>
</td></tr>
<tr><td><code id="occ_+3A_inatopts">inatopts</code></td>
<td>
<p>(list) List of named options to pass on to internal function
<code>get_inat_obs</code></p>
</td></tr>
<tr><td><code id="occ_+3A_ebirdopts">ebirdopts</code></td>
<td>
<p>(list) List of named options to pass on to
<code><a href="rebird.html#topic+ebirdregion">rebird::ebirdregion()</a></code> or <code><a href="rebird.html#topic+ebirdgeo">rebird::ebirdgeo()</a></code>. See also <code><a href="#topic+occ_options">occ_options()</a></code></p>
</td></tr>
<tr><td><code id="occ_+3A_vertnetopts">vertnetopts</code></td>
<td>
<p>(list) List of named options to pass on to
<code><a href="rvertnet.html#topic+searchbyterm">rvertnet::searchbyterm()</a></code>. See also <code><a href="#topic+occ_options">occ_options()</a></code>.</p>
</td></tr>
<tr><td><code id="occ_+3A_idigbioopts">idigbioopts</code></td>
<td>
<p>(list) List of named options to pass on to
<code><a href="ridigbio.html#topic+idig_search_records">ridigbio::idig_search_records()</a></code>. See also <code><a href="#topic+occ_options">occ_options()</a></code>.</p>
</td></tr>
<tr><td><code id="occ_+3A_obisopts">obisopts</code></td>
<td>
<p>(list) List of named options to pass on to internal function.
See  https://api.obis.org/#/Occurrence/get_occurrence and <a href="#topic+obis_search">obis_search</a> for
what parameters can be used.</p>
</td></tr>
<tr><td><code id="occ_+3A_alaopts">alaopts</code></td>
<td>
<p>(list) List of named options to pass on to internal function.</p>
</td></tr>
<tr><td><code id="occ_+3A_throw_warnings">throw_warnings</code></td>
<td>
<p>(logical) <code>occ()</code> collects errors returned from each
data provider when they occur, and are accessible in the <code style="white-space: pre;">&#8288;$meta$errors&#8288;</code> slot
for each data provider. If you set <code>throw_warnings=TRUE</code>, we give these
request errors as warnings with <code><a href="base.html#topic+warning">warning()</a></code>. if <code>FALSE</code>, we don't give warnings,
but you can still access them in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>occ</code> function is an opinionated wrapper
around the rgbif, rinat, rebird, rvertnet and
ridigbio packages (as well as internal custom wrappers around some data
sources) to allow data access from a single access point. We take
care of making sure you get useful objects out at the cost of
flexibility/options - although you can still set options for each of the
packages via the gbifopts, inatopts, etc. parameters.
</p>


<h3>Value</h3>

<p>an object of class <code>occdat</code>, with a print method to give a brief
summary. The print method only shows results for those that have some
results (those with no results are not shown). The <code>occdat</code> class is just
a thin wrapper around a named list, where the top level names are the
data sources:
</p>

<ul>
<li><p> gbif
</p>
</li>
<li><p> inat
</p>
</li>
<li><p> ebird
</p>
</li>
<li><p> vertnet
</p>
</li>
<li><p> idigbio
</p>
</li>
<li><p> obis
</p>
</li>
<li><p> ala
</p>
</li></ul>

<p>Note that you only get data back for sources that were specified in the <code>from</code>
parameter. All others are present, but empty.
</p>
<p>Then within each data source is an object of class <code>occdatind</code> holding another
named list that contains:
</p>

<ul>
<li><p> meta: metadata
</p>

<ul>
<li><p> source: the data source name (e.g., &quot;gbif&quot;)
</p>
</li>
<li><p> time: time the request was sent
</p>
</li>
<li><p> found: number of records found (number found across all queries)
</p>
</li>
<li><p> returned: number of records returned (number of rows in all data.frame's
in the <code>data</code> slot)
</p>
</li>
<li><p> type: query type, only &quot;sci&quot; for scientific
</p>
</li>
<li><p> opts: a named list with the options you sent to the data source
</p>
</li>
<li><p> errors: a character vector of errors returned, if any occurred
</p>
</li></ul>

</li>
<li><p> data: named list of data.frame's, named by the queries sent
</p>
</li></ul>



<h3>Inputs</h3>

<p>All inputs to <code>occ</code> are one of:
</p>

<ul>
<li><p> scientific name
</p>
</li>
<li><p> taxonomic id
</p>
</li>
<li><p> geometry as bounds, WKT, os Spatial classes
</p>
</li></ul>

<p>To search by common name, first use <code><a href="#topic+occ_names">occ_names()</a></code> to find scientic names or
taxonomic IDs, then feed those to this function. Or use the <code>taxize</code> package
to get names and/or IDs to use here.
</p>


<h3>Using the query parameter</h3>

<p>When you use the <code>query</code> parameter, we pass your search terms on to parameters
within functions that query data sources you specify. Those parameters are:
</p>

<ul>
<li><p> rgbif - <code>scientificName</code> in the <code><a href="rgbif.html#topic+occ_search">rgbif::occ_search()</a></code> function - API
parameter: same as the <code>occ</code> parameter
</p>
</li>
<li><p> rebird - <code>species</code> in the <code><a href="rebird.html#topic+ebirdregion">rebird::ebirdregion()</a></code> or
<code><a href="rebird.html#topic+ebirdgeo">rebird::ebirdgeo()</a></code> functions, depending on whether you set
<code>method="ebirdregion"</code> or <code>method="ebirdgeo"</code> - API parameters: <code>sci</code> for both
<code><a href="rebird.html#topic+ebirdregion">rebird::ebirdregion()</a></code> and <code><a href="rebird.html#topic+ebirdgeo">rebird::ebirdgeo()</a></code>
</p>
</li>
<li><p> rvertnet - <code>taxon</code> in the <code><a href="rvertnet.html#topic+vertsearch">rvertnet::vertsearch()</a></code> function - API
parameter: <code>q</code>
</p>
</li>
<li><p> ridigbio - <code>scientificname</code> in the <code><a href="ridigbio.html#topic+idig_search_records">ridigbio::idig_search_records()</a></code>
function - API parameter: <code>scientificname</code>
</p>
</li>
<li><p> inat - internal function - API parameter: <code>q</code>
</p>
</li>
<li><p> obis - internal function - API parameter: <code>scientificName</code>
</p>
</li>
<li><p> ala - internal function - API parameter: <code>q</code>
</p>
</li></ul>

<p>If you have questions about how each of those parameters behaves with respect to
the terms you pass to it, lookup documentation for those functions, or get in touch
at the development repository <a href="https://github.com/ropensci/spocc/issues">https://github.com/ropensci/spocc/issues</a>
</p>


<h3>iDigBio notes</h3>

<p>When searching iDigBio note that by deafult we set <code>fields = "all"</code>, so that we return
a richer suite of fields than the <code>ridigbio</code> R client gives by default. But you can
changes this by passing in a <code>fields</code> parameter to <code>idigbioopts</code> parameter with
the specific fields you want.
</p>
<p>Maximum of 100,000 results are allowed to be returned. See
<a href="https://github.com/iDigBio/ridigbio/issues/33">https://github.com/iDigBio/ridigbio/issues/33</a>
</p>


<h3>iNaturalist notes</h3>

<p>We're using the iNaturalist API, docs at
https://api.inaturalist.org/v1/docs/#!/Observations/get_observations
</p>
<p>API rate limits: max of 100 requests per minute, though they ask that you try to keep it
to 60 requests per minute or lower. If they notice usage that has serious impact on their
performance they may institute blocks without notification.
</p>
<p>There is a hard limit 0f 10,000 observations with the iNaturalist API. We do paging
internally so you may not see this aspect, but for example, if you request 12,000
records, you won't be able to get that many. The API will error at anything more than
10,000. We now error if you request more than 10,000 from iNaturalist. There are
some alternatives:
</p>

<ul>
<li><p> Consider exporting data while logged in
to your iNaturalist account, or the iNaturalist research grade observations within
GBIF - see https://www.gbif.org/dataset/50c9509d-22c7-4a22-a47d-8c48425ef4a7 - at
time of this writing it has 8.5 million observations.
</p>
</li>
<li><p> Search for iNaturalist data within GBIF. e.g., the following searches for iNaturalist
data within GBIF and allows more than 10,000 records:
&ldquo;
</p>
</li></ul>



<h3>limit parameter</h3>

<p>The <code>limit</code> parameter is set to a default of 500. This means that you will get <strong>up to</strong>
500 results back for each data source you ask for data from. If there are no results for a
particular source, you'll get zero back; if there are 8 results for a particular source, you'll
get 8 back. If there are 501 results for a particular source, you'll get 500 back. You can always
ask for more or less back by setting the limit parameter to any number. If you want to request
a different number for each source, pass the appropriate parameter to each data source via the
respective options parameter for each data source.
</p>


<h3>WKT</h3>

<p>WKT objects are strings of pairs of lat/long coordinates that define a shape. Many classes
of shapes are supported, including POLYGON, POINT, and MULTIPOLYGON. Within each defined shape
define all vertices of the shape with a coordinate like 30.1 10.1, the first of which is the
latitude, the second the longitude.
</p>
<p>Examples of valid WKT objects:
</p>

<ul>
<li><p> 'POLYGON((30.1 10.1, 10 20, 20 60, 60 60, 30.1 10.1))'
</p>
</li>
<li><p> 'POINT((30.1 10.1))'
</p>
</li>
<li><p> 'LINESTRING(3 4,10 50,20 25)'
</p>
</li>
<li><p> 'MULTIPOINT((3.5 5.6),(4.8 10.5))&quot;)'
</p>
</li>
<li><p> 'MULTILINESTRING((3 4,10 50,20 25),(-5 -8,-10 -8,-15 -4))'
</p>
</li>
<li><p> 'MULTIPOLYGON(((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2)),((6 3,9 2,9 4,6 3)))'
</p>
</li>
<li><p> 'GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))'
</p>
</li></ul>

<p>Only POLYGON objects are currently supported.
</p>
<p>Getting WKT polygons or bounding boxes. We will soon introduce a function to help you select
a bounding box but for now, you can use a few sites on the web.
</p>

<ul>
<li><p> Bounding box - <a href="https://boundingbox.klokantech.com/">https://boundingbox.klokantech.com/</a>
</p>
</li>
<li><p> Well known text - <a href="http://arthur-e.github.io/Wicket/sandbox-gmaps3.html">http://arthur-e.github.io/Wicket/sandbox-gmaps3.html</a>
</p>
</li></ul>



<h3>geometry parameter</h3>

<p>The behavior of the <code>occ</code> function with respect to the <code>geometry</code> parameter
varies depending on the inputs to the <code>query</code> parameter. Here are the options:
</p>

<ul>
<li><p> geometry (single), no query - If a single bounding box/WKT string passed in,
and no query, a single query is made against each data source.
</p>
</li>
<li><p> geometry (many), no query - If many bounding boxes/WKT strings are passed in,
we do a separate query for each bounding box/WKT string against each data source.
</p>
</li>
<li><p> geometry (single), query - If a single bounding box/WKT string passed in,
and a single query, we do a single query against each data source.
</p>
</li>
<li><p> geometry (many), query - If many bounding boxes/WKT strings are passed in,
and a single query, we do a separate query for each bounding box/WKT string with the
same queried name against each data source.
</p>
</li>
<li><p> geometry (single), many query - If a single bounding box/WKT string passed in,
and many names to query, we do a separate query for each name, using the same geometry,
for each data source.
</p>
</li>
<li><p> geometry (many), many query - If many bounding boxes/WKT strings are passed in,
and many names to query, this poses a problem for all data sources, none of which
accept many bounding boxes of WKT strings. So, in this scenario, we loop over each
name and each geometry query, and then re-combine by queried name, so that you get
back a single group of data for each name.
</p>
</li></ul>



<h3>Geometry options by data provider</h3>

<p><strong>wkt &amp; bbox allowed, see WKT section above</strong>
</p>

<ul>
<li><p> gbif
</p>
</li>
<li><p> obis
</p>
</li>
<li><p> ala
</p>
</li></ul>

<p><strong>bbox only</strong>
</p>

<ul>
<li><p> inat
</p>
</li>
<li><p> idigbio
</p>
</li></ul>

<p><strong>No spatial search allowed</strong>
</p>

<ul>
<li><p> ebird
</p>
</li>
<li><p> vertnet
</p>
</li></ul>



<h3>Notes on the date parameter</h3>

<p>Date searches with the <code>date</code> parameter are allowed for all sources
except ebird.
</p>
<p>Notes on some special cases
</p>

<ul>
<li><p> idigbio: We search on the <code>datecollected</code> field. Other date fields can be
searched on, but we chose <code>datecollected</code> as it seemed most appropriate.
</p>
</li>
<li><p> vertnet: If you want more flexible date searches, you can pass various
types of date searches to <code>vertnetopts</code>. See <code><a href="rvertnet.html#topic+searchbyterm">rvertnet::searchbyterm()</a></code>
for more information
</p>
</li>
<li><p> ala: There's some issues with the dates returned from ALA. They are
returned as time stamps, and some seem to be malformed. So do beware
of using ALA dates for important things.
</p>
</li></ul>

<p>Get in touch if you have other date search use cases you think
are widely useful
</p>


<h3>Paging</h3>

<p>All data sources respond to the <code>limit</code> parameter passed to <code>occ</code>.
</p>
<p>Data sources, however, vary as to whether they respond to an offset. Here's
the details on which data sources will respond to <code>start</code> and which
to the <code>page</code> parameter:
</p>

<ul>
<li><p> gbif - Responds to <code>start</code>. Default: 0
</p>
</li>
<li><p> inat - Responds to <code>page</code>. Default: 1
</p>
</li>
<li><p> ebird - No paging, both <code>start</code> and <code>page</code> ignored.
</p>
</li>
<li><p> vertnet - No paging implemented here, both <code>start</code> and <code>page</code>
ignored. VertNet does have a form of paging, but it uses a cursor, and can't
easily be included  here via parameters. However, <code>rvertnet</code> does paging
internally for you.  For example, the max records per request for VertNet is
1000; if you request 2000 records, we'll do the first request, and do the
second request for you automatically.
</p>
</li>
<li><p> idigbio - Responds to <code>start</code>. Default: 0
</p>
</li>
<li><p> obis - Does not respond to <code>start</code>. They only allow a starting occurrence
UUID up to which to skip. So order of results matters a great deal of course.
To paginate with OBIS, do e.g.
<code>obisopts = list(after = "017b7818-5b2c-4c88-9d76-f4471afe5584")</code>; <code>after</code> can
be combined with the <code>limit</code> value you pass in to the main <code>occ()</code> function
call. See <a href="#topic+obis_search">obis_search</a> for what parameters can be used.
</p>
</li>
<li><p> ala - Responds to <code>start</code>. Default: 0
</p>
</li></ul>



<h3>Photographs</h3>

<p>The iNaturalist data source provides photographs of the records returned,
if available. For example, the following will give photos from inat:
<code>occ(query = 'Danaus plexippus', from = 'inat')$inat$data$Danaus_plexippus$photos</code>
</p>


<h3>BEWARE</h3>

<p>In cases where you request data from multiple providers, especially when
including GBIF, there could be duplicate records since many providers' data eventually
ends up with GBIF. See <code><a href="#topic+spocc_duplicates">spocc_duplicates()</a></code> for more.
</p>


<h3>See Also</h3>

<p>Other queries: 
<code><a href="#topic+occ_names">occ_names</a>()</code>,
<code><a href="#topic+occ_names_options">occ_names_options</a>()</code>,
<code><a href="#topic+occ_options">occ_options</a>()</code>,
<code><a href="#topic+spocc_objects">spocc_objects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Single data sources
(res &lt;- occ(query = 'Accipiter striatus', from = 'gbif', limit = 5))
res$gbif
(res &lt;- occ(query = 'Accipiter striatus', from = 'ebird', limit = 50))
res$ebird
(res &lt;- occ(query = 'Danaus plexippus', from = 'inat', limit = 50,
  has_coords = TRUE))
res$inat
res$inat$data
data.table::rbindlist(res$inat$data$Danaus_plexippus$photos)
(res &lt;- occ(query = 'Bison bison', from = 'vertnet', limit = 5))
res$vertnet
res$vertnet$data$Bison_bison
occ2df(res)

# Paging
one &lt;- occ(query = 'Accipiter striatus', from = 'gbif', limit = 5)
two &lt;- occ(query = 'Accipiter striatus', from = 'gbif', limit = 5, start = 5)
one$gbif
two$gbif

# iNaturalist limits: they allow at most 10,000; query through GBIF to get
# more than 10,000
# See https://www.gbif.org/dataset/50c9509d-22c7-4a22-a47d-8c48425ef4a7
# x &lt;- occ(query = 'Danaus plexippus', from = 'gbif', limit = 10100, 
#   gbifopts = list(datasetKey = "50c9509d-22c7-4a22-a47d-8c48425ef4a7"))
# x$gbif

# Date range searches across data sources
## Not possible for ebird
## ala
occ(date = c('2018-01-01T00:00:00Z', '2018-03-28T00:00:00Z'), from = 'ala', limit = 5)
## gbif
occ(query = 'Accipiter striatus', date = c('2010-08-01', '2010-08-31'), from = 'gbif', limit=5)
## vertnet
occ(query = 'Mustela nigripes', date = c('1990-01-01', '2015-12-31'), from = 'vertnet', limit=5)
## idigbio
occ(query = 'Acer', date = c('2010-01-01', '2015-12-31'), from = 'idigbio', limit=5)
## obis
occ(query = 'Mola mola', date = c('2015-01-01', '2015-12-31'), from = 'obis', limit=5)
## inat
occ(query = 'Danaus plexippus', date = c('2015-01-01', '2015-12-31'), from = 'inat', limit=5)


# Restrict to records with coordinates
occ(query = "Acer", from = "idigbio", limit = 5, has_coords = TRUE)

occ(query = 'Setophaga caerulescens', from = 'ebird', ebirdopts = list(loc='US'))
occ(query = 'Spinus tristis', from = 'ebird', ebirdopts =
   list(method = 'ebirdgeo', lat = 42, lng = -76, dist = 50))

# idigbio data
## scientific name search
occ(query = "Acer", from = "idigbio", limit = 5)
occ(query = "Acer", from = "idigbio", idigbioopts = list(offset = 5, limit  = 3))
## geo search
bounds &lt;- c(-120, 40, -100, 45)
occ(from = "idigbio", geometry = bounds, limit = 10)
## just class arachnida, spiders
occ(idigbioopts = list(rq = list(class = 'arachnida')), from = "idigbio", limit = 10)
## search certain recordsets
sets &lt;- c("1ffce054-8e3e-4209-9ff4-c26fa6c24c2f",
    "8dc14464-57b3-423e-8cb0-950ab8f36b6f", 
    "26f7cbde-fbcb-4500-80a9-a99daa0ead9d")
occ(idigbioopts = list(rq = list(recordset = sets)), from = "idigbio", limit = 10)

# Many data sources
(out &lt;- occ(query = 'Pinus contorta', from=c('gbif','vertnet'), limit=10))

## Select individual elements
out$gbif
out$gbif$data
out$vertnet

## Coerce to combined data.frame, selects minimal set of
## columns (name, lat, long, provider, date, occurrence key)
occ2df(out)

# Pass in limit parameter to all sources. This limits the number of occurrences
# returned to 10, in this example, for all sources, in this case gbif and inat.
occ(query='Pinus contorta', from=c('gbif','inat'), limit=10)

# Geometry
## Pass in geometry parameter to all sources. This constraints the search to the
## specified polygon for all sources, gbif in this example.
## Check out http://arthur-e.github.io/Wicket/sandbox-gmaps3.html to get a WKT string
occ(query='Accipiter', from='gbif',
   geometry='POLYGON((30.1 10.1, 10 20, 20 60, 60 60, 30.1 10.1))')

## Or pass in a bounding box, which is automatically converted to WKT (required by GBIF)
## via the bbox2wkt function. The format of a bounding box is
## [min-longitude, min-latitude, max-longitude, max-latitude].
occ(query='Accipiter striatus', from='gbif', geometry=c(-125.0,38.4,-121.8,40.9))

## lots of results, can see how many by indexing to meta
res &lt;- occ(query='Accipiter striatus', from='gbif',
   geometry='POLYGON((-69.9 49.2,-69.9 29.0,-123.3 29.0,-123.3 49.2,-69.9 49.2))')
res$gbif

## You can pass in geometry to each source separately via their opts parameter, at
## least those that support it. Note that if you use rinat, you reverse the order, with
## latitude first, and longitude second, but here it's the reverse for consistency across
## the spocc package
bounds &lt;- c(-125.0,38.4,-121.8,40.9)
occ(query = 'Danaus plexippus', from="inat", geometry=bounds)

## Passing geometry with multiple sources
occ(query = 'Danaus plexippus', from=c("inat","gbif"), geometry=bounds)

## Using geometry only for the query
### A single bounding box
occ(geometry = bounds, from = "gbif", limit=50)
### Many bounding boxes
occ(geometry = list(c(-125.0,38.4,-121.8,40.9), c(-115.0,22.4,-111.8,30.9)), from = "gbif")

## Geometry only with WKT
wkt &lt;- 'POLYGON((-98.9 44.2,-89.1 36.6,-116.7 37.5,-102.5 39.6,-98.9 44.2))'
occ(from = "gbif", geometry = wkt, limit = 10)

# Specify many data sources, another example
ebirdopts = list(loc = 'US'); gbifopts  =  list(country = 'US')
out &lt;- occ(query = 'Setophaga caerulescens', from = c('gbif','inat','ebird'),
    gbifopts = gbifopts, ebirdopts = ebirdopts, limit=20)
occ2df(out)

# Pass in many species names, combine just data to a single data.frame, and
# first six rows
spnames &lt;- c('Accipiter striatus', 'Setophaga caerulescens', 'Spinus tristis')
(out &lt;- occ(query = spnames, from = 'gbif', gbifopts = list(hasCoordinate = TRUE), limit=25))
df &lt;- occ2df(out)
head(df)

# no query, geometry, or ids passed
## many dataset keys to gbif
dsets &lt;- c("14f3151a-e95d-493c-a40d-d9938ef62954", "f934f8e2-32ca-46a7-b2f8-b032a4740454")
occ(limit = 20, from = "gbif", gbifopts = list(datasetKey = dsets))
## class name to idigbio
occ(limit = 20, from = "idigbio", idigbioopts = list(rq = list(class = 'arachnida')))

# taxize integration
## You can pass in taxonomic identifiers
library("taxize")
(ids &lt;- get_ids(c("Chironomus riparius","Pinus contorta"), db = c('itis','gbif')))
occ(ids = ids, from='gbif', limit=20)

(ids &lt;- get_ids("Chironomus riparius", db = 'gbif'))
occ(ids = ids, from='gbif', limit=20)

(ids &lt;- get_gbifid("Chironomus riparius"))
occ(ids = ids, from='gbif', limit=20)

## sf classes
library("sp")
library("sf")
one &lt;- Polygon(cbind(c(91,90,90,91), c(30,30,32,30)))
spone = Polygons(list(one), "s1")
sppoly = SpatialPolygons(list(spone), as.integer(1))

## single polygon in a sf class
x &lt;- st_as_sf(sppoly)
out &lt;- occ(geometry = x, limit=50)
out$gbif$data
mapr::map_leaflet(out)

## single polygon in a sfc class
x &lt;- st_as_sf(sppoly)
out &lt;- occ(geometry = x[[1]], limit=50)
out$gbif$data

## single polygon in a sf POLYGON class
x &lt;- st_as_sf(sppoly)
x &lt;- unclass(x[[1]])[[1]]
class(x)
out &lt;- occ(geometry = x, limit=50)
out$gbif$data

## two polygons in an sf class
one &lt;- Polygon(cbind(c(-121.0,-117.9,-121.0,-121.0), c(39.4, 37.1, 35.1, 39.4)))
two &lt;- Polygon(cbind(c(-123.0,-121.2,-122.3,-124.5,-123.5,-124.1,-123.0),
                     c(44.8,42.9,41.9,42.6,43.3,44.3,44.8)))
spone = Polygons(list(one), "s1")
sptwo = Polygons(list(two), "s2")
sppoly = SpatialPolygons(list(spone, sptwo), 1:2)
sppoly_df &lt;- SpatialPolygonsDataFrame(sppoly, 
   data.frame(a=c(1,2), b=c("a","b"), c=c(TRUE,FALSE),
   row.names=row.names(sppoly)))
x &lt;- st_as_sf(sppoly_df)
out &lt;- occ(geometry = x, limit=50)
out$gbif$data


# curl debugging
occ(query = 'Accipiter striatus', from = 'gbif', limit=10, 
 callopts=list(verbose = TRUE))
occ(query = 'Accipiter striatus', from = 'inat', 
 callopts=list(verbose = TRUE))
occ(query = 'Mola mola', from = 'obis', limit = 200, 
 callopts = list(verbose = TRUE))

########## More thorough data source specific examples
# idigbio
## scientific name search
res &lt;- occ(query = "Acer", from = "idigbio", limit = 5)
res$idigbio

## geo search
### bounding box
bounds &lt;- c(-120, 40, -100, 45)
occ(from = "idigbio", geometry = bounds, limit = 10)
### wkt
# wkt &lt;- 'POLYGON((-69.9 49.2,-69.9 29.0,-123.3 29.0,-123.3 49.2,-69.9 49.2))'
wkt &lt;- 'POLYGON((-98.9 44.2,-89.1 36.6,-116.7 37.5,-102.5 39.6,-98.9 44.2))'
occ(from = "idigbio", geometry = wkt, limit = 10)

## limit fields returned
occ(query = "Acer", from = "idigbio", limit = 5,
   idigbioopts = list(fields = "scientificname"))

## offset and max_items
occ(query = "Acer", from = "idigbio", limit = 5,
   idigbioopts = list(offset = 10))

## sort
occ(query = "Acer", from = "idigbio", limit = 5,
   idigbioopts = list(sort = TRUE))$idigbio
occ(query = "Acer", from = "idigbio", limit = 5,
   idigbioopts = list(sort = FALSE))$idigbio

## more complex queries
### parameters passed to "rq", get combined with the name queried
occ(query = "Acer", from = "idigbio", limit = 5,
   idigbioopts = list(rq = list(basisofrecord="fossilspecimen")))$idigbio

#### NOTE: no support for multipolygons yet
## WKT's are more flexible than bounding box's. You can pass in a WKT with multiple
## polygons like so (you can use POLYGON or MULTIPOLYGON) when specifying more than one
## polygon. Note how each polygon is in it's own set of parentheses.
# occ(query='Accipiter striatus', from='gbif',
#    geometry='MULTIPOLYGON((30 10, 10 20, 20 60, 60 60, 30 10),
#                           (30 10, 10 20, 20 60, 60 60, 30 10))')

# OBIS examples
## basic query
(res &lt;- occ(query = 'Mola mola', from = 'obis', limit = 200))
## get to obis data
res$obis
## get obis + gbif data
(res &lt;- occ(query = 'Mola mola', from = c('obis', 'gbif'), limit = 200))
res$gbif
res$obis
## no match found
(res &lt;- occ(query = 'Linguimaera thomsonia', from = 'obis'))
## geometry query
geometry &lt;- "POLYGON((8.98 48.05,15.66 48.05,15.66 45.40,8.98 45.40,8.98 48.05))"
(res &lt;- occ(from = 'obis', geometry = geometry, limit = 50))
res$obis

## Pass in spatial classes
## sp classes no longer supported

## Paging
(res1 &lt;- occ(query = 'Mola mola', from = 'obis', limit = 10))
occ_ids &lt;- res1$obis$data$Mola_mola$id
(res2 &lt;- occ(query = 'Mola mola', from = 'obis',
  limit = 10, obisopts = list(after = occ_ids[length(occ_ids)])))
res1$obis
res2$obis
## Pass in any parameters to obisopts as a list
(res &lt;- occ(query = 'Mola mola', from = 'obis', 
   obisopts = list(startdepth = 40, enddepth = 50)))
min(res$obis$data$Mola_mola$minimumDepthInMeters, na.rm=TRUE)
max(res$obis$data$Mola_mola$maximumDepthInMeters, na.rm=TRUE)


# ALA examples
## basic query
(res &lt;- occ(query = 'Alaba vibex', from = 'ala', limit = 200))
## get to ala data
res$ala
occ2df(res)

# geometry search
(x &lt;- occ(query = "Macropus", from = 'ala',
  geometry = "POLYGON((145 -37,150 -37,150 -30,145 -30,145 -37))"))
x$ala
occ2df(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_coverage'>Automatically generate coverages for a spocc search</h2><span id='topic+occ_coverage'></span>

<h3>Description</h3>

<p>This function will automatically generate metadata for spocc
queries that can then be converted to other standards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_coverage(occObj, coverage = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occ_coverage_+3A_occobj">occObj</code></td>
<td>
<p>an search object returned by occ</p>
</td></tr>
<tr><td><code id="occ_coverage_+3A_coverage">coverage</code></td>
<td>
<p>a vector of coverage types to generate. These include
'temporal','spatial','taxa', or just 'all'.</p>
</td></tr>
</table>

<hr>
<h2 id='occ_names'>Search for species names across many data sources.</h2><span id='topic+occ_names'></span>

<h3>Description</h3>

<p>Search for species names across many data sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_names(
  query = NULL,
  from = "gbif",
  limit = 100,
  rank = "species",
  callopts = list(),
  gbifopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occ_names_+3A_query">query</code></td>
<td>
<p>(character) One to many names. Either a scientific name or a
common name. Only scientific names supported right now.</p>
</td></tr>
<tr><td><code id="occ_names_+3A_from">from</code></td>
<td>
<p>(character) Data source to get data from, only gbif</p>
</td></tr>
<tr><td><code id="occ_names_+3A_limit">limit</code></td>
<td>
<p>(numeric) Number of records to return. This is passed across
all sources. To specify different limits for each source, use the options
for each source (gbifopts). See Details for more.</p>
</td></tr>
<tr><td><code id="occ_names_+3A_rank">rank</code></td>
<td>
<p>(character) Taxonomic rank to limit search space. Used in GBIF.</p>
</td></tr>
<tr><td><code id="occ_names_+3A_callopts">callopts</code></td>
<td>
<p>Options passed on to <code><a href="crul.html#topic+HttpClient">crul::HttpClient()</a></code>, e.g., for
debugging curl calls, setting timeouts, etc.</p>
</td></tr>
<tr><td><code id="occ_names_+3A_gbifopts">gbifopts</code></td>
<td>
<p>(list) List of named options to pass on to
<code><a href="rgbif.html#topic+name_lookup">rgbif::name_lookup()</a></code>. See also <code><a href="#topic+occ_names_options">occ_names_options()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all 7 data sources available from the <code><a href="#topic+occ">occ()</a></code> function are
available here, as not all of those sources have functionality to search
for names.
</p>
<p>We strongly encourage you to use the <code>taxize</code> package if you want to
search for taxonomic or common names, convert common to scientific names,
etc. That package was built exactly for that purpose, and we only provide
a bit of name searching here in this function.
</p>


<h3>See Also</h3>

<p>Other queries: 
<code><a href="#topic+occ">occ</a>()</code>,
<code><a href="#topic+occ_names_options">occ_names_options</a>()</code>,
<code><a href="#topic+occ_options">occ_options</a>()</code>,
<code><a href="#topic+spocc_objects">spocc_objects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Single data sources
## gbif
(res &lt;- occ_names(query = 'Accipiter striatus', from = 'gbif'))
head(res$gbif$data[[1]])

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_names_options'>Look up options for parameters passed to each source for occ_names function</h2><span id='topic+occ_names_options'></span>

<h3>Description</h3>

<p>Look up options for parameters passed to each source for occ_names function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_names_options(from = "gbif", where = "console")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occ_names_options_+3A_from">from</code></td>
<td>
<p>(character) Data source to get data from, only gbif.
Case doesn't matter.</p>
</td></tr>
<tr><td><code id="occ_names_options_+3A_where">where</code></td>
<td>
<p>(character) One of console (print to console) or html
(opens help page, if in non-interactive R session, prints help to console).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any of the parameters passed to e.g. <code><a href="rgbif.html#topic+name_lookup">rgbif::name_lookup()</a></code> from the
<code>rgbif</code> package can be passed in the associated gbifopts list
in <code><a href="#topic+occ">occ()</a></code>.
</p>
<p>Note that the from parameter is lowercased within the function and is
called through <code>match.arg</code> first, so you can match on unique partial
strings too (e.g., 'rg' for 'rgbif').
</p>


<h3>Value</h3>

<p>Opens up the documentation for the function that is used internally
within the occ function for each source.
</p>


<h3>See Also</h3>

<p>Other queries: 
<code><a href="#topic+occ">occ</a>()</code>,
<code><a href="#topic+occ_names">occ_names</a>()</code>,
<code><a href="#topic+occ_options">occ_options</a>()</code>,
<code><a href="#topic+spocc_objects">spocc_objects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# opens up documentation for this function
occ_names_options()

# Open up documentation for the appropriate search function for each source
occ_names_options('gbif')

# Or open in html version
occ_names_options('gbif', 'html')

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_options'>Look up options for parameters passed to each source</h2><span id='topic+occ_options'></span>

<h3>Description</h3>

<p>Look up options for parameters passed to each source
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_options(from = "gbif", where = "console")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occ_options_+3A_from">from</code></td>
<td>
<p>(character) Data source to get data from, any combination of
gbif, ebird, idigibio and/or vertnet. Case doesn't matter.
inat is not included here, see that package's help docs.</p>
</td></tr>
<tr><td><code id="occ_options_+3A_where">where</code></td>
<td>
<p>(character) One of console (print to console) or html (opens
help page, if in non-interactive R session, prints help to console).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any of the parameters passed to e.g. <code><a href="rgbif.html#topic+occ_data">rgbif::occ_data()</a></code> from the
<code>rgbif</code> package can be passed in the associated gbifopts list
in <code><a href="#topic+occ">occ()</a></code>
</p>
<p>Note that the from parameter is lowercased within the function and is
called through match.arg first, so you can match on unique partial
strings too (e.g., 'rv' for 'rvertnet').
</p>


<h3>Value</h3>

<p>Opens up the documentation for the function that is used internally
within the occ function for each source.
</p>


<h3>See Also</h3>

<p>Other queries: 
<code><a href="#topic+occ">occ</a>()</code>,
<code><a href="#topic+occ_names">occ_names</a>()</code>,
<code><a href="#topic+occ_names_options">occ_names_options</a>()</code>,
<code><a href="#topic+spocc_objects">spocc_objects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# opens up documentation for this function
occ_options()

# Open up documentation for the appropriate search function for each source
occ_options('gbif')
occ_options('ebird')
occ_options('idigbio')
occ_options('vertnet')

# Or open in html version
occ_options('gbif', 'html')

## End(Not run)
</code></pre>

<hr>
<h2 id='occ2df'>Combine results from occ calls to a single data.frame</h2><span id='topic+occ2df'></span>

<h3>Description</h3>

<p>Combine results from occ calls to a single data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ2df(obj, what = "data")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occ2df_+3A_obj">obj</code></td>
<td>
<p>Input from occ, an object of class <code>occdat</code>, or an object
of class <code>occdatind</code>, the individual objects from each source within the
<code>occdat</code> class.</p>
</td></tr>
<tr><td><code id="occ2df_+3A_what">what</code></td>
<td>
<p>(character) One of data (default) or all (with metadata)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines a subset of data from each data provider to a single
data.frame, or metadata plus data if you request <code>what="all"</code>. The
single data.frame contains the following columns:
</p>

<ul>
<li><p> name - scientific (or common) name
</p>
</li>
<li><p> longitude - decimal degree longitude
</p>
</li>
<li><p> latitude - decimal degree latitude
</p>
</li>
<li><p> prov - data provider
</p>
</li>
<li><p> date - occurrence record date
</p>
</li>
<li><p> key - occurrence record key
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# combine results from output of an occ() call
spnames &lt;- c('Accipiter striatus', 'Setophaga caerulescens',
  'Spinus tristis')
out &lt;- occ(query=spnames, from='gbif', gbifopts=list(hasCoordinate=TRUE),
  limit=10)
occ2df(out)
occ2df(out$gbif)

out &lt;- occ(
  query='Accipiter striatus',
  from=c('gbif','ebird','inat'),
  gbifopts=list(hasCoordinate=TRUE), limit=2)
occ2df(out)
occ2df(out$gbif)

# or combine many results from a single data source
spnames &lt;- c('Accipiter striatus', 'Spinus tristis')
out &lt;- occ(query=spnames, from='gbif', limit=2)
occ2df(out$gbif)

## End(Not run)
</code></pre>

<hr>
<h2 id='spocc_capwords'>Capitalize the first letter of a character string.</h2><span id='topic+spocc_capwords'></span>

<h3>Description</h3>

<p>Capitalize the first letter of a character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spocc_capwords(s, strict = FALSE, onlyfirst = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spocc_capwords_+3A_s">s</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="spocc_capwords_+3A_strict">strict</code></td>
<td>
<p>Should the algorithm be strict about capitalizing.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="spocc_capwords_+3A_onlyfirst">onlyfirst</code></td>
<td>
<p>Capitalize only first word, lowercase all others.
Useful for taxonomic names.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spocc_capwords(c('using AIC for model selection'))
spocc_capwords(c('using AIC for model selection'), strict=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='spocc_duplicates'>A note about duplicate occurrence records</h2><span id='topic+spocc_duplicates'></span>

<h3>Description</h3>

<p>BEWARE: spocc provides you a nice interface to many data providers for
species occurrence data. However, in cases where you request data from
GBIF <em>in addition</em> to other data sources, there could be duplicate records.
This is because GBIF is, to use an ecology  analogy, a top predator, and
pulls in data from lower nodes in the food chain. For example, iNaturalist
provides data to GBIF, so if you search for occurrence records for
<em>Pinus contorta</em> from iNaturalist and GBIF, you could get, for example,
20 of the same records.
</p>
<p>We think a single R interface to many occurrence record providers
will provide a consistent way to work with occurrence data, making
analyses and vizualizations more repeatable across providers.
</p>
<p>For cleaning data, see packages <code>scrubr</code>
(<a href="https://cran.r-project.org/package=scrubr">https://cran.r-project.org/package=scrubr</a>) and <code>CoordinateCleaner</code>
(<a href="https://cran.r-project.org/package=CoordinateCleaner">https://cran.r-project.org/package=CoordinateCleaner</a>)
</p>
<p>Do get in touch with us if you have concerns, have ideas for eliminating
duplicates
</p>

<hr>
<h2 id='spocc_objects'>spocc objects and their print, plot, and summary methods</h2><span id='topic+spocc_objects'></span><span id='topic+print.occdat'></span><span id='topic+print.occdatind'></span><span id='topic+summary.occdat'></span><span id='topic+summary.occdatind'></span><span id='topic+print.occnames'></span>

<h3>Description</h3>

<p>spocc objects and their print, plot, and summary methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'occdat'
print(x, ...)

## S3 method for class 'occdatind'
print(x, ...)

## S3 method for class 'occdat'
summary(object, ...)

## S3 method for class 'occdatind'
summary(object, ...)

## S3 method for class 'occnames'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spocc_objects_+3A_x">x</code></td>
<td>
<p>Input, of class occdatind</p>
</td></tr>
<tr><td><code id="spocc_objects_+3A_...">...</code></td>
<td>
<p>Further args to print, plot or summary methods</p>
</td></tr>
<tr><td><code id="spocc_objects_+3A_object">object</code></td>
<td>
<p>Input to summary methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other queries: 
<code><a href="#topic+occ">occ</a>()</code>,
<code><a href="#topic+occ_names">occ_names</a>()</code>,
<code><a href="#topic+occ_names_options">occ_names_options</a>()</code>,
<code><a href="#topic+occ_options">occ_options</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# occdat object
res &lt;- occ(query = 'Accipiter striatus', from = 'gbif')
res
print(res)
class(res)

# occdatind object
res$gbif
print(res$gbif)
class(res$gbif)

# print summary of occdat object
summary(res)

# print summary of occdatind object
summary(res$gbif)

# Geometry based searches print slightly differently
bounds &lt;- c(-120, 40, -100, 45)
(res &lt;- occ(from = "idigbio", geometry = bounds, limit = 10))
res$idigbio
## Many bounding boxes/WKT strings
bounds &lt;- list(c(165,-53,180,-29), c(-180,-53,-175,-29))
res &lt;- occ(from = "idigbio", geometry = bounds, limit = 10)
res$idigbio

## End(Not run)
</code></pre>

<hr>
<h2 id='spocc-package'>Interface to many species occurrence data sources</h2><span id='topic+spocc-package'></span>

<h3>Description</h3>

<p>A programmatic interface to many species occurrence data
sources, including GBIF, iNaturalist, Berkeley Ecoinformatics
Engine, eBird, iDigBio, VertNet, OBIS, and ALA. Includes
functionality for retrieving species occurrence data, and
combining that data.
</p>


<h3>Package API</h3>

<p>The main function to use is <code><a href="#topic+occ">occ()</a></code> - a single interface to
many species occurrence databases (see below for a list).
</p>
<p>Other functions include:
</p>

<ul>
<li> <p><code><a href="#topic+occ2df">occ2df()</a></code> - Combine results from <code>occ</code> into a
data.frame
</p>
</li>
<li> <p><code><a href="#topic+wkt_vis">wkt_vis()</a></code> - Visualize WKT strings (used to define
geometry based searches for some data sources) in an interactive map
</p>
</li></ul>



<h3>Currently supported species occurrence data sources</h3>


<table>
<tr>
 <td style="text-align: left;">
Provider </td><td style="text-align: left;"> Web </td>
</tr>
<tr>
 <td style="text-align: left;">
GBIF </td><td style="text-align: left;"> <a href="https://www.gbif.org/">https://www.gbif.org/</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
eBird </td><td style="text-align: left;"> <a href="http://ebird.org/content/ebird/">http://ebird.org/content/ebird/</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
iNaturalist </td><td style="text-align: left;"> <a href="https://www.inaturalist.org/">https://www.inaturalist.org/</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
VertNet </td><td style="text-align: left;"> <a href="http://vertnet.org/">http://vertnet.org/</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
iDigBio </td><td style="text-align: left;"> <a href="https://www.idigbio.org/">https://www.idigbio.org/</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
OBIS </td><td style="text-align: left;"> <a href="https://www.obis.org/">https://www.obis.org/</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
ALA </td><td style="text-align: left;"> <a href="https://www.ala.org.au/">https://www.ala.org.au/</a>
</td>
</tr>

</table>



<h3>Duplicates</h3>

<p>See <code><a href="#topic+spocc_duplicates">spocc_duplicates()</a></code> for more.
</p>


<h3>Clean data</h3>

<p>All data cleaning functionality is in as archived package: <code>scrubr</code>
(<a href="https://github.com/ropensci-archive/scrubr">https://github.com/ropensci-archive/scrubr</a>).
On CRAN: <a href="https://cran.r-project.org/src/contrib/Archive/scrubr/">https://cran.r-project.org/src/contrib/Archive/scrubr/</a>.
See also package
<a href="https://cran.r-project.org/package=CoordinateCleaner">https://cran.r-project.org/package=CoordinateCleaner</a>
</p>


<h3>Make maps</h3>

<p>All mapping functionality is now in a separate package: <code style="white-space: pre;">&#8288;mapr`` (&lt;https://github.com/ropensci/mapr&gt;) (formerly known as &#8288;</code>spoccutils').
On CRAN: <a href="https://cran.r-project.org/package=mapr">https://cran.r-project.org/package=mapr</a>
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain
</p>

<hr>
<h2 id='wkt_vis'>Visualize well-known text area's on a map.</h2><span id='topic+wkt_vis'></span>

<h3>Description</h3>

<p>This can be helpful in visualizing the area in which you are searching for
occurrences with the <code><a href="#topic+occ">occ()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkt_vis(x, zoom = 6, maptype = "terrain", browse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkt_vis_+3A_x">x</code></td>
<td>
<p>Input well-known text area (character)</p>
</td></tr>
<tr><td><code id="wkt_vis_+3A_zoom">zoom</code></td>
<td>
<p>Zoom level, defaults to 6 (numeric)</p>
</td></tr>
<tr><td><code id="wkt_vis_+3A_maptype">maptype</code></td>
<td>
<p>Map type, default is terrain (character)</p>
</td></tr>
<tr><td><code id="wkt_vis_+3A_browse">browse</code></td>
<td>
<p>Open in browser or not. If not, gives back
path to html file. Default: <code>TRUE</code> (logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Mapbox's map layers, openes in your default browser
</p>


<h3>See Also</h3>

<p>Other bbox: 
<code><a href="#topic+bbox2wkt">bbox2wkt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
poly &lt;- 'POLYGON((-111.06 38.84, -110.80 39.37, -110.20 39.17, -110.20 38.90,
     -110.63 38.67, -111.06 38.84))'
wkt_vis(poly)

poly2 &lt;- 'POLYGON((-125 38.4,-125 40.9,-121.8 40.9,-121.8 38.4,-125 38.4))'
wkt_vis(poly2)

# Multiple polygons
x &lt;- "POLYGON((-125 38.4, -121.8 38.4, -121.8 40.9, -125 40.9, -125 38.4), 
(-115 22.4, -111.8 22.4, -111.8 30.9, -115 30.9, -115 22.4))"
wkt_vis(x)

# don't open in browser
poly2 &lt;- 'POLYGON((-125 38.4,-125 40.9,-121.8 40.9,-121.8 38.4,-125 38.4))'
wkt_vis(poly2, browse = FALSE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
