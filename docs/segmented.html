<!DOCTYPE html><html lang="en"><head><title>Help for package segmented</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {segmented}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#segmented-package'>
<p>Segmented Relationships in Regression Models with Breakpoints / Changepoints Estimation (with Possibly Random Effects)</p></a></li>
<li><a href='#aapc'>
<p>Average annual per cent change in segmented trend analysis</p></a></li>
<li><a href='#broken.line'><p> Fitted values for segmented relationships</p></a></li>
<li><a href='#confint.segmented'><p> Confidence intervals for breakpoints</p></a></li>
<li><a href='#confint.segmented.lme'>
<p>Confidence intervals in segmented mixed models</p></a></li>
<li><a href='#confint.stepmented'><p> Confidence intervals for jumpoints in stepmented regression</p></a></li>
<li><a href='#davies.test'><p> Testing for a change in the slope</p></a></li>
<li><a href='#down'><p> Down syndrome in babies</p></a></li>
<li><a href='#draw.history'><p> History for the breakpoint estimates</p></a></li>
<li><a href='#fitted.segmented.lme'>
<p>Fitted values for segmented mixed fits</p></a></li>
<li><a href='#globTempAnom'><p> Global temperature anomalies 1850-2023</p></a></li>
<li><a href='#intercept'>
<p>Intercept estimates from segmented relationships</p></a></li>
<li><a href='#lines.segmented'><p> Bars for interval estimate of the breakpoints</p></a></li>
<li><a href='#lines.stepmented'><p> Bars for interval estimate of the breakpoints</p></a></li>
<li><a href='#model.matrix.segmented'>
<p>Design matrix for segmented fits</p></a></li>
<li><a href='#model.matrix.stepmented'>
<p>Design matrix for stepmented fits</p></a></li>
<li><a href='#plant'><p> Plan organ dataset</p></a></li>
<li><a href='#plot.segmented'><p> Plot method for segmented objects</p></a></li>
<li><a href='#plot.segmented.lme'>
<p>Plot method for segmented mixed objects</p></a></li>
<li><a href='#plot.stepmented'>
<p>Plot method for stepmented objects</p></a></li>
<li><a href='#points.segmented'>
<p>Points method for segmented objects</p></a></li>
<li><a href='#predict.segmented'>
<p>Predict method for segmented model fits</p></a></li>
<li><a href='#predict.stepmented'>
<p>Predict method for stepmented model fits</p></a></li>
<li><a href='#print.segmented'><p> Print method for the segmented class</p></a></li>
<li><a href='#print.segmented.lme'><p> Print method for the segmented.lme class</p></a></li>
<li><a href='#pscore.test'><p> Testing for existence of one breakpoint</p></a></li>
<li><a href='#pwr.seg'>
<p>Power Analysis in segmented regression</p></a></li>
<li><a href='#seg'>
<p>Specifying a segmented/stepmented term in the segreg/stepreg formula</p></a></li>
<li><a href='#seg.control'><p> Auxiliary for controlling segmented/stepmented model fitting</p></a></li>
<li><a href='#seg.lm.fit'>
<p>Fitter Functions for Segmented Linear Models</p></a></li>
<li><a href='#segmented'>
<p>Segmented relationships in regression models</p></a></li>
<li><a href='#segmented.lme'>
<p>Segmented relationships in linear mixed models</p></a></li>
<li><a href='#segreg'>
<p>Fitting segmented/stepmented regression</p></a></li>
<li><a href='#selgmented'>
<p>Selecting the number of breakpoints in segmented regression</p></a></li>
<li><a href='#slope'><p> Slope estimates from segmented/stepmented relationships</p></a></li>
<li><a href='#stagnant'><p>Stagnant band height data</p></a></li>
<li><a href='#step.lm.fit'>
<p>Fitter Functions for stepmented Linear Models</p></a></li>
<li><a href='#stepmented'>
<p>stepmented relationships in regression models</p></a></li>
<li><a href='#summary.segmented'><p> Summarizing  model fits for segmented regression</p></a></li>
<li><a href='#summary.segmented.lme'><p> Summarizing  model fits for segmented mixed-effects regression</p></a></li>
<li><a href='#summary.stepmented'><p> Summarizing  model fits for stepmented regression</p></a></li>
<li><a href='#vcov.segmented'>
<p>Variance-Covariance Matrix for a Fitted Segmented Model</p></a></li>
<li><a href='#vcov.segmented.lme'>
<p>Variance-Covariance Matrix for a Fitted Segmented Mixed Model</p></a></li>
<li><a href='#vcov.stepmented'>
<p>Variance-Covariance Matrix for a Fitted Stepmented Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regression Models with Break-Points / Change-Points Estimation
(with Possibly Random Effects)</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vito M. R. Muggeo &lt;vito.muggeo@unipa.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fitting regression models where, in addition to possible linear terms, one or more covariates have segmented (i.e., broken-line or piece-wise linear) or stepmented (i.e. piece-wise constant) effects. Multiple breakpoints for the same variable are allowed. 
  The estimation method is discussed in Muggeo (2003, &lt;<a href="https://doi.org/10.1002%2Fsim.1545">doi:10.1002/sim.1545</a>&gt;) and 
  illustrated in Muggeo (2008, <a href="https://www.r-project.org/doc/Rnews/Rnews_2008-1.pdf">https://www.r-project.org/doc/Rnews/Rnews_2008-1.pdf</a>). An approach for hypothesis testing is presented 
  in Muggeo (2016, &lt;<a href="https://doi.org/10.1080%2F00949655.2016.1149855">doi:10.1080/00949655.2016.1149855</a>&gt;), and interval estimation for the breakpoint is discussed in Muggeo (2017, &lt;<a href="https://doi.org/10.1111%2Fanzs.12200">doi:10.1111/anzs.12200</a>&gt;). 
  Segmented mixed models, i.e. random effects in the change point, are discussed in Muggeo (2014, &lt;<a href="https://doi.org/10.1177%2F1471082X13504721">doi:10.1177/1471082X13504721</a>&gt;).
  Estimation of piecewise-constant relationships and changepoints (mean-shift models) is 
  discussed in Fasola et al. (2018, &lt;<a href="https://doi.org/10.1007%2Fs00180-017-0740-4">doi:10.1007/s00180-017-0740-4</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), MASS, nlme</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-26 16:34:01 UTC; vito</td>
</tr>
<tr>
<td>Author:</td>
<td>Vito M. R. Muggeo <a href="https://orcid.org/0000-0002-3386-4054"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-28 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='segmented-package'>
Segmented Relationships in Regression Models with Breakpoints / Changepoints Estimation (with Possibly Random Effects) 
</h2><span id='topic+segmented-package'></span>

<h3>Description</h3>

<p>Estimation and inference of regression models with piecewise linear relationships, also known as segmented regression models, with a number of break-points fixed or to be &lsquo;selected&rsquo;. Random effects changepoints are also allowed since version 1.6-0, and since version 2.0-0 it is also possible to fit regression models with piecewise constant (or &lsquo;stepmented&rsquo;) relationships.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> segmented</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2025-02-26</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Package <code>segmented</code> aims to estimate linear and generalized linear models (and virtually any regression model) having one or more segmented or stepmented relationships in the linear predictor. Estimates of the slopes and
breakpoints are provided along with standard errors. The package includes testing/estimating
functions and methods to print, summarize and plot the results. 
</p>
<p>The algorithms used by <code>segmented</code> are <em>not</em> grid-search. They are iterative procedures (Muggeo, 2003; Fasola et al., 2018) that need starting values <em>only</em> for the breakpoint parameters and therefore they are quite efficient even
with several breakpoints to be estimated. Moreover since version 0.2-9.0, <code>segmented</code> implements 
the bootstrap restarting (Wood, 2001) to make the algorithms less sensitive to the starting values (which can be also omitted by the user) . 
</p>
<p>Since version 0.5-0.0 a default method <code>segmented.default</code> has been added. It may be employed to include segmented relationships in <em>general</em> regression models where specific methods do not exist. Examples include quantile, Cox, and lme regressions where the random effects do not refer to the breakpoints; see <code>segmented.lme</code> to include random changepoints.  <code><a href="#topic+segmented.default">segmented.default</a></code> includes some examples.
</p>
<p>Since version 1.0-0 the estimating algorithm has been slight modified and it appears to be much stabler (in examples with noisy segmented relationhips and flat log likelihoods)
then previous versions.
</p>
<p>Hypothesis testing (about the existence of the breakpoint) and confidence intervals are performed via appropriate methods and functions.
</p>
<p>A tentative approach to deal with unknown number of breakpoints is also provided, see option <code>fix.npsi</code> in <code><a href="#topic+seg.control">seg.control</a></code>. Also, as version 1.3-0, the <code><a href="#topic+selgmented">selgmented</a></code> function has been introduced to select the number of breakpoints via the BIC or sequential hypothesis testing.
</p>
<p>Since version 1.6-0, estimation of segmented mixed models has been introduced, see <code><a href="#topic+segmented.lme">segmented.lme</a></code> and related function. 
Since version 2.0-0, it is possible to fit segmented relationships with constraints on the slopes, see <code><a href="#topic+segreg">segreg</a></code>. 
</p>
<p>Finally, since 2.0-0, it is possible to fit (G)LM wherein one or more covariates  have a stepmented (i.e. a step-function like) relationship, see <code><a href="#topic+stepmented">stepmented</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vito M.R. Muggeo &lt;vito.muggeo@unipa.it&gt;
</p>


<h3>References</h3>

<p>Muggeo V.M.R., Atkins D.C., Gallop R.J., Dimidjian S. (2014) 
Segmented mixed models with random changepoints: a maximum likelihood approach 
with application to treatment for depression study. <em>Statistical Modelling</em>, <b>14</b>, 293-313.
</p>
<p>Muggeo, V.M.R. (2017) Interval estimation for the breakpoint in segmented regression: a smoothed score-based approach. 
<em>Australian &amp; New Zealand Journal of Statistics</em>, <b>59</b>, 311&ndash;322.
</p>
<p>Fasola S, Muggeo V.M.R., Kuchenhoff, H. (2018) A heuristic, iterative algorithm for change-point detection in abrupt change models, <em>Computational Statistics</em>, <b>2</b>, 997&ndash;1015.
</p>
<p>Muggeo, V.M.R. (2016) Testing with a nuisance parameter present only under the alternative: a score-based approach with application to segmented modelling. <em>J of Statistical Computation and Simulation</em> <b>86</b>, 3059&ndash;3067.
</p>
<p>Davies, R.B. (1987) Hypothesis testing when a nuisance parameter is present only under the alternative.
<em>Biometrika</em> <b>74</b>, 33&ndash;43.
</p>
<p>Seber, G.A.F. and Wild, C.J. (1989) <em>Nonlinear Regression</em>. Wiley, New York.
</p>
<p>Bacon D.W., Watts D.G. (1971) Estimating the transistion between two intersecting straight lines.
<em>Biometrika</em> <b>58</b>: 525 &ndash; 534.
</p>
<p>Muggeo, V.M.R. (2003) Estimating regression models with unknown break-points.
<em>Statistics in Medicine</em> <b>22</b>, 3055&ndash;3071.
</p>
<p>Muggeo, V.M.R. (2008) Segmented: an R package to fit regression 
models with broken-line relationships. <em>R News</em> <b>8/1</b>, 20&ndash;25.
</p>
<p>Muggeo, V.M.R., Adelfio, G. (2011) Efficient change point detection in genomic sequences of 
continuous measurements. <em>Bioinformatics</em> <b>27</b>, 161&ndash;166.
</p>
<p>Wood, S. N. (2001) Minimizing model fitting objectives that contain spurious local minima
by bootstrap restarting. <em>Biometrics</em> <b>57</b>, 240&ndash;244. 
</p>
<p>Muggeo, V.M.R. (2010) Comment on &lsquo;Estimating average annual per cent change in trend analysis&rsquo; by Clegg et al., Statistics in Medicine; 28, 3670-3682. 
<em>Statistics in Medicine</em>, <b>29</b>, 1958&ndash;1960.
</p>

<hr>
<h2 id='aapc'>
Average annual per cent change in segmented trend analysis
</h2><span id='topic+aapc'></span>

<h3>Description</h3>

<p>Computes the average annual per cent change  to summarize piecewise linear relationships in segmented regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aapc(ogg, parm, exp.it = FALSE, conf.level = 0.95, wrong.se = TRUE, 
    .vcov=NULL, .coef=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aapc_+3A_ogg">ogg</code></td>
<td>
<p> the fitted model returned by <code>segmented</code>. </p>
</td></tr>
<tr><td><code id="aapc_+3A_parm">parm</code></td>
<td>
<p> the <em>single</em> segmented variable of interest. It can be missing if the model includes a single segmented covariate. If missing and <code>ogg</code> includes several segmented variables, the first one is considered.</p>
</td></tr>
<tr><td><code id="aapc_+3A_exp.it">exp.it</code></td>
<td>
<p>logical. If <code>TRUE</code>, the per cent change is computed, namely <code class="reqn">\exp(\hat\mu)-1</code> where 
<code class="reqn">\mu=\sum_j \beta_jw_j</code>, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="aapc_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level desidered.</p>
</td></tr>
<tr><td><code id="aapc_+3A_wrong.se">wrong.se</code></td>
<td>
<p>logical, if <code>TRUE</code>, the 'wrong&rdquo; standard error (as discussed in Clegg et al. (2009)) ignoring 
uncertainty in the breakpoint estimate is returned as an attribute <code>"wrong.se"</code>.</p>
</td></tr>
<tr><td><code id="aapc_+3A_.vcov">.vcov</code></td>
<td>
<p> The <em>full</em> covariance matrix of estimates. If unspecified (i.e. <code>NULL</code>), the covariance matrix is computed internally by <code>vcov(ogg,...)</code>.</p>
</td></tr>
<tr><td><code id="aapc_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef(ogg)</code>.</p>
</td></tr>
<tr><td><code id="aapc_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code>vcov.segmented()</code>, such as <code>var.diff</code> or <code>is</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To summarize the fitted piecewise linear relationship, Clegg et al. (2009) proposed the 'average annual per cent change' (AAPC)
computed as the sum of the slopes (<code class="reqn">\beta_j</code>) weighted by corresponding covariate sub-interval width (<code class="reqn">w_j</code>), namely 
<code class="reqn">\mu=\sum_j \beta_jw_j</code>. Since the weights are the breakpoint differences, the standard error of the AAPC should account
for uncertainty in the breakpoint estimate, as discussed in Muggeo (2010) and implemented by <code>aapc()</code>.
</p>


<h3>Value</h3>

<p><code>aapc</code> returns a numeric vector including point estimate, standard error and confidence interval for the AAPC relevant to variable specified in <code>parm</code>.
</p>


<h3>Note</h3>

<p><code>exp.it=TRUE</code> would be appropriate only if the response variable is the log of (any) counts.
</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo, <a href="mailto:vito.muggeo@unipa.it">vito.muggeo@unipa.it</a> </p>


<h3>References</h3>

<p>Clegg LX, Hankey BF, Tiwari R, Feuer EJ, Edwards BK (2009) Estimating average annual per cent change in trend analysis. 
<em>Statistics in Medicine</em>, <b>28</b>; 3670-3682.
</p>
<p>Muggeo, V.M.R. (2010) Comment on &lsquo;Estimating average annual per cent change in trend analysis&rsquo; by Clegg et al., 
Statistics in Medicine; 28, 3670-3682. <em>Statistics in Medicine</em>, <b>29</b>, 1958&ndash;1960.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x&lt;-1:20
y&lt;-2-.5*x+.7*pmax(x-9,0)-.8*pmax(x-15,0)+rnorm(20)*.3
o&lt;-lm(y~x)
os&lt;-segmented(o, psi=c(5,12))
aapc(os)
</code></pre>

<hr>
<h2 id='broken.line'> Fitted values for segmented relationships</h2><span id='topic+broken.line'></span>

<h3>Description</h3>

<p>Given a segmented model (typically returned by a <code>segmented</code> method), <code>broken.line</code>
computes the fitted values (and relevant standard errors) for the specified &lsquo;segmented&rsquo; relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>broken.line(ogg, term = NULL, link = TRUE, interc=TRUE, se.fit=TRUE, isV=FALSE, 
  .vcov=NULL, .coef=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="broken.line_+3A_ogg">ogg</code></td>
<td>
<p> A fitted object of class segmented (returned by any <code>segmented</code> method). </p>
</td></tr>
<tr><td><code id="broken.line_+3A_term">term</code></td>
<td>
<p> Three options. i) A named list (whose name should be one of the segmented covariates in the model <code>ogg</code>) 
including the covariate values for which segmented predictions should be computed; ii) a character meaning 
the name of any segmented covariate in the model (and predictions corresponding to the observed covariate values are returned); 
iii) It can be <code>NULL</code> if the model includes a single segmented covariate (and predictions corresponding to the observed covariate values are returned).</p>
</td></tr>
<tr><td><code id="broken.line_+3A_link">link</code></td>
<td>
<p> Should the predictions be computed on the scale of the link function if <code>ogg</code> is a segmented glm fit? Default to <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="broken.line_+3A_interc">interc</code></td>
<td>
<p> Should the model intercept be added? (provided it exists).</p>
</td></tr>
<tr><td><code id="broken.line_+3A_se.fit">se.fit</code></td>
<td>
<p> If <code>TRUE</code> also standard errors for predictions are returned.</p>
</td></tr>
<tr><td><code id="broken.line_+3A_isv">isV</code></td>
<td>
<p> A couple of logicals indicating if the segmented terms <code class="reqn">(x-\psi)_+</code> and <code class="reqn">I(x&gt;\psi)</code> in the model matrix should be replaced by their smoothed counterparts when computing the standard errors. If a single logical is provided, it is applied to both terms.</p>
</td></tr>
<tr><td><code id="broken.line_+3A_.vcov">.vcov</code></td>
<td>
<p> Optional. The <em>full</em> covariance matrix of estimates. If <code>NULL</code> (and <code>se.fit=TRUE</code>), the matrix is computed internally via <code>vcov.segmented()</code>.</p>
</td></tr>
<tr><td><code id="broken.line_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef(ogg)</code>.</p>
</td></tr>
<tr><td><code id="broken.line_+3A_...">...</code></td>
<td>
<p> Additional arguments to be passed on to <code>vcov.segmented()</code> when computing the standard errors for the predictions, namely
<code>is</code>, <code>var.diff</code>, <code>p.df</code>. See <code><a href="#topic+summary.segmented">summary.segmented</a></code> and <code><a href="#topic+vcov.segmented">vcov.segmented</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>term=NULL</code> or <code>term</code> is a valid segmented covariate name, 
predictions for that segmented variable are the relevant fitted values from the model. If <code>term</code> 
is a (correctly named) list with numerical values, predictions corresponding to such specified values 
are computed. If <code>link=FALSE</code> and <code>ogg</code> inherits from the class &quot;glm&quot;, predictions and possible standard 
errors are returned on the response scale. The standard errors come from the Delta method.
Argument <code>link</code> is ignored whether <code>ogg</code> does not inherit from the class &quot;glm&quot;.
</p>


<h3>Value</h3>

<p>A list having one component if (if <code>se.fit=FALSE</code>), and two components (if <code>se.fit=TRUE</code>) list representing predictions and standard errors for the segmented covariate values.
</p>


<h3>Note</h3>

 
<p>This function was written when there was not <code>predict.segmented</code> (which is more general).
</p>


<h3>Author(s)</h3>

<p> Vito M. R. Muggeo </p>


<h3>See Also</h3>

 <p><code><a href="#topic+segmented">segmented</a></code>, <code><a href="#topic+predict.segmented">predict.segmented</a></code>, <code><a href="#topic+plot.segmented">plot.segmented</a></code>, <code><a href="#topic+vcov.segmented">vcov.segmented</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
z&lt;-runif(100)
y&lt;-rpois(100,exp(2+1.8*pmax(z-.6,0)))
o&lt;-glm(y~z,family=poisson)
o.seg&lt;-segmented(o,seg.Z=~z)
## Not run: plot(z,y)
## Not run: points(z,broken.line(o.seg,link=FALSE)$fit,col=2) #ok, but use plot.segmented()!
    </code></pre>

<hr>
<h2 id='confint.segmented'> Confidence intervals for breakpoints</h2><span id='topic+confint.segmented'></span>

<h3>Description</h3>

<p>Computes confidence intervals for the breakpoints in a fitted &lsquo;segmented&rsquo; model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented'
confint(object, parm, level=0.95, method=c("delta", "score", "gradient"), 
    rev.sgn=FALSE, var.diff=FALSE, is=FALSE, digits=max(4, getOption("digits") - 1), 
    .coef=NULL, .vcov=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.segmented_+3A_object">object</code></td>
<td>
<p>a fitted <code>segmented</code> object. </p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_parm">parm</code></td>
<td>
<p>the segmented variable of interest. If missing the first segmented variable in <code>object</code> is considered. </p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_level">level</code></td>
<td>
<p>the confidence level required, default to 0.95.</p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_method">method</code></td>
<td>
<p>which confidence interval should be computed. One of <code>"delta"</code>, <code>"score"</code>, or <code>"gradient"</code>. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_rev.sgn">rev.sgn</code></td>
<td>
<p>vector of logicals. The length should be equal to the length of <code>parm</code>; recycled otherwise.
when <code>TRUE</code> it is assumed that the current <code>parm</code> is &lsquo;minus&rsquo; the actual segmented variable,
therefore the sign is reversed before printing. This is useful when a null-constraint has been set on the last slope.</p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_var.diff">var.diff</code></td>
<td>
<p>logical. If <code>method="delta"</code>,  and there is a single segmented variable, <code>var.diff=TRUE</code> leads     to standard errors based on sandwich-type formula of the covariance matrix. See Details in <code><a href="#topic+summary.segmented">summary.segmented</a></code>.</p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_is">is</code></td>
<td>
<p>logical. If <code>method="delta"</code>, <code>is=TRUE</code> means that the full covariance matrix is computed via 
<code>vcov(.., is=TRUE)</code></p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_digits">digits</code></td>
<td>
<p>controls the number of digits to print when returning the output. </p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_.vcov">.vcov</code></td>
<td>
<p> The <em>full</em> covariance matrix of estimates. If unspecified (i.e. <code>NULL</code>), the covariance matrix is computed internally by <code>vcov(object)</code>.</p>
</td></tr>
<tr><td><code id="confint.segmented_+3A_...">...</code></td>
<td>
<p>additional parameters referring to Score-based confidence intervals, such as <code>"h"</code>, <code>"d.h"</code>, <code>"bw"</code>, <code>"msgWarn"</code>, and <code>"n.values"</code> 
specifying the number of points used to profile the Score (or Gradient) statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>confint.segmented</code> computes confidence limits for the breakpoints. Currently there are three options, see argument <code>method</code>. 
<code>method="delta"</code> uses the standard error coming from the Delta
method for the ratio of two random variables. This value is an approximation (slightly) better than the 
one reported in the &lsquo;psi&rsquo; component of the list returned by any <code>segmented</code> method. The resulting
confidence intervals are based on the asymptotic Normal distribution of the breakpoint
estimator which is reliable just for clear-cut kink relationships. See Details in <code><a href="#topic+segmented">segmented</a></code>. <br />
<code>method="score"</code> or <code>method="gradient"</code> compute the 
confidence interval via profiling the Score or the Gradient statistics smoothed out by the induced smoothing paradigm, as discussed in the reference below. 
</p>


<h3>Value</h3>

<p>A matrix including point estimate and confidence limits of the breakpoint(s) for the
segmented variable possibly specified in <code>parm</code>.
</p>


<h3>Note</h3>

 
<p>Currently <code>method="score"</code> or <code>method="gradient"</code> only works for segmented <em>linear</em> model. For segmented <em>generalized linear</em> model, currently only <code>method="delta"</code> is available. 
</p>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>References</h3>

 
<p>Muggeo, V.M.R. (2017) Interval estimation for the breakpoint in segmented regression: a smoothed score-based approach. 
<em>Australian &amp; New Zealand Journal of Statistics</em> <b>59</b>, 311&ndash;322.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+segmented">segmented</a></code> and <code><a href="#topic+lines.segmented">lines.segmented</a></code> to plot the estimated breakpoints with corresponding 
confidence intervals. </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
x&lt;-1:100
z&lt;-runif(100)
y&lt;-2+1.5*pmax(x-35,0)-1.5*pmax(x-70,0)+10*pmax(z-.5,0)+rnorm(100,0,2)
out.lm&lt;-lm(y~x)
o&lt;-segmented(out.lm,seg.Z=~x+z,psi=list(x=c(30,60),z=.4))
confint(o) #delta CI for the 1st variable 
confint(o, "x", method="score") #also method="g"
</code></pre>

<hr>
<h2 id='confint.segmented.lme'>
Confidence intervals in segmented mixed models 
</h2><span id='topic+confint.segmented.lme'></span>

<h3>Description</h3>

<p>Computes confidence intervals for all regression parameters, including the the breakpoint, in a fitted &lsquo;segmented mixed&rsquo; model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented.lme'
confint(object, parm, level = 0.95, obj.boot, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.segmented.lme_+3A_object">object</code></td>
<td>

<p>A fit object returned by <code><a href="#topic+segmented.lme">segmented.lme</a></code>.
</p>
</td></tr>
<tr><td><code id="confint.segmented.lme_+3A_parm">parm</code></td>
<td>

<p>A vector of numbers indicating which parameters should be considered. If missing all parameters.
</p>
</td></tr>
<tr><td><code id="confint.segmented.lme_+3A_level">level</code></td>
<td>

<p>The confidence level.
</p>
</td></tr>
<tr><td><code id="confint.segmented.lme_+3A_obj.boot">obj.boot</code></td>
<td>

<p>The possible list including the bootstrap distributions of the regression coefficients. Such list is returned by <code>vcov.segmented.lme(.., ret.b=TRUE)</code>
</p>
</td></tr>
<tr><td><code id="confint.segmented.lme_+3A_...">...</code></td>
<td>

<p>if <code>obj.boot</code> is missing and bootstrap CIs are requested, additional optional arguments, such as <code>B</code>, <code>seed</code>, and <code>it.max.b</code>, to be used in computations of the boot distributions. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>obj.boot</code> is provided or <code>...</code> includes the argument <code>B&gt;0</code>, confidence intervals are computed by exploiting the bootstrap 
distributions.
</p>


<h3>Value</h3>

<p>A matrix (or a list of matrices if bootstrap ci are requested) including the confidence intervals for the model parameters. 
</p>


<h3>Warning </h3>

<p>All the functions for segmented mixed models (*.segmented.lme) are still at an experimental stage 
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcov.segmented.lme">vcov.segmented.lme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
confint(os) #asymptotic CI

confint(os, B=50) #boot CIs

#it is possible to obtain the boot distribution beforehand
ob &lt;-vcov(os, B=50, ret.b=TRUE)
confint(os, obj.boot=ob) #boot CI


## End(Not run)
</code></pre>

<hr>
<h2 id='confint.stepmented'> Confidence intervals for jumpoints in stepmented regression</h2><span id='topic+confint.stepmented'></span>

<h3>Description</h3>

<p>Computes confidence intervals for the changepoints (or jumpoints) in a fitted &lsquo;stepmented&rsquo; model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stepmented'
confint(object, parm, level=0.95, method=c("delta", "score", "gradient"), 
    round=TRUE, cheb=FALSE, digits=max(4, getOption("digits") - 1), 
    .coef=NULL, .vcov=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.stepmented_+3A_object">object</code></td>
<td>
<p>a fitted <code>stepmented</code> object. </p>
</td></tr>
<tr><td><code id="confint.stepmented_+3A_parm">parm</code></td>
<td>
<p>the stepmented variable of interest. If missing the first stepmented variable in <code>object</code> is considered. </p>
</td></tr>
<tr><td><code id="confint.stepmented_+3A_level">level</code></td>
<td>
<p>the confidence level required, default to 0.95.</p>
</td></tr>
<tr><td><code id="confint.stepmented_+3A_method">method</code></td>
<td>
<p>which confidence interval should be computed. One of <code>"delta"</code>, <code>"score"</code>, or <code>"gradient"</code>. Can be abbreviated. Currently only <code>"delta"</code> allowed.</p>
</td></tr>
<tr><td><code id="confint.stepmented_+3A_round">round</code></td>
<td>
<p>logical. Should the values (estimates and lower/upper limits) rounded to the smallest observed value?</p>
</td></tr>
<tr><td><code id="confint.stepmented_+3A_cheb">cheb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the confidence limits are computed using the Chebyshev inequality which yields conservative confidence intervals but it is 'robust' to the non-normality of the changepoint sampling distribution. 
</p>
</td></tr>



<tr><td><code id="confint.stepmented_+3A_digits">digits</code></td>
<td>
<p>controls the number of digits to print when returning the output. </p>
</td></tr>
<tr><td><code id="confint.stepmented_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="confint.stepmented_+3A_.vcov">.vcov</code></td>
<td>
<p> The <em>full</em> covariance matrix of estimates. If unspecified (i.e. <code>NULL</code>), the covariance matrix is computed internally by <code>vcov(object)</code>.</p>
</td></tr>
<tr><td><code id="confint.stepmented_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>vcov.stepmented</code>, namely <code>k</code>. 

</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>confint.stepmented</code> computes confidence limits for the changepoints. Currently the only option is <code>'delta'</code>, i.e. to compute the approximate covariance matrix via a smoothing approximation (see <code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code>) and to build the limits using the standard Normal quantiles. Note that, the limits are rounded to the lowest observed value, thus the resulting confidence interval might not be symmetric if the stepmented covariate has not equispaced values. 
</p>


<h3>Value</h3>

<p>A matrix including point estimate and confidence limits of the breakpoint(s) for the
stepmented variable possibly specified in <code>parm</code>.
</p>


<h3>Note</h3>

 
<p>Currently only method='delta' is allowed. 

</p>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>See Also</h3>

 <p><code><a href="#topic+stepmented">stepmented</a></code> and <code><a href="#topic+lines.segmented">lines.segmented</a></code> to plot the estimated breakpoints with corresponding 
confidence intervals. </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
x&lt;-1:100
z&lt;-runif(100)
y&lt;-2+2.5*(x&gt;45)-1.5*(x&gt;70)+z+rnorm(100)
o&lt;-stepmented(y, npsi=2)

confint(o) #round=TRUE is default
confint(o, round=FALSE)  
</code></pre>

<hr>
<h2 id='davies.test'> Testing for a change in the slope </h2><span id='topic+davies.test'></span>

<h3>Description</h3>

<p>Given a generalized linear model, the Davies' test can be employed to test for a non-constant regression parameter
in the linear predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>davies.test(obj, seg.Z, k = 10, alternative = c("two.sided", "less", "greater"), 
    type=c("lrt","wald"), values=NULL, dispersion=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="davies.test_+3A_obj">obj</code></td>
<td>
<p> a fitted model typically returned by <code>glm</code> or <code>lm</code>. Even an object returned 
by <code>segmented</code> can be set (e.g. if interest lies in testing for an additional breakpoint).</p>
</td></tr>
<tr><td><code id="davies.test_+3A_seg.z">seg.Z</code></td>
<td>
<p> a formula with no response variable, such as <code>seg.Z=~x1</code>, indicating the 
(continuous) segmented variable being tested. Only a single variable may be tested and an
error is printed when <code>seg.Z</code> includes two or more terms. <code>seg.Z</code> can be omitted if i)<code>obj</code> is a segmented fit with a single segmented covariate (and that variable is taken), or ii)if it is a &quot;lm&quot; or &quot;glm&quot; fit with a single covariate (and that variable is taken)</p>
</td></tr>
<tr><td><code id="davies.test_+3A_k">k</code></td>
<td>
<p> number of points where the test should be evaluated. See Details. </p>
</td></tr>
<tr><td><code id="davies.test_+3A_alternative">alternative</code></td>
<td>
<p> a character string specifying the alternative hypothesis (relevant to the slope difference parameter). </p>
</td></tr>
<tr><td><code id="davies.test_+3A_type">type</code></td>
<td>
<p> the test statistic to be used (only for GLM, default to lrt). 
Ignored if <code>obj</code> is a simple linear model.</p>
</td></tr>
<tr><td><code id="davies.test_+3A_values">values</code></td>
<td>
<p> optional. The evaluation points where the Davies approximation is computed. See Details for default values.</p>
</td></tr>
<tr><td><code id="davies.test_+3A_dispersion">dispersion</code></td>
<td>
<p> the dispersion parameter for the family to be used to compute the test statistic.
When <code>NULL</code> (the default), it is inferred from <code>obj</code>. Namely it is taken as <code>1</code> for the
Binomial and Poisson families, and otherwise estimated by the residual Chi-squared statistic (calculated from cases with
non-zero weights) divided by the residual degrees of freedom.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>davies.test</code> tests for a non-zero difference-in-slope parameter of a segmented
relationship. Namely, the null hypothesis is <code class="reqn">H_0:\beta=0</code>, where <code class="reqn">\beta</code> is the difference-in-slopes, 
i.e. the coefficient of the segmented function <code class="reqn">\beta(x-\psi)_+</code>. The hypothesis of interest 
<code class="reqn">\beta=0</code> means no breakpoint. 
Roughtly speaking, the procedure computes <code>k</code> &lsquo;naive&rsquo; (i.e. assuming
fixed and known the breakpoint) test statistics for the difference-in-slope,
seeks the &lsquo;best&rsquo; value and corresponding naive p-value (according to the alternative hypothesis), and then corrects 
the selected (minimum) p-value by means of the <code>k</code> values of the test statistic. 
If <code>obj</code> is a LM, the Davies (2002) test is implemented. This approach works even for small samples. 
If <code>obj</code> represents a GLM fit, relevant methods are described in Davies (1987), and the Wald or the Likelihood ratio 
test statistics can be used, see argument <code>type</code>. This is an asymptotic test.
The <code>k</code> evaluation points are <code>k</code> equally spaced values between the second and the second-last 
values of the variable reported in <code>seg.Z</code>. <code>k</code> should not be small; I find no important difference for <code>k</code> larger than 10, so default 
is <code>k=10</code>. 
</p>


<h3>Value</h3>

<p>A list with class '<code>htest</code>' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method</code></td>
<td>
<p>title (character)</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the regression model and the segmented variable being tested</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the point within the range of the covariate in <code>seg.Z</code> at which the maximum 
(or the minimum if <code>alternative="less"</code>) occurs</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>number of evaluation points</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the adjusted p-value</p>
</td></tr>
<tr><td><code>process</code></td>
<td>
<p>a two-column matrix including the evaluation points and corresponding values of the test statistic</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The Davies test is <em>not</em> aimed at obtaining the estimate of the breakpoint.
The Davies test is based on <code>k</code> evaluation points, thus the value returned in the <code>statistic</code> component
(and printed as &quot;'best' at&quot;) is the best among the <code>k</code> points, and typically it will differ from the maximum likelihood estimate
returned by <code>segmented</code>. Use <code><a href="#topic+segmented">segmented</a></code> if you are interested in the point estimate. 
</p>
<p>To test for a breakpoint in <em>linear</em> models with small samples, it is suggested to use <code>davies.test()</code> with 
objects of class &quot;lm&quot;. If <code>obj</code> is a <code>"glm"</code> object with gaussian family, <code>davies.test()</code> will use 
an approximate test resulting in smaller p-values when the sample is small. 
However if the sample size is large (n&gt;300), the exact Davies (2002) upper bound cannot be computed (as it relies on 
<code>gamma()</code> function) and the <em>approximate</em> upper bound of Davies (1987) is returned.
</p>


<h3>Note</h3>

<p>Strictly speaking,
the Davies test is not confined to the segmented regression; the procedure can be applied when a nuisance parameter
vanishes under the null hypothesis. The test is slightly conservative, as the computed p-value is actually an upper
bound.
</p>
<p>Results should change slightly with respect to previous versions  where the evaluation points were computed 
as <code>k</code> equally spaced values between the second and the second last observed values of the segmented 
variable. 
</p>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>References</h3>

<p>Davies, R.B. (1987) Hypothesis testing when a nuisance parameter is present only under the alternative.
<em>Biometrika</em> <b>74</b>, 33&ndash;43. 
</p>
<p>Davies, R.B. (2002) Hypothesis testing when a nuisance parameter is present only under the alternative: 
linear model case. <em>Biometrika</em> <b>89</b>, 484&ndash;489. 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+pscore.test">pscore.test</a></code> which is more powerful, especially when the signal-to-noise ratio is low. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(20)
z&lt;-runif(100)
x&lt;-rnorm(100,2)
y&lt;-2+10*pmax(z-.5,0)+rnorm(100,0,3)

o&lt;-lm(y~z+x)
davies.test(o,~z)
davies.test(o,~x)

o&lt;-glm(y~z+x)
davies.test(o,~z) #it works but the p-value is too small..
  
## End(Not run)
</code></pre>

<hr>
<h2 id='down'> Down syndrome in babies</h2><span id='topic+down'></span>

<h3>Description</h3>

<p>The <code>down</code> data frame has 30 rows and 3 columns.
Variable <code>cases</code> means the number of babies with Down syndrome out of total number of births 
<code>births</code> for mothers with mean age <code>age</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(down)</code></pre>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 3 variables.
</p>

<dl>
<dt><code>age</code></dt><dd><p>the mothers' mean age.</p>
</dd>
<dt><code>births</code></dt><dd><p>count of total births.</p>
</dd>
<dt><code>cases</code></dt><dd><p>count of babies with Down syndrome.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Davison, A.C. and Hinkley, D. V. (1997) <em>Bootstrap Methods
and their Application</em>. Cambridge University Press.
</p>


<h3>References</h3>

<p>Geyer, C. J. (1991) Constrained maximum likelihood exemplified by isotonic 
convex logistic regression. <em>Journal of the American Statistical Association</em>
<b>86</b>, 717&ndash;724.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(down)
    </code></pre>

<hr>
<h2 id='draw.history'> History for the breakpoint estimates </h2><span id='topic+draw.history'></span>

<h3>Description</h3>

<p>Displays breakpoint iteration values for segmented fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.history(obj, term, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.history_+3A_obj">obj</code></td>
<td>
<p> a segmented fit returned by any &quot;segmented&quot; method. </p>
</td></tr>
<tr><td><code id="draw.history_+3A_term">term</code></td>
<td>
<p> a character to mean the &lsquo;segmented&rsquo; variable whose breakpoint values throughout iterations have to be displayed. </p>
</td></tr>
<tr><td><code id="draw.history_+3A_...">...</code></td>
<td>
<p> graphic parameters to be passed to <code>matplot()</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given <code>term</code> in a segmented fit, <code>draw.history()</code> produces two plots. On the left panel it displays the different breakpoint
values obtained during the estimating process, since the starting values up to the final ones, while on the right panel the objective values at different iterations.  When 
bootstrap restarting is employed, <code>draw.history()</code> produces two plots, the values of objective function 
and the number of distinct solutions against the bootstrap replicates.
</p>


<h3>Value</h3>

<p> None. </p>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stagnant)
os&lt;-segmented(lm(y~x,data=stagnant),seg.Z=~x,psi=-.8)
# draw.history(os) #diagnostics with boot restarting

os&lt;-segmented(lm(y~x,data=stagnant),seg.Z=~x,psi=-.8, control=seg.control(n.boot=0))
# draw.history(os) #diagnostics without boot restarting

</code></pre>

<hr>
<h2 id='fitted.segmented.lme'>
Fitted values for segmented mixed fits
</h2><span id='topic+fitted.segmented.lme'></span>

<h3>Description</h3>

<p>Computes fitted values at different levels of nesting for segmented mixed objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented.lme'
fitted(object, level = 1, sort=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.segmented.lme_+3A_object">object</code></td>
<td>

<p>Object of class <code>"segmented.lme"</code>
</p>
</td></tr>
<tr><td><code id="fitted.segmented.lme_+3A_level">level</code></td>
<td>

<p>the level to be considered. Currently only levels 0 or 1 are allowed.
</p>
</td></tr>
<tr><td><code id="fitted.segmented.lme_+3A_sort">sort</code></td>
<td>

<p>If <code>TRUE</code>, the fitted values are sorted by the names of the 'id' levels.
</p>
</td></tr>
<tr><td><code id="fitted.segmented.lme_+3A_...">...</code></td>
<td>

<p>Ignored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently it works only if <code>level=1</code>
</p>


<h3>Value</h3>

<p>A numeric object including the fitted values at the specified level of nesting.
</p>


<h3>Warning </h3>

<p>All the functions for segmented mixed models (*.segmented.lme) are still at an experimental stage 
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.segmented.lme">summary.segmented.lme</a></code>
</p>

<hr>
<h2 id='globTempAnom'> Global temperature anomalies 1850-2023</h2><span id='topic+globTempAnom'></span>

<h3>Description</h3>

<p>The <code>globTempAnom</code> data frame includes the global surface temperature anomalies from 1850 to 2023.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(globTempAnom)</code></pre>


<h3>Format</h3>

<p>The included variables are (clearly).
</p>

<dl>
<dt><code>Year</code></dt><dd><p>the calendar year.</p>
</dd>
<dt><code>Anomaly</code></dt><dd><p>the temperature anomalies computed as differences of the annual (average) measurement with respect to the 20th century average (1901-2000). </p>
</dd>
</dl>



<h3>Details</h3>

<p>Data refer to averages measurements referring to land and ocean surface of Northern and Southern hemisphere.
</p>


<h3>Source</h3>

<p>https://www.ncei.noaa.gov/access/monitoring/global-temperature-anomalies/anomalies
</p>


<h3>References</h3>

<p>There are several references using such dataset, e.g.
</p>
<p>Cahill, N., Rahmstorf, S., and Parnell, A. C. (2015). Change points of
global temperature. <em>Environmental Research Letters</em>, 10: 1-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(globTempAnom)
    </code></pre>

<hr>
<h2 id='intercept'>
Intercept estimates from segmented relationships
</h2><span id='topic+intercept'></span>

<h3>Description</h3>

<p>Computes the intercepts of each &lsquo;segmented&rsquo; relationship in the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercept(ogg, parm, rev.sgn = FALSE, var.diff=FALSE,
    .vcov=NULL, .coef=NULL, digits = max(4, getOption("digits") - 2),...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercept_+3A_ogg">ogg</code></td>
<td>

<p>an object of class &quot;segmented&quot;, returned by any <code>segmented</code> method.
</p>
</td></tr>
<tr><td><code id="intercept_+3A_parm">parm</code></td>
<td>

<p>the segmented variable whose intercepts have to be computed. If missing all the segmented variables in the model are considered. 
</p>
</td></tr>
<tr><td><code id="intercept_+3A_rev.sgn">rev.sgn</code></td>
<td>
<p>vector of logicals. The length should be equal to the length of <code>parm</code>, but it is recycled otherwise.
When <code>TRUE</code> it is assumed that the current <code>parm</code> is &lsquo;minus&rsquo; the actual segmented variable,
therefore the order is reversed before printing. This is useful when a null-constraint has been set on the last slope.
</p>
</td></tr>
<tr><td><code id="intercept_+3A_var.diff">var.diff</code></td>
<td>
<p>Currently ignored as only point estimates are computed.


</p>
</td></tr>
<tr><td><code id="intercept_+3A_.vcov">.vcov</code></td>
<td>
<p> The <em>full</em> covariance matrix of estimates. If unspecified (i.e. <code>NULL</code>), the covariance matrix is computed internally by     <code>vcov(ogg)</code>.</p>
</td></tr>
<tr><td><code id="intercept_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef(ogg)</code>.</p>
</td></tr>
<tr><td><code id="intercept_+3A_digits">digits</code></td>
<td>
<p>controls number of digits in the returned output.</p>
</td></tr>
<tr><td><code id="intercept_+3A_...">...</code></td>
<td>
<p> Further arguments to be passed on to <code>vcov.segmented</code>, such as <code>var.diff</code> and <code>is</code>. See Details in <code><a href="#topic+vcov.segmented">vcov.segmented</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A broken-line relationship means that a regression equation exists in the intervals 
'<code class="reqn">min(x)</code> to <code class="reqn">\psi_1</code>', '<code class="reqn">\psi_1</code> to <code class="reqn">\psi_2</code>', and so on.
<code>intercept</code> computes point estimates of the intercepts of the different regression equations 
for each segmented relationship in the fitted model.
</p>


<h3>Value</h3>

<p><code>intercept</code> returns a list of one-column matrices. Each matrix represents a segmented relationship.
</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo, <a href="mailto:vito.muggeo@unipa.it">vito.muggeo@unipa.it</a></p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+slope">slope</a></code> to compute the slopes of the different regression equations 
for each segmented relationship in the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see ?slope
## Not run: 
intercept(out.seg)

## End(Not run)
</code></pre>

<hr>
<h2 id='lines.segmented'> Bars for interval estimate of the breakpoints </h2><span id='topic+lines.segmented'></span>

<h3>Description</h3>

<p>Draws bars relevant to breakpoint estimates (point estimate and confidence limits)
on the current device
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented'
lines(x, term, bottom = TRUE, shift=FALSE, conf.level = 0.95, k = 50, 
    pch = 18, rev.sgn = FALSE, .vcov=NULL, .coef=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines.segmented_+3A_x">x</code></td>
<td>
<p> an object of class <code>segmented</code>. </p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_term">term</code></td>
<td>
<p> the segmented variable of the breakpoints being drawn. It may be unspecified when there is a single segmented variable.</p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_bottom">bottom</code></td>
<td>
<p> logical, indicating if the bars should be plotted at the bottom (<code>TRUE</code>) or at the top (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_shift">shift</code></td>
<td>
<p> logical, indicating if the bars should be &lsquo;shifted&rsquo; on the y-axis before plotting. Useful for multiple breakpoints
with overlapped confidence intervals.</p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_conf.level">conf.level</code></td>
<td>
<p> the confidence level of the confidence intervals for the breakpoints. </p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_k">k</code></td>
<td>
<p> a positive integer regulating the vertical position of the drawn bars. See Details. </p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_pch">pch</code></td>
<td>
<p> either an integer specifying a symbol or a single character to be used
in plotting the point estimates of the breakpoints. See <code><a href="graphics.html#topic+points">points</a></code>. </p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_rev.sgn">rev.sgn</code></td>
<td>
<p> should the signs of the breakpoint estimates be changed before plotting? see Details. </p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_.vcov">.vcov</code></td>
<td>
<p> The <em>full</em> covariance matrix of estimates. If unspecified (i.e. <code>NULL</code>), the covariance matrix is computed internally by <code>vcov(x)</code>.</p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef(x)</code>.</p>
</td></tr>
<tr><td><code id="lines.segmented_+3A_...">...</code></td>
<td>
<p> further arguments passed to <code><a href="graphics.html#topic+arrows">arrows</a></code>, for instance &lsquo;col&rsquo; that 
can be a vector. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lines.segmented</code> simply draws on the current device the point estimates and relevant
confidence limits of the estimated breakpoints from a &quot;segmented&quot; object. The y coordinate
where the bars are drawn is computed as <code>usr[3]+h</code> if <code>bottom=TRUE</code> or
<code>usr[4]-h</code> when <code>bottom=FALSE</code>, where <code>h=(usr[4]-usr[3])/abs(k)</code> and
<code>usr</code> are the extremes of the user coordinates of the plotting region.
Therefore for larger values of <code>k</code> the bars are plotted on the edges.
The argument <code>rev.sgn</code> allows to change the sign of the breakpoints before plotting. This may
be useful when a null-right-slope constraint is set.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.segmented">plot.segmented</a></code> to plot the fitted segmented lines, and  
<code><a href="#topic+points.segmented">points.segmented</a></code> to add the fitted joinpoints. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## See ?plot.segmented

</code></pre>

<hr>
<h2 id='lines.stepmented'> Bars for interval estimate of the breakpoints </h2><span id='topic+lines.stepmented'></span>

<h3>Description</h3>

<p>Draws bars relevant to breakpoint estimates (point estimate and confidence limits)
on the current device
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stepmented'
lines(x, term, bottom = TRUE, shift=FALSE, conf.level = 0.95, k = 50, 
    pch = 18, .vcov=NULL, .coef=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines.stepmented_+3A_x">x</code></td>
<td>
<p> an object of class <code>stepmented</code>. </p>
</td></tr>
<tr><td><code id="lines.stepmented_+3A_term">term</code></td>
<td>
<p> the stepmented variable of the breakpoints being drawn. It may be unspecified when there is a single stepmented variable.</p>
</td></tr>
<tr><td><code id="lines.stepmented_+3A_bottom">bottom</code></td>
<td>
<p> logical, indicating if the bars should be plotted at the bottom (<code>TRUE</code>) or at the top (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="lines.stepmented_+3A_shift">shift</code></td>
<td>
<p> logical, indicating if the bars should be &lsquo;shifted&rsquo; on the y-axis before plotting. Useful for multiple breakpoints
with overlapped confidence intervals.</p>
</td></tr>
<tr><td><code id="lines.stepmented_+3A_conf.level">conf.level</code></td>
<td>
<p> the confidence level of the confidence intervals for the breakpoints. </p>
</td></tr>
<tr><td><code id="lines.stepmented_+3A_k">k</code></td>
<td>
<p> a positive integer regulating the vertical position of the drawn bars. See Details. </p>
</td></tr>
<tr><td><code id="lines.stepmented_+3A_pch">pch</code></td>
<td>
<p> either an integer specifying a symbol or a single character to be used
in plotting the point estimates of the breakpoints. See <code><a href="graphics.html#topic+points">points</a></code>. </p>
</td></tr>
<tr><td><code id="lines.stepmented_+3A_.vcov">.vcov</code></td>
<td>
<p> The <em>full</em> covariance matrix of estimates. If unspecified (i.e. <code>NULL</code>), the covariance matrix is computed internally by <code>vcov(x)</code>.</p>
</td></tr>
<tr><td><code id="lines.stepmented_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef(x)</code>.</p>
</td></tr>
<tr><td><code id="lines.stepmented_+3A_...">...</code></td>
<td>
<p> further arguments passed to <code><a href="graphics.html#topic+arrows">arrows</a></code>, for instance &lsquo;col&rsquo; that 
can be a vector. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lines.stepmented</code> simply draws on the current device the point estimates and relevant
confidence limits of the estimated breakpoints from a &quot;stepmented&quot; object. The y coordinates
where the bars are drawn is computed as <code>usr[3]+h</code> if <code>bottom=TRUE</code> or
<code>usr[4]-h</code> when <code>bottom=FALSE</code>, where <code>h=(usr[4]-usr[3])/abs(k)</code> and
<code>usr</code> are the extremes of the user coordinates of the plotting region.
Therefore for larger values of <code>k</code> the bars are plotted on the edges.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.stepmented">plot.stepmented</a></code> to plot the fitted stepmented lines</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See ?plot.stepmented

</code></pre>

<hr>
<h2 id='model.matrix.segmented'>
Design matrix for segmented fits
</h2><span id='topic+model.matrix.segmented'></span>

<h3>Description</h3>

<p>This function builds the model matrix for <code>segmented</code> fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.matrix.segmented_+3A_object">object</code></td>
<td>

<p>A segmented fit
</p>
</td></tr>
<tr><td><code id="model.matrix.segmented_+3A_...">...</code></td>
<td>

<p>additional arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.matrix.segmented</code>
</p>


<h3>Value</h3>

<p>The design matrix for a segmented regression model with the specified formula and data
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>
</p>

<hr>
<h2 id='model.matrix.stepmented'>
Design matrix for stepmented fits
</h2><span id='topic+model.matrix.stepmented'></span>

<h3>Description</h3>

<p>This function builds the model matrix for <code>stepmented</code> fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stepmented'
model.matrix(object, type=c("cdf","abs","none"), k=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.matrix.stepmented_+3A_object">object</code></td>
<td>

<p>A stepmented fit
</p>
</td></tr>
<tr><td><code id="model.matrix.stepmented_+3A_k">k</code></td>
<td>

<p>The (negative) exponent of the sample size to approximate the absolute value; see <code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code> for details.
</p>
</td></tr>
<tr><td><code id="model.matrix.stepmented_+3A_type">type</code></td>
<td>

<p>The approximation for the indicator function/absolute value. If <code>"none"</code>, the simple matrix with the original indicator values is returned. <code>type='abs'</code> is not yet allowed.  
</p>
</td></tr>
<tr><td><code id="model.matrix.stepmented_+3A_...">...</code></td>
<td>

<p>additional arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type="none"</code>, <code>model.matrix.stepmented</code> return the design matrix including the indicator function values and ignoring the psi terms.
</p>


<h3>Value</h3>

<p>The design matrix for a stepmented regression model with the specified formula and data
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code> 
</p>

<hr>
<h2 id='plant'> Plan organ dataset</h2><span id='topic+plant'></span>

<h3>Description</h3>

<p>The <code>plant</code> data frame has 103 rows and 3 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(plant)</code></pre>


<h3>Format</h3>

<p>A data frame with 103 observations on the following 3 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>measurements of the plant organ.</p>
</dd>
<dt><code>time</code></dt><dd><p>times where measurements took place.</p>
</dd>
<dt><code>group</code></dt><dd><p>three attributes of the plant organ, <code>RKV</code>, <code>RKW</code>, <code>RWC</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Three attributes of a plant organ measured over time where biological reasoning indicates
likelihood of multiple breakpoints.  The data are scaled to the maximum value
for each attribute and all attributes are measured at each time.
</p>


<h3>Source</h3>

<p>The data have been kindly provided by Dr Zongjian Yang
at School of Land, Crop and Food Sciences, The University of Queensland, Brisbane, Australia.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(plant)

lattice::xyplot(y~time,groups=group,auto.key=list(space="right"), data=plant)

o&lt;-segreg(y~ 0+group+seg(time, by=group, npsi=2), data=plant)
summary(o)

par(mfrow=c(1,2))
plot(y~time, data=plant)
plot(o, term=1:3, add=TRUE, leg=NA, psi.lines=TRUE) #add the lines to the current plot

plot(o, term=1:3, col=3:5, res.col=3:5, res=TRUE, leg="bottomright")


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.segmented'> Plot method for segmented objects  </h2><span id='topic+plot.segmented'></span>

<h3>Description</h3>

<p>Takes a fitted <code>segmented</code> object returned by <code>segmented()</code> and plots (or adds)
the fitted broken-line relationship for the selected segmented term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented'
plot(x, term, add=FALSE, res=FALSE, conf.level=0, interc=TRUE, link=TRUE, 
    res.col=grey(.15, alpha = .4), rev.sgn=FALSE, const=NULL, shade=FALSE, rug=!add, 
    dens.rug=FALSE, dens.col = grey(0.8), transf=I, isV=FALSE, is=FALSE, var.diff=FALSE, 
    p.df="p", .vcov=NULL, .coef=NULL, prev.trend=FALSE, smoos=NULL, hide.zeros=FALSE, 
    leg="topleft", psi.lines=FALSE, ...)
      </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.segmented_+3A_x">x</code></td>
<td>
<p> a fitted <code>segmented</code> object. </p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_term">term</code></td>
<td>
<p>Numerical or character to indicate the segmented variable having the piece-wise relationship to be plotted. If there is a single segmented variable in the fitted model <code>x</code>, <code>term</code> can be omitted.
If vector, multiple segmented lines will be drawn on the same plot.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_add">add</code></td>
<td>
<p> when <code>TRUE</code> the fitted lines are added to the current device.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_res">res</code></td>
<td>
<p> when <code>TRUE</code> the fitted lines are plotted along with corresponding partial residuals.
See Details.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_conf.level">conf.level</code></td>
<td>
<p> If greater than zero, it means the confidence level at which the pointwise confidence itervals have to 
be plotted.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_interc">interc</code></td>
<td>
<p> If <code>TRUE</code> the computed segmented components include the model intercept (if it exists).</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_link">link</code></td>
<td>
<p> when <code>TRUE</code> (default), the fitted lines are plotted on the link scale, otherwise they are
tranformed on the response scale before plotting. Ignored for linear segmented fits. </p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_res.col">res.col</code></td>
<td>
<p>when <code>res=TRUE</code> it means the color of the points representing the partial residuals.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_rev.sgn">rev.sgn</code></td>
<td>
<p> when <code>TRUE</code> it is assumed that current <code>term</code> is &lsquo;minus&rsquo; the actual segmented variable,
therefore the sign is reversed before plotting. This is useful when a null-constraint has been set on the last slope.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_const">const</code></td>
<td>
<p> constant to add to each fitted segmented relationship (on the scale of the linear predictor) before plotting.
If <code>const=NULL</code> and the fit includes a segmented interaction term (obtained via <code>seg(..,by)</code> in the formula), the group-specific intercept is included. 
</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_shade">shade</code></td>
<td>
<p>if <code>TRUE</code> and <code>conf.level&gt;0</code> it produces shaded regions (in grey color) for the pointwise confidence 
intervals embracing the fitted segmented line. </p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_rug">rug</code></td>
<td>
<p>when <code>TRUE</code> the covariate values are displayed as a rug plot
at the foot of the plot. Default is to <code>!add</code>.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_dens.rug">dens.rug</code></td>
<td>
<p>when <code>TRUE</code> then smooth covariate distribution is plotted on the x-axis.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_dens.col">dens.col</code></td>
<td>
<p>if <code>dens.rug=TRUE</code>, it means the colour to be used to plot the density.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_transf">transf</code></td>
<td>
<p> A possible function to convert the fitted values before plotting. It is only effective 
if <code>res=FALSE</code>. If <code>res=TRUE</code> any transformation is ignored.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_isv">isV</code></td>
<td>
<p>logical value (to be passed to <code><a href="#topic+broken.line">broken.line</a></code>). Ignored if <code>conf.level=0</code></p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_is">is</code></td>
<td>
<p>logical value (to be passed to <code><a href="#topic+broken.line">broken.line</a></code>) indicating if the covariance matrix based on the induced smoothing should be used. Ignored if <code>conf.level=0</code></p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_var.diff">var.diff</code></td>
<td>
<p>logical value to be passed to <code><a href="#topic+summary.segmented">summary.segmented</a></code> to compute dthe standard errors of fitted values (if <code>conf.level&gt;0</code>).</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_p.df">p.df</code></td>
<td>
<p> degrees of freedom when <code>var.diff=TRUE</code>, see <code><a href="#topic+summary.segmented">summary.segmented</a></code></p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_.vcov">.vcov</code></td>
<td>
<p> The <em>full</em> covariance matrix of estimates to be used when <code>conf.level&gt;0</code>. If unspecified (i.e. <code>NULL</code>), the covariance matrix is computed internally by the function <code>vcov.segmented</code>.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef()</code>.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_prev.trend">prev.trend</code></td>
<td>
<p>logical. If <code>TRUE</code> dashed lines corresponding to the &lsquo;previous&rsquo; trends (i.e. the trends if the breakpoints would not have occurred) are also drawn.</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_smoos">smoos</code></td>
<td>

<p>logical, indicating if the residuals (provided that <code>res=TRUE</code>) will be drawn using a <em>smoothed</em> scatterplot. If <code>NULL</code> (default) the smoothed scatterplot will be employed when the number of observation is larger than 10000.
</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_hide.zeros">hide.zeros</code></td>
<td>

<p>logical, indicating if the residuals (provided that <code>res=TRUE</code>) corresponding to the covariate zero values should be deleted. Useful when the fit includes an interaction term in the formula, such as <code>seg(.., by=..)</code>, and the zeros in covariates indicate units in other groups.
</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_leg">leg</code></td>
<td>

<p>If the plot refers to segmented relationships in groups, i.e. <code>term</code> has been specified as a vector, a legend is placed at the specified <code>leg</code> position. Put <code>NA</code> not to draw the legend.
</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_psi.lines">psi.lines</code></td>
<td>

<p>if <code>TRUE</code> vertical lines corresponding to the estimated breakpoints are also drawn. Ignored if <code>term</code> is not a vector.
</p>
</td></tr>
<tr><td><code id="plot.segmented_+3A_...">...</code></td>
<td>
<p> other graphics parameters to pass to plotting commands: &lsquo;col&rsquo;, &lsquo;lwd&rsquo; and &lsquo;lty&rsquo; (that
can be vectors and are recycled if necessary, see the example below) for the fitted piecewise lines; &lsquo;ylab&rsquo;, &lsquo;xlab&rsquo;, &lsquo;main&rsquo;, &lsquo;sub&rsquo;, &lsquo;cex.axis&rsquo;, &lsquo;cex.lab&rsquo;, &lsquo;xlim&rsquo; and 
&lsquo;ylim&rsquo; when a new plot is produced (i.e. when <code>add=FALSE</code>); &lsquo;pch&rsquo; and &lsquo;cex&rsquo; for the partial residuals (when <code>res=TRUE</code>, <code>res.col</code> is for the color); <code>col.shade</code> for the shaded regions (provided that <code>shade=TRUE</code> and <code>conf.level&gt;0</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces (or adds to the current device) the fitted segmented relationship between the
response and the selected <code>term</code>. If the fitted model includes just a single &lsquo;segmented&rsquo; variable,
<code>term</code> may be omitted. <br /> 
The partial residuals are computed as &lsquo;fitted + residuals&rsquo;, where &lsquo;fitted&rsquo; are the fitted values of the
segmented relationship relevant to the covariate specified in <code>term</code>. 
Notice that for GLMs the residuals are the response residuals if <code>link=FALSE</code> and
the working residuals if <code>link=TRUE</code>.<br /> 
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Note</h3>

<p> For models with offset, partial residuals on the response scale are not defined. Thus <code>plot.segmented</code> does not work 
when <code>link=FALSE</code>, <code>res=TRUE</code>, and the fitted model includes an offset.<br />
When <code>term</code> is a vector and multiple segmented relationships are being drawn on the same plot, <code>col</code> and <code>res.col</code> can be vectors. Also <code>pch</code>, <code>cex</code>, <code>lty</code>, and <code>lwd</code> can be vectors, if specified.
</p>


<h3>Author(s)</h3>

<p> Vito M. R. Muggeo </p>


<h3>See Also</h3>

 <p><code><a href="#topic+segmented">segmented</a></code> to fit the model, <code><a href="#topic+lines.segmented">lines.segmented</a></code> to add the estimated breakpoints on the current plot. 
<code><a href="#topic+points.segmented">points.segmented</a></code> to add the joinpoints of the segmented relationship.
<code><a href="#topic+predict.segmented">predict.segmented</a></code> to compute standard errors and confidence intervals for predictions from a 
&quot;segmented&quot; fit. </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
z&lt;-runif(100)
y&lt;-rpois(100,exp(2+1.8*pmax(z-.6,0)))
o&lt;-glm(y~z,family=poisson)
o.seg&lt;-segmented(o) #single segmented covariate and one breakpoint: 'seg.Z' and 'psi' can be omitted
par(mfrow=c(1,2))
plot(o.seg, conf.level=0.95, shade=TRUE)
points(o.seg, link=TRUE, col=2)
## new plot
plot(z,y)
## add the fitted lines using different colors and styles..
plot(o.seg,add=TRUE,link=FALSE,lwd=2,col=2:3, lty=c(1,3))
lines(o.seg,col=2,pch=19,bottom=FALSE,lwd=2) #for the CI for the breakpoint
points(o.seg,col=4, link=FALSE)
## using the options 'is', 'isV', 'shade' and 'col.shade'.
par(mfrow=c(1,2))
plot(o.seg, conf.level=.9, is=TRUE, isV=TRUE, col=1, shade = TRUE, col.shade=2)
plot(o.seg, conf.level=.9, is=TRUE, isV=FALSE, col=2, shade = TRUE, res=TRUE, res.col=4, pch=3)
</code></pre>

<hr>
<h2 id='plot.segmented.lme'>
Plot method for segmented mixed objects
</h2><span id='topic+plot.segmented.lme'></span>

<h3>Description</h3>

<p>Takes a fitted <code>segmented.lme</code> object returned by <code>segmented.lme()</code> and plots (or adds)
the fitted broken-line relationship for the segmented term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented.lme'
plot(x, level=1, id = NULL, res = TRUE, pop = FALSE, yscale = 1, xscale = 1, 
    n.plot, pos.leg = "topright", vline = FALSE, lines = TRUE, 
    by=NULL, add=FALSE, conf.level=0, withI=TRUE, vcov.=NULL, shade=FALSE, 
    drop.var=NULL, text.leg=NULL, id.name=TRUE, ci.psi.pop=-1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.segmented.lme_+3A_x">x</code></td>
<td>

<p>Object of class <code>"segmented.lme"</code>
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_level">level</code></td>
<td>

<p>An integer giving the level of grouping to be used when computing the segmented relationship(s). <code>level=0</code> means depending on fixed effects estimates only (such estimates are also said, to some extend, 'population' or 'marginal' estimates), otherewise the segmented lines will also depend on the random effects predictions. 
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_id">id</code></td>
<td>

<p>A scalar or vector meaning which subjects profiles have to be drawn. If <code>NULL</code> (default) all profiles are drawn. Ignored if <code>level=0</code>.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_res">res</code></td>
<td>

<p>If <code>TRUE</code>, the data points are also drawn. Ignored if <code>level=0</code>.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_pop">pop</code></td>
<td>

<p>if <code>TRUE</code>, the fitted segmented relationships based on fixed-effects only is also portrayed. Ignored if <code>level=0</code>.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_yscale">yscale</code></td>
<td>

<p>If <code>&gt;= 0</code>, the same and common y-scale is used for all 'subjects' (panels); otherwise the y-scale will depend on the actual (observed and fitted) values for each 'subject'.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_xscale">xscale</code></td>
<td>

<p>If <code>&gt;= 0</code>, the same and common x-scale is used for all 'subjects' (panels); otherwise the x-scale will depend on the actual observed values of the segmented covariate for each 'subject'.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_n.plot">n.plot</code></td>
<td>

<p>a vector to be passed to <code>par(mfrow=c(..))</code> for plotting multiple panels (should be coherent with <code>length(id)</code>). If missing, it is computed automatically depending on <code>length(id)</code>. Type <code>n.plot=1</code> to draw all the segmented profiles on the same panel.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_pos.leg">pos.leg</code></td>
<td>

<p>a character ('topright', 'topleft',...) meaning the location of the legend. Set <code>NULL</code> for no legend.  
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_vline">vline</code></td>
<td>

<p>logical, if <code>TRUE</code> a vertical dashed segment is added to emphasize the breakpoint location.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_lines">lines</code></td>
<td>

<p>logical, if <code>FALSE</code> points, rather than lines, are used to portray the segmented relationships.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_by">by</code></td>
<td>

<p>A named list indicating covariate names and corresponding values affecting the fitted segmented relationship. For instance: 
<code>by=list(sex="male",z=.2)</code>, provided that the variables <code>sex</code> and <code>z</code> affect the segmented relationship. Effective only if <code>level=0</code>. 
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_add">add</code></td>
<td>

<p>If <code>TRUE</code> the (fixed-effect) fitted segmented relationship is added to the current plot. Effective only if <code>level=0</code>. 
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_conf.level">conf.level</code></td>
<td>

<p>The confidence level for pointwise confidence intervals. Effective only if <code>level=0</code>.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_withi">withI</code></td>
<td>

<p>If <code>TRUE</code>, the level 0 segmented relationship is computed with the model intercept. Effective only if <code>level=0</code>.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_vcov.">vcov.</code></td>
<td>

<p>The fixed effects covariance matrix. If <code>NULL</code>, it is computed by <code>vcov.segmented.lme()</code>. Effective only if <code>level=0</code>.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_shade">shade</code></td>
<td>

<p>If <code>TRUE</code>  (and <code>conf.level&gt;0</code>) the area within the pointiwise CIs is shaded. Effective only if <code>level=0</code>.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_drop.var">drop.var</code></td>
<td>

<p>Possible coefficient names to be removed before computing the segmented relationship (E.g. the group-specific intercept.).
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_text.leg">text.leg</code></td>
<td>

<p>If specified (and <code>pos.leg</code> has been also specified), it is the legend text. Effective only if <code>level=0</code>.
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_id.name">id.name</code></td>
<td>

<p>If <code>pos.leg</code> is different from <code>NULL</code>, <code>id.name=TRUE</code> will portray the cluster variable name along the value. Namely <code>id.name=TRUE</code> leads to 'country = italy' on each panel, while  <code>id.name=FALSE</code> to 'italy'. 
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_ci.psi.pop">ci.psi.pop</code></td>
<td>

<p>Should the point estimate and CI for the population breakpoint be added? If <code>ci.psi.pop&gt;0</code> both the point estimate and CI (at level <code>ci.psi.pop</code>)
are added; if <code>ci.psi.pop=0</code> only the point estimate.   
</p>
</td></tr>
<tr><td><code id="plot.segmented.lme_+3A_...">...</code></td>
<td>

<p>additional arguments, such as <code>ylab</code>,<code>xlab</code>, <code>ylim</code> and <code>xlim</code>; <code>l.col,l.lwd,l.lty</code> (for the fitted individual lines - can be vectors and will be recycled); <code>p.col, p.lwd, p.lty</code> for the population line (if <code>pop=TRUE</code>); <code>col, cex, pch</code> for the data points (if <code>res=TRUE</code>); <code>t.col</code> for the legend color, if <code>pos.leg</code> is not <code>NULL</code>. If <code>level=0</code> and <code>conf.level&gt;0</code>, <code>lty</code> and <code>lwd</code> can be vectors.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots the 'subject'-specific segmented profiles for the 'subjects' specificed in <code>id</code> or, if <code>level=0</code>, the fitted segmented relationship based on fixed effects only. The number of panels to drawn is actually the minimum between <code>length(id)</code> and <code>prod(n.plot)</code>, but if <code>n.plot=c(1,1)</code> (or also simply <code>n.plot=1</code>), the &lsquo;individual&rsquo; profiles will be pictured on the same panel. 
</p>


<h3>Value</h3>

<p>A single or multiple (depending on <code>level</code> and <code>id</code>) plot showing the fitted segmented profiles.
</p>


<h3>Warning </h3>

<p>All the functions for segmented mixed models (*.segmented.lme) are still at an experimental stage 
</p>


<h3>Note</h3>

<p>If <code>by</code> is specified (and <code>level=0</code> is set), a legend is also added in the plot reporting covariate(s) name and value affecting the segmented relationship.  Set <code>pos.leg=TRUE</code> to have no legend. On the other hand, use <code>text.leg</code> to add legend reporting the covariate baseline values.
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+segmented.lme">segmented.lme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#continues example from segmented.lme

plot(os, yscale=-1) #different y-scales

plot(os2, n.plot=1, l.col=2:6, l.lwd=2) #all segmented profiles on the same plot


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.stepmented'>
Plot method for stepmented objects
</h2><span id='topic+plot.stepmented'></span>

<h3>Description</h3>

<p>Takes a fitted <code>stepmented</code> object returned by <code>stepmented()</code> and plots (or adds)
the fitted piecewise constant lines for the selected stepmented term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stepmented'
plot(x, term, add = FALSE, res = TRUE, conf.level=0, interc = TRUE, add.fx = FALSE, 
      psi.lines = TRUE, link=TRUE, const=NULL, res.col=grey(.15, alpha = .4), 
      surf=FALSE, zero.cor=TRUE, heurs=TRUE, shade=FALSE, se.type=c("cdf","abs","none"), 
      k=NULL, .vcov=NULL, leg="topleft", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.stepmented_+3A_x">x</code></td>
<td>

<p>a fitted <code>stepmented</code> object.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_term">term</code></td>
<td>

<p>the stepmented variable having the piece-wise constant relationship to be plotted.
If there is a single stepmented variable in the fitted model <code>x</code>, 
<code>term</code> can be omitted.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_add">add</code></td>
<td>

<p>when <code>TRUE</code> the fitted lines are added to the current device.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_res">res</code></td>
<td>

<p>when <code>TRUE</code> the fitted lines are plotted along with corresponding partial residuals.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_conf.level">conf.level</code></td>
<td>

<p>the confidence level for the pointwise confidence intervals for the expected values.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_interc">interc</code></td>
<td>

<p>if <code>TRUE</code> the computed components include the model intercept (if it exists).
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_add.fx">add.fx</code></td>
<td>

<p>logical. If TRUE and the object fit also includes an additional term for the same stepmented variable, the plot also portrays such &lsquo;additional&rsquo; term. 
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_psi.lines">psi.lines</code></td>
<td>

<p>if <code>TRUE</code> vertical lines corresponding to the estimated changepoints are also drawn
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_link">link</code></td>
<td>

<p>if <code>FALSE</code> the fitted lines (and possibily the residuals) are reported on the response scale. Ignored if the fit object <code>x</code> is not a glm-like fit.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_const">const</code></td>
<td>
<p> constant to add to each fitted segmented relationship (on the scale of the linear predictor) before plotting.
If <code>const=NULL</code> and the fit includes a segmented interaction term (obtained via <code>seg(..,by)</code> in the formula), the group-specific intercept is included. 
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_res.col">res.col</code></td>
<td>
<p>when <code>res=TRUE</code> it means the color of the points representing the partial residuals.</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_surf">surf</code></td>
<td>

<p>if the object fit <code>x</code> includes 2 stepmented covariates (x1 and x2, say) with relevant estimated breakpoints, <code>surf=TRUE</code> will draw on the plane x1-x2 the areas splitted according to the estimated breakpoints with corresponding estimated means superimposed.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_zero.cor">zero.cor</code></td>
<td>

<p>see <code>zero.cor</code> in <code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code>; effective only if <code>conf.level&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_heurs">heurs</code></td>
<td>

<p>logical; if <code>TRUE</code>, heuristic (usually somewhat conservative) confidence intervals are computed and plotted; effective only if <code>conf.level&gt;0</code>. 
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_shade">shade</code></td>
<td>

<p>if <code>TRUE</code> the pointwise confidence intervals are portrayed via shaded area; effective only if <code>conf.level&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_se.type">se.type</code></td>
<td>

<p>which standard errors should be computed? see <code>type</code> in <code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code>; effective only if <code>conf.level&gt;0</code>.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_k">k</code></td>
<td>

<p>The value to be passed to <code>vcov.stepmented</code> to computed the standard errors.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_.vcov">.vcov</code></td>
<td>

<p>The estimate var-covariance matrix; if <code>NULL</code>, it is computed internally by <code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_leg">leg</code></td>
<td>

<p>If the plot refers to stepmented relationships in groups, i.e. <code>term</code> has been specified as a vector, a legend is placed at the specified <code>leg</code> position. Put <code>NA</code> not to draw the legend.
</p>
</td></tr>
<tr><td><code id="plot.stepmented_+3A_...">...</code></td>
<td>
<p> other graphics parameters to pass to plotting commands: &lsquo;col&rsquo;, &lsquo;lwd&rsquo; and &lsquo;lty&rsquo; (that
can be vectors and are recycled if necessary, see the example below) for the fitted piecewise constant lines; &lsquo;ylab&rsquo;, &lsquo;xlab&rsquo;, &lsquo;main&rsquo;, &lsquo;sub&rsquo;, &lsquo;cex.axis&rsquo;, &lsquo;cex.lab&rsquo;, &lsquo;xlim&rsquo; and &lsquo;ylim&rsquo; when a new plot is produced (i.e. when <code>add=FALSE</code>); &lsquo;pch&rsquo; and &lsquo;cex&rsquo; for the partial residuals (when <code>res=TRUE</code>, <code>res.col</code> is for the color).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces (or adds to the current device) the fitted step-function like relationship between the
response and the selected <code>term</code>. If the fitted model includes just a single &lsquo;stepmented&rsquo; variable,
<code>term</code> may be omitted. If <code>surf=TRUE</code>, and <code>res=TRUE</code> the point widths are proportional to the partial residual values. 
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Note</h3>

<p>Implementation of confidence intervals for the conditional means in stepmented regression is under development; <code>conf.level&gt;0</code> should be used with care, especially with multiple jumpoints.
</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+stepmented">stepmented</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Following code in stepmented..
## Not run: 

par(mfrow=c(1,3))

plot(os,"x")
plot(os,"z")
plot(os,"z", add.fx=TRUE, psi.lines=FALSE ) 
lines(os, "z")

#display the 'surface'
par(mfrow=c(1,3))
plot(os, surf=TRUE, col=1, res.col=2)
plot(os, surf=TRUE, lty=2)
plot(x,z)
plot(os, surf=TRUE, add=TRUE, col=4, res=FALSE)


## End(Not run)

</code></pre>

<hr>
<h2 id='points.segmented'>
Points method for segmented objects
</h2><span id='topic+points.segmented'></span>

<h3>Description</h3>

<p>Takes a fitted <code>segmented</code> object returned by <code>segmented()</code> and adds
on the current plot the joinpoints of the fitted broken-line relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'segmented'
points(x, term, interc = TRUE, link = TRUE, rev.sgn=FALSE, 
    transf=I, .vcov=NULL, .coef=NULL, const=0, v=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points.segmented_+3A_x">x</code></td>
<td>

<p>an object of class <code>segmented</code>.
</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_term">term</code></td>
<td>

<p>the segmented variable of interest. It may be unspecified when there is a single segmented variable.
</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_interc">interc</code></td>
<td>

<p>If <code>TRUE</code> the computed joinpoints include the model intercept (if it exists).
</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_link">link</code></td>
<td>

<p>when <code>TRUE</code> (default), the fitted joinpoints are plotted on the link scale
</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_rev.sgn">rev.sgn</code></td>
<td>

<p>when <code>TRUE</code>, the fitted joinpoints are plotted on the &lsquo;minus&rsquo; scale
of the current <code>term</code> variable. This is useful when a null-constraint 
has been set on the last slope.
</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_transf">transf</code></td>
<td>

<p>A possible function to convert the fitted values before plotting.
</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_.vcov">.vcov</code></td>
<td>
<p> The <em>full</em> covariance matrix of estimates. If unspecified (i.e. <code>NULL</code>), the covariance matrix is computed internally by <code>vcov()</code>.</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef(x)</code>.</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_const">const</code></td>
<td>
<p> A constant to be added (on the y-scale) to the values before transforming and plotting.</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_v">v</code></td>
<td>
<p>logical. If <code>TRUE</code>, vertical lines at the breakpoints are also drawn.</p>
</td></tr>
<tr><td><code id="points.segmented_+3A_...">...</code></td>
<td>

<p>other graphics parameters to pass on to <code>points()</code> and <code>segments()</code> (if <code>v=TRUE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We call 'joinpoint' the plane point having as coordinates the breakpoints (on the x scale) and the fitted values of
the segmented relationship at that breakpoints (on the y scale). <code>points.segmented()</code> simply adds the fitted 
joinpoints on the current plot. This could be useful to emphasize the changes of the piecewise linear relationship. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.segmented">plot.segmented</a></code> to plot the fitted segmented lines. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#see examples in ?plot.segmented

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.segmented'>
Predict method for segmented model fits
</h2><span id='topic+predict.segmented'></span>

<h3>Description</h3>

<p>Returns predictions and optionally associated quantities (standard errors or confidence intervals) from a fitted segmented model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented'
predict(object, newdata, se.fit=FALSE, interval=c("none","confidence", "prediction"), 
            type = c("link", "response"), na.action=na.omit, level=0.95, .coef=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.segmented_+3A_object">object</code></td>
<td>

<p>a fitted segmented model coming from <code>segmented.(g)lm</code> or <code>segreg</code>.
</p>
</td></tr>
<tr><td><code id="predict.segmented_+3A_newdata">newdata</code></td>
<td>

<p>An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.segmented_+3A_se.fit">se.fit</code></td>
<td>

<p>Logical. Should the standard errors be returned?
</p>
</td></tr>
<tr><td><code id="predict.segmented_+3A_interval">interval</code></td>
<td>

<p>Which interval? See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>
</p>
</td></tr>
<tr><td><code id="predict.segmented_+3A_type">type</code></td>
<td>

<p>Predictions on the link or response scale? Only if <code>object</code> is a segmented glm.
</p>
</td></tr>
<tr><td><code id="predict.segmented_+3A_na.action">na.action</code></td>
<td>

<p>How to deal with missing data,  <em>if</em> <code>newdata</code> include them.
</p>
</td></tr>
<tr><td><code id="predict.segmented_+3A_level">level</code></td>
<td>

<p>The confidence level.
</p>
</td></tr>
<tr><td><code id="predict.segmented_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef()</code>.</p>
</td></tr>
<tr><td><code id="predict.segmented_+3A_...">...</code></td>
<td>

<p>further arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically <code>predict.segmented</code> builds the right design matrix accounting for breakpoint and passes it 
to <code>predict.lm</code> or <code>predict.glm</code> depending on the actual model fit <code>object</code>.
</p>


<h3>Value</h3>

<p><code>predict.segmented</code> produces a vector of predictions with possibly associated standard errors or confidence intervals. 
See <code>predict.lm</code> or  <code>predict.glm</code>.
</p>


<h3>Warning </h3>

<p>For segmented glm fits with offset, <code>predict.segmented</code> returns the fitted values <em>including</em> the offset. 
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+segreg">segreg</a></code>, <code><a href="#topic+segmented">segmented</a></code>, <code><a href="#topic+plot.segmented">plot.segmented</a></code>, <code><a href="#topic+broken.line">broken.line</a></code>, <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=10
x=seq(-3,3,l=n)
set.seed(1515)
y &lt;- (x&lt;0)*x/2 + 1 + rnorm(x,sd=0.15)
segm &lt;- segmented(lm(y ~ x), ~ x, psi=0.5)
predict(segm,se.fit = TRUE)$se.fit

#wrong (smaller) st.errors (assuming known the breakpoint)
olm&lt;-lm(y~x+pmax(x-segm$psi[,2],0))
predict(olm,se.fit = TRUE)$se.fit
</code></pre>

<hr>
<h2 id='predict.stepmented'>
Predict method for stepmented model fits
</h2><span id='topic+predict.stepmented'></span>

<h3>Description</h3>

<p>Returns predictions and optionally associated quantities (standard errors or confidence intervals) from a fitted stepmented model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stepmented'
predict(object, newdata, se.fit=FALSE, interval=c("none","confidence", "prediction"), 
            type = c("link", "response"), na.action=na.omit, level=0.95, .coef=NULL, 
            .vcov=NULL, apprx.fit=c("none","cdf"), apprx.se=c("cdf","none"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.stepmented_+3A_object">object</code></td>
<td>

<p>a fitted stepmented model coming from <code>stepmented.lm</code> or <code>stepmented.glm</code>.
</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_newdata">newdata</code></td>
<td>

<p>An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_se.fit">se.fit</code></td>
<td>

<p>Logical. Should the standard errors be returned?
</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_interval">interval</code></td>
<td>

<p>Which interval? See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>
</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_type">type</code></td>
<td>

<p>Predictions on the link or response scale? Only if <code>object</code> is a stepmented glm.
</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_na.action">na.action</code></td>
<td>

<p>How to deal with missing data,  <em>if</em> <code>newdata</code> include them.
</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_level">level</code></td>
<td>

<p>The confidence level.
</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef()</code>.</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_.vcov">.vcov</code></td>
<td>
<p> The estimate covariance matrix. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>vcov.stepmented()</code>.</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_apprx.fit">apprx.fit</code></td>
<td>
<p> The approximation of the <code class="reqn">(x&gt;\hat\psi)</code> used to compute the predictions/fitted values of the piece-wise relationships. </p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_apprx.se">apprx.se</code></td>
<td>
<p> The same abovementioned approximation to compute the standard error.</p>
</td></tr>
<tr><td><code id="predict.stepmented_+3A_...">...</code></td>
<td>

<p>further arguments, for instance <code>k</code> to be passed to <code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically <code>predict.stepmented</code> builds the right design matrix accounting for breakpoint and passes it 
to <code>predict.lm</code> or <code>predict.glm</code> depending on the actual model fit <code>object</code>.
</p>


<h3>Value</h3>

<p><code>predict.stepmented</code> produces a vector of predictions with possibly associated standard errors or confidence intervals. 
See <code>predict.lm</code>, <code>predict.glm</code>, or <code><a href="#topic+predict.segmented">predict.segmented</a></code>.
</p>


<h3>Warning </h3>

<p>For stepmented glm fits with offset, <code>predict.stepmented</code> returns the fitted values <em>including</em> the offset. 
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepreg">stepreg</a></code>, <code><a href="#topic+stepmented">stepmented</a></code>, <code><a href="#topic+plot.stepmented">plot.stepmented</a></code>, <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=10
x=seq(-3,3,l=n)
set.seed(1515)
y &lt;- (x&lt;0)*x/2 + 1 + rnorm(x,sd=0.15)
segm &lt;- segmented(lm(y ~ x), ~ x, psi=0.5)
predict(segm,se.fit = TRUE)$se.fit
</code></pre>

<hr>
<h2 id='print.segmented'> Print method for the segmented class </h2><span id='topic+print.segmented'></span><span id='topic+coef.segmented'></span>

<h3>Description</h3>

<p>Printing the most important features and coefficients (including the breakpoints) of a segmented model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'segmented'
coef(object, include.psi=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.segmented_+3A_x">x</code></td>
<td>
<p> object of class <code>segmented</code> </p>
</td></tr>
<tr><td><code id="print.segmented_+3A_digits">digits</code></td>
<td>
<p> number of digits to be printed </p>
</td></tr>
<tr><td><code id="print.segmented_+3A_object">object</code></td>
<td>
<p>object of class <code>segmented</code> </p>
</td></tr>
<tr><td><code id="print.segmented_+3A_include.psi">include.psi</code></td>
<td>
<p>logical. If <code>TRUE</code>, the breakpoints are returned along with the regression coefficients</p>
</td></tr>
<tr><td><code id="print.segmented_+3A_...">...</code></td>
<td>
<p> arguments passed to other functions </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.segmented">summary.segmented</a></code>, <code><a href="#topic+print.summary.segmented">print.summary.segmented</a></code> </p>

<hr>
<h2 id='print.segmented.lme'> Print method for the segmented.lme class </h2><span id='topic+print.segmented.lme'></span><span id='topic+fixef.segmented.lme'></span><span id='topic+logLik.segmented.lme'></span>

<h3>Description</h3>

<p>Printing and extracting the most important features of a segmented mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented.lme'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'segmented.lme'
fixef(object, ...)

## S3 method for class 'segmented.lme'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.segmented.lme_+3A_x">x</code></td>
<td>
<p> object of class <code>segmented.lme</code> </p>
</td></tr>
<tr><td><code id="print.segmented.lme_+3A_digits">digits</code></td>
<td>
<p> number of digits to be printed </p>
</td></tr>
<tr><td><code id="print.segmented.lme_+3A_object">object</code></td>
<td>
<p>object of class <code>segmented</code> </p>
</td></tr>

<tr><td><code id="print.segmented.lme_+3A_...">...</code></td>
<td>
<p> arguments passed to other functions </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>See Also</h3>

 <p><code><a href="#topic+segmented.lme">segmented.lme</a></code>, <code><a href="#topic+summary.segmented.lme">summary.segmented.lme</a></code> </p>

<hr>
<h2 id='pscore.test'> Testing for existence of one breakpoint</h2><span id='topic+pscore.test'></span>

<h3>Description</h3>

<p>Given a (generalized) linear model, the (pseudo) Score statistic tests for the existence of one breakpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pscore.test(obj, seg.Z, k = 10, alternative = c("two.sided", "less", "greater"), 
    values=NULL, dispersion=NULL, df.t=NULL, more.break=FALSE, n.break=1, 
    only.term=FALSE, break.type=c("break","jump"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pscore.test_+3A_obj">obj</code></td>
<td>
<p> a fitted model typically returned by <code>glm</code> or <code>lm</code>. Even an object returned by 
<code>segmented</code> can be set. Offset and weights are allowed.</p>
</td></tr>
<tr><td><code id="pscore.test_+3A_seg.z">seg.Z</code></td>
<td>
<p> a formula with no response variable, such as <code>seg.Z=~x1</code>, indicating the (continuous) segmented variable being tested. Only a single variable may be tested and an error is printed when <code>seg.Z</code> includes two or more terms. <code>seg.Z</code> can be omitted if i)<code>obj</code> is a segmented fit with a single segmented covariate (and that variable is taken), or ii)if it is a &quot;lm&quot; or &quot;glm&quot; fit with a single covariate (and that variable is taken).</p>
</td></tr>
<tr><td><code id="pscore.test_+3A_k">k</code></td>
<td>
<p> optional. Number of points (equi-spaced from the min to max) used to compute the pseudo Score statistic. See Details. </p>
</td></tr>
<tr><td><code id="pscore.test_+3A_alternative">alternative</code></td>
<td>
<p> a character string specifying the alternative hypothesis (relevant to the slope difference parameter). </p>
</td></tr>
<tr><td><code id="pscore.test_+3A_values">values</code></td>
<td>
<p> optional. The evaluation points where the Score test is computed. See Details for default values.</p>
</td></tr>
<tr><td><code id="pscore.test_+3A_dispersion">dispersion</code></td>
<td>
<p> optional. the dispersion parameter for the family to be used to compute the test statistic.
When <code>NULL</code> (the default), it is inferred from <code>obj</code>. Namely it is taken as <code>1</code> for the
Binomial and Poisson families, and otherwise estimated by the residual Chi-squared statistic in the model <code>obj</code> (calculated from cases with non-zero weights divided by the residual degrees of freedom).</p>
</td></tr>
<tr><td><code id="pscore.test_+3A_df.t">df.t</code></td>
<td>
<p> optional. The degress-of-freedom used to compute the p-value. When <code>NULL</code>, the df extracted from <code>obj</code> are used.</p>
</td></tr>
<tr><td><code id="pscore.test_+3A_more.break">more.break</code></td>
<td>
<p> optional, logical. If <code>obj</code> is a 'segmented' fit, <code>more.break=FALSE</code> tests for the actual breakpoint for the variable 'seg.Z', 
while <code>more.break=TRUE</code> tests for an <em>additional</em> breakpoint(s) for the variable 'seg.Z'. Ignored when <code>obj</code> is not a segmented fit.</p>
</td></tr>
<tr><td><code id="pscore.test_+3A_n.break">n.break</code></td>
<td>
<p>optional. Number of breakpoints postuled under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="pscore.test_+3A_only.term">only.term</code></td>
<td>
<p>logical. If <code>TRUE</code>, only the pseudo covariate(s) relevant to the testing for the breakpoint is returned, and no test is computed.</p>
</td></tr>
<tr><td><code id="pscore.test_+3A_break.type">break.type</code></td>
<td>
<p>The kind of breakpoint being tested. <code>"break"</code> is for piecewise-linear relationships, <code>"jump"</code> means piecewise-constant, i.e. a step-function, relationships.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pscore.test</code> tests for a non-zero difference-in-slope parameter of a segmented
relationship. Namely, the null hypothesis is <code class="reqn">H_0:\beta=0</code>, where <code class="reqn">\beta</code> is the difference-in-slopes, 
i.e. the coefficient of the segmented function <code class="reqn">\beta(x-\psi)_+</code>. The hypothesis of interest 
<code class="reqn">\beta=0</code> means no breakpoint. Simulation studies have shown that such Score test is more powerful than the Davies test (see reference) when the alternative hypothesis is &lsquo;one changepoint&rsquo;. If there are two or more breakpoints (for instance, a sinusoidal-like relationships), <code>pscore.test</code> can have lower power, and <code><a href="#topic+davies.test">davies.test</a></code> can perform better.
</p>
<p>The <code>dispersion</code> value, if unspecified, is taken from <code>obj</code>. If <code>obj</code> represents the fit under the null hypothesis (no changepoint), the dispersion parameter estimate will be usually larger, leading to a (potentially severe) loss of power.  
</p>
<p>The <code>k</code> evaluation points are <code>k</code> equally spaced values in the range of the segmented covariate. <code>k</code> should not be small. 
Specific values can be set via <code>values</code>, although I have found no important difference due to number and location of the evaluation points, thus  default is <code>k=10</code> equally-spaced points. However, when the possible breakpoint is believed to lie into a specified narrower range, the user can specify <code>k</code> values in that range leading to higher power in detecting it, i.e. typically lower p-value.
</p>
<p>If <code>obj</code> is a (segmented) <em>lm</em> object, the returned p-value comes from the t-distribution with appropriate degrees of freedom. Otherwise, namely if <code>obj</code> is a (segmented) <em>glm</em> object, the p-value is computed wrt the Normal distribution.   
</p>


<h3>Value</h3>

<p>A list with class '<code>htest</code>' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method</code></td>
<td>
<p>title (character)</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the regression model and the segmented variable being tested</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the empirical value of the statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>number of evaluation points</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value</p>
</td></tr>
<tr><td><code>process</code></td>
<td>
<p>the alternative hypothesis set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>References</h3>

<p>Muggeo, V.M.R. (2016) Testing with a nuisance parameter present only under the alternative:
a score-based approach with application to segmented modelling. 
<em>J of Statistical Computation and Simulation</em>, <b>86</b>, 3059&ndash;3067. 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+davies.test">davies.test</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(20)
z&lt;-runif(100)
x&lt;-rnorm(100,2)
y&lt;-2+10*pmax(z-.5,0)+rnorm(100,0,3)

o&lt;-lm(y~z+x)

#testing for one changepoint
#use the simple null fit
pscore.test(o,~z) #compare with davies.test(o,~z)..

#use the segmented fit
os&lt;-segmented(o, ~z)
pscore.test(os,~z) #smaller p-value, as it uses the dispersion under the alternative (from 'os') 

#test for the 2nd breakpoint in the variable z
pscore.test(os,~z, more.break=TRUE) 

  
## End(Not run)
</code></pre>

<hr>
<h2 id='pwr.seg'>
Power Analysis in segmented regression
</h2><span id='topic+pwr.seg'></span>

<h3>Description</h3>

<p>Given the appropriate input values, the function computes the power (sample size) corresponding to the specifed sample size (power). If a segmented fit object is provided, the power is computed taking the parameter estimates as input values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwr.seg(oseg, pow, n, z = "1:n/n", psi, d, s, n.range = c(10,300), 
    X = NULL, break.type=c("break","jump"), alpha = 0.01, round.n = TRUE, 
    alternative = c("two.sided", "greater", "less"), msg = TRUE, ci.pow=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwr.seg_+3A_oseg">oseg</code></td>
<td>

<p>The fitted segmented object. If provided, the power is computed at the model parameter estimates, and all the remaining arguments but <code>alternative</code> and <code>alpha</code> are ignored. 
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_pow">pow</code></td>
<td>

<p>The desired power level. If provided <code>n</code> has to be missing 
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_n">n</code></td>
<td>

<p>The fixed sample size. If provided <code>pow</code> has to be missing
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_z">z</code></td>
<td>

<p>The covariate understood to have a segmented effect. Default is <code>"1:n/n"</code>, i.e. equispaced values in (0,1). More generally a string indicating the quantile function having <code>p</code> and possible other numerical values as arguments. For istance <code>"qunif(p,0,1)"</code>,  <code>"qnorm(p,2,5)"</code>, or <code>"qexp(p)"</code>. <code>"qunif(p,1,n)"</code> can be also specified, but attention should be paid to guarantee <code>psi</code> within the covariate range. Finally, it could be also a numerical vector meaning the actual covariate, but <code>pow</code> has to be missing. Namely if the covariate is supplied (and n is known), only the relevant power can be estimated.
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_psi">psi</code></td>
<td>

<p>The breakpoint value within the covariate range
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_d">d</code></td>
<td>

<p>The slope difference
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_s">s</code></td>
<td>

<p>The response standard deviation
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_n.range">n.range</code></td>
<td>

<p>When <code>pow</code> is provided and the relevant sample size estimate has to be returned, the function evaluates 50 sample sizes equally spaced in <code>n.range</code>. However the function can also compute, via spline interpolation, sample sizes outside the   
specified range.
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_x">X</code></td>
<td>

<p>The design matrix including additional linear variables in the regression equation. Default to <code>NULL</code> which means intercept and linear term for the segmented covariate.
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_break.type">break.type</code></td>
<td>

<p>Type of breakpoint. <code>break.type='break'</code> means piecewise linear (segmented), <code>break.type='jump'</code> refers to piecewise constant. 
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_alpha">alpha</code></td>
<td>

<p>The type-I error probability. Default to 0.01.
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_round.n">round.n</code></td>
<td>

<p>logical. If <code>TRUE</code> the (possible) returned sample size value is rounded.
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_alternative">alternative</code></td>
<td>

<p>a character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;. Note, this refers to the sign of the slope difference.
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_msg">msg</code></td>
<td>

<p>logical. If <code>TRUE</code> the output is returned along with a simple message, otherwise only the values are returned 
</p>
</td></tr>
<tr><td><code id="pwr.seg_+3A_ci.pow">ci.pow</code></td>
<td>

<p>Numerical. If <code>oseg</code> has been supplied, <code>ci.pow</code> replicates are drawn to build a 95% confidence interval for the power. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function exploits the sampling distribution of the pseudo Score statistic under the alternative hypothesis of one breakpoint.
</p>


<h3>Value</h3>

<p>The computed power <em>or</em> sample size, with or without message (depending on <code>msg</code>)
</p>


<h3>Note</h3>

<p>Currently the function assumes just 1 breakpoint in one covariate
</p>


<h3>Author(s)</h3>

<p>Nicoletta D'Angelo and Vito Muggeo
</p>


<h3>References</h3>

<p>D'Angelo N, Muggeo V.M.R. (2021) Power analysis in segmented regression, working paper <br />
https://www.researchgate.net/publication/355885747.
</p>
<p>Muggeo, V.M.R. (2016) Testing with a nuisance parameter present only under the alternative:
a score-based approach with application to segmented modelling. 
<em>J of Statistical Computation and Simulation</em>, <b>86</b>, 3059&ndash;3067.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pscore.test">pscore.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## pwr.seg(pow=.7, psi=.5, d=1.5, s=.5) #returns the sample size
  ## pwr.seg(n=219, psi=.5, d=1.5, s=.5) #returns the power
  ## pwr.seg(n=20,z="qnorm(p, 2,5)", psi=3, d=.5, s=2) #the covariate is N(2,5)
  ## pwr.seg(n=20,z="qexp(p)", psi=.1, d=.5, s=.1) #the covariate is Exp(1)

    </code></pre>

<hr>
<h2 id='seg'>
Specifying a segmented/stepmented term in the segreg/stepreg formula
</h2><span id='topic+seg'></span>

<h3>Description</h3>

<p>Function used to define a segmented (stepmented) term within the segreg (stepreg) formula. The function simply passes relevant information to proper fitter functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg(x, npsi = 1, psi = NA, est = NA, R = NA, fixed.psi = NULL, by = NULL, f.x = I)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seg_+3A_x">x</code></td>
<td>

<p>The segmented/stepmented (numeric) covariate
</p>
</td></tr>
<tr><td><code id="seg_+3A_npsi">npsi</code></td>
<td>

<p>The number of breakpoints/jumpoints to estimate. Default to <code>npsi=1</code>. If <code>by</code> has been specified and <code>npsi</code> is a scalar, the same <code>npsi</code> applies to all categories of the factor <code>by</code>; otherwise it can be vector, wherein 
the entries represent the number of breakpoints of the segmented relationships within the categories of <code>by</code>. 
The <code>npsi</code> starting values are computed according the specification of <code>quant</code> in <code><a href="#topic+seg.control">seg.control</a></code>.
</p>
</td></tr>
<tr><td><code id="seg_+3A_psi">psi</code></td>
<td>

<p>Numerical vector indicating possible starting value(s) for the breakpoint(s). When provided, <code>psi</code> overwrites 
<code>npsi</code>. If <code>by</code> has been specified and <code>psi</code> is a vector, the same <code>psi</code> applies to all categories of the factor <code>by</code>. Otherwise <code>psi</code> can be a list, wherein the components represent 
the starting values of the segmented/stepmented relationships within the categories of <code>by</code>.
</p>
</td></tr>
<tr><td><code id="seg_+3A_est">est</code></td>
<td>

<p>Possible vector (of length equal to <code>npsi+1</code>) of 1's and 0's to indicate whether the slopes have to be estimated 
or fixed to zero. <code>NA</code>, the default, means all ones, namely every slope is estimated. Consecutive zeroes are not allowed. If it is a vector and <code>by</code> has been specified, the same <code>est</code> applies to all categories of the factor <code>by</code>; otherwise <code>est</code> can be a list, wherein the components represent the slope constraints of the segmented relationships within the categories of <code>by</code>. 
</p>
</td></tr>
<tr><td><code id="seg_+3A_r">R</code></td>
<td>

<p>Matrix to constrain the slopes. If provided, it overwrites the matrix (which is built internally) coming from the specification of <code>est</code>. If matrix and <code>by</code> has been specified, the same <code>R</code> applies to all categories of the factor <code>by</code>; otherwise <code>R</code> can be a list, wherein the components represent the slope constraints of the segmented relationships within the categories of <code>by</code>.
</p>
</td></tr>
<tr><td><code id="seg_+3A_fixed.psi">fixed.psi</code></td>
<td>

<p>Possible <em>fixed</em> breakpoint values to be accounted for <em>in addition</em> to those being estimated. If <code>by</code> has been specified and <code>fixed.psi</code> is a vector, the same <code>fixed.psi</code> applies to all categories of the factor <code>by</code>. Otherwise <code>fixed.psi</code> can be a list, wherein the components refer to the segmented relationship within the levels of <code>by</code>. <code>slope</code> and <code>plot.segmented</code> will account for them correctly.
</p>
</td></tr>
<tr><td><code id="seg_+3A_by">by</code></td>
<td>

<p>A possible <em>factor</em> meaning an interaction with the segmented term <code>x</code>. Hence, if specified, a different segmented relationship is fitted within each category of <code>by</code>.
</p>
</td></tr>
<tr><td><code id="seg_+3A_f.x">f.x</code></td>
<td>

<p>an optional function meaning a function to apply to the covariate before fitting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used within <code><a href="#topic+segreg">segreg</a></code> and <code>stepreg</code> to 'build' information about the segmented relationships to fit. 
</p>
<p>Note that, when a grouping variable has been specified in <code>by</code>, <code>npsi</code> can be specified as a vector, and <code>est</code>, if specified, should be a list.
</p>


<h3>Value</h3>

<p>The function simply returns the covariate with added attributes relevant to segmented term
</p>


<h3>Note</h3>

<p>If any value is provided in <code>fix.psi</code>, the corresponding slope difference coefficient will be labelled by <code>*.fixed.*</code>. The <code><a href="#topic+slope">slope</a></code> function will compute the 'right' slopes also accounting for the fixed breakpoints.
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+segreg">segreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##see ?segreg
</code></pre>

<hr>
<h2 id='seg.control'> Auxiliary for controlling segmented/stepmented model fitting </h2><span id='topic+seg.control'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for 'segmented' and 'stepmented' fitting. Typically
only used when calling any 'segmented' or 'stepmented' method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg.control(n.boot=10, display = FALSE, tol = 1e-05, it.max = 30, fix.npsi=TRUE,
    K = 10, quant = FALSE, maxit.glm = NULL, h = 1.25, break.boot=5, size.boot=NULL, 
    jt=FALSE, nonParam=TRUE, random=TRUE, seed=NULL, fn.obj=NULL, digits=NULL, 
    alpha = NULL, fc=.95, check.next=TRUE, tol.opt=NULL, fit.psi0=NULL, eta=NULL, 
    min.nj=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seg.control_+3A_n.boot">n.boot</code></td>
<td>
<p> number of bootstrap samples used in the bootstrap restarting algorithm. If 0 the standard algorithm,
i.e. without bootstrap restart, is used. Default to 10 that appears to be sufficient in most of problems. However
when multiple breakpoints have to be estimated it is suggested to increase <code>n.boot</code>, e.g. <code>n.boot=50</code>, and even <code>break.boot</code>.</p>
</td></tr>
<tr><td><code id="seg.control_+3A_display">display</code></td>
<td>
<p> logical indicating if the value of the objective function should be printed along with current breakpoint estimates at each iteration or at each bootstrap resample (but no more than 5 breakpoints are printed). If bootstrap restarting is employed, the values of objective and breakpoint estimates should not change at the last runs.</p>
</td></tr>
<tr><td><code id="seg.control_+3A_tol">tol</code></td>
<td>
<p> positive convergence tolerance. </p>
</td></tr>
<tr><td><code id="seg.control_+3A_it.max">it.max</code></td>
<td>
<p> integer giving the maximal number of iterations. </p>
</td></tr>
<tr><td><code id="seg.control_+3A_fix.npsi">fix.npsi</code></td>
<td>
<p>logical (it replaces previous argument <code>stop.if.error</code>) If <code>TRUE</code> (default) the <em>number</em> (and not location) of breakpoints is held fixed           throughout iterations. Otherwise a sort of &lsquo;automatic&rsquo; breakpoint selection is carried out, provided that several starting values are supplied for the breakpoints, 
see argument <code>psi</code> in <code><a href="#topic+segmented.lm">segmented.lm</a></code> or <code><a href="#topic+segmented.glm">segmented.glm</a></code>. The idea, relying on removing the &lsquo;non-admissible&rsquo; breakpoint estimates at each     iteration, is discussed in Muggeo and Adelfio (2011) and it is not compatible with the bootstrap restart algorithm. <code>fix.npsi=FALSE</code>, indeed, should be considered as a preliminary and tentative approach to deal with an unknown number of breakpoints. Alternatively, see <code><a href="#topic+selgmented">selgmented</a></code>.</p>
</td></tr> 
<tr><td><code id="seg.control_+3A_k">K</code></td>
<td>
<p> the number of quantiles (or equally-spaced values) to supply as starting values for the breakpoints 
when the <code>psi</code> argument of <code>segmented</code> is set to <code>NA</code>. <code>K</code> is ignored when <code>psi</code> is different from <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_quant">quant</code></td>
<td>
<p>logical, indicating how the starting values should be selected. If <code>FALSE</code> equally-spaced 
values are used, otherwise the quantiles. Ignored when <code>psi</code> is different from <code>NA</code>.</p>
</td></tr> 
<tr><td><code id="seg.control_+3A_maxit.glm">maxit.glm</code></td>
<td>
<p> integer giving the maximum number of inner IWLS iterations (see details). If <code>NULL</code>, the number is low in the first iterations and then increases as th eprocess goes on. Ignored for segmented lm fits </p>
</td></tr>
<tr><td><code id="seg.control_+3A_h">h</code></td>
<td>
<p> positive factor modifying the increments in breakpoint updates during
the estimation process (see details). </p>
</td></tr>
<tr><td><code id="seg.control_+3A_break.boot">break.boot</code></td>
<td>

<p>Integer, less than <code>n.boot</code>. If <code>break.boot</code> consecutive bootstrap samples lead to the same objective function during the estimation process, the algorithm stops without performing all <code>n.boot</code> 'trials'.
This can save computational time considerably. Default is <code>5</code> for the <code>segmented</code> and <code>5+2</code> for the <code>stepmented</code> functions. However if the number of changepoints is large, <code>break.boot</code> should be increased, even 10 or 15.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_size.boot">size.boot</code></td>
<td>
<p>the size of the bootstrap samples. If <code>NULL</code>, it is taken equal to the actual sample size. If the sample is very large, the idea is to run bootstrap restarting using smaller bootstrap samples.</p>
</td></tr>
<tr><td><code id="seg.control_+3A_jt">jt</code></td>
<td>
<p>logical. If <code>TRUE</code> the values of the segmented variable(s) are jittered before fitting the model to the
bootstrap resamples.</p>
</td></tr>
<tr><td><code id="seg.control_+3A_nonparam">nonParam</code></td>
<td>

<p>if <code>TRUE</code> nonparametric bootstrap (i.e. case-resampling) is used, otherwise residual-based.
Currently working only for LM fits. It is not clear what residuals should be used for GLMs.</p>
</td></tr>
<tr><td><code id="seg.control_+3A_random">random</code></td>
<td>

<p>if <code>TRUE</code>, when the algorithm fails to obtain a solution, random values are employed to obtain candidate values.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_seed">seed</code></td>
<td>

<p>The seed to be passed on to <code>set.seed()</code> when <code>n.boot&gt;0</code>. If <code>NULL</code>, a seed depending on the response values is generated and used. Otherwise it can be a numerical value or, if <code>NA</code>, a random value is generated. 
Fixing the seed can be useful to replicate <em>exactly</em> the results when the bootstrap restart algorithm is employed. Whichever choice, the segmented fit includes the component <code>seed</code> representing the value saved just before the bootstrap resampling. Re-use it if you want to replicate the bootstrap restarting algorithm with the <em>same</em> re-samples.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_fn.obj">fn.obj</code></td>
<td>

<p>A <em>character string</em> to be used (optionally) only when <code>segmented.default</code> is used. It represents the function 
(with argument <code>'x'</code>) to be applied to the fit object to extract the objective function to be <em>minimized</em>. 
Thus for <code>"lm"</code> fits (although unnecessary) it should be <code>fn.obj="sum(x$residuals^2)"</code>, for
<code>"coxph"</code> fits it should be <code>fn.obj="-x$loglik[2]"</code>. If <code>NULL</code> the &lsquo;minus log likelihood&rsquo; extracted from 
the object, namely <code>"-logLik(x)"</code>, is used. See <code><a href="#topic+segmented.default">segmented.default</a></code>.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_digits">digits</code></td>
<td>
<p>optional. If specified it means the desidered number of decimal points of the breakpoint to be used during the iterative algorithm.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_alpha">alpha</code></td>
<td>
<p>optional numerical values. The breakpoints are estimated within the quantiles <code>alpha[1]</code> and <code>alpha[2]</code> of the relevant covariate. If a single value is provided, it is assumed <code>alpha</code> and <code>1-alpha</code>. Defaults to <code>NULL</code> which means <code>alpha=max(.05, 1/n)</code>. Note: Providing <code>alpha=c(mean(x&lt;=a),mean(x&lt;=b))</code> means to constrain the breakpoint estimates within <code class="reqn">[a,b]</code>.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_fc">fc</code></td>
<td>
<p>A proportionality factor (<code class="reqn">\le 1</code>) to adjust the breakpoint estimates <em>if</em> these come close to the boundary or too close each other. For instance, if <code>psi</code> turns up close to the maximum, it will be changed to <code>psi*fc</code> or to <code>psi/fc</code> if close to the minimum. This is useful to get finite point estimate and standard errors for each slope paramete.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_check.next">check.next</code></td>
<td>
<p>logical, effective only for stepmented fit. If <code>TRUE</code> the solutions next to the current one are also investigated.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_tol.opt">tol.opt</code></td>
<td>
<p>Numerical value to be passed to <code>tol</code> in <code><a href="stats.html#topic+optimize">optimize</a></code>.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_fit.psi0">fit.psi0</code></td>
<td>
<p>Possible list including preliminary values.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_eta">eta</code></td>
<td>
<p>Only for segmented/stepmented fits: starting values to be passed to <code>etastart</code> in <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.
</p>
</td></tr>
<tr><td><code id="seg.control_+3A_min.nj">min.nj</code></td>
<td>
<p>How many observations (at least) should be in the covariate intervals induced by the breakpoints?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitting a &lsquo;segmented&rsquo; GLM model is attained via fitting iteratively standard GLMs. The number of (outer) 
iterations is governed by <code>it.max</code>, while the (maximum) number of (inner) iterations to fit the GLM at 
each fixed value of psi is fixed via <code>maxit.glm</code>. Usually three-four inner iterations may be sufficient.
</p>
<p>When the starting value for the breakpoints is set to <code>NA</code> for any segmented variable specified
in <code>seg.Z</code>, <code>K</code> values (quantiles or equally-spaced) are selected as starting values for the breakpoints. 


</p>
<p>Since version 0.2-9.0 <code>segmented</code> implements the bootstrap restarting algorithm described in Wood (2001).
The bootstrap restarting is expected to escape the local optima of the objective function when the
segmented relationship is noisy and the loglikelihood can be flat. Notice bootstrap restart runs <code>n.boot</code> iterations regardless of <code>tol</code> that only affects convergence within the inner loop.
</p>


<h3>Value</h3>

<p>A list with the arguments as components.
</p>


<h3>Author(s)</h3>

<p> Vito Muggeo </p>


<h3>References</h3>

<p> Muggeo, V.M.R., Adelfio, G. (2011) Efficient change point detection in genomic sequences of 
continuous measurements. <em>Bioinformatics</em> <b>27</b>, 161&ndash;166. 
</p>
<p>Wood, S. N. (2001) Minimizing model fitting objectives that contain spurious local minima
by bootstrap restarting. <em>Biometrics</em> <b>57</b>, 240&ndash;244. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     #decrease the maximum number inner iterations and display the 
     #evolution of the (outer) iterations
     #seg.control(display = TRUE, maxit.glm=4)
  </code></pre>

<hr>
<h2 id='seg.lm.fit'>
Fitter Functions for Segmented Linear Models
</h2><span id='topic+seg.lm.fit'></span><span id='topic+seg.glm.fit'></span><span id='topic+seg.def.fit'></span><span id='topic+seg.Ar.fit'></span><span id='topic+seg.num.fit'></span><span id='topic+seg.lm.fit.boot'></span><span id='topic+seg.glm.fit.boot'></span><span id='topic+seg.def.fit.boot'></span><span id='topic+seg.Ar.fit.boot'></span><span id='topic+seg.num.fit.boot'></span><span id='topic+segConstr.lm.fit'></span><span id='topic+segConstr.glm.fit'></span><span id='topic+segConstr.lm.fit.boot'></span><span id='topic+segConstr.glm.fit.boot'></span>

<h3>Description</h3>

<p><code>seg.lm.fit</code> is called by <code>segmented.lm</code> to fit segmented linear 
(gaussian) models.  Likewise, <code>seg.glm.fit</code> is called by <code>segmented.glm</code> to fit  
generalized segmented linear models, and <code>seg.def.fit</code> is called by <code>segmented.default</code> to fit  
segmented relationships in general regression models (e.g., quantile regression and Cox regression). <code>seg.lm.fit.boot</code>, 
<code>seg.glm.fit.boot</code>, and <code>seg.def.fit.boot</code> are employed to perform bootstrap restart. 
The functions <code>segConstr.*</code> are called by <code>segreg()</code> when some contraints are set on the slopes of the segmented relationships.
</p>
<p>These functions should usually not be used directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg.lm.fit(y, XREG, Z, PSI, w, offs, opz, return.all.sol=FALSE)

seg.lm.fit.boot(y, XREG, Z, PSI, w, offs, opz, n.boot=10,
    size.boot=NULL, jt=FALSE, nonParam=TRUE, random=FALSE, break.boot=n.boot)

seg.glm.fit(y, XREG, Z, PSI, w, offs, opz, return.all.sol=FALSE)

seg.glm.fit.boot(y, XREG, Z, PSI, w, offs, opz, n.boot=10,
    size.boot=NULL, jt=FALSE, nonParam=TRUE, random=FALSE, break.boot=n.boot)

seg.def.fit(obj, Z, PSI, mfExt, opz, return.all.sol=FALSE)

seg.def.fit.boot(obj, Z, PSI, mfExt, opz, n.boot=10, size.boot=NULL, 
    jt=FALSE, nonParam=TRUE, random=FALSE, break.boot=n.boot)

seg.Ar.fit(obj, XREG, Z, PSI, opz, return.all.sol=FALSE)

seg.Ar.fit.boot(obj, XREG, Z, PSI, opz, n.boot=10, size.boot=NULL, jt=FALSE,
    nonParam=TRUE, random=FALSE, break.boot=n.boot)

seg.num.fit(y, XREG, Z, PSI, w, opz, return.all.sol=FALSE)

seg.num.fit.boot(y, XREG, Z, PSI, w, opz, n.boot=10, size.boot=NULL, jt=FALSE,
    nonParam=TRUE, random=FALSE, break.boot=n.boot)
    
segConstr.lm.fit(y, XREG, Z, PSI, w, offs, opz, return.all.sol = FALSE)

segConstr.lm.fit.boot(y, XREG, Z, PSI, w, offs, opz, n.boot=10, size.boot=NULL, 
    jt=FALSE, nonParam=TRUE, random=FALSE, break.boot=n.boot)

segConstr.glm.fit(y, XREG, Z, PSI, w, offs, opz, return.all.sol = FALSE)

segConstr.glm.fit.boot(y, XREG, Z, PSI, w, offs, opz, n.boot=10, size.boot=NULL, 
    jt=FALSE, nonParam=TRUE, random=FALSE, break.boot=n.boot)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seg.lm.fit_+3A_y">y</code></td>
<td>

<p>vector of observations of length <code>n</code>.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_xreg">XREG</code></td>
<td>

<p>design matrix for standard linear terms.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_z">Z</code></td>
<td>

<p>appropriate matrix including the segmented variables whose breakpoints have to be estimated.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_psi">PSI</code></td>
<td>

<p>appropriate matrix including the starting values of the breakpoints to be estimated.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_w">w</code></td>
<td>

<p>possibe weights vector.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_offs">offs</code></td>
<td>

<p>possibe offset vector.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_opz">opz</code></td>
<td>

<p>a list including information useful for model fitting.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_n.boot">n.boot</code></td>
<td>

<p>the number of bootstrap samples employed in the bootstrap restart algorithm.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_break.boot">break.boot</code></td>
<td>

<p>Integer, less than <code>n.boot</code>. If <code>break.boot</code> consecutive bootstrap samples lead to the same objective function, the algorithm stops without performing all <code>n.boot</code> 'trials'.
This can save computational time considerably.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_size.boot">size.boot</code></td>
<td>

<p>the size of the bootstrap resamples. If <code>NULL</code> (default), it is taken equal to the sample size.
values smaller than the sample size are expected to increase perturbation in the bootstrap resamples.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_jt">jt</code></td>
<td>

<p>logical. If <code>TRUE</code> the values of the segmented variable(s) are jittered before fitting the model to the
bootstrap resamples.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_nonparam">nonParam</code></td>
<td>

<p>if <code>TRUE</code> nonparametric bootstrap (i.e. case-resampling) is used, otherwise residual-based.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_random">random</code></td>
<td>

<p>if <code>TRUE</code>, when the algorithm fails to obtain a solution, random values are used as candidate values.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_return.all.sol">return.all.sol</code></td>
<td>

<p>if <code>TRUE</code>, when the algorithm fails to obtain a solution, the values visited by the algorithm
with corresponding deviances are returned.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_obj">obj</code></td>
<td>

<p>the starting regression model where the segmented relationships have to be added.
</p>
</td></tr>
<tr><td><code id="seg.lm.fit_+3A_mfext">mfExt</code></td>
<td>

<p>the model frame.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions call iteratively <code>lm.wfit</code> (or <code>glm.fit</code>) with proper design matrix depending on 
<code>XREG</code>, <code>Z</code> and <code>PSI</code>. <code>seg.lm.fit.boot</code> (and <code>seg.glm.fit.boot</code>) implements the bootstrap restarting idea discussed in
Wood (2001).
</p>


<h3>Value</h3>

<p>A list of fit information.
</p>


<h3>Note</h3>

<p>These functions should usually not be used directly by the user.
</p>


<h3>Author(s)</h3>

<p> Vito Muggeo </p>


<h3>References</h3>

<p> Wood, S. N. (2001) Minimizing model fitting objectives that contain spurious local minima
by bootstrap restarting. <em>Biometrics</em> <b>57</b>, 240&ndash;244. </p>


<h3>See Also</h3>

<p><code><a href="#topic+segmented.lm">segmented.lm</a></code>, <code><a href="#topic+segmented.glm">segmented.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##See ?segmented
</code></pre>

<hr>
<h2 id='segmented'>
Segmented relationships in regression models
</h2><span id='topic+segmented'></span><span id='topic+segmented.lm'></span><span id='topic+segmented.glm'></span><span id='topic+segmented.default'></span><span id='topic+segmented.Arima'></span><span id='topic+segmented.numeric'></span>

<h3>Description</h3>

<p>Fits regression models with segmented relationships between the response
and one or more explanatory variables. Break-point estimates are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(), 
    model = TRUE, ...)

## Default S3 method:
segmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(),
    model = TRUE, keep.class=FALSE, ...)

## S3 method for class 'lm'
segmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(),
    model = TRUE, keep.class=FALSE, ...)

## S3 method for class 'glm'
segmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(),
    model = TRUE, keep.class=FALSE, ...)

## S3 method for class 'Arima'
segmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(),
    model = TRUE, keep.class=FALSE, ...)
    
## S3 method for class 'numeric'
segmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(),
    model = TRUE, keep.class=FALSE, adjX=FALSE, weights=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmented_+3A_obj">obj</code></td>
<td>
<p> standard &lsquo;linear&rsquo; model of class &quot;lm&quot;, &quot;glm&quot; or &quot;Arima&quot;, or potentially any regression 
fit may be supplied since version 0.5-0 (see 'Details'). <code>obj</code> can include any covariate understood to have a linear (i.e. no break-points) effect on the response. If <code>obj</code> also includes the segmented covariate specified in <code>seg.Z</code>, then all the slopes of the fitted segmented relationship will be estimated. On the other hand, if <code>obj</code> misses the segmented variable, then the 1st (the leftmost) slope is assumed to be zero. Since version 1.5.0, <code>obj</code> can be a simple numeric or <code>ts</code> object but with only a single segmented variable (<code>segmented.numeric</code>) see examples below.</p>
</td></tr>
<tr><td><code id="segmented_+3A_seg.z">seg.Z</code></td>
<td>
<p> the segmented variable(s), i.e. the continuous covariate(s) understood to have a piecewise-linear relationship with response. It is a formula with no response variable, such as <code>seg.Z=~x</code> or <code>seg.Z=~x1+x2</code>. It can be missing when <code>obj</code> includes only one covariate which is taken as segmented variable. Currently, formulas involving functions, 
such as <code>seg.Z=~log(x1)</code>, or selection operators, such as <code>seg.Z=~d[,"x1"]</code> or <code>seg.Z=~d$x1</code>, are <em>not</em> allowed. Also, variable names formed by <code style="white-space: pre;">&#8288;U&#8288;</code> or <code style="white-space: pre;">&#8288;V&#8288;</code> only (with or without numbers) are not permitted.</p>
</td></tr>
<tr><td><code id="segmented_+3A_psi">psi</code></td>
<td>
<p> starting values for the breakpoints to be estimated. If there is a single segmented variable specified in <code>seg.Z</code>, <code>psi</code> is a numeric vector, and it can be missing  when 1 breakpoint has to be estimated (and the median of the segmented variable is used as a starting value). If <code>seg.Z</code> includes several covariates, <code>psi</code> has be specified as a <em>named</em> list of vectors whose names have to match the variables in the <code>seg.Z</code> argument. Each vector of such list includes starting values for the break-point(s) for the corresponding variable in <code>seg.Z</code>. A <code>NA</code> value means that '<code>K</code>' quantiles (or equally spaced values) are used as starting values; <code>K</code> is fixed via the <code><a href="#topic+seg.control">seg.control</a></code> auxiliary function. See <code>npsi</code> as an alternative to specify just the number of breakpoints.  
</p>
</td></tr>
<tr><td><code id="segmented_+3A_npsi">npsi</code></td>
<td>

<p>A named vector or list meaning the <em>number</em> (and not locations) of breakpoints to be estimated. The starting values will be internally computed via the quantiles or equally spaced values, as specified in argument <code>quant</code> in <code><a href="#topic+seg.control">seg.control</a></code>. <code>npsi</code> can be missing and <code>npsi=1</code> is assumed for all variables specified in <code>seg.Z</code>. If <code>psi</code> is provided, <code>npsi</code> is ignored.
</p>
</td></tr>
<tr><td><code id="segmented_+3A_fixed.psi">fixed.psi</code></td>
<td>
<p>An optional named list meaning the breakpoints to be kept fixed during the estimation procedure. The names should be a subset of (or even the same) variables specified in <code>seg.Z</code>. If there is a single variable in <code>seg.Z</code>, a simple numeric vector can be specified. Note that, in addition to the values specified here, <code>segmented</code> will estimate additional breakpoints. To keep fixed all breakpoints (to be specified in <code>psi</code>) use <code>it.max=0</code> in <code><a href="#topic+seg.control">seg.control</a></code>
</p>
</td></tr>
<tr><td><code id="segmented_+3A_control">control</code></td>
<td>
<p> a list of parameters for controlling the fitting process.
See the documentation for <code><a href="#topic+seg.control">seg.control</a></code> for details. </p>
</td></tr>
<tr><td><code id="segmented_+3A_model">model</code></td>
<td>
<p>logical value indicating if the model.frame should be returned.</p>
</td></tr>
<tr><td><code id="segmented_+3A_keep.class">keep.class</code></td>
<td>
<p>logical value indicating if the final fit returned by <code>segmented.default</code> should keep the class '<code>segmented</code>' (along with the class of the original fit <code>obj</code>). Ignored by the segmented methods. </p>
</td></tr>
<tr><td><code id="segmented_+3A_...">...</code></td>
<td>
<p> optional arguments (to be ignored safely). Notice specific arguments relevant to the original call (via <code>lm</code> or <code>glm</code> for instance), such as <code>weights</code> or <code>offet</code>, have to be included in the starting model <code>obj</code>
</p>
</td></tr>
<tr><td><code id="segmented_+3A_adjx">adjX</code></td>
<td>
<p>if <code>obj</code> is a <code>ts</code>, the segmented variable (if not specified in <code>seg.Z</code>) is computed by taking information from the time series (e.g., years starting from 2000, say). If <code>adjX=TRUE</code>, the segmented variable is shifted such that its min equals zero.
Default is using the unshifted values, but if there are several breakpoints to be estimated , it is strongly suggested to set <code>adjX=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="segmented_+3A_weights">weights</code></td>
<td>
<p>the weights if <code>obj</code> is a vector or a ts object, otherwise the  weights should be specified in the 
starting fit <code>obj</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a linear regression model usually of class &quot;lm&quot; or &quot;glm&quot; (or even a simple numeric/ts vector), segmented tries to estimate
a new regression model having broken-line relationships with the variables specified in <code>seg.Z</code>.
A segmented (or broken-line) relationship is defined by the slope
parameters and the break-points where the linear relation changes. The number of breakpoints
of each segmented relationship is fixed via the <code>psi</code> (or <code>npsi</code>) argument, where initial
values for the break-points (or simply their number via <code>npsi</code>) must be specified. The model
is estimated simultaneously yielding point estimates and relevant approximate
standard errors of all the model parameters, including the break-points.
</p>
<p>Since version 0.2-9.0 <code>segmented</code> implements the bootstrap restarting algorithm described in Wood (2001).
The bootstrap restarting is expected to escape the local optima of the objective function when the
segmented relationship is flat and the log likelihood can have multiple local optima.
</p>
<p>Since version 0.5-0.0 the default method <code>segmented.default</code> has been added to estimate segmented relationships in 
general (besides &quot;lm&quot; and &quot;glm&quot; fits) regression models, such as Cox regression or quantile regression (for a single percentile). 
The objective function to be minimized is the (minus) value extracted by the <code>logLik</code> function or it may be passed on via 
the <code>fn.obj</code> argument in <code>seg.control</code>. See example below. While the default method is expected to work with any regression 
fit (where the usual <code>coef()</code>, <code>update()</code>, and <code>logLik()</code> returns appropriate results), it is not recommended for 
&quot;lm&quot; or &quot;glm&quot; fits (as <code>segmented.default</code> is slower than the specific methods <code>segmented.lm</code> and <code>segmented.glm</code>), although 
final results are the same. However the object returned by <code>segmented.default</code> is <em>not</em> of class &quot;segmented&quot;, as currently
the segmented methods are not guaranteed to work for &lsquo;generic&rsquo; (i.e., besides &quot;lm&quot; and &quot;glm&quot;) regression fits. The user 
could try each &quot;segmented&quot; method on the returned object by calling it explicitly (e.g. via <code>plot.segmented()</code> or <code>confint.segmented()</code> wherein the regression coefficients and relevant covariance matrix have to be specified, see <code>.coef</code> and <code>.vcov</code> in <code>plot.segmented()</code>, <code>confint.segmented()</code>, <code>slope()</code>). 
</p>


<h3>Value</h3>

<p>segmented returns an object of class &quot;segmented&quot; which inherits
from the class of <code>obj</code>, for instance &quot;lm&quot; or &quot;glm&quot;. <br />
</p>
<p>An object of class &quot;segmented&quot; is a list containing the components of the
original object <code>obj</code> with additionally the followings:
</p>
<table role = "presentation">
<tr><td><code>psi</code></td>
<td>
<p>estimated break-points (sorted) and relevant (approximate) standard errors</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>number of iterations employed</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>difference in the objective function when the algorithm stops</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the model frame</p>
</td></tr>
<tr><td><code>psi.history</code></td>
<td>
<p>a list or a vector including the breakpoint estimates at each step</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the integer vector containing the seed just before the bootstrap resampling. 
Returned only if bootstrap restart is employed</p>
</td></tr>
<tr><td><code>..</code></td>
<td>
<p>Other components are not of direct interest of the user</p>
</td></tr>
</table>


<h3> Warning </h3>

<p>At convergence, if the estimated breakpoints are too close each other or at the boundaries, the parameter point estimate could be returned, but without finite standard errors. To avoid that, <code>segmented</code> revises the final breakpoint estimates to allow that at least <code>min.nj</code> are within each interval of the segmented covariate. A warning message is printed if such adjustment is made. See <code>min.nj</code> in <code><a href="#topic+seg.control">seg.control</a></code>.
</p>


<h3>Note</h3>


<ol>
<li><p> The algorithm will start if the <code>it.max</code> argument returned by <code>seg.control</code>
is greater than zero. If <code>it.max=0</code> <code>segmented</code> will estimate a new linear model with
break-point(s) fixed at the values reported in <code>psi</code>.Alternatively, it is also possible to set <code>h=0</code> in <code>seg.control()</code>. In this case, bootstrap restarting is unncessary, then to have breakpoints at <code>mypsi</code> type <br />
</p>
<p><code>segmented(.., psi=mypsi, control=seg.control(h=0, n.boot=0, it.max=1))</code>
</p>
</li>
<li><p> In the returned fit object, &lsquo;U.&rsquo; is put before the name of the segmented 
variable to mean the difference-in-slopes coefficient.
</p>
</li>
<li><p> Methods specific to the class <code>"segmented"</code> are
</p>

<ul>
<li> <p><code><a href="#topic+print.segmented">print.segmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summary.segmented">summary.segmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.summary.segmented">print.summary.segmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.segmented">plot.segmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+lines.segmented">lines.segmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+confint.segmented">confint.segmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vcov.segmented">vcov.segmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+predict.segmented">predict.segmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+points.segmented">points.segmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+coef.segmented">coef.segmented</a></code>
</p>
</li></ul>

<p>Others are inherited from the class <code>"lm"</code> or <code>"glm"</code> depending on the
class of <code>obj</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p> Vito M. R. Muggeo, <a href="mailto:vito.muggeo@unipa.it">vito.muggeo@unipa.it</a> </p>


<h3>References</h3>

 
<p>Muggeo, V.M.R. (2003) Estimating regression models with unknown 
break-points. <em>Statistics in Medicine</em> <b>22</b>, 3055&ndash;3071.
</p>
<p>Muggeo, V.M.R. (2008) Segmented: an R package to fit regression 
models with broken-line relationships. <em>R News</em> <b>8/1</b>, 20&ndash;25.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+segmented.glm">segmented.glm</a></code> for segmented GLM and <code><a href="#topic+segreg">segreg</a></code> to fit the models via a formula interface. <code><a href="#topic+segmented.lme">segmented.lme</a></code> fits random changepoints (segmented mixed) models. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12)
xx&lt;-1:100
zz&lt;-runif(100)
yy&lt;-2+1.5*pmax(xx-35,0)-1.5*pmax(xx-70,0)+15*pmax(zz-.5,0)+rnorm(100,0,2)
dati&lt;-data.frame(x=xx,y=yy,z=zz)
out.lm&lt;-lm(y~x,data=dati)

#the simplest example: the starting model includes just 1 covariate 
#.. and 1 breakpoint has to be estimated for that
o&lt;-segmented(out.lm) #1 breakpoint for x

#the single segmented variable is not in the starting model, and thus..
#... you need to specify it via seg.Z, but no starting value for psi
o&lt;-segmented(out.lm, seg.Z=~z)
#note the leftmost slope is constrained to be zero (since out.lm does not include z)

#2 segmented variables, 1 breakpoint each (again no need to specify npsi or psi)
o&lt;-segmented(out.lm,seg.Z=~z+x)


#1 segmented variable, but 2 breakpoints: you have to specify starting values (vector) for psi:
o&lt;-segmented(out.lm,seg.Z=~x,psi=c(30,60), control=seg.control(display=FALSE))

#.. or you can specify just the *number* of breakpoints
#o&lt;-segmented(out.lm,seg.Z=~x, npsi=2, control=seg.control(display=FALSE)) 

slope(o) #the slopes of the segmented relationship


#2 segmented variables: starting values requested via a named list
out.lm&lt;-lm(y~z,data=dati)
o1&lt;-update(o,seg.Z=~x+z,psi=list(x=c(30,60),z=.3))
#..or by specifying just the *number* of breakpoints
#o1&lt;-update(o,seg.Z=~x+z, npsi=c(x=2,z=1))



#the default method leads to the same results (but it is slower)
#o1&lt;-segmented.default(out.lm,seg.Z=~x+z,psi=list(x=c(30,60),z=.3))
#o1&lt;-segmented.default(out.lm,seg.Z=~x+z,psi=list(x=c(30,60),z=.3), 
#    control=seg.control(fn.obj="sum(x$residuals^2)"))


#automatic procedure to estimate breakpoints in the covariate x (starting from K quantiles)
# Hint: increases number of iterations. Notice: bootstrap restart is not allowed!
# However see ?selgmented for a better approach
#o&lt;-segmented.lm(out.lm,seg.Z=~x+z,psi=list(x=NA,z=.3), 
#    control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))

#assess the progress of the breakpoint estimates throughout the iterations
## Not run: 
par(mfrow=c(1,2))
draw.history(o, "x")
draw.history(o, "z")

## End(Not run)
#try to increase the number of iterations and re-assess the 
#convergence diagnostics 


# A simple segmented model with continuous responses and no linear covariates
# No need to fit the starting lm model:
segmented(yy, npsi=2) #NOTE: subsetting the vector works ( segmented(yy[-1],..) ) 
#only a single segmented covariate is allowed in seg.Z, and if seg.Z is unspecified, 
#   the segmented variable is taken as 1:n/n 


# An example using the Arima method:
## Not run: 
n&lt;-50
idt &lt;-1:n #the time index

mu&lt;-50-idt +1.5*pmax(idt-30,0)
set.seed(6969)
y&lt;-mu+arima.sim(list(ar=.5),n)*3.5

o&lt;-arima(y, c(1,0,0), xreg=idt)
os1&lt;-segmented(o, ~idt, control=seg.control(display=TRUE))

#note using the .coef argument is mandatory!
slope(os1, .coef=os1$coef)
plot(y)
plot(os1, add=TRUE, .coef=os1$coef, col=2)


## End(Not run)

################################################################
################################################################
######Four examples using the default method:
################################################################
################################################################


################################################################
#==&gt; 1. Cox regression with a segmented relationship  
################################################################
## Not run: 
library(survival)
data(stanford2)

o&lt;-coxph(Surv(time, status)~age, data=stanford2)
os&lt;-segmented(o, ~age, psi=40) #estimate the breakpoint in the age effect
summary(os) #actually it means summary.coxph(os)
plot(os) #it does not work
plot.segmented(os) #call explicitly plot.segmented() to plot the fitted piecewise lines


################################################################
# ==&gt; 2. Linear mixed model via the nlme package
################################################################

dati$g&lt;-gl(10,10) #the cluster 'id' variable
library(nlme)
o&lt;-lme(y~x+z, random=~1|g, data=dati)
os&lt;-segmented.default(o, ~x+z, npsi=list(x=2, z=1))

#summarizing results (note the '.coef' argument)
slope(os, .coef=fixef(os))
plot.segmented(os, "x", .coef=fixef(os), conf.level=.95)
confint.segmented(os, "x", .coef=fixef(os))
dd&lt;-data.frame(x=c(20,50),z=c(.2,.6), g=1:2)
predict.segmented(os, newdata=dd, .coef=fixef(os)) 


################################################################
# ==&gt; 3. segmented quantile regression via the quantreg  package
################################################################

library(quantreg)
data(Mammals)
y&lt;-with(Mammals, log(speed))
x&lt;-with(Mammals, log(weight))
o&lt;-rq(y~x, tau=.9)
os&lt;-segmented.default(o, ~x) #it does NOT work. It cannot compute the vcov matrix..

#Let's define the vcov.rq function.. (I don't know if it is the best option..)
vcov.rq&lt;-function(x,...) {
  V&lt;-summary(x,cov=TRUE,se="nid",...)$cov
  rownames(V)&lt;-colnames(V)&lt;-names(x$coef)
V}

os&lt;-segmented.default(o, ~x) #now it does work
 plot.segmented(os, res=TRUE, col=2, conf.level=.95)


################################################################
# ==&gt; 4. segmented regression with the svyglm() (survey  package)   
################################################################

library(survey)
data(api)
dstrat&lt;-svydesign(id=~1,strata=~stype, weights=~pw, data=apistrat, fpc=~fpc)

o&lt;-svyglm(api00~ell, design=dstrat)

#specify as a string the objective function to be minimized. It can be obtained via svyvar() 

fn.x&lt;- 'as.numeric(svyvar(resid(x, "pearson"), x$survey.design, na.rm = TRUE))'
os&lt;-segmented.default(o, ~ell, control=seg.control(fn.obj=fn.x, display=TRUE))
slope(os)
plot.segmented(os, res=TRUE, conf.level=.9, shade=TRUE)

## End(Not run)
            
</code></pre>

<hr>
<h2 id='segmented.lme'>
Segmented relationships in linear mixed models
</h2><span id='topic+segmented.lme'></span>

<h3>Description</h3>

<p>Fits linear mixed models with a segmented relationship between the response and 
a numeric covariate. Random effects are allowed in each model parameter, including the breakpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
segmented(obj, seg.Z, psi, npsi = 1, fixed.psi = NULL, 
    control = seg.control(), model = TRUE, 
    z.psi = ~1, x.diff = ~1, random = NULL, 
    random.noG = NULL, start.pd = NULL, psi.link = c("identity", "logit"), 
    start = NULL, data, fixed.parms = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmented.lme_+3A_obj">obj</code></td>
<td>

<p>A 'lme' fit returned by <code>lme</code> or simply its call. See example below. This represents the linear mixed model
where the segmented relationship is added.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_seg.z">seg.Z</code></td>
<td>

<p>A one-sided formula indicating the segmented variable, i.e. the quantitative variable having a segmented relationship with
the response. In longitudinal studies typically it is the time.</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_psi">psi</code></td>
<td>

<p>An optional starting value for the breakpoint. If missing a starting value is obtained via the nadir estimate of a quadratic fit.
When provided it may be a single numeric value or a vector of length equal to the number of clusters (i.e. subjects).
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_z.psi">z.psi</code></td>
<td>

<p>Optional. A one-sided formula meaning the covariates in the sub-regression model for the changepoint parameter. Default to <code>~1</code>. 
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_x.diff">x.diff</code></td>
<td>

<p>Optional. A one-sided formula meaning the covariates in the sub-regression model for the difference-in-slopes parameter. 
Default to <code>~1</code> for no covariate for the difference-in-slope parameter.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_npsi">npsi</code></td>
<td>

<p>Ignored. Currently only <code>npsi=1</code> is allowed.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_fixed.psi">fixed.psi</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_control">control</code></td>
<td>

<p>A list returned by <code><a href="#topic+seg.control">seg.control</a></code>, in particular <code>display</code>, <code>n.boot</code> for the bootstrap restarting.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_model">model</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_random">random</code></td>
<td>

<p>A list, as the one supplied in <code>random</code> of <code>lme()</code> including the random effects. Default to <code>NULL</code>,
meaning that the same random effect structure of the initial lme fit supplied in <code>obj</code> should be used. 
When specified, this list could include the variables '<code>G0</code>' and '<code>U</code>'. 
<code>G0</code> means random effects in the breakpoints and <code>U</code> means random effects in the
slope-difference parameter. Assuming <code>id</code> is the the cluster variable and <code>x</code> the segmented variable, some examples are
</p>
<p><code>random = list(id = pdDiag(~1 + x + U))</code> #ind. random eff. (changepoint fixed)
</p>
<p><code>random = list(id = pdDiag(~1 + x + U + G0))</code> #ind. random eff. (in the changepoint too) 
</p>
<p><code>random = list(id=pdBlocked(list(pdSymm(~1+x), pdSymm(~U+G0-1))))</code> #block diagonal 
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_random.nog">random.noG</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_start.pd">start.pd</code></td>
<td>

<p>An optional starting value for the variances of the random effects. It should be coherent with the
specification in <code>random</code>.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_psi.link">psi.link</code></td>
<td>

<p>The link function used to specify the sub-regression model for the breakpoint <code class="reqn">psi</code>.
The identity (default) assumes
</p>
<p style="text-align: center;"><code class="reqn">\psi_i=\eta_i</code>
</p>

<p>while the logit link is
</p>
<p style="text-align: center;"><code class="reqn">\psi_i=(m+M*exp(\eta_i))/(1+exp(\eta_i))</code>
</p>

<p>where <code class="reqn">m</code> and <code class="reqn">M</code> are the observed minimum and maximum of the segmented variable in <code>seg.Z</code>.
In each case the &lsquo;linear predictor&rsquo; is <code class="reqn">\eta_i=\kappa_0+z_i^T\kappa_1+k_i</code>, where <code class="reqn">z^T</code> includes the covariates 
specified in <code>z.psi</code> and the <code class="reqn">k_i</code>s are the changepoint random effects 
included by means of <code>G0</code> in the <code>random</code> argument.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_start">start</code></td>
<td>

<p>An optional list including the <em>starting values</em> for the difference-in-slopes parameter, delta0 and delta,
and the changepoint parameter, kappa and kappa0. When provided, 'kappa0' overwrites 'psi'.
</p>
<p>If provided, the components 'delta' and 'kappa' should be <em>named</em> vectors with length and names
matching length and names in <code>x.diff</code> and <code>z.psi</code> respectively. The component <code>delta0</code> can be
a scalar or a vector with length equal to the number of clusters (subjects).
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_data">data</code></td>
<td>

<p>the dataframe where the variables are stored. If missing, the dataframe of the <code>"lme"</code> fit <code>obj</code> is assumed.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_fixed.parms">fixed.parms</code></td>
<td>

<p>An optional <em>named</em> vector representing the coefficients <em>of the changepoint</em> to be maintained <em>fixed</em>
during the estimation process. Allowed names are &quot;G0&quot; or any variable (in the dataframe) supposed to
affect the location of breakpoints.
For instance <code>fixed.parms=c(G0=.3)</code> implies a fixed value for the changepoint.
Notice if you use the same variable in <code>fixed.parms</code> and in <code>z.psi</code>, for instance
<code>fixed.parms=c(x2=.3)</code> and <code>z.psi=~x2</code>, a warning is printed and the
coefficient &quot;G.x2&quot; is estimated to maximize the log likelihood <em>given</em> that fixed value. As an example, suppose the 
unconstrained estimated coefficient for x2, say, in <code>z.psi</code> is 0.5; if in a new call both <code>fixed.parms=c(x2=.4)</code> and 
<code>z.psi=~x2</code> are included, the estimate of &quot;G.x2&quot; will be (approximately) 0.1.
Essentially, if you really want to fix the parameters in <code>fixed.parms</code>, then 
do not include the same covariates in <code>z.psi</code>.
</p>
</td></tr>
<tr><td><code id="segmented.lme_+3A_...">...</code></td>
<td>

<p>Ignored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits segmented mixed regression models, i.e. segmented models with random effects also in the slope-difference and change-point parameters. 
</p>


<h3>Value</h3>

<p>A list of class <code>segmented.lme</code> with several components. The most relevant are 
</p>
<table role = "presentation">
<tr><td><code>lme.fit</code></td>
<td>
<p>The fitted lme object at convergence</p>
</td></tr>
<tr><td><code>lme.fit.noG</code></td>
<td>
<p>The fitted lme object at convergence assuming known the breakpoints</p>
</td></tr>
<tr><td><code>psi.i</code></td>
<td>
<p>The subject/cluster-specific change points (fixed + random). It includes 2 attributes: <code>attr(,"ni")</code> for the number of measurements in each 'cluster', and <code>attr(,"is.break")</code> a vector of logicals indicating if the breakpoint for each subject i can be reliable (<code>TRUE</code>) or not (<code>FALSE</code>). Here 'reliable' simply means within the covariate range (for subject i). See also argument <code>nq</code>.</p>
</td></tr>
<tr><td><code>fixed.eta.psi</code></td>
<td>
<p>The fixed-effect linear predictor for the change points regression equation. These values will different among 'clusters' only if at least one covariate has been specified in <code>z.psi</code>.</p>
</td></tr>
<tr><td><code>fixed.eta.delta</code></td>
<td>
<p>The fixed-effect linear predictor of the slope difference regression equation. These values will different among 'clusters' only if at least one covariate has been specified in <code>x.diff</code>.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The function deals with estimation with a <em>single</em> breakpoint only.
</p>


<h3>Note</h3>

<p>Currently only one breakpoint (with or without random effects) can be estimated. If <code>fit</code> is the segmented.lme fit, use <code>VarCorr(fit$lme.fit)</code> to extract the random effect covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Vito M.R. Muggeo <a href="mailto:vito.muggeo@unipa.it">vito.muggeo@unipa.it</a>
</p>


<h3>References</h3>

<p>Muggeo V., Atkins D.C., Gallop R.J., Dimidjian S. (2014) 
Segmented mixed models with random changepoints: a maximum likelihood approach 
with application to treatment for depression study. Statistical Modelling, 14, 293-313.
</p>
<p>Muggeo V. (2016) 
Segmented mixed models with random changepoints in R.  
Working paper available on RG. doi: 10.13140/RG.2.1.4180.8402
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.segmented.lme">plot.segmented.lme</a></code> for the plotting method and <code><a href="#topic+segmented.default">segmented.default</a></code> (example 2) for segmented models with no random effects in breakpoints or slope difference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(nlme)
data(Cefamandole)
Cefamandole$lTime &lt;-log(Cefamandole$Time)
Cefamandole$lconc &lt;-log(Cefamandole$conc)

o&lt;-lme(lconc ~ lTime, random=~1|Subject, data=Cefamandole)

os&lt;-segmented.lme(o, ~lTime, random=list(Subject=pdDiag(~1+lTime+U+G0)), 
  control=seg.control(n.boot=0, display=TRUE))
slope(os)


####################################################
# covariate effect on the changepoint and slope diff


#let's assume a new subject-specific covariates..
set.seed(69)
Cefamandole$z &lt;- rep(runif(6), rep(14,6))
Cefamandole$group &lt;- gl(2,42,labels=c('a','b'))

#Here 'group' affects the slopes and 'z' affects the changepoint 

o1 &lt;-lme(lconc ~ lTime*group, random=~1|Subject, data=Cefamandole)
os1 &lt;- segmented(o1, ~lTime, x.diff=~group, z.psi=~z, 
  random=list(Subject=pdDiag(~1+lTime+U+G0)))

slope(os1, by=list(group="a")) #the slope estimates in group="a" (baseline level)
slope(os1, by=list(group="b")) #the slope estimates in group="b" 


###################################################
# A somewhat "complicated" example:
#     i)  strong heterogeneity in the changepoints
#     ii) No changepoint for the Subject #7 (added) 

d&lt;-Cefamandole
d$x&lt;- d$lTime
d$x[d$Subject==1]&lt;- d$lTime[d$Subject==1]+3
d$x[d$Subject==5]&lt;- d$lTime[d$Subject==5]+5
d$x[d$Subject==3]&lt;- d$lTime[d$Subject==3]-5
d&lt;-rbind(d, d[71:76,])
d$Subject &lt;- factor(d$Subject, levels=c(levels(d$Subject),"7")) 
d$Subject[85:90] &lt;- rep("7",6)

o&lt;-lme(lconc ~ x, random=~1|Subject, data=d)
os2&lt;-segmented.lme(o, ~x, random=list(Subject=pdDiag(~1+x+U+G0)), 
  control=seg.control(n.boot=5, display=TRUE))

#plots with common x- and y- scales (to note heterogeneity in the changepoints)
plot(os2, n.plot = c(3,3)) 
os2$psi.i
attr(os2$psi.i, "is.break") #it is FALSE for Subject #7

#plots with subject-specific scales
plot(os2, n.plot = c(3,3), xscale=-1, yscale = -1) 

## End(Not run)

</code></pre>

<hr>
<h2 id='segreg'>
Fitting segmented/stepmented regression
</h2><span id='topic+segreg'></span><span id='topic+stepreg'></span>

<h3>Description</h3>

<p><code>segreg</code> (<code>stepreg</code>) fits (generalized) linear segmented (stepmented) regression via a symbolic description of the linear predictor. This is an alternative but equivalent function, introduced since version 2.0-0 (segreg) and 2.1-0 (stepreg), to <code>segmented.(g)lm</code> or <code>stepmented.(g)lm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segreg(formula, data, subset, weights, na.action, family = lm, control = seg.control(), 
      transf = NULL, contrasts = NULL, model = TRUE, x = FALSE, var.psi = TRUE, ...)
      
stepreg(formula, data, subset, weights, na.action, family = lm, control = seg.control(), 
       transf = NULL, contrasts = NULL, model = TRUE, x = FALSE, var.psi = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segreg_+3A_formula">formula</code></td>
<td>

<p>A standard model formula also including one or more 'segmented'/'stepmented' terms via the function <code><a href="#topic+seg">seg</a></code>
</p>
</td></tr>
<tr><td><code id="segreg_+3A_data">data</code></td>
<td>

<p>The possible dataframe where the variables are stored
</p>
</td></tr>
<tr><td><code id="segreg_+3A_subset">subset</code></td>
<td>

<p>Possible subset, as in <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>
</p>
</td></tr>
<tr><td><code id="segreg_+3A_weights">weights</code></td>
<td>

<p>Possible weight vector, see <code>weights</code> in <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>
</p>
</td></tr>
<tr><td><code id="segreg_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what happen when the data contain NA values. See <code>na.action</code> in <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>.
</p>
</td></tr>
<tr><td><code id="segreg_+3A_family">family</code></td>
<td>

<p>The family specification, similar to <code>family</code> in <code><a href="stats.html#topic+glm">glm</a></code>. Default to <code>'lm'</code> for segmented/stepmented linear models.
</p>
</td></tr>
<tr><td><code id="segreg_+3A_control">control</code></td>
<td>

<p>See <code><a href="#topic+seg.control">seg.control</a></code>
</p>
</td></tr>
<tr><td><code id="segreg_+3A_transf">transf</code></td>
<td>

<p>an optional character string (with &quot;y&quot; as argument) meaning a function to apply to the response variable before fitting
</p>
</td></tr>
<tr><td><code id="segreg_+3A_contrasts">contrasts</code></td>
<td>

<p>see <code>contrasts</code> in <code><a href="stats.html#topic+glm">glm</a></code>
</p>
</td></tr>
<tr><td><code id="segreg_+3A_model">model</code></td>
<td>

<p>If <code>TRUE</code>, the model frame is returned.
</p>
</td></tr>
<tr><td><code id="segreg_+3A_x">x</code></td>
<td>

<p>If <code>TRUE</code>, the model matrix is returned.
</p>
</td></tr>
<tr><td><code id="segreg_+3A_var.psi">var.psi</code></td>
<td>

<p>logical, meaning if the standard errors for the breakpoint estimates should be returned in the object fit. If <code>FALSE</code>, 
the standard errors will be computed by <code><a href="#topic+vcov.segmented">vcov.segmented</a></code> or <code><a href="#topic+summary.segmented">summary.segmented</a></code>. Setting <code>var.psi=FALSE</code> could speed up model estimation for very large datasets. Default to <code>TRUE</code> for <code>segreg</code> and <code>FALSE</code> for <code>stepreg</code>.  
</p>
</td></tr>
<tr><td><code id="segreg_+3A_...">...</code></td>
<td>

<p>Ignored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows to fit segmented/stepmented (G)LM regression models using a formula interface. Results will be the 
same of those coming from the traditional <code>segmented.lm</code> and <code>segmented.glm</code> (or <code>stepmented.lm</code> or 
<code>stepmented.glm</code>), but there are some additional facilities: i) it is possible to estimate strightforwardly the segmented/stepmented 
relationships in each level of a categorical variable, see argument <code>by</code> in  <code><a href="#topic+seg">seg</a></code>; 
ii) it is possible to constrain some slopes of the segmented relationship, see argument <code>est</code> or <code>R</code> in <code><a href="#topic+seg">seg</a></code>.
</p>
<p>See  <code><a href="#topic+segmented">segmented</a></code> and <code><a href="#topic+stepmented">stepmented</a></code> for some details on the fit objects.
</p>


<h3>Value</h3>

<p>An object of class &quot;segmented&quot; (or &quot;stepmented&quot;) which inherits from the class &quot;lm&quot; or &quot;glm&quot; depending on <code>family</code> specification. See <code><a href="#topic+segmented.lm">segmented.lm</a></code>.
</p>


<h3>Warning </h3>

<p>Currently for fits returned by <code>segreg</code>, <code><a href="#topic+confint.segmented">confint.segmented</a></code> only works if <code>method="delta"</code>.
Constraints on the mean levels (possibly via argument 'est' of <code>seg</code>) are not yet allowed when calling <code>stepreg</code>.
</p>


<h3>Note</h3>

<p>When the formula includes even a single segmented term with constraints (specified via the argument <code>est</code> in <code>seg()</code>), the relevant coefficients returned do not represent the slope differences as in <code>segmented.lm</code> or <code>segmented.glm</code>. The values depend on the constraints and are not usually interpretable. Use <code><a href="#topic+slope">slope</a></code> the recover the actual slopes of the segmented relationships. 
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>References</h3>

<p>Muggeo, V.M.R. (2003) Estimating regression models with unknown break-points. Statistics in Medicine 22, 3055-3071.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seg">seg</a></code>, <code><a href="#topic+segmented">segmented</a></code>, <code><a href="#topic+stepmented">stepmented</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################
#An example using segreg()
###########################

set.seed(10)
x&lt;-1:100
z&lt;-runif(100)
w&lt;-runif(100,-10,-5)
y&lt;-2+1.5*pmax(x-35,0)-1.5*pmax(x-70,0)+10*pmax(z-.5,0)+rnorm(100,0,2)

##the traditional approach
out.lm&lt;-lm(y~x+z+w)
o&lt;-segmented(out.lm, seg.Z=~x+z, psi=list(x=c(30,60),z=.4))

o1&lt;-segreg(y ~ w+seg(x,npsi=2)+seg(z))
all.equal(fitted(o), fitted(o1))

#put some constraints on the slopes
o2&lt;-segreg(y ~ w+seg(x,npsi=2, est=c(0,1,0))+seg(z))
o3&lt;-segreg(y ~ w+seg(x,npsi=2, est=c(0,1,0))+seg(z, est=c(0,1)))

slope(o2)
slope(o3)

##see ?plant for an additional example


###########################
#An example using stepreg()
###########################

### Two stepmented covariates (with 1 and 2 breakpoints)
n=100
x&lt;-1:n/n
z&lt;-runif(n,2,5)
w&lt;-rnorm(n)
mu&lt;- 2+ 1*(x&gt;.6)-2*(z&gt;3)+3*(z&gt;4)
y&lt;- mu + rnorm(n)*.8

os &lt;-stepreg(y~seg(x)+seg(z,2)+w) #also includes 'w' as a possible linear term
os
summary(os)
plot(os, "z", col=2:4) #plot the effect of z


</code></pre>

<hr>
<h2 id='selgmented'>
Selecting the number of breakpoints in segmented regression
</h2><span id='topic+selgmented'></span>

<h3>Description</h3>

<p>This function selects (and estimates) the number of breakpoints of the segmented relationship according to the BIC/AIC criterion or sequential hypothesis testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selgmented(olm, seg.Z, Kmax=2, type = c("score", "bic", "davies", "aic"), 
  alpha = 0.05, control = seg.control(), refit = FALSE, stop.if = 5, 
  return.fit = TRUE, bonferroni = FALSE, msg = TRUE, plot.ic = FALSE, th = NULL, 
  G = 1, check.dslope = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selgmented_+3A_olm">olm</code></td>
<td>

<p>A starting <code>lm</code> or <code>glm</code> object, or a simple numerical vector meaning the response variable.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_seg.z">seg.Z</code></td>
<td>

<p>A one-side formula for the segmented variable. Only one term can be included, and it can be omitted if <code>olm</code> is a (g)lm fit including just one numeric covariate. Also it might be omitted, and will be taken as 1,2..., if <code>olm</code> includes a single numeric variable. 
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_kmax">Kmax</code></td>
<td>

<p>The maximum number of breakpoints being tested. If <code>type='bic'</code> or <code>type='aic'</code>, any integer value can be specified; otherwise at most <code>Kmax=2</code> breakpoints can be tested via the Score or Davies statistics.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_type">type</code></td>
<td>

<p>Which criterion should be used? Options <code>"score"</code> and <code>"davies"</code> allow to carry out sequential hypothesis testing with no more than 2 breakpoints (<code>Kmax=2</code>). Alternatively, the number of breakpoints can be selected via the BIC (or AIC) with virtually no upper bound for <code>Kmax</code>.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_alpha">alpha</code></td>
<td>

<p>The fixed type I error probability when sequential hypothesis testing is carried out (i.e. <code>type='score'</code> or <code>'davies'</code>). It is also used when <code>type='bic'</code> (or <code>type='aic'</code>) and <code>check.dslope=TRUE</code> to remove the breakpoints based on the slope diffence t-value.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_control">control</code></td>
<td>

<p>See <code><a href="#topic+seg.control">seg.control</a></code>.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_refit">refit</code></td>
<td>

<p>If <code>TRUE</code>, the final selected model is re-fitted using arguments in <code>control</code>, typically with bootstrap restarting. Set <code>refit=FALSE</code> to speed up computation (and possibly accepting near-optimal estimates). It is always <code>TRUE</code> if <code>type='score'</code> or <code>type='davies'</code>.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_stop.if">stop.if</code></td>
<td>

<p>An integer. If, when trying models with an increasing (when <code>G=1</code>) or decreasing (when <code>G&gt;1</code>) number of breakpoints, <code>stop.if</code> consecutive fits exhibit higher AIC/BIC values, the search is interrupted. Set a large number, larger then <code>Kmax</code> say, if you want to assess the fits for all breakpoints <code>0, 1, 2, ..., Kmax</code>. Ignored if <code>type='score'</code> or <code>type='davies'</code>.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_return.fit">return.fit</code></td>
<td>

<p>If <code>TRUE</code>, the fitted model (with the number of breakpoints selected according to <code>type</code>) is returned.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_bonferroni">bonferroni</code></td>
<td>

<p>If <code>TRUE</code>, the Bonferroni correction is employed, i.e. <code>alpha/Kmax</code> (rather than <code>alpha</code>) is always taken as threshold value to reject or not. If <code>FALSE</code>, <code>alpha</code> is used in the second level of hypothesis testing. It is also effective when <code>type="bic"</code> (or <code>'aic'</code>) and <code>check.dslope=TRUE</code>, see Details. 
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_msg">msg</code></td>
<td>

<p>If <code>FALSE</code> the final fit is returned silently with the selected number of breakpoints, otherwise the messages about the selection procedure (i.e. the BIC values), and possible warnings are also printed.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_plot.ic">plot.ic</code></td>
<td>

<p>If <code>TRUE</code> the information criterion values with respect to the number of breakpoints are plotted. Ignored if <code>type='score'</code> or <code>type='davies'</code> or <code>G&gt;1</code>. Note that if <code>check.dslope=TRUE</code>, the final number of breakpoints could differ from the one selected by the BIC/AIC leading to an inconsistent plot of the information criterion, see Note below.   
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_th">th</code></td>
<td>

<p>When a large number of breakpoints is being tested, it could happen that 2 estimated breakpoints are too close each other, and only one can be retained. Thus if the difference between two breakpoints is less or equal to <code>th</code>, one (the first) breakpoint is removed. Of course, <code>th</code> depends on the <code>x</code> scale: Integers, like 5 or 10, are appropriate if the covariate is the observation index. Default (<code>NULL</code>) means <code>th=diff(range(x))/100</code>. Set <code>th=0</code> if you are willing to consider even breakpoints very clode each other. Ignored if <code>type='score'</code> or <code>type='davies'</code>.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_g">G</code></td>
<td>

<p>Number of sub-intervals to consider to search for the breakpoints when <code>type='bic'</code> or <code>'aic'</code>. See Details.
</p>
</td></tr>
<tr><td><code id="selgmented_+3A_check.dslope">check.dslope</code></td>
<td>

<p>Logical. Effective only if <code>type='bic'</code> or <code>'aic'</code>. After the optimal number of breakpoints has been selected (via AIC/BIC), should the <code class="reqn">t</code> values of the slope differences be checked? If <code>TRUE</code>, the breakpoints corresponding to slope differences with a 'low' <code class="reqn">t</code> values will be removed. Note the model is re-fitted at each removal and a new check is performed. Simulation evidence suggests that such strategy leads to better results. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses properly the functions <code>segmented</code>, <code>pscore.test</code> or <code>davies.test</code> to select the 'optimal' number of breakpoints <code>0,1,...,Kmax</code>. If <code>type='bic'</code> or <code>'aic'</code>, the procedure stops if the last <code>stop.if</code> fits have increasing values of the information criterion. Moreover, a breakpoint is removed if too close to other, actually if the difference between two consecutive estimates is less then <code>th</code>. Finally, if <code>check.dslope=TRUE</code>, breakpoints whose corresponding slope difference estimate is &lsquo;small&rsquo; (i.e. <code class="reqn">p</code>-value larger then <code>alpha</code> or <code>alpha/Kmax</code>) are also removed. 
</p>
<p>When <code class="reqn">G&gt;1</code> the dataset is split into <code class="reqn">G</code> groups, and the search is carried out separately within each group. This approach is fruitful when there are many breakpoints not evenly spaced in the covariate range and/or concentrated in some sub-intervals. <code>G=3</code> or <code>4</code> is recommended based on simulation evidence. 
</p>
<p>Note <code>Kmax</code> is always tacitely reduced in order to have at least 1 residual df in the model with <code>Kmax</code> changepoints. Namely, if <code class="reqn">n=20</code>, the maximal segmented model has <code>2*(Kmax + 1)</code> parameters, and therefore the largest <code>Kmax</code> allowed is 8.
</p>
<p>When <code>type='score'</code> or <code>'davies'</code>, the function also returns the 'overall p-value' coming from combing the single p-values using the Fisher method. The pooled p-value, however, does not affect the final result which depends on the single p-values only. 
</p>


<h3>Value</h3>

<p>The returned object depends on argument <code>return.fit</code>. If <code>FALSE</code>, the returned object is a list with some information on the compared models (i.e. the BIC values), otherwise a classical <code>'segmented'</code> object (see <code><a href="#topic+segmented">segmented</a></code> for details) with the component <code>selection.psi</code> including the A/BIC values and<br />
- if <code>refit=TRUE</code>, <code>psi.no.refit</code> that represents the breakpoint values before the last fit (with boot restarting)<br />
- if <code>G&gt;1</code>, <code>cutvalues</code> including the cutoffs values used to split the data.
</p>


<h3>Note</h3>

<p>If <code>check.dslope=TRUE</code>, there is no guarantee that the final model has the lowest AIC/BIC. Namely the model with the best A/BIC could have &lsquo;non-significant&rsquo; slope differences which will be removed (with the corresponding breakpoints) by the final model. Hence the possible plot (obtained via <code>plot.ic=TRUE</code>) could be misleading. See Example 1 below.   
</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo
</p>


<h3>References</h3>

<p>Muggeo V (2020) Selecting number of breakpoints in segmented regression: implementation in the R package segmented
https://www.researchgate.net/publication/343737604
</p>


<h3>See Also</h3>

<p><code><a href="#topic+segmented">segmented</a></code>, <code><a href="#topic+pscore.test">pscore.test</a></code>, <code><a href="#topic+davies.test">davies.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12)
xx&lt;-1:100
zz&lt;-runif(100)
yy&lt;-2+1.5*pmax(xx-35,0)-1.5*pmax(xx-70,0)+15*pmax(zz-.5,0)+rnorm(100,0,2)
dati&lt;-data.frame(x=xx,y=yy,z=zz)
out.lm&lt;-lm(y~x,data=dati)

os &lt;-selgmented(out.lm) #selection (Kmax=2) via the Score test (default)

os &lt;-selgmented(out.lm, type="bic", Kmax=3) #BIC-based selection

## Not run: 
########################################
#Example 1: selecting a large number of breakpoints

b &lt;- c(-1,rep(c(1.5,-1.5),l=15))
psi &lt;- seq(.1,.9,l=15)
n &lt;- 2000
x &lt;- 1:n/n
X &lt;- cbind(x, outer(x,psi,function(x,y)pmax(x-y,0)))
mu &lt;- drop(tcrossprod(X,t(b)))
set.seed(113)
y&lt;- mu + rnorm(n)*.022 
par(mfrow=c(1,2))

#select number of breakpoints via the BIC (and plot it)
o&lt;-selgmented(y, Kmax=20, type='bic', plot.ic=TRUE, check.dslope = FALSE) 
plot(o, res=TRUE, col=2, lwd=3)
points(o)
# select via the BIC + check on the slope differences (default)
o1 &lt;-selgmented(y, Kmax=20, type='bic', plot.ic=TRUE) #check.dslope = TRUE by default
#note the plot of BIC is misleading.. But the number of psi is correct 
plot(o1, add=TRUE, col=3)
points(o1, col=3, pch=3)

##################################################
#Example 2: a large number of breakpoints not evenly spaced.  

b &lt;- c(-1,rep(c(2,-2),l=10))
psi &lt;- seq(.5,.9,l=10)
n &lt;- 2000
x &lt;- 1:n/n
X &lt;- cbind(x, outer(x,psi,function(x,y)pmax(x-y,0)))
mu &lt;- drop(tcrossprod(X,t(b)))
y&lt;- mu + rnorm(n)*.02 

#run selgmented with G&gt;1. G=3 or 4 recommended. 
#note G=1 does not return the right number of breaks  
o1 &lt;-selgmented(y, type="bic", Kmax=20, G=4)

## End(Not run)

</code></pre>

<hr>
<h2 id='slope'> Slope estimates from segmented/stepmented relationships </h2><span id='topic+slope'></span>

<h3>Description</h3>

<p>Computes the slopes of each &lsquo;segmented&rsquo; (or even &lsquo;stepmented&rsquo;) relationship in the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope(ogg, parm, conf.level = 0.95, rev.sgn=FALSE, 
    APC=FALSE, .vcov=NULL, .coef=NULL, use.t=NULL, by=NULL, 
    interc=TRUE, level=0, ..., digits = max(4, getOption("digits") - 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slope_+3A_ogg">ogg</code></td>
<td>
<p> an object of class &quot;segmented&quot; or &quot;segmented.lme&quot;, returned by any <code>segmented</code> method or a list of two segmented fits to compare the estimates of corresponding slopes.</p>
</td></tr>
<tr><td><code id="slope_+3A_parm">parm</code></td>
<td>
<p> the segmented variable whose slopes have to be computed. If missing all the segmented variables are considered. </p>
</td></tr>
<tr><td><code id="slope_+3A_conf.level">conf.level</code></td>
<td>
<p> the confidence level required. </p>
</td></tr>
<tr><td><code id="slope_+3A_rev.sgn">rev.sgn</code></td>
<td>
<p>vector of logicals. The length should be equal to the length of <code>parm</code>, but it is recycled 
otherwise. When <code>TRUE</code> it is assumed that the current <code>parm</code> is &lsquo;minus&rsquo; the actual segmented variable,
therefore the sign is reversed before printing. This is useful when a null-constraint has been set on the last slope.</p>
</td></tr>
<tr><td><code id="slope_+3A_apc">APC</code></td>
<td>
<p>logical. If <code>APC=TRUE</code> the &lsquo;annual percent changes&rsquo;, i.e. <code class="reqn">100\times(\exp(\beta)-1)</code>, 
are computed for each interval (<code class="reqn">\beta</code> is the slope). Only point estimates and confidence intervals are returned.</p>
</td></tr>
<tr><td><code id="slope_+3A_.vcov">.vcov</code></td>
<td>
<p> The <em>full</em> covariance matrix of estimates. If unspecified (i.e. <code>NULL</code>), the covariance matrix is computed internally by <code>vcov(ogg)</code>.</p>
</td></tr>
<tr><td><code id="slope_+3A_.coef">.coef</code></td>
<td>
<p> The regression parameter estimates. If unspecified (i.e. <code>NULL</code>), it is computed internally by <code>coef(ogg)</code>.</p>
</td></tr>
<tr><td><code id="slope_+3A_use.t">use.t</code></td>
<td>
<p>Which quantiles should be used to compute the confidence intervals? If <code>NULL</code> (default) the <code class="reqn">t</code> distribution is used only for objects obtained by <code>segmented.lm</code>. </p>
</td></tr>
<tr><td><code id="slope_+3A_by">by</code></td>
<td>
<p>Only for <code>segmented.lme</code> objects. 
It is a named list indicating covariate names and corresponding values affecting the fitted segmented relationship. 
For instance, <code>by=list(group="2",z2=.2)</code>, provided that the model has been fitted by specifying <code>group</code> and <code>z2</code> in <code>x.diff</code> (or as interaction with the segmented variable). Note that if the provided variables or values are irrelevant for changing the slopes, a warning message is printed.   
</p>
</td></tr>
<tr><td><code id="slope_+3A_interc">interc</code></td>
<td>
<p>logical, only for <code>'stepmented'</code> fits. If <code>TRUE</code>, the mean levels also account for the intercept; otherwise the first level is assumed to be zero.
</p>
</td></tr>
<tr><td><code id="slope_+3A_level">level</code></td>
<td>
<p>Numeric, only for <code>'segmented.lme'</code> fits. If <code>0</code>, fixed effects left/right slopes are returned, otherwise the subject-specific values (with no confidence intervals).
</p>
</td></tr>
<tr><td><code id="slope_+3A_...">...</code></td>
<td>
<p> Further arguments to be passed on to <code>vcov.segmented</code>, such as <code>var.diff</code> and <code>is</code>. See Details in <code><a href="#topic+vcov.segmented">vcov.segmented</a></code> and <code><a href="#topic+summary.segmented">summary.segmented</a></code>.
</p>
</td></tr>
<tr><td><code id="slope_+3A_digits">digits</code></td>
<td>
<p>controls number of digits in the returned output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To fit broken-line relationships, <code>segmented</code> uses a parameterization whose coefficients are not 
the slopes. Therefore given an object <code>"segmented"</code>, <code>slope</code> computes point estimates,
standard errors, t-values and confidence intervals of the slopes of each segmented relationship in the fitted model.
</p>


<h3>Value</h3>

<p><code>slope</code> returns a list of matrices. Each matrix represents a segmented relationship and its number of rows equal 
to the number of segments, while five columns summarize the results.
</p>


<h3>Note</h3>

<p>The returned summary is based on limiting Gaussian distribution for the model parameters involved 
in the computations. Sometimes, even with large sample sizes such approximations are questionable 
(e.g., with small difference-in-slope parameters) and the results returned by <code>slope</code> 
might be unreliable. Therefore is responsability of the user to gauge the applicability of such asymptotic 
approximations. Anyway, the t values may be not assumed for testing purposes 
and they should be used just as guidelines to assess the estimate uncertainty.
</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo, <a href="mailto:vito.muggeo@unipa.it">vito.muggeo@unipa.it</a> </p>


<h3>References</h3>

<p>Muggeo, V.M.R. (2003) Estimating regression models with unknown break-points. 
<em>Statistics in Medicine</em> <b>22</b>, 3055&ndash;3071.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+davies.test">davies.test</a></code> and <code><a href="#topic+pscore.test">pscore.test</a></code> to test for a nonzero difference-in-slope parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(16)
x&lt;-1:100
y&lt;-2+1.5*pmax(x-35,0)-1.5*pmax(x-70,0)+rnorm(100,0,3)
out&lt;-glm(y~1)
out.seg&lt;-segmented(out,seg.Z=~x,psi=list(x=c(20,80)))
## the slopes of the three segments....
slope(out.seg)
rm(x,y,out,out.seg)
#
## an heteroscedastic example..
set.seed(123)
n&lt;-100
x&lt;-1:n/n
y&lt;- -x+1.5*pmax(x-.5,0)+rnorm(n,0,1)*ifelse(x&lt;=.5,.4,.1)
o&lt;-lm(y~x)
oseg&lt;-segmented(o,seg.Z=~x,psi=.6)
slope(oseg)
slope(oseg,var.diff=TRUE) #better CI
</code></pre>

<hr>
<h2 id='stagnant'>Stagnant band height data</h2><span id='topic+stagnant'></span>

<h3>Description</h3>

<p>The <code>stagnant</code> data frame has 28 rows and 2 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stagnant)</code></pre>


<h3>Format</h3>

<p>A data frame with 28 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>log of flow rate in g/cm sec.</p>
</dd>
<dt><code>y</code></dt><dd><p>log of band height in cm</p>
</dd>
</dl>



<h3>Details</h3>

<p>Bacon and Watts report that such data were obtained by R.A. Cook during his investigation
of the behaviour of stagnant surface layer height in a controlled flow of water.
</p>


<h3>Source</h3>

<p>Bacon D.W., Watts D.G. (1971) Estimating the transistion between two intersecting straight lines.
<em>Biometrika</em> <b>58</b>: 525 &ndash; 534.
</p>
<p>Originally from the PhD thesis by R.A. Cook
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stagnant)
## plot(stagnant)
</code></pre>

<hr>
<h2 id='step.lm.fit'>
Fitter Functions for stepmented Linear Models
</h2><span id='topic+step.lm.fit'></span><span id='topic+step.glm.fit'></span><span id='topic+step.num.fit'></span><span id='topic+step.ts.fit'></span><span id='topic+step.lm.fit.boot'></span><span id='topic+step.glm.fit.boot'></span><span id='topic+step.num.fit.boot'></span><span id='topic+step.ts.fit.boot'></span>

<h3>Description</h3>

<p><code>step.lm.fit</code> is called by <code>stepmented.lm</code> to fit stepmented linear 
(gaussian) models.  Likewise, <code>step.glm.fit</code> is called by <code>stepmented.glm</code> to fit  
generalized stepmented linear models.
The <code>step.*.fit.boot</code> functions are employed to perform bootstrap restarting. 
These functions should usually not be used directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step.lm.fit(y, x.lin, Xtrue, PSI, ww, offs, opz, return.all.sol=FALSE)  

step.lm.fit.boot(y, XREG, Z, PSI, w, offs, opz, n.boot=10, size.boot=NULL, 
        jt=FALSE, nonParam=TRUE, random=FALSE, break.boot=n.boot)                          

step.glm.fit(y, x.lin, Xtrue, PSI, ww, offs, opz, return.all.sol=FALSE)

step.glm.fit.boot(y, XREG, Z, PSI, w, offs, opz, n.boot=10, size.boot=NULL, 
        jt=FALSE, nonParam=TRUE, random=FALSE, break.boot=n.boot)
 
 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step.lm.fit_+3A_y">y</code></td>
<td>

<p>vector of observations of length <code>n</code>.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_x.lin">x.lin</code>, <code id="step.lm.fit_+3A_xreg">XREG</code></td>
<td>

<p>design matrix for standard linear terms.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_xtrue">Xtrue</code>, <code id="step.lm.fit_+3A_z">Z</code></td>
<td>

<p>appropriate matrix including the stepmented variables whose breakpoints have to be estimated.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_psi">PSI</code></td>
<td>

<p>appropriate matrix including the starting values of the breakpoints to be estimated.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_ww">ww</code>, <code id="step.lm.fit_+3A_w">w</code></td>
<td>

<p>possibe weights vector.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_offs">offs</code></td>
<td>

<p>possibe offset vector.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_opz">opz</code></td>
<td>

<p>a list including information useful for model fitting.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_n.boot">n.boot</code></td>
<td>

<p>the number of bootstrap samples employed in the bootstrap restart algorithm.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_break.boot">break.boot</code></td>
<td>

<p>Integer, less than <code>n.boot</code>. If <code>break.boot</code> consecutive bootstrap samples lead to the same objective function, the algorithm stops without performing all <code>n.boot</code> 'trials'.
This can save computational time considerably.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_size.boot">size.boot</code></td>
<td>

<p>the size of the bootstrap resamples. If <code>NULL</code> (default), it is taken equal to the sample size.
values smaller than the sample size are expected to increase perturbation in the bootstrap resamples.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_jt">jt</code></td>
<td>

<p>logical. If <code>TRUE</code> the values of the stepmented variable(s) are jittered before fitting the model to the
bootstrap resamples.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_nonparam">nonParam</code></td>
<td>

<p>if <code>TRUE</code> nonparametric bootstrap (i.e. case-resampling) is used, otherwise residual-based.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_random">random</code></td>
<td>

<p>if <code>TRUE</code>, when the algorithm fails to obtain a solution, random values are used as candidate values.
</p>
</td></tr>
<tr><td><code id="step.lm.fit_+3A_return.all.sol">return.all.sol</code></td>
<td>

<p>if <code>TRUE</code>, when the algorithm fails to obtain a solution, the values visited by the algorithm
with corresponding deviances are returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions call iteratively <code>lm.wfit</code> (or <code>glm.fit</code>) with proper design matrix depending on 
<code>XREG</code>, <code>Z</code> and <code>PSI</code>. <code>step.lm.fit.boot</code> (and <code>step.glm.fit.boot</code>) implements the bootstrap restarting idea discussed in
Wood (2001).
</p>


<h3>Value</h3>

<p>A list of fit information.
</p>


<h3>Note</h3>

<p>These functions should usually not be used directly by the user.
</p>


<h3>Author(s)</h3>

<p> Vito Muggeo </p>


<h3>References</h3>

<p> Wood, S. N. (2001) Minimizing model fitting objectives that contain spurious local minima
by bootstrap restarting. <em>Biometrics</em> <b>57</b>, 240&ndash;244. </p>


<h3>See Also</h3>

<p><code><a href="#topic+stepmented.lm">stepmented.lm</a></code> or <code><a href="#topic+stepmented.glm">stepmented.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##See ?stepmented
</code></pre>

<hr>
<h2 id='stepmented'>
stepmented relationships in regression models
</h2><span id='topic+stepmented'></span><span id='topic+stepmented.lm'></span><span id='topic+stepmented.glm'></span><span id='topic+stepmented.ts'></span><span id='topic+stepmented.numeric'></span>

<h3>Description</h3>

<p>Fits regression models with stepmented (i.e. piecewise-constant) relationships between the response and one or more explanatory variables. Break-point estimates are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(), 
   keep.class=FALSE, var.psi=FALSE, ...)
## S3 method for class 'lm'
stepmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(),
   keep.class=FALSE, var.psi=FALSE, ...)

## S3 method for class 'glm'
stepmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(),
    keep.class=FALSE, var.psi=FALSE, ...)

## S3 method for class 'numeric'
stepmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(),
    keep.class=FALSE, var.psi=FALSE, ..., 
    pertV=0, centerX=FALSE, adjX=NULL, weights=NULL)

## S3 method for class 'ts'
stepmented(obj, seg.Z, psi, npsi, fixed.psi=NULL, control = seg.control(),
    keep.class=FALSE, var.psi=FALSE, ..., 
    pertV=0, centerX=FALSE, adjX=NULL)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepmented_+3A_obj">obj</code></td>
<td>
<p>A standard &lsquo;linear&rsquo; regression model of class &quot;lm&quot; or &quot;glm&quot;. Alternatively, a simple &quot;ts&quot; object or a simple data vector may be supplied. 
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_seg.z">seg.Z</code></td>
<td>
<p> the stepmented variables(s), i.e. the numeric covariate(s) understood to have a piecewise-constant relationship with response. It is a formula with no response variable, such as <code>seg.Z=~x</code> or <code>seg.Z=~x1+x2</code>. Currently, formulas involving functions, 
such as <code>seg.Z=~log(x1)</code>, or selection operators, such as <code>seg.Z=~d[,"x1"]</code> or <code>seg.Z=~d$x1</code>, are <em>not</em> allowed. Also, variable names formed by <code style="white-space: pre;">&#8288;U&#8288;</code> or <code style="white-space: pre;">&#8288;V&#8288;</code> only (with or without numbers ) are not permitted. If missing, the index variable <code>id=1,2,..,n</code> is used. For <code>stepmented.ts</code>, <code>seg.Z</code> is usually unspecified as the (time) covariate is obtained by the <code>ts</code> object itself.
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_psi">psi</code></td>
<td>
<p> starting values for the breakpoints to be estimated. If there is a single stepmented variable specified in <code>seg.Z</code>, <code>psi</code> can be a numeric vector, and it can be missing  when 1 breakpoint has to be estimated (and the median of the stepmented variable is used as a starting value). If <code>seg.Z</code> includes several covariates, <code>psi</code> has to be specified as a <em>named</em> list of vectors whose names have to match the variables in the <code>seg.Z</code> argument. Each vector of such list includes starting values for the break-point(s) for the corresponding variable in <code>seg.Z</code>. A <code>NA</code> value means that '<code>K</code>' quantiles (or equally spaced values) are used as starting values; <code>K</code> is fixed via the <code><a href="#topic+seg.control">seg.control</a></code> auxiliary function. 
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_npsi">npsi</code></td>
<td>
<p>A named vector or list meaning the <em>number</em> (and not locations) of breakpoints to be estimated. The starting values will be internally computed via the quantiles or equally spaced values, as specified in argument <code>quant</code> in <code><a href="#topic+seg.control">seg.control</a></code>. <code>npsi</code> can be missing and <code>npsi=1</code> is assumed for all variables specified in <code>seg.Z</code>. If <code>psi</code> is provided, <code>npsi</code> is ignored.</p>
</td></tr>
<tr><td><code id="stepmented_+3A_fixed.psi">fixed.psi</code></td>
<td>
<p>An optional named list including the breakpoint values to be kept fixed during the estimation procedure. The names should be a subset of (or even the same) variables specified in <code>seg.Z</code>. If there is a single variable in <code>seg.Z</code>, a simple numeric vector can be specified. Note that, in addition to the values specified here, <code>stepmented</code> will estimate additional breakpoints. To keep fixed all breakpoints (to be specified in <code>psi</code>) use <code>it.max=0</code> in <code><a href="#topic+seg.control">seg.control</a></code>
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_control">control</code></td>
<td>
<p> a list of parameters for controlling the fitting process.
See the documentation for <code><a href="#topic+seg.control">seg.control</a></code> for details. 
</p>
</td></tr>

<tr><td><code id="stepmented_+3A_keep.class">keep.class</code></td>
<td>
<p>logical value indicating if the final fit returned by <code>stepmented.default</code> should keep the class '<code>stepmented</code>' (along with the class of the original fit <code>obj</code>). Ignored by the stepmented methods. 
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_...">...</code></td>
<td>
<p> optional arguments (to be ignored safely). Notice specific arguments relevant to the original call (via <code>lm</code> or <code>glm</code> for instance), such as <code>weights</code> or <code>offet</code>, have to be included in the starting model <code>obj</code>.
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_pertv">pertV</code></td>
<td>

<p>Only for <code>stepmented.ts</code> and <code>stepmented.numeric</code>.
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_centerx">centerX</code></td>
<td>

<p>Only for <code>stepmented.ts</code> and <code>stepmented.numeric</code>. If <code>TRUE</code>, the covariate is centered before fitting.
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_adjx">adjX</code></td>
<td>

<p>Only for <code>stepmented.ts</code> and <code>stepmented.numeric</code>. If the response vector leads to covariate with large values (such as years for ts objects), <code>adjX=TRUE</code> will shift the covariate to have a zero origin. Default is <code>NULL</code> which means <code>TRUE</code> if the minimum of covariate is 1000 or larger.
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_var.psi">var.psi</code></td>
<td>

<p>logical. If <code>TRUE</code>, the estimate covariance matrix is also computed via <code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code>, thus the breakpoint standard errors are also included in the <code>psi</code> component of the returned object. Default is <code>FALSE</code>, as computing the estimate covariance matrix is somewhat time-consuming when the sample size is large. 
</p>
</td></tr>
<tr><td><code id="stepmented_+3A_weights">weights</code></td>
<td>

<p>possible weights to include in the estimation process (only for <code>stepmented.numeric</code>).
</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Given a linear regression model (usually of class &quot;lm&quot; or &quot;glm&quot;), stepmented tries to estimate
a new regression model having piecewise-constant (i.e. step-function like) relationships with the variables specified in <code>seg.Z</code>.
A <em>stepmented</em> relationship is defined by the mean level
parameters and the break-points where the mean level changes. The number of breakpoints
of each stepmented relationship depends on the <code>psi</code> argument, where initial
values for the break-points must be specified. The model
is estimated simultaneously yielding point estimates and relevant approximate
standard errors of all the model parameters, including the break-points.
</p>
<p><code>stepmented</code> implements the algorithm described in Fasola et al. (2018) along with  bootstrap restarting 
(Wood, 2001) to escape local optima. The procedure turns out to be particularly appealing and efficient
when there are two or more covariates exhibiting different change points to be estimated.
</p>
<p>See also section &lsquo;Note&rsquo; below.
</p>


<h3>Value</h3>

<p>The returned object is of class &quot;stepmented&quot; which inherits
from the class &quot;lm&quot; or &quot;glm&quot; depending on the class of <code>obj</code>. When <code>only.mean=FALSE</code>, it is a list having two 'stepmented' fits (for the mean and for the dispersion submodels). <br />
</p>
<p>An object of class &quot;stepmented&quot; is a list containing the components of the
original object <code>obj</code> with additionally the followings:
</p>
<table role = "presentation">
<tr><td><code>psi</code></td>
<td>
<p>estimated break-points and relevant (approximate) standard errors (on the continuum)</p>
</td></tr>
<tr><td><code>psi.rounded</code></td>
<td>
<p>the rounded estimated break-points (see Note, below)</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>number of iterations employed</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>difference in the objective function when the algorithm stops</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the model frame</p>
</td></tr>
<tr><td><code>psi.history</code></td>
<td>
<p>a list or a vector including the breakpoint estimates at each step</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>the integer vector containing the seed just before the bootstrap resampling. 
Returned only if bootstrap restart is employed</p>
</td></tr>
<tr><td><code>..</code></td>
<td>
<p>Other components are not of direct interest of the user</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Assuming a single changepoint <code class="reqn">\psi</code> for the covariate <code class="reqn">x</code>, the underlying fitted stepmented relationship is 
<code class="reqn">\beta_0+\beta_1 \ I(x&gt;\psi)</code>, namely the fitted value (on the linear predictor scale) is <code class="reqn">\beta_0</code> if <code class="reqn">x\le \psi</code>, and <code class="reqn">\beta_0+\beta_1</code> when 
<code class="reqn">x &gt; \psi</code>. While the point estimate <code class="reqn">\hat\psi</code> returned (in the <code>psi</code> component of the fit object) 
is a unique real number, actually there exist infinite solutions in the range <code class="reqn">[a, b)</code> where the extremes are the two 
closest <em>observed</em> covariate values 
such hat <code class="reqn">a \le \hat\psi&lt;b</code>. The component <code>psi.rounded</code> of the fit object includes the rounded changepoint values 
which can be taken as the final estimates. More specifically, each column of <code>psi.rounded</code> 
represents a changepoint and the corresponding rows are the extremes of the &lsquo;optimal&rsquo; interval <code class="reqn">[a, b)</code>. 
The first row, i.e. the lower bound of the interval (<code class="reqn">a</code> in the above example), 
is taken as point estimate. <code>print.stepmented</code>, <code>print.summary.stepmented</code>, 
and <code>confint.stepmented</code> return the rounded (lower) value of the interval.
</p>
<p>Also:
</p>

<ol>
<li><p> The algorithm will start if the <code>it.max</code> argument returned by <code>seg.control</code>
is greater than zero. If <code>it.max=0</code> <code>stepmented</code> will estimate a new linear model with
break-point(s) fixed at the starting values reported in <code>psi</code>. Alternatively, it is also possible to set <code>h=0</code> in <code>seg.control()</code>. In this case, bootstrap restarting is unncessary, then to have changepoints at <code>mypsi</code> type <br />
</p>
<p><code>stepmented(.., psi=mypsi, control=seg.control(h=0, n.boot=0, it.max=1))</code>
</p>
</li>
<li><p> In the returned fit object, &lsquo;U.&rsquo; is put before the name of the stepmented 
variable to indicate the difference in the mean levels. <code><a href="#topic+slope">slope</a></code> can be used to compute the actual mean levels corresponding to the different intervals.
</p>
</li>
<li><p> Currently methods specific to the class <code>"stepmented"</code> are
</p>

<ul>
<li> <p><code><a href="#topic+print.stepmented">print.stepmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summary.stepmented">summary.stepmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.summary.stepmented">print.summary.stepmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.stepmented">plot.stepmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+confint.stepmented">confint.stepmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code>
</p>
</li>
<li> <p><code><a href="#topic+lines.stepmented">lines.stepmented</a></code>



</p>
</li></ul>

<p>Others are inherited from the class <code>"lm"</code> or <code>"glm"</code> depending on the
class of <code>obj</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p> Vito M. R. Muggeo, <a href="mailto:vito.muggeo@unipa.it">vito.muggeo@unipa.it</a> (based on original code by Salvatore Fasola)</p>


<h3>References</h3>

<p>Fasola S, Muggeo VMR, Kuchenhoff H (2018) A heuristic, iterative algorithm for change-point detection in abrupt change models, <em>Computational Statistics</em> <b>33</b>,  997&ndash;1015
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+segmented">segmented</a></code> for segmented regression, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
n=20
x&lt;-1:n/n
mu&lt;- 2+ 1*(x&gt;.6)
y&lt;- mu + rnorm(n)*.8

#fitting via regression model
os &lt;-stepmented(lm(y~1),~x)

y&lt;-ts(y)
os1&lt;- stepmented(y)  #the 'ts' method
os2&lt;- stepmented(y, npsi=2)
#plot(y)
#plot(os1, add=TRUE)
#plot(os2, add=TRUE, col=3:5)


### Example with (poisson) GLM
y&lt;- rpois(n,exp(mu))
o&lt;-stepmented(glm(y~1,family=poisson))
plot(o, res=TRUE)

## Not run: 

## Example using the (well-known) Nile dataset
data(Nile)
plot(Nile)
os&lt;- stepmented(Nile)
plot(os, add=TRUE)


### Example with (binary) GLM (example from the package stepR)
set.seed(1234)
y &lt;- rbinom(200, 1, rep(c(0.1, 0.7, 0.3, 0.9), each=50))
o&lt;-stepmented(glm(y~1,family=binomial), npsi=3)
plot(o, res=TRUE)

### Two stepmented covariates (with 1 and 2 breakpoints); z has also an additional linear effect
n=100
x&lt;-1:n/n
z&lt;-runif(n,2,5)
mu&lt;- 2+ 1*(x&gt;.6)-2*(z&gt;3)+3*(z&gt;4)+z
y&lt;- mu + rnorm(n)*.8

os &lt;-stepmented(lm(y~z),~x+z, npsi=c(x=1,z=2))
os
summary(os)

## see ?plot.stepmented

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.segmented'> Summarizing  model fits for segmented regression </h2><span id='topic+summary.segmented'></span><span id='topic+print.summary.segmented'></span>

<h3>Description</h3>

<p>summary method for class <code>segmented</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented'
summary(object, short = FALSE, var.diff = FALSE, p.df="p", .vcov=NULL, ...)

## S3 method for class 'summary.segmented'
print(x, short=x$short, var.diff=x$var.diff, 
    digits = max(3, getOption("digits") - 3),
    signif.stars = getOption("show.signif.stars"),...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.segmented_+3A_object">object</code></td>
<td>
<p> Object of class &quot;segmented&quot;. </p>
</td></tr>
<tr><td><code id="summary.segmented_+3A_short">short</code></td>
<td>
<p> logical indicating if the &lsquo;short&rsquo; summary should be printed. </p>
</td></tr>
<tr><td><code id="summary.segmented_+3A_var.diff">var.diff</code></td>
<td>
<p> logical indicating if different error variances should be computed 
in each interval of the segmented variable, see Details. If <code>.vcov</code> is provided, <code>var.diff</code> is set to <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="summary.segmented_+3A_p.df">p.df</code></td>
<td>
<p> A character as a function of <code>'p'</code> (number of parameters) and <code>'K'</code> (number of groups or segments) affecting computations of the group-specific 
variance (and the standard errors) if <code>var.diff=TRUE</code>, see Details.</p>
</td></tr>
<tr><td><code id="summary.segmented_+3A_.vcov">.vcov</code></td>
<td>
<p> Optional. The full covariance matrix for the parameter estimates. If provided, standard errors are computed (and displayed) according to this matrix.</p>
</td></tr>
<tr><td><code id="summary.segmented_+3A_x">x</code></td>
<td>
<p>a <code>summary.segmented</code> object produced by <code>summary.segmented()</code>.</p>
</td></tr>
<tr><td><code id="summary.segmented_+3A_digits">digits</code></td>
<td>
<p>controls number of digits printed in output.</p>
</td></tr>
<tr><td><code id="summary.segmented_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical, should stars be printed on summary tables of coefficients?</p>
</td></tr>
<tr><td><code id="summary.segmented_+3A_...">...</code></td>
<td>
<p> further arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>short=TRUE</code> only coefficients of the segmented relationships are printed.
If <code>var.diff=TRUE</code> and there is only one segmented variable, different error variances are 
computed in the intervals defined by the estimated breakpoints of the segmented variable. 
For the jth interval with <code class="reqn">n_j</code> observations, the error variance is estimated via <code class="reqn">RSS_j/(n_j-p)</code>, 
where <code class="reqn">RSS_j</code> is the residual sum of squares in interval j, and <code class="reqn">p</code> is the number of model parameters. This number to be subtracted from <code class="reqn">n_j</code> can be changed via argument <code>p.df</code>. For instance <code>p.df="0"</code> uses <code class="reqn">RSS_j/(n_j)</code>, and <code>p.df="p/K"</code> leads to <code class="reqn">RSS_j/(n_j-p/K)</code>, where <code class="reqn">K</code> is the number of groups (segments), and <code class="reqn">p/K</code> can be interpreted as the average number of model parameter in that group. 
</p>
<p>Note <code>var.diff=TRUE</code> only affects the estimates covariance matrix. It does <em>not</em> affect the parameter estimates, neither the log likelihood and relevant measures, such as AIC  or BIC. In other words, <code>var.diff=TRUE</code> just provides 'alternative' standard errors, probably appropriate when the error variances are different before/after the estimated breakpoints. Also <code class="reqn">p-values</code> are computed using the t-distribution with 'naive' degrees of freedom (as reported in <code>object$df.residual</code>).
</p>
<p>If <code>var.diff=TRUE</code> the variance-covariance matrix of the estimates is computed via the 
sandwich formula, 
</p>
<p style="text-align: center;"><code class="reqn">(X^TX)^{-1}X^TVX(X^TX)^{-1}</code>
</p>
 
<p>where V is the diagonal matrix including the different group-specific error variance estimates. Standard errors are the square root of the main diagonal of this matrix.
</p>


<h3>Value</h3>

<p>A list (similar to one returned by <code>segmented.lm</code> or <code>segmented.glm</code>) with additional components:
</p>
<table role = "presentation">
<tr><td><code>psi</code></td>
<td>
<p>estimated break-points and relevant (approximate) standard errors</p>
</td></tr>
<tr><td><code>Ttable</code></td>
<td>
<p>estimates and standard errors of the model parameters. This is similar
to the matrix <code>coefficients</code> returned by <code>summary.lm</code> or <code>summary.glm</code>,
but without the rows corresponding to the breakpoints. Even the p-values relevant to the
difference-in-slope parameters have been replaced by NA, since they are meaningless in
this case, see <code><a href="#topic+davies.test">davies.test</a></code>.</p>
</td></tr>
<tr><td><code>gap</code></td>
<td>
<p>estimated coefficients, standard errors and t-values for the &lsquo;gap&rsquo; variables</p>
</td></tr>
<tr><td><code>cov.var.diff</code></td>
<td>
<p>if <code>var.diff=TRUE</code>, the covaraince matrix accounting for heteroscedastic errors.</p>
</td></tr>
<tr><td><code>sigma.new</code></td>
<td>
<p>if <code>var.diff=TRUE</code>, the square root of the estimated error variances in each interval.</p>
</td></tr>
<tr><td><code>df.new</code></td>
<td>
<p>if <code>var.diff=TRUE</code>, the residual degrees of freedom in each interval.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.segmented">print.segmented</a></code>, <code><a href="#topic+davies.test">davies.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##continues example from segmented()
# summary(segmented.model,short=TRUE)

## an heteroscedastic example..
# set.seed(123)
# n&lt;-100
# x&lt;-1:n/n
# y&lt;- -x+1.5*pmax(x-.5,0)+rnorm(n,0,1)*ifelse(x&lt;=.5,.4,.1)
# o&lt;-lm(y~x)
# oseg&lt;-segmented(o,seg.Z=~x,psi=.6)
# summary(oseg,var.diff=TRUE)$sigma.new
</code></pre>

<hr>
<h2 id='summary.segmented.lme'> Summarizing  model fits for segmented mixed-effects regression </h2><span id='topic+summary.segmented.lme'></span>

<h3>Description</h3>

<p>summary method for class <code>segmented.lme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented.lme'
summary(object, .vcov=NULL, digits = max(3, getOption("digits") - 3), ...)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.segmented.lme_+3A_object">object</code></td>
<td>
<p> Object of class &quot;segmented.lme&quot;. </p>
</td></tr>
<tr><td><code id="summary.segmented.lme_+3A_.vcov">.vcov</code></td>
<td>
<p> Optional. The full covariance matrix for the parameter estimates. If provided, standard errors are computed (and displayed) according to this matrix.</p>
</td></tr>
<tr><td><code id="summary.segmented.lme_+3A_digits">digits</code></td>
<td>
<p>controls number of digits printed in output.</p>
</td></tr>
<tr><td><code id="summary.segmented.lme_+3A_...">...</code></td>
<td>
<p> further arguments. </p>
</td></tr>
</table>


<h3>Details</h3>


<p>The function summarizes and prints the most relevant information on the segmented mixed fit. The output is similar to that returned by <code>print.summary.lme</code> 
</p>


<h3>Value</h3>

<p>A list (similar to one returned by <code>segmented.lm</code>) with estimates of the variance components, and point estimates, standard errors, DF, t-value and p-value for the fixed effects. p-values for the variables <code>U</code> and <code>G0</code> are omitted as pointless. 
</p>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.segmented.lme">print.segmented.lme</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##continues example from segmented.lme()
# summary(os)

</code></pre>

<hr>
<h2 id='summary.stepmented'> Summarizing  model fits for stepmented regression </h2><span id='topic+summary.stepmented'></span><span id='topic+print.summary.stepmented'></span><span id='topic+print.stepmented'></span>

<h3>Description</h3>

<p>summary/print method for class <code>stepmented</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stepmented'
summary(object, short = FALSE, var.diff = FALSE, p.df="p", .vcov=NULL, ...)

## S3 method for class 'summary.stepmented'
print(x, short=x$short, var.diff=x$var.diff, 
    digits = max(3, getOption("digits") - 3),
    signif.stars = getOption("show.signif.stars"),...)

## S3 method for class 'stepmented'
print(x, digits = max(3, getOption("digits") - 3), 
    ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.stepmented_+3A_object">object</code>, <code id="summary.stepmented_+3A_x">x</code></td>
<td>
<p> Object of class &quot;stepmented&quot; or a <code>summary.stepmented</code> object produced by <code>summary.stepmented()</code>. </p>
</td></tr>
<tr><td><code id="summary.stepmented_+3A_short">short</code></td>
<td>
<p> logical indicating if the &lsquo;short&rsquo; summary should be printed. </p>
</td></tr>
<tr><td><code id="summary.stepmented_+3A_var.diff">var.diff</code></td>
<td>
<p> logical indicating if different error variances should be computed 
in each interval of the stepmented variable, see Details. If <code>.vcov</code> is provided, <code>var.diff</code> is set to <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="summary.stepmented_+3A_p.df">p.df</code></td>
<td>
<p> A character as a function of <code>'p'</code> (number of parameters) and <code>'K'</code> (number of groups or segments) affecting computations of the group-specific variance (and the standard errors) if <code>var.diff=TRUE</code>, see Details.</p>
</td></tr>
<tr><td><code id="summary.stepmented_+3A_.vcov">.vcov</code></td>
<td>
<p> Optional. The full covariance matrix for the parameter estimates. If provided, standard errors are computed (and displayed) according to this matrix.</p>
</td></tr>

<tr><td><code id="summary.stepmented_+3A_digits">digits</code></td>
<td>
<p>controls number of digits printed in output.</p>
</td></tr>
<tr><td><code id="summary.stepmented_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical, should stars be printed on summary tables of coefficients?</p>
</td></tr>
<tr><td><code id="summary.stepmented_+3A_...">...</code></td>
<td>
<p> further arguments, notably <code>type</code> to be passed to <code>vcov.stepmented</code> to compute the standard errors. See <code><a href="#topic+vcov.stepmented">vcov.stepmented</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>short=TRUE</code> only coefficients of the stepmented relationships are printed.
If <code>var.diff=TRUE</code> and there is only one stepmented variable, different error variances are 
computed in the intervals defined by the estimated breakpoints of the stepmented variable. 
For the jth interval with <code class="reqn">n_j</code> observations, the error variance is estimated via <code class="reqn">RSS_j/(n_j-p)</code>, 
where <code class="reqn">RSS_j</code> is the residual sum of squares in interval j, and <code class="reqn">p</code> is the number of model parameters. This number to be subtracted from <code class="reqn">n_j</code> can be changed via argument <code>p.df</code>. For instance <code>p.df="0"</code> uses <code class="reqn">RSS_j/(n_j)</code>, and <code>p.df="p/K"</code> leads to <code class="reqn">RSS_j/(n_j-p/K)</code>, where <code class="reqn">K</code> is the number of groups (segments), and <code class="reqn">p/K</code> can be interpreted as the average number of model parameter in that group. 
</p>
<p>Note <code>var.diff=TRUE</code> only affects the estimates covariance matrix. It does <em>not</em> affect the parameter estimates, neither the log likelihood and relevant measures, such as AIC  or BIC. In other words, <code>var.diff=TRUE</code> just provides 'alternative' standard errors, probably appropriate when the error variances are different before/after the estimated breakpoints. Also <code class="reqn">p-values</code> are computed using the t-distribution with 'naive' degrees of freedom (as reported in <code>object$df.residual</code>).
</p>
<p>If <code>var.diff=TRUE</code> the variance-covariance matrix of the estimates is computed via the 
sandwich formula, 
</p>
<p style="text-align: center;"><code class="reqn">(X^TX)^{-1}X^TVX(X^TX)^{-1}</code>
</p>
 
<p>where V is the diagonal matrix including the different group-specific error variance estimates. Standard errors are the square root of the main diagonal of this matrix.
</p>


<h3>Value</h3>

<p>A list (similar to one returned by <code>stepmented.lm</code> or <code>stepmented.glm</code>) with additional components:
</p>
<table role = "presentation">
<tr><td><code>psi</code></td>
<td>
<p>estimated break-points and relevant (approximate) standard errors</p>
</td></tr>
<tr><td><code>Ttable</code></td>
<td>
<p>estimates and standard errors of the model parameters. This is similar
to the matrix <code>coefficients</code> returned by <code>summary.lm</code> or <code>summary.glm</code>,
but without the rows corresponding to the breakpoints. Even the p-values relevant to the
difference-in-slope parameters have been replaced by NA, since they are meaningless in
this case, see <code><a href="#topic+davies.test">davies.test</a></code>.</p>
</td></tr>
<tr><td><code>cov.var.diff</code></td>
<td>
<p>if <code>var.diff=TRUE</code>, the covaraince matrix accounting for heteroscedastic errors.</p>
</td></tr>
<tr><td><code>sigma.new</code></td>
<td>
<p>if <code>var.diff=TRUE</code>, the square root of the estimated error variances in each interval.</p>
</td></tr>
<tr><td><code>df.new</code></td>
<td>
<p>if <code>var.diff=TRUE</code>, the residual degrees of freedom in each interval.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>If <code>type</code> is not specified in <code>...</code> (which means <code>type="standard"</code>), no standard error will be computed (and returned) for the jumpoint. </p>


<h3>Author(s)</h3>

<p> Vito M.R. Muggeo </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pscore.test">pscore.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##continues example from stepmented()
# summary(stepmented.model,short=TRUE)

## an heteroscedastic example..
# set.seed(123)
# n&lt;-100
# x&lt;-1:n/n
# y&lt;- -x+1.5*pmax(x-.5,0)+rnorm(n,0,1)*ifelse(x&lt;=.5,.4,.1)
# o&lt;-lm(y~x)
# oseg&lt;-stepmented(o,seg.Z=~x,psi=.6)
# summary(oseg,var.diff=TRUE)$sigma.new
</code></pre>

<hr>
<h2 id='vcov.segmented'>
Variance-Covariance Matrix for a Fitted Segmented Model
</h2><span id='topic+vcov.segmented'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the parameters (including breakpoints) of a
fitted segmented model object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented'
vcov(object, var.diff = FALSE, is = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.segmented_+3A_object">object</code></td>
<td>
<p>a fitted model object of class &quot;segmented&quot;, returned by any <code>segmented</code> method or <code>segreg</code>.</p>
</td></tr>
<tr><td><code id="vcov.segmented_+3A_var.diff">var.diff</code></td>
<td>
<p>logical. If <code>var.diff=TRUE</code> and there is a single segmented variable, the covariance 
matrix is computed using a sandwich-type formula. See Details in <code><a href="#topic+summary.segmented">summary.segmented</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.segmented_+3A_is">is</code></td>
<td>
<p>logical. If <code>TRUE</code>, the <em>asymptotic</em> covariance matrix based on the idea of induced smoothing is returned. If <code>is=TRUE</code>, <code>var.diff=FALSE</code> is set. 
<code>is=TRUE</code> only works with segmented (g)lm fits.</p>
</td></tr>
<tr><td><code id="vcov.segmented_+3A_...">...</code></td>
<td>
<p>additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned covariance matrix is based on an approximation of the nonlinear segmented term. Therefore 
covariances corresponding to breakpoints are reliable only in large samples and/or clear cut segmented 
relationships. If <code>is=TRUE</code>, the returned covariance matrix depends on the design matrix having the term <code class="reqn">I(x&gt;\psi)</code> replaced by its smooth counterpart.
</p>


<h3>Value</h3>

<p>The full matrix of the estimated covariances between the parameter estimates, including 
the breakpoints.
</p>


<h3>Note</h3>

<p><code>var.diff=TRUE</code> works when there is a single segmented variable.</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo, <a href="mailto:vito.muggeo@unipa.it">vito.muggeo@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.segmented">summary.segmented</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##continues example from summary.segmented()
# vcov(oseg)
# vcov(oseg, var.diff=TRUE)
# vcov(oseg, is=TRUE)
</code></pre>

<hr>
<h2 id='vcov.segmented.lme'>
Variance-Covariance Matrix for a Fitted Segmented Mixed Model</h2><span id='topic+vcov.segmented.lme'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the parameters (including breakpoints) of a
fitted segmented mixed model object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segmented.lme'
vcov(object, B=0, ret.b=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.segmented.lme_+3A_object">object</code></td>
<td>
<p>a fitted model object of class &quot;segmented.lme&quot;, returned by <code>segmented.lme</code> method.</p>
</td></tr>
<tr><td><code id="vcov.segmented.lme_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates, if a bootstrap-based covariance matrix is requested.</p>
</td></tr>
<tr><td><code id="vcov.segmented.lme_+3A_ret.b">ret.b</code></td>
<td>
<p>logical. If <code>FALSE</code> the full covariance matrix (for the fixed effect estimates) based on <code>B</code> case-resampling bootstrap samples is returned; otherwise a list with information on the bootstrap sampling distributions.</p>
</td></tr>
<tr><td><code id="vcov.segmented.lme_+3A_...">...</code></td>
<td>
<p>optional arguments, i.e. <code>seed</code> and <code>it.max.b</code>, used when implementing the bootstrap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned covariance matrix is based on an approximation of the nonlinear segmented term. Therefore 
covariances corresponding to breakpoints are reliable only in large samples and/or clear cut segmented 
relationships. If <code>B&gt;0</code> is set, case resampling bootstrap (on the outermost nesting level) is carried out. Moreover, if <code>ret.b=TRUE</code>, the bootstrap distributions are returned, rather than the covariance matrix.  
</p>


<h3>Value</h3>

<p>The full matrix of the estimated covariances of the fixed effects estimates, including 
the breakpoint.
</p>


<h3>Warning </h3>

<p>All the functions for segmented mixed models (*.segmented.lme) are still at an experimental stage 
</p>


<h3>Author(s)</h3>

<p>Vito M. R. Muggeo, <a href="mailto:vito.muggeo@unipa.it">vito.muggeo@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.segmented.lme">summary.segmented.lme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##continues example from segmented.lme()
# vcov(os)
# vcov(os, B=50)
# vcov(os, B=50, ret.b=TRUE)
</code></pre>

<hr>
<h2 id='vcov.stepmented'>
Variance-Covariance Matrix for a Fitted Stepmented Model
</h2><span id='topic+vcov.stepmented'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the parameters estimates (including breakpoints) of a
fitted stepmented model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stepmented'
vcov(object, k=NULL, zero.cor=TRUE, type=c("cdf", "none", "abs"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.stepmented_+3A_object">object</code></td>
<td>

<p>a fitted model object of class &quot;stepmented&quot;, returned by any <code>stepmented</code> method
</p>
</td></tr>
<tr><td><code id="vcov.stepmented_+3A_k">k</code></td>
<td>

<p>The power of <code>n</code> for the smooth approximation. Simulation evidence suggests <code>k</code> in <code class="reqn">[-1, -1/2]</code>; with <code class="reqn">k=-1/2</code> providing somewhat 'conservative' standard errors especially at small sample sizes. In general, the larger <code class="reqn">k</code>, the smaller <code class="reqn">n^{-k}</code>, and the smaller the jumpoint standard error.  
</p>
</td></tr>
<tr><td><code id="vcov.stepmented_+3A_zero.cor">zero.cor</code></td>
<td>

<p>If <code>TRUE</code>, the covariances between the jumpoints and the remaining linear coefficients are set to zero (as theory states).
</p>
</td></tr>
<tr><td><code id="vcov.stepmented_+3A_type">type</code></td>
<td>
<p>How the covariance matrix should be computed. If <code>"none"</code>, the usual asymptotic covariance matrix for the linear coefficients only (under homoskedasticity and assuming known the jumpoints) is returned; if <code>"cdf"</code>, the standard normal cdf is used to approximate the indicator function (see details); <code>"abs"</code> is yet another approximation (currently unimplemented). 
</p>
</td></tr>
<tr><td><code id="vcov.stepmented_+3A_...">...</code></td>
<td>

<p>additional arguments. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The full covariance matrix is based on the smooth approximation 
</p>
<p style="text-align: center;"><code class="reqn">I(x&gt;\psi)\approx \Phi((x-\psi)/n^{k})</code>
</p>
 
<p>via the sandwich formula using the empirical information matrix and assuming <code class="reqn">x \in [0,1]</code>. <code class="reqn">\Phi(\cdot)</code> is the standard Normal cdf, and <code class="reqn">k</code> is the argument <code>k</code>. When <code>k=NULL</code> (default), it is computed via
</p>
<p style="text-align: center;"><code class="reqn">k=-(0.6 + 0.5 \ \log(snr)/\sqrt snr - (|\hat\psi-0.5|/n)^{1/2})</code>
</p>

<p>where <code class="reqn">snr</code> is the signal-to-noise ratio corresponding to the estimated changepoint <code class="reqn">\hat\psi</code> (in the range (0,1)). The above formula comes from extensive simulation studies under different scenarios: Seo and Linton (2007) discuss using the normal cdf to smooth out the indicator function by suggesting <code class="reqn">\log(n)/n^{1/2}</code> as bandwidth; we found such suggestion does not perform well in practice. 
</p>


<h3>Value</h3>

<p>The full matrix of the estimated covariances between the parameter estimates, including 
the breakpoints.
</p>


<h3>Warning </h3>

<p>The function, including the value of <code class="reqn">k</code>, must be considered at preliminary stage. Currently the value of <code class="reqn">k</code> appears to  overestimate slightly the true <code class="reqn">\hat\psi</code> variability.</p>


<h3>Note</h3>

<p>If the fit <code>object</code> has been called by <code>stepmented(.., var.psi=TRUE)</code>, then <code>vcov.stepmented</code> will return <code>object$vcov</code>, unless the power <code>k</code> differs from <code>-2/3</code>.  
</p>


<h3>Author(s)</h3>

<p>Vito Muggeo
</p>


<h3>References</h3>

<p>Seo MH, Linton O (2007) A smoothed least squares estimator for threshold regression models, J of Econometrics, 141: 704-735
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepmented">stepmented</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##see ?stepmented
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
