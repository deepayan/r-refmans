<!DOCTYPE html><html><head><title>Help for package tmod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tmod}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tmod-package'><p>Transcriptional Module Analysis</p></a></li>
<li><a href='#cell_signatures'><p>Cell type signatures</p></a></li>
<li><a href='#check_tmod_gs'><p>Check an object of class tmodGS</p></a></li>
<li><a href='#EgambiaResults'><p>Gene expression in TB patients and Healthy controls</p></a></li>
<li><a href='#eigengene'><p>Calculate the eigengene of a module from a data set</p></a></li>
<li><a href='#evidencePlot'><p>Create an evidence plot for a module</p></a></li>
<li><a href='#filterGS'><p>Filter by genes belonging to a gene set from a data frame</p></a></li>
<li><a href='#getGenes'><p>Get genes belonging to a gene set</p></a></li>
<li><a href='#getModuleMembers'><p>Return the contents of a gene set</p></a></li>
<li><a href='#ggEvidencePlot'><p>Create an evidence plot for a module (ggplot2 version)</p></a></li>
<li><a href='#ggPanelplot'><p>Create a tmod panel plot using ggplot</p></a></li>
<li><a href='#hgEnrichmentPlot'><p>Create a visualisation of enrichment</p></a></li>
<li><a href='#makeTmodFromDataFrame'><p>Convert a data frame to a tmod object</p></a></li>
<li><a href='#makeTmodGS'><p>S3 class for tmod gene set collections</p></a></li>
<li><a href='#modCorPlot'><p>Plot a correlation heatmap for modules</p></a></li>
<li><a href='#modcors'><p>Module correlation</p></a></li>
<li><a href='#modGroups'><p>Find group of modules</p></a></li>
<li><a href='#modjaccard'><p>Jaccard index for modules</p></a></li>
<li><a href='#modmetabo'><p>Modules for metabolic profiling</p></a></li>
<li><a href='#modOverlaps'><p>Calculate overlaps of the modules</p></a></li>
<li><a href='#pcaplot'><p>Plot a PCA object returned by prcomp</p></a></li>
<li><a href='#pvalEffectPlot'><p>Create an effect size / p-value plot</p></a></li>
<li><a href='#showGene'><p>A combined beeswarm / boxplot</p></a></li>
<li><a href='#simplePie'><p>Simple Pie Chart</p></a></li>
<li><a href='#tmod_ids'><p>Query and set IDs of gene sets in a tmodGS object</p></a></li>
<li><a href='#tmod-data'><p>Default gene expression module data</p></a></li>
<li><a href='#tmod2DataFrame'><p>Convert a tmod module set into a data frame</p></a></li>
<li><a href='#tmod2tmodGS'><p>Convert the old tmod objects to the tmodGS objects</p></a></li>
<li><a href='#tmodAUC'><p>Calculate AUC</p></a></li>
<li><a href='#tmodDecideTests'><p>Count the Up- or Down-regulated genes per module</p></a></li>
<li><a href='#tmodImportMSigDB'><p>Import data from MSigDB</p></a></li>
<li><a href='#tmodLEA'><p>Leading Edge Analysis</p></a></li>
<li><a href='#tmodLEASummary'><p>Summary stats of a leading edge analysis</p></a></li>
<li><a href='#tmodLimmaDecideTests'><p>Up- and down-regulated genes in modules based on limma object</p></a></li>
<li><a href='#tmodLimmaTest'><p>Run tmod enrichment tests directly on a limma object</p></a></li>
<li><a href='#tmodLimmaTopTable'><p>tmod's replacement for the limma topTable function</p></a></li>
<li><a href='#tmodPal'><p>A selection of color palettes</p></a></li>
<li><a href='#tmodPanelPlot'><p>Plot a summary of multiple tmod analyses</p></a></li>
<li><a href='#tmodPCA'><p>PCA plot annotated with tmod</p></a></li>
<li><a href='#tmodSummary'><p>Create a summary of multiple tmod analyses</p></a></li>
<li><a href='#tmodTagcloud'><p>Tag cloud based on tmod results</p></a></li>
<li><a href='#tmodUtest'><p>Perform a statistical test of module expression</p></a></li>
<li><a href='#upset'><p>Upset plot</p></a></li>
<li><a href='#vaccination'><p>Transcriptomic responses to vaccination</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Feature Set Enrichment Analysis for Metabolomics and
Transcriptomics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.50.13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>January Weiner &lt;january.weiner@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods and feature set definitions for feature or gene set
  enrichment analysis in transcriptional and metabolic profiling data.
  Package includes tests for enrichment based on ranked lists of features,
  functions for visualisation and multivariate functional analysis. See Zyla et al (2019)
  &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtz447">doi:10.1093/bioinformatics/btz447</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tmod.online">https://tmod.online</a>, <a href="https://github.com/january3/tmod/">https://github.com/january3/tmod/</a>,
<a href="https://january3.github.io/tmod/">https://january3.github.io/tmod/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>beeswarm,tagcloud,XML,methods,plotwidgets,RColorBrewer,gplots,tibble,pheatmap,ggplot2,tidyr,purrr,rlang,tidyselect,ggrepel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat,knitr,rmarkdown,dplyr,pander,cowplot</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-31 11:39:20 UTC; january</td>
</tr>
<tr>
<td>Author:</td>
<td>January Weiner <a href="https://orcid.org/0000-0003-1438-7819"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-31 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tmod-package'>Transcriptional Module Analysis</h2><span id='topic+tmod-package'></span>

<h3>Description</h3>

<p>Transcriptional Module Analysis
</p>


<h3>Details</h3>

<p>The primary role of this package is to provide published module
assignments between genes and transcriptional modules, as well as tools
to analyse and visualize the modules.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tmodHGtest">tmodHGtest</a></code>, <code><a href="#topic+tmodUtest">tmodUtest</a></code>
</p>

<hr>
<h2 id='cell_signatures'>Cell type signatures</h2><span id='topic+cell_signatures'></span>

<h3>Description</h3>

<p>Cell type signatures
</p>


<h3>Format</h3>

<p>An object of class tmodGS
</p>


<h3>Details</h3>

<p>* CellMarker: Zhang X, Lan Y, Xu J, Quan F, Zhao E, Deng C, Luo T, Xu L, Liao G, Yan M, Ping Y. CellMarker: a manually curated resource of cell markers in human and mouse. Nucleic acids research. 2019 Jan 8;47(D1):D721-8.
</p>
<p>* CIBERSORT: Newman AM, Liu CL, Green MR, Gentles AJ, Feng W, Xu Y, Hoang CD, Diehn M, Alizadeh AA. Robust enumeration of cell subsets from tissue expression profiles. Nature methods. 2015 May;12(5):453-7.
</p>
<p>* PanglaoDB: Franzén O, Gan LM, Björkegren JL. PanglaoDB: a web server for exploration of mouse and human single-cell RNA sequencing data. Database. 2019 Jan 1;2019.
</p>


<h3>Source</h3>

<p>CIBERSORT, CellMarkers, PanglaoDB
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## to use cell signatures, type
data(cell_signatures)
data(vaccination)
gl &lt;- vaccination$GeneName[ order(vaccination$qval.F.D1) ]
tmodCERNOtest(gl, mset=cell_signatures)
</code></pre>

<hr>
<h2 id='check_tmod_gs'>Check an object of class tmodGS</h2><span id='topic+check_tmod_gs'></span>

<h3>Description</h3>

<p>Check an object of class tmodGS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_tmod_gs(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_tmod_gs_+3A_object">object</code></td>
<td>
<p>an object of class tmodGS</p>
</td></tr>
</table>

<hr>
<h2 id='EgambiaResults'>Gene expression in TB patients and Healthy controls</h2><span id='topic+EgambiaResults'></span><span id='topic+Egambia'></span>

<h3>Description</h3>

<p>Gene expression in TB patients and Healthy controls
</p>


<h3>Details</h3>

<p>This data set has been constructed from the gene expression data set
accessible in the Gene Expression Omnibus (GEO) at the accession number
GSE28623. Ten healthy donors (NID, non-infected donors) and 10 tubercolosis patients
(TB) have been randomly selected from the full data set, and top 25
genes with the highest IQR have been selected for further analysis. Genes without
an Entrez gene (EG) identifier have likewise been omitted. 
</p>
<p>The Egambia object is a data frame. The first three columns are the gene
symbol, gene name and Entrez gene (EG) identifier. The remaining columns
correspond to the gene expression data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The data set has been generated as follows:
# get the data set from GEO
library(GEOquery)
gambia &lt;- getGEO("GSE28623")[[1]]

# Convert to limma and normalize
library(limma)
e &lt;- new("EListRaw", list(E= exprs(gambia), genes=fData(gambia), targets= pData(gambia)))
e.bg &lt;- backgroundCorrect(e, method= "normexp")
en &lt;- normalizeBetweenArrays(e.bg, method= "q")
en &lt;- avereps(en, ID=en$genes$NAME)
en &lt;- en[ en$genes$CONTROL_TYPE == "FALSE", ]
en$targets$group &lt;- factor(gsub(" whole blood RNA *", "", en$targets$description))

# Fill in Entrez Gene IDs
library(org.Hs.eg.db)
en$genes$EG &lt;- ""
sel &lt;- en$genes$REFSEQ %in% ls(org.Hs.egREFSEQ2EG)
en$genes$EG[sel] &lt;- mget(as.character(en$genes$REFSEQ[sel]), org.Hs.egREFSEQ2EG)

# Filter by IQR and missing EG's
iqrs &lt;- apply(en$E, 1, IQR)
en2 &lt;- en[ iqrs &gt; quantile(iqrs, 0.75) &amp; en$genes$EG != "", ]

# Select 10 random samples from NID and TB groups
en2 &lt;- en2[ , c(sample(which(en2$targets$group == "NID"), 10), 
                 sample(which(en2$targets$group == "TB"), 10)) ]
colnames(en2$E) &lt;- en2$targets$group
Egambia &lt;- cbind(en2$genes[ , c("GENE_SYMBOL", "GENE_NAME", "EG") ], en2$E)

## End(Not run)
</code></pre>

<hr>
<h2 id='eigengene'>Calculate the eigengene of a module from a data set</h2><span id='topic+eigengene'></span>

<h3>Description</h3>

<p>Calculate the eigengene of a module from a data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigengene(x, g, mset = NULL, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigengene_+3A_x">x</code></td>
<td>
<p>data; genes in rows, samples in columns</p>
</td></tr>
<tr><td><code id="eigengene_+3A_g">g</code></td>
<td>
<p>genes &ndash; a vector gene IDs corresponding to annotation in modules</p>
</td></tr>
<tr><td><code id="eigengene_+3A_mset">mset</code></td>
<td>
<p>&ndash; a module set; eigengenes will be calculated for each module in the set</p>
</td></tr>
<tr><td><code id="eigengene_+3A_k">k</code></td>
<td>
<p>which component defines the eigengene (default: 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The eigengene of a module is here defined as the first principal
component of a PCA on the gene expression of all genes from a module.
</p>


<h3>Value</h3>

<p>A numeric matrix with rows corresponding to modules. If there
was not a sufficient number of genes in a module corresponding to the data
set, the row will contain only NA's.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Egambia)
data(tmod)
x &lt;- Egambia[ , -c(1:3) ]
ifns &lt;- tmod[ grep("[Ii]nterferon", tmod$gs$Title) ]
eigv &lt;- eigengene(x, Egambia$GENE_SYMBOL, ifns)
plot(eigv["LI.M127", ], eigv["DC.M1.2",])

# which interferon modules are correlated
cor(eigv) 
</code></pre>

<hr>
<h2 id='evidencePlot'>Create an evidence plot for a module</h2><span id='topic+evidencePlot'></span>

<h3>Description</h3>

<p>Create an evidence plot for a module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evidencePlot(
  l,
  m,
  mset = "all",
  rug = TRUE,
  roc = TRUE,
  filter = FALSE,
  unique = TRUE,
  add = FALSE,
  col = "black",
  col.rug = "#eeeeee",
  gene.labels = NULL,
  gene.colors = NULL,
  gene.lines = 1,
  gl.cex = 1,
  style = "roc",
  lwd = 1,
  lty = 1,
  rug.size = 0.2,
  legend = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evidencePlot_+3A_l">l</code></td>
<td>
<p>sorted list of HGNC gene identifiers</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_m">m</code></td>
<td>
<p>character vector of modules for which the plot should be created</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_mset">mset</code></td>
<td>
<p>Which module set to use (see tmodUtest for details)</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_rug">rug</code></td>
<td>
<p>if TRUE, draw a rug-plot beneath the ROC curve</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_roc">roc</code></td>
<td>
<p>if TRUE, draw a ROC curve above the rug-plot</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_filter">filter</code></td>
<td>
<p>if TRUE, genes not defined in the module set will be removed</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_unique">unique</code></td>
<td>
<p>if TRUE, duplicates will be removed</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_add">add</code></td>
<td>
<p>if TRUE, the plot will be added to the existing plot</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_col">col</code></td>
<td>
<p>a character vector color to be used</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_col.rug">col.rug</code></td>
<td>
<p>a character value specifying the color of the rug</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_gene.labels">gene.labels</code></td>
<td>
<p>if TRUE, gene names are shown; alternatively, a named character vector with gene labels to be shown, or NULL (default) for no labels (option evaluated only if rug is plotted)</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_gene.colors">gene.colors</code></td>
<td>
<p>NULL (default) or a character vectors indicating the color for each gene. Either a named vector or a vector with the same order of genes as 'l'.</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_gene.lines">gene.lines</code></td>
<td>
<p>a number or a vector of numbers; line width for marking the genes on the rug (default=1). If the vector is named, the names should be gene ids.</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_gl.cex">gl.cex</code></td>
<td>
<p>Text cex (magnification) for gene labels</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_style">style</code></td>
<td>
<p>&quot;roc&quot; for receiver-operator characteristic curve (default), and &quot;gsea&quot; for GSEA-style (Kaplan-Meier like plot)</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_lwd">lwd</code></td>
<td>
<p>line width (see par())</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_lty">lty</code></td>
<td>
<p>line type (see par())</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_rug.size">rug.size</code></td>
<td>
<p>fraction of the plot that should show the rug. If rug.size is 0, rug is not drawn. If rug.size is 1, ROC curve is not drawn.</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_legend">legend</code></td>
<td>
<p>position of the legend. If NULL, no legend will be drawn</p>
</td></tr>
<tr><td><code id="evidencePlot_+3A_...">...</code></td>
<td>
<p>Further parameters passed to the plotting function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an evidence plot for a module, based on an
ordered list of genes. By default, the plot shows the receiving operator
characteristic (ROC) curve and a rug below, which indicates the distribution of the
module genes in the sorted list.
</p>
<p>Several styles of the evidence plot are possible:
* roc (default): a receiver-operator characteristic like curve; the
area under the curve corresponds to the effect size (AUC)
* roc_absolute: same as above, but the values are not scaled by the
total number of genes in a module
* gsea
* enrichment: the curve shows relative enrichment at the given position
</p>


<h3>See Also</h3>

<p>[tmod-package()], [hgEnrichmentPlot()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># artificially enriched list of genes
set.seed(123)
data(tmod)
bg &lt;- sample(tmod$gv)
fg &lt;- getGenes("LI.M127", as.list=TRUE)[[1]]
fg &lt;- sample(c(fg, bg[1:1000]))
l &lt;- unique(c(fg, bg))
evidencePlot(l, "LI.M127")
evidencePlot(l, filter=TRUE, "LI.M127")
</code></pre>

<hr>
<h2 id='filterGS'>Filter by genes belonging to a gene set from a data frame</h2><span id='topic+filterGS'></span><span id='topic+showModule'></span>

<h3>Description</h3>

<p>Filter a data frame or vector by genes belonging to a gene set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterGS(genes, gs, mset = "all")

showModule(x, genes, gs, mset = "all", extra = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterGS_+3A_genes">genes</code></td>
<td>
<p>a character vector with gene IDs</p>
</td></tr>
<tr><td><code id="filterGS_+3A_gs">gs</code></td>
<td>
<p>a character vector corresponding to the IDs of the gene sets to be shown</p>
</td></tr>
<tr><td><code id="filterGS_+3A_mset">mset</code></td>
<td>
<p>Module set to use; see &quot;tmodUtest&quot; for details</p>
</td></tr>
<tr><td><code id="filterGS_+3A_x">x</code></td>
<td>
<p>a data frame or a vector</p>
</td></tr>
<tr><td><code id="filterGS_+3A_extra">extra</code></td>
<td>
<p>no longer used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>filterGS filters a vector of gene IDs based on whether the IDs belong to
a given set of gene sets, returning a logical vector.
</p>
<p>The showModule function is deprecated and will be removed in future.
</p>


<h3>Value</h3>

<p>filterGS returns a logical vector of length equal to genes, with
TRUE indicating that the given gene is a member of the gene sets in 'gs'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Egambia)
## LI.M127 – type I interferon response
sel &lt;- filterGS("LI.M127", Egambia$GENE_SYMBOL)
head(Egambia[sel, ])
</code></pre>

<hr>
<h2 id='getGenes'>Get genes belonging to a gene set</h2><span id='topic+getGenes'></span>

<h3>Description</h3>

<p>Get genes belonging to a gene set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGenes(gs = NULL, genes = NULL, fg = NULL, mset = "all", as.list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGenes_+3A_gs">gs</code></td>
<td>
<p>gene set IDs; if NULL, returns all genes from all gene sets</p>
</td></tr>
<tr><td><code id="getGenes_+3A_genes">genes</code></td>
<td>
<p>character vector with gene IDs. If not NULL, only genes
from this parameter will be considered.</p>
</td></tr>
<tr><td><code id="getGenes_+3A_fg">fg</code></td>
<td>
<p>genes which are in the foreground set</p>
</td></tr>
<tr><td><code id="getGenes_+3A_mset">mset</code></td>
<td>
<p>gene set to use (default: all tmod gene sets)</p>
</td></tr>
<tr><td><code id="getGenes_+3A_as.list">as.list</code></td>
<td>
<p>should a list of genes rather than a data frame be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a data frame mapping each module to a comma separated list of
genes. If genelist is provided, then only genes in that list will be
shown. An optional column, &quot;fg&quot; informs which genes are in the &quot;foreground&quot;
data set.
</p>


<h3>Value</h3>

<p>data frame containing module to gene mapping, or a list (if
as.list == TRUE
</p>

<hr>
<h2 id='getModuleMembers'>Return the contents of a gene set</h2><span id='topic+getModuleMembers'></span>

<h3>Description</h3>

<p>Return the contents of a gene set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModuleMembers(x, mset = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModuleMembers_+3A_x">x</code></td>
<td>
<p>a character vector of gene set names</p>
</td></tr>
<tr><td><code id="getModuleMembers_+3A_mset">mset</code></td>
<td>
<p>optional, a gene set collection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the selected gene sets from a collection.
</p>


<h3>Value</h3>

<p>A list of gene sets
</p>


<h3>Examples</h3>

<pre><code class='language-R'># show the interferon related modules
getModuleMembers(c("LI.M127", "LI.M158.0", "LI.M158.0"))
getModuleMembers("LI.M127")
</code></pre>

<hr>
<h2 id='ggEvidencePlot'>Create an evidence plot for a module (ggplot2 version)</h2><span id='topic+ggEvidencePlot'></span>

<h3>Description</h3>

<p>Create an evidence plot for a module (ggplot2 version)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggEvidencePlot(
  l,
  m,
  mset = NULL,
  filter = FALSE,
  unique = TRUE,
  gene.labels = NULL,
  gene.colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggEvidencePlot_+3A_l">l</code></td>
<td>
<p>sorted list of HGNC gene identifiers</p>
</td></tr>
<tr><td><code id="ggEvidencePlot_+3A_m">m</code></td>
<td>
<p>character vector of modules for which the plot should be created</p>
</td></tr>
<tr><td><code id="ggEvidencePlot_+3A_mset">mset</code></td>
<td>
<p>Which module set to use (see tmodUtest for details)</p>
</td></tr>
<tr><td><code id="ggEvidencePlot_+3A_filter">filter</code></td>
<td>
<p>if TRUE, genes not defined in the module set will be removed</p>
</td></tr>
<tr><td><code id="ggEvidencePlot_+3A_unique">unique</code></td>
<td>
<p>if TRUE, duplicates will be removed</p>
</td></tr>
<tr><td><code id="ggEvidencePlot_+3A_gene.labels">gene.labels</code></td>
<td>
<p>if TRUE, gene names are shown; alternatively, a named character vector with gene labels to be shown, or NULL (default) for no labels (option evaluated only if rug is plotted)</p>
</td></tr>
<tr><td><code id="ggEvidencePlot_+3A_gene.colors">gene.colors</code></td>
<td>
<p>NULL (default) or a character vectors indicating the color for each gene. Either a named vector or a vector with the same order of genes as 'l'.</p>
</td></tr>
</table>

<hr>
<h2 id='ggPanelplot'>Create a tmod panel plot using ggplot</h2><span id='topic+ggPanelplot'></span>

<h3>Description</h3>

<p>Create a tmod panel plot using ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggPanelplot(
  res,
  sgenes = NULL,
  auc_thr = 0.5,
  q_thr = 0.05,
  filter_row_q = 0.01,
  filter_row_auc = 0.65,
  q_cutoff = 1e-12,
  cluster = TRUE,
  id_order = NULL,
  effect_size = "auto",
  colors = c("red", "grey", "blue"),
  label_angle = 45,
  add_ids = TRUE,
  mset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggPanelplot_+3A_res">res</code></td>
<td>
<p>a list with tmod results (each element of the list is a data
frame returned by a tmod test function)</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_sgenes">sgenes</code></td>
<td>
<p>a list with summaries of significantly DE genes by gene set.
Each a element of the list is a matrix returned by tmodDecideTests. If
NULL, the bars on the plot will be monochromatic.</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_auc_thr">auc_thr</code></td>
<td>
<p>gene sets enrichments with AUC (or other effect size) below 'auc_thr' will not be shown</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_q_thr">q_thr</code></td>
<td>
<p>gene sets enrichments with q (adjusted P value) above 'q_thr' will not be shown</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_filter_row_q">filter_row_q</code></td>
<td>
<p>Gene sets will only be shown if at least in one
contrast q is smaller than 'filter_row_q'</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_filter_row_auc">filter_row_auc</code></td>
<td>
<p>Gene sets will only be shown if at least in one
contrast AUC (or other effect size if specified) is larger than 'filter_row_auc'</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_q_cutoff">q_cutoff</code></td>
<td>
<p>Any q value below 'q_cutoff' will be considered equal to
'q_cutoff'</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_cluster">cluster</code></td>
<td>
<p>whether to cluster the IDs by similarity</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_id_order">id_order</code></td>
<td>
<p>character vector specifying the order of IDs to be
shown. This needs not to contain all IDs shown, but whatever IDs are in this
vector, they will be shown on top in the given order.</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_effect_size">effect_size</code></td>
<td>
<p>name of the column which contains the effect sizes;
by default, the name of this column is taken from the &quot;effect_size&quot;
attribute of the first result table.</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_colors">colors</code></td>
<td>
<p>character vector with at least 1 (when sgenes is NULL) or 3
(when sgenes is not NULL) elements</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_label_angle">label_angle</code></td>
<td>
<p>The angle at which column labels are shown</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_add_ids">add_ids</code></td>
<td>
<p>add IDs of gene sets to their titles on the plot</p>
</td></tr>
<tr><td><code id="ggPanelplot_+3A_mset">mset</code></td>
<td>
<p>an object of the type 'tmodGS'. If the option 'cluster' is
TRUE, the mset object is used to cluster the gene sets. By default, the
built-in transcription modules are used. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Panel plot is a kind of a heatmap. This is the most compact way of
representing the results of several gene set enrichment analyses. Each row of a
panel plot shows the result for one gene set, and each column shows
corresponds to one analysis. For example, if one tests gene set enrichment
for a number of different contrasts, then each contrast will be represented
in a separate column.
</p>
<p>Each cell of a panel plot shows both the effect size and the p-value.
The p-value is encoded as transparency: the enrichments with a lower
p-value have stronger colors. The size of the bar corresponds to the effect
size, however it is defined. For example, in case of the tmodCERNOtest,
tmodZtest or tmodUtest it is the area under curve, AUC.
</p>
<p>In addition, the bars may also encode information about the number of
up- or down-regulated genes. For this, an object must be created using the
function tmodDecideTests. This object provides  information about which
genes in a particular gene set are regulated in which direction.
</p>
<p>The order of the gene sets displayed is, by default, determined by
clustering the gene sets based on their overlaps. For this to work,
ggPanelplot must know about what genes are contained in which gene sets.
This is provided by the parameter 'mset'. By default (when mset is NULL)
this is the built-in list of gene sets. If, however, the results of gene
set enrichment come from a different set of gene sets, you need to specify
it with the mset parameter. See Examples.
</p>


<h3>Value</h3>

<p>The object returned is a ggplot2 object which can be further
modified the usual way.
</p>


<h3>See Also</h3>

<p>[tmodDecideTests()], [tmodPanelPlot()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## prepare a set of results
data(Egambia)
genes &lt;- Egambia$GENE_SYMBOL
exprs &lt;- Egambia[ , -1:-4 ]
group &lt;- gsub("\\..*", "", colnames(exprs))
## test differential expression using limma
design &lt;- cbind(Intercept=rep(1, 30), TB=rep(c(0,1), each= 15))
## Not run: 
library(limma)
fit &lt;- eBayes( lmFit(Egambia[,-c(1:3)], design))
tt &lt;- topTable(fit, coef=2, number=Inf, genelist=Egambia[,1:3] )
res &lt;- tmodCERNOtest(tt$GENE_SYMBOL)
## show the results using a panel plot
ggPanelplot(list(limma=res))
## add information about the significant genes
sgenes &lt;- tmodDecideTests(tt$GENE_SYMBOL, lfc=tt$logFC, pval=tt$adj.P.Val)
names(sgenes) &lt;- "limma"
ggPanelplot(list(limma=res), sgenes=sgenes)
## we will now compare the results of enrichments for different types of
## differential expression tests on the data
res_utest &lt;- apply(exprs, 1, function(x) wilcox.test(x ~ group)$p.value)
res_ttest &lt;- apply(exprs, 1, function(x) t.test(x ~ group)$p.value)
## Calculate the gene set enrichment analysis results for each of the
## different types of tests
res_tmod &lt;- list()
res_tmod$limma &lt;- res
res_tmod$utest &lt;- tmodCERNOtest(genes[order(res_utest)])
res_tmod$ttest &lt;- tmodCERNOtest(genes[order(res_ttest)])
ggPanelplot(res_tmod)
## Using the `mset` parameter
## First, we generate results using a different set of gene sets
data(cell_signatures)
res_cs &lt;- tmodCERNOtest(tt$GENE_SYMBOL, mset=cell_signatures)
## the following will triger a warning that no clustering is possible
## because ggPanelplot doesn't have the information about the gene set
## contents
ggPanelplot(list(res=res_cs))
## if we use the mset parameter, clustering is available
ggPanelplot(list(res=res_cs), mset=cell_signatures)

## End(Not run)
</code></pre>

<hr>
<h2 id='hgEnrichmentPlot'>Create a visualisation of enrichment</h2><span id='topic+hgEnrichmentPlot'></span>

<h3>Description</h3>

<p>Create a visualisation of enrichment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgEnrichmentPlot(fg, bg, m, mset = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hgEnrichmentPlot_+3A_fg">fg</code></td>
<td>
<p>the foreground set of genes</p>
</td></tr>
<tr><td><code id="hgEnrichmentPlot_+3A_bg">bg</code></td>
<td>
<p>the background set of genes (gene universe)</p>
</td></tr>
<tr><td><code id="hgEnrichmentPlot_+3A_m">m</code></td>
<td>
<p>gene set for which the plot should be created</p>
</td></tr>
<tr><td><code id="hgEnrichmentPlot_+3A_mset">mset</code></td>
<td>
<p>Which module set to use (see tmodUtest for details)</p>
</td></tr>
<tr><td><code id="hgEnrichmentPlot_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the plotting function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions creates a barplot visualizing the enrichment of a
module in the foreground (fg) set as compared to the background (bg) set.
It is the counterpart
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tmod-package">tmod-package</a></code>, [evidencePlot()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
data(tmod)
bg &lt;- tmod$gv
fg &lt;- getGenes("LI.M127", as.list=TRUE)[[1]]
fg &lt;- sample(c(fg, bg[1:100]))
hgEnrichmentPlot(fg, bg, "LI.M127")
</code></pre>

<hr>
<h2 id='makeTmodFromDataFrame'>Convert a data frame to a tmod object</h2><span id='topic+makeTmodFromDataFrame'></span>

<h3>Description</h3>

<p>Convert a data frame to a tmod object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTmodFromDataFrame(
  df,
  feature_col = 1,
  module_col = 2,
  title_col = NULL,
  extra_module_cols = NULL,
  extra_gene_cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTmodFromDataFrame_+3A_df">df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="makeTmodFromDataFrame_+3A_feature_col">feature_col</code></td>
<td>
<p>Which column contains the feature (gene) IDs</p>
</td></tr>
<tr><td><code id="makeTmodFromDataFrame_+3A_module_col">module_col</code></td>
<td>
<p>Which column contains the module (gene set) IDs</p>
</td></tr>
<tr><td><code id="makeTmodFromDataFrame_+3A_title_col">title_col</code></td>
<td>
<p>Description of the modules (if NULL, the description will
be taken from the module_col)</p>
</td></tr>
<tr><td><code id="makeTmodFromDataFrame_+3A_extra_module_cols">extra_module_cols</code></td>
<td>
<p>Additional columns to include in the module data frame</p>
</td></tr>
<tr><td><code id="makeTmodFromDataFrame_+3A_extra_gene_cols">extra_gene_cols</code></td>
<td>
<p>Additional gene columns to include in the genes data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'makeTmodFromFeatureDataFrame' converts mapping information from features (genes) to modules (gene
sets). The data frame has a row for each feature-module pair.
</p>
<p>'makeTmodFromModuleDataFrame' converts mapping information from features
(genes) to modules (gene sets). The data frame has a row for each module,
and all gene IDs corresponding to a module are stored as a comma separated string, e.g.
</p>
<p>Vice versa, 'tmod2DataFrame' converts a tmod object to a data frame.
</p>


<h3>Value</h3>

<p>A tmod object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeTmodGS">makeTmodGS</a></code>, <code><a href="#topic+makeTmodGS">makeTmodGS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
gene_id=LETTERS[1:10],
geneset_id=rep(letters[1:2], each=5),
geneset_description=rep(paste0("Gene set ", letters[1:2]), each=5))
res &lt;- makeTmodFromDataFrame(df, 
  feature_col="gene_id", 
  module_col="geneset_id",
  title_col="geneset_description")
</code></pre>

<hr>
<h2 id='makeTmodGS'>S3 class for tmod gene set collections</h2><span id='topic+makeTmodGS'></span><span id='topic+makeTmod'></span><span id='topic+as_tmodGS'></span><span id='topic+print.tmodGS'></span><span id='topic+length.tmodGS'></span><span id='topic++5B.tmodGS'></span><span id='topic++5B.tmod'></span>

<h3>Description</h3>

<p>S3 class for tmod gene set collections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTmodGS(gs2gene, gs = NULL, weights = NULL, info = NULL)

makeTmod(modules, modules2genes, genes2modules = NULL, genes = NULL)

as_tmodGS(x, check_sanity = FALSE)

## S3 method for class 'tmodGS'
print(x, ...)

## S3 method for class 'tmodGS'
length(x)

## S3 method for class 'tmodGS'
x[i]

## S3 method for class 'tmod'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTmodGS_+3A_gs2gene">gs2gene</code>, <code id="makeTmodGS_+3A_modules2genes">modules2genes</code></td>
<td>
<p>A list with module IDs as names. Each member of the list is a character vector with IDs of genes contained in that module</p>
</td></tr>
<tr><td><code id="makeTmodGS_+3A_gs">gs</code>, <code id="makeTmodGS_+3A_modules">modules</code></td>
<td>
<p>[Optional] A data frame with at least columns ID and Title</p>
</td></tr>
<tr><td><code id="makeTmodGS_+3A_weights">weights</code></td>
<td>
<p>[Optional] a named numeric vector of weights for each gene set</p>
</td></tr>
<tr><td><code id="makeTmodGS_+3A_info">info</code></td>
<td>
<p>[Optional] a list containing meta-information about the gene set collection</p>
</td></tr>
<tr><td><code id="makeTmodGS_+3A_genes2modules">genes2modules</code>, <code id="makeTmodGS_+3A_genes">genes</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="makeTmodGS_+3A_x">x</code></td>
<td>
<p>a tmodGS or tmod object</p>
</td></tr>
<tr><td><code id="makeTmodGS_+3A_check_sanity">check_sanity</code></td>
<td>
<p>whether the tmodGS object should be tested for correctness</p>
</td></tr>
<tr><td><code id="makeTmodGS_+3A_...">...</code></td>
<td>
<p>further arguments passed to 'print()'</p>
</td></tr>
<tr><td><code id="makeTmodGS_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract or replace</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class tmod contains the gene set annotations ('tmod$gs'), 
a character vector of gene identifiers ('tmod$gv')
and a mapping between gene sets and gene identifiers ('tmod$gs2gv').
Optionally, a vector of numeric weights of the same length as 'gs2gv' may
be provided ('tmod$weights').
</p>
<p>Furthermore, it may contain additional information about the gene set
('tmod$info').
</p>
<p>'tmod$gs' is a data frame which must contain the column &quot;ID&quot;. Additional
optional columns 'Title' and 'Description' are recognized by some
functions. Any further columns may contain additional information on the
gene sets. The number of rows of that data frame is equal to the number
of gene sets in a gene set collection.
</p>
<p>Each element of the tmod$g2m list corresponds to the respective row of
the 'tmod$gs' data frame. Each element is an integer vector containing
the positions of the gene identifiers in the 'tmod$gv' character vector.
</p>
<p>Objects of class tmodGS should be constructed 
by calling the function makeTmodGS(). This function check the validity and
consistency of the provided objects.
</p>
<p>The makeTmod function remains for compatibility with previous versions
of the package. It produces the objects of the new class tmodGS,
however.
</p>
<p>See the package vignette for more on constructing custom module sets.
</p>


<h3>See Also</h3>

<p>tmod-data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A minimal example
gs &lt;- data.frame(ID=letters[1:3], Title=LETTERS[1:3])
gs2gv &lt;- list(a=c("g1", "g2"), b=c("g3", "g4"), c=c("g1", "g2", "g4"))
mymset &lt;- makeTmodGS(gs2gene=gs2gv, gs=gs)
str(mymset)
</code></pre>

<hr>
<h2 id='modCorPlot'>Plot a correlation heatmap for modules</h2><span id='topic+modCorPlot'></span>

<h3>Description</h3>

<p>Plot a correlation heatmap for modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modCorPlot(
  modules,
  mset = NULL,
  heatmap_func = pheatmap,
  labels = NULL,
  stat = "jaccard",
  upper.cutoff = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modCorPlot_+3A_modules">modules</code></td>
<td>
<p>either a character vector with module IDs from mset, or a list which
contains the module members</p>
</td></tr>
<tr><td><code id="modCorPlot_+3A_mset">mset</code></td>
<td>
<p>Which module set to use. Either a character vector (&quot;LI&quot;, &quot;DC&quot; or &quot;all&quot;, default: all) or an object of class tmod (see &quot;Custom module definitions&quot; below)</p>
</td></tr>
<tr><td><code id="modCorPlot_+3A_heatmap_func">heatmap_func</code></td>
<td>
<p>function drawing the heatmap</p>
</td></tr>
<tr><td><code id="modCorPlot_+3A_labels">labels</code></td>
<td>
<p>Labels for the modules (if NULL, labels will be retrieved from 'mset')</p>
</td></tr>
<tr><td><code id="modCorPlot_+3A_stat">stat</code></td>
<td>
<p>Type of statistics to return. 
&quot;jaccard&quot;: Jaccard index (default);
&quot;number&quot;: number of common genes;
&quot;soerensen&quot;: Soerensen-Dice coefficient;
&quot;overlap&quot;: Szymkiewicz-Simpson coefficient.</p>
</td></tr>
<tr><td><code id="modCorPlot_+3A_upper.cutoff">upper.cutoff</code></td>
<td>
<p>Specify upper cutoff for the color palette</p>
</td></tr>
<tr><td><code id="modCorPlot_+3A_...">...</code></td>
<td>
<p>Any further parameters are passed to the heatmap function (by
default, [pheatmap()].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the return value of heatmap_func (by default, a pheatmap object).
</p>

<hr>
<h2 id='modcors'>Module correlation</h2><span id='topic+modcors'></span>

<h3>Description</h3>

<p>Calculate the correlation between modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modcors(x, g, mset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modcors_+3A_x">x</code></td>
<td>
<p>a data set, with variables (e.g. genes) in rows and samples in columns</p>
</td></tr>
<tr><td><code id="modcors_+3A_g">g</code></td>
<td>
<p>a vector of variable idenitifiers which correspond to the definition of modules</p>
</td></tr>
<tr><td><code id="modcors_+3A_mset">mset</code></td>
<td>
<p>a module set</p>
</td></tr>
<tr><td><code id="modcors_+3A_...">...</code></td>
<td>
<p>any further parameters will be passed to the cor() function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation between modules are defined as 
correlation coefficient between the modules eigengenes.
These are based on a particular gene expression data set.
</p>
<p>This function is a simple wrapper combining eigengene() and cor().
</p>


<h3>Value</h3>

<p>a matrix of module correlation coefficients
</p>

<hr>
<h2 id='modGroups'>Find group of modules</h2><span id='topic+modGroups'></span>

<h3>Description</h3>

<p>Find group of modules  based on shared genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modGroups(modules, mset = NULL, min.overlap = 2, stat = "number")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modGroups_+3A_modules">modules</code></td>
<td>
<p>Either a list of modules or character vector.</p>
</td></tr>
<tr><td><code id="modGroups_+3A_mset">mset</code></td>
<td>
<p>Which module set to use. Either a character vector (&quot;LI&quot;, &quot;DC&quot; or &quot;all&quot;, default: all) or an object of class tmod (see &quot;Custom module definitions&quot; below)</p>
</td></tr>
<tr><td><code id="modGroups_+3A_min.overlap">min.overlap</code></td>
<td>
<p>Minimum number of overlapping items if stat ==
number, minimum jaccard index if stat == jaccard etc.</p>
</td></tr>
<tr><td><code id="modGroups_+3A_stat">stat</code></td>
<td>
<p>Type of statistics to return. 
&quot;jaccard&quot;: Jaccard index (default);
&quot;number&quot;: number of common genes;
&quot;soerensen&quot;: Soerensen-Dice coefficient;
&quot;overlap&quot;: Szymkiewicz-Simpson coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Split the modules into groups based on the overlapping items.
</p>
<p>The first argument, modules, is either a character vector of module identifiers from 'mset'
(NULL mset indicates the default mset of tmod) or a list. If it is a
list, then each element is assumed to be a character vector with module
IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mymods &lt;- list(A=c(1, 2, 3), B=c(2, 3, 4, 5), C=c(5, 6, 7))
modGroups(mymods)
</code></pre>

<hr>
<h2 id='modjaccard'>Jaccard index for modules</h2><span id='topic+modjaccard'></span>

<h3>Description</h3>

<p>Jaccard index for modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modjaccard(mset = NULL, g = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modjaccard_+3A_mset">mset</code></td>
<td>
<p>set of modules for which to calculate the Jaccard index. If
NULL, the default tmod module set will be used.</p>
</td></tr>
<tr><td><code id="modjaccard_+3A_g">g</code></td>
<td>
<p>a list of genes. If NULL, the list of genes from the mset will be
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of modules in mset, calculate the Jacard index between
these modules.
</p>


<h3>Value</h3>

<p>matrix with Jaccard index for each pair of modules in mset
</p>

<hr>
<h2 id='modmetabo'>Modules for metabolic profiling</h2><span id='topic+modmetabo'></span><span id='topic+tbmprof'></span>

<h3>Description</h3>

<p>Feature and data sets for metabolic profiling
</p>


<h3>Details</h3>

<p>The module set &quot;modmetabo&quot; can be used with tmod to analyse metabolic profiling
data. The clusters defined in this set are based on hierarchical clustering
of metabolic compounds from human serum and have been published in a paper on 
metabolic profiling in tuberculosis by
Weiner et al. (2012).
</p>
<p>For an example analysis, &quot;tbmprof&quot; is a data set containing metabolic profiles
of serum isolated from tuberculosis (TB) patients and healthy individuals. The tbmprof is
a data frame containing observations in rows and metabolite id's
(corresponding to the id's in the modmetabo object). See examples below.
</p>


<h3>References</h3>

<p>Weiner 3rd J, Parida SK, Maertzdorf J, Black GF, Repsilber D, Telaar A,
Mohney RP, Arndt-Sullivan C, Ganoza CA, Fae KC, Walzl G. Biomarkers of
inflammation, immunosuppression and stress are revealed by metabolomic
profiling of tuberculosis patients. PloS one. 2012 Jul 23;7(7):e40221.
</p>


<h3>See Also</h3>

<p>tmod-data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(modmetabo)  # module definitions
data(tbmprof)    # example data set
ids &lt;- rownames(tbmprof)
tb  &lt;- factor(gsub("\\..*", "", ids))

## use Wilcoxon test to calculate significant differences
wcx &lt;- apply(tbmprof, 2, function(x) wilcox.test(x ~ tb)$p.value)
wcx &lt;- sort(wcx)
tmodCERNOtest(names(wcx), mset=modmetabo)
</code></pre>

<hr>
<h2 id='modOverlaps'>Calculate overlaps of the modules</h2><span id='topic+modOverlaps'></span>

<h3>Description</h3>

<p>Calculate overlaps of the modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modOverlaps(modules = NULL, mset = NULL, stat = "jaccard")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modOverlaps_+3A_modules">modules</code></td>
<td>
<p>either a character vector with module IDs from mset, or a list which
contains the module members</p>
</td></tr>
<tr><td><code id="modOverlaps_+3A_mset">mset</code></td>
<td>
<p>Which module set to use. Either a character vector (&quot;LI&quot;, &quot;DC&quot; or &quot;all&quot;, default: all) or an object of class tmod (see &quot;Custom module definitions&quot; below)</p>
</td></tr>
<tr><td><code id="modOverlaps_+3A_stat">stat</code></td>
<td>
<p>Type of statistics to return. 
&quot;jaccard&quot;: Jaccard index (default);
&quot;number&quot;: number of common genes;
&quot;soerensen&quot;: Soerensen-Dice coefficient;
&quot;overlap&quot;: Szymkiewicz-Simpson coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a set of modules (aka gene sets) determine the similarity between
these. You can run modOverlaps either on a character vector of module
IDs or on a list. In the first case, the module elements are taken from
'mset', and if that is NULL, from the default tmod module set. 
</p>
<p>Alternatively, you can provide a list in which each element is a
character vector. In this case, the names of the list are the module IDs,
and the character vectors contain the associated elements.
</p>
<p>The different statistics available are:
* &quot;number&quot;: total number of common genes (size of the overlap)
* &quot;jaccard&quot;: Jaccard index, i.e. <code class="reqn">\frac{|A \cap B|}{|A \cup B|}</code>
(number of common elements divided by the total number of unique elements);
* &quot;soerensen&quot;: Soerensen-Dice coefficient, defined as <code class="reqn">\frac{2 \cdot |A \cap B|}{|A| + |B|}</code> – number of common genes in relation to the total number of elements (divided by two, such that the maximum is 1)
(number of common elements divided by the average size of both gene sets)
* &quot;overlap&quot;: Szymkiewicz-Simpson coefficient, defined as <code class="reqn">\frac{|A \cap B|}{\min(|A|, |B|)}</code> – this is the number of common genes scaled by the size of the smaller of the two gene sets
(number of common elements divided by the size of the smaller gene set)
</p>

<hr>
<h2 id='pcaplot'>Plot a PCA object returned by prcomp</h2><span id='topic+pcaplot'></span>

<h3>Description</h3>

<p>Plot a PCA object returned by prcomp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaplot(
  pca,
  components = 1:2,
  group = NULL,
  col = NULL,
  pch = 19,
  cex = 2,
  legend = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcaplot_+3A_pca">pca</code></td>
<td>
<p>PCA object returned by prcomp</p>
</td></tr>
<tr><td><code id="pcaplot_+3A_components">components</code></td>
<td>
<p>a vector of length two indicating the components to plot</p>
</td></tr>
<tr><td><code id="pcaplot_+3A_group">group</code></td>
<td>
<p>a factor determining shapes of the points to show (unless
overriden by pch=...)</p>
</td></tr>
<tr><td><code id="pcaplot_+3A_col">col</code></td>
<td>
<p>Color for plotting (default: internal palette)</p>
</td></tr>
<tr><td><code id="pcaplot_+3A_pch">pch</code></td>
<td>
<p>Type of character to plot (default: 19)</p>
</td></tr>
<tr><td><code id="pcaplot_+3A_cex">cex</code></td>
<td>
<p>size of the symbols used for plotting</p>
</td></tr>
<tr><td><code id="pcaplot_+3A_legend">legend</code></td>
<td>
<p>draw a legend? If legend is a position (eg. &quot;topright&quot;), then a legend
is drawn. If NULL or if the group parameter is NULL, then not.</p>
</td></tr>
<tr><td><code id="pcaplot_+3A_...">...</code></td>
<td>
<p>any further parameters will be passed to the plot() function
(e.g. col, cex, ...)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simplistic function. A much better way is to use the pca2d
function from the pca3d package.
</p>


<h3>Value</h3>

<p>If group is NULL, then NULL; else a data frame containing
colors and shapes matching each group
</p>

<hr>
<h2 id='pvalEffectPlot'>Create an effect size / p-value plot</h2><span id='topic+pvalEffectPlot'></span>

<h3>Description</h3>

<p>Create a heatmap-like plot showing information about both effect size
and p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvalEffectPlot(
  e,
  p,
  pval.thr = 0.01,
  pval.cutoff = 1e-06,
  row.labels = NULL,
  col.labels = NULL,
  plot.func = NULL,
  grid = "at",
  grid.color = "#33333333",
  plot.cex = 1,
  text.cex = 1,
  col.labels.style = "top",
  symmetrical = FALSE,
  legend.style = "auto",
  min.e = NULL,
  max.e = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pvalEffectPlot_+3A_e">e</code></td>
<td>
<p>matrix with effect sizes</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_p">p</code></td>
<td>
<p>matrix with probabilities</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_pval.thr">pval.thr</code></td>
<td>
<p>The p-value must be this or lower in order for a test result to be visualized</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_pval.cutoff">pval.cutoff</code></td>
<td>
<p>On visual scale, all p-values below pval.cutoff will be replaced by pval.cutoff</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_row.labels">row.labels</code></td>
<td>
<p>Labels for the modules. This must be a named vector, with module IDs as vector names. If NULL, module titles from
the analyses results will be used.</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_col.labels">col.labels</code></td>
<td>
<p>Labels for the columns. If NULL, names of the elements
of the list x will be used.</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_plot.func">plot.func</code></td>
<td>
<p>Optionally, a function to be used to draw the dots. See &quot;Details&quot;</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_grid">grid</code></td>
<td>
<p>Style of a light-grey grid to be plotted; can be &quot;none&quot;, &quot;at&quot; and &quot;between&quot;</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_grid.color">grid.color</code></td>
<td>
<p>Color of the grid to be plotted (default: light grey)</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_plot.cex">plot.cex</code></td>
<td>
<p>a numerical value giving the amount by which the plot
symbols will be maginfied</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_text.cex">text.cex</code></td>
<td>
<p>a numerical value giving the amount by which the plot
text will be magnified, or a vector containing three cex values for row labels, column labels and legend, respectively</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_col.labels.style">col.labels.style</code></td>
<td>
<p>Style of column names: &quot;top&quot; (default), &quot;bottom&quot;, &quot;both&quot;, &quot;none&quot;</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_symmetrical">symmetrical</code></td>
<td>
<p>effect sizes are distributed symmetrically around 0 (default: FALSE)</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_legend.style">legend.style</code></td>
<td>
<p>Style of the legend: &quot;auto&quot; &ndash; automatic; &quot;broad&quot;:
pval legend side by side with effect size legend; &quot;tall&quot;: effect size
legend above pval legend; &quot;none&quot; &ndash; no legend.</p>
</td></tr>
<tr><td><code id="pvalEffectPlot_+3A_min.e">min.e</code>, <code id="pvalEffectPlot_+3A_max.e">max.e</code></td>
<td>
<p>scale limits for the effect size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>pvalEffectPlot shows a heatmap-like plot. Each row corresponds to one
series of tests (e.g. one module), and each column corresponds to the time points or conditions for which
a given analysis was run. Each significant result is shown as
a red dot. Size of the dot corresponds to the effect size (or any
arbitrary value), and intensity of the color corresponds to the log10 of
p-value.
</p>
<p>Just like a heatmap corresponds to a single numeric matrix, the pvalue /
effect plot corresponds to two matrices: one with the effect size, and
another one with the p-values. Each cell in the matrix corresponds to the
results of a single statistical test.
</p>
<p>For example, a number of genes or transcriptional modules might be tested
for differential expression or enrichment, respectively, in several conditions. 
</p>
<p>By default, each test outcome is represented by a dot of varying size
and color. Alternatively, a function may be specified with the parameter
'plot.func'. It will be called for each test result to be drawn. The plot.func function must take the following arguments:
</p>

<ul>
<li><p>row, coleither row / column number or the id of the row / column to plot; NULL if drawing legend
</p>
</li>
<li><p>x, yuser coordinates of the result to visualize
</p>
</li>
<li><p>w, hwidth and height of the item to plot
</p>
</li>
<li><p>eEnrichment &ndash; a relative value between 0 and 1, where 0 is the minimum and 1 is the maximum enrichment found
</p>
</li>
<li><p>pP-value &ndash; an absolute value between 0 and 1
</p>
</li></ul>

<p>For the purposes of drawing a legend, the function must accept NULL
p-value or a NULL enrichment parameter.
</p>


<h3>Value</h3>

<p>Invisibly returns a NULL value.
</p>

<hr>
<h2 id='showGene'>A combined beeswarm / boxplot</h2><span id='topic+showGene'></span>

<h3>Description</h3>

<p>A combined beeswarm / boxplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showGene(
  data,
  group,
  main = "",
  pch = 19,
  xlab = "",
  ylab = "log2 expression",
  las = 2,
  pwcol = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showGene_+3A_data">data</code></td>
<td>
<p>a vector of numeric values to be plotted</p>
</td></tr>
<tr><td><code id="showGene_+3A_group">group</code></td>
<td>
<p>factor describing the groups</p>
</td></tr>
<tr><td><code id="showGene_+3A_main">main</code></td>
<td>
<p>title of the plot</p>
</td></tr>
<tr><td><code id="showGene_+3A_pch">pch</code></td>
<td>
<p>character to plot the points</p>
</td></tr>
<tr><td><code id="showGene_+3A_xlab">xlab</code>, <code id="showGene_+3A_ylab">ylab</code></td>
<td>
<p>x and y axis labels</p>
</td></tr>
<tr><td><code id="showGene_+3A_las">las</code></td>
<td>
<p>see par()</p>
</td></tr>
<tr><td><code id="showGene_+3A_pwcol">pwcol</code></td>
<td>
<p>colors of the points (see beeswarm)</p>
</td></tr>
<tr><td><code id="showGene_+3A_...">...</code></td>
<td>
<p>any additional parameters to be passed to the beeswarm command</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a simple wrapper around the beeswarm() and boxplot()
commands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Egambia)
E &lt;- as.matrix(Egambia[,-c(1:3)])
showGene(E["20799",], rep(c("CTRL", "TB"), each=15))
</code></pre>

<hr>
<h2 id='simplePie'>Simple Pie Chart</h2><span id='topic+simplePie'></span><span id='topic+simpleRug'></span><span id='topic+simpleBoxpie'></span>

<h3>Description</h3>

<p>The simplePie function draws a simple pie chart at specified coordinates with
specified width, height and color. The simpleRug function draws a
corresponding rug plot, while simpleBoxpie creates a &quot;rectangular pie
chart&quot; that is considered to be better legible than the regular pie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplePie(x, y, w, h, v, col, res = 100, border = NA)

simpleRug(x, y, w, h, v, col, border = NULL)

simpleBoxpie(x, y, w, h, v, col, border = NA, grid = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplePie_+3A_x">x</code>, <code id="simplePie_+3A_y">y</code></td>
<td>
<p>coordinates at which to draw the plot</p>
</td></tr>
<tr><td><code id="simplePie_+3A_w">w</code>, <code id="simplePie_+3A_h">h</code></td>
<td>
<p>width and height of the plot</p>
</td></tr>
<tr><td><code id="simplePie_+3A_v">v</code></td>
<td>
<p>sizes of the slices</p>
</td></tr>
<tr><td><code id="simplePie_+3A_col">col</code></td>
<td>
<p>colors of the slices</p>
</td></tr>
<tr><td><code id="simplePie_+3A_res">res</code></td>
<td>
<p>resolution (number of polygon edges in a full circle)</p>
</td></tr>
<tr><td><code id="simplePie_+3A_border">border</code></td>
<td>
<p>color of the border. Use NA (default) or NULL for no border</p>
</td></tr>
<tr><td><code id="simplePie_+3A_grid">grid</code></td>
<td>
<p>boxpie only: the grid over which the areas are distributed.
Should be roughly equal to the number of areas shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>simplePie() draws a pie chart with width w and height h at coordinates
(x,y). The size of the slices is taken from the numeric vector v, and
their color from the character vector col.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># demonstration of the three widgets
plot.new()
par(usr=c(0,3,0,3))
x &lt;- c(7, 5, 11)
col &lt;- tmodPal()
b &lt;- "black"
simpleRug(0.5, 1.5, 0.8, 0.8, v=x, col=col, border=b)
simplePie(1.5, 1.5, 0.8, 0.8, v=x, col=col, border=b)
simpleBoxpie(2.5, 1.5, 0.8, 0.8, v=x, col=col, border=b)

# using pie as plotting symbol
plot(NULL, xlim=1:2, ylim=1:2, xlab="", ylab="")
col &lt;- c("#cc000099", "#0000cc99")
for(i in 1:125) { 
  x &lt;- runif(1) + 1 
  y &lt;- runif(1) + 1
  simplePie( x, y, 0.05, 0.05, c(x,y), col)
}

# square filled with box pies
n &lt;- 10 
w &lt;- h &lt;- 1/(n+1)
plot.new()
for(i in 1:n) for(j in 1:n) 
 simpleBoxpie(1/n*(i-1/2), 1/n*(j-1/2), w, h, 
 v=runif(3), col=tmodPal())
</code></pre>

<hr>
<h2 id='tmod_ids'>Query and set IDs of gene sets in a tmodGS object</h2><span id='topic+tmod_ids'></span><span id='topic+tmod_ids+3C-'></span><span id='topic+tmod_titles'></span><span id='topic+tmod_titles+3C-'></span>

<h3>Description</h3>

<p>Query and set IDs (tmod_id) or Titles (tmod_title) of gene sets in a tmodGS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmod_ids(x)

tmod_ids(x) &lt;- value

tmod_titles(x)

tmod_titles(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmod_ids_+3A_x">x</code></td>
<td>
<p>an object of class tmodGS</p>
</td></tr>
<tr><td><code id="tmod_ids_+3A_value">value</code></td>
<td>
<p>a character vector of unique IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns character vector corresponding to x$gs$ID
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tmod)
mset &lt;- tmod[ c("LI.M37.0", "LI.M75", "LI.M3") ]
tmod_ids(mset)
tmod_ids(mset) &lt;- c("em", "pstrem", "bzdrem")
tmod_titles(mset) &lt;- c("foo", "bar", "baz")
mset$gs
</code></pre>

<hr>
<h2 id='tmod-data'>Default gene expression module data</h2><span id='topic+tmod-data'></span><span id='topic+tmod'></span>

<h3>Description</h3>

<p>Gene expression module data from Chaussabel et al. (2008) and Li et al. (2014)
</p>


<h3>Details</h3>

<p>The tmod package includes one data set of class tmod which can be loaded with
data(tmod). This data set is derived from two studies (see package
vignette for details). By default, enrichment analysis with tmod uses
this data set; however, it is not loaded into user workspace by default.
</p>


<h3>References</h3>

<p>Chaussabel, Damien, Charles Quinn, Jing Shen, Pinakeen Patel, Casey Glaser, Nicole Baldwin, Dorothee Stichweh, et al. 2008. 
&quot;A Modular Analysis Framework for Blood Genomics Studies: Application to Systemic Lupus Erythematosus.&quot; Immunity 29(1):150-64.
</p>
<p>Li, Shuzhao, Nadine Rouphael, Sai Duraisingham, Sandra Romero-Steiner, Scott Presnell, Carl Davis, Daniel
S Schmidt, et al. 2014. &quot;Molecular Signatures of Antibody Responses Derived from a Systems Biology Study
of Five Human Vaccines.&quot; Nature Immunology 15(2):195-204.
</p>


<h3>See Also</h3>

<p>tmod-class, modmetabo
</p>


<h3>Examples</h3>

<pre><code class='language-R'># list of first 10 modules
data(tmod)
tmod
tmod$MODULES[1:10, ]
tmod[1:10]
</code></pre>

<hr>
<h2 id='tmod2DataFrame'>Convert a tmod module set into a data frame</h2><span id='topic+tmod2DataFrame'></span>

<h3>Description</h3>

<p>Convert a tmod module set into a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmod2DataFrame(
  mset,
  rows = "modules",
  module_col = "module_id",
  feature_col = "feature_id",
  sep = ","
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmod2DataFrame_+3A_mset">mset</code></td>
<td>
<p>a tmod object (e.g. generated by makeTmod)</p>
</td></tr>
<tr><td><code id="tmod2DataFrame_+3A_rows">rows</code></td>
<td>
<p>if &quot;modules&quot;, then there will be a row corresponding to each
module (gene set); if &quot;features&quot;, then there will be a row corresponding to
each gene.</p>
</td></tr>
<tr><td><code id="tmod2DataFrame_+3A_module_col">module_col</code></td>
<td>
<p>Name of the column with module (gene set) IDs</p>
</td></tr>
<tr><td><code id="tmod2DataFrame_+3A_feature_col">feature_col</code></td>
<td>
<p>Name of the column with feature (gene) IDs</p>
</td></tr>
<tr><td><code id="tmod2DataFrame_+3A_sep">sep</code></td>
<td>
<p>separator used to collate module IDs (if rows==&quot;features&quot;) or feature IDs (if rows==&quot;modules&quot;)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+makeTmodGS">makeTmodGS</a></code>, <code><a href="#topic+makeTmod">makeTmod</a></code>
</p>

<hr>
<h2 id='tmod2tmodGS'>Convert the old tmod objects to the tmodGS objects</h2><span id='topic+tmod2tmodGS'></span>

<h3>Description</h3>

<p>Convert the old tmod objects to the tmodGS objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmod2tmodGS(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmod2tmodGS_+3A_x">x</code></td>
<td>
<p>an object of class tmod</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The old tmod representation was very inefficient. This function converts
the objects to a new representation which is both allowing faster
computations and more memory efficient.
</p>


<h3>Value</h3>

<p>Returns an object of class tmodGS.
</p>

<hr>
<h2 id='tmodAUC'>Calculate AUC</h2><span id='topic+tmodAUC'></span>

<h3>Description</h3>

<p>Calculate AUC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodAUC(
  l,
  ranks,
  modules = NULL,
  stat = "AUC",
  recalculate.ranks = TRUE,
  filter = FALSE,
  mset = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodAUC_+3A_l">l</code></td>
<td>
<p>List of gene names corresponding to rows from the ranks matrix</p>
</td></tr>
<tr><td><code id="tmodAUC_+3A_ranks">ranks</code></td>
<td>
<p>a matrix with ranks, where columns correspond to samples
and rows to genes from the l list</p>
</td></tr>
<tr><td><code id="tmodAUC_+3A_modules">modules</code></td>
<td>
<p>optional list of modules for which to make the test</p>
</td></tr>
<tr><td><code id="tmodAUC_+3A_stat">stat</code></td>
<td>
<p>Which statistics to generate. Default: AUC</p>
</td></tr>
<tr><td><code id="tmodAUC_+3A_recalculate.ranks">recalculate.ranks</code></td>
<td>
<p>Filtering and removing duplicates will also
remove ranks, so that they should be recalculated. Use FALSE if you don't
want this behavior. If unsure, stay with TRUE</p>
</td></tr>
<tr><td><code id="tmodAUC_+3A_filter">filter</code></td>
<td>
<p>Remove gene names which have no module assignments</p>
</td></tr>
<tr><td><code id="tmodAUC_+3A_mset">mset</code></td>
<td>
<p>Which module set to use. &quot;LI&quot;, &quot;DC&quot; or &quot;all&quot; (default: &quot;all&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tmodAUC calculates the AUC and U statistics. The main purpose of this
function is the use in randomization tests. While tmodCERNOtest and
tmodUtest both calculate, for each module, the enrichment in a single
sorted list of genes, tmodAUC takes any number of such sorted lists. Or,
actually, sortings &ndash; vectors with ranks of the genes in each replicate.
</p>
<p>Note that the input for this function
is different from tmodUtest and related functions: the ordering of l
and the matrix ranks does not matter, as long as the matrix ranks
contains the actual rankings. Each column in the ranks matrix is treated as
a separate sample.
</p>
<p>Also, the 'nodups' parameter which is available (and TRUE by default) for 
other tests cannot be used here. This means that the AUCs calculated here
might be slightly different from the AUCs calculated with default
parameters in tests such as the [tmodCERNOtest()]. Use 'nodups=FALSE'
with [tmodCERNOtest()] to obtain identical results as with 'tmodAUC'.
</p>


<h3>Value</h3>

<p>A matrix with the same number of columns as &quot;ranks&quot; and as many
rows as there were modules to be tested.
</p>


<h3>See Also</h3>

<p>tmod-package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tmod)
l &lt;- tmod_ids(tmod)
ranks &lt;- 1:length(l)
res &lt;- tmodAUC(l, ranks)
head(res)
</code></pre>

<hr>
<h2 id='tmodDecideTests'>Count the Up- or Down-regulated genes per module</h2><span id='topic+tmodDecideTests'></span>

<h3>Description</h3>

<p>For each module in a set, calculate the number of genes which are in
that module and which are significantly up- or down-regulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodDecideTests(
  g,
  lfc = NULL,
  pval = NULL,
  lfc.thr = 0.5,
  pval.thr = 0.05,
  labels = NULL,
  filter.unknown = FALSE,
  mset = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodDecideTests_+3A_g">g</code></td>
<td>
<p>a character vector with gene symbols</p>
</td></tr>
<tr><td><code id="tmodDecideTests_+3A_lfc">lfc</code></td>
<td>
<p>a numeric vector or a matrix with log fold changes</p>
</td></tr>
<tr><td><code id="tmodDecideTests_+3A_pval">pval</code></td>
<td>
<p>a numeric vector or a matrix with p-values. Must have the same dimensions as lfc</p>
</td></tr>
<tr><td><code id="tmodDecideTests_+3A_lfc.thr">lfc.thr</code></td>
<td>
<p>log fold change threshold</p>
</td></tr>
<tr><td><code id="tmodDecideTests_+3A_pval.thr">pval.thr</code></td>
<td>
<p>p-value threshold</p>
</td></tr>
<tr><td><code id="tmodDecideTests_+3A_labels">labels</code></td>
<td>
<p>Names of the comparisons. Either NULL or a character
vector of length equal to the number of columns in lfc and pval.</p>
</td></tr>
<tr><td><code id="tmodDecideTests_+3A_filter.unknown">filter.unknown</code></td>
<td>
<p>If TRUE, modules with no annotation will be omitted</p>
</td></tr>
<tr><td><code id="tmodDecideTests_+3A_mset">mset</code></td>
<td>
<p>Which module set to use. Either a character vector (&quot;LI&quot;, &quot;DC&quot; or &quot;all&quot;, default: LI) or a list (see &quot;Custom module definitions&quot; below)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to decide whether a module, as a whole, is up- or
down regulated. For each module, it calculates the number of genes which
are up-, down- or not regulated. 
A gene is considered to be up- regulated
if the associated p-value is smaller than pval.thr and the associated log
fold change is greater than lfc.thr.
A gene is considered to be down- regulated
if the associated p-value is smaller than pval.thr and the associated log
fold change is smaller than lfc.thr.
</p>
<p>Note that unlike decideTests from limma, tmodDecideTests does not correct
the p-values for multiple testing &ndash; therefore, the p-values should already
be corrected.
</p>


<h3>Value</h3>

<p>A list with as many elements as there were comparisons (columns in lfc and pval). Each element of the list is a data 
frame with the columns &quot;Down&quot;, &quot;Zero&quot; and &quot;Up&quot; giving the number of the
down-, not- and up-regulated genes respectively. Rows of the data frame
correspond to module IDs.
</p>


<h3>See Also</h3>

<p>tmodSummary, tmodPanelPlot, tmodDecideTestsLimma
</p>

<hr>
<h2 id='tmodImportMSigDB'>Import data from MSigDB</h2><span id='topic+tmodImportMSigDB'></span>

<h3>Description</h3>

<p>Import data from an MSigDB file in either XML or GMT format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodImportMSigDB(
  file = NULL,
  format = "xml",
  organism = "Homo sapiens",
  fields = c("STANDARD_NAME", "CATEGORY_CODE", "SUB_CATEGORY_CODE", "EXACT_SOURCE",
    "EXTERNAL_DETAILS_URL")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodImportMSigDB_+3A_file">file</code></td>
<td>
<p>The name of the file to parse</p>
</td></tr>
<tr><td><code id="tmodImportMSigDB_+3A_format">format</code></td>
<td>
<p>Format (either &quot;xml&quot; or &quot;gmt&quot;)</p>
</td></tr>
<tr><td><code id="tmodImportMSigDB_+3A_organism">organism</code></td>
<td>
<p>Select the organism to use. Use &quot;all&quot; for all organisms in the file (only for &quot;xml&quot; format; default: &quot;Homo sapiens&quot;)</p>
</td></tr>
<tr><td><code id="tmodImportMSigDB_+3A_fields">fields</code></td>
<td>
<p>Which fields to import to the MODULES data frame (only for &quot;xml&quot; format)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command parses a file from MSigDB. Both XML and the MSigDB-specific
&quot;GMT&quot; format are supported (however, the latter is discouraged, as it
contains less information).
</p>


<h3>Value</h3>

<p>A tmod object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## First, download the file "msigdb_v7.5.1.xml" 
## from http://www.broadinstitute.org/gsea/downloads.jsp
msig &lt;- tmodImportMSigDB("msigdb_v7.5.1.xml")

## End(Not run)
</code></pre>

<hr>
<h2 id='tmodLEA'>Leading Edge Analysis</h2><span id='topic+tmodLEA'></span>

<h3>Description</h3>

<p>For each module, return a list of genes on the leading edge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodLEA(l, modules, mset = "all", nodups = TRUE, filter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodLEA_+3A_l">l</code></td>
<td>
<p>list of genes</p>
</td></tr>
<tr><td><code id="tmodLEA_+3A_modules">modules</code></td>
<td>
<p>character vector of module IDs for which to run the LEA</p>
</td></tr>
<tr><td><code id="tmodLEA_+3A_mset">mset</code></td>
<td>
<p>Which module set to use. Either a character vector (&quot;LI&quot;, &quot;DC&quot; or &quot;all&quot;, default: LI) or an object of class tmod</p>
</td></tr>
<tr><td><code id="tmodLEA_+3A_nodups">nodups</code></td>
<td>
<p>Remove duplicate gene names in l and corresponding
rows from ranks</p>
</td></tr>
<tr><td><code id="tmodLEA_+3A_filter">filter</code></td>
<td>
<p>Remove gene names which have no module assignments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of ordered gene identifiers and a vector of module IDs,
for each module, return the genes which are on the up-slope of the
GSEA-style evidence plot. That is, return the genes that are driving the
enrichment.
</p>

<hr>
<h2 id='tmodLEASummary'>Summary stats of a leading edge analysis</h2><span id='topic+tmodLEASummary'></span>

<h3>Description</h3>

<p>Summary stats of a leading edge analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodLEASummary(lea, genes = FALSE, labels = NULL, mset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodLEASummary_+3A_lea">lea</code></td>
<td>
<p>result of 'tmodLEA'</p>
</td></tr>
<tr><td><code id="tmodLEASummary_+3A_genes">genes</code></td>
<td>
<p>if TRUE, the gene identifiers of the leading edge (joined by commas) will be appended.</p>
</td></tr>
<tr><td><code id="tmodLEASummary_+3A_labels">labels</code></td>
<td>
<p>labels to add to the result; if NULL, the labels will be
taken from 'mset'</p>
</td></tr>
<tr><td><code id="tmodLEASummary_+3A_mset">mset</code></td>
<td>
<p>Which module set to use. Either a character vector (&quot;LI&quot;, &quot;DC&quot; or &quot;all&quot;, default: all) or an object of class tmod (see &quot;Custom module definitions&quot; below)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with summary stats
</p>

<hr>
<h2 id='tmodLimmaDecideTests'>Up- and down-regulated genes in modules based on limma object</h2><span id='topic+tmodLimmaDecideTests'></span>

<h3>Description</h3>

<p>For each module in mset and for each coefficient in f$coefficients, this
function calculates the numbers of significantly up- and down-regulated genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodLimmaDecideTests(
  f,
  genes,
  lfc.thr = 0.5,
  pval.thr = 0.05,
  filter.unknown = FALSE,
  adjust.method = "BH",
  mset = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodLimmaDecideTests_+3A_f">f</code></td>
<td>
<p>result of linear model fit produced by limma functions lmFit and eBayes</p>
</td></tr>
<tr><td><code id="tmodLimmaDecideTests_+3A_genes">genes</code></td>
<td>
<p>Either the name of the column in f$genes which
contains the gene symbols corresponding to the gene set collection used, or
a character vector with gene symbols</p>
</td></tr>
<tr><td><code id="tmodLimmaDecideTests_+3A_lfc.thr">lfc.thr</code></td>
<td>
<p>log fold change threshold</p>
</td></tr>
<tr><td><code id="tmodLimmaDecideTests_+3A_pval.thr">pval.thr</code></td>
<td>
<p>p-value threshold</p>
</td></tr>
<tr><td><code id="tmodLimmaDecideTests_+3A_filter.unknown">filter.unknown</code></td>
<td>
<p>If TRUE, modules with no annotation will be omitted</p>
</td></tr>
<tr><td><code id="tmodLimmaDecideTests_+3A_adjust.method">adjust.method</code></td>
<td>
<p>method used to adjust the p-values for multiple testing. See p.adjust(). Default:BH.</p>
</td></tr>
<tr><td><code id="tmodLimmaDecideTests_+3A_mset">mset</code></td>
<td>
<p>Which module set to use (see tmodUtest for details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an f object returned by eBayes(), tmodLimmaDecideTests considers every
coefficient in this model (every column of f$coefficients). For each such
coefficient, tmodLimmaDecideTests calculates, for each module, the number
of genes which are up- or down-regulated.
</p>
<p>In short, tmodLimmaDecideTests is the equivalent of tmodDecideTests, but
for limma objects returned by eBayes().
</p>


<h3>Value</h3>

<p>A list with as many elements as there were coefficients in f. Each element of the list is a data 
frame with the columns &quot;Down&quot;, &quot;Zero&quot; and &quot;Up&quot; giving the number of the
down-, not- and up-regulated genes respectively. Rows of the data frame
correspond to module IDs. The object can directly be used in
tmodPanelPlot as the pie parameter.
</p>


<h3>See Also</h3>

<p>tmodDecideTests, tmodLimmaTest, tmodPanelPlot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Egambia)
design &lt;- cbind(Intercept=rep(1, 30), TB=rep(c(0,1), each= 15))
if(require(limma)) {
  fit &lt;- eBayes( lmFit(Egambia[,-c(1:3)], design))
  ret &lt;- tmodLimmaTest(fit, Egambia$GENE_SYMBOL)
  pie &lt;- tmodLimmaDecideTests(fit, Egambia$GENE_SYMBOL)
  tmodPanelPlot(ret, pie=pie)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='tmodLimmaTest'>Run tmod enrichment tests directly on a limma object</h2><span id='topic+tmodLimmaTest'></span>

<h3>Description</h3>

<p>Order the genes according to each of the coefficient
found in a limma object and run an enrichment test on the ordered list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodLimmaTest(
  f,
  genes,
  sort.by = "msd",
  tmodFunc = tmodCERNOtest,
  coef = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodLimmaTest_+3A_f">f</code></td>
<td>
<p>result of linear model fit produced by limma functions lmFit and eBayes</p>
</td></tr>
<tr><td><code id="tmodLimmaTest_+3A_genes">genes</code></td>
<td>
<p>Either the name of the column in f$genes which
contains the gene symbols corresponding to the gene set collection used, or
a character vector with gene symbols</p>
</td></tr>
<tr><td><code id="tmodLimmaTest_+3A_sort.by">sort.by</code></td>
<td>
<p>How the gene names should be ordered: &quot;msd&quot; (default), &quot;pval&quot; or &quot;lfc&quot;</p>
</td></tr>
<tr><td><code id="tmodLimmaTest_+3A_tmodfunc">tmodFunc</code></td>
<td>
<p>The function to run the enrichment tests. Either tmodCERNOtest or tmodUtest</p>
</td></tr>
<tr><td><code id="tmodLimmaTest_+3A_coef">coef</code></td>
<td>
<p>If not NULL, only run tmod on these coefficients</p>
</td></tr>
<tr><td><code id="tmodLimmaTest_+3A_...">...</code></td>
<td>
<p>Further parameters passed to the tmod test function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each coefficient in the fit returned by the eBayes / lmFit functions
from the limma package, tmodLimmaTest will order the genes run an enrichment test and return
the results.
</p>
<p>The ordering of the genes according to a certain metric is the fundament for
gene enrichment analysis. tmodLimmaTest allows three orderings: p-values, &quot;MSD&quot; and log fold changes.
The default MSD (&quot;minimal significant difference&quot;) is the lower boundary of the 95
confidence interval for positive log fold changes, and 0 minus the upper boundary
of the 95
better than ordering by p-value or by log fold change. See discussion in
the package vignette.
</p>


<h3>Value</h3>

<p>A list with length equal to the number of coeffients. Each
element is the value returned by tmod test function. The list can be
directly passed to the functions tmodSummary and tmodPanelPlot.
</p>


<h3>See Also</h3>

<p>tmodCERNOtest, tmodUtest, tmodPlotPanel, tmodSummary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Egambia)
design &lt;- cbind(Intercept=rep(1, 30), TB=rep(c(0,1), each= 15))
if(require(limma)) {
  fit &lt;- eBayes( lmFit(Egambia[,-c(1:3)], design))
  ret &lt;- tmodLimmaTest(fit, genes=Egambia$GENE_SYMBOL)
  tmodSummary(ret)
  tmodPanelPlot(ret)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='tmodLimmaTopTable'>tmod's replacement for the limma topTable function</h2><span id='topic+tmodLimmaTopTable'></span>

<h3>Description</h3>

<p>Produce a data frame for all or for selected coefficients of a linear
fit object, including log fold changes, q-values, confidence intervals and
MSD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodLimmaTopTable(
  f,
  genelist = NULL,
  coef = NULL,
  adjust.method = "BH",
  confint = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodLimmaTopTable_+3A_f">f</code></td>
<td>
<p>result of linear model fit produced by limma functions lmFit and eBayes</p>
</td></tr>
<tr><td><code id="tmodLimmaTopTable_+3A_genelist">genelist</code></td>
<td>
<p>A data frame or a character vector with additional
information on the genes / probes</p>
</td></tr>
<tr><td><code id="tmodLimmaTopTable_+3A_coef">coef</code></td>
<td>
<p>Which coefficients to extract</p>
</td></tr>
<tr><td><code id="tmodLimmaTopTable_+3A_adjust.method">adjust.method</code></td>
<td>
<p>Which method of p-value adjustment; see &quot;p.adjust()&quot;</p>
</td></tr>
<tr><td><code id="tmodLimmaTopTable_+3A_confint">confint</code></td>
<td>
<p>Confidence interval to be calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produce a data frame for all or for selected coefficients of a linear
fit object, including log fold changes, q-values, confidence intervals and
MSD. For each coefficient, these four columns will be created in the
output file, with the name consisting of a prefix indicating the type of
the column (&quot;msd&quot;, &quot;logFC&quot;, &quot;qval&quot;, &quot;SE&quot;, &quot;ci.L&quot;, &quot;ci.R&quot;) and the name of the
coefficient.
</p>


<h3>Value</h3>

<p>A data frame with all genes.
</p>


<h3>See Also</h3>

<p>tmodLimmaTest
</p>

<hr>
<h2 id='tmodPal'>A selection of color palettes</h2><span id='topic+tmodPal'></span>

<h3>Description</h3>

<p>Return a preset selection of colors, adjusted by alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodPal(n = NULL, set = "friendly", alpha = 0.7, func = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodPal_+3A_n">n</code></td>
<td>
<p>Number of colors to return (default: all for &quot;friendly&quot;, 3 for everything else)</p>
</td></tr>
<tr><td><code id="tmodPal_+3A_set">set</code></td>
<td>
<p>Which palette set (see Details).</p>
</td></tr>
<tr><td><code id="tmodPal_+3A_alpha">alpha</code></td>
<td>
<p>0 for maximum transparency, 1 for no transparency.</p>
</td></tr>
<tr><td><code id="tmodPal_+3A_func">func</code></td>
<td>
<p>if TRUE, the returned object will be a function rather than
a character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A few palettes have been predefined in tmod, and this function can be
used to extract them. The following palettes have been defined:
* friendly &ndash; a set of distinct, colorblind-friendly colors
* bwr, rwb, ckp, pkc &ndash; gradients (b-blue, r-red, w-white, c-cyan, k-blacK, p-purple)
By default, either all colors are returned, or, if it is a gradient
palette, only three.
</p>


<h3>Value</h3>

<p>Either a character vector, or, when the func parameter is TRUE,
a function that takes only one argument (a single number)
</p>

<hr>
<h2 id='tmodPanelPlot'>Plot a summary of multiple tmod analyses</h2><span id='topic+tmodPanelPlot'></span>

<h3>Description</h3>

<p>Plot a summary of multiple tmod analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodPanelPlot(
  x,
  pie = NULL,
  clust = "qval",
  select = NULL,
  filter.empty.cols = FALSE,
  filter.empty.rows = TRUE,
  filter.unknown = TRUE,
  filter.rows.pval = 0.05,
  filter.rows.auc = 0.5,
  filter.by.id = NULL,
  col.labels = NULL,
  col.labels.style = "top",
  row.labels = NULL,
  row.labels.auto = "both",
  pval.thr = 10^-2,
  pval.thr.lower = 10^-6,
  plot.func = NULL,
  grid = "at",
  pie.colors = c("#0000FF", "#cccccc", "#FF0000"),
  plot.cex = 1,
  text.cex = 1,
  pie.style = "auto",
  min.e = 0.5,
  max.e = 1,
  legend.style = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodPanelPlot_+3A_x">x</code></td>
<td>
<p>either a list, in which each element has been generated with a tmod test function, or the result of the tmodSummary function</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_pie">pie</code></td>
<td>
<p>a list of data frames with information for drawing a pie chart</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_clust">clust</code></td>
<td>
<p>whether, in the resulting data frame, the modules should be
ordered by clustering them with either q-values (&quot;qval&quot;) or the effect size
(&quot;effect&quot;). If &quot;sort&quot; or NULL, the modules are sorted alphabetically by their ID.
If &quot;keep&quot;, then the order of the modules is kept.</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_select">select</code></td>
<td>
<p>a character vector of module IDs to show. If clust == &quot;keep&quot;, then in that particular
order.</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_filter.empty.cols">filter.empty.cols</code></td>
<td>
<p>If TRUE, all elements (columns) with no enrichment below pval.thr in any row will be removed</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_filter.empty.rows">filter.empty.rows</code></td>
<td>
<p>If TRUE, all modules (rows) with no enrichment below pval.thr in any column will be removed</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_filter.unknown">filter.unknown</code></td>
<td>
<p>If TRUE, modules with no annotation will be omitted</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_filter.rows.pval">filter.rows.pval</code></td>
<td>
<p>Rows in which no p value is below this threshold will be omitted</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_filter.rows.auc">filter.rows.auc</code></td>
<td>
<p>Rows in which no AUC value is above this threshold will be omitted</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_filter.by.id">filter.by.id</code></td>
<td>
<p>if provided, show only modules with IDs in this character vector</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_col.labels">col.labels</code></td>
<td>
<p>Labels for the columns. If NULL, names of the elements
of the list x will be used.</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_col.labels.style">col.labels.style</code></td>
<td>
<p>Style of column names: &quot;top&quot; (default), &quot;bottom&quot;, &quot;both&quot;, &quot;none&quot;</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_row.labels">row.labels</code></td>
<td>
<p>Labels for the modules. This must be a named vector, with module IDs as vector names. If NULL, module titles from
the analyses results will be used.</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_row.labels.auto">row.labels.auto</code></td>
<td>
<p>Automatic generation of row labels from module
data: &quot;both&quot; or &quot;auto&quot; (default, ID and title), &quot;id&quot; (only ID), &quot;title&quot; (only title),
&quot;none&quot; (no row label)</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_pval.thr">pval.thr</code></td>
<td>
<p>Results with p-value above pval.thr will not be shown</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_pval.thr.lower">pval.thr.lower</code></td>
<td>
<p>Results with p-value below pval.thr.lower will look identical on the plot</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_plot.func">plot.func</code></td>
<td>
<p>Optionally, a function to be used to draw the dots. See &quot;pvalEffectPlot&quot;</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_grid">grid</code></td>
<td>
<p>Style of a light-grey grid to be plotted; can be &quot;none&quot;, &quot;at&quot; and &quot;between&quot;</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_pie.colors">pie.colors</code></td>
<td>
<p>character vector of length equal to the cardinality of the third dimension of the pie argument. By default: blue, grey and red.</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_plot.cex">plot.cex</code></td>
<td>
<p>a numerical value giving the amount by which the plot
symbols will be maginfied</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_text.cex">text.cex</code></td>
<td>
<p>a numerical value giving the amount by which the plot
text will be magnified, or a vector containing three cex values for row labels, column labels and legend, respectively</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_pie.style">pie.style</code></td>
<td>
<p>Can be &quot;auto&quot; (default), &quot;dot&quot;, &quot;symdot&quot;, &quot;pie&quot;, &quot;boxpie&quot;, &quot;rug&quot; (see Details)</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_min.e">min.e</code>, <code id="tmodPanelPlot_+3A_max.e">max.e</code></td>
<td>
<p>scale limits for the effect size (default: 0.5 and 1.0)</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_legend.style">legend.style</code></td>
<td>
<p>Style of the legend: &quot;auto&quot; &ndash; automatic; &quot;broad&quot;:
pval legend side by side with effect size legend; &quot;tall&quot;: effect size
legend above pval legend</p>
</td></tr>
<tr><td><code id="tmodPanelPlot_+3A_...">...</code></td>
<td>
<p>Any further arguments will be passed to the pvalEffectPlot function (for example, grid.color)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful if you run an analysis for several conditions or
time points and would like to summarize the information on a plot.
You can use lapply() to generate a list with tmod results and use
tmodPanelPlot to visualize it.
</p>
<p>tmodPanelPlot shows a heatmap-like plot. Each row corresponds to one
module, and columns correspond to the time points or conditions for which
the tmod analyses were run. Each significantly enriched module is shown as
a red dot. Size of the dot corresponds to the effect size (for example, AUC
in the CERNO test), and intensity of the color corresponds to the q-value.
</p>
<p>By default, tmodPanelPlot visualizes each the results of a single
statistical test by a red dot, or blue and red dots if the effect sizes are both 
negative and positive. However, it is often interesting to know how
many of the genes in a module are significantly up- or down regulated.
tmodPanelPlot can draw a pie chart based on the optional argument &quot;pie&quot;.
The argument must be a list of length equal to the length of x.
Note also that the names of the pie list must be equal to the names of x.
Objects returned by the function tmodDecideTests can be directly used
here. The rownames of either the data frame or the array must be the
module IDs.
</p>


<h3>Value</h3>

<p>a data frame with a line for each module encountered anywhere in
the list x, two columns describing the module (ID and module title), and
two columns(effect size and q value) for each element of list x.
</p>


<h3>See Also</h3>

<p>tmodDecideTests, tmodSummary, pvalEffectPlot, simplePie
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Egambia)
E &lt;- Egambia[,-c(1:3)]
pca &lt;- prcomp(t(E), scale.=TRUE)

# Calculate enrichment for first 5 PCs
gs   &lt;- Egambia$GENE_SYMBOL
gn.f &lt;- function(r) {
    o &lt;- order(abs(r), decreasing=TRUE)
    tmodCERNOtest(gs[o], 
                qval=0.01)
}
x &lt;- apply(pca$rotation[,3:4], 2, gn.f)
tmodPanelPlot(x, text.cex=0.7)
</code></pre>

<hr>
<h2 id='tmodPCA'>PCA plot annotated with tmod</h2><span id='topic+tmodPCA'></span>

<h3>Description</h3>

<p>Generate a PCA plot on which each dimension is annotated by a tag cloud
based on tmod enrichment test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodPCA(
  pca,
  loadings = NULL,
  genes,
  tmodfunc = "tmodCERNOtest",
  plotfunc = pcaplot,
  mode = "simple",
  components = c(1, 2),
  plot.params = NULL,
  filter = TRUE,
  simplify = TRUE,
  legend = FALSE,
  maxn = NULL,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodPCA_+3A_pca">pca</code></td>
<td>
<p>Object returned by prcomp or a matrix of PCA coordinates. In the latter case, a
loading matrix must be provided separately.</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_loadings">loadings</code></td>
<td>
<p>A matrix with loadings</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_genes">genes</code></td>
<td>
<p>A character vector with gene identifiers</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_tmodfunc">tmodfunc</code></td>
<td>
<p>Name of the tmod enrichment test function to use. Either</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_plotfunc">plotfunc</code></td>
<td>
<p>Function for plotting the PCA plot. See Details</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_mode">mode</code></td>
<td>
<p>Type of the plot to generate; see Details. tmodCERNOtest or tmodUtest (tmodHGtest is not suitable)</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_components">components</code></td>
<td>
<p>integer vector of length two: components which components to show on the plot. Must be smaller than the number of columns in pca.</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_plot.params">plot.params</code></td>
<td>
<p>A list of parameters to be passed to the plotting function. See
Details</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_filter">filter</code></td>
<td>
<p>Whether &quot;uninteresting&quot; modules (with no annotation)
should be removed from the tag cloud</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_simplify">simplify</code></td>
<td>
<p>Whether the names of the modules should be simplified</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_legend">legend</code></td>
<td>
<p>whether a legend should be shown</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_maxn">maxn</code></td>
<td>
<p>Maximum number of gene set enrichment terms shown on the plot (if NULL – default – all terms will be shown)</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_plot">plot</code></td>
<td>
<p>if FALSE, no plot will be shown, but the enrichments will be calculated and returned invisibly</p>
</td></tr>
<tr><td><code id="tmodPCA_+3A_...">...</code></td>
<td>
<p>Any further parameters passed to the tmod test function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three types of plots that can be generated (parameter &quot;mode&quot;):
simple, leftbottom and cross. In the &quot;simple&quot; mode, two enrichments are
run, on on each component, sorted by absolute loadings of the PCA
components.
Both &quot;leftbottom&quot; and &quot;cross&quot; run two enrichment analyses on each component,
one on the loadings sorted from lowest to largest, and one on the loadings
sorted from largetst to lowest. Thus, two tag clouds are displayed per
component. In the &quot;leftbottom&quot; mode, the tag clouds are displayed to the
left and below the PCA plot. In the &quot;cross&quot; mode, the tag clouds are
displayed on each of the four sides of the plot.
</p>
<p>By default, the plotting function is plotpca.
You can define your own function instead of plotpca, however, mind
that in any case, there will be two parameters passed to it on the first
two positions: pca and components, named &quot;pca&quot; and &quot;components&quot;
respectively.
</p>


<h3>Value</h3>

<p>A list containing the calculated enrichments as well as the
return value from the plotting function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Egambia)
E &lt;- as.matrix(Egambia[,-c(1:3)])
pca &lt;- prcomp(t(E), scale.=TRUE)
group &lt;- rep(c("CTRL", "TB"), each=15)
tmodPCA(pca, 
  genes=Egambia$GENE_SYMBOL, 
  components=4:3,
  plot.params=list(group=group))
</code></pre>

<hr>
<h2 id='tmodSummary'>Create a summary of multiple tmod analyses</h2><span id='topic+tmodSummary'></span>

<h3>Description</h3>

<p>Create a summary of multiple tmod analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodSummary(
  x,
  clust = NULL,
  filter.empty = FALSE,
  filter.unknown = TRUE,
  select = NULL,
  effect.col = NULL,
  pval.col = "adj.P.Val"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodSummary_+3A_x">x</code></td>
<td>
<p>list, in which each element has been generated with a tmod test function</p>
</td></tr>
<tr><td><code id="tmodSummary_+3A_clust">clust</code></td>
<td>
<p>whether, in the resulting data frame, the modules should be
ordered by clustering them with either q-values (&quot;qval&quot;) or the effect size
(&quot;effect&quot;). If &quot;sort&quot; or NULL, the modules are sorted alphabetically by their ID.
If &quot;keep&quot;, then the order of the modules is kept.</p>
</td></tr>
<tr><td><code id="tmodSummary_+3A_filter.empty">filter.empty</code></td>
<td>
<p>If TRUE, all elements (columns) with no significant enrichment will be removed</p>
</td></tr>
<tr><td><code id="tmodSummary_+3A_filter.unknown">filter.unknown</code></td>
<td>
<p>If TRUE, modules with no annotation will be omitted</p>
</td></tr>
<tr><td><code id="tmodSummary_+3A_select">select</code></td>
<td>
<p>a character vector of module IDs to show. If clust == &quot;keep&quot;, then in that particular
order.</p>
</td></tr>
<tr><td><code id="tmodSummary_+3A_effect.col">effect.col</code></td>
<td>
<p>The name of the column with the effect size (if NULL,
the default, the effect size will be taken from the tmod results object
attributes)</p>
</td></tr>
<tr><td><code id="tmodSummary_+3A_pval.col">pval.col</code></td>
<td>
<p>The name of the p-value column</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful if you run an analysis for several conditions or
time points and would like to summarize the information in a single data
frame. You can use lapply() to generate a list with tmod results and use
tmodSummary to convert it to a data frame.
</p>


<h3>Value</h3>

<p>a data frame with a line for each module encountered anywhere in
the list x, two columns describing the module (ID and module title), and
two columns(effect size and q value) for each element of list x.
</p>


<h3>See Also</h3>

<p>tmodPanelPlot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Egambia)
E &lt;- Egambia[,-c(1:3)]
pca &lt;- prcomp(t(E), scale.=TRUE)

# Calculate enrichment for each component
gs   &lt;- Egambia$GENE_SYMBOL
gn.f &lt;- function(r) {
    tmodCERNOtest(gs[order(abs(r), 
                decreasing=TRUE)], 
                qval=0.01)
}
x &lt;- apply(pca$rotation, 2, gn.f)
tmodSummary(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='tmodTagcloud'>Tag cloud based on tmod results</h2><span id='topic+tmodTagcloud'></span>

<h3>Description</h3>

<p>Plot a tag (word) cloud based on results from tmod enrichment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodTagcloud(
  results,
  filter = TRUE,
  simplify = TRUE,
  tag.col = "Title",
  min.auc = 0.5,
  max.qval = 0.05,
  plot = TRUE,
  weights.col = "auto",
  pval.col = "P.Value",
  maxn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodTagcloud_+3A_results">results</code></td>
<td>
<p>data frame produced by one of the tmod enrichment tests</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_filter">filter</code></td>
<td>
<p>Whether redundant and not annotated modules should be removed</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_simplify">simplify</code></td>
<td>
<p>Whether module names should be simplified</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_tag.col">tag.col</code></td>
<td>
<p>Which column from results should be used as tags on the plot</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_min.auc">min.auc</code></td>
<td>
<p>Minimal AUC to show (default: 0.5)</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_max.qval">max.qval</code></td>
<td>
<p>Maximal adjusted p value to show (default: 0.05)</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_plot">plot</code></td>
<td>
<p>Should the tag cloud be plotted or only returned</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_weights.col">weights.col</code></td>
<td>
<p>Which column from results should be used as weights for the tag cloud</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_pval.col">pval.col</code></td>
<td>
<p>Which column contains the P values which will be used to shade the tags</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_maxn">maxn</code></td>
<td>
<p>Maximum number of gene set enrichment terms shown on the plot (if NULL – default – all terms will be shown)</p>
</td></tr>
<tr><td><code id="tmodTagcloud_+3A_...">...</code></td>
<td>
<p>Any further parameters are passed to the tagcloud function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tags will be generated based on results from tmod or any other
suitable data frame. The data frame must contain two numeric columns,
specified with &quot;weights.col&quot; and &quot;pval.col&quot;, which will be
used to calculate the size and shade of the tags, respectively.
Furthermore, it has to contain a column with tags (parameter &quot;tag.col&quot;,
by default &quot;Title&quot;).
</p>
<p>Any data frame can be used as long as it contains the specified columns.
</p>


<h3>Value</h3>

<p>Either NULL or whatever tagcloud returns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tmod)
fg &lt;- getModuleMembers("LI.M127")[[1]]
bg &lt;- tmod$gv
result &lt;- tmodHGtest( fg, bg )
tmodTagcloud(result)
</code></pre>

<hr>
<h2 id='tmodUtest'>Perform a statistical test of module expression</h2><span id='topic+tmodUtest'></span><span id='topic+tmodGeneSetTest'></span><span id='topic+tmodCERNOtest'></span><span id='topic+tmodPLAGEtest'></span><span id='topic+tmodZtest'></span><span id='topic+tmodHGtest'></span>

<h3>Description</h3>

<p>Perform a statistical test of module expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmodUtest(
  l,
  modules = NULL,
  qval = 0.05,
  order.by = "pval",
  filter = FALSE,
  mset = "all",
  cols = "Title",
  useR = FALSE,
  nodups = TRUE
)

tmodGeneSetTest(
  l,
  x,
  modules = NULL,
  qval = 0.05,
  order.by = "pval",
  filter = FALSE,
  mset = "all",
  cols = "Title",
  Nsim = 1000,
  nodups = TRUE
)

tmodCERNOtest(
  l,
  modules = NULL,
  qval = 0.05,
  order.by = "pval",
  filter = FALSE,
  mset = "all",
  cols = "Title",
  nodups = TRUE
)

tmodPLAGEtest(
  l,
  x,
  group,
  modules = NULL,
  qval = 0.05,
  order.by = "pval",
  mset = "all",
  cols = "Title",
  filter = FALSE,
  nodups = TRUE
)

tmodZtest(
  l,
  modules = NULL,
  qval = 0.05,
  order.by = "pval",
  filter = FALSE,
  mset = "all",
  cols = "Title",
  nodups = TRUE
)

tmodHGtest(
  fg,
  bg,
  modules = NULL,
  qval = 0.05,
  order.by = "pval",
  filter = FALSE,
  mset = "all",
  cols = "Title",
  nodups = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmodUtest_+3A_l">l</code></td>
<td>
<p>sorted list of HGNC gene identifiers</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_modules">modules</code></td>
<td>
<p>optional list of modules for which to make the test</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_qval">qval</code></td>
<td>
<p>Threshold FDR value to report</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_order.by">order.by</code></td>
<td>
<p>Order by P value (&quot;pval&quot;) or none (&quot;none&quot;)</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_filter">filter</code></td>
<td>
<p>Remove gene names which have no module assignments</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_mset">mset</code></td>
<td>
<p>Which module set to use. Either a character vector (&quot;LI&quot;, &quot;DC&quot; or &quot;all&quot;, default: all) or an object of class tmod (see &quot;Custom module definitions&quot; below)</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_cols">cols</code></td>
<td>
<p>Which columns from the MODULES data frame should be included in resulsts</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_user">useR</code></td>
<td>
<p>use the R <code>wilcox.test</code> function; slow, but with exact p-values for small samples</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_nodups">nodups</code></td>
<td>
<p>Remove duplicate gene names in l and corresponding
rows from ranks</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_x">x</code></td>
<td>
<p>Expression matrix for the tmodPLAGEtest; a vector for tmodGeneSetTest</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_nsim">Nsim</code></td>
<td>
<p>for tmodGeneSetTest, number of replicates for the randomization test</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_group">group</code></td>
<td>
<p>group assignments for the tmodPLAGEtest</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_fg">fg</code></td>
<td>
<p>foreground gene set for the HG test</p>
</td></tr>
<tr><td><code id="tmodUtest_+3A_bg">bg</code></td>
<td>
<p>background gene set for the HG test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a test on either on an ordered list of genes (tmodUtest,
tmodCERNOtest, tmodZtest) or on two groups of genes (tmodHGtest).
tmodUtest is a U test on ranks of genes that are contained in a module.
</p>
<p>tmodCERNOtest is also a nonparametric test working on gene ranks, but it
originates from Fisher's combined probability test. This test weights
genes with lower ranks more, the resulting p-values better correspond to
the observed effect size. In effect, modules with small effect but many
genes get higher p-values than in case of the U-test.
</p>
<p>tmodPLAGEtest is based on the PLAGE, &quot;Pathway level analysis of gene
expression&quot; published by Tomfohr, Lu and Kepler (2005), doi 10.1186/1471-2105-6-225.
In essence it is just a t-test run on module eigengenes, but it
performs really well. This approach can be used with any complex linear
model; for this, use the function eigengene(). See users guide for details.
</p>
<p>tmodZtest works very much like tmodCERNOtest, but instead of combining
the rank-derived p-values using Fisher's method, it uses the Stouffer
method (known also as the Z-transform test). 
</p>
<p>tmodGeneSetTest is an implementation of the function geneSetTest from
the limma package (note that tmodUtest is equivalent to the limma's
wilcoxGST function).
</p>
<p>For a discussion of the above three methods, read M. C. Whitlock,
&quot;Combining probability from independent tests: the weighted Z-method is
superior to Fisher's approach&quot;, J. Evol. Biol. 2005 (doi:
10.1111/j.1420-9101.2005.00917.x) for further details.
</p>
<p>tmodHGtest is simply a hypergeometric test.
</p>
<p>In tmod, two module sets can be used, &quot;LI&quot; (from Li et al. 2013), or
&quot;DC&quot; (from Chaussabel et al. 2008). Using the parameter &quot;mset&quot;, the
module set can be selected, or, if mset is &quot;all&quot;, both of sets are used.
</p>


<h3>Value</h3>

<p>The statistical tests return a data frame with module names, additional statistic (e.g.
enrichment or AUC, depending on the test), P value and FDR q-value (P value corrected for multiple
testing using the p.adjust function and Benjamini-Hochberg correction.
The data frame has class 'colorDF' (see package colorDF for details),
but except for printing using colors on the terminal behaves just like an
ordinary data.frame. To strip the coloring, use [colorDF::uncolor()].
</p>


<h3>Custom module definitions</h3>

<p>Custom and arbitrary module, gene set or pathway definitions can be also provided through the mset
option, if the parameter is a list rather than a character vector. The
list parameter to mset must contain the following members: &quot;MODULES&quot;,
&quot;MODULES2GENES&quot; and &quot;GENES&quot;. 
</p>
<p>&quot;MODULES&quot; and &quot;GENES&quot; are data frames. It is required that MODULES
contains the following columns: &quot;ID&quot;, specifying a unique identifier of a
module, and &quot;Title&quot;, containing the description of the module. The
data frame &quot;GENES&quot; must contain the column &quot;ID&quot;.
</p>
<p>The list MODULES2GENES is a mapping between modules and genes. The names
of the list must correspond to the ID column of the MODULES data frame. The members of the
list are character vectors, and the values of these vectors must correspond
to the ID column of the GENES data frame.
</p>


<h3>See Also</h3>

<p>tmod-package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tmod)
fg &lt;- tmod$MODULES2GENES[["LI.M127"]]
bg &lt;- tmod$GENES$ID
result &lt;- tmodHGtest( fg, bg )

## A more sophisticated example
## Gene set enrichment in TB patients compared to 
## healthy controls (Egambia data set)
## Not run: 
data(Egambia)
library(limma)
design &lt;- cbind(Intercept=rep(1, 30), TB=rep(c(0,1), each= 15))
fit &lt;- eBayes( lmFit(Egambia[,-c(1:3)], design))
tt &lt;- topTable(fit, coef=2, number=Inf, genelist=Egambia[,1:3] )
tmodUtest(tt$GENE_SYMBOL)
tmodCERNOtest(tt$GENE_SYMBOL)

## End(Not run)
</code></pre>

<hr>
<h2 id='upset'>Upset plot</h2><span id='topic+upset'></span>

<h3>Description</h3>

<p>Upset plots help to interpret the results of gene set enrichment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset(
  modules,
  mset = NULL,
  min.size = 2,
  min.overlap = 2,
  max.comb = 4,
  min.group = 2,
  value = "number",
  cutoff = NULL,
  labels = NULL,
  group.stat = "jaccard",
  group.cutoff = 0.1,
  group = TRUE,
  pal = brewer.pal(8, "Dark2"),
  lab.cex = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_+3A_modules">modules</code></td>
<td>
<p>optional list of modules for which to make the test</p>
</td></tr>
<tr><td><code id="upset_+3A_mset">mset</code></td>
<td>
<p>Which module set to use. Either a character vector (&quot;LI&quot;, &quot;DC&quot; or &quot;all&quot;, default: all) or an object of class tmod (see &quot;Custom module definitions&quot; below)</p>
</td></tr>
<tr><td><code id="upset_+3A_min.size">min.size</code></td>
<td>
<p>minimal number of modules in a comparison to show</p>
</td></tr>
<tr><td><code id="upset_+3A_min.overlap">min.overlap</code></td>
<td>
<p>smallest overlap (number of elements) between two modules to plot</p>
</td></tr>
<tr><td><code id="upset_+3A_max.comb">max.comb</code></td>
<td>
<p>Maximum number of combinations to show (i.e., number of
dots on every vertical segment in the upset plot)</p>
</td></tr>
<tr><td><code id="upset_+3A_min.group">min.group</code></td>
<td>
<p>Minimum number of modules in a group. Group with a
smaller number of members will be ignored. Change this value to 
1 to see also modules which could not be grouped.</p>
</td></tr>
<tr><td><code id="upset_+3A_value">value</code></td>
<td>
<p>what to show on the plot: &quot;number&quot; (number of common
elements; default), &quot;soerensen&quot; (Sørensen–Dice coefficient), 
&quot;overlap&quot; (Szymkiewicz–Simpson coefficient) or &quot;jaccard&quot; (Jaccard index)</p>
</td></tr>
<tr><td><code id="upset_+3A_cutoff">cutoff</code></td>
<td>
<p>Combinations with the 'value' below cutoff will not be shown.</p>
</td></tr>
<tr><td><code id="upset_+3A_labels">labels</code></td>
<td>
<p>Labels for the modules. Character vector with the same
length as 'modules'</p>
</td></tr>
<tr><td><code id="upset_+3A_group.stat">group.stat</code></td>
<td>
<p>Statistics for finding groups 
(can be &quot;number&quot;, &quot;overlap&quot;, &quot;soerensen&quot; or &quot;jaccard&quot;; see function modOverlaps)</p>
</td></tr>
<tr><td><code id="upset_+3A_group.cutoff">group.cutoff</code></td>
<td>
<p>cutoff for group statistics</p>
</td></tr>
<tr><td><code id="upset_+3A_group">group</code></td>
<td>
<p>Should the modules be grouped by the overlap?</p>
</td></tr>
<tr><td><code id="upset_+3A_pal">pal</code></td>
<td>
<p>Color palette to show the groups.</p>
</td></tr>
<tr><td><code id="upset_+3A_lab.cex">lab.cex</code></td>
<td>
<p>Initial cex (font size) for labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot consists of three parts. The main part shows the overlaps
between the different modules (module can be a gene set, for example).
Each row corresponds to one module. Each column corresponds to an
intersection of one or more gene sets. Dots show which gene sets are in
that combination. Which combinations are shown depends on the parameters
'min.overlap' (which is the cutoff for the similarity measure specified by
the 'value' parameter), the parameter 'min.group' which specifies the
minimum number of modules in a group and the parameter 'max.comb' which
specifies the maximum number of combinations tested (too many combinations
are messing the plot).
</p>
<p>Above the intersections, you see a plot showing a similarity measure of
the intersected gene sets. By default it is the number of module members
(genes in case of a gene set), but several
other measures (e.g. the Jaccard index) are also implemented.
</p>
<p>To the left are the module descriptions (parameter 'label'; if label is
empty, the labels are taken from the mset object provided or, if that is
NULL, from the default tmod module set). The function attempts to scale
the text in such a way that all labels are visible. 
</p>
<p>By default, upset attempts to group the modules. This is done by
defining a similarity measure (by default the Jaccard index, parameter
'group.stat') and a cutoff threshold (parameter 'group.cutoff').
</p>


<h3>Value</h3>

<p>upset returns invisibly the identified module groups: a list of
character vectors.
</p>


<h3>See Also</h3>

<p>[modGroups()], [modOverlaps()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Egambia)
design &lt;- cbind(Intercept=rep(1, 30), TB=rep(c(0,1), each= 15))
library(limma)
fit &lt;- eBayes( lmFit(Egambia[,-c(1:3)], design))
tt &lt;- topTable(fit, coef=2, number=Inf, genelist=Egambia[,1:3] )
res &lt;- tmodCERNOtest(tt$GENE_SYMBOL)

upset(res$ID, group.cutoff=.1, value="jaccard")

## End(Not run)
</code></pre>

<hr>
<h2 id='vaccination'>Transcriptomic responses to vaccination</h2><span id='topic+vaccination'></span>

<h3>Description</h3>

<p>Transcriptomic responses to vaccination
</p>


<h3>Format</h3>

<p>Data frame with one row per gene containing log fold changes and FDR (q
values) for the Fluad vaccine as compared to placebo on day 0, day 1, day 2
and day 3 after the vaccination.
</p>


<h3>Details</h3>

<p>The data shows the time course of transcriptomic responses to influenza
vaccination in healthy volunteers. The source of the data is 
GEO project PRJNA515032, associated with the following paper:
</p>
<p>Weiner, January, et al. &quot;Characterization of potential
biomarkers of reactogenicity of licensed antiviral vaccines: randomized
controlled clinical trials conducted by the BIOVACSAFE consortium.&quot;
Scientific reports 9.1 (2019): 1-14.
</p>
<p>For the data set, 3000 genes with top variance were chosen.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
