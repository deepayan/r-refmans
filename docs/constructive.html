<!DOCTYPE html><html lang="en"><head><title>Help for package constructive</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {constructive}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#constructive-package'><p>constructive: Display Idiomatic Code to Construct Most R Objects</p></a></li>
<li><a href='#.cstr_apply'><p>.cstr_apply</p></a></li>
<li><a href='#.cstr_combine_errors'><p>Combine errors</p></a></li>
<li><a href='#.cstr_construct'><p>Generic for object code generation</p></a></li>
<li><a href='#.cstr_options'><p>Create constructive options</p></a></li>
<li><a href='#.cstr_pipe'><p>Insert a pipe between two calls</p></a></li>
<li><a href='#.cstr_repair_attributes'><p>Repair attributes after idiomatic construction</p></a></li>
<li><a href='#.cstr_wrap'><p>Wrap argument code in function call</p></a></li>
<li><a href='#.env'><p>Fetch environment from memory address</p></a></li>
<li><a href='#.xptr'><p>Build a pointer from a memory address</p></a></li>
<li><a href='#compare_options'><p>Options for waldo::compare</p></a></li>
<li><a href='#construct'><p>Build code to recreate an object</p></a></li>
<li><a href='#construct_clip'><p>Construct to clipboard</p></a></li>
<li><a href='#construct_diff'><p>Display diff of object definitions</p></a></li>
<li><a href='#construct_dput'><p>Construct using only low level constructors</p></a></li>
<li><a href='#construct_dump'><p>Dump Constructed Code to a File</p></a></li>
<li><a href='#construct_issues'><p>Show constructive issues</p></a></li>
<li><a href='#construct_reprex'><p>construct_reprex</p></a></li>
<li><a href='#construct_signature'><p>Construct a function's signature</p></a></li>
<li><a href='#constructive-global_options'><p>Global Options</p></a></li>
<li><a href='#deparse_call'><p>Deparse a language object</p></a></li>
<li><a href='#extend-constructive'><p>Extend constructive</p></a></li>
<li><a href='#opts_array'><p>Constructive options for arrays</p></a></li>
<li><a href='#opts_AsIs'><p>Constructive options for the class <code>AsIs</code></p></a></li>
<li><a href='#opts_atomic'><p>Constructive options for atomic types</p></a></li>
<li><a href='#opts_blob'><p>Constructive options for class 'blob'</p></a></li>
<li><a href='#opts_character'><p>Constructive options for type 'character'</p></a></li>
<li><a href='#opts_classGeneratorFunction'><p>Constructive options for class 'classGeneratorFunction'</p></a></li>
<li><a href='#opts_classPrototypeDef'><p>Constructive options for class 'classPrototypeDef'</p></a></li>
<li><a href='#opts_classRepresentation'><p>Constructive options for class 'classRepresentation'</p></a></li>
<li><a href='#opts_complex'><p>Constructive options for type 'complex'</p></a></li>
<li><a href='#opts_constructive_options'><p>Constructive options for the class <code>constructive_options</code></p></a></li>
<li><a href='#opts_data.frame'><p>Constructive options for class 'data.frame'</p></a></li>
<li><a href='#opts_data.table'><p>Constructive options for class 'data.table'</p></a></li>
<li><a href='#opts_Date'><p>Constructive options class 'Date'</p></a></li>
<li><a href='#opts_dm'><p>Constructive options class 'dm'</p></a></li>
<li><a href='#opts_dots'><p>Constructive options for type '...'</p></a></li>
<li><a href='#opts_double'><p>Constructive options for type 'double'</p></a></li>
<li><a href='#opts_environment'><p>Constructive options for type 'environment'</p></a></li>
<li><a href='#opts_externalptr'><p>Constructive options for type 'externalptr'</p></a></li>
<li><a href='#opts_factor'><p>Constructive options for class 'factor'</p></a></li>
<li><a href='#opts_formula'><p>Constructive options for formulas</p></a></li>
<li><a href='#opts_function'><p>Constructive options for functions</p></a></li>
<li><a href='#opts_ggplot'><p>Constructive options for class 'ggplot'</p></a></li>
<li><a href='#opts_grouped_df'><p>Constructive options for class 'grouped_df'</p></a></li>
<li><a href='#opts_hexmode'><p>Constructive options for class 'hexmode'</p></a></li>
<li><a href='#opts_integer'><p>Constructive options for type 'integer'</p></a></li>
<li><a href='#opts_integer64'><p>Constructive options for class 'integer64'</p></a></li>
<li><a href='#opts_language'><p>Constructive options for type 'language'</p></a></li>
<li><a href='#opts_Layer'><p>Constructive options for class 'Layer' (ggplot2)</p></a></li>
<li><a href='#opts_list'><p>Constructive options for type 'list'</p></a></li>
<li><a href='#opts_logical'><p>Constructive options for type 'logical'</p></a></li>
<li><a href='#opts_matrix'><p>Constructive options for matrices</p></a></li>
<li><a href='#opts_mts'><p>Constructive options for time-series objets</p></a></li>
<li><a href='#opts_numeric_version'><p>Constructive options for numeric_version</p></a></li>
<li><a href='#opts_octmode'><p>Constructive options for class 'octmode'</p></a></li>
<li><a href='#opts_ordered'><p>Constructive options for class 'ordered'</p></a></li>
<li><a href='#opts_package_version'><p>Constructive options for package_version</p></a></li>
<li><a href='#opts_pairlist'><p>Constructive options for pairlists</p></a></li>
<li><a href='#opts_POSIXct'><p>Constructive options for class 'POSIXct'</p></a></li>
<li><a href='#opts_POSIXlt'><p>Constructive options for class 'POSIXlt'</p></a></li>
<li><a href='#opts_quosure'><p>Constructive options for class 'quosure'</p></a></li>
<li><a href='#opts_quosures'><p>Constructive options for class 'quosures'</p></a></li>
<li><a href='#opts_R_system_version'><p>Constructive options for R_system_version</p></a></li>
<li><a href='#opts_R6'><p>Constructive options for class 'R6'</p></a></li>
<li><a href='#opts_R6ClassGenerator'><p>Constructive options for class 'R6ClassGenerator'</p></a></li>
<li><a href='#opts_raw'><p>Constructive options for type 'raw'</p></a></li>
<li><a href='#opts_rowwise_df'><p>Constructive options for class 'rowwise_df'</p></a></li>
<li><a href='#opts_S4'><p>Constructive options for class 'S4'</p></a></li>
<li><a href='#opts_tbl_df'><p>Constructive options for tibbles</p></a></li>
<li><a href='#opts_ts'><p>Constructive options for time-series objets</p></a></li>
<li><a href='#opts_vctrs_list_of'><p>Constructive options for class 'data.table'</p></a></li>
<li><a href='#opts_weakref'><p>Constructive options for the class <code>weakref</code></p></a></li>
<li><a href='#opts_xts'><p>Constructive options for class 'xts'</p></a></li>
<li><a href='#opts_yearmon'><p>Constructive options for class 'yearmon'</p></a></li>
<li><a href='#opts_yearqtr'><p>Constructive options for class 'yearqtr'</p></a></li>
<li><a href='#opts_zoo'><p>Constructive options for class 'zoo'</p></a></li>
<li><a href='#opts_zooreg'><p>Constructive options for class 'zooreg'</p></a></li>
<li><a href='#other-opts'><p>Other Opts Functions</p></a></li>
<li><a href='#templates'><p>Extend constructive</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Display Idiomatic Code to Construct Most R Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Prints code that can be used to recreate R objects. In a
    sense it is similar to 'base::dput()' or 'base::deparse()' but
    'constructive' strives to use idiomatic constructors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cynkra/constructive">https://github.com/cynkra/constructive</a>,
<a href="https://cynkra.github.io/constructive/">https://cynkra.github.io/constructive/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cynkra/constructive/issues">https://github.com/cynkra/constructive/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, diffobj, methods, rlang (&ge; 1.0.0), waldo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64, blob, clipr, data.table, DiagrammeR, DiagrammeRsvg,
dm, dplyr, forcats, ggplot2, knitr, lubridate, pixarfilms,
prettycode, R6, reprex, rmarkdown, roxygen2, rstudioapi,
scales, sf, testthat (&ge; 3.0.0), tibble, tidyselect, vctrs,
withr, xts, zoo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 13:49:16 UTC; Antoine</td>
</tr>
<tr>
<td>Author:</td>
<td>Antoine Fabri [aut, cre],
  Kirill Müller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jacob Scott [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antoine Fabri &lt;antoine.fabri@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-10 14:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='constructive-package'>constructive: Display Idiomatic Code to Construct Most R Objects</h2><span id='topic+constructive'></span><span id='topic+constructive-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Prints code that can be used to recreate R objects. In a sense it is similar to 'base::dput()' or 'base::deparse()' but 'constructive' strives to use idiomatic constructors.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Antoine Fabri <a href="mailto:antoine.fabri@gmail.com">antoine.fabri@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Kirill Müller <a href="mailto:kirill@cynkra.com">kirill@cynkra.com</a> (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>) [contributor]
</p>
</li>
<li><p> Jacob Scott <a href="mailto:jscott2718@gmail.com">jscott2718@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cynkra/constructive">https://github.com/cynkra/constructive</a>
</p>
</li>
<li> <p><a href="https://cynkra.github.io/constructive/">https://cynkra.github.io/constructive/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cynkra/constructive/issues">https://github.com/cynkra/constructive/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.cstr_apply'>.cstr_apply</h2><span id='topic+.cstr_apply'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. If <code>recurse</code> is <code>TRUE</code> (default), we
recurse to construct <code>args</code> and insert their construction code in a <code>fun(...)</code> call returned
as a character vector. If <code>args</code> already contains code rather than object to
construct one should set <code>recurse</code> to <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_apply(
  args,
  fun = "list",
  ...,
  trailing_comma = FALSE,
  recurse = TRUE,
  implicit_names = FALSE,
  new_line = TRUE,
  one_liner = FALSE,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cstr_apply_+3A_args">args</code></td>
<td>
<p>A list of arguments to construct recursively, or code if <code>recurse = FALSE</code>.
If elements are named, the arguments will be named in the generated code.</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_fun">fun</code></td>
<td>
<p>The function name to use to build code of the form &quot;fun(...)&quot;</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_...">...</code></td>
<td>
<p>Options passed recursively to the further methods</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_trailing_comma">trailing_comma</code></td>
<td>
<p>Boolean. Whether to leave a trailing comma after the last argument if
the code is multiline, some constructors allow it (e.g. <code>tibble::tibble()</code>) and it makes for nicer
diffs in version control.</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_recurse">recurse</code></td>
<td>
<p>Boolean. Whether to recursively generate the code to construct <code>args</code>. If <code>FALSE</code> arguments
are expected to contain code.</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_implicit_names">implicit_names</code></td>
<td>
<p>When data is provided, compress calls of the form <code>f(a = a)</code> to <code>f(a)</code></p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_new_line">new_line</code></td>
<td>
<p>Boolean. Forwarded to <code>wrap()</code> to add a line between &quot;fun(&quot; and &quot;)&quot;, forced to
<code>FALSE</code> if <code>one_liner</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to return a one line call.</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_unicode_representation">unicode_representation</code></td>
<td>
<p>By default &quot;ascii&quot;, which means only ASCII characters
(code point &lt; 128) will be used to construct strings and variable names. This makes sure that
homoglyphs (different spaces and other identically displayed unicode characters)
are printed differently, and avoid possible unfortunate copy and paste
auto conversion issues. &quot;latin&quot; is more lax and uses all latin characters
(code point &lt; 256). &quot;character&quot; shows all characters, but not emojis. Finally
&quot;unicode&quot; displays all characters and emojis, which is what <code>dput()</code> does.</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_escape">escape</code></td>
<td>
<p>Boolean. Whether to escape double quotes and backslashes. If <code>FALSE</code> we use
single quotes to surround strings (including variable and element names)
containing double quotes, and raw strings for strings that contain backslashes
and/or a combination of single and double quotes. Depending on
<code>unicode_representation</code> <code>escape = FALSE</code> cannot be applied on all strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1
.cstr_apply(list(a=a), "foo")
.cstr_apply(list(a=a), "foo", data = list(a=1))
.cstr_apply(list(a=a), "foo", data = list(a=1), implicit_names = TRUE)
.cstr_apply(list(b=a), "foo", data = list(a=1), implicit_names = TRUE)
.cstr_apply(list(a="c(1,2)"), "foo")
.cstr_apply(list(a="c(1,2)"), "foo", recurse = FALSE)
</code></pre>

<hr>
<h2 id='.cstr_combine_errors'>Combine errors</h2><span id='topic+.cstr_combine_errors'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. This function allows combining independent checks so information is given about
all failing checks rather than the first one. All parameters except <code>...</code> are
forwarded to <code>rlang::abort()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_combine_errors(
  ...,
  class = NULL,
  call,
  header = NULL,
  body = NULL,
  footer = NULL,
  trace = NULL,
  parent = NULL,
  use_cli_format = NULL,
  .internal = FALSE,
  .file = NULL,
  .frame = parent.frame(),
  .trace_bottom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cstr_combine_errors_+3A_...">...</code></td>
<td>
<p>check expressions</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_class">class</code></td>
<td>
<p>Subclass of the condition.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running
function, e.g. <code>call = caller_env()</code>. The corresponding function
call is retrieved and mentioned in error messages as the source
of the error.
</p>
<p>You only need to supply <code>call</code> when throwing a condition from a
helper function which wouldn't be relevant to mention in the
message.
</p>
<p>Can also be <code>NULL</code> or a <a href="rlang.html#topic+topic-defuse">defused function call</a> to
respectively not display any call or hard-code a code to display.
</p>
<p>For more information about error calls, see <a href="rlang.html#topic+topic-error-call">Including function calls in error messages</a>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_header">header</code></td>
<td>
<p>An optional header to precede the errors</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_body">body</code>, <code id=".cstr_combine_errors_+3A_footer">footer</code></td>
<td>
<p>Additional bullets.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_trace">trace</code></td>
<td>
<p>A <code>trace</code> object created by <code><a href="rlang.html#topic+trace_back">trace_back()</a></code>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_parent">parent</code></td>
<td>
<p>Supply <code>parent</code> when you rethrow an error from a
condition handler (e.g. with <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>).
</p>

<ul>
<li><p> If <code>parent</code> is a condition object, a <em>chained error</em> is
created, which is useful when you want to enhance an error with
more details, while still retaining the original information.
</p>
</li>
<li><p> If <code>parent</code> is <code>NA</code>, it indicates an unchained rethrow, which
is useful when you want to take ownership over an error and
rethrow it with a custom message that better fits the
surrounding context.
</p>
<p>Technically, supplying <code>NA</code> lets <code>abort()</code> know it is called
from a condition handler. This helps it create simpler
backtraces where the condition handling context is hidden by
default.
</p>
</li></ul>

<p>For more information about error calls, see <a href="rlang.html#topic+topic-error-chaining">Including contextual information with error chains</a>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_use_cli_format">use_cli_format</code></td>
<td>
<p>Whether to format <code>message</code> lazily using
<a href="https://cli.r-lib.org/">cli</a> if available. This results in
prettier and more accurate formatting of messages. See
<code><a href="rlang.html#topic+local_use_cli">local_use_cli()</a></code> to set this condition field by default in your
package namespace.
</p>
<p>If set to <code>TRUE</code>, <code>message</code> should be a character vector of
individual and unformatted lines. Any newline character <code>"\\n"</code>
already present in <code>message</code> is reformatted by cli's paragraph
formatter. See <a href="rlang.html#topic+topic-condition-formatting">Formatting messages with cli</a>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_.internal">.internal</code></td>
<td>
<p>If <code>TRUE</code>, a footer bullet is added to <code>message</code>
to let the user know that the error is internal and that they
should report it to the package authors. This argument is
incompatible with <code>footer</code>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_.file">.file</code></td>
<td>
<p>A connection or a string specifying where to print the
message. The default depends on the context, see the <code>stdout</code> vs
<code>stderr</code> section.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_.frame">.frame</code></td>
<td>
<p>The throwing context. Used as default for
<code>.trace_bottom</code>, and to determine the internal package to mention
in internal errors when <code>.internal</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_.trace_bottom">.trace_bottom</code></td>
<td>
<p>Used in the display of simplified backtraces
as the last relevant call frame to show. This way, the irrelevant
parts of backtraces corresponding to condition handling
(<code><a href="base.html#topic+tryCatch">tryCatch()</a></code>, <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>, <code>abort()</code>, etc.) are hidden by
default. Defaults to <code>call</code> if it is an environment, or <code>.frame</code>
otherwise. Without effect if <code>trace</code> is supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly, called for side effects.
</p>

<hr>
<h2 id='.cstr_construct'>Generic for object code generation</h2><span id='topic+.cstr_construct'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. <code>.cstr_construct()</code> is basically a
naked <code>construct()</code>, without the checks, the style, the object post processing etc...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_construct(x, ..., data = NULL, classes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cstr_construct_+3A_x">x</code></td>
<td>
<p>An object, for <code>construct_multi()</code> a named list or an environment.</p>
</td></tr>
<tr><td><code id=".cstr_construct_+3A_...">...</code></td>
<td>
<p>Constructive options built with the <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> family of functions. See the &quot;Constructive options&quot;
section below.</p>
</td></tr>
<tr><td><code id=".cstr_construct_+3A_data">data</code></td>
<td>
<p>Named list or environment of objects we want to detect and mention by name (as opposed to
deparsing them further). Can also contain unnamed nested lists, environments, or
package names, in the latter case package exports and datasets will be considered.
In case of conflict, the last provided name is considered.</p>
</td></tr>
<tr><td><code id=".cstr_construct_+3A_classes">classes</code></td>
<td>
<p>A character vector of classes for which to use idiomatic
constructors when available, we can provide a package instead of all its
classes, in the &quot;{pkg}&quot; form, and we can use a minus sign (inside the quotes)
to exclude rather than include. By default we use idiomatic constructors
whenever possible. The special values <code>"*none*"</code> and <code>"*base*"</code> can be used
to restrict the idiomatic construction to the objects. See <code>construct_dput()</code>
and <code>construct_base()</code> for wrappers around this feature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='.cstr_options'>Create constructive options</h2><span id='topic+.cstr_options'></span>

<h3>Description</h3>

<p>Exported for custom constructor design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_options(class, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cstr_options_+3A_class">class</code></td>
<td>
<p>A string. An S3 class.</p>
</td></tr>
<tr><td><code id=".cstr_options_+3A_...">...</code></td>
<td>
<p>Options to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c(paste0("constructive_options_", class), "constructive_options")</code>
</p>

<hr>
<h2 id='.cstr_pipe'>Insert a pipe between two calls</h2><span id='topic+.cstr_pipe'></span>

<h3>Description</h3>

<p>Exported for custom constructor design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_pipe(x, y, ..., pipe = NULL, one_liner = FALSE, indent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cstr_pipe_+3A_x">x</code></td>
<td>
<p>A character vector. The code for the left hand side call.</p>
</td></tr>
<tr><td><code id=".cstr_pipe_+3A_y">y</code></td>
<td>
<p>A character vector. The code for the right hand side call.</p>
</td></tr>
<tr><td><code id=".cstr_pipe_+3A_...">...</code></td>
<td>
<p>Implemented to collect unused arguments forwarded by the dots of the
caller environment.</p>
</td></tr>
<tr><td><code id=".cstr_pipe_+3A_pipe">pipe</code></td>
<td>
<p>A string. The pipe to use, <code>"plus"</code> is useful for ggplot code.</p>
</td></tr>
<tr><td><code id=".cstr_pipe_+3A_one_liner">one_liner</code></td>
<td>
<p>A boolean. Whether to paste <code>x</code>, the pipe and <code>y</code> together</p>
</td></tr>
<tr><td><code id=".cstr_pipe_+3A_indent">indent</code></td>
<td>
<p>A boolean. Whether to indent <code>y</code>
on a same line (provided that <code>x</code> and <code>y</code> are strings and one liners themselves)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.cstr_pipe("iris", "head(2)", pipe = "magrittr", one_liner = FALSE)
.cstr_pipe("iris", "head(2)", pipe = "magrittr", one_liner = TRUE)
</code></pre>

<hr>
<h2 id='.cstr_repair_attributes'>Repair attributes after idiomatic construction</h2><span id='topic+.cstr_repair_attributes'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. In the general case an object might have more attributes than given by the idiomatic
construction. <code>.cstr_repair_attributes()</code> sets some of those attributes and ignores
others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_repair_attributes(
  x,
  code,
  ...,
  ignore = NULL,
  idiomatic_class = NULL,
  remove = NULL,
  flag_s4 = TRUE,
  repair_names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cstr_repair_attributes_+3A_x">x</code></td>
<td>
<p>The object to construct</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_code">code</code></td>
<td>
<p>The code constructing the object before attribute repair</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>.construct_apply()</code> when relevant</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_ignore">ignore</code></td>
<td>
<p>The attributes that shouldn't be repaired, i.e. we expect them
to be set by the constructor already in <code>code</code></p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_idiomatic_class">idiomatic_class</code></td>
<td>
<p>The class of the objects that the constructor produces,
if <code>x</code> is of class <code>idiomatic_class</code> there is no need to repair the class.</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_remove">remove</code></td>
<td>
<p>Attributes that should be removed, should rarely be useful.</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_flag_s4">flag_s4</code></td>
<td>
<p>Boolean. Whether to use <code>asS4()</code> on the code of S4 objects,
set to <code>FALSE</code> when a constructor that produces S4 objects was used.</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_repair_names">repair_names</code></td>
<td>
<p>Boolean. Whether to repair the <code>names</code> attribute. Generally it is
generated by the constructor but it is needed for some corner cases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='.cstr_wrap'>Wrap argument code in function call</h2><span id='topic+.cstr_wrap'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. Generally called through <code>.cstr_apply()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_wrap(args, fun, new_line = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cstr_wrap_+3A_args">args</code></td>
<td>
<p>A character vector containing the code of arguments.</p>
</td></tr>
<tr><td><code id=".cstr_wrap_+3A_fun">fun</code></td>
<td>
<p>A string. The name of the function to use in the function call.
Use <code>fun = ""</code> to wrap in parentheses.</p>
</td></tr>
<tr><td><code id=".cstr_wrap_+3A_new_line">new_line</code></td>
<td>
<p>Boolean. Whether to insert a new line between <code>"fun("</code> and the closing <code>")"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='.env'>Fetch environment from memory address</h2><span id='topic+.env'></span>

<h3>Description</h3>

<p>This is designed to be used in constructed output. The <code>parents</code> and <code>...</code> arguments
are not processed and only used to display additional information. If used on
an improper memory address it will either fail (most likely) or the output
will be erratic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.env(address, parents = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".env_+3A_address">address</code></td>
<td>
<p>Memory address of the environment</p>
</td></tr>
<tr><td><code id=".env_+3A_parents">parents</code>, <code id=".env_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The environment that the memory address points to.
</p>

<hr>
<h2 id='.xptr'>Build a pointer from a memory address</h2><span id='topic+.xptr'></span>

<h3>Description</h3>

<p>Base R doesn't provide utilities to build or manipulate external pointers
(objects of type &quot;externalptr&quot;), so we provide our own.
Objects defined with <code>.xptr()</code> are not stable across sessions,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.xptr(address)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".xptr_+3A_address">address</code></td>
<td>
<p>Memory address</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The external pointer (type &quot;externalptr&quot;) that the memory address points to.
</p>

<hr>
<h2 id='compare_options'>Options for waldo::compare</h2><span id='topic+compare_options'></span>

<h3>Description</h3>

<p>Builds options that will be passed to <code>waldo::compare()</code> down the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_options(
  ignore_srcref = TRUE,
  ignore_attr = FALSE,
  ignore_function_env = FALSE,
  ignore_formula_env = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_options_+3A_ignore_srcref">ignore_srcref</code></td>
<td>
<p>Ignore differences in function <code>srcref</code>s? <code>TRUE</code> by
default since the <code>srcref</code> does not change the behaviour of a function,
only its printed representation.</p>
</td></tr>
<tr><td><code id="compare_options_+3A_ignore_attr">ignore_attr</code></td>
<td>
<p>Ignore differences in specified attributes?
Supply a character vector to ignore differences in named attributes.
By default the <code>"waldo_opts"</code> attribute is listed in <code>ignore_attr</code> so
that changes to it are not reported; if you customize <code>ignore_attr</code>, you
will probably want to do this yourself.
</p>
<p>For backward compatibility with <code>all.equal()</code>, you can also use <code>TRUE</code>,
to all ignore differences in all attributes. This is not generally
recommended as it is a blunt tool that will ignore many important
functional differences.</p>
</td></tr>
<tr><td><code id="compare_options_+3A_ignore_function_env">ignore_function_env</code>, <code id="compare_options_+3A_ignore_formula_env">ignore_formula_env</code></td>
<td>
<p>Ignore the environments of
functions and formulas, respectively? These are provided primarily for
backward compatibility with <code>all.equal()</code> which always ignores these
environments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='construct'>Build code to recreate an object</h2><span id='topic+construct'></span><span id='topic+construct_multi'></span>

<h3>Description</h3>


<ul>
<li> <p><code>construct()</code> builds the code to reproduce one object,
</p>
</li>
<li> <p><code>construct_multi()</code> builds the code to reproduce objects stored in a named
list or environment.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>construct(
  x,
  ...,
  data = NULL,
  pipe = NULL,
  check = NULL,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE,
  pedantic_encoding = FALSE,
  compare = compare_options(),
  one_liner = FALSE,
  template = getOption("constructive_opts_template"),
  classes = NULL
)

construct_multi(
  x,
  ...,
  data = NULL,
  pipe = NULL,
  check = NULL,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE,
  pedantic_encoding = FALSE,
  compare = compare_options(),
  one_liner = FALSE,
  template = getOption("constructive_opts_template"),
  classes = NULL,
  include_dotted = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_+3A_x">x</code></td>
<td>
<p>An object, for <code>construct_multi()</code> a named list or an environment.</p>
</td></tr>
<tr><td><code id="construct_+3A_...">...</code></td>
<td>
<p>Constructive options built with the <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> family of functions. See the &quot;Constructive options&quot;
section below.</p>
</td></tr>
<tr><td><code id="construct_+3A_data">data</code></td>
<td>
<p>Named list or environment of objects we want to detect and mention by name (as opposed to
deparsing them further). Can also contain unnamed nested lists, environments, or
package names, in the latter case package exports and datasets will be considered.
In case of conflict, the last provided name is considered.</p>
</td></tr>
<tr><td><code id="construct_+3A_pipe">pipe</code></td>
<td>
<p>Which pipe to use, either <code>"base"</code> or <code>"magrittr"</code>.
Defaults to <code>"base"</code> for R &gt;= 4.2, otherwise to <code>"magrittr"</code>.</p>
</td></tr>
<tr><td><code id="construct_+3A_check">check</code></td>
<td>
<p>Boolean. Whether to check if the created code reproduces the object
using <code>waldo::compare()</code>.</p>
</td></tr>
<tr><td><code id="construct_+3A_unicode_representation">unicode_representation</code></td>
<td>
<p>By default &quot;ascii&quot;, which means only ASCII characters
(code point &lt; 128) will be used to construct strings and variable names. This makes sure that
homoglyphs (different spaces and other identically displayed unicode characters)
are printed differently, and avoid possible unfortunate copy and paste
auto conversion issues. &quot;latin&quot; is more lax and uses all latin characters
(code point &lt; 256). &quot;character&quot; shows all characters, but not emojis. Finally
&quot;unicode&quot; displays all characters and emojis, which is what <code>dput()</code> does.</p>
</td></tr>
<tr><td><code id="construct_+3A_escape">escape</code></td>
<td>
<p>Boolean. Whether to escape double quotes and backslashes. If <code>FALSE</code> we use
single quotes to surround strings (including variable and element names)
containing double quotes, and raw strings for strings that contain backslashes
and/or a combination of single and double quotes. Depending on
<code>unicode_representation</code> <code>escape = FALSE</code> cannot be applied on all strings.</p>
</td></tr>
<tr><td><code id="construct_+3A_pedantic_encoding">pedantic_encoding</code></td>
<td>
<p>Boolean. Whether to mark strings with the &quot;unknown&quot; encoding
rather than an explicit native encoding (&quot;UTF-8&quot; or &quot;latin1&quot;) when it's
necessary to reproduce the binary representation exactly. This detail is
normally of very little significance. The reason why we're not pedantic by default is that
the constructed code might be different in the console and in snapshot
tests and reprexes due to the latter rounding some angles, and it would
be confusing for users.</p>
</td></tr>
<tr><td><code id="construct_+3A_compare">compare</code></td>
<td>
<p>Parameters passed to <code>waldo::compare()</code>, built with <code>compare_options()</code>.</p>
</td></tr>
<tr><td><code id="construct_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single line of code.</p>
</td></tr>
<tr><td><code id="construct_+3A_template">template</code></td>
<td>
<p>A list of constructive options built with <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> functions,
they will be overriden by <code>...</code>. Use it to set a default
behavior for <code>{constructive}</code>.</p>
</td></tr>
<tr><td><code id="construct_+3A_classes">classes</code></td>
<td>
<p>A character vector of classes for which to use idiomatic
constructors when available, we can provide a package instead of all its
classes, in the &quot;{pkg}&quot; form, and we can use a minus sign (inside the quotes)
to exclude rather than include. By default we use idiomatic constructors
whenever possible. The special values <code>"*none*"</code> and <code>"*base*"</code> can be used
to restrict the idiomatic construction to the objects. See <code>construct_dput()</code>
and <code>construct_base()</code> for wrappers around this feature.</p>
</td></tr>
<tr><td><code id="construct_+3A_include_dotted">include_dotted</code></td>
<td>
<p>Whether to include names starting with dots, this includes
<code>.Random.seed</code> in the global environment and objects like <code>.Class</code> and
<code>.Generic</code> in the execution environments of S3 methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>construct_multi()</code> recognizes promises (also called lazy bindings),
this means that for instance <code>construct_multi(environment())</code> can be called
when debugging a function and will construct unevaluated arguments using
<code>delayedAssign()</code>.
</p>


<h3>Value</h3>

<p>An object of class 'constructive'.
</p>


<h3>Constructive options</h3>

<p>Constructive options provide a way to customize the output of 'construct()'.
We can provide calls to 'opts_*()' functions to the '...' argument. Each of these functions targets a specific type or class and is documented on its own page.
</p>

<ul>
<li> <p><code><a href="#topic+opts_array">opts_array</a>(constructor = c("array", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_AsIs">opts_AsIs</a>(constructor = c("I", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_atomic">opts_atomic</a>(..., trim = NULL, fill = c("default", "rlang", "+", "...", "none"), compress = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_bibentry">opts_bibentry</a>(constructor = c("bibentry", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_blob">opts_blob</a>(constructor = c("blob", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_character">opts_character</a>(constructor = c("default"), ..., trim = NULL, fill = c("default", "rlang", "+", "...", "none"), compress = TRUE, unicode_representation = c("ascii", "latin", "character", "unicode"), escape = FALSE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_citationFooter">opts_citationFooter</a>(constructor = c("citFooter", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_citationHeader">opts_citationHeader</a>(constructor = c("citHeader", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_classGeneratorFunction">opts_classGeneratorFunction</a>(constructor = c("setClass"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_classPrototypeDef">opts_classPrototypeDef</a>(constructor = c("prototype"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_classRepresentation">opts_classRepresentation</a>(constructor = c("getClassDef"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_complex">opts_complex</a>(constructor = c("default"), ..., trim = NULL, fill = c("default", "rlang", "+", "...", "none"), compress = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_constructive_options">opts_constructive_options</a>(constructor = c("opts", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_CoordCartesian">opts_CoordCartesian</a>(constructor = c("coord_cartesian", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_CoordFixed">opts_CoordFixed</a>(constructor = c("coord_fixed", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_CoordFlip">opts_CoordFlip</a>(constructor = c("coord_flip", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_CoordMap">opts_CoordMap</a>(constructor = c("coord_map", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_CoordMunch">opts_CoordMunch</a>(constructor = c("coord_munch", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_CoordPolar">opts_CoordPolar</a>(constructor = c("coord_polar", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_CoordQuickmap">opts_CoordQuickmap</a>(constructor = c("coord_quickmap", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_CoordSf">opts_CoordSf</a>(constructor = c("coord_sf", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_CoordTrans">opts_CoordTrans</a>(constructor = c("coord_trans", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_data.frame">opts_data.frame</a>(constructor = c("data.frame", "read.table", "next", "list"), ..., recycle = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_data.table">opts_data.table</a>(constructor = c("data.table", "next", "list"), ..., selfref = FALSE, recycle = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_Date">opts_Date</a>(constructor = c("as.Date", "as_date", "date", "new_date", "as.Date.numeric", "as_date.numeric", "next", "double"), ..., origin = "1970-01-01")</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_difftime">opts_difftime</a>(constructor = c("as.difftime", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_dm">opts_dm</a>(constructor = c("dm", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_dots">opts_dots</a>(constructor = c("default"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_double">opts_double</a>(constructor = c("default"), ..., trim = NULL, fill = c("default", "rlang", "+", "...", "none"), compress = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_element_blank">opts_element_blank</a>(constructor = c("element_blank", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_element_grob">opts_element_grob</a>(constructor = c("element_grob", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_element_line">opts_element_line</a>(constructor = c("element_line", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_element_rect">opts_element_rect</a>(constructor = c("element_rect", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_element_render">opts_element_render</a>(constructor = c("element_render", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_element_text">opts_element_text</a>(constructor = c("element_text", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_environment">opts_environment</a>(constructor = c(".env", "list2env", "as.environment", "new.env", "topenv", "new_environment", "predefine"), ..., recurse = FALSE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_error">opts_error</a>(constructor = c("errorCondition", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_expression">opts_expression</a>(constructor = c("default"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_externalptr">opts_externalptr</a>(constructor = c("default"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_FacetWrap">opts_FacetWrap</a>(constructor = c("facet_wrap", "ggproto", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_factor">opts_factor</a>(constructor = c("factor", "as_factor", "new_factor", "next", "integer"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_formula">opts_formula</a>(constructor = c("default", "formula", "as.formula", "new_formula", "next"), ..., environment = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_function">opts_function</a>(constructor = c("function", "as.function", "new_function"), ..., environment = TRUE, srcref = FALSE, trim = NULL)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_ggplot">opts_ggplot</a>(constructor = c("ggplot", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_ggproto">opts_ggproto</a>(constructor = c("default", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_grouped_df">opts_grouped_df</a>(constructor = c("default", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_hexmode">opts_hexmode</a>(constructor = c("as.hexmode", "next"), ..., integer = FALSE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_integer">opts_integer</a>(constructor = c("default"), ..., trim = NULL, fill = c("default", "rlang", "+", "...", "none"), compress = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_integer64">opts_integer64</a>(constructor = c("as.integer64", "next", "double"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_labels">opts_labels</a>(constructor = c("labs", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_language">opts_language</a>(constructor = c("default"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_Layer">opts_Layer</a>(constructor = c("default", "layer", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_list">opts_list</a>(constructor = c("list", "list2"), ..., trim = NULL, fill = c("vector", "new_list", "+", "...", "none"))</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_logical">opts_logical</a>(constructor = c("default"), ..., trim = NULL, fill = c("default", "rlang", "+", "...", "none"), compress = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_margin">opts_margin</a>(constructor = c("margin", "next", "double"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_matrix">opts_matrix</a>(constructor = c("matrix", "array", "cbind", "rbind", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_mts">opts_mts</a>(constructor = c("ts", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_noquote">opts_noquote</a>(constructor = c("noquote", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_NULL">opts_NULL</a>(constructor = "NULL", ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_numeric_version">opts_numeric_version</a>(constructor = c("numeric_version", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_octmode">opts_octmode</a>(constructor = c("as.octmode", "next"), ..., integer = FALSE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_ordered">opts_ordered</a>(constructor = c("ordered", "factor", "new_ordered", "next", "integer"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_package_version">opts_package_version</a>(constructor = c("package_version", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_pairlist">opts_pairlist</a>(constructor = c("pairlist", "pairlist2"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_person">opts_person</a>(constructor = c("person", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_POSIXct">opts_POSIXct</a>(constructor = c("as.POSIXct", ".POSIXct", "as_datetime", "as.POSIXct.numeric", "as_datetime.numeric", "next", "atomic"), ..., origin = "1970-01-01")</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_POSIXlt">opts_POSIXlt</a>(constructor = c("as.POSIXlt", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_quosure">opts_quosure</a>(constructor = c("new_quosure", "next", "language"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_quosures">opts_quosures</a>(constructor = c("new_quosures", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_R_system_version">opts_R_system_version</a>(constructor = c("R_system_version", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_R6">opts_R6</a>(constructor = c("R6Class", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_R6ClassGenerator">opts_R6ClassGenerator</a>(constructor = c("R6Class", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_raw">opts_raw</a>(constructor = c("as.raw", "charToRaw"), ..., trim = NULL, fill = c("default", "rlang", "+", "...", "none"), compress = TRUE, representation = c("hexadecimal", "decimal"))</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_rel">opts_rel</a>(constructor = c("rel", "next", "double"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_rowwise_df">opts_rowwise_df</a>(constructor = c("default", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_S4">opts_S4</a>(constructor = c("new"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_Scale">opts_Scale</a>(constructor = c("default", "next", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_ScalesList">opts_ScalesList</a>(constructor = c("ScalesList", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_simpleCondition">opts_simpleCondition</a>(constructor = c("simpleCondition", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_simpleError">opts_simpleError</a>(constructor = c("simpleError", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_simpleMessage">opts_simpleMessage</a>(constructor = c("simpleMessage", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_simpleUnit">opts_simpleUnit</a>(constructor = c("unit", "next", "double"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_simpleWarning">opts_simpleWarning</a>(constructor = c("simpleWarning", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_tbl_df">opts_tbl_df</a>(constructor = c("tibble", "tribble", "next", "list"), ..., trailing_comma = TRUE, justify = c("left", "right", "centre", "none"), recycle = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_theme">opts_theme</a>(constructor = c("theme", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_ts">opts_ts</a>(constructor = c("ts", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_uneval">opts_uneval</a>(constructor = c("aes", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_vctrs_list_of">opts_vctrs_list_of</a>(constructor = c("list_of", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_waiver">opts_waiver</a>(constructor = c("waiver", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_warning">opts_warning</a>(constructor = c("warningCondition", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_weakref">opts_weakref</a>(constructor = c("new_weakref"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_xts">opts_xts</a>(constructor = c("as.xts.matrix", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_yearmon">opts_yearmon</a>(constructor = c("as.yearmon", "yearmon", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_yearqtr">opts_yearqtr</a>(constructor = c("as.yearqtr", "yearqtr", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_zoo">opts_zoo</a>(constructor = c("zoo", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_zooreg">opts_zooreg</a>(constructor = c("zooreg", "next"), ...)</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+construct_dput">construct_dput()</a></code> <code><a href="#topic+construct_base">construct_base()</a></code> <code><a href="#topic+construct_clip">construct_clip()</a></code>
<code><a href="#topic+construct_dump">construct_dump()</a></code> <code><a href="#topic+construct_reprex">construct_reprex()</a></code> <code><a href="#topic+construct_diff">construct_diff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct(head(cars))
construct(head(cars), opts_data.frame("read.table"))
construct(head(cars), opts_data.frame("next"))
construct(iris$Species)
construct(iris$Species, opts_atomic(compress = FALSE), opts_factor("new_factor"))
construct_multi(list(a = head(cars), b = iris$Species))
</code></pre>

<hr>
<h2 id='construct_clip'>Construct to clipboard</h2><span id='topic+construct_clip'></span>

<h3>Description</h3>

<p>This is a simple wrapper for convenience, <code>construct_clip(x, ...)</code> is equivalent to
<code>print(construct(x, ...), print_mode = "clipboard")</code> (an idiom that you might
use to use the clipboard with other functions). For more flexible printing
options see <code>?constructive_print_mode</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_clip(
  x,
  ...,
  data = NULL,
  pipe = NULL,
  check = NULL,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE,
  pedantic_encoding = FALSE,
  compare = compare_options(),
  one_liner = FALSE,
  template = getOption("constructive_opts_template"),
  classes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_clip_+3A_x">x</code></td>
<td>
<p>An object, for <code>construct_multi()</code> a named list or an environment.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_...">...</code></td>
<td>
<p>Constructive options built with the <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> family of functions. See the &quot;Constructive options&quot;
section below.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_data">data</code></td>
<td>
<p>Named list or environment of objects we want to detect and mention by name (as opposed to
deparsing them further). Can also contain unnamed nested lists, environments, or
package names, in the latter case package exports and datasets will be considered.
In case of conflict, the last provided name is considered.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_pipe">pipe</code></td>
<td>
<p>Which pipe to use, either <code>"base"</code> or <code>"magrittr"</code>.
Defaults to <code>"base"</code> for R &gt;= 4.2, otherwise to <code>"magrittr"</code>.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_check">check</code></td>
<td>
<p>Boolean. Whether to check if the created code reproduces the object
using <code>waldo::compare()</code>.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_unicode_representation">unicode_representation</code></td>
<td>
<p>By default &quot;ascii&quot;, which means only ASCII characters
(code point &lt; 128) will be used to construct strings and variable names. This makes sure that
homoglyphs (different spaces and other identically displayed unicode characters)
are printed differently, and avoid possible unfortunate copy and paste
auto conversion issues. &quot;latin&quot; is more lax and uses all latin characters
(code point &lt; 256). &quot;character&quot; shows all characters, but not emojis. Finally
&quot;unicode&quot; displays all characters and emojis, which is what <code>dput()</code> does.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_escape">escape</code></td>
<td>
<p>Boolean. Whether to escape double quotes and backslashes. If <code>FALSE</code> we use
single quotes to surround strings (including variable and element names)
containing double quotes, and raw strings for strings that contain backslashes
and/or a combination of single and double quotes. Depending on
<code>unicode_representation</code> <code>escape = FALSE</code> cannot be applied on all strings.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_pedantic_encoding">pedantic_encoding</code></td>
<td>
<p>Boolean. Whether to mark strings with the &quot;unknown&quot; encoding
rather than an explicit native encoding (&quot;UTF-8&quot; or &quot;latin1&quot;) when it's
necessary to reproduce the binary representation exactly. This detail is
normally of very little significance. The reason why we're not pedantic by default is that
the constructed code might be different in the console and in snapshot
tests and reprexes due to the latter rounding some angles, and it would
be confusing for users.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_compare">compare</code></td>
<td>
<p>Parameters passed to <code>waldo::compare()</code>, built with <code>compare_options()</code>.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single line of code.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_template">template</code></td>
<td>
<p>A list of constructive options built with <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> functions,
they will be overriden by <code>...</code>. Use it to set a default
behavior for <code>{constructive}</code>.</p>
</td></tr>
<tr><td><code id="construct_clip_+3A_classes">classes</code></td>
<td>
<p>A character vector of classes for which to use idiomatic
constructors when available, we can provide a package instead of all its
classes, in the &quot;{pkg}&quot; form, and we can use a minus sign (inside the quotes)
to exclude rather than include. By default we use idiomatic constructors
whenever possible. The special values <code>"*none*"</code> and <code>"*base*"</code> can be used
to restrict the idiomatic construction to the objects. See <code>construct_dput()</code>
and <code>construct_base()</code> for wrappers around this feature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'constructive', invisibly. Called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
construct_clip(head(cars))

## End(Not run)
</code></pre>

<hr>
<h2 id='construct_diff'>Display diff of object definitions</h2><span id='topic+construct_diff'></span>

<h3>Description</h3>

<p>This calls <code>construct()</code> on two objects and compares the output using
<code>diffobj::diffChr()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_diff(
  target,
  current,
  ...,
  data = NULL,
  pipe = NULL,
  check = TRUE,
  compare = compare_options(),
  one_liner = FALSE,
  template = getOption("constructive_opts_template"),
  classes = NULL,
  mode = c("sidebyside", "auto", "unified", "context"),
  interactive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_diff_+3A_target">target</code></td>
<td>
<p>the reference object</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_current">current</code></td>
<td>
<p>the object being compared to <code>target</code></p>
</td></tr>
<tr><td><code id="construct_diff_+3A_...">...</code></td>
<td>
<p>Constructive options built with the <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> family of functions. See the &quot;Constructive options&quot;
section below.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_data">data</code></td>
<td>
<p>Named list or environment of objects we want to detect and mention by name (as opposed to
deparsing them further). Can also contain unnamed nested lists, environments, or
package names, in the latter case package exports and datasets will be considered.
In case of conflict, the last provided name is considered.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_pipe">pipe</code></td>
<td>
<p>Which pipe to use, either <code>"base"</code> or <code>"magrittr"</code>.
Defaults to <code>"base"</code> for R &gt;= 4.2, otherwise to <code>"magrittr"</code>.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_check">check</code></td>
<td>
<p>Boolean. Whether to check if the created code reproduces the object
using <code>waldo::compare()</code>.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_compare">compare</code></td>
<td>
<p>Parameters passed to <code>waldo::compare()</code>, built with <code>compare_options()</code>.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single line of code.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_template">template</code></td>
<td>
<p>A list of constructive options built with <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> functions,
they will be overriden by <code>...</code>. Use it to set a default
behavior for <code>{constructive}</code>.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_classes">classes</code></td>
<td>
<p>A character vector of classes for which to use idiomatic
constructors when available, we can provide a package instead of all its
classes, in the &quot;{pkg}&quot; form, and we can use a minus sign (inside the quotes)
to exclude rather than include. By default we use idiomatic constructors
whenever possible. The special values <code>"*none*"</code> and <code>"*base*"</code> can be used
to restrict the idiomatic construction to the objects. See <code>construct_dput()</code>
and <code>construct_base()</code> for wrappers around this feature.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_mode">mode</code>, <code id="construct_diff_+3A_interactive">interactive</code></td>
<td>
<p>passed to <code>diffobj::diffChr()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# some object print the same though they're different
# `construct_diff()` shows how they differ :
df1 &lt;- data.frame(a=1, b = "x")
df2 &lt;- data.frame(a=1L, b = "x", stringsAsFactors = TRUE)
attr(df2, "some_attribute") &lt;- "a value"
df1
df2
construct_diff(df1, df2)


# Those are made easy to compare
construct_diff(substr, substring)
construct_diff(month.abb, month.name)

# more examples borrowed from {waldo} package
construct_diff(c("a", "b", "c"), c("a", "B", "c"))
construct_diff(c("X", letters), c(letters, "X"))
construct_diff(list(factor("x")), list(1L))
construct_diff(df1, df2)
x &lt;- list(a = list(b = list(c = list(structure(1, e = 1)))))
y &lt;- list(a = list(b = list(c = list(structure(1, e = "a")))))
construct_diff(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='construct_dput'>Construct using only low level constructors</h2><span id='topic+construct_dput'></span><span id='topic+construct_base'></span>

<h3>Description</h3>


<ul>
<li> <p><code>construct_dput()</code> is a closer counterpart to <code>base::dput()</code> that doesn't
use higher level constructors such as <code>data.frame()</code> and <code>factor()</code>.
</p>
</li>
<li> <p><code>construct_base()</code> uses higher constructors, but only for the classes
maintained in the default base R packages. This includes <code>data.frame()</code>
and <code>factor()</code>, the S4 constructors from the 'method' package etc,
but not <code>data.table()</code> and other constructors for classes from other
packages.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>construct_dput(
  x,
  ...,
  data = NULL,
  pipe = NULL,
  check = NULL,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE,
  pedantic_encoding = FALSE,
  compare = compare_options(),
  one_liner = FALSE,
  template = getOption("constructive_opts_template")
)

construct_base(
  x,
  ...,
  data = NULL,
  pipe = NULL,
  check = NULL,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE,
  pedantic_encoding = FALSE,
  compare = compare_options(),
  one_liner = FALSE,
  template = getOption("constructive_opts_template")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_dput_+3A_x">x</code></td>
<td>
<p>An object, for <code>construct_multi()</code> a named list or an environment.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_...">...</code></td>
<td>
<p>Constructive options built with the <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> family of functions. See the &quot;Constructive options&quot;
section below.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_data">data</code></td>
<td>
<p>Named list or environment of objects we want to detect and mention by name (as opposed to
deparsing them further). Can also contain unnamed nested lists, environments, or
package names, in the latter case package exports and datasets will be considered.
In case of conflict, the last provided name is considered.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_pipe">pipe</code></td>
<td>
<p>Which pipe to use, either <code>"base"</code> or <code>"magrittr"</code>.
Defaults to <code>"base"</code> for R &gt;= 4.2, otherwise to <code>"magrittr"</code>.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_check">check</code></td>
<td>
<p>Boolean. Whether to check if the created code reproduces the object
using <code>waldo::compare()</code>.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_unicode_representation">unicode_representation</code></td>
<td>
<p>By default &quot;ascii&quot;, which means only ASCII characters
(code point &lt; 128) will be used to construct strings and variable names. This makes sure that
homoglyphs (different spaces and other identically displayed unicode characters)
are printed differently, and avoid possible unfortunate copy and paste
auto conversion issues. &quot;latin&quot; is more lax and uses all latin characters
(code point &lt; 256). &quot;character&quot; shows all characters, but not emojis. Finally
&quot;unicode&quot; displays all characters and emojis, which is what <code>dput()</code> does.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_escape">escape</code></td>
<td>
<p>Boolean. Whether to escape double quotes and backslashes. If <code>FALSE</code> we use
single quotes to surround strings (including variable and element names)
containing double quotes, and raw strings for strings that contain backslashes
and/or a combination of single and double quotes. Depending on
<code>unicode_representation</code> <code>escape = FALSE</code> cannot be applied on all strings.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_pedantic_encoding">pedantic_encoding</code></td>
<td>
<p>Boolean. Whether to mark strings with the &quot;unknown&quot; encoding
rather than an explicit native encoding (&quot;UTF-8&quot; or &quot;latin1&quot;) when it's
necessary to reproduce the binary representation exactly. This detail is
normally of very little significance. The reason why we're not pedantic by default is that
the constructed code might be different in the console and in snapshot
tests and reprexes due to the latter rounding some angles, and it would
be confusing for users.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_compare">compare</code></td>
<td>
<p>Parameters passed to <code>waldo::compare()</code>, built with <code>compare_options()</code>.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single line of code.</p>
</td></tr>
<tr><td><code id="construct_dput_+3A_template">template</code></td>
<td>
<p>A list of constructive options built with <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> functions,
they will be overriden by <code>...</code>. Use it to set a default
behavior for <code>{constructive}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions are valuable for object inspection, and might provide more
stable snapshots, since supporting more classes in the package means
the default output of <code>construct()</code> might change over time for some objects.
</p>
<p>To use higher level constructor from the base package itself, excluding
for instance <code>stats::ts()</code>, <code>utils::person()</code> or
<code>methods::classGeneratorFunction()</code>), we can call <code style="white-space: pre;">&#8288;construct(x, classes = "{base}"&#8288;</code>
</p>


<h3>Value</h3>

<p>An object of class 'constructive'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct_dput(head(iris, 2))
construct_base(head(iris, 2))
</code></pre>

<hr>
<h2 id='construct_dump'>Dump Constructed Code to a File</h2><span id='topic+construct_dump'></span>

<h3>Description</h3>

<p>An alternative to <code>base::dump()</code> using code built with <span class="pkg">constructive</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_dump(x, path, append = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_dump_+3A_x">x</code></td>
<td>
<p>A named list or an environment.</p>
</td></tr>
<tr><td><code id="construct_dump_+3A_path">path</code></td>
<td>
<p>File or connection to write to.</p>
</td></tr>
<tr><td><code id="construct_dump_+3A_append">append</code></td>
<td>
<p>If FALSE, will overwrite existing file. If TRUE, will append to existing file. In both cases, if the file does not exist a new file is created.</p>
</td></tr>
<tr><td><code id="construct_dump_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>construct_multi()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly, called for side effects.
</p>

<hr>
<h2 id='construct_issues'>Show constructive issues</h2><span id='topic+construct_issues'></span>

<h3>Description</h3>

<p>Usually called without arguments right after an imperfect code generation,
but can also be called on the 'constructive' object itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_issues(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_issues_+3A_x">x</code></td>
<td>
<p>An object built by <code>construct()</code>, if <code>NULL</code> the latest encountered
issues will be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with class &quot;waldo_compare&quot;
</p>

<hr>
<h2 id='construct_reprex'>construct_reprex</h2><span id='topic+construct_reprex'></span>

<h3>Description</h3>

<p><code>construct_reprex()</code> constructs all objects of the local environment,
or a caller environment <code>n</code> steps above. If <code>n &gt; 0</code> the function call
is also included in a comment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_reprex(..., n = 0, include_dotted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_reprex_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>construct_multi()</code></p>
</td></tr>
<tr><td><code id="construct_reprex_+3A_n">n</code></td>
<td>
<p>The number of steps to go up on the call stack</p>
</td></tr>
<tr><td><code id="construct_reprex_+3A_include_dotted">include_dotted</code></td>
<td>
<p>Whether to include names starting with dots, this includes
<code>.Random.seed</code> in the global environment and objects like <code>.Class</code> and
<code>.Generic</code> in the execution environments of S3 methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>construct_reprex()</code> doesn't call the {reprex} package. <code>construct_reprex()</code>
builds reproducible data while the reprex package build reproducible output
once you have the data.
</p>
<p><code>construct_reprex()</code> wraps <code>construct_multi()</code> and is thus able to construct
unevaluated arguments using <code>delayedAssign()</code>. This means we can construct
reprexes for functions that use Non Standard Evaluation.
</p>
<p>A useful trick is to use <code>options(error = recover)</code> to be able to inspect
frames on error, and use <code>construct_reprex()</code> from there to reproduce the
data state.
</p>
<p><code>construct_reprex()</code> might fail to reproduce the output of functions that refer
to environments other than their caller environment. We believe these are
very rare and that the simplicity is worth the rounded corners, but if you
encounter these limitations please do open a ticket on our issue tracker
at <code style="white-space: pre;">&#8288;https://github.com/cynkra/constructive/&#8288;</code> and we might expand the feature.
</p>


<h3>Value</h3>

<p>An object of class 'constructive'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+construct_multi">construct_multi()</a></code>
</p>

<hr>
<h2 id='construct_signature'>Construct a function's signature</h2><span id='topic+construct_signature'></span>

<h3>Description</h3>

<p>Construct a function's signature such as the one you can see right below in
the 'Usage' section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_signature(x, name = NULL, one_liner = FALSE, style = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_signature_+3A_x">x</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="construct_signature_+3A_name">name</code></td>
<td>
<p>The name of the function, by default we use the symbol provided to <code>x</code></p>
</td></tr>
<tr><td><code id="construct_signature_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse multi-line expressions on a single line using
semicolons.</p>
</td></tr>
<tr><td><code id="construct_signature_+3A_style">style</code></td>
<td>
<p>Boolean. Whether to give a class &quot;constructive_code&quot; on the output
for pretty printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string or a character vector, with a class &quot;constructive_code&quot; for pretty
printing if <code>style</code> is <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct_signature(lm)
</code></pre>

<hr>
<h2 id='constructive-global_options'>Global Options</h2><span id='topic+constructive-global_options'></span><span id='topic+constructive_opts_template'></span><span id='topic+constructive_pretty'></span><span id='topic+constructive_print_mode'></span>

<h3>Description</h3>

<p>Set these options to tweak {constructive}'s global behavior, to set them
permanently you can edit your <code>.RProfile</code> (<code>usethis::edit_r_profile()</code> might help).
</p>


<h3>Details</h3>


<ul>
<li><p> Set <code style="white-space: pre;">&#8288;options(constructive_print_mode = &lt;character&gt;)&#8288;</code> to change the default
value of the <code>print_mode</code> argument, of <code>print.constructive</code>, where <code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> is a vector
of strings among the following :
</p>

<ul>
<li> <p><code>"console"</code> : The default behavior, the code is printed in the console
</p>
</li>
<li> <p><code>"script"</code> : The code is copied to a new R script
</p>
</li>
<li> <p><code>"reprex"</code> : The code is shown in the viewer as a reprex,
the reprex (not only the code!) is also copied to the clipboard.
</p>
</li>
<li> <p><code>"clipboard"</code> : The constructed code is copied to the clipboard, if combined
with <code>"reprex"</code> this takes precedence (the reprex is showed in the viewer,
the code without output is copied to the clipboard)
</p>
</li></ul>

</li>
<li><p> Set <code style="white-space: pre;">&#8288;options(constructive_opts_template = &lt;list&gt;)&#8288;</code> to set default constructive options,
see documentation of the <code>template</code> arg in <code>?construct</code>
</p>
</li>
<li><p> Set <code>options(constructive_pretty = FALSE)</code> to disable pretty printing using
{prettycode}
</p>
</li></ul>


<hr>
<h2 id='deparse_call'>Deparse a language object</h2><span id='topic+deparse_call'></span>

<h3>Description</h3>

<p>An alternative to <code>base::deparse()</code> and <code>rlang::expr_deparse()</code> that
handles additional corner cases and fails when encountering tokens other than
symbols and syntactic literals where cited alternatives would produce non syntactic code.<br /><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deparse_call(
  call,
  one_liner = FALSE,
  pipe = FALSE,
  style = TRUE,
  collapse = !style,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE,
  pedantic_encoding = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deparse_call_+3A_call">call</code></td>
<td>
<p>A call.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse multi-line expressions on a single line using
semicolons.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_pipe">pipe</code></td>
<td>
<p>Boolean. Whether to use the base pipe to disentangle nested calls. This
works best on simple calls.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_style">style</code></td>
<td>
<p>Boolean. Whether to give a class &quot;constructive_code&quot; on the output
for pretty printing.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_collapse">collapse</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single string,
won't be directly visible if <code>style</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_unicode_representation">unicode_representation</code></td>
<td>
<p>By default &quot;ascii&quot;, which means only ASCII characters
(code point &lt; 128) will be used to construct strings and variable names. This makes sure that
homoglyphs (different spaces and other identically displayed unicode characters)
are printed differently, and avoid possible unfortunate copy and paste
auto conversion issues. &quot;latin&quot; is more lax and uses all latin characters
(code point &lt; 256). &quot;character&quot; shows all characters, but not emojis. Finally
&quot;unicode&quot; displays all characters and emojis, which is what <code>dput()</code> does.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_escape">escape</code></td>
<td>
<p>Boolean. Whether to escape double quotes and backslashes. If <code>FALSE</code> we use
single quotes to surround strings (including variable and element names)
containing double quotes, and raw strings for strings that contain backslashes
and/or a combination of single and double quotes. Depending on
<code>unicode_representation</code> <code>escape = FALSE</code> cannot be applied on all strings.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_pedantic_encoding">pedantic_encoding</code></td>
<td>
<p>Boolean. Whether to mark strings with the &quot;unknown&quot; encoding
rather than an explicit native encoding (&quot;UTF-8&quot; or &quot;latin1&quot;) when it's
necessary to reproduce the binary representation exactly. This detail is
normally of very little significance. The reason why we're not pedantic by default is that
the constructed code might be different in the console and in snapshot
tests and reprexes due to the latter rounding some angles, and it would
be confusing for users.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string or a character vector, with a class &quot;constructive_code&quot; for pretty
printing if <code>style</code> is <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expr &lt;- quote(foo(bar({this; that}, 1)))
deparse_call(expr)
deparse_call(expr, one_liner = TRUE)
deparse_call(expr, pipe = TRUE)
deparse_call(expr, style = FALSE)
</code></pre>

<hr>
<h2 id='extend-constructive'>Extend constructive</h2><span id='topic+extend-constructive'></span>

<h3>Description</h3>

<p>We export a collection of functions that can be used to design custom methods for
<a href="#topic+.cstr_construct">.cstr_construct</a>() or custom constructors for a given method.
</p>

<ul>
<li> <p><a href="#topic+.cstr_new_class">.cstr_new_class</a>() : Open template to support a new class
</p>
</li>
<li> <p><a href="#topic+.cstr_new_constructor">.cstr_new_constructor</a>() : Open template to implement a new constructor
</p>
</li>
<li> <p><a href="#topic+.cstr_construct">.cstr_construct</a>() : Low level generic for object construction code generation
</p>
</li>
<li> <p><a href="#topic+.cstr_repair_attributes">.cstr_repair_attributes</a>()' : Helper to repair attributes of objects
</p>
</li>
<li> <p><a href="#topic+.cstr_options">.cstr_options</a>() : Define and check options to pass to custom constructors
</p>
</li>
<li> <p><a href="#topic+.cstr_apply">.cstr_apply</a>() : Build recursively the arguments passed to your constructor
</p>
</li>
<li> <p><a href="#topic+.cstr_wrap">.cstr_wrap</a>() : Wrap argument code in function code (rarely needed)
</p>
</li>
<li> <p><a href="#topic+.cstr_pipe">.cstr_pipe</a>() : Pipe a call to another (rarely needed)
</p>
</li>
<li> <p><a href="#topic+.cstr_combine_errors">.cstr_combine_errors</a>() : helper function report several errors
at once when relevant
</p>
</li></ul>


<hr>
<h2 id='opts_array'>Constructive options for arrays</h2><span id='topic+opts_array'></span>

<h3>Description</h3>

<p>These options will be used on arrays. Note that arrays can be built on top of
vectors, lists or expressions. Canonical arrays have an implicit class &quot;array&quot;
shown by <code>class()</code> but &quot;array&quot; is not part of the class attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_array(constructor = c("array", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_array_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_array_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"array"</code> (default): Use the <code>array()</code> function
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_array&gt;
</p>

<hr>
<h2 id='opts_AsIs'>Constructive options for the class <code>AsIs</code></h2><span id='topic+opts_AsIs'></span>

<h3>Description</h3>

<p>These options will be used on objects of class <code>AsIs</code>. <code>AsIs</code> objects are
created with <code>I()</code> which only prepends <code>"AsIs"</code> to the class attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_AsIs(constructor = c("I", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_AsIs_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_AsIs_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"I"</code> (default): Use the <code>I()</code> function
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_AsIs&gt;
</p>

<hr>
<h2 id='opts_atomic'>Constructive options for atomic types</h2><span id='topic+opts_atomic'></span>

<h3>Description</h3>

<p>These options will be used on atomic types (&quot;logical&quot;, &quot;integer&quot;, &quot;numeric&quot;, &quot;complex&quot;, &quot;character&quot; and &quot;raw&quot;).
They can also be directly provided to atomic types through their own <code style="white-space: pre;">&#8288;opts_*()&#8288;</code>
function, and in this case the latter will have precedence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_atomic(
  ...,
  trim = NULL,
  fill = c("default", "rlang", "+", "...", "none"),
  compress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_atomic_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_atomic_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_atomic_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements.</p>
</td></tr>
<tr><td><code id="opts_atomic_+3A_compress">compress</code></td>
<td>
<p>Boolean. If <code>TRUE</code> instead of <code>c()</code> Use <code>seq()</code>, <code>rep()</code>
when relevant to simplify the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>trim</code> is provided, depending on <code>fill</code> we will present trimmed elements as followed:
</p>

<ul>
<li> <p><code>"default"</code> : Use default atomic constructors, so for instance <code>c("a", "b", "c")</code> might become <code>c("a", character(2))</code>.
</p>
</li>
<li> <p><code>"rlang"</code> : Use rlang atomic constructors, so for instance <code>c("a", "b", "c")</code> might become <code>c("a", rlang::new_character(2))</code>,
these <code>rlang</code> constructors create vectors of <code>NAs</code>, so it's different from the default option.
</p>
</li>
<li> <p><code>"+"</code>: Use unary <code>+</code>, so for instance <code>c("a", "b", "c")</code> might become <code>c("a", +2)</code>.
</p>
</li>
<li> <p><code>"..."</code>: Use <code>...</code>, so for instance <code>c("a", "b", "c")</code> might become <code>c("a", ...)</code>
</p>
</li>
<li> <p><code>"none"</code>: Don't represent trimmed elements.
</p>
</li></ul>

<p>Depending on the case some or all of the choices above might generate code that
cannot be executed. The 2 former options above are the most likely to succeed
and produce an output of the same type and dimensions recursively. This would
at least be the case for data frame.
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_atomic&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct(iris, opts_atomic(trim = 2), check = FALSE) # fill = "default"
construct(iris, opts_atomic(trim = 2, fill = "rlang"), check = FALSE)
construct(iris, opts_atomic(trim = 2, fill = "+"), check = FALSE)
construct(iris, opts_atomic(trim = 2, fill = "..."), check = FALSE)
construct(iris, opts_atomic(trim = 2, fill = "none"), check = FALSE)
construct(iris, opts_atomic(trim = 2, fill = "none"), check = FALSE)
x &lt;- c("a a", "a\U000000A0a", "a\U00002002a", "\U430 \U430")
construct(x, opts_atomic(unicode_representation = "unicode"))
construct(x, opts_atomic(unicode_representation = "character"))
construct(x, opts_atomic(unicode_representation = "latin"))
construct(x, opts_atomic(unicode_representation = "ascii"))
</code></pre>

<hr>
<h2 id='opts_blob'>Constructive options for class 'blob'</h2><span id='topic+opts_blob'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'blob'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_blob(constructor = c("blob", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_blob_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_blob_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"blob"</code> (default): Use <code>blob::blob()</code> on a raw object.
</p>

<ul>
<li> <p><code>"new_blob"</code> (default): Use <code>blob::new_blob()</code> on a list of raw objects.
</p>
</li></ul>

</li>
<li> <p><code>"as.blob"</code> : Use <code>blob::as_blob()</code> on a character vector
</p>
</li></ul>

<p>Use <code>opts_raw()</code> and <code>opts_character()</code> to tweak the construction of raw or
character objects constructed as part of the blob construction.
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_blob&gt;
</p>

<hr>
<h2 id='opts_character'>Constructive options for type 'character'</h2><span id='topic+opts_character'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'character'. This type has
a single native constructor, but some additional options can be set.
</p>
<p><code>unicode_representation</code> and <code>escape</code> are usually better set in the main
function (<code>construct()</code> or other) so they apply not only on strings but on
symbols and argument names as well.
</p>
<p>To set options on all atomic types at once see <a href="#topic+opts_atomic">opts_atomic</a>().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_character(
  constructor = c("default"),
  ...,
  trim = NULL,
  fill = c("default", "rlang", "+", "...", "none"),
  compress = TRUE,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_character_+3A_constructor">constructor</code></td>
<td>
<p>String. Method used to construct the object, often the name
of a function.</p>
</td></tr>
<tr><td><code id="opts_character_+3A_...">...</code></td>
<td>
<p>Constructive options built with the <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> family of functions. See the &quot;Constructive options&quot;
section below.</p>
</td></tr>
<tr><td><code id="opts_character_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_character_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements. See <code>?opts_atomic</code></p>
</td></tr>
<tr><td><code id="opts_character_+3A_compress">compress</code></td>
<td>
<p>Boolean. If <code>TRUE</code> instead of <code>c()</code> Use <code>seq()</code>, <code>rep()</code>
when relevant to simplify the output.</p>
</td></tr>
<tr><td><code id="opts_character_+3A_unicode_representation">unicode_representation</code></td>
<td>
<p>By default &quot;ascii&quot;, which means only ASCII characters
(code point &lt; 128) will be used to construct strings and variable names. This makes sure that
homoglyphs (different spaces and other identically displayed unicode characters)
are printed differently, and avoid possible unfortunate copy and paste
auto conversion issues. &quot;latin&quot; is more lax and uses all latin characters
(code point &lt; 256). &quot;character&quot; shows all characters, but not emojis. Finally
&quot;unicode&quot; displays all characters and emojis, which is what <code>dput()</code> does.</p>
</td></tr>
<tr><td><code id="opts_character_+3A_escape">escape</code></td>
<td>
<p>Boolean. Whether to escape double quotes and backslashes. If <code>FALSE</code> we use
single quotes to surround strings (including variable and element names)
containing double quotes, and raw strings for strings that contain backslashes
and/or a combination of single and double quotes. Depending on
<code>unicode_representation</code> <code>escape = FALSE</code> cannot be applied on all strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_character&gt;
</p>

<hr>
<h2 id='opts_classGeneratorFunction'>Constructive options for class 'classGeneratorFunction'</h2><span id='topic+opts_classGeneratorFunction'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'classGeneratorFunction'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_classGeneratorFunction(constructor = c("setClass"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_classGeneratorFunction_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_classGeneratorFunction_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_classGeneratorFunction&gt;
</p>

<hr>
<h2 id='opts_classPrototypeDef'>Constructive options for class 'classPrototypeDef'</h2><span id='topic+opts_classPrototypeDef'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'classPrototypeDef'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_classPrototypeDef(constructor = c("prototype"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_classPrototypeDef_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_classPrototypeDef_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_classPrototypeDef&gt;
</p>

<hr>
<h2 id='opts_classRepresentation'>Constructive options for class 'classRepresentation'</h2><span id='topic+opts_classRepresentation'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'classRepresentation'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_classRepresentation(constructor = c("getClassDef"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_classRepresentation_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_classRepresentation_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_classRepresentation&gt;
</p>

<hr>
<h2 id='opts_complex'>Constructive options for type 'complex'</h2><span id='topic+opts_complex'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'complex'. This type has
a single native constructor, but some additional options can be set.
</p>
<p>To set options on all atomic types at once see <a href="#topic+opts_atomic">opts_atomic</a>().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_complex(
  constructor = c("default"),
  ...,
  trim = NULL,
  fill = c("default", "rlang", "+", "...", "none"),
  compress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_complex_+3A_constructor">constructor</code></td>
<td>
<p>String. Method used to construct the object, often the name
of a function.</p>
</td></tr>
<tr><td><code id="opts_complex_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_complex_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_complex_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements. See <code>?opts_atomic</code></p>
</td></tr>
<tr><td><code id="opts_complex_+3A_compress">compress</code></td>
<td>
<p>Boolean. If <code>TRUE</code> instead of <code>c()</code> Use <code>seq()</code>, <code>rep()</code>
when relevant to simplify the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_complex&gt;
</p>

<hr>
<h2 id='opts_constructive_options'>Constructive options for the class <code>constructive_options</code></h2><span id='topic+opts_constructive_options'></span>

<h3>Description</h3>

<p>These options will be used on objects of class <code>constructive_options</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_constructive_options(constructor = c("opts", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_constructive_options_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_constructive_options_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"opts"</code> : Use the relevant <code style="white-space: pre;">&#8288;constructive::opts_?()&#8288;</code> function.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_constructive_options&gt;
</p>

<hr>
<h2 id='opts_data.frame'>Constructive options for class 'data.frame'</h2><span id='topic+opts_data.frame'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'data.frame'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_data.frame(
  constructor = c("data.frame", "read.table", "next", "list"),
  ...,
  recycle = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_data.frame_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_data.frame_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_data.frame_+3A_recycle">recycle</code></td>
<td>
<p>Boolean. For the <code>"data.frame"</code> constructor. Whether to recycle
scalars to compress the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"data.frame"</code> (default): Wrap the column definitions in a <code>data.frame()</code> call. If some
columns are lists or data frames, we wrap the column definitions in <code>tibble::tibble()</code>.
then use <code>as.data.frame()</code>.
</p>
</li>
<li> <p><code>"read.table"</code> : We build the object using <code>read.table()</code> if possible, or fall
back to <code>data.frame()</code>.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_data.frame&gt;
</p>

<hr>
<h2 id='opts_data.table'>Constructive options for class 'data.table'</h2><span id='topic+opts_data.table'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'data.table'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_data.table(
  constructor = c("data.table", "next", "list"),
  ...,
  selfref = FALSE,
  recycle = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_data.table_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_data.table_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_data.table_+3A_selfref">selfref</code></td>
<td>
<p>Boolean. Whether to include the <code>.internal.selfref</code> attribute. It's
probably not useful, hence the default, <code>waldo::compare()</code> is used to assess the output
fidelity and doesn't check it, but if you really need to generate code that builds
an object <code>identical()</code> to the input you'll need to set this to <code>TRUE</code>.#'</p>
</td></tr>
<tr><td><code id="opts_data.table_+3A_recycle">recycle</code></td>
<td>
<p>Boolean. Whether to recycle scalars to compress the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"data.table"</code> (default): Wrap the column definitions in a <code>data.table()</code> call.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_data.table&gt;
</p>

<hr>
<h2 id='opts_Date'>Constructive options class 'Date'</h2><span id='topic+opts_Date'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'date'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_Date(
  constructor = c("as.Date", "as_date", "date", "new_date", "as.Date.numeric",
    "as_date.numeric", "next", "double"),
  ...,
  origin = "1970-01-01"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_Date_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_Date_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_Date_+3A_origin">origin</code></td>
<td>
<p>Origin to be used, ignored when irrelevant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.Date"</code> (default): We wrap a character vector with <code>as.Date()</code>, if the date
is infinite it cannot be converted to character and we wrap a numeric vector and
provide an <code>origin</code> argument.
</p>
</li>
<li> <p><code>"as_date"</code> : Similar as above but using <code>lubridate::as_date()</code>, the only difference is
that we never need to supply <code>origin</code>.
</p>
</li>
<li> <p><code>"date"</code> : Similar as above but using <code>lubridate::date()</code>, it doesn't support
infinite dates so we fall back on <code>lubridate::as_date()</code> when we encounter them.
</p>
</li>
<li> <p><code>"new_date"</code> : We wrap a numeric vector with <code>vctrs::new_date()</code>
</p>
</li>
<li> <p><code>"as.Date.numeric"</code> : We wrap a numeric vector with <code>as.Date()</code> and use the
provided <code>origin</code>
</p>
</li>
<li> <p><code>"as_date.numeric"</code> : Same as above but using <code>lubridate::as_date()</code> and use the
provided <code>origin</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"double"</code> : We define as an double vector and repair attributes
</p>
</li></ul>

<p>If the data is not appropriate for a constructor we fall back to another one
appropriately.
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_Date&gt;
</p>

<hr>
<h2 id='opts_dm'>Constructive options class 'dm'</h2><span id='topic+opts_dm'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'dm'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_dm(constructor = c("dm", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_dm_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_dm_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"dm"</code> (default): We use <code>dm::dm()</code> and other functions from <span class="pkg">dm</span> to adjust the content.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_dm&gt;
</p>

<hr>
<h2 id='opts_dots'>Constructive options for type '...'</h2><span id='topic+opts_dots'></span>

<h3>Description</h3>

<p>These options will be used on objects of type '...'. These are rarely encountered
in practice. By default this function is useless as nothing can be set, this
is provided in case users want to extend the method with other constructors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_dots(constructor = c("default"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_dots_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_dots_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"default"</code> : We use the construct <code style="white-space: pre;">&#8288;(function(...) get(\"...\"))(a = x, y)&#8288;</code>
which we evaluate in the correct environment.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_dots&gt;
</p>

<hr>
<h2 id='opts_double'>Constructive options for type 'double'</h2><span id='topic+opts_double'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'double'. This type has
a single native constructor, but some additional options can be set.
</p>
<p>To set options on all atomic types at once see <a href="#topic+opts_atomic">opts_atomic</a>().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_double(
  constructor = c("default"),
  ...,
  trim = NULL,
  fill = c("default", "rlang", "+", "...", "none"),
  compress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_double_+3A_constructor">constructor</code></td>
<td>
<p>String. Method used to construct the object, often the name
of a function.</p>
</td></tr>
<tr><td><code id="opts_double_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_double_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_double_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements. See <code>?opts_atomic</code></p>
</td></tr>
<tr><td><code id="opts_double_+3A_compress">compress</code></td>
<td>
<p>Boolean. If <code>TRUE</code> instead of <code>c()</code> Use <code>seq()</code>, <code>rep()</code>
when relevant to simplify the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_double&gt;
</p>

<hr>
<h2 id='opts_environment'>Constructive options for type 'environment'</h2><span id='topic+opts_environment'></span>

<h3>Description</h3>

<p>Environments use reference semantics, they cannot be copied.
An attempt to copy an environment would indeed yield a different environment and <code>identical(env, copy)</code> would be <code>FALSE</code>.<br />
Moreover most environments have a parent (exceptions are <code>emptyenv()</code> and some
rare cases where the parent is <code>NULL</code>) and thus to copy the environment we'd
have to have a way to point to the parent, or copy it too. <br />
For this reason environments are <span class="pkg">constructive</span>'s cryptonite. They make some objects
impossible to reproduce exactly. And since every function or formula has one they're hard to
avoid. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_environment(
  constructor = c(".env", "list2env", "as.environment", "new.env", "topenv",
    "new_environment", "predefine"),
  ...,
  recurse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_environment_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the
environment, see <strong>Constructors</strong> section.</p>
</td></tr>
<tr><td><code id="opts_environment_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_environment_+3A_recurse">recurse</code></td>
<td>
<p>Boolean. Only considered if <code>constructor</code> is <code>"list2env"</code> or
<code>"new_environment"</code>. Whether to attempt to recreate all parent environments
until a known environment is found, if <code>FALSE</code> (the default) we will use
<code>topenv()</code> to find a known ancestor to set as the parent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some case we can build code that points to a specific environment, namely:
</p>

<ul>
<li> <p><code>.GlobalEnv</code>, <code>.BaseNamespaceEnv</code>, <code>baseenv()</code> and <code>emptyenv()</code> are used to construct
the global environment, the base namespace, the base package environment and the empty
environment
</p>
</li>
<li><p> Namespaces are constructed using <code>asNamespace("pkg")</code>
</p>
</li>
<li><p> Package environments are constructed using <code>as.environment("package:pkg")</code>
</p>
</li>
<li><p> &quot;imports&quot; environments are constructed with <code>parent.env(asNamespace("pkg"))</code>
</p>
</li>
<li><p> &quot;lazydata&quot; environments are constructed with <code>getNamespaceInfo("pkg", "lazydata")</code>
</p>
</li></ul>

<p>By default For other environments we use <span class="pkg">constructive</span>'s function <code>constructive::.env()</code>, it fetches
the environment from its memory address and provides as additional information
the sequence of parents until we reach a special environment (those enumerated above).
The advantage of this approach is that it's readable and that the object is accurately reproduced.
The inconvenient is that it's not stable between sessions. If an environment has a <code>NULL</code> parent it's always constructed
with <code>constructive::.env()</code>, whatever the choice of the constructor.
</p>
<p>Often however we wish to be able to reproduce from scratch a similar environment,
so that we might run the constructed code later in a new session. We offer different
different options to do this, with different trade-offs regarding accuracy and verbosity.
</p>
<p>{constructive} will not signal any difference if it can reproduce an equivalent environment,
defined as containing the same values and having a same or equivalent parent.<br />
</p>
<p>See also the <code>ignore_function_env</code> argument in <code>?compare_options</code>, which disables the check
of environments of function.
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>


<h3>Constructors</h3>

<p>We might set the <code>constructor</code> argument to:
</p>

<ul>
<li> <p><code>".env"</code> (default): use <code>constructive::.env()</code> to construct the environment from
its memory address.
</p>
</li></ul>


<ul>
<li> <p><code>"list2env"</code>: We construct the environment as a list then
use <code>base::list2env()</code> to convert it to an environment and assign it a parent. By
default we will use <code>base::topenv()</code> to construct a parent. If <code>recurse</code> is <code>TRUE</code>
the parent will be built recursively so all ancestors will be created until
we meet a known environment, this might be verbose and will fail if environments
are nested too deep or have a circular relationship. If the environment is empty we use <code>new.env(parent=)</code>
for a more economic syntax.
</p>
</li>
<li> <p><code>"new_environment"</code> : Similar to the above, but using <code>rlang::new_environment()</code>.
</p>
</li>
<li> <p><code>"new.env"</code> : All environments will be recreated with the code <code>"base::new.env()"</code>,
without argument, effectively creating an empty environment child of
the local (often global) environment. This is enough in cases where the environment
doesn't matter (or matters as long as it inherits from the local environment),
as is often the case with formulas. <code>recurse</code> is ignored.
</p>
</li>
<li> <p><code>"as.environment"</code> : we attempt to construct the environment as a list and use
<code>base::as.environment()</code> on top of it, as in <code>as.environment(list(a=1, b=2))</code>, it will
contain the same variables as the original environment but the parent will be the
<code>emptyenv()</code>. <code>recurse</code> is ignored.
</p>
</li>
<li> <p><code>"topenv"</code> : we construct <code>base::topenv(x)</code>, see <code>?topenv</code>. <code>recurse</code> is ignored.
This is the most accurate we can be when constructing only special environments.
</p>
</li>
<li> <p><code>"predefine"</code> : Building environments from scratch using the above methods
can be verbose, sometimes redundant and sometimes even impossible due to
circularity (e.g. an environment referencing itself).  With <code>"predefine"</code>
we define the environments and their content  above the object returning
call, using placeholder names <code>..env.1..</code>, <code>..env.2..</code> etc.
The caveat is that the created code won't be a single call
and will create objects in the workspace. <code>recurse</code> is ignored.
</p>
</li></ul>


<hr>
<h2 id='opts_externalptr'>Constructive options for type 'externalptr'</h2><span id='topic+opts_externalptr'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'externalptr'. By default this
function is useless as nothing can be set, this is provided in case users wan
to extend the method with other constructors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_externalptr(constructor = c("default"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_externalptr_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_externalptr_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"default"</code> : We use a special function from the constructive
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_externalptr&gt;
</p>

<hr>
<h2 id='opts_factor'>Constructive options for class 'factor'</h2><span id='topic+opts_factor'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'factor'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_factor(
  constructor = c("factor", "as_factor", "new_factor", "next", "integer"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_factor_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_factor_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"factor"</code> (default): Build the object using <code>factor()</code>, levels won't
be defined explicitly if they are in alphabetical order (locale dependent!)
</p>
</li>
<li> <p><code>"as_factor"</code> : Build the object using <code>forcats::as_factor()</code> whenever
possible, i.e. when levels are defined in order of appearance in the vector. Otherwise falls back to <code>"factor"</code> constructor.
</p>
</li>
<li> <p><code>"new_factor"</code> : Build the object using <code>vctrs::new_factor()</code>. Levels are
always defined explicitly.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"integer"</code> : We define as an integer vector and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_formula'>Constructive options for formulas</h2><span id='topic+opts_formula'></span>

<h3>Description</h3>

<p>These options will be used on formulas, defined as calls to <code>~</code>, regardless
of their <code>"class"</code> attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_formula(
  constructor = c("default", "formula", "as.formula", "new_formula", "next"),
  ...,
  environment = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_formula_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_formula_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_formula_+3A_environment">environment</code></td>
<td>
<p>Boolean. Whether to attempt to construct the environment, if
it makes a difference to construct it.
</p>
<p>Depending on <code>constructor</code>, we construct the formula as follows:
</p>

<ul>
<li> <p><code>"default"</code>: We construct the formula in the most common way using the <code>~</code>
operator.
</p>
</li>
<li> <p><code>"formula"</code> : deparse the formula as a string and use <code>base::formula()</code> on top of it.
</p>
</li>
<li> <p><code>"as.formula"</code> : Same as above, but using <code>base::as.formula()</code>.
</p>
</li>
<li> <p><code>"new_formula"</code> : extract both sides of the formula as separate language objects
and feed them to <code>rlang::new_formula()</code>, along with the reconstructed environment
if relevant.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_formula&gt;
</p>

<hr>
<h2 id='opts_function'>Constructive options for functions</h2><span id='topic+opts_function'></span>

<h3>Description</h3>

<p>These options will be used on functions, i.e. objects of type &quot;closure&quot;, &quot;special&quot; and &quot;builtin&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_function(
  constructor = c("function", "as.function", "new_function"),
  ...,
  environment = TRUE,
  srcref = FALSE,
  trim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_function_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_function_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_function_+3A_environment">environment</code></td>
<td>
<p>Boolean. Whether to reconstruct the function's environment.</p>
</td></tr>
<tr><td><code id="opts_function_+3A_srcref">srcref</code></td>
<td>
<p>Boolean. Whether to attempt to reconstruct the function's srcref.</p>
</td></tr>
<tr><td><code id="opts_function_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of lines showed in the body before it's trimmed,
replacing code with <code>...</code>. Note that it will necessarily produce code that doesn't
reproduce the input, but it will parse and evaluate without failure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"function"</code> (default): Build the object using a standard <code>function() {}</code>
definition. This won't set the environment by default, unless <code>environment</code>
is set to <code>TRUE</code>. If a srcref is available, if this srcref matches the function's
definition, and if <code>trim</code> is left <code>NULL</code>, the code is returned from using the srcref,
so comments will be shown in the output of <code>construct()</code>. In the rare case
where the ast body of the function contains non syntactic nodes this constructor
cannot be used and falls back to the <code>"as.function"</code> constructor.
</p>
</li>
<li> <p><code>"as.function"</code> : Build the object using a <code>as.function()</code> call.
back to <code>data.frame()</code>.
</p>
</li>
<li> <p><code>"new_function"</code> : Build the object using a <code>rlang::new_function()</code> call.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_function&gt;
</p>

<hr>
<h2 id='opts_ggplot'>Constructive options for class 'ggplot'</h2><span id='topic+opts_ggplot'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'ggplot'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_ggplot(constructor = c("ggplot", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_ggplot_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_ggplot_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"ggplot"</code> (default): Use <code>ggplot2::ggplot()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_ggplot&gt;
</p>

<hr>
<h2 id='opts_grouped_df'>Constructive options for class 'grouped_df'</h2><span id='topic+opts_grouped_df'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'grouped_df'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_grouped_df(constructor = c("default", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_grouped_df_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_grouped_df_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : We define as an list object and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_hexmode'>Constructive options for class 'hexmode'</h2><span id='topic+opts_hexmode'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'hexmode'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_hexmode(constructor = c("as.hexmode", "next"), ..., integer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_hexmode_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_hexmode_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_hexmode_+3A_integer">integer</code></td>
<td>
<p>Whether to use <code>as.hexmode()</code> on integer rather than character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.hexmode"</code> (default): We build the object using <code>as.hexmode()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_hexmode&gt;
</p>

<hr>
<h2 id='opts_integer'>Constructive options for type 'integer'</h2><span id='topic+opts_integer'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'integer'. This type has
a single native constructor, but some additional options can be set.
</p>
<p>To set options on all atomic types at once see <a href="#topic+opts_atomic">opts_atomic</a>().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_integer(
  constructor = c("default"),
  ...,
  trim = NULL,
  fill = c("default", "rlang", "+", "...", "none"),
  compress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_integer_+3A_constructor">constructor</code></td>
<td>
<p>String. Method used to construct the object, often the name
of a function.</p>
</td></tr>
<tr><td><code id="opts_integer_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_integer_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_integer_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements. See <code>?opts_atomic</code></p>
</td></tr>
<tr><td><code id="opts_integer_+3A_compress">compress</code></td>
<td>
<p>Boolean. If <code>TRUE</code> instead of <code>c()</code> Use <code>seq()</code>, <code>rep()</code>
when relevant to simplify the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_integer&gt;
</p>

<hr>
<h2 id='opts_integer64'>Constructive options for class 'integer64'</h2><span id='topic+opts_integer64'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'integer64'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_integer64(constructor = c("as.integer64", "next", "double"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_integer64_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_integer64_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.integer64"</code> (default): Build the object using <code>as.integer64()</code> on a
character vector.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"double"</code> : We define as an atomic vector and repair attributes.
</p>
</li></ul>

<p>We don't recommend the &quot;next&quot; and &quot;double&quot; constructors for this class as
they give incorrect results on negative or <code>NA</code> &quot;integer64&quot; objects
due to some quirks in the implementation of the 'bit64' package.
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_integer64&gt;
</p>

<hr>
<h2 id='opts_language'>Constructive options for type 'language'</h2><span id='topic+opts_language'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'language'. By default this
function is useless as nothing can be set, this is provided in case users want
to extend the method with other constructors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_language(constructor = c("default"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_language_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_language_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"default"</code> : We use constructive's deparsing algorithm on attributeless calls,
and use <code>as.call()</code> on other language elements when attributes need to be constructed.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_language&gt;
</p>

<hr>
<h2 id='opts_Layer'>Constructive options for class 'Layer' (ggplot2)</h2><span id='topic+opts_Layer'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'Layer'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_Layer(constructor = c("default", "layer", "next", "environment"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_Layer_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_Layer_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"default"</code> : We attempt to use the function originally used to create the
plot.
</p>
</li>
<li> <p><code>"layer"</code> : We use the <code>ggplot2::layer()</code> function
</p>
</li>
<li> <p><code>"environment"</code> : Reconstruct the object using the general environment method
(which can be itself tweaked using <code>opts_environment()</code>)
</p>
</li></ul>

<p>The latter constructor is the only one that reproduces the object exactly
since Layers are environments and environments can't be exactly copied (see <code>?opts_environment</code>)
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_Layer&gt;
</p>

<hr>
<h2 id='opts_list'>Constructive options for type 'list'</h2><span id='topic+opts_list'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'list'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_list(
  constructor = c("list", "list2"),
  ...,
  trim = NULL,
  fill = c("vector", "new_list", "+", "...", "none")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_list_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_list_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_list_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_list_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"list"</code> (default): Build the object by calling <code>list()</code>.
</p>
</li>
<li> <p><code>"list2"</code>: Build the object by calling <code>rlang::list2()</code>, the only difference with
the above is that we keep a trailing comma when the list is not trimmed and the call
spans several lines.
</p>
</li></ul>

<p>If <code>trim</code> is provided, depending on <code>fill</code> we will present trimmed elements as followed:
</p>

<ul>
<li> <p><code>"vector"</code> (default): Use <code>vector()</code>, so for instance <code>list("a", "b", "c")</code> might become <code>c(list("a"), vector("list", 2))</code>.
</p>
</li>
<li> <p><code>"new_list"</code>: Use <code>rlang::new_list()</code>, so for instance <code>list("a", "b", "c")</code> might become <code>c(list("a"), rlang::new_list(2))</code>.
</p>
</li>
<li> <p><code>"+"</code>: Use unary <code>+</code>, so for instance <code>list("a", "b", "c")</code> might become <code>list("a", +2)</code>.
</p>
</li>
<li> <p><code>"..."</code>: Use <code>...</code>, so for instance <code>list("a", "b", "c")</code> might become <code>list("a", ...)</code>
</p>
</li>
<li> <p><code>"none"</code>: Don't represent trimmed elements.
</p>
</li></ul>

<p>When <code>trim</code> is used the output is parsable but might not be possible to evaluate,
especially with <code>fill = "..."</code>. In that case you might want to set <code>check = FALSE</code>
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_list&gt;
</p>

<hr>
<h2 id='opts_logical'>Constructive options for type 'logical'</h2><span id='topic+opts_logical'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'logical'. This type has
a single native constructor, but some additional options can be set.
</p>
<p>To set options on all atomic types at once see <a href="#topic+opts_atomic">opts_atomic</a>().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_logical(
  constructor = c("default"),
  ...,
  trim = NULL,
  fill = c("default", "rlang", "+", "...", "none"),
  compress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_logical_+3A_constructor">constructor</code></td>
<td>
<p>String. Method used to construct the object, often the name
of a function.</p>
</td></tr>
<tr><td><code id="opts_logical_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_logical_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_logical_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements. See <code>?opts_atomic</code></p>
</td></tr>
<tr><td><code id="opts_logical_+3A_compress">compress</code></td>
<td>
<p>Boolean. If <code>TRUE</code> instead of <code>c()</code> Use <code>seq()</code>, <code>rep()</code>
when relevant to simplify the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_logical&gt;
</p>

<hr>
<h2 id='opts_matrix'>Constructive options for matrices</h2><span id='topic+opts_matrix'></span>

<h3>Description</h3>

<p>Matrices are atomic vectors, lists, or objects of type <code>"expression"</code> with a <code>"dim"</code>
attributes of length 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_matrix(constructor = c("matrix", "array", "cbind", "rbind", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_matrix_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_matrix_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"matrix"</code> : We use <code>matrix()</code>
</p>
</li>
<li> <p><code>"array"</code> : We use <code>array()</code>
</p>
</li>
<li> <p><code>"cbind"</code>,<code>"rbind"</code> : We use <code>cbind()</code> or <code>"rbind()"</code>, this makes named
columns and rows easier to read.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"array"</code>
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_matrix&gt;
</p>

<hr>
<h2 id='opts_mts'>Constructive options for time-series objets</h2><span id='topic+opts_mts'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"ts"</code> : We use <code>ts()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"atomic"</code>
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_mts(constructor = c("ts", "next", "atomic"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_mts_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_mts_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_mts&gt;
</p>

<hr>
<h2 id='opts_numeric_version'>Constructive options for numeric_version</h2><span id='topic+opts_numeric_version'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"numeric_version"</code> : We use <code>numeric_version()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"list"</code>
</p>
</li>
<li> <p><code>"list"</code> : We define as a list and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_numeric_version(constructor = c("numeric_version", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_numeric_version_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_numeric_version_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_numeric_version&gt;
</p>

<hr>
<h2 id='opts_octmode'>Constructive options for class 'octmode'</h2><span id='topic+opts_octmode'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'octmode'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_octmode(constructor = c("as.octmode", "next"), ..., integer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_octmode_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_octmode_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_octmode_+3A_integer">integer</code></td>
<td>
<p>Whether to use <code>as.octmode()</code> on integer rather than character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.octmode"</code> (default): We build the object using <code>as.octmode()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_octmode&gt;
</p>

<hr>
<h2 id='opts_ordered'>Constructive options for class 'ordered'</h2><span id='topic+opts_ordered'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'ordered'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_ordered(
  constructor = c("ordered", "factor", "new_ordered", "next", "integer"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_ordered_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_ordered_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"ordered"</code> (default): Build the object using <code>ordered()</code>, levels won't
be defined explicitly if they are in alphabetical order (locale dependent!)
</p>
</li>
<li> <p><code>"factor"</code> : Same as above but build the object using <code>factor()</code> and <code>ordered = TRUE</code>.
</p>
</li>
<li> <p><code>"new_ordered"</code> : Build the object using <code>vctrs::new_ordered()</code>. Levels are
always defined explicitly.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"integer"</code> : We define as an integer vector and repair attributes
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_ordered&gt;
</p>

<hr>
<h2 id='opts_package_version'>Constructive options for package_version</h2><span id='topic+opts_package_version'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"package_version"</code> : We use <code>package_version()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"array"</code>
</p>
</li>
<li> <p><code>"list"</code> : We define as a list and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_package_version(constructor = c("package_version", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_package_version_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_package_version_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_package_version&gt;
</p>

<hr>
<h2 id='opts_pairlist'>Constructive options for pairlists</h2><span id='topic+opts_pairlist'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"pairlist"</code> (default): Build the object using a <code>pairlist()</code> call.
</p>
</li>
<li> <p><code>"pairlist2"</code> : Build the object using a <code>rlang::pairlist2()</code> call.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_pairlist(constructor = c("pairlist", "pairlist2"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_pairlist_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_pairlist_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_pairlist&gt;
</p>

<hr>
<h2 id='opts_POSIXct'>Constructive options for class 'POSIXct'</h2><span id='topic+opts_POSIXct'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'POSIXct'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_POSIXct(
  constructor = c("as.POSIXct", ".POSIXct", "as_datetime", "as.POSIXct.numeric",
    "as_datetime.numeric", "next", "atomic"),
  ...,
  origin = "1970-01-01"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_POSIXct_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_POSIXct_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_POSIXct_+3A_origin">origin</code></td>
<td>
<p>Origin to be used, ignored when irrelevant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.POSIXct"</code> (default): Build the object using a <code>as.POSIXct()</code> call on a
character vector.
</p>
</li>
<li> <p><code>".POSIXct"</code> : Build the object using a <code>.POSIXct()</code> call on a numeric vector.
</p>
</li>
<li> <p><code>"as_datetime"</code> : Build the object using a <code>lubridate::as_datetime()</code> call on
a character vector.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes.
</p>
</li></ul>

<p>If the data is not appropriate for a constructor we fall back to another one
appropriately. In particular corrupted POSIXct objects such as those defined
on top of integers (or worse) are all constructed with the <code>".POSIXct"</code> constructor.
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_POSIXct&gt;
</p>

<hr>
<h2 id='opts_POSIXlt'>Constructive options for class 'POSIXlt'</h2><span id='topic+opts_POSIXlt'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'POSIXlt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_POSIXlt(constructor = c("as.POSIXlt", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_POSIXlt_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_POSIXlt_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.POSIXlt"</code> (default): Build the object using a <code>as.POSIXlt()</code> call on a
character vector.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : We define as a list and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_POSIXlt&gt;
</p>

<hr>
<h2 id='opts_quosure'>Constructive options for class 'quosure'</h2><span id='topic+opts_quosure'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'quosure'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_quosure(constructor = c("new_quosure", "next", "language"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_quosure_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_quosure_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"new_quosure"</code> (default): Build the object using a <code>new_quosure()</code> call on a
character vector.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"language"</code> : We define as an language object and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_quosure&gt;
</p>

<hr>
<h2 id='opts_quosures'>Constructive options for class 'quosures'</h2><span id='topic+opts_quosures'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'quosures'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_quosures(constructor = c("new_quosures", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_quosures_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_quosures_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as_quosures"</code> (default): Build the object using a <code>as_quosures()</code> call on a
character vector.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : We define as an list object and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_quosures&gt;
</p>

<hr>
<h2 id='opts_R_system_version'>Constructive options for R_system_version</h2><span id='topic+opts_R_system_version'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"R_system_version"</code> : We use <code>R_system_version()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"list"</code>
</p>
</li>
<li> <p><code>"list"</code> : We define as a list and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_R_system_version(constructor = c("R_system_version", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_R_system_version_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_R_system_version_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_R_system_version&gt;
</p>

<hr>
<h2 id='opts_R6'>Constructive options for class 'R6'</h2><span id='topic+opts_R6'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'R6'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_R6(constructor = c("R6Class", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_R6_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_R6_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"R6Class"</code> (default): We build the object using <code>R6Class()$new()</code>, see details.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class.
</p>
</li></ul>

<p>Objects of class &quot;R6&quot; are harder to construct than &quot;R6ClassGenerator&quot; objects,
because  'constructive' doesn't know by default the constructor (i.e. class
generator) that was used to build them. So what we do is we build a class
generator that generates this object by default. This is why the generated code
is in the form <code>R6Class()$new()</code>.
</p>
<p>Another layer of complexity is added when the object features an
<code>initialize()</code> method, we cannot implement it in the class generator because
it might change the behavior of <code style="white-space: pre;">&#8288;$new()&#8288;</code> and return a wrong result (or fail).
For this reason the <code>initialize()</code> method when it exists is repaired as an
extra step.
</p>
<p><code>construct_diff()</code> works well to inspect the differences between two R6
objects where alternatives like <code>waldo::compare()</code> or <code>base::all.equal()</code>
don't return anything informative.
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_R6&gt;
</p>

<hr>
<h2 id='opts_R6ClassGenerator'>Constructive options for class 'R6ClassGenerator'</h2><span id='topic+opts_R6ClassGenerator'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'R6ClassGenerator'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_R6ClassGenerator(constructor = c("R6Class", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_R6ClassGenerator_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_R6ClassGenerator_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"R6Class"</code> (default): We build the object using <code>R6Class()</code>.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_R6ClassGenerator&gt;
</p>

<hr>
<h2 id='opts_raw'>Constructive options for type 'raw'</h2><span id='topic+opts_raw'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'raw'.
</p>
<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.raw"</code> (default): Use <code>as.raw()</code>, or <code>raw()</code> when relevant
</p>
</li>
<li> <p><code>"charToRaw"</code> : Use <code>charToRaw()</code> on a string, if the a raw vector contains
a zero we fall back to the &quot;as.raw&quot; constructor.
</p>
</li></ul>

<p>To set options on all atomic types at once see <a href="#topic+opts_atomic">opts_atomic</a>().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_raw(
  constructor = c("as.raw", "charToRaw"),
  ...,
  trim = NULL,
  fill = c("default", "rlang", "+", "...", "none"),
  compress = TRUE,
  representation = c("hexadecimal", "decimal")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_raw_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_raw_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_raw_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_raw_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements. See <code>?opts_atomic</code></p>
</td></tr>
<tr><td><code id="opts_raw_+3A_compress">compress</code></td>
<td>
<p>Boolean. If <code>TRUE</code> instead of <code>c()</code> Use <code>seq()</code>, <code>rep()</code>
when relevant to simplify the output.</p>
</td></tr>
<tr><td><code id="opts_raw_+3A_representation">representation</code></td>
<td>
<p>For &quot;as.raw&quot; constructor. Respectively generate output
in the formats <code>as.raw(0x10)</code> or <code>as.raw(16)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_raw&gt;
</p>

<hr>
<h2 id='opts_rowwise_df'>Constructive options for class 'rowwise_df'</h2><span id='topic+opts_rowwise_df'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'rowwise_df'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_rowwise_df(constructor = c("default", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_rowwise_df_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_rowwise_df_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : We define as an list object and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_rowwise_df&gt;
</p>

<hr>
<h2 id='opts_S4'>Constructive options for class 'S4'</h2><span id='topic+opts_S4'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'S4'. Note that the support
for S4 is very experimental so might easily break. Please report issues if it
does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_S4(constructor = c("new"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_S4_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_S4_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_S4&gt;
</p>

<hr>
<h2 id='opts_tbl_df'>Constructive options for tibbles</h2><span id='topic+opts_tbl_df'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'tbl_df', also known as tibbles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_tbl_df(
  constructor = c("tibble", "tribble", "next", "list"),
  ...,
  trailing_comma = TRUE,
  justify = c("left", "right", "centre", "none"),
  recycle = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_tbl_df_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_tbl_df_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
<tr><td><code id="opts_tbl_df_+3A_trailing_comma">trailing_comma</code></td>
<td>
<p>Boolean. Whether to leave a trailing comma at the end of the constructor call
calls</p>
</td></tr>
<tr><td><code id="opts_tbl_df_+3A_justify">justify</code></td>
<td>
<p>String. Justification for columns if <code>constructor</code> is <code>"tribble"</code></p>
</td></tr>
<tr><td><code id="opts_tbl_df_+3A_recycle">recycle</code></td>
<td>
<p>Boolean. For the <code>"tibble"</code> constructor. Whether to recycle
scalars to compress the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"tibble"</code> (default): Wrap the column definitions in a <code>tibble::tibble()</code> call.
</p>
</li>
<li> <p><code>"tribble"</code> : We build the object using <code>tibble::tribble()</code> if possible, and fall
back to <code>tibble::tibble()</code>.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_tbl_df&gt;
</p>

<hr>
<h2 id='opts_ts'>Constructive options for time-series objets</h2><span id='topic+opts_ts'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"ts"</code> : We use <code>ts()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"atomic"</code>
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_ts(constructor = c("ts", "next", "atomic"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_ts_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_ts_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_ts&gt;
</p>

<hr>
<h2 id='opts_vctrs_list_of'>Constructive options for class 'data.table'</h2><span id='topic+opts_vctrs_list_of'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'data.table'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_vctrs_list_of(constructor = c("list_of", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_vctrs_list_of_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_vctrs_list_of_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"list_of"</code> (default): Wrap the column definitions in a <code>list_of()</code> call.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_vctrs_list_of&gt;
</p>

<hr>
<h2 id='opts_weakref'>Constructive options for the class <code>weakref</code></h2><span id='topic+opts_weakref'></span>

<h3>Description</h3>

<p>These options will be used on objects of type <code>weakref</code>. <code>weakref</code> objects
are rarely encountered and there is no base R function to create them. However
<span class="pkg">rlang</span> has a <code>new_weakref</code> function that we can use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_weakref(constructor = c("new_weakref"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_weakref_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the constructor.</p>
</td></tr>
<tr><td><code id="opts_weakref_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_array&gt;
</p>

<hr>
<h2 id='opts_xts'>Constructive options for class 'xts'</h2><span id='topic+opts_xts'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'xts'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_xts(constructor = c("as.xts.matrix", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_xts_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_xts_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.xts.matrix"</code> (default): We build the object using <code>xts::as.xts.matrix()</code>.
</p>
</li>
<li> <p><code>"as.xts.data.frame"</code>: We build the object using <code>xts::as.xts.data.frame()</code>,
this is probably the most readable option but couldn't be made the default
constructor because it requires the 'xts' package to be installed .
</p>
</li>
<li> <p><code>"xts"</code>: We build the object using <code>xts::xts()</code>.
</p>
</li>
<li> <p><code>".xts"</code>: We build the object using <code>xts::.xts()</code>.
</p>
</li>
<li> <p><code>"next"</code>: Use the constructor for the next supported class.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_xts&gt;
</p>

<hr>
<h2 id='opts_yearmon'>Constructive options for class 'yearmon'</h2><span id='topic+opts_yearmon'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'yearmon'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_yearmon(constructor = c("as.yearmon", "yearmon", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_yearmon_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_yearmon_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.yearmon"</code> (default): We build the object using <code>zoo::as.yearmon()</code> on
a string in the format <code>"2000 Q3"</code>.
</p>
</li>
<li> <p><code>"yearmon"</code> : We build the object using <code>zoo::yearmon()</code> on a double in the
format <code>2000.5</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_yearmon&gt;
</p>

<hr>
<h2 id='opts_yearqtr'>Constructive options for class 'yearqtr'</h2><span id='topic+opts_yearqtr'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'yearqtr'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_yearqtr(constructor = c("as.yearqtr", "yearqtr", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_yearqtr_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_yearqtr_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"as.yearqtr"</code> (default): We build the object using <code>zoo::as.yearqtr()</code> on
a string in the format <code>"2000 Q3"</code>.
</p>
</li>
<li> <p><code>"yearqtr"</code> : We build the object using <code>zoo::yearqtr()</code> on a double in the
format <code>2000.5</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_yearqtr&gt;
</p>

<hr>
<h2 id='opts_zoo'>Constructive options for class 'zoo'</h2><span id='topic+opts_zoo'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'zoo'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_zoo(constructor = c("zoo", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_zoo_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_zoo_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"zoo"</code> (default): We build the object using <code>zoo::zoo()</code>.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_zoo&gt;
</p>

<hr>
<h2 id='opts_zooreg'>Constructive options for class 'zooreg'</h2><span id='topic+opts_zooreg'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'zooreg'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_zooreg(constructor = c("zooreg", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opts_zooreg_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_zooreg_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"zooreg"</code> (default): We build the object using <code>zoo::zooreg()</code>, using the
<code>start</code> and <code>frequency</code> arguments.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_zooreg&gt;
</p>

<hr>
<h2 id='other-opts'>Other Opts Functions</h2><span id='topic+other-opts'></span><span id='topic+opts_NULL'></span><span id='topic+opts_bibentry'></span><span id='topic+opts_citationFooter'></span><span id='topic+opts_citationHeader'></span><span id='topic+opts_difftime'></span><span id='topic+opts_error'></span><span id='topic+opts_expression'></span><span id='topic+opts_CoordCartesian'></span><span id='topic+opts_CoordFixed'></span><span id='topic+opts_CoordFlip'></span><span id='topic+opts_CoordMap'></span><span id='topic+opts_CoordMunch'></span><span id='topic+opts_CoordPolar'></span><span id='topic+opts_CoordQuickmap'></span><span id='topic+opts_CoordSf'></span><span id='topic+opts_CoordTrans'></span><span id='topic+opts_FacetWrap'></span><span id='topic+opts_Scale'></span><span id='topic+opts_ScalesList'></span><span id='topic+opts_element_blank'></span><span id='topic+opts_element_grob'></span><span id='topic+opts_element_line'></span><span id='topic+opts_element_rect'></span><span id='topic+opts_element_render'></span><span id='topic+opts_element_text'></span><span id='topic+opts_ggproto'></span><span id='topic+opts_labels'></span><span id='topic+opts_margin'></span><span id='topic+opts_rel'></span><span id='topic+opts_theme'></span><span id='topic+opts_uneval'></span><span id='topic+opts_waiver'></span><span id='topic+opts_noquote'></span><span id='topic+opts_person'></span><span id='topic+opts_simpleCondition'></span><span id='topic+opts_simpleError'></span><span id='topic+opts_simpleMessage'></span><span id='topic+opts_simpleUnit'></span><span id='topic+opts_simpleWarning'></span><span id='topic+opts_warning'></span>

<h3>Description</h3>

<p>These <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> functions are not extensively documented yet. Hopefully
the signature is self explanatory, if not please
<a href="https://github.com/cynkra/constructive/issues">raise an issue</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_NULL(constructor = "NULL", ...)

opts_bibentry(constructor = c("bibentry", "next"), ...)

opts_citationFooter(constructor = c("citFooter", "next"), ...)

opts_citationHeader(constructor = c("citHeader", "next"), ...)

opts_difftime(constructor = c("as.difftime", "next"), ...)

opts_error(constructor = c("errorCondition", "next"), ...)

opts_expression(constructor = c("default"), ...)

opts_CoordCartesian(
  constructor = c("coord_cartesian", "next", "environment"),
  ...
)

opts_CoordFixed(constructor = c("coord_fixed", "next", "environment"), ...)

opts_CoordFlip(constructor = c("coord_flip", "next", "environment"), ...)

opts_CoordMap(constructor = c("coord_map", "next", "environment"), ...)

opts_CoordMunch(constructor = c("coord_munch", "next", "environment"), ...)

opts_CoordPolar(constructor = c("coord_polar", "next", "environment"), ...)

opts_CoordQuickmap(
  constructor = c("coord_quickmap", "next", "environment"),
  ...
)

opts_CoordSf(constructor = c("coord_sf", "next", "environment"), ...)

opts_CoordTrans(constructor = c("coord_trans", "next", "environment"), ...)

opts_FacetWrap(
  constructor = c("facet_wrap", "ggproto", "next", "environment"),
  ...
)

opts_Scale(constructor = c("default", "next", "environment"), ...)

opts_ScalesList(constructor = c("ScalesList", "next", "list"), ...)

opts_element_blank(constructor = c("element_blank", "next", "list"), ...)

opts_element_grob(constructor = c("element_grob", "next", "list"), ...)

opts_element_line(constructor = c("element_line", "next", "list"), ...)

opts_element_rect(constructor = c("element_rect", "next", "list"), ...)

opts_element_render(constructor = c("element_render", "next", "list"), ...)

opts_element_text(constructor = c("element_text", "next", "list"), ...)

opts_ggproto(constructor = c("default", "next", "environment"), ...)

opts_labels(constructor = c("labs", "next", "list"), ...)

opts_margin(constructor = c("margin", "next", "double"), ...)

opts_rel(constructor = c("rel", "next", "double"), ...)

opts_theme(constructor = c("theme", "next", "list"), ...)

opts_uneval(constructor = c("aes", "next", "list"), ...)

opts_waiver(constructor = c("waiver", "next", "list"), ...)

opts_noquote(constructor = c("noquote", "next"), ...)

opts_person(constructor = c("person", "next"), ...)

opts_simpleCondition(constructor = c("simpleCondition", "next"), ...)

opts_simpleError(constructor = c("simpleError", "next"), ...)

opts_simpleMessage(constructor = c("simpleMessage", "next"), ...)

opts_simpleUnit(constructor = c("unit", "next", "double"), ...)

opts_simpleWarning(constructor = c("simpleWarning", "next"), ...)

opts_warning(constructor = c("warningCondition", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="other-opts_+3A_constructor">constructor</code></td>
<td>
<p>String. Method used to construct the object, often the name
of a function.</p>
</td></tr>
<tr><td><code id="other-opts_+3A_...">...</code></td>
<td>
<p>Additional options used by user defined constructors through the <code>opts</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='templates'>Extend constructive</h2><span id='topic+templates'></span><span id='topic+.cstr_new_class'></span><span id='topic+.cstr_new_constructor'></span>

<h3>Description</h3>

<p><code>.cstr_new_class()</code> and <code>.cstr_new_constructor()</code> open new unsaved scripts,
optionally commented, that can be used as templates to define new constructors.
If the class is already supported and you want to implement a new constructor,
use <code>.cstr_new_constructor()</code>, otherwise use <code>.cstr_new_class()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_new_class(
  class = c("CLASS", "PARENT_CLASS"),
  constructor = "PKG::CONSTRUCTOR",
  commented = FALSE
)

.cstr_new_constructor(
  class = c("CLASS", "PARENT_CLASS"),
  constructor = "PKG::CONSTRUCTOR",
  commented = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="templates_+3A_class">class</code></td>
<td>
<p>Class to support, provide the full <code>class()</code> vector.</p>
</td></tr>
<tr><td><code id="templates_+3A_constructor">constructor</code></td>
<td>
<p>Name of the constructor, usually the name of the function
you can to use to build the object. If not you might need to adjust the
script.</p>
</td></tr>
<tr><td><code id="templates_+3A_commented">commented</code></td>
<td>
<p>Boolean. Whether to include comments in the template.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We suggest the following workflow (summarized in a message when you call the functions):
</p>

<ul>
<li><p> Call <code style="white-space: pre;">&#8288;usethis::use_package(\"constructive\"&#8288;</code>, \&quot;Suggests\&quot;)' one time at any
point, this will add a soft dependency on 'constructive' so it's only needed to
install it when you use it.
</p>
</li>
<li><p> Call <code>.cstr_new_class()</code> or <code>.cstr_new_constructor()</code>, with <code>commented = TRUE</code> for more guidance.
</p>
</li>
<li><p> Save the scripts unchanged in the &quot;R&quot; folder of your package.
</p>
</li>
<li> <p><code>devtools::document()</code>: this will register the S3 methods.
</p>
</li>
<li><p> Try <code>construct()</code> on your new object, it should print a call to your chosen
constructor.
</p>
</li>
<li><p> Tweak the code, in particular the definition of <code>args</code>.
</p>
</li></ul>

<p>The README of the example extension package
<a href="https://github.com/cynkra/constructive.example">'constructive.example'</a>
guides you through the process. See also {constructive}'s own code
and <code>vignette("extend-constructive")</code> for more details.
</p>


<h3>Value</h3>

<p>Both function return <code>NULL</code> invisibly and are called for side effects
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
