<!DOCTYPE html><html><head><title>Help for package constructive</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {constructive}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.cstr_apply'><p>.cstr_apply</p></a></li>
<li><a href='#.cstr_combine_errors'><p>Combine errors</p></a></li>
<li><a href='#.cstr_construct'><p>Generic for object code generation</p></a></li>
<li><a href='#.cstr_fetch_opts'><p>Fetch constructive options</p></a></li>
<li><a href='#.cstr_match_constructor'><p>Validate a constructor</p></a></li>
<li><a href='#.cstr_options'><p>Create constructive options</p></a></li>
<li><a href='#.cstr_pipe'><p>Insert a pipe between two calls</p></a></li>
<li><a href='#.cstr_register_constructors'><p>Register constructors</p></a></li>
<li><a href='#.cstr_repair_attributes'><p>Repair attributes after idiomatic construction</p></a></li>
<li><a href='#.cstr_wrap'><p>Wrap argument code in function call</p></a></li>
<li><a href='#.env'><p>Fetch environment from memory address</p></a></li>
<li><a href='#.xptr'><p>Build a pointer from a memory address</p></a></li>
<li><a href='#compare_options'><p>Options for waldo::compare</p></a></li>
<li><a href='#construct'><p>Build code to recreate an object</p></a></li>
<li><a href='#construct_diff'><p>Display diff of object definitions</p></a></li>
<li><a href='#construct_dump'><p>Dump Constructed Code to a File</p></a></li>
<li><a href='#construct_issues'><p>Show constructive issues</p></a></li>
<li><a href='#construct_reprex'><p>construct_reprex</p></a></li>
<li><a href='#construct_signature'><p>Construct a function's signature</p></a></li>
<li><a href='#constructive-global_options'><p>Global Options</p></a></li>
<li><a href='#constructive-package'><p>constructive: Display Idiomatic Code to Construct Most R Objects</p></a></li>
<li><a href='#constructors'><p>constructors</p></a></li>
<li><a href='#custom-constructors'><p>Custom constructors</p></a></li>
<li><a href='#deparse_call'><p>Deparse a language object</p></a></li>
<li><a href='#opts_array'><p>Constructive options for arrays</p></a></li>
<li><a href='#opts_AsIs'><p>Constructive options for the class <code>AsIs</code></p></a></li>
<li><a href='#opts_atomic'><p>Constructive options for atomic types</p></a></li>
<li><a href='#opts_classGeneratorFunction'><p>Constructive options for class 'classGeneratorFunction'</p></a></li>
<li><a href='#opts_classPrototypeDef'><p>Constructive options for class 'classPrototypeDef'</p></a></li>
<li><a href='#opts_classRepresentation'><p>Constructive options for class 'classRepresentation'</p></a></li>
<li><a href='#opts_constructive_options'><p>Constructive options for the class <code>constructive_options</code></p></a></li>
<li><a href='#opts_data.frame'><p>Constructive options for class 'data.frame'</p></a></li>
<li><a href='#opts_data.table'><p>Constructive options for class 'data.table'</p></a></li>
<li><a href='#opts_Date'><p>Constructive options class 'Date'</p></a></li>
<li><a href='#opts_dm'><p>Constructive options class 'dm'</p></a></li>
<li><a href='#opts_dots'><p>Constructive options for type '...'</p></a></li>
<li><a href='#opts_environment'><p>Constructive options for type 'environment'</p></a></li>
<li><a href='#opts_externalptr'><p>Constructive options for type 'externalptr'</p></a></li>
<li><a href='#opts_factor'><p>Constructive options for class 'factor'</p></a></li>
<li><a href='#opts_formula'><p>Constructive options for formulas</p></a></li>
<li><a href='#opts_function'><p>Constructive options for functions</p></a></li>
<li><a href='#opts_grouped_df'><p>Constructive options for class 'grouped_df'</p></a></li>
<li><a href='#opts_language'><p>Constructive options for type 'language'</p></a></li>
<li><a href='#opts_Layer'><p>Constructive options for class 'Layer' (ggplot2)</p></a></li>
<li><a href='#opts_list'><p>Constructive options for type 'list'</p></a></li>
<li><a href='#opts_matrix'><p>Constructive options for matrices</p></a></li>
<li><a href='#opts_mts'><p>Constructive options for time-series objets</p></a></li>
<li><a href='#opts_numeric_version'><p>Constructive options for numeric_version</p></a></li>
<li><a href='#opts_ordered'><p>Constructive options for class 'ordered'</p></a></li>
<li><a href='#opts_package_version'><p>Constructive options for package_version</p></a></li>
<li><a href='#opts_pairlist'><p>Constructive options for pairlists</p></a></li>
<li><a href='#opts_POSIXct'><p>Constructive options for class 'POSIXct'</p></a></li>
<li><a href='#opts_POSIXlt'><p>Constructive options for class 'POSIXlt'</p></a></li>
<li><a href='#opts_quosure'><p>Constructive options for class 'quosure'</p></a></li>
<li><a href='#opts_quosures'><p>Constructive options for class 'quosures'</p></a></li>
<li><a href='#opts_R_system_version'><p>Constructive options for R_system_version</p></a></li>
<li><a href='#opts_rowwise_df'><p>Constructive options for class 'rowwise_df'</p></a></li>
<li><a href='#opts_S4'><p>Constructive options for class 'S4'</p></a></li>
<li><a href='#opts_tbl_df'><p>Constructive options for tibbles</p></a></li>
<li><a href='#opts_ts'><p>Constructive options for time-series objets</p></a></li>
<li><a href='#opts_vctrs_list_of'><p>Constructive options for class 'data.table'</p></a></li>
<li><a href='#opts_weakref'><p>Constructive options for the class <code>weakref</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Display Idiomatic Code to Construct Most R Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Prints code that can be used to recreate R objects. In a
    sense it is similar to 'base::dput()' or 'base::deparse()' but
    'constructive' strives to use idiomatic constructors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cynkra/constructive">https://github.com/cynkra/constructive</a>,
<a href="https://cynkra.github.io/constructive/">https://cynkra.github.io/constructive/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cynkra/constructive/issues">https://github.com/cynkra/constructive/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, diffobj, methods, rlang (&ge; 1.0.0), waldo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>clipr, data.table, DiagrammeR, DiagrammeRsvg, dm, dplyr,
forcats, ggplot2, knitr, lubridate, pixarfilms, prettycode,
reprex, rmarkdown, roxygen2, rstudioapi, scales, sf, testthat
(&ge; 3.0.0), tibble, tidyselect, vctrs, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 17:08:19 UTC; Antoine</td>
</tr>
<tr>
<td>Author:</td>
<td>Antoine Fabri [aut, cre],
  Kirill MÃ¼ller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antoine Fabri &lt;antoine.fabri@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 17:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='.cstr_apply'>.cstr_apply</h2><span id='topic+.cstr_apply'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. If <code>recurse</code> is <code>TRUE</code> (default), we
recurse to construct <code>args</code> and insert their construction code in a <code>fun(...)</code> call returned
as a character vector. If <code>args</code> already contains code rather than object to
construct one should set <code>recurse</code> to <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_apply(
  args,
  fun = "list",
  ...,
  trailing_comma = FALSE,
  recurse = TRUE,
  implicit_names = FALSE,
  new_line = TRUE,
  one_liner = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_apply_+3A_args">args</code></td>
<td>
<p>A list of arguments to construct recursively, or code if <code>recurse = FALSE</code>.
If elements are named, the arguments will be named in the generated code.</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_fun">fun</code></td>
<td>
<p>The function name to use to build code of the form &quot;fun(...)&quot;</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_...">...</code></td>
<td>
<p>options passed recursively to the further methods</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_trailing_comma">trailing_comma</code></td>
<td>
<p>leave a trailing comma after the last argument if
the code is multiline, some constructors allow it (e.g. <code>tibble::tibble()</code>) and it makes for nicer
diffs in version control.</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_recurse">recurse</code></td>
<td>
<p>Whether to recursively generate the code to construct <code>args</code>. If <code>FALSE</code> arguments
are expected to contain code.</p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_implicit_names">implicit_names</code></td>
<td>
<p>When data is provided, compress calls of the form <code>f(a = a)</code> to <code>f(a)</code></p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_new_line">new_line</code></td>
<td>
<p>passed to wrap to remove add a line after &quot;fun(&quot; and before &quot;)&quot;, forced to
<code>FALSE</code> if <code>one_liner</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id=".cstr_apply_+3A_one_liner">one_liner</code></td>
<td>
<p>Whether to return a one line call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1
.cstr_apply(list(a=a), "foo")
.cstr_apply(list(a=a), "foo", data = list(a=1))
.cstr_apply(list(a=a), "foo", data = list(a=1), implicit_names = TRUE)
.cstr_apply(list(b=a), "foo", data = list(a=1), implicit_names = TRUE)
.cstr_apply(list(a="c(1,2)"), "foo")
.cstr_apply(list(a="c(1,2)"), "foo", recurse = FALSE)
</code></pre>

<hr>
<h2 id='.cstr_combine_errors'>Combine errors</h2><span id='topic+.cstr_combine_errors'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. This function allows combining independent checks so information is given about
all failing checks rather than the first one. All parameters except <code>...</code> are
forwarded to <code>rlang::abort()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_combine_errors(
  ...,
  class = NULL,
  call,
  header = NULL,
  body = NULL,
  footer = NULL,
  trace = NULL,
  parent = NULL,
  use_cli_format = NULL,
  .internal = FALSE,
  .file = NULL,
  .frame = parent.frame(),
  .trace_bottom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_combine_errors_+3A_...">...</code></td>
<td>
<p>check expressions</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_class">class</code></td>
<td>
<p>Subclass of the condition.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running
function, e.g. <code>call = caller_env()</code>. The corresponding function
call is retrieved and mentioned in error messages as the source
of the error.
</p>
<p>You only need to supply <code>call</code> when throwing a condition from a
helper function which wouldn't be relevant to mention in the
message.
</p>
<p>Can also be <code>NULL</code> or a <a href="rlang.html#topic+topic-defuse">defused function call</a> to
respectively not display any call or hard-code a code to display.
</p>
<p>For more information about error calls, see <a href="rlang.html#topic+topic-error-call">Including function calls in error messages</a>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_header">header</code></td>
<td>
<p>An optional header to precede the errors</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_body">body</code>, <code id=".cstr_combine_errors_+3A_footer">footer</code></td>
<td>
<p>Additional bullets.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_trace">trace</code></td>
<td>
<p>A <code>trace</code> object created by <code><a href="rlang.html#topic+trace_back">trace_back()</a></code>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_parent">parent</code></td>
<td>
<p>Supply <code>parent</code> when you rethrow an error from a
condition handler (e.g. with <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>).
</p>

<ul>
<li><p> If <code>parent</code> is a condition object, a <em>chained error</em> is
created, which is useful when you want to enhance an error with
more details, while still retaining the original information.
</p>
</li>
<li><p> If <code>parent</code> is <code>NA</code>, it indicates an unchained rethrow, which
is useful when you want to take ownership over an error and
rethrow it with a custom message that better fits the
surrounding context.
</p>
<p>Technically, supplying <code>NA</code> lets <code>abort()</code> know it is called
from a condition handler. This helps it create simpler
backtraces where the condition handling context is hidden by
default.
</p>
</li></ul>

<p>For more information about error calls, see <a href="rlang.html#topic+topic-error-chaining">Including contextual information with error chains</a>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_use_cli_format">use_cli_format</code></td>
<td>
<p>Whether to format <code>message</code> lazily using
<a href="https://cli.r-lib.org/">cli</a> if available. This results in
prettier and more accurate formatting of messages. See
<code><a href="rlang.html#topic+local_use_cli">local_use_cli()</a></code> to set this condition field by default in your
package namespace.
</p>
<p>If set to <code>TRUE</code>, <code>message</code> should be a character vector of
individual and unformatted lines. Any newline character <code>"\\n"</code>
already present in <code>message</code> is reformatted by cli's paragraph
formatter. See <a href="rlang.html#topic+topic-condition-formatting">Formatting messages with cli</a>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_.internal">.internal</code></td>
<td>
<p>If <code>TRUE</code>, a footer bullet is added to <code>message</code>
to let the user know that the error is internal and that they
should report it to the package authors. This argument is
incompatible with <code>footer</code>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_.file">.file</code></td>
<td>
<p>A connection or a string specifying where to print the
message. The default depends on the context, see the <code>stdout</code> vs
<code>stderr</code> section.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_.frame">.frame</code></td>
<td>
<p>The throwing context. Used as default for
<code>.trace_bottom</code>, and to determine the internal package to mention
in internal errors when <code>.internal</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id=".cstr_combine_errors_+3A_.trace_bottom">.trace_bottom</code></td>
<td>
<p>Used in the display of simplified backtraces
as the last relevant call frame to show. This way, the irrelevant
parts of backtraces corresponding to condition handling
(<code><a href="base.html#topic+tryCatch">tryCatch()</a></code>, <code><a href="rlang.html#topic+try_fetch">try_fetch()</a></code>, <code>abort()</code>, etc.) are hidden by
default. Defaults to <code>call</code> if it is an environment, or <code>.frame</code>
otherwise. Without effect if <code>trace</code> is supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly, called for side effects.
</p>

<hr>
<h2 id='.cstr_construct'>Generic for object code generation</h2><span id='topic+.cstr_construct'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. <code>.cstr_construct()</code> is basically a
naked <code>construct()</code>, without the checks, the style, the object post processing etc...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_construct(x, ..., data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_construct_+3A_x">x</code></td>
<td>
<p>An object, for <code>construct_multi()</code> a named list or an environment.</p>
</td></tr>
<tr><td><code id=".cstr_construct_+3A_...">...</code></td>
<td>
<p>Constructive options built with the <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> family of functions. See the &quot;Constructive options&quot;
section below.</p>
</td></tr>
<tr><td><code id=".cstr_construct_+3A_data">data</code></td>
<td>
<p>Named list or environment of objects we want to detect and mention by name (as opposed to
deparsing them further). Can also contain unnamed nested lists, environments, or
package names, in the latter case package exports and datasets will be considered.
In case of conflict, the last provided name is considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='.cstr_fetch_opts'>Fetch constructive options</h2><span id='topic+.cstr_fetch_opts'></span>

<h3>Description</h3>

<p>Exported for custom constructor design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_fetch_opts(class, ..., template = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_fetch_opts_+3A_class">class</code></td>
<td>
<p>A string. An S3 class.</p>
</td></tr>
<tr><td><code id=".cstr_fetch_opts_+3A_...">...</code>, <code id=".cstr_fetch_opts_+3A_template">template</code></td>
<td>
<p>Parameters generally forwarded through the dots of the caller function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c(paste0("constructive_options_", class), "constructive_options")</code>
</p>

<hr>
<h2 id='.cstr_match_constructor'>Validate a constructor</h2><span id='topic+.cstr_match_constructor'></span>

<h3>Description</h3>

<p>Fails if the chosen constructor doesn't exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_match_constructor(constructor, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_match_constructor_+3A_constructor">constructor</code></td>
<td>
<p>a String (or character vector but only the first item will
be considered)</p>
</td></tr>
<tr><td><code id=".cstr_match_constructor_+3A_class">class</code></td>
<td>
<p>A string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string, the first value of <code>constructor</code> if it is the name of a n existing
constructor or &quot;next&quot;.
</p>

<hr>
<h2 id='.cstr_options'>Create constructive options</h2><span id='topic+.cstr_options'></span>

<h3>Description</h3>

<p>Exported for custom constructor design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_options(class, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_options_+3A_class">class</code></td>
<td>
<p>A string. An S3 class.</p>
</td></tr>
<tr><td><code id=".cstr_options_+3A_...">...</code></td>
<td>
<p>Options to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c(paste0("constructive_options_", class), "constructive_options")</code>
</p>

<hr>
<h2 id='.cstr_pipe'>Insert a pipe between two calls</h2><span id='topic+.cstr_pipe'></span>

<h3>Description</h3>

<p>Exported for custom constructor design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_pipe(x, y, pipe, one_liner, indent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_pipe_+3A_x">x</code></td>
<td>
<p>A character vector. The code for the left hand side call.</p>
</td></tr>
<tr><td><code id=".cstr_pipe_+3A_y">y</code></td>
<td>
<p>A character vector. The code for the right hand side call.</p>
</td></tr>
<tr><td><code id=".cstr_pipe_+3A_pipe">pipe</code></td>
<td>
<p>A string. The pipe to use, <code>"plus"</code> is useful for ggplot code.</p>
</td></tr>
<tr><td><code id=".cstr_pipe_+3A_one_liner">one_liner</code></td>
<td>
<p>A boolean. Whether to paste <code>x</code>, the pipe and <code>y</code> together</p>
</td></tr>
<tr><td><code id=".cstr_pipe_+3A_indent">indent</code></td>
<td>
<p>A boolean. Whether to indent <code>y</code>
on a same line (provided that <code>x</code> and <code>y</code> are strings and one liners themselves)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.cstr_pipe("iris", "head(2)", pipe = "magrittr", one_liner = FALSE)
.cstr_pipe("iris", "head(2)", pipe = "magrittr", one_liner = TRUE)
</code></pre>

<hr>
<h2 id='.cstr_register_constructors'>Register constructors</h2><span id='topic+.cstr_register_constructors'></span>

<h3>Description</h3>

<p>Use this function to register a custom constructor. See vignette for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_register_constructors(class, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_register_constructors_+3A_class">class</code></td>
<td>
<p>A string</p>
</td></tr>
<tr><td><code id=".cstr_register_constructors_+3A_...">...</code></td>
<td>
<p>named constructors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly, called for side effects.
</p>

<hr>
<h2 id='.cstr_repair_attributes'>Repair attributes after idiomatic construction</h2><span id='topic+.cstr_repair_attributes'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. In the general case an object might have more attributes than given by the idiomatic
construction. <code>.cstr_repair_attributes()</code> sets some of those attributes and ignores
others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_repair_attributes(
  x,
  code,
  ...,
  pipe = NULL,
  ignore = NULL,
  idiomatic_class = NULL,
  remove = NULL,
  one_liner = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_repair_attributes_+3A_x">x</code></td>
<td>
<p>The object to construct</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_code">code</code></td>
<td>
<p>The code constructing the object before attribute reparation</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>.construct_apply()</code> when relevant</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_pipe">pipe</code></td>
<td>
<p>Which pipe to use, either <code>"base"</code> or <code>"magrittr"</code>.
Defaults to <code>"base"</code> for R &gt;= 4.2, otherwise to <code>"magrittr"</code>.</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_ignore">ignore</code></td>
<td>
<p>The attributes that shouldn't be repaired, i.e. we expect them
to be set by the constructor already in <code>code</code></p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_idiomatic_class">idiomatic_class</code></td>
<td>
<p>The class of the objects that the constructor produces,
if <code>x</code> is of class <code>idiomatic_class</code> there is no need to repair the class.</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_remove">remove</code></td>
<td>
<p>Attributes that should be removed, should rarely be useful.</p>
</td></tr>
<tr><td><code id=".cstr_repair_attributes_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single line of code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='.cstr_wrap'>Wrap argument code in function call</h2><span id='topic+.cstr_wrap'></span>

<h3>Description</h3>

<p>Exported for custom constructor design. Generally called through <code>.cstr_apply()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cstr_wrap(args, fun, new_line = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cstr_wrap_+3A_args">args</code></td>
<td>
<p>A character vector containing the code of arguments.</p>
</td></tr>
<tr><td><code id=".cstr_wrap_+3A_fun">fun</code></td>
<td>
<p>A string. The name of the function to use in the function call.
Use <code>fun = ""</code> to wrap in parentheses.</p>
</td></tr>
<tr><td><code id=".cstr_wrap_+3A_new_line">new_line</code></td>
<td>
<p>Boolean. Whether to insert a new line between <code>"fun("</code> and the closing <code>")"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='.env'>Fetch environment from memory address</h2><span id='topic+.env'></span>

<h3>Description</h3>

<p>This is designed to be used in constructed output. The <code>parents</code> and <code>...</code> arguments
are not processed and only used to display additional information. If used on
an improper memory address the output might be erratic or the session might crash.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.env(address, parents = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".env_+3A_address">address</code></td>
<td>
<p>Memory address of the environment</p>
</td></tr>
<tr><td><code id=".env_+3A_parents">parents</code>, <code id=".env_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The environment that the memory address points to.
</p>

<hr>
<h2 id='.xptr'>Build a pointer from a memory address</h2><span id='topic+.xptr'></span>

<h3>Description</h3>

<p>Base R doesn't provide utilities to build or manipulate external pointers
(objects of type &quot;externalptr&quot;), so we provide our own. Be warned that
objects defined with <code>.xptr()</code> are not stable across sessions,
however this is the best we can
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.xptr(address)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".xptr_+3A_address">address</code></td>
<td>
<p>Memory address</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The external pointer (type &quot;externalptr&quot;) that the memory address points to.
</p>

<hr>
<h2 id='compare_options'>Options for waldo::compare</h2><span id='topic+compare_options'></span>

<h3>Description</h3>

<p>Builds options that will be passed to <code>waldo::compare()</code> down the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_options(
  ignore_srcref = TRUE,
  ignore_attr = FALSE,
  ignore_function_env = FALSE,
  ignore_formula_env = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_options_+3A_ignore_srcref">ignore_srcref</code></td>
<td>
<p>Ignore differences in function <code>srcref</code>s? <code>TRUE</code> by
default since the <code>srcref</code> does not change the behaviour of a function,
only its printed representation.</p>
</td></tr>
<tr><td><code id="compare_options_+3A_ignore_attr">ignore_attr</code></td>
<td>
<p>Ignore differences in specified attributes?
Supply a character vector to ignore differences in named attributes.
By default the <code>"waldo_opts"</code> attribute is listed in <code>ignore_attr</code> so
that changes to it are not reported; if you customize <code>ignore_attr</code>, you
will probably want to do this yourself.
</p>
<p>For backward compatibility with <code>all.equal()</code>, you can also use <code>TRUE</code>,
to all ignore differences in all attributes. This is not generally
recommended as it is a blunt tool that will ignore many important
functional differences.</p>
</td></tr>
<tr><td><code id="compare_options_+3A_ignore_function_env">ignore_function_env</code>, <code id="compare_options_+3A_ignore_formula_env">ignore_formula_env</code></td>
<td>
<p>Ignore the environments of
functions and formulas, respectively? These are provided primarily for
backward compatibility with <code>all.equal()</code> which always ignores these
environments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='construct'>Build code to recreate an object</h2><span id='topic+construct'></span><span id='topic+construct_multi'></span>

<h3>Description</h3>

<p><code>construct()</code> builds the code to reproduce one object, <code>construct_multi()</code>
builds the code to reproduce objects stored in a named list or environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct(
  x,
  ...,
  data = NULL,
  pipe = NULL,
  check = NULL,
  compare = compare_options(),
  one_liner = FALSE,
  template = getOption("constructive_opts_template")
)

construct_multi(
  x,
  ...,
  data = NULL,
  pipe = NULL,
  check = NULL,
  compare = compare_options(),
  one_liner = FALSE,
  template = getOption("constructive_opts_template")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_+3A_x">x</code></td>
<td>
<p>An object, for <code>construct_multi()</code> a named list or an environment.</p>
</td></tr>
<tr><td><code id="construct_+3A_...">...</code></td>
<td>
<p>Constructive options built with the <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> family of functions. See the &quot;Constructive options&quot;
section below.</p>
</td></tr>
<tr><td><code id="construct_+3A_data">data</code></td>
<td>
<p>Named list or environment of objects we want to detect and mention by name (as opposed to
deparsing them further). Can also contain unnamed nested lists, environments, or
package names, in the latter case package exports and datasets will be considered.
In case of conflict, the last provided name is considered.</p>
</td></tr>
<tr><td><code id="construct_+3A_pipe">pipe</code></td>
<td>
<p>Which pipe to use, either <code>"base"</code> or <code>"magrittr"</code>.
Defaults to <code>"base"</code> for R &gt;= 4.2, otherwise to <code>"magrittr"</code>.</p>
</td></tr>
<tr><td><code id="construct_+3A_check">check</code></td>
<td>
<p>Boolean. Whether to check if the created code reproduces the object
using <code>waldo::compare()</code>.</p>
</td></tr>
<tr><td><code id="construct_+3A_compare">compare</code></td>
<td>
<p>Parameters passed to <code>waldo::compare()</code>, built with <code>compare_options()</code>.</p>
</td></tr>
<tr><td><code id="construct_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single line of code.</p>
</td></tr>
<tr><td><code id="construct_+3A_template">template</code></td>
<td>
<p>A list of constructive options built with <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> functions,
they will be overriden by <code>...</code>. Use it to set a default
behavior for <code>{constructive}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>construct_multi()</code> recognizes promises, this means that for instance
<code>construct_multi(environment())</code> can be called in a
function and will construct unevaluated arguments using <code>delayedAssign()</code>.
Note however that <code>construct_multi(environment())</code> is equivalent to <code>construct_reprex()</code>
called without argument and the latter is preferred.
</p>


<h3>Value</h3>

<p>An object of class 'constructive'.
</p>


<h3>Constructive options</h3>

<p>Constructive options provide a way to customize the output of 'construct()'.
We can provide calls to 'opts_*()' functions to the '...' argument. Each of these functions targets a specific type or class and is documented on its own page.
</p>

<ul>
<li> <p><code><a href="#topic+opts_array">opts_array</a>(constructor = c("array", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_AsIs">opts_AsIs</a>(constructor = c("I", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_atomic">opts_atomic</a>(..., trim = NULL, fill = c("default", "rlang", "+", "...", "none"), compress = TRUE, unicode_representation = c("ascii", "latin", "character", "unicode"), escape = FALSE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_classGeneratorFunction">opts_classGeneratorFunction</a>(constructor = c("setClass"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_classPrototypeDef">opts_classPrototypeDef</a>(constructor = c("prototype"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_classRepresentation">opts_classRepresentation</a>(constructor = c("getClassDef"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_constructive_options">opts_constructive_options</a>(constructor = c("opts", "next"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_data.frame">opts_data.frame</a>(constructor = c("data.frame", "read.table", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_data.table">opts_data.table</a>(constructor = c("data.table", "next", "list"), ..., selfref = FALSE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_Date">opts_Date</a>(constructor = c("as.Date", "as_date", "date", "new_date", "as.Date.numeric", "as_date.numeric", "next", "atomic"), ..., origin = "1970-01-01")</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_dm">opts_dm</a>(constructor = c("dm", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_dots">opts_dots</a>(constructor = c("default"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_environment">opts_environment</a>(constructor = c(".env", "list2env", "as.environment", "new.env", "topenv", "new_environment"), ..., recurse = FALSE, predefine = FALSE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_externalptr">opts_externalptr</a>(constructor = c("default"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_factor">opts_factor</a>(constructor = c("factor", "as_factor", "new_factor", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_formula">opts_formula</a>(constructor = c("~", "formula", "as.formula", "new_formula", "next"), ..., environment = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_function">opts_function</a>(constructor = c("function", "as.function", "new_function"), ..., environment = TRUE, srcref = FALSE, trim = NULL)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_grouped_df">opts_grouped_df</a>(constructor = c("default", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_language">opts_language</a>(constructor = c("default"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_Layer">opts_Layer</a>(constructor = c("default", "layer", "environment"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_list">opts_list</a>(constructor = c("list", "list2"), ..., trim = NULL, fill = c("vector", "new_list", "+", "...", "none"))</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_matrix">opts_matrix</a>(constructor = c("matrix", "array", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_mts">opts_mts</a>(constructor = c("ts", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_numeric_version">opts_numeric_version</a>(constructor = c("numeric_version", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_ordered">opts_ordered</a>(constructor = c("ordered", "factor", "new_ordered", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_package_version">opts_package_version</a>(constructor = c("package_version", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_pairlist">opts_pairlist</a>(constructor = c("pairlist", "pairlist2"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_POSIXct">opts_POSIXct</a>(constructor = c("as.POSIXct", ".POSIXct", "as_datetime", "as.POSIXct.numeric", "as_datetime.numeric", "next", "atomic"), ..., origin = "1970-01-01")</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_POSIXlt">opts_POSIXlt</a>(constructor = c("as.POSIXlt", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_quosure">opts_quosure</a>(constructor = c("new_quosure", "next", "language"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_quosures">opts_quosures</a>(constructor = c("new_quosures", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_R_system_version">opts_R_system_version</a>(constructor = c("R_system_version", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_rowwise_df">opts_rowwise_df</a>(constructor = c("default", "next", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_S4">opts_S4</a>(constructor = c("new"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_tbl_df">opts_tbl_df</a>(constructor = c("tibble", "tribble", "next", "list"), ..., trailing_comma = TRUE)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_ts">opts_ts</a>(constructor = c("ts", "next", "atomic"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_vctrs_list_of">opts_vctrs_list_of</a>(constructor = c("list_of", "list"), ...)</code>
</p>
</li>
<li> <p><code><a href="#topic+opts_weakref">opts_weakref</a>(constructor = c("new_weakref"), ...)</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>construct(head(cars))
construct(head(cars), opts_data.frame("read.table"))
construct(head(cars), opts_data.frame("next"))
construct(iris$Species)
construct(iris$Species, opts_atomic(compress = FALSE), opts_factor("new_factor"))
</code></pre>

<hr>
<h2 id='construct_diff'>Display diff of object definitions</h2><span id='topic+construct_diff'></span>

<h3>Description</h3>

<p>Display diff of object definitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_diff(
  target,
  current,
  ...,
  data = NULL,
  pipe = NULL,
  check = TRUE,
  compare = compare_options(),
  one_liner = FALSE,
  template = getOption("constructive_opts_template"),
  mode = c("sidebyside", "auto", "unified", "context"),
  interactive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_diff_+3A_target">target</code></td>
<td>
<p>the reference object</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_current">current</code></td>
<td>
<p>the object being compared to <code>target</code></p>
</td></tr>
<tr><td><code id="construct_diff_+3A_...">...</code></td>
<td>
<p>Constructive options built with the <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> family of functions. See the &quot;Constructive options&quot;
section below.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_data">data</code></td>
<td>
<p>Named list or environment of objects we want to detect and mention by name (as opposed to
deparsing them further). Can also contain unnamed nested lists, environments, or
package names, in the latter case package exports and datasets will be considered.
In case of conflict, the last provided name is considered.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_pipe">pipe</code></td>
<td>
<p>Which pipe to use, either <code>"base"</code> or <code>"magrittr"</code>.
Defaults to <code>"base"</code> for R &gt;= 4.2, otherwise to <code>"magrittr"</code>.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_check">check</code></td>
<td>
<p>Boolean. Whether to check if the created code reproduces the object
using <code>waldo::compare()</code>.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_compare">compare</code></td>
<td>
<p>Parameters passed to <code>waldo::compare()</code>, built with <code>compare_options()</code>.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single line of code.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_template">template</code></td>
<td>
<p>A list of constructive options built with <code style="white-space: pre;">&#8288;opts_*()&#8288;</code> functions,
they will be overriden by <code>...</code>. Use it to set a default
behavior for <code>{constructive}</code>.</p>
</td></tr>
<tr><td><code id="construct_diff_+3A_mode">mode</code>, <code id="construct_diff_+3A_interactive">interactive</code></td>
<td>
<p>passed to <code>diffobj::diffChr()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# some object print the same though they're different
# `construct_diff()` shows how they differ :
df1 &lt;- data.frame(a=1, b = "x")
df2 &lt;- data.frame(a=1L, b = "x", stringsAsFactors = TRUE)
attr(df2, "some_attribute") &lt;- "a value"
df1
df2
construct_diff(df1, df2)


# Those are made easy to compare
construct_diff(substr, substring)
construct_diff(month.abb, month.name)

# more examples borrowed from {waldo} package
construct_diff(c("a", "b", "c"), c("a", "B", "c"))
construct_diff(c("X", letters), c(letters, "X"))
construct_diff(list(factor("x")), list(1L))
construct_diff(df1, df2)
x &lt;- list(a = list(b = list(c = list(structure(1, e = 1)))))
y &lt;- list(a = list(b = list(c = list(structure(1, e = "a")))))
construct_diff(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='construct_dump'>Dump Constructed Code to a File</h2><span id='topic+construct_dump'></span>

<h3>Description</h3>

<p>An alternative to <code>base::dump()</code> using code built with <span class="pkg">constructive</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_dump(x, path, append = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_dump_+3A_x">x</code></td>
<td>
<p>A named list or an environment.</p>
</td></tr>
<tr><td><code id="construct_dump_+3A_path">path</code></td>
<td>
<p>File or connection to write to.</p>
</td></tr>
<tr><td><code id="construct_dump_+3A_append">append</code></td>
<td>
<p>If FALSE, will overwrite existing file. If TRUE, will append to existing file. In both cases, if the file does not exist a new file is created.</p>
</td></tr>
<tr><td><code id="construct_dump_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>construct_multi()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly, called for side effects.
</p>

<hr>
<h2 id='construct_issues'>Show constructive issues</h2><span id='topic+construct_issues'></span>

<h3>Description</h3>

<p>Show constructive issues
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_issues(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_issues_+3A_x">x</code></td>
<td>
<p>An object built by <code>construct()</code>, if <code>NULL</code> the latest encountered
issues will be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with class &quot;waldo_compare&quot;
</p>

<hr>
<h2 id='construct_reprex'>construct_reprex</h2><span id='topic+construct_reprex'></span>

<h3>Description</h3>

<p><code>construct_reprex()</code> constructs all objects of the local environment,
or a caller environment <code>n</code> steps above. If <code>n &gt; 0</code> the function call
is also included in a comment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_reprex(n = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_reprex_+3A_n">n</code></td>
<td>
<p>The number of steps to go up on the call stack</p>
</td></tr>
<tr><td><code id="construct_reprex_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>construct_multi()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>construct_reprex()</code> doesn't call the {reprex} package but it shares
the purpose of making it easier to reproduce an output, hence the name.
If you want to it to look more like a <code>reprex::reprex</code> consider <code>options(constructive_print_mode = "reprex")</code>.
See <code>?constructive_print_mode</code> for more.
</p>
<p><code>construct_reprex()</code> wraps <code>construct_multi()</code> and is thus able to construct
unevaluated arguments using <code>delayedAssign()</code>. This means we can construct
reprexes for functions that use Non Standard Evaluation.
</p>
<p>A useful trick is to use <code>construct_reprex()</code> with <code>options(error = recover)</code>
to be able to reproduce an error.
</p>
<p><code>construct_reprex()</code> might fail to reproduce the output of functions that refer
to environments other than their caller environment. We believe these are
very rare and that the simplicity is worth the rounded corners, but if you
encounter these limitations please do open a ticket on our issue tracker
at <code style="white-space: pre;">&#8288;https://github.com/cynkra/constructive/&#8288;</code> and we might expand the feature.
</p>


<h3>Value</h3>

<p>Returns return <code>NULL</code> invisibly, called for side-effects.
</p>

<hr>
<h2 id='construct_signature'>Construct a function's signature</h2><span id='topic+construct_signature'></span>

<h3>Description</h3>

<p>Construct a function's signature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_signature(x, name = NULL, one_liner = FALSE, style = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_signature_+3A_x">x</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="construct_signature_+3A_name">name</code></td>
<td>
<p>The name of the function, by default we use the symbol provided to <code>x</code></p>
</td></tr>
<tr><td><code id="construct_signature_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse multi-line expressions on a single line using
semicolons</p>
</td></tr>
<tr><td><code id="construct_signature_+3A_style">style</code></td>
<td>
<p>Boolean. Whether to give a class &quot;constructive_code&quot; on the output
for pretty printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string or a character vector, with a class &quot;constructive_code&quot; for pretty
printing if <code>style</code> is <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct_signature(lm)
</code></pre>

<hr>
<h2 id='constructive-global_options'>Global Options</h2><span id='topic+constructive-global_options'></span><span id='topic+constructive_opts_template'></span><span id='topic+constructive_pretty'></span><span id='topic+constructive_print_mode'></span>

<h3>Description</h3>

<p>Set these options to tweak {constructive}'s global behavior, to set them
permanently you can edit your <code>.RProfile</code> (<code>usethis::edit_r_profile()</code> might help).
</p>


<h3>Details</h3>


<ul>
<li><p> Set <code style="white-space: pre;">&#8288;options(constructive_print_mode = &lt;character&gt;)&#8288;</code> to change the default
value of the <code>print_mode</code> arument, of <code>print.constructive</code>, where <code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> is a vector
of strings among the following :
</p>

<ul>
<li> <p><code>"console"</code> : The default behavior, the code is printed in the console
</p>
</li>
<li> <p><code>"script"</code> : The code is copied to a new R script
</p>
</li>
<li> <p><code>"reprex"</code> : The code is shown in the viewer as a reprex,
the reprex (not only the code!) is also copied to the clipboard. Note that
if the construction fails the reprex will too, and it might happen often
when constructing environments since <span class="pkg">reprex</span> opens a new session.
</p>
</li>
<li> <p><code>"clipboard"</code> : The constructed code is copied to the clipboard, if combined
with <code>"reprex"</code> this takes precedence
</p>
</li></ul>

</li>
<li><p> Set <code style="white-space: pre;">&#8288;options(constructive_opts_template = &lt;list&gt;)&#8288;</code> to set default constructive options,
see documentation of the <code>template</code> arg in <code>?construct</code>
</p>
</li>
<li><p> Set <code>options(constructive_pretty = FALSE)</code> to disable pretty printinh using
{prettycode}
</p>
</li></ul>


<hr>
<h2 id='constructive-package'>constructive: Display Idiomatic Code to Construct Most R Objects</h2><span id='topic+constructive'></span><span id='topic+constructive-package'></span>

<h3>Description</h3>

<p>Prints code that can be used to recreate R objects. In a sense it is similar to 'base::dput()' or 'base::deparse()' but 'constructive' strives to use idiomatic constructors.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Antoine Fabri <a href="mailto:antoine.fabri@gmail.com">antoine.fabri@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Kirill MÃ¼ller <a href="mailto:kirill@cynkra.com">kirill@cynkra.com</a> (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cynkra/constructive">https://github.com/cynkra/constructive</a>
</p>
</li>
<li> <p><a href="https://cynkra.github.io/constructive/">https://cynkra.github.io/constructive/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cynkra/constructive/issues">https://github.com/cynkra/constructive/issues</a>
</p>
</li></ul>


<hr>
<h2 id='constructors'>constructors</h2><span id='topic+constructors'></span>

<h3>Description</h3>

<p>A nested environment containing constructor functions for the package <span class="pkg">constructive</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 36.
</p>

<hr>
<h2 id='custom-constructors'>Custom constructors</h2><span id='topic+custom-constructors'></span>

<h3>Description</h3>

<p>We export a collection of functions that can be used to design custom methods for
<code>.cstr_construct()</code> or custom constructors for a given method.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>.cstr_construct</code> : Low level generic for object construction code generation
</p>
</li>
<li> <p><code>.cstr_repair_attributes</code> : Helper to repair attributes of objects
</p>
</li>
<li> <p><code>.cstr_options</code> : Define and check options to pass to custom constructors
</p>
</li>
<li> <p><code>.cstr_fetch_opts</code>
</p>
</li>
<li> <p><code>.cstr_apply</code>
</p>
</li>
<li> <p><code>.cstr_wrap</code>
</p>
</li>
<li> <p><code>.cstr_pipe</code>
</p>
</li>
<li> <p><code>.cstr_combine_errors</code>
</p>
</li></ul>


<hr>
<h2 id='deparse_call'>Deparse a language object</h2><span id='topic+deparse_call'></span>

<h3>Description</h3>

<p>This is an alternative to <code>base::deparse()</code> and <code>rlang::expr_deparse()</code> that
handles additional corner cases and fails when encountering tokens other than
symbols and syntactic literals where cited alternatives would produce non syntactic code.<br /><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deparse_call(
  call,
  one_liner = FALSE,
  pipe = FALSE,
  style = TRUE,
  collapse = !style,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deparse_call_+3A_call">call</code></td>
<td>
<p>A call</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_one_liner">one_liner</code></td>
<td>
<p>Boolean. Whether to collapse multi-line expressions on a single line using
semicolons</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_pipe">pipe</code></td>
<td>
<p>Boolean. Whether to use the base pipe to disentangle nested calls. This
works best on simple calls.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_style">style</code></td>
<td>
<p>Boolean. Whether to give a class &quot;constructive_code&quot; on the output
for pretty printing.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_collapse">collapse</code></td>
<td>
<p>Boolean. Whether to collapse the output to a single string,
won't be directly visible if <code>style</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="deparse_call_+3A_unicode_representation">unicode_representation</code></td>
<td>
<p>By default &quot;ascii&quot;, which means only ASCII characters
(code point &lt; 128) will be used to construct a string. This makes sure that
homoglyphs (different spaces and other identically displayed unicode characters)
are printed differently, and avoid possible unfortunate copy and paste
auto conversion issues. &quot;latin&quot; is more lax and uses all latin characters
(code point &lt; 256). &quot;character&quot; shows all characters, but not emojis. Finally
&quot;unicode&quot; displays all characters and emojis, which is what <code>dput()</code> does.</p>
</td></tr>
<tr><td><code id="deparse_call_+3A_escape">escape</code></td>
<td>
<p>Whether to escape double quotes and backslashes. If <code>FALSE</code> we use
single quotes to suround strings containing double quotes, and raw strings
for strings that contain backslashes and/or a combination of single and
double quotes. Depending on <code>unicode_representation</code> <code>escape = FALSE</code> cannot be applied
on all strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string or a character vector, with a class &quot;constructive_code&quot; for pretty
printing if <code>style</code> is <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expr &lt;- quote(foo(bar({this; that}, 1)))
deparse_call(expr)
deparse_call(expr, one_liner = TRUE)
deparse_call(expr, pipe = TRUE)
deparse_call(expr, style = FALSE)
# some corner cases are handled better than in base R
deparse(call("$", 1, 1)) # returns non syntactic output
deparse_call(call("$", 1, 1))
</code></pre>

<hr>
<h2 id='opts_array'>Constructive options for arrays</h2><span id='topic+opts_array'></span>

<h3>Description</h3>

<p>These options will be used on arrays. Note that arrays can be built on top of
vectors, lists or expressions. Canonical arrays have an implicit class &quot;array&quot;
shown by <code>class()</code> but &quot;array&quot; is not part of the class attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_array(constructor = c("array", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_array_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_array_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"array"</code> (default): Use the <code>array()</code> function
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_array&gt;
</p>

<hr>
<h2 id='opts_AsIs'>Constructive options for the class <code>AsIs</code></h2><span id='topic+opts_AsIs'></span>

<h3>Description</h3>

<p>These options will be used on objects of class <code>AsIs</code>. <code>AsIs</code> objects are
created with <code>I()</code> which only prepends <code>"AsIs"</code> to the class attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_AsIs(constructor = c("I", "next", "atomic"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_AsIs_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_AsIs_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"I"</code> (default): Use the <code>I()</code> function
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_array&gt;
</p>

<hr>
<h2 id='opts_atomic'>Constructive options for atomic types</h2><span id='topic+opts_atomic'></span>

<h3>Description</h3>

<p>These options will be used on atomic types (&quot;logical&quot;, &quot;integer&quot;, &quot;numeric&quot;, &quot;complex&quot;, &quot;character&quot; and &quot;raw&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_atomic(
  ...,
  trim = NULL,
  fill = c("default", "rlang", "+", "...", "none"),
  compress = TRUE,
  unicode_representation = c("ascii", "latin", "character", "unicode"),
  escape = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_atomic_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
<tr><td><code id="opts_atomic_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_atomic_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements.</p>
</td></tr>
<tr><td><code id="opts_atomic_+3A_compress">compress</code></td>
<td>
<p>Boolean. It <code>TRUE</code> instead of <code>c()</code> Use <code>seq()</code>, <code>rep()</code>, or atomic constructors <code>logical()</code>, <code>integer()</code>,
<code>numeric()</code>, <code>complex()</code>, <code>raw()</code> when relevant to simplify the output.</p>
</td></tr>
<tr><td><code id="opts_atomic_+3A_unicode_representation">unicode_representation</code></td>
<td>
<p>By default &quot;ascii&quot;, which means only ASCII characters
(code point &lt; 128) will be used to construct a string. This makes sure that
homoglyphs (different spaces and other identically displayed unicode characters)
are printed differently, and avoid possible unfortunate copy and paste
auto conversion issues. &quot;latin&quot; is more lax and uses all latin characters
(code point &lt; 256). &quot;character&quot; shows all characters, but not emojis. Finally
&quot;unicode&quot; displays all characters and emojis, which is what <code>dput()</code> does.</p>
</td></tr>
<tr><td><code id="opts_atomic_+3A_escape">escape</code></td>
<td>
<p>Whether to escape double quotes and backslashes. If <code>FALSE</code> we use
single quotes to suround strings containing double quotes, and raw strings
for strings that contain backslashes and/or a combination of single and
double quotes. Depending on <code>unicode_representation</code> <code>escape = FALSE</code> cannot be applied
on all strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>trim</code> is provided, depending on <code>fill</code> we will present trimmed elements as followed:
</p>

<ul>
<li> <p><code>"default"</code> : Use default atomic constructors, so for instance <code>c("a", "b", "c")</code> might become <code>c("a", character(2))</code>.
</p>
</li>
<li> <p><code>"rlang"</code> : Use rlang atomic constructors, so for instance <code>c("a", "b", "c")</code> might become <code>c("a", rlang::new_character(2))</code>,
these <code>rlang</code> constructors create vectors of <code>NAs</code>, so it's different from the default option.
</p>
</li>
<li> <p><code>"+"</code>: Use unary <code>+</code>, so for instance <code>c("a", "b", "c")</code> might become <code>c("a", +2)</code>.
</p>
</li>
<li> <p><code>"..."</code>: Use <code>...</code>, so for instance <code>c("a", "b", "c")</code> might become <code>c("a", ...)</code>
</p>
</li>
<li> <p><code>"none"</code>: Don't represent trimmed elements.
</p>
</li></ul>

<p>Depending on the case some or all of the choices above might generate code that
cannot be executed. The 2 former options above are the most likely to suceed
and produce an output of the same type and dimensions recursively. This would
at least be the case for data frame.
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_atomic&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct(iris, opts_atomic(trim = 2), check = FALSE) # fill = "default"
construct(iris, opts_atomic(trim = 2, fill = "rlang"), check = FALSE)
construct(iris, opts_atomic(trim = 2, fill = "+"), check = FALSE)
construct(iris, opts_atomic(trim = 2, fill = "..."), check = FALSE)
construct(iris, opts_atomic(trim = 2, fill = "none"), check = FALSE)
construct(iris, opts_atomic(trim = 2, fill = "none"), check = FALSE)
x &lt;- c("a a", "a\U000000A0a", "a\U00002002a", "\U430 \U430")
construct(x, opts_atomic(unicode_representation = "unicode"))
construct(x, opts_atomic(unicode_representation = "character"))
construct(x, opts_atomic(unicode_representation = "latin"))
construct(x, opts_atomic(unicode_representation = "ascii"))
</code></pre>

<hr>
<h2 id='opts_classGeneratorFunction'>Constructive options for class 'classGeneratorFunction'</h2><span id='topic+opts_classGeneratorFunction'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'classGeneratorFunction'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_classGeneratorFunction(constructor = c("setClass"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_classGeneratorFunction_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_classGeneratorFunction_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_classGeneratorFunction&gt;
</p>

<hr>
<h2 id='opts_classPrototypeDef'>Constructive options for class 'classPrototypeDef'</h2><span id='topic+opts_classPrototypeDef'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'classPrototypeDef'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_classPrototypeDef(constructor = c("prototype"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_classPrototypeDef_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object, see Details section.</p>
</td></tr>
<tr><td><code id="opts_classPrototypeDef_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_classPrototypeDef&gt;
</p>

<hr>
<h2 id='opts_classRepresentation'>Constructive options for class 'classRepresentation'</h2><span id='topic+opts_classRepresentation'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'classRepresentation'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_classRepresentation(constructor = c("getClassDef"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_classRepresentation_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the object.</p>
</td></tr>
<tr><td><code id="opts_classRepresentation_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_classRepresentation&gt;
</p>

<hr>
<h2 id='opts_constructive_options'>Constructive options for the class <code>constructive_options</code></h2><span id='topic+opts_constructive_options'></span>

<h3>Description</h3>

<p>These options will be used on objects of class <code>constructive_options</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_constructive_options(constructor = c("opts", "next"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_constructive_options_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_constructive_options_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"opts"</code> : Use the relevant <code style="white-space: pre;">&#8288;constructive::opts_?()&#8288;</code> function.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_array&gt;
</p>

<hr>
<h2 id='opts_data.frame'>Constructive options for class 'data.frame'</h2><span id='topic+opts_data.frame'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'data.frame'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_data.frame(
  constructor = c("data.frame", "read.table", "next", "list"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_data.frame_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_data.frame_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"data.frame"</code> (default): Wrap the column definitions in a <code>data.frame()</code> call. If some
columns are lists or data frames, we wrap the column definitions in <code>tibble::tibble()</code>.
then use <code>as.data.frame()</code>.
</p>
</li>
<li> <p><code>"read.table"</code> : We build the object using <code>read.table()</code> if possible, or fall
back to <code>data.frame()</code>.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_data.frame&gt;
</p>

<hr>
<h2 id='opts_data.table'>Constructive options for class 'data.table'</h2><span id='topic+opts_data.table'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'data.table'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_data.table(
  constructor = c("data.table", "next", "list"),
  ...,
  selfref = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_data.table_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_data.table_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
<tr><td><code id="opts_data.table_+3A_selfref">selfref</code></td>
<td>
<p>Boolean. Whether to include the <code>.internal.selfref</code> attribute. It's
probably not useful, hence the default, <code>waldo::compare()</code> is used to assess the output
fidelity and doesn't check it, but if you really need to generate code that builds
an object <code>identical()</code> to the input you'll need to set this to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"data.table"</code> (default): Wrap the column definitions in a <code>data.table()</code> call.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_data.table&gt;
</p>

<hr>
<h2 id='opts_Date'>Constructive options class 'Date'</h2><span id='topic+opts_Date'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'date'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_Date(
  constructor = c("as.Date", "as_date", "date", "new_date", "as.Date.numeric",
    "as_date.numeric", "next", "atomic"),
  ...,
  origin = "1970-01-01"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_Date_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_Date_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
<tr><td><code id="opts_Date_+3A_origin">origin</code></td>
<td>
<p>Origin to be used, ignored when irrelevant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"as.Date"</code> (default): We wrap a character vector with <code>as.Date()</code>, if the date
is infinite it cannot be converted to character and we wrap a numeric vector and
provide an <code>origin</code> argument.
</p>
</li>
<li> <p><code>"as_date"</code> : Similar as above but using <code>lubridate::as_date()</code>, the only difference is
that we never need to supply <code>origin</code>.
</p>
</li>
<li> <p><code>"date"</code> : Similar as above but using <code>lubridate::date()</code>, it doesn't support
infinite dates so we fall back on <code>lubridate::as_date()</code> when we encounter them.
</p>
</li>
<li> <p><code>"new_date"</code> : We wrap a numeric vector with <code>vctrs::new_date()</code>
</p>
</li>
<li> <p><code>"as.Date.numeric"</code> : We wrap a numeric vector with <code>as.Date()</code> and use the
provided <code>origin</code>
</p>
</li>
<li> <p><code>"as_date.numeric"</code> : Same as above but using <code>lubridate::as_date()</code> and use the
provided <code>origin</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_dm'>Constructive options class 'dm'</h2><span id='topic+opts_dm'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'dm'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_dm(constructor = c("dm", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_dm_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_dm_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"dm"</code> (default): We use <code>dm::dm()</code> and other functions from <span class="pkg">dm</span> to adjust the content.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_dots'>Constructive options for type '...'</h2><span id='topic+opts_dots'></span>

<h3>Description</h3>

<p>These options will be used on objects of type '...'. These are rarely encountered
in practice. By default this function is useless as nothing can be set, this
is provided in case users want to extend the method with other constructors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_dots(constructor = c("default"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_dots_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_dots_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"default"</code> : We use the construct <code>(function(...) environment()$...)(a = x, y)</code>
which we evaluate in the correct environment.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_environment'>Constructive options for type 'environment'</h2><span id='topic+opts_environment'></span>

<h3>Description</h3>

<p>Environments use reference semantics, they cannot be copied.
An attempt to copy an environment would indeed yield a different environment and <code>identical(env, copy)</code> would be <code>FALSE</code>.<br />
Moreover most environments have a parent (exceptions are <code>emptyenv()</code> and some
rare cases where the parent is <code>NULL</code>) and thus to copy the environment we'd
have to have a way to point to the parent, or copy it too. <br />
For this reason environments are <span class="pkg">constructive</span>'s cryptonite. They make some objects
impossible to reproduce exactly. And since every function or formula has one they're hard to
avoid. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_environment(
  constructor = c(".env", "list2env", "as.environment", "new.env", "topenv",
    "new_environment"),
  ...,
  recurse = FALSE,
  predefine = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_environment_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see <strong>Constructors</strong> section.</p>
</td></tr>
<tr><td><code id="opts_environment_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
<tr><td><code id="opts_environment_+3A_recurse">recurse</code></td>
<td>
<p>Boolean. Only considered if <code>constructor</code> is <code>"list2env"</code> or <code>"new_environment"</code>. Whether to
attempt to recreate all parent environments until a known environment is found,
if <code>FALSE</code> (the default) we will use <code>topenv()</code> to find a known ancestor to set as
the parent.</p>
</td></tr>
<tr><td><code id="opts_environment_+3A_predefine">predefine</code></td>
<td>
<p>Boolean. Whether to define environments first. If <code>TRUE</code> <code>constructor</code> and <code>recurse</code>
are ignored. It circumvents the circularity, recursivity and redundancy issues of
other constructors. The caveat is that the created code won't be a single call
and will create objects in the workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some case we can build code that points to a specific environment, namely:
</p>

<ul>
<li> <p><code>.GlobalEnv</code>, <code>.BaseNamespaceEnv</code>, <code>baseenv()</code> and <code>emptyenv()</code> are used to construct
the global environment, the base namespace, the base package environment and the empty
environment
</p>
</li>
<li><p> Namespaces are constructed using <code>asNamespace("pkg")</code>
</p>
</li>
<li><p> Package environments are constructed using <code>as.environment("package:pkg")</code>
</p>
</li></ul>

<p>By default For other environments we use <span class="pkg">constructive</span>'s function <code>constructive::.env()</code>, it fetches
the environment from its memory address and provides as additional information
the sequence of parents until we reach a special environment (those enumerated above).
The advantage of this approach is that it's readable and that the object is accurately reproduced.
The inconvenient is that it's not stable between sessions. If an environment has a <code>NULL</code> parent it's always constructed
with <code>constructive::.env()</code>, whatever the choice of the constructor.
</p>
<p>Often however we wish to be able to reproduce from scratch a similar environment,
so that we might run the constructed code later in a new session. We offer different
different options to do this, with different trade-offs regarding accuracy and verbosity.
</p>
<p>{constructive} will not signal any difference if it can reproduce an equivalent environment,
defined as containing the same values and having a same or equivalent parent.<br />
</p>
<p>See also the <code>ignore_function_env</code> argument in <code>?compare_options</code>, which disables the check
of environments of function.
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>


<h3>Constructors</h3>

<p>We might set the <code>constructor</code> argument to:
</p>

<ul>
<li> <p><code>".env"</code> (default): use <code>constructive::.env()</code> to construct the environment from
its memory address.
</p>
</li></ul>


<ul>
<li> <p><code>"list2env"</code>: We construct the environment as a list then
use <code>base::list2env()</code> to convert it to an environment and assign it a parent. By
default we will use <code>base::topenv()</code> to construct a parent. If <code>recurse</code> is <code>TRUE</code>
the parent will be built recursively so all ancestors will be created until
we meet a known environment, this might be verbose and will fail if environments
are nested too deep or have a circular relationship. If the environment is empty we use <code>new.env(parent=)</code>
for a more economic syntax.
</p>
</li>
<li> <p><code>"new_environment"</code> : Similar to the above, but using <code>rlang::new_environment()</code>.
</p>
</li>
<li> <p><code>"new.env"</code> : All environments will be recreated with the code <code>"base::new.env()"</code>,
without argument, effectively creating an empty environment child of
the local (often global) environment. This is enough in cases where the environment
doesn't matter (or matters as long as it inherits from the local environment),
as is often the case with formulas. <code>recurse</code> is ignored.
</p>
</li>
<li> <p><code>"as.environment"</code> : we attempt to construct the environment as a list and use
<code>base::as.environment()</code> on top of it, as in <code>as.environment(list(a=1, b=2))</code>, it will
contain the same variables as the original environment but the parent will be the
<code>emptyenv()</code>. <code>recurse</code> is ignored.
</p>
</li>
<li> <p><code>"topenv"</code> : we construct <code>base::topenv(x)</code>, see <code>?topenv</code>. <code>recurse</code> is ignored.
This is the most accurate we can be when constructing only special environments.
</p>
</li></ul>



<h3>Predefine</h3>

<p>Building environments from scratch using the above methods can be verbose and
sometimes redundant if and environment is used several times. One last option
is to define the environments and their content above the object returning call,
using placeholder names <code>..env.1..</code>, <code>..env.2..</code> etc. This is done by setting
<code>predefine</code> to <code>TRUE</code>. <code>constructor</code> and <code>recurse</code> are ignored in that case.
</p>

<hr>
<h2 id='opts_externalptr'>Constructive options for type 'externalptr'</h2><span id='topic+opts_externalptr'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'externalptr'. By default this
function is useless as nothing can be set, this is provided in case users wan
to extend the method with other constructors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_externalptr(constructor = c("default"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_externalptr_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_externalptr_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"default"</code> : We use a special function from the constructive
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_factor'>Constructive options for class 'factor'</h2><span id='topic+opts_factor'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'factor'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_factor(
  constructor = c("factor", "as_factor", "new_factor", "next", "atomic"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_factor_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_factor_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"factor"</code> (default): Build the object using <code>factor()</code>, levels won't
be defined explicitly if they are in alphabetical order (locale dependent!)
</p>
</li>
<li> <p><code>"as_factor"</code> : Build the object using <code>forcats::as_factor()</code> whenever
possible, i.e. when levels are defined in order of appearance in the vector. Otherwise falls back to <code>"factor"</code> constructor.
</p>
</li>
<li> <p><code>"new_factor"</code> : Build the object using <code>vctrs::new_factor()</code>. Levels are
always defined explicitly.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_formula'>Constructive options for formulas</h2><span id='topic+opts_formula'></span>

<h3>Description</h3>

<p>These options will be used on formulas, defined as calls to <code>~</code>, regardless
of their <code>"class"</code> attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_formula(
  constructor = c("~", "formula", "as.formula", "new_formula", "next"),
  ...,
  environment = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_formula_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_formula_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
<tr><td><code id="opts_formula_+3A_environment">environment</code></td>
<td>
<p>Boolean. Whether to attempt to construct the environment, if
it makes a difference to construct it.
</p>
<p>Depending on <code>constructor</code>, we construct the formula as follows:
</p>

<ul>
<li> <p><code>"~"</code> (default): We construct the formula in the most common way using the <code>~</code>
operator.
</p>
</li>
<li> <p><code>"formula"</code> : deparse the formula as a string and use <code>base::formula()</code> on top of it.
</p>
</li>
<li> <p><code>"as.formula"</code> : Same as above, but using <code>base::as.formula()</code>.
</p>
</li>
<li> <p><code>"new_formula"</code> : extract both sides of the formula as separate language objects
and feed them to <code>rlang::new_formula()</code>, along with the reconstructed environment
if relevant.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_function'>Constructive options for functions</h2><span id='topic+opts_function'></span>

<h3>Description</h3>

<p>These options will be used on functions, i.e. objects of type &quot;closure&quot;, &quot;special&quot; and &quot;builtin&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_function(
  constructor = c("function", "as.function", "new_function"),
  ...,
  environment = TRUE,
  srcref = FALSE,
  trim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_function_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_function_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
<tr><td><code id="opts_function_+3A_environment">environment</code></td>
<td>
<p>Boolean. Whether to reconstruct the function's environment.</p>
</td></tr>
<tr><td><code id="opts_function_+3A_srcref">srcref</code></td>
<td>
<p>Boolean. Whether to attempt to reconstruct the function's srcref.</p>
</td></tr>
<tr><td><code id="opts_function_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of lines showed in the body before it's trimmed,
replacing code with <code>...</code>. Note that it will necessarily produce code that doesn't
reproduce the input, but it will parse and evaluate without failure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"function"</code> (default): Build the object using a standard <code>function() {}</code>
definition. This won't set the environment by default, unless <code>environment</code>
is set to <code>TRUE</code>. If a srcref is available, if this srcref matches the function's
definition, and if <code>trim</code> is left <code>NULL</code>, the code is returned from using the srcref,
so comments will be shown in the output of <code>construct()</code>. In the rare case
where the ast body of the function contains non syntactic nodes this constructor
cannot be used and falls back to the <code>"as.function"</code> constructor.
</p>
</li>
<li> <p><code>"as.function"</code> : Build the object using a <code>as.function()</code> call.
back to <code>data.frame()</code>.
</p>
</li>
<li> <p><code>"new_function"</code> : Build the object using a <code>rlang::new_function()</code> call.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_function&gt;
</p>

<hr>
<h2 id='opts_grouped_df'>Constructive options for class 'grouped_df'</h2><span id='topic+opts_grouped_df'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'grouped_df'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_grouped_df(constructor = c("default", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_grouped_df_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_grouped_df_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : We define as an list object and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_language'>Constructive options for type 'language'</h2><span id='topic+opts_language'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'language'. By default this
function is useless as nothing can be set, this is provided in case users want
to extend the method with other constructors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_language(constructor = c("default"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_language_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_language_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"default"</code> : We use constructive's deparsing algorithm on attributeless calls,
and use <code>as.call()</code> on other language elements when attributes need to be constructed.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_Layer'>Constructive options for class 'Layer' (ggplot2)</h2><span id='topic+opts_Layer'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'Layer'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_Layer(constructor = c("default", "layer", "environment"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_Layer_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_Layer_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"default"</code> : We attempt to use the function originally used to create the
plot.
</p>
</li>
<li> <p><code>"layer"</code> : We use the <code>ggplot2::layer()</code> function
</p>
</li>
<li> <p><code>"environment"</code> : Reconstruct the object using the general environment method
(which can be itself tweaked using <code>opts_environment()</code>)
</p>
</li></ul>

<p>The latter constructor is the only one that reproduces the object exactly
since Layers are environments and environments can't be exactly copied (see <code>?opts_environment</code>)
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_Layer&gt;
</p>

<hr>
<h2 id='opts_list'>Constructive options for type 'list'</h2><span id='topic+opts_list'></span>

<h3>Description</h3>

<p>These options will be used on objects of type 'list'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_list(
  constructor = c("list", "list2"),
  ...,
  trim = NULL,
  fill = c("vector", "new_list", "+", "...", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_list_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_list_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
<tr><td><code id="opts_list_+3A_trim">trim</code></td>
<td>
<p><code>NULL</code> or integerish. Maximum of elements showed before it's trimmed.
Note that it will necessarily produce code that doesn't reproduce the input.
This code will parse without failure but its evaluation might fail.</p>
</td></tr>
<tr><td><code id="opts_list_+3A_fill">fill</code></td>
<td>
<p>String. Method to use to represent the trimmed elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"list"</code> (default): Build the object by calling <code>list()</code>.
</p>
</li>
<li> <p><code>"list2"</code>: Build the object by calling <code>rlang::list2()</code>, the only difference with
the above is that we keep a trailing comma when the list is not trimmed and the call
spans several lines.
</p>
</li></ul>

<p>If <code>trim</code> is provided, depending on <code>fill</code> we will present trimmed elements as followed:
</p>

<ul>
<li> <p><code>"vector"</code> (default): Use <code>vector()</code>, so for instance <code>list("a", "b", "c")</code> might become <code>c(list("a"), vector("list", 2))</code>.
</p>
</li>
<li> <p><code>"new_list"</code>: Use <code>rlang::new_list()</code>, so for instance <code>list("a", "b", "c")</code> might become <code>c(list("a"), rlang::new_list(2))</code>.
</p>
</li>
<li> <p><code>"+"</code>: Use unary <code>+</code>, so for instance <code>list("a", "b", "c")</code> might become <code>list("a", +2)</code>.
</p>
</li>
<li> <p><code>"..."</code>: Use <code>...</code>, so for instance <code>list("a", "b", "c")</code> might become <code>list("a", ...)</code>
</p>
</li>
<li> <p><code>"none"</code>: Don't represent trimmed elements.
</p>
</li></ul>

<p>When <code>trim</code> is used the output is parsable but might not be possible to evaluate,
especially with <code>fill = "..."</code>. In that case you might want to set <code>check = FALSE</code>
</p>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_list&gt;
</p>

<hr>
<h2 id='opts_matrix'>Constructive options for matrices</h2><span id='topic+opts_matrix'></span>

<h3>Description</h3>

<p>Matrices are atomic vectors, lists, or objects of type <code>"expression"</code> with a <code>"dim"</code>
attributes of length 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_matrix(constructor = c("matrix", "array", "next", "atomic"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_matrix_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_matrix_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"matrix"</code> : We use <code>matrix()</code>
</p>
</li>
<li> <p><code>"array"</code> : We use <code>array()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"array"</code>
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_mts'>Constructive options for time-series objets</h2><span id='topic+opts_mts'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"ts"</code> : We use <code>ts()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"atomic"</code>
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_mts(constructor = c("ts", "next", "atomic"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_mts_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_mts_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_numeric_version'>Constructive options for numeric_version</h2><span id='topic+opts_numeric_version'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"numeric_version"</code> : We use <code>numeric_version()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"array"</code>
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_numeric_version(constructor = c("numeric_version", "next", "atomic"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_numeric_version_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_numeric_version_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_ordered'>Constructive options for class 'ordered'</h2><span id='topic+opts_ordered'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'ordered'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_ordered(
  constructor = c("ordered", "factor", "new_ordered", "next", "atomic"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_ordered_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_ordered_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"ordered"</code> (default): Build the object using <code>ordered()</code>, levels won't
be defined explicitly if they are in alphabetical order (locale dependent!)
</p>
</li>
<li> <p><code>"factor"</code> : Same as above but build the object using <code>factor()</code> and <code>ordered = TRUE</code>.
</p>
</li>
<li> <p><code>"new_ordered"</code> : Build the object using <code>vctrs::new_ordered()</code>. Levels are
always defined explicitly.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_package_version'>Constructive options for package_version</h2><span id='topic+opts_package_version'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"package_version"</code> : We use <code>package_version()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"array"</code>
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_package_version(constructor = c("package_version", "next", "atomic"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_package_version_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_package_version_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_pairlist'>Constructive options for pairlists</h2><span id='topic+opts_pairlist'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"pairlist"</code> (default): Build the object using a <code>pairlist()</code> call.
</p>
</li>
<li> <p><code>"pairlist2"</code> : Build the object using a <code>rlang::pairlist2()</code> call.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_pairlist(constructor = c("pairlist", "pairlist2"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_pairlist_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_pairlist_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_POSIXct'>Constructive options for class 'POSIXct'</h2><span id='topic+opts_POSIXct'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'POSIXct'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_POSIXct(
  constructor = c("as.POSIXct", ".POSIXct", "as_datetime", "as.POSIXct.numeric",
    "as_datetime.numeric", "next", "atomic"),
  ...,
  origin = "1970-01-01"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_POSIXct_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_POSIXct_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
<tr><td><code id="opts_POSIXct_+3A_origin">origin</code></td>
<td>
<p>Origin to be used, ignored when irrelevant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"as.POSIXct"</code> (default): Build the object using a <code>as.POSIXct()</code> call on a
character vector.
</p>
</li>
<li> <p><code>".POSIXct"</code> : Build the object using a <code>.POSIXct()</code> call on a numeric vector.
</p>
</li>
<li> <p><code>"as_datetime"</code> : Build the object using a <code>lubridate::as_datetime()</code> call on
a character vector.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_POSIXlt'>Constructive options for class 'POSIXlt'</h2><span id='topic+opts_POSIXlt'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'POSIXlt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_POSIXlt(constructor = c("as.POSIXlt", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_POSIXlt_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_POSIXlt_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"as.POSIXlt"</code> (default): Build the object using a <code>as.POSIXlt()</code> call on a
character vector.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : We define as a list and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_quosure'>Constructive options for class 'quosure'</h2><span id='topic+opts_quosure'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'quosure'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_quosure(constructor = c("new_quosure", "next", "language"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_quosure_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_quosure_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"new_quosure"</code> (default): Build the object using a <code>new_quosure()</code> call on a
character vector.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"language"</code> : We define as an language object and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_quosures'>Constructive options for class 'quosures'</h2><span id='topic+opts_quosures'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'quosures'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_quosures(constructor = c("new_quosures", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_quosures_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_quosures_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"as_quosures"</code> (default): Build the object using a <code>as_quosures()</code> call on a
character vector.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : We define as an list object and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_R_system_version'>Constructive options for R_system_version</h2><span id='topic+opts_R_system_version'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"R_system_version"</code> : We use <code>R_system_version()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"array"</code>
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_R_system_version(
  constructor = c("R_system_version", "next", "atomic"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_R_system_version_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_R_system_version_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_rowwise_df'>Constructive options for class 'rowwise_df'</h2><span id='topic+opts_rowwise_df'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'rowwise_df'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_rowwise_df(constructor = c("default", "next", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_rowwise_df_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_rowwise_df_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : We define as an list object and repair attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_factor&gt;
</p>

<hr>
<h2 id='opts_S4'>Constructive options for class 'S4'</h2><span id='topic+opts_S4'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'S4'. Note that the support
for S4 is very experimental so might easily beak. Please report issues if it
does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_S4(constructor = c("new"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_S4_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_S4_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_S4&gt;
</p>

<hr>
<h2 id='opts_tbl_df'>Constructive options for tibbles</h2><span id='topic+opts_tbl_df'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'tbl_df', also known as tibbles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_tbl_df(
  constructor = c("tibble", "tribble", "next", "list"),
  ...,
  trailing_comma = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_tbl_df_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_tbl_df_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
<tr><td><code id="opts_tbl_df_+3A_trailing_comma">trailing_comma</code></td>
<td>
<p>Boolean, whether to leave a trailing comma at the end of the constructor call
calls</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"tibble"</code> (default): Wrap the column definitions in a <code>tibble::tibble()</code> call.
</p>
</li>
<li> <p><code>"tribble"</code> : We build the object using <code>tibble::tribble()</code> if possible, and fall
back to <code>tibble::tibble()</code>.
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_tbl_df&gt;
</p>

<hr>
<h2 id='opts_ts'>Constructive options for time-series objets</h2><span id='topic+opts_ts'></span>

<h3>Description</h3>

<p>Depending on <code>constructor</code>, we construct the environment as follows:
</p>

<ul>
<li> <p><code>"ts"</code> : We use <code>ts()</code>
</p>
</li>
<li> <p><code>"next"</code> : Use the constructor for the next supported class. Call <code>.class2()</code>
on the object to see in which order the methods will be tried. This will usually
be equivalent to <code>"atomic"</code>
</p>
</li>
<li> <p><code>"atomic"</code> : We define as an atomic vector and repair attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opts_ts(constructor = c("ts", "next", "atomic"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_ts_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment.</p>
</td></tr>
<tr><td><code id="opts_ts_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_environment&gt;
</p>

<hr>
<h2 id='opts_vctrs_list_of'>Constructive options for class 'data.table'</h2><span id='topic+opts_vctrs_list_of'></span>

<h3>Description</h3>

<p>These options will be used on objects of class 'data.table'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_vctrs_list_of(constructor = c("list_of", "list"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_vctrs_list_of_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the function used to construct the environment, see Details section.</p>
</td></tr>
<tr><td><code id="opts_vctrs_list_of_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>constructor</code>, we construct the object as follows:
</p>

<ul>
<li> <p><code>"list_of"</code> (default): Wrap the column definitions in a <code>list_of()</code> call.
</p>
</li>
<li> <p><code>"list"</code> : Use <code>list()</code> and treat the class as a regular attribute.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_data.table&gt;
</p>

<hr>
<h2 id='opts_weakref'>Constructive options for the class <code>weakref</code></h2><span id='topic+opts_weakref'></span>

<h3>Description</h3>

<p>These options will be used on objects of type <code>weakref</code>. <code>weakref</code> objects
are rarely encountered and there is no base R function to create them. However
<span class="pkg">rlang</span> has a <code>new_weakref</code> function that we can use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_weakref(constructor = c("new_weakref"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opts_weakref_+3A_constructor">constructor</code></td>
<td>
<p>String. Name of the constructor.</p>
</td></tr>
<tr><td><code id="opts_weakref_+3A_...">...</code></td>
<td>
<p>Should not be used. Forces passing arguments by name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lt;constructive_options/constructive_options_array&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
