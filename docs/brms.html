<!DOCTYPE html><html><head><title>Help for package brms</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {brms}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brms-package'><p>Bayesian Regression Models using 'Stan'</p></a></li>
<li><a href='#add_criterion'><p>Add model fit criteria to model objects</p></a></li>
<li><a href='#add_loo'><p>Add model fit criteria to model objects</p></a></li>
<li><a href='#add_rstan_model'><p>Add compiled <span class="pkg">rstan</span> models to <code>brmsfit</code> objects</p></a></li>
<li><a href='#addition-terms'><p>Additional Response Information</p></a></li>
<li><a href='#ar'><p>Set up AR(p) correlation structures</p></a></li>
<li><a href='#arma'><p>Set up ARMA(p,q) correlation structures</p></a></li>
<li><a href='#as.brmsprior'><p>Transform into a brmsprior object</p></a></li>
<li><a href='#as.data.frame.brmsfit'><p>Extract Posterior Draws</p></a></li>
<li><a href='#as.mcmc.brmsfit'><p>(Deprecated) Extract posterior samples for use with the <span class="pkg">coda</span> package</p></a></li>
<li><a href='#AsymLaplace'><p>The Asymmetric Laplace Distribution</p></a></li>
<li><a href='#autocor-terms'><p>Autocorrelation structures</p></a></li>
<li><a href='#autocor.brmsfit'><p>(Deprecated) Extract Autocorrelation Objects</p></a></li>
<li><a href='#bayes_factor.brmsfit'><p>Bayes Factors from Marginal Likelihoods</p></a></li>
<li><a href='#bayes_R2.brmsfit'><p>Compute a Bayesian version of R-squared for regression models</p></a></li>
<li><a href='#BetaBinomial'><p>The Beta-binomial Distribution</p></a></li>
<li><a href='#bridge_sampler.brmsfit'><p>Log Marginal Likelihood via Bridge Sampling</p></a></li>
<li><a href='#brm'><p>Fit Bayesian Generalized (Non-)Linear Multivariate Multilevel Models</p></a></li>
<li><a href='#brm_multiple'><p>Run the same <span class="pkg">brms</span> model on multiple datasets</p></a></li>
<li><a href='#brmsfamily'><p>Special Family Functions for <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#brmsfit_needs_refit'><p>Check if cached fit can be used.</p></a></li>
<li><a href='#brmsfit-class'><p>Class <code>brmsfit</code> of models fitted with the <span class="pkg">brms</span> package</p></a></li>
<li><a href='#brmsformula'><p>Set up a model formula for use in <span class="pkg">brms</span></p></a></li>
<li><a href='#brmsformula-helpers'><p>Linear and Non-linear formulas in <span class="pkg">brms</span></p></a></li>
<li><a href='#brmshypothesis'><p>Descriptions of <code>brmshypothesis</code> Objects</p></a></li>
<li><a href='#brmsterms'><p>Parse Formulas of <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#car'><p>Spatial conditional autoregressive (CAR) structures</p></a></li>
<li><a href='#coef.brmsfit'><p>Extract Model Coefficients</p></a></li>
<li><a href='#combine_models'><p>Combine Models fitted with <span class="pkg">brms</span></p></a></li>
<li><a href='#compare_ic'><p>Compare Information Criteria of Different Models</p></a></li>
<li><a href='#conditional_effects.brmsfit'><p>Display Conditional Effects of Predictors</p></a></li>
<li><a href='#conditional_smooths.brmsfit'><p>Display Smooth Terms</p></a></li>
<li><a href='#constant'><p>Constant priors in <span class="pkg">brms</span></p></a></li>
<li><a href='#control_params'><p>Extract Control Parameters of the NUTS Sampler</p></a></li>
<li><a href='#cor_ar'><p>(Deprecated) AR(p) correlation structure</p></a></li>
<li><a href='#cor_arma'><p>(Deprecated) ARMA(p,q) correlation structure</p></a></li>
<li><a href='#cor_arr'><p>(Defunct) ARR correlation structure</p></a></li>
<li><a href='#cor_brms'><p>(Deprecated) Correlation structure classes for the <span class="pkg">brms</span> package</p></a></li>
<li><a href='#cor_bsts'><p>(Defunct) Basic Bayesian Structural Time Series</p></a></li>
<li><a href='#cor_car'><p>(Deprecated) Spatial conditional autoregressive (CAR) structures</p></a></li>
<li><a href='#cor_cosy'><p>(Deprecated) Compound Symmetry (COSY) Correlation Structure</p></a></li>
<li><a href='#cor_fixed'><p>(Deprecated) Fixed user-defined covariance matrices</p></a></li>
<li><a href='#cor_ma'><p>(Deprecated) MA(q) correlation structure</p></a></li>
<li><a href='#cor_sar'><p>(Deprecated) Spatial simultaneous autoregressive (SAR) structures</p></a></li>
<li><a href='#cosy'><p>Set up COSY correlation structures</p></a></li>
<li><a href='#cs'><p>Category Specific Predictors in <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#custom_family'><p>Custom Families in <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#data_predictor'><p>Prepare Predictor Data</p></a></li>
<li><a href='#data_response'><p>Prepare Response Data</p></a></li>
<li><a href='#default_prior'><p>Default priors for Bayesian models</p></a></li>
<li><a href='#default_prior.default'><p>Default Priors for <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#density_ratio'><p>Compute Density Ratios</p></a></li>
<li><a href='#diagnostic-quantities'><p>Extract Diagnostic Quantities of <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#Dirichlet'><p>The Dirichlet Distribution</p></a></li>
<li><a href='#do_call'><p>Execute a Function Call</p></a></li>
<li><a href='#draws-brms'><p>Transform <code>brmsfit</code> to <code>draws</code> objects</p></a></li>
<li><a href='#draws-index-brms'><p>Index <code>brmsfit</code> objects</p></a></li>
<li><a href='#emmeans-brms-helpers'><p>Support Functions for <span class="pkg">emmeans</span></p></a></li>
<li><a href='#epilepsy'><p>Epileptic seizure counts</p></a></li>
<li><a href='#ExGaussian'><p>The Exponentially Modified Gaussian Distribution</p></a></li>
<li><a href='#expose_functions.brmsfit'><p>Expose user-defined <span class="pkg">Stan</span> functions</p></a></li>
<li><a href='#expp1'><p>Exponential function plus one.</p></a></li>
<li><a href='#family.brmsfit'><p>Extract Model Family Objects</p></a></li>
<li><a href='#fcor'><p>Fixed residual correlation (FCOR) structures</p></a></li>
<li><a href='#fitted.brmsfit'><p>Expected Values of the Posterior Predictive Distribution</p></a></li>
<li><a href='#fixef.brmsfit'><p>Extract Population-Level Estimates</p></a></li>
<li><a href='#Frechet'><p>The Frechet Distribution</p></a></li>
<li><a href='#GenExtremeValue'><p>The Generalized Extreme Value Distribution</p></a></li>
<li><a href='#get_dpar'><p>Draws of a Distributional Parameter</p></a></li>
<li><a href='#get_refmodel.brmsfit'><p>Projection Predictive Variable Selection: Get Reference Model</p></a></li>
<li><a href='#get_y'><p>Extract response values</p></a></li>
<li><a href='#gp'><p>Set up Gaussian process terms in <span class="pkg">brms</span></p></a></li>
<li><a href='#gr'><p>Set up basic grouping terms in <span class="pkg">brms</span></p></a></li>
<li><a href='#horseshoe'><p>Regularized horseshoe priors in <span class="pkg">brms</span></p></a></li>
<li><a href='#Hurdle'><p>Hurdle Distributions</p></a></li>
<li><a href='#hypothesis.brmsfit'><p>Non-Linear Hypothesis Testing</p></a></li>
<li><a href='#inhaler'><p>Clarity of inhaler instructions</p></a></li>
<li><a href='#inv_logit_scaled'><p>Scaled inverse logit-link</p></a></li>
<li><a href='#InvGaussian'><p>The Inverse Gaussian Distribution</p></a></li>
<li><a href='#is.brmsfit'><p>Checks if argument is a <code>brmsfit</code> object</p></a></li>
<li><a href='#is.brmsfit_multiple'><p>Checks if argument is a <code>brmsfit_multiple</code> object</p></a></li>
<li><a href='#is.brmsformula'><p>Checks if argument is a <code>brmsformula</code> object</p></a></li>
<li><a href='#is.brmsprior'><p>Checks if argument is a <code>brmsprior</code> object</p></a></li>
<li><a href='#is.brmsterms'><p>Checks if argument is a <code>brmsterms</code> object</p></a></li>
<li><a href='#is.cor_brms'><p>Check if argument is a correlation structure</p></a></li>
<li><a href='#is.mvbrmsformula'><p>Checks if argument is a <code>mvbrmsformula</code> object</p></a></li>
<li><a href='#is.mvbrmsterms'><p>Checks if argument is a <code>mvbrmsterms</code> object</p></a></li>
<li><a href='#kfold_predict'><p>Predictions from K-Fold Cross-Validation</p></a></li>
<li><a href='#kfold.brmsfit'><p>K-Fold Cross-Validation</p></a></li>
<li><a href='#kidney'><p>Infections in kidney patients</p></a></li>
<li><a href='#lasso'><p>(Defunct) Set up a lasso prior in <span class="pkg">brms</span></p></a></li>
<li><a href='#launch_shinystan.brmsfit'><p>Interface to <span class="pkg">shinystan</span></p></a></li>
<li><a href='#log_lik.brmsfit'><p>Compute the Pointwise Log-Likelihood</p></a></li>
<li><a href='#LogisticNormal'><p>The (Multivariate) Logistic Normal Distribution</p></a></li>
<li><a href='#logit_scaled'><p>Scaled logit-link</p></a></li>
<li><a href='#logm1'><p>Logarithm with a minus one offset.</p></a></li>
<li><a href='#loo_compare.brmsfit'><p>Model comparison with the <span class="pkg">loo</span> package</p></a></li>
<li><a href='#loo_model_weights.brmsfit'><p>Model averaging via stacking or pseudo-BMA weighting.</p></a></li>
<li><a href='#loo_moment_match.brmsfit'><p>Moment matching for efficient approximate leave-one-out cross-validation</p></a></li>
<li><a href='#loo_predict.brmsfit'><p>Compute Weighted Expectations Using LOO</p></a></li>
<li><a href='#loo_R2.brmsfit'><p>Compute a LOO-adjusted R-squared for regression models</p></a></li>
<li><a href='#loo_subsample.brmsfit'><p>Efficient approximate leave-one-out cross-validation (LOO) using subsampling</p></a></li>
<li><a href='#loo.brmsfit'><p>Efficient approximate leave-one-out cross-validation (LOO)</p></a></li>
<li><a href='#loss'><p>Cumulative Insurance Loss Payments</p></a></li>
<li><a href='#ma'><p>Set up MA(q) correlation structures</p></a></li>
<li><a href='#make_conditions'><p>Prepare Fully Crossed Conditions</p></a></li>
<li><a href='#mcmc_plot.brmsfit'><p>MCMC Plots Implemented in <span class="pkg">bayesplot</span></p></a></li>
<li><a href='#me'><p>Predictors with Measurement Error in <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#mi'><p>Predictors with Missing Values in <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#mixture'><p>Finite Mixture Families in <span class="pkg">brms</span></p></a></li>
<li><a href='#mm'><p>Set up multi-membership grouping terms in <span class="pkg">brms</span></p></a></li>
<li><a href='#mmc'><p>Multi-Membership Covariates</p></a></li>
<li><a href='#mo'><p>Monotonic Predictors in <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#model_weights.brmsfit'><p>Model Weighting Methods</p></a></li>
<li><a href='#MultiNormal'><p>The Multivariate Normal Distribution</p></a></li>
<li><a href='#MultiStudentT'><p>The Multivariate Student-t Distribution</p></a></li>
<li><a href='#mvbind'><p>Bind response variables in multivariate models</p></a></li>
<li><a href='#mvbrmsformula'><p>Set up a multivariate model formula for use in <span class="pkg">brms</span></p></a></li>
<li><a href='#ngrps.brmsfit'><p>Number of Grouping Factor Levels</p></a></li>
<li><a href='#nsamples.brmsfit'><p>(Deprecated) Number of Posterior Samples</p></a></li>
<li><a href='#opencl'><p>GPU support in Stan via OpenCL</p></a></li>
<li><a href='#pairs.brmsfit'><p>Create a matrix of output plots from a <code>brmsfit</code> object</p></a></li>
<li><a href='#parnames'><p>Extract Parameter Names</p></a></li>
<li><a href='#plot.brmsfit'><p>Trace and Density Plots for MCMC Draws</p></a></li>
<li><a href='#post_prob.brmsfit'><p>Posterior Model Probabilities from Marginal Likelihoods</p></a></li>
<li><a href='#posterior_average.brmsfit'><p>Posterior draws of parameters averaged across models</p></a></li>
<li><a href='#posterior_epred.brmsfit'><p>Draws from the Expected Value of the Posterior Predictive Distribution</p></a></li>
<li><a href='#posterior_interval.brmsfit'><p>Compute posterior uncertainty intervals</p></a></li>
<li><a href='#posterior_linpred.brmsfit'><p>Posterior Draws of the Linear Predictor</p></a></li>
<li><a href='#posterior_predict.brmsfit'><p>Draws from the Posterior Predictive Distribution</p></a></li>
<li><a href='#posterior_samples.brmsfit'><p>(Deprecated) Extract Posterior Samples</p></a></li>
<li><a href='#posterior_smooths.brmsfit'><p>Posterior Predictions of Smooth Terms</p></a></li>
<li><a href='#posterior_summary'><p>Summarize Posterior draws</p></a></li>
<li><a href='#posterior_table'><p>Table Creation for Posterior Draws</p></a></li>
<li><a href='#pp_average.brmsfit'><p>Posterior predictive draws averaged across models</p></a></li>
<li><a href='#pp_check.brmsfit'><p>Posterior Predictive Checks for <code>brmsfit</code> Objects</p></a></li>
<li><a href='#pp_mixture.brmsfit'><p>Posterior Probabilities of Mixture Component Memberships</p></a></li>
<li><a href='#predict.brmsfit'><p>Draws from the Posterior Predictive Distribution</p></a></li>
<li><a href='#predictive_error.brmsfit'><p>Posterior Draws of Predictive Errors</p></a></li>
<li><a href='#predictive_interval.brmsfit'><p>Predictive Intervals</p></a></li>
<li><a href='#prepare_predictions.brmsfit'><p>Prepare Predictions</p></a></li>
<li><a href='#print.brmsfit'><p>Print a summary for a fitted model represented by a <code>brmsfit</code> object</p></a></li>
<li><a href='#print.brmsprior'><p>Print method for <code>brmsprior</code> objects</p></a></li>
<li><a href='#prior_draws.brmsfit'><p>Extract Prior Draws</p></a></li>
<li><a href='#prior_summary.brmsfit'><p>Priors of <code>brms</code> models</p></a></li>
<li><a href='#psis.brmsfit'><p>Pareto smoothed importance sampling (PSIS)</p></a></li>
<li><a href='#R2D2'><p>R2D2 Priors in <span class="pkg">brms</span></p></a></li>
<li><a href='#ranef.brmsfit'><p>Extract Group-Level Estimates</p></a></li>
<li><a href='#read_csv_as_stanfit'><p>Read CmdStan CSV files as a brms-formatted stanfit object</p></a></li>
<li><a href='#recompile_model'><p>Recompile Stan models in <code>brmsfit</code> objects</p></a></li>
<li><a href='#reloo.brmsfit'><p>Compute exact cross-validation for problematic observations</p></a></li>
<li><a href='#rename_pars'><p>Rename parameters in brmsfit objects</p></a></li>
<li><a href='#residuals.brmsfit'><p>Posterior Draws of Residuals/Predictive Errors</p></a></li>
<li><a href='#restructure'><p>Restructure Old R Objects</p></a></li>
<li><a href='#restructure.brmsfit'><p>Restructure Old <code>brmsfit</code> Objects</p></a></li>
<li><a href='#rows2labels'><p>Convert Rows to Labels</p></a></li>
<li><a href='#s'><p>Defining smooths in <span class="pkg">brms</span> formulas</p></a></li>
<li><a href='#sar'><p>Spatial simultaneous autoregressive (SAR) structures</p></a></li>
<li><a href='#save_pars'><p>Control Saving of Parameter Draws</p></a></li>
<li><a href='#set_prior'><p>Prior Definitions for <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#Shifted_Lognormal'><p>The Shifted Log Normal Distribution</p></a></li>
<li><a href='#SkewNormal'><p>The Skew-Normal Distribution</p></a></li>
<li><a href='#stancode'><p>Stan Code for Bayesian models</p></a></li>
<li><a href='#stancode.brmsfit'><p>Extract Stan code from <code>brmsfit</code> objects</p></a></li>
<li><a href='#stancode.default'><p>Stan Code for <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#standata'><p>Stan data for Bayesian models</p></a></li>
<li><a href='#standata.brmsfit'><p>Extract data passed to Stan from <code>brmsfit</code> objects</p></a></li>
<li><a href='#standata.default'><p>Data for <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#stanvar'><p>User-defined variables passed to Stan</p></a></li>
<li><a href='#StudentT'><p>The Student-t Distribution</p></a></li>
<li><a href='#summary.brmsfit'><p>Create a summary of a fitted model represented by a <code>brmsfit</code> object</p></a></li>
<li><a href='#theme_black'><p>(Deprecated) Black Theme for <span class="pkg">ggplot2</span> Graphics</p></a></li>
<li><a href='#theme_default'><p>Default <span class="pkg">bayesplot</span> Theme for <span class="pkg">ggplot2</span> Graphics</p></a></li>
<li><a href='#threading'><p>Threading in Stan</p></a></li>
<li><a href='#unstr'><p>Set up UNSTR correlation structures</p></a></li>
<li><a href='#update_adterms'><p>Update Formula Addition Terms</p></a></li>
<li><a href='#update.brmsfit'><p>Update <span class="pkg">brms</span> models</p></a></li>
<li><a href='#update.brmsfit_multiple'><p>Update <span class="pkg">brms</span> models based on multiple data sets</p></a></li>
<li><a href='#validate_newdata'><p>Validate New Data</p></a></li>
<li><a href='#validate_prior'><p>Validate Prior for <span class="pkg">brms</span> Models</p></a></li>
<li><a href='#VarCorr.brmsfit'><p>Extract Variance and Correlation Components</p></a></li>
<li><a href='#vcov.brmsfit'><p>Covariance and Correlation Matrix of Population-Level Effects</p></a></li>
<li><a href='#VonMises'><p>The von Mises Distribution</p></a></li>
<li><a href='#waic.brmsfit'><p>Widely Applicable Information Criterion (WAIC)</p></a></li>
<li><a href='#Wiener'><p>The Wiener Diffusion Model Distribution</p></a></li>
<li><a href='#ZeroInflated'><p>Zero-Inflated Distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Regression Models using 'Stan'</td>
</tr>
<tr>
<td>Version:</td>
<td>2.21.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-18</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), Rcpp (&ge; 0.12.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstan (&ge; 2.29.0), ggplot2 (&ge; 2.0.0), loo (&ge; 2.3.1),
posterior (&ge; 1.0.0), Matrix (&ge; 1.1.1), mgcv (&ge; 1.8-13),
rstantools (&ge; 2.1.1), bayesplot (&ge; 1.5.0), bridgesampling (&ge;
0.3-0), glue (&ge; 1.3.0), rlang (&ge; 1.0.0), future (&ge; 1.19.0),
future.apply (&ge; 1.0.0), matrixStats, nleqslv, nlme, coda,
abind, stats, utils, parallel, grDevices, backports</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.9.1), emmeans (&ge; 1.4.2), cmdstanr (&ge; 0.5.0),
projpred (&ge; 2.0.0), shinystan (&ge; 2.4.0), splines2 (&ge; 0.5.0),
RWiener, rtdists, extraDistr, processx, mice, spdep, mnormt,
lme4, MCMCglmm, ape, arm, statmod, digest, diffobj, R.rsp,
gtable, shiny, knitr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Bayesian generalized (non-)linear multivariate multilevel models
    using 'Stan' for full Bayesian inference. A wide range of distributions
    and link functions are supported, allowing users to fit &ndash; among others &ndash;
    linear, robust linear, count data, survival, response times, ordinal,
    zero-inflated, hurdle, and even self-defined mixture models all in a
    multilevel context. Further modeling options include both theory-driven and
    data-driven non-linear terms, auto-correlation structures, censoring and 
    truncation, meta-analytic standard errors, and quite a few more. 
    In addition, all parameters of the response distribution can be predicted 
    in order to perform distributional regression. Prior specifications are 
    flexible and explicitly encourage users to apply prior distributions that
    actually reflect their prior knowledge. Models can easily be evaluated and
    compared using several methods assessing posterior or prior predictions. 
    References: Bürkner (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v080.i01">doi:10.18637/jss.v080.i01</a>&gt;; 
    Bürkner (2018) &lt;<a href="https://doi.org/10.32614%2FRJ-2018-017">doi:10.32614/RJ-2018-017</a>&gt;;
    Bürkner (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i05">doi:10.18637/jss.v100.i05</a>&gt;; Carpenter et al. (2017)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v076.i01">doi:10.18637/jss.v076.i01</a>&gt;.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/paul-buerkner/brms">https://github.com/paul-buerkner/brms</a>,
<a href="https://discourse.mc-stan.org/">https://discourse.mc-stan.org/</a>,
<a href="https://paul-buerkner.github.io/brms/">https://paul-buerkner.github.io/brms/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paul-buerkner/brms/issues">https://github.com/paul-buerkner/brms/issues</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-19 20:40:33 UTC; paul.buerkner</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul-Christian Bürkner [aut, cre],
  Jonah Gabry [ctb],
  Sebastian Weber [ctb],
  Andrew Johnson [ctb],
  Martin Modrak [ctb],
  Hamada S. Badr [ctb],
  Frank Weber [ctb],
  Aki Vehtari [ctb],
  Mattan S. Ben-Shachar [ctb],
  Hayden Rabel [ctb],
  Simon C. Mills [ctb],
  Stephen Wild [ctb],
  Ven Popov [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul-Christian Bürkner &lt;paul.buerkner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 12:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='brms-package'>Bayesian Regression Models using 'Stan'</h2><span id='topic+brms-package'></span><span id='topic+brms'></span>

<h3>Description</h3>


<p><img src="../help/figures/stanlogo.png" width="50" alt="https://mc-stan.org/about/logo/" />
<em>Stan Development Team</em>

</p>
<p>The <span class="pkg">brms</span> package provides an interface to fit Bayesian generalized
multivariate (non-)linear multilevel models using <span class="pkg">Stan</span>, which is a C++
package for obtaining full Bayesian inference (see
<a href="https://mc-stan.org/">https://mc-stan.org/</a>). The formula syntax is an extended version of the
syntax applied in the <span class="pkg">lme4</span> package to provide a familiar and simple
interface for performing regression analyses.
</p>


<h3>Details</h3>

<p>The main function of <span class="pkg">brms</span> is <code><a href="#topic+brm">brm</a></code>, which uses
formula syntax to specify a wide range of complex Bayesian models
(see <code><a href="#topic+brmsformula">brmsformula</a></code> for details). Based on the supplied
formulas, data, and additional information, it writes the Stan code
on the fly via <code><a href="#topic+stancode.default">stancode</a></code>, prepares the data via
<code><a href="#topic+standata.default">standata</a></code> and fits the model using
<span class="pkg"><a href="rstan.html#topic+rstan">Stan</a></span>.
</p>
<p>Subsequently, a large number of post-processing methods can be applied:
To get an overview on the estimated parameters,
<code><a href="#topic+summary.brmsfit">summary</a></code> or
<code><a href="#topic+conditional_effects.brmsfit">conditional_effects</a></code>
are perfectly suited. Detailed visual analyses can be performed by applying
the <code><a href="#topic+pp_check">pp_check</a></code> and <code><a href="#topic+stanplot">stanplot</a></code> methods, which both
rely on the <span class="pkg"><a href="bayesplot.html#topic+bayesplot-package">bayesplot</a></span> package.
Model comparisons can be done via <code><a href="#topic+loo">loo</a></code> and <code><a href="#topic+waic">waic</a></code>,
which make use of the <span class="pkg"><a href="loo.html#topic+loo-package">loo</a></span> package as well as
via <code><a href="#topic+bayes_factor">bayes_factor</a></code> which relies on the <span class="pkg">bridgesampling</span> package.
For a full list of methods to apply, type <code>methods(class = "brmsfit")</code>.
</p>
<p>Because <span class="pkg">brms</span> is based on <span class="pkg">Stan</span>, a C++ compiler is required. The
program Rtools (available on
<a href="https://cran.r-project.org/bin/windows/Rtools/">https://cran.r-project.org/bin/windows/Rtools/</a>) comes with a C++
compiler for Windows. On Mac, you should use Xcode. For further instructions
on how to get the compilers running, see the prerequisites section at the
<a href="https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started">RStan-Getting-Started</a>
page.
</p>
<p>When comparing other packages fitting multilevel models to <span class="pkg">brms</span>, keep
in mind that the latter needs to compile models before actually fitting them,
which will require between 20 and 40 seconds depending on your machine,
operating system and overall model complexity.
</p>
<p>Thus, fitting smaller models may be relatively slow as compilation time makes
up the majority of the whole running time. For larger / more complex
models however, fitting my take several minutes or even hours, so that the
compilation time won't make much of a difference for these models.
</p>
<p>See <code>vignette("brms_overview")</code> and <code>vignette("brms_multilevel")</code>
for a general introduction and overview of <span class="pkg">brms</span>. For a full list of
available vignettes, type <code>vignette(package = "brms")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paul-Christian Bürkner <a href="mailto:paul.buerkner@gmail.com">paul.buerkner@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Jonah Gabry [contributor]
</p>
</li>
<li><p> Sebastian Weber [contributor]
</p>
</li>
<li><p> Andrew Johnson [contributor]
</p>
</li>
<li><p> Martin Modrak [contributor]
</p>
</li>
<li><p> Hamada S. Badr [contributor]
</p>
</li>
<li><p> Frank Weber [contributor]
</p>
</li>
<li><p> Aki Vehtari [contributor]
</p>
</li>
<li><p> Mattan S. Ben-Shachar [contributor]
</p>
</li>
<li><p> Hayden Rabel [contributor]
</p>
</li>
<li><p> Simon C. Mills [contributor]
</p>
</li>
<li><p> Stephen Wild [contributor]
</p>
</li>
<li><p> Ven Popov [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Paul-Christian Buerkner (2017). brms: An R Package for Bayesian Multilevel
Models Using Stan. <em>Journal of Statistical Software</em>, 80(1), 1-28.
<code>doi:10.18637/jss.v080.i01</code>
</p>
<p>Paul-Christian Buerkner (2018). Advanced Bayesian Multilevel Modeling
with the R Package brms. <em>The R Journal</em>. 10(1), 395–411.
<code>doi:10.32614/RJ-2018-017</code>
</p>
<p>The Stan Development Team. <em>Stan Modeling Language User's Guide and
Reference Manual</em>. <a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>.
</p>
<p>Stan Development Team (2020). RStan: the R interface to Stan. R package
version 2.21.2. <a href="https://mc-stan.org/">https://mc-stan.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brm">brm</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>,
<code><a href="#topic+brmsfamily">brmsfamily</a></code>,
<code><a href="#topic+brmsfit">brmsfit</a></code>
</p>

<hr>
<h2 id='add_criterion'>Add model fit criteria to model objects</h2><span id='topic+add_criterion'></span><span id='topic+add_criterion.brmsfit'></span>

<h3>Description</h3>

<p>Add model fit criteria to model objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_criterion(x, ...)

## S3 method for class 'brmsfit'
add_criterion(
  x,
  criterion,
  model_name = NULL,
  overwrite = FALSE,
  file = NULL,
  force_save = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_criterion_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object typically of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="add_criterion_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying
functions computing the model fit criteria. If you are recomputing
an already stored criterion with other <code>...</code> arguments, make
sure to set <code>overwrite = TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_criterion_+3A_criterion">criterion</code></td>
<td>
<p>Names of model fit criteria
to compute. Currently supported are <code>"loo"</code>,
<code>"waic"</code>, <code>"kfold"</code>, <code>"loo_subsample"</code>,
<code>"bayes_R2"</code> (Bayesian R-squared),
<code>"loo_R2"</code> (LOO-adjusted R-squared), and
<code>"marglik"</code> (log marginal likelihood).</p>
</td></tr>
<tr><td><code id="add_criterion_+3A_model_name">model_name</code></td>
<td>
<p>Optional name of the model. If <code>NULL</code>
(the default) the name is taken from the call to <code>x</code>.</p>
</td></tr>
<tr><td><code id="add_criterion_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical; Indicates if already stored fit
indices should be overwritten. Defaults to <code>FALSE</code>.
Setting it to <code>TRUE</code> is useful for example when changing
additional arguments of an already stored criterion.</p>
</td></tr>
<tr><td><code id="add_criterion_+3A_file">file</code></td>
<td>
<p>Either <code>NULL</code> or a character string. In the latter case, the
fitted model object including the newly added criterion values is saved via
<code><a href="base.html#topic+saveRDS">saveRDS</a></code> in a file named after the string supplied in
<code>file</code>. The <code>.rds</code> extension is added automatically. If <code>x</code>
was already stored in a file before, the file name will be reused
automatically (with a message) unless overwritten by <code>file</code>. In any
case, <code>file</code> only applies if new criteria were actually added via
<code>add_criterion</code> or if <code>force_save</code> was set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_criterion_+3A_force_save">force_save</code></td>
<td>
<p>Logical; only relevant if <code>file</code> is specified and
ignored otherwise. If <code>TRUE</code>, the fitted model object will be saved
regardless of whether new criteria were added via <code>add_criterion</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>add_loo</code> and <code>add_waic</code> are aliases of
<code>add_criterion</code> with fixed values for the <code>criterion</code> argument.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>, but
with model fit criteria added for later usage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ Trt, data = epilepsy)
# add both LOO and WAIC at once
fit &lt;- add_criterion(fit, c("loo", "waic"))
print(fit$criteria$loo)
print(fit$criteria$waic)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_loo'>Add model fit criteria to model objects</h2><span id='topic+add_loo'></span><span id='topic+add_waic'></span><span id='topic+add_ic'></span><span id='topic+add_ic.brmsfit'></span><span id='topic+add_ic+3C-'></span>

<h3>Description</h3>

<p>Deprecated aliases of <code><a href="#topic+add_criterion">add_criterion</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_loo(x, model_name = NULL, ...)

add_waic(x, model_name = NULL, ...)

add_ic(x, ...)

## S3 method for class 'brmsfit'
add_ic(x, ic = "loo", model_name = NULL, ...)

add_ic(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_loo_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object typically of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="add_loo_+3A_model_name">model_name</code></td>
<td>
<p>Optional name of the model. If <code>NULL</code>
(the default) the name is taken from the call to <code>x</code>.</p>
</td></tr>
<tr><td><code id="add_loo_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying
functions computing the model fit criteria. If you are recomputing
an already stored criterion with other <code>...</code> arguments, make
sure to set <code>overwrite = TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_loo_+3A_ic">ic</code>, <code id="add_loo_+3A_value">value</code></td>
<td>
<p>Names of model fit criteria
to compute. Currently supported are <code>"loo"</code>,
<code>"waic"</code>, <code>"kfold"</code>, <code>"R2"</code> (R-squared), and
<code>"marglik"</code> (log marginal likelihood).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>, but
with model fit criteria added for later usage.
Previously computed criterion objects will be overwritten.
</p>

<hr>
<h2 id='add_rstan_model'>Add compiled <span class="pkg">rstan</span> models to <code>brmsfit</code> objects</h2><span id='topic+add_rstan_model'></span>

<h3>Description</h3>

<p>Compile a <code><a href="rstan.html#topic+stanmodel-class">stanmodel</a></code> and add
it to a <code>brmsfit</code> object. This enables some advanced functionality
of <span class="pkg">rstan</span>, most notably <code><a href="rstan.html#topic+log_prob">log_prob</a></code>
and friends, to be used with brms models fitted with other Stan backends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_rstan_model(x, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_rstan_model_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object to be updated.</p>
</td></tr>
<tr><td><code id="add_rstan_model_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. If <code>TRUE</code>, overwrite any existing
<code><a href="rstan.html#topic+stanmodel-class">stanmodel</a></code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (possibly updated) <code>brmsfit</code> object.
</p>

<hr>
<h2 id='addition-terms'>Additional Response Information</h2><span id='topic+addition-terms'></span><span id='topic+se'></span><span id='topic+weights'></span><span id='topic+trials'></span><span id='topic+thres'></span><span id='topic+cat'></span><span id='topic+dec'></span><span id='topic+cens'></span><span id='topic+trunc'></span><span id='topic+index'></span><span id='topic+rate'></span><span id='topic+subset'></span><span id='topic+vreal'></span><span id='topic+vint'></span><span id='topic+resp_se'></span><span id='topic+resp_weights'></span><span id='topic+resp_trials'></span><span id='topic+resp_thres'></span><span id='topic+resp_cat'></span><span id='topic+resp_dec'></span><span id='topic+resp_cens'></span><span id='topic+resp_trunc'></span><span id='topic+resp_mi'></span><span id='topic+resp_index'></span><span id='topic+resp_rate'></span><span id='topic+resp_subset'></span><span id='topic+resp_vreal'></span><span id='topic+resp_vint'></span>

<h3>Description</h3>

<p>Provide additional information on the response variable
in <span class="pkg">brms</span> models, such as censoring, truncation, or
known measurement error. Detailed documentation on the use
of each of these functions can be found in the Details section
of <code><a href="#topic+brmsformula">brmsformula</a></code> (under &quot;Additional response information&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_se(x, sigma = FALSE)

resp_weights(x, scale = FALSE)

resp_trials(x)

resp_thres(x, gr = NA)

resp_cat(x)

resp_dec(x)

resp_cens(x, y2 = NA)

resp_trunc(lb = -Inf, ub = Inf)

resp_mi(sdy = NA)

resp_index(x)

resp_rate(denom)

resp_subset(x)

resp_vreal(...)

resp_vint(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addition-terms_+3A_x">x</code></td>
<td>
<p>A vector; Ideally a single variable defined in the data (see
Details). Allowed values depend on the function: <code>resp_se</code> and
<code>resp_weights</code> require positive numeric values. <code>resp_trials</code>,
<code>resp_thres</code>, and <code>resp_cat</code> require positive integers.
<code>resp_dec</code> requires <code>0</code> and <code>1</code>, or alternatively
<code>'lower'</code> and <code>'upper'</code>. <code>resp_subset</code> requires <code>0</code> and
<code>1</code>, or alternatively <code>FALSE</code> and <code>TRUE</code>. <code>resp_cens</code>
requires <code>'left'</code>, <code>'none'</code>, <code>'right'</code>, and
<code>'interval'</code> (or equivalently <code>-1</code>, <code>0</code>, <code>1</code>, and
<code>2</code>) to indicate left, no, right, or interval censoring.
<code>resp_index</code> does not make any requirements other than the value being
unique for each observation.</p>
</td></tr>
<tr><td><code id="addition-terms_+3A_sigma">sigma</code></td>
<td>
<p>Logical; Indicates whether the residual standard deviation
parameter <code>sigma</code> should be included in addition to the known
measurement error. Defaults to <code>FALSE</code> for backwards compatibility,
but setting it to <code>TRUE</code> is usually the better choice.</p>
</td></tr>
<tr><td><code id="addition-terms_+3A_scale">scale</code></td>
<td>
<p>Logical; Indicates whether weights should be scaled
so that the average weight equals one. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="addition-terms_+3A_gr">gr</code></td>
<td>
<p>A vector of grouping indicators.</p>
</td></tr>
<tr><td><code id="addition-terms_+3A_y2">y2</code></td>
<td>
<p>A vector specifying the upper bounds in interval censoring.
Will be ignored for non-interval censored observations. However, it
should NOT be <code>NA</code> even for non-interval censored observations to
avoid accidental exclusion of these observations.</p>
</td></tr>
<tr><td><code id="addition-terms_+3A_lb">lb</code></td>
<td>
<p>A numeric vector or single numeric value specifying
the lower truncation bound.</p>
</td></tr>
<tr><td><code id="addition-terms_+3A_ub">ub</code></td>
<td>
<p>A numeric vector or single numeric value specifying
the upper truncation bound.</p>
</td></tr>
<tr><td><code id="addition-terms_+3A_sdy">sdy</code></td>
<td>
<p>Optional known measurement error of the response
treated as standard deviation. If specified, handles
measurement error and (completely) missing values
at the same time using the plausible-values-technique.</p>
</td></tr>
<tr><td><code id="addition-terms_+3A_denom">denom</code></td>
<td>
<p>A vector of positive numeric values specifying
the denominator values from which the response rates are computed.</p>
</td></tr>
<tr><td><code id="addition-terms_+3A_...">...</code></td>
<td>
<p>For <code>resp_vreal</code>, vectors of real values.
For <code>resp_vint</code>, vectors of integer values. In Stan,
these variables will be named <code>vreal1</code>, <code>vreal2</code>, ...,
and <code>vint1</code>, <code>vint2</code>, ..., respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are almost solely useful when
called in formulas passed to the <span class="pkg">brms</span> package.
Within formulas, the <code>resp_</code> prefix may be omitted.
More information is given in the 'Details' section
of <code><a href="#topic+brmsformula">brmsformula</a></code> (under &quot;Additional response information&quot;).
</p>
<p>It is highly recommended to use a single data variable as input
for <code>x</code> (instead of a more complicated expression) to make sure all
post-processing functions work as expected.
</p>


<h3>Value</h3>

<p>A list of additional response information to be processed further
by <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brm">brm</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Random effects meta-analysis
nstudies &lt;- 20
true_effects &lt;- rnorm(nstudies, 0.5, 0.2)
sei &lt;- runif(nstudies, 0.05, 0.3)
outcomes &lt;- rnorm(nstudies, true_effects, sei)
data1 &lt;- data.frame(outcomes, sei)
fit1 &lt;- brm(outcomes | se(sei, sigma = TRUE) ~ 1,
            data = data1)
summary(fit1)

## Probit regression using the binomial family
n &lt;- sample(1:10, 100, TRUE)  # number of trials
success &lt;- rbinom(100, size = n, prob = 0.4)
x &lt;- rnorm(100)
data2 &lt;- data.frame(n, success, x)
fit2 &lt;- brm(success | trials(n) ~ x, data = data2,
            family = binomial("probit"))
summary(fit2)

## Survival regression modeling the time between the first
## and second recurrence of an infection in kidney patients.
fit3 &lt;- brm(time | cens(censored) ~ age * sex + disease + (1|patient),
            data = kidney, family = lognormal())
summary(fit3)

## Poisson model with truncated counts
fit4 &lt;- brm(count | trunc(ub = 104) ~ zBase * Trt,
            data = epilepsy, family = poisson())
summary(fit4)

## End(Not run)

</code></pre>

<hr>
<h2 id='ar'>Set up AR(p) correlation structures</h2><span id='topic+ar'></span>

<h3>Description</h3>

<p>Set up an autoregressive (AR) term of order p in <span class="pkg">brms</span>. The function
does not evaluate its arguments &ndash; it exists purely to help set up a model
with AR terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar(time = NA, gr = NA, p = 1, cov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar_+3A_time">time</code></td>
<td>
<p>An optional time variable specifying the time ordering
of the observations. By default, the existing order of the observations
in the data is used.</p>
</td></tr>
<tr><td><code id="ar_+3A_gr">gr</code></td>
<td>
<p>An optional grouping variable. If specified, the correlation
structure is assumed to apply only to observations within the same grouping
level.</p>
</td></tr>
<tr><td><code id="ar_+3A_p">p</code></td>
<td>
<p>A non-negative integer specifying the autoregressive (AR)
order of the ARMA structure. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ar_+3A_cov">cov</code></td>
<td>
<p>A flag indicating whether ARMA effects should be estimated by
means of residual covariance matrices. This is currently only possible for
stationary ARMA effects of order 1. If the model family does not have
natural residuals, latent residuals are added automatically. If
<code>FALSE</code> (the default), a regression formulation is used that is
considerably faster and allows for ARMA effects of order higher than 1 but
is only available for <code>gaussian</code> models and some of its
generalizations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>'arma_term'</code>, which is a list
of arguments to be interpreted by the formula
parsing functions of <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocor-terms">autocor-terms</a></code>, <code><a href="#topic+arma">arma</a></code>, <code><a href="#topic+ma">ma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("LakeHuron")
LakeHuron &lt;- as.data.frame(LakeHuron)
fit &lt;- brm(x ~ ar(p = 2), data = LakeHuron)
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='arma'>Set up ARMA(p,q) correlation structures</h2><span id='topic+arma'></span>

<h3>Description</h3>

<p>Set up an autoregressive moving average (ARMA) term of order (p, q) in
<span class="pkg">brms</span>. The function does not evaluate its arguments &ndash; it exists purely
to help set up a model with ARMA terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma(time = NA, gr = NA, p = 1, q = 1, cov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma_+3A_time">time</code></td>
<td>
<p>An optional time variable specifying the time ordering
of the observations. By default, the existing order of the observations
in the data is used.</p>
</td></tr>
<tr><td><code id="arma_+3A_gr">gr</code></td>
<td>
<p>An optional grouping variable. If specified, the correlation
structure is assumed to apply only to observations within the same grouping
level.</p>
</td></tr>
<tr><td><code id="arma_+3A_p">p</code></td>
<td>
<p>A non-negative integer specifying the autoregressive (AR)
order of the ARMA structure. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="arma_+3A_q">q</code></td>
<td>
<p>A non-negative integer specifying the moving average (MA)
order of the ARMA structure. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="arma_+3A_cov">cov</code></td>
<td>
<p>A flag indicating whether ARMA effects should be estimated by
means of residual covariance matrices. This is currently only possible for
stationary ARMA effects of order 1. If the model family does not have
natural residuals, latent residuals are added automatically. If
<code>FALSE</code> (the default), a regression formulation is used that is
considerably faster and allows for ARMA effects of order higher than 1 but
is only available for <code>gaussian</code> models and some of its
generalizations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>'arma_term'</code>, which is a list
of arguments to be interpreted by the formula
parsing functions of <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocor-terms">autocor-terms</a></code>, <code><a href="#topic+ar">ar</a></code>, <code><a href="#topic+ma">ma</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("LakeHuron")
LakeHuron &lt;- as.data.frame(LakeHuron)
fit &lt;- brm(x ~ arma(p = 2, q = 1), data = LakeHuron)
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='as.brmsprior'>Transform into a brmsprior object</h2><span id='topic+as.brmsprior'></span>

<h3>Description</h3>

<p>Try to transform an object into a <code>brmsprior</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.brmsprior(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.brmsprior_+3A_x">x</code></td>
<td>
<p>An object to be transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>brmsprior</code> object if the transformation was possible.
</p>

<hr>
<h2 id='as.data.frame.brmsfit'>Extract Posterior Draws</h2><span id='topic+as.data.frame.brmsfit'></span><span id='topic+as.matrix.brmsfit'></span><span id='topic+as.array.brmsfit'></span>

<h3>Description</h3>

<p>Extract posterior draws in conventional formats
as data.frames, matrices, or arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
as.data.frame(
  x,
  row.names = NULL,
  optional = TRUE,
  pars = NA,
  variable = NULL,
  draw = NULL,
  subset = NULL,
  ...
)

## S3 method for class 'brmsfit'
as.matrix(x, pars = NA, variable = NULL, draw = NULL, subset = NULL, ...)

## S3 method for class 'brmsfit'
as.array(x, pars = NA, variable = NULL, draw = NULL, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object or another <span class="rlang"><b>R</b></span> object for which
the methods are defined.</p>
</td></tr>
<tr><td><code id="as.data.frame.brmsfit_+3A_row.names">row.names</code>, <code id="as.data.frame.brmsfit_+3A_optional">optional</code></td>
<td>
<p>Unused and only added for consistency with
the <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> generic.</p>
</td></tr>
<tr><td><code id="as.data.frame.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Deprecated alias of <code>variable</code>. For reasons of backwards
compatibility, <code>pars</code> is interpreted as a vector of regular
expressions by default unless <code>fixed = TRUE</code> is specified.</p>
</td></tr>
<tr><td><code id="as.data.frame.brmsfit_+3A_variable">variable</code></td>
<td>
<p>A character vector providing the variables to extract.
By default, all variables are extracted.</p>
</td></tr>
<tr><td><code id="as.data.frame.brmsfit_+3A_draw">draw</code></td>
<td>
<p>The draw indices to be select. Subsetting draw indices will lead
to an automatic merging of chains.</p>
</td></tr>
<tr><td><code id="as.data.frame.brmsfit_+3A_subset">subset</code></td>
<td>
<p>Deprecated alias of <code>draw</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the corresponding
<code><a href="#topic+draws-brms">as_draws_*</a></code> methods as well as to
<code><a href="posterior.html#topic+subset_draws">subset_draws</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame, matrix, or array containing the posterior draws.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draws-brms">as_draws</a></code>,
<code><a href="posterior.html#topic+subset_draws">subset_draws</a></code>
</p>

<hr>
<h2 id='as.mcmc.brmsfit'>(Deprecated) Extract posterior samples for use with the <span class="pkg">coda</span> package</h2><span id='topic+as.mcmc.brmsfit'></span><span id='topic+as.mcmc'></span>

<h3>Description</h3>

<p>The <code>as.mcmc</code> method is deprecated. We recommend using the more
modern and consistent <code><a href="#topic+draws-brms">as_draws_*</a></code> extractor
functions of the <span class="pkg">posterior</span> package instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
as.mcmc(
  x,
  pars = NA,
  fixed = FALSE,
  combine_chains = FALSE,
  inc_warmup = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.brmsfit_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object typically of class <code>brmsfit</code></p>
</td></tr>
<tr><td><code id="as.mcmc.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Names of parameters for which posterior samples
should be returned, as given by a character vector or regular expressions.
By default, all posterior samples of all parameters are extracted.</p>
</td></tr>
<tr><td><code id="as.mcmc.brmsfit_+3A_fixed">fixed</code></td>
<td>
<p>Indicates whether parameter names
should be matched exactly (<code>TRUE</code>) or treated as
regular expressions (<code>FALSE</code>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.mcmc.brmsfit_+3A_combine_chains">combine_chains</code></td>
<td>
<p>Indicates whether chains should be combined.</p>
</td></tr>
<tr><td><code id="as.mcmc.brmsfit_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>Indicates if the warmup samples should be included.
Default is <code>FALSE</code>. Warmup samples are used to tune the
parameters of the sampling algorithm and should not be analyzed.</p>
</td></tr>
<tr><td><code id="as.mcmc.brmsfit_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>combine_chains = TRUE</code> an <code>mcmc</code> object is returned.
If <code>combine_chains = FALSE</code> an <code>mcmc.list</code> object is returned.
</p>

<hr>
<h2 id='AsymLaplace'>The Asymmetric Laplace Distribution</h2><span id='topic+AsymLaplace'></span><span id='topic+dasym_laplace'></span><span id='topic+pasym_laplace'></span><span id='topic+qasym_laplace'></span><span id='topic+rasym_laplace'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the asymmetric Laplace distribution with location <code>mu</code>,
scale <code>sigma</code> and asymmetry parameter <code>quantile</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dasym_laplace(x, mu = 0, sigma = 1, quantile = 0.5, log = FALSE)

pasym_laplace(
  q,
  mu = 0,
  sigma = 1,
  quantile = 0.5,
  lower.tail = TRUE,
  log.p = FALSE
)

qasym_laplace(
  p,
  mu = 0,
  sigma = 1,
  quantile = 0.5,
  lower.tail = TRUE,
  log.p = FALSE
)

rasym_laplace(n, mu = 0, sigma = 1, quantile = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AsymLaplace_+3A_x">x</code>, <code id="AsymLaplace_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="AsymLaplace_+3A_mu">mu</code></td>
<td>
<p>Vector of locations.</p>
</td></tr>
<tr><td><code id="AsymLaplace_+3A_sigma">sigma</code></td>
<td>
<p>Vector of scales.</p>
</td></tr>
<tr><td><code id="AsymLaplace_+3A_quantile">quantile</code></td>
<td>
<p>Asymmetry parameter corresponding to quantiles
in quantile regression (hence the name).</p>
</td></tr>
<tr><td><code id="AsymLaplace_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="AsymLaplace_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="AsymLaplace_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="AsymLaplace_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="AsymLaplace_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details
on the parameterization.
</p>

<hr>
<h2 id='autocor-terms'>Autocorrelation structures</h2><span id='topic+autocor-terms'></span>

<h3>Description</h3>

<p>Specify autocorrelation terms in <span class="pkg">brms</span> models. Currently supported terms
are <code><a href="#topic+arma">arma</a></code>, <code><a href="#topic+ar">ar</a></code>, <code><a href="#topic+ma">ma</a></code>,
<code><a href="#topic+cosy">cosy</a></code>, <code><a href="#topic+unstr">unstr</a></code>, <code><a href="#topic+sar">sar</a></code>,
<code><a href="#topic+car">car</a></code>, and <code><a href="#topic+fcor">fcor</a></code>. Terms can be directly specified
within the formula, or passed to the <code>autocor</code> argument of
<code><a href="#topic+brmsformula">brmsformula</a></code> in the form of a one-sided formula. For deprecated
ways of specifying autocorrelation terms, see <code><a href="#topic+cor_brms">cor_brms</a></code>.
</p>


<h3>Details</h3>

<p>The autocor term functions are almost solely useful when called in
formulas passed to the <span class="pkg">brms</span> package. They do not evaluate its
arguments &ndash; but exist purely to help set up a model with autocorrelation
terms.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>, <code><a href="#topic+acformula">acformula</a></code>,
<code><a href="#topic+arma">arma</a></code>, <code><a href="#topic+ar">ar</a></code>, <code><a href="#topic+ma">ma</a></code>,
<code><a href="#topic+cosy">cosy</a></code>, <code><a href="#topic+unstr">unstr</a></code>, <code><a href="#topic+sar">sar</a></code>,
<code><a href="#topic+car">car</a></code>, <code><a href="#topic+fcor">fcor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify autocor terms within the formula
y ~ x + arma(p = 1, q = 1) + car(M)

# specify autocor terms in the 'autocor' argument
bf(y ~ x, autocor = ~ arma(p = 1, q = 1) + car(M))

# specify autocor terms via 'acformula'
bf(y ~ x) + acformula(~ arma(p = 1, q = 1) + car(M))
</code></pre>

<hr>
<h2 id='autocor.brmsfit'>(Deprecated) Extract Autocorrelation Objects</h2><span id='topic+autocor.brmsfit'></span><span id='topic+autocor'></span>

<h3>Description</h3>

<p>(Deprecated) Extract Autocorrelation Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
autocor(object, resp = NULL, ...)

autocor(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocor.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="autocor.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="autocor.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>cor_brms</code> object or a list of such objects for multivariate
models. Not supported for models fitted with brms 2.11.1 or higher.
</p>

<hr>
<h2 id='bayes_factor.brmsfit'>Bayes Factors from Marginal Likelihoods</h2><span id='topic+bayes_factor.brmsfit'></span><span id='topic+bayes_factor'></span>

<h3>Description</h3>

<p>Compute Bayes factors from marginal likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
bayes_factor(x1, x2, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_factor.brmsfit_+3A_x1">x1</code></td>
<td>
<p>A <code>brmsfit</code> object</p>
</td></tr>
<tr><td><code id="bayes_factor.brmsfit_+3A_x2">x2</code></td>
<td>
<p>Another <code>brmsfit</code> object based on the same responses.</p>
</td></tr>
<tr><td><code id="bayes_factor.brmsfit_+3A_log">log</code></td>
<td>
<p>Report Bayes factors on the log-scale?</p>
</td></tr>
<tr><td><code id="bayes_factor.brmsfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+bridge_sampler.brmsfit">bridge_sampler</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the marginal likelihood requires samples
of all variables defined in Stan's <code>parameters</code> block
to be saved. Otherwise <code>bayes_factor</code> cannot be computed.
Thus, please set <code>save_all_pars = TRUE</code> in the call to <code>brm</code>,
if you are planning to apply <code>bayes_factor</code> to your models.
</p>
<p>The computation of Bayes factors based on bridge sampling requires
a lot more posterior samples than usual. A good conservative
rule of thumb is perhaps 10-fold more samples (read: the default of 4000
samples may not be enough in many cases). If not enough posterior
samples are provided, the bridge sampling algorithm tends to be unstable,
leading to considerably different results each time it is run.
We thus recommend running <code>bayes_factor</code>
multiple times to check the stability of the results.
</p>
<p>More details are provided under
<code><a href="bridgesampling.html#topic+bf">bridgesampling::bayes_factor</a></code>.
</p>


<h3>See Also</h3>

<p><code>
  <a href="#topic+bridge_sampler.brmsfit">bridge_sampler</a>,
  <a href="#topic+post_prob.brmsfit">post_prob</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with the treatment effect
fit1 &lt;- brm(
  count ~ zAge + zBase + Trt,
  data = epilepsy, family = negbinomial(),
  prior = prior(normal(0, 1), class = b),
  save_all_pars = TRUE
)
summary(fit1)

# model without the treatment effect
fit2 &lt;- brm(
  count ~ zAge + zBase,
  data = epilepsy, family = negbinomial(),
  prior = prior(normal(0, 1), class = b),
  save_all_pars = TRUE
)
summary(fit2)

# compute the bayes factor
bayes_factor(fit1, fit2)

## End(Not run)

</code></pre>

<hr>
<h2 id='bayes_R2.brmsfit'>Compute a Bayesian version of R-squared for regression models</h2><span id='topic+bayes_R2.brmsfit'></span><span id='topic+bayes_R2'></span>

<h3>Description</h3>

<p>Compute a Bayesian version of R-squared for regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
bayes_R2(
  object,
  resp = NULL,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_R2.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="bayes_R2.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="bayes_R2.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bayes_R2.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bayes_R2.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bayes_R2.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="#topic+posterior_epred.brmsfit">posterior_epred</a></code>,
which is used in the computation of the R-squared values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an introduction to the approach, see Gelman et al. (2018)
and <a href="https://github.com/jgabry/bayes_R2/">https://github.com/jgabry/bayes_R2/</a>.
</p>


<h3>Value</h3>

<p>If <code>summary = TRUE</code>, an M x C matrix is returned
(M = number of response variables and c = <code>length(probs) + 2</code>)
containing summary statistics of the Bayesian R-squared values.
If <code>summary = FALSE</code>, the posterior draws of the Bayesian
R-squared values are returned in an S x M matrix (S is the number of draws).
</p>


<h3>References</h3>

<p>Andrew Gelman, Ben Goodrich, Jonah Gabry &amp; Aki Vehtari. (2018).
R-squared for Bayesian regression models, <em>The American Statistician</em>.
<code>10.1080/00031305.2018.1549100</code> (Preprint available at
<a href="https://stat.columbia.edu/~gelman/research/published/bayes_R2_v3.pdf">https://stat.columbia.edu/~gelman/research/published/bayes_R2_v3.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(mpg ~ wt + cyl, data = mtcars)
summary(fit)
bayes_R2(fit)

# compute R2 with new data
nd &lt;- data.frame(mpg = c(10, 20, 30), wt = c(4, 3, 2), cyl = c(8, 6, 4))
bayes_R2(fit, newdata = nd)

## End(Not run)

</code></pre>

<hr>
<h2 id='BetaBinomial'>The Beta-binomial Distribution</h2><span id='topic+BetaBinomial'></span><span id='topic+dbeta_binomial'></span><span id='topic+pbeta_binomial'></span><span id='topic+rbeta_binomial'></span>

<h3>Description</h3>

<p>Cumulative density &amp; mass functions, and random number generation for the
Beta-binomial distribution using the following re-parameterisation of the
<a href="https://mc-stan.org/docs/2_29/functions-reference/beta-binomial-distribution.html">Stan
Beta-binomial definition</a>:
</p>

<ul>
<li><p><code>mu = alpha * beta</code> mean probability of trial success.
</p>
</li>
<li><p><code>phi = (1 - mu) * beta</code> precision or over-dispersion, component.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dbeta_binomial(x, size, mu, phi, log = FALSE)

pbeta_binomial(q, size, mu, phi, lower.tail = TRUE, log.p = FALSE)

rbeta_binomial(n, size, mu, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BetaBinomial_+3A_x">x</code>, <code id="BetaBinomial_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_size">size</code></td>
<td>
<p>Vector of number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_mu">mu</code></td>
<td>
<p>Vector of means.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_phi">phi</code></td>
<td>
<p>Vector of precisions.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>

<hr>
<h2 id='bridge_sampler.brmsfit'>Log Marginal Likelihood via Bridge Sampling</h2><span id='topic+bridge_sampler.brmsfit'></span><span id='topic+bridge_sampler'></span>

<h3>Description</h3>

<p>Computes log marginal likelihood via bridge sampling,
which can be used in the computation of bayes factors
and posterior model probabilities.
The <code>brmsfit</code> method is just a thin wrapper around
the corresponding method for <code>stanfit</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
bridge_sampler(samples, recompile = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bridge_sampler.brmsfit_+3A_samples">samples</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="bridge_sampler.brmsfit_+3A_recompile">recompile</code></td>
<td>
<p>Logical, indicating whether the Stan model should be
recompiled. This may be necessary if you are running bridge sampling on
another machine than the one used to fit the model. No recompilation
is done by default.</p>
</td></tr>
<tr><td><code id="bridge_sampler.brmsfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="bridgesampling.html#topic+bridge_sampler">bridge_sampler.stanfit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the marginal likelihood requires samples of all variables
defined in Stan's <code>parameters</code> block to be saved. Otherwise
<code>bridge_sampler</code> cannot be computed. Thus, please set <code>save_pars
  = save_pars(all = TRUE)</code> in the call to <code>brm</code>, if you are planning to
apply <code>bridge_sampler</code> to your models.
</p>
<p>The computation of marginal likelihoods based on bridge sampling requires
a lot more posterior draws than usual. A good conservative
rule of thump is perhaps 10-fold more draws (read: the default of 4000
draws may not be enough in many cases). If not enough posterior
draws are provided, the bridge sampling algorithm tends to be
unstable leading to considerably different results each time it is run.
We thus recommend running <code>bridge_sampler</code>
multiple times to check the stability of the results.
</p>
<p>More details are provided under
<code><a href="bridgesampling.html#topic+bridge_sampler">bridgesampling::bridge_sampler</a></code>.
</p>


<h3>See Also</h3>

<p><code>
  <a href="#topic+bayes_factor.brmsfit">bayes_factor</a>,
  <a href="#topic+post_prob.brmsfit">post_prob</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with the treatment effect
fit1 &lt;- brm(
  count ~ zAge + zBase + Trt,
  data = epilepsy, family = negbinomial(),
  prior = prior(normal(0, 1), class = b),
  save_pars = save_pars(all = TRUE)
)
summary(fit1)
bridge_sampler(fit1)

# model without the treatment effect
fit2 &lt;- brm(
  count ~ zAge + zBase,
  data = epilepsy, family = negbinomial(),
  prior = prior(normal(0, 1), class = b),
  save_pars = save_pars(all = TRUE)
)
summary(fit2)
bridge_sampler(fit2)

## End(Not run)

</code></pre>

<hr>
<h2 id='brm'>Fit Bayesian Generalized (Non-)Linear Multivariate Multilevel Models</h2><span id='topic+brm'></span>

<h3>Description</h3>

<p>Fit Bayesian generalized (non-)linear multivariate multilevel models
using Stan for full Bayesian inference. A wide range of distributions
and link functions are supported, allowing users to fit &ndash; among others &ndash;
linear, robust linear, count data, survival, response times, ordinal,
zero-inflated, hurdle, and even self-defined mixture models all in a
multilevel context. Further modeling options include non-linear and
smooth terms, auto-correlation structures, censored data, meta-analytic
standard errors, and quite a few more. In addition, all parameters of the
response distributions can be predicted in order to perform distributional
regression. Prior specifications are flexible and explicitly encourage
users to apply prior distributions that actually reflect their beliefs.
In addition, model fit can easily be assessed and compared with
posterior predictive checks and leave-one-out cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm(
  formula,
  data,
  family = gaussian(),
  prior = NULL,
  autocor = NULL,
  data2 = NULL,
  cov_ranef = NULL,
  sample_prior = "no",
  sparse = NULL,
  knots = NULL,
  drop_unused_levels = TRUE,
  stanvars = NULL,
  stan_funs = NULL,
  fit = NA,
  save_pars = getOption("brms.save_pars", NULL),
  save_ranef = NULL,
  save_mevars = NULL,
  save_all_pars = NULL,
  init = NULL,
  inits = NULL,
  chains = 4,
  iter = 2000,
  warmup = floor(iter/2),
  thin = 1,
  cores = getOption("mc.cores", 1),
  threads = getOption("brms.threads", NULL),
  opencl = getOption("brms.opencl", NULL),
  normalize = getOption("brms.normalize", TRUE),
  control = NULL,
  algorithm = getOption("brms.algorithm", "sampling"),
  backend = getOption("brms.backend", "rstan"),
  future = getOption("future", FALSE),
  silent = 1,
  seed = NA,
  save_model = NULL,
  stan_model_args = list(),
  file = NULL,
  file_compress = TRUE,
  file_refit = getOption("brms.file_refit", "never"),
  empty = FALSE,
  rename = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>, or <code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code> (or one that can
be coerced to that classes): A symbolic description of the model to be
fitted. The details of model specification are explained in
<code><a href="#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="brm_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced
to that class) containing data of all variables used in the model.</p>
</td></tr>
<tr><td><code id="brm_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and link function to
be used in the model. This can be a family function, a call to a family
function or a character string naming the family. Every family function has
a <code>link</code> argument allowing to specify the link function to be applied
on the response variable. If not specified, default links are used. For
details of supported families see <code><a href="#topic+brmsfamily">brmsfamily</a></code>. By default, a
linear <code>gaussian</code> model is applied. In multivariate models,
<code>family</code> might also be a list of families.</p>
</td></tr>
<tr><td><code id="brm_+3A_prior">prior</code></td>
<td>
<p>One or more <code>brmsprior</code> objects created by
<code><a href="#topic+set_prior">set_prior</a></code> or related functions and combined using the
<code>c</code> method or the <code>+</code> operator. See also <code><a href="#topic+default_prior.default">default_prior</a></code>
for more help.</p>
</td></tr>
<tr><td><code id="brm_+3A_autocor">autocor</code></td>
<td>
<p>(Deprecated) An optional <code><a href="#topic+cor_brms">cor_brms</a></code> object
describing the correlation structure within the response variable (i.e.,
the 'autocorrelation'). See the documentation of <code><a href="#topic+cor_brms">cor_brms</a></code> for
a description of the available correlation structures. Defaults to
<code>NULL</code>, corresponding to no correlations. In multivariate models,
<code>autocor</code> might also be a list of autocorrelation structures.
It is now recommend to specify autocorrelation terms directly
within <code>formula</code>. See <code><a href="#topic+brmsformula">brmsformula</a></code> for more details.</p>
</td></tr>
<tr><td><code id="brm_+3A_data2">data2</code></td>
<td>
<p>A named <code>list</code> of objects containing data, which
cannot be passed via argument <code>data</code>. Required for some objects
used in autocorrelation structures to specify dependency structures
as well as for within-group covariance matrices.</p>
</td></tr>
<tr><td><code id="brm_+3A_cov_ranef">cov_ranef</code></td>
<td>
<p>(Deprecated) A list of matrices that are proportional to the
(within) covariance structure of the group-level effects. The names of the
matrices should correspond to columns in <code>data</code> that are used as
grouping factors. All levels of the grouping factor should appear as
rownames of the corresponding matrix. This argument can be used, among
others to model pedigrees and phylogenetic effects.
It is now recommended to specify those matrices in the formula
interface using the <code><a href="#topic+gr">gr</a></code> and related functions. See
<code>vignette("brms_phylogenetics")</code> for more details.</p>
</td></tr>
<tr><td><code id="brm_+3A_sample_prior">sample_prior</code></td>
<td>
<p>Indicate if draws from priors should be drawn
additionally to the posterior draws. Options are <code>"no"</code> (the
default), <code>"yes"</code>, and <code>"only"</code>. Among others, these draws can
be used to calculate Bayes factors for point hypotheses via
<code><a href="#topic+hypothesis">hypothesis</a></code>. Please note that improper priors are not sampled,
including the default improper priors used by <code>brm</code>. See
<code><a href="#topic+set_prior">set_prior</a></code> on how to set (proper) priors. Please also note
that prior draws for the overall intercept are not obtained by default
for technical reasons. See <code><a href="#topic+brmsformula">brmsformula</a></code> how to obtain prior
draws for the intercept. If <code>sample_prior</code> is set to <code>"only"</code>,
draws are drawn solely from the priors ignoring the likelihood, which
allows among others to generate draws from the prior predictive
distribution. In this case, all parameters must have proper priors.</p>
</td></tr>
<tr><td><code id="brm_+3A_sparse">sparse</code></td>
<td>
<p>(Deprecated) Logical; indicates whether the population-level
design matrices should be treated as sparse (defaults to <code>FALSE</code>). For
design matrices with many zeros, this can considerably reduce required
memory. Sampling speed is currently not improved or even slightly
decreased. It is now recommended to use the <code>sparse</code> argument of
<code><a href="#topic+brmsformula">brmsformula</a></code> and related functions.</p>
</td></tr>
<tr><td><code id="brm_+3A_knots">knots</code></td>
<td>
<p>Optional list containing user specified knot values to be used
for basis construction of smoothing terms. See
<code><a href="mgcv.html#topic+gamm">gamm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="brm_+3A_drop_unused_levels">drop_unused_levels</code></td>
<td>
<p>Should unused factors levels in the data be
dropped? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="brm_+3A_stanvars">stanvars</code></td>
<td>
<p>An optional <code>stanvars</code> object generated by function
<code><a href="#topic+stanvar">stanvar</a></code> to define additional variables for use in
<span class="pkg">Stan</span>'s program blocks.</p>
</td></tr>
<tr><td><code id="brm_+3A_stan_funs">stan_funs</code></td>
<td>
<p>(Deprecated) An optional character string containing
self-defined  <span class="pkg">Stan</span> functions, which will be included in the functions
block of the generated <span class="pkg">Stan</span> code. It is now recommended to use the
<code>stanvars</code> argument for this purpose instead.</p>
</td></tr>
<tr><td><code id="brm_+3A_fit">fit</code></td>
<td>
<p>An instance of S3 class <code>brmsfit</code> derived from a previous
fit; defaults to <code>NA</code>. If <code>fit</code> is of class <code>brmsfit</code>, the
compiled model associated with the fitted result is re-used and all
arguments modifying the model code or data are ignored. It is not
recommended to use this argument directly, but to call the
<code><a href="#topic+update.brmsfit">update</a></code> method, instead.</p>
</td></tr>
<tr><td><code id="brm_+3A_save_pars">save_pars</code></td>
<td>
<p>An object generated by <code><a href="#topic+save_pars">save_pars</a></code> controlling
which parameters should be saved in the model. The argument has no
impact on the model fitting itself.</p>
</td></tr>
<tr><td><code id="brm_+3A_save_ranef">save_ranef</code></td>
<td>
<p>(Deprecated) A flag to indicate if group-level effects for
each level of the grouping factor(s) should be saved (default is
<code>TRUE</code>). Set to <code>FALSE</code> to save memory. The argument has no
impact on the model fitting itself.</p>
</td></tr>
<tr><td><code id="brm_+3A_save_mevars">save_mevars</code></td>
<td>
<p>(Deprecated) A flag to indicate if draws of latent
noise-free variables obtained by using <code>me</code> and <code>mi</code> terms should
be saved (default is <code>FALSE</code>). Saving these draws allows to better
use methods such as <code>predict</code> with the latent variables but leads to
very large <span class="rlang"><b>R</b></span> objects even for models of moderate size and complexity.</p>
</td></tr>
<tr><td><code id="brm_+3A_save_all_pars">save_all_pars</code></td>
<td>
<p>(Deprecated) A flag to indicate if draws from all
variables defined in Stan's <code>parameters</code> block should be saved
(default is <code>FALSE</code>). Saving these draws is required in order to
apply the methods <code>bridge_sampler</code>, <code>bayes_factor</code>, and
<code>post_prob</code>. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.save_pars"</code> option (see <code><a href="base.html#topic+options">options</a></code>).</p>
</td></tr>
<tr><td><code id="brm_+3A_init">init</code></td>
<td>
<p>Initial values for the sampler. If <code>NULL</code> (the default) or
<code>"random"</code>, Stan will randomly generate initial values for parameters
in a reasonable range. If <code>0</code>, all parameters are initialized to zero
on the unconstrained space. This option is sometimes useful for certain
families, as it happens that default random initial values cause draws to
be essentially constant. Generally, setting <code>init = 0</code> is worth a try,
if chains do not initialize or behave well. Alternatively, <code>init</code> can
be a list of lists containing the initial values, or a function (or
function name) generating initial values. The latter options are mainly
implemented for internal testing but are available to users if necessary.
If specifying initial values using a list or a function then currently the
parameter names must correspond to the names used in the generated Stan
code (not the names used in <span class="rlang"><b>R</b></span>). For more details on specifying initial
values you can consult the documentation of the selected <code>backend</code>.</p>
</td></tr>
<tr><td><code id="brm_+3A_inits">inits</code></td>
<td>
<p>(Deprecated) Alias of <code>init</code>.</p>
</td></tr>
<tr><td><code id="brm_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains (defaults to 4).</p>
</td></tr>
<tr><td><code id="brm_+3A_iter">iter</code></td>
<td>
<p>Number of total iterations per chain (including warmup; defaults
to 2000).</p>
</td></tr>
<tr><td><code id="brm_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying number of warmup (aka burnin)
iterations. This also specifies the number of iterations used for stepsize
adaptation, so warmup draws should not be used for inference. The number
of warmup should not be larger than <code>iter</code> and the default is
<code>iter/2</code>.</p>
</td></tr>
<tr><td><code id="brm_+3A_thin">thin</code></td>
<td>
<p>Thinning rate. Must be a positive integer. Set <code>thin &gt; 1</code> to
save memory and computation time if <code>iter</code> is large.</p>
</td></tr>
<tr><td><code id="brm_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
which defaults to 1 but we recommend setting the <code>mc.cores</code> option to
be as many processors as the hardware and RAM allow (up to the number of
chains). For non-Windows OS in non-interactive <span class="rlang"><b>R</b></span> sessions, forking is used
instead of PSOCK clusters.</p>
</td></tr>
<tr><td><code id="brm_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in within-chain parallelization. For
more control over the threading process, <code>threads</code> may also be a
<code>brmsthreads</code> object created by <code><a href="#topic+threading">threading</a></code>. Within-chain
parallelization is experimental! We recommend its use only if you are
experienced with Stan's <code>reduce_sum</code> function and have a slow running
model that cannot be sped up by any other means. Can be set globally for
the current <span class="rlang"><b>R</b></span> session via the <code>"brms.threads"</code> option (see
<code><a href="base.html#topic+options">options</a></code>).</p>
</td></tr>
<tr><td><code id="brm_+3A_opencl">opencl</code></td>
<td>
<p>The platform and device IDs of the OpenCL device to use for
fitting using GPU support. If you don't know the IDs of your OpenCL device,
<code>c(0,0)</code> is most likely what you need. For more details, see
<code><a href="#topic+opencl">opencl</a></code>. Can be set globally for the current <span class="rlang"><b>R</b></span> session via
the <code>"brms.opencl"</code> option</p>
</td></tr>
<tr><td><code id="brm_+3A_normalize">normalize</code></td>
<td>
<p>Logical. Indicates whether normalization constants should
be included in the Stan code (defaults to <code>TRUE</code>). Setting it
to <code>FALSE</code> requires Stan version &gt;= 2.25 to work. If <code>FALSE</code>,
sampling efficiency may be increased but some post processing functions
such as <code><a href="#topic+bridge_sampler">bridge_sampler</a></code> will not be available. Can be
controlled globally for the current <span class="rlang"><b>R</b></span> session via the 'brms.normalize'
option.</p>
</td></tr>
<tr><td><code id="brm_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> of parameters to control the sampler's
behavior. It defaults to <code>NULL</code> so all the default values are used.
The most important control parameters are discussed in the 'Details'
section below. For a comprehensive overview see
<code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="brm_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string naming the estimation approach to use.
Options are <code>"sampling"</code> for MCMC (the default), <code>"meanfield"</code> for
variational inference with independent normal distributions,
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution, or <code>"fixed_param"</code> for sampling from fixed parameter
values. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.algorithm"</code> option (see <code><a href="base.html#topic+options">options</a></code>).</p>
</td></tr>
<tr><td><code id="brm_+3A_backend">backend</code></td>
<td>
<p>Character string naming the package to use as the backend for
fitting the Stan model. Options are <code>"rstan"</code> (the default) or
<code>"cmdstanr"</code>. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.backend"</code> option (see <code><a href="base.html#topic+options">options</a></code>). Details on the
<span class="pkg">rstan</span> and <span class="pkg">cmdstanr</span> packages are available at
<a href="https://mc-stan.org/rstan/">https://mc-stan.org/rstan/</a> and <a href="https://mc-stan.org/cmdstanr/">https://mc-stan.org/cmdstanr/</a>,
respectively. Additionally a <code>"mock"</code> backend is available to make
testing <span class="pkg">brms</span> and packages that depend on it easier.
The <code>"mock"</code> backend does not actually do any fitting, it only checks
the generated Stan code for correctness and then returns whatever is passed
in an additional <code>mock_fit</code> argument as the result of the fit.</p>
</td></tr>
<tr><td><code id="brm_+3A_future">future</code></td>
<td>
<p>Logical; If <code>TRUE</code>, the <span class="pkg"><a href="future.html#topic+future">future</a></span>
package is used for parallel execution of the chains and argument
<code>cores</code> will be ignored. Can be set globally for the current <span class="rlang"><b>R</b></span>
session via the <code>"future"</code> option. The execution type is controlled via
<code><a href="future.html#topic+plan">plan</a></code> (see the examples section below).</p>
</td></tr>
<tr><td><code id="brm_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between <code>0</code> and <code>2</code>.
If <code>1</code> (the default), most of the
informational messages of compiler and sampler are suppressed.
If <code>2</code>, even more messages are suppressed. The actual
sampling progress is still printed. Set <code>refresh = 0</code> to turn this off
as well. If using <code>backend = "rstan"</code> you can also set
<code>open_progress = FALSE</code> to prevent opening additional progress bars.</p>
</td></tr>
<tr><td><code id="brm_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation to make results
reproducible. If <code>NA</code> (the default), <span class="pkg">Stan</span> will set the seed
randomly.</p>
</td></tr>
<tr><td><code id="brm_+3A_save_model">save_model</code></td>
<td>
<p>Either <code>NULL</code> or a character string. In the latter
case, the model's Stan code is saved via <code><a href="#topic+cat">cat</a></code> in a text file
named after the string supplied in <code>save_model</code>.</p>
</td></tr>
<tr><td><code id="brm_+3A_stan_model_args">stan_model_args</code></td>
<td>
<p>A <code>list</code> of further arguments passed to
<code><a href="rstan.html#topic+stan_model">rstan::stan_model</a></code> for <code>backend =
"rstan"</code> or to <code>cmdstanr::cmdstan_model</code> for <code>backend =
"cmdstanr"</code>, which allows to change how models are compiled.</p>
</td></tr>
<tr><td><code id="brm_+3A_file">file</code></td>
<td>
<p>Either <code>NULL</code> or a character string. In the latter case, the
fitted model object is saved via <code><a href="base.html#topic+saveRDS">saveRDS</a></code> in a file named
after the string supplied in <code>file</code>. The <code>.rds</code> extension is
added automatically. If the file already exists, <code>brm</code> will load and
return the saved model object instead of refitting the model.
Unless you specify the <code>file_refit</code> argument as well, the existing
files won't be overwritten, you have to manually remove the file in order
to refit and save the model under an existing file name. The file name
is stored in the <code>brmsfit</code> object for later usage.</p>
</td></tr>
<tr><td><code id="brm_+3A_file_compress">file_compress</code></td>
<td>
<p>Logical or a character string, specifying one of the
compression algorithms supported by <code><a href="base.html#topic+saveRDS">saveRDS</a></code>. If the
<code>file</code> argument is provided, this compression will be used when saving
the fitted model object.</p>
</td></tr>
<tr><td><code id="brm_+3A_file_refit">file_refit</code></td>
<td>
<p>Modifies when the fit stored via the <code>file</code> argument
is re-used. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.file_refit"</code> option (see <code><a href="base.html#topic+options">options</a></code>).
For <code>"never"</code> (default) the fit is always loaded if it
exists and fitting is skipped. For <code>"always"</code> the model is always
refitted. If set to <code>"on_change"</code>, brms will
refit the model if model, data or algorithm as passed to Stan differ from
what is stored in the file. This also covers changes in priors,
<code>sample_prior</code>, <code>stanvars</code>, covariance structure, etc. If you
believe there was a false positive, you can use
<code><a href="#topic+brmsfit_needs_refit">brmsfit_needs_refit</a></code> to see why refit is deemed necessary.
Refit will not be triggered for changes in additional parameters of the fit
(e.g., initial values, number of iterations, control arguments, ...). A
known limitation is that a refit will be triggered if within-chain
parallelization is switched on/off.</p>
</td></tr>
<tr><td><code id="brm_+3A_empty">empty</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the Stan model is not created
and compiled and the corresponding <code>'fit'</code> slot of the <code>brmsfit</code>
object will be empty. This is useful if you have estimated a brms-created
Stan model outside of <span class="pkg">brms</span> and want to feed it back into the package.</p>
</td></tr>
<tr><td><code id="brm_+3A_rename">rename</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
<tr><td><code id="brm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to Stan.
For <code>backend = "rstan"</code> the arguments are passed to
<code><a href="rstan.html#topic+sampling">sampling</a></code> or <code><a href="rstan.html#topic+vb">vb</a></code>.
For <code>backend = "cmdstanr"</code> the arguments are passed to the
<code>cmdstanr::sample</code> or <code>cmdstanr::variational</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit a generalized (non-)linear multivariate multilevel model via
full Bayesian inference using Stan. A general overview is provided in the
vignettes <code>vignette("brms_overview")</code> and
<code>vignette("brms_multilevel")</code>. For a full list of available vignettes
see <code>vignette(package = "brms")</code>.
</p>
<p><b>Formula syntax of brms models</b>
</p>
<p>Details of the formula syntax applied in <span class="pkg">brms</span> can be found in
<code><a href="#topic+brmsformula">brmsformula</a></code>.
</p>
<p><b>Families and link functions</b>
</p>
<p>Details of families supported by <span class="pkg">brms</span> can be found in
<code><a href="#topic+brmsfamily">brmsfamily</a></code>.
</p>
<p><b>Prior distributions</b>
</p>
<p>Priors should be specified using the
<code><a href="#topic+set_prior">set_prior</a></code> function. Its documentation
contains detailed information on how to correctly specify priors. To find
out on which parameters or parameter classes priors can be defined, use
<code><a href="#topic+default_prior.default">default_prior</a></code>. Default priors are chosen to be
non or very weakly informative so that their influence on the results will
be negligible and you usually don't have to worry about them. However,
after getting more familiar with Bayesian statistics, I recommend you to
start thinking about reasonable informative priors for your model
parameters: Nearly always, there is at least some prior information
available that can be used to improve your inference.
</p>
<p><b>Adjusting the sampling behavior of <span class="pkg">Stan</span></b>
</p>
<p>In addition to choosing the number of iterations, warmup draws, and
chains, users can control the behavior of the NUTS sampler, by using the
<code>control</code> argument. The most important reason to use <code>control</code> is
to decrease (or eliminate at best) the number of divergent transitions that
cause a bias in the obtained posterior draws. Whenever you see the
warning &quot;There were x divergent transitions after warmup.&quot; you should
really think about increasing <code>adapt_delta</code>. To do this, write
<code>control = list(adapt_delta = &lt;x&gt;)</code>, where <code>&lt;x&gt;</code> should usually
be value between <code>0.8</code> (current default) and <code>1</code>. Increasing
<code>adapt_delta</code> will slow down the sampler but will decrease the number
of divergent transitions threatening the validity of your posterior
draws.
</p>
<p>Another problem arises when the depth of the tree being evaluated in each
iteration is exceeded. This is less common than having divergent
transitions, but may also bias the posterior draws. When it happens,
<span class="pkg">Stan</span> will throw out a warning suggesting to increase
<code>max_treedepth</code>, which can be accomplished by writing <code>control =
  list(max_treedepth = &lt;x&gt;)</code> with a positive integer <code>&lt;x&gt;</code> that should
usually be larger than the current default of <code>10</code>. For more details
on the <code>control</code> argument see <code><a href="rstan.html#topic+stan">stan</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>brmsfit</code>, which contains the posterior
draws along with many other useful information about the model. Use
<code>methods(class = "brmsfit")</code> for an overview on available methods.
</p>


<h3>Author(s)</h3>

<p>Paul-Christian Buerkner <a href="mailto:paul.buerkner@gmail.com">paul.buerkner@gmail.com</a>
</p>


<h3>References</h3>

<p>Paul-Christian Buerkner (2017). brms: An R Package for Bayesian Multilevel
Models Using Stan. <em>Journal of Statistical Software</em>, 80(1), 1-28.
<code>doi:10.18637/jss.v080.i01</code>
</p>
<p>Paul-Christian Buerkner (2018). Advanced Bayesian Multilevel Modeling
with the R Package brms. <em>The R Journal</em>. 10(1), 395–411.
<code>doi:10.32614/RJ-2018-017</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brms">brms</a></code>, <code><a href="#topic+brmsformula">brmsformula</a></code>,
<code><a href="#topic+brmsfamily">brmsfamily</a></code>, <code><a href="#topic+brmsfit">brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Poisson regression for the number of seizures in epileptic patients
fit1 &lt;- brm(
  count ~ zBase * Trt + (1|patient),
  data = epilepsy, family = poisson(),
  prior = prior(normal(0, 10), class = b) +
    prior(cauchy(0, 2), class = sd)
)

# generate a summary of the results
summary(fit1)

# plot the MCMC chains as well as the posterior distributions
plot(fit1)

# predict responses based on the fitted model
head(predict(fit1))

# plot conditional effects for each predictor
plot(conditional_effects(fit1), ask = FALSE)

# investigate model fit
loo(fit1)
pp_check(fit1)


# Ordinal regression modeling patient's rating of inhaler instructions
# category specific effects are estimated for variable 'treat'
fit2 &lt;- brm(rating ~ period + carry + cs(treat),
            data = inhaler, family = sratio("logit"),
            prior = set_prior("normal(0,5)"), chains = 2)
summary(fit2)
plot(fit2, ask = FALSE)
WAIC(fit2)


# Survival regression modeling the time between the first
# and second recurrence of an infection in kidney patients.
fit3 &lt;- brm(time | cens(censored) ~ age * sex + disease + (1|patient),
            data = kidney, family = lognormal())
summary(fit3)
plot(fit3, ask = FALSE)
plot(conditional_effects(fit3), ask = FALSE)


# Probit regression using the binomial family
ntrials &lt;- sample(1:10, 100, TRUE)
success &lt;- rbinom(100, size = ntrials, prob = 0.4)
x &lt;- rnorm(100)
data4 &lt;- data.frame(ntrials, success, x)
fit4 &lt;- brm(success | trials(ntrials) ~ x, data = data4,
            family = binomial("probit"))
summary(fit4)


# Non-linear Gaussian model
fit5 &lt;- brm(
  bf(cum ~ ult * (1 - exp(-(dev/theta)^omega)),
     ult ~ 1 + (1|AY), omega ~ 1, theta ~ 1,
     nl = TRUE),
  data = loss, family = gaussian(),
  prior = c(
    prior(normal(5000, 1000), nlpar = "ult"),
    prior(normal(1, 2), nlpar = "omega"),
    prior(normal(45, 10), nlpar = "theta")
  ),
  control = list(adapt_delta = 0.9)
)
summary(fit5)
conditional_effects(fit5)


# Normal model with heterogeneous variances
data_het &lt;- data.frame(
  y = c(rnorm(50), rnorm(50, 1, 2)),
  x = factor(rep(c("a", "b"), each = 50))
)
fit6 &lt;- brm(bf(y ~ x, sigma ~ 0 + x), data = data_het)
summary(fit6)
plot(fit6)
conditional_effects(fit6)

# extract estimated residual SDs of both groups
sigmas &lt;- exp(as.data.frame(fit6, variable = "^b_sigma_", regex = TRUE))
ggplot(stack(sigmas), aes(values)) +
  geom_density(aes(fill = ind))


# Quantile regression predicting the 25%-quantile
fit7 &lt;- brm(bf(y ~ x, quantile = 0.25), data = data_het,
            family = asym_laplace())
summary(fit7)
conditional_effects(fit7)


# use the future package for more flexible parallelization
library(future)
plan(multisession, workers = 4)
fit7 &lt;- update(fit7, future = TRUE)


# fit a model manually via rstan
scode &lt;- stancode(count ~ Trt, data = epilepsy)
sdata &lt;- standata(count ~ Trt, data = epilepsy)
stanfit &lt;- rstan::stan(model_code = scode, data = sdata)
# feed the Stan model back into brms
fit8 &lt;- brm(count ~ Trt, data = epilepsy, empty = TRUE)
fit8$fit &lt;- stanfit
fit8 &lt;- rename_pars(fit8)
summary(fit8)

## End(Not run)

</code></pre>

<hr>
<h2 id='brm_multiple'>Run the same <span class="pkg">brms</span> model on multiple datasets</h2><span id='topic+brm_multiple'></span>

<h3>Description</h3>

<p>Run the same <span class="pkg">brms</span> model on multiple datasets and then combine the
results into one fitted model object. This is useful in particular for
multiple missing value imputation, where the same model is fitted on multiple
imputed data sets. Models can be run in parallel using the <span class="pkg">future</span>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brm_multiple(
  formula,
  data,
  family = gaussian(),
  prior = NULL,
  data2 = NULL,
  autocor = NULL,
  cov_ranef = NULL,
  sample_prior = c("no", "yes", "only"),
  sparse = NULL,
  knots = NULL,
  stanvars = NULL,
  stan_funs = NULL,
  silent = 1,
  recompile = FALSE,
  combine = TRUE,
  fit = NA,
  algorithm = getOption("brms.algorithm", "sampling"),
  seed = NA,
  file = NULL,
  file_compress = TRUE,
  file_refit = getOption("brms.file_refit", "never"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brm_multiple_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>, or <code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code> (or one that can
be coerced to that classes): A symbolic description of the model to be
fitted. The details of model specification are explained in
<code><a href="#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_data">data</code></td>
<td>
<p>A <em>list</em> of data.frames each of which will be used to fit a
separate model. Alternatively, a <code>mids</code> object from the <span class="pkg">mice</span>
package.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and link function to
be used in the model. This can be a family function, a call to a family
function or a character string naming the family. Every family function has
a <code>link</code> argument allowing to specify the link function to be applied
on the response variable. If not specified, default links are used. For
details of supported families see <code><a href="#topic+brmsfamily">brmsfamily</a></code>. By default, a
linear <code>gaussian</code> model is applied. In multivariate models,
<code>family</code> might also be a list of families.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_prior">prior</code></td>
<td>
<p>One or more <code>brmsprior</code> objects created by
<code><a href="#topic+set_prior">set_prior</a></code> or related functions and combined using the
<code>c</code> method or the <code>+</code> operator. See also <code><a href="#topic+default_prior.default">default_prior</a></code>
for more help.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_data2">data2</code></td>
<td>
<p>A <em>list</em> of named lists each of which will be used to fit a
separate model. Each of the named lists contains objects representing data
which cannot be passed via argument <code>data</code> (see <code><a href="#topic+brm">brm</a></code> for
examples). The length of the outer list should match the length of the list
passed to the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_autocor">autocor</code></td>
<td>
<p>(Deprecated) An optional <code><a href="#topic+cor_brms">cor_brms</a></code> object
describing the correlation structure within the response variable (i.e.,
the 'autocorrelation'). See the documentation of <code><a href="#topic+cor_brms">cor_brms</a></code> for
a description of the available correlation structures. Defaults to
<code>NULL</code>, corresponding to no correlations. In multivariate models,
<code>autocor</code> might also be a list of autocorrelation structures.
It is now recommend to specify autocorrelation terms directly
within <code>formula</code>. See <code><a href="#topic+brmsformula">brmsformula</a></code> for more details.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_cov_ranef">cov_ranef</code></td>
<td>
<p>(Deprecated) A list of matrices that are proportional to the
(within) covariance structure of the group-level effects. The names of the
matrices should correspond to columns in <code>data</code> that are used as
grouping factors. All levels of the grouping factor should appear as
rownames of the corresponding matrix. This argument can be used, among
others to model pedigrees and phylogenetic effects.
It is now recommended to specify those matrices in the formula
interface using the <code><a href="#topic+gr">gr</a></code> and related functions. See
<code>vignette("brms_phylogenetics")</code> for more details.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_sample_prior">sample_prior</code></td>
<td>
<p>Indicate if draws from priors should be drawn
additionally to the posterior draws. Options are <code>"no"</code> (the
default), <code>"yes"</code>, and <code>"only"</code>. Among others, these draws can
be used to calculate Bayes factors for point hypotheses via
<code><a href="#topic+hypothesis">hypothesis</a></code>. Please note that improper priors are not sampled,
including the default improper priors used by <code>brm</code>. See
<code><a href="#topic+set_prior">set_prior</a></code> on how to set (proper) priors. Please also note
that prior draws for the overall intercept are not obtained by default
for technical reasons. See <code><a href="#topic+brmsformula">brmsformula</a></code> how to obtain prior
draws for the intercept. If <code>sample_prior</code> is set to <code>"only"</code>,
draws are drawn solely from the priors ignoring the likelihood, which
allows among others to generate draws from the prior predictive
distribution. In this case, all parameters must have proper priors.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_sparse">sparse</code></td>
<td>
<p>(Deprecated) Logical; indicates whether the population-level
design matrices should be treated as sparse (defaults to <code>FALSE</code>). For
design matrices with many zeros, this can considerably reduce required
memory. Sampling speed is currently not improved or even slightly
decreased. It is now recommended to use the <code>sparse</code> argument of
<code><a href="#topic+brmsformula">brmsformula</a></code> and related functions.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_knots">knots</code></td>
<td>
<p>Optional list containing user specified knot values to be used
for basis construction of smoothing terms. See
<code><a href="mgcv.html#topic+gamm">gamm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_stanvars">stanvars</code></td>
<td>
<p>An optional <code>stanvars</code> object generated by function
<code><a href="#topic+stanvar">stanvar</a></code> to define additional variables for use in
<span class="pkg">Stan</span>'s program blocks.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_stan_funs">stan_funs</code></td>
<td>
<p>(Deprecated) An optional character string containing
self-defined  <span class="pkg">Stan</span> functions, which will be included in the functions
block of the generated <span class="pkg">Stan</span> code. It is now recommended to use the
<code>stanvars</code> argument for this purpose instead.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between <code>0</code> and <code>2</code>.
If <code>1</code> (the default), most of the
informational messages of compiler and sampler are suppressed.
If <code>2</code>, even more messages are suppressed. The actual
sampling progress is still printed. Set <code>refresh = 0</code> to turn this off
as well. If using <code>backend = "rstan"</code> you can also set
<code>open_progress = FALSE</code> to prevent opening additional progress bars.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_recompile">recompile</code></td>
<td>
<p>Logical, indicating whether the Stan model should be
recompiled for every imputed data set. Defaults to <code>FALSE</code>. If
<code>NULL</code>, <code>brm_multiple</code> tries to figure out internally, if recompilation
is necessary, for example because data-dependent priors have changed.
Using the default of no recompilation should be fine in most cases.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_combine">combine</code></td>
<td>
<p>Logical; Indicates if the fitted models should be combined
into a single fitted model object via <code><a href="#topic+combine_models">combine_models</a></code>.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_fit">fit</code></td>
<td>
<p>An instance of S3 class <code>brmsfit_multiple</code> derived from a
previous fit; defaults to <code>NA</code>. If <code>fit</code> is of class
<code>brmsfit_multiple</code>, the compiled model associated with the fitted
result is re-used and all arguments modifying the model code or data are
ignored. It is not recommended to use this argument directly, but to call
the <code><a href="#topic+update.brmsfit_multiple">update</a></code> method, instead.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string naming the estimation approach to use.
Options are <code>"sampling"</code> for MCMC (the default), <code>"meanfield"</code> for
variational inference with independent normal distributions,
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution, or <code>"fixed_param"</code> for sampling from fixed parameter
values. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.algorithm"</code> option (see <code><a href="base.html#topic+options">options</a></code>).</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation to make results
reproducible. If <code>NA</code> (the default), <span class="pkg">Stan</span> will set the seed
randomly.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_file">file</code></td>
<td>
<p>Either <code>NULL</code> or a character string. In the latter case, the
fitted model object is saved via <code><a href="base.html#topic+saveRDS">saveRDS</a></code> in a file named
after the string supplied in <code>file</code>. The <code>.rds</code> extension is
added automatically. If the file already exists, <code>brm</code> will load and
return the saved model object instead of refitting the model.
Unless you specify the <code>file_refit</code> argument as well, the existing
files won't be overwritten, you have to manually remove the file in order
to refit and save the model under an existing file name. The file name
is stored in the <code>brmsfit</code> object for later usage.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_file_compress">file_compress</code></td>
<td>
<p>Logical or a character string, specifying one of the
compression algorithms supported by <code><a href="base.html#topic+saveRDS">saveRDS</a></code>. If the
<code>file</code> argument is provided, this compression will be used when saving
the fitted model object.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_file_refit">file_refit</code></td>
<td>
<p>Modifies when the fit stored via the <code>file</code> argument
is re-used. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.file_refit"</code> option (see <code><a href="base.html#topic+options">options</a></code>).
For <code>"never"</code> (default) the fit is always loaded if it
exists and fitting is skipped. For <code>"always"</code> the model is always
refitted. If set to <code>"on_change"</code>, brms will
refit the model if model, data or algorithm as passed to Stan differ from
what is stored in the file. This also covers changes in priors,
<code>sample_prior</code>, <code>stanvars</code>, covariance structure, etc. If you
believe there was a false positive, you can use
<code><a href="#topic+brmsfit_needs_refit">brmsfit_needs_refit</a></code> to see why refit is deemed necessary.
Refit will not be triggered for changes in additional parameters of the fit
(e.g., initial values, number of iterations, control arguments, ...). A
known limitation is that a refit will be triggered if within-chain
parallelization is switched on/off.</p>
</td></tr>
<tr><td><code id="brm_multiple_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+brm">brm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The combined model may issue false positive convergence warnings, as
the MCMC chains corresponding to different datasets may not necessarily
overlap, even if each of the original models did converge. To find out
whether each of the original models converged, investigate
<code>fit$rhats</code>, where <code>fit</code> denotes the output of
<code>brm_multiple</code>.
</p>


<h3>Value</h3>

<p>If <code>combine = TRUE</code> a <code>brmsfit_multiple</code> object, which
inherits from class <code>brmsfit</code> and behaves essentially the same. If
<code>combine = FALSE</code> a list of <code>brmsfit</code> objects.
</p>


<h3>Author(s)</h3>

<p>Paul-Christian Buerkner <a href="mailto:paul.buerkner@gmail.com">paul.buerkner@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(mice)
imp &lt;- mice(nhanes2)

# fit the model using mice and lm
fit_imp1 &lt;- with(lm(bmi ~ age + hyp + chl), data = imp)
summary(pool(fit_imp1))

# fit the model using brms
fit_imp2 &lt;- brm_multiple(bmi ~ age + hyp + chl, data = imp, chains = 1)
summary(fit_imp2)
plot(fit_imp2, pars = "^b_")
# investigate convergence of the original models
fit_imp2$rhats

# use the future package for parallelization
library(future)
plan(multisession, workers = 4)
fit_imp3 &lt;- brm_multiple(bmi~age+hyp+chl, data = imp, chains = 1)
summary(fit_imp3)

## End(Not run)

</code></pre>

<hr>
<h2 id='brmsfamily'>Special Family Functions for <span class="pkg">brms</span> Models</h2><span id='topic+brmsfamily'></span><span id='topic+student'></span><span id='topic+bernoulli'></span><span id='topic+beta_binomial'></span><span id='topic+negbinomial'></span><span id='topic+geometric'></span><span id='topic+lognormal'></span><span id='topic+shifted_lognormal'></span><span id='topic+skew_normal'></span><span id='topic+exponential'></span><span id='topic+weibull'></span><span id='topic+frechet'></span><span id='topic+gen_extreme_value'></span><span id='topic+exgaussian'></span><span id='topic+wiener'></span><span id='topic+Beta'></span><span id='topic+dirichlet'></span><span id='topic+logistic_normal'></span><span id='topic+von_mises'></span><span id='topic+asym_laplace'></span><span id='topic+cox'></span><span id='topic+hurdle_poisson'></span><span id='topic+hurdle_negbinomial'></span><span id='topic+hurdle_gamma'></span><span id='topic+hurdle_lognormal'></span><span id='topic+hurdle_cumulative'></span><span id='topic+zero_inflated_beta'></span><span id='topic+zero_one_inflated_beta'></span><span id='topic+zero_inflated_poisson'></span><span id='topic+zero_inflated_negbinomial'></span><span id='topic+zero_inflated_binomial'></span><span id='topic+zero_inflated_beta_binomial'></span><span id='topic+categorical'></span><span id='topic+multinomial'></span><span id='topic+cumulative'></span><span id='topic+sratio'></span><span id='topic+cratio'></span><span id='topic+acat'></span>

<h3>Description</h3>

<p>Family objects provide a convenient way to specify the details of the models
used by many model fitting functions. The family functions presented here are
for use with <span class="pkg">brms</span> only and will **not** work with other model
fitting functions such as <code>glm</code> or <code>glmer</code>.
However, the standard family functions as described in
<code><a href="stats.html#topic+family">family</a></code> will work with <span class="pkg">brms</span>.
You can also specify custom families for use in <span class="pkg">brms</span> with
the <code><a href="#topic+custom_family">custom_family</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brmsfamily(
  family,
  link = NULL,
  link_sigma = "log",
  link_shape = "log",
  link_nu = "logm1",
  link_phi = "log",
  link_kappa = "log",
  link_beta = "log",
  link_zi = "logit",
  link_hu = "logit",
  link_zoi = "logit",
  link_coi = "logit",
  link_disc = "log",
  link_bs = "log",
  link_ndt = "log",
  link_bias = "logit",
  link_xi = "log1p",
  link_alpha = "identity",
  link_quantile = "logit",
  threshold = "flexible",
  refcat = NULL,
  bhaz = NULL
)

student(link = "identity", link_sigma = "log", link_nu = "logm1")

bernoulli(link = "logit")

beta_binomial(link = "logit", link_phi = "log")

negbinomial(link = "log", link_shape = "log")

geometric(link = "log")

lognormal(link = "identity", link_sigma = "log")

shifted_lognormal(link = "identity", link_sigma = "log", link_ndt = "log")

skew_normal(link = "identity", link_sigma = "log", link_alpha = "identity")

exponential(link = "log")

weibull(link = "log", link_shape = "log")

frechet(link = "log", link_nu = "logm1")

gen_extreme_value(link = "identity", link_sigma = "log", link_xi = "log1p")

exgaussian(link = "identity", link_sigma = "log", link_beta = "log")

wiener(
  link = "identity",
  link_bs = "log",
  link_ndt = "log",
  link_bias = "logit"
)

Beta(link = "logit", link_phi = "log")

dirichlet(link = "logit", link_phi = "log", refcat = NULL)

logistic_normal(link = "identity", link_sigma = "log", refcat = NULL)

von_mises(link = "tan_half", link_kappa = "log")

asym_laplace(link = "identity", link_sigma = "log", link_quantile = "logit")

cox(link = "log", bhaz = NULL)

hurdle_poisson(link = "log", link_hu = "logit")

hurdle_negbinomial(link = "log", link_shape = "log", link_hu = "logit")

hurdle_gamma(link = "log", link_shape = "log", link_hu = "logit")

hurdle_lognormal(link = "identity", link_sigma = "log", link_hu = "logit")

hurdle_cumulative(
  link = "logit",
  link_hu = "logit",
  link_disc = "log",
  threshold = "flexible"
)

zero_inflated_beta(link = "logit", link_phi = "log", link_zi = "logit")

zero_one_inflated_beta(
  link = "logit",
  link_phi = "log",
  link_zoi = "logit",
  link_coi = "logit"
)

zero_inflated_poisson(link = "log", link_zi = "logit")

zero_inflated_negbinomial(link = "log", link_shape = "log", link_zi = "logit")

zero_inflated_binomial(link = "logit", link_zi = "logit")

zero_inflated_beta_binomial(
  link = "logit",
  link_phi = "log",
  link_zi = "logit"
)

categorical(link = "logit", refcat = NULL)

multinomial(link = "logit", refcat = NULL)

cumulative(link = "logit", link_disc = "log", threshold = "flexible")

sratio(link = "logit", link_disc = "log", threshold = "flexible")

cratio(link = "logit", link_disc = "log", threshold = "flexible")

acat(link = "logit", link_disc = "log", threshold = "flexible")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brmsfamily_+3A_family">family</code></td>
<td>
<p>A character string naming the distribution family of the response
variable to be used in the model. Currently, the following families are
supported: <code>gaussian</code>, <code>student</code>, <code>binomial</code>,
<code>bernoulli</code>, <code>beta-binomial</code>, <code>poisson</code>, <code>negbinomial</code>,
<code>geometric</code>, <code>Gamma</code>, <code>skew_normal</code>, <code>lognormal</code>,
<code>shifted_lognormal</code>, <code>exgaussian</code>, <code>wiener</code>,
<code>inverse.gaussian</code>, <code>exponential</code>, <code>weibull</code>,
<code>frechet</code>, <code>Beta</code>, <code>dirichlet</code>, <code>von_mises</code>,
<code>asym_laplace</code>, <code>gen_extreme_value</code>, <code>categorical</code>,
<code>multinomial</code>, <code>cumulative</code>, <code>cratio</code>, <code>sratio</code>,
<code>acat</code>, <code>hurdle_poisson</code>, <code>hurdle_negbinomial</code>,
<code>hurdle_gamma</code>, <code>hurdle_lognormal</code>, <code>hurdle_cumulative</code>,
<code>zero_inflated_binomial</code>, <code>zero_inflated_beta_binomial</code>,
<code>zero_inflated_beta</code>, <code>zero_inflated_negbinomial</code>,
<code>zero_inflated_poisson</code>, and <code>zero_one_inflated_beta</code>.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link">link</code></td>
<td>
<p>A specification for the model link function. This can be a
name/expression or character string. See the 'Details' section for more
information on link functions supported by each family.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_sigma">link_sigma</code></td>
<td>
<p>Link of auxiliary parameter <code>sigma</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_shape">link_shape</code></td>
<td>
<p>Link of auxiliary parameter <code>shape</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_nu">link_nu</code></td>
<td>
<p>Link of auxiliary parameter <code>nu</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_phi">link_phi</code></td>
<td>
<p>Link of auxiliary parameter <code>phi</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_kappa">link_kappa</code></td>
<td>
<p>Link of auxiliary parameter <code>kappa</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_beta">link_beta</code></td>
<td>
<p>Link of auxiliary parameter <code>beta</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_zi">link_zi</code></td>
<td>
<p>Link of auxiliary parameter <code>zi</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_hu">link_hu</code></td>
<td>
<p>Link of auxiliary parameter <code>hu</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_zoi">link_zoi</code></td>
<td>
<p>Link of auxiliary parameter <code>zoi</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_coi">link_coi</code></td>
<td>
<p>Link of auxiliary parameter <code>coi</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_disc">link_disc</code></td>
<td>
<p>Link of auxiliary parameter <code>disc</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_bs">link_bs</code></td>
<td>
<p>Link of auxiliary parameter <code>bs</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_ndt">link_ndt</code></td>
<td>
<p>Link of auxiliary parameter <code>ndt</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_bias">link_bias</code></td>
<td>
<p>Link of auxiliary parameter <code>bias</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_xi">link_xi</code></td>
<td>
<p>Link of auxiliary parameter <code>xi</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_alpha">link_alpha</code></td>
<td>
<p>Link of auxiliary parameter <code>alpha</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_link_quantile">link_quantile</code></td>
<td>
<p>Link of auxiliary parameter <code>quantile</code> if being predicted.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_threshold">threshold</code></td>
<td>
<p>A character string indicating the type
of thresholds (i.e. intercepts) used in an ordinal model.
<code>"flexible"</code> provides the standard unstructured thresholds,
<code>"equidistant"</code> restricts the distance between
consecutive thresholds to the same value, and
<code>"sum_to_zero"</code> ensures the thresholds sum to zero.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_refcat">refcat</code></td>
<td>
<p>Optional name of the reference response category used in
<code>categorical</code>, <code>multinomial</code>, <code>dirichlet</code> and
<code>logistic_normal</code> models. If <code>NULL</code> (the default), the first
category is used as the reference. If <code>NA</code>, all categories will be
predicted, which requires strong priors or carefully specified predictor
terms in order to lead to an identified model.</p>
</td></tr>
<tr><td><code id="brmsfamily_+3A_bhaz">bhaz</code></td>
<td>
<p>Currently for experimental purposes only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below, we list common use cases for the different families.
This list is not ment to be exhaustive.
</p>

<ul>
<li><p>Family <code>gaussian</code> can be used for linear regression.
</p>
</li>
<li><p>Family <code>student</code> can be used for robust linear regression
that is less influenced by outliers.
</p>
</li>
<li><p>Family <code>skew_normal</code> can handle skewed responses in linear
regression.
</p>
</li>
<li><p>Families <code>poisson</code>, <code>negbinomial</code>, and <code>geometric</code>
can be used for regression of unbounded count data.
</p>
</li>
<li><p>Families <code>bernoulli</code>, <code>binomial</code>, and <code>beta_binomial</code>
can be used for binary regression (i.e., most commonly logistic
regression).
</p>
</li>
<li><p>Families <code>categorical</code> and <code>multinomial</code> can be used for
multi-logistic regression when there are more than two possible outcomes.
</p>
</li>
<li><p>Families <code>cumulative</code>, <code>cratio</code> ('continuation ratio'),
<code>sratio</code> ('stopping ratio'), and <code>acat</code> ('adjacent category')
leads to ordinal regression.
</p>
</li>
<li><p>Families <code>Gamma</code>, <code>weibull</code>, <code>exponential</code>,
<code>lognormal</code>, <code>frechet</code>, <code>inverse.gaussian</code>, and <code>cox</code>
(Cox proportional hazards model) can be used (among others) for
time-to-event regression also known as survival regression.
</p>
</li>
<li><p>Families <code>weibull</code>, <code>frechet</code>, and <code>gen_extreme_value</code>
('generalized extreme value') allow for modeling extremes.
</p>
</li>
<li><p>Families <code>beta</code>, <code>dirichlet</code>, and <code>logistic_normal</code>
can be used to model responses representing rates or probabilities.
</p>
</li>
<li><p>Family <code>asym_laplace</code> allows for quantile regression when fixing
the auxiliary <code>quantile</code> parameter to the quantile of interest.
</p>
</li>
<li><p>Family <code>exgaussian</code> ('exponentially modified Gaussian') and
<code>shifted_lognormal</code> are especially suited to model reaction times.
</p>
</li>
<li><p>Family <code>wiener</code> provides an implementation of the Wiener
diffusion model. For this family, the main formula predicts the drift
parameter 'delta' and all other parameters are modeled as auxiliary parameters
(see <code><a href="#topic+brmsformula">brmsformula</a></code> for details).
</p>
</li>
<li><p>Families <code>hurdle_poisson</code>, <code>hurdle_negbinomial</code>,
<code>hurdle_gamma</code>, <code>hurdle_lognormal</code>, <code>zero_inflated_poisson</code>,
<code>zero_inflated_negbinomial</code>, <code>zero_inflated_binomial</code>,
<code>zero_inflated_beta_binomial</code>, <code>zero_inflated_beta</code>,
<code>zero_one_inflated_beta</code>, and <code>hurdle_cumulative</code> allow to estimate
zero-inflated and hurdle models. These models can be very helpful when there
are many zeros in the data (or ones in case of one-inflated models)
that cannot be explained by the primary distribution of the response.
</p>
</li></ul>

<p>Below, we list all possible links for each family.
The first link mentioned for each family is the default.
</p>

<ul>
<li><p>Families <code>gaussian</code>, <code>student</code>, <code>skew_normal</code>,
<code>exgaussian</code>, <code>asym_laplace</code>, and <code>gen_extreme_value</code>
support the links (as names) <code>identity</code>, <code>log</code>, <code>inverse</code>,
and <code>softplus</code>.
</p>
</li>
<li><p>Families <code>poisson</code>, <code>negbinomial</code>, <code>geometric</code>,
<code>zero_inflated_poisson</code>, <code>zero_inflated_negbinomial</code>,
<code>hurdle_poisson</code>, and <code>hurdle_negbinomial</code> support
<code>log</code>, <code>identity</code>, <code>sqrt</code>, and <code>softplus</code>.
</p>
</li>
<li><p>Families <code>binomial</code>, <code>bernoulli</code>, <code>beta_binomial</code>,
<code>zero_inflated_binomial</code>, <code>zero_inflated_beta_binomial</code>,
<code>Beta</code>, <code>zero_inflated_beta</code>, and <code>zero_one_inflated_beta</code>
support <code>logit</code>, <code>probit</code>, <code>probit_approx</code>, <code>cloglog</code>,
<code>cauchit</code>, <code>identity</code>, and <code>log</code>.
</p>
</li>
<li><p>Families <code>cumulative</code>, <code>cratio</code>, <code>sratio</code>,
<code>acat</code>, and <code>hurdle_cumulative</code> support <code>logit</code>,
<code>probit</code>, <code>probit_approx</code>, <code>cloglog</code>, and <code>cauchit</code>.
</p>
</li>
<li><p>Families <code>categorical</code>, <code>multinomial</code>, and <code>dirichlet</code>
support <code>logit</code>.
</p>
</li>
<li><p>Families <code>Gamma</code>, <code>weibull</code>, <code>exponential</code>,
<code>frechet</code>, and <code>hurdle_gamma</code> support
<code>log</code>, <code>identity</code>, <code>inverse</code>, and <code>softplus</code>.
</p>
</li>
<li><p>Families <code>lognormal</code> and <code>hurdle_lognormal</code>
support <code>identity</code> and <code>inverse</code>.
</p>
</li>
<li><p>Family <code>logistic_normal</code> supports <code>identity</code>.
</p>
</li>
<li><p>Family <code>inverse.gaussian</code> supports <code>1/mu^2</code>,
<code>inverse</code>, <code>identity</code>, <code>log</code>, and <code>softplus</code>.
</p>
</li>
<li><p>Family <code>von_mises</code> supports <code>tan_half</code> and
<code>identity</code>.
</p>
</li>
<li><p>Family <code>cox</code> supports <code>log</code>, <code>identity</code>,
and <code>softplus</code> for the proportional hazards parameter.
</p>
</li>
<li><p>Family <code>wiener</code> supports <code>identity</code>, <code>log</code>,
and <code>softplus</code> for the main parameter which represents the
drift rate.
</p>
</li></ul>

<p>Please note that when calling the <code><a href="stats.html#topic+family">Gamma</a></code> family
function of the <span class="pkg">stats</span> package, the default link will be
<code>inverse</code> instead of <code>log</code> although the latter is the default in
<span class="pkg">brms</span>. Also, when using the family functions <code>gaussian</code>,
<code>binomial</code>, <code>poisson</code>, and <code>Gamma</code> of the <span class="pkg">stats</span>
package (see <code><a href="stats.html#topic+family">family</a></code>), special link functions
such as <code>softplus</code> or <code>cauchit</code> won't work. In this case, you
have to use <code>brmsfamily</code> to specify the family with corresponding link
function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brm">brm</a></code>,
<code><a href="stats.html#topic+family">family</a></code>,
<code><a href="#topic+customfamily">customfamily</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # create a family object
 (fam1 &lt;- student("log"))
 # alternatively use the brmsfamily function
 (fam2 &lt;- brmsfamily("student", "log"))
 # both leads to the same object
 identical(fam1, fam2)

</code></pre>

<hr>
<h2 id='brmsfit_needs_refit'>Check if cached fit can be used.</h2><span id='topic+brmsfit_needs_refit'></span>

<h3>Description</h3>

<p>Checks whether a given cached fit can be used without refitting when
<code>file_refit = "on_change"</code> is used.
This function is internal and exposed only to facilitate debugging problems
with cached fits. The function may change or be removed in future versions
and scripts should not use it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brmsfit_needs_refit(
  fit,
  sdata = NULL,
  scode = NULL,
  data = NULL,
  algorithm = NULL,
  silent = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brmsfit_needs_refit_+3A_fit">fit</code></td>
<td>
<p>Old <code>brmsfit</code> object (e.g., loaded from file).</p>
</td></tr>
<tr><td><code id="brmsfit_needs_refit_+3A_sdata">sdata</code></td>
<td>
<p>New Stan data (result of a call to <code><a href="#topic+standata.default">standata</a></code>).
Pass <code>NULL</code> to avoid this data check.</p>
</td></tr>
<tr><td><code id="brmsfit_needs_refit_+3A_scode">scode</code></td>
<td>
<p>New Stan code (result of a call to <code><a href="#topic+stancode.default">stancode</a></code>).
Pass <code>NULL</code> to avoid this code check.</p>
</td></tr>
<tr><td><code id="brmsfit_needs_refit_+3A_data">data</code></td>
<td>
<p>New data to check consistency of factor level names.
Pass <code>NULL</code> to avoid this data check.</p>
</td></tr>
<tr><td><code id="brmsfit_needs_refit_+3A_algorithm">algorithm</code></td>
<td>
<p>New algorithm. Pass <code>NULL</code> to avoid algorithm check.</p>
</td></tr>
<tr><td><code id="brmsfit_needs_refit_+3A_silent">silent</code></td>
<td>
<p>Logical. If <code>TRUE</code>, no messages will be given.</p>
</td></tr>
<tr><td><code id="brmsfit_needs_refit_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> detailed report of the differences
is printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use with <code>verbose = TRUE</code> to get additional info on how the stored
fit differs from the given data and code.
</p>


<h3>Value</h3>

<p>A boolean indicating whether a refit is needed.
</p>

<hr>
<h2 id='brmsfit-class'>Class <code>brmsfit</code> of models fitted with the <span class="pkg">brms</span> package</h2><span id='topic+brmsfit-class'></span><span id='topic+brmsfit'></span>

<h3>Description</h3>

<p>Models fitted with the <code><a href="#topic+brms-package">brms</a></code> package are
represented as a <code>brmsfit</code> object, which contains the posterior
draws (samples), model formula, Stan code, relevant data, and other information.
</p>


<h3>Details</h3>

<p>See <code>methods(class = "brmsfit")</code> for an overview of available methods.
</p>


<h3>Slots</h3>


<dl>
<dt><code>formula</code></dt><dd><p>A <code><a href="#topic+brmsformula">brmsformula</a></code> object.</p>
</dd>
<dt><code>data</code></dt><dd><p>A <code>data.frame</code> containing all variables used in the model.</p>
</dd>
<dt><code>data2</code></dt><dd><p>A <code>list</code> of data objects which cannot be passed
via <code>data</code>.</p>
</dd>
<dt><code>prior</code></dt><dd><p>A <code><a href="#topic+brmsprior">brmsprior</a></code> object containing
information on the priors used in the model.</p>
</dd>
<dt><code>stanvars</code></dt><dd><p>A <code><a href="#topic+stanvars">stanvars</a></code> object.</p>
</dd>
<dt><code>model</code></dt><dd><p>The model code in <span class="pkg">Stan</span> language.</p>
</dd>
<dt><code>ranef</code></dt><dd><p>A <code>data.frame</code> containing the group-level structure.</p>
</dd>
<dt><code>exclude</code></dt><dd><p>The names of the parameters for which draws are not saved.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>The name of the algorithm used to fit the model.</p>
</dd>
<dt><code>backend</code></dt><dd><p>The name of the backend used to fit the model.</p>
</dd>
<dt><code>threads</code></dt><dd><p>An object of class 'brmsthreads' created by
<code><a href="#topic+threading">threading</a></code>.</p>
</dd>
<dt><code>opencl</code></dt><dd><p>An object of class 'brmsopencl' created by <code><a href="#topic+opencl">opencl</a></code>.</p>
</dd>
<dt><code>stan_args</code></dt><dd><p>Named list of additional control arguments that were passed
to the Stan backend directly.</p>
</dd>
<dt><code>fit</code></dt><dd><p>An object of class <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code>
among others containing the posterior draws.</p>
</dd>
<dt><code>basis</code></dt><dd><p>An object that contains a small subset of the Stan data
created at fitting time, which is needed to process new data correctly.</p>
</dd>
<dt><code>criteria</code></dt><dd><p>An empty <code>list</code> for adding model fit criteria
after estimation of the model.</p>
</dd>
<dt><code>file</code></dt><dd><p>Optional name of a file in which the model object was stored in
or loaded from.</p>
</dd>
<dt><code>version</code></dt><dd><p>The versions of <span class="pkg">brms</span> and <span class="pkg">rstan</span> with
which the model was fitted.</p>
</dd>
<dt><code>family</code></dt><dd><p>(Deprecated) A <code><a href="#topic+brmsfamily">brmsfamily</a></code> object.</p>
</dd>
<dt><code>autocor</code></dt><dd><p>(Deprecated) An <code><a href="#topic+cor_brms">cor_brms</a></code> object containing
the autocorrelation structure if specified.</p>
</dd>
<dt><code>cov_ranef</code></dt><dd><p>(Deprecated) A <code>list</code> of customized group-level
covariance matrices.</p>
</dd>
<dt><code>stan_funs</code></dt><dd><p>(Deprecated) A character string of length one or <code>NULL</code>.</p>
</dd>
<dt><code>data.name</code></dt><dd><p>(Deprecated) The name of <code>data</code> as specified by the user.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+brms">brms</a></code>,
<code><a href="#topic+brm">brm</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>,
<code><a href="#topic+brmsfamily">brmsfamily</a></code>
</p>

<hr>
<h2 id='brmsformula'>Set up a model formula for use in <span class="pkg">brms</span></h2><span id='topic+brmsformula'></span><span id='topic+bf'></span>

<h3>Description</h3>

<p>Set up a model formula for use in the <span class="pkg">brms</span> package
allowing to define (potentially non-linear) additive multilevel
models for all parameters of the assumed response distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brmsformula(
  formula,
  ...,
  flist = NULL,
  family = NULL,
  autocor = NULL,
  nl = NULL,
  loop = NULL,
  center = NULL,
  cmc = NULL,
  sparse = NULL,
  decomp = NULL,
  unused = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brmsformula_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code>
(or one that can be coerced to that class):
a symbolic description of the model to be fitted.
The details of model specification are given in 'Details'.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_...">...</code></td>
<td>
<p>Additional <code>formula</code> objects to specify predictors of
non-linear and distributional parameters. Formulas can either be named
directly or contain names on their left-hand side. Alternatively,
it is possible to fix parameters to certain values by passing
numbers or character strings in which case arguments have to be named
to provide the parameter names. See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_flist">flist</code></td>
<td>
<p>Optional list of formulas, which are treated in the
same way as formulas passed via the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_family">family</code></td>
<td>
<p>Same argument as in <code><a href="#topic+brm">brm</a></code>.
If <code>family</code> is specified in <code>brmsformula</code>, it will
overwrite the value specified in other functions.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_autocor">autocor</code></td>
<td>
<p>An optional <code>formula</code> which contains
autocorrelation terms as described in <code><a href="#topic+autocor-terms">autocor-terms</a></code>
or alternatively a <code><a href="#topic+cor_brms">cor_brms</a></code> object (deprecated).
If <code>autocor</code> is specified in <code>brmsformula</code>, it will
overwrite the value specified in other functions.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_nl">nl</code></td>
<td>
<p>Logical; Indicates whether <code>formula</code> should be
treated as specifying a non-linear model. By default, <code>formula</code>
is treated as an ordinary linear model formula.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_loop">loop</code></td>
<td>
<p>Logical; Only used in non-linear models.
Indicates if the computation of the non-linear formula should be
done inside (<code>TRUE</code>) or outside (<code>FALSE</code>) a loop
over observations. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_center">center</code></td>
<td>
<p>Logical; Indicates if the population-level design
matrix should be centered, which usually increases sampling efficiency.
See the 'Details' section for more information.
Defaults to <code>TRUE</code> for distributional parameters
and to <code>FALSE</code> for non-linear parameters.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_cmc">cmc</code></td>
<td>
<p>Logical; Indicates whether automatic cell-mean coding
should be enabled when removing the intercept by adding <code>0</code>
to the right-hand of model formulas. Defaults to <code>TRUE</code> to
mirror the behavior of standard <span class="rlang"><b>R</b></span> formula parsing.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_sparse">sparse</code></td>
<td>
<p>Logical; indicates whether the population-level design matrices
should be treated as sparse (defaults to <code>FALSE</code>). For design matrices
with many zeros, this can considerably reduce required memory. Sampling
speed is currently not improved or even slightly decreased.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_decomp">decomp</code></td>
<td>
<p>Optional name of the decomposition used for the
population-level design matrix. Defaults to <code>NULL</code> that is
no decomposition. Other options currently available are
<code>"QR"</code> for the QR decomposition that helps in fitting models
with highly correlated predictors.</p>
</td></tr>
<tr><td><code id="brmsformula_+3A_unused">unused</code></td>
<td>
<p>An optional <code>formula</code> which contains variables
that are unused in the model but should still be stored in the
model's data frame. This can be useful, for example,
if those variables are required for post-processing the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>General formula structure</b>
</p>
<p>The <code>formula</code> argument accepts formulas of the following syntax:
</p>
<p><code>response | aterms ~ pterms + (gterms | group)</code>
</p>
<p>The <code>pterms</code> part contains effects that are assumed to be the same
across observations. We call them 'population-level' or 'overall' effects,
or (adopting frequentist vocabulary) 'fixed' effects. The optional
<code>gterms</code> part may contain effects that are assumed to vary across
grouping variables specified in <code>group</code>. We call them 'group-level' or
'varying' effects, or (adopting frequentist vocabulary) 'random' effects,
although the latter name is misleading in a Bayesian context. For more
details type <code>vignette("brms_overview")</code> and
<code>vignette("brms_multilevel")</code>.
</p>
<p><b>Group-level terms</b>
</p>
<p>Multiple grouping factors each with multiple group-level effects are
possible. (Of course we can also run models without any group-level
effects.) Instead of <code>|</code> you may use <code>||</code> in grouping terms to
prevent correlations from being modeled. Equivalently, the <code>cor</code>
argument of the <code><a href="#topic+gr">gr</a></code> function can be used for this purpose,
for example, <code>(1 + x || g)</code> is equivalent to
<code>(1 + x | gr(g, cor = FALSE))</code>.
</p>
<p>It is also possible to model different group-level terms of the same
grouping factor as correlated (even across different formulas, e.g., in
non-linear models) by using <code>|&lt;ID&gt;|</code> instead of <code>|</code>. All
group-level terms sharing the same ID will be modeled as correlated. If,
for instance, one specifies the terms <code>(1+x|i|g)</code> and <code>(1+z|i|g)</code>
somewhere in the formulas passed to <code>brmsformula</code>, correlations
between the corresponding group-level effects will be estimated. In the
above example, <code>i</code> is not a variable in the data but just a symbol to
indicate correlations between multiple group-level terms. Equivalently, the
<code>id</code> argument of the <code><a href="#topic+gr">gr</a></code> function can be used as well,
for example, <code>(1 + x | gr(g, id = "i"))</code>.
</p>
<p>If levels of the grouping factor belong to different sub-populations,
it may be reasonable to assume a different covariance matrix for each
of the sub-populations. For instance, the variation within the
treatment group and within the control group in a randomized control
trial might differ. Suppose that <code>y</code> is the outcome, and
<code>x</code> is the factor indicating the treatment and control group.
Then, we could estimate different hyper-parameters of the varying
effects (in this case a varying intercept) for treatment and control
group via <code>y ~ x + (1 | gr(subject, by = x))</code>.
</p>
<p>You can specify multi-membership terms using the <code><a href="#topic+mm">mm</a></code>
function. For instance, a multi-membership term with two members
could be <code>(1 | mm(g1, g2))</code>, where <code>g1</code> and <code>g2</code>
specify the first and second member, respectively. Moreover,
if a covariate <code>x</code> varies across the levels of the grouping-factors
<code>g1</code> and <code>g2</code>, we can save the respective covariate values
in the variables <code>x1</code> and <code>x2</code> and then model the varying
effect as <code>(1 + mmc(x1, x2) | mm(g1, g2))</code>.
</p>
<p><b>Special predictor terms</b>
</p>
<p>Flexible non-linear smooth terms can modeled using the <code><a href="#topic+s">s</a></code>
and <code><a href="#topic+t2">t2</a></code> functions in the <code>pterms</code> part
of the model formula. This allows to fit generalized additive mixed
models (GAMMs) with <span class="pkg">brms</span>. The implementation is similar to that
used in the <span class="pkg">gamm4</span> package. For more details on this model class
see <code><a href="mgcv.html#topic+gam">gam</a></code> and <code><a href="mgcv.html#topic+gamm">gamm</a></code>.
</p>
<p>Gaussian process terms can be fitted using the <code><a href="#topic+gp">gp</a></code>
function in the <code>pterms</code> part of the model formula. Similar to
smooth terms, Gaussian processes can be used to model complex non-linear
relationships, for instance temporal or spatial autocorrelation.
However, they are computationally demanding and are thus not recommended
for very large datasets or approximations need to be used.
</p>
<p>The <code>pterms</code> and <code>gterms</code> parts may contain four non-standard
effect types namely monotonic, measurement error, missing value, and
category specific effects, which can be specified using terms of the
form <code>mo(predictor)</code>, <code>me(predictor, sd_predictor)</code>,
<code>mi(predictor)</code>, and <code>cs(&lt;predictors&gt;)</code>, respectively.
Category specific effects can only be estimated in
ordinal models and are explained in more detail in the package's
main vignette (type <code>vignette("brms_overview")</code>).
The other three effect types are explained in the following.
</p>
<p>A monotonic predictor must either be integer valued or an ordered factor,
which is the first difference to an ordinary continuous predictor.
More importantly, predictor categories (or integers) are not assumed to be
equidistant with respect to their effect on the response variable.
Instead, the distance between adjacent predictor categories (or integers)
is estimated from the data and may vary across categories.
This is realized by parameterizing as follows:
One parameter takes care of the direction and size of the effect similar
to an ordinary regression parameter, while an additional parameter vector
estimates the normalized distances between consecutive predictor categories.
A main application of monotonic effects are ordinal predictors that
can this way be modeled without (falsely) treating them as continuous
or as unordered categorical predictors. For more details and examples
see <code>vignette("brms_monotonic")</code>.
</p>
<p>Quite often, predictors are measured and as such naturally contain
measurement error. Although most researchers are well aware of this problem,
measurement error in predictors is ignored in most
regression analyses, possibly because only few packages allow
for modeling it. Notably, measurement error can be handled in
structural equation models, but many more general regression models
(such as those featured by <span class="pkg">brms</span>) cannot be transferred
to the SEM framework. In <span class="pkg">brms</span>, effects of noise-free predictors
can be modeled using the <code>me</code> (for 'measurement error') function.
If, say, <code>y</code> is the response variable and
<code>x</code> is a measured predictor with known measurement error
<code>sdx</code>, we can simply include it on the right-hand side of the
model formula via <code>y ~ me(x, sdx)</code>.
This can easily be extended to more general formulas.
If <code>x2</code> is another measured predictor with corresponding error
<code>sdx2</code> and <code>z</code> is a predictor without error
(e.g., an experimental setting), we can model all main effects
and interactions of the three predictors in the well known manner:
<code>y ~ me(x, sdx) * me(x2, sdx2) * z</code>.
The <code>me</code> function is soft deprecated in favor of the more flexible
and consistent <code>mi</code> function (see below).
</p>
<p>When a variable contains missing values, the corresponding rows will
be excluded from the data by default (row-wise exclusion). However,
quite often we want to keep these rows and instead estimate the missing values.
There are two approaches for this: (a) Impute missing values before
the model fitting for instance via multiple imputation (see
<code><a href="#topic+brm_multiple">brm_multiple</a></code> for a way to handle multiple imputed datasets).
(b) Impute missing values on the fly during model fitting. The latter
approach is explained in the following. Using a variable with missing
values as predictors requires two things, First, we need to specify that
the predictor contains missings that should to be imputed.
If, say, <code>y</code> is the primary response, <code>x</code> is a
predictor with missings and <code>z</code> is a predictor without missings,
we go for <code>y ~ mi(x) + z</code>. Second, we need to model <code>x</code>
as an additional response with corresponding predictors and the
addition term <code>mi()</code>. In our example, we could write
<code>x | mi() ~ z</code>. Measurement error may be included via
the <code>sdy</code> argument, say, <code>x | mi(sdy = se) ~ z</code>.
See <code><a href="#topic+mi">mi</a></code> for examples with real data.
</p>
<p><b>Autocorrelation terms</b>
</p>
<p>Autocorrelation terms can be directly specified inside the <code>pterms</code>
part as well. Details can be found in <code><a href="#topic+autocor-terms">autocor-terms</a></code>.
</p>
<p><b>Additional response information</b>
</p>
<p>Another special of the <span class="pkg">brms</span> formula syntax is the optional
<code>aterms</code> part, which may contain multiple terms of the form
<code>fun(&lt;variable&gt;)</code> separated by <code>+</code> each providing special
information on the response variable. <code>fun</code> can be replaced with
either <code>se</code>, <code>weights</code>, <code>subset</code>, <code>cens</code>, <code>trunc</code>,
<code>trials</code>, <code>cat</code>, <code>dec</code>, <code>rate</code>, <code>vreal</code>, or
<code>vint</code>. Their meanings are explained below
(see also <code><a href="#topic+addition-terms">addition-terms</a></code>).
</p>
<p>For families <code>gaussian</code>, <code>student</code> and <code>skew_normal</code>, it is
possible to specify standard errors of the observations, thus allowing
to perform meta-analysis. Suppose that the variable <code>yi</code> contains
the effect sizes from the studies and <code>sei</code> the corresponding
standard errors. Then, fixed and random effects meta-analyses can
be conducted using the formulas <code>yi | se(sei) ~ 1</code> and
<code>yi | se(sei) ~ 1 + (1|study)</code>, respectively, where
<code>study</code> is a variable uniquely identifying every study.
If desired, meta-regression can be performed via
<code>yi | se(sei) ~ 1 + mod1 + mod2 + (1|study)</code>
or <br /> <code>yi | se(sei) ~ 1 + mod1 + mod2 + (1 + mod1 + mod2|study)</code>,
where <code>mod1</code> and <code>mod2</code> represent moderator variables.
By default, the standard errors replace the parameter <code>sigma</code>.
To model <code>sigma</code> in addition to the known standard errors,
set argument <code>sigma</code> in function <code>se</code> to <code>TRUE</code>,
for instance, <code>yi | se(sei, sigma = TRUE) ~ 1</code>.
</p>
<p>For all families, weighted regression may be performed using
<code>weights</code> in the <code>aterms</code> part. Internally, this is
implemented by multiplying the log-posterior values of each
observation by their corresponding weights.
Suppose that variable <code>wei</code> contains the weights
and that <code>yi</code> is the response variable.
Then, formula <code>yi | weights(wei) ~ predictors</code>
implements a weighted regression.
</p>
<p>For multivariate models, <code>subset</code> may be used in the <code>aterms</code>
part, to use different subsets of the data in different univariate
models. For instance, if <code>sub</code> is a logical variable and
<code>y</code> is the response of one of the univariate models, we may
write <code>y | subset(sub) ~ predictors</code> so that <code>y</code> is
predicted only for those observations for which <code>sub</code> evaluates
to <code>TRUE</code>.
</p>
<p>For log-linear models such as poisson models, <code>rate</code> may be used
in the <code>aterms</code> part to specify the denominator of a response that
is expressed as a rate. The numerator is given by the actual response
variable and has a distribution according to the family as usual. Using
<code>rate(denom)</code> is equivalent to adding <code>offset(log(denom))</code> to
the linear predictor of the main parameter but the former is arguably
more convenient and explicit.
</p>
<p>With the exception of categorical and ordinal families,
left, right, and interval censoring can be modeled through
<code>y | cens(censored) ~ predictors</code>. The censoring variable
(named <code>censored</code> in this example) should contain the values
<code>'left'</code>, <code>'none'</code>, <code>'right'</code>, and <code>'interval'</code>
(or equivalently <code>-1</code>, <code>0</code>, <code>1</code>, and <code>2</code>) to indicate that
the corresponding observation is left censored, not censored, right censored,
or interval censored. For interval censored data, a second variable
(let's call it <code>y2</code>) has to be passed to <code>cens</code>. In this case,
the formula has the structure <code>y | cens(censored, y2) ~ predictors</code>.
While the lower bounds are given in <code>y</code>, the upper bounds are given
in <code>y2</code> for interval censored data. Intervals are assumed to be open
on the left and closed on the right: <code>(y, y2]</code>.
</p>
<p>With the exception of categorical and ordinal families,
the response distribution can be truncated using the <code>trunc</code>
function in the addition part. If the response variable is truncated
between, say, 0 and 100, we can specify this via
<code>yi | trunc(lb = 0, ub = 100) ~ predictors</code>.
Instead of numbers, variables in the data set can also be passed allowing
for varying truncation points across observations. Defining only one of
the two arguments in <code>trunc</code> leads to one-sided truncation.
</p>
<p>For all continuous families, missing values in the responses can be imputed
within Stan by using the addition term <code>mi</code>. This is mostly
useful in combination with <code>mi</code> predictor terms as explained
above under 'Special predictor terms'.
</p>
<p>For families <code>binomial</code> and <code>zero_inflated_binomial</code>,
addition should contain a variable indicating the number of trials
underlying each observation. In <code>lme4</code> syntax, we may write for instance
<code>cbind(success, n - success)</code>, which is equivalent
to <code>success | trials(n)</code> in <span class="pkg">brms</span> syntax. If the number of trials
is constant across all observations, say <code>10</code>,
we may also write <code>success | trials(10)</code>.
<b>Please note that the <code>cbind()</code> syntax will not work
in <span class="pkg">brms</span> in the expected way because this syntax is reserved
for other purposes.</b>
</p>
<p>For all ordinal families, <code>aterms</code> may contain a term
<code>thres(number)</code> to specify the number thresholds (e.g,
<code>thres(6)</code>), which should be equal to the total number of response
categories - 1. If not given, the number of thresholds is calculated from
the data. If different threshold vectors should be used for different
subsets of the data, the <code>gr</code> argument can be used to provide the
grouping variable (e.g, <code>thres(6, gr = item)</code>, if <code>item</code> is the
grouping variable). In this case, the number of thresholds can also be a
variable in the data with different values per group.
</p>
<p>A deprecated quasi alias of <code>thres()</code> is <code>cat()</code> with which the
total number of response categories (i.e., number of thresholds + 1) can be
specified.
</p>
<p>In Wiener diffusion models (family <code>wiener</code>) the addition term
<code>dec</code> is mandatory to specify the (vector of) binary decisions
corresponding to the reaction times. Non-zero values will be treated
as a response on the upper boundary of the diffusion process and zeros
will be treated as a response on the lower boundary. Alternatively,
the variable passed to <code>dec</code> might also be a character vector
consisting of <code>'lower'</code> and <code>'upper'</code>.
</p>
<p>All families support the <code>index</code> addition term to uniquely identify
each observation of the corresponding response variable. Currently,
<code>index</code> is primarily useful in combination with the <code>subset</code>
addition and <code><a href="#topic+mi">mi</a></code> terms.
</p>
<p>For custom families, it is possible to pass an arbitrary number of real and
integer vectors via the addition terms <code>vreal</code> and <code>vint</code>,
respectively. An example is provided in
<code>vignette('brms_customfamilies')</code>. To pass multiple vectors of the
same data type, provide them separated by commas inside a single
<code>vreal</code> or <code>vint</code> statement.
</p>
<p>Multiple addition terms of different types may be specified at the same
time using the <code>+</code> operator. For example, the formula
<code>formula = yi | se(sei) + cens(censored) ~ 1</code> implies a censored
meta-analytic model.
</p>
<p>The addition argument <code>disp</code> (short for dispersion)
has been removed in version 2.0. You may instead use the
distributional regression approach by specifying
<code>sigma ~ 1 + offset(log(xdisp))</code> or
<code>shape ~ 1 + offset(log(xdisp))</code>, where <code>xdisp</code> is
the variable being previously passed to <code>disp</code>.
</p>
<p><b>Parameterization of the population-level intercept</b>
</p>
<p>By default, the population-level intercept (if incorporated) is estimated
separately and not as part of population-level parameter vector <code>b</code> As
a result, priors on the intercept also have to be specified separately.
Furthermore, to increase sampling efficiency, the population-level design
matrix <code>X</code> is centered around its column means <code>X_means</code> if the
intercept is incorporated. This leads to a temporary bias in the intercept
equal to <code>&lt;X_means, b&gt;</code>, where <code>&lt;,&gt;</code> is the scalar product. The
bias is corrected after fitting the model, but be aware that you are
effectively defining a prior on the intercept of the centered design matrix
not on the real intercept. You can turn off this special handling of the
intercept by setting argument <code>center</code> to <code>FALSE</code>. For more
details on setting priors on population-level intercepts, see
<code><a href="#topic+set_prior">set_prior</a></code>.
</p>
<p>This behavior can be avoided by using the reserved
(and internally generated) variable <code>Intercept</code>.
Instead of <code>y ~ x</code>, you may write
<code>y ~ 0 + Intercept + x</code>. This way, priors can be
defined on the real intercept, directly. In addition,
the intercept is just treated as an ordinary population-level effect
and thus priors defined on <code>b</code> will also apply to it.
Note that this parameterization may be less efficient
than the default parameterization discussed above.
</p>
<p><b>Formula syntax for non-linear models</b>
</p>
<p>In <span class="pkg">brms</span>, it is possible to specify non-linear models
of arbitrary complexity.
The non-linear model can just be specified within the <code>formula</code>
argument. Suppose, that we want to predict the response <code>y</code>
through the predictor <code>x</code>, where <code>x</code> is linked to <code>y</code>
through <code>y = alpha - beta * lambda^x</code>, with parameters
<code>alpha</code>, <code>beta</code>, and <code>lambda</code>. This is certainly a
non-linear model being defined via
<code>formula = y ~ alpha - beta * lambda^x</code> (addition arguments
can be added in the same way as for ordinary formulas).
To tell <span class="pkg">brms</span> that this is a non-linear model,
we set argument <code>nl</code> to <code>TRUE</code>.
Now we have to specify a model for each of the non-linear parameters.
Let's say we just want to estimate those three parameters
with no further covariates or random effects. Then we can pass
<code>alpha + beta + lambda ~ 1</code> or equivalently
(and more flexible) <code>alpha ~ 1, beta ~ 1, lambda ~ 1</code>
to the <code>...</code> argument.
This can, of course, be extended. If we have another predictor <code>z</code> and
observations nested within the grouping factor <code>g</code>, we may write for
instance <code>alpha ~ 1, beta ~ 1 + z + (1|g), lambda ~ 1</code>.
The formula syntax described above applies here as well.
In this example, we are using <code>z</code> and <code>g</code> only for the
prediction of <code>beta</code>, but we might also use them for the other
non-linear parameters (provided that the resulting model is still
scientifically reasonable).
</p>
<p>By default, non-linear covariates are treated as real vectors in Stan.
However, if the data of the covariates is of type 'integer' in <span class="rlang"><b>R</b></span> (which
can be enforced by the 'as.integer' function), the Stan type will be
changed to an integer array. That way, covariates can also be used
for indexing purposes in Stan.
</p>
<p>Non-linear models may not be uniquely identified and / or show bad convergence.
For this reason it is mandatory to specify priors on the non-linear parameters.
For instructions on how to do that, see <code><a href="#topic+set_prior">set_prior</a></code>.
For some examples of non-linear models, see <code>vignette("brms_nonlinear")</code>.
</p>
<p><b>Formula syntax for predicting distributional parameters</b>
</p>
<p>It is also possible to predict parameters of the response distribution such
as the residual standard deviation <code>sigma</code> in gaussian models or the
hurdle probability <code>hu</code> in hurdle models. The syntax closely resembles
that of a non-linear parameter, for instance <code>sigma ~ x + s(z) +
  (1+x|g)</code>. For some examples of distributional models, see
<code>vignette("brms_distreg")</code>.
</p>
<p>Parameter <code>mu</code> exists for every family and can be used as an
alternative to specifying terms in <code>formula</code>. If both <code>mu</code> and
<code>formula</code> are given, the right-hand side of <code>formula</code> is ignored.
Accordingly, specifying terms on the right-hand side of both <code>formula</code>
and <code>mu</code> at the same time is deprecated. In future versions,
<code>formula</code> might be updated by <code>mu</code>.
</p>
<p>The following are
distributional parameters of specific families (all other parameters are
treated as non-linear parameters): <code>sigma</code> (residual standard
deviation or scale of the <code>gaussian</code>, <code>student</code>,
<code>skew_normal</code>, <code>lognormal</code> <code>exgaussian</code>, and
<code>asym_laplace</code> families); <code>shape</code> (shape parameter of the
<code>Gamma</code>, <code>weibull</code>, <code>negbinomial</code>, and related zero-inflated
/ hurdle families); <code>nu</code> (degrees of freedom parameter of the
<code>student</code> and <code>frechet</code> families); <code>phi</code> (precision
parameter of the <code>beta</code> and <code>zero_inflated_beta</code> families);
<code>kappa</code> (precision parameter of the <code>von_mises</code> family);
<code>beta</code> (mean parameter of the exponential component of the
<code>exgaussian</code> family); <code>quantile</code> (quantile parameter of the
<code>asym_laplace</code> family); <code>zi</code> (zero-inflation probability);
<code>hu</code> (hurdle probability); <code>zoi</code> (zero-one-inflation
probability); <code>coi</code> (conditional one-inflation probability);
<code>disc</code> (discrimination) for ordinal models; <code>bs</code>, <code>ndt</code>, and
<code>bias</code> (boundary separation, non-decision time, and initial bias of
the <code>wiener</code> diffusion model). By default, distributional parameters
are modeled on the log scale if they can be positive only or on the logit
scale if the can only be within the unit interval.
</p>
<p>Alternatively, one may fix distributional parameters to certain values.
However, this is mainly useful when models become too
complicated and otherwise have convergence issues.
We thus suggest to be generally careful when making use of this option.
The <code>quantile</code> parameter of the <code>asym_laplace</code> distribution
is a good example where it is useful. By fixing <code>quantile</code>,
one can perform quantile regression for the specified quantile.
For instance, <code>quantile = 0.25</code> allows predicting the 25%-quantile.
Furthermore, the <code>bias</code> parameter in drift-diffusion models,
is assumed to be <code>0.5</code> (i.e. no bias) in many applications.
To achieve this, simply write <code>bias = 0.5</code>.
Other possible applications are the Cauchy distribution as a
special case of the Student-t distribution with
<code>nu = 1</code>, or the geometric distribution as a special case of
the negative binomial distribution with <code>shape = 1</code>.
Furthermore, the parameter <code>disc</code> ('discrimination') in ordinal
models is fixed to <code>1</code> by default and not estimated,
but may be modeled as any other distributional parameter if desired
(see examples). For reasons of identification, <code>'disc'</code>
can only be positive, which is achieved by applying the log-link.
</p>
<p>In categorical models, distributional parameters do not have
fixed names. Instead, they are named after the response categories
(excluding the first one, which serves as the reference category),
with the prefix <code>'mu'</code>. If, for instance, categories are named
<code>cat1</code>, <code>cat2</code>, and <code>cat3</code>, the distributional parameters
will be named <code>mucat2</code> and <code>mucat3</code>.
</p>
<p>Some distributional parameters currently supported by <code>brmsformula</code>
have to be positive (a negative standard deviation or precision parameter
does not make any sense) or are bounded between 0 and 1 (for zero-inflated /
hurdle probabilities, quantiles, or the initial bias parameter of
drift-diffusion models).
However, linear predictors can be positive or negative, and thus the log link
(for positive parameters) or logit link (for probability parameters) are used
by default to ensure that distributional parameters are within their valid intervals.
This implies that, by default, effects for such distributional parameters are
estimated on the log / logit scale and one has to apply the inverse link
function to get to the effects on the original scale.
Alternatively, it is possible to use the identity link to predict parameters
on their original scale, directly. However, this is much more likely to lead
to problems in the model fitting, if the parameter actually has a restricted range.
</p>
<p>See also <code><a href="#topic+brmsfamily">brmsfamily</a></code> for an overview of valid link functions.
</p>
<p><b>Formula syntax for mixture models</b>
</p>
<p>The specification of mixture models closely resembles that
of non-mixture models. If not specified otherwise (see below),
all mean parameters of the mixture components are predicted
using the right-hand side of <code>formula</code>. All types of predictor
terms allowed in non-mixture models are allowed in mixture models
as well.
</p>
<p>Distributional parameters of mixture distributions have the same
name as those of the corresponding ordinary distributions, but with
a number at the end to indicate the mixture component. For instance, if
you use family <code>mixture(gaussian, gaussian)</code>, the distributional
parameters are <code>sigma1</code> and <code>sigma2</code>.
Distributional parameters of the same class can be fixed to the same value.
For the above example, we could write <code>sigma2 = "sigma1"</code> to make
sure that both components have the same residual standard deviation,
which is in turn estimated from the data.
</p>
<p>In addition, there are two types of special distributional parameters.
The first are named <code>mu&lt;ID&gt;</code>, that allow for modeling different
predictors for the mean parameters of different mixture components.
For instance, if you want to predict the mean of the first component
using predictor <code>x</code> and the mean of the second component using
predictor <code>z</code>, you can write <code>mu1 ~ x</code> as well as <code>mu2 ~ z</code>.
The second are named <code>theta&lt;ID&gt;</code>, which constitute the mixing
proportions. If the mixing proportions are fixed to certain values,
they are internally normalized to form a probability vector.
If one seeks to predict the mixing proportions, all but
one of the them has to be predicted, while the remaining one is used
as the reference category to identify the model. The so-called 'softmax'
transformation is applied on the linear predictor terms to form a
probability vector.
</p>
<p>For more information on mixture models, see
the documentation of <code><a href="#topic+mixture">mixture</a></code>.
</p>
<p><b>Formula syntax for multivariate models</b>
</p>
<p>Multivariate models may be specified using <code>mvbind</code> notation
or with help of the <code><a href="#topic+mvbf">mvbf</a></code> function.
Suppose that <code>y1</code> and <code>y2</code> are response variables
and <code>x</code> is a predictor. Then <code>mvbind(y1, y2) ~ x</code>
specifies a multivariate model.
The effects of all terms specified at the RHS of the formula
are assumed to vary across response variables.
For instance, two parameters will be estimated for <code>x</code>,
one for the effect on <code>y1</code> and another for the effect on <code>y2</code>.
This is also true for group-level effects. When writing, for instance,
<code>mvbind(y1, y2) ~ x + (1+x|g)</code>, group-level effects will be
estimated separately for each response. To model these effects
as correlated across responses, use the ID syntax (see above).
For the present example, this would look as follows:
<code>mvbind(y1, y2) ~ x + (1+x|2|g)</code>. Of course, you could also use
any value other than <code>2</code> as ID.
</p>
<p>It is also possible to specify different formulas for different responses.
If, for instance, <code>y1</code> should be predicted by <code>x</code> and <code>y2</code>
should be predicted by <code>z</code>, we could write <code>mvbf(y1 ~ x, y2 ~ z)</code>.
Alternatively, multiple <code>brmsformula</code> objects can be added to
specify a joint multivariate model (see 'Examples').
</p>


<h3>Value</h3>

<p>An object of class <code>brmsformula</code>, which
is essentially a <code>list</code> containing all model
formulas as well as some additional information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code>, <code><a href="#topic+brmsformula-helpers">brmsformula-helpers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># multilevel model with smoothing terms
brmsformula(y ~ x1*x2 + s(z) + (1+x1|1) + (1|g2))

# additionally predict 'sigma'
brmsformula(y ~ x1*x2 + s(z) + (1+x1|1) + (1|g2),
            sigma ~ x1 + (1|g2))

# use the shorter alias 'bf'
(formula1 &lt;- brmsformula(y ~ x + (x|g)))
(formula2 &lt;- bf(y ~ x + (x|g)))
# will be TRUE
identical(formula1, formula2)

# incorporate censoring
bf(y | cens(censor_variable) ~ predictors)

# define a simple non-linear model
bf(y ~ a1 - a2^x, a1 + a2 ~ 1, nl = TRUE)

# predict a1 and a2 differently
bf(y ~ a1 - a2^x, a1 ~ 1, a2 ~ x + (x|g), nl = TRUE)

# correlated group-level effects across parameters
bf(y ~ a1 - a2^x, a1 ~ 1 + (1 |2| g), a2 ~ x + (x |2| g), nl = TRUE)
# alternative but equivalent way to specify the above model
bf(y ~ a1 - a2^x, a1 ~ 1 + (1 | gr(g, id = 2)),
   a2 ~ x + (x | gr(g, id = 2)), nl = TRUE)

# define a multivariate model
bf(mvbind(y1, y2) ~ x * z + (1|g))

# define a zero-inflated model
# also predicting the zero-inflation part
bf(y ~ x * z + (1+x|ID1|g), zi ~ x + (1|ID1|g))

# specify a predictor as monotonic
bf(y ~ mo(x) + more_predictors)

# for ordinal models only
# specify a predictor as category specific
bf(y ~ cs(x) + more_predictors)
# add a category specific group-level intercept
bf(y ~ cs(x) + (cs(1)|g))
# specify parameter 'disc'
bf(y ~ person + item, disc ~ item)

# specify variables containing measurement error
bf(y ~ me(x, sdx))

# specify predictors on all parameters of the wiener diffusion model
# the main formula models the drift rate 'delta'
bf(rt | dec(decision) ~ x, bs ~ x, ndt ~ x, bias ~ x)

# fix the bias parameter to 0.5
bf(rt | dec(decision) ~ x, bias = 0.5)

# specify different predictors for different mixture components
mix &lt;- mixture(gaussian, gaussian)
bf(y ~ 1, mu1 ~ x, mu2 ~ z, family = mix)

# fix both residual standard deviations to the same value
bf(y ~ x, sigma2 = "sigma1", family = mix)

# use the '+' operator to specify models
bf(y ~ 1) +
  nlf(sigma ~ a * exp(b * x), a ~ x) +
  lf(b ~ z + (1|g), dpar = "sigma") +
  gaussian()

# specify a multivariate model using the '+' operator
bf(y1 ~ x + (1|g)) +
  gaussian() + cor_ar(~1|g) +
  bf(y2 ~ z) + poisson()

# specify correlated residuals of a gaussian and a poisson model
form1 &lt;- bf(y1 ~ 1 + x + (1|c|obs), sigma = 1) + gaussian()
form2 &lt;- bf(y2 ~ 1 + x + (1|c|obs)) + poisson()

# model missing values in predictors
bf(bmi ~ age * mi(chl)) +
  bf(chl | mi() ~ age) +
  set_rescor(FALSE)

# model sigma as a function of the mean
bf(y ~ eta, nl = TRUE) +
  lf(eta ~ 1 + x) +
  nlf(sigma ~ tau * sqrt(eta)) +
  lf(tau ~ 1)

</code></pre>

<hr>
<h2 id='brmsformula-helpers'>Linear and Non-linear formulas in <span class="pkg">brms</span></h2><span id='topic+brmsformula-helpers'></span><span id='topic+bf-helpers'></span><span id='topic+nlf'></span><span id='topic+lf'></span><span id='topic+set_nl'></span><span id='topic+set_rescor'></span><span id='topic+acformula'></span><span id='topic+set_mecor'></span>

<h3>Description</h3>

<p>Helper functions to specify linear and non-linear
formulas for use with <code><a href="#topic+brmsformula">brmsformula</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlf(formula, ..., flist = NULL, dpar = NULL, resp = NULL, loop = NULL)

lf(
  ...,
  flist = NULL,
  dpar = NULL,
  resp = NULL,
  center = NULL,
  cmc = NULL,
  sparse = NULL,
  decomp = NULL
)

acformula(autocor, resp = NULL)

set_nl(nl = TRUE, dpar = NULL, resp = NULL)

set_rescor(rescor = TRUE)

set_mecor(mecor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brmsformula-helpers_+3A_formula">formula</code></td>
<td>
<p>Non-linear formula for a distributional parameter.
The name of the distributional parameter can either be specified
on the left-hand side of <code>formula</code> or via argument <code>dpar</code>.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_...">...</code></td>
<td>
<p>Additional <code>formula</code> objects to specify predictors of
non-linear and distributional parameters. Formulas can either be named
directly or contain names on their left-hand side. Alternatively,
it is possible to fix parameters to certain values by passing
numbers or character strings in which case arguments have to be named
to provide the parameter names. See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_flist">flist</code></td>
<td>
<p>Optional list of formulas, which are treated in the
same way as formulas passed via the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_dpar">dpar</code></td>
<td>
<p>Optional character string specifying the distributional
parameter to which the formulas passed via <code>...</code> and
<code>flist</code> belong.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_resp">resp</code></td>
<td>
<p>Optional character string specifying the response
variable to which the formulas passed via <code>...</code> and
<code>flist</code> belong. Only relevant in multivariate models.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_loop">loop</code></td>
<td>
<p>Logical; Only used in non-linear models.
Indicates if the computation of the non-linear formula should be
done inside (<code>TRUE</code>) or outside (<code>FALSE</code>) a loop
over observations. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_center">center</code></td>
<td>
<p>Logical; Indicates if the population-level design
matrix should be centered, which usually increases sampling efficiency.
See the 'Details' section for more information.
Defaults to <code>TRUE</code> for distributional parameters
and to <code>FALSE</code> for non-linear parameters.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_cmc">cmc</code></td>
<td>
<p>Logical; Indicates whether automatic cell-mean coding
should be enabled when removing the intercept by adding <code>0</code>
to the right-hand of model formulas. Defaults to <code>TRUE</code> to
mirror the behavior of standard <span class="rlang"><b>R</b></span> formula parsing.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_sparse">sparse</code></td>
<td>
<p>Logical; indicates whether the population-level design matrices
should be treated as sparse (defaults to <code>FALSE</code>). For design matrices
with many zeros, this can considerably reduce required memory. Sampling
speed is currently not improved or even slightly decreased.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_decomp">decomp</code></td>
<td>
<p>Optional name of the decomposition used for the
population-level design matrix. Defaults to <code>NULL</code> that is
no decomposition. Other options currently available are
<code>"QR"</code> for the QR decomposition that helps in fitting models
with highly correlated predictors.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_autocor">autocor</code></td>
<td>
<p>A one sided formula containing autocorrelation
terms. All none autocorrelation terms in <code>autocor</code> will
be silently ignored.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_nl">nl</code></td>
<td>
<p>Logical; Indicates whether <code>formula</code> should be
treated as specifying a non-linear model. By default, <code>formula</code>
is treated as an ordinary linear model formula.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_rescor">rescor</code></td>
<td>
<p>Logical; Indicates if residual correlation between
the response variables should be modeled. Currently this is only
possible in multivariate <code>gaussian</code> and <code>student</code> models.
Only relevant in multivariate models.</p>
</td></tr>
<tr><td><code id="brmsformula-helpers_+3A_mecor">mecor</code></td>
<td>
<p>Logical; Indicates if correlations between latent variables
defined by <code><a href="#topic+me">me</a></code> terms should be modeled. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>lf</code> and <code>nlf</code> a <code>list</code> that can be
passed to <code><a href="#topic+brmsformula">brmsformula</a></code> or added
to an existing <code>brmsformula</code> or <code>mvbrmsformula</code> object.
For <code>set_nl</code> and <code>set_rescor</code> a logical value that can be
added to an existing <code>brmsformula</code> or <code>mvbrmsformula</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>, <code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add more formulas to the model
bf(y ~ 1) +
  nlf(sigma ~ a * exp(b * x)) +
  lf(a ~ x, b ~ z + (1|g)) +
  gaussian()

# specify 'nl' later on
bf(y ~ a * inv_logit(x * b)) +
  lf(a + b ~ z) +
  set_nl(TRUE)

# specify a multivariate model
bf(y1 ~ x + (1|g)) +
  bf(y2 ~ z) +
  set_rescor(TRUE)

# add autocorrelation terms
bf(y ~ x) + acformula(~ arma(p = 1, q = 1) + car(W))
</code></pre>

<hr>
<h2 id='brmshypothesis'>Descriptions of <code>brmshypothesis</code> Objects</h2><span id='topic+brmshypothesis'></span><span id='topic+print.brmshypothesis'></span><span id='topic+plot.brmshypothesis'></span>

<h3>Description</h3>

<p>A <code>brmshypothesis</code> object contains posterior draws
as well as summary statistics of non-linear hypotheses as
returned by <code><a href="#topic+hypothesis">hypothesis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmshypothesis'
print(x, digits = 2, chars = 20, ...)

## S3 method for class 'brmshypothesis'
plot(
  x,
  nvariables = 5,
  N = NULL,
  ignore_prior = FALSE,
  chars = 40,
  colors = NULL,
  theme = NULL,
  ask = TRUE,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brmshypothesis_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_digits">digits</code></td>
<td>
<p>Minimal number of significant digits,
see <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_chars">chars</code></td>
<td>
<p>Maximum number of characters of each hypothesis
to print or plot. If <code>NULL</code>, print the full hypotheses.
Defaults to <code>20</code>.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_nvariables">nvariables</code></td>
<td>
<p>The number of variables (parameters) plotted per page.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_n">N</code></td>
<td>
<p>Deprecated alias of <code>nvariables</code>.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_ignore_prior">ignore_prior</code></td>
<td>
<p>A flag indicating if prior distributions
should also be plotted. Only used if priors were specified on
the relevant parameters.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_colors">colors</code></td>
<td>
<p>Two values specifying the colors of the posterior
and prior density respectively. If <code>NULL</code> (the default)
colors are taken from the current color scheme of
the <span class="pkg">bayesplot</span> package.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="ggplot2.html#topic+theme">theme</a></code> object
modifying the appearance of the plots.
For some basic themes see <code><a href="ggplot2.html#topic+ggtheme">ggtheme</a></code>
and <code><a href="bayesplot.html#topic+theme_default">theme_default</a></code>.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_ask">ask</code></td>
<td>
<p>Logical; indicates if the user is prompted
before a new page is plotted.
Only used if <code>plot</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="brmshypothesis_+3A_plot">plot</code></td>
<td>
<p>Logical; indicates if plots should be
plotted directly in the active graphic device.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two most important elements of a <code>brmshypothesis</code> object are
<code>hypothesis</code>, which is a data.frame containing the summary estimates
of the hypotheses, and <code>samples</code>, which is a data.frame containing
the corresponding posterior draws.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypothesis">hypothesis</a></code>
</p>

<hr>
<h2 id='brmsterms'>Parse Formulas of <span class="pkg">brms</span> Models</h2><span id='topic+brmsterms'></span><span id='topic+parse_bf'></span><span id='topic+brmsterms.default'></span><span id='topic+brmsterms.brmsformula'></span><span id='topic+brmsterms.mvbrmsformula'></span>

<h3>Description</h3>

<p>Parse formulas objects for use in <span class="pkg">brms</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brmsterms(formula, ...)

## Default S3 method:
brmsterms(formula, ...)

## S3 method for class 'brmsformula'
brmsterms(formula, check_response = TRUE, resp_rhs_all = TRUE, ...)

## S3 method for class 'mvbrmsformula'
brmsterms(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brmsterms_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>, or <code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code> (or one that can
be coerced to that classes): A symbolic description of the model to be
fitted. The details of model specification are explained in
<code><a href="#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="brmsterms_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="brmsterms_+3A_check_response">check_response</code></td>
<td>
<p>Logical; Indicates whether the left-hand side
of <code>formula</code> (i.e. response variables and addition arguments)
should be parsed. If <code>FALSE</code>, <code>formula</code> may also be one-sided.</p>
</td></tr>
<tr><td><code id="brmsterms_+3A_resp_rhs_all">resp_rhs_all</code></td>
<td>
<p>Logical; Indicates whether to also include response
variables on the right-hand side of formula <code>.$allvars</code>,
where <code>.</code> represents the output of <code>brmsterms</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main formula parsing function of <span class="pkg">brms</span>.
It should usually not be called directly, but is exported to allow
package developers making use of the formula syntax implemented
in <span class="pkg">brms</span>. As long as no other packages depend on this functions,
it may be changed without deprecation warnings, when new features make
this necessary.
</p>


<h3>Value</h3>

<p>An object of class <code>brmsterms</code> or <code>mvbrmsterms</code>
(for multivariate models), which is a <code>list</code> containing all
required information initially stored in <code>formula</code>
in an easier to use format, basically a list of formulas
(not an abstract syntax tree).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brm">brm</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>,
<code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code>
</p>

<hr>
<h2 id='car'>Spatial conditional autoregressive (CAR) structures</h2><span id='topic+car'></span>

<h3>Description</h3>

<p>Set up an spatial conditional autoregressive (CAR) term in <span class="pkg">brms</span>. The
function does not evaluate its arguments &ndash; it exists purely to help set up a
model with CAR terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>car(M, gr = NA, type = "escar")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="car_+3A_m">M</code></td>
<td>
<p>Adjacency matrix of locations. All non-zero entries are treated as
if the two locations are adjacent. If <code>gr</code> is specified, the row names
of <code>M</code> have to match the levels of the grouping factor.</p>
</td></tr>
<tr><td><code id="car_+3A_gr">gr</code></td>
<td>
<p>An optional grouping factor mapping observations to spatial
locations. If not specified, each observation is treated as a separate
location. It is recommended to always specify a grouping factor to allow
for handling of new data in post-processing methods.</p>
</td></tr>
<tr><td><code id="car_+3A_type">type</code></td>
<td>
<p>Type of the CAR structure. Currently implemented are
<code>"escar"</code> (exact sparse CAR), <code>"esicar"</code> (exact sparse intrinsic
CAR), <code>"icar"</code> (intrinsic CAR), and <code>"bym2"</code>. More information is
provided in the 'Details' section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>escar</code> and <code>esicar</code> types are
implemented based on the case study of Max Joseph
(<a href="https://github.com/mbjoseph/CARstan">https://github.com/mbjoseph/CARstan</a>). The <code>icar</code> and
<code>bym2</code> type is implemented based on the case study of Mitzi Morris
(<a href="https://mc-stan.org/users/documentation/case-studies/icar_stan.html">https://mc-stan.org/users/documentation/case-studies/icar_stan.html</a>).
</p>


<h3>Value</h3>

<p>An object of class <code>'car_term'</code>, which is a list
of arguments to be interpreted by the formula
parsing functions of <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocor-terms">autocor-terms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate some spatial data
east &lt;- north &lt;- 1:10
Grid &lt;- expand.grid(east, north)
K &lt;- nrow(Grid)

# set up distance and neighbourhood matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;- array(0, c(K, K))
W[distance == 1] &lt;- 1

# generate the covariates and response data
x1 &lt;- rnorm(K)
x2 &lt;- rnorm(K)
theta &lt;- rnorm(K, sd = 0.05)
phi &lt;- rmulti_normal(
  1, mu = rep(0, K), Sigma = 0.4 * exp(-0.1 * distance)
)
eta &lt;- x1 + x2 + phi
prob &lt;- exp(eta) / (1 + exp(eta))
size &lt;- rep(50, K)
y &lt;- rbinom(n = K, size = size, prob = prob)
dat &lt;- data.frame(y, size, x1, x2)

# fit a CAR model
fit &lt;- brm(y | trials(size) ~ x1 + x2 + car(W),
           data = dat, data2 = list(W = W),
           family = binomial())
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='coef.brmsfit'>Extract Model Coefficients</h2><span id='topic+coef.brmsfit'></span>

<h3>Description</h3>

<p>Extract model coefficients, which are the sum of population-level
effects and corresponding group-level effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
coef(object, summary = TRUE, robust = FALSE, probs = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="coef.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+fixef.brmsfit">fixef.brmsfit</a></code>
and <code><a href="#topic+ranef.brmsfit">ranef.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3D arrays (one per grouping factor).
If <code>summary</code> is <code>TRUE</code>,
the 1st dimension contains the factor levels,
the 2nd dimension contains the summary statistics
(see <code><a href="#topic+posterior_summary">posterior_summary</a></code>), and
the 3rd dimension contains the group-level effects.
If <code>summary</code> is <code>FALSE</code>, the 1st dimension contains
the posterior draws, the 2nd dimension contains the factor levels,
and the 3rd dimension contains the group-level effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zAge + zBase * Trt + (1+Trt|visit),
           data = epilepsy, family = gaussian(), chains = 2)
## extract population and group-level coefficients separately
fixef(fit)
ranef(fit)
## extract combined coefficients
coef(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='combine_models'>Combine Models fitted with <span class="pkg">brms</span></h2><span id='topic+combine_models'></span>

<h3>Description</h3>

<p>Combine multiple <code>brmsfit</code> objects, which fitted the same model.
This is usefully for instance when having manually run models in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_models(..., mlist = NULL, check_data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_models_+3A_...">...</code></td>
<td>
<p>One or more <code>brmsfit</code> objects.</p>
</td></tr>
<tr><td><code id="combine_models_+3A_mlist">mlist</code></td>
<td>
<p>Optional list of one or more <code>brmsfit</code> objects.</p>
</td></tr>
<tr><td><code id="combine_models_+3A_check_data">check_data</code></td>
<td>
<p>Logical; indicates if the data should be checked
for being the same across models (defaults to <code>TRUE</code>).
Setting it to <code>FALSE</code> may be useful for instance
when combining models fitted on multiple imputed data sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function just takes the first model and replaces
its <code>stanfit</code> object (slot <code>fit</code>) by the combined
<code>stanfit</code> objects of all models.
</p>


<h3>Value</h3>

<p>A <code>brmsfit</code> object.
</p>

<hr>
<h2 id='compare_ic'>Compare Information Criteria of Different Models</h2><span id='topic+compare_ic'></span>

<h3>Description</h3>

<p>Compare information criteria of different models fitted
with <code><a href="#topic+waic">waic</a></code> or <code><a href="#topic+loo">loo</a></code>.
Deprecated and will be removed in the future. Please use
<code><a href="#topic+loo_compare">loo_compare</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_ic(..., x = NULL, ic = c("loo", "waic", "kfold"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_ic_+3A_...">...</code></td>
<td>
<p>At least two objects returned by
<code><a href="#topic+waic">waic</a></code> or <code><a href="#topic+loo">loo</a></code>.
Alternatively, <code>brmsfit</code> objects with information
criteria precomputed via <code><a href="#topic+add_ic">add_ic</a></code>
may be passed, as well.</p>
</td></tr>
<tr><td><code id="compare_ic_+3A_x">x</code></td>
<td>
<p>A <code>list</code> containing the same types of objects as
can be passed via <code>...</code>.</p>
</td></tr>
<tr><td><code id="compare_ic_+3A_ic">ic</code></td>
<td>
<p>The name of the information criterion to be extracted
from <code>brmsfit</code> objects. Ignored if information
criterion objects are only passed directly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+loo_compare">loo_compare</a></code> for the recommended way
of comparing models with the <span class="pkg">loo</span> package.
</p>


<h3>Value</h3>

<p>An object of class <code>iclist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loo">loo</a></code>,
<code><a href="#topic+loo_compare">loo_compare</a></code>
<code><a href="#topic+add_criterion">add_criterion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with population-level effects only
fit1 &lt;- brm(rating ~ treat + period + carry,
            data = inhaler)
waic1 &lt;- waic(fit1)

# model with an additional varying intercept for subjects
fit2 &lt;- brm(rating ~ treat + period + carry + (1|subject),
            data = inhaler)
waic2 &lt;- waic(fit2)

# compare both models
compare_ic(waic1, waic2)

## End(Not run)

</code></pre>

<hr>
<h2 id='conditional_effects.brmsfit'>Display Conditional Effects of Predictors</h2><span id='topic+conditional_effects.brmsfit'></span><span id='topic+marginal_effects'></span><span id='topic+marginal_effects.brmsfit'></span><span id='topic+conditional_effects'></span><span id='topic+plot.brms_conditional_effects'></span>

<h3>Description</h3>

<p>Display conditional effects of one or more numeric and/or categorical
predictors including two-way interaction effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
conditional_effects(
  x,
  effects = NULL,
  conditions = NULL,
  int_conditions = NULL,
  re_formula = NA,
  prob = 0.95,
  robust = TRUE,
  method = "posterior_epred",
  spaghetti = FALSE,
  surface = FALSE,
  categorical = FALSE,
  ordinal = FALSE,
  transform = NULL,
  resolution = 100,
  select_points = 0,
  too_far = 0,
  probs = NULL,
  ...
)

conditional_effects(x, ...)

## S3 method for class 'brms_conditional_effects'
plot(
  x,
  ncol = NULL,
  points = getOption("brms.plot_points", FALSE),
  rug = getOption("brms.plot_rug", FALSE),
  mean = TRUE,
  jitter_width = 0,
  stype = c("contour", "raster"),
  line_args = list(),
  cat_args = list(),
  errorbar_args = list(),
  surface_args = list(),
  spaghetti_args = list(),
  point_args = list(),
  rug_args = list(),
  facet_args = list(),
  theme = NULL,
  ask = TRUE,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_effects.brmsfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_effects">effects</code></td>
<td>
<p>An optional character vector naming effects (main effects or
interactions) for which to compute conditional plots. Interactions are
specified by a <code>:</code> between variable names. If <code>NULL</code> (the
default), plots are generated for all main effects and two-way interactions
estimated in the model. When specifying <code>effects</code> manually, <em>all</em>
two-way interactions (including grouping variables) may be plotted
even if not originally modeled.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_conditions">conditions</code></td>
<td>
<p>An optional <code>data.frame</code> containing variable values
to condition on. Each effect defined in <code>effects</code> will
be plotted separately for each row of <code>conditions</code>. Values in the
<code>cond__</code> column will be used as titles of the subplots. If <code>cond__</code>
is not given, the row names will be used for this purpose instead.
It is recommended to only define a few rows in order to keep the plots clear.
See <code><a href="#topic+make_conditions">make_conditions</a></code> for an easy way to define conditions.
If <code>NULL</code> (the default), numeric variables will be conditionalized by
using their means and factors will get their first level assigned.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_int_conditions">int_conditions</code></td>
<td>
<p>An optional named <code>list</code> whose elements are
vectors of values of the variables specified in <code>effects</code>.
At these values, predictions are evaluated. The names of
<code>int_conditions</code> have to match the variable names exactly.
Additionally, the elements of the vectors may be named themselves,
in which case their names appear as labels for the conditions in the plots.
Instead of vectors, functions returning vectors may be passed and are
applied on the original values of the corresponding variable.
If <code>NULL</code> (the default), predictions are evaluated at the
<code class="reqn">mean</code> and at <code class="reqn">mean +/- sd</code> for numeric predictors and at
all categories for factor-like predictors.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>A formula containing group-level effects to be considered
in the conditional predictions. If <code>NULL</code>, include all group-level
effects; if <code>NA</code> (default), include no group-level effects.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_prob">prob</code></td>
<td>
<p>A value between 0 and 1 indicating the desired probability
to be covered by the uncertainty intervals. The default is 0.95.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>TRUE</code> (the default) the median is used as the
measure of central tendency. If <code>FALSE</code> the mean is used instead.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_method">method</code></td>
<td>
<p>Method used to obtain predictions. Can be set to
<code>"posterior_epred"</code> (the default), <code>"posterior_predict"</code>,
or <code>"posterior_linpred"</code>. For more details, see the respective
function documentations.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_spaghetti">spaghetti</code></td>
<td>
<p>Logical. Indicates if predictions should
be visualized via spaghetti plots. Only applied for numeric
predictors. If <code>TRUE</code>, it is recommended
to set argument <code>ndraws</code> to a relatively small value
(e.g., <code>100</code>) in order to reduce computation time.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_surface">surface</code></td>
<td>
<p>Logical. Indicates if interactions or
two-dimensional smooths should be visualized as a surface.
Defaults to <code>FALSE</code>. The surface type can be controlled
via argument <code>stype</code> of the related plotting method.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_categorical">categorical</code></td>
<td>
<p>Logical. Indicates if effects of categorical
or ordinal models should be shown in terms of probabilities
of response categories. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_ordinal">ordinal</code></td>
<td>
<p>(Deprecated) Please use argument <code>categorical</code>.
Logical. Indicates if effects in ordinal models
should be visualized as a raster with the response categories
on the y-axis. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_transform">transform</code></td>
<td>
<p>A function or a character string naming
a function to be applied on the predicted responses
before summary statistics are computed. Only allowed
if <code>method = "posterior_predict"</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_resolution">resolution</code></td>
<td>
<p>Number of support points used to generate
the plots. Higher resolution leads to smoother plots.
Defaults to <code>100</code>. If <code>surface</code> is <code>TRUE</code>,
this implies <code>10000</code> support points for interaction terms,
so it might be necessary to reduce <code>resolution</code>
when only few RAM is available.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_select_points">select_points</code></td>
<td>
<p>Positive number.
Only relevant if <code>points</code> or <code>rug</code> are set to <code>TRUE</code>:
Actual data points of numeric variables that
are too far away from the values specified in <code>conditions</code>
can be excluded from the plot. Values are scaled into
the unit interval and then points more than <code>select_points</code>
from the values in <code>conditions</code> are excluded.
By default, all points are used.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_too_far">too_far</code></td>
<td>
<p>Positive number.
For surface plots only: Grid points that are too
far away from the actual data points can be excluded from the plot.
<code>too_far</code> determines what is too far. The grid is scaled into
the unit square and then grid points more than <code>too_far</code>
from the predictor variables are excluded. By default, all
grid points are used. Ignored for non-surface plots.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_probs">probs</code></td>
<td>
<p>(Deprecated) The quantiles to be used in the computation of
uncertainty intervals. Please use argument <code>prob</code> instead.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments such as <code>draw_ids</code> or <code>ndraws</code>
passed to <code><a href="#topic+posterior_predict">posterior_predict</a></code> or <code><a href="#topic+posterior_epred">posterior_epred</a></code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_ncol">ncol</code></td>
<td>
<p>Number of plots to display per column for each effect.
If <code>NULL</code> (default), <code>ncol</code> is computed internally based
on the number of rows of <code>conditions</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_points">points</code></td>
<td>
<p>Logical. Indicates if the original data points should be added
via <code><a href="ggplot2.html#topic+geom_jitter">geom_jitter</a></code>. Default is <code>FALSE</code>. Can be controlled
globally via the <code>brms.plot_points</code> option. Note that only those data
points will be added that match the specified conditions defined in
<code>conditions</code>. For categorical predictors, the conditions have to match
exactly. For numeric predictors, argument <code>select_points</code> is used to
determine, which points do match a condition.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_rug">rug</code></td>
<td>
<p>Logical. Indicates if a rug representation of predictor values
should be added via <code><a href="ggplot2.html#topic+geom_rug">geom_rug</a></code>. Default is <code>FALSE</code>.
Depends on <code>select_points</code> in the same way as <code>points</code> does. Can
be controlled globally via the <code>brms.plot_rug</code> option.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_mean">mean</code></td>
<td>
<p>Logical. Only relevant for spaghetti plots.
If <code>TRUE</code> (the default), display the mean regression
line on top of the regression lines for each sample.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_jitter_width">jitter_width</code></td>
<td>
<p>Only used if <code>points = TRUE</code>:
Amount of horizontal jittering of the data points.
Mainly useful for ordinal models. Defaults to <code>0</code> that
is no jittering.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_stype">stype</code></td>
<td>
<p>Indicates how surface plots should be displayed.
Either <code>"contour"</code> or <code>"raster"</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_line_args">line_args</code></td>
<td>
<p>Only used in plots of continuous predictors:
A named list of arguments passed to
<code><a href="ggplot2.html#topic+geom_smooth">geom_smooth</a></code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_cat_args">cat_args</code></td>
<td>
<p>Only used in plots of categorical predictors:
A named list of arguments passed to
<code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_errorbar_args">errorbar_args</code></td>
<td>
<p>Only used in plots of categorical predictors:
A named list of arguments passed to
<code><a href="ggplot2.html#topic+geom_errorbar">geom_errorbar</a></code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_surface_args">surface_args</code></td>
<td>
<p>Only used in surface plots:
A named list of arguments passed to
<code><a href="ggplot2.html#topic+geom_contour">geom_contour</a></code> or
<code><a href="ggplot2.html#topic+geom_raster">geom_raster</a></code>
(depending on argument <code>stype</code>).</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_spaghetti_args">spaghetti_args</code></td>
<td>
<p>Only used in spaghetti plots:
A named list of arguments passed to
<code><a href="ggplot2.html#topic+geom_smooth">geom_smooth</a></code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_point_args">point_args</code></td>
<td>
<p>Only used if <code>points = TRUE</code>:
A named list of arguments passed to
<code><a href="ggplot2.html#topic+geom_jitter">geom_jitter</a></code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_rug_args">rug_args</code></td>
<td>
<p>Only used if <code>rug = TRUE</code>:
A named list of arguments passed to
<code><a href="ggplot2.html#topic+geom_rug">geom_rug</a></code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_facet_args">facet_args</code></td>
<td>
<p>Only used if if multiple condtions are provided:
A named list of arguments passed to
<code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="ggplot2.html#topic+theme">theme</a></code> object
modifying the appearance of the plots.
For some basic themes see <code><a href="ggplot2.html#topic+ggtheme">ggtheme</a></code>
and <code><a href="bayesplot.html#topic+theme_default">theme_default</a></code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_ask">ask</code></td>
<td>
<p>Logical; indicates if the user is prompted
before a new page is plotted.
Only used if <code>plot</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.brmsfit_+3A_plot">plot</code></td>
<td>
<p>Logical; indicates if plots should be
plotted directly in the active graphic device.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When creating <code>conditional_effects</code> for a particular predictor
(or interaction of two predictors), one has to choose the values of all
other predictors to condition on. By default, the mean is used for
continuous variables and the reference category is used for factors, but
you may change these values via argument <code>conditions</code>. This also has
an implication for the <code>points</code> argument: In the created plots, only
those points will be shown that correspond to the factor levels actually
used in the conditioning, in order not to create the false impression of
bad model fit, where it is just due to conditioning on certain factor
levels.
</p>
<p>To fully change colors of the created plots, one has to amend both
<code>scale_colour</code> and <code>scale_fill</code>. See
<code><a href="ggplot2.html#topic+scale_colour_grey">scale_colour_grey</a></code> or <code><a href="ggplot2.html#topic+scale_colour_gradient">scale_colour_gradient</a></code> for
more details.
</p>


<h3>Value</h3>

<p>An object of class <code>'brms_conditional_effects'</code> which is a
named list with one data.frame per effect containing all information
required to generate conditional effects plots. Among others, these
data.frames contain some special variables, namely <code>estimate__</code>
(predicted values of the response), <code>se__</code> (standard error of the
predicted response), <code>lower__</code> and <code>upper__</code> (lower and upper
bounds of the uncertainty interval of the response), as well as
<code>cond__</code> (used in faceting when <code>conditions</code> contains multiple
rows).
</p>
<p>The corresponding <code>plot</code> method returns a named
list of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> objects, which can be further
customized using the <span class="pkg">ggplot2</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zAge + zBase * Trt + (1 | patient),
           data = epilepsy, family = poisson())

## plot all conditional effects
plot(conditional_effects(fit), ask = FALSE)

## change colours to grey scale
library(ggplot2)
ce &lt;- conditional_effects(fit, "zBase:Trt")
plot(ce, plot = FALSE)[[1]] +
  scale_color_grey() +
  scale_fill_grey()

## only plot the conditional interaction effect of 'zBase:Trt'
## for different values for 'zAge'
conditions &lt;- data.frame(zAge = c(-1, 0, 1))
plot(conditional_effects(fit, effects = "zBase:Trt",
                         conditions = conditions))

## also incorporate group-level effects variance over patients
## also add data points and a rug representation of predictor values
plot(conditional_effects(fit, effects = "zBase:Trt",
                         conditions = conditions, re_formula = NULL),
     points = TRUE, rug = TRUE)

## change handling of two-way interactions
int_conditions &lt;- list(
  zBase = setNames(c(-2, 1, 0), c("b", "c", "a"))
)
conditional_effects(fit, effects = "Trt:zBase",
                    int_conditions = int_conditions)
conditional_effects(fit, effects = "Trt:zBase",
                    int_conditions = list(zBase = quantile))

## fit a model to illustrate how to plot 3-way interactions
fit3way &lt;- brm(count ~ zAge * zBase * Trt, data = epilepsy)
conditions &lt;- make_conditions(fit3way, "zAge")
conditional_effects(fit3way, "zBase:Trt", conditions = conditions)
## only include points close to the specified values of zAge
ce &lt;- conditional_effects(
  fit3way, "zBase:Trt", conditions = conditions,
  select_points = 0.1
)
plot(ce, points = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='conditional_smooths.brmsfit'>Display Smooth Terms</h2><span id='topic+conditional_smooths.brmsfit'></span><span id='topic+marginal_smooths'></span><span id='topic+marginal_smooths.brmsfit'></span><span id='topic+conditional_smooths'></span>

<h3>Description</h3>

<p>Display smooth <code>s</code> and <code>t2</code> terms of models
fitted with <span class="pkg">brms</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
conditional_smooths(
  x,
  smooths = NULL,
  int_conditions = NULL,
  prob = 0.95,
  spaghetti = FALSE,
  resolution = 100,
  too_far = 0,
  ndraws = NULL,
  draw_ids = NULL,
  nsamples = NULL,
  subset = NULL,
  probs = NULL,
  ...
)

conditional_smooths(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_smooths.brmsfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_smooths">smooths</code></td>
<td>
<p>Optional character vector of smooth terms
to display. If <code>NULL</code> (the default) all smooth terms
are shown.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_int_conditions">int_conditions</code></td>
<td>
<p>An optional named <code>list</code> whose elements are
vectors of values of the variables specified in <code>effects</code>.
At these values, predictions are evaluated. The names of
<code>int_conditions</code> have to match the variable names exactly.
Additionally, the elements of the vectors may be named themselves,
in which case their names appear as labels for the conditions in the plots.
Instead of vectors, functions returning vectors may be passed and are
applied on the original values of the corresponding variable.
If <code>NULL</code> (the default), predictions are evaluated at the
<code class="reqn">mean</code> and at <code class="reqn">mean +/- sd</code> for numeric predictors and at
all categories for factor-like predictors.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_prob">prob</code></td>
<td>
<p>A value between 0 and 1 indicating the desired probability
to be covered by the uncertainty intervals. The default is 0.95.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_spaghetti">spaghetti</code></td>
<td>
<p>Logical. Indicates if predictions should
be visualized via spaghetti plots. Only applied for numeric
predictors. If <code>TRUE</code>, it is recommended
to set argument <code>ndraws</code> to a relatively small value
(e.g., <code>100</code>) in order to reduce computation time.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_resolution">resolution</code></td>
<td>
<p>Number of support points used to generate
the plots. Higher resolution leads to smoother plots.
Defaults to <code>100</code>. If <code>surface</code> is <code>TRUE</code>,
this implies <code>10000</code> support points for interaction terms,
so it might be necessary to reduce <code>resolution</code>
when only few RAM is available.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_too_far">too_far</code></td>
<td>
<p>Positive number.
For surface plots only: Grid points that are too
far away from the actual data points can be excluded from the plot.
<code>too_far</code> determines what is too far. The grid is scaled into
the unit square and then grid points more than <code>too_far</code>
from the predictor variables are excluded. By default, all
grid points are used. Ignored for non-surface plots.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many
posterior draws should be used.
If <code>NULL</code> (the default) all draws are used.
Ignored if <code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying
the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_nsamples">nsamples</code></td>
<td>
<p>Deprecated alias of <code>ndraws</code>.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_subset">subset</code></td>
<td>
<p>Deprecated alias of <code>draw_ids</code>.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_probs">probs</code></td>
<td>
<p>(Deprecated) The quantiles to be used in the computation of
uncertainty intervals. Please use argument <code>prob</code> instead.</p>
</td></tr>
<tr><td><code id="conditional_smooths.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two-dimensional smooth terms will be visualized using
either contour or raster plots.
</p>


<h3>Value</h3>

<p>For the <code>brmsfit</code> method,
an object of class <code>brms_conditional_effects</code>. See
<code><a href="#topic+conditional_effects">conditional_effects</a></code> for
more details and documentation of the related plotting function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(0)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
fit &lt;- brm(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat)
# show all smooth terms
plot(conditional_smooths(fit), rug = TRUE, ask = FALSE)
# show only the smooth term s(x2)
plot(conditional_smooths(fit, smooths = "s(x2)"), ask = FALSE)

# fit and plot a two-dimensional smooth term
fit2 &lt;- brm(y ~ t2(x0, x2), data = dat)
ms &lt;- conditional_smooths(fit2)
plot(ms, stype = "contour")
plot(ms, stype = "raster")

## End(Not run)

</code></pre>

<hr>
<h2 id='constant'>Constant priors in <span class="pkg">brms</span></h2><span id='topic+constant'></span>

<h3>Description</h3>

<p>Function used to set up constant priors in <span class="pkg">brms</span>.
The function does not evaluate its arguments &ndash; it exists purely
to help set up the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constant(const, broadcast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constant_+3A_const">const</code></td>
<td>
<p>Numeric value, vector, matrix of values to which the parameters
should be fixed to. Can also be a valid Stan variable in the model.</p>
</td></tr>
<tr><td><code id="constant_+3A_broadcast">broadcast</code></td>
<td>
<p>Should <code>const</code> be automatically broadcasted to the
correct size of the parameter? Defaults to <code>TRUE</code>. If you supply
vectors or matrices in <code>const</code> or vector/matrix valued Stan variables,
you need to set <code>broadcast</code> to <code>TRUE</code> (see Examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with elements <code>const</code> and <code>broadcast</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stancode(count ~ Base + Age, data = epilepsy,
         prior = prior(constant(1), class = "b"))

# will fail parsing because brms will try to broadcast a vector into a vector
stancode(count ~ Base + Age, data = epilepsy,
         prior = prior(constant(alpha), class = "b"),
         stanvars = stanvar(c(1, 0), name = "alpha"))

stancode(count ~ Base + Age, data = epilepsy,
         prior = prior(constant(alpha, broadcast = FALSE), class = "b"),
         stanvars = stanvar(c(1, 0), name = "alpha"))

</code></pre>

<hr>
<h2 id='control_params'>Extract Control Parameters of the NUTS Sampler</h2><span id='topic+control_params'></span><span id='topic+control_params.brmsfit'></span>

<h3>Description</h3>

<p>Extract control parameters of the NUTS sampler such as
<code>adapt_delta</code> or <code>max_treedepth</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_params(x, ...)

## S3 method for class 'brmsfit'
control_params(x, pars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_params_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="control_params_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="control_params_+3A_pars">pars</code></td>
<td>
<p>Optional names of the control parameters to be returned.
If <code>NULL</code> (the default) all control parameters are returned.
See <code><a href="rstan.html#topic+stan">stan</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> with control parameter values.
</p>

<hr>
<h2 id='cor_ar'>(Deprecated) AR(p) correlation structure</h2><span id='topic+cor_ar'></span>

<h3>Description</h3>

<p>This function is deprecated. Please see <code><a href="#topic+ar">ar</a></code> for the new syntax.
This function is a constructor for the <code>cor_arma</code> class,
allowing for autoregression terms only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_ar(formula = ~1, p = 1, cov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_ar_+3A_formula">formula</code></td>
<td>
<p>A one sided formula of the form <code>~ t</code>, or <code>~ t | g</code>,
specifying a time covariate <code>t</code> and, optionally, a grouping factor
<code>g</code>. A covariate for this correlation structure must be integer
valued. When a grouping factor is present in <code>formula</code>, the
correlation structure is assumed to apply only to observations within the
same grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds to
using the order of the observations in the data as a covariate, and no
groups.</p>
</td></tr>
<tr><td><code id="cor_ar_+3A_p">p</code></td>
<td>
<p>A non-negative integer specifying the autoregressive (AR)
order of the ARMA structure. Default is 1.</p>
</td></tr>
<tr><td><code id="cor_ar_+3A_cov">cov</code></td>
<td>
<p>A flag indicating whether ARMA effects should be estimated by
means of residual covariance matrices. This is currently only possible for
stationary ARMA effects of order 1. If the model family does not have
natural residuals, latent residuals are added automatically. If
<code>FALSE</code> (the default) a regression formulation is used that is
considerably faster and allows for ARMA effects of order higher than 1 but
is only available for <code>gaussian</code> models and some of its
generalizations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AR refers to autoregressive effects of residuals, which
is what is typically understood as autoregressive effects.
However, one may also model autoregressive effects of the response
variable, which is called ARR in <span class="pkg">brms</span>.
</p>


<h3>Value</h3>

<p>An object of class <code>cor_arma</code> containing solely autoregression terms.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_arma">cor_arma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor_ar(~visit|patient, p = 2)

</code></pre>

<hr>
<h2 id='cor_arma'>(Deprecated) ARMA(p,q) correlation structure</h2><span id='topic+cor_arma'></span><span id='topic+cor_arma-class'></span>

<h3>Description</h3>

<p>This function is deprecated. Please see <code><a href="#topic+arma">arma</a></code> for the new syntax.
This functions is a constructor for the <code>cor_arma</code> class, representing
an autoregression-moving average correlation structure of order (p, q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_arma(formula = ~1, p = 0, q = 0, r = 0, cov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_arma_+3A_formula">formula</code></td>
<td>
<p>A one sided formula of the form <code>~ t</code>, or <code>~ t | g</code>,
specifying a time covariate <code>t</code> and, optionally, a grouping factor
<code>g</code>. A covariate for this correlation structure must be integer
valued. When a grouping factor is present in <code>formula</code>, the
correlation structure is assumed to apply only to observations within the
same grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds to
using the order of the observations in the data as a covariate, and no
groups.</p>
</td></tr>
<tr><td><code id="cor_arma_+3A_p">p</code></td>
<td>
<p>A non-negative integer specifying the autoregressive (AR)
order of the ARMA structure. Default is 0.</p>
</td></tr>
<tr><td><code id="cor_arma_+3A_q">q</code></td>
<td>
<p>A non-negative integer specifying the moving average (MA)
order of the ARMA structure. Default is 0.</p>
</td></tr>
<tr><td><code id="cor_arma_+3A_r">r</code></td>
<td>
<p>No longer supported.</p>
</td></tr>
<tr><td><code id="cor_arma_+3A_cov">cov</code></td>
<td>
<p>A flag indicating whether ARMA effects should be estimated by
means of residual covariance matrices. This is currently only possible for
stationary ARMA effects of order 1. If the model family does not have
natural residuals, latent residuals are added automatically. If
<code>FALSE</code> (the default) a regression formulation is used that is
considerably faster and allows for ARMA effects of order higher than 1 but
is only available for <code>gaussian</code> models and some of its
generalizations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cor_arma</code>, representing an
autoregression-moving-average correlation structure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_ar">cor_ar</a></code>, <code><a href="#topic+cor_ma">cor_ma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor_arma(~ visit | patient, p = 2, q = 2)

</code></pre>

<hr>
<h2 id='cor_arr'>(Defunct) ARR correlation structure</h2><span id='topic+cor_arr'></span>

<h3>Description</h3>

<p>The ARR correlation structure is no longer supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_arr(formula = ~1, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_arr_+3A_formula">formula</code></td>
<td>
<p>A one sided formula of the form <code>~ t</code>, or <code>~ t | g</code>,
specifying a time covariate <code>t</code> and, optionally, a grouping factor
<code>g</code>. A covariate for this correlation structure must be integer
valued. When a grouping factor is present in <code>formula</code>, the
correlation structure is assumed to apply only to observations within the
same grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds to
using the order of the observations in the data as a covariate, and no
groups.</p>
</td></tr>
<tr><td><code id="cor_arr_+3A_r">r</code></td>
<td>
<p>No longer supported.</p>
</td></tr>
</table>

<hr>
<h2 id='cor_brms'>(Deprecated) Correlation structure classes for the <span class="pkg">brms</span> package</h2><span id='topic+cor_brms'></span><span id='topic+cor_brms-class'></span>

<h3>Description</h3>

<p>Classes of correlation structures available in the <span class="pkg">brms</span> package.
<code>cor_brms</code> is not a correlation structure itself,
but the class common to all correlation structures implemented in <span class="pkg">brms</span>.
</p>


<h3>Available correlation structures</h3>


<dl>
<dt>cor_arma</dt><dd><p>autoregressive-moving average (ARMA) structure,
with arbitrary orders for the autoregressive and moving
average components</p>
</dd>
<dt>cor_ar</dt><dd><p>autoregressive (AR) structure of arbitrary order</p>
</dd>
<dt>cor_ma</dt><dd><p>moving average (MA) structure of arbitrary order</p>
</dd>
<dt>cor_car</dt><dd><p>Spatial conditional autoregressive (CAR) structure</p>
</dd>
<dt>cor_sar</dt><dd><p>Spatial simultaneous autoregressive (SAR) structure</p>
</dd>
<dt>cor_fixed</dt><dd><p>fixed user-defined covariance structure</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+cor_arma">cor_arma</a>, <a href="#topic+cor_ar">cor_ar</a>, <a href="#topic+cor_ma">cor_ma</a>,
      <a href="#topic+cor_car">cor_car</a>, <a href="#topic+cor_sar">cor_sar</a>, <a href="#topic+cor_fixed">cor_fixed</a></code>
</p>

<hr>
<h2 id='cor_bsts'>(Defunct) Basic Bayesian Structural Time Series</h2><span id='topic+cor_bsts'></span>

<h3>Description</h3>

<p>The BSTS correlation structure is no longer supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_bsts(formula = ~1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_bsts_+3A_formula">formula</code></td>
<td>
<p>A one sided formula of the form <code>~ t</code>, or <code>~ t | g</code>,
specifying a time covariate <code>t</code> and, optionally, a grouping factor
<code>g</code>. A covariate for this correlation structure must be integer
valued. When a grouping factor is present in <code>formula</code>, the
correlation structure is assumed to apply only to observations within the
same grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds to
using the order of the observations in the data as a covariate, and no
groups.</p>
</td></tr>
</table>

<hr>
<h2 id='cor_car'>(Deprecated) Spatial conditional autoregressive (CAR) structures</h2><span id='topic+cor_car'></span><span id='topic+cor_icar'></span>

<h3>Description</h3>

<p>These function are deprecated. Please see <code><a href="#topic+car">car</a></code> for the new
syntax. These functions are constructors for the <code>cor_car</code> class
implementing spatial conditional autoregressive structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_car(W, formula = ~1, type = "escar")

cor_icar(W, formula = ~1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_car_+3A_w">W</code></td>
<td>
<p>Adjacency matrix of locations.
All non-zero entries are treated as if the two locations
are adjacent. If <code>formula</code> contains a grouping factor,
the row names of <code>W</code> have to match the levels
of the grouping factor.</p>
</td></tr>
<tr><td><code id="cor_car_+3A_formula">formula</code></td>
<td>
<p>An optional one-sided formula of the form
<code>~ 1 | g</code>, where <code>g</code> is a grouping factor mapping
observations to spatial locations. If not specified,
each observation is treated as a separate location.
It is recommended to always specify a grouping factor
to allow for handling of new data in post-processing methods.</p>
</td></tr>
<tr><td><code id="cor_car_+3A_type">type</code></td>
<td>
<p>Type of the CAR structure. Currently implemented
are <code>"escar"</code> (exact sparse CAR), <code>"esicar"</code>
(exact sparse intrinsic CAR), <code>"icar"</code> (intrinsic CAR),
and <code>"bym2"</code>. More information is provided in the 'Details' section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>escar</code> and <code>esicar</code> types are
implemented based on the case study of Max Joseph
(<a href="https://github.com/mbjoseph/CARstan">https://github.com/mbjoseph/CARstan</a>). The <code>icar</code> and
<code>bym2</code> type is implemented based on the case study of Mitzi Morris
(<a href="https://mc-stan.org/users/documentation/case-studies/icar_stan.html">https://mc-stan.org/users/documentation/case-studies/icar_stan.html</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate some spatial data
east &lt;- north &lt;- 1:10
Grid &lt;- expand.grid(east, north)
K &lt;- nrow(Grid)

# set up distance and neighbourhood matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;- array(0, c(K, K))
W[distance == 1] &lt;- 1

# generate the covariates and response data
x1 &lt;- rnorm(K)
x2 &lt;- rnorm(K)
theta &lt;- rnorm(K, sd = 0.05)
phi &lt;- rmulti_normal(
  1, mu = rep(0, K), Sigma = 0.4 * exp(-0.1 * distance)
)
eta &lt;- x1 + x2 + phi
prob &lt;- exp(eta) / (1 + exp(eta))
size &lt;- rep(50, K)
y &lt;- rbinom(n = K, size = size, prob = prob)
dat &lt;- data.frame(y, size, x1, x2)

# fit a CAR model
fit &lt;- brm(y | trials(size) ~ x1 + x2, data = dat,
           family = binomial(), autocor = cor_car(W))
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='cor_cosy'>(Deprecated) Compound Symmetry (COSY) Correlation Structure</h2><span id='topic+cor_cosy'></span><span id='topic+cor_cosy-class'></span>

<h3>Description</h3>

<p>This function is deprecated. Please see <code><a href="#topic+cosy">cosy</a></code> for the new syntax.
This functions is a constructor for the <code>cor_cosy</code> class, representing
a compound symmetry structure corresponding to uniform correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_cosy(formula = ~1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_cosy_+3A_formula">formula</code></td>
<td>
<p>A one sided formula of the form <code>~ t</code>, or <code>~ t | g</code>,
specifying a time covariate <code>t</code> and, optionally, a grouping factor
<code>g</code>. A covariate for this correlation structure must be integer
valued. When a grouping factor is present in <code>formula</code>, the
correlation structure is assumed to apply only to observations within the
same grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds to
using the order of the observations in the data as a covariate, and no
groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cor_cosy</code>, representing a compound symmetry
correlation structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor_cosy(~ visit | patient)

</code></pre>

<hr>
<h2 id='cor_fixed'>(Deprecated) Fixed user-defined covariance matrices</h2><span id='topic+cor_fixed'></span><span id='topic+cov_fixed'></span>

<h3>Description</h3>

<p>This function is deprecated. Please see <code><a href="#topic+fcor">fcor</a></code> for the new
syntax. Define a fixed covariance matrix of the response variable for
instance to model multivariate effect sizes in meta-analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_fixed(V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_fixed_+3A_v">V</code></td>
<td>
<p>Known covariance matrix of the response variable.
If a vector is passed, it will be used as diagonal entries
(variances) and covariances will be set to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cor_fixed</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- data.frame(y = rnorm(3))
V &lt;- cbind(c(0.5, 0.3, 0.2), c(0.3, 1, 0.1), c(0.2, 0.1, 0.2))
fit &lt;- brm(y~1, data = dat, autocor = cor_fixed(V))

## End(Not run)

</code></pre>

<hr>
<h2 id='cor_ma'>(Deprecated) MA(q) correlation structure</h2><span id='topic+cor_ma'></span>

<h3>Description</h3>

<p>This function is deprecated. Please see <code><a href="#topic+ma">ma</a></code> for the new syntax.
This function is a constructor for the <code>cor_arma</code> class,
allowing for moving average terms only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_ma(formula = ~1, q = 1, cov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_ma_+3A_formula">formula</code></td>
<td>
<p>A one sided formula of the form <code>~ t</code>, or <code>~ t | g</code>,
specifying a time covariate <code>t</code> and, optionally, a grouping factor
<code>g</code>. A covariate for this correlation structure must be integer
valued. When a grouping factor is present in <code>formula</code>, the
correlation structure is assumed to apply only to observations within the
same grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds to
using the order of the observations in the data as a covariate, and no
groups.</p>
</td></tr>
<tr><td><code id="cor_ma_+3A_q">q</code></td>
<td>
<p>A non-negative integer specifying the moving average (MA)
order of the ARMA structure. Default is 1.</p>
</td></tr>
<tr><td><code id="cor_ma_+3A_cov">cov</code></td>
<td>
<p>A flag indicating whether ARMA effects should be estimated by
means of residual covariance matrices. This is currently only possible for
stationary ARMA effects of order 1. If the model family does not have
natural residuals, latent residuals are added automatically. If
<code>FALSE</code> (the default) a regression formulation is used that is
considerably faster and allows for ARMA effects of order higher than 1 but
is only available for <code>gaussian</code> models and some of its
generalizations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cor_arma</code> containing solely moving
average terms.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_arma">cor_arma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor_ma(~visit|patient, q = 2)

</code></pre>

<hr>
<h2 id='cor_sar'>(Deprecated) Spatial simultaneous autoregressive (SAR) structures</h2><span id='topic+cor_sar'></span><span id='topic+cor_lagsar'></span><span id='topic+cor_errorsar'></span>

<h3>Description</h3>

<p>Thse functions are deprecated. Please see <code><a href="#topic+sar">sar</a></code> for the new
syntax. These functions are constructors for the <code>cor_sar</code> class
implementing spatial simultaneous autoregressive structures.
The <code>lagsar</code> structure implements SAR of the response values:
</p>
<p style="text-align: center;"><code class="reqn">y = \rho W y + \eta + e</code>
</p>

<p>The <code>errorsar</code> structure implements SAR of the residuals:
</p>
<p style="text-align: center;"><code class="reqn">y = \eta + u, u = \rho W u + e</code>
</p>

<p>In the above equations, <code class="reqn">\eta</code> is the predictor term and
<code class="reqn">e</code> are independent normally or t-distributed residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_sar(W, type = c("lag", "error"))

cor_lagsar(W)

cor_errorsar(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_sar_+3A_w">W</code></td>
<td>
<p>An object specifying the spatial weighting matrix.
Can be either the spatial weight matrix itself or an
object of class <code>listw</code> or <code>nb</code>, from which
the spatial weighting matrix can be computed.</p>
</td></tr>
<tr><td><code id="cor_sar_+3A_type">type</code></td>
<td>
<p>Type of the SAR structure. Either <code>"lag"</code>
(for SAR of the response values) or <code>"error"</code>
(for SAR of the residuals).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only families <code>gaussian</code> and <code>student</code>
support SAR structures.
</p>


<h3>Value</h3>

<p>An object of class <code>cor_sar</code> to be used in calls to
<code><a href="#topic+brm">brm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(oldcol, package = "spdep")
fit1 &lt;- brm(CRIME ~ INC + HOVAL, data = COL.OLD,
            autocor = cor_lagsar(COL.nb),
            chains = 2, cores = 2)
summary(fit1)
plot(fit1)

fit2 &lt;- brm(CRIME ~ INC + HOVAL, data = COL.OLD,
            autocor = cor_errorsar(COL.nb),
            chains = 2, cores = 2)
summary(fit2)
plot(fit2)

## End(Not run)

</code></pre>

<hr>
<h2 id='cosy'>Set up COSY correlation structures</h2><span id='topic+cosy'></span>

<h3>Description</h3>

<p>Set up a compounds symmetry (COSY) term in <span class="pkg">brms</span>. The function does
not evaluate its arguments &ndash; it exists purely to help set up a model with
COSY terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosy(time = NA, gr = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosy_+3A_time">time</code></td>
<td>
<p>An optional time variable specifying the time ordering
of the observations. By default, the existing order of the observations
in the data is used.</p>
</td></tr>
<tr><td><code id="cosy_+3A_gr">gr</code></td>
<td>
<p>An optional grouping variable. If specified, the correlation
structure is assumed to apply only to observations within the same grouping
level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>'cosy_term'</code>, which is a list
of arguments to be interpreted by the formula
parsing functions of <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocor-terms">autocor-terms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("lh")
lh &lt;- as.data.frame(lh)
fit &lt;- brm(x ~ cosy(), data = lh)
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='cs'>Category Specific Predictors in <span class="pkg">brms</span> Models</h2><span id='topic+cs'></span><span id='topic+cse'></span>

<h3>Description</h3>

<p>Category Specific Predictors in <span class="pkg">brms</span> Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cs(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cs_+3A_expr">expr</code></td>
<td>
<p>Expression containing predictors,
for which category specific effects should be estimated.
For evaluation, <span class="rlang"><b>R</b></span> formula syntax is applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For detailed documentation see <code>help(brmsformula)</code>
as well as <code>vignette("brms_overview")</code>.
</p>
<p>This function is almost solely useful when
called in formulas passed to the <span class="pkg">brms</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(rating ~ period + carry + cs(treat),
           data = inhaler, family = sratio("cloglog"),
           prior = set_prior("normal(0,5)"), chains = 2)
summary(fit)
plot(fit, ask = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='custom_family'>Custom Families in <span class="pkg">brms</span> Models</h2><span id='topic+custom_family'></span><span id='topic+customfamily'></span>

<h3>Description</h3>

<p>Define custom families (i.e. response distribution) for use in
<span class="pkg">brms</span> models. It allows users to benefit from the modeling
flexibility of <span class="pkg">brms</span>, while applying their self-defined likelihood
functions. All of the post-processing methods for <code>brmsfit</code>
objects can be made compatible with custom families.
See <code>vignette("brms_customfamilies")</code> for more details.
For a list of built-in families see <code><a href="#topic+brmsfamily">brmsfamily</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_family(
  name,
  dpars = "mu",
  links = "identity",
  type = c("real", "int"),
  lb = NA,
  ub = NA,
  vars = NULL,
  loop = TRUE,
  specials = NULL,
  threshold = "flexible",
  log_lik = NULL,
  posterior_predict = NULL,
  posterior_epred = NULL,
  predict = NULL,
  fitted = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_family_+3A_name">name</code></td>
<td>
<p>Name of the custom family.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_dpars">dpars</code></td>
<td>
<p>Names of the distributional parameters of
the family. One parameter must be named <code>"mu"</code> and
the main formula of the model will correspond to that
parameter.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_links">links</code></td>
<td>
<p>Names of the link functions of the
distributional parameters.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_type">type</code></td>
<td>
<p>Indicates if the response distribution is
continuous (<code>"real"</code>) or discrete (<code>"int"</code>). This controls
if the corresponding density function will be named with
<code>&lt;name&gt;_lpdf</code> or <code>&lt;name&gt;_lpmf</code>.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_lb">lb</code></td>
<td>
<p>Vector of lower bounds of the distributional
parameters. Defaults to <code>NA</code> that is no lower bound.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_ub">ub</code></td>
<td>
<p>Vector of upper bounds of the distributional
parameters. Defaults to <code>NA</code> that is no upper bound.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_vars">vars</code></td>
<td>
<p>Names of variables that are part of the likelihood function
without being distributional parameters. That is, <code>vars</code> can be used
to pass data to the likelihood. Such arguments will be added to the list of
function arguments at the end, after the distributional parameters. See
<code><a href="#topic+stanvar">stanvar</a></code> for details about adding self-defined data to the
generated <span class="pkg">Stan</span> model. Addition arguments <code>vreal</code> and <code>vint</code>
may be used for this purpose as well (see Examples below). See also
<code><a href="#topic+brmsformula">brmsformula</a></code> and <code><a href="#topic+addition-terms">addition-terms</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_loop">loop</code></td>
<td>
<p>Logical; Should the likelihood be evaluated via a loop
(<code>TRUE</code>; the default) over observations in Stan?
If <code>FALSE</code>, the Stan code will be written in a vectorized
manner over observations if possible.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_specials">specials</code></td>
<td>
<p>A character vector of special options to enable
for this custom family. Currently for internal use only.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_threshold">threshold</code></td>
<td>
<p>Optional threshold type for custom ordinal families.
Ignored for non-ordinal families.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_log_lik">log_lik</code></td>
<td>
<p>Optional function to compute log-likelihood values of
the model in <span class="rlang"><b>R</b></span>. This is only relevant if one wants to ensure
compatibility with method <code><a href="#topic+log_lik.brmsfit">log_lik</a></code>.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_posterior_predict">posterior_predict</code></td>
<td>
<p>Optional function to compute posterior prediction of
the model in <span class="rlang"><b>R</b></span>. This is only relevant if one wants to ensure compatibility
with method <code><a href="#topic+posterior_predict.brmsfit">posterior_predict</a></code>.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_posterior_epred">posterior_epred</code></td>
<td>
<p>Optional function to compute expected values of the
posterior predictive distribution of the model in <span class="rlang"><b>R</b></span>. This is only relevant
if one wants to ensure compatibility with method
<code><a href="#topic+posterior_epred.brmsfit">posterior_epred</a></code>.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_predict">predict</code></td>
<td>
<p>Deprecated alias of 'posterior_predict'.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_fitted">fitted</code></td>
<td>
<p>Deprecated alias of 'posterior_epred'.</p>
</td></tr>
<tr><td><code id="custom_family_+3A_env">env</code></td>
<td>
<p>An <code><a href="base.html#topic+environment">environment</a></code> in which certain post-processing
functions related to the custom family can be found, if there were not
directly passed to <code>custom_family</code>. This is only
relevant if one wants to ensure compatibility with the methods
<code><a href="#topic+log_lik.brmsfit">log_lik</a></code>,
<code><a href="#topic+posterior_predict.brmsfit">posterior_predict</a></code>, or
<code><a href="#topic+posterior_epred.brmsfit">posterior_epred</a></code>.
By default, <code>env</code> is the environment from which
<code>custom_family</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The corresponding probability density or mass <code>Stan</code>
functions need to have the same name as the custom family.
That is if a family is called <code>myfamily</code>, then the
<span class="pkg">Stan</span> functions should be called <code>myfamily_lpdf</code> or
<code>myfamily_lpmf</code> depending on whether it defines a
continuous or discrete distribution.
</p>


<h3>Value</h3>

<p>An object of class <code>customfamily</code> inheriting
from class <code><a href="#topic+brmsfamily">brmsfamily</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsfamily">brmsfamily</a></code>, <code><a href="#topic+brmsformula">brmsformula</a></code>,
<code><a href="#topic+stanvar">stanvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## demonstrate how to fit a beta-binomial model
## generate some fake data
phi &lt;- 0.7
n &lt;- 300
z &lt;- rnorm(n, sd = 0.2)
ntrials &lt;- sample(1:10, n, replace = TRUE)
eta &lt;- 1 + z
mu &lt;- exp(eta) / (1 + exp(eta))
a &lt;- mu * phi
b &lt;- (1 - mu) * phi
p &lt;- rbeta(n, a, b)
y &lt;- rbinom(n, ntrials, p)
dat &lt;- data.frame(y, z, ntrials)

# define a custom family
beta_binomial2 &lt;- custom_family(
  "beta_binomial2", dpars = c("mu", "phi"),
  links = c("logit", "log"), lb = c(NA, 0),
  type = "int", vars = "vint1[n]"
)

# define the corresponding Stan density function
stan_density &lt;- "
  real beta_binomial2_lpmf(int y, real mu, real phi, int N) {
    return beta_binomial_lpmf(y | N, mu * phi, (1 - mu) * phi);
  }
"
stanvars &lt;- stanvar(scode = stan_density, block = "functions")

# fit the model
fit &lt;- brm(y | vint(ntrials) ~ z, data = dat,
           family = beta_binomial2, stanvars = stanvars)
summary(fit)


# define a *vectorized* custom family (no loop over observations)
# notice also that 'vint' no longer has an observation index
beta_binomial2_vec &lt;- custom_family(
  "beta_binomial2", dpars = c("mu", "phi"),
  links = c("logit", "log"), lb = c(NA, 0),
  type = "int", vars = "vint1", loop = FALSE
)

# define the corresponding Stan density function
stan_density_vec &lt;- "
  real beta_binomial2_lpmf(array[] int y, vector mu, real phi, array[] int N) {
    return beta_binomial_lpmf(y | N, mu * phi, (1 - mu) * phi);
  }
"
stanvars_vec &lt;- stanvar(scode = stan_density_vec, block = "functions")

# fit the model
fit_vec &lt;- brm(y | vint(ntrials) ~ z, data = dat,
           family = beta_binomial2_vec,
           stanvars = stanvars_vec)
summary(fit_vec)

## End(Not run)

</code></pre>

<hr>
<h2 id='data_predictor'>Prepare Predictor Data</h2><span id='topic+data_predictor'></span>

<h3>Description</h3>

<p>Prepare data related to predictor variables in <span class="pkg">brms</span>.
Only exported for use in package development.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_predictor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_predictor_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="data_predictor_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of data related to predictor variables.
</p>

<hr>
<h2 id='data_response'>Prepare Response Data</h2><span id='topic+data_response'></span>

<h3>Description</h3>

<p>Prepare data related to response variables in <span class="pkg">brms</span>.
Only exported for use in package development.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_response(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_response_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="data_response_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of data related to response variables.
</p>

<hr>
<h2 id='default_prior'>Default priors for Bayesian models</h2><span id='topic+default_prior'></span><span id='topic+get_prior'></span>

<h3>Description</h3>

<p><code>default_prior</code> is a generic function that can be used to
get default priors for Bayesian models. Its original use is
within the <span class="pkg">brms</span> package, but new methods for use
with objects from other packages can be registered to the same generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_prior(object, ...)

get_prior(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_prior_+3A_object">object</code></td>
<td>
<p>An object whose class will determine which method will
be used. A symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="default_prior_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the specific method.</p>
</td></tr>
<tr><td><code id="default_prior_+3A_formula">formula</code></td>
<td>
<p>Synonym of <code>object</code> for use in <code>get_prior</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+default_prior.default">default_prior.default</a></code> for the default method applied for
<span class="pkg">brms</span> models. You can view the available methods by typing
<code>methods(default_prior)</code>.
</p>


<h3>Value</h3>

<p>Usually, a <code>brmsprior</code> object. See
<code><a href="#topic+default_prior.default">default_prior.default</a></code> for more details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code>, <code><a href="#topic+default_prior.default">default_prior.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get all parameters and parameters classes to define priors on
(prior &lt;- default_prior(count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
                        data = epilepsy, family = poisson()))

</code></pre>

<hr>
<h2 id='default_prior.default'>Default Priors for <span class="pkg">brms</span> Models</h2><span id='topic+default_prior.default'></span>

<h3>Description</h3>

<p>Get information on all parameters (and parameter classes) for which priors
may be specified including default priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
default_prior(
  object,
  data,
  family = gaussian(),
  autocor = NULL,
  data2 = NULL,
  knots = NULL,
  drop_unused_levels = TRUE,
  sparse = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_prior.default_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>, or <code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code> (or one that can
be coerced to that classes): A symbolic description of the model to be
fitted. The details of model specification are explained in
<code><a href="#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="default_prior.default_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced
to that class) containing data of all variables used in the model.</p>
</td></tr>
<tr><td><code id="default_prior.default_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and link function to
be used in the model. This can be a family function, a call to a family
function or a character string naming the family. Every family function has
a <code>link</code> argument allowing to specify the link function to be applied
on the response variable. If not specified, default links are used. For
details of supported families see <code><a href="#topic+brmsfamily">brmsfamily</a></code>. By default, a
linear <code>gaussian</code> model is applied. In multivariate models,
<code>family</code> might also be a list of families.</p>
</td></tr>
<tr><td><code id="default_prior.default_+3A_autocor">autocor</code></td>
<td>
<p>(Deprecated) An optional <code><a href="#topic+cor_brms">cor_brms</a></code> object
describing the correlation structure within the response variable (i.e.,
the 'autocorrelation'). See the documentation of <code><a href="#topic+cor_brms">cor_brms</a></code> for
a description of the available correlation structures. Defaults to
<code>NULL</code>, corresponding to no correlations. In multivariate models,
<code>autocor</code> might also be a list of autocorrelation structures.
It is now recommend to specify autocorrelation terms directly
within <code>formula</code>. See <code><a href="#topic+brmsformula">brmsformula</a></code> for more details.</p>
</td></tr>
<tr><td><code id="default_prior.default_+3A_data2">data2</code></td>
<td>
<p>A named <code>list</code> of objects containing data, which
cannot be passed via argument <code>data</code>. Required for some objects
used in autocorrelation structures to specify dependency structures
as well as for within-group covariance matrices.</p>
</td></tr>
<tr><td><code id="default_prior.default_+3A_knots">knots</code></td>
<td>
<p>Optional list containing user specified knot values to be used
for basis construction of smoothing terms. See
<code><a href="mgcv.html#topic+gamm">gamm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="default_prior.default_+3A_drop_unused_levels">drop_unused_levels</code></td>
<td>
<p>Should unused factors levels in the data be
dropped? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="default_prior.default_+3A_sparse">sparse</code></td>
<td>
<p>(Deprecated) Logical; indicates whether the population-level
design matrices should be treated as sparse (defaults to <code>FALSE</code>). For
design matrices with many zeros, this can considerably reduce required
memory. Sampling speed is currently not improved or even slightly
decreased. It is now recommended to use the <code>sparse</code> argument of
<code><a href="#topic+brmsformula">brmsformula</a></code> and related functions.</p>
</td></tr>
<tr><td><code id="default_prior.default_+3A_...">...</code></td>
<td>
<p>Other arguments for internal usage only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>brmsprior</code> object. That is, a data.frame with specific
columns including <code>prior</code>, <code>class</code>, <code>coef</code>, and <code>group</code>
and several rows, each providing information on a parameter (or parameter
class) on which priors can be specified. The prior column is empty except
for internal default priors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+default_prior">default_prior</a></code>, <code><a href="#topic+set_prior">set_prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get all parameters and parameters classes to define priors on
(prior &lt;- default_prior(count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
                        data = epilepsy, family = poisson()))

# define a prior on all population-level effects a once
prior$prior[1] &lt;- "normal(0,10)"

# define a specific prior on the population-level effect of Trt
prior$prior[5] &lt;- "student_t(10, 0, 5)"

# verify that the priors indeed found their way into Stan's model code
stancode(count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
         data = epilepsy, family = poisson(),
         prior = prior)

</code></pre>

<hr>
<h2 id='density_ratio'>Compute Density Ratios</h2><span id='topic+density_ratio'></span>

<h3>Description</h3>

<p>Compute the ratio of two densities at given points based on draws of the
corresponding distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_ratio(x, y = NULL, point = 0, n = 4096, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_ratio_+3A_x">x</code></td>
<td>
<p>Vector of draws from the first distribution, usually the posterior
distribution of the quantity of interest.</p>
</td></tr>
<tr><td><code id="density_ratio_+3A_y">y</code></td>
<td>
<p>Optional vector of draws from the second distribution, usually the
prior distribution of the quantity of interest. If <code>NULL</code> (the
default), only the density of <code>x</code> will be evaluated.</p>
</td></tr>
<tr><td><code id="density_ratio_+3A_point">point</code></td>
<td>
<p>Numeric values at which to evaluate and compare the densities.
Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="density_ratio_+3A_n">n</code></td>
<td>
<p>Single numeric value. Influences the accuracy of the density
estimation. See <code><a href="stats.html#topic+density">density</a></code> for details.</p>
</td></tr>
<tr><td><code id="density_ratio_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to achieve sufficient accuracy in the density estimation,
more draws than usual are required. That is you may need an effective
sample size of 10,000 or more to reliably estimate the densities.
</p>


<h3>Value</h3>

<p>A vector of length equal to <code>length(point)</code>. If <code>y</code> is
provided, the density ratio of <code>x</code> against <code>y</code> is returned. Else,
only the density of <code>x</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(10000)
y &lt;- rnorm(10000, mean = 1)
density_ratio(x, y, point = c(0, 1))

</code></pre>

<hr>
<h2 id='diagnostic-quantities'>Extract Diagnostic Quantities of <span class="pkg">brms</span> Models</h2><span id='topic+diagnostic-quantities'></span><span id='topic+log_posterior'></span><span id='topic+nuts_params'></span><span id='topic+rhat'></span><span id='topic+neff_ratio'></span><span id='topic+log_posterior.brmsfit'></span><span id='topic+nuts_params.brmsfit'></span><span id='topic+rhat.brmsfit'></span><span id='topic+neff_ratio.brmsfit'></span>

<h3>Description</h3>

<p>Extract quantities that can be used to diagnose sampling behavior
of the algorithms applied by <span class="pkg">Stan</span> at the back-end of <span class="pkg">brms</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
log_posterior(object, ...)

## S3 method for class 'brmsfit'
nuts_params(object, pars = NULL, ...)

## S3 method for class 'brmsfit'
rhat(x, pars = NULL, ...)

## S3 method for class 'brmsfit'
neff_ratio(object, pars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic-quantities_+3A_object">object</code>, <code id="diagnostic-quantities_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="diagnostic-quantities_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods.</p>
</td></tr>
<tr><td><code id="diagnostic-quantities_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names.
For <code>nuts_params</code> these will be NUTS sampler parameter
names rather than model parameters. If pars is omitted
all parameters are included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see
<code><a href="bayesplot.html#topic+bayesplot-extractors">bayesplot-extractors</a></code>.
</p>


<h3>Value</h3>

<p>The exact form of the output depends on the method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(time ~ age * sex, data = kidney)

lp &lt;- log_posterior(fit)
head(lp)

np &lt;- nuts_params(fit)
str(np)
# extract the number of divergence transitions
sum(subset(np, Parameter == "divergent__")$Value)

head(rhat(fit))
head(neff_ratio(fit))

## End(Not run)
</code></pre>

<hr>
<h2 id='Dirichlet'>The Dirichlet Distribution</h2><span id='topic+Dirichlet'></span><span id='topic+ddirichlet'></span><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Density function and random number generation for the dirichlet
distribution with shape parameter vector <code>alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichlet(x, alpha, log = FALSE)

rdirichlet(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dirichlet_+3A_x">x</code></td>
<td>
<p>Matrix of quantiles. Each row corresponds to one probability vector.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>Matrix of positive shape parameters. Each row corresponds to one
probability vector.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details on the
parameterization.
</p>

<hr>
<h2 id='do_call'>Execute a Function Call</h2><span id='topic+do_call'></span>

<h3>Description</h3>

<p>Execute a function call similar to <code><a href="base.html#topic+do.call">do.call</a></code>, but without
deparsing function arguments. For large number of arguments (i.e., more
than a few thousand) this function currently is somewhat inefficient
and should be used with care in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_call(what, args, pkg = NULL, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_call_+3A_what">what</code></td>
<td>
<p>Either a function or a non-empty character string naming the
function to be called.</p>
</td></tr>
<tr><td><code id="do_call_+3A_args">args</code></td>
<td>
<p>A list of arguments to the function call. The names attribute of
<code>args</code> gives the argument names.</p>
</td></tr>
<tr><td><code id="do_call_+3A_pkg">pkg</code></td>
<td>
<p>Optional name of the package in which to search for the
function if <code>what</code> is a character string.</p>
</td></tr>
<tr><td><code id="do_call_+3A_envir">envir</code></td>
<td>
<p>An environment within which to evaluate the call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the (evaluated) function call.
</p>

<hr>
<h2 id='draws-brms'>Transform <code>brmsfit</code> to <code>draws</code> objects</h2><span id='topic+draws-brms'></span><span id='topic+as_draws'></span><span id='topic+as_draws_matrix'></span><span id='topic+as_draws_array'></span><span id='topic+as_draws_df'></span><span id='topic+as_draws_rvars'></span><span id='topic+as_draws_list'></span><span id='topic+as_draws.brmsfit'></span><span id='topic+as_draws_matrix.brmsfit'></span><span id='topic+as_draws_array.brmsfit'></span><span id='topic+as_draws_df.brmsfit'></span><span id='topic+as_draws_list.brmsfit'></span><span id='topic+as_draws_rvars.brmsfit'></span>

<h3>Description</h3>

<p>Transform a <code>brmsfit</code> object to a format supported by the
<span class="pkg">posterior</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
as_draws(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'brmsfit'
as_draws_matrix(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'brmsfit'
as_draws_array(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'brmsfit'
as_draws_df(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'brmsfit'
as_draws_list(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)

## S3 method for class 'brmsfit'
as_draws_rvars(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws-brms_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object or another <span class="rlang"><b>R</b></span> object for which
the methods are defined.</p>
</td></tr>
<tr><td><code id="draws-brms_+3A_variable">variable</code></td>
<td>
<p>A character vector providing the variables to extract.
By default, all variables are extracted.</p>
</td></tr>
<tr><td><code id="draws-brms_+3A_regex">regex</code></td>
<td>
<p>Logical; Should variable should be treated as a (vector of)
regular expressions? Any variable in <code>x</code> matching at least one of the
regular expressions will be selected. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="draws-brms_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>Should warmup draws be included? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="draws-brms_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To subset iterations, chains, or draws, use the
<code><a href="posterior.html#topic+subset_draws">subset_draws</a></code> method after
transforming the <code>brmsfit</code> to a <code>draws</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="posterior.html#topic+draws">draws</a></code>
<code><a href="posterior.html#topic+subset_draws">subset_draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zAge + zBase * Trt + (1|patient),
           data = epilepsy, family = poisson())

# extract posterior draws in an array format
(draws_fit &lt;- as_draws_array(fit))
posterior::summarize_draws(draws_fit)

# extract only certain variables
as_draws_array(fit, variable = "r_patient")
as_draws_array(fit, variable = "^b_", regex = TRUE)

# extract posterior draws in a random variables format
as_draws_rvars(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='draws-index-brms'>Index <code>brmsfit</code> objects</h2><span id='topic+draws-index-brms'></span><span id='topic+variables'></span><span id='topic+nvariables'></span><span id='topic+niterations'></span><span id='topic+nchains'></span><span id='topic+ndraws'></span><span id='topic+Index'></span><span id='topic+variables+2C'></span><span id='topic+iterations+2C'></span><span id='topic+chains+2C'></span><span id='topic+and'></span><span id='topic+draws.'></span><span id='topic+variables.brmsfit'></span><span id='topic+nvariables.brmsfit'></span><span id='topic+niterations.brmsfit'></span><span id='topic+nchains.brmsfit'></span><span id='topic+ndraws.brmsfit'></span>

<h3>Description</h3>

<p>Index <code>brmsfit</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
variables(x, ...)

## S3 method for class 'brmsfit'
nvariables(x, ...)

## S3 method for class 'brmsfit'
niterations(x)

## S3 method for class 'brmsfit'
nchains(x)

## S3 method for class 'brmsfit'
ndraws(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws-index-brms_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object or another <span class="rlang"><b>R</b></span> object for which
the methods are defined.</p>
</td></tr>
<tr><td><code id="draws-index-brms_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>

<hr>
<h2 id='emmeans-brms-helpers'>Support Functions for <span class="pkg">emmeans</span></h2><span id='topic+emmeans-brms-helpers'></span><span id='topic+recover_data.brmsfit'></span><span id='topic+emm_basis.brmsfit'></span>

<h3>Description</h3>

<p>Functions required for compatibility of <span class="pkg">brms</span> with <span class="pkg">emmeans</span>.
Users are not required to call these functions themselves. Instead,
they will be called automatically by the <code>emmeans</code> function
of the <span class="pkg">emmeans</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recover_data.brmsfit(
  object,
  data,
  resp = NULL,
  dpar = NULL,
  nlpar = NULL,
  re_formula = NA,
  epred = FALSE,
  ...
)

emm_basis.brmsfit(
  object,
  trms,
  xlev,
  grid,
  vcov.,
  resp = NULL,
  dpar = NULL,
  nlpar = NULL,
  re_formula = NA,
  epred = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emmeans-brms-helpers_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="emmeans-brms-helpers_+3A_data">data</code>, <code id="emmeans-brms-helpers_+3A_trms">trms</code>, <code id="emmeans-brms-helpers_+3A_xlev">xlev</code>, <code id="emmeans-brms-helpers_+3A_grid">grid</code>, <code id="emmeans-brms-helpers_+3A_vcov.">vcov.</code></td>
<td>
<p>Arguments required by <span class="pkg">emmeans</span>.</p>
</td></tr>
<tr><td><code id="emmeans-brms-helpers_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="emmeans-brms-helpers_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="emmeans-brms-helpers_+3A_nlpar">nlpar</code></td>
<td>
<p>Optional name of a predicted non-linear parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="emmeans-brms-helpers_+3A_re_formula">re_formula</code></td>
<td>
<p>Optional formula containing group-level effects to be
considered in the prediction. If <code>NULL</code>, include all group-level
effects; if <code>NA</code> (default), include no group-level effects.</p>
</td></tr>
<tr><td><code id="emmeans-brms-helpers_+3A_epred">epred</code></td>
<td>
<p>Logical. If <code>TRUE</code> compute predictions of
the posterior predictive distribution's mean
(see <code><a href="#topic+posterior_epred.brmsfit">posterior_epred.brmsfit</a></code>) while ignoring
arguments <code>dpar</code> and <code>nlpar</code>. Defaults to <code>FALSE</code>.
If you have specified a response transformation within the formula,
you need to set <code>epred</code> to <code>TRUE</code> for <span class="pkg">emmeans</span> to
detect this transformation.</p>
</td></tr>
<tr><td><code id="emmeans-brms-helpers_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <span class="pkg">emmeans</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to ensure compatibility of most <span class="pkg">brms</span> models with
<span class="pkg">emmeans</span>, predictions are not generated 'manually' via a design matrix
and coefficient vector, but rather via <code><a href="#topic+posterior_linpred.brmsfit">posterior_linpred.brmsfit</a></code>.
This appears to generally work well, but note that it produces an '.@linfct'
slot that contains the computed predictions as columns instead of the
coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit1 &lt;- brm(time | cens(censored) ~ age * sex + disease + (1|patient),
            data = kidney, family = lognormal())
summary(fit1)

# summarize via 'emmeans'
library(emmeans)
rg &lt;- ref_grid(fit1)
em &lt;- emmeans(rg, "disease")
summary(em, point.est = mean)

# obtain estimates for the posterior predictive distribution's mean
epred &lt;- emmeans(fit1, "disease", epred = TRUE)
summary(epred, point.est = mean)


# model with transformed response variable
fit2 &lt;- brm(log(mpg) ~ factor(cyl), data = mtcars)
summary(fit2)

# results will be on the log scale by default
emmeans(fit2, ~ cyl)
# log transform is detected and can be adjusted automatically
emmeans(fit2, ~ cyl, epred = TRUE, type = "response")

## End(Not run)
</code></pre>

<hr>
<h2 id='epilepsy'>Epileptic seizure counts</h2><span id='topic+epilepsy'></span>

<h3>Description</h3>

<p>Breslow and Clayton (1993) analyze data initially
provided by Thall and Vail (1990) concerning
seizure counts in a randomized trial of anti-convulsant
therapy in epilepsy. Covariates are treatment,
8-week baseline seizure counts, and age of the patients in years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epilepsy
</code></pre>


<h3>Format</h3>

<p>A data frame of 236 observations containing information
on the following 9 variables.
</p>

<dl>
<dt>Age</dt><dd><p>The age of the patients in years</p>
</dd>
<dt>Base</dt><dd><p>The seizure count at 8-weeks baseline</p>
</dd>
<dt>Trt</dt><dd><p>Either <code>0</code> or <code>1</code> indicating
if the patient received anti-convulsant therapy</p>
</dd>
<dt>patient</dt><dd><p>The patient number</p>
</dd>
<dt>visit</dt><dd><p>The session number from <code>1</code> (first visit)
to <code>4</code> (last visit)</p>
</dd>
<dt>count</dt><dd><p>The seizure count between two visits</p>
</dd>
<dt>obs</dt><dd><p>The observation number, that is
a unique identifier for each observation</p>
</dd>
<dt>zAge</dt><dd><p>Standardized <code>Age</code></p>
</dd>
<dt>zBase</dt><dd><p>Standardized <code>Base</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Thall, P. F., &amp; Vail, S. C. (1990).
Some covariance models for longitudinal count data with overdispersion.
<em>Biometrics, 46(2)</em>, 657-671. <br />
</p>
<p>Breslow, N. E., &amp; Clayton, D. G. (1993).
Approximate inference in generalized linear mixed models.
<em>Journal of the American Statistical Association</em>, 88(421), 9-25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## poisson regression without random effects.
fit1 &lt;- brm(count ~ zAge + zBase * Trt,
            data = epilepsy, family = poisson())
summary(fit1)
plot(fit1)

## poisson regression with varying intercepts of patients
## as well as normal priors for overall effects parameters.
fit2 &lt;- brm(count ~ zAge + zBase * Trt + (1|patient),
            data = epilepsy, family = poisson(),
            prior = set_prior("normal(0,5)"))
summary(fit2)
plot(fit2)

## End(Not run)

</code></pre>

<hr>
<h2 id='ExGaussian'>The Exponentially Modified Gaussian Distribution</h2><span id='topic+ExGaussian'></span><span id='topic+dexgaussian'></span><span id='topic+pexgaussian'></span><span id='topic+rexgaussian'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation
for the exponentially modified Gaussian distribution with
mean <code>mu</code> and standard deviation <code>sigma</code> of the gaussian
component, as well as scale <code>beta</code> of the exponential
component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexgaussian(x, mu, sigma, beta, log = FALSE)

pexgaussian(q, mu, sigma, beta, lower.tail = TRUE, log.p = FALSE)

rexgaussian(n, mu, sigma, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExGaussian_+3A_x">x</code>, <code id="ExGaussian_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="ExGaussian_+3A_mu">mu</code></td>
<td>
<p>Vector of means of the combined distribution.</p>
</td></tr>
<tr><td><code id="ExGaussian_+3A_sigma">sigma</code></td>
<td>
<p>Vector of standard deviations of the gaussian component.</p>
</td></tr>
<tr><td><code id="ExGaussian_+3A_beta">beta</code></td>
<td>
<p>Vector of scales of the exponential component.</p>
</td></tr>
<tr><td><code id="ExGaussian_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="ExGaussian_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="ExGaussian_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="ExGaussian_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details
on the parameterization.
</p>

<hr>
<h2 id='expose_functions.brmsfit'>Expose user-defined <span class="pkg">Stan</span> functions</h2><span id='topic+expose_functions.brmsfit'></span><span id='topic+expose_functions'></span>

<h3>Description</h3>

<p>Export user-defined <span class="pkg">Stan</span> function and
optionally vectorize them. For more details see
<code><a href="rstan.html#topic+expose_stan_functions">expose_stan_functions</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
expose_functions(x, vectorize = FALSE, env = globalenv(), ...)

expose_functions(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expose_functions.brmsfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="expose_functions.brmsfit_+3A_vectorize">vectorize</code></td>
<td>
<p>Logical; Indicates if the exposed functions
should be vectorized via <code><a href="base.html#topic+Vectorize">Vectorize</a></code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="expose_functions.brmsfit_+3A_env">env</code></td>
<td>
<p>Environment where the functions should be made
available. Defaults to the global environment.</p>
</td></tr>
<tr><td><code id="expose_functions.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="rstan.html#topic+expose_stan_functions">expose_stan_functions</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='expp1'>Exponential function plus one.</h2><span id='topic+expp1'></span>

<h3>Description</h3>

<p>Computes <code>exp(x) + 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expp1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expp1_+3A_x">x</code></td>
<td>
<p>A numeric or complex vector.</p>
</td></tr>
</table>

<hr>
<h2 id='family.brmsfit'>Extract Model Family Objects</h2><span id='topic+family.brmsfit'></span>

<h3>Description</h3>

<p>Extract Model Family Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
family(object, resp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="family.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="family.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>brmsfamily</code> object
or a list of such objects for multivariate models.
</p>

<hr>
<h2 id='fcor'>Fixed residual correlation (FCOR) structures</h2><span id='topic+fcor'></span>

<h3>Description</h3>

<p>Set up a fixed residual correlation (FCOR) term in <span class="pkg">brms</span>. The function
does not evaluate its arguments &ndash; it exists purely to help set up a model
with FCOR terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcor(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcor_+3A_m">M</code></td>
<td>
<p>Known correlation/covariance matrix of the response variable.
If a vector is passed, it will be used as diagonal entries
(variances) and correlations/covariances will be set to zero.
The actual covariance matrix used in the likelihood is obtained
by multiplying <code>M</code> by the square of the residual standard
deviation parameter <code>sigma</code> estimated as part of the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>'fcor_term'</code>, which is a list
of arguments to be interpreted by the formula
parsing functions of <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocor-terms">autocor-terms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- data.frame(y = rnorm(3))
V &lt;- cbind(c(0.5, 0.3, 0.2), c(0.3, 1, 0.1), c(0.2, 0.1, 0.2))
fit &lt;- brm(y ~ 1 + fcor(V), data = dat, data2 = list(V = V))

## End(Not run)

</code></pre>

<hr>
<h2 id='fitted.brmsfit'>Expected Values of the Posterior Predictive Distribution</h2><span id='topic+fitted.brmsfit'></span>

<h3>Description</h3>

<p>This method is an alias of <code><a href="#topic+posterior_epred.brmsfit">posterior_epred.brmsfit</a></code>
with additional arguments for obtaining summaries of the computed draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
fitted(
  object,
  newdata = NULL,
  re_formula = NULL,
  scale = c("response", "linear"),
  resp = NULL,
  dpar = NULL,
  nlpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  sort = FALSE,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale
of the response variable. If <code>"linear"</code>,
results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or
other transformations.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_nlpar">nlpar</code></td>
<td>
<p>Optional name of a predicted non-linear parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_sort">sort</code></td>
<td>
<p>Logical. Only relevant for time series models.
Indicating whether to return predicted values in the original
order (<code>FALSE</code>; default) or in the order of the
time series (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>..</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>array</code> of predicted <em>mean</em> response values.
If <code>summary = FALSE</code> the output resembles those of
<code><a href="#topic+posterior_epred.brmsfit">posterior_epred.brmsfit</a></code>.
</p>
<p>If <code>summary = TRUE</code> the output depends on the family: For categorical
and ordinal families, the output is an N x E x C array, where N is the
number of observations, E is the number of summary statistics, and C is the
number of categories. For all other families, the output is an N x E
matrix. The number of summary statistics E is equal to <code>2 +
  length(probs)</code>: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>
<p>In multivariate models, an additional dimension is added to the output
which indexes along the different response variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_epred.brmsfit">posterior_epred.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fit a model
fit &lt;- brm(rating ~ treat + period + carry + (1|subject),
           data = inhaler)

## compute expected predictions
fitted_values &lt;- fitted(fit)
head(fitted_values)

## plot expected predictions against actual response
dat &lt;- as.data.frame(cbind(Y = standata(fit)$Y, fitted_values))
ggplot(dat) + geom_point(aes(x = Estimate, y = Y))

## End(Not run)

</code></pre>

<hr>
<h2 id='fixef.brmsfit'>Extract Population-Level Estimates</h2><span id='topic+fixef.brmsfit'></span><span id='topic+fixef'></span>

<h3>Description</h3>

<p>Extract the population-level ('fixed') effects
from a <code>brmsfit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
fixef(
  object,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  pars = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="fixef.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fixef.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fixef.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fixef.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Optional names of coefficients to extract.
By default, all coefficients are extracted.</p>
</td></tr>
<tr><td><code id="fixef.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>summary</code> is <code>TRUE</code>, a matrix returned
by <code><a href="#topic+posterior_summary">posterior_summary</a></code> for the population-level effects.
If <code>summary</code> is <code>FALSE</code>, a matrix with one row per
posterior draw and one column per population-level effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(time | cens(censored) ~ age + sex + disease,
           data = kidney, family = "exponential")
fixef(fit)
# extract only some coefficients
fixef(fit, pars = c("age", "sex"))

## End(Not run)

</code></pre>

<hr>
<h2 id='Frechet'>The Frechet Distribution</h2><span id='topic+Frechet'></span><span id='topic+dfrechet'></span><span id='topic+pfrechet'></span><span id='topic+qfrechet'></span><span id='topic+rfrechet'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Frechet distribution with location <code>loc</code>, scale <code>scale</code>,
and shape <code>shape</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfrechet(x, loc = 0, scale = 1, shape = 1, log = FALSE)

pfrechet(q, loc = 0, scale = 1, shape = 1, lower.tail = TRUE, log.p = FALSE)

qfrechet(p, loc = 0, scale = 1, shape = 1, lower.tail = TRUE, log.p = FALSE)

rfrechet(n, loc = 0, scale = 1, shape = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Frechet_+3A_x">x</code>, <code id="Frechet_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_loc">loc</code></td>
<td>
<p>Vector of locations.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_scale">scale</code></td>
<td>
<p>Vector of scales.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_shape">shape</code></td>
<td>
<p>Vector of shapes.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="Frechet_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details
on the parameterization.
</p>

<hr>
<h2 id='GenExtremeValue'>The Generalized Extreme Value Distribution</h2><span id='topic+GenExtremeValue'></span><span id='topic+dgen_extreme_value'></span><span id='topic+pgen_extreme_value'></span><span id='topic+qgen_extreme_value'></span><span id='topic+rgen_extreme_value'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation
for the generalized extreme value distribution with
location <code>mu</code>, scale <code>sigma</code> and shape <code>xi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgen_extreme_value(x, mu = 0, sigma = 1, xi = 0, log = FALSE)

pgen_extreme_value(
  q,
  mu = 0,
  sigma = 1,
  xi = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

qgen_extreme_value(
  p,
  mu = 0,
  sigma = 1,
  xi = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

rgen_extreme_value(n, mu = 0, sigma = 1, xi = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenExtremeValue_+3A_x">x</code>, <code id="GenExtremeValue_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="GenExtremeValue_+3A_mu">mu</code></td>
<td>
<p>Vector of locations.</p>
</td></tr>
<tr><td><code id="GenExtremeValue_+3A_sigma">sigma</code></td>
<td>
<p>Vector of scales.</p>
</td></tr>
<tr><td><code id="GenExtremeValue_+3A_xi">xi</code></td>
<td>
<p>Vector of shapes.</p>
</td></tr>
<tr><td><code id="GenExtremeValue_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="GenExtremeValue_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="GenExtremeValue_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="GenExtremeValue_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="GenExtremeValue_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details
on the parameterization.
</p>

<hr>
<h2 id='get_dpar'>Draws of a Distributional Parameter</h2><span id='topic+get_dpar'></span>

<h3>Description</h3>

<p>Get draws of a distributional parameter from a <code>brmsprep</code> or
<code>mvbrmsprep</code> object. This function is primarily useful when developing
custom families or packages depending on <span class="pkg">brms</span>.
This function lets callers easily handle both the case when the
distributional parameter is predicted directly, via a (non-)linear
predictor or fixed to a constant. See the vignette
<code>vignette("brms_customfamilies")</code> for an example use case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dpar(prep, dpar, i = NULL, inv_link = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dpar_+3A_prep">prep</code></td>
<td>
<p>A 'brmsprep' or 'mvbrmsprep' object created by
<code><a href="#topic+prepare_predictions.brmsfit">prepare_predictions</a></code>.</p>
</td></tr>
<tr><td><code id="get_dpar_+3A_dpar">dpar</code></td>
<td>
<p>Name of the distributional parameter.</p>
</td></tr>
<tr><td><code id="get_dpar_+3A_i">i</code></td>
<td>
<p>The observation numbers for which predictions shall be extracted.
If <code>NULL</code> (the default), all observation will be extracted.
Ignored if <code>dpar</code> is not predicted.</p>
</td></tr>
<tr><td><code id="get_dpar_+3A_inv_link">inv_link</code></td>
<td>
<p>Should the inverse link function be applied?
If <code>NULL</code> (the default), the value is chosen internally.
In particular, <code>inv_link</code> is <code>TRUE</code> by default for custom
families.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the parameter is predicted and <code>i</code> is <code>NULL</code> or
<code>length(i) &gt; 1</code>, an <code>S x N</code> matrix. If the parameter it not
predicted or <code>length(i) == 1</code>, a vector of length <code>S</code>. Here
<code>S</code> is the number of draws and <code>N</code> is the number of
observations or length of <code>i</code> if specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
posterior_predict_my_dist &lt;- function(i, prep, ...) {
  mu &lt;- brms::get_dpar(prep, "mu", i = i)
  mypar &lt;- brms::get_dpar(prep, "mypar", i = i)
  my_rng(mu, mypar)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='get_refmodel.brmsfit'>Projection Predictive Variable Selection: Get Reference Model</h2><span id='topic+get_refmodel.brmsfit'></span>

<h3>Description</h3>

<p>The <code>get_refmodel.brmsfit</code> method can be used to create the reference
model structure which is needed by the <span class="pkg">projpred</span> package for performing
a projection predictive variable selection. This method is called
automatically when performing variable selection via
<code><a href="projpred.html#topic+varsel">varsel</a></code> or
<code><a href="projpred.html#topic+cv_varsel">cv_varsel</a></code>, so you will rarely need to call
it manually yourself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_refmodel.brmsfit(
  object,
  newdata = NULL,
  resp = NULL,
  cvfun = NULL,
  dis = NULL,
  latent = FALSE,
  brms_seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_refmodel.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="get_refmodel.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="get_refmodel.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="get_refmodel.brmsfit_+3A_cvfun">cvfun</code></td>
<td>
<p>Optional cross-validation function
(see <code><a href="projpred.html#topic+get_refmodel">get_refmodel</a></code> for details).
If <code>NULL</code> (the default), <code>cvfun</code> is defined internally
based on <code><a href="#topic+kfold.brmsfit">kfold.brmsfit</a></code>.</p>
</td></tr>
<tr><td><code id="get_refmodel.brmsfit_+3A_dis">dis</code></td>
<td>
<p>Passed to argument <code>dis</code> of
<code><a href="projpred.html#topic+init_refmodel">init_refmodel</a></code>, but leave this at
<code>NULL</code> unless <span class="pkg">projpred</span> complains about it.</p>
</td></tr>
<tr><td><code id="get_refmodel.brmsfit_+3A_latent">latent</code></td>
<td>
<p>See argument <code>latent</code> of
<code><a href="projpred.html#topic+extend_family">extend_family</a></code>. Setting this to
<code>TRUE</code> requires a <span class="pkg">projpred</span> version &gt;= 2.4.0.</p>
</td></tr>
<tr><td><code id="get_refmodel.brmsfit_+3A_brms_seed">brms_seed</code></td>
<td>
<p>A seed used to infer seeds for <code><a href="#topic+kfold.brmsfit">kfold.brmsfit</a></code>
and for sampling group-level effects for new levels (in multilevel models).
If <code>NULL</code>, then <code><a href="base.html#topic+set.seed">set.seed</a></code> is not called at all. If not
<code>NULL</code>, then the pseudorandom number generator (PRNG) state is reset
(to the state before calling this function) upon exiting this function.</p>
</td></tr>
<tr><td><code id="get_refmodel.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="projpred.html#topic+init_refmodel">init_refmodel</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>extract_model_data</code> function used internally by
<code>get_refmodel.brmsfit</code> ignores arguments <code>wrhs</code> and <code>orhs</code>
(a warning is thrown if these are non-<code>NULL</code>). For example, arguments
<code>weightsnew</code> and <code>offsetnew</code> of
<code><a href="projpred.html#topic+proj_linpred">proj_linpred</a></code>,
<code><a href="projpred.html#topic+proj_predict">proj_predict</a></code>, and
<code><a href="projpred.html#topic+predict.refmodel">predict.refmodel</a></code> are passed to
<code>wrhs</code> and <code>orhs</code>, respectively.
</p>


<h3>Value</h3>

<p>A <code>refmodel</code> object to be used in conjunction with the
<span class="pkg">projpred</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit a simple model
fit &lt;- brm(count ~ zAge + zBase * Trt,
           data = epilepsy, family = poisson())
summary(fit)

# The following code requires the 'projpred' package to be installed:
library(projpred)

# perform variable selection without cross-validation
vs &lt;- varsel(fit)
summary(vs)
plot(vs)

# perform variable selection with cross-validation
cv_vs &lt;- cv_varsel(fit)
summary(cv_vs)
plot(cv_vs)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_y'>Extract response values</h2><span id='topic+get_y'></span>

<h3>Description</h3>

<p>Extract response values from a <code><a href="#topic+brmsfit">brmsfit</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_y(x, resp = NULL, sort = FALSE, warn = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_y_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+brmsfit">brmsfit</a></code> object.</p>
</td></tr>
<tr><td><code id="get_y_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables for which to extract values.</p>
</td></tr>
<tr><td><code id="get_y_+3A_sort">sort</code></td>
<td>
<p>Logical. Only relevant for time series models.
Indicating whether to return predicted values in the original
order (<code>FALSE</code>; default) or in the order of the
time series (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get_y_+3A_warn">warn</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
<tr><td><code id="get_y_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+standata">standata</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of response values for univariate models and a
matrix of response values with one column per response variable for
multivariate models.
</p>

<hr>
<h2 id='gp'>Set up Gaussian process terms in <span class="pkg">brms</span></h2><span id='topic+gp'></span>

<h3>Description</h3>

<p>Set up a Gaussian process (GP) term in <span class="pkg">brms</span>. The function does not
evaluate its arguments &ndash; it exists purely to help set up a model with
GP terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp(
  ...,
  by = NA,
  k = NA,
  cov = "exp_quad",
  iso = TRUE,
  gr = TRUE,
  cmc = TRUE,
  scale = TRUE,
  c = 5/4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_+3A_...">...</code></td>
<td>
<p>One or more predictors for the GP.</p>
</td></tr>
<tr><td><code id="gp_+3A_by">by</code></td>
<td>
<p>A numeric or factor variable of the same length as
each predictor. In the numeric vector case, the elements multiply
the values returned by the GP. In the factor variable
case, a separate GP is fitted for each factor level.</p>
</td></tr>
<tr><td><code id="gp_+3A_k">k</code></td>
<td>
<p>Optional number of basis functions for computing approximate
GPs. If <code>NA</code> (the default), exact GPs are computed.</p>
</td></tr>
<tr><td><code id="gp_+3A_cov">cov</code></td>
<td>
<p>Name of the covariance kernel. By default,
the exponentiated-quadratic kernel <code>"exp_quad"</code> is used.</p>
</td></tr>
<tr><td><code id="gp_+3A_iso">iso</code></td>
<td>
<p>A flag to indicate whether an isotropic (<code>TRUE</code>; the
default) or a non-isotropic GP should be used.
In the former case, the same amount of smoothing is applied to all
predictors. In the latter case, predictors may have different smoothing.
Ignored if only a single predictor is supplied.</p>
</td></tr>
<tr><td><code id="gp_+3A_gr">gr</code></td>
<td>
<p>Logical; Indicates if auto-grouping should be used (defaults
to <code>TRUE</code>). If enabled, observations sharing the same
predictor values will be represented by the same latent variable
in the GP. This will improve sampling efficiency
drastically if the number of unique predictor combinations is small
relative to the number of observations.</p>
</td></tr>
<tr><td><code id="gp_+3A_cmc">cmc</code></td>
<td>
<p>Logical; Only relevant if <code>by</code> is a factor. If <code>TRUE</code>
(the default), cell-mean coding is used for the <code>by</code>-factor, that is
one GP per level is estimated. If <code>FALSE</code>, contrast GPs are estimated
according to the contrasts set for the <code>by</code>-factor.</p>
</td></tr>
<tr><td><code id="gp_+3A_scale">scale</code></td>
<td>
<p>Logical; If <code>TRUE</code> (the default), predictors are
scaled so that the maximum Euclidean distance between two points
is 1. This often improves sampling speed and convergence.
Scaling also affects the estimated length-scale parameters
in that they resemble those of scaled predictors (not of the original
predictors) if <code>scale</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_c">c</code></td>
<td>
<p>Numeric value only used in approximate GPs. Defines the
multiplicative constant of the predictors' range over which
predictions should be computed. A good default could be <code>c = 5/4</code>
but we are still working on providing better recommendations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A GP is a stochastic process, which
describes the relation between one or more predictors
<code class="reqn">x = (x_1, ..., x_d)</code> and a response <code class="reqn">f(x)</code>, where
<code class="reqn">d</code> is the number of predictors. A GP is the
generalization of the multivariate normal distribution
to an infinite number of dimensions. Thus, it can be
interpreted as a prior over functions. The values of <code class="reqn">f( )</code>
at any finite set of locations are jointly multivariate
normal, with a covariance matrix defined by the covariance
kernel <code class="reqn">k_p(x_i, x_j)</code>, where <code class="reqn">p</code> is the vector of parameters
of the GP:
</p>
<p style="text-align: center;"><code class="reqn">(f(x_1), \ldots f(x_n) \sim MVN(0, (k_p(x_i, x_j))_{i,j=1}^n) .</code>
</p>

<p>The smoothness and general behavior of the function <code class="reqn">f</code>
depends only on the choice of covariance kernel.
For a more detailed introduction to Gaussian processes,
see <a href="https://en.wikipedia.org/wiki/Gaussian_process">https://en.wikipedia.org/wiki/Gaussian_process</a>.
</p>
<p>Below, we describe the currently supported covariance kernels:
</p>

<ul>
<li><p> &quot;exp_quad&quot;: The exponentiated quadratic kernel is defined as
<code class="reqn">k(x_i, x_j) = sdgp^2 \exp(- || x_i - x_j ||^2 / (2 lscale^2))</code>,
where <code class="reqn">|| . ||</code> is the Euclidean norm, <code class="reqn">sdgp</code> is a
standard deviation parameter, and <code class="reqn">lscale</code> is characteristic
length-scale parameter. The latter practically measures how close two
points <code class="reqn">x_i</code> and <code class="reqn">x_j</code> have to be to influence each other
substantially.
</p>
</li></ul>

<p>In the current implementation, <code>"exp_quad"</code> is the only supported
covariance kernel. More options will follow in the future.
</p>


<h3>Value</h3>

<p>An object of class <code>'gp_term'</code>, which is a list
of arguments to be interpreted by the formula
parsing functions of <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate data using the mgcv package
dat &lt;- mgcv::gamSim(1, n = 30, scale = 2)

# fit a simple GP model
fit1 &lt;- brm(y ~ gp(x2), dat, chains = 2)
summary(fit1)
me1 &lt;- conditional_effects(fit1, ndraws = 200, spaghetti = TRUE)
plot(me1, ask = FALSE, points = TRUE)

# fit a more complicated GP model
fit2 &lt;- brm(y ~ gp(x0) + x1 + gp(x2) + x3, dat, chains = 2)
summary(fit2)
me2 &lt;- conditional_effects(fit2, ndraws = 200, spaghetti = TRUE)
plot(me2, ask = FALSE, points = TRUE)

# fit a multivariate GP model
fit3 &lt;- brm(y ~ gp(x1, x2), dat, chains = 2)
summary(fit3)
me3 &lt;- conditional_effects(fit3, ndraws = 200, spaghetti = TRUE)
plot(me3, ask = FALSE, points = TRUE)

# compare model fit
loo(fit1, fit2, fit3)

# simulate data with a factor covariate
dat2 &lt;- mgcv::gamSim(4, n = 90, scale = 2)

# fit separate gaussian processes for different levels of 'fac'
fit4 &lt;- brm(y ~ gp(x2, by = fac), dat2, chains = 2)
summary(fit4)
plot(conditional_effects(fit4), points = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='gr'>Set up basic grouping terms in <span class="pkg">brms</span></h2><span id='topic+gr'></span>

<h3>Description</h3>

<p>Function used to set up a basic grouping term in <span class="pkg">brms</span>.
The function does not evaluate its arguments &ndash;
it exists purely to help set up a model with grouping terms.
<code>gr</code> is called implicitly inside the package
and there is usually no need to call it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr(..., by = NULL, cor = TRUE, id = NA, cov = NULL, dist = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_+3A_...">...</code></td>
<td>
<p>One or more terms containing grouping factors.</p>
</td></tr>
<tr><td><code id="gr_+3A_by">by</code></td>
<td>
<p>An optional factor variable, specifying sub-populations of the
groups. For each level of the <code>by</code> variable, a separate
variance-covariance matrix will be fitted. Levels of the grouping factor
must be nested in levels of the <code>by</code> variable.</p>
</td></tr>
<tr><td><code id="gr_+3A_cor">cor</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), group-level terms will be
modelled as correlated.</p>
</td></tr>
<tr><td><code id="gr_+3A_id">id</code></td>
<td>
<p>Optional character string. All group-level terms across the model
with the same <code>id</code> will be modeled as correlated (if <code>cor</code> is
<code>TRUE</code>). See <code><a href="#topic+brmsformula">brmsformula</a></code> for more details.</p>
</td></tr>
<tr><td><code id="gr_+3A_cov">cov</code></td>
<td>
<p>An optional matrix which is proportional to the withon-group
covariance matrix of the group-level effects. All levels of the grouping
factor should appear as rownames of the corresponding matrix. This argument
can be used, among others, to model pedigrees and phylogenetic effects. See
<code>vignette("brms_phylogenetics")</code> for more details. By default, levels
of the same grouping factor are modeled as independent of each other.</p>
</td></tr>
<tr><td><code id="gr_+3A_dist">dist</code></td>
<td>
<p>Name of the distribution of the group-level effects.
Currently <code>"gaussian"</code> is the only option.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model using basic lme4-style formula
fit1 &lt;- brm(count ~ Trt + (1|patient), data = epilepsy)
summary(fit1)

# equivalent model using 'gr' which is called anyway internally
fit2 &lt;- brm(count ~ Trt + (1|gr(patient)), data = epilepsy)
summary(fit2)

# include Trt as a by variable
fit3 &lt;- brm(count ~ Trt + (1|gr(patient, by = Trt)), data = epilepsy)
summary(fit3)

## End(Not run)

</code></pre>

<hr>
<h2 id='horseshoe'>Regularized horseshoe priors in <span class="pkg">brms</span></h2><span id='topic+horseshoe'></span>

<h3>Description</h3>

<p>Function used to set up regularized horseshoe priors and related
hierarchical shrinkage priors for population-level effects in <span class="pkg">brms</span>. The
function does not evaluate its arguments &ndash; it exists purely to help set up
the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horseshoe(
  df = 1,
  scale_global = 1,
  df_global = 1,
  scale_slab = 2,
  df_slab = 4,
  par_ratio = NULL,
  autoscale = TRUE,
  main = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horseshoe_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of student-t prior of the
local shrinkage parameters. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_scale_global">scale_global</code></td>
<td>
<p>Scale of the student-t prior of the global shrinkage
parameter. Defaults to <code>1</code>.
In linear models, <code>scale_global</code> will internally be
multiplied by the residual standard deviation parameter <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_df_global">df_global</code></td>
<td>
<p>Degrees of freedom of student-t prior of the
global shrinkage parameter. Defaults to <code>1</code>. If <code>df_global</code>
is greater <code>1</code>, the shape of the prior will no longer resemble
a horseshoe and it may be more appropriately called an hierarchical
shrinkage prior in this case.</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_scale_slab">scale_slab</code></td>
<td>
<p>Scale of the Student-t slab. Defaults to <code>2</code>. The
original unregularized horseshoe prior is obtained by setting
<code>scale_slab</code> to infinite, which we can approximate in practice by
setting it to a very large real value.</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_df_slab">df_slab</code></td>
<td>
<p>Degrees of freedom of the student-t slab.
Defaults to <code>4</code>.</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_par_ratio">par_ratio</code></td>
<td>
<p>Ratio of the expected number of non-zero coefficients
to the expected number of zero coefficients. If specified,
<code>scale_global</code> is ignored and internally computed as
<code>par_ratio / sqrt(N)</code>, where <code>N</code> is the total number
of observations in the data.</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_autoscale">autoscale</code></td>
<td>
<p>Logical; indicating whether the horseshoe
prior should be scaled using the residual standard deviation
<code>sigma</code> if possible and sensible (defaults to <code>TRUE</code>).
Autoscaling is not applied for distributional parameters or
when the model does not contain the parameter <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_main">main</code></td>
<td>
<p>Logical (defaults to <code>FALSE</code>); only relevant if the horseshoe
prior spans multiple parameter classes. In this case, only arguments given
in the single instance where <code>main</code> is <code>TRUE</code> will be used.
Arguments given in other instances of the prior will be ignored.
See the Examples section below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The horseshoe prior is a special shrinkage prior initially proposed by
Carvalho et al. (2009).
It is symmetric around zero with fat tails and an infinitely large spike
at zero. This makes it ideal for sparse models that have
many regression coefficients, although only a minority of them is non-zero.
The horseshoe prior can be applied on all population-level effects at once
(excluding the intercept) by using <code>set_prior("horseshoe(1)")</code>.
The <code>1</code> implies that the student-t prior of the local shrinkage
parameters has 1 degrees of freedom. This may, however, lead to an
increased number of divergent transition in <span class="pkg">Stan</span>.
Accordingly, increasing the degrees of freedom to slightly higher values
(e.g., <code>3</code>) may often be a better option, although the prior
no longer resembles a horseshoe in this case.
Further, the scale of the global shrinkage parameter plays an important role
in amount of shrinkage applied. It defaults to <code>1</code>,
but this may result in too few shrinkage (Piironen &amp; Vehtari, 2016).
It is thus possible to change the scale using argument <code>scale_global</code>
of the horseshoe prior, for instance <code>horseshoe(1, scale_global = 0.5)</code>.
In linear models, <code>scale_global</code> will internally be multiplied by the
residual standard deviation parameter <code>sigma</code>. See Piironen and
Vehtari (2016) for recommendations how to properly set the global scale.
The degrees of freedom of the global shrinkage prior may also be
adjusted via argument <code>df_global</code>.
Piironen and Vehtari (2017) recommend to specifying the ratio of the
expected number of non-zero coefficients to the expected number of zero
coefficients <code>par_ratio</code> rather than <code>scale_global</code> directly.
As proposed by Piironen and Vehtari (2017), an additional regularization
is applied that only affects non-zero coefficients. The amount of
regularization can be controlled via <code>scale_slab</code> and <code>df_slab</code>.
To make sure that shrinkage can equally affect all coefficients,
predictors should be one the same scale.
Generally, models with horseshoe priors a more likely than other models
to have divergent transitions so that increasing <code>adapt_delta</code>
from <code>0.8</code> to values closer to <code>1</code> will often be necessary.
See the documentation of <code><a href="#topic+brm">brm</a></code> for instructions
on how to increase <code>adapt_delta</code>.
</p>
<p>Currently, the following classes support the horseshoe prior: <code>b</code>
(overall regression coefficients), <code>sds</code> (SDs of smoothing splines),
<code>sdgp</code> (SDs of Gaussian processes), <code>ar</code> (autoregressive
coefficients), <code>ma</code> (moving average coefficients), <code>sderr</code> (SD of
latent residuals), <code>sdcar</code> (SD of spatial CAR structures), <code>sd</code>
(SD of varying coefficients).
</p>


<h3>Value</h3>

<p>A character string obtained by <code>match.call()</code> with
additional arguments.
</p>


<h3>References</h3>

<p>Carvalho, C. M., Polson, N. G., &amp; Scott, J. G. (2009). Handling sparsity via
the horseshoe. Artificial Intelligence and Statistics.
<a href="http://proceedings.mlr.press/v5/carvalho09a">http://proceedings.mlr.press/v5/carvalho09a</a>
</p>
<p>Piironen J. &amp; Vehtari A. (2017). On the Hyperprior Choice for the Global
Shrinkage Parameter in the Horseshoe Prior. Artificial Intelligence and
Statistics. <a href="https://arxiv.org/pdf/1610.05559v1.pdf">https://arxiv.org/pdf/1610.05559v1.pdf</a>
</p>
<p>Piironen, J., and Vehtari, A. (2017). Sparsity information and regularization
in the horseshoe and other shrinkage priors. Electronic Journal of
Statistics. <a href="https://arxiv.org/abs/1707.01694">https://arxiv.org/abs/1707.01694</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_prior(horseshoe(df = 3, par_ratio = 0.1))

# specify the horseshoe prior across multiple parameter classes
set_prior(horseshoe(df = 3, par_ratio = 0.1, main = TRUE), class = "b") +
  set_prior(horseshoe(), class = "sd")

</code></pre>

<hr>
<h2 id='Hurdle'>Hurdle Distributions</h2><span id='topic+Hurdle'></span><span id='topic+dhurdle_poisson'></span><span id='topic+phurdle_poisson'></span><span id='topic+dhurdle_negbinomial'></span><span id='topic+phurdle_negbinomial'></span><span id='topic+dhurdle_gamma'></span><span id='topic+phurdle_gamma'></span><span id='topic+dhurdle_lognormal'></span><span id='topic+phurdle_lognormal'></span>

<h3>Description</h3>

<p>Density and distribution functions for hurdle distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhurdle_poisson(x, lambda, hu, log = FALSE)

phurdle_poisson(q, lambda, hu, lower.tail = TRUE, log.p = FALSE)

dhurdle_negbinomial(x, mu, shape, hu, log = FALSE)

phurdle_negbinomial(q, mu, shape, hu, lower.tail = TRUE, log.p = FALSE)

dhurdle_gamma(x, shape, scale, hu, log = FALSE)

phurdle_gamma(q, shape, scale, hu, lower.tail = TRUE, log.p = FALSE)

dhurdle_lognormal(x, mu, sigma, hu, log = FALSE)

phurdle_lognormal(q, mu, sigma, hu, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hurdle_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Hurdle_+3A_hu">hu</code></td>
<td>
<p>hurdle probability</p>
</td></tr>
<tr><td><code id="Hurdle_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="Hurdle_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Hurdle_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="Hurdle_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="Hurdle_+3A_mu">mu</code>, <code id="Hurdle_+3A_lambda">lambda</code></td>
<td>
<p>location parameter</p>
</td></tr>
<tr><td><code id="Hurdle_+3A_shape">shape</code></td>
<td>
<p>shape parameter</p>
</td></tr>
<tr><td><code id="Hurdle_+3A_sigma">sigma</code>, <code id="Hurdle_+3A_scale">scale</code></td>
<td>
<p>scale parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of a hurdle distribution can be specified as follows.
If <code class="reqn">x = 0</code> set <code class="reqn">f(x) = \theta</code>. Else set
<code class="reqn">f(x) = (1 - \theta) * g(x) / (1 - G(0))</code>
where <code class="reqn">g(x)</code> and <code class="reqn">G(x)</code> are the density and distribution
function of the non-hurdle part, respectively.
</p>

<hr>
<h2 id='hypothesis.brmsfit'>Non-Linear Hypothesis Testing</h2><span id='topic+hypothesis.brmsfit'></span><span id='topic+hypothesis'></span><span id='topic+hypothesis.default'></span>

<h3>Description</h3>

<p>Perform non-linear hypothesis testing for all model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
hypothesis(
  x,
  hypothesis,
  class = "b",
  group = "",
  scope = c("standard", "ranef", "coef"),
  alpha = 0.05,
  robust = FALSE,
  seed = NULL,
  ...
)

hypothesis(x, ...)

## Default S3 method:
hypothesis(x, hypothesis, alpha = 0.05, robust = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypothesis.brmsfit_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object. If it is no <code>brmsfit</code> object,
it must be coercible to a <code>data.frame</code>.
In the latter case, the variables used in the <code>hypothesis</code> argument
need to correspond to column names of <code>x</code>, while the rows
are treated as representing posterior draws of the variables.</p>
</td></tr>
<tr><td><code id="hypothesis.brmsfit_+3A_hypothesis">hypothesis</code></td>
<td>
<p>A character vector specifying one or more
non-linear hypothesis concerning parameters of the model.</p>
</td></tr>
<tr><td><code id="hypothesis.brmsfit_+3A_class">class</code></td>
<td>
<p>A string specifying the class of parameters being tested.
Default is &quot;b&quot; for population-level effects.
Other typical options are &quot;sd&quot; or &quot;cor&quot;.
If <code>class = NULL</code>, all parameters can be tested
against each other, but have to be specified with their full name
(see also <code><a href="#topic+draws-index-brms">variables</a></code>)</p>
</td></tr>
<tr><td><code id="hypothesis.brmsfit_+3A_group">group</code></td>
<td>
<p>Name of a grouping factor to evaluate only
group-level effects parameters related to this grouping factor.</p>
</td></tr>
<tr><td><code id="hypothesis.brmsfit_+3A_scope">scope</code></td>
<td>
<p>Indicates where to look for the variables specified in
<code>hypothesis</code>. If <code>"standard"</code>, use the full parameter names
(subject to the restriction given by <code>class</code> and <code>group</code>).
If <code>"coef"</code> or <code>"ranef"</code>, compute the hypothesis for all levels
of the grouping factor given in <code>"group"</code>, based on the
output of <code><a href="#topic+coef.brmsfit">coef.brmsfit</a></code> and <code><a href="#topic+ranef.brmsfit">ranef.brmsfit</a></code>,
respectively.</p>
</td></tr>
<tr><td><code id="hypothesis.brmsfit_+3A_alpha">alpha</code></td>
<td>
<p>The alpha-level of the tests (default is 0.05;
see 'Details' for more information).</p>
</td></tr>
<tr><td><code id="hypothesis.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.</p>
</td></tr>
<tr><td><code id="hypothesis.brmsfit_+3A_seed">seed</code></td>
<td>
<p>A single numeric value passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>
to make results reproducible.</p>
</td></tr>
<tr><td><code id="hypothesis.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Among others, <code>hypothesis</code> computes an evidence ratio
(<code>Evid.Ratio</code>) for each hypothesis. For a one-sided hypothesis, this
is just the posterior probability (<code>Post.Prob</code>) under the hypothesis
against its alternative. That is, when the hypothesis is of the form
<code>a &gt; b</code>, the evidence ratio is the ratio of the posterior probability
of <code>a &gt; b</code> and the posterior probability of <code>a &lt; b</code>. In this
example, values greater than one indicate that the evidence in favor of
<code>a &gt; b</code> is larger than evidence in favor of <code>a &lt; b</code>. For an
two-sided (point) hypothesis, the evidence ratio is a Bayes factor between
the hypothesis and its alternative computed via the Savage-Dickey density
ratio method. That is the posterior density at the point of interest
divided by the prior density at that point. Values greater than one
indicate that evidence in favor of the point hypothesis has increased after
seeing the data. In order to calculate this Bayes factor, all parameters
related to the hypothesis must have proper priors and argument
<code>sample_prior</code> of function <code>brm</code> must be set to <code>"yes"</code>.
Otherwise <code>Evid.Ratio</code> (and <code>Post.Prob</code>) will be <code>NA</code>.
Please note that, for technical reasons, we cannot sample from priors of
certain parameters classes. Most notably, these include overall intercept
parameters (prior class <code>"Intercept"</code>) as well as group-level
coefficients. When interpreting Bayes factors, make sure that your priors
are reasonable and carefully chosen, as the result will depend heavily on
the priors. In particular, avoid using default priors.
</p>
<p>The <code>Evid.Ratio</code> may sometimes be <code>0</code> or <code>Inf</code> implying very
small or large evidence, respectively, in favor of the tested hypothesis.
For one-sided hypotheses pairs, this basically means that all posterior
draws are on the same side of the value dividing the two hypotheses. In
that sense, instead of <code>0</code> or <code>Inf,</code> you may rather read it as
<code>Evid.Ratio</code> smaller <code>1 / S</code> or greater <code>S</code>, respectively,
where <code>S</code> denotes the number of posterior draws used in the
computations.
</p>
<p>The argument <code>alpha</code> specifies the size of the credible interval
(i.e., Bayesian confidence interval). For instance, if we tested a
two-sided hypothesis and set <code>alpha = 0.05</code> (5%) an, the credible
interval will contain <code>1 - alpha = 0.95</code> (95%) of the posterior
values. Hence, <code>alpha * 100</code>% of the posterior values will
lie outside of the credible interval. Although this allows testing of
hypotheses in a similar manner as in the frequentist null-hypothesis
testing framework, we strongly argue against using arbitrary cutoffs (e.g.,
<code>p &lt; .05</code>) to determine the 'existence' of an effect.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+brmshypothesis">brmshypothesis</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Paul-Christian Buerkner <a href="mailto:paul.buerkner@gmail.com">paul.buerkner@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmshypothesis">brmshypothesis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## define priors
prior &lt;- c(set_prior("normal(0,2)", class = "b"),
           set_prior("student_t(10,0,1)", class = "sigma"),
           set_prior("student_t(10,0,1)", class = "sd"))

## fit a linear mixed effects models
fit &lt;- brm(time ~ age + sex + disease + (1 + age|patient),
           data = kidney, family = lognormal(),
           prior = prior, sample_prior = "yes",
           control = list(adapt_delta = 0.95))

## perform two-sided hypothesis testing
(hyp1 &lt;- hypothesis(fit, "sexfemale = age + diseasePKD"))
plot(hyp1)
hypothesis(fit, "exp(age) - 3 = 0", alpha = 0.01)

## perform one-sided hypothesis testing
hypothesis(fit, "diseasePKD + diseaseGN - 3 &lt; 0")

hypothesis(fit, "age &lt; Intercept",
           class = "sd", group  = "patient")

## test the amount of random intercept variance on all variance
h &lt;- paste("sd_patient__Intercept^2 / (sd_patient__Intercept^2 +",
           "sd_patient__age^2 + sigma^2) = 0")
(hyp2 &lt;- hypothesis(fit, h, class = NULL))
plot(hyp2)

## test more than one hypothesis at once
h &lt;- c("diseaseGN = diseaseAN", "2 * diseaseGN - diseasePKD = 0")
(hyp3 &lt;- hypothesis(fit, h))
plot(hyp3, ignore_prior = TRUE)

## compute hypotheses for all levels of a grouping factor
hypothesis(fit, "age = 0", scope = "coef", group = "patient")

## use the default method
dat &lt;- as.data.frame(fit)
str(dat)
hypothesis(dat, "b_age &gt; 0")

## End(Not run)

</code></pre>

<hr>
<h2 id='inhaler'>Clarity of inhaler instructions</h2><span id='topic+inhaler'></span>

<h3>Description</h3>

<p>Ezzet and Whitehead (1991) analyze data from a two-treatment,
two-period crossover trial to compare 2 inhalation devices for
delivering the drug salbutamol in 286 asthma patients.
Patients were asked to rate the clarity of leaflet instructions
accompanying each device, using a 4-point ordinal scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inhaler
</code></pre>


<h3>Format</h3>

<p>A data frame of 572 observations containing
information on the following 5 variables.
</p>

<dl>
<dt>subject</dt><dd><p>The subject number</p>
</dd>
<dt>rating</dt><dd><p>The rating of the inhaler instructions
on a scale ranging from 1 to 4</p>
</dd>
<dt>treat</dt><dd><p>A contrast to indicate which of
the two inhaler devices was used</p>
</dd>
<dt>period</dt><dd><p>A contrast to indicate the time of administration</p>
</dd>
<dt>carry</dt><dd><p>A contrast to indicate possible carry over effects</p>
</dd>
</dl>



<h3>Source</h3>

<p>Ezzet, F., &amp; Whitehead, J. (1991).
A random effects model for ordinal responses from a crossover trial.
<em>Statistics in Medicine</em>, 10(6), 901-907.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## ordinal regression with family "sratio"
fit1 &lt;- brm(rating ~ treat + period + carry,
            data = inhaler, family = sratio(),
            prior = set_prior("normal(0,5)"))
summary(fit1)
plot(fit1)

## ordinal regression with family "cumulative"
## and random intercept over subjects
fit2 &lt;- brm(rating ~ treat + period + carry + (1|subject),
              data = inhaler, family = cumulative(),
              prior = set_prior("normal(0,5)"))
summary(fit2)
plot(fit2)

## End(Not run)

</code></pre>

<hr>
<h2 id='inv_logit_scaled'>Scaled inverse logit-link</h2><span id='topic+inv_logit_scaled'></span>

<h3>Description</h3>

<p>Computes <code>inv_logit(x) * (ub - lb) + lb</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_logit_scaled(x, lb = 0, ub = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_logit_scaled_+3A_x">x</code></td>
<td>
<p>A numeric or complex vector.</p>
</td></tr>
<tr><td><code id="inv_logit_scaled_+3A_lb">lb</code></td>
<td>
<p>Lower bound defaulting to <code>0</code>.</p>
</td></tr>
<tr><td><code id="inv_logit_scaled_+3A_ub">ub</code></td>
<td>
<p>Upper bound defaulting to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex vector between <code>lb</code> and <code>ub</code>.
</p>

<hr>
<h2 id='InvGaussian'>The Inverse Gaussian Distribution</h2><span id='topic+InvGaussian'></span><span id='topic+dinv_gaussian'></span><span id='topic+pinv_gaussian'></span><span id='topic+rinv_gaussian'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation
for the inverse Gaussian distribution with location <code>mu</code>,
and shape <code>shape</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinv_gaussian(x, mu = 1, shape = 1, log = FALSE)

pinv_gaussian(q, mu = 1, shape = 1, lower.tail = TRUE, log.p = FALSE)

rinv_gaussian(n, mu = 1, shape = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvGaussian_+3A_x">x</code>, <code id="InvGaussian_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="InvGaussian_+3A_mu">mu</code></td>
<td>
<p>Vector of locations.</p>
</td></tr>
<tr><td><code id="InvGaussian_+3A_shape">shape</code></td>
<td>
<p>Vector of shapes.</p>
</td></tr>
<tr><td><code id="InvGaussian_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="InvGaussian_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="InvGaussian_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="InvGaussian_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details
on the parameterization.
</p>

<hr>
<h2 id='is.brmsfit'>Checks if argument is a <code>brmsfit</code> object</h2><span id='topic+is.brmsfit'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>brmsfit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.brmsfit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.brmsfit_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>

<hr>
<h2 id='is.brmsfit_multiple'>Checks if argument is a <code>brmsfit_multiple</code> object</h2><span id='topic+is.brmsfit_multiple'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>brmsfit_multiple</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.brmsfit_multiple(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.brmsfit_multiple_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>

<hr>
<h2 id='is.brmsformula'>Checks if argument is a <code>brmsformula</code> object</h2><span id='topic+is.brmsformula'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>brmsformula</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.brmsformula(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.brmsformula_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>

<hr>
<h2 id='is.brmsprior'>Checks if argument is a <code>brmsprior</code> object</h2><span id='topic+is.brmsprior'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>brmsprior</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.brmsprior(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.brmsprior_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>

<hr>
<h2 id='is.brmsterms'>Checks if argument is a <code>brmsterms</code> object</h2><span id='topic+is.brmsterms'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>brmsterms</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.brmsterms(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.brmsterms_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+brmsterms">brmsterms</a></code>
</p>

<hr>
<h2 id='is.cor_brms'>Check if argument is a correlation structure</h2><span id='topic+is.cor_brms'></span><span id='topic+is.cor_arma'></span><span id='topic+is.cor_cosy'></span><span id='topic+is.cor_sar'></span><span id='topic+is.cor_car'></span><span id='topic+is.cor_fixed'></span>

<h3>Description</h3>

<p>Check if argument is one of the correlation structures
used in <span class="pkg">brms</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cor_brms(x)

is.cor_arma(x)

is.cor_cosy(x)

is.cor_sar(x)

is.cor_car(x)

is.cor_fixed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.cor_brms_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>

<hr>
<h2 id='is.mvbrmsformula'>Checks if argument is a <code>mvbrmsformula</code> object</h2><span id='topic+is.mvbrmsformula'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>mvbrmsformula</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mvbrmsformula(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mvbrmsformula_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>

<hr>
<h2 id='is.mvbrmsterms'>Checks if argument is a <code>mvbrmsterms</code> object</h2><span id='topic+is.mvbrmsterms'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>mvbrmsterms</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mvbrmsterms(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mvbrmsterms_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+brmsterms">brmsterms</a></code>
</p>

<hr>
<h2 id='kfold_predict'>Predictions from K-Fold Cross-Validation</h2><span id='topic+kfold_predict'></span>

<h3>Description</h3>

<p>Compute and evaluate predictions after performing K-fold
cross-validation via <code><a href="#topic+kfold">kfold</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfold_predict(x, method = "posterior_predict", resp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfold_predict_+3A_x">x</code></td>
<td>
<p>Object of class <code>'kfold'</code> computed by <code><a href="#topic+kfold">kfold</a></code>.
For <code>kfold_predict</code> to work, the fitted model objects need to have
been stored via argument <code>save_fits</code> of <code><a href="#topic+kfold">kfold</a></code>.</p>
</td></tr>
<tr><td><code id="kfold_predict_+3A_method">method</code></td>
<td>
<p>Method used to obtain predictions. Can be set to
<code>"posterior_predict"</code> (the default), <code>"posterior_epred"</code>,
or <code>"posterior_linpred"</code>. For more details, see the respective
function documentations.</p>
</td></tr>
<tr><td><code id="kfold_predict_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="kfold_predict_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two slots named <code>'y'</code> and <code>'yrep'</code>.
Slot <code>y</code> contains the vector of observed responses.
Slot <code>yrep</code> contains the matrix of predicted responses,
with rows being posterior draws and columns being observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfold">kfold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zBase * Trt + (1|patient),
           data = epilepsy, family = poisson())

# perform k-fold cross validation
(kf &lt;- kfold(fit, save_fits = TRUE, chains = 1))

# define a loss function
rmse &lt;- function(y, yrep) {
  yrep_mean &lt;- colMeans(yrep)
  sqrt(mean((yrep_mean - y)^2))
}

# predict responses and evaluate the loss
kfp &lt;- kfold_predict(kf)
rmse(y = kfp$y, yrep = kfp$yrep)

## End(Not run)

</code></pre>

<hr>
<h2 id='kfold.brmsfit'>K-Fold Cross-Validation</h2><span id='topic+kfold.brmsfit'></span><span id='topic+kfold'></span>

<h3>Description</h3>

<p>Perform exact K-fold cross-validation by refitting the model <code class="reqn">K</code>
times each leaving out one-<code class="reqn">K</code>th of the original data.
Folds can be run in parallel using the <span class="pkg">future</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
kfold(
  x,
  ...,
  K = 10,
  Ksub = NULL,
  folds = NULL,
  group = NULL,
  joint = FALSE,
  compare = TRUE,
  resp = NULL,
  model_names = NULL,
  save_fits = FALSE,
  recompile = NULL,
  future_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfold.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+brm">brm</a></code>.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_k">K</code></td>
<td>
<p>The number of subsets of equal (if possible) size
into which the data will be partitioned for performing
<code class="reqn">K</code>-fold cross-validation. The model is refit <code>K</code> times, each time
leaving out one of the <code>K</code> subsets. If <code>K</code> is equal to the total
number of observations in the data then <code class="reqn">K</code>-fold cross-validation is
equivalent to exact leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_ksub">Ksub</code></td>
<td>
<p>Optional number of subsets (of those subsets defined by <code>K</code>)
to be evaluated. If <code>NULL</code> (the default), <code class="reqn">K</code>-fold cross-validation
will be performed on all subsets. If <code>Ksub</code> is a single integer,
<code>Ksub</code> subsets (out of all <code>K</code>) subsets will be randomly chosen.
If <code>Ksub</code> consists of multiple integers or a one-dimensional array
(created via <code>as.array</code>) potentially of length one, the corresponding
subsets will be used. This argument is primarily useful, if evaluation of
all subsets is infeasible for some reason.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_folds">folds</code></td>
<td>
<p>Determines how the subsets are being constructed.
Possible values are <code>NULL</code> (the default), <code>"stratified"</code>,
<code>"grouped"</code>, or <code>"loo"</code>. May also be a vector of length
equal to the number of observations in the data. Alters the way
<code>group</code> is handled. More information is provided in the 'Details'
section.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_group">group</code></td>
<td>
<p>Optional name of a grouping variable or factor in the model.
What exactly is done with this variable depends on argument <code>folds</code>.
More information is provided in the 'Details' section.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_joint">joint</code></td>
<td>
<p>Indicates which observations' log likelihoods shall be
considered jointly in the ELPD computation. If <code>"obs"</code> or <code>FALSE</code>
(the default), each observation is considered separately. This enables
comparability of <code>kfold</code> with <code>loo</code>. If <code>"fold"</code>, the joint
log likelihoods per fold are used. If <code>"group"</code>, the joint log
likelihoods per group within folds are used (only available if argument
<code>group</code> is specified).</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_compare">compare</code></td>
<td>
<p>A flag indicating if the information criteria
of the models should be compared to each other
via <code><a href="#topic+loo_compare">loo_compare</a></code>.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_save_fits">save_fits</code></td>
<td>
<p>If <code>TRUE</code>, a component <code>fits</code> is added to
the returned object to store the cross-validated <code>brmsfit</code>
objects and the indices of the omitted observations for each fold.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_recompile">recompile</code></td>
<td>
<p>Logical, indicating whether the Stan model should be
recompiled. This may be necessary if you are running <code>reloo</code> on
another machine than the one used to fit the model.</p>
</td></tr>
<tr><td><code id="kfold.brmsfit_+3A_future_args">future_args</code></td>
<td>
<p>A list of further arguments passed to
<code><a href="future.html#topic+future">future</a></code> for additional control over parallel
execution if activated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>kfold</code> function performs exact <code class="reqn">K</code>-fold
cross-validation. First the data are partitioned into <code class="reqn">K</code> folds
(i.e. subsets) of equal (or as close to equal as possible) size by default.
Then the model is refit <code class="reqn">K</code> times, each time leaving out one of the
<code>K</code> subsets. If <code class="reqn">K</code> is equal to the total number of observations
in the data then <code class="reqn">K</code>-fold cross-validation is equivalent to exact
leave-one-out cross-validation (to which <code>loo</code> is an efficient
approximation). The <code>compare_ic</code> function is also compatible with
the objects returned by <code>kfold</code>.
</p>
<p>The subsets can be constructed in multiple different ways:
</p>

<ul>
<li><p> If both <code>folds</code> and <code>group</code> are <code>NULL</code>, the subsets
are randomly chosen so that they have equal (or as close to equal as
possible) size.
</p>
</li>
<li><p> If <code>folds</code> is <code>NULL</code> but <code>group</code> is specified, the
data is split up into subsets, each time omitting all observations of one
of the factor levels, while ignoring argument <code>K</code>.
</p>
</li>
<li><p> If <code>folds = "stratified"</code> the subsets are stratified after
<code>group</code> using <code><a href="loo.html#topic+kfold-helpers">loo::kfold_split_stratified</a></code>.
</p>
</li>
<li><p> If <code>folds = "grouped"</code> the subsets are split by
<code>group</code> using <code><a href="loo.html#topic+kfold-helpers">loo::kfold_split_grouped</a></code>.
</p>
</li>
<li><p> If <code>folds = "loo"</code> exact leave-one-out cross-validation
will be performed and <code>K</code> will be ignored. Further, if <code>group</code>
is specified, all observations corresponding to the factor level of the
currently predicted single value are omitted. Thus, in this case, the
predicted values are only a subset of the omitted ones.
</p>
</li>
<li><p> If <code>folds</code> is a numeric vector, it must contain one element per
observation in the data. Each element of the vector is an integer in
<code>1:K</code> indicating to which of the <code>K</code> folds the corresponding
observation belongs. There are some convenience functions available in
the <span class="pkg">loo</span> package that create integer vectors to use for this purpose
(see the Examples section below and also the
<a href="loo.html#topic+kfold-helpers">kfold-helpers</a> page).
</p>
</li></ul>

<p>When running <code>kfold</code> on a <code>brmsfit</code> created with the
<span class="pkg">cmdstanr</span> backend in a different <span class="rlang"><b>R</b></span> session, several recompilations
will be triggered because by default, <span class="pkg">cmdstanr</span> writes the model
executable to a temporary directory. To avoid that, set option
<code>"cmdstanr_write_stan_file_dir"</code> to a nontemporary path of your choice
before creating the original <code>brmsfit</code> (see section 'Examples' below).
</p>


<h3>Value</h3>

<p><code>kfold</code> returns an object that has a similar structure as the
objects returned by the <code>loo</code> and <code>waic</code> methods and
can be used with the same post-processing functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loo">loo</a></code>, <code><a href="#topic+reloo">reloo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit1 &lt;- brm(count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
           data = epilepsy, family = poisson())
# throws warning about some pareto k estimates being too high
(loo1 &lt;- loo(fit1))
# perform 10-fold cross validation
(kfold1 &lt;- kfold(fit1, chains = 1))

# use joint likelihoods per fold for ELPD evaluation
kfold(fit1, chains = 1, joint = "fold")

# use the future package for parallelization of models
# that is to fit models belonging to different folds in parallel
library(future)
plan(multisession, workers = 4)
kfold(fit1, chains = 1)
plan(sequential)

## to avoid recompilations when running kfold() on a 'cmdstanr'-backend fit
## in a fresh R session, set option 'cmdstanr_write_stan_file_dir' before
## creating the initial 'brmsfit'
## CAUTION: the following code creates some files in the current working
## directory: two 'model_&lt;hash&gt;.stan' files, one 'model_&lt;hash&gt;(.exe)'
## executable, and one 'fit_cmdstanr_&lt;some_number&gt;.rds' file
set.seed(7)
fname &lt;- paste0("fit_cmdstanr_", sample.int(.Machine$integer.max, 1))
options(cmdstanr_write_stan_file_dir = getwd())
fit_cmdstanr &lt;- brm(rate ~ conc + state, data = Puromycin,
                    backend = "cmdstanr", file = fname)

# now restart the R session and run the following (after attaching 'brms')
set.seed(7)
fname &lt;- paste0("fit_cmdstanr_", sample.int(.Machine$integer.max, 1))
fit_cmdstanr &lt;- brm(rate ~ conc + state,
                    data = Puromycin,
                    backend = "cmdstanr",
                    file = fname)
kfold_cmdstanr &lt;- kfold(fit_cmdstanr, K = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='kidney'>Infections in kidney patients</h2><span id='topic+kidney'></span>

<h3>Description</h3>

<p>This dataset, originally discussed in
McGilchrist and Aisbett (1991), describes the first and second
(possibly right censored) recurrence time of
infection in kidney patients using portable dialysis equipment.
In addition, information on the risk variables age, sex and disease
type is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kidney
</code></pre>


<h3>Format</h3>

<p>A data frame of 76 observations containing
information on the following 7 variables.
</p>

<dl>
<dt>time</dt><dd><p>The time to first or second recurrence of the infection,
or the time of censoring</p>
</dd>
<dt>recur</dt><dd><p>A factor of levels <code>1</code> or <code>2</code>
indicating if the infection recurred for the first
or second time for this patient</p>
</dd>
<dt>censored</dt><dd><p>Either <code>0</code> or <code>1</code>, where <code>0</code> indicates
no censoring of recurrence time and <code>1</code> indicates right censoring</p>
</dd>
<dt>patient</dt><dd><p>The patient number</p>
</dd>
<dt>age</dt><dd><p>The age of the patient</p>
</dd>
<dt>sex</dt><dd><p>The sex of the patient</p>
</dd>
<dt>disease</dt><dd><p>A factor of levels <code>other, GN, AN</code>,
and <code>PKD</code> specifying the type of disease</p>
</dd>
</dl>



<h3>Source</h3>

<p>McGilchrist, C. A., &amp; Aisbett, C. W. (1991).
Regression with frailty in survival analysis.
<em>Biometrics</em>, 47(2), 461-466.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## performing surivival analysis using the "weibull" family
fit1 &lt;- brm(time | cens(censored) ~ age + sex + disease,
            data = kidney, family = weibull, init = "0")
summary(fit1)
plot(fit1)

## adding random intercepts over patients
fit2 &lt;- brm(time | cens(censored) ~ age + sex + disease + (1|patient),
            data = kidney, family = weibull(), init = "0",
            prior = set_prior("cauchy(0,2)", class = "sd"))
summary(fit2)
plot(fit2)

## End(Not run)

</code></pre>

<hr>
<h2 id='lasso'>(Defunct) Set up a lasso prior in <span class="pkg">brms</span></h2><span id='topic+lasso'></span>

<h3>Description</h3>

<p>This functionality is no longer supported as of brms version 2.19.2. Please
use the <code><a href="#topic+horseshoe">horseshoe</a></code> or <code><a href="#topic+R2D2">R2D2</a></code> shrinkage priors instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso(df = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lasso_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the chi-square prior of the inverse tuning
parameter. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="lasso_+3A_scale">scale</code></td>
<td>
<p>Scale of the lasso prior. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An error indicating that the lasso prior is no longer supported.
</p>


<h3>References</h3>

<p>Park, T., &amp; Casella, G. (2008). The Bayesian Lasso. Journal of the American
Statistical Association, 103(482), 681-686.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code>, <code><a href="#topic+horseshoe">horseshoe</a></code>, <code><a href="#topic+R2D2">R2D2</a></code>
</p>

<hr>
<h2 id='launch_shinystan.brmsfit'>Interface to <span class="pkg">shinystan</span></h2><span id='topic+launch_shinystan.brmsfit'></span><span id='topic+launch_shinystan'></span>

<h3>Description</h3>

<p>Provide an interface to <span class="pkg">shinystan</span> for models fitted with <span class="pkg">brms</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launch_shinystan.brmsfit(object, rstudio = getOption("shinystan.rstudio"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launch_shinystan.brmsfit_+3A_object">object</code></td>
<td>
<p>A fitted model object typically of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="launch_shinystan.brmsfit_+3A_rstudio">rstudio</code></td>
<td>
<p>Only relevant for RStudio users.
The default (<code>rstudio=FALSE</code>) is to launch the app
in the default web browser rather than RStudio's pop-up Viewer.
Users can change the default to <code>TRUE</code>
by setting the global option <br /> <code>options(shinystan.rstudio = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="launch_shinystan.brmsfit_+3A_...">...</code></td>
<td>
<p>Optional arguments to pass to <code><a href="shiny.html#topic+runApp">runApp</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 shinystan object
</p>


<h3>See Also</h3>

<p><code><a href="shinystan.html#topic+launch_shinystan">launch_shinystan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(rating ~ treat + period + carry + (1|subject),
           data = inhaler, family = "gaussian")
launch_shinystan(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='log_lik.brmsfit'>Compute the Pointwise Log-Likelihood</h2><span id='topic+log_lik.brmsfit'></span><span id='topic+log_lik'></span><span id='topic+logLik.brmsfit'></span>

<h3>Description</h3>

<p>Compute the Pointwise Log-Likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
log_lik(
  object,
  newdata = NULL,
  re_formula = NULL,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  pointwise = FALSE,
  combine = TRUE,
  add_point_estimate = FALSE,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_lik.brmsfit_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_pointwise">pointwise</code></td>
<td>
<p>A flag indicating whether to compute the full
log-likelihood matrix at once (the default), or just return
the likelihood function along with all data and draws
required to compute the log-likelihood separately for each
observation. The latter option is rarely useful when
calling <code>log_lik</code> directly, but rather when computing
<code><a href="#topic+waic">waic</a></code> or <code><a href="#topic+loo">loo</a></code>.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_combine">combine</code></td>
<td>
<p>Only relevant in multivariate models.
Indicates if the log-likelihoods of the submodels should
be combined per observation (i.e. added together; the default)
or if the log-likelihoods should be returned separately.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_add_point_estimate">add_point_estimate</code></td>
<td>
<p>For internal use only. Ensures compatibility
with the <code><a href="#topic+loo_subsample">loo_subsample</a></code> method.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores (defaults to <code>1</code>). On non-Windows systems,
this argument can be set globally via the <code>mc.cores</code> option.</p>
</td></tr>
<tr><td><code id="log_lik.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NA</code> values within factors in <code>newdata</code>,
are interpreted as if all dummy variables of this factor are
zero. This allows, for instance, to make predictions of the grand mean
when using sum coding.
</p>
<p>In multilevel models, it is possible to
allow new levels of grouping factors to be used in the predictions.
This can be controlled via argument <code>allow_new_levels</code>.
New levels can be sampled in multiple ways, which can be controlled
via argument <code>sample_new_levels</code>. Both of these arguments are
documented in <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> along with several
other useful arguments to control specific aspects of the predictions.
</p>


<h3>Value</h3>

<p>Usually, an S x N matrix containing the pointwise log-likelihood
draws, where S is the number of draws and N is the number
of observations in the data. For multivariate models and if
<code>combine</code> is <code>FALSE</code>, an S x N x R array is returned,
where R is the number of response variables.
If <code>pointwise = TRUE</code>, the output is a function
with a <code>draws</code> attribute containing all relevant
data and posterior draws.
</p>

<hr>
<h2 id='LogisticNormal'>The (Multivariate) Logistic Normal Distribution</h2><span id='topic+LogisticNormal'></span><span id='topic+dlogistic_normal'></span><span id='topic+rlogistic_normal'></span>

<h3>Description</h3>

<p>Density function and random generation for the (multivariate) logistic normal
distribution with latent mean vector <code>mu</code> and covariance matrix <code>Sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlogistic_normal(x, mu, Sigma, refcat = 1, log = FALSE, check = FALSE)

rlogistic_normal(n, mu, Sigma, refcat = 1, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogisticNormal_+3A_x">x</code></td>
<td>
<p>Vector or matrix of quantiles. If <code>x</code> is a matrix,
each row is taken to be a quantile.</p>
</td></tr>
<tr><td><code id="LogisticNormal_+3A_mu">mu</code></td>
<td>
<p>Mean vector with length equal to the number of dimensions.</p>
</td></tr>
<tr><td><code id="LogisticNormal_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="LogisticNormal_+3A_refcat">refcat</code></td>
<td>
<p>A single integer indicating the reference category.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="LogisticNormal_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="LogisticNormal_+3A_check">check</code></td>
<td>
<p>Logical; Indicates whether several input checks
should be performed. Defaults to <code>FALSE</code> to improve
efficiency.</p>
</td></tr>
<tr><td><code id="LogisticNormal_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>

<hr>
<h2 id='logit_scaled'>Scaled logit-link</h2><span id='topic+logit_scaled'></span>

<h3>Description</h3>

<p>Computes <code>logit((x - lb) / (ub - lb))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit_scaled(x, lb = 0, ub = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_scaled_+3A_x">x</code></td>
<td>
<p>A numeric or complex vector.</p>
</td></tr>
<tr><td><code id="logit_scaled_+3A_lb">lb</code></td>
<td>
<p>Lower bound defaulting to <code>0</code>.</p>
</td></tr>
<tr><td><code id="logit_scaled_+3A_ub">ub</code></td>
<td>
<p>Upper bound defaulting to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or complex vector.
</p>

<hr>
<h2 id='logm1'>Logarithm with a minus one offset.</h2><span id='topic+logm1'></span>

<h3>Description</h3>

<p>Computes <code>log(x - 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logm1(x, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logm1_+3A_x">x</code></td>
<td>
<p>A numeric or complex vector.</p>
</td></tr>
<tr><td><code id="logm1_+3A_base">base</code></td>
<td>
<p>A positive or complex number: the base with respect to which
logarithms are computed. Defaults to <em>e</em> = <code>exp(1)</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='loo_compare.brmsfit'>Model comparison with the <span class="pkg">loo</span> package</h2><span id='topic+loo_compare.brmsfit'></span><span id='topic+loo_compare'></span>

<h3>Description</h3>

<p>For more details see <code><a href="loo.html#topic+loo_compare">loo_compare</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
loo_compare(x, ..., criterion = c("loo", "waic", "kfold"), model_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_compare.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="loo_compare.brmsfit_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects.</p>
</td></tr>
<tr><td><code id="loo_compare.brmsfit_+3A_criterion">criterion</code></td>
<td>
<p>The name of the criterion to be extracted
from <code>brmsfit</code> objects.</p>
</td></tr>
<tr><td><code id="loo_compare.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All <code>brmsfit</code> objects should contain precomputed
criterion objects. See <code><a href="#topic+add_criterion">add_criterion</a></code> for more help.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>compare.loo</code>&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with population-level effects only
fit1 &lt;- brm(rating ~ treat + period + carry,
            data = inhaler)
fit1 &lt;- add_criterion(fit1, "waic")

# model with an additional varying intercept for subjects
fit2 &lt;- brm(rating ~ treat + period + carry + (1|subject),
            data = inhaler)
fit2 &lt;- add_criterion(fit2, "waic")

# compare both models
loo_compare(fit1, fit2, criterion = "waic")

## End(Not run)

</code></pre>

<hr>
<h2 id='loo_model_weights.brmsfit'>Model averaging via stacking or pseudo-BMA weighting.</h2><span id='topic+loo_model_weights.brmsfit'></span><span id='topic+loo_model_weights'></span>

<h3>Description</h3>

<p>Compute model weights for <code>brmsfit</code> objects via stacking
or pseudo-BMA weighting. For more details, see
<code><a href="loo.html#topic+loo_model_weights">loo::loo_model_weights</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
loo_model_weights(x, ..., model_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_model_weights.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="loo_model_weights.brmsfit_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects or further arguments
passed to the underlying post-processing functions.
In particular, see <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> for further
supported arguments.</p>
</td></tr>
<tr><td><code id="loo_model_weights.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of model weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with population-level effects only
fit1 &lt;- brm(rating ~ treat + period + carry,
            data = inhaler, family = "gaussian")
# model with an additional varying intercept for subjects
fit2 &lt;- brm(rating ~ treat + period + carry + (1|subject),
            data = inhaler, family = "gaussian")
loo_model_weights(fit1, fit2)

## End(Not run)

</code></pre>

<hr>
<h2 id='loo_moment_match.brmsfit'>Moment matching for efficient approximate leave-one-out cross-validation</h2><span id='topic+loo_moment_match.brmsfit'></span><span id='topic+loo_moment_match'></span>

<h3>Description</h3>

<p>Moment matching for efficient approximate leave-one-out cross-validation
(LOO-CV). See <code><a href="loo.html#topic+loo_moment_match">loo_moment_match</a></code>
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
loo_moment_match(
  x,
  loo,
  k_threshold = 0.7,
  newdata = NULL,
  resp = NULL,
  check = TRUE,
  recompile = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_moment_match.brmsfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="loo_moment_match.brmsfit_+3A_loo">loo</code></td>
<td>
<p>An object of class <code>loo</code> originally created from <code>x</code>.</p>
</td></tr>
<tr><td><code id="loo_moment_match.brmsfit_+3A_k_threshold">k_threshold</code></td>
<td>
<p>The Pareto <code class="reqn">k</code> threshold for which observations
moment matching is applied. Defaults to <code>0.7</code>.
See <code><a href="loo.html#topic+pareto-k-diagnostic">pareto_k_ids</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="loo_moment_match.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="loo_moment_match.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="loo_moment_match.brmsfit_+3A_check">check</code></td>
<td>
<p>Logical; If <code>TRUE</code> (the default), some checks
check are performed if the <code>loo</code> object was generated
from the <code>brmsfit</code> object passed to argument <code>fit</code>.</p>
</td></tr>
<tr><td><code id="loo_moment_match.brmsfit_+3A_recompile">recompile</code></td>
<td>
<p>Logical, indicating whether the Stan model should be
recompiled. This may be necessary if you are running moment matching on
another machine than the one used to fit the model. No recompilation
is done by default.</p>
</td></tr>
<tr><td><code id="loo_moment_match.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying methods.
Additional arguments initially passed to <code><a href="#topic+loo">loo</a></code>,
for example, <code>newdata</code> or <code>resp</code> need to be passed
again to <code>loo_moment_match</code> in order for the latter
to work correctly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The moment matching algorithm requires draws of all variables
defined in Stan's <code>parameters</code> block to be saved. Otherwise
<code>loo_moment_match</code> cannot be computed. Thus, please set
<code>save_pars = save_pars(all = TRUE)</code> in the call to <code><a href="#topic+brm">brm</a></code>,
if you are planning to apply <code>loo_moment_match</code> to your models.
</p>


<h3>Value</h3>

<p>An updated object of class <code>loo</code>.
</p>


<h3>References</h3>

<p>Paananen, T., Piironen, J., Buerkner, P.-C., Vehtari, A. (2021).
Implicitly Adaptive Importance Sampling. Statistics and Computing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit1 &lt;- brm(count ~ zAge + zBase * Trt + (1|patient),
            data = epilepsy, family = poisson(),
            save_pars = save_pars(all = TRUE))

# throws warning about some pareto k estimates being too high
(loo1 &lt;- loo(fit1))
(mmloo1 &lt;- loo_moment_match(fit1, loo = loo1))

## End(Not run)

</code></pre>

<hr>
<h2 id='loo_predict.brmsfit'>Compute Weighted Expectations Using LOO</h2><span id='topic+loo_predict.brmsfit'></span><span id='topic+loo_predict'></span><span id='topic+loo_linpred'></span><span id='topic+loo_predictive_interval'></span><span id='topic+loo_linpred.brmsfit'></span><span id='topic+loo_predictive_interval.brmsfit'></span>

<h3>Description</h3>

<p>These functions are wrappers around the <code><a href="loo.html#topic+E_loo">E_loo</a></code>
function of the <span class="pkg">loo</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
loo_predict(
  object,
  type = c("mean", "var", "quantile"),
  probs = 0.5,
  psis_object = NULL,
  resp = NULL,
  ...
)

## S3 method for class 'brmsfit'
loo_linpred(
  object,
  type = c("mean", "var", "quantile"),
  probs = 0.5,
  psis_object = NULL,
  resp = NULL,
  ...
)

## S3 method for class 'brmsfit'
loo_predictive_interval(object, prob = 0.9, psis_object = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_predict.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="loo_predict.brmsfit_+3A_type">type</code></td>
<td>
<p>The statistic to be computed on the results.
Can by either <code>"mean"</code> (default), <code>"var"</code>, or
<code>"quantile"</code>.</p>
</td></tr>
<tr><td><code id="loo_predict.brmsfit_+3A_probs">probs</code></td>
<td>
<p>A vector of quantiles to compute.
Only used if <code>type = quantile</code>.</p>
</td></tr>
<tr><td><code id="loo_predict.brmsfit_+3A_psis_object">psis_object</code></td>
<td>
<p>An optional object returned by <code><a href="loo.html#topic+psis">psis</a></code>.
If <code>psis_object</code> is missing then <code><a href="loo.html#topic+psis">psis</a></code> is executed
internally, which may be time consuming for models fit to very large datasets.</p>
</td></tr>
<tr><td><code id="loo_predict.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="loo_predict.brmsfit_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to the underlying methods that is
<code><a href="#topic+log_lik.brmsfit">log_lik</a></code>, as well as
<code><a href="#topic+posterior_predict.brmsfit">posterior_predict</a></code> or
<code><a href="#topic+posterior_linpred.brmsfit">posterior_linpred</a></code>.</p>
</td></tr>
<tr><td><code id="loo_predict.brmsfit_+3A_prob">prob</code></td>
<td>
<p>For <code>loo_predictive_interval</code>, a scalar in <code class="reqn">(0,1)</code>
indicating the desired probability mass to include in the intervals. The
default is <code>prob = 0.9</code> (<code class="reqn">90</code>% intervals).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>loo_predict</code> and <code>loo_linpred</code> return a vector with one
element per observation. The only exception is if <code>type = "quantile"</code>
and <code>length(probs) &gt;= 2</code>, in which case a separate vector for each
element of <code>probs</code> is computed and they are returned in a matrix with
<code>length(probs)</code> rows and one column per observation.
</p>
<p><code>loo_predictive_interval</code> returns a matrix with one row per
observation and two columns.
<code>loo_predictive_interval(..., prob = p)</code> is equivalent to
<code>loo_predict(..., type = "quantile", probs = c(a, 1-a))</code> with
<code>a = (1 - p)/2</code>, except it transposes the result and adds informative
column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## data from help("lm")
ctl &lt;- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt &lt;- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
d &lt;- data.frame(
  weight = c(ctl, trt),
  group = gl(2, 10, 20, labels = c("Ctl", "Trt"))
)
fit &lt;- brm(weight ~ group, data = d)
loo_predictive_interval(fit, prob = 0.8)

## optionally log-weights can be pre-computed and reused
psis &lt;- loo::psis(-log_lik(fit), cores = 2)
loo_predictive_interval(fit, prob = 0.8, psis_object = psis)
loo_predict(fit, type = "var", psis_object = psis)

## End(Not run)

</code></pre>

<hr>
<h2 id='loo_R2.brmsfit'>Compute a LOO-adjusted R-squared for regression models</h2><span id='topic+loo_R2.brmsfit'></span><span id='topic+loo_R2'></span>

<h3>Description</h3>

<p>Compute a LOO-adjusted R-squared for regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
loo_R2(
  object,
  resp = NULL,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_R2.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="loo_R2.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="loo_R2.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="loo_R2.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="loo_R2.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="loo_R2.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="#topic+posterior_epred.brmsfit">posterior_epred</a></code> and
<code><a href="#topic+log_lik.brmsfit">log_lik</a></code>,
which are used in the computation of the R-squared values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>summary = TRUE</code>, an M x C matrix is returned
(M = number of response variables and c = <code>length(probs) + 2</code>)
containing summary statistics of the LOO-adjusted R-squared values.
If <code>summary = FALSE</code>, the posterior draws of the LOO-adjusted
R-squared values are returned in an S x M matrix (S is the number of draws).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(mpg ~ wt + cyl, data = mtcars)
summary(fit)
loo_R2(fit)

# compute R2 with new data
nd &lt;- data.frame(mpg = c(10, 20, 30), wt = c(4, 3, 2), cyl = c(8, 6, 4))
loo_R2(fit, newdata = nd)

## End(Not run)

</code></pre>

<hr>
<h2 id='loo_subsample.brmsfit'>Efficient approximate leave-one-out cross-validation (LOO) using subsampling</h2><span id='topic+loo_subsample.brmsfit'></span><span id='topic+loo_subsample'></span>

<h3>Description</h3>

<p>Efficient approximate leave-one-out cross-validation (LOO) using subsampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
loo_subsample(x, ..., compare = TRUE, resp = NULL, model_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_subsample.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="loo_subsample.brmsfit_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects or further arguments
passed to the underlying post-processing functions.
In particular, see <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> for further
supported arguments.</p>
</td></tr>
<tr><td><code id="loo_subsample.brmsfit_+3A_compare">compare</code></td>
<td>
<p>A flag indicating if the information criteria
of the models should be compared to each other
via <code><a href="#topic+loo_compare">loo_compare</a></code>.</p>
</td></tr>
<tr><td><code id="loo_subsample.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="loo_subsample.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details can be found on
<code><a href="loo.html#topic+loo_subsample">loo_subsample</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with population-level effects only
fit1 &lt;- brm(rating ~ treat + period + carry,
            data = inhaler)
(loo1 &lt;- loo_subsample(fit1))

# model with an additional varying intercept for subjects
fit2 &lt;- brm(rating ~ treat + period + carry + (1|subject),
            data = inhaler)
(loo2 &lt;- loo_subsample(fit2))

# compare both models
loo_compare(loo1, loo2)

## End(Not run)

</code></pre>

<hr>
<h2 id='loo.brmsfit'>Efficient approximate leave-one-out cross-validation (LOO)</h2><span id='topic+loo.brmsfit'></span><span id='topic+loo'></span><span id='topic+LOO'></span><span id='topic+LOO.brmsfit'></span>

<h3>Description</h3>

<p>Perform approximate leave-one-out cross-validation based
on the posterior likelihood using the <span class="pkg">loo</span> package.
For more details see <code><a href="loo.html#topic+loo">loo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
loo(
  x,
  ...,
  compare = TRUE,
  resp = NULL,
  pointwise = FALSE,
  moment_match = FALSE,
  reloo = FALSE,
  k_threshold = 0.7,
  save_psis = FALSE,
  moment_match_args = list(),
  reloo_args = list(),
  model_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects or further arguments
passed to the underlying post-processing functions.
In particular, see <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> for further
supported arguments.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_compare">compare</code></td>
<td>
<p>A flag indicating if the information criteria
of the models should be compared to each other
via <code><a href="#topic+loo_compare">loo_compare</a></code>.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_pointwise">pointwise</code></td>
<td>
<p>A flag indicating whether to compute the full
log-likelihood matrix at once or separately for each observation.
The latter approach is usually considerably slower but
requires much less working memory. Accordingly, if one runs
into memory issues, <code>pointwise = TRUE</code> is the way to go.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_moment_match">moment_match</code></td>
<td>
<p>Logical; Indicate whether <code><a href="#topic+loo_moment_match">loo_moment_match</a></code>
should be applied on problematic observations. Defaults to <code>FALSE</code>.
For most models, moment matching will only work if you have set
<code>save_pars = save_pars(all = TRUE)</code> when fitting the model with
<code><a href="#topic+brm">brm</a></code>. See <code><a href="#topic+loo_moment_match.brmsfit">loo_moment_match.brmsfit</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_reloo">reloo</code></td>
<td>
<p>Logical; Indicate whether <code><a href="#topic+reloo">reloo</a></code>
should be applied on problematic observations. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_k_threshold">k_threshold</code></td>
<td>
<p>The Pareto <code class="reqn">k</code> threshold for which observations
<code><a href="#topic+loo_moment_match">loo_moment_match</a></code> or <code><a href="#topic+reloo">reloo</a></code> is applied if
argument <code>moment_match</code> or <code>reloo</code> is <code>TRUE</code>.
Defaults to <code>0.7</code>.
See <code><a href="loo.html#topic+pareto-k-diagnostic">pareto_k_ids</a></code> for more details.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_save_psis">save_psis</code></td>
<td>
<p>Should the <code>"psis"</code> object created internally be saved
in the returned object? For more details see <code><a href="loo.html#topic+loo">loo</a></code>.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_moment_match_args">moment_match_args</code></td>
<td>
<p>Optional <code>list</code> of additional arguments passed to
<code><a href="#topic+loo_moment_match">loo_moment_match</a></code>.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_reloo_args">reloo_args</code></td>
<td>
<p>Optional <code>list</code> of additional arguments passed to
<code><a href="#topic+reloo">reloo</a></code>.</p>
</td></tr>
<tr><td><code id="loo.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+loo_compare">loo_compare</a></code> for details on model comparisons.
For <code>brmsfit</code> objects, <code>LOO</code> is an alias of <code>loo</code>.
Use method <code><a href="#topic+add_criterion">add_criterion</a></code> to store
information criteria in the fitted model object for later usage.
</p>


<h3>Value</h3>

<p>If just one object is provided, an object of class <code>loo</code>.
If multiple objects are provided, an object of class <code>loolist</code>.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., &amp; Gabry J. (2016). Practical Bayesian model
evaluation using leave-one-out cross-validation and WAIC. In Statistics
and Computing, doi:10.1007/s11222-016-9696-4. arXiv preprint arXiv:1507.04544.
</p>
<p>Gelman, A., Hwang, J., &amp; Vehtari, A. (2014).
Understanding predictive information criteria for Bayesian models.
Statistics and Computing, 24, 997-1016.
</p>
<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation
and widely applicable information criterion in singular learning theory.
The Journal of Machine Learning Research, 11, 3571-3594.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with population-level effects only
fit1 &lt;- brm(rating ~ treat + period + carry,
            data = inhaler)
(loo1 &lt;- loo(fit1))

# model with an additional varying intercept for subjects
fit2 &lt;- brm(rating ~ treat + period + carry + (1|subject),
            data = inhaler)
(loo2 &lt;- loo(fit2))

# compare both models
loo_compare(loo1, loo2)

## End(Not run)

</code></pre>

<hr>
<h2 id='loss'>Cumulative Insurance Loss Payments</h2><span id='topic+loss'></span>

<h3>Description</h3>

<p>This dataset, discussed in Gesmann &amp; Morris (2020), contains
cumulative insurance loss payments over the course of ten years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss
</code></pre>


<h3>Format</h3>

<p>A data frame of 55 observations containing information
on the following 4 variables.
</p>

<dl>
<dt>AY</dt><dd><p>Origin year of the insurance (1991 to 2000)</p>
</dd>
<dt>dev</dt><dd><p>Deviation from the origin year in months</p>
</dd>
<dt>cum</dt><dd><p>Cumulative loss payments</p>
</dd>
<dt>premium</dt><dd><p>Achieved premiums for the given origin year</p>
</dd>
</dl>



<h3>Source</h3>

<p>Gesmann M. &amp; Morris J. (2020). Hierarchical Compartmental Reserving
Models. <em>CAS Research Papers</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# non-linear model to predict cumulative loss payments
fit_loss &lt;- brm(
  bf(cum ~ ult * (1 - exp(-(dev/theta)^omega)),
     ult ~ 1 + (1|AY), omega ~ 1, theta ~ 1,
     nl = TRUE),
  data = loss, family = gaussian(),
  prior = c(
    prior(normal(5000, 1000), nlpar = "ult"),
    prior(normal(1, 2), nlpar = "omega"),
    prior(normal(45, 10), nlpar = "theta")
  ),
  control = list(adapt_delta = 0.9)
)

# basic summaries
summary(fit_loss)
conditional_effects(fit_loss)

# plot predictions per origin year
conditions &lt;- data.frame(AY = unique(loss$AY))
rownames(conditions) &lt;- unique(loss$AY)
me_loss &lt;- conditional_effects(
  fit_loss, conditions = conditions,
  re_formula = NULL, method = "predict"
)
plot(me_loss, ncol = 5, points = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='ma'>Set up MA(q) correlation structures</h2><span id='topic+ma'></span>

<h3>Description</h3>

<p>Set up a moving average (MA) term of order q in <span class="pkg">brms</span>. The function does
not evaluate its arguments &ndash; it exists purely to help set up a model with
MA terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma(time = NA, gr = NA, q = 1, cov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma_+3A_time">time</code></td>
<td>
<p>An optional time variable specifying the time ordering
of the observations. By default, the existing order of the observations
in the data is used.</p>
</td></tr>
<tr><td><code id="ma_+3A_gr">gr</code></td>
<td>
<p>An optional grouping variable. If specified, the correlation
structure is assumed to apply only to observations within the same grouping
level.</p>
</td></tr>
<tr><td><code id="ma_+3A_q">q</code></td>
<td>
<p>A non-negative integer specifying the moving average (MA)
order of the ARMA structure. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ma_+3A_cov">cov</code></td>
<td>
<p>A flag indicating whether ARMA effects should be estimated by
means of residual covariance matrices. This is currently only possible for
stationary ARMA effects of order 1. If the model family does not have
natural residuals, latent residuals are added automatically. If
<code>FALSE</code> (the default), a regression formulation is used that is
considerably faster and allows for ARMA effects of order higher than 1 but
is only available for <code>gaussian</code> models and some of its
generalizations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>'arma_term'</code>, which is a list
of arguments to be interpreted by the formula
parsing functions of <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocor-terms">autocor-terms</a></code>, <code><a href="#topic+arma">arma</a></code>, <code><a href="#topic+ar">ar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("LakeHuron")
LakeHuron &lt;- as.data.frame(LakeHuron)
fit &lt;- brm(x ~ ma(p = 2), data = LakeHuron)
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='make_conditions'>Prepare Fully Crossed Conditions</h2><span id='topic+make_conditions'></span>

<h3>Description</h3>

<p>This is a helper function to prepare fully crossed conditions primarily
for use with the <code>conditions</code> argument of <code><a href="#topic+conditional_effects">conditional_effects</a></code>.
Automatically creates labels for each row in the <code>cond__</code> column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_conditions(x, vars, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_conditions_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object from which to extract the variables
that should be part of the conditions.</p>
</td></tr>
<tr><td><code id="make_conditions_+3A_vars">vars</code></td>
<td>
<p>Names of the variables that should be part of the conditions.</p>
</td></tr>
<tr><td><code id="make_conditions_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+rows2labels">rows2labels</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For factor like variables, all levels are used as conditions.
For numeric variables, <code>mean + (-1:1) * SD</code> are used as conditions.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> where each row indicates a condition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditional_effects">conditional_effects</a></code>, <code><a href="#topic+rows2labels">rows2labels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c("a", "b"), y = rnorm(10))
make_conditions(df, vars = c("x", "y"))

</code></pre>

<hr>
<h2 id='mcmc_plot.brmsfit'>MCMC Plots Implemented in <span class="pkg">bayesplot</span></h2><span id='topic+mcmc_plot.brmsfit'></span><span id='topic+stanplot'></span><span id='topic+stanplot.brmsfit'></span><span id='topic+mcmc_plot'></span>

<h3>Description</h3>

<p>Convenient way to call MCMC plotting functions
implemented in the <span class="pkg">bayesplot</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
mcmc_plot(
  object,
  pars = NA,
  type = "intervals",
  variable = NULL,
  regex = FALSE,
  fixed = FALSE,
  ...
)

mcmc_plot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_plot.brmsfit_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object typically of class <code>brmsfit</code></p>
</td></tr>
<tr><td><code id="mcmc_plot.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Deprecated alias of <code>variable</code>.
Names of the parameters to plot, as given by a
character vector or a regular expression.</p>
</td></tr>
<tr><td><code id="mcmc_plot.brmsfit_+3A_type">type</code></td>
<td>
<p>The type of the plot.
Supported types are (as names) <code>hist</code>, <code>dens</code>,
<code>hist_by_chain</code>, <code>dens_overlay</code>,
<code>violin</code>, <code>intervals</code>, <code>areas</code>, <code>acf</code>,
<code>acf_bar</code>,<code>trace</code>, <code>trace_highlight</code>, <code>scatter</code>,
<code>rhat</code>, <code>rhat_hist</code>, <code>neff</code>, <code>neff_hist</code>
<code>nuts_acceptance</code>, <code>nuts_divergence</code>,
<code>nuts_stepsize</code>, <code>nuts_treedepth</code>, and <code>nuts_energy</code>.
For an overview on the various plot types see
<code><a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc_plot.brmsfit_+3A_variable">variable</code></td>
<td>
<p>Names of the variables (parameters) to plot, as given by a
character vector or a regular expression (if <code>regex = TRUE</code>). By
default, a hopefully not too large selection of variables is plotted.</p>
</td></tr>
<tr><td><code id="mcmc_plot.brmsfit_+3A_regex">regex</code></td>
<td>
<p>Logical; Indicates whether <code>variable</code> should
be treated as regular expressions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mcmc_plot.brmsfit_+3A_fixed">fixed</code></td>
<td>
<p>(Deprecated) Indicates whether parameter names
should be matched exactly (<code>TRUE</code>) or treated as
regular expressions (<code>FALSE</code>). Default is <code>FALSE</code>
and only works with argument <code>pars</code>.</p>
</td></tr>
<tr><td><code id="mcmc_plot.brmsfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plotting functions.
See <code><a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a></code> for
more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Also consider using the <span class="pkg">shinystan</span> package available via
method <code><a href="#topic+launch_shinystan">launch_shinystan</a></code> in <span class="pkg">brms</span> for flexible
and interactive visual analysis.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
that can be further customized using the <span class="pkg">ggplot2</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model &lt;- brm(count ~ zAge + zBase * Trt + (1|patient),
             data = epilepsy, family = "poisson")

# plot posterior intervals
mcmc_plot(model)

# only show population-level effects in the plots
mcmc_plot(model, variable = "^b_", regex = TRUE)

# show histograms of the posterior distributions
mcmc_plot(model, type = "hist")

# plot some diagnostics of the sampler
mcmc_plot(model, type = "neff")
mcmc_plot(model, type = "rhat")

# plot some diagnostics specific to the NUTS sampler
mcmc_plot(model, type = "nuts_acceptance")
mcmc_plot(model, type = "nuts_divergence")

## End(Not run)

</code></pre>

<hr>
<h2 id='me'>Predictors with Measurement Error in <span class="pkg">brms</span> Models</h2><span id='topic+me'></span>

<h3>Description</h3>

<p>(Soft deprecated) Specify predictors with measurement error. The function
does not evaluate its arguments &ndash; it exists purely to help set up a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>me(x, sdx, gr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="me_+3A_x">x</code></td>
<td>
<p>The variable measured with error.</p>
</td></tr>
<tr><td><code id="me_+3A_sdx">sdx</code></td>
<td>
<p>Known measurement error of <code>x</code>
treated as standard deviation.</p>
</td></tr>
<tr><td><code id="me_+3A_gr">gr</code></td>
<td>
<p>Optional grouping factor to specify which
values of <code>x</code> correspond to the same value of the
latent variable. If <code>NULL</code> (the default) each
observation will have its own value of the latent variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For detailed documentation see <code>help(brmsformula)</code>.
<code>me</code> terms are soft deprecated in favor of the more
general and consistent <code><a href="#topic+mi">mi</a></code> terms.
By default, latent noise-free variables are assumed
to be correlated. To change that, add <code>set_mecor(FALSE)</code>
to your model formula object (see examples).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>, <code><a href="#topic+brmsformula-helpers">brmsformula-helpers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# sample some data
N &lt;- 100
dat &lt;- data.frame(
  y = rnorm(N), x1 = rnorm(N),
  x2 = rnorm(N), sdx = abs(rnorm(N, 1))
 )
# fit a simple error-in-variables model
fit1 &lt;- brm(y ~ me(x1, sdx) + me(x2, sdx), data = dat,
            save_pars = save_pars(latent = TRUE))
summary(fit1)

# turn off modeling of correlations
bform &lt;- bf(y ~ me(x1, sdx) + me(x2, sdx)) + set_mecor(FALSE)
fit2 &lt;- brm(bform, data = dat, save_pars = save_pars(latent = TRUE))
summary(fit2)

## End(Not run)

</code></pre>

<hr>
<h2 id='mi'>Predictors with Missing Values in <span class="pkg">brms</span> Models</h2><span id='topic+mi'></span>

<h3>Description</h3>

<p>Specify predictor term with missing values in <span class="pkg">brms</span>. The function does
not evaluate its arguments &ndash; it exists purely to help set up a model.
For documentation on how to specify missing values in response variables,
see <code><a href="#topic+resp_mi">resp_mi</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi(x, idx = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi_+3A_x">x</code></td>
<td>
<p>The variable containing missing values.</p>
</td></tr>
<tr><td><code id="mi_+3A_idx">idx</code></td>
<td>
<p>An optional variable containing indices of observations in 'x'
that are to be used in the model. This is mostly relevant in partially
subsetted models (via <code>resp_subset</code>) but may also have other
applications that I haven't thought of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For detailed documentation see <code>help(brmsformula)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("nhanes", package = "mice")
N &lt;- nrow(nhanes)

# simple model with missing data
bform1 &lt;- bf(bmi | mi() ~ age * mi(chl)) +
  bf(chl | mi() ~ age) +
  set_rescor(FALSE)

fit1 &lt;- brm(bform1, data = nhanes)

summary(fit1)
plot(conditional_effects(fit1, resp = "bmi"), ask = FALSE)
loo(fit1, newdata = na.omit(fit1$data))

# simulate some measurement noise
nhanes$se &lt;- rexp(N, 2)

# measurement noise can be handled within 'mi' terms
# with or without the presence of missing values
bform2 &lt;- bf(bmi | mi() ~ age * mi(chl)) +
  bf(chl | mi(se) ~ age) +
  set_rescor(FALSE)

fit2 &lt;- brm(bform2, data = nhanes)

summary(fit2)
plot(conditional_effects(fit2, resp = "bmi"), ask = FALSE)

# 'mi' terms can also be used when some responses are subsetted
nhanes$sub &lt;- TRUE
nhanes$sub[1:2] &lt;- FALSE
nhanes$id &lt;- 1:N
nhanes$idx &lt;- sample(3:N, N, TRUE)

# this requires the addition term 'index' being specified
# in the subsetted part of the model
bform3 &lt;- bf(bmi | mi() ~ age * mi(chl, idx)) +
  bf(chl | mi(se) + subset(sub) + index(id) ~ age) +
  set_rescor(FALSE)

fit3 &lt;- brm(bform3, data = nhanes)

summary(fit3)
plot(conditional_effects(fit3, resp = "bmi"), ask = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='mixture'>Finite Mixture Families in <span class="pkg">brms</span></h2><span id='topic+mixture'></span>

<h3>Description</h3>

<p>Set up a finite mixture family for use in <span class="pkg">brms</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture(..., flist = NULL, nmix = 1, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixture_+3A_...">...</code></td>
<td>
<p>One or more objects providing a description of the
response distributions to be combined in the mixture model.
These can be family functions, calls to family functions or
character strings naming the families. For details of supported
families see <code><a href="#topic+brmsfamily">brmsfamily</a></code>.</p>
</td></tr>
<tr><td><code id="mixture_+3A_flist">flist</code></td>
<td>
<p>Optional list of objects, which are treated in the
same way as objects passed via the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="mixture_+3A_nmix">nmix</code></td>
<td>
<p>Optional numeric vector specifying the number of times
each family is repeated. If specified, it must have the same length
as the number of families passed via <code>...</code> and <code>flist</code>.</p>
</td></tr>
<tr><td><code id="mixture_+3A_order">order</code></td>
<td>
<p>Ordering constraint to identify mixture components.
If <code>'mu'</code> or <code>TRUE</code>, population-level intercepts
of the mean parameters are ordered in non-ordinal models
and fixed to the same value in ordinal models (see details).
If <code>'none'</code> or <code>FALSE</code>, no ordering constraint is applied.
If <code>NULL</code> (the default), <code>order</code> is set to <code>'mu'</code>
if all families are the same and <code>'none'</code> otherwise.
Other ordering constraints may be implemented in the future.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most families supported by <span class="pkg">brms</span> can be used to form mixtures. The
response variable has to be valid for all components of the mixture family.
Currently, the number of mixture components has to be specified by the user.
It is not yet possible to estimate the number of mixture components from the
data.
</p>
<p>Ordering intercepts in mixtures of ordinal families is not possible as each
family has itself a set of vector of intercepts (i.e. ordinal thresholds).
Instead, <span class="pkg">brms</span> will fix the vector of intercepts across components in
ordinal mixtures, if desired, so that users can try to identify the mixture
model via selective inclusion of predictors.
</p>
<p>For most mixture models, you may want to specify priors on the
population-level intercepts via <code><a href="#topic+set_prior">set_prior</a></code> to improve
convergence. In addition, it is sometimes necessary to set <code>init = 0</code>
in the call to <code><a href="#topic+brm">brm</a></code> to allow chains to initialize properly.
</p>
<p>For more details on the specification of mixture
models, see <code><a href="#topic+brmsformula">brmsformula</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>mixfamily</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simulate some data
set.seed(1234)
dat &lt;- data.frame(
  y = c(rnorm(200), rnorm(100, 6)),
  x = rnorm(300),
  z = sample(0:1, 300, TRUE)
)

## fit a simple normal mixture model
mix &lt;- mixture(gaussian, gaussian)
prior &lt;- c(
  prior(normal(0, 7), Intercept, dpar = mu1),
  prior(normal(5, 7), Intercept, dpar = mu2)
)
fit1 &lt;- brm(bf(y ~ x + z), dat, family = mix,
            prior = prior, chains = 2)
summary(fit1)
pp_check(fit1)

## use different predictors for the components
fit2 &lt;- brm(bf(y ~ 1, mu1 ~ x, mu2 ~ z), dat, family = mix,
            prior = prior, chains = 2)
summary(fit2)

## fix the mixing proportions
fit3 &lt;- brm(bf(y ~ x + z, theta1 = 1, theta2 = 2),
            dat, family = mix, prior = prior,
            init = 0, chains = 2)
summary(fit3)
pp_check(fit3)

## predict the mixing proportions
fit4 &lt;- brm(bf(y ~ x + z, theta2 ~ x),
            dat, family = mix, prior = prior,
            init = 0, chains = 2)
summary(fit4)
pp_check(fit4)

## compare model fit
loo(fit1, fit2, fit3, fit4)

## End(Not run)

</code></pre>

<hr>
<h2 id='mm'>Set up multi-membership grouping terms in <span class="pkg">brms</span></h2><span id='topic+mm'></span>

<h3>Description</h3>

<p>Function to set up a multi-membership grouping term in <span class="pkg">brms</span>.
The function does not evaluate its arguments &ndash;
it exists purely to help set up a model with grouping terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mm(
  ...,
  weights = NULL,
  scale = TRUE,
  by = NULL,
  cor = TRUE,
  id = NA,
  cov = NULL,
  dist = "gaussian"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mm_+3A_...">...</code></td>
<td>
<p>One or more terms containing grouping factors.</p>
</td></tr>
<tr><td><code id="mm_+3A_weights">weights</code></td>
<td>
<p>A matrix specifying the weights of each member.
It should have as many columns as grouping terms specified in <code>...</code>.
If <code>NULL</code> (the default), equally weights are used.</p>
</td></tr>
<tr><td><code id="mm_+3A_scale">scale</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default),
weights are standardized in order to sum to one per row.
If negative weights are specified, <code>scale</code> needs
to be set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mm_+3A_by">by</code></td>
<td>
<p>An optional factor matrix, specifying sub-populations of the
groups. It should have as many columns as grouping terms specified in
<code>...</code>. For each level of the <code>by</code> variable, a separate
variance-covariance matrix will be fitted. Levels of the grouping factor
must be nested in levels of the <code>by</code> variable matrix.</p>
</td></tr>
<tr><td><code id="mm_+3A_cor">cor</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), group-level terms will be
modelled as correlated.</p>
</td></tr>
<tr><td><code id="mm_+3A_id">id</code></td>
<td>
<p>Optional character string. All group-level terms across the model
with the same <code>id</code> will be modeled as correlated (if <code>cor</code> is
<code>TRUE</code>). See <code><a href="#topic+brmsformula">brmsformula</a></code> for more details.</p>
</td></tr>
<tr><td><code id="mm_+3A_cov">cov</code></td>
<td>
<p>An optional matrix which is proportional to the withon-group
covariance matrix of the group-level effects. All levels of the grouping
factor should appear as rownames of the corresponding matrix. This argument
can be used, among others, to model pedigrees and phylogenetic effects. See
<code>vignette("brms_phylogenetics")</code> for more details. By default, levels
of the same grouping factor are modeled as independent of each other.</p>
</td></tr>
<tr><td><code id="mm_+3A_dist">dist</code></td>
<td>
<p>Name of the distribution of the group-level effects.
Currently <code>"gaussian"</code> is the only option.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>, <code><a href="#topic+mmc">mmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate some data
dat &lt;- data.frame(
 y = rnorm(100), x1 = rnorm(100), x2 = rnorm(100),
 g1 = sample(1:10, 100, TRUE), g2 = sample(1:10, 100, TRUE)
)

# multi-membership model with two members per group and equal weights
fit1 &lt;- brm(y ~ x1 + (1|mm(g1, g2)), data = dat)
summary(fit1)

# weight the first member two times for than the second member
dat$w1 &lt;- rep(2, 100)
dat$w2 &lt;- rep(1, 100)
fit2 &lt;- brm(y ~ x1 + (1|mm(g1, g2, weights = cbind(w1, w2))), data = dat)
summary(fit2)

# multi-membership model with level specific covariate values
dat$xc &lt;- (dat$x1 + dat$x2) / 2
fit3 &lt;- brm(y ~ xc + (1 + mmc(x1, x2) | mm(g1, g2)), data = dat)
summary(fit3)

## End(Not run)

</code></pre>

<hr>
<h2 id='mmc'>Multi-Membership Covariates</h2><span id='topic+mmc'></span>

<h3>Description</h3>

<p>Specify covariates that vary over different levels
of multi-membership grouping factors thus requiring
special treatment. This function is almost solely useful,
when called in combination with <code><a href="#topic+mm">mm</a></code>.
Outside of multi-membership terms it will behave
very much like <code><a href="base.html#topic+cbind">cbind</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmc(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmc_+3A_...">...</code></td>
<td>
<p>One or more terms containing covariates
corresponding to the grouping levels specified in <code><a href="#topic+mm">mm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with covariates as columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mm">mm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate some data
dat &lt;- data.frame(
  y = rnorm(100), x1 = rnorm(100), x2 = rnorm(100),
  g1 = sample(1:10, 100, TRUE), g2 = sample(1:10, 100, TRUE)
)

# multi-membership model with level specific covariate values
dat$xc &lt;- (dat$x1 + dat$x2) / 2
fit &lt;- brm(y ~ xc + (1 + mmc(x1, x2) | mm(g1, g2)), data = dat)
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='mo'>Monotonic Predictors in <span class="pkg">brms</span> Models</h2><span id='topic+mo'></span>

<h3>Description</h3>

<p>Specify a monotonic predictor term in <span class="pkg">brms</span>. The function does not
evaluate its arguments &ndash; it exists purely to help set up a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mo(x, id = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mo_+3A_x">x</code></td>
<td>
<p>An integer variable or an ordered factor to be modeled as monotonic.</p>
</td></tr>
<tr><td><code id="mo_+3A_id">id</code></td>
<td>
<p>Optional character string. All monotonic terms
with the same <code>id</code> within one formula will be modeled as
having the same simplex (shape) parameter vector. If all monotonic terms
of the same predictor have the same <code>id</code>, the resulting
predictions will be conditionally monotonic for all values of
interacting covariates (Bürkner &amp; Charpentier, 2020).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Bürkner and Charpentier (2020) for the underlying theory. For
detailed documentation of the formula syntax used for monotonic terms,
see <code>help(brmsformula)</code> as well as <code>vignette("brms_monotonic")</code>.
</p>


<h3>References</h3>

<p>Bürkner P. C. &amp; Charpentier E. (2020). Modeling Monotonic Effects of Ordinal
Predictors in Regression Models. British Journal of Mathematical and
Statistical Psychology. doi:10.1111/bmsp.12195
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate some data
income_options &lt;- c("below_20", "20_to_40", "40_to_100", "greater_100")
income &lt;- factor(sample(income_options, 100, TRUE),
                 levels = income_options, ordered = TRUE)
mean_ls &lt;- c(30, 60, 70, 75)
ls &lt;- mean_ls[income] + rnorm(100, sd = 7)
dat &lt;- data.frame(income, ls)

# fit a simple monotonic model
fit1 &lt;- brm(ls ~ mo(income), data = dat)
summary(fit1)
plot(fit1, N = 6)
plot(conditional_effects(fit1), points = TRUE)

# model interaction with other variables
dat$x &lt;- sample(c("a", "b", "c"), 100, TRUE)
fit2 &lt;- brm(ls ~ mo(income)*x, data = dat)
summary(fit2)
plot(conditional_effects(fit2), points = TRUE)

# ensure conditional monotonicity
fit3 &lt;- brm(ls ~ mo(income, id = "i")*x, data = dat)
summary(fit3)
plot(conditional_effects(fit3), points = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='model_weights.brmsfit'>Model Weighting Methods</h2><span id='topic+model_weights.brmsfit'></span><span id='topic+model_weights'></span>

<h3>Description</h3>

<p>Compute model weights in various ways, for instance, via
stacking of posterior predictive distributions, Akaike weights,
or marginal likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
model_weights(x, ..., weights = "stacking", model_names = NULL)

model_weights(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_weights.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="model_weights.brmsfit_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects or further arguments
passed to the underlying post-processing functions.
In particular, see <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> for further
supported arguments.</p>
</td></tr>
<tr><td><code id="model_weights.brmsfit_+3A_weights">weights</code></td>
<td>
<p>Name of the criterion to compute weights from. Should be one
of <code>"loo"</code>, <code>"waic"</code>, <code>"kfold"</code>, <code>"stacking"</code> (current
default), or <code>"bma"</code>, <code>"pseudobma"</code>, For the former three
options, Akaike weights will be computed based on the information criterion
values returned by the respective methods. For <code>"stacking"</code> and
<code>"pseudobma"</code>, method <code><a href="#topic+loo_model_weights">loo_model_weights</a></code> will be used to
obtain weights. For <code>"bma"</code>, method <code><a href="#topic+post_prob">post_prob</a></code> will be
used to compute Bayesian model averaging weights based on log marginal
likelihood values (make sure to specify reasonable priors in this case).
For some methods, <code>weights</code> may also be a numeric vector of
pre-specified weights.</p>
</td></tr>
<tr><td><code id="model_weights.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of weights for the models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with 'treat' as predictor
fit1 &lt;- brm(rating ~ treat + period + carry, data = inhaler)
summary(fit1)

# model without 'treat' as predictor
fit2 &lt;- brm(rating ~ period + carry, data = inhaler)
summary(fit2)

# obtain Akaike weights based on the WAIC
model_weights(fit1, fit2, weights = "waic")

## End(Not run)

</code></pre>

<hr>
<h2 id='MultiNormal'>The Multivariate Normal Distribution</h2><span id='topic+MultiNormal'></span><span id='topic+dmulti_normal'></span><span id='topic+rmulti_normal'></span>

<h3>Description</h3>

<p>Density function and random generation for the multivariate normal
distribution with mean vector <code>mu</code> and covariance matrix <code>Sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmulti_normal(x, mu, Sigma, log = FALSE, check = FALSE)

rmulti_normal(n, mu, Sigma, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiNormal_+3A_x">x</code></td>
<td>
<p>Vector or matrix of quantiles. If <code>x</code> is a matrix,
each row is taken to be a quantile.</p>
</td></tr>
<tr><td><code id="MultiNormal_+3A_mu">mu</code></td>
<td>
<p>Mean vector with length equal to the number of dimensions.</p>
</td></tr>
<tr><td><code id="MultiNormal_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="MultiNormal_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="MultiNormal_+3A_check">check</code></td>
<td>
<p>Logical; Indicates whether several input checks
should be performed. Defaults to <code>FALSE</code> to improve
efficiency.</p>
</td></tr>
<tr><td><code id="MultiNormal_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the Stan user's manual <a href="https://mc-stan.org/documentation/">https://mc-stan.org/documentation/</a>
for details on the parameterization
</p>

<hr>
<h2 id='MultiStudentT'>The Multivariate Student-t Distribution</h2><span id='topic+MultiStudentT'></span><span id='topic+dmulti_student_t'></span><span id='topic+rmulti_student_t'></span>

<h3>Description</h3>

<p>Density function and random generation for the multivariate Student-t
distribution with location vector <code>mu</code>, covariance matrix <code>Sigma</code>,
and degrees of freedom <code>df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmulti_student_t(x, df, mu, Sigma, log = FALSE, check = FALSE)

rmulti_student_t(n, df, mu, Sigma, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiStudentT_+3A_x">x</code></td>
<td>
<p>Vector or matrix of quantiles. If <code>x</code> is a matrix,
each row is taken to be a quantile.</p>
</td></tr>
<tr><td><code id="MultiStudentT_+3A_df">df</code></td>
<td>
<p>Vector of degrees of freedom.</p>
</td></tr>
<tr><td><code id="MultiStudentT_+3A_mu">mu</code></td>
<td>
<p>Location vector with length equal to the number of dimensions.</p>
</td></tr>
<tr><td><code id="MultiStudentT_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="MultiStudentT_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="MultiStudentT_+3A_check">check</code></td>
<td>
<p>Logical; Indicates whether several input checks
should be performed. Defaults to <code>FALSE</code> to improve
efficiency.</p>
</td></tr>
<tr><td><code id="MultiStudentT_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the Stan user's manual <a href="https://mc-stan.org/documentation/">https://mc-stan.org/documentation/</a>
for details on the parameterization
</p>

<hr>
<h2 id='mvbind'>Bind response variables in multivariate models</h2><span id='topic+mvbind'></span>

<h3>Description</h3>

<p>Can be used to specify a multivariate <span class="pkg">brms</span> model within a single
formula. Outside of <code><a href="#topic+brmsformula">brmsformula</a></code>, it just behaves like
<code><a href="base.html#topic+cbind">cbind</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvbind_+3A_...">...</code></td>
<td>
<p>Same as in <code><a href="base.html#topic+cbind">cbind</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>, <code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bf(mvbind(y1, y2) ~ x)

</code></pre>

<hr>
<h2 id='mvbrmsformula'>Set up a multivariate model formula for use in <span class="pkg">brms</span></h2><span id='topic+mvbrmsformula'></span><span id='topic+mvbf'></span>

<h3>Description</h3>

<p>Set up a multivariate model formula for use in the <span class="pkg">brms</span> package
allowing to define (potentially non-linear) additive multilevel
models for all parameters of the assumed response distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvbrmsformula(..., flist = NULL, rescor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvbrmsformula_+3A_...">...</code></td>
<td>
<p>Objects of class <code>formula</code> or <code>brmsformula</code>,
each specifying a univariate model. See <code><a href="#topic+brmsformula">brmsformula</a></code>
for details on how to specify univariate models.</p>
</td></tr>
<tr><td><code id="mvbrmsformula_+3A_flist">flist</code></td>
<td>
<p>Optional list of formulas, which are treated in the
same way as formulas passed via the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="mvbrmsformula_+3A_rescor">rescor</code></td>
<td>
<p>Logical; Indicates if residual correlation between
the response variables should be modeled. Currently, this is only
possible in multivariate <code>gaussian</code> and <code>student</code> models.
If <code>NULL</code> (the default), <code>rescor</code> is internally set to
<code>TRUE</code> when possible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_multivariate")</code> for a case study.
</p>


<h3>Value</h3>

<p>An object of class <code>mvbrmsformula</code>, which
is essentially a <code>list</code> containing all model formulas
as well as some additional information for multivariate models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>, <code><a href="#topic+brmsformula-helpers">brmsformula-helpers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bf1 &lt;- bf(y1 ~ x + (1|g))
bf2 &lt;- bf(y2 ~ s(z))
mvbf(bf1, bf2)

</code></pre>

<hr>
<h2 id='ngrps.brmsfit'>Number of Grouping Factor Levels</h2><span id='topic+ngrps.brmsfit'></span><span id='topic+ngrps'></span>

<h3>Description</h3>

<p>Extract the number of levels of one or more grouping factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
ngrps(object, ...)

ngrps(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngrps.brmsfit_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="ngrps.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing the number of levels per
grouping factor.
</p>

<hr>
<h2 id='nsamples.brmsfit'>(Deprecated) Number of Posterior Samples</h2><span id='topic+nsamples.brmsfit'></span><span id='topic+nsamples'></span>

<h3>Description</h3>

<p>Extract the number of posterior samples (draws) stored in a fitted Bayesian
model. Method <code>nsamples</code> is deprecated. Please use <code>ndraws</code>
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
nsamples(object, subset = NULL, incl_warmup = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsamples.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="nsamples.brmsfit_+3A_subset">subset</code></td>
<td>
<p>An optional integer vector defining a subset of samples
to be considered.</p>
</td></tr>
<tr><td><code id="nsamples.brmsfit_+3A_incl_warmup">incl_warmup</code></td>
<td>
<p>A flag indicating whether to also count warmup / burn-in
samples.</p>
</td></tr>
<tr><td><code id="nsamples.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='opencl'>GPU support in Stan via OpenCL</h2><span id='topic+opencl'></span>

<h3>Description</h3>

<p>Use OpenCL for GPU support in <span class="pkg">Stan</span> via the <span class="pkg">brms</span> interface. Only
some <span class="pkg">Stan</span> functions can be run on a GPU at this point and so
a lot of <span class="pkg">brms</span> models won't benefit from OpenCL for now.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opencl(ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opencl_+3A_ids">ids</code></td>
<td>
<p>(integer vector of length 2) The platform and device IDs of the
OpenCL device to use for fitting. If you don't know the IDs of your OpenCL
device, <code>c(0,0)</code> is most likely what you need.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on OpenCL in <span class="pkg">Stan</span>, check out
<a href="https://mc-stan.org/docs/2_26/cmdstan-guide/parallelization.html#opencl">https://mc-stan.org/docs/2_26/cmdstan-guide/parallelization.html#opencl</a>
as well as <a href="https://mc-stan.org/docs/2_26/stan-users-guide/opencl.html">https://mc-stan.org/docs/2_26/stan-users-guide/opencl.html</a>.
</p>


<h3>Value</h3>

<p>A <code>brmsopencl</code> object which can be passed to the
<code>opencl</code> argument of <code>brm</code> and related functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# this model just serves as an illustration
# OpenCL may not actually speed things up here
fit &lt;- brm(count ~ zAge + zBase * Trt + (1|patient),
           data = epilepsy, family = poisson(),
           chains = 2, cores = 2, opencl = opencl(c(0, 0)),
           backend = "cmdstanr")
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='pairs.brmsfit'>Create a matrix of output plots from a <code>brmsfit</code> object</h2><span id='topic+pairs.brmsfit'></span>

<h3>Description</h3>

<p>A <code><a href="graphics.html#topic+pairs">pairs</a></code>
method that is customized for MCMC output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
pairs(x, pars = NA, variable = NULL, regex = FALSE, fixed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.brmsfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code></p>
</td></tr>
<tr><td><code id="pairs.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Deprecated alias of <code>variable</code>.
Names of the parameters to plot, as given by a
character vector or a regular expression.</p>
</td></tr>
<tr><td><code id="pairs.brmsfit_+3A_variable">variable</code></td>
<td>
<p>Names of the variables (parameters) to plot, as given by a
character vector or a regular expression (if <code>regex = TRUE</code>). By
default, a hopefully not too large selection of variables is plotted.</p>
</td></tr>
<tr><td><code id="pairs.brmsfit_+3A_regex">regex</code></td>
<td>
<p>Logical; Indicates whether <code>variable</code> should
be treated as regular expressions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pairs.brmsfit_+3A_fixed">fixed</code></td>
<td>
<p>(Deprecated) Indicates whether parameter names
should be matched exactly (<code>TRUE</code>) or treated as
regular expressions (<code>FALSE</code>). Default is <code>FALSE</code>
and only works with argument <code>pars</code>.</p>
</td></tr>
<tr><td><code id="pairs.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed description see
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zAge + zBase * Trt
           + (1|patient) + (1|visit),
           data = epilepsy, family = "poisson")
pairs(fit, variable = variables(fit)[1:3])
pairs(fit, variable = "^sd_", regex = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='parnames'>Extract Parameter Names</h2><span id='topic+parnames'></span><span id='topic+parnames.brmsfit'></span>

<h3>Description</h3>

<p>Extract all parameter names of a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parnames(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parnames_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="parnames_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the parameter names of the model.
</p>

<hr>
<h2 id='plot.brmsfit'>Trace and Density Plots for MCMC Draws</h2><span id='topic+plot.brmsfit'></span>

<h3>Description</h3>

<p>Trace and Density Plots for MCMC Draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
plot(
  x,
  pars = NA,
  combo = c("hist", "trace"),
  nvariables = 5,
  N = NULL,
  variable = NULL,
  regex = FALSE,
  fixed = FALSE,
  bins = 30,
  theme = NULL,
  plot = TRUE,
  ask = TRUE,
  newpage = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.brmsfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Deprecated alias of <code>variable</code>.
Names of the parameters to plot, as given by a
character vector or a regular expression.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_combo">combo</code></td>
<td>
<p>A character vector with at least two elements.
Each element of <code>combo</code> corresponds to a column in the resulting
graphic and should be the name of one of the available
<code><a href="bayesplot.html#topic+MCMC-overview">MCMC</a></code> functions
(omitting the <code>mcmc_</code> prefix).</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_nvariables">nvariables</code></td>
<td>
<p>The number of variables (parameters) plotted per page.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_n">N</code></td>
<td>
<p>Deprecated alias of <code>nvariables</code>.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_variable">variable</code></td>
<td>
<p>Names of the variables (parameters) to plot, as given by a
character vector or a regular expression (if <code>regex = TRUE</code>). By
default, a hopefully not too large selection of variables is plotted.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_regex">regex</code></td>
<td>
<p>Logical; Indicates whether <code>variable</code> should
be treated as regular expressions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_fixed">fixed</code></td>
<td>
<p>(Deprecated) Indicates whether parameter names
should be matched exactly (<code>TRUE</code>) or treated as
regular expressions (<code>FALSE</code>). Default is <code>FALSE</code>
and only works with argument <code>pars</code>.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_bins">bins</code></td>
<td>
<p>Number of bins used for posterior histograms (defaults to 30).</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_theme">theme</code></td>
<td>
<p>A <code><a href="ggplot2.html#topic+theme">theme</a></code> object
modifying the appearance of the plots.
For some basic themes see <code><a href="ggplot2.html#topic+ggtheme">ggtheme</a></code>
and <code><a href="bayesplot.html#topic+theme_default">theme_default</a></code>.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_plot">plot</code></td>
<td>
<p>Logical; indicates if plots should be
plotted directly in the active graphic device.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_ask">ask</code></td>
<td>
<p>Logical; indicates if the user is prompted
before a new page is plotted.
Only used if <code>plot</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_newpage">newpage</code></td>
<td>
<p>Logical; indicates if the first set of plots
should be plotted to a new page.
Only used if <code>plot</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="bayesplot.html#topic+MCMC-combos">mcmc_combo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible list of
<code><a href="gtable.html#topic+gtable">gtable</a></code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zAge + zBase * Trt
           + (1|patient) + (1|visit),
           data = epilepsy, family = "poisson")
plot(fit)
## plot population-level effects only
plot(fit, variable = "^b_", regex = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='post_prob.brmsfit'>Posterior Model Probabilities from Marginal Likelihoods</h2><span id='topic+post_prob.brmsfit'></span><span id='topic+post_prob'></span>

<h3>Description</h3>

<p>Compute posterior model probabilities from marginal likelihoods.
The <code>brmsfit</code> method is just a thin wrapper around
the corresponding method for <code>bridge</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
post_prob(x, ..., prior_prob = NULL, model_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_prob.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="post_prob.brmsfit_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects or further arguments
passed to the underlying post-processing functions.
In particular, see <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> for further
supported arguments.</p>
</td></tr>
<tr><td><code id="post_prob.brmsfit_+3A_prior_prob">prior_prob</code></td>
<td>
<p>Numeric vector with prior model probabilities.
If omitted, a uniform prior is used (i.e., all models are equally
likely a priori). The default <code>NULL</code> corresponds to equal
prior model weights.</p>
</td></tr>
<tr><td><code id="post_prob.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing the marginal likelihood requires samples
of all variables defined in Stan's <code>parameters</code> block
to be saved. Otherwise <code>post_prob</code> cannot be computed.
Thus, please set <code>save_all_pars = TRUE</code> in the call to <code>brm</code>,
if you are planning to apply <code>post_prob</code> to your models.
</p>
<p>The computation of model probabilities based on bridge sampling requires
a lot more posterior samples than usual. A good conservative
rule of thump is perhaps 10-fold more samples (read: the default of 4000
samples may not be enough in many cases). If not enough posterior
samples are provided, the bridge sampling algorithm tends to be
unstable leading to considerably different results each time it is run.
We thus recommend running <code>post_prob</code>
multiple times to check the stability of the results.
</p>
<p>More details are provided under
<code><a href="bridgesampling.html#topic+post_prob">bridgesampling::post_prob</a></code>.
</p>


<h3>See Also</h3>

<p><code>
  <a href="#topic+bridge_sampler.brmsfit">bridge_sampler</a>,
  <a href="#topic+bayes_factor.brmsfit">bayes_factor</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with the treatment effect
fit1 &lt;- brm(
  count ~ zAge + zBase + Trt,
  data = epilepsy, family = negbinomial(),
  prior = prior(normal(0, 1), class = b),
  save_all_pars = TRUE
)
summary(fit1)

# model without the treatent effect
fit2 &lt;- brm(
  count ~ zAge + zBase,
  data = epilepsy, family = negbinomial(),
  prior = prior(normal(0, 1), class = b),
  save_all_pars = TRUE
)
summary(fit2)

# compute the posterior model probabilities
post_prob(fit1, fit2)

# specify prior model probabilities
post_prob(fit1, fit2, prior_prob = c(0.8, 0.2))

## End(Not run)

</code></pre>

<hr>
<h2 id='posterior_average.brmsfit'>Posterior draws of parameters averaged across models</h2><span id='topic+posterior_average.brmsfit'></span><span id='topic+posterior_average'></span>

<h3>Description</h3>

<p>Extract posterior draws of parameters averaged across models.
Weighting can be done in various ways, for instance using
Akaike weights based on information criteria or
marginal likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
posterior_average(
  x,
  ...,
  variable = NULL,
  pars = NULL,
  weights = "stacking",
  ndraws = NULL,
  nsamples = NULL,
  missing = NULL,
  model_names = NULL,
  control = list(),
  seed = NULL
)

posterior_average(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_average.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects or further arguments
passed to the underlying post-processing functions.
In particular, see <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> for further
supported arguments.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_variable">variable</code></td>
<td>
<p>Names of variables (parameters) for which to average across
models. Only those variables can be averaged that appear in every model.
Defaults to all overlapping variables.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Deprecated alias of <code>variable</code>.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_weights">weights</code></td>
<td>
<p>Name of the criterion to compute weights from. Should be one
of <code>"loo"</code>, <code>"waic"</code>, <code>"kfold"</code>, <code>"stacking"</code> (current
default), or <code>"bma"</code>, <code>"pseudobma"</code>, For the former three
options, Akaike weights will be computed based on the information criterion
values returned by the respective methods. For <code>"stacking"</code> and
<code>"pseudobma"</code>, method <code><a href="#topic+loo_model_weights">loo_model_weights</a></code> will be used to
obtain weights. For <code>"bma"</code>, method <code><a href="#topic+post_prob">post_prob</a></code> will be
used to compute Bayesian model averaging weights based on log marginal
likelihood values (make sure to specify reasonable priors in this case).
For some methods, <code>weights</code> may also be a numeric vector of
pre-specified weights.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Total number of posterior draws to use.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_nsamples">nsamples</code></td>
<td>
<p>Deprecated alias of <code>ndraws</code>.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_missing">missing</code></td>
<td>
<p>An optional numeric value or a named list of numeric values
to use if a model does not contain a variable for which posterior draws
should be averaged. Defaults to <code>NULL</code>, in which case only those
variables can be averaged that are present in all of the models.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_control">control</code></td>
<td>
<p>Optional <code>list</code> of further arguments
passed to the function specified in <code>weights</code>.</p>
</td></tr>
<tr><td><code id="posterior_average.brmsfit_+3A_seed">seed</code></td>
<td>
<p>A single numeric value passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>
to make results reproducible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weights are computed with the <code><a href="#topic+model_weights">model_weights</a></code> method.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of posterior draws.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_weights">model_weights</a></code>, <code><a href="#topic+pp_average">pp_average</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with 'treat' as predictor
fit1 &lt;- brm(rating ~ treat + period + carry, data = inhaler)
summary(fit1)

# model without 'treat' as predictor
fit2 &lt;- brm(rating ~ period + carry, data = inhaler)
summary(fit2)

# compute model-averaged posteriors of overlapping parameters
posterior_average(fit1, fit2, weights = "waic")

## End(Not run)

</code></pre>

<hr>
<h2 id='posterior_epred.brmsfit'>Draws from the Expected Value of the Posterior Predictive Distribution</h2><span id='topic+posterior_epred.brmsfit'></span><span id='topic+pp_expect'></span><span id='topic+posterior_epred'></span>

<h3>Description</h3>

<p>Compute posterior draws of the expected value of the posterior predictive
distribution. Can be performed for the data used to fit the model (posterior
predictive checks) or for new data. By definition, these predictions have
smaller variance than the posterior predictions performed by the
<code><a href="#topic+posterior_predict.brmsfit">posterior_predict.brmsfit</a></code> method. This is because only the
uncertainty in the expected value of the posterior predictive distribution is
incorporated in the draws computed by <code>posterior_epred</code> while the
residual error is ignored there. However, the estimated means of both methods
averaged across draws should be very similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
posterior_epred(
  object,
  newdata = NULL,
  re_formula = NULL,
  re.form = NULL,
  resp = NULL,
  dpar = NULL,
  nlpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  sort = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_epred.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_re.form">re.form</code></td>
<td>
<p>Alias of <code>re_formula</code>.</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_nlpar">nlpar</code></td>
<td>
<p>Optional name of a predicted non-linear parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_sort">sort</code></td>
<td>
<p>Logical. Only relevant for time series models.
Indicating whether to return predicted values in the original
order (<code>FALSE</code>; default) or in the order of the
time series (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="posterior_epred.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NA</code> values within factors in <code>newdata</code>,
are interpreted as if all dummy variables of this factor are
zero. This allows, for instance, to make predictions of the grand mean
when using sum coding.
</p>
<p>In multilevel models, it is possible to
allow new levels of grouping factors to be used in the predictions.
This can be controlled via argument <code>allow_new_levels</code>.
New levels can be sampled in multiple ways, which can be controlled
via argument <code>sample_new_levels</code>. Both of these arguments are
documented in <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> along with several
other useful arguments to control specific aspects of the predictions.
</p>


<h3>Value</h3>

<p>An <code>array</code> of draws. For
categorical and ordinal models, the output is an S x N x C array.
Otherwise, the output is an S x N matrix, where S is the number of
posterior draws, N is the number of observations, and C is the number of
categories. In multivariate models, an additional dimension is added to the
output which indexes along the different response variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fit a model
fit &lt;- brm(rating ~ treat + period + carry + (1|subject),
           data = inhaler)

## compute expected predictions
ppe &lt;- posterior_epred(fit)
str(ppe)

## End(Not run)

</code></pre>

<hr>
<h2 id='posterior_interval.brmsfit'>Compute posterior uncertainty intervals</h2><span id='topic+posterior_interval.brmsfit'></span><span id='topic+posterior_interval'></span>

<h3>Description</h3>

<p>Compute posterior uncertainty intervals for <code>brmsfit</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
posterior_interval(object, pars = NA, variable = NULL, prob = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_interval.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="posterior_interval.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Deprecated alias of <code>variable</code>. For reasons of backwards
compatibility, <code>pars</code> is interpreted as a vector of regular
expressions by default unless <code>fixed = TRUE</code> is specified.</p>
</td></tr>
<tr><td><code id="posterior_interval.brmsfit_+3A_variable">variable</code></td>
<td>
<p>A character vector providing the variables to extract.
By default, all variables are extracted.</p>
</td></tr>
<tr><td><code id="posterior_interval.brmsfit_+3A_prob">prob</code></td>
<td>
<p>A value between 0 and 1 indicating the desired probability
to be covered by the uncertainty intervals. The default is 0.95.</p>
</td></tr>
<tr><td><code id="posterior_interval.brmsfit_+3A_...">...</code></td>
<td>
<p>More arguments passed to <code><a href="#topic+as.matrix.brmsfit">as.matrix.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with lower and upper interval bounds
as columns and as many rows as selected variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zAge + zBase * Trt,
           data = epilepsy, family = negbinomial())
posterior_interval(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='posterior_linpred.brmsfit'>Posterior Draws of the Linear Predictor</h2><span id='topic+posterior_linpred.brmsfit'></span><span id='topic+posterior_linpred'></span>

<h3>Description</h3>

<p>Compute posterior draws of the linear predictor, that is draws before
applying any link functions or other transformations. Can be performed for
the data used to fit the model (posterior predictive checks) or for new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
posterior_linpred(
  object,
  transform = FALSE,
  newdata = NULL,
  re_formula = NULL,
  re.form = NULL,
  resp = NULL,
  dpar = NULL,
  nlpar = NULL,
  incl_thres = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  sort = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_linpred.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_transform">transform</code></td>
<td>
<p>Logical; if <code>FALSE</code>
(the default), draws of the linear predictor are returned.
If <code>TRUE</code>, draws of the transformed linear predictor,
that is, after applying the inverse link function are returned.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_re.form">re.form</code></td>
<td>
<p>Alias of <code>re_formula</code>.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_dpar">dpar</code></td>
<td>
<p>Name of a predicted distributional parameter
for which draws are to be returned. By default, draws
of the main distributional parameter(s) <code>"mu"</code> are returned.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_nlpar">nlpar</code></td>
<td>
<p>Optional name of a predicted non-linear parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_incl_thres">incl_thres</code></td>
<td>
<p>Logical; only relevant for ordinal models when
<code>transform</code> is <code>FALSE</code>, and ignored otherwise. Shall the
thresholds and category-specific effects be included in the linear
predictor? For backwards compatibility, the default is to not include them.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_sort">sort</code></td>
<td>
<p>Logical. Only relevant for time series models.
Indicating whether to return predicted values in the original
order (<code>FALSE</code>; default) or in the order of the
time series (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="posterior_linpred.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_epred.brmsfit">posterior_epred.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fit a model
fit &lt;- brm(rating ~ treat + period + carry + (1|subject),
           data = inhaler)

## extract linear predictor values
pl &lt;- posterior_linpred(fit)
str(pl)

## End(Not run)

</code></pre>

<hr>
<h2 id='posterior_predict.brmsfit'>Draws from the Posterior Predictive Distribution</h2><span id='topic+posterior_predict.brmsfit'></span><span id='topic+posterior_predict'></span>

<h3>Description</h3>

<p>Compute posterior draws of the posterior predictive distribution. Can be
performed for the data used to fit the model (posterior predictive checks) or
for new data. By definition, these draws have higher variance than draws
of the expected value of the posterior predictive distribution computed by
<code><a href="#topic+posterior_epred.brmsfit">posterior_epred.brmsfit</a></code>. This is because the residual error
is incorporated in <code>posterior_predict</code>. However, the estimated means of
both methods averaged across draws should be very similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
posterior_predict(
  object,
  newdata = NULL,
  re_formula = NULL,
  re.form = NULL,
  transform = NULL,
  resp = NULL,
  negative_rt = FALSE,
  ndraws = NULL,
  draw_ids = NULL,
  sort = FALSE,
  ntrys = 5,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_predict.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_re.form">re.form</code></td>
<td>
<p>Alias of <code>re_formula</code>.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_transform">transform</code></td>
<td>
<p>(Deprecated) A function or a character string naming
a function to be applied on the predicted responses
before summary statistics are computed.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_negative_rt">negative_rt</code></td>
<td>
<p>Only relevant for Wiener diffusion models.
A flag indicating whether response times of responses
on the lower boundary should be returned as negative values.
This allows to distinguish responses on the upper and
lower boundary. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_sort">sort</code></td>
<td>
<p>Logical. Only relevant for time series models.
Indicating whether to return predicted values in the original
order (<code>FALSE</code>; default) or in the order of the
time series (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_ntrys">ntrys</code></td>
<td>
<p>Parameter used in rejection sampling
for truncated discrete models only
(defaults to <code>5</code>). See Details for more information.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores (defaults to <code>1</code>). On non-Windows systems,
this argument can be set globally via the <code>mc.cores</code> option.</p>
</td></tr>
<tr><td><code id="posterior_predict.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NA</code> values within factors in <code>newdata</code>,
are interpreted as if all dummy variables of this factor are
zero. This allows, for instance, to make predictions of the grand mean
when using sum coding.
</p>
<p>In multilevel models, it is possible to
allow new levels of grouping factors to be used in the predictions.
This can be controlled via argument <code>allow_new_levels</code>.
New levels can be sampled in multiple ways, which can be controlled
via argument <code>sample_new_levels</code>. Both of these arguments are
documented in <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> along with several
other useful arguments to control specific aspects of the predictions.
</p>
<p>For truncated discrete models only: In the absence of any general
algorithm to sample from truncated discrete distributions, rejection
sampling is applied in this special case. This means that values are
sampled until a value lies within the defined truncation boundaries. In
practice, this procedure may be rather slow (especially in <span class="rlang"><b>R</b></span>). Thus, we
try to do approximate rejection sampling by sampling each value
<code>ntrys</code> times and then select a valid value. If all values are
invalid, the closest boundary is used, instead. If there are more than a
few of these pathological cases, a warning will occur suggesting to
increase argument <code>ntrys</code>.
</p>


<h3>Value</h3>

<p>An <code>array</code> of draws. In univariate models,
the output is as an S x N matrix, where S is the number of posterior
draws and N is the number of observations. In multivariate models, an
additional dimension is added to the output which indexes along the
different response variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fit a model
fit &lt;- brm(time | cens(censored) ~ age + sex + (1 + age || patient),
           data = kidney, family = "exponential", init = "0")

## predicted responses
pp &lt;- posterior_predict(fit)
str(pp)

## predicted responses excluding the group-level effect of age
pp &lt;- posterior_predict(fit, re_formula = ~ (1 | patient))
str(pp)

## predicted responses of patient 1 for new data
newdata &lt;- data.frame(
  sex = factor(c("male", "female")),
  age = c(20, 50),
  patient = c(1, 1)
)
pp &lt;- posterior_predict(fit, newdata = newdata)
str(pp)

## End(Not run)

</code></pre>

<hr>
<h2 id='posterior_samples.brmsfit'>(Deprecated) Extract Posterior Samples</h2><span id='topic+posterior_samples.brmsfit'></span><span id='topic+posterior_samples'></span>

<h3>Description</h3>

<p>Extract posterior samples of specified parameters. The
<code>posterior_samples</code> method is deprecated. We recommend using the more
modern and consistent <code><a href="#topic+draws-brms">as_draws_*</a></code> extractor
functions of the <span class="pkg">posterior</span> package instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
posterior_samples(
  x,
  pars = NA,
  fixed = FALSE,
  add_chain = FALSE,
  subset = NULL,
  as.matrix = FALSE,
  as.array = FALSE,
  ...
)

posterior_samples(x, pars = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_samples.brmsfit_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object typically of class <code>brmsfit</code></p>
</td></tr>
<tr><td><code id="posterior_samples.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Names of parameters for which posterior samples
should be returned, as given by a character vector or regular expressions.
By default, all posterior samples of all parameters are extracted.</p>
</td></tr>
<tr><td><code id="posterior_samples.brmsfit_+3A_fixed">fixed</code></td>
<td>
<p>Indicates whether parameter names
should be matched exactly (<code>TRUE</code>) or treated as
regular expressions (<code>FALSE</code>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples.brmsfit_+3A_add_chain">add_chain</code></td>
<td>
<p>A flag indicating if the returned <code>data.frame</code>
should contain two additional columns. The <code>chain</code> column
indicates the chain in which each sample was generated, the <code>iter</code>
column indicates the iteration number within each chain.</p>
</td></tr>
<tr><td><code id="posterior_samples.brmsfit_+3A_subset">subset</code></td>
<td>
<p>A numeric vector indicating the rows
(i.e., posterior samples) to be returned.
If <code>NULL</code> (the default), all  posterior samples are returned.</p>
</td></tr>
<tr><td><code id="posterior_samples.brmsfit_+3A_as.matrix">as.matrix</code></td>
<td>
<p>Should the output be a <code>matrix</code>
instead of a <code>data.frame</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples.brmsfit_+3A_as.array">as.array</code></td>
<td>
<p>Should the output be an <code>array</code>
instead of a <code>data.frame</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples.brmsfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame (matrix or array) containing the posterior samples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draws-brms">as_draws</a></code>,
<code><a href="#topic+as.data.frame.brmsfit">as.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(rating ~ treat + period + carry + (1|subject),
           data = inhaler, family = "cumulative")

# extract posterior samples of population-level effects
samples1 &lt;- posterior_samples(fit, pars = "^b")
head(samples1)

# extract posterior samples of group-level standard deviations
samples2 &lt;- posterior_samples(fit, pars = "^sd_")
head(samples2)

## End(Not run)

</code></pre>

<hr>
<h2 id='posterior_smooths.brmsfit'>Posterior Predictions of Smooth Terms</h2><span id='topic+posterior_smooths.brmsfit'></span><span id='topic+posterior_smooths'></span>

<h3>Description</h3>

<p>Compute posterior predictions of smooth <code>s</code> and <code>t2</code> terms of
models fitted with <span class="pkg">brms</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
posterior_smooths(
  object,
  smooth,
  newdata = NULL,
  resp = NULL,
  dpar = NULL,
  nlpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  ...
)

posterior_smooths(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_smooths.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="posterior_smooths.brmsfit_+3A_smooth">smooth</code></td>
<td>
<p>Name of a single smooth term for which predictions should
be computed.</p>
</td></tr>
<tr><td><code id="posterior_smooths.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional <code>data.frame</code> for which to evaluate
predictions. If <code>NULL</code> (default), the original data of the model is
used. Only those variables appearing in the chosen <code>smooth</code> term are
required.</p>
</td></tr>
<tr><td><code id="posterior_smooths.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="posterior_smooths.brmsfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="posterior_smooths.brmsfit_+3A_nlpar">nlpar</code></td>
<td>
<p>Optional name of a predicted non-linear parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="posterior_smooths.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="posterior_smooths.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_smooths.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S x N matrix, where S is the number of
posterior draws and N is the number of observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(0)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
fit &lt;- brm(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat)
summary(fit)

newdata &lt;- data.frame(x2 = seq(0, 1, 10))
str(posterior_smooths(fit, smooth = "s(x2)", newdata = newdata))

## End(Not run)

</code></pre>

<hr>
<h2 id='posterior_summary'>Summarize Posterior draws</h2><span id='topic+posterior_summary'></span><span id='topic+posterior_summary.default'></span><span id='topic+posterior_summary.brmsfit'></span>

<h3>Description</h3>

<p>Summarizes posterior draws based on point estimates (mean or median),
estimation errors (SD or MAD) and quantiles. This function mainly exists to
retain backwards compatibility. It will eventually be replaced by functions
of the <span class="pkg">posterior</span> package (see examples below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_summary(x, ...)

## Default S3 method:
posterior_summary(x, probs = c(0.025, 0.975), robust = FALSE, ...)

## S3 method for class 'brmsfit'
posterior_summary(
  x,
  pars = NA,
  variable = NULL,
  probs = c(0.025, 0.975),
  robust = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_summary_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="posterior_summary_+3A_...">...</code></td>
<td>
<p>More arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="posterior_summary_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the
<code><a href="stats.html#topic+quantile">quantile</a></code> function.</p>
</td></tr>
<tr><td><code id="posterior_summary_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.</p>
</td></tr>
<tr><td><code id="posterior_summary_+3A_pars">pars</code></td>
<td>
<p>Deprecated alias of <code>variable</code>. For reasons of backwards
compatibility, <code>pars</code> is interpreted as a vector of regular
expressions by default unless <code>fixed = TRUE</code> is specified.</p>
</td></tr>
<tr><td><code id="posterior_summary_+3A_variable">variable</code></td>
<td>
<p>A character vector providing the variables to extract.
By default, all variables are extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where rows indicate variables
and columns indicate the summary estimates.
</p>


<h3>See Also</h3>

<p><code><a href="posterior.html#topic+summarize_draws">summarize_draws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(time ~ age * sex, data = kidney)
posterior_summary(fit)

# recommended workflow using posterior
library(posterior)
draws &lt;- as_draws_array(fit)
summarise_draws(draws, default_summary_measures())

## End(Not run)

</code></pre>

<hr>
<h2 id='posterior_table'>Table Creation for Posterior Draws</h2><span id='topic+posterior_table'></span>

<h3>Description</h3>

<p>Create a table for unique values of posterior draws.
This is usually only useful when summarizing predictions
of ordinal models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_table(x, levels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_table_+3A_x">x</code></td>
<td>
<p>A matrix of posterior draws where rows
indicate draws and columns indicate parameters.</p>
</td></tr>
<tr><td><code id="posterior_table_+3A_levels">levels</code></td>
<td>
<p>Optional values of possible posterior values.
Defaults to all unique values in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where rows indicate parameters
and columns indicate the unique values of
posterior draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(rating ~ period + carry + treat,
           data = inhaler, family = cumulative())
pr &lt;- predict(fit, summary = FALSE)
posterior_table(pr)

## End(Not run)

</code></pre>

<hr>
<h2 id='pp_average.brmsfit'>Posterior predictive draws averaged across models</h2><span id='topic+pp_average.brmsfit'></span><span id='topic+pp_average'></span>

<h3>Description</h3>

<p>Compute posterior predictive draws averaged across models.
Weighting can be done in various ways, for instance using
Akaike weights based on information criteria or
marginal likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
pp_average(
  x,
  ...,
  weights = "stacking",
  method = "posterior_predict",
  ndraws = NULL,
  nsamples = NULL,
  summary = TRUE,
  probs = c(0.025, 0.975),
  robust = FALSE,
  model_names = NULL,
  control = list(),
  seed = NULL
)

pp_average(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_average.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects or further arguments
passed to the underlying post-processing functions.
In particular, see <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> for further
supported arguments.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_weights">weights</code></td>
<td>
<p>Name of the criterion to compute weights from. Should be one
of <code>"loo"</code>, <code>"waic"</code>, <code>"kfold"</code>, <code>"stacking"</code> (current
default), or <code>"bma"</code>, <code>"pseudobma"</code>, For the former three
options, Akaike weights will be computed based on the information criterion
values returned by the respective methods. For <code>"stacking"</code> and
<code>"pseudobma"</code>, method <code><a href="#topic+loo_model_weights">loo_model_weights</a></code> will be used to
obtain weights. For <code>"bma"</code>, method <code><a href="#topic+post_prob">post_prob</a></code> will be
used to compute Bayesian model averaging weights based on log marginal
likelihood values (make sure to specify reasonable priors in this case).
For some methods, <code>weights</code> may also be a numeric vector of
pre-specified weights.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_method">method</code></td>
<td>
<p>Method used to obtain predictions to average over. Should be
one of <code>"posterior_predict"</code> (default), <code>"posterior_epred"</code>,
<code>"posterior_linpred"</code> or <code>"predictive_error"</code>.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Total number of posterior draws to use.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_nsamples">nsamples</code></td>
<td>
<p>Deprecated alias of <code>ndraws</code>.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics
(i.e. means, sds, and 95% intervals) be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_control">control</code></td>
<td>
<p>Optional <code>list</code> of further arguments
passed to the function specified in <code>weights</code>.</p>
</td></tr>
<tr><td><code id="pp_average.brmsfit_+3A_seed">seed</code></td>
<td>
<p>A single numeric value passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>
to make results reproducible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weights are computed with the <code><a href="#topic+model_weights">model_weights</a></code> method.
</p>


<h3>Value</h3>

<p>Same as the output of the method specified
in argument <code>method</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_weights">model_weights</a></code>, <code><a href="#topic+posterior_average">posterior_average</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with 'treat' as predictor
fit1 &lt;- brm(rating ~ treat + period + carry, data = inhaler)
summary(fit1)

# model without 'treat' as predictor
fit2 &lt;- brm(rating ~ period + carry, data = inhaler)
summary(fit2)

# compute model-averaged predicted values
(df &lt;- unique(inhaler[, c("treat", "period", "carry")]))
pp_average(fit1, fit2, newdata = df)

# compute model-averaged fitted values
pp_average(fit1, fit2, method = "fitted", newdata = df)

## End(Not run)

</code></pre>

<hr>
<h2 id='pp_check.brmsfit'>Posterior Predictive Checks for <code>brmsfit</code> Objects</h2><span id='topic+pp_check.brmsfit'></span><span id='topic+pp_check'></span>

<h3>Description</h3>

<p>Perform posterior predictive checks with the help
of the <span class="pkg">bayesplot</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
pp_check(
  object,
  type,
  ndraws = NULL,
  prefix = c("ppc", "ppd"),
  group = NULL,
  x = NULL,
  newdata = NULL,
  resp = NULL,
  draw_ids = NULL,
  nsamples = NULL,
  subset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_check.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_type">type</code></td>
<td>
<p>Type of the ppc plot as given by a character string.
See <code><a href="bayesplot.html#topic+PPC-overview">PPC</a></code> for an overview
of currently supported types. You may also use an invalid
type (e.g. <code>type = "xyz"</code>) to get a list of supported
types in the resulting error message.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many
posterior draws should be used.
If <code>NULL</code> all draws are used. If not specified,
the number of posterior draws is chosen automatically.
Ignored if <code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_prefix">prefix</code></td>
<td>
<p>The prefix of the <span class="pkg">bayesplot</span> function to be applied. 
Either '&quot;ppc&quot;' (posterior predictive check; the default)
or '&quot;ppd&quot;' (posterior predictive distribution), the latter being the same
as the former except that the observed data is not shown for '&quot;ppd&quot;'.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_group">group</code></td>
<td>
<p>Optional name of a factor variable in the model
by which to stratify the ppc plot. This argument is required for
ppc <code>*_grouped</code> types and ignored otherwise.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_x">x</code></td>
<td>
<p>Optional name of a variable in the model.
Only used for ppc types having an <code>x</code> argument
and ignored otherwise.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_nsamples">nsamples</code></td>
<td>
<p>Deprecated alias of <code>ndraws</code>.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_subset">subset</code></td>
<td>
<p>Deprecated alias of <code>draw_ids</code>.</p>
</td></tr>
<tr><td><code id="pp_check.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+predict.brmsfit">predict.brmsfit</a></code>
as well as to the PPC function specified in <code>type</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed explanation of each of the ppc functions,
see the <code><a href="bayesplot.html#topic+PPC-overview">PPC</a></code>
documentation of the <span class="pkg"><a href="bayesplot.html#topic+bayesplot-package">bayesplot</a></span>
package.
</p>


<h3>Value</h3>

<p>A ggplot object that can be further
customized using the <span class="pkg">ggplot2</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;-  brm(count ~ zAge + zBase * Trt
            + (1|patient) + (1|obs),
            data = epilepsy, family = poisson())

pp_check(fit)  # shows dens_overlay plot by default
pp_check(fit, type = "error_hist", ndraws = 11)
pp_check(fit, type = "scatter_avg", ndraws = 100)
pp_check(fit, type = "stat_2d")
pp_check(fit, type = "rootogram")
pp_check(fit, type = "loo_pit")

## get an overview of all valid types
pp_check(fit, type = "xyz")

## get a plot without the observed data
pp_check(fit, prefix = "ppd")

## End(Not run)

</code></pre>

<hr>
<h2 id='pp_mixture.brmsfit'>Posterior Probabilities of Mixture Component Memberships</h2><span id='topic+pp_mixture.brmsfit'></span><span id='topic+pp_mixture'></span>

<h3>Description</h3>

<p>Compute the posterior probabilities of mixture component
memberships for each observation including uncertainty
estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
pp_mixture(
  x,
  newdata = NULL,
  re_formula = NULL,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  log = FALSE,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)

pp_mixture(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_mixture.brmsfit_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object usually of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_log">log</code></td>
<td>
<p>Logical; Indicates whether to return
probabilities on the log-scale.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pp_mixture.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned probabilities can be written as
<code class="reqn">P(Kn = k | Yn)</code>, that is the posterior probability
that observation n originates from component k.
They are computed using Bayes' Theorem
</p>
<p style="text-align: center;"><code class="reqn">P(Kn = k | Yn) = P(Yn | Kn = k) P(Kn = k) / P(Yn),</code>
</p>

<p>where <code class="reqn">P(Yn | Kn = k)</code> is the (posterior) likelihood
of observation n for component k, <code class="reqn">P(Kn = k)</code> is
the (posterior) mixing probability of component k
(i.e. parameter <code>theta&lt;k&gt;</code>), and
</p>
<p style="text-align: center;"><code class="reqn">P(Yn) = \sum (k=1,...,K) P(Yn | Kn = k) P(Kn = k)</code>
</p>

<p>is a normalizing constant.
</p>


<h3>Value</h3>

<p>If <code>summary = TRUE</code>, an N x E x K array,
where N is the number of observations, K is the number
of mixture components, and E is equal to <code>length(probs) + 2</code>.
If <code>summary = FALSE</code>, an S x N x K array, where
S is the number of posterior draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simulate some data
set.seed(1234)
dat &lt;- data.frame(
  y = c(rnorm(100), rnorm(50, 2)),
  x = rnorm(150)
)
## fit a simple normal mixture model
mix &lt;- mixture(gaussian, nmix = 2)
prior &lt;- c(
  prior(normal(0, 5), Intercept, nlpar = mu1),
  prior(normal(0, 5), Intercept, nlpar = mu2),
  prior(dirichlet(2, 2), theta)
)
fit1 &lt;- brm(bf(y ~ x), dat, family = mix,
            prior = prior, chains = 2, init = 0)
summary(fit1)

## compute the membership probabilities
ppm &lt;- pp_mixture(fit1)
str(ppm)

## extract point estimates for each observation
head(ppm[, 1, ])

## classify every observation according to
## the most likely component
apply(ppm[, 1, ], 1, which.max)

## End(Not run)

</code></pre>

<hr>
<h2 id='predict.brmsfit'>Draws from the Posterior Predictive Distribution</h2><span id='topic+predict.brmsfit'></span>

<h3>Description</h3>

<p>This method is an alias of <code><a href="#topic+posterior_predict.brmsfit">posterior_predict.brmsfit</a></code>
with additional arguments for obtaining summaries of the computed draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
predict(
  object,
  newdata = NULL,
  re_formula = NULL,
  transform = NULL,
  resp = NULL,
  negative_rt = FALSE,
  ndraws = NULL,
  draw_ids = NULL,
  sort = FALSE,
  ntrys = 5,
  cores = NULL,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_transform">transform</code></td>
<td>
<p>(Deprecated) A function or a character string naming
a function to be applied on the predicted responses
before summary statistics are computed.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_negative_rt">negative_rt</code></td>
<td>
<p>Only relevant for Wiener diffusion models.
A flag indicating whether response times of responses
on the lower boundary should be returned as negative values.
This allows to distinguish responses on the upper and
lower boundary. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_sort">sort</code></td>
<td>
<p>Logical. Only relevant for time series models.
Indicating whether to return predicted values in the original
order (<code>FALSE</code>; default) or in the order of the
time series (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_ntrys">ntrys</code></td>
<td>
<p>Parameter used in rejection sampling
for truncated discrete models only
(defaults to <code>5</code>). See Details for more information.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores (defaults to <code>1</code>). On non-Windows systems,
this argument can be set globally via the <code>mc.cores</code> option.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>array</code> of predicted response values.
If <code>summary = FALSE</code> the output resembles those of
<code><a href="#topic+posterior_predict.brmsfit">posterior_predict.brmsfit</a></code>.
</p>
<p>If <code>summary = TRUE</code> the output depends on the family: For categorical
and ordinal families, the output is an N x C matrix, where N is the number
of observations, C is the number of categories, and the values are
predicted category probabilities. For all other families, the output is a N
x E matrix where E = <code>2 + length(probs)</code> is the number of summary
statistics: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_predict.brmsfit">posterior_predict.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fit a model
fit &lt;- brm(time | cens(censored) ~ age + sex + (1 + age || patient),
           data = kidney, family = "exponential", init = "0")

## predicted responses
pp &lt;- predict(fit)
head(pp)

## predicted responses excluding the group-level effect of age
pp &lt;- predict(fit, re_formula = ~ (1 | patient))
head(pp)

## predicted responses of patient 1 for new data
newdata &lt;- data.frame(
  sex = factor(c("male", "female")),
  age = c(20, 50),
  patient = c(1, 1)
)
predict(fit, newdata = newdata)

## End(Not run)

</code></pre>

<hr>
<h2 id='predictive_error.brmsfit'>Posterior Draws of Predictive Errors</h2><span id='topic+predictive_error.brmsfit'></span><span id='topic+predictive_error'></span>

<h3>Description</h3>

<p>Compute posterior draws of predictive errors, that is, observed minus
predicted responses. Can be performed for the data used to fit the model
(posterior predictive checks) or for new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
predictive_error(
  object,
  newdata = NULL,
  re_formula = NULL,
  re.form = NULL,
  method = "posterior_predict",
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  sort = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive_error.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="predictive_error.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="predictive_error.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="predictive_error.brmsfit_+3A_re.form">re.form</code></td>
<td>
<p>Alias of <code>re_formula</code>.</p>
</td></tr>
<tr><td><code id="predictive_error.brmsfit_+3A_method">method</code></td>
<td>
<p>Method used to obtain predictions. Can be set to
<code>"posterior_predict"</code> (the default), <code>"posterior_epred"</code>,
or <code>"posterior_linpred"</code>. For more details, see the respective
function documentations.</p>
</td></tr>
<tr><td><code id="predictive_error.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="predictive_error.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predictive_error.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="predictive_error.brmsfit_+3A_sort">sort</code></td>
<td>
<p>Logical. Only relevant for time series models.
Indicating whether to return predicted values in the original
order (<code>FALSE</code>; default) or in the order of the
time series (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="predictive_error.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S x N <code>array</code> of predictive error draws, where S is the
number of posterior draws and N is the number of observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fit a model
fit &lt;- brm(rating ~ treat + period + carry + (1|subject),
           data = inhaler, cores = 2)

## extract predictive errors
pe &lt;- predictive_error(fit)
str(pe)

## End(Not run)

</code></pre>

<hr>
<h2 id='predictive_interval.brmsfit'>Predictive Intervals</h2><span id='topic+predictive_interval.brmsfit'></span><span id='topic+predictive_interval'></span>

<h3>Description</h3>

<p>Compute intervals from the posterior predictive distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
predictive_interval(object, prob = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive_interval.brmsfit_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="predictive_interval.brmsfit_+3A_prob">prob</code></td>
<td>
<p>A number p (0 &lt; p &lt; 1) indicating the desired probability mass to
include in the intervals. Defaults to <code>0.9</code>.</p>
</td></tr>
<tr><td><code id="predictive_interval.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+posterior_predict">posterior_predict</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 2 columns for the lower and upper bounds of the
intervals, respectively, and as many rows as observations being predicted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zBase, data = epilepsy, family = poisson())
predictive_interval(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='prepare_predictions.brmsfit'>Prepare Predictions</h2><span id='topic+prepare_predictions.brmsfit'></span><span id='topic+prepare_predictions'></span><span id='topic+extract_draws'></span>

<h3>Description</h3>

<p>This method helps in preparing <span class="pkg">brms</span> models for certin post-processing
tasks most notably various forms of predictions. Unless you are a package
developer, you will rarely need to call <code>prepare_predictions</code> directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
prepare_predictions(
  x,
  newdata = NULL,
  re_formula = NULL,
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  oos = NULL,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  nsamples = NULL,
  subset = NULL,
  nug = NULL,
  smooths_only = FALSE,
  offset = TRUE,
  newdata2 = NULL,
  new_objects = NULL,
  point_estimate = NULL,
  ndraws_point_estimate = 1,
  ...
)

prepare_predictions(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_predictions.brmsfit_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object typically of class <code>'brmsfit'</code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_oos">oos</code></td>
<td>
<p>Optional indices of observations for which to compute
out-of-sample rather than in-sample predictions. Only required in models
that make use of response values to make predictions, that is, currently
only ARMA models.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_nsamples">nsamples</code></td>
<td>
<p>Deprecated alias of <code>ndraws</code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_subset">subset</code></td>
<td>
<p>Deprecated alias of <code>draw_ids</code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_nug">nug</code></td>
<td>
<p>Small positive number for Gaussian process terms only. For
numerical reasons, the covariance matrix of a Gaussian process might not be
positive definite. Adding a very small number to the matrix's diagonal
often solves this problem. If <code>NULL</code> (the default), <code>nug</code> is
chosen internally.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_smooths_only">smooths_only</code></td>
<td>
<p>Logical; If <code>TRUE</code> only predictions related to
smoothing splines (i.e., <code>s</code> or <code>t2</code>) will be computed.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_offset">offset</code></td>
<td>
<p>Logical; Indicates if offsets should be included in the
predictions. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_newdata2">newdata2</code></td>
<td>
<p>A named <code>list</code> of objects containing new data, which
cannot be passed via argument <code>newdata</code>. Required for some objects
used in autocorrelation structures, or <code><a href="#topic+stanvars">stanvars</a></code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_new_objects">new_objects</code></td>
<td>
<p>Deprecated alias of <code>newdata2</code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_point_estimate">point_estimate</code></td>
<td>
<p>Shall the returned object contain only point estimates
of the parameters instead of their posterior draws? Defaults to
<code>NULL</code> in which case no point estimate is computed. Alternatively, may
be set to <code>"mean"</code> or <code>"median"</code>. This argument is primarily
implemented to ensure compatibility with the <code><a href="#topic+loo_subsample">loo_subsample</a></code>
method.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_ndraws_point_estimate">ndraws_point_estimate</code></td>
<td>
<p>Only used if <code>point_estimate</code> is not
<code>NULL</code>. How often shall the point estimate's value be repeated?
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="prepare_predictions.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+validate_newdata">validate_newdata</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>'brmsprep'</code> or <code>'mvbrmsprep'</code>,
depending on whether a univariate or multivariate model is passed.
</p>

<hr>
<h2 id='print.brmsfit'>Print a summary for a fitted model represented by a <code>brmsfit</code> object</h2><span id='topic+print.brmsfit'></span><span id='topic+print.brmssummary'></span>

<h3>Description</h3>

<p>Print a summary for a fitted model represented by a <code>brmsfit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.brmsfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code></p>
</td></tr>
<tr><td><code id="print.brmsfit_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits for printing out the summary;
defaults to 2. The effective sample size is always rounded to integers.</p>
</td></tr>
<tr><td><code id="print.brmsfit_+3A_...">...</code></td>
<td>
<p>Additional arguments that would be passed
to method <code>summary</code> of <code>brmsfit</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.brmsfit">summary.brmsfit</a></code>
</p>

<hr>
<h2 id='print.brmsprior'>Print method for <code>brmsprior</code> objects</h2><span id='topic+print.brmsprior'></span>

<h3>Description</h3>

<p>Print method for <code>brmsprior</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsprior'
print(x, show_df = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.brmsprior_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsprior</code>.</p>
</td></tr>
<tr><td><code id="print.brmsprior_+3A_show_df">show_df</code></td>
<td>
<p>Logical; Print priors as a single
<code>data.frame</code> (<code>TRUE</code>) or as a sequence of
sampling statements (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="print.brmsprior_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='prior_draws.brmsfit'>Extract Prior Draws</h2><span id='topic+prior_draws.brmsfit'></span><span id='topic+prior_samples'></span><span id='topic+prior_draws'></span>

<h3>Description</h3>

<p>Extract prior draws of specified parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
prior_draws(x, variable = NULL, pars = NULL, ...)

prior_draws(x, ...)

prior_samples(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_draws.brmsfit_+3A_x">x</code></td>
<td>
<p>An <code>R</code> object typically of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="prior_draws.brmsfit_+3A_variable">variable</code></td>
<td>
<p>A character vector providing the variables to extract.
By default, all variables are extracted.</p>
</td></tr>
<tr><td><code id="prior_draws.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Deprecated alias of <code>variable</code>. For reasons of backwards
compatibility, <code>pars</code> is interpreted as a vector of regular
expressions by default unless <code>fixed = TRUE</code> is specified.</p>
</td></tr>
<tr><td><code id="prior_draws.brmsfit_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To make use of this function, the model must contain draws of
prior distributions. This can be ensured by setting <code>sample_prior =
  TRUE</code> in function <code>brm</code>. Priors of certain parameters cannot be saved
for technical reasons. For instance, this is the case for the
population-level intercept, which is only computed after fitting the model
by default. If you want to treat the intercept as part of all the other
regression coefficients, so that sampling from its prior becomes possible,
use <code>... ~ 0 + Intercept + ...</code> in the formulas.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the prior draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(rating ~ treat + period + carry + (1|subject),
           data = inhaler, family = "cumulative",
           prior = set_prior("normal(0,2)", class = "b"),
           sample_prior = TRUE)

# extract all prior draws
draws1 &lt;- prior_draws(fit)
head(draws1)

# extract prior draws for the coefficient of 'treat'
draws2 &lt;- prior_draws(fit, "b_treat")
head(draws2)

## End(Not run)

</code></pre>

<hr>
<h2 id='prior_summary.brmsfit'>Priors of <code>brms</code> models</h2><span id='topic+prior_summary.brmsfit'></span><span id='topic+prior_summary'></span>

<h3>Description</h3>

<p>Extract priors of models fitted with <span class="pkg">brms</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
prior_summary(object, all = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_summary.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="prior_summary.brmsfit_+3A_all">all</code></td>
<td>
<p>Logical; Show all parameters in the model which may have
priors (<code>TRUE</code>) or only those with proper priors (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="prior_summary.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>brmsprior</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(
  count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
  data = epilepsy, family = poisson(),
  prior = prior(student_t(5,0,10), class = b) +
    prior(cauchy(0,2), class = sd)
)

prior_summary(fit)
prior_summary(fit, all = FALSE)
print(prior_summary(fit, all = FALSE), show_df = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='psis.brmsfit'>Pareto smoothed importance sampling (PSIS)</h2><span id='topic+psis.brmsfit'></span><span id='topic+psis'></span>

<h3>Description</h3>

<p>Implementation of Pareto smoothed importance sampling (PSIS), a method for
stabilizing importance ratios. The version of PSIS implemented here
corresponds to the algorithm presented in Vehtari, Simpson, Gelman, Yao,
and Gabry (2022).
For PSIS diagnostics see the <a href="loo.html#topic+pareto-k-diagnostic">pareto-k-diagnostic</a> page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
psis(log_ratios, newdata = NULL, resp = NULL, model_name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psis.brmsfit_+3A_log_ratios">log_ratios</code></td>
<td>
<p>A fitted model object of class <code>brmsfit</code>.
Argument is named &quot;log_ratios&quot; to match the argument name of the
<code><a href="loo.html#topic+psis">loo::psis</a></code> generic function.</p>
</td></tr>
<tr><td><code id="psis.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="psis.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="psis.brmsfit_+3A_model_name">model_name</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="psis.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+log_lik">log_lik</a></code> and
<code><a href="loo.html#topic+psis">loo::psis</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>psis()</code> methods return an object of class <code>"psis"</code>,
which is a named list with the following components:
</p>

<dl>
<dt><code>log_weights</code></dt><dd>
<p>Vector or matrix of smoothed (and truncated) but <em>unnormalized</em> log
weights. To get normalized weights use the
<code><a href="loo.html#topic+weights.importance_sampling">weights()</a></code> method provided for objects of
class <code>"psis"</code>.
</p>
</dd>
<dt><code>diagnostics</code></dt><dd>
<p>A named list containing two vectors:
</p>

<ul>
<li> <p><code>pareto_k</code>: Estimates of the shape parameter <code class="reqn">k</code> of the
generalized Pareto distribution. See the <a href="loo.html#topic+pareto-k-diagnostic">pareto-k-diagnostic</a>
page for details.
</p>
</li>
<li> <p><code>n_eff</code>: PSIS effective sample size estimates.
</p>
</li></ul>

</dd>
</dl>

<p>Objects of class <code>"psis"</code> also have the following <a href="base.html#topic+attributes">attributes</a>:
</p>

<dl>
<dt><code>norm_const_log</code></dt><dd>
<p>Vector of precomputed values of <code>colLogSumExps(log_weights)</code> that are
used internally by the <code>weights</code> method to normalize the log weights.
</p>
</dd>
<dt><code>tail_len</code></dt><dd>
<p>Vector of tail lengths used for fitting the generalized Pareto distribution.
</p>
</dd>
<dt><code>r_eff</code></dt><dd>
<p>If specified, the user's <code>r_eff</code> argument.
</p>
</dd>
<dt><code>dims</code></dt><dd>
<p>Integer vector of length 2 containing <code>S</code> (posterior sample size)
and <code>N</code> (number of observations).
</p>
</dd>
<dt><code>method</code></dt><dd>
<p>Method used for importance sampling, here <code>psis</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical Bayesian model
evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em>. 27(5), 1413&ndash;1432. doi:10.1007/s11222-016-9696-4
(<a href="https://link.springer.com/article/10.1007/s11222-016-9696-4">journal version</a>,
<a href="https://arxiv.org/abs/1507.04544">preprint arXiv:1507.04544</a>).
</p>
<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry, J. (2022).
Pareto smoothed importance sampling.
<a href="https://arxiv.org/abs/1507.02646">preprint arXiv:1507.02646</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(rating ~ treat + period + carry, data = inhaler)
psis(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='R2D2'>R2D2 Priors in <span class="pkg">brms</span></h2><span id='topic+R2D2'></span>

<h3>Description</h3>

<p>Function used to set up R2D2 priors for population-level effects in
<span class="pkg">brms</span>. The function does not evaluate its arguments &ndash; it exists purely
to help set up the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2D2(mean_R2 = 0.5, prec_R2 = 2, cons_D2 = 0.5, autoscale = TRUE, main = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2D2_+3A_mean_r2">mean_R2</code></td>
<td>
<p>Mean of the Beta prior on the coefficient of determination R^2.</p>
</td></tr>
<tr><td><code id="R2D2_+3A_prec_r2">prec_R2</code></td>
<td>
<p>Precision of the Beta prior on the coefficient of determination R^2.</p>
</td></tr>
<tr><td><code id="R2D2_+3A_cons_d2">cons_D2</code></td>
<td>
<p>Concentration vector of the Dirichlet prior on the variance
decomposition parameters. Lower values imply more shrinkage.</p>
</td></tr>
<tr><td><code id="R2D2_+3A_autoscale">autoscale</code></td>
<td>
<p>Logical; indicating whether the R2D2
prior should be scaled using the residual standard deviation
<code>sigma</code> if possible and sensible (defaults to <code>TRUE</code>).
Autoscaling is not applied for distributional parameters or
when the model does not contain the parameter <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="R2D2_+3A_main">main</code></td>
<td>
<p>Logical (defaults to <code>FALSE</code>); only relevant if the R2D2
prior spans multiple parameter classes. In this case, only arguments given
in the single instance where <code>main</code> is <code>TRUE</code> will be used.
Arguments given in other instances of the prior will be ignored.
See the Examples section below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the following classes support the R2D2 prior: <code>b</code>
(overall regression coefficients), <code>sds</code> (SDs of smoothing splines),
<code>sdgp</code> (SDs of Gaussian processes), <code>ar</code> (autoregressive
coefficients), <code>ma</code> (moving average coefficients), <code>sderr</code> (SD of
latent residuals), <code>sdcar</code> (SD of spatial CAR structures), <code>sd</code>
(SD of varying coefficients).
</p>
<p>Even when the R2D2 prior is applied to multiple parameter classes at once,
the concentration vector (argument <code>cons_D2</code>) has to be provided
jointly in the the one instance of the prior where <code>main = TRUE</code>. The
order in which the elements of concentration vector correspond to the
classes' coefficients is the same as the order of the classes provided
above.
</p>


<h3>References</h3>

<p>Zhang, Y. D., Naughton, B. P., Bondell, H. D., &amp; Reich, B. J. (2020).
Bayesian regression using a prior on the model fit: The R2-D2 shrinkage
prior. Journal of the American Statistical Association.
<a href="https://arxiv.org/pdf/1609.00046.pdf">https://arxiv.org/pdf/1609.00046.pdf</a>
</p>
<p>Aguilar J. E. &amp; Bürkner P. C. (2022). Intuitive Joint Priors for Bayesian
Linear Multilevel Models: The R2D2M2 prior. ArXiv preprint.
<a href="https://arxiv.org/pdf/2208.07132.pdf">https://arxiv.org/pdf/2208.07132.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_prior(R2D2(mean_R2 = 0.8, prec_R2 = 10))

# specify the R2D2 prior across multiple parameter classes
set_prior(R2D2(mean_R2 = 0.8, prec_R2 = 10, main = TRUE), class = "b") +
  set_prior(R2D2(), class = "sd")

</code></pre>

<hr>
<h2 id='ranef.brmsfit'>Extract Group-Level Estimates</h2><span id='topic+ranef.brmsfit'></span><span id='topic+ranef'></span>

<h3>Description</h3>

<p>Extract the group-level ('random') effects of each level
from a <code>brmsfit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
ranef(
  object,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  pars = NULL,
  groups = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="ranef.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ranef.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ranef.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ranef.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Optional names of coefficients to extract.
By default, all coefficients are extracted.</p>
</td></tr>
<tr><td><code id="ranef.brmsfit_+3A_groups">groups</code></td>
<td>
<p>Optional names of grouping variables
for which to extract effects.</p>
</td></tr>
<tr><td><code id="ranef.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3D arrays (one per grouping factor).
If <code>summary</code> is <code>TRUE</code>,
the 1st dimension contains the factor levels,
the 2nd dimension contains the summary statistics
(see <code><a href="#topic+posterior_summary">posterior_summary</a></code>), and
the 3rd dimension contains the group-level effects.
If <code>summary</code> is <code>FALSE</code>, the 1st dimension contains
the posterior draws, the 2nd dimension contains the factor levels,
and the 3rd dimension contains the group-level effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zAge + zBase * Trt + (1+Trt|visit),
           data = epilepsy, family = gaussian(), chains = 2)
ranef(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='read_csv_as_stanfit'>Read CmdStan CSV files as a brms-formatted stanfit object</h2><span id='topic+read_csv_as_stanfit'></span>

<h3>Description</h3>

<p><code>read_csv_as_stanfit</code> is used internally to read CmdStan CSV files into a
<code>stanfit</code> object that is consistent with the structure of the fit slot of a
brmsfit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_csv_as_stanfit(
  files,
  variables = NULL,
  sampler_diagnostics = NULL,
  model = NULL,
  exclude = "",
  algorithm = "sampling"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_csv_as_stanfit_+3A_files">files</code></td>
<td>
<p>Character vector of CSV files names where draws are stored.</p>
</td></tr>
<tr><td><code id="read_csv_as_stanfit_+3A_variables">variables</code></td>
<td>
<p>Character vector of variables to extract from the CSV files.</p>
</td></tr>
<tr><td><code id="read_csv_as_stanfit_+3A_sampler_diagnostics">sampler_diagnostics</code></td>
<td>
<p>Character vector of sampler diagnostics to extract.</p>
</td></tr>
<tr><td><code id="read_csv_as_stanfit_+3A_model">model</code></td>
<td>
<p>A compiled cmdstanr model object (optional). Provide this argument
if you want to allow updating the model without recompilation.</p>
</td></tr>
<tr><td><code id="read_csv_as_stanfit_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of variables to exclude from the stanfit. Only
used when <code>variables</code> is also specified.</p>
</td></tr>
<tr><td><code id="read_csv_as_stanfit_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm with which the model was fitted.
See <code><a href="#topic+brm">brm</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stanfit object consistent with the structure of the <code>fit</code>
slot of a brmsfit object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit a model manually via cmdstanr
scode &lt;- stancode(count ~ Trt, data = epilepsy)
sdata &lt;- standata(count ~ Trt, data = epilepsy)
mod &lt;- cmdstanr::cmdstan_model(cmdstanr::write_stan_file(scode))
stanfit &lt;- mod$sample(data = sdata)

# feed the Stan model back into brms
fit &lt;- brm(count ~ Trt, data = epilepsy, empty = TRUE, backend = 'cmdstanr')
fit$fit &lt;- read_csv_as_stanfit(stanfit$output_files(), model = mod)
fit &lt;- rename_pars(fit)
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='recompile_model'>Recompile Stan models in <code>brmsfit</code> objects</h2><span id='topic+recompile_model'></span>

<h3>Description</h3>

<p>Recompile the Stan model inside a <code>brmsfit</code> object, if necessary.
This does not change the model, it simply recreates the executable
so that sampling is possible again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recompile_model(x, recompile = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recompile_model_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="recompile_model_+3A_recompile">recompile</code></td>
<td>
<p>Logical, indicating whether the Stan model should be
recompiled. If <code>NULL</code> (the default), <code>recompile_model</code> tries
to figure out internally, if recompilation is necessary. Setting it to
<code>FALSE</code> will cause <code>recompile_model</code> to always return the
<code>brmsfit</code> object unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (possibly updated) <code>brmsfit</code> object.
</p>

<hr>
<h2 id='reloo.brmsfit'>Compute exact cross-validation for problematic observations</h2><span id='topic+reloo.brmsfit'></span><span id='topic+reloo.loo'></span><span id='topic+reloo'></span>

<h3>Description</h3>

<p>Compute exact cross-validation for problematic observations for which
approximate leave-one-out cross-validation may return incorrect results.
Models for problematic observations can be run in parallel using the
<span class="pkg">future</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
reloo(
  x,
  loo,
  k_threshold = 0.7,
  newdata = NULL,
  resp = NULL,
  check = TRUE,
  recompile = NULL,
  future_args = list(),
  ...
)

## S3 method for class 'loo'
reloo(x, fit, ...)

reloo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reloo.brmsfit_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code>brmsfit</code> or <code>loo</code> depending
on the method.</p>
</td></tr>
<tr><td><code id="reloo.brmsfit_+3A_loo">loo</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code>loo</code>.</p>
</td></tr>
<tr><td><code id="reloo.brmsfit_+3A_k_threshold">k_threshold</code></td>
<td>
<p>The threshold at which Pareto <code class="reqn">k</code>
estimates are treated as problematic. Defaults to <code>0.7</code>.
See <code><a href="loo.html#topic+pareto-k-diagnostic">pareto_k_ids</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="reloo.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="reloo.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="reloo.brmsfit_+3A_check">check</code></td>
<td>
<p>Logical; If <code>TRUE</code> (the default), some checks
check are performed if the <code>loo</code> object was generated
from the <code>brmsfit</code> object passed to argument <code>fit</code>.</p>
</td></tr>
<tr><td><code id="reloo.brmsfit_+3A_recompile">recompile</code></td>
<td>
<p>Logical, indicating whether the Stan model should be
recompiled. This may be necessary if you are running <code>reloo</code> on
another machine than the one used to fit the model.</p>
</td></tr>
<tr><td><code id="reloo.brmsfit_+3A_future_args">future_args</code></td>
<td>
<p>A list of further arguments passed to
<code><a href="future.html#topic+future">future</a></code> for additional control over parallel
execution if activated.</p>
</td></tr>
<tr><td><code id="reloo.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="#topic+update.brmsfit">update.brmsfit</a></code> and <code><a href="#topic+log_lik.brmsfit">log_lik.brmsfit</a></code>.</p>
</td></tr>
<tr><td><code id="reloo.brmsfit_+3A_fit">fit</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code>brmsfit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warnings about Pareto <code class="reqn">k</code> estimates indicate observations
for which the approximation to LOO is problematic (this is described in
detail in Vehtari, Gelman, and Gabry (2017) and the
<span class="pkg"><a href="loo.html#topic+loo-package">loo</a></span> package documentation).
If there are <code class="reqn">J</code> observations with <code class="reqn">k</code> estimates above
<code>k_threshold</code>, then <code>reloo</code> will refit the original model
<code class="reqn">J</code> times, each time leaving out one of the <code class="reqn">J</code>
problematic observations. The pointwise contributions of these observations
to the total ELPD are then computed directly and substituted for the
previous estimates from these <code class="reqn">J</code> observations that are stored in the
original <code>loo</code> object.
</p>


<h3>Value</h3>

<p>An object of the class <code>loo</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loo">loo</a></code>, <code><a href="#topic+kfold">kfold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit1 &lt;- brm(count ~ zAge + zBase * Trt + (1|patient),
            data = epilepsy, family = poisson())
# throws warning about some pareto k estimates being too high
(loo1 &lt;- loo(fit1))
(reloo1 &lt;- reloo(fit1, loo = loo1, chains = 1))

## End(Not run)

</code></pre>

<hr>
<h2 id='rename_pars'>Rename parameters in brmsfit objects</h2><span id='topic+rename_pars'></span>

<h3>Description</h3>

<p>Rename parameters within the <code>stanfit</code> object
after model fitting to ensure reasonable parameter names. This function is
usually called automatically by <code><a href="#topic+brm">brm</a></code> and users will rarely be
required to call it themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_pars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_pars_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>rename_pars</code> is a deprecated alias of <code>rename_pars</code>.
</p>


<h3>Value</h3>

<p>A <code>brmsfit</code> object with adjusted parameter names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit a model manually via rstan
scode &lt;- stancode(count ~ Trt, data = epilepsy)
sdata &lt;- standata(count ~ Trt, data = epilepsy)
stanfit &lt;- rstan::stan(model_code = scode, data = sdata)

# feed the Stan model back into brms
fit &lt;- brm(count ~ Trt, data = epilepsy, empty = TRUE)
fit$fit &lt;- stanfit
fit &lt;- rename_pars(fit)
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='residuals.brmsfit'>Posterior Draws of Residuals/Predictive Errors</h2><span id='topic+residuals.brmsfit'></span>

<h3>Description</h3>

<p>This method is an alias of <code><a href="#topic+predictive_error.brmsfit">predictive_error.brmsfit</a></code>
with additional arguments for obtaining summaries of the computed draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
residuals(
  object,
  newdata = NULL,
  re_formula = NULL,
  method = "posterior_predict",
  type = c("ordinary", "pearson"),
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  sort = FALSE,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_method">method</code></td>
<td>
<p>Method used to obtain predictions. Can be set to
<code>"posterior_predict"</code> (the default), <code>"posterior_epred"</code>,
or <code>"posterior_linpred"</code>. For more details, see the respective
function documentations.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_type">type</code></td>
<td>
<p>The type of the residuals,
either <code>"ordinary"</code> or <code>"pearson"</code>.
More information is provided under 'Details'.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many posterior draws should
be used. If <code>NULL</code> (the default) all draws are used. Ignored if
<code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer vector specifying the posterior draws to be used.
If <code>NULL</code> (the default), all draws are used.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_sort">sort</code></td>
<td>
<p>Logical. Only relevant for time series models.
Indicating whether to return predicted values in the original
order (<code>FALSE</code>; default) or in the order of the
time series (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>..</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals of type <code>'ordinary'</code> are of the form <code class="reqn">R = Y -
  Yrep</code>, where <code class="reqn">Y</code> is the observed and <code class="reqn">Yrep</code> is the predicted response.
Residuals of type <code>pearson</code> are of the form <code class="reqn">R = (Y - Yrep) /
  SD(Yrep)</code>, where <code class="reqn">SD(Yrep)</code> is an estimate of the standard deviation of
<code class="reqn">Yrep</code>.
</p>


<h3>Value</h3>

<p>An <code>array</code> of predictive error/residual draws. If
<code>summary = FALSE</code> the output resembles those of
<code><a href="#topic+predictive_error.brmsfit">predictive_error.brmsfit</a></code>. If <code>summary = TRUE</code> the output
is an N x E matrix, where N is the number of observations and E denotes
the summary statistics computed from the draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fit a model
fit &lt;- brm(rating ~ treat + period + carry + (1|subject),
           data = inhaler, cores = 2)

## extract residuals/predictive errors
res &lt;- residuals(fit)
head(res)

## End(Not run)

</code></pre>

<hr>
<h2 id='restructure'>Restructure Old R Objects</h2><span id='topic+restructure'></span>

<h3>Description</h3>

<p><code>restructure</code> is a generic function used to restructure old R objects to
work with newer versions of the package that generated them. Its original
use is within the <span class="pkg">brms</span> package, but new methods for use with objects
from other packages can be registered to the same generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restructure(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restructure_+3A_x">x</code></td>
<td>
<p>An object to be restructured. The object's class will determine
which method to apply</p>
</td></tr>
<tr><td><code id="restructure_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the specific methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually the version of the package that generated the object will be
stored somewhere in the object and this information will be used by the
specific method to determine what transformations to apply. See
<code><a href="#topic+restructure.brmsfit">restructure.brmsfit</a></code> for the default
method applied for <span class="pkg">brms</span> models. You can view the available methods by
typing: <code>methods(restructure)</code>
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> compatible with the latest
version of the package that generated it.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+restructure.brmsfit">restructure.brmsfit</a></code>
</p>

<hr>
<h2 id='restructure.brmsfit'>Restructure Old <code>brmsfit</code> Objects</h2><span id='topic+restructure.brmsfit'></span>

<h3>Description</h3>

<p>Restructure old <code>brmsfit</code> objects to work with
the latest <span class="pkg">brms</span> version. This function is called
internally when applying post-processing methods.
However, in order to avoid unnecessary run time caused
by the restructuring, I recommend explicitly calling
<code>restructure</code> once per model after updating <span class="pkg">brms</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
restructure(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restructure.brmsfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="restructure.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you are restructuring an old spline model (fitted with brms &lt; 2.19.3) to
avoid prediction inconsistencies between machines (see GitHub issue #1465),
please make sure to <code>restructure</code> your model on the machine on which it
was originally fitted.
</p>


<h3>Value</h3>

<p>A <code>brmsfit</code> object compatible with the latest version
of <span class="pkg">brms</span>.
</p>

<hr>
<h2 id='rows2labels'>Convert Rows to Labels</h2><span id='topic+rows2labels'></span>

<h3>Description</h3>

<p>Convert information in rows to labels for each row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rows2labels(x, digits = 2, sep = " &amp; ", incl_vars = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rows2labels_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> for which to extract labels.</p>
</td></tr>
<tr><td><code id="rows2labels_+3A_digits">digits</code></td>
<td>
<p>Minimal number of decimal places shown in
the labels of numeric variables.</p>
</td></tr>
<tr><td><code id="rows2labels_+3A_sep">sep</code></td>
<td>
<p>A single character string defining the separator
between variables used in the labels.</p>
</td></tr>
<tr><td><code id="rows2labels_+3A_incl_vars">incl_vars</code></td>
<td>
<p>Indicates if variable names should
be part of the labels. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rows2labels_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same length as the number
of rows of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_conditions">make_conditions</a></code>, <code><a href="#topic+conditional_effects">conditional_effects</a></code>
</p>

<hr>
<h2 id='s'>Defining smooths in <span class="pkg">brms</span> formulas</h2><span id='topic+s'></span><span id='topic+t2'></span>

<h3>Description</h3>

<p>Functions used in definition of smooth terms within a model formulas.
The function does not evaluate a (spline) smooth - it exists purely
to help set up a model using spline based smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s(...)

t2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="mgcv.html#topic+s">mgcv::s</a></code> or
<code><a href="mgcv.html#topic+t2">mgcv::t2</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function defined here are just simple wrappers of the respective
functions of the <span class="pkg">mgcv</span> package. When using them, please cite the
appropriate references obtained via <code>citation("mgcv")</code>.
</p>
<p><span class="pkg">brms</span> uses the &quot;random effects&quot; parameterization of smoothing splines
as explained in <code><a href="mgcv.html#topic+gamm">mgcv::gamm</a></code>. A nice tutorial on this
topic can be found in Pedersen et al. (2019). The answers provided in this
<a href="https://discourse.mc-stan.org/t/better-priors-non-flat-for-gams-brms/23012/4">Stan discourse post</a>
may also be helpful.
</p>


<h3>References</h3>

<p>Pedersen, E. J., Miller, D. L., Simpson, G. L., &amp; Ross, N. (2019).
Hierarchical generalized additive models in ecology: an introduction with
mgcv. PeerJ.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brmsformula">brmsformula</a></code>,
<code><a href="mgcv.html#topic+s">mgcv::s</a></code>, <code><a href="mgcv.html#topic+t2">mgcv::t2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate some data
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)

# fit univariate smooths for all predictors
fit1 &lt;- brm(y ~ s(x0) + s(x1) + s(x2) + s(x3),
            data = dat, chains = 2)
summary(fit1)
plot(conditional_smooths(fit1), ask = FALSE)

# fit a more complicated smooth model
fit2 &lt;- brm(y ~ t2(x0, x1) + s(x2, by = x3),
            data = dat, chains = 2)
summary(fit2)
plot(conditional_smooths(fit2), ask = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='sar'>Spatial simultaneous autoregressive (SAR) structures</h2><span id='topic+sar'></span>

<h3>Description</h3>

<p>Set up an spatial simultaneous autoregressive (SAR) term in <span class="pkg">brms</span>. The
function does not evaluate its arguments &ndash; it exists purely to help set up a
model with SAR terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar(M, type = "lag")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sar_+3A_m">M</code></td>
<td>
<p>An object specifying the spatial weighting matrix.
Can be either the spatial weight matrix itself or an
object of class <code>listw</code> or <code>nb</code>, from which
the spatial weighting matrix can be computed.</p>
</td></tr>
<tr><td><code id="sar_+3A_type">type</code></td>
<td>
<p>Type of the SAR structure. Either <code>"lag"</code>
(for SAR of the response values) or <code>"error"</code>
(for SAR of the residuals). More information is
provided in the 'Details' section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lagsar</code> structure implements SAR of the response values:
</p>
<p style="text-align: center;"><code class="reqn">y = \rho W y + \eta + e</code>
</p>

<p>The <code>errorsar</code> structure implements SAR of the residuals:
</p>
<p style="text-align: center;"><code class="reqn">y = \eta + u, u = \rho W u + e</code>
</p>

<p>In the above equations, <code class="reqn">\eta</code> is the predictor term and <code class="reqn">e</code> are
independent normally or t-distributed residuals. Currently, only families
<code>gaussian</code> and <code>student</code> support SAR structures.
</p>


<h3>Value</h3>

<p>An object of class <code>'sar_term'</code>, which is a list
of arguments to be interpreted by the formula
parsing functions of <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocor-terms">autocor-terms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(oldcol, package = "spdep")
fit1 &lt;- brm(CRIME ~ INC + HOVAL + sar(COL.nb, type = "lag"),
            data = COL.OLD, data2 = list(COL.nb = COL.nb),
            chains = 2, cores = 2)
summary(fit1)
plot(fit1)

fit2 &lt;- brm(CRIME ~ INC + HOVAL + sar(COL.nb, type = "error"),
            data = COL.OLD, data2 = list(COL.nb = COL.nb),
            chains = 2, cores = 2)
summary(fit2)
plot(fit2)

## End(Not run)

</code></pre>

<hr>
<h2 id='save_pars'>Control Saving of Parameter Draws</h2><span id='topic+save_pars'></span>

<h3>Description</h3>

<p>Control which (draws of) parameters should be saved in a <span class="pkg">brms</span>
model. The output of this function is meant for usage in the
<code>save_pars</code> argument of <code><a href="#topic+brm">brm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_pars(group = TRUE, latent = FALSE, all = FALSE, manual = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_pars_+3A_group">group</code></td>
<td>
<p>A flag to indicate if group-level coefficients for
each level of the grouping factors should be saved (default is
<code>TRUE</code>). Set to <code>FALSE</code> to save memory. Alternatively,
<code>group</code> may also be a character vector naming the grouping factors
for which to save draws of coefficients.</p>
</td></tr>
<tr><td><code id="save_pars_+3A_latent">latent</code></td>
<td>
<p>A flag to indicate if draws of latent variables obtained by
using <code>me</code> and <code>mi</code> terms should be saved (default is
<code>FALSE</code>). Saving these draws allows to better use methods such as
<code>posterior_predict</code> with the latent variables but leads to very large
<span class="rlang"><b>R</b></span> objects even for models of moderate size and complexity. Alternatively,
<code>latent</code> may also be a character vector naming the latent variables
for which to save draws.</p>
</td></tr>
<tr><td><code id="save_pars_+3A_all">all</code></td>
<td>
<p>A flag to indicate if draws of all variables defined in Stan's
<code>parameters</code> block should be saved (default is <code>FALSE</code>). Saving
these draws is required in order to apply the certain methods such as
<code>bridge_sampler</code> and <code>bayes_factor</code>.</p>
</td></tr>
<tr><td><code id="save_pars_+3A_manual">manual</code></td>
<td>
<p>A character vector naming Stan variable names which should be
saved. These names should match the variable names inside the Stan code
before renaming. This feature is meant for power users only and will rarely
be useful outside of very special cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"save_pars"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# don't store group-level coefficients
fit &lt;- brm(count ~ zAge + zBase * Trt + (1|patient),
           data = epilepsy, family = poisson(),
           save_pars = save_pars(group = FALSE))
variables(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='set_prior'>Prior Definitions for <span class="pkg">brms</span> Models</h2><span id='topic+set_prior'></span><span id='topic+brmsprior'></span><span id='topic+brmsprior-class'></span><span id='topic+prior'></span><span id='topic+prior_'></span><span id='topic+prior_string'></span><span id='topic+empty_prior'></span>

<h3>Description</h3>

<p>Define priors for specific parameters or classes of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_prior(
  prior,
  class = "b",
  coef = "",
  group = "",
  resp = "",
  dpar = "",
  nlpar = "",
  lb = NA,
  ub = NA,
  check = TRUE
)

prior(prior, ...)

prior_(prior, ...)

prior_string(prior, ...)

empty_prior()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_prior_+3A_prior">prior</code></td>
<td>
<p>A character string defining a distribution in <span class="pkg">Stan</span> language</p>
</td></tr>
<tr><td><code id="set_prior_+3A_class">class</code></td>
<td>
<p>The parameter class. Defaults to <code>"b"</code>
(i.e. population-level effects).
See 'Details' for other valid parameter classes.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_coef">coef</code></td>
<td>
<p>Name of the coefficient within the parameter class.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_group">group</code></td>
<td>
<p>Grouping factor for group-level parameters.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_resp">resp</code></td>
<td>
<p>Name of the response variable.
Only used in multivariate models.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_dpar">dpar</code></td>
<td>
<p>Name of a distributional parameter.
Only used in distributional models.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_nlpar">nlpar</code></td>
<td>
<p>Name of a non-linear parameter.
Only used in non-linear models.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_lb">lb</code></td>
<td>
<p>Lower bound for parameter restriction. Currently only allowed
for classes <code>"b"</code>. Defaults to <code>NULL</code>, that is no restriction.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_ub">ub</code></td>
<td>
<p>Upper bound for parameter restriction. Currently only allowed
for classes <code>"b"</code>. Defaults to <code>NULL</code>, that is no restriction.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_check">check</code></td>
<td>
<p>Logical; Indicates whether priors
should be checked for validity (as far as possible).
Defaults to <code>TRUE</code>. If <code>FALSE</code>, <code>prior</code> is passed
to the Stan code as is, and all other arguments are ignored.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>set_prior</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>set_prior</code> is used to define prior distributions for parameters
in <span class="pkg">brms</span> models. The functions <code>prior</code>, <code>prior_</code>, and
<code>prior_string</code> are aliases of <code>set_prior</code> each allowing
for a different kind of argument specification.
<code>prior</code> allows specifying arguments as expression without
quotation marks using non-standard evaluation.
<code>prior_</code> allows specifying arguments as one-sided formulas
or wrapped in <code>quote</code>.
<code>prior_string</code> allows specifying arguments as strings just
as <code>set_prior</code> itself.
</p>
<p>Below, we explain its usage and list some common
prior distributions for parameters.
A complete overview on possible prior distributions is given
in the Stan Reference Manual available at <a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>
<p>To combine multiple priors, use <code>c(...)</code> or the <code>+</code> operator
(see 'Examples'). <span class="pkg">brms</span> does not check if the priors are written
in correct <span class="pkg">Stan</span> language. Instead, <span class="pkg">Stan</span> will check their
syntactical correctness when the model is parsed to <code>C++</code> and
returns an error if they are not.
This, however, does not imply that priors are always meaningful if they are
accepted by <span class="pkg">Stan</span>. Although <span class="pkg">brms</span> trys to find common problems
(e.g., setting bounded priors on unbounded parameters), there is no guarantee
that the defined priors are reasonable for the model.
Below, we list the types of parameters in <span class="pkg">brms</span> models,
for which the user can specify prior distributions.
</p>
<p>Below, we provide details for the individual parameter classes that you can
set priors on. Often, it may not be immediately clear, which parameters are
present in the model. To get a full list of parameters and parameter
classes for which priors can be specified (depending on the model) use
function <code><a href="#topic+default_prior.default">default_prior</a></code>.
</p>
<p>1. Population-level ('fixed') effects
</p>
<p>Every Population-level effect has its own regression parameter
represents the name of the corresponding population-level effect.
Suppose, for instance, that <code>y</code> is predicted by <code>x1</code> and <code>x2</code>
(i.e., <code>y ~ x1 + x2</code> in formula syntax).
Then, <code>x1</code> and <code>x2</code> have regression parameters
<code>b_x1</code> and <code>b_x2</code> respectively.
The default prior for population-level effects (including monotonic and
category specific effects) is an improper flat prior over the reals.
Other common options are normal priors or student-t priors.
If we want to have a normal prior with mean 0 and
standard deviation 5 for <code>x1</code>, and a unit student-t prior with 10
degrees of freedom for <code>x2</code>, we can specify this via
<code>set_prior("normal(0,5)", class = "b", coef = "x1")</code> and <br />
<code>set_prior("student_t(10, 0, 1)", class = "b", coef = "x2")</code>.
To put the same prior on all population-level effects at once,
we may write as a shortcut <code>set_prior("&lt;prior&gt;", class = "b")</code>.
This also leads to faster sampling, because priors can be vectorized in this case.
Both ways of defining priors can be combined using for instance
<code>set_prior("normal(0, 2)", class = "b")</code> and <br />
<code>set_prior("normal(0, 10)", class = "b", coef = "x1")</code>
at the same time. This will set a <code>normal(0, 10)</code> prior on
the effect of <code>x1</code> and a <code>normal(0, 2)</code> prior
on all other population-level effects.
However, this will break vectorization and
may slow down the sampling procedure a bit.
</p>
<p>In case of the default intercept parameterization
(discussed in the 'Details' section of <code><a href="#topic+brmsformula">brmsformula</a></code>),
general priors on class <code>"b"</code> will <em>not</em> affect
the intercept. Instead, the intercept has its own parameter class
named <code>"Intercept"</code> and priors can thus be
specified via <code>set_prior("&lt;prior&gt;", class = "Intercept")</code>.
Setting a prior on the intercept will not break vectorization
of the other population-level effects.
Note that technically, this prior is set on an intercept that
results when internally centering all population-level predictors
around zero to improve sampling efficiency. On this centered
intercept, specifying a prior is actually much easier and
intuitive than on the original intercept, since the former
represents the expected response value when all predictors
are at their means. To treat the intercept as an ordinary
population-level effect and avoid the centering parameterization,
use <code>0 + Intercept</code> on the right-hand side of the model formula.
</p>
<p>In non-linear models, population-level effects are defined separately
for each non-linear parameter. Accordingly, it is necessary to specify
the non-linear parameter in <code>set_prior</code> so that priors
we can be assigned correctly.
If, for instance, <code>alpha</code> is the parameter and <code>x</code> the predictor
for which we want to define the prior, we can write
<code>set_prior("&lt;prior&gt;", coef = "x", nlpar = "alpha")</code>.
As a shortcut we can use <code>set_prior("&lt;prior&gt;", nlpar = "alpha")</code>
to set the same prior on all population-level effects of <code>alpha</code> at once.
</p>
<p>The same goes for specifying priors for specific distributional
parameters in the context of distributional regression, for example,
<code>set_prior("&lt;prior&gt;", coef = "x", dpar = "sigma")</code>.
For most other parameter classes (see below), you need to indicate
non-linear and distributional parameters in the same way as shown here.
</p>
<p>If desired, population-level effects can be restricted to fall only
within a certain interval using the <code>lb</code> and <code>ub</code> arguments
of <code>set_prior</code>. This is often required when defining priors
that are not defined everywhere on the real line, such as uniform
or gamma priors. When defining a <code>uniform(2,4)</code> prior,
you should write <code>set_prior("uniform(2,4)", lb = 2, ub = 4)</code>.
When using a prior that is defined on the positive reals only
(such as a gamma prior) set <code>lb = 0</code>.
In most situations, it is not useful to restrict population-level
parameters through bounded priors
(non-linear models are an important exception),
but if you really want to this is the way to go.
</p>
<p>2. Group-level ('random') effects
</p>
<p>Each group-level effect of each grouping factor has a standard deviation named
<code>sd_&lt;group&gt;_&lt;coef&gt;</code>. Consider, for instance, the formula
<code>y ~ x1 + x2 + (1 + x1 | g)</code>.
We see that the intercept as well as <code>x1</code> are group-level effects
nested in the grouping factor <code>g</code>.
The corresponding standard deviation parameters are named as
<code>sd_g_Intercept</code> and <code>sd_g_x1</code> respectively.
These parameters are restricted to be non-negative and, by default,
have a half student-t prior with 3 degrees of freedom and a
scale parameter that depends on the standard deviation of the response
after applying the link function. Minimally, the scale parameter is 2.5.
This prior is used (a) to be only weakly informative in order to influence
results as few as possible, while (b) providing at least some regularization
to considerably improve convergence and sampling efficiency.
To define a prior distribution only for standard deviations
of a specific grouping factor,
use <br /> <code>set_prior("&lt;prior&gt;", class = "sd", group = "&lt;group&gt;")</code>.
To define a prior distribution only for a specific standard deviation
of a specific grouping factor, you may write <br />
<code>set_prior("&lt;prior&gt;", class = "sd", group = "&lt;group&gt;", coef = "&lt;coef&gt;")</code>.
</p>
<p>If there is more than one group-level effect per grouping factor,
the correlations between those effects have to be estimated.
The prior <code>lkj_corr_cholesky(eta)</code> or in short
<code>lkj(eta)</code> with <code>eta &gt; 0</code>
is essentially the only prior for (Cholesky factors) of correlation matrices.
If <code>eta = 1</code> (the default) all correlations matrices
are equally likely a priori. If <code>eta &gt; 1</code>, extreme correlations
become less likely, whereas <code>0 &lt; eta &lt; 1</code> results in
higher probabilities for extreme correlations.
Correlation matrix parameters in <code>brms</code> models are named as
<code>cor_&lt;group&gt;</code>, (e.g., <code>cor_g</code> if <code>g</code> is the grouping factor).
To set the same prior on every correlation matrix,
use for instance <code>set_prior("lkj(2)", class = "cor")</code>.
Internally, the priors are transformed to be put on the Cholesky factors
of the correlation matrices to improve efficiency and numerical stability.
The corresponding parameter class of the Cholesky factors is <code>L</code>,
but it is not recommended to specify priors for this parameter class directly.
</p>
<p>4. Smoothing Splines
</p>
<p>Smoothing splines are implemented in <span class="pkg">brms</span> using the 'random effects'
formulation as explained in <code><a href="mgcv.html#topic+gamm">gamm</a></code>). Thus, each
spline has its corresponding standard deviations modeling the variability
within this term. In <span class="pkg">brms</span>, this parameter class is called <code>sds</code>
and priors can be specified via
<code>set_prior("&lt;prior&gt;", class = "sds", coef = "&lt;term label&gt;")</code>.
The default prior is the same as for standard deviations of group-level effects.
</p>
<p>5. Gaussian processes
</p>
<p>Gaussian processes as currently implemented in <span class="pkg">brms</span> have two
parameters, the standard deviation parameter <code>sdgp</code>, and
characteristic length-scale parameter <code>lscale</code> (see <code><a href="#topic+gp">gp</a></code>
for more details). The default prior of <code>sdgp</code> is the same as for
standard deviations of group-level effects. The default prior of
<code>lscale</code> is an informative inverse-gamma prior specifically tuned to
the covariates of the Gaussian process (for more details see
<a href="https://betanalpha.github.io/assets/case_studies/gp_part3/part3.html">https://betanalpha.github.io/assets/case_studies/gp_part3/part3.html</a>).
This tuned prior may be overly informative in some cases, so please
consider other priors as well to make sure inference is robust to the prior
specification. If tuning fails, a half-normal prior is used instead.
</p>
<p>6. Autocorrelation parameters
</p>
<p>The autocorrelation parameters currently implemented are named <code>ar</code>
(autoregression), <code>ma</code> (moving average), <code>sderr</code> (standard
deviation of latent residuals in latent ARMA models), <code>cosy</code> (compound
symmetry correlation), <code>car</code> (spatial conditional autoregression), as
well as <code>lagsar</code> and <code>errorsar</code> (spatial simultaneous
autoregression).
</p>
<p>Priors can be defined by <code>set_prior("&lt;prior&gt;", class = "ar")</code> for
<code>ar</code> and similar for other autocorrelation parameters. By default,
<code>ar</code> and <code>ma</code> are bounded between <code>-1</code> and <code>1</code>;
<code>cosy</code>, <code>car</code>, <code>lagsar</code>, and <code>errorsar</code> are bounded
between <code>0</code> and <code>1</code>. The default priors are flat over the
respective definition areas.
</p>
<p>7. Parameters of measurement error terms
</p>
<p>Latent variables induced via measurement error <code><a href="#topic+me">me</a></code> terms
require both mean and standard deviation parameters, whose prior classes
are named <code>"meanme"</code> and <code>"sdme"</code>, respectively. If multiple
latent variables are induced this way, their correlation matrix will
be modeled as well and corresponding priors can be specified via the
<code>"corme"</code> class. All of the above parameters have flat priors over
their respective definition spaces by default.
</p>
<p>8. Distance parameters of monotonic effects
</p>
<p>As explained in the details section of <code><a href="#topic+brm">brm</a></code>,
monotonic effects make use of a special parameter vector to
estimate the 'normalized distances' between consecutive predictor
categories. This is realized in <span class="pkg">Stan</span> using the <code>simplex</code>
parameter type. This class is named <code>"simo"</code> (short for
simplex monotonic) in <span class="pkg">brms</span>.
The only valid prior for simplex parameters is the
dirichlet prior, which accepts a vector of length <code>K - 1</code>
(K = number of predictor categories) as input defining the
'concentration' of the distribution. Explaining the dirichlet prior
is beyond the scope of this documentation, but we want to describe
how to define this prior syntactically correct.
If a predictor <code>x</code> with <code>K</code> categories is modeled as monotonic,
we can define a prior on its corresponding simplex via <br />
<code>prior(dirichlet(&lt;vector&gt;), class = simo, coef = mox1)</code>.
The <code>1</code> in the end of <code>coef</code> indicates that this is the first
simplex in this term. If interactions between multiple monotonic
variables are modeled, multiple simplexes per term are required.
For <code>&lt;vector&gt;</code>, we can put in any <code>R</code> expression
defining a vector of length <code>K - 1</code>. The default is a uniform
prior (i.e. <code>&lt;vector&gt; = rep(1, K-1)</code>) over all simplexes
of the respective dimension.
</p>
<p>9. Parameters for specific families
</p>
<p>Some families need additional parameters to be estimated.
Families <code>gaussian</code>, <code>student</code>, <code>skew_normal</code>,
<code>lognormal</code>, and <code>gen_extreme_value</code> need the parameter
<code>sigma</code> to account for the residual standard deviation.
By default, <code>sigma</code> has a half student-t prior that scales
in the same way as the group-level standard deviations.
Further, family <code>student</code> needs the parameter
<code>nu</code> representing the degrees of freedom of Student-t distribution.
By default, <code>nu</code> has prior <code>gamma(2, 0.1)</code>, which is
close to a penalized complexity prior (see Stan prior choice Wiki),
and a fixed lower bound of <code>1</code>.
Family <code>negbinomial</code> needs a <code>shape</code> parameter that has by
default <code>inv_gamma(0.4, 0.3)</code> prior which is close to a
penalized complexity prior (see Stan prior choice Wiki).
Families <code>gamma</code>, <code>weibull</code>, and <code>inverse.gaussian</code>,
need a <code>shape</code> parameter that has a <code>gamma(0.01, 0.01)</code>
prior by default.
For families <code>cumulative</code>, <code>cratio</code>, <code>sratio</code>,
and <code>acat</code>, and only if <code>threshold = "equidistant"</code>,
the parameter <code>delta</code> is used to model the distance between
two adjacent thresholds.
By default, <code>delta</code> has an improper flat prior over the reals.
The <code>von_mises</code> family needs the parameter <code>kappa</code>, representing
the concentration parameter. By default, <code>kappa</code> has prior
<code>gamma(2, 0.01)</code>.
</p>
<p>Every family specific parameter has its own prior class, so that
<code>set_prior("&lt;prior&gt;", class = "&lt;parameter&gt;")</code> is the right way to go.
All of these priors are chosen to be weakly informative,
having only minimal influence on the estimations,
while improving convergence and sampling efficiency.
</p>
<p>10. Shrinkage priors
</p>
<p>To reduce the danger of overfitting in models with many predictor terms fit
on comparably sparse data, brms supports special shrinkage priors, namely
the (regularized) <code><a href="#topic+horseshoe">horseshoe</a></code> and the <code><a href="#topic+R2D2">R2D2</a></code> prior.
These priors can be applied on many parameter classes, either directly on
the coefficient classes (e.g., class <code>b</code>), if directly setting priors
on them is supported, or on the corresponding standard deviation
hyperparameters (e.g., class <code>sd</code>) otherwise. Currently, the following
classes support shrinkage priors: <code>b</code> (overall regression
coefficients), <code>sds</code> (SDs of smoothing splines), <code>sdgp</code> (SDs of
Gaussian processes), <code>ar</code> (autoregressive coefficients), <code>ma</code>
(moving average coefficients), <code>sderr</code> (SD of latent residuals),
<code>sdcar</code> (SD of spatial CAR structures), <code>sd</code> (SD of varying
coefficients).
</p>
<p>11. Fixing parameters to constants
</p>
<p>Fixing parameters to constants is possible by using the <code>constant</code>
function, for example, <code>constant(1)</code> to fix a parameter to 1.
Broadcasting to vectors and matrices is done automatically.
</p>


<h3>Value</h3>

<p>An object of class <code>brmsprior</code> to be used in the <code>prior</code>
argument of <code><a href="#topic+brm">brm</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>prior()</code>: Alias of <code>set_prior</code> allowing to
specify arguments as expressions without quotation marks.
</p>
</li>
<li> <p><code>prior_()</code>: Alias of <code>set_prior</code> allowing to specify
arguments as as one-sided formulas or wrapped in <code>quote</code>.
</p>
</li>
<li> <p><code>prior_string()</code>: Alias of <code>set_prior</code> allowing to
specify arguments as strings.
</p>
</li>
<li> <p><code>empty_prior()</code>: Create an empty <code>brmsprior</code> object.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+default_prior.default">default_prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use alias functions
(prior1 &lt;- prior(cauchy(0, 1), class = sd))
(prior2 &lt;- prior_(~cauchy(0, 1), class = ~sd))
(prior3 &lt;- prior_string("cauchy(0, 1)", class = "sd"))
identical(prior1, prior2)
identical(prior1, prior3)

# check which parameters can have priors
default_prior(rating ~ treat + period + carry + (1|subject),
             data = inhaler, family = cumulative())

# define some priors
bprior &lt;- c(prior_string("normal(0,10)", class = "b"),
            prior(normal(1,2), class = b, coef = treat),
            prior_(~cauchy(0,2), class = ~sd,
                   group = ~subject, coef = ~Intercept))

# verify that the priors indeed found their way into Stan's model code
stancode(rating ~ treat + period + carry + (1|subject),
         data = inhaler, family = cumulative(),
         prior = bprior)

# use the horseshoe prior to model sparsity in regression coefficients
stancode(count ~ zAge + zBase * Trt,
         data = epilepsy, family = poisson(),
         prior = set_prior("horseshoe(3)"))

# fix certain priors to constants
bprior &lt;- prior(constant(1), class = "b") +
  prior(constant(2), class = "b", coef = "zBase") +
  prior(constant(0.5), class = "sd")
stancode(count ~ zAge + zBase + (1 | patient),
              data = epilepsy, prior = bprior)

# pass priors to Stan without checking
prior &lt;- prior_string("target += normal_lpdf(b[1] | 0, 1)", check = FALSE)
stancode(count ~ Trt, data = epilepsy, prior = prior)

# define priors in a vectorized manner
# useful in particular for categorical or multivariate models
set_prior("normal(0, 2)", dpar = c("muX", "muY", "muZ"))

</code></pre>

<hr>
<h2 id='Shifted_Lognormal'>The Shifted Log Normal Distribution</h2><span id='topic+Shifted_Lognormal'></span><span id='topic+dshifted_lnorm'></span><span id='topic+pshifted_lnorm'></span><span id='topic+qshifted_lnorm'></span><span id='topic+rshifted_lnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the shifted log normal distribution with mean <code>meanlog</code>,
standard deviation <code>sdlog</code>, and shift parameter <code>shift</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dshifted_lnorm(x, meanlog = 0, sdlog = 1, shift = 0, log = FALSE)

pshifted_lnorm(
  q,
  meanlog = 0,
  sdlog = 1,
  shift = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

qshifted_lnorm(
  p,
  meanlog = 0,
  sdlog = 1,
  shift = 0,
  lower.tail = TRUE,
  log.p = FALSE
)

rshifted_lnorm(n, meanlog = 0, sdlog = 1, shift = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Shifted_Lognormal_+3A_x">x</code>, <code id="Shifted_Lognormal_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Shifted_Lognormal_+3A_meanlog">meanlog</code></td>
<td>
<p>Vector of means.</p>
</td></tr>
<tr><td><code id="Shifted_Lognormal_+3A_sdlog">sdlog</code></td>
<td>
<p>Vector of standard deviations.</p>
</td></tr>
<tr><td><code id="Shifted_Lognormal_+3A_shift">shift</code></td>
<td>
<p>Vector of shifts.</p>
</td></tr>
<tr><td><code id="Shifted_Lognormal_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="Shifted_Lognormal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="Shifted_Lognormal_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="Shifted_Lognormal_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="Shifted_Lognormal_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details
on the parameterization.
</p>

<hr>
<h2 id='SkewNormal'>The Skew-Normal Distribution</h2><span id='topic+SkewNormal'></span><span id='topic+dskew_normal'></span><span id='topic+pskew_normal'></span><span id='topic+qskew_normal'></span><span id='topic+rskew_normal'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation for the
skew-normal distribution with mean <code>mu</code>,
standard deviation <code>sigma</code>, and skewness <code>alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dskew_normal(
  x,
  mu = 0,
  sigma = 1,
  alpha = 0,
  xi = NULL,
  omega = NULL,
  log = FALSE
)

pskew_normal(
  q,
  mu = 0,
  sigma = 1,
  alpha = 0,
  xi = NULL,
  omega = NULL,
  lower.tail = TRUE,
  log.p = FALSE
)

qskew_normal(
  p,
  mu = 0,
  sigma = 1,
  alpha = 0,
  xi = NULL,
  omega = NULL,
  lower.tail = TRUE,
  log.p = FALSE,
  tol = 1e-08
)

rskew_normal(n, mu = 0, sigma = 1, alpha = 0, xi = NULL, omega = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SkewNormal_+3A_x">x</code>, <code id="SkewNormal_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_mu">mu</code></td>
<td>
<p>Vector of mean values.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_sigma">sigma</code></td>
<td>
<p>Vector of standard deviation values.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_alpha">alpha</code></td>
<td>
<p>Vector of skewness values.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_xi">xi</code></td>
<td>
<p>Optional vector of location values.
If <code>NULL</code> (the default), will be computed internally.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_omega">omega</code></td>
<td>
<p>Optional vector of scale values.
If <code>NULL</code> (the default), will be computed internally.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_tol">tol</code></td>
<td>
<p>Tolerance of the approximation used in the
computation of quantiles.</p>
</td></tr>
<tr><td><code id="SkewNormal_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details
on the parameterization.
</p>

<hr>
<h2 id='stancode'>Stan Code for Bayesian models</h2><span id='topic+stancode'></span><span id='topic+make_stancode'></span>

<h3>Description</h3>

<p><code>stancode</code> is a generic function that can be used to
generate Stan code for Bayesian models. Its original use is
within the <span class="pkg">brms</span> package, but new methods for use
with objects from other packages can be registered to the same generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stancode(object, ...)

make_stancode(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stancode_+3A_object">object</code></td>
<td>
<p>An object whose class will determine which method to apply.
Usually, it will be some kind of symbolic description of the model
form which Stan code should be generated.</p>
</td></tr>
<tr><td><code id="stancode_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the specific method.</p>
</td></tr>
<tr><td><code id="stancode_+3A_formula">formula</code></td>
<td>
<p>Synonym of <code>object</code> for use in <code>make_stancode</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+stancode.default">stancode.default</a></code> for the default
method applied for <span class="pkg">brms</span> models.
You can view the available methods by typing: <code>methods(stancode)</code>
The <code>make_stancode</code> function is an alias of <code>stancode</code>.
</p>


<h3>Value</h3>

<p>Usually, a character string containing the generated Stan code.
For pretty printing, we recommend the returned object to be of class
<code>c("character", "brmsmodel")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stancode.default">stancode.default</a></code>, <code><a href="#topic+stancode.brmsfit">stancode.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stancode(rating ~ treat + period + carry + (1|subject),
         data = inhaler, family = "cumulative")

</code></pre>

<hr>
<h2 id='stancode.brmsfit'>Extract Stan code from <code>brmsfit</code> objects</h2><span id='topic+stancode.brmsfit'></span>

<h3>Description</h3>

<p>Extract Stan code from a fitted <span class="pkg">brms</span> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
stancode(
  object,
  version = TRUE,
  regenerate = NULL,
  threads = NULL,
  backend = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stancode.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="stancode.brmsfit_+3A_version">version</code></td>
<td>
<p>Logical; indicates if the first line containing the <span class="pkg">brms</span>
version number should be included. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stancode.brmsfit_+3A_regenerate">regenerate</code></td>
<td>
<p>Logical; indicates if the Stan code should be regenerated
with the current <span class="pkg">brms</span> version. By default, <code>regenerate</code> will be
<code>FALSE</code> unless required to be <code>TRUE</code> by other arguments.</p>
</td></tr>
<tr><td><code id="stancode.brmsfit_+3A_threads">threads</code></td>
<td>
<p>Controls whether the Stan code should be threaded. See
<code><a href="#topic+threading">threading</a></code> for details.</p>
</td></tr>
<tr><td><code id="stancode.brmsfit_+3A_backend">backend</code></td>
<td>
<p>Controls the Stan backend. See <code><a href="#topic+brm">brm</a></code> for details.</p>
</td></tr>
<tr><td><code id="stancode.brmsfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="#topic+stancode.default">stancode</a></code> if the Stan code is
regenerated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stan code for further processing.
</p>

<hr>
<h2 id='stancode.default'>Stan Code for <span class="pkg">brms</span> Models</h2><span id='topic+stancode.default'></span>

<h3>Description</h3>

<p>Generate Stan code for <span class="pkg">brms</span> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
stancode(
  object,
  data,
  family = gaussian(),
  prior = NULL,
  autocor = NULL,
  data2 = NULL,
  cov_ranef = NULL,
  sparse = NULL,
  sample_prior = "no",
  stanvars = NULL,
  stan_funs = NULL,
  knots = NULL,
  drop_unused_levels = TRUE,
  threads = getOption("brms.threads", NULL),
  normalize = getOption("brms.normalize", TRUE),
  save_model = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stancode.default_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>, or <code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code> (or one that can
be coerced to that classes): A symbolic description of the model to be
fitted. The details of model specification are explained in
<code><a href="#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced
to that class) containing data of all variables used in the model.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and link function to
be used in the model. This can be a family function, a call to a family
function or a character string naming the family. Every family function has
a <code>link</code> argument allowing to specify the link function to be applied
on the response variable. If not specified, default links are used. For
details of supported families see <code><a href="#topic+brmsfamily">brmsfamily</a></code>. By default, a
linear <code>gaussian</code> model is applied. In multivariate models,
<code>family</code> might also be a list of families.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_prior">prior</code></td>
<td>
<p>One or more <code>brmsprior</code> objects created by
<code><a href="#topic+set_prior">set_prior</a></code> or related functions and combined using the
<code>c</code> method or the <code>+</code> operator. See also <code><a href="#topic+default_prior.default">default_prior</a></code>
for more help.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_autocor">autocor</code></td>
<td>
<p>(Deprecated) An optional <code><a href="#topic+cor_brms">cor_brms</a></code> object
describing the correlation structure within the response variable (i.e.,
the 'autocorrelation'). See the documentation of <code><a href="#topic+cor_brms">cor_brms</a></code> for
a description of the available correlation structures. Defaults to
<code>NULL</code>, corresponding to no correlations. In multivariate models,
<code>autocor</code> might also be a list of autocorrelation structures.
It is now recommend to specify autocorrelation terms directly
within <code>formula</code>. See <code><a href="#topic+brmsformula">brmsformula</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_data2">data2</code></td>
<td>
<p>A named <code>list</code> of objects containing data, which
cannot be passed via argument <code>data</code>. Required for some objects
used in autocorrelation structures to specify dependency structures
as well as for within-group covariance matrices.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_cov_ranef">cov_ranef</code></td>
<td>
<p>(Deprecated) A list of matrices that are proportional to the
(within) covariance structure of the group-level effects. The names of the
matrices should correspond to columns in <code>data</code> that are used as
grouping factors. All levels of the grouping factor should appear as
rownames of the corresponding matrix. This argument can be used, among
others to model pedigrees and phylogenetic effects.
It is now recommended to specify those matrices in the formula
interface using the <code><a href="#topic+gr">gr</a></code> and related functions. See
<code>vignette("brms_phylogenetics")</code> for more details.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_sparse">sparse</code></td>
<td>
<p>(Deprecated) Logical; indicates whether the population-level
design matrices should be treated as sparse (defaults to <code>FALSE</code>). For
design matrices with many zeros, this can considerably reduce required
memory. Sampling speed is currently not improved or even slightly
decreased. It is now recommended to use the <code>sparse</code> argument of
<code><a href="#topic+brmsformula">brmsformula</a></code> and related functions.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_sample_prior">sample_prior</code></td>
<td>
<p>Indicate if draws from priors should be drawn
additionally to the posterior draws. Options are <code>"no"</code> (the
default), <code>"yes"</code>, and <code>"only"</code>. Among others, these draws can
be used to calculate Bayes factors for point hypotheses via
<code><a href="#topic+hypothesis">hypothesis</a></code>. Please note that improper priors are not sampled,
including the default improper priors used by <code>brm</code>. See
<code><a href="#topic+set_prior">set_prior</a></code> on how to set (proper) priors. Please also note
that prior draws for the overall intercept are not obtained by default
for technical reasons. See <code><a href="#topic+brmsformula">brmsformula</a></code> how to obtain prior
draws for the intercept. If <code>sample_prior</code> is set to <code>"only"</code>,
draws are drawn solely from the priors ignoring the likelihood, which
allows among others to generate draws from the prior predictive
distribution. In this case, all parameters must have proper priors.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_stanvars">stanvars</code></td>
<td>
<p>An optional <code>stanvars</code> object generated by function
<code><a href="#topic+stanvar">stanvar</a></code> to define additional variables for use in
<span class="pkg">Stan</span>'s program blocks.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_stan_funs">stan_funs</code></td>
<td>
<p>(Deprecated) An optional character string containing
self-defined  <span class="pkg">Stan</span> functions, which will be included in the functions
block of the generated <span class="pkg">Stan</span> code. It is now recommended to use the
<code>stanvars</code> argument for this purpose instead.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_knots">knots</code></td>
<td>
<p>Optional list containing user specified knot values to be used
for basis construction of smoothing terms. See
<code><a href="mgcv.html#topic+gamm">gamm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_drop_unused_levels">drop_unused_levels</code></td>
<td>
<p>Should unused factors levels in the data be
dropped? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in within-chain parallelization. For
more control over the threading process, <code>threads</code> may also be a
<code>brmsthreads</code> object created by <code><a href="#topic+threading">threading</a></code>. Within-chain
parallelization is experimental! We recommend its use only if you are
experienced with Stan's <code>reduce_sum</code> function and have a slow running
model that cannot be sped up by any other means. Can be set globally for
the current <span class="rlang"><b>R</b></span> session via the <code>"brms.threads"</code> option (see
<code><a href="base.html#topic+options">options</a></code>).</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_normalize">normalize</code></td>
<td>
<p>Logical. Indicates whether normalization constants should
be included in the Stan code (defaults to <code>TRUE</code>). Setting it
to <code>FALSE</code> requires Stan version &gt;= 2.25 to work. If <code>FALSE</code>,
sampling efficiency may be increased but some post processing functions
such as <code><a href="#topic+bridge_sampler">bridge_sampler</a></code> will not be available. Can be
controlled globally for the current <span class="rlang"><b>R</b></span> session via the 'brms.normalize'
option.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_save_model">save_model</code></td>
<td>
<p>Either <code>NULL</code> or a character string. In the latter
case, the model's Stan code is saved via <code><a href="#topic+cat">cat</a></code> in a text file
named after the string supplied in <code>save_model</code>.</p>
</td></tr>
<tr><td><code id="stancode.default_+3A_...">...</code></td>
<td>
<p>Other arguments for internal usage only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string containing the fully commented <span class="pkg">Stan</span> code
to fit a <span class="pkg">brms</span> model. It is of class <code>c("character", "brmsmodel")</code>
to facilitate pretty printing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stancode(rating ~ treat + period + carry + (1|subject),
         data = inhaler, family = "cumulative")

stancode(count ~ zAge + zBase * Trt + (1|patient),
         data = epilepsy, family = "poisson")

</code></pre>

<hr>
<h2 id='standata'>Stan data for Bayesian models</h2><span id='topic+standata'></span><span id='topic+make_standata'></span>

<h3>Description</h3>

<p><code>standata</code> is a generic function that can be used to
generate data for Bayesian models to be passed to Stan. Its original use is
within the <span class="pkg">brms</span> package, but new methods for use
with objects from other packages can be registered to the same generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standata(object, ...)

make_standata(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standata_+3A_object">object</code></td>
<td>
<p>A formula object whose class will determine which method will
be used. A symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="standata_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the specific method.</p>
</td></tr>
<tr><td><code id="standata_+3A_formula">formula</code></td>
<td>
<p>Synonym of <code>object</code> for use in <code>make_standata</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+standata.default">standata.default</a></code> for the default method applied for
<span class="pkg">brms</span> models. You can view the available methods by typing
<code>methods(standata)</code>. The <code>make_standata</code> function is an alias
of <code>standata</code>.
</p>


<h3>Value</h3>

<p>A named list of objects containing the required data to fit a
Bayesian model with <span class="pkg">Stan</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standata.default">standata.default</a></code>, <code><a href="#topic+standata.brmsfit">standata.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sdata1 &lt;- standata(rating ~ treat + period + carry + (1|subject),
                   data = inhaler, family = "cumulative")
str(sdata1)

</code></pre>

<hr>
<h2 id='standata.brmsfit'>Extract data passed to Stan from <code>brmsfit</code> objects</h2><span id='topic+standata.brmsfit'></span>

<h3>Description</h3>

<p>Extract all data that was used by Stan to fit a <span class="pkg">brms</span> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
standata(
  object,
  newdata = NULL,
  re_formula = NULL,
  newdata2 = NULL,
  new_objects = NULL,
  incl_autocor = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standata.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="standata.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which to evaluate predictions. If
<code>NULL</code> (default), the original data of the model is used.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="standata.brmsfit_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="standata.brmsfit_+3A_newdata2">newdata2</code></td>
<td>
<p>A named <code>list</code> of objects containing new data, which
cannot be passed via argument <code>newdata</code>. Required for some objects
used in autocorrelation structures, or <code><a href="#topic+stanvars">stanvars</a></code>.</p>
</td></tr>
<tr><td><code id="standata.brmsfit_+3A_new_objects">new_objects</code></td>
<td>
<p>Deprecated alias of <code>newdata2</code>.</p>
</td></tr>
<tr><td><code id="standata.brmsfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="standata.brmsfit_+3A_...">...</code></td>
<td>
<p>More arguments passed to
<code><a href="#topic+standata.default">standata.default</a></code>.
and <code><a href="#topic+validate_newdata">validate_newdata</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing the data passed to Stan.
</p>

<hr>
<h2 id='standata.default'>Data for <span class="pkg">brms</span> Models</h2><span id='topic+standata.default'></span>

<h3>Description</h3>

<p>Generate data for <span class="pkg">brms</span> models to be passed to <span class="pkg">Stan</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
standata(
  object,
  data,
  family = gaussian(),
  prior = NULL,
  autocor = NULL,
  data2 = NULL,
  cov_ranef = NULL,
  sample_prior = "no",
  stanvars = NULL,
  threads = getOption("brms.threads", NULL),
  knots = NULL,
  drop_unused_levels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standata.default_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>, or <code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code> (or one that can
be coerced to that classes): A symbolic description of the model to be
fitted. The details of model specification are explained in
<code><a href="#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced
to that class) containing data of all variables used in the model.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and link function to
be used in the model. This can be a family function, a call to a family
function or a character string naming the family. Every family function has
a <code>link</code> argument allowing to specify the link function to be applied
on the response variable. If not specified, default links are used. For
details of supported families see <code><a href="#topic+brmsfamily">brmsfamily</a></code>. By default, a
linear <code>gaussian</code> model is applied. In multivariate models,
<code>family</code> might also be a list of families.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_prior">prior</code></td>
<td>
<p>One or more <code>brmsprior</code> objects created by
<code><a href="#topic+set_prior">set_prior</a></code> or related functions and combined using the
<code>c</code> method or the <code>+</code> operator. See also <code><a href="#topic+default_prior.default">default_prior</a></code>
for more help.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_autocor">autocor</code></td>
<td>
<p>(Deprecated) An optional <code><a href="#topic+cor_brms">cor_brms</a></code> object
describing the correlation structure within the response variable (i.e.,
the 'autocorrelation'). See the documentation of <code><a href="#topic+cor_brms">cor_brms</a></code> for
a description of the available correlation structures. Defaults to
<code>NULL</code>, corresponding to no correlations. In multivariate models,
<code>autocor</code> might also be a list of autocorrelation structures.
It is now recommend to specify autocorrelation terms directly
within <code>formula</code>. See <code><a href="#topic+brmsformula">brmsformula</a></code> for more details.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_data2">data2</code></td>
<td>
<p>A named <code>list</code> of objects containing data, which
cannot be passed via argument <code>data</code>. Required for some objects
used in autocorrelation structures to specify dependency structures
as well as for within-group covariance matrices.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_cov_ranef">cov_ranef</code></td>
<td>
<p>(Deprecated) A list of matrices that are proportional to the
(within) covariance structure of the group-level effects. The names of the
matrices should correspond to columns in <code>data</code> that are used as
grouping factors. All levels of the grouping factor should appear as
rownames of the corresponding matrix. This argument can be used, among
others to model pedigrees and phylogenetic effects.
It is now recommended to specify those matrices in the formula
interface using the <code><a href="#topic+gr">gr</a></code> and related functions. See
<code>vignette("brms_phylogenetics")</code> for more details.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_sample_prior">sample_prior</code></td>
<td>
<p>Indicate if draws from priors should be drawn
additionally to the posterior draws. Options are <code>"no"</code> (the
default), <code>"yes"</code>, and <code>"only"</code>. Among others, these draws can
be used to calculate Bayes factors for point hypotheses via
<code><a href="#topic+hypothesis">hypothesis</a></code>. Please note that improper priors are not sampled,
including the default improper priors used by <code>brm</code>. See
<code><a href="#topic+set_prior">set_prior</a></code> on how to set (proper) priors. Please also note
that prior draws for the overall intercept are not obtained by default
for technical reasons. See <code><a href="#topic+brmsformula">brmsformula</a></code> how to obtain prior
draws for the intercept. If <code>sample_prior</code> is set to <code>"only"</code>,
draws are drawn solely from the priors ignoring the likelihood, which
allows among others to generate draws from the prior predictive
distribution. In this case, all parameters must have proper priors.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_stanvars">stanvars</code></td>
<td>
<p>An optional <code>stanvars</code> object generated by function
<code><a href="#topic+stanvar">stanvar</a></code> to define additional variables for use in
<span class="pkg">Stan</span>'s program blocks.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in within-chain parallelization. For
more control over the threading process, <code>threads</code> may also be a
<code>brmsthreads</code> object created by <code><a href="#topic+threading">threading</a></code>. Within-chain
parallelization is experimental! We recommend its use only if you are
experienced with Stan's <code>reduce_sum</code> function and have a slow running
model that cannot be sped up by any other means. Can be set globally for
the current <span class="rlang"><b>R</b></span> session via the <code>"brms.threads"</code> option (see
<code><a href="base.html#topic+options">options</a></code>).</p>
</td></tr>
<tr><td><code id="standata.default_+3A_knots">knots</code></td>
<td>
<p>Optional list containing user specified knot values to be used
for basis construction of smoothing terms. See
<code><a href="mgcv.html#topic+gamm">gamm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_drop_unused_levels">drop_unused_levels</code></td>
<td>
<p>Should unused factors levels in the data be
dropped? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="standata.default_+3A_...">...</code></td>
<td>
<p>Other arguments for internal use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of objects containing the required data
to fit a <span class="pkg">brms</span> model with <span class="pkg">Stan</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sdata1 &lt;- standata(rating ~ treat + period + carry + (1|subject),
                   data = inhaler, family = "cumulative")
str(sdata1)

sdata2 &lt;- standata(count ~ zAge + zBase * Trt + (1|patient),
                   data = epilepsy, family = "poisson")
str(sdata2)

</code></pre>

<hr>
<h2 id='stanvar'>User-defined variables passed to Stan</h2><span id='topic+stanvar'></span><span id='topic+stanvars'></span>

<h3>Description</h3>

<p>Prepare user-defined variables to be passed to one of Stan's
program blocks. This is primarily useful for defining more complex
priors, for refitting models without recompilation despite
changing priors, or for defining custom Stan functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanvar(
  x = NULL,
  name = NULL,
  scode = NULL,
  block = "data",
  position = "start",
  pll_args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanvar_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object containing data to be passed to Stan.
Only required if <code>block = 'data'</code> and ignored otherwise.</p>
</td></tr>
<tr><td><code id="stanvar_+3A_name">name</code></td>
<td>
<p>Optional character string providing the desired variable
name of the object in <code>x</code>. If <code>NULL</code> (the default)
the variable name is directly inferred from <code>x</code>.</p>
</td></tr>
<tr><td><code id="stanvar_+3A_scode">scode</code></td>
<td>
<p>Line of Stan code to define the variable
in Stan language. If <code>block = 'data'</code>, the
Stan code is inferred based on the class of <code>x</code> by default.</p>
</td></tr>
<tr><td><code id="stanvar_+3A_block">block</code></td>
<td>
<p>Name of one of Stan's program blocks in
which the variable should be defined. Can be <code>'data'</code>,
<code>'tdata'</code> (transformed data), <code>'parameters'</code>,
<code>'tparameters'</code> (transformed parameters), <code>'model'</code>,
<code>'likelihood'</code> (part of the model block where the likelihood is given),
<code>'genquant'</code> (generated quantities) or <code>'functions'</code>.</p>
</td></tr>
<tr><td><code id="stanvar_+3A_position">position</code></td>
<td>
<p>Name of the position within the block where the
Stan code should be placed. Currently allowed are <code>'start'</code>
(the default) and <code>'end'</code> of the block.</p>
</td></tr>
<tr><td><code id="stanvar_+3A_pll_args">pll_args</code></td>
<td>
<p>Optional Stan code to be put into the header
of <code>partial_log_lik</code> functions. This ensures that the variables
specified in <code>scode</code> can be used in the likelihood even when
within-chain parallelization is activated via <code><a href="#topic+threading">threading</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stanvar</code> function is not vectorized. Instead, multiple
<code>stanvars</code> objects can be added together via <code>+</code> (see Examples).
</p>
<p>Special attention is necessary when using <code>stanvars</code> to inject
code into the <code>'likelihood'</code> block while having <code><a href="#topic+threading">threading</a></code>
activated. In this case, your custom Stan code may need adjustments to ensure
correct observation indexing. Please investigate the generated Stan code via
<code><a href="#topic+stancode.default">stancode</a></code> to see which adjustments are necessary in your case.
</p>


<h3>Value</h3>

<p>An object of class <code>stanvars</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bprior &lt;- prior(normal(mean_intercept, 10), class = "Intercept")
stanvars &lt;- stanvar(5, name = "mean_intercept")
stancode(count ~ Trt, epilepsy, prior = bprior,
         stanvars = stanvars)

# define a multi-normal prior with known covariance matrix
bprior &lt;- prior(multi_normal(M, V), class = "b")
stanvars &lt;- stanvar(rep(0, 2), "M", scode = "  vector[K] M;") +
  stanvar(diag(2), "V", scode = "  matrix[K, K] V;")
stancode(count ~ Trt + zBase, epilepsy,
         prior = bprior, stanvars = stanvars)

# define a hierachical prior on the regression coefficients
bprior &lt;- set_prior("normal(0, tau)", class = "b") +
  set_prior("target += normal_lpdf(tau | 0, 10)", check = FALSE)
stanvars &lt;- stanvar(scode = "real&lt;lower=0&gt; tau;",
                    block = "parameters")
stancode(count ~ Trt + zBase, epilepsy,
         prior = bprior, stanvars = stanvars)

# ensure that 'tau' is passed to the likelihood of a threaded model
# not necessary for this example but may be necessary in other cases
stanvars &lt;- stanvar(scode = "real&lt;lower=0&gt; tau;",
                    block = "parameters", pll_args = "real tau")
stancode(count ~ Trt + zBase, epilepsy,
         stanvars = stanvars, threads = threading(2))

</code></pre>

<hr>
<h2 id='StudentT'>The Student-t Distribution</h2><span id='topic+StudentT'></span><span id='topic+dstudent_t'></span><span id='topic+pstudent_t'></span><span id='topic+qstudent_t'></span><span id='topic+rstudent_t'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Student-t distribution with location <code>mu</code>, scale <code>sigma</code>,
and degrees of freedom <code>df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dstudent_t(x, df, mu = 0, sigma = 1, log = FALSE)

pstudent_t(q, df, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qstudent_t(p, df, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rstudent_t(n, df, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StudentT_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="StudentT_+3A_df">df</code></td>
<td>
<p>Vector of degrees of freedom.</p>
</td></tr>
<tr><td><code id="StudentT_+3A_mu">mu</code></td>
<td>
<p>Vector of location values.</p>
</td></tr>
<tr><td><code id="StudentT_+3A_sigma">sigma</code></td>
<td>
<p>Vector of scale values.</p>
</td></tr>
<tr><td><code id="StudentT_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="StudentT_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="StudentT_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="StudentT_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="StudentT_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="StudentT_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details
on the parameterization.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">TDist</a></code>
</p>

<hr>
<h2 id='summary.brmsfit'>Create a summary of a fitted model represented by a <code>brmsfit</code> object</h2><span id='topic+summary.brmsfit'></span>

<h3>Description</h3>

<p>Create a summary of a fitted model represented by a <code>brmsfit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
summary(
  object,
  priors = FALSE,
  prob = 0.95,
  robust = FALSE,
  mc_se = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="summary.brmsfit_+3A_priors">priors</code></td>
<td>
<p>Logical; Indicating if priors should be included
in the summary. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.brmsfit_+3A_prob">prob</code></td>
<td>
<p>A value between 0 and 1 indicating the desired probability
to be covered by the uncertainty intervals. The default is 0.95.</p>
</td></tr>
<tr><td><code id="summary.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.</p>
</td></tr>
<tr><td><code id="summary.brmsfit_+3A_mc_se">mc_se</code></td>
<td>
<p>Logical; Indicating if the uncertainty in <code>Estimate</code>
caused by the MCMC sampling should be shown in the summary. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.brmsfit_+3A_...">...</code></td>
<td>
<p>Other potential arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The convergence diagnostics <code>Rhat</code>, <code>Bulk_ESS</code>, and
<code>Tail_ESS</code> are described in detail in Vehtari et al. (2020).
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Bürkner (2020). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC. *Bayesian Analysis*. 1–28. dpi:10.1214/20-BA1221
</p>

<hr>
<h2 id='theme_black'>(Deprecated) Black Theme for <span class="pkg">ggplot2</span> Graphics</h2><span id='topic+theme_black'></span>

<h3>Description</h3>

<p>A black theme for ggplot graphics inspired by a blog post of Jon Lefcheck
(<a href="https://jonlefcheck.net/2013/03/11/black-theme-for-ggplot2-2/">https://jonlefcheck.net/2013/03/11/black-theme-for-ggplot2-2/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_black(base_size = 12, base_family = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_black_+3A_base_size">base_size</code></td>
<td>
<p>base font size</p>
</td></tr>
<tr><td><code id="theme_black_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>theme_black</code> in plots powered by the
<span class="pkg">bayesplot</span> package such as <code>pp_check</code> or <code>stanplot</code>,
I recommend using the <code>"viridisC"</code> color scheme (see examples).
</p>


<h3>Value</h3>

<p>A <code>theme</code> object used in <span class="pkg">ggplot2</span> graphics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# change default ggplot theme
ggplot2::theme_set(theme_black())

# change default bayesplot color scheme
bayesplot::color_scheme_set("viridisC")

# fit a simple model
fit &lt;- brm(count ~ zAge + zBase * Trt + (1|patient),
           data = epilepsy, family = poisson(), chains = 2)
summary(fit)

# create various plots
plot(marginal_effects(fit), ask = FALSE)
pp_check(fit)
mcmc_plot(fit, type = "hex", variable = c("b_Intercept", "b_Trt1"))

## End(Not run)

</code></pre>

<hr>
<h2 id='theme_default'>Default <span class="pkg">bayesplot</span> Theme for <span class="pkg">ggplot2</span> Graphics</h2><span id='topic+theme_default'></span>

<h3>Description</h3>

<p>This theme is imported from the <span class="pkg">bayesplot</span> package.
See <code><a href="bayesplot.html#topic+theme_default">theme_default</a></code>
for a complete documentation.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_default_+3A_base_size">base_size</code></td>
<td>
<p>base font size</p>
</td></tr>
<tr><td><code id="theme_default_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>theme</code> object used in <span class="pkg">ggplot2</span> graphics.
</p>

<hr>
<h2 id='threading'>Threading in Stan</h2><span id='topic+threading'></span>

<h3>Description</h3>

<p>Use threads for within-chain parallelization in <span class="pkg">Stan</span> via the <span class="pkg">brms</span>
interface. Within-chain parallelization is experimental! We recommend its use
only if you are experienced with Stan's <code>reduce_sum</code> function and have a
slow running model that cannot be sped up by any other means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threading(threads = NULL, grainsize = NULL, static = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threading_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in within-chain parallelization.</p>
</td></tr>
<tr><td><code id="threading_+3A_grainsize">grainsize</code></td>
<td>
<p>Number of observations evaluated together in one chunk on
one of the CPUs used for threading. If <code>NULL</code> (the default),
<code>grainsize</code> is currently chosen as <code>max(100, N / (2 *
threads))</code>, where <code>N</code> is the number of observations in the data. This
default is experimental and may change in the future without prior notice.</p>
</td></tr>
<tr><td><code id="threading_+3A_static">static</code></td>
<td>
<p>Logical. Apply the static (non-adaptive) version of
<code>reduce_sum</code>? Defaults to <code>FALSE</code>. Setting it to <code>TRUE</code>
is required to achieve exact reproducibility of the model results
(if the random seed is set as well).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adaptive scheduling procedure used by <code>reduce_sum</code> will
prevent the results to be exactly reproducible even if you set the random
seed. If you need exact reproducibility, you have to set argument
<code>static = TRUE</code> which may reduce efficiency a bit.
</p>
<p>To ensure that chunks (whose size is defined by <code>grainsize</code>) require
roughly the same amount of computing time, we recommend storing
observations in random order in the data. At least, please avoid sorting
observations after the response values. This is because the latter often
cause variations in the computing time of the pointwise log-likelihood,
which makes up a big part of the parallelized code.
</p>


<h3>Value</h3>

<p>A <code>brmsthreads</code> object which can be passed to the
<code>threads</code> argument of <code>brm</code> and related functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# this model just serves as an illustration
# threading may not actually speed things up here
fit &lt;- brm(count ~ zAge + zBase * Trt + (1|patient),
           data = epilepsy, family = negbinomial(),
           chains = 1, threads = threading(2, grainsize = 100),
           backend = "cmdstanr")
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='unstr'>Set up UNSTR correlation structures</h2><span id='topic+unstr'></span>

<h3>Description</h3>

<p>Set up an unstructured (UNSTR) correlation term in <span class="pkg">brms</span>. The function does
not evaluate its arguments &ndash; it exists purely to help set up a model with
UNSTR terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unstr(time, gr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstr_+3A_time">time</code></td>
<td>
<p>An optional time variable specifying the time ordering
of the observations. By default, the existing order of the observations
in the data is used.</p>
</td></tr>
<tr><td><code id="unstr_+3A_gr">gr</code></td>
<td>
<p>An optional grouping variable. If specified, the correlation
structure is assumed to apply only to observations within the same grouping
level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>'unstr_term'</code>, which is a list
of arguments to be interpreted by the formula
parsing functions of <span class="pkg">brms</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocor-terms">autocor-terms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# add an unstructured correlation matrix for visits within the same patient
fit &lt;- brm(count ~ Trt + unstr(visit, patient), data = epilepsy)
summary(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='update_adterms'>Update Formula Addition Terms</h2><span id='topic+update_adterms'></span>

<h3>Description</h3>

<p>Update additions terms used in formulas of <span class="pkg">brms</span>. See
<code><a href="#topic+addition-terms">addition-terms</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_adterms(formula, adform, action = c("update", "replace"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_adterms_+3A_formula">formula</code></td>
<td>
<p>Two-sided formula to be updated.</p>
</td></tr>
<tr><td><code id="update_adterms_+3A_adform">adform</code></td>
<td>
<p>One-sided formula containing addition terms to update
<code>formula</code> with.</p>
</td></tr>
<tr><td><code id="update_adterms_+3A_action">action</code></td>
<td>
<p>Indicates what should happen to the existing addition terms in
<code>formula</code>. If <code>"update"</code> (the default), old addition terms that
have no corresponding term in <code>adform</code> will be kept. If
<code>"replace"</code>, all old addition terms will be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>formula</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>form &lt;- y | trials(size) ~ x
update_adterms(form, ~ trials(10))
update_adterms(form, ~ weights(w))
update_adterms(form, ~ weights(w), action = "replace")
update_adterms(y ~ x, ~ trials(10))

</code></pre>

<hr>
<h2 id='update.brmsfit'>Update <span class="pkg">brms</span> models</h2><span id='topic+update.brmsfit'></span>

<h3>Description</h3>

<p>This method allows to update an existing <code>brmsfit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
update(object, formula., newdata = NULL, recompile = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="update.brmsfit_+3A_formula.">formula.</code></td>
<td>
<p>Changes to the formula; for details see
<code><a href="stats.html#topic+update.formula">update.formula</a></code> and <code><a href="#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="update.brmsfit_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> to update the model with new data.
Data-dependent default priors will not be updated automatically.</p>
</td></tr>
<tr><td><code id="update.brmsfit_+3A_recompile">recompile</code></td>
<td>
<p>Logical, indicating whether the Stan model should
be recompiled. If <code>NULL</code> (the default), <code>update</code> tries
to figure out internally, if recompilation is necessary.
Setting it to <code>FALSE</code> will cause all Stan code changing
arguments to be ignored.</p>
</td></tr>
<tr><td><code id="update.brmsfit_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+brm">brm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When updating a <code>brmsfit</code> created with the <span class="pkg">cmdstanr</span>
backend in a different <span class="rlang"><b>R</b></span> session, a recompilation will be triggered
because by default, <span class="pkg">cmdstanr</span> writes the model executable to a
temporary directory. To avoid that, set option
<code>"cmdstanr_write_stan_file_dir"</code> to a nontemporary path of your choice
before creating the original <code>brmsfit</code> (see section 'Examples' below).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit1 &lt;- brm(time | cens(censored) ~ age * sex + disease + (1|patient),
            data = kidney, family = gaussian("log"))
summary(fit1)

## remove effects of 'disease'
fit2 &lt;- update(fit1, formula. = ~ . - disease)
summary(fit2)

## remove the group specific term of 'patient' and
## change the data (just take a subset in this example)
fit3 &lt;- update(fit1, formula. = ~ . - (1|patient),
               newdata = kidney[1:38, ])
summary(fit3)

## use another family and add population-level priors
fit4 &lt;- update(fit1, family = weibull(), init = "0",
               prior = set_prior("normal(0,5)"))
summary(fit4)

## to avoid a recompilation when updating a 'cmdstanr'-backend fit in a fresh
## R session, set option 'cmdstanr_write_stan_file_dir' before creating the
## initial 'brmsfit'
## CAUTION: the following code creates some files in the current working
## directory: two 'model_&lt;hash&gt;.stan' files, one 'model_&lt;hash&gt;(.exe)'
## executable, and one 'fit_cmdstanr_&lt;some_number&gt;.rds' file
set.seed(7)
fname &lt;- paste0("fit_cmdstanr_", sample.int(.Machine$integer.max, 1))
options(cmdstanr_write_stan_file_dir = getwd())
fit_cmdstanr &lt;- brm(rate ~ conc + state,
                    data = Puromycin,
                    backend = "cmdstanr",
                    file = fname)
# now restart the R session and run the following (after attaching 'brms')
set.seed(7)
fname &lt;- paste0("fit_cmdstanr_", sample.int(.Machine$integer.max, 1))
fit_cmdstanr &lt;- brm(rate ~ conc + state,
                    data = Puromycin,
                    backend = "cmdstanr",
                    file = fname)
upd_cmdstanr &lt;- update(fit_cmdstanr,
                       formula. = rate ~ conc)

## End(Not run)

</code></pre>

<hr>
<h2 id='update.brmsfit_multiple'>Update <span class="pkg">brms</span> models based on multiple data sets</h2><span id='topic+update.brmsfit_multiple'></span>

<h3>Description</h3>

<p>This method allows to update an existing <code>brmsfit_multiple</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit_multiple'
update(object, formula., newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.brmsfit_multiple_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit_multiple</code>.</p>
</td></tr>
<tr><td><code id="update.brmsfit_multiple_+3A_formula.">formula.</code></td>
<td>
<p>Changes to the formula; for details see
<code><a href="stats.html#topic+update.formula">update.formula</a></code> and <code><a href="#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="update.brmsfit_multiple_+3A_newdata">newdata</code></td>
<td>
<p>List of <code>data.frames</code> to update the model with new data.
Currently required even if the original data should be used.</p>
</td></tr>
<tr><td><code id="update.brmsfit_multiple_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+update.brmsfit">update.brmsfit</a></code>
and <code><a href="#topic+brm_multiple">brm_multiple</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(mice)
imp &lt;- mice(nhanes2)

# initially fit the model
fit_imp1 &lt;- brm_multiple(bmi ~ age + hyp + chl, data = imp, chains = 1)
summary(fit_imp1)

# update the model using fewer predictors
fit_imp2 &lt;- update(fit_imp1, formula. = . ~ hyp + chl, newdata = imp)
summary(fit_imp2)

## End(Not run)

</code></pre>

<hr>
<h2 id='validate_newdata'>Validate New Data</h2><span id='topic+validate_newdata'></span>

<h3>Description</h3>

<p>Validate new data passed to post-processing methods of <span class="pkg">brms</span>. Unless you
are a package developer, you will rarely need to call <code>validate_newdata</code>
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_newdata(
  newdata,
  object,
  re_formula = NULL,
  allow_new_levels = FALSE,
  newdata2 = NULL,
  resp = NULL,
  check_response = TRUE,
  incl_autocor = TRUE,
  group_vars = NULL,
  req_vars = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_newdata_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> containing new data to be validated.</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_object">object</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in
the prediction. If <code>NULL</code> (default), include all group-level effects;
if <code>NA</code>, include no group-level effects.</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_newdata2">newdata2</code></td>
<td>
<p>A named <code>list</code> of objects containing new data, which
cannot be passed via argument <code>newdata</code>. Required for some objects
used in autocorrelation structures, or <code><a href="#topic+stanvars">stanvars</a></code>.</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_check_response">check_response</code></td>
<td>
<p>Logical; Indicates if response variables should
be checked as well. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_group_vars">group_vars</code></td>
<td>
<p>Optional names of grouping variables to be validated.
Defaults to all grouping variables in the model.</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_req_vars">req_vars</code></td>
<td>
<p>Optional names of variables required in <code>newdata</code>.
If <code>NULL</code> (the default), all variables in the original data
are required (unless ignored for some other reason).</p>
</td></tr>
<tr><td><code id="validate_newdata_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A validated <code>'data.frame'</code> based on <code>newdata</code>.
</p>

<hr>
<h2 id='validate_prior'>Validate Prior for <span class="pkg">brms</span> Models</h2><span id='topic+validate_prior'></span>

<h3>Description</h3>

<p>Validate priors supplied by the user. Return a complete
set of priors for the given model, including default priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_prior(
  prior,
  formula,
  data,
  family = gaussian(),
  sample_prior = "no",
  data2 = NULL,
  knots = NULL,
  drop_unused_levels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_prior_+3A_prior">prior</code></td>
<td>
<p>One or more <code>brmsprior</code> objects created by
<code><a href="#topic+set_prior">set_prior</a></code> or related functions and combined using the
<code>c</code> method or the <code>+</code> operator. See also <code><a href="#topic+default_prior.default">default_prior</a></code>
for more help.</p>
</td></tr>
<tr><td><code id="validate_prior_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+brmsformula">brmsformula</a></code>, or <code><a href="#topic+mvbrmsformula">mvbrmsformula</a></code> (or one that can
be coerced to that classes): A symbolic description of the model to be
fitted. The details of model specification are explained in
<code><a href="#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="validate_prior_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced
to that class) containing data of all variables used in the model.</p>
</td></tr>
<tr><td><code id="validate_prior_+3A_family">family</code></td>
<td>
<p>A description of the response distribution and link function to
be used in the model. This can be a family function, a call to a family
function or a character string naming the family. Every family function has
a <code>link</code> argument allowing to specify the link function to be applied
on the response variable. If not specified, default links are used. For
details of supported families see <code><a href="#topic+brmsfamily">brmsfamily</a></code>. By default, a
linear <code>gaussian</code> model is applied. In multivariate models,
<code>family</code> might also be a list of families.</p>
</td></tr>
<tr><td><code id="validate_prior_+3A_sample_prior">sample_prior</code></td>
<td>
<p>Indicate if draws from priors should be drawn
additionally to the posterior draws. Options are <code>"no"</code> (the
default), <code>"yes"</code>, and <code>"only"</code>. Among others, these draws can
be used to calculate Bayes factors for point hypotheses via
<code><a href="#topic+hypothesis">hypothesis</a></code>. Please note that improper priors are not sampled,
including the default improper priors used by <code>brm</code>. See
<code><a href="#topic+set_prior">set_prior</a></code> on how to set (proper) priors. Please also note
that prior draws for the overall intercept are not obtained by default
for technical reasons. See <code><a href="#topic+brmsformula">brmsformula</a></code> how to obtain prior
draws for the intercept. If <code>sample_prior</code> is set to <code>"only"</code>,
draws are drawn solely from the priors ignoring the likelihood, which
allows among others to generate draws from the prior predictive
distribution. In this case, all parameters must have proper priors.</p>
</td></tr>
<tr><td><code id="validate_prior_+3A_data2">data2</code></td>
<td>
<p>A named <code>list</code> of objects containing data, which
cannot be passed via argument <code>data</code>. Required for some objects
used in autocorrelation structures to specify dependency structures
as well as for within-group covariance matrices.</p>
</td></tr>
<tr><td><code id="validate_prior_+3A_knots">knots</code></td>
<td>
<p>Optional list containing user specified knot values to be used
for basis construction of smoothing terms. See
<code><a href="mgcv.html#topic+gamm">gamm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="validate_prior_+3A_drop_unused_levels">drop_unused_levels</code></td>
<td>
<p>Should unused factors levels in the data be
dropped? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="validate_prior_+3A_...">...</code></td>
<td>
<p>Other arguments for internal usage only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>brmsprior</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+default_prior.default">default_prior</a></code>, <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prior1 &lt;- prior(normal(0,10), class = b) +
  prior(cauchy(0,2), class = sd)
validate_prior(prior1, count ~ zAge + zBase * Trt + (1|patient),
               data = epilepsy, family = poisson())

</code></pre>

<hr>
<h2 id='VarCorr.brmsfit'>Extract Variance and Correlation Components</h2><span id='topic+VarCorr.brmsfit'></span><span id='topic+VarCorr'></span>

<h3>Description</h3>

<p>This function calculates the estimated standard deviations,
correlations and covariances of the group-level terms
in a multilevel model of class <code>brmsfit</code>.
For linear models, the residual standard deviations,
correlations and covariances are also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
VarCorr(
  x,
  sigma = 1,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarCorr.brmsfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="VarCorr.brmsfit_+3A_sigma">sigma</code></td>
<td>
<p>Ignored (included for compatibility with
<code><a href="nlme.html#topic+VarCorr">VarCorr</a></code>).</p>
</td></tr>
<tr><td><code id="VarCorr.brmsfit_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="VarCorr.brmsfit_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="VarCorr.brmsfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="VarCorr.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists (one per grouping factor), each with
three elements: a matrix containing the standard deviations,
an array containing the correlation matrix, and an array
containing the covariance matrix with variances on the diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zAge + zBase * Trt + (1+Trt|visit),
           data = epilepsy, family = gaussian(), chains = 2)
VarCorr(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='vcov.brmsfit'>Covariance and Correlation Matrix of Population-Level Effects</h2><span id='topic+vcov.brmsfit'></span>

<h3>Description</h3>

<p>Get a point estimate of the covariance or
correlation matrix of population-level parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
vcov(object, correlation = FALSE, pars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code>.</p>
</td></tr>
<tr><td><code id="vcov.brmsfit_+3A_correlation">correlation</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default), compute
the covariance matrix, if <code>TRUE</code>, compute the correlation matrix.</p>
</td></tr>
<tr><td><code id="vcov.brmsfit_+3A_pars">pars</code></td>
<td>
<p>Optional names of coefficients to extract.
By default, all coefficients are extracted.</p>
</td></tr>
<tr><td><code id="vcov.brmsfit_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates are obtained by calculating the maximum likelihood
covariances (correlations) of the posterior draws.
</p>


<h3>Value</h3>

<p>covariance or correlation matrix of population-level parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- brm(count ~ zAge + zBase * Trt + (1+Trt|visit),
           data = epilepsy, family = gaussian(), chains = 2)
vcov(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='VonMises'>The von Mises Distribution</h2><span id='topic+VonMises'></span><span id='topic+dvon_mises'></span><span id='topic+pvon_mises'></span><span id='topic+rvon_mises'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation for the
von Mises distribution with location <code>mu</code>, and precision <code>kappa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvon_mises(x, mu, kappa, log = FALSE)

pvon_mises(q, mu, kappa, lower.tail = TRUE, log.p = FALSE, acc = 1e-20)

rvon_mises(n, mu, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VonMises_+3A_x">x</code>, <code id="VonMises_+3A_q">q</code></td>
<td>
<p>Vector of quantiles between <code>-pi</code> and <code>pi</code>.</p>
</td></tr>
<tr><td><code id="VonMises_+3A_mu">mu</code></td>
<td>
<p>Vector of location values.</p>
</td></tr>
<tr><td><code id="VonMises_+3A_kappa">kappa</code></td>
<td>
<p>Vector of precision values.</p>
</td></tr>
<tr><td><code id="VonMises_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="VonMises_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="VonMises_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="VonMises_+3A_acc">acc</code></td>
<td>
<p>Accuracy of numerical approximations.</p>
</td></tr>
<tr><td><code id="VonMises_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("brms_families")</code> for details
on the parameterization.
</p>

<hr>
<h2 id='waic.brmsfit'>Widely Applicable Information Criterion (WAIC)</h2><span id='topic+waic.brmsfit'></span><span id='topic+waic'></span><span id='topic+WAIC'></span><span id='topic+WAIC.brmsfit'></span>

<h3>Description</h3>

<p>Compute the widely applicable information criterion (WAIC)
based on the posterior likelihood using the <span class="pkg">loo</span> package.
For more details see <code><a href="loo.html#topic+waic">waic</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
waic(
  x,
  ...,
  compare = TRUE,
  resp = NULL,
  pointwise = FALSE,
  model_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waic.brmsfit_+3A_x">x</code></td>
<td>
<p>A <code>brmsfit</code> object.</p>
</td></tr>
<tr><td><code id="waic.brmsfit_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects or further arguments
passed to the underlying post-processing functions.
In particular, see <code><a href="#topic+prepare_predictions">prepare_predictions</a></code> for further
supported arguments.</p>
</td></tr>
<tr><td><code id="waic.brmsfit_+3A_compare">compare</code></td>
<td>
<p>A flag indicating if the information criteria
of the models should be compared to each other
via <code><a href="#topic+loo_compare">loo_compare</a></code>.</p>
</td></tr>
<tr><td><code id="waic.brmsfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="waic.brmsfit_+3A_pointwise">pointwise</code></td>
<td>
<p>A flag indicating whether to compute the full
log-likelihood matrix at once or separately for each observation.
The latter approach is usually considerably slower but
requires much less working memory. Accordingly, if one runs
into memory issues, <code>pointwise = TRUE</code> is the way to go.</p>
</td></tr>
<tr><td><code id="waic.brmsfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+loo_compare">loo_compare</a></code> for details on model comparisons.
For <code>brmsfit</code> objects, <code>WAIC</code> is an alias of <code>waic</code>.
Use method <code><a href="#topic+add_criterion">add_criterion</a></code> to store
information criteria in the fitted model object for later usage.
</p>


<h3>Value</h3>

<p>If just one object is provided, an object of class <code>loo</code>.
If multiple objects are provided, an object of class <code>loolist</code>.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., &amp; Gabry J. (2016). Practical Bayesian model
evaluation using leave-one-out cross-validation and WAIC. In Statistics
and Computing, doi:10.1007/s11222-016-9696-4. arXiv preprint arXiv:1507.04544.
</p>
<p>Gelman, A., Hwang, J., &amp; Vehtari, A. (2014).
Understanding predictive information criteria for Bayesian models.
Statistics and Computing, 24, 997-1016.
</p>
<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation
and widely applicable information criterion in singular learning theory.
The Journal of Machine Learning Research, 11, 3571-3594.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model with population-level effects only
fit1 &lt;- brm(rating ~ treat + period + carry,
            data = inhaler)
(waic1 &lt;- waic(fit1))

# model with an additional varying intercept for subjects
fit2 &lt;- brm(rating ~ treat + period + carry + (1|subject),
            data = inhaler)
(waic2 &lt;- waic(fit2))

# compare both models
loo_compare(waic1, waic2)

## End(Not run)

</code></pre>

<hr>
<h2 id='Wiener'>The Wiener Diffusion Model Distribution</h2><span id='topic+Wiener'></span><span id='topic+dwiener'></span><span id='topic+rwiener'></span>

<h3>Description</h3>

<p>Density function and random generation for the Wiener
diffusion model distribution with boundary separation <code>alpha</code>,
non-decision time <code>tau</code>, bias  <code>beta</code> and
drift rate <code>delta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwiener(
  x,
  alpha,
  tau,
  beta,
  delta,
  resp = 1,
  log = FALSE,
  backend = getOption("wiener_backend", "Rwiener")
)

rwiener(
  n,
  alpha,
  tau,
  beta,
  delta,
  types = c("q", "resp"),
  backend = getOption("wiener_backend", "Rwiener")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wiener_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Wiener_+3A_alpha">alpha</code></td>
<td>
<p>Boundary separation parameter.</p>
</td></tr>
<tr><td><code id="Wiener_+3A_tau">tau</code></td>
<td>
<p>Non-decision time parameter.</p>
</td></tr>
<tr><td><code id="Wiener_+3A_beta">beta</code></td>
<td>
<p>Bias parameter.</p>
</td></tr>
<tr><td><code id="Wiener_+3A_delta">delta</code></td>
<td>
<p>Drift rate parameter.</p>
</td></tr>
<tr><td><code id="Wiener_+3A_resp">resp</code></td>
<td>
<p>Response: <code>"upper"</code> or <code>"lower"</code>.
If no character vector, it is coerced to logical
where <code>TRUE</code> indicates <code>"upper"</code> and
<code>FALSE</code> indicates <code>"lower"</code>.</p>
</td></tr>
<tr><td><code id="Wiener_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="Wiener_+3A_backend">backend</code></td>
<td>
<p>Name of the package to use as backend for the computations.
Either <code>"Rwiener"</code> (the default) or <code>"rtdists"</code>.
Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"wiener_backend"</code> option (see <code><a href="base.html#topic+options">options</a></code>).</p>
</td></tr>
<tr><td><code id="Wiener_+3A_n">n</code></td>
<td>
<p>Number of draws to sample from the distribution.</p>
</td></tr>
<tr><td><code id="Wiener_+3A_types">types</code></td>
<td>
<p>Which types of responses to return? By default,
return both the response times <code>"q"</code> and the dichotomous
responses <code>"resp"</code>. If either <code>"q"</code> or <code>"resp"</code>,
return only one of the two types.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are wrappers around functions of the <span class="pkg">RWiener</span> or <span class="pkg">rtdists</span>
package (depending on the chosen <code>backend</code>). See
<code>vignette("brms_families")</code> for details on the parameterization.
</p>


<h3>See Also</h3>

<p><code><a href="RWiener.html#topic+wienerdist">wienerdist</a></code>,
<code><a href="rtdists.html#topic+Diffusion">Diffusion</a></code>
</p>

<hr>
<h2 id='ZeroInflated'>Zero-Inflated Distributions</h2><span id='topic+ZeroInflated'></span><span id='topic+dzero_inflated_poisson'></span><span id='topic+pzero_inflated_poisson'></span><span id='topic+dzero_inflated_negbinomial'></span><span id='topic+pzero_inflated_negbinomial'></span><span id='topic+dzero_inflated_binomial'></span><span id='topic+pzero_inflated_binomial'></span><span id='topic+dzero_inflated_beta_binomial'></span><span id='topic+pzero_inflated_beta_binomial'></span><span id='topic+dzero_inflated_beta'></span><span id='topic+pzero_inflated_beta'></span>

<h3>Description</h3>

<p>Density and distribution functions for zero-inflated distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzero_inflated_poisson(x, lambda, zi, log = FALSE)

pzero_inflated_poisson(q, lambda, zi, lower.tail = TRUE, log.p = FALSE)

dzero_inflated_negbinomial(x, mu, shape, zi, log = FALSE)

pzero_inflated_negbinomial(q, mu, shape, zi, lower.tail = TRUE, log.p = FALSE)

dzero_inflated_binomial(x, size, prob, zi, log = FALSE)

pzero_inflated_binomial(q, size, prob, zi, lower.tail = TRUE, log.p = FALSE)

dzero_inflated_beta_binomial(x, size, mu, phi, zi, log = FALSE)

pzero_inflated_beta_binomial(
  q,
  size,
  mu,
  phi,
  zi,
  lower.tail = TRUE,
  log.p = FALSE
)

dzero_inflated_beta(x, shape1, shape2, zi, log = FALSE)

pzero_inflated_beta(q, shape1, shape2, zi, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZeroInflated_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_zi">zi</code></td>
<td>
<p>zero-inflation probability</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_log">log</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), return P(X &lt;= x).
Else, return P(X &gt; x) .</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_log.p">log.p</code></td>
<td>
<p>Logical; If <code>TRUE</code>, values are returned on the log scale.</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_mu">mu</code>, <code id="ZeroInflated_+3A_lambda">lambda</code></td>
<td>
<p>location parameter</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_shape">shape</code>, <code id="ZeroInflated_+3A_shape1">shape1</code>, <code id="ZeroInflated_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_size">size</code></td>
<td>
<p>number of trials</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial</p>
</td></tr>
<tr><td><code id="ZeroInflated_+3A_phi">phi</code></td>
<td>
<p>precision parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of a zero-inflated distribution can be specified as follows.
If <code class="reqn">x = 0</code> set <code class="reqn">f(x) = \theta + (1 - \theta) * g(0)</code>.
Else set <code class="reqn">f(x) = (1 - \theta) * g(x)</code>,
where <code class="reqn">g(x)</code> is the density of the non-zero-inflated part.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
