<!DOCTYPE html><html><head><title>Help for package ecolRxC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ecolRxC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ecolRxC'><p>Ecological Inference of RxC Tables by Latent Structure Approaches</p></a></li>
<li><a href='#plot.ecolRxC'><p>Graphical representation of a RxC ecological inference (vote transfer) matrix</p></a></li>
<li><a href='#print.ecolRxC'><p>Print a summary of an output of the ecolRxC function</p></a></li>
<li><a href='#print.summary.ecolRxC'><p>Print a summary of a summary.ecolRxC object</p></a></li>
<li><a href='#summary.ecolRxC'><p>Summarize a ecolRxC output object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ecological Inference of RxC Tables by Latent Structure
Approaches</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates RxC (R by C) vote transfer matrices (ecological contingency tables) from aggregate data building on Thomsen (1987) and Park (2008) approaches.
   References:
   Park, W.-H. (2008). &rdquo;Ecological Inference and Aggregate Analysis of Election&rdquo;. PhD Dissertation. University of Michigan. <a href="https://deepblue.lib.umich.edu/bitstream/handle/2027.42/58525/wpark_1.pdf">https://deepblue.lib.umich.edu/bitstream/handle/2027.42/58525/wpark_1.pdf</a>
   Thomsen, S.R. (1987, ISBN:87-7335-037-2). &rdquo;Danish Elections 1920 79: a Logit Approach to Ecological Analysis and Inference&rdquo;. Politica, Aarhus, Denmark.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, scales</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-28 14:56:09 UTC; Jose M Pavia</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose M. Pavía <a href="https://orcid.org/0000-0002-0129-726X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Søren Risbjerg Thomsen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose M. Pavía &lt;jose.m.pavia@uv.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-31 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ecolRxC'>Ecological Inference of RxC Tables by Latent Structure Approaches</h2><span id='topic+ecolRxC'></span>

<h3>Description</h3>

<p>Estimates JxK (RxC) vote transfer matrices (ecological contingency tables) based on Thomsen (1987) and Park (2008) approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecolRxC(
  votes.election1,
  votes.election2,
  scale = "probit",
  method = "Thomsen",
  local = TRUE,
  census.changes = c("adjust", "raw", "regular", "ordinary", "enriched",
    "simultaneous", "semifull", "full", "gold"),
  reference = NULL,
  confidence = NULL,
  B = 500,
  Yule.aprox = FALSE,
  tol = 1e-06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecolRxC_+3A_votes.election1">votes.election1</code></td>
<td>
<p>data.frame (or matrix) of order IxJ1 with the votes gained by
(or the counts corresponding to) the J1 (social classes) political options competing
(available) on election 1 (or origin) in the I units considered.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_votes.election2">votes.election2</code></td>
<td>
<p>data.frame (or matrix) of order IxK2 with the votes gained by
(or the counts corresponding to) the K2 political options competing
(available) on election 2 (or destination) in the I (territorial) units considered.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_scale">scale</code></td>
<td>
<p>A character string indicating the type of transformation to be applied to the vote
fractions for applying ecological inference. Only <code>logit</code> and <code>probit</code> are allowed.
Default, <code>probit</code>.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_method">method</code></td>
<td>
<p>A character string indicating the algorithm to be used for adjusting (making congruent with
the observed margins) the initial crude fractions attained in a 2x2 fashion.
Only <code>Thomsen</code> (see sec. 4.3 in Thomsen, 1987) and <code>IPF</code> (iterative proportional fitting,
also known as raking) are allowed. This argument has no effect in the 2x2 case.
Default, <code>Thomsen</code>.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_local">local</code></td>
<td>
<p>A TRUE/FALSE argument indicating whether local solutions (solutions for each polling unit)
must be computed. In that case, the global solution is attained as composition/aggregation
of local solutions. When <code>method = "Thomsen"</code> local solutions are always computed.
Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_census.changes">census.changes</code></td>
<td>
<p>A character string informing about the level of information available
in <code>votes.election1</code> and <code>votes.election2</code> regarding new entries
and exits of the election censuses between the two elections or
indicating how their sum discrepancies should be handled.
This argument allows the eight options discussed in Pavia (2022)
as well as an adjusting option. This argument admits nine values: <code>adjust</code>,
<code>raw</code>, <code>regular</code>, <code>ordinary</code>, <code>simultaneous</code>, <code>enriched</code>, <code>semifull</code>,
<code>full</code> and <code>gold</code>. See <strong>Details</strong>. Default, <code>adjust</code>.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_reference">reference</code></td>
<td>
<p>A vector of two components indicating (parties) options in election 1
and 2, respectively, to be used as reference with <code>method = "Thomsen"</code>. This has not effect
with <code>method = "IPF"</code>. The references can be indicated by name or by position.
If <code>reference = NULL</code>, the final solution is constructed as a weighted average
of all the congruent solutions attained after considering as references all
combinations of options. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_confidence">confidence</code></td>
<td>
<p>A number between 0 and 1 to be used as level of confidence for the
confidence intervals of the transition rates. By default <code>NULL</code>.
If <code>confidence = NULL</code>, confidence intervals are not computed.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_b">B</code></td>
<td>
<p>An integer indicating the number of samples to be drawn from each crude estimated
confidence interval for estimating final confidence intervals when either
R (J) or C (K) is higher than two. This is not relevant for the 2x2 case.
It can take a while to compute confidence intervals, mainly when <code>method = Thomsen</code>.
In general computation burden grows with <code>B</code>. Default, <code>500</code>.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_yule.aprox">Yule.aprox</code></td>
<td>
<p><code>TRUE</code>/<code>FALSE</code> argument indicating if either Thomsen (1987)'s formula (3.44),
based on a binormal, or Thomsen (1987)'s formula (3.46), based on Yule's
approximation of tetrachoric correlation, should be use to estimate
cross-proportions. Default <code>FALSE</code>, formula (3.44).</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_tol">tol</code></td>
<td>
<p>A number indicating the level of precision to be used to stop the
adjustment of initial/crude count estimates reached using a 2x2 approach in a
general RxC case. This is not relevant for the 2x2 case. Default, <code>0.000001</code>.</p>
</td></tr>
<tr><td><code id="ecolRxC_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Description of the <code>census.changes</code> argument in more detail.
</p>

<ul>
<li><p><code>adjust</code>: The default value. This is the simplest solution for handling discrepancies
between the total number of counts for the first and second elections.
With this value the J1 column-aggregations of the counts
in <code>votes.election1</code> of the first election are proportionally adjusted to
equal the aggregation of the counts in <code>votes.election2</code> of the second election.
In this scenario, J is equal to J1 and K equal to K2.
</p>
</li>
<li><p><code>raw</code>: This argument accounts for a scenario with two elections elapsed at least
some months where only the raw election data recorded in the I (territorial) units,
in which the electoral space under study is divided, are available and net
entries and net exits are approached from the available information.
In this scenario, net exits and net entries are estimated according to
Pavia (2022). When both net entries and exits are no
null, constraint (15) of Pavia (2022) applies: no transfer between entries and
exits are allowed. In this scenario, J could be equal to J1 or J1 + 1 and K equal to
K2 or K2 + 1.
</p>
</li>
<li><p><code>simultaneous</code>: This is the value to be used in classical ecological inference problems,
such as in ecological studies of social or racial voting, and in scenarios with two simultaneous elections.
In this scenario, the sum by rows of <code>votes.election1</code> and <code>votes.election2</code> must coincide.
</p>
</li>
<li><p><code>regular</code>: This value accounts for a scenario with
two elections elapsed at least some months where (i) the column J1
of <code>votes.election1</code> corresponds to new (young) electors who have the right
to vote for the first time, (ii) net exits and maybe other additional
net entries are computed according to Pavia (2022). When both net entries and exits
are no null, constraints (13) and (15) of Pavia (2022) apply. In this scenario, J
could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
</p>
</li>
<li><p><code>ordinary</code>: This value accounts for a scenario
with two elections elapsed at least some months where (i) the column K1
of <code>votes.election2</code> corresponds to electors who died in the interperiod
election, (ii) net entries and maybe other additional net exits are
computed according to Pavia (2022). When both net entries and net exits are no null,
constraints (14) and (15) of Pavia (2022) apply.
In this scenario, J could be equal to J1 or J1 + 1 and K equal to K2 or K2 + 1.
</p>
</li>
<li><p><code>enriched</code>: This value accounts for a scenario that somewhat combine <code>regular</code> and
<code>ordinary</code> scenarios. We consider two elections elapsed at least some months where
(i) the column J1 of <code>votes.election1</code> corresponds to new (young) electors
who have the right to vote for the first time, (ii) the column K2 of
<code>votes.election2</code> corresponds to electors who died in the interperiod
election, (iii) other (net) entries and (net) exits are computed according
to Pavia (2022). When both net entries and net exits are no null, constraints (12) to
(15) of Pavia (2022) apply. In this scenario, J could be equal
to J1 or J1 + 1 and K equal to K2 or K2 + 1.
</p>
</li>
<li><p><code>semifull</code>: This value accounts for a scenario with two elections elapsed at least some
months, where: (i) the column J1 = J of <code>votes.election1</code> totals new
electors (young and immigrants) that have the right to vote for the first time in each polling unit and
(ii) the column K2 = K of <code>votes.election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes.election1</code> and <code>votes.election2</code> must agree and constraint (15)
of Pavia (2022) apply.
</p>
</li>
<li><p><code>full</code>: This value accounts for a scenario with two elections elapsed at least some
months, where J = J1, K = K2 and (i) the column J - 1 of <code>votes.election1</code> totals new (young)
electors that have the right to vote for the first time, (ii) the column J
of <code>votes.election1</code> measures new immigrants that have the right to vote and
(iii) the column K of <code>votes.election2</code> corresponds to total exits of the census
lists (due to death or emigration). In this scenario, the sum by rows of
<code>votes.election1</code> and <code>votes.election2</code> must agree and constraints (13)
and (15) of Pavia (2022) apply.
</p>
</li>
<li><p><code>gold</code>: This value accounts for a scenario similar to <code>full</code>, where J = J1, K = K2 and
total exits are separated out between exits due to emigration
(column K - 1 of <code>votes.election2</code>) and death (column K of <code>votes.election2</code>).
In this scenario, the sum by rows of <code>votes.election1</code> and <code>votes.election2</code> must agree.
Constraints (12) to (15) of Pavia (2022) apply.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>VTM</code></td>
<td>
<p> A matrix of order JxK (RxC) with the estimated proportions of the row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present). When <code>local = TRUE</code> (default), this matrix is obtained as
composition of the local solutions.</p>
</td></tr>
<tr><td><code>VTM.votes</code></td>
<td>
<p> A matrix of order JxK (RxC) with the estimated vote transfers from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present). When <code>local = TRUE</code> (default), this matrix is obtained as
aggregation of the local solutions.</p>
</td></tr>
<tr><td><code>VTM.global</code></td>
<td>
<p> A matrix of order JxK (RxC) with the estimated proportions of the row-standardized vote transitions from election 1 to election 2,
attained directly from the global (whole electoral space) proportions. When <code>local = FALSE</code>. <code>VTM</code> and <code>VTM.global</code> coincide.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.votes.global</code></td>
<td>
<p> A matrix of order JxK (RxC) with the estimated vote transfers from election 1 to election 2,
attained directly from the global proportions. When <code>local = FALSE</code>, <code>VTM.votes</code> and <code>VTM.votes.global</code> coincide.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.lower</code></td>
<td>
<p> A matrix of order JxK (RxC) with the estimated lower limits of the confidence intervals for
the proportions of the row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present). When <code>confidence = NULL</code> this is a <code>NULL</code> object.</p>
</td></tr>
<tr><td><code>VTM.upper</code></td>
<td>
<p> A matrix of order JxK (RxC) with the estimated upper limits of the confidence intervals for
the proportions of the row-standardized vote transitions from election 1 to election 2.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the column corresponding to net entries
and net exits (when they are present). When <code>confidence = NULL</code> this is a <code>NULL</code> object.</p>
</td></tr>
<tr><td><code>VTM.crude.global</code></td>
<td>
<p> A matrix of order JxK (RxC) with the  (inconsistent) crude estimated proportions for the row-standardized
vote transitions from election 1 to election 2 in the whole space attained in a 2x2 fashion before making them
consistent using the iterative proportional fitting algorithm or the Thomsen iteratuve algortihm.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, this matrix includes the row and the
column corresponding to net entries and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.units</code></td>
<td>
<p> An array of order JxKxI (RxCxI) with the estimated proportions of the row-standardized vote transitions from election 1 to election 2
attained for each unit. When <code>local = FALSE</code>, this is a <code>NULL</code> object.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, each unit matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.votes.units</code></td>
<td>
<p> An array of order JxKxI (RxCxI) with the estimated transfer of votes from election 1 to election 2
attained for each unit. When <code>local = FALSE</code>, this is a <code>NULL</code> object.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, each unit matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.lower.units</code></td>
<td>
<p> An array of order JxKxI (RxCxI) with the estimated lower limits of the confidence intervals for
the proportions of the row-standardized vote transitions from election 1 to election 2 corresponding to each unit.
When either <code>local = FALSE</code> or <code>confidence = NULL</code>, this is a <code>NULL</code> object.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, each unit matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.upper.units</code></td>
<td>
<p> An array of order JxKxI (RxCxI) with the estimated upper limits of the confidence intervals for
the proportions of the row-standardized vote transitions from election 1 to election 2 corresponding to each unit.
When either <code>local = FALSE</code> or <code>confidence = NULL</code>, this is a <code>NULL</code> object.
In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, each unit matrix includes the row and the column corresponding to net entries
and net exits (when they are present).</p>
</td></tr>
<tr><td><code>VTM.crude.units</code></td>
<td>
<p> An array of order JxKxI (RxCxI) with the (inconsistent) crude estimated proportions of the row-standardized vote transitions from election 1 to election 2
attained for each unit in a 2x2 fashion before making them consistent using the iterative proportional fitting algorithm or the Thomsen iterative algorithm.
When <code>local = FALSE</code>, this is a NULL object. In <code>raw</code>, <code>regular</code>, <code>ordinary</code> and <code>enriched</code> scenarios, each unit matrix includes the row and the column
corresponding to net entries and net exits (when they are present).</p>
</td></tr>
<tr><td><code>correlations</code></td>
<td>
<p> A matrix of order JxK (Rxc) with the across units correlations between options for the proportions
in the transformed scale.</p>
</td></tr>
<tr><td><code>reference.outputs</code></td>
<td>
<p> A list with three components: <code>vjk.averages</code>, <code>vjk.by.reference</code> and <code>vjk.units.by.reference</code>.
The first component <code>vjk.averages</code> is a JxKx8 array with eight different global solutions
of transfer matrix of votes attained after combining with different weights each of the
solutions obtained using the different combinations of a row and a column option as reference.
The second component <code>vjk.by.reference</code> is a JxKx(J1·K1) array with the J1K1 different
global solutions of transfer matrix of votes attained after choosing as reference all the
possible combination of a row and a column option. The third component <code>vjk.units.by.reference</code>
is a JxKxIx(J1·K1) array with the local solutions linked to <code>vjk.by.reference</code>.
When either <code>method = "IPF"</code> or <code>reference</code> is not <code>NULL</code>, this is a <code>NULL</code> object.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p> A vector of either length 1 (when <code>reference</code> is different of <code>NULL</code>) or J1·K1 with
the number of iterations needed by the Thomsen algorithm to reach convergence for
each reference pair. When <code>method = "Thomsen"</code> this is a <code>NULL</code> object.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p> A list containing all the objects with the values used as arguments by the function.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function somewhere builds on the .ado (STATA) functions written by Won-ho Park, in 2002.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>References</h3>

<p>Achen, C.H. (2000). The Thomsen Estimator for Ecological Inference (Unpublished manuscript). University of Michigan.
</p>
<p>Park, W.-H. (2008). Ecological Inference and Aggregate Analysis of Elections. PhD Dissertation. University of Michigan.
</p>
<p>Pavia, J.M. (2022). Adjustment of initial estimates of voter transition probabilities to guarantee consistency and completeness.
</p>
<p>Thomsen, S.R. (1987). Danish Elections 1920-79: a Logit Approach to Ecological Analysis and Inference. Politica, Aarhus, Denmark.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes1 &lt;- structure(list(P1 = c(16L, 4L, 13L, 6L, 1L, 16L, 6L, 17L, 48L, 14L),
                         P2 = c(8L, 3L, 0L, 5L, 1L, 4L, 7L, 6L, 28L, 8L),
                         P3 = c(38L, 11L, 11L, 3L, 13L, 39L, 14L, 34L, 280L, 84L),
                         P4 = c(66L, 5L, 18L, 39L, 30L, 57L, 35L, 65L, 180L, 78L),
                         P5 = c(14L, 0L, 5L, 2L, 4L, 21L, 6L, 11L, 54L, 9L),
                         P6 = c(8L, 2L, 5L, 3L, 0L, 7L, 7L, 11L, 45L, 17L),
                         P7 = c(7L, 3L, 5L, 2L, 3L, 17L, 7L, 13L, 40L, 8L)),
                         row.names = c(NA, 10L), class = "data.frame")
votes2 &lt;- structure(list(C1 = c(2L, 1L, 2L, 2L, 0L, 4L, 0L, 4L, 19L, 14L),
                         C2 = c(7L, 3L, 1L, 7L, 2L, 5L, 3L, 10L, 21L, 6L),
                         C3 = c(78L, 7L, 28L, 42L, 28L, 84L, 49L, 85L, 260L, 100L),
                         C4 = c(56L, 14L, 20L, 7L, 19L, 54L, 22L, 50L, 330L, 91L),
                         C5 = c(14L, 3L, 6L, 2L, 3L, 14L, 8L, 8L, 45L, 7L)),
                         row.names = c(NA, 10L), class = "data.frame")
example &lt;- ecolRxC(votes1, votes2, method = "IPF")$VTM

</code></pre>

<hr>
<h2 id='plot.ecolRxC'>Graphical representation of a RxC ecological inference (vote transfer) matrix</h2><span id='topic+plot.ecolRxC'></span>

<h3>Description</h3>

<p>Plot method for objects obtained with ecolRxC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ecolRxC'
plot(
  x,
  margins = TRUE,
  digits = 2,
  row.names = NULL,
  col.names = NULL,
  size.numbers = 6,
  size.labels = 4,
  size.margins = 4,
  colour.cells = "cyan4",
  colour.grid = "cornsilk2",
  alpha = 0.5,
  which = NULL,
  ...,
  show.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ecolRxC_+3A_x">x</code></td>
<td>
<p>An object output of the <strong>ecolRxC</strong> function.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_margins">margins</code></td>
<td>
<p>A TRUE/FALSE argument informing if the margins of the matrix should be displayed. Default TRUE.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be shown. Default, 2.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_row.names">row.names</code></td>
<td>
<p>Names to be used for the rows of the matrix.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_col.names">col.names</code></td>
<td>
<p>Names to be used for the columns of the matrix.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_size.numbers">size.numbers</code></td>
<td>
<p>A reference number indicating the average font size to be used for the transfer numbers. Default, 6.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_size.labels">size.labels</code></td>
<td>
<p>A number indicating the font size to be used for labels. Default, 4.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_size.margins">size.margins</code></td>
<td>
<p>A number indicating the font size to be used for margin numbers. Default, 4.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_colour.cells">colour.cells</code></td>
<td>
<p>Background base colour for cells.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_colour.grid">colour.grid</code></td>
<td>
<p>Colour to be used for grid lines.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_alpha">alpha</code></td>
<td>
<p>A [0,1] number of colour transparency.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_which">which</code></td>
<td>
<p>A vector of integers informing the units for which the aggregate transfer matrix should be plotted. Default, NULL, the global matrix is shown.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="plot.ecolRxC_+3A_show.plot">show.plot</code></td>
<td>
<p>A TRUE/FALSE indicating if the plot should be displayed as a side-effect. By default, TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the (ggplot) description of the plot, which is a list with components that contain the plot itself, the data, information about the scales, panels etc.
</p>


<h3>Note</h3>

<p>ggplot2 is needed to be installed for this function to work.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes1 &lt;- structure(list(P1 = c(16L, 4L, 13L, 6L, 1L, 16L, 6L, 17L, 48L, 14L),
                         P2 = c(8L, 3L, 0L, 5L, 1L, 4L, 7L, 6L, 28L, 8L),
                         P3 = c(38L, 11L, 11L, 3L, 13L, 39L, 14L, 34L, 280L, 84L),
                         P4 = c(66L, 5L, 18L, 39L, 30L, 57L, 35L, 65L, 180L, 78L),
                         P5 = c(14L, 0L, 5L, 2L, 4L, 21L, 6L, 11L, 54L, 9L),
                         P6 = c(8L, 2L, 5L, 3L, 0L, 7L, 7L, 11L, 45L, 17L),
                         P7 = c(7L, 3L, 5L, 2L, 3L, 17L, 7L, 13L, 40L, 8L)),
                         row.names = c(NA, 10L), class = "data.frame")
votes2 &lt;- structure(list(C1 = c(2L, 1L, 2L, 2L, 0L, 4L, 0L, 4L, 19L, 14L),
                         C2 = c(7L, 3L, 1L, 7L, 2L, 5L, 3L, 10L, 21L, 6L),
                         C3 = c(78L, 7L, 28L, 42L, 28L, 84L, 49L, 85L, 260L, 100L),
                         C4 = c(56L, 14L, 20L, 7L, 19L, 54L, 22L, 50L, 330L, 91L),
                         C5 = c(14L, 3L, 6L, 2L, 3L, 14L, 8L, 8L, 45L, 7L)),
                         row.names = c(NA, 10L), class = "data.frame")
example &lt;- ecolRxC(votes1, votes2, method = "IPF")
p &lt;- plot(example, show.plot = FALSE)
p

</code></pre>

<hr>
<h2 id='print.ecolRxC'>Print a summary of an output of the ecolRxC function</h2><span id='topic+print.ecolRxC'></span>

<h3>Description</h3>

<p>Print method for objects obtained with the ecolRxC function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ecolRxC'
print(x, ..., margins = TRUE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ecolRxC_+3A_x">x</code></td>
<td>
<p>An object output of the <strong>ecolRxC</strong> function.</p>
</td></tr>
<tr><td><code id="print.ecolRxC_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="print.ecolRxC_+3A_margins">margins</code></td>
<td>
<p>A TRUE/FALSE argument informing if the margins of the transition matrix should be displayed. Default TRUE.</p>
</td></tr>
<tr><td><code id="print.ecolRxC_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be shown. Default, 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes1 &lt;- structure(list(P1 = c(16L, 4L, 13L, 6L, 1L, 16L, 6L, 17L, 48L, 14L),
                         P2 = c(8L, 3L, 0L, 5L, 1L, 4L, 7L, 6L, 28L, 8L),
                         P3 = c(38L, 11L, 11L, 3L, 13L, 39L, 14L, 34L, 280L, 84L),
                         P4 = c(66L, 5L, 18L, 39L, 30L, 57L, 35L, 65L, 180L, 78L),
                         P5 = c(14L, 0L, 5L, 2L, 4L, 21L, 6L, 11L, 54L, 9L),
                         P6 = c(8L, 2L, 5L, 3L, 0L, 7L, 7L, 11L, 45L, 17L),
                         P7 = c(7L, 3L, 5L, 2L, 3L, 17L, 7L, 13L, 40L, 8L)),
                         row.names = c(NA, 10L), class = "data.frame")
votes2 &lt;- structure(list(C1 = c(2L, 1L, 2L, 2L, 0L, 4L, 0L, 4L, 19L, 14L),
                         C2 = c(7L, 3L, 1L, 7L, 2L, 5L, 3L, 10L, 21L, 6L),
                         C3 = c(78L, 7L, 28L, 42L, 28L, 84L, 49L, 85L, 260L, 100L),
                         C4 = c(56L, 14L, 20L, 7L, 19L, 54L, 22L, 50L, 330L, 91L),
                         C5 = c(14L, 3L, 6L, 2L, 3L, 14L, 8L, 8L, 45L, 7L)),
                         row.names = c(NA, 10L), class = "data.frame")
example &lt;- ecolRxC(votes1, votes2, method = "IPF")
print(example, digits = 1, margins = TRUE)

</code></pre>

<hr>
<h2 id='print.summary.ecolRxC'>Print a summary of a summary.ecolRxC object</h2><span id='topic+print.summary.ecolRxC'></span>

<h3>Description</h3>

<p>Print method for <code>summary.ecolRxC</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ecolRxC'
print(x, ..., margins = TRUE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ecolRxC_+3A_x">x</code></td>
<td>
<p>An <code>summary.ecolRxC</code> class object.</p>
</td></tr>
<tr><td><code id="print.summary.ecolRxC_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="print.summary.ecolRxC_+3A_margins">margins</code></td>
<td>
<p>A TRUE/FALSE argument informing if the margins of the transition matrix should be displayed. Default TRUE.</p>
</td></tr>
<tr><td><code id="print.summary.ecolRxC_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be shown. Default, 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='summary.ecolRxC'>Summarize a ecolRxC output object</h2><span id='topic+summary.ecolRxC'></span>

<h3>Description</h3>

<p>Summary method for objects obtained with the ecolRxC function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ecolRxC'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ecolRxC_+3A_object">object</code></td>
<td>
<p>An object output of the <strong>ecolRxC</strong> function.</p>
</td></tr>
<tr><td><code id="summary.ecolRxC_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"summary.ecolRxC"</code>.
A list with four components:
</p>
<table>
<tr><td><code>prop.matrix</code></td>
<td>
<p> A matrix of order JxK (RxC) with the estimated proportions of the row-standardized vote transitions from election 1 to election 2.</p>
</td></tr>
<tr><td><code>counts.matrix</code></td>
<td>
<p> A matrix of order JxK (RxC) with the estimated vote transfers from election 1 to election 2.</p>
</td></tr>
<tr><td><code>row.margins</code></td>
<td>
<p> A vector of length R with aggregate observed distribution of votes in election 1.</p>
</td></tr>
<tr><td><code>col.margins</code></td>
<td>
<p> A vector of length C with aggregate observed distribution of votes in election 2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose M. Pavia, <a href="mailto:pavia@uv.es">pavia@uv.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes1 &lt;- structure(list(P1 = c(16L, 4L, 13L, 6L, 1L, 16L, 6L, 17L, 48L, 14L),
                         P2 = c(8L, 3L, 0L, 5L, 1L, 4L, 7L, 6L, 28L, 8L),
                         P3 = c(38L, 11L, 11L, 3L, 13L, 39L, 14L, 34L, 280L, 84L),
                         P4 = c(66L, 5L, 18L, 39L, 30L, 57L, 35L, 65L, 180L, 78L),
                         P5 = c(14L, 0L, 5L, 2L, 4L, 21L, 6L, 11L, 54L, 9L),
                         P6 = c(8L, 2L, 5L, 3L, 0L, 7L, 7L, 11L, 45L, 17L),
                         P7 = c(7L, 3L, 5L, 2L, 3L, 17L, 7L, 13L, 40L, 8L)),
                         row.names = c(NA, 10L), class = "data.frame")
votes2 &lt;- structure(list(C1 = c(2L, 1L, 2L, 2L, 0L, 4L, 0L, 4L, 19L, 14L),
                         C2 = c(7L, 3L, 1L, 7L, 2L, 5L, 3L, 10L, 21L, 6L),
                         C3 = c(78L, 7L, 28L, 42L, 28L, 84L, 49L, 85L, 260L, 100L),
                         C4 = c(56L, 14L, 20L, 7L, 19L, 54L, 22L, 50L, 330L, 91L),
                         C5 = c(14L, 3L, 6L, 2L, 3L, 14L, 8L, 8L, 45L, 7L)),
                         row.names = c(NA, 10L), class = "data.frame")
example &lt;- ecolRxC(votes1, votes2, method = "IPF")
summary(example)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
