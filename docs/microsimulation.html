<!DOCTYPE html><html lang="en"><head><title>Help for package microsimulation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {microsimulation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#microsimulation-package'><p>microsimulation</p></a></li>
<li><a href='#.microsimulationLdFlags'><p>Internal function</p></a></li>
<li><a href='#callCalibrationPerson'><p>call CalibrationPerson example</p></a></li>
<li><a href='#discountedInterval'><p>Integrate a discounted value</p></a></li>
<li><a href='#fhcrcData'><p>Old data used in the prostata model</p></a></li>
<li><a href='#pqueue'><p>S3 priority queue implementation using C++</p></a></li>
<li><a href='#pqueue__new'><p>C++ function</p></a></li>
<li><a href='#RNGStream'><p>S3 class to work with RngStream objects</p></a></li>
<li><a href='#simulate.survreg'><p>Simulate event times from a survreg object</p></a></li>
<li><a href='#summary.SummaryReport'><p>summary method for a SummaryReport object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Discrete Event Simulation in R and C++, with Tools for
Cost-Effectiveness Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-13</td>
</tr>
<tr>
<td>Description:</td>
<td>Discrete event simulation using both R and C++ (Karlsson et al 2016; &lt;<a href="https://doi.org/10.1109%2FeScience.2016.7870915">doi:10.1109/eScience.2016.7870915</a>&gt;). The C++ code is adapted from the SSIM library <a href="https://www.inf.usi.ch/carzaniga/ssim/">https://www.inf.usi.ch/carzaniga/ssim/</a>, allowing for event-oriented simulation. The code includes a SummaryReport class for reporting events and costs by age and other covariates. The C++ code is available as a static library for linking to other packages. A priority queue implementation is given in C++ together with an S3 closure and a reference class implementation. Finally, some tools are provided for cost-effectiveness analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp (&ge; 0.10.2), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, grDevices, ascii, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mclements/microsimulation">https://github.com/mclements/microsimulation</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mclements/microsimulation/issues">https://github.com/mclements/microsimulation/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-13 18:04:42 UTC; marcle</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Clements [aut, cre, cph],
  Alexandra Jauhiainen [aut],
  Andreas Karlsson [aut],
  Antonio Carzaniga [cph],
  University of Colorado [cph],
  Pierre L'Ecuyer [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark Clements &lt;mark.clements@ki.se&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-19 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='microsimulation-package'>microsimulation</h2><span id='topic+microsimulation-package'></span><span id='topic+microsimulation'></span>

<h3>Description</h3>

<p>Discrete event simulations in both R and C++ with Tools for Cost-Effectiveness Analysis.
</p>


<h3>Introduction</h3>

<p>Discrete event simulations in both R and C++ with Tools for Cost-Effectiveness Analysis.
</p>


<h3>Author(s)</h3>

<p>Mark Clements <a href="mailto:mark.clements@ki.se">mark.clements@ki.se</a>
</p>


<h3>References</h3>

<p><a href="https://github.com/mclements/microsimulation">https://github.com/mclements/microsimulation</a>
</p>


<h3>See Also</h3>

<p><code><a href="Rcpp.html#topic+sourceCpp">sourceCpp</a></code>
</p>

<hr>
<h2 id='.microsimulationLdFlags'>Internal function</h2><span id='topic+.microsimulationLdFlags'></span><span id='topic+inlineCxxPlugin'></span><span id='topic+LdFlags'></span><span id='topic+microsimulation.init'></span><span id='topic+microsimulation.exit'></span><span id='topic+unsigned'></span><span id='topic+signed'></span><span id='topic+rnormPos'></span><span id='topic+set.user.Random.seed'></span><span id='topic+advance.substream'></span><span id='topic+next.user.Random.substream'></span><span id='topic+user.Random.seed'></span><span id='topic+enum'></span><span id='topic+enum+3C-'></span><span id='topic+RNGstate'></span><span id='topic+frontier'></span><span id='topic+lines_frontier'></span><span id='topic+discountedPoint'></span><span id='topic+ICER'></span><span id='topic+.onLoad'></span><span id='topic+.onUnload'></span>

<h3>Description</h3>

<p>Is this function needed? We could define the current stream in open code.
</p>
<p>Again, is this needed?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.microsimulationLdFlags()

inlineCxxPlugin(...)

LdFlags()

microsimulation.init(PACKAGE = "microsimulation")

microsimulation.exit(PACKAGE = "microsimulation")

unsigned(seed)

signed(seed)

rnormPos(n, mean = 0, sd = 1, lbound = 0)

set.user.Random.seed(seed, PACKAGE = "microsimulation")

advance.substream(seed, n, PACKAGE = "microsimulation")

next.user.Random.substream(PACKAGE = "microsimulation")

user.Random.seed(PACKAGE = "microsimulation")

enum(obj, labels, start = 0)

enum(obj) &lt;- value

RNGstate()

frontier(x, y, concave = TRUE, convex = NULL)

lines_frontier(x, y, pch = 19, type = "b", ...)

discountedPoint(y, time, dr)

ICER(object1, object2, ...)

.onLoad(lib, pkg)

.onUnload(libpath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".microsimulationLdFlags_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_package">PACKAGE</code></td>
<td>
<p>package for the seed</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_seed">seed</code></td>
<td>
<p>random number seed</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_n">n</code></td>
<td>
<p>number of sub-streams to advance</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_mean">mean</code></td>
<td>
<p>numeric for the mean of the (untruncated) normal distribution (default=0)</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_sd">sd</code></td>
<td>
<p>numeric for the sd of the (untruncated) normal distribution (default=1)</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_lbound">lbound</code></td>
<td>
<p>numeric for the lower bound (default=0)</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_obj">obj</code></td>
<td>
<p>integer or logical for factor levels</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_labels">labels</code></td>
<td>
<p>labels for the factor levels</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_start">start</code></td>
<td>
<p>first value of the levels</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_value">value</code></td>
<td>
<p>labels for the factor levels</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_x">x</code></td>
<td>
<p>vector of x coordinates</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_y">y</code></td>
<td>
<p>the undiscounted value</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_concave">concave</code></td>
<td>
<p>logical for whether to calculate a concave frontier (default=TRUE)</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_convex">convex</code></td>
<td>
<p>logical for whether to calculate a convex frontier (default=NULL)</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_pch">pch</code></td>
<td>
<p>type of pch for the plotted symbols (default=19)</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_type">type</code></td>
<td>
<p>join type (default=&quot;b&quot;)</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_time">time</code></td>
<td>
<p>the time of the event</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_dr">dr</code></td>
<td>
<p>discount rate, expressed as a percentage</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_object1">object1</code></td>
<td>
<p>first object</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_object2">object2</code></td>
<td>
<p>second object</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_lib">lib</code></td>
<td>
<p>library string</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_pkg">pkg</code></td>
<td>
<p>package string</p>
</td></tr>
<tr><td><code id=".microsimulationLdFlags_+3A_libpath">libpath</code></td>
<td>
<p>library path string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>
<p>No return value, called for side effects
</p>
<p>No return value, called for side effects
</p>
<p>unsigned seed
</p>
<p>signed seed
</p>
<p>numeric vector
</p>
<p>invisibly returns the new seed
</p>
<p>the advanced seed
</p>
<p>invisibly returns TRUE &ndash; called for side effect
</p>
<p>random seed
</p>
<p>the new factor
</p>
<p>update the factor
</p>
<p>a list with oldseed (the old value of .Random.seed), and reset(), which resets .Random.seed
</p>
<p>a list with components x and y for the frontier
</p>
<p>No return value, called for side effects
</p>
<p>numeric vector
</p>

<hr>
<h2 id='callCalibrationPerson'>call CalibrationPerson example</h2><span id='topic+callCalibrationPerson'></span><span id='topic+callPersonSimulation'></span><span id='topic+callSimplePerson'></span><span id='topic+callSimplePerson2'></span><span id='topic+callIllnessDeath'></span>

<h3>Description</h3>

<p>Example that uses the RngStream random number generator
</p>
<p>Example that uses the Mersenne-Twister random number generator
</p>
<p>Example that uses the Mersenne-Twister random number generator
</p>
<p>Example that uses the Mersenne-Twister random number generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callCalibrationPerson(
  seed = 12345,
  n = 500,
  runpar = c(4, 0.5, 0.05, 10, 3, 0.5),
  mc.cores = 1
)

callPersonSimulation(n = 20, seed = rep(12345, 6))

callSimplePerson(n = 10)

callSimplePerson2(n = 10)

callIllnessDeath(n = 10L, cure = 0.1, zsd = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="callCalibrationPerson_+3A_seed">seed</code></td>
<td>
<p>random number seed</p>
</td></tr>
<tr><td><code id="callCalibrationPerson_+3A_n">n</code></td>
<td>
<p>number of simulations (default=10)</p>
</td></tr>
<tr><td><code id="callCalibrationPerson_+3A_runpar">runpar</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="callCalibrationPerson_+3A_mc.cores">mc.cores</code></td>
<td>
<p>number of cores</p>
</td></tr>
<tr><td><code id="callCalibrationPerson_+3A_cure">cure</code></td>
<td>
<p>probability of cure</p>
</td></tr>
<tr><td><code id="callCalibrationPerson_+3A_zsd">zsd</code></td>
<td>
<p>frailty standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data-frame
</p>
<p>data-frame
</p>
<p>data-frame
</p>
<p>data-frame
</p>
<p>data-frame
</p>

<hr>
<h2 id='discountedInterval'>Integrate a discounted value</h2><span id='topic+discountedInterval'></span>

<h3>Description</h3>

<p>Integrate a discounted value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discountedInterval(y, start, finish, dr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discountedInterval_+3A_y">y</code></td>
<td>
<p>the undiscounted value</p>
</td></tr>
<tr><td><code id="discountedInterval_+3A_start">start</code></td>
<td>
<p>the start time</p>
</td></tr>
<tr><td><code id="discountedInterval_+3A_finish">finish</code></td>
<td>
<p>the finish time</p>
</td></tr>
<tr><td><code id="discountedInterval_+3A_dr">dr</code></td>
<td>
<p>discount rate, expressed as a percentage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric discounted value
</p>

<hr>
<h2 id='fhcrcData'>Old data used in the prostata model</h2><span id='topic+fhcrcData'></span>

<h3>Description</h3>

<p>Old data used in the prostata model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fhcrcData
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 10.
</p>

<hr>
<h2 id='pqueue'>S3 priority queue implementation using C++</h2><span id='topic+pqueue'></span><span id='topic+PQueueRef-class'></span><span id='topic+PQueueRef'></span><span id='topic+EventQueue-class'></span><span id='topic+EventQueue'></span><span id='topic+BaseDiscreteEventSimulation-class'></span><span id='topic+BaseDiscreteEventSimulation'></span>

<h3>Description</h3>

<p>This provides a priority queue that is sorted by the priority and entry order. The priority is assumed to be numeric. The events can be of any type. As an extension, events can be cancelled if they satisfy a certain predicate. Note that the inactive events are not removed, rather they are marked as cancelled and will not be available to be popped.
</p>
<p>Based on C++ code. See also the S3 implementation <code>pqueue</code>.
</p>
<p>This event queue is simple and useful for pedagogic purposes.
</p>
<p>Inherit from this class to represent a discrete event simulation. The
API is similar to that for Omnet++, where an <code>init</code> method sets up
the initial events using the <code>scheduleAt(time,event)</code> method, the
messages are handled using the <code>handleMessage(event)</code> method, the
simulation is run using the <code>run</code> method, and the <code>final</code>
method is called at the end of the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pqueue(lower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pqueue_+3A_lower">lower</code></td>
<td>
<p>boolean to determine whether to give priority to lower values (default=TRUE)
or higher values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm for pushing values into the queue is computationally
very simple: simply rank the times using <code>order()</code> and re-order
times and events. This approach is probably of acceptable performance
for smaller queue. A more computationally efficient approach for
pushing into larger queues would be to use a binary search (e.g. using
<code>findInterval()</code>).
</p>
<p>For faster alternatives, see <code>pqueue</code> and <code>PQueueRef</code>.
</p>


<h3>Value</h3>

<p>a list with
</p>

<dl>
<dt>push</dt><dd><p>function with arguments priority (numeric) and event (SEXP). Pushes an event with a given priority</p>
</dd>
<dt>pop</dt><dd><p>function to return a list with a priority (numeric) and an event (SEXP). This pops the first active event.</p>
</dd>
<dt>cancel</dt><dd><p>function that takes a predicate (or R function) for a given event and returns a logical that indicates whether to cancel that event or not. This may cancel some events that will no longer be popped.</p>
</dd>
<dt>empty</dt><dd><p>function that returns whether the priority queue is empty (or has no active events).</p>
</dd>
<dt>clear</dt><dd><p>function to clear the priority queue.</p>
</dd>
<dt>ptr</dt><dd><p>XPtr value</p>
</dd>
</dl>



<h3>Fields</h3>


<dl>
<dt><code>ptr</code></dt><dd><p>External pointer to the C++ class</p>
</dd>
<dt><code>times</code></dt><dd><p>vector of times</p>
</dd>
<dt><code>events</code></dt><dd><p>list of events</p>
</dd>
<dt><code>times</code></dt><dd><p>vector of times</p>
</dd>
<dt><code>events</code></dt><dd><p>list of events</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>cancel(predicate)</code></dt><dd><p>Method to cancel events that satisfy some predicate</p>
</dd>
<dt><code>clear()</code></dt><dd><p>Method to clear the event queue</p>
</dd>
<dt><code>empty()</code></dt><dd><p>Method to check whether there are no events in the queue</p>
</dd>
<dt><code>initialize(lower = TRUE)</code></dt><dd><p>Method to initialize the object. lower argument indicates whether lowest priority or highest priority</p>
</dd>
<dt><code>pop()</code></dt><dd><p>Method to remove the head of the event queue and return its value</p>
</dd>
<dt><code>push(priority, event)</code></dt><dd><p>Method to push an event with a given priority</p>
</dd>
<dt><code>cancel(predicate, ...)</code></dt><dd><p>Method to remove events that satisfy some predicate</p>
</dd>
<dt><code>clear()</code></dt><dd><p>Method to clear the event queue</p>
</dd>
<dt><code>empty()</code></dt><dd><p>Method to check whether there are no events in the queue</p>
</dd>
<dt><code>pop()</code></dt><dd><p>Method to remove the head of the event queue and return its value</p>
</dd>
<dt><code>push(time, event)</code></dt><dd><p>Method to insert the event at the given time</p>
</dd>
<dt><code>final()</code></dt><dd><p>Method for finalising the simulation</p>
</dd>
<dt><code>handleMessage(event)</code></dt><dd><p>Virtual method to handle the messages as they arrive</p>
</dd>
<dt><code>init()</code></dt><dd><p>Virtual method to initialise the event queue and attributes</p>
</dd>
<dt><code>reset(startTime = 0)</code></dt><dd><p>Method to reset the event queue</p>
</dd>
<dt><code>run(startTime = 0)</code></dt><dd><p>Method to run the simulation</p>
</dd>
<dt><code>scheduleAt(time, event)</code></dt><dd><p>Method that adds attributes for the event time and the sendingTime, and then insert the event into the event queue</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>pq = pqueue()
pq$push(3,"Clear drains")
pq$push(4, "Feed cat")
pq$push(5, "Make tea")
pq$push(1, "Solve RC tasks")
pq$push(2, "Tax return")
while(!pq$empty())
  print(pq$pop())

pq = new("PQueueRef")
pq$push(3,"Clear drains")
pq$push(4, "Feed cat")
pq$push(5, "Make tea")
pq$push(1, "Solve RC tasks")
pq$push(2, "Tax return")
while(!pq$empty())
  print(pq$pop())

pq = new("EventQueue")
pq$push(3,"Clear drains")
pq$push(4, "Feed cat")
pq$push(5, "Make tea")
pq$push(1, "Solve RC tasks")
pq$push(2, "Tax return")
while(!pq$empty())
  print(pq$pop())

DES = setRefClass("DES",
                  contains = "BaseDiscreteEventSimulation",
                  methods=list(
                      init=function() {
                         scheduleAt(3,"Clear drains")
                         scheduleAt(4, "Feed cat")
                         scheduleAt(5, "Make tea")
                         scheduleAt(1, "Solve RC tasks")
                         scheduleAt(2, "Tax return")
                      },
                      handleMessage=function(event) print(event)))

des = new("DES")
des$run()
## Not run: 
testRsimulation1 &lt;- function() {
    ## A simple example
    Simulation &lt;-
        setRefClass("Simulation",
                    contains = "BaseDiscreteEventSimulation")
    Simulation$methods(
        init = function() {
            scheduleAt(rweibull(1,8,85), "Death due to other causes")
            scheduleAt(rweibull(1,3,90), "Cancer diagnosis")
        },
        handleMessage = function(event) {
            if (event %in% c("Death due to other causes", "Cancer death")) {
                clear()
                print(event)
            }
            else if (event == "Cancer diagnosis") {
                if (runif(1) &lt; 0.5)
                    scheduleAt(now() + rweibull(1,2,10), "Cancer death")
                print(event)
            }
        })
    Simulation$new()$run()
}

## An extension with individual life histories
testRsimulation2 &lt;- function(n=100) {
    Simulation &lt;-
        setRefClass("Simulation",
                    contains = "BaseDiscreteEventSimulation",
                    fields = list(state = "character", report = "data.frame"))
    Simulation$methods(
        init = function() {
            report &lt;&lt;- data.frame()
            state &lt;&lt;- "Healthy"
            scheduleAt(rweibull(1,8,85), "Death due to other causes")
            scheduleAt(rweibull(1,3,90), "Cancer diagnosis")
        },
        handleMessage = function(event) {
            report &lt;&lt;- rbind(report, data.frame(state = state,
                                                begin = attr(event,"sendingTime"),
                                                end = currentTime,
                                                event = event,
                                                stringsAsFactors = FALSE))
            if (event %in% c("Death due to other causes", "Cancer death")) {
                clear()
            }
            else if (event == "Cancer diagnosis") {
                state &lt;&lt;- "Cancer"
                if (runif(1) &lt; 0.5)
                    scheduleAt(now() + rweibull(1,2,10), "Cancer death")
            }
        },
        final = function() report)
    sim &lt;- Simulation$new()
    do.call("rbind", lapply(1:n, function(id) data.frame(id=id,sim$run())))
}

## reversible illness-death model
testRsimulation3 &lt;- function(n=100) {
    Simulation &lt;-
        setRefClass("Simulation",
                    contains = "BaseDiscreteEventSimulation",
                    fields = list(state = "character", everCancer = "logical",
                                  report = "data.frame"))
    Simulation$methods(
        init = function() {
            report &lt;&lt;- data.frame()
            state &lt;&lt;- "Healthy"
            everCancer &lt;&lt;- FALSE
            scheduleAt(rweibull(1,8,85), "Death due to other causes")
            scheduleAt(rweibull(1,3,90), "Cancer diagnosis")
        },
        handleMessage = function(event) {
            report &lt;&lt;- rbind(report, data.frame(state = state,
                                                everCancer = everCancer,
                                                begin = attr(event,"sendingTime"),
                                                end = currentTime,
                                                event = event,
                                                stringsAsFactors = FALSE))
            if (event %in% c("Death due to other causes", "Cancer death")) {
                clear()
            }
            else if (event == "Cancer diagnosis") {
                state &lt;&lt;- "Cancer"
                everCancer &lt;&lt;- TRUE
                if (runif(1) &lt; 0.5)
                    scheduleAt(now() + rweibull(1,2,10), "Cancer death")
                scheduleAt(now() + 10, "Recovery")
            }
            else if (event == "Recovery") {
                state &lt;&lt;- "Healthy"
                scheduleAt(now() + rexp(1,10), "Cancer diagnosis")
            }
        },
        final = function() report)
    sim &lt;- Simulation$new()
    do.call("rbind", lapply(1:n, function(id) data.frame(id=id,sim$run())))
}

## cancer screening
testRsimulation4 &lt;- function(n=1) {
    Simulation &lt;-
        setRefClass("Simulation",
                    contains = "BaseDiscreteEventSimulation",
                    fields = list(state = "character", report = "data.frame"))
    Simulation$methods(
        init = function() {
            report &lt;&lt;- data.frame()
            state &lt;&lt;- "Healthy"
            scheduleAt(rweibull(1,8,85), "Death due to other causes")
            scheduleAt(rweibull(1,3,90), "Cancer onset")
            scheduleAt(50,"Screening")
        },
        handleMessage = function(event) {
            report &lt;&lt;- rbind(report, data.frame(state = state,
                                                begin = attr(event,"sendingTime"),
                                                end = currentTime,
                                                event = event,
                                                stringsAsFactors = FALSE))
            if (event %in% c("Death due to other causes", "Cancer death")) {
                clear()
            }
            else if (event == "Cancer onset") {
                state &lt;&lt;- event
                dx &lt;- now() + rweibull(1,2,10)
                scheduleAt(dx, "Clinical cancer diagnosis")
                scheduleAt(dx + rweibull(1,1,10), "Cancer death")
                scheduleAt(now() + rweibull(1,1,10), "Metastatic cancer")
            }
            else if (event == "Metastatic cancer") {
                state &lt;&lt;- event
                cancel(function(event) event %in%
                       c("Clinical cancer diagnosis","Cancer death")) # competing events
                scheduleAt(now() + rweibull(1,2,5), "Cancer death")
            }
            else if (event == "Clinical cancer diagnosis") {
                state &lt;&lt;- event
                cancel(function(event) event == "Metastatic cancer")
            }
            else if (event == "Screening") {
                switch(state,
                       "Cancer onset" = {
                           state &lt;&lt;- "Screen-detected cancer diagnosis"
                           cancel(function(event) event %in%
                                  c("Clinical cancer diagnosis","Metastatic cancer"))
                       },
                       "Metastatic cancer" = {}, # ignore
                       "Clincal cancer diagnosis" = {}, # ignore
                       "Healthy" = {
                           if (now()&lt;=68) scheduleAt(now()+2, "Screening")
                       })
            }
            else stop(event)
        },
        final = function() report)
    sim &lt;- Simulation$new()
    do.call("rbind", lapply(1:n, function(id) data.frame(id=id,sim$run())))
}

## ticking bomb - toy example
testRsimulation5 &lt;- function(n=1) {
    Simulation &lt;-
        setRefClass("Simulation",
                    contains = "BaseDiscreteEventSimulation",
                    fields = list(report = "data.frame"))
    Simulation$methods(
        init = function() {
            report &lt;&lt;- data.frame()
            scheduleAt(rexp(1,1), "tick")
            if (runif(1)&lt;0.1)
                scheduleAt(rexp(1,1), "explosion")
        },
        handleMessage = function(event) {
            report &lt;&lt;- rbind(report, data.frame(begin = attr(event,"sendingTime"),
                                                end = currentTime,
                                                event = event,
                                                stringsAsFactors = FALSE))
            if (event == "explosion")
                clear()
            else {
                clear() # queue
                if (event == "tick") scheduleAt(currentTime+rexp(1,1), "tock")
                else scheduleAt(currentTime+rexp(1,1), "tick")
                if (runif(1)&lt;0.1)
                    scheduleAt(currentTime+rexp(1,1), "explosion")
            }
        },
        final = function() report)
    sim &lt;- Simulation$new()
    do.call("rbind", lapply(1:n, function(id) data.frame(id=id,sim$run())))
}

## End(Not run)

</code></pre>

<hr>
<h2 id='pqueue__new'>C++ function</h2><span id='topic+pqueue__new'></span><span id='topic+pqueue__push'></span><span id='topic+pqueue__pop'></span><span id='topic+pqueue__cancel'></span><span id='topic+pqueue__empty'></span><span id='topic+pqueue__clear'></span><span id='topic+callCalibrationSimulation'></span><span id='topic+r_create_current_stream'></span><span id='topic+r_remove_current_stream'></span><span id='topic+r_set_user_random_seed'></span><span id='topic+r_rng_advance_substream'></span><span id='topic+r_next_rng_substream'></span><span id='topic+r_get_user_random_seed'></span>

<h3>Description</h3>

<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>
<p>C++ function
</p>


<h3>Value</h3>

<p>data-frame
</p>
<p>No return value, called for side effects
</p>
<p>No return value, called for side effects
</p>
<p>No return value, called for side effects
</p>
<p>No return value, called for side effects
</p>
<p>No return value, called for side effects
</p>
<p>No return value, called for side effects
</p>

<hr>
<h2 id='RNGStream'>S3 class to work with RngStream objects</h2><span id='topic+RNGStream'></span><span id='topic+RNGStream-class'></span><span id='topic+with.RNGStream'></span>

<h3>Description</h3>

<p>S3 class to work with RngStream objects
</p>
<p>Use RNGStream as an old class
</p>
<p>With method for RNGStream S3 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RNGStream(nextStream = TRUE, iseed = NULL)

## S3 method for class 'RNGStream'
with(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RNGStream_+3A_nextstream">nextStream</code></td>
<td>
<p>whether to move to the next stream (default=TRUE)</p>
</td></tr>
<tr><td><code id="RNGStream_+3A_iseed">iseed</code></td>
<td>
<p>set seed after changing RNG (otherwise keep the current seed)</p>
</td></tr>
<tr><td><code id="RNGStream_+3A_data">data</code></td>
<td>
<p>object of type RNGStream</p>
</td></tr>
<tr><td><code id="RNGStream_+3A_expr">expr</code></td>
<td>
<p>expression using the RNGStream</p>
</td></tr>
<tr><td><code id="RNGStream_+3A_...">...</code></td>
<td>
<p>other arguments passed to eval()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of class <code>RNGStream</code> with components:
</p>

<dl>
<dt>resetRNGkind</dt><dd><p>function to reset to the previous RNG and seed</p>
</dd>
<dt>seed</dt><dd><p>function to return the current seed</p>
</dd>
<dt>open</dt><dd><p>function to use the current seed</p>
</dd>
<dt>close</dt><dd><p>function to make the current seed equal to .Random.seed</p>
</dd>
<dt>resetStream</dt><dd><p>function to move back to start of stream</p>
</dd>
<dt>resetSubStream</dt><dd><p>function to move back to start of sub-stream</p>
</dd>
<dt>nextSubStream</dt><dd><p>function to move to next sub-stream</p>
</dd>
<dt>nextStream</dt><dd><p>function to move to next stream</p>
</dd>
</dl>

<p>the value from the expression
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up one stream
s1 &lt;- RNGStream()
s1$open()
rnorm(1)
s1$nextSubStream()
rnorm(1)
## reset the stream
s1$resetStream()
rnorm(2)
s1$nextSubStream()
rnorm(2)

## now do with two streams
s1$resetStream()
s2 &lt;- RNGStream()
with(s1,rnorm(1))
with(s2,rnorm(1))
s1$nextSubStream()
with(s1,rnorm(1))
## now reset the streams and take two samples each time
s1$resetStream()
s2$resetStream()
with(s1,rnorm(2))
with(s2,rnorm(2))
s1$nextSubStream()
with(s1,rnorm(2))
</code></pre>

<hr>
<h2 id='simulate.survreg'>Simulate event times from a survreg object</h2><span id='topic+simulate.survreg'></span>

<h3>Description</h3>

<p>Simulate event times from a survreg object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survreg'
simulate(object, nsim = 1, seed = NULL, newdata, t0 = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.survreg_+3A_object">object</code></td>
<td>
<p>survreg object</p>
</td></tr>
<tr><td><code id="simulate.survreg_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations per row in newdata</p>
</td></tr>
<tr><td><code id="simulate.survreg_+3A_seed">seed</code></td>
<td>
<p>random number seed</p>
</td></tr>
<tr><td><code id="simulate.survreg_+3A_newdata">newdata</code></td>
<td>
<p>data-frame for defining the covariates for the simulations. Required.</p>
</td></tr>
<tr><td><code id="simulate.survreg_+3A_t0">t0</code></td>
<td>
<p>delayed entry time. Defaults to NULL (which assumes that t0=0)</p>
</td></tr>
<tr><td><code id="simulate.survreg_+3A_...">...</code></td>
<td>
<p>other arguments (not currently used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of event times with nsim repeats per row in newdata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
fit &lt;- survreg(Surv(time, status) ~ ph.ecog + age + sex + strata(sex),
               data = lung)
nd = transform(expand.grid(ph.ecog=0:1, sex=1:2), age=60)
simulate(fit, seed=1002, newdata=nd)
simulate(fit, seed=1002, newdata=nd, t0=500)
</code></pre>

<hr>
<h2 id='summary.SummaryReport'>summary method for a SummaryReport object</h2><span id='topic+summary.SummaryReport'></span><span id='topic+print.summary.SummaryReport'></span><span id='topic+print.SummaryReport'></span><span id='topic+rbind.SummaryReport'></span><span id='topic+ascii.SummaryReport'></span><span id='topic+ICER.SummaryReport'></span><span id='topic+ascii.ICER.SummaryReport'></span>

<h3>Description</h3>

<p>At present, this passes the object to summary and then prints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SummaryReport'
summary(object, ...)

## S3 method for class 'summary.SummaryReport'
print(x, ...)

## S3 method for class 'SummaryReport'
print(x, ...)

## S3 method for class 'SummaryReport'
rbind(...)

## S3 method for class 'SummaryReport'
ascii(
  x,
  include.rownames = FALSE,
  include.colnames = TRUE,
  header = TRUE,
  digits = c(0, 3, 2, 2, 4, 4),
  ...
)

## S3 method for class 'SummaryReport'
ICER(object1, object2, ...)

## S3 method for class 'ICER.SummaryReport'
ascii(
  x,
  include.rownames = TRUE,
  include.colnames = TRUE,
  header = TRUE,
  digits = c(1, 1, 3, 3, 1, 1, 3, 3, 1),
  rownames = c("Reference", "Treatment"),
  colnames = c("Costs", "(se)", "QALYs", "(se)", "Costs", "(se)", "QALYs", "(se)",
    "ICER"),
  tgroup = c("Total", "Incremental"),
  n.tgroup = c(4, 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.SummaryReport_+3A_object">object</code></td>
<td>
<p>SummaryReport object</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_...">...</code></td>
<td>
<p>other arguments to pass to ascii</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_x">x</code></td>
<td>
<p>an ICER.SummaryReport object</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_include.rownames">include.rownames</code></td>
<td>
<p>logical for whether to include rownames (default=FALSE)</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_include.colnames">include.colnames</code></td>
<td>
<p>logical for whether to include colnames (default=TRUE)</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_header">header</code></td>
<td>
<p>logical for whether to include the header (default=TRUE)</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_digits">digits</code></td>
<td>
<p>vector of the number of digits to use for each column</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_object1">object1</code></td>
<td>
<p>SummaryReport object (reference)</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_object2">object2</code></td>
<td>
<p>SummaryReport object</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_rownames">rownames</code></td>
<td>
<p>rownames for output</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_colnames">colnames</code></td>
<td>
<p>colnames for output</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_tgroup">tgroup</code></td>
<td>
<p>tgroup arg passed to ascii</p>
</td></tr>
<tr><td><code id="summary.SummaryReport_+3A_n.tgroup">n.tgroup</code></td>
<td>
<p>arg passed to ascii</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class summary.SummaryReport with components:
</p>

<dl>
<dt>n</dt><dd><p>Number of simulations</p>
</dd>
<dt>indivip</dt><dd><p>boolean with whether individual values were retained</p>
</dd>
<dt>utilityDiscountRate</dt><dd><p>discount rate for utilities/QALYs</p>
</dd>
<dt>costDiscountRate</dt><dd><p>discount rate for costs</p>
</dd>
<dt>QALE</dt><dd><p>Quality-adjusted life expectancy (discounted)</p>
</dd>
<dt>LE</dt><dd><p>Life expectancy (not discounted)</p>
</dd>
<dt>ECosts</dt><dd><p>Life-time expected costs (discounted)</p>
</dd>
<dt>se.QALE</dt><dd><p>standard error for QALE</p>
</dd>
<dt>se.Ecosts</dt><dd><p>standard error Ecosts</p>
</dd>
</dl>

<p>a SummaryReport object
</p>
<p>ascii object
</p>
<p>a list of type ICER.SummaryReport with components:
</p>

<dl>
<dt>n</dt><dd><p>number of simulations</p>
</dd>
<dt>utilityDiscountRate</dt><dd><p>Discount rate for the utilities/QALE</p>
</dd>
<dt>costDiscountRate</dt><dd><p>Discount rate for the costs</p>
</dd>
<dt>s1</dt><dd><p>summary for object1</p>
</dd>
<dt>s2</dt><dd><p>summary for object2</p>
</dd>
<dt>dQALE</dt><dd><p>QALE for object2 minus QALE for object1</p>
</dd>
<dt>dCosts</dt><dd><p>Costs for object2 minus costs for object1</p>
</dd>
<dt>ICER</dt><dd><p>change of costs divided by change in QALEs</p>
</dd>
<dt>se.dQALE</dt><dd><p>standard error for dQALE</p>
</dd>
<dt>se.dCosts</dt><dd><p>standard error for dCosts</p>
</dd>
</dl>

<p>ascii object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
