<!DOCTYPE html><html><head><title>Help for package heterogen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {heterogen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bg_transpose'><p>bg_transpose</p></a></li>
<li><a href='#distance_weighted_gauss'><p>distance_weighted_gauss</p></a></li>
<li><a href='#float_relative'><p>float_relative</p></a></li>
<li><a href='#float_round'><p>float_round</p></a></li>
<li><a href='#gwpca_core'><p>Core Function of GWPCA</p></a></li>
<li><a href='#gwpca_df_mc'><p>Perform GWPCA from data.frame with spatial structure.</p></a></li>
<li><a href='#heterog'><p>Heterogeneity (rasters)</p></a></li>
<li><a href='#matrixcec_square'><p>matrixcec_square</p></a></li>
<li><a href='#matrixmult'><p>matrixmult</p></a></li>
<li><a href='#matrixvec_plus'><p>matrixvec_plus</p></a></li>
<li><a href='#matrixvec_subs'><p>matrixvec_subs</p></a></li>
<li><a href='#plot+2CSpatHetero+2CANY-method'><p>Plot Heterogeneity Layer</p></a></li>
<li><a href='#SpatHetero-class'><p>SpatHetero</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Functions for Heterogeneity and Climate Variability</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.33</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-13</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive suite of spatial 
  functions created to analyze and assess data heterogeneity and climate variability 
  in spatial datasets. This package is specifically designed to address the challenges associated
  with characterizing and understanding complex spatial patterns in environmental and climate-related data.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>P.Joser Atauchi &lt;patauchi@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/patauchi/heterogen">https://github.com/patauchi/heterogen</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/patauchi/heterogen/issues">https://github.com/patauchi/heterogen/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>terra</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, rio, scales, future, parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-16 16:40:05 UTC; pjoseratauchi</td>
</tr>
<tr>
<td>Author:</td>
<td>P.Joser Atauchi [aut, cre],
  A. Townsend Peterson [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-17 07:42:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='bg_transpose'>bg_transpose</h2><span id='topic+bg_transpose'></span>

<h3>Description</h3>

<p>Transpose of a matrix based on row or column index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bg_transpose(mat, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bg_transpose_+3A_mat">mat</code></td>
<td>
<p>A Matrix.</p>
</td></tr>
<tr><td><code id="bg_transpose_+3A_byrow">byrow</code></td>
<td>
<p><code>FALSE</code> computes based on row index. <code>TRUE</code> computes based on column index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix transposed.
</p>

<hr>
<h2 id='distance_weighted_gauss'>distance_weighted_gauss</h2><span id='topic+distance_weighted_gauss'></span>

<h3>Description</h3>

<p>Weighted Distance based on Gaussian function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_weighted_gauss(coord_xy, point_xy, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_weighted_gauss_+3A_coord_xy">coord_xy</code></td>
<td>
<p>A Matrix with lon/lat coordinates.</p>
</td></tr>
<tr><td><code id="distance_weighted_gauss_+3A_point_xy">point_xy</code></td>
<td>
<p>lon/lat coordinate.</p>
</td></tr>
<tr><td><code id="distance_weighted_gauss_+3A_tau">tau</code></td>
<td>
<p>bandwidth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>

<hr>
<h2 id='float_relative'>float_relative</h2><span id='topic+float_relative'></span>

<h3>Description</h3>

<p>Relative sum formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>float_relative(xx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="float_relative_+3A_xx">xx</code></td>
<td>
<p>A Matrix with lon/lat coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>

<hr>
<h2 id='float_round'>float_round</h2><span id='topic+float_round'></span>

<h3>Description</h3>

<p>Rouding of Numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>float_round(float_n, digits = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="float_round_+3A_float_n">float_n</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="float_round_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>

<hr>
<h2 id='gwpca_core'>Core Function of GWPCA</h2><span id='topic+gwpca_core'></span>

<h3>Description</h3>

<p>The <code>gwpca_core</code> function is a core implementation of Generalized Weighted Principal Component Analysis for each iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwpca_core(xy, p_xy, env, env_trans, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwpca_core_+3A_xy">xy</code></td>
<td>
<p>A matrix containing the coordinates of the points where environmental measurements were taken. The matrix should have two columns, representing the X and Y coordinates.</p>
</td></tr>
<tr><td><code id="gwpca_core_+3A_p_xy">p_xy</code></td>
<td>
<p>A matrix containing the coordinates of the point GWPCA will be estimated. It should have two columns for X and Y coordinates.</p>
</td></tr>
<tr><td><code id="gwpca_core_+3A_env">env</code></td>
<td>
<p>A data matrix representing the environmental variables. Rows represent observations (points or grid cells), and columns represent environmental variables.</p>
</td></tr>
<tr><td><code id="gwpca_core_+3A_env_trans">env_trans</code></td>
<td>
<p>Transpose of <code>env</code> matrix.</p>
</td></tr>
<tr><td><code id="gwpca_core_+3A_tau">tau</code></td>
<td>
<p>The bandwidth parameter for spatial weighting in GWPCA. It determines the extent of spatial influence on the estimation of principal components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of eigenvalues from local PCA
</p>

<hr>
<h2 id='gwpca_df_mc'>Perform GWPCA from data.frame with spatial structure.</h2><span id='topic+gwpca_df_mc'></span>

<h3>Description</h3>

<p>gwpca_df is an R function that performs Generalized Weighted Principal Component Analysis (GWPCA) on a given dataset.
This function allow to calculate the environmental heterogeneity from data.frame with spatial structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwpca_df_mc(
  datadf,
  bandwidth = 0.2,
  tolerance = 5,
  nprocess = 10000,
  parallel = FALSE,
  ncores = 2,
  normalized = FALSE,
  method = "iter",
  dirds = "rds"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwpca_df_mc_+3A_datadf">datadf</code></td>
<td>
<p>The input data matrix for which GWPCA needs to be performed. It should contain numerical values only. Rows represent cells, and columns represent bioclimatic variables.</p>
</td></tr>
<tr><td><code id="gwpca_df_mc_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The bandwidth for the spatial weighting function.</p>
</td></tr>
<tr><td><code id="gwpca_df_mc_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance for spatial weight computation.</p>
</td></tr>
<tr><td><code id="gwpca_df_mc_+3A_nprocess">nprocess</code></td>
<td>
<p>(Optional) The number of iterations for calculating the principal components. Default is set to 1000.</p>
</td></tr>
<tr><td><code id="gwpca_df_mc_+3A_parallel">parallel</code></td>
<td>
<p>(Optional) A logical value indicating whether to run the computation in parallel. If <code>TRUE</code>, multiple cores will be used for processing. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gwpca_df_mc_+3A_ncores">ncores</code></td>
<td>
<p>(Optional) The number of cores to be used for parallel computation. Only applicable if <code>parallel</code> is set to <code>TRUE</code>. Default is 4.</p>
</td></tr>
<tr><td><code id="gwpca_df_mc_+3A_normalized">normalized</code></td>
<td>
<p>(Optional) A logical value indicating whether the input data should be normalized before performing GWPCA. Default is <code>FALSE</code>, meaning the data will not be normalized.
Take in account that core function performs correlation analysis in order to normalize the input variables.</p>
</td></tr>
<tr><td><code id="gwpca_df_mc_+3A_method">method</code></td>
<td>
<p>The method used for GWPCA computation. It can take one of the following values. <code>local</code> Performs GWPCA locally and will save each iteration on .rds files. Recommended for large-scale data sets.
<code>inter</code> Uses RAM memory to . Default is <code>inter</code>.</p>
</td></tr>
<tr><td><code id="gwpca_df_mc_+3A_dirds">dirds</code></td>
<td>
<p>(Optional) The directory where the results will be saved in RDS format. Default is <code>rds</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of eigenvalues
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path_csv &lt;- system.file("extdata","south.csv", package="heterogen")
south_csv &lt;- rio::import(path_csv)

# notice: south_csv object contains x,y (lot/lat coordinates)
# and environmental variables
north_het &lt;- gwpca_df_mc(as.matrix(south_csv), parallel = TRUE, 
ncores = 2, bandwidth = 0.1, tolerance = 10)



</code></pre>

<hr>
<h2 id='heterog'>Heterogeneity (rasters)</h2><span id='topic+heterog'></span>

<h3>Description</h3>

<p>The <code>heterog</code> function is designed to calculate environmental heterogeneity metric from a raster stack dataset.
This function aids in assessing the spatial variation and diversity of environmental variables within the raster data,
providing valuable insights into the heterogeneity of the study area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heterog(
  datastack,
  bandwidth = 0.3,
  tolerance = 5,
  nprocess = 1000,
  parallel = FALSE,
  ncores = 2,
  normalized = FALSE,
  method = "iter",
  dirds = "rds"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heterog_+3A_datastack">datastack</code></td>
<td>
<p><code>SpatRaster</code> class. The input raster stack representing environmental variables.
Each layer in the stack corresponds to a different environmental variable, and the function calculates heterogeneity based on the variability across these layers.</p>
</td></tr>
<tr><td><code id="heterog_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The bandwidth for the spatial weighting function.</p>
</td></tr>
<tr><td><code id="heterog_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance for spatial weight computation.</p>
</td></tr>
<tr><td><code id="heterog_+3A_nprocess">nprocess</code></td>
<td>
<p>(Optional) The number of iterations for calculating the principal components. Default is set to 1000.</p>
</td></tr>
<tr><td><code id="heterog_+3A_parallel">parallel</code></td>
<td>
<p>(Optional) A logical value indicating whether to run the computation in parallel. If <code>TRUE</code>, multiple cores will be used for processing. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="heterog_+3A_ncores">ncores</code></td>
<td>
<p>(Optional) The number of cores to be used for parallel computation. Only applicable if <code>parallel</code> is set to <code>TRUE</code>. Default is 4.</p>
</td></tr>
<tr><td><code id="heterog_+3A_normalized">normalized</code></td>
<td>
<p>(Optional) A logical value indicating whether the input data should be normalized before performing GWPCA. Default is <code>FALSE</code>, meaning the data will not be normalized.
Take in account that core function performs correlation analysis in order to normalize the input variables.</p>
</td></tr>
<tr><td><code id="heterog_+3A_method">method</code></td>
<td>
<p>The method used for GWPCA computation. It can take one of the following values. <code>local</code> Performs GWPCA locally and will save each iteration on .rds files. Recommended for large-scale data sets.
<code>inter</code> Uses RAM memory to . Default is <code>inter</code>.</p>
</td></tr>
<tr><td><code id="heterog_+3A_dirds">dirds</code></td>
<td>
<p>(Optional) The directory where the results will be saved in RDS format. Default is <code>rds</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatHetero object
</p>

<ul>
<li><p>hetero A heterogeneity layer
</p>
</li>
<li><p>matrix A Matrix of eigenvalues
</p>
</li>
<li><p>rasters A complete set of heterogeneity layers for each component
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Case 01: South
path &lt;- system.file("extdata","south", package="heterogen")
south_rast &lt;- terra::rast(list.files(path, full.names = TRUE, 
pattern = '.tif'))

south_het &lt;- heterog(south_rast, parallel = TRUE, 
bandwidth = 0.1, tolerance = 10)
plot(south_het)



# Case 02: North
path &lt;- system.file("extdata","north", package="heterogen")
north_rast &lt;- terra::rast(list.files(path, full.names = TRUE, 
pattern = '.tif'))

north_het &lt;- heterog(north_rast, parallel = TRUE,
bandwidth = 0.1, tolerance = 10)
plot(north_het)




</code></pre>

<hr>
<h2 id='matrixcec_square'>matrixcec_square</h2><span id='topic+matrixcec_square'></span>

<h3>Description</h3>

<p>Matrix Square
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixcec_square(X, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixcec_square_+3A_x">X</code></td>
<td>
<p>A Matrix.</p>
</td></tr>
<tr><td><code id="matrixcec_square_+3A_y">y</code></td>
<td>
<p>A Vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='matrixmult'>matrixmult</h2><span id='topic+matrixmult'></span>

<h3>Description</h3>

<p>Matrix Multiplication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixmult(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixmult_+3A_a">A</code></td>
<td>
<p>A Matrix.</p>
</td></tr>
<tr><td><code id="matrixmult_+3A_b">B</code></td>
<td>
<p>A Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='matrixvec_plus'>matrixvec_plus</h2><span id='topic+matrixvec_plus'></span>

<h3>Description</h3>

<p>Matrix Multiplication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixvec_plus(X, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixvec_plus_+3A_x">X</code></td>
<td>
<p>A Matrix.</p>
</td></tr>
<tr><td><code id="matrixvec_plus_+3A_y">y</code></td>
<td>
<p>A Vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='matrixvec_subs'>matrixvec_subs</h2><span id='topic+matrixvec_subs'></span>

<h3>Description</h3>

<p>Matrix Substraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixvec_subs(X, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixvec_subs_+3A_x">X</code></td>
<td>
<p>A Matrix.</p>
</td></tr>
<tr><td><code id="matrixvec_subs_+3A_y">y</code></td>
<td>
<p>A Vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='plot+2CSpatHetero+2CANY-method'>Plot Heterogeneity Layer</h2><span id='topic+plot+2CSpatHetero+2CANY-method'></span>

<h3>Description</h3>

<p>Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatHetero,ANY'
plot(x, comp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CSpatHetero+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>SpatHetero Class</p>
</td></tr>
<tr><td><code id="plot+2B2CSpatHetero+2B2CANY-method_+3A_comp">comp</code></td>
<td>
<p>integer. Plot specific component of the heterogeneity.</p>
</td></tr>
<tr><td><code id="plot+2B2CSpatHetero+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>Plot parameters forwarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='SpatHetero-class'>SpatHetero</h2><span id='topic+SpatHetero-class'></span>

<h3>Description</h3>

<p>SpatHetero
</p>


<h3>Slots</h3>


<dl>
<dt><code>hetero</code></dt><dd><p>A Heterogeneity Layer</p>
</dd>
<dt><code>matrix</code></dt><dd><p>SpatHetero_in data</p>
</dd>
<dt><code>rasters</code></dt><dd><p>A SpatRaster for Each Component</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
