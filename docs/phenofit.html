<!DOCTYPE html><html><head><title>Help for package phenofit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phenofit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_HeadTail'><p>Add one year data in the head and tail</p></a></li>
<li><a href='#brks2rfit'><p>get rough fitting</p></a></li>
<li><a href='#CA_NS6'><p>MOD13A1 EVI observations at flux site CA-NS6</p></a></li>
<li><a href='#check_GS_HeadTail'><p>Check growing season head and tail minimum values</p></a></li>
<li><a href='#check_input'><p>check_input</p></a></li>
<li><a href='#check_ylu'><p>check_ylu</p></a></li>
<li><a href='#curvefit'><p>Fine curve fitting</p></a></li>
<li><a href='#curvefit0'><p>curvefit0</p></a></li>
<li><a href='#curvefits'><p>Fine Curve fitting</p></a></li>
<li><a href='#curvefits_LocalModel'><p>curvefits by local model functions of TIMESAT</p></a></li>
<li><a href='#cutoff'><p>cutoff</p></a></li>
<li><a href='#cv_coef'><p>weighted CV</p></a></li>
<li><a href='#D'><p>D</p></a></li>
<li><a href='#f_goal'><p>Goal function of fine curve fitting methods</p></a></li>
<li><a href='#f_goal2'><p>objective function of double logistics</p></a></li>
<li><a href='#fFIT'><p>S3 class of fine curve fitting object.</p></a></li>
<li><a href='#fFITs'><p>S3 class of multiple fine curve fittings object.</p></a></li>
<li><a href='#find_season.peaks'><p>find_season</p></a></li>
<li><a href='#findpeaks'><p>findpeaks</p></a></li>
<li><a href='#FitDL'><p>Fine fitting</p></a></li>
<li><a href='#get_fitting'><p>getFittings</p></a></li>
<li><a href='#get_GOF'><p>get_GOF</p></a></li>
<li><a href='#get_param'><p>Get parameters from curve fitting result</p></a></li>
<li><a href='#get_pheno'><p>get_pheno</p></a></li>
<li><a href='#getRealDate'><p>getRealDate</p></a></li>
<li><a href='#GOF'><p>GOF</p></a></li>
<li><a href='#I_optim'><p>Interface of unified optimization functions.</p></a></li>
<li><a href='#init_lambda'><p>Initial lambda value of Whittaker smoother</p></a></li>
<li><a href='#init_param'><p>init_param</p></a></li>
<li><a href='#input_single'><p>input object with one growing season per year</p></a></li>
<li><a href='#kurtosis'><p>skewness and kurtosis</p></a></li>
<li><a href='#lambda_vcurve'><p>lambda_vcurve</p></a></li>
<li><a href='#logistic'><p>Double logistics in Rcpp</p></a></li>
<li><a href='#Logistic'><p>Fine fitting functions</p></a></li>
<li><a href='#melt_list'><p>melt_list</p></a></li>
<li><a href='#MOD13A1'><p>MOD13A1</p></a></li>
<li><a href='#movmean'><p>movmean</p></a></li>
<li><a href='#opt_FUN'><p>Unified optimization function</p></a></li>
<li><a href='#optim_pheno'><p>optim_pheno</p></a></li>
<li><a href='#PhenoDeriv'><p>Phenology extraction in Derivative method (DER)</p></a></li>
<li><a href='#phenofit'><p>phenofit</p></a></li>
<li><a href='#PhenoGu'><p>Phenology extraction in GU method (GU)</p></a></li>
<li><a href='#PhenoKl'><p>Phenology extraction in Inflection method (Zhang)</p></a></li>
<li><a href='#PhenoTrs'><p>Phenology extraction in Threshold method (TRS)</p></a></li>
<li><a href='#plot_curvefits'><p>plot_curvefits</p></a></li>
<li><a href='#plot_input'><p>Plot INPUT returned by check_input</p></a></li>
<li><a href='#plot_phenofit'><p>plot_phenofit</p></a></li>
<li><a href='#plot_season'><p>plot_season</p></a></li>
<li><a href='#process_phenofit'><p>Extract Vegetation Phenology at site scale</p></a></li>
<li><a href='#process_season'><p>divide_seasons</p></a></li>
<li><a href='#qc_levels'><p>qc level, color and shape</p></a></li>
<li><a href='#qc_sentinel2'><p>Initial weights for sentinel2 according to SCL band</p></a></li>
<li><a href='#qcFUN'><p>Initial weights according to qc</p></a></li>
<li><a href='#R2_sign'><p>Critical value of determined correlation</p></a></li>
<li><a href='#rcpp_season_filter'><p>season_filter</p></a></li>
<li><a href='#rcpp_wSG'><p>Weighted Savitzky-Golay written in RcppArmadillo</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#removeClosedExtreme'><p>rm too closed peaks or troughs</p></a></li>
<li><a href='#roughFit'><p>Rough fitting</p></a></li>
<li><a href='#season'><p>Growing season division</p></a></li>
<li><a href='#season_input'><p>Growing season division (unstable version)</p></a></li>
<li><a href='#season_mov'><p>Moving growing season division</p></a></li>
<li><a href='#set_options'><p>set and get phenofit option</p></a></li>
<li><a href='#smooth_wHANTS'><p>Weighted HANTS SMOOTH</p></a></li>
<li><a href='#smooth_wSG'><p>Weighted Savitzky-Golay</p></a></li>
<li><a href='#smooth_wWHIT'><p>Weigthed Whittaker Smoother</p></a></li>
<li><a href='#tidy_MOD13'><p>tidy_MOD13</p></a></li>
<li><a href='#tidy_pheno'><p>tidy_pheno</p></a></li>
<li><a href='#v_curve'><p>V-curve theory to optimize Whittaker parameter <code>lambda</code>.</p></a></li>
<li><a href='#whit2'><p>Weighted Whittaker smoothing with a second order finite difference penalty</p></a></li>
<li><a href='#wSELF'><p>Weight updating functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extract Remote Sensing Vegetation Phenology</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.9</td>
</tr>
<tr>
<td>Description:</td>
<td>
    The merits of 'TIMESAT' and 'phenopix' are adopted. Besides, a simple and 
    growing season dividing method and a practical snow elimination method 
    based on Whittaker were proposed. 7 curve fitting methods and 4 phenology 
    extraction methods were provided. Parameters boundary are considered for 
    every curve fitting methods according to their ecological meaning. 
    And 'optimx' is used to select best optimization method for different 
    curve fitting methods.
    Reference:
    Kong, D., (2020). R package: A state-of-the-art Vegetation Phenology extraction 
    package, phenofit version 0.3.1, &lt;<a href="https://doi.org/10.5281%2Fzenodo.5150204">doi:10.5281/zenodo.5150204</a>&gt;;
    Kong, D., Zhang, Y., Wang, D., Chen, J., &amp; Gu, X. (2020). Photoperiod Explains 
    the Asynchronization Between Vegetation Carbon Phenology and Vegetation Greenness 
    Phenology. Journal of Geophysical Research: Biogeosciences, 125(8), e2020JG005636. 
    &lt;<a href="https://doi.org/10.1029%2F2020JG005636">doi:10.1029/2020JG005636</a>&gt;;
    Kong, D., Zhang, Y., Gu, X., &amp; Wang, D. (2019). A robust method for reconstructing 
    global MODIS EVI time series on the Google Earth Engine. 
    ISPRS Journal of Photogrammetry and Remote Sensing, 155, 13–24;
    Zhang, Q., Kong, D., Shi, P., Singh, V.P., Sun, P., 2018. Vegetation phenology 
    on the Qinghai-Tibetan Plateau and its response to climate change (1982–2013). 
    Agric. For. Meteorol. 248, 408–417. &lt;<a href="https://doi.org/10.1016%2Fj.agrformet.2017.10.026">doi:10.1016/j.agrformet.2017.10.026</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, purrr, dplyr (&ge; 1.1.0), stringr, magrittr, lubridate,
data.table, zoo, gridExtra, ggplot2, optimx, ucminf, numDeriv,
methods, zeallot</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eco-hydro/phenofit">https://github.com/eco-hydro/phenofit</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eco-hydro/phenofit/issues">https://github.com/eco-hydro/phenofit/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 06:31:45 UTC; kong</td>
</tr>
<tr>
<td>Author:</td>
<td>Dongdong Kong [aut, cre],
  Mingzhong Xiao [aut],
  Yongqiang Zhang [aut],
  Xihui Gu [aut],
  Jianjian Cui [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dongdong Kong &lt;kongdd.sysu@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_HeadTail'>Add one year data in the head and tail</h2><span id='topic+add_HeadTail'></span>

<h3>Description</h3>

<p>Add the data of the year of <code>year_start - 1</code> to the head, add the data of the
year of <code>year_end - 1</code> to the tail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_HeadTail(d, south = FALSE, nptperyear, trs = 0.45)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_HeadTail_+3A_d">d</code></td>
<td>
<p>A data.table, should have <code>t</code> (compositing date) or <code>date</code>
(image date) column which are (<code>Date</code> variable).</p>
</td></tr>
<tr><td><code id="add_HeadTail_+3A_south">south</code></td>
<td>
<p>Boolean. In south hemisphere, growing year is 1 July to the
following year 31 June; In north hemisphere, growing year is 1 Jan to 31 Dec.</p>
</td></tr>
<tr><td><code id="add_HeadTail_+3A_nptperyear">nptperyear</code></td>
<td>
<p>Integer, number of images per year.</p>
</td></tr>
<tr><td><code id="add_HeadTail_+3A_trs">trs</code></td>
<td>
<p>If nmissing &lt; trs*nptperyear (little missing), this year is
include to extract phenology; if <code>FALSE</code>, this year is excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>Note</h3>

<p><code>date</code> is image date; <code>t</code> is compositing date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
data("CA_NS6"); d = CA_NS6

nptperyear = 23
dnew     &lt;- add_HeadTail(d, nptperyear = nptperyear) # add one year in head and tail
</code></pre>

<hr>
<h2 id='brks2rfit'>get rough fitting</h2><span id='topic+brks2rfit'></span>

<h3>Description</h3>

<p>get rough fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brks2rfit(brks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brks2rfit_+3A_brks">brks</code></td>
<td>
<p>returned by function <code><a href="#topic+season_mov">season_mov()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>data</code>:
</p>

<ul>
<li><p> t
</p>
</li>
<li><p> y
</p>
</li>
<li><p> QC_flag
</p>
</li></ul>

</li>
<li> <p><code>tout</code>:
</p>
</li>
<li> <p><code>zs</code>: list of iter1, ..., itern
</p>
</li>
<li> <p><code>ws</code>: list of iter1, ..., itern
</p>
</li></ul>


<hr>
<h2 id='CA_NS6'>MOD13A1 EVI observations at flux site CA-NS6</h2><span id='topic+CA_NS6'></span>

<h3>Description</h3>

<p>Variables in <code>CA-NS6</code>:
</p>

<ul>
<li> <p><code>site</code>: site name
</p>
</li>
<li> <p><code>y</code>: EVI
</p>
</li>
<li> <p><code>date</code>: date of image
</p>
</li>
<li> <p><code>t</code>: date of compositing image
</p>
</li>
<li> <p><code>w</code>: weights of data point
</p>
</li>
<li> <p><code>QC_flag</code>: QC flag of y, in the range of <code>c("snow", "cloud", "shadow", "aerosol", "marginal", "good")</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data('CA_NS6')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 161 rows and 6 columns.
</p>

<hr>
<h2 id='check_GS_HeadTail'>Check growing season head and tail minimum values</h2><span id='topic+check_GS_HeadTail'></span>

<h3>Description</h3>

<p>Check growing season head and tail minimum values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_GS_HeadTail(pos, ypred, minlen, A = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_GS_HeadTail_+3A_pos">pos</code></td>
<td>
<p>data.frame, with the columns of <code>pos</code>, <code>type</code>, and <code>val</code>.</p>
</td></tr>
<tr><td><code id="check_GS_HeadTail_+3A_minlen">minlen</code></td>
<td>
<p><code>nptperyear/3</code>, distance from peak point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>di
</p>

<hr>
<h2 id='check_input'>check_input</h2><span id='topic+check_input'></span>

<h3>Description</h3>

<p>Check input data, interpolate NA values in y, remove spike values, and set
weights for NA in y and w.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_input(
  t,
  y,
  w,
  QC_flag,
  nptperyear,
  south = FALSE,
  wmin = 0.2,
  wsnow = 0.8,
  ymin,
  missval,
  maxgap,
  alpha = 0.02,
  alpha_high = NULL,
  date_start = NULL,
  date_end = NULL,
  mask_spike = TRUE,
  na.rm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_input_+3A_t">t</code></td>
<td>
<p>Numeric vector, <code>Date</code> variable</p>
</td></tr>
<tr><td><code id="check_input_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="check_input_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="check_input_+3A_qc_flag">QC_flag</code></td>
<td>
<p>Factor (optional) returned by <code>qcFUN</code>, levels should be
in the range of <code>c("snow", "cloud", "shadow", "aerosol", "marginal", "good")</code>, others will be categoried into <code>others</code>. <code>QC_flag</code> is
used for visualization in <code><a href="#topic+get_pheno">get_pheno()</a></code> and <code><a href="#topic+plot_curvefits">plot_curvefits()</a></code>.</p>
</td></tr>
<tr><td><code id="check_input_+3A_nptperyear">nptperyear</code></td>
<td>
<p>Integer, number of images per year.</p>
</td></tr>
<tr><td><code id="check_input_+3A_south">south</code></td>
<td>
<p>Boolean. In south hemisphere, growing year is 1 July to the
following year 31 June; In north hemisphere, growing year is 1 Jan to 31 Dec.</p>
</td></tr>
<tr><td><code id="check_input_+3A_wmin">wmin</code></td>
<td>
<p>Double, minimum weight of bad points, which could be smaller
the weight of snow, ice and cloud.</p>
</td></tr>
<tr><td><code id="check_input_+3A_wsnow">wsnow</code></td>
<td>
<p>Doulbe. Reset the weight of snow points, after get <code>ylu</code>.
Snow flag is an important flag of ending of growing
season. Snow points is more valuable than marginal points. Hence, the weight
of snow should be great than that of <code>marginal</code>.</p>
</td></tr>
<tr><td><code id="check_input_+3A_ymin">ymin</code></td>
<td>
<p>If specified, <code>ylu[1]</code> is constrained greater than ymin. This
value is critical for bare, snow/ice land, where vegetation amplitude is quite
small. Generally, you can set ymin=0.08 for NDVI, ymin=0.05 for EVI,
ymin=0.5 gC m-2 s-1 for GPP.</p>
</td></tr>
<tr><td><code id="check_input_+3A_missval">missval</code></td>
<td>
<p>Double, which is used to replace NA values in y. If missing,
the default vlaue is <code>ylu[1]</code>.</p>
</td></tr>
<tr><td><code id="check_input_+3A_maxgap">maxgap</code></td>
<td>
<p>Integer, nptperyear/4 will be a suitable value. If continuous
missing value numbers less than maxgap, then interpolate those NA values by
zoo::na.approx; If false, then replace those NA values with a constant value
<code>ylu[1]</code>. <br />
Replacing NA values with a constant missing value (e.g. background value ymin)
is inappropriate for middle growing season points. Interpolating all values
by na.approx, it is unsuitable for large number continous missing segments,
e.g. in the start or end of growing season.</p>
</td></tr>
<tr><td><code id="check_input_+3A_alpha">alpha</code></td>
<td>
<p>Double, in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>, quantile prob of ylu_min.</p>
</td></tr>
<tr><td><code id="check_input_+3A_alpha_high">alpha_high</code></td>
<td>
<p>Double, <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>, quantile prob of <code>ylu_max</code>. If not
specified, <code>alpha_high=alpha</code>.</p>
</td></tr>
<tr><td><code id="check_input_+3A_date_start">date_start</code>, <code id="check_input_+3A_date_end">date_end</code></td>
<td>
<p>starting and ending date of the original vegetation
time-sereis (before <code>add_HeadTail</code>)</p>
</td></tr>
<tr><td><code id="check_input_+3A_mask_spike">mask_spike</code></td>
<td>
<p>Boolean. Whether to remove spike values?</p>
</td></tr>
<tr><td><code id="check_input_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, NA and spike values will be removed;
otherwise, NA and spike values will be interpolated by valid neighbours.</p>
</td></tr>
<tr><td><code id="check_input_+3A_...">...</code></td>
<td>
<p>Others will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object returned:
</p>

<ul>
<li> <p><code>t</code> : Numeric vector
</p>
</li>
<li> <p><code>y0</code>: Numeric vector, original vegetation time-series.
</p>
</li>
<li> <p><code>y</code> : Numeric vector, checked vegetation time-series, <code>NA</code> values are interpolated.
</p>
</li>
<li> <p><code>w</code> : Numeric vector
</p>
</li>
<li> <p><code>Tn</code>: Numeric vector
</p>
</li>
<li> <p><code>ylu</code>: = <code style="white-space: pre;">&#8288;[ymin, ymax]&#8288;</code>. <code>w_critical</code> is used to filter not too bad values.
</p>
<p>If the percentage good values (w=1) is greater than 30\
</p>
<p>The else, if the percentage of w &gt;= 0.5 points is greater than 10\
<code>w_critical</code>=0.5. In boreal regions, even if the percentage of w &gt;= 0.5
points is only 10\
</p>
<p>We can't rely on points with the wmin weights. Then,  <br />
<code>y_good = y[w &gt;= w_critical]</code>,  <br />
<code>ymin = pmax( quantile(y_good, alpha/2), 0)</code>  <br /> <code>ymax = max(y_good)</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("CA_NS6")
d = CA_NS6
# head(d)

nptperyear = 23
INPUT &lt;- check_input(d$t, d$y, d$w, QC_flag = d$QC_flag,
     nptperyear = nptperyear, south = FALSE, 
     maxgap = nptperyear/4, alpha = 0.02, wmin = 0.2)
plot_input(INPUT)
</code></pre>

<hr>
<h2 id='check_ylu'>check_ylu</h2><span id='topic+check_ylu'></span>

<h3>Description</h3>

<p>Curve fitting values are constrained in the range of <code>ylu</code>.
Only constrain trough value for a stable background value. But not for peak
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ylu(yfit, ylu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ylu_+3A_yfit">yfit</code></td>
<td>
<p>Numeric vector, curve fitting result</p>
</td></tr>
<tr><td><code id="check_ylu_+3A_ylu">ylu</code></td>
<td>
<p>limits of y value, <code style="white-space: pre;">&#8288;[ymin, ymax]&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>yfit, the numeric vector in the range of <code>ylu</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_ylu(1:10, c(2, 8))
</code></pre>

<hr>
<h2 id='curvefit'>Fine curve fitting</h2><span id='topic+curvefit'></span>

<h3>Description</h3>

<p>Curve fit vegetation index (VI) time-series of every growing season using
fine curve fitting methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curvefit(
  y,
  t = index(y),
  tout = t,
  methods = c("AG", "Beck", "Elmore", "Gu", "Klos", "Zhang"),
  w = NULL,
  ...,
  type = 1L,
  use.cpp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvefit_+3A_y">y</code></td>
<td>
<p>Vegetation time-series index, numeric vector</p>
</td></tr>
<tr><td><code id="curvefit_+3A_t">t</code></td>
<td>
<p>The corresponding doy of x</p>
</td></tr>
<tr><td><code id="curvefit_+3A_tout">tout</code></td>
<td>
<p>The output interpolated time.</p>
</td></tr>
<tr><td><code id="curvefit_+3A_methods">methods</code></td>
<td>
<p>Fine curve fitting methods, can be one or more of <code>c('AG', 'Beck', 'Elmore', 'Gu', 'Klos', 'Zhang')</code>.</p>
</td></tr>
<tr><td><code id="curvefit_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="curvefit_+3A_...">...</code></td>
<td>
<p>other parameters passed to curve fitting function.</p>
</td></tr>
<tr><td><code id="curvefit_+3A_type">type</code></td>
<td>
<p>integer, <code>1</code> or <code>-1</code>
</p>

<ul>
<li> <p><code>1</code>: trough-to-trough curve fitting
</p>
</li>
<li> <p><code>-1</code>: peak-to-peak curve fitting
</p>
</li></ul>
</td></tr>
<tr><td><code id="curvefit_+3A_use.cpp">use.cpp</code></td>
<td>
<p>(unstable, not used) boolean, whether to use c++ defined fine
fitting function? If <code>FALSE</code>, R version will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fFITs S3 object, see <code><a href="#topic+fFITs">fFITs()</a></code> for details.
</p>


<h3>Note</h3>

<p>'Klos' have too many parameters. It will be slow and not stable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fFITs">fFITs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
# simulate vegetation time-series
FUN = doubleLog.Beck
par = c(mn  = 0.1, mx  = 0.7, sos = 50, rsp = 0.1, eos = 250, rau = 0.1)
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y &lt;- FUN(par, t)

methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout = tout, methods)
</code></pre>

<hr>
<h2 id='curvefit0'>curvefit0</h2><span id='topic+curvefit0'></span>

<h3>Description</h3>

<p>curvefit0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curvefit0(
  y,
  t = index(y),
  tout = t,
  methods = c("AG", "Beck", "Elmore", "Gu", "Klos", "Zhang"),
  w = NULL,
  ...
)
</code></pre>

<hr>
<h2 id='curvefits'>Fine Curve fitting</h2><span id='topic+curvefits'></span>

<h3>Description</h3>

<p>Fine Curve fitting for INPUT time-series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curvefits(INPUT, brks, options = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvefits_+3A_input">INPUT</code></td>
<td>
<p>A list object with the elements of 't', 'y', 'w', 'Tn' (optional)
and 'ylu', returned by <code>check_input</code>.</p>
</td></tr>
<tr><td><code id="curvefits_+3A_brks">brks</code></td>
<td>
<p>A list object with the elements of 'fit' and 'dt', returned by
<code>season</code> or <code>season_mov</code>, which contains the growing season division information.</p>
</td></tr>
<tr><td><code id="curvefits_+3A_options">options</code></td>
<td>
<p>see section: options for fitting for details.</p>
</td></tr>
<tr><td><code id="curvefits_+3A_...">...</code></td>
<td>
<p>other parameters to <code><a href="#topic+curvefit">curvefit()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of phenofit fitting object.
</p>


<h3>options for fitting</h3>


<ul>
<li> <p><code>methods</code> (default <code style="white-space: pre;">&#8288;c('AG', 'Beck', 'Elmore', 'Zhang')``): Fine curve fitting methods, can be one or more of &#8288;</code>c('AG', 'Beck', 'Elmore', 'Zhang',
'Gu', 'Klos')&lsquo;. Note that &rsquo;Gu' and 'Klos' are very slow.
</p>
</li>
<li> <p><code>iters</code> (default 2): max iterations of fine fitting.
</p>
</li>
<li> <p><code>wFUN</code> (default <code>wTSM</code>): Character or function, weights updating function
of fine fitting function.
</p>
</li>
<li> <p><code>wmin</code> (default 0.1): min weights in the weights updating procedure.
</p>
</li>
<li> <p><code>use.rough</code> (default FALSE): Whether to use rough fitting smoothed
time-series as input? If <code>false</code>, smoothed VI by rough fitting will be used
for Phenological metrics extraction; If <code>true</code>, original input <code>y</code> will be
used (rough fitting is used to divide growing seasons and update weights.
</p>
</li>
<li> <p><code>use.y0</code> (default TRUE): boolean. whether to use original <code>y0</code> as the input
of <code>plot_input</code>, note that not for curve fitting. <code>y0</code> is the original
value before the process of <code>check_input</code>.
</p>
</li>
<li> <p><code>nextend</code> (default 2): Extend curve fitting window, until <code>nextend</code> good or
marginal points are found in the previous and subsequent growing season.
</p>
</li>
<li> <p><code>maxExtendMonth</code> (default 1): Search good or marginal good values in
previous and subsequent <code>maxExtendMonth</code> period.
</p>
</li>
<li> <p><code>minExtendMonth</code> (default 0.5): Extend period defined by <code>nextend</code> and
<code>maxExtendMonth</code>, should be no shorter than <code>minExtendMonth</code>. When all
points of the input time-series are good value, then the extending period
will be too short. In that situation, we can't make sure the connection
between different growing seasons is smoothing.
</p>
</li>
<li> <p><code>minPercValid</code>: (default 0, not use). If the percentage of good- and
marginal- quality points is less than <code>minPercValid</code>, curve fiting result is
set to <code>NA</code>.
</p>
</li>
<li> <p><code>minT</code>: (not use). If <code>Tn</code> not provided in <code>INPUT</code>, <code>minT</code> will
not be used. <code>minT</code> use night temperature Tn to define backgroud value
(days with <code>Tn &lt; minT</code> treated as ungrowing season).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+FitDL">FitDL()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CA_NS6")
d = CA_NS6

nptperyear &lt;- 23
INPUT &lt;- check_input(d$t, d$y, d$w, QC_flag = d$QC_flag,
     nptperyear = nptperyear, south = FALSE,
     maxgap = nptperyear/4, alpha = 0.02, wmin = 0.2)
# plot_input(INPUT)

# Rough fitting and growing season dividing
wFUN &lt;- "wTSM"
brks2 &lt;- season_mov(INPUT,
    options = list(
        rFUN = "smooth_wWHIT", wFUN = wFUN,
        r_min = 0.05, ypeak_min = 0.05,
        lambda = 10,
        verbose = FALSE
    ))
# plot_season(INPUT, brks2, d)
# Fine fitting
fits &lt;- curvefits(
    INPUT, brks2,
    options = list(
        methods = c("AG", "Beck", "Elmore", "Zhang"), #,"klos", "Gu"
        wFUN = wFUN,
        nextend = 2, maxExtendMonth = 2, minExtendMonth = 1, minPercValid = 0.2
    )
)

r_param = get_param(fits)
r_pheno = get_pheno(fits)
r_gof = get_GOF(fits)
d_fit = get_fitting(fits)

g &lt;- plot_curvefits(d_fit, brks2)
grid::grid.newpage(); grid::grid.draw(g)
</code></pre>

<hr>
<h2 id='curvefits_LocalModel'>curvefits by local model functions of TIMESAT</h2><span id='topic+curvefits_LocalModel'></span><span id='topic+merge_LocalModels'></span>

<h3>Description</h3>

<p>Local model functions <code>f_L(t)</code>, <code>f_C(t)</code> and <code>f_R(t)</code>
describe the VI variation in intervals around the left minima, the central
maxima and the right minima.
</p>
<p>Local model function are merged into global model function via <code><a href="#topic+merge_LocalModels">merge_LocalModels()</a></code>
and Per J\&quot;onsson et al. (2004; their Eq. 12),
where cut-off function sharply drop from 1 to 0 in small intervals around
<code>(t_L + t_C)/2</code> and <code>(t_C + t_R)/2</code>.
</p>
<p style="text-align: center;"><code class="reqn">
F(t)= \begin{cases}
\alpha(t) f_{L}(t)+[1-\alpha(t)] f_{C}(t), t_{L}&lt;t&lt;t_{C} \\ 
\beta(t) f_{C}(t)+[1-\beta(t)] f_{R}(t), t_{C}&lt;t&lt;t_{R}\end{cases}
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>curvefits_LocalModel(INPUT, brks, options = list(), ...)

merge_LocalModels(fits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvefits_LocalModel_+3A_input">INPUT</code></td>
<td>
<p>A list object with the elements of 't', 'y', 'w', 'Tn' (optional)
and 'ylu', returned by <code>check_input</code>.</p>
</td></tr>
<tr><td><code id="curvefits_LocalModel_+3A_brks">brks</code></td>
<td>
<p>A list object with the elements of 'fit' and 'dt', returned by
<code>season</code> or <code>season_mov</code>, which contains the growing season division information.</p>
</td></tr>
<tr><td><code id="curvefits_LocalModel_+3A_options">options</code></td>
<td>
<p>see section: options for fitting for details.</p>
</td></tr>
<tr><td><code id="curvefits_LocalModel_+3A_...">...</code></td>
<td>
<p>other parameters to <code><a href="#topic+curvefit">curvefit()</a></code></p>
</td></tr>
<tr><td><code id="curvefits_LocalModel_+3A_fits">fits</code></td>
<td>
<p>List objects returned by <code><a href="#topic+curvefits_LocalModel">curvefits_LocalModel()</a></code> (not <code><a href="#topic+curvefits">curvefits()</a></code>).</p>
</td></tr>
</table>


<h3>options for fitting</h3>


<ul>
<li> <p><code>methods</code> (default <code style="white-space: pre;">&#8288;c('AG', 'Beck', 'Elmore', 'Zhang')``): Fine curve fitting methods, can be one or more of &#8288;</code>c('AG', 'Beck', 'Elmore', 'Zhang',
'Gu', 'Klos')&lsquo;. Note that &rsquo;Gu' and 'Klos' are very slow.
</p>
</li>
<li> <p><code>iters</code> (default 2): max iterations of fine fitting.
</p>
</li>
<li> <p><code>wFUN</code> (default <code>wTSM</code>): Character or function, weights updating function
of fine fitting function.
</p>
</li>
<li> <p><code>wmin</code> (default 0.1): min weights in the weights updating procedure.
</p>
</li>
<li> <p><code>use.rough</code> (default FALSE): Whether to use rough fitting smoothed
time-series as input? If <code>false</code>, smoothed VI by rough fitting will be used
for Phenological metrics extraction; If <code>true</code>, original input <code>y</code> will be
used (rough fitting is used to divide growing seasons and update weights.
</p>
</li>
<li> <p><code>use.y0</code> (default TRUE): boolean. whether to use original <code>y0</code> as the input
of <code>plot_input</code>, note that not for curve fitting. <code>y0</code> is the original
value before the process of <code>check_input</code>.
</p>
</li>
<li> <p><code>nextend</code> (default 2): Extend curve fitting window, until <code>nextend</code> good or
marginal points are found in the previous and subsequent growing season.
</p>
</li>
<li> <p><code>maxExtendMonth</code> (default 1): Search good or marginal good values in
previous and subsequent <code>maxExtendMonth</code> period.
</p>
</li>
<li> <p><code>minExtendMonth</code> (default 0.5): Extend period defined by <code>nextend</code> and
<code>maxExtendMonth</code>, should be no shorter than <code>minExtendMonth</code>. When all
points of the input time-series are good value, then the extending period
will be too short. In that situation, we can't make sure the connection
between different growing seasons is smoothing.
</p>
</li>
<li> <p><code>minPercValid</code>: (default 0, not use). If the percentage of good- and
marginal- quality points is less than <code>minPercValid</code>, curve fiting result is
set to <code>NA</code>.
</p>
</li>
<li> <p><code>minT</code>: (not use). If <code>Tn</code> not provided in <code>INPUT</code>, <code>minT</code> will
not be used. <code>minT</code> use night temperature Tn to define backgroud value
(days with <code>Tn &lt; minT</code> treated as ungrowing season).
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> Per J\&quot;onsson, P., Eklundh, L., 2004. TIMESAT - A program for analyzing
time-series of satellite sensor data. Comput. Geosci. 30, 833-845.
<a href="https://doi.org/10.1016/j.cageo.2004.05.006">doi:10.1016/j.cageo.2004.05.006</a>.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+curvefits">curvefits()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phenofit)

data("CA_NS6")
d = CA_NS6

nptperyear &lt;- 23
INPUT &lt;- check_input(d$t, d$y, d$w, QC_flag = d$QC_flag,
     nptperyear = nptperyear, south = FALSE,
     maxgap = nptperyear/4, alpha = 0.02, wmin = 0.2)
# plot_input(INPUT)

# Rough fitting and growing season dividing
wFUN &lt;- "wTSM"
brks2 &lt;- season_mov(INPUT,
    options = list(
        rFUN = "smooth_wWHIT", wFUN = wFUN,
        r_min = 0.05, ypeak_min = 0.05,
        lambda = 10,
        verbose = FALSE
    ))
# plot_season(INPUT, brks2, d)

# Fine fitting
fits &lt;- curvefits_LocalModel(
    INPUT, brks2,
    options = list(
        methods = c("AG", "Beck", "Elmore", "Zhang", "Gu"), #,"klos", "Gu"
        wFUN = wFUN,
        nextend = 2, maxExtendMonth = 2, minExtendMonth = 1, minPercValid = 0.2
    ),
    constrain = TRUE
)
# merge local model function into global model function
fits_merged = merge_LocalModels(fits) 

## Visualization ---------------------------------------------------------------
l_fitting = map(fits %&gt;% guess_names, get_fitting) #%&gt;% melt_list("period")

d_merged = get_fitting(fits_merged[[2]]) %&gt;% cbind(type = "Merged")
d_raw = l_fitting[2:4] %&gt;% set_names(c("Left", "Central", "Right")) %&gt;%
    melt_list("type")
d_obs = d_raw[, .(t, y, QC_flag)] %&gt;% unique()
d_fit = rbind(d_merged, d_raw)[meth == "Zhang"]

levs = c("Left", "Central", "Right", "Merged")
levs_new = glue("({letters[1:4]}) {levs}") %&gt;% as.character()
d_fit$type %&lt;&gt;% factor(levs, levs_new)

p = ggplot(d_obs, aes(t, y)) +
    geom_point() +
    geom_line(data = d_fit, aes(t, ziter2, color = type)) +
    facet_wrap(~type) +
    labs(x = "Date", y = "EVI") +
    scale_x_date(date_labels = "%b %Y", expand = c(1, 1)*0.08) +
    theme_bw(base_size = 13) +
    theme(legend.position = "none",
          strip.text = element_text(size = 14))
p

## End(Not run)
</code></pre>

<hr>
<h2 id='cutoff'>cutoff</h2><span id='topic+cutoff'></span>

<h3>Description</h3>

<p>cutoff
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutoff(n1, n2, k = n1:n2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff_+3A_n1">n1</code>, <code id="cutoff_+3A_n2">n2</code></td>
<td>
<p>peak and trough (or trough and peak)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, in small intervals around <code>(tL + tC)/2</code> and <code>(tC+tR)/2</code>,
respectively, smoothly drop from 1 to 0.
</p>


<h3>References</h3>


<ol>
<li><p> Per J\&quot;onsson, P., Eklundh, L., 2004. TIMESAT - A program for analyzing
time-series of satellite sensor data. Comput. Geosci. 30, 833-845.
https://doi.org/10.1016/j.cageo.2004.05.006.
</p>
</li></ol>


<hr>
<h2 id='cv_coef'>weighted CV</h2><span id='topic+cv_coef'></span>

<h3>Description</h3>

<p>weighted CV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_coef(x, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_coef_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="cv_coef_+3A_w">w</code></td>
<td>
<p>weights of different point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named numeric vector, (mean, sd, cv).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
x = rnorm(100)
coefs &lt;- cv_coef(x)
</code></pre>

<hr>
<h2 id='D'>D</h2><span id='topic+D'></span><span id='topic+D1'></span><span id='topic+D2'></span><span id='topic+D1.fFIT'></span><span id='topic+D2.fFIT'></span><span id='topic+curvature'></span><span id='topic+curvature.fFIT'></span>

<h3>Description</h3>

<p>Get derivative of <code>phenofit</code> object.
<code>D1</code> first order derivative, <code>D2</code> second order derivative, n
<code>curvature</code> curvature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D1(fit, t = NULL, analytical = FALSE, smoothed.spline = FALSE, ...)

D2(fit, t = NULL, analytical = FALSE, smoothed.spline = FALSE, ...)

## S3 method for class 'fFIT'
D1(fit, t = NULL, analytical = FALSE, smoothed.spline = FALSE, ...)

## S3 method for class 'fFIT'
D2(fit, t = NULL, analytical = FALSE, smoothed.spline = FALSE, ...)

curvature(fit, t = NULL, analytical = FALSE, smoothed.spline = FALSE, ...)

## S3 method for class 'fFIT'
curvature(fit, t = NULL, analytical = FALSE, smoothed.spline = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_+3A_fit">fit</code></td>
<td>
<p>A curve fitting object returned by <code>curvefit</code>, with the object of:
</p>

<ul>
<li> <p><code>par</code>: parameters of curve fitting function
</p>
</li>
<li> <p><code>fun</code>: curve fitting function name, e.g., &quot;doubleLog_AG&quot;
</p>
</li>
<li> <p><code>zs</code>: predicted values, vector or data.frame
</p>
</li></ul>
</td></tr>
<tr><td><code id="D_+3A_analytical">analytical</code></td>
<td>
<p>If true, <code>numDeriv</code> package <code>grad</code> and <code>hess</code>
will be used; if false, <code>D1</code> and <code>D2</code> will be used.</p>
</td></tr>
<tr><td><code id="D_+3A_smoothed.spline">smoothed.spline</code></td>
<td>
<p>Whether apply <code>smooth.spline</code> first?</p>
</td></tr>
<tr><td><code id="D_+3A_...">...</code></td>
<td>
<p>Other parameters will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>fit$fun</code> has no gradient function or <code>smoothed.spline = TRUE</code>,
time-series smoothed by spline first, and get derivatives at last.
If <code>fit$fun</code> exists and <code>analytical = TRUE</code>, <code>smoothed.spline</code>
will be ignored.
</p>


<h3>Value</h3>


<ul>
<li><p> der1 First order derivative
</p>
</li>
<li><p> der2 Second order derivative
</p>
</li>
<li><p> k    Curvature
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># doubleLog.Beck
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
par  = c(mn  = 0.1, mx  = 0.7, sos = 50, rsp = 0.1, eos = 250, rau = 0.1)
y &lt;- doubleLog.Beck(par, t)

methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout, methods)
x  &lt;- fit$model$AG
d1 &lt;- D1(x)
d2 &lt;- D2(x)
d_k &lt;- curvature(x)
</code></pre>

<hr>
<h2 id='f_goal'>Goal function of fine curve fitting methods</h2><span id='topic+f_goal'></span>

<h3>Description</h3>

<p>Goal function of fine curve fitting methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_goal(par, fun, y, t, pred, w, ylu, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_goal_+3A_par">par</code></td>
<td>
<p>A vector of parameters</p>
</td></tr>
<tr><td><code id="f_goal_+3A_fun">fun</code></td>
<td>
<p>A curve fitting function, can be one of <code>doubleAG</code>,
<code>doubleLog.Beck</code>, <code>doubleLog.Elmore</code>, <code>doubleLog.Gu</code>,
<code>doubleLog.Klos</code>, <code>doubleLog.Zhang</code>, see <code><a href="#topic+Logistic">Logistic()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="f_goal_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="f_goal_+3A_t">t</code></td>
<td>
<p>Numeric vector, <code>Date</code> variable</p>
</td></tr>
<tr><td><code id="f_goal_+3A_pred">pred</code></td>
<td>
<p>Numeric Vector, predicted values</p>
</td></tr>
<tr><td><code id="f_goal_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="f_goal_+3A_ylu">ylu</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[ymin, ymax]&#8288;</code>, which is used to force <code>ypred</code> in the range of <code>ylu</code>.</p>
</td></tr>
<tr><td><code id="f_goal_+3A_...">...</code></td>
<td>
<p>others will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RMSE Root Mean Square Error of curve fitting values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)

par  = c( mn  = 0.1 , mx  = 0.7 , sos = 50 , rsp = 0.1 , eos = 250, rau = 0.1)
par0 = c( mn  = 0.15, mx  = 0.65, sos = 100, rsp = 0.12, eos = 200, rau = 0.12)

# simulate vegetation time-series
fFUN = doubleLog_Beck
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y    &lt;- fFUN(par, t)

f_goal(par0, fFUN, y, t)
</code></pre>

<hr>
<h2 id='f_goal2'>objective function of double logistics</h2><span id='topic+f_goal2'></span>

<h3>Description</h3>

<p>objective function of double logistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_goal2(par, fun, y, t, pred, w = NULL, ylu = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_goal2_+3A_par">par</code></td>
<td>
<p>A vector of parameters</p>
</td></tr>
<tr><td><code id="f_goal2_+3A_fun">fun</code></td>
<td>
<p>A curve fitting function, can be one of <code>doubleAG</code>,
<code>doubleLog.Beck</code>, <code>doubleLog.Elmore</code>, <code>doubleLog.Gu</code>,
<code>doubleLog.Klos</code>, <code>doubleLog.Zhang</code>, see <code><a href="#topic+Logistic">Logistic()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="f_goal2_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="f_goal2_+3A_t">t</code></td>
<td>
<p>Numeric vector, <code>Date</code> variable</p>
</td></tr>
<tr><td><code id="f_goal2_+3A_pred">pred</code></td>
<td>
<p>Numeric Vector, predicted values</p>
</td></tr>
<tr><td><code id="f_goal2_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="f_goal2_+3A_ylu">ylu</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[ymin, ymax]&#8288;</code>, which is used to force <code>ypred</code> in the range of <code>ylu</code>.</p>
</td></tr>
<tr><td><code id="f_goal2_+3A_...">...</code></td>
<td>
<p>others will be ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='fFIT'>S3 class of fine curve fitting object.</h2><span id='topic+fFIT'></span>

<h3>Description</h3>

<p><code>fFIT</code> is returned by <code><a href="#topic+optim_pheno">optim_pheno()</a></code>.
</p>


<h3>Format</h3>


<ul>
<li> <p><code>tout</code>: Corresponding doy of prediction
</p>
</li>
<li> <p><code>zs</code>: curve fitting values of every iteration
</p>
</li>
<li> <p><code>ws</code>: weight of every iteration
</p>
</li>
<li> <p><code>par</code>: Optimized parameter of fine curve fitting method
</p>
</li>
<li> <p><code>fun</code>: The name of fine curve fitting function.
</p>
</li></ul>


<hr>
<h2 id='fFITs'>S3 class of multiple fine curve fittings object.</h2><span id='topic+fFITs'></span><span id='topic+plot.fFITs'></span><span id='topic+plot.fFIT'></span>

<h3>Description</h3>

<p>plot curve fitting VI, gradient (first order difference D1), hessian (D2),
curvature (k) and the change rate of curvature(der.k)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fFITs'
plot(x, method, show.pheno = TRUE, ...)

## S3 method for class 'fFIT'
plot(x, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fFITs_+3A_x">x</code></td>
<td>
<p>Fine curve fitting object <code><a href="#topic+fFITs">fFITs()</a></code> returned by <code><a href="#topic+curvefit">curvefit()</a></code>.</p>
</td></tr>
<tr><td><code id="fFITs_+3A_method">method</code></td>
<td>
<p>Which fine curve fitting method to be extracted?</p>
</td></tr>
<tr><td><code id="fFITs_+3A_show.pheno">show.pheno</code></td>
<td>
<p>whether to plot phenological metrics.</p>
</td></tr>
<tr><td><code id="fFITs_+3A_...">...</code></td>
<td>
<p>other parameters to <code><a href="#topic+curvature">curvature()</a></code>.</p>
</td></tr>
<tr><td><code id="fFITs_+3A_data">data</code></td>
<td>
<p>A data.frame with the columns of <code>c('t', 'y')</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+curvature">curvature()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
# simulate vegetation time-series
fFUN = doubleLog.Beck
par  = c( mn  = 0.1 , mx  = 0.7 , sos = 50 , rsp = 0.1 , eos = 250, rau = 0.1)

t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y &lt;- fFUN(par, t)

methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout, methods)

# plot
plot(fit)
</code></pre>

<hr>
<h2 id='find_season.peaks'>find_season</h2><span id='topic+find_season.peaks'></span><span id='topic+find_season.default'></span>

<h3>Description</h3>

<p>find_season
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_season.peaks(rfit, info_peak, options = list(), ...)

find_season.default(
  ypred,
  t = seq_along(ypred),
  nptperyear = NULL,
  south = NULL,
  options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_season.peaks_+3A_rfit">rfit</code></td>
<td>
<p>data.frame with the columns of t and <code>ziter...</code>, the first column
should be <code>t</code>, and the last should be <code>ziter...</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='findpeaks'>findpeaks</h2><span id='topic+findpeaks'></span>

<h3>Description</h3>

<p>Find peaks (maxima) in a time series. This function is modified from
<code>pracma::findpeaks</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findpeaks(
  x,
  nups = 1,
  ndowns = nups,
  zero = "0",
  peakpat = NULL,
  minpeakheight = -Inf,
  minpeakdistance = 1,
  h_min = 0,
  h_max = 0,
  npeaks = 0,
  sortstr = FALSE,
  include_gregexpr = FALSE,
  IsPlot = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findpeaks_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_nups">nups</code></td>
<td>
<p>minimum number of increasing steps before a peak is reached</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_ndowns">ndowns</code></td>
<td>
<p>minimum number of decreasing steps after the peak</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_zero">zero</code></td>
<td>
<p>can be <code>+</code>, <code>-</code>, or <code>0</code>; how to interprete succeeding steps
of the same value: increasing, decreasing, or special</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_peakpat">peakpat</code></td>
<td>
<p>define a peak as a regular pattern, such as the default
pattern <code style="white-space: pre;">&#8288;[+]{1,}[-]{1,}&#8288;</code>; if a pattern is provided, the parameters
<code>nups</code> and <code>ndowns</code> are not taken into account</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_minpeakheight">minpeakheight</code></td>
<td>
<p>The minimum (absolute) height a peak has to have
to be recognized as such</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_minpeakdistance">minpeakdistance</code></td>
<td>
<p>The minimum distance (in indices) peaks have to have
to be counted. If the distance of two maximum extreme value less than
<code>minpeakdistance</code>, only the real maximum value will be left.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_h_min">h_min</code></td>
<td>
<p><code>h</code> is defined as the difference of peak value to the
adjacent left and right trough value (<code>h_left</code> and <code>h_right</code> respectively).
The real peaks should follow <code>min(h_left, h_right) &gt;= h_min</code>.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_h_max">h_max</code></td>
<td>
<p>Similar as <code>h_min</code>, the real peaks should follow
<code>max(h_left, h_right) &gt;= h_min</code>.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_npeaks">npeaks</code></td>
<td>
<p>the number of peaks to return. If <code>sortstr</code> = true, the
largest npeaks maximum values will be returned; If <code>sortstr</code> = false,
just the first npeaks are returned in the order of index.</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_sortstr">sortstr</code></td>
<td>
<p>Boolean, Should the peaks be returned sorted in decreasing oreder of
their maximum value?</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_include_gregexpr">include_gregexpr</code></td>
<td>
<p>Boolean (default <code>FALSE</code>), whether to include the
matched <code>gregexpr</code>?</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_isplot">IsPlot</code></td>
<td>
<p>Boolean, whether to plot?</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In versions before v0.3.4, <code>findpeaks(c(1, 2, 3, 4, 4, 3, 1))</code> failed to detect
peaks when a flat pattern exit in the middle.
</p>
<p>From version v0.3.4, the peak pattern was changed from <code style="white-space: pre;">&#8288;[+]{%d,}[-]{%d,}&#8288;</code> to
<code style="white-space: pre;">&#8288;[+]{%d,}[0]{0,}[-]{%d,}&#8288;</code>. The latter can escape the flat part successfully.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0, 1, len = 1024)
pos &lt;- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
hgt &lt;- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
wdt &lt;- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
pSignal &lt;- numeric(length(x))
for (i in seq(along=pos)) {
    pSignal &lt;- pSignal + hgt[i]/(1 + abs((x - pos[i])/wdt[i]))^4
}

plot(pSignal, type="l", col="navy"); grid()
x &lt;- findpeaks(pSignal, npeaks=3, h_min=4, sortstr=TRUE)
points(val~pos, x$X, pch=20, col="maroon")

</code></pre>

<hr>
<h2 id='FitDL'>Fine fitting</h2><span id='topic+FitDL'></span><span id='topic+FitDL.Zhang'></span><span id='topic+FitDL.AG'></span><span id='topic+FitDL.AG2'></span><span id='topic+FitDL.Beck'></span><span id='topic+FitDL.Elmore'></span><span id='topic+FitDL.Gu'></span><span id='topic+FitDL.Klos'></span>

<h3>Description</h3>

<p>Fine curve fitting function is used to fit vegetation
time-series in every growing season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitDL.Zhang(y, t = index(y), tout = t, method = "nlm", w, type = 1L, ...)

FitDL.AG(y, t = index(y), tout = t, method = "nlminb", w, type = 1L, ...)

FitDL.AG2(y, t = index(y), tout = t, method = "nlminb", w, type = 1L, ...)

FitDL.Beck(y, t = index(y), tout = t, method = "nlminb", w, type = 1L, ...)

FitDL.Elmore(y, t = index(y), tout = t, method = "nlminb", w, type = 1L, ...)

FitDL.Gu(y, t = index(y), tout = t, method = "nlminb", w, type = 1L, ...)

FitDL.Klos(y, t = index(y), tout = t, method = "BFGS", w, type = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitDL_+3A_y">y</code></td>
<td>
<p>input vegetation index time-series.</p>
</td></tr>
<tr><td><code id="FitDL_+3A_t">t</code></td>
<td>
<p>the corresponding doy(day of year) of y.</p>
</td></tr>
<tr><td><code id="FitDL_+3A_tout">tout</code></td>
<td>
<p>the time of output curve fitting time-series.</p>
</td></tr>
<tr><td><code id="FitDL_+3A_method">method</code></td>
<td>
<p>method passed to <code>optimx</code> or <code>optim</code> function.</p>
</td></tr>
<tr><td><code id="FitDL_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="FitDL_+3A_type">type</code></td>
<td>
<p>integer, <code>1</code> or <code>-1</code>
</p>

<ul>
<li> <p><code>1</code>: trough-to-trough curve fitting
</p>
</li>
<li> <p><code>-1</code>: peak-to-peak curve fitting
</p>
</li></ul>
</td></tr>
<tr><td><code id="FitDL_+3A_...">...</code></td>
<td>
<p>other paraters passed to <code><a href="#topic+optim_pheno">optim_pheno()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>tout</code>: The time of output curve fitting time-series.
</p>
</li>
<li> <p><code>zs</code>  : Smoothed vegetation time-series of every iteration.
</p>
</li>
<li> <p><code>ws</code>  : Weights of every iteration.
</p>
</li>
<li> <p><code>par</code> : Final optimized parameter of fine fitting.
</p>
</li>
<li> <p><code>fun</code> : The name of fine fitting.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> Beck, P.S.A., Atzberger, C., Hogda, K.A., Johansen, B., Skidmore, A.K.,
2006. Improved monitoring of vegetation dynamics at very high latitudes:
A new method using MODIS NDVI. Remote Sens. Environ.
https://doi.org/10.1016/j.rse.2005.10.021.
</p>
</li>
<li><p> Elmore, A.J., Guinn, S.M., Minsley, B.J., Richardson, A.D., 2012.
Landscape controls on the timing of spring, autumn, and growing season
length in mid-Atlantic forests. Glob. Chang. Biol. 18, 656-674.
https://doi.org/10.1111/j.1365-2486.2011.02521.x. <br />
</p>
</li>
<li><p> Gu, L., Post, W.M., Baldocchi, D.D., Black, TRUE.A., Suyker, A.E., Verma,
S.B., Vesala, TRUE., Wofsy, S.C., 2009. Characterizing the Seasonal Dynamics
of Plant Community Photosynthesis Across a Range of Vegetation Types,
in: Noormets, A. (Ed.), Phenology of Ecosystem Processes: Applications
in Global Change Research. Springer New York, New York, NY, pp. 35-58.
https://doi.org/10.1007/978-1-4419-0026-5_2. <br />
</p>
</li>
<li><p> https://github.com/cran/phenopix/blob/master/R/FitDoubleLogGu.R
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># simulate vegetation time-series
t    &lt;- seq(1, 365, 8)
par  &lt;- c(mn = 0.1, mx = 0.7, sos = 50, rsp = 0.1, eos = 250, rau = 0.1)
y    &lt;- doubleLog.Beck(par, t)
data &lt;- data.frame(t, y)
# methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang")
tout &lt;- seq(1, 365, 1)
r &lt;- FitDL.Elmore(y, t, tout)

plot(r, data)
get_GOF(r, data)
get_param(r)
</code></pre>

<hr>
<h2 id='get_fitting'>getFittings</h2><span id='topic+get_fitting'></span><span id='topic+get_fitting.list'></span><span id='topic+get_fitting.fFITs'></span>

<h3>Description</h3>

<p>Get curve fitting data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fitting(x)

## S3 method for class 'list'
get_fitting(x)

## S3 method for class 'fFITs'
get_fitting(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fitting_+3A_x">x</code></td>
<td>
<p><code>fFITs</code> object returned by <code><a href="#topic+curvefit">curvefit()</a></code>, or list of <code>fFITs</code> objects</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
# simulate vegetation time-series
FUN = doubleLog.Beck
par  = c( mn  = 0.1, mx  = 0.7, sos = 50, rsp = 0.1, eos = 250, rau = 0.1)
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y &lt;- FUN(par, t)
methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout, methods) # `fFITs` (fine-fitting) object 
fits &lt;- list(`2001` = fit, `2002` = fit) # multiple years

l_param   &lt;- get_param(fits)
d_GOF     &lt;- get_GOF(fits)
d_fitting &lt;- get_fitting(fits)
l_pheno   &lt;- get_pheno(fits, "AG", IsPlot=TRUE)
</code></pre>

<hr>
<h2 id='get_GOF'>get_GOF</h2><span id='topic+get_GOF'></span><span id='topic+get_GOF.list'></span><span id='topic+get_GOF.fFITs'></span><span id='topic+get_GOF.fFIT'></span>

<h3>Description</h3>

<p>Goodness-of-fitting (GOF) of fine curve fitting results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_GOF(x, ...)

## S3 method for class 'list'
get_GOF(x, ...)

## S3 method for class 'fFITs'
get_GOF(x, ...)

## S3 method for class 'fFIT'
get_GOF(x, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_GOF_+3A_x">x</code></td>
<td>
<p><code>fFITs</code> object returned by <code><a href="#topic+curvefit">curvefit()</a></code>, or list of <code>fFITs</code> objects</p>
</td></tr>
<tr><td><code id="get_GOF_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="get_GOF_+3A_data">data</code></td>
<td>
<p>A data.frame with the columns of <code>c('t', 'y')</code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>meth</code>: The name of fine curve fitting method
</p>
</li>
<li> <p><code>RMSE</code>: Root Mean Square Error
</p>
</li>
<li> <p><code>NSE</code> : Nash-Sutcliffe model efficiency coefficient
</p>
</li>
<li> <p><code>R</code>   : Pearson-Correlation
</p>
</li>
<li> <p><code>R2</code>  : determined coefficient
</p>
</li>
<li> <p><code>pvalue</code>: pvalue of <code>R</code>
</p>
</li>
<li> <p><code>n</code>   : The number of observations
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> https://en.wikipedia.org/wiki/Nash-Sutcliffe_model_efficiency_coefficient <br />
</p>
</li>
<li><p> https://en.wikipedia.org/wiki/Pearson_correlation_coefficient
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+curvefit">curvefit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
# simulate vegetation time-series
FUN = doubleLog.Beck
par  = c( mn  = 0.1, mx  = 0.7, sos = 50, rsp = 0.1, eos = 250, rau = 0.1)
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y &lt;- FUN(par, t)
methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout, methods) # `fFITs` (fine-fitting) object 
fits &lt;- list(`2001` = fit, `2002` = fit) # multiple years

l_param   &lt;- get_param(fits)
d_GOF     &lt;- get_GOF(fits)
d_fitting &lt;- get_fitting(fits)
l_pheno   &lt;- get_pheno(fits, "AG", IsPlot=TRUE)
</code></pre>

<hr>
<h2 id='get_param'>Get parameters from curve fitting result</h2><span id='topic+get_param'></span><span id='topic+get_param.list'></span><span id='topic+get_param.fFITs'></span><span id='topic+get_param.fFIT'></span>

<h3>Description</h3>

<p>Get parameters from curve fitting result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_param(x)

## S3 method for class 'list'
get_param(x)

## S3 method for class 'fFITs'
get_param(x)

## S3 method for class 'fFIT'
get_param(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_param_+3A_x">x</code></td>
<td>
<p><code>fFITs</code> object returned by <code><a href="#topic+curvefit">curvefit()</a></code>, or list of <code>fFITs</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>tibble</code> with the length being equal to the number of methods.
Each line of <code>tibble</code> cotains the corresponding parameters of each growing
season.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
# simulate vegetation time-series
FUN = doubleLog.Beck
par  = c( mn  = 0.1, mx  = 0.7, sos = 50, rsp = 0.1, eos = 250, rau = 0.1)
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y &lt;- FUN(par, t)
methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout, methods) # `fFITs` (fine-fitting) object 
fits &lt;- list(`2001` = fit, `2002` = fit) # multiple years

l_param   &lt;- get_param(fits)
d_GOF     &lt;- get_GOF(fits)
d_fitting &lt;- get_fitting(fits)
l_pheno   &lt;- get_pheno(fits, "AG", IsPlot=TRUE)
</code></pre>

<hr>
<h2 id='get_pheno'>get_pheno</h2><span id='topic+get_pheno'></span><span id='topic+get_pheno.rfit'></span><span id='topic+get_pheno.list'></span><span id='topic+get_pheno.fFITs'></span>

<h3>Description</h3>

<p>Get yearly vegetation phenological metrics of a curve fitting method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pheno(x, ...)

## S3 method for class 'rfit'
get_pheno(x, TRS = c(0.2, 0.5), asymmetric = TRUE, ...)

## S3 method for class 'list'
get_pheno(
  x,
  method,
  TRS = c(0.2, 0.5, 0.6),
  analytical = FALSE,
  smoothed.spline = FALSE,
  IsPlot = FALSE,
  show.title = TRUE,
  ...
)

## S3 method for class 'fFITs'
get_pheno(
  x,
  method,
  TRS = c(0.2, 0.5),
  analytical = FALSE,
  smoothed.spline = FALSE,
  IsPlot = FALSE,
  title.left = "",
  show.PhenoName = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pheno_+3A_x">x</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>rfit</code> (rought fitting object), returned by <code><a href="#topic+brks2rfit">brks2rfit()</a></code>.
</p>
</li>
<li> <p><code>fFITs</code> (fine fitting object), return by multiple curve fitting methods by <code><a href="#topic+curvefit">curvefit()</a></code> for
a growing season.
</p>
</li>
<li><p> list of <code><a href="#topic+fFITs">fFITs()</a></code> object, for multiple growing seasons.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_pheno_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_trs">TRS</code></td>
<td>
<p>Threshold for <code>PhenoTrs</code>.</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_asymmetric">asymmetric</code></td>
<td>
<p>If true, background value in spring season and autumn season
is regarded as different.</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_method">method</code></td>
<td>
<p>Which fine curve fitting method to be extracted?</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_analytical">analytical</code></td>
<td>
<p>If true, <code>numDeriv</code> package <code>grad</code> and <code>hess</code>
will be used; if false, <code>D1</code> and <code>D2</code> will be used.</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_smoothed.spline">smoothed.spline</code></td>
<td>
<p>Whether apply <code>smooth.spline</code> first?</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_isplot">IsPlot</code></td>
<td>
<p>Boolean. Whether to plot figure?</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_show.title">show.title</code></td>
<td>
<p>Whether to show the name of fine curve fitting method
in top title?</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_title.left">title.left</code></td>
<td>
<p>String of growing season flag.</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_show.phenoname">show.PhenoName</code></td>
<td>
<p>Whether to show phenological methods names in the top panel?</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_ffits">fFITs</code></td>
<td>
<p><code>fFITs</code> object returned by <code><a href="#topic+curvefits">curvefits()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of every year phenology metrics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
# simulate vegetation time-series
FUN = doubleLog.Beck
par  = c( mn  = 0.1, mx  = 0.7, sos = 50, rsp = 0.1, eos = 250, rau = 0.1)
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y &lt;- FUN(par, t)
methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout, methods) # `fFITs` (fine-fitting) object 
fits &lt;- list(`2001` = fit, `2002` = fit) # multiple years

l_param   &lt;- get_param(fits)
d_GOF     &lt;- get_GOF(fits)
d_fitting &lt;- get_fitting(fits)
l_pheno   &lt;- get_pheno(fits, "AG", IsPlot=TRUE)
</code></pre>

<hr>
<h2 id='getRealDate'>getRealDate</h2><span id='topic+getRealDate'></span>

<h3>Description</h3>

<p>convert MODIS <code>DayOfYear</code> to the exact compositing date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRealDate(date, DayOfYear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRealDate_+3A_date">date</code></td>
<td>
<p>Date vector, the first day of the 16-day composite period.</p>
</td></tr>
<tr><td><code id="getRealDate_+3A_dayofyear">DayOfYear</code></td>
<td>
<p>Numeric vector, exact composite day of year.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with a new column <code>t</code>, which is the exact compositing date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
data("MOD13A1")

df  &lt;- MOD13A1$dt
df$t &lt;- getRealDate(df$date, df$DayOfYear)
</code></pre>

<hr>
<h2 id='GOF'>GOF</h2><span id='topic+GOF'></span>

<h3>Description</h3>

<p>Good of fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GOF(Y_obs, Y_sim, w, include.r = TRUE, include.cv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GOF_+3A_y_obs">Y_obs</code></td>
<td>
<p>Numeric vector, observations</p>
</td></tr>
<tr><td><code id="GOF_+3A_y_sim">Y_sim</code></td>
<td>
<p>Numeric vector, corresponding simulated values</p>
</td></tr>
<tr><td><code id="GOF_+3A_w">w</code></td>
<td>
<p>Numeric vector, weights of every points. If w included, when
calculating mean, Bias, MAE, RMSE and NSE, w will be taken into considered.</p>
</td></tr>
<tr><td><code id="GOF_+3A_include.r">include.r</code></td>
<td>
<p>If true, r and R2 will be included.</p>
</td></tr>
<tr><td><code id="GOF_+3A_include.cv">include.cv</code></td>
<td>
<p>If true, cv will be included.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>RMSE</code> root mean square error
</p>
</li>
<li> <p><code>NSE</code> NASH coefficient
</p>
</li>
<li> <p><code>MAE</code> mean absolute error
</p>
</li>
<li> <p><code>AI</code> Agreement index (only good points (w == 1)) participate to
calculate. See details in Zhang et al., (2015).
</p>
</li>
<li> <p><code>Bias</code> bias
</p>
</li>
<li> <p><code>Bias_perc</code> bias percentage
</p>
</li>
<li> <p><code>n_sim</code> number of valid obs
</p>
</li>
<li> <p><code>cv</code> Coefficient of variation
</p>
</li>
<li> <p><code>R2</code> correlation of determination
</p>
</li>
<li> <p><code>R</code> pearson correlation
</p>
</li>
<li> <p><code>pvalue</code> pvalue of <code>R</code>
</p>
</li></ul>



<h3>References</h3>

<p>Zhang Xiaoyang (2015), http://dx.doi.org/10.1016/j.rse.2014.10.012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y_obs = rnorm(100)
Y_sim = Y_obs + rnorm(100)/4
GOF(Y_obs, Y_sim)

</code></pre>

<hr>
<h2 id='I_optim'>Interface of unified optimization functions.</h2><span id='topic+I_optim'></span><span id='topic+I_optimx'></span>

<h3>Description</h3>

<p><span class="pkg">optimx</span> speed is not satisfied. So <code>I_optim</code> is present.
</p>

<ul>
<li> <p><code>I_optim</code>: Interface of unified optimization functions.
</p>
</li>
<li> <p><code>I_optimx</code>: deprecated, which is about 10 times slower than <code>I_optim</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>I_optim(prior, FUN, y, t, method = "BFGS", ..., use.cpp = FALSE)

I_optimx(prior, FUN, y, t, method, verbose = FALSE, ..., use.cpp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="I_optim_+3A_prior">prior</code></td>
<td>
<p>A vector of initial values for the parameters for which optimal
values are to be found. <code>prior</code> is suggested giving a column name.</p>
</td></tr>
<tr><td><code id="I_optim_+3A_fun">FUN</code></td>
<td>
<p>Fine curve fitting function for goal function <code><a href="#topic+f_goal">f_goal()</a></code>.</p>
</td></tr>
<tr><td><code id="I_optim_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="I_optim_+3A_t">t</code></td>
<td>
<p>Numeric vector, <code>Date</code> variable</p>
</td></tr>
<tr><td><code id="I_optim_+3A_method">method</code></td>
<td>
<p><code>method</code> can be some of <code style="white-space: pre;">&#8288;'BFGS','CG','Nelder-Mead', 'L-BFGS-B', 'nlm', 'nlminb', 'ucminf'&#8288;</code>. <br />
For <code>I_optimx</code>, other methods are also supported,
e.g. <code style="white-space: pre;">&#8288;'spg','Rcgmin','Rvmmin', 'newuoa','bobyqa','nmkb','hjkb'&#8288;</code>.</p>
</td></tr>
<tr><td><code id="I_optim_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="#topic+I_optim">I_optim()</a></code> or <code><a href="#topic+I_optimx">I_optimx()</a></code>.</p>
</td></tr>
<tr><td><code id="I_optim_+3A_use.cpp">use.cpp</code></td>
<td>
<p>(unstable, not used) boolean, whether to use c++ defined fine
fitting function? If <code>FALSE</code>, R version will be used.</p>
</td></tr>
<tr><td><code id="I_optim_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, all optimization methods in
<code><a href="optimx.html#topic+optimx">optimx::optimx()</a></code> are used, and print optimization information
of all methods.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>convcode</code>: An integer code. 0 indicates successful convergence.
Various methods may or may not return sufficient information to allow all
the codes to be specified. An incomplete list of codes includes
</p>

<ul>
<li> <p><code>1</code>: indicates that the iteration limit <code>maxit</code> had been reached.
</p>
</li>
<li> <p><code>20</code>: indicates that the initial set of parameters is inadmissible,
that is, that the function cannot be computed or returns an infinite,
NULL, or NA value.
</p>
</li>
<li> <p><code>21</code>: indicates that an intermediate set of parameters is inadmissible.
</p>
</li>
<li> <p><code>10</code>: indicates degeneracy of the Nelder&ndash;Mead simplex.
</p>
</li>
<li> <p><code>51</code>: indicates a warning from the <code>"L-BFGS-B"</code> method; see component
<code>message</code> for further details.
</p>
</li>
<li> <p><code>52</code>: indicates an error from the <code>"L-BFGS-B"</code> method; see component
<code>message</code> for further details.
</p>
</li>
<li> <p><code>9999</code>: error
</p>
</li></ul>

</li>
<li> <p><code>value</code>: The value of fn corresponding to par
</p>
</li>
<li> <p><code>par</code>: The best parameter found
</p>
</li>
<li> <p><code>nitns</code>: the number of iterations
</p>
</li>
<li> <p><code>fevals</code>: The number of calls to <code>objective</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">stats::optim()</a></code>, <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>,
<code><a href="stats.html#topic+nlm">stats::nlm()</a></code>, <code><a href="optimx.html#topic+optimx">optimx::optimx()</a></code>,
<code><a href="ucminf.html#topic+ucminf">ucminf::ucminf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate vegetation time-series
FUN  = doubleLog_Beck
par  = c( mn  = 0.1 , mx  = 0.7 , sos = 50 , rsp = 0.1 , eos = 250, rau = 0.1)
par0 = c( mn  = 0.15, mx  = 0.65, sos = 100, rsp = 0.12, eos = 200, rau = 0.12)

t &lt;- seq(1, 365, 8)
y &lt;- FUN(par, t)

methods = c("BFGS", "ucminf", "nlm", "nlminb")
opt1 &lt;- I_optim (par0, FUN, y, t, methods)
opt2 &lt;- I_optimx(par0, FUN, y, t, methods)

# \dontrun{
# microbenchmark::microbenchmark(
#     opt1 = I_optim (par0, FUN, y, t, methods),
#     opt2 = I_optimx(par0, FUN, y, t, methods),
#     times = 2
# )
# }
</code></pre>

<hr>
<h2 id='init_lambda'>Initial lambda value of Whittaker smoother</h2><span id='topic+init_lambda'></span>

<h3>Description</h3>

<p>This function is only suitable for 16-day EVI time-series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_lambda(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_lambda_+3A_y">y</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
data("MOD13A1")

dt &lt;- tidy_MOD13(MOD13A1$dt)
st &lt;- MOD13A1$st

sitename &lt;- dt$site[1]
d      &lt;- dt[site == sitename, ] # get the first site data
lambda &lt;- init_lambda(d$y)
</code></pre>

<hr>
<h2 id='init_param'>init_param</h2><span id='topic+init_param'></span><span id='topic+init_Zhang'></span><span id='topic+init_AG'></span><span id='topic+init_AG2'></span><span id='topic+init_Beck'></span><span id='topic+init_Elmore'></span><span id='topic+init_Gu'></span><span id='topic+init_Klos'></span>

<h3>Description</h3>

<p>Initialize parameters of double logistic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_param(y, t, w, type = 1L)

init_Zhang(e, type = 1L, ...)

init_AG(e, type = 1L, ...)

init_AG2(e, type = 1L, ...)

init_Beck(e, type = 1L, ...)

init_Elmore(e, type = 1L, ...)

init_Gu(e, type = 1L, ...)

init_Klos(e, type = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_param_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="init_param_+3A_t">t</code></td>
<td>
<p>Numeric vector, <code>Date</code> variable</p>
</td></tr>
<tr><td><code id="init_param_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="init_param_+3A_type">type</code></td>
<td>
<p>integer, <code>1</code> or <code>-1</code>
</p>

<ul>
<li> <p><code>1</code>: trough-to-trough curve fitting
</p>
</li>
<li> <p><code>-1</code>: peak-to-peak curve fitting
</p>
</li></ul>
</td></tr>
<tr><td><code id="init_param_+3A_e">e</code></td>
<td>
<p>The object returned by <code><a href="#topic+init_param">init_param()</a></code></p>
</td></tr>
<tr><td><code id="init_param_+3A_...">...</code></td>
<td>
<p>Others will be ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
# simulate vegetation time-series
fFUN = doubleLog.Beck
par  = c(
    mn  = 0.1,
    mx  = 0.7,
    sos = 50,
    rsp = 0.1,
    eos = 250,
    rau = 0.1)
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y &lt;- fFUN(par, t)

l_param &lt;- init_param(y, t)
</code></pre>

<hr>
<h2 id='input_single'>input object with one growing season per year</h2><span id='topic+input_single'></span>

<h3>Description</h3>

<p>Variables in <code>input_single</code>:
</p>

<ul>
<li> <p><code>t</code>: date of compositing image
</p>
</li>
<li> <p><code>y</code>: EVI
</p>
</li>
<li> <p><code>w</code>: weights of data point
</p>
</li>
<li> <p><code>ylu</code>: lower and upper boundary
</p>
</li>
<li> <p><code>nptperyear</code>: points per year
</p>
</li>
<li> <p><code>south</code>: boolean, whether in south Hemisphere?
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data('input_single')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>

<hr>
<h2 id='kurtosis'>skewness and kurtosis</h2><span id='topic+kurtosis'></span><span id='topic+skewness'></span>

<h3>Description</h3>

<p>Inherit from package <code>e1071</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kurtosis(x, na.rm = FALSE, type = 3)

skewness(x, na.rm = FALSE, type = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kurtosis_+3A_x">x</code></td>
<td>
<p>a numeric vector containing the values whose skewness is to be
computed.</p>
</td></tr>
<tr><td><code id="kurtosis_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="kurtosis_+3A_type">type</code></td>
<td>
<p>an integer between 1 and 3 selecting one of the algorithms for
computing skewness.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = rnorm(100)
coef_kurtosis &lt;- kurtosis(x)
coef_skewness &lt;- skewness(x)

</code></pre>

<hr>
<h2 id='lambda_vcurve'>lambda_vcurve</h2><span id='topic+lambda_vcurve'></span>

<h3>Description</h3>

<p>lambda_vcurve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_vcurve(
  y,
  w,
  lg_lambdas = seq(0.1, 5, 0.1),
  plot = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_vcurve_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="lambda_vcurve_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="lambda_vcurve_+3A_lg_lambdas">lg_lambdas</code></td>
<td>
<p>numeric vector, log10(lambda) candidates. The optimal <code>lambda</code>
will be optimized from <code>lg_lambda</code>.</p>
</td></tr>
<tr><td><code id="lambda_vcurve_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, the optimized <code>lambda</code> will be printed on the
console.</p>
</td></tr>
<tr><td><code id="lambda_vcurve_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='logistic'>Double logistics in Rcpp</h2><span id='topic+logistic'></span><span id='topic+doubleLog_Zhang'></span><span id='topic+doubleLog_AG'></span><span id='topic+doubleLog_Beck'></span><span id='topic+doubleLog_Elmore'></span><span id='topic+doubleLog_Gu'></span><span id='topic+doubleLog_Klos'></span>

<h3>Description</h3>

<p>Double logistics in Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic(par, t, pred)

doubleLog_Zhang(par, t, pred)

doubleLog_AG(par, t, pred)

doubleLog_Beck(par, t, pred)

doubleLog_Elmore(par, t, pred)

doubleLog_Gu(par, t, pred)

doubleLog_Klos(par, t, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_+3A_par">par</code></td>
<td>
<p>A vector of parameters</p>
</td></tr>
<tr><td><code id="logistic_+3A_t">t</code></td>
<td>
<p>A <code>Date</code> or numeric vector</p>
</td></tr>
<tr><td><code id="logistic_+3A_pred">pred</code></td>
<td>
<p>Numeric Vector, predicted values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+doubleLog.Beck">doubleLog.Beck()</a></code>
</p>

<hr>
<h2 id='Logistic'>Fine fitting functions</h2><span id='topic+Logistic'></span><span id='topic+doubleLog.Zhang'></span><span id='topic+doubleLog.AG'></span><span id='topic+doubleLog.AG2'></span><span id='topic+doubleLog.Beck'></span><span id='topic+doubleLog.Elmore'></span><span id='topic+doubleLog.Gu'></span><span id='topic+doubleLog.Klos'></span>

<h3>Description</h3>

<p>double logistics, piecewise logistics and many other functions to
curve fit VI time-series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Logistic(par, t)

doubleLog.Zhang(par, t)

doubleLog.AG(par, t)

doubleLog.AG2(par, t)

doubleLog.Beck(par, t)

doubleLog.Elmore(par, t)

doubleLog.Gu(par, t)

doubleLog.Klos(par, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Logistic_+3A_par">par</code></td>
<td>
<p>A vector of parameters</p>
</td></tr>
<tr><td><code id="Logistic_+3A_t">t</code></td>
<td>
<p>A <code>Date</code> or numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>Logistic</code> The traditional simplest logistic function. It can
be only used in half growing season, i.e. vegetation green-up or senescence
period.
</p>
</li>
<li> <p><code>doubleLog.Zhang</code> Piecewise logistics, (Zhang Xiaoyang, RSE, 2003).
</p>
</li>
<li> <p><code>doubleAG</code> Asymmetric Gaussian.
</p>
</li>
<li> <p><code>doubleLog.Beck</code> Beck logistics.
</p>
</li>
<li> <p><code>doubleLog.Gu</code> Gu logistics.
</p>
</li>
<li> <p><code>doubleLog.Elmore</code> Elmore logistics.
</p>
</li>
<li> <p><code>doubleLog.Klos</code> Klos logistics.
</p>
</li></ul>

<p>All of those function have <code>par</code> and <code>formula</code> attributes for the
convenience for analytical D1 and D2
</p>


<h3>References</h3>


<ol>
<li><p> Beck, P.S.A., Atzberger, C., Hogda, K.A., Johansen, B., Skidmore, A.K.,
2006. Improved monitoring of vegetation dynamics at very high latitudes:
A new method using MODIS NDVI. Remote Sens. Environ.
https://doi.org/10.1016/j.rse.2005.10.021.
</p>
</li>
<li><p> Elmore, A.J., Guinn, S.M., Minsley, B.J., Richardson, A.D., 2012.
Landscape controls on the timing of spring, autumn, and growing season
length in mid-Atlantic forests. Glob. Chang. Biol. 18, 656-674.
https://doi.org/10.1111/j.1365-2486.2011.02521.x. <br />
</p>
</li>
<li><p> Gu, L., Post, W.M., Baldocchi, D.D., Black, TRUE.A., Suyker, A.E., Verma,
S.B., Vesala, TRUE., Wofsy, S.C., 2009. Characterizing the Seasonal Dynamics
of Plant Community Photosynthesis Across a Range of Vegetation Types,
in: Noormets, A. (Ed.), Phenology of Ecosystem Processes: Applications
in Global Change Research. Springer New York, New York, NY, pp. 35-58.
https://doi.org/10.1007/978-1-4419-0026-5_2. <br />
</p>
</li>
<li><p> Peter M. Atkinson, et al., 2012, RSE, 123:400-417
</p>
</li>
<li><p> https://github.com/cran/phenopix/blob/master/R/FitDoubleLogGu.R
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># simulate vegetation time-series
t    &lt;- seq(1, 365, 8)
par  &lt;- c(mn = 0.1, mx = 0.7, sos = 50, rsp = 0.1, eos = 250, rau = 0.1)
y    &lt;- doubleLog.Beck(par, t)
data &lt;- data.frame(t, y)
# methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang")
tout &lt;- seq(1, 365, 1)
r &lt;- FitDL.Elmore(y, t, tout)

plot(r, data)
get_GOF(r, data)
get_param(r)
</code></pre>

<hr>
<h2 id='melt_list'>melt_list</h2><span id='topic+melt_list'></span>

<h3>Description</h3>

<p>melt_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt_list(list, var.name = "variable", na.rm = TRUE, ...)
</code></pre>

<hr>
<h2 id='MOD13A1'>MOD13A1</h2><span id='topic+MOD13A1'></span>

<h3>Description</h3>

<p>A data.table dataset, raw data of MOD13A1 data, clipped in 10 representative points
('DE-Obe', 'IT-Col', 'CN-Cha', 'AT-Neu', 'ZA-Kru', 'AU-How', 'CA-NS6',
'US-KS2', 'CH-Oe2', 'CZ-wet').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('MOD13A1')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Details</h3>

<p>Variables in MOD13A1:
</p>

<ul>
<li> <p><strong><code>dt</code></strong>: vegetation index data
</p>

<ul>
<li> <p><code>system:index</code>: image index
</p>
</li>
<li> <p><code>DayOfYear</code>: Numeric, Julian day of year
</p>
</li>
<li> <p><code>DayOfYear</code>: corresponding doy of compositing NDVI and EVI
</p>
</li>
<li> <p><code>DetailedQA</code>: VI quality indicators
</p>
</li>
<li> <p><code>SummaryQA</code>: Quality reliability of VI pixel
</p>
</li>
<li> <p><code>EVI</code>: Enhanced Vegetation Index
</p>
</li>
<li> <p><code>NDVI</code>: Normalized Difference Vegetation Index
</p>
</li>
<li> <p><code>date</code>: Date, corresponding date
</p>
</li>
<li> <p><code>site</code>: String, site name
</p>
</li>
<li> <p><code>sur_refl_b01</code>: Red surface reflectance
</p>
</li>
<li> <p><code>sur_refl_b02</code>: NIR surface reflectance
</p>
</li>
<li> <p><code>sur_refl_b03</code>: Blue surface reflectance
</p>
</li>
<li> <p><code>sur_refl_b07</code>: MIR surface reflectance
</p>
</li>
<li> <p><code>.geo</code>: geometry
</p>
</li></ul>

</li>
<li> <p><strong><code>st</code></strong>: station info
</p>

<ul>
<li> <p><code>ID</code>: site ID
</p>
</li>
<li> <p><code>site</code>: site name
</p>
</li>
<li> <p><code>lat</code>: latitude
</p>
</li>
<li> <p><code>lon</code>: longitude
</p>
</li>
<li> <p><code>IGBPname</code>: IGBP land cover type
</p>
</li></ul>

</li></ul>



<h3>References</h3>


<ol>
<li><p> https://code.earthengine.google.com/dataset/MODIS/006/MOD13A1
</p>
</li></ol>


<hr>
<h2 id='movmean'>movmean</h2><span id='topic+movmean'></span>

<h3>Description</h3>

<p>NA and Inf values in the yy will be ignored automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movmean(y, halfwin = 1L, SG_style = FALSE, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movmean_+3A_y">y</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="movmean_+3A_halfwin">halfwin</code></td>
<td>
<p>Integer, half of moving window size</p>
</td></tr>
<tr><td><code id="movmean_+3A_sg_style">SG_style</code></td>
<td>
<p>If true, head and tail values will be in the style of SG
(more weights on the center point), else traditional moving mean style.</p>
</td></tr>
<tr><td><code id="movmean_+3A_w">w</code></td>
<td>
<p>Corresponding weights of yy, same long as yy.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:100
x[50] &lt;- NA; x[80] &lt;- Inf
s1 &lt;- movmean(x, 2, SG_style = TRUE)
s2 &lt;- movmean(x, 2, SG_style = FALSE)
</code></pre>

<hr>
<h2 id='opt_FUN'>Unified optimization function</h2><span id='topic+opt_FUN'></span><span id='topic+opt_ucminf'></span><span id='topic+opt_nlm'></span><span id='topic+opt_optim'></span><span id='topic+opt_nlminb'></span>

<h3>Description</h3>

<p><code>I_optimx</code> is rich of functionality, but with a low computing
performance. Some basic optimization functions are unified here, with some
input and output format. <br />
</p>

<ul>
<li> <p><code>opt_ncminf</code> General-Purpose Unconstrained Non-Linear Optimization,
see <code><a href="ucminf.html#topic+ucminf">ucminf::ucminf()</a></code>.
</p>
</li>
<li> <p><code>opt_nlminb</code> Optimization using PORT routines, see <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.
</p>
</li>
<li> <p><code>opt_nlm</code> Non-Linear Minimization, <code><a href="stats.html#topic+nlm">stats::nlm()</a></code>.
</p>
</li>
<li> <p><code>opt_optim</code> General-purpose Optimization, see <code><a href="stats.html#topic+optim">stats::optim()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opt_ucminf(par0, objective, ...)

opt_nlm(par0, objective, ...)

opt_optim(par0, objective, method = "BFGS", ...)

opt_nlminb(par0, objective, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_FUN_+3A_par0">par0</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="opt_FUN_+3A_objective">objective</code></td>
<td>
<p>A function to be minimized (or maximized), with first
argument the vector of parameters over which minimization is to take place.
It should return a scalar result.</p>
</td></tr>
<tr><td><code id="opt_FUN_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>objective</code>.</p>
</td></tr>
<tr><td><code id="opt_FUN_+3A_method">method</code></td>
<td>
<p>optimization method to be used in <code>p_optim</code>. See
<code><a href="stats.html#topic+optim">stats::optim()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>convcode</code>: An integer code. 0 indicates successful convergence.
Various methods may or may not return sufficient information to allow all
the codes to be specified. An incomplete list of codes includes
</p>

<ul>
<li> <p><code>1</code>: indicates that the iteration limit <code>maxit</code> had been reached.
</p>
</li>
<li> <p><code>20</code>: indicates that the initial set of parameters is inadmissible,
that is, that the function cannot be computed or returns an infinite,
NULL, or NA value.
</p>
</li>
<li> <p><code>21</code>: indicates that an intermediate set of parameters is inadmissible.
</p>
</li>
<li> <p><code>10</code>: indicates degeneracy of the Nelder&ndash;Mead simplex.
</p>
</li>
<li> <p><code>51</code>: indicates a warning from the <code>"L-BFGS-B"</code> method; see component
<code>message</code> for further details.
</p>
</li>
<li> <p><code>52</code>: indicates an error from the <code>"L-BFGS-B"</code> method; see component
<code>message</code> for further details.
</p>
</li>
<li> <p><code>9999</code>: error
</p>
</li></ul>

</li>
<li> <p><code>value</code>: The value of fn corresponding to par
</p>
</li>
<li> <p><code>par</code>: The best parameter found
</p>
</li>
<li> <p><code>nitns</code>: the number of iterations
</p>
</li>
<li> <p><code>fevals</code>: The number of calls to <code>objective</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+optim_pheno">optim_pheno()</a></code>, <code><a href="#topic+I_optim">I_optim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
library(ggplot2)
library(magrittr)
library(purrr)
library(data.table)

# simulate vegetation time-series
fFUN = doubleLog_Beck
par  = c( mn  = 0.1 , mx  = 0.7 , sos = 50 , rsp = 0.1 , eos = 250, rau = 0.1)
par0 = c( mn  = 0.15, mx  = 0.65, sos = 100, rsp = 0.12, eos = 200, rau = 0.12)

t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y &lt;- fFUN(par, t)

optFUNs &lt;- c("opt_ucminf", "opt_nlminb", "opt_nlm", "opt_optim") %&gt;% set_names(., .)
opts &lt;- lapply(optFUNs, function(optFUN){
    optFUN &lt;- get(optFUN)
    opt    &lt;- optFUN(par0, f_goal, y = y, t = t, fun = fFUN)
    opt$ysim &lt;- fFUN(opt$par, t)
    opt
})

# visualization
df   &lt;- map(opts, "ysim") %&gt;% as.data.table() %&gt;% cbind(t, y, .)
pdat &lt;- data.table::melt(df, c("t", "y"), variable.name = "optFUN")

ggplot(pdat) + 
    geom_point(data = data.frame(t, y), aes(t, y), size = 2) + 
    geom_line(aes(t, value, color = optFUN), linewidth = 0.9)
</code></pre>

<hr>
<h2 id='optim_pheno'>optim_pheno</h2><span id='topic+optim_pheno'></span>

<h3>Description</h3>

<p>Interface of optimization functions for double logistics and other parametric
curve fitting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_pheno(
  prior,
  sFUN,
  y,
  t,
  tout,
  method,
  w,
  nptperyear,
  ylu,
  iters = 2,
  wFUN = wTSM,
  lower = -Inf,
  upper = Inf,
  constrain = TRUE,
  verbose = FALSE,
  ...,
  use.cpp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim_pheno_+3A_prior">prior</code></td>
<td>
<p>A vector of initial values for the parameters for which optimal
values are to be found. <code>prior</code> is suggested giving a column name.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_sfun">sFUN</code></td>
<td>
<p>The name of fine curve fitting functions, can be one of <code style="white-space: pre;">&#8288; 'FitAG', 'FitDL.Beck', 'FitDL.Elmore', 'FitDL.Gu' and 'FitDL.Klos', 'FitDL.Zhang'&#8288;</code>.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_t">t</code></td>
<td>
<p>Numeric vector, <code>Date</code> variable</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_tout">tout</code></td>
<td>
<p>Corresponding doy of prediction.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_method">method</code></td>
<td>
<p>The name of optimization method to solve fine fitting, one of
<code style="white-space: pre;">&#8288;'BFGS','CG','Nelder-Mead', 'L-BFGS-B', 'nlm', 'nlminb', 'ucminf'&#8288;</code> and
<code style="white-space: pre;">&#8288;'spg','Rcgmin','Rvmmin', 'newuoa','bobyqa','nmkb','hjkb'&#8288;</code>.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_nptperyear">nptperyear</code></td>
<td>
<p>Integer, number of images per year, passed to <code>wFUN</code>.
Only <code><a href="#topic+wTSM">wTSM()</a></code> needs <code>nptperyear</code>. If not specified,
<code>nptperyear</code> will be calculated based on <code>t</code>.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_ylu">ylu</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[ymin, ymax]&#8288;</code>, which is used to force <code>ypred</code> in the range of <code>ylu</code>.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_iters">iters</code></td>
<td>
<p>How many times curve fitting is implemented.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_wfun">wFUN</code></td>
<td>
<p>weights updating function, can be one of 'wTSM', 'wChen' and
'wBisquare'.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_lower">lower</code>, <code id="optim_pheno_+3A_upper">upper</code></td>
<td>

<p>vectors of lower and upper bounds, replicated to be as long as
<code>start</code>.  If unspecified, all parameters are assumed to be
unconstrained.
</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_constrain">constrain</code></td>
<td>
<p>boolean, whether to use parameter constrain</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_verbose">verbose</code></td>
<td>
<p>Whether to display intermediate variables?</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="#topic+I_optim">I_optim()</a></code> or <code><a href="#topic+I_optimx">I_optimx()</a></code>.</p>
</td></tr>
<tr><td><code id="optim_pheno_+3A_use.cpp">use.cpp</code></td>
<td>
<p>(unstable, not used) boolean, whether to use c++ defined fine
fitting function? If <code>FALSE</code>, R version will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+fFIT">fFIT()</a></code> object, with the element of:
</p>

<ul>
<li> <p><code>tout</code>: The time of output curve fitting time-series.
</p>
</li>
<li> <p><code>zs</code>  : Smoothed vegetation time-series of every iteration.
</p>
</li>
<li> <p><code>ws</code>  : Weights of every iteration.
</p>
</li>
<li> <p><code>par</code> : Final optimized parameter of fine fitting.
</p>
</li>
<li> <p><code>fun</code> : The name of fine fitting.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fFIT">fFIT()</a></code>, <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># library(magrittr)
# library(purrr)

# simulate vegetation time-series
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)

FUN = doubleLog_Beck
par  = c( mn  = 0.1 , mx  = 0.7 , sos = 50 , rsp = 0.1 , eos = 250, rau = 0.1)
par0 = c( mn  = 0.15, mx  = 0.65, sos = 100, rsp = 0.12, eos = 200, rau = 0.12)

y &lt;- FUN(par, t)

methods = c("BFGS", "ucminf", "nlm", "nlminb")
opt1 &lt;- I_optim(par0, doubleLog_Beck, y, t, methods) # "BFGS", "ucminf", "nlm",
# opt2 &lt;- I_optimx(prior, fFUN, y, t, tout, )

sFUN   = "doubleLog.Beck" # doubleLog.Beck
r &lt;- optim_pheno(par0, sFUN, y, t, tout, method = methods[4],
                 nptperyear = 46, iters = 2, wFUN = wTSM, verbose = FALSE, use.julia = FALSE)
</code></pre>

<hr>
<h2 id='PhenoDeriv'>Phenology extraction in Derivative method (DER)</h2><span id='topic+PhenoDeriv'></span><span id='topic+PhenoDeriv.fFIT'></span><span id='topic+PhenoDeriv.default'></span>

<h3>Description</h3>

<p>Phenology extraction in Derivative method (DER)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoDeriv(x, t, ...)

## S3 method for class 'fFIT'
PhenoDeriv(x, t = NULL, analytical = FALSE, smoothed.spline = FALSE, ...)

## Default S3 method:
PhenoDeriv(x, t, der1, IsPlot = TRUE, show.legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhenoDeriv_+3A_x">x</code></td>
<td>
<p>numeric vector, or <code>fFIT</code> object returned by <code><a href="#topic+curvefit">curvefit()</a></code>.</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_t">t</code></td>
<td>
<p><code>doy</code> vector, corresponding doy of vegetation index.</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_...">...</code></td>
<td>
<p>Other parameters will be ignored.</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_analytical">analytical</code></td>
<td>
<p>If true, <code>numDeriv</code> package <code>grad</code> and <code>hess</code>
will be used; if false, <code>D1</code> and <code>D2</code> will be used.</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_smoothed.spline">smoothed.spline</code></td>
<td>
<p>Whether apply <code>smooth.spline</code> first?</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_der1">der1</code></td>
<td>
<p>the first order difference</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_isplot">IsPlot</code></td>
<td>
<p>whether to plot?</p>
</td></tr>
<tr><td><code id="PhenoDeriv_+3A_show.legend">show.legend</code></td>
<td>
<p>whether show figure lelend?</p>
</td></tr>
</table>


<h3>References</h3>


<ol>
<li><p> Filippa, G., Cremonese, E., Migliavacca, M., Galvagno, M., Forkel, M.,
Wingate, L., … Richardson, A. D. (2016). Phenopix: A R package for
image-based vegetation phenology. Agricultural and Forest Meteorology,
220, 141–150. <a href="https://doi.org/10.1016/j.agrformet.2016.01.006">doi:10.1016/j.agrformet.2016.01.006</a>
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+PhenoTrs">PhenoTrs()</a></code>, <code><a href="#topic+PhenoGu">PhenoGu()</a></code>, <code><a href="#topic+PhenoKl">PhenoKl()</a></code>
</p>

<hr>
<h2 id='phenofit'>phenofit</h2><span id='topic+phenofit'></span><span id='topic+_PACKAGE'></span><span id='topic+phenofit-package'></span>

<h3>Description</h3>

<p>Vegetation phenology package
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dongdong Kong <a href="mailto:kongdd.sysu@gmail.com">kongdd.sysu@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Mingzhong Xiao <a href="mailto:xmingzh@mail2.sysu.edu.cn">xmingzh@mail2.sysu.edu.cn</a>
</p>
</li>
<li><p> Yongqiang Zhang <a href="mailto:yongqiang.zhang2014@gmail.com">yongqiang.zhang2014@gmail.com</a>
</p>
</li>
<li><p> Xihui Gu <a href="mailto:guxh@cug.edu.cn">guxh@cug.edu.cn</a>
</p>
</li>
<li><p> Jianjian Cui <a href="mailto:cuijj6@mail2.sysu.edu.cn">cuijj6@mail2.sysu.edu.cn</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/eco-hydro/phenofit">https://github.com/eco-hydro/phenofit</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/eco-hydro/phenofit/issues">https://github.com/eco-hydro/phenofit/issues</a>
</p>
</li></ul>


<hr>
<h2 id='PhenoGu'>Phenology extraction in GU method (GU)</h2><span id='topic+PhenoGu'></span><span id='topic+PhenoGu.fFIT'></span><span id='topic+PhenoGu.default'></span>

<h3>Description</h3>

<p>Phenology extraction in GU method (GU)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoGu(x, t, ...)

## S3 method for class 'fFIT'
PhenoGu(x, t = NULL, analytical = FALSE, smoothed.spline = FALSE, ...)

## Default S3 method:
PhenoGu(x, t, der1, IsPlot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhenoGu_+3A_x">x</code></td>
<td>
<p>numeric vector, or <code>fFIT</code> object returned by <code><a href="#topic+curvefit">curvefit()</a></code>.</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_t">t</code></td>
<td>
<p><code>doy</code> vector, corresponding doy of vegetation index.</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_...">...</code></td>
<td>
<p>other parameters to <code><a href="#topic+PhenoGu.default">PhenoGu.default()</a></code> or <code><a href="#topic+PhenoGu.fFIT">PhenoGu.fFIT()</a></code></p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_analytical">analytical</code></td>
<td>
<p>If true, <code>numDeriv</code> package <code>grad</code> and <code>hess</code>
will be used; if false, <code>D1</code> and <code>D2</code> will be used.</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_smoothed.spline">smoothed.spline</code></td>
<td>
<p>Whether apply <code>smooth.spline</code> first?</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_der1">der1</code></td>
<td>
<p>the first order difference</p>
</td></tr>
<tr><td><code id="PhenoGu_+3A_isplot">IsPlot</code></td>
<td>
<p>whether to plot?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, with the elements of:
</p>

<ul>
<li> <p><code>UD</code>: upturn date
</p>
</li>
<li> <p><code>SD</code>: stabilisation date
</p>
</li>
<li> <p><code>DD</code>: downturn date
</p>
</li>
<li> <p><code>RD</code>: recession date
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> Gu, L., Post, W. M., Baldocchi, D. D., Black, T. A., Suyker, A. E., Verma,
S. B., … Wofsy, S. C. (2009). Characterizing the Seasonal Dynamics of
Plant Community Photosynthesis Across a Range of Vegetation Types. In A.
Noormets (Ed.), Phenology of Ecosystem Processes: Applications in Global
Change Research (pp. 35–58). New York, NY: Springer New York.
<a href="https://doi.org/10.1007/978-1-4419-0026-5_2">doi:10.1007/978-1-4419-0026-5_2</a>
</p>
</li>
<li><p> Filippa, G., Cremonese, E., Migliavacca, M., Galvagno, M., Forkel, M.,
Wingate, L., … Richardson, A. D. (2016). Phenopix: A R package for
image-based vegetation phenology. Agricultural and Forest Meteorology,
220, 141–150. <a href="https://doi.org/10.1016/j.agrformet.2016.01.006">doi:10.1016/j.agrformet.2016.01.006</a>
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># `doubleLog.Beck` simulate vegetation time-series
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
par  = c( mn  = 0.1 , mx  = 0.7 , sos = 50 , rsp = 0.1 , eos = 250, rau = 0.1)
y &lt;- doubleLog.Beck(par, t)

methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout, methods)
x &lt;- fit$model$AG # one model

par(mfrow = c(2, 2))
PhenoTrs(x)
PhenoDeriv(x)
PhenoGu(x)
PhenoKl(x)
</code></pre>

<hr>
<h2 id='PhenoKl'>Phenology extraction in Inflection method (Zhang)</h2><span id='topic+PhenoKl'></span>

<h3>Description</h3>

<p>Phenology extraction in Inflection method (Zhang)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoKl(
  fFIT,
  t = NULL,
  analytical = FALSE,
  smoothed.spline = FALSE,
  IsPlot = TRUE,
  show.legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhenoKl_+3A_ffit">fFIT</code></td>
<td>
<p>object return by <code><a href="#topic+curvefit">curvefit()</a></code></p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_t">t</code></td>
<td>
<p><code>doy</code> vector, corresponding doy of vegetation index.</p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_analytical">analytical</code></td>
<td>
<p>If true, <code>numDeriv</code> package <code>grad</code> and <code>hess</code>
will be used; if false, <code>D1</code> and <code>D2</code> will be used.</p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_smoothed.spline">smoothed.spline</code></td>
<td>
<p>Whether apply <code>smooth.spline</code> first?</p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_isplot">IsPlot</code></td>
<td>
<p>whether to plot?</p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_show.legend">show.legend</code></td>
<td>
<p>whether show figure lelend?</p>
</td></tr>
<tr><td><code id="PhenoKl_+3A_...">...</code></td>
<td>
<p>Other parameters will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, with the elements of:
<code>Greenup</code>, <code>Maturity</code>, <code>Senescence</code>, <code>Dormancy</code>.
</p>


<h3>References</h3>


<ol>
<li><p> Zhang, X., Friedl, M. A., Schaaf, C. B., Strahler, A. H., Hodges, J. C. F.
F., Gao, F., … Huete, A. (2003). Monitoring vegetation phenology using
MODIS. Remote Sensing of Environment, 84(3), 471–475.
<a href="https://doi.org/10.1016/S0034-4257%2802%2900135-9">doi:10.1016/S0034-4257(02)00135-9</a>
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># `doubleLog.Beck` simulate vegetation time-series
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
par  = c( mn  = 0.1 , mx  = 0.7 , sos = 50 , rsp = 0.1 , eos = 250, rau = 0.1)
y &lt;- doubleLog.Beck(par, t)

methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout, methods)
x &lt;- fit$model$AG # one model

par(mfrow = c(2, 2))
PhenoTrs(x)
PhenoDeriv(x)
PhenoGu(x)
PhenoKl(x)
</code></pre>

<hr>
<h2 id='PhenoTrs'>Phenology extraction in Threshold method (TRS)</h2><span id='topic+PhenoTrs'></span><span id='topic+PhenoTrs.fFIT'></span><span id='topic+PhenoTrs.default'></span>

<h3>Description</h3>

<p>Phenology extraction in Threshold method (TRS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoTrs(
  x,
  t = NULL,
  approach = c("White", "Trs"),
  trs = 0.5,
  asymmetric = TRUE,
  IsPlot = TRUE,
  ...
)

## S3 method for class 'fFIT'
PhenoTrs(x, t = NULL, ...)

## Default S3 method:
PhenoTrs(
  x,
  t = NULL,
  approach = c("White", "Trs"),
  trs = 0.5,
  asymmetric = TRUE,
  IsPlot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhenoTrs_+3A_x">x</code></td>
<td>
<p>numeric vector, or <code>fFIT</code> object returned by <code><a href="#topic+curvefit">curvefit()</a></code>.</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_t">t</code></td>
<td>
<p><code>doy</code> vector, corresponding doy of vegetation index.</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_approach">approach</code></td>
<td>
<p>to be used to calculate phenology metrics.
'White' (White et al. 1997) or 'Trs' for simple threshold.</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_trs">trs</code></td>
<td>
<p>threshold to be used for approach &quot;Trs&quot;, in (0, 1).</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_asymmetric">asymmetric</code></td>
<td>
<p>If true, background value in spring season and autumn season
is regarded as different.</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_isplot">IsPlot</code></td>
<td>
<p>whether to plot?</p>
</td></tr>
<tr><td><code id="PhenoTrs_+3A_...">...</code></td>
<td>
<p>other parameters to PhenoPlot</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+PhenoDeriv">PhenoDeriv()</a></code>, <code><a href="#topic+PhenoGu">PhenoGu()</a></code>, <code><a href="#topic+PhenoKl">PhenoKl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `doubleLog.Beck` simulate vegetation time-series
t    &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
par  = c( mn  = 0.1 , mx  = 0.7 , sos = 50 , rsp = 0.1 , eos = 250, rau = 0.1)
y &lt;- doubleLog.Beck(par, t)

methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fit &lt;- curvefit(y, t, tout, methods)
x &lt;- fit$model$AG # one model

par(mfrow = c(2, 2))
PhenoTrs(x)
PhenoDeriv(x)
PhenoGu(x)
PhenoKl(x)
</code></pre>

<hr>
<h2 id='plot_curvefits'>plot_curvefits</h2><span id='topic+plot_curvefits'></span>

<h3>Description</h3>

<p>plot_curvefits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_curvefits(
  d_fit,
  seasons,
  d_obs = NULL,
  title = NULL,
  xlab = "Time",
  ylab = "Vegetation Index",
  yticks = NULL,
  font.size = 14,
  theme = NULL,
  cex = 2,
  shape = "point",
  angle = 30,
  show.legend = TRUE,
  layer_extra = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_curvefits_+3A_d_fit">d_fit</code></td>
<td>
<p>data.frame of curve fittings returned by <code><a href="#topic+get_fitting">get_fitting()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_seasons">seasons</code></td>
<td>
<p>growing season division object returned by <code><a href="#topic+season">season()</a></code>
and <code><a href="#topic+season_mov">season_mov()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_d_obs">d_obs</code></td>
<td>
<p>data.frame of original vegetation time series, with the columns
of <code>t</code>, <code>y</code> and <code>QC_flag</code>. If not specified, it will be determined from <code>d_fit</code>.</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_title">title</code></td>
<td>
<p>String, title of figure.</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_xlab">xlab</code>, <code id="plot_curvefits_+3A_ylab">ylab</code></td>
<td>
<p>String, title of <code>xlab</code> and <code>ylab</code>.</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_yticks">yticks</code></td>
<td>
<p>ticks of y axis</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_font.size">font.size</code></td>
<td>
<p>Font size of axis.text</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_theme">theme</code></td>
<td>
<p>ggplot theme</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_cex">cex</code></td>
<td>
<p>point size for VI observation.</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_shape">shape</code></td>
<td>
<p>the shape of input VI observation? <code>line</code> or <code>point</code></p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_angle">angle</code></td>
<td>
<p><code>text.x</code> angle</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_show.legend">show.legend</code></td>
<td>
<p>Boolean</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_layer_extra">layer_extra</code></td>
<td>
<p>(not used) extra ggplot layers</p>
</td></tr>
<tr><td><code id="plot_curvefits_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("CA_NS6")
d = CA_NS6

nptperyear &lt;- 23
INPUT &lt;- check_input(d$t, d$y, d$w, QC_flag = d$QC_flag,
     nptperyear = nptperyear, south = FALSE,
     maxgap = nptperyear/4, alpha = 0.02, wmin = 0.2)
# plot_input(INPUT)

# Rough fitting and growing season dividing
wFUN &lt;- "wTSM"
brks2 &lt;- season_mov(INPUT,
    options = list(
        rFUN = "smooth_wWHIT", wFUN = wFUN,
        r_min = 0.05, ypeak_min = 0.05,
        lambda = 10,
        verbose = FALSE
    ))
# plot_season(INPUT, brks2, d)
# Fine fitting
fits &lt;- curvefits(
    INPUT, brks2,
    options = list(
        methods = c("AG", "Beck", "Elmore", "Zhang"), #,"klos", "Gu"
        wFUN = wFUN,
        nextend = 2, maxExtendMonth = 2, minExtendMonth = 1, minPercValid = 0.2
    )
)

r_param = get_param(fits)
r_pheno = get_pheno(fits)
r_gof = get_GOF(fits)
d_fit = get_fitting(fits)

g &lt;- plot_curvefits(d_fit, brks2)
grid::grid.newpage(); grid::grid.draw(g)
</code></pre>

<hr>
<h2 id='plot_input'>Plot INPUT returned by check_input</h2><span id='topic+plot_input'></span>

<h3>Description</h3>

<p>Plot INPUT returned by check_input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_input(INPUT, wmin = 0.2, show.y0 = TRUE, ylab = "VI", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_input_+3A_input">INPUT</code></td>
<td>
<p>A list object with the elements of <code>t</code>, <code>y</code>, <code>w</code>,
<code>Tn</code> (optional) and <code>ylu</code>, returned by <code><a href="#topic+check_input">check_input()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_input_+3A_wmin">wmin</code></td>
<td>
<p>double, minimum weigth (i.e. weight of snow, ice and cloud).</p>
</td></tr>
<tr><td><code id="plot_input_+3A_show.y0">show.y0</code></td>
<td>
<p>boolean. Whether to show original time-series <code>y0</code> or processed time-series <code>y</code> by
<code><a href="#topic+check_input">check_input()</a></code>?</p>
</td></tr>
<tr><td><code id="plot_input_+3A_ylab">ylab</code></td>
<td>
<p>y axis title</p>
</td></tr>
<tr><td><code id="plot_input_+3A_...">...</code></td>
<td>
<p>other parameter will be ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
data("CA_NS6"); d = CA_NS6
# global parameter
IsPlot = TRUE
nptperyear = 23
ypeak_min  = 0.05

INPUT    &lt;- check_input(d$t, d$y, d$w, d$QC_flag, nptperyear,
                        maxgap = nptperyear/4, alpha = 0.02, wmin = 0.2)
plot_input(INPUT)
</code></pre>

<hr>
<h2 id='plot_phenofit'>plot_phenofit</h2><span id='topic+plot_phenofit'></span>

<h3>Description</h3>

<p>plot_phenofit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_phenofit(
  obj,
  type = "all",
  methods,
  title = NULL,
  ylab = "Vegetation Index",
  IsPlot = TRUE,
  show.legend = TRUE,
  newpage = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_phenofit_+3A_obj">obj</code></td>
<td>
<p><code>phenofit</code> object, list(INPUT, fit, seasons)</p>
</td></tr>
<tr><td><code id="plot_phenofit_+3A_type">type</code></td>
<td>
<p>one of c(&quot;season&quot;, &quot;fitting&quot;, &quot;pheno&quot;, &quot;all&quot;)</p>
</td></tr>
<tr><td><code id="plot_phenofit_+3A_methods">methods</code></td>
<td>
<p>fine fitting functions, e.g., <code>c("AG", "Zhang", "Beck", "Elmore", "Gu")</code></p>
</td></tr>
<tr><td><code id="plot_phenofit_+3A_title">title</code></td>
<td>
<p>String, title of figure.</p>
</td></tr>
<tr><td><code id="plot_phenofit_+3A_isplot">IsPlot</code></td>
<td>
<p>boolean. If false, a ggplot object will be returned.</p>
</td></tr>
<tr><td><code id="plot_phenofit_+3A_show.legend">show.legend</code></td>
<td>
<p>If now show legend, ggplot object will be returned, else
grid object will be returned.</p>
</td></tr>
<tr><td><code id="plot_phenofit_+3A_newpage">newpage</code></td>
<td>
<p>boolean, whether draw figure in a new page?</p>
</td></tr>
<tr><td><code id="plot_phenofit_+3A_...">...</code></td>
<td>
<p>other parameters to <code><a href="#topic+plot_curvefits">plot_curvefits()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='plot_season'>plot_season</h2><span id='topic+plot_season'></span>

<h3>Description</h3>

<p>Plot growing season divding result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_season(
  INPUT,
  brks,
  plotdat,
  IsPlot.OnlyBad = FALSE,
  show.legend = TRUE,
  ylab = "VI",
  title = NULL,
  show.shade = TRUE,
  margin = 0.35
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_season_+3A_input">INPUT</code></td>
<td>
<p>A list object with the elements of <code>t</code>, <code>y</code>, <code>w</code>,
<code>Tn</code> (optional) and <code>ylu</code>, returned by <code><a href="#topic+check_input">check_input()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_season_+3A_brks">brks</code></td>
<td>
<p>A list object returned by <code>season</code> or <code>season_mov</code>.</p>
</td></tr>
<tr><td><code id="plot_season_+3A_plotdat">plotdat</code></td>
<td>
<p>(optional) A list or data.table, with <code>t</code>, <code>y</code> and <code>w</code>.
Only if <code>IsPlot=TRUE</code>, <code><a href="#topic+plot_input">plot_input()</a></code> will be used to plot.
Known that y and w in <code>INPUT</code> have been changed, we suggest using the
original data.table.</p>
</td></tr>
<tr><td><code id="plot_season_+3A_isplot.onlybad">IsPlot.OnlyBad</code></td>
<td>
<p>If true, only plot partial figures whose NSE &lt; 0.3.</p>
</td></tr>
<tr><td><code id="plot_season_+3A_show.legend">show.legend</code></td>
<td>
<p>Whether to show legend?</p>
</td></tr>
<tr><td><code id="plot_season_+3A_ylab">ylab</code></td>
<td>
<p>y axis title</p>
</td></tr>
<tr><td><code id="plot_season_+3A_title">title</code></td>
<td>
<p>The main title (on top)</p>
</td></tr>
<tr><td><code id="plot_season_+3A_show.shade">show.shade</code></td>
<td>
<p>Boolean, period inside growing cycle colored as shade?</p>
</td></tr>
<tr><td><code id="plot_season_+3A_margin">margin</code></td>
<td>
<p><code style="white-space: pre;">&#8288;ylim = c(ymin, ymax + margin * A); A = ymax - ymin&#8288;</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='process_phenofit'>Extract Vegetation Phenology at site scale</h2><span id='topic+process_phenofit'></span>

<h3>Description</h3>

<p>Extract Vegetation Phenology at site scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_phenofit(
  d_obs,
  nptperyear = 36,
  south = FALSE,
  options_season = list(wFUN = "wTSM", maxExtendMonth = 12, MaxPeaksPerYear = 3,
    MaxTroughsPerYear = 4),
  options_fitting = list(methods = c("AG", "Zhang", "Beck", "Elmore", "Gu"), wFUN =
    "wTSM", maxExtendMonth = 12, minExtendMonth = 0.5, use.y0 = FALSE),
  brks = NULL,
  TRS = c(0.1, 0.2, 0.5, 0.6, 0.8, 0.9),
  run.curvefit = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_phenofit_+3A_d_obs">d_obs</code></td>
<td>
<p>data.table with the columns of y, t, w and QC_flag (optional).</p>
</td></tr>
<tr><td><code id="process_phenofit_+3A_nptperyear">nptperyear</code></td>
<td>
<p>Integer, number of images per year.</p>
</td></tr>
<tr><td><code id="process_phenofit_+3A_south">south</code></td>
<td>
<p>Boolean. In south hemisphere, growing year is 1 July to the
following year 31 June; In north hemisphere, growing year is 1 Jan to 31 Dec.</p>
</td></tr>
<tr><td><code id="process_phenofit_+3A_brks">brks</code></td>
<td>
<p>A list object with the elements of 'fit' and 'dt', returned by
<code>season</code> or <code>season_mov</code>, which contains the growing season division information.</p>
</td></tr>
<tr><td><code id="process_phenofit_+3A_...">...</code></td>
<td>
<p>other parameters to <code><a href="#topic+curvefits">curvefits()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='process_season'>divide_seasons</h2><span id='topic+process_season'></span>

<h3>Description</h3>

<p>divide_seasons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_season(
  d_obs,
  options = list(wFUN = "wTSM", maxExtendMonth = 12, MaxPeaksPerYear = 3,
    MaxTroughsPerYear = 4),
  nptperyear = 36,
  south = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_season_+3A_d_obs">d_obs</code></td>
<td>
<p>data.frame, with the columns of <code>t</code>, <code>y</code> and <code>w</code>.</p>
</td></tr>
<tr><td><code id="process_season_+3A_options">options</code></td>
<td>
<p>options of <code><a href="#topic+season_mov">season_mov()</a></code></p>
</td></tr>
<tr><td><code id="process_season_+3A_nptperyear">nptperyear</code></td>
<td>
<p>Integer, number of images per year.</p>
</td></tr>
<tr><td><code id="process_season_+3A_south">south</code></td>
<td>
<p>Boolean. In south hemisphere, growing year is 1 July to the
following year 31 June; In north hemisphere, growing year is 1 Jan to 31 Dec.</p>
</td></tr>
<tr><td><code id="process_season_+3A_...">...</code></td>
<td>
<p>Others will be ignored.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>site-year may be not continuous.
</p>

<hr>
<h2 id='qc_levels'>qc level, color and shape</h2><span id='topic+qc_levels'></span><span id='topic+qc_colors'></span><span id='topic+qc_shapes'></span>

<h3>Description</h3>

<p>qc level, color and shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_levels

qc_colors

qc_shapes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 6.
</p>
<p>An object of class <code>character</code> of length 6.
</p>
<p>An object of class <code>numeric</code> of length 6.
</p>

<hr>
<h2 id='qc_sentinel2'>Initial weights for sentinel2 according to SCL band</h2><span id='topic+qc_sentinel2'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>SCL Value</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Quality</strong> </td><td style="text-align: left;"> <strong>weight</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> Saturated or defective </td><td style="text-align: left;"> Bad </td><td style="text-align: left;"> <code class="reqn">w_{min}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> Dark Area Pixels </td><td style="text-align: left;"> Bad </td><td style="text-align: left;"> <code class="reqn">w_{min}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> Cloud Shadows </td><td style="text-align: left;"> Bad </td><td style="text-align: left;"> <code class="reqn">w_{min}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: left;"> Vegetation </td><td style="text-align: left;"> Good </td><td style="text-align: left;"> <code class="reqn">w_{max}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   5 </td><td style="text-align: left;"> Bare Soils </td><td style="text-align: left;"> Good </td><td style="text-align: left;"> <code class="reqn">w_{max}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   6 </td><td style="text-align: left;"> Water </td><td style="text-align: left;"> Good </td><td style="text-align: left;"> <code class="reqn">w_{max}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   7 </td><td style="text-align: left;"> Clouds Low Probability / Unclassified </td><td style="text-align: left;"> Good </td><td style="text-align: left;"> <code class="reqn">w_{max}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   8 </td><td style="text-align: left;"> Clouds Medium Probability </td><td style="text-align: left;"> Marginal </td><td style="text-align: left;"> <code class="reqn">w_{mid}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   9 </td><td style="text-align: left;"> Clouds High Probability </td><td style="text-align: left;"> Bad </td><td style="text-align: left;"> <code class="reqn">w_{mid}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   10 </td><td style="text-align: left;"> Cirrus </td><td style="text-align: left;"> Good </td><td style="text-align: left;"> <code class="reqn">w_{mid}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   11 </td><td style="text-align: left;"> Snow / Ice </td><td style="text-align: left;"> Bad </td><td style="text-align: left;"> <code class="reqn">w_{mid}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>qc_sentinel2(SCL, wmin = 0.2, wmid = 0.5, wmax = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qc_sentinel2_+3A_scl">SCL</code></td>
<td>
<p>quality control variable for sentinel2</p>
</td></tr>
<tr><td><code id="qc_sentinel2_+3A_wmin">wmin</code></td>
<td>
<p>Double, minimum weigth (i.e. weight of snow, ice and cloud).</p>
</td></tr>
<tr><td><code id="qc_sentinel2_+3A_wmid">wmid</code></td>
<td>
<p>Dougle, middle weight, i.e. marginal</p>
</td></tr>
<tr><td><code id="qc_sentinel2_+3A_wmax">wmax</code></td>
<td>
<p>Double, maximum weight, i.e. good</p>
</td></tr>
</table>


<h3>References</h3>

<p>https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_SR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qc_sentinel2(1:11)
</code></pre>

<hr>
<h2 id='qcFUN'>Initial weights according to qc</h2><span id='topic+qcFUN'></span><span id='topic+getBits'></span><span id='topic+qc_summary'></span><span id='topic+qc_StateQA'></span><span id='topic+qc_FparLai'></span><span id='topic+qc_5l'></span><span id='topic+qc_NDVIv4'></span><span id='topic+qc_NDVI3g'></span><span id='topic+qc_SPOT'></span>

<h3>Description</h3>


<ul>
<li> <p><code>getBits</code>: Extract bitcoded QA information from bin value
</p>
</li>
<li> <p><code>qc_summary</code>: Initial weigths based on Quality reliability of VI pixel,
suit for MOD13A1, MOD13A2 and MOD13Q1 (SummaryQA band).
</p>
</li>
<li> <p><code>qc_5l</code>: Initial weights based on Quality control of five-level
confidence score, suit for MCD15A3H(LAI, FparLai_QC), MOD17A2H(GPP, Psn_QC)
and MOD16A2(ET, ET_QC).
</p>
</li>
<li> <p><code>qc_StateQA</code>: Initial weights based on <code>StateQA</code>, suit for MOD09A1, MYD09A1.
</p>
</li>
<li> <p><code>qc_FparLai</code>: For MODIS LAI
</p>
</li>
<li> <p><code>qc_NDVI3g</code>: For AVHRR NDVI3g
</p>
</li>
<li> <p><code>qc_NDVIv4</code>: For AVHRR NDVIv4
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>getBits(x, start, end = start)

qc_summary(QA, wmin = 0.2, wmid = 0.5, wmax = 1)

qc_StateQA(QA, wmin = 0.2, wmid = 0.5, wmax = 1)

qc_FparLai(QA, FparLai_QC = NULL, wmin = 0.2, wmid = 0.5, wmax = 1)

qc_5l(QA, wmin = 0.2, wmid = 0.5, wmax = 1)

qc_NDVIv4(QA, wmin = 0.2, wmid = 0.5, wmax = 1)

qc_NDVI3g(QA, wmin = 0.2, wmid = 0.5, wmax = 1)

qc_SPOT(QA, wmin = 0.2, wmid = 0.5, wmax = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qcFUN_+3A_x">x</code></td>
<td>
<p>Binary value</p>
</td></tr>
<tr><td><code id="qcFUN_+3A_start">start</code></td>
<td>
<p>Bit starting position, count from zero</p>
</td></tr>
<tr><td><code id="qcFUN_+3A_end">end</code></td>
<td>
<p>Bit ending position</p>
</td></tr>
<tr><td><code id="qcFUN_+3A_qa">QA</code></td>
<td>
<p>quality control variable</p>
</td></tr>
<tr><td><code id="qcFUN_+3A_wmin">wmin</code></td>
<td>
<p>Double, minimum weigth (i.e. weight of snow, ice and cloud).</p>
</td></tr>
<tr><td><code id="qcFUN_+3A_wmid">wmid</code></td>
<td>
<p>Dougle, middle weight, i.e. marginal</p>
</td></tr>
<tr><td><code id="qcFUN_+3A_wmax">wmax</code></td>
<td>
<p>Double, maximum weight, i.e. good</p>
</td></tr>
<tr><td><code id="qcFUN_+3A_fparlai_qc">FparLai_QC</code></td>
<td>
<p>Another QC flag of <code>MCD15A3H</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>FparLai_QC</code> specified, <code>I_margin = SCF_QC &gt;= 2 &amp; SCF_QC &lt;= 3</code>.
</p>


<h3>Value</h3>

<p>A list object with
</p>

<ul>
<li> <p><code>weigths</code>: Double vector, initial weights.
</p>
</li>
<li> <p><code>QC_flag</code>: Factor vector, with the level of
<code>c("snow", "cloud", "shadow", "aerosol", "marginal", "good")</code>
</p>
</li></ul>



<h3>Note</h3>

<p><code>qc_5l</code> and <code>qc_NDVIv4</code> only returns <code>weight</code>, without <code>QC_flag</code>.
</p>


<h3>References</h3>

<p>https://developers.google.com/earth-engine/datasets/catalog/MODIS_006_MOD13A1
</p>
<p>https://developers.google.com/earth-engine/datasets/catalog/MODIS_006_MCD15A3H
</p>
<p>Erwin Wolters, Else Swinnen, Carolien Toté, Sindy Sterckx.
SPOT-VGT COLLECTION 3 PRODUCTS USER MANUAL V1.2, 2018, P47
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qc_sentinel2">qc_sentinel2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
QA &lt;- as.integer(runif(100, 0, 2^7))

r1 &lt;- qc_summary(QA, wmin = 0.2, wmid = 0.5, wmax = 1)
r2 &lt;- qc_StateQA(QA, wmin = 0.2, wmid = 0.5, wmax = 1)
r_5l &lt;- qc_5l(QA, wmin = 0.2, wmid = 0.5, wmax = 1)
r_NDVI3g &lt;- qc_NDVI3g(QA, wmin = 0.2, wmid = 0.5, wmax = 1)
r_NDVIv4 &lt;- qc_NDVIv4(QA, wmin = 0.2, wmid = 0.5, wmax = 1)
</code></pre>

<hr>
<h2 id='R2_sign'>Critical value of determined correlation</h2><span id='topic+R2_sign'></span>

<h3>Description</h3>

<p>Critical value of determined correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2_sign(n, NumberOfPredictor = 2, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2_sign_+3A_n">n</code></td>
<td>
<p>length of observation.</p>
</td></tr>
<tr><td><code id="R2_sign_+3A_numberofpredictor">NumberOfPredictor</code></td>
<td>
<p>Number of predictor, including constant.</p>
</td></tr>
<tr><td><code id="R2_sign_+3A_alpha">alpha</code></td>
<td>
<p>significant level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>F</code> statistic and <code>R2</code> at significant level.
</p>


<h3>References</h3>

<p>Chen Yanguang (2012), Geographical Data analysis with MATLAB.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R2_critical &lt;- R2_sign(30, NumberOfPredictor = 2, alpha = 0.05)
</code></pre>

<hr>
<h2 id='rcpp_season_filter'>season_filter</h2><span id='topic+rcpp_season_filter'></span><span id='topic+check_season_dt'></span><span id='topic+check_season_list'></span>

<h3>Description</h3>

<p>season_filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_season_filter(d, rm_closed = TRUE, rtrough_max = 0.7, r_min = 0.02)

check_season_dt(dt)

check_season_list(lst_dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_season_filter_+3A_d">d</code></td>
<td>
<p>Data.frame of growing season dividing info</p>
</td></tr>
<tr><td><code id="rcpp_season_filter_+3A_rtrough_max">rtrough_max</code></td>
<td>
<p><code>ytrough &lt;= rtrough_max*A</code>, A is the amplitude of y.</p>
</td></tr>
<tr><td><code id="rcpp_season_filter_+3A_r_min">r_min</code></td>
<td>
<p>Threshold is defined as the difference of peak value with
trough value. There are two threshold (left and right). The minimum threshold
should be greater than r_min.</p>
</td></tr>
<tr><td><code id="rcpp_season_filter_+3A_dt">dt</code></td>
<td>
<p>data.table of growing season division info</p>
</td></tr>
<tr><td><code id="rcpp_season_filter_+3A_lst_dt">lst_dt</code></td>
<td>
<p>list of <code>dt</code>. Every year is corresponding to a <code>dt</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='rcpp_wSG'>Weighted Savitzky-Golay written in RcppArmadillo</h2><span id='topic+rcpp_wSG'></span><span id='topic+rcpp_SG'></span>

<h3>Description</h3>

<p>NA and Inf values in the yy has been ignored automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_wSG(y, halfwin = 1L, d = 1L, w = NULL)

rcpp_SG(y, halfwin = 1L, d = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_wSG_+3A_y">y</code></td>
<td>
<p>colvec</p>
</td></tr>
<tr><td><code id="rcpp_wSG_+3A_halfwin">halfwin</code></td>
<td>
<p>halfwin of Savitzky-Golay</p>
</td></tr>
<tr><td><code id="rcpp_wSG_+3A_d">d</code></td>
<td>
<p>polynomial of degree. When d = 1, it becomes moving average.</p>
</td></tr>
<tr><td><code id="rcpp_wSG_+3A_w">w</code></td>
<td>
<p>colvec of weight</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- 1:15
w &lt;- seq_along(y)/length(y)

frame = 5
d = 2
s1 &lt;- rcpp_wSG(y, frame, d, w)
s2 &lt;- rcpp_SG(y, frame, d)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3C-+25'></span><span id='topic++25+3E+25'></span><span id='topic++25+3C+3E+25'></span><span id='topic+make_date'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>lubridate</dt><dd><p><code><a href="lubridate.html#topic+make_datetime">make_date</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+compound">%&lt;&gt;%</a></code>, <code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>zeallot</dt><dd><p><code><a href="zeallot.html#topic+operator">%&lt;-%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='removeClosedExtreme'>rm too closed peaks or troughs</h2><span id='topic+removeClosedExtreme'></span>

<h3>Description</h3>

<p>rm too closed peaks or troughs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeClosedExtreme(pos, ypred, A = NULL, y_min)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeClosedExtreme_+3A_pos">pos</code></td>
<td>
<p>data.table with the columns of <code style="white-space: pre;">&#8288;"val", "pos", "left", "right", "type"&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with the columns of:
<code style="white-space: pre;">&#8288;"val", "pos", "left", "right", "type"&#8288;</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#removeClosedExtreme(pos, ypred, A, y_min)

</code></pre>

<hr>
<h2 id='roughFit'>Rough fitting</h2><span id='topic+roughFit'></span>

<h3>Description</h3>

<p>Divide growing seasons according to rough fitting (<code>rFUN</code>) result .
</p>
<p>For <code>season</code>, rough fitting is applied for whole.
For <code>season_mov</code> rough fitting is applied in every year, during which
<code>maxExtendMonth</code> is extended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roughFit(
  INPUT,
  options = list(),
  frame = floor(INPUT$nptperyear/5) * 2 + 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roughFit_+3A_input">INPUT</code></td>
<td>
<p>A list object with the elements of <code>t</code>, <code>y</code>, <code>w</code>,
<code>Tn</code> (optional) and <code>ylu</code>, returned by <code><a href="#topic+check_input">check_input()</a></code>.</p>
</td></tr>
<tr><td><code id="roughFit_+3A_options">options</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="roughFit_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before division growing season, <code>INPUT</code> should be added a year in head
and tail first by <code>add_HeadTail</code>.
</p>
<p>Finally, use <code><a href="#topic+findpeaks">findpeaks()</a></code> to get local maximum and local minimum values.
Two local minimum define a growing season.
If two local minimum(maximum) are too closed, then only the smaller(biger)
is left.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>fit</code>: A data.table of Rough fitting result, with the columns of
(<code>t</code>, <code>y</code>, <code>witer1</code>, ..., <code>witerN</code>, <code>ziter1</code>, ..., <code>ziterN</code>).
</p>
</li>
<li> <p><code>dt</code>: A data.table of growing season division information, with the columns
of (<code>beg</code>, <code>peak</code>, <code>end</code>, <code>y_beg</code>, <code>y_peak</code>, <code>y_end</code>, <code>len</code>, <code>year</code>,
<code>season</code>, <code>flag</code>).
</p>
</li></ul>



<h3>options for season</h3>



<h4>(a) Parameters for rough fitting</h4>


<ul>
<li> <p><code>rFUN</code>              : character (default <code>smooth_wWHIT</code>), the name of rough
curve fitting function, can be one of <code>c("smooth_wSG", "smooth_wWHIT", "smooth_wHANTS")</code>, which are corresponding to <code><a href="#topic+smooth_wSG">smooth_wSG()</a></code>,
<code><a href="#topic+smooth_wWHIT">smooth_wWHIT()</a></code> and <code><a href="#topic+smooth_wHANTS">smooth_wHANTS()</a></code>.
</p>
</li>
<li> <p><code>wFUN</code>              : character (default <code>wTSM</code>), the name of weights
updating functions, can be one of c(&quot;wTSM&quot;, &quot;wChen&quot;, &quot;wBisquare&quot;,
&quot;wSELF&quot;). See <code><a href="#topic+wTSM">wTSM()</a></code>, <code><a href="#topic+wChen">wChen()</a></code>, <code><a href="#topic+wBisquare">wBisquare()</a></code> and <code><a href="#topic+wSELF">wSELF()</a></code> for
details.
</p>
</li>
<li> <p><code>iters</code>             : integer (default 2), the number of rough fitting
iterations.
</p>
</li>
<li> <p><code>wmin</code>              : double, the minimum weight of bad points (i.e. snow,
ice and cloud).
</p>
</li>
<li> <p><code>verbose</code>           : logical (default <code>FALSE</code>). If <code>TRUE</code>,
<code>options$season</code> will be printed on the console.
</p>
</li>
<li> <p><code>lambda</code>            : double (default NULL), the smoothing parameter of
<code><a href="#topic+smooth_wWHIT">smooth_wWHIT()</a></code>.
</p>

<ul>
<li><p> If <code>lambda = NULL</code>, V-curve theory will be employed to find the
optimal <code>lambda</code>. See <code><a href="#topic+lambda_vcurve">lambda_vcurve()</a></code> for details.
</p>
</li></ul>

</li>
<li> <p><code>frame</code>             : integer (default NULL), the parameter of
<code><a href="#topic+smooth_wSG">smooth_wSG()</a></code>, moving window size.
</p>

<ul>
<li><p> If <code>frame = NULL</code>, <code>frame</code> will be reset as <code>floor(nptperyear/5)*2 +    1</code> (refered by TIMESAT).
</p>
</li></ul>

</li>
<li> <p><code>nf</code>                : integer (default 4), the number of frequencies in
<code><a href="#topic+smooth_wHANTS">smooth_wHANTS()</a></code>.
</p>
</li>
<li> <p><code>maxExtendMonth</code>: integer (default 12), previous and subsequent
<code>maxExtendMonth</code> (in month) data were added to the current year for rough
fitting.
</p>
</li>
<li> <p><code>nextend</code>           : integer (default NULL), same as <code>maxExtendMonth</code>, but
in points.
</p>

<ul>
<li><p> If <code>nextend</code> provided, <code>maxExtendMonth</code> will be ignored.
</p>
</li>
<li><p> If <code>nextend = NULL</code>, <code>nextend</code> will be reset as
<code>ceiling(maxExtendMonth/12*nptperyear)</code>
</p>
</li></ul>

</li></ul>




<h4>(b) Parameters for growing season division</h4>


<ul>
<li> <p><code>minpeakdistance</code>   : double (default NULL), the minimum distance of two
peaks (in points). If the distance of two maximum extreme value less than
<code>minpeakdistance</code>, only the maximum one will be kept.
</p>

<ul>
<li><p> If <code>minpeakdistance = NULL</code>, it will be reset as <code>nptperyear/6</code>.
</p>
</li></ul>

</li>
<li> <p><code>r_max</code>             : double (default 0.2; in (0, 1)). <code>r_max</code> and <code>r_min</code>
are used to eliminate fake peaks and troughs.
</p>

<ul>
<li><p> The real peaks should satisfy:
</p>

<ol>
<li> <p><code class="reqn">max(h_{peak, L}, h_{peak, R}) &gt; r_{max} A</code>
</p>
</li>
<li> <p><code class="reqn">min(h_{peak, L}, h_{peak, R}) &gt; r_{min} A,</code> where <code class="reqn">h_{peak,
     L}, h_{peak, R}</code> are height difference from the peak to the left- and
right-hand troughs.
</p>
</li></ol>

</li>
<li><p> The troughs should satisfy:
</p>

<ol>
<li> <p><code class="reqn">max(h_{trough, L}, h_{trough, R}) &gt; r_{max} A,</code> where
<code class="reqn">h_{trough, L}, h_{trough, R}</code> are height difference from the trough
to the left- and right-hand peaks.
</p>
</li></ol>

</li></ul>

</li>
<li> <p><code>r_min</code>             : double (default 0.05; in (0, 1)), see above <code>r_max</code>
for details. <code>r_min</code> &lt; <code>r_max</code>.
</p>
</li>
<li> <p><code>rtrough_max</code>       : double (default 0.6, in (0, 1)), <code class="reqn">y_{peak} &lt;=
  rtrough_max * A + ylu[1]</code>.
</p>
</li>
<li> <p><code>ypeak_min</code>         : double 0.1 (in VI unit), <code class="reqn">y_{peak} &gt;= ypeak_min</code>.
</p>
</li>
<li> <p><code>.check_season</code>     : logical (default <code>TRUE</code>). check the growing season
length according to <code>len_min</code> and <code>len_max</code>. If <code>FALSE</code>, <code>len_min</code> and
<code>len_max</code> will lose their effect.
</p>
</li>
<li> <p><code>len_min</code>           : integer (default 45), the minimum length (in days) of
growing season
</p>
</li>
<li> <p><code>len_max</code>           : integer (default 650), the minimum length (in days)
of growing season
</p>
</li>
<li> <p><code>adj.param</code>         : logical. If <code>TRUE</code> (default), if there are too many
or too less peaks and troughs, <code>phenofit</code> will automatically adjust rough
curve fitting function parameters. See <code>MaxPeaksPerYear</code> and
<code>MaxTroughsPerYear</code> for details.
</p>
</li>
<li> <p><code>MaxPeaksPerYear</code> (optional)   : integer (default 2), the max number of
peaks per year. If <code>PeaksPerYear</code> &gt; <code>MaxPeaksPerYear</code>, then <code>lambda = lambda*2</code>.
</p>
</li>
<li> <p><code>MaxTroughsPerYear</code> (optional) : integer (default 3), the max number of
troughs per year. If <code>TroughsPerYear</code> &gt; <code>MaxTroughsPerYear</code>, then <code>lambda = lambda*2</code>.
</p>
</li>
<li> <p><code>calendarYear</code>      : logical (default <code>FALSE</code>). If <code>TRUE</code>, the start and
end of a calendar year will be regarded as growing season division (North
Hemisphere is from 01 Jan to 31 Dec; South Hemisphere is from 01 Jul to 30
Jun).
</p>
</li>
<li> <p><code>rm.closed</code>         : logical (default <code>TRUE</code>). If <code>TRUE</code>, closed peaks (or troughs)
will be further tidied. Only the maximum
</p>
</li>
<li> <p><code>is.continuous</code> (not used): logical (default <code>TRUE</code>). This parameter is for
<code>fluxnet2015</code> fluxsite data, where the input might be not continuous.
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+findpeaks">findpeaks()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CA_NS6")
d &lt;- CA_NS6

nptperyear &lt;- 23
INPUT &lt;- check_input(d$t, d$y, d$w,
    QC_flag = d$QC_flag,
    nptperyear = nptperyear, south = FALSE,
    maxgap = nptperyear / 4, alpha = 0.02, wmin = 0.2
)
# plot_input(INPUT)

wFUN &lt;- "wTSM"
# all year as a whole
options = list(rFUN = "smooth_wWHIT", wFUN = wFUN, lambda = 10)
brks &lt;- season(INPUT, lambda = 10)
plot_season(INPUT, brks, d)

brks2 = season_input(INPUT, options)
all.equal(brks2, brks)

c(d_fit, info_peak) %&lt;-% roughFit(INPUT)
d_season = find_season.peaks(d_fit, info_peak)

c(t, ypred) %&lt;-% d_fit[, .(t, ziter2)]
d_season = find_season.default(ypred, t)
all.equal(brks$dt, d_season)

# opt &lt;- .options$season
# brks$fit - d_fit # function passed test

# curve fitting by year
brks_mov &lt;- season_mov(INPUT,
    options = list(
        rFUN = "smooth_wWHIT", wFUN = wFUN,
        lambda = 10,
        r_min = 0.05, ypeak_min = 0.05,
        verbose = TRUE
    )
)
plot_season(INPUT, brks_mov)

rfit &lt;- brks2rfit(brks_mov)
r &lt;- get_pheno(rfit)
</code></pre>

<hr>
<h2 id='season'>Growing season division</h2><span id='topic+season'></span><span id='topic+stat_season'></span>

<h3>Description</h3>

<p>Divide growing seasons according to rough fitting (<code>rFUN</code>) result .
</p>
<p>For <code>season</code>, rough fitting is applied for whole.
For <code>season_mov</code> rough fitting is applied in every year, during which
<code>maxExtendMonth</code> is extended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>season(
  INPUT,
  rFUN,
  wFUN,
  iters = 2,
  wmin = 0.1,
  lambda,
  nf = 3,
  frame = floor(INPUT$nptperyear/5) * 2 + 1,
  minpeakdistance = NULL,
  ypeak_min = 0.1,
  r_max = 0.2,
  r_min = 0.05,
  rtrough_max = 0.6,
  MaxPeaksPerYear = 2,
  MaxTroughsPerYear = 3,
  calendarYear = FALSE,
  adj.param = TRUE,
  rm.closed = TRUE,
  is.continuous = TRUE,
  .check_season = TRUE,
  verbose = FALSE,
  ...
)

stat_season(INPUT, d_fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="season_+3A_input">INPUT</code></td>
<td>
<p>A list object with the elements of <code>t</code>, <code>y</code>, <code>w</code>,
<code>Tn</code> (optional) and <code>ylu</code>, returned by <code><a href="#topic+check_input">check_input()</a></code>.</p>
</td></tr>
<tr><td><code id="season_+3A_rfun">rFUN</code></td>
<td>
<p>character, the name of rough curve fitting function, can be one of
c(&quot;smooth_wSG&quot;, &quot;smooth_wWHIT&quot;, &quot;smooth_wHANTS&quot;), which are corresponding to
<code><a href="#topic+smooth_wSG">smooth_wSG()</a></code>, <code><a href="#topic+smooth_wWHIT">smooth_wWHIT()</a></code> and <code><a href="#topic+smooth_wHANTS">smooth_wHANTS()</a></code>.</p>
</td></tr>
<tr><td><code id="season_+3A_wfun">wFUN</code></td>
<td>
<p>weights updating function, can be one of .</p>
</td></tr>
<tr><td><code id="season_+3A_iters">iters</code></td>
<td>
<p>integer, the number of rough fitting iterations</p>
</td></tr>
<tr><td><code id="season_+3A_wmin">wmin</code></td>
<td>
<p>double, minimum weigth (i.e. weight of snow, ice and cloud).</p>
</td></tr>
<tr><td><code id="season_+3A_lambda">lambda</code></td>
<td>
<p>The smoothing parameter of <code><a href="#topic+smooth_wWHIT">smooth_wWHIT()</a></code>. For
<code><a href="#topic+season_mov">season_mov()</a></code>, if lambda is <code>NULL</code>, <code><a href="#topic+init_lambda">init_lambda()</a></code>
will be used. Generally, it was set as 10000, 15, and 5 for daily, 8-day
and 16-day inputs respectively.</p>
</td></tr>
<tr><td><code id="season_+3A_nf">nf</code></td>
<td>
<p>The parameter of <code><a href="#topic+smooth_wHANTS">smooth_wHANTS()</a></code>, number of frequencies to be
considered above the zero frequency.</p>
</td></tr>
<tr><td><code id="season_+3A_frame">frame</code></td>
<td>
<p>The parameter of <code><a href="#topic+smooth_wSG">smooth_wSG()</a></code>, moving window size. Suggested by
TIMESAT, default <code>frame = floor(nptperyear/7)*2 + 1</code>.</p>
</td></tr>
<tr><td><code id="season_+3A_minpeakdistance">minpeakdistance</code></td>
<td>
<p>double, in points (default as
<code>nptperyear/6</code>). The minimum distance of two peaks. If the distance of two
maximum extreme value less than <code>minpeakdistance</code>, only the real maximum
value will be left.</p>
</td></tr>
<tr><td><code id="season_+3A_ypeak_min">ypeak_min</code></td>
<td>
<p><code>y_peak &gt;= ypeak_min</code></p>
</td></tr>
<tr><td><code id="season_+3A_r_max">r_max</code></td>
<td>
<p>Similar as <code>r_min</code>, The maximum threshold should
be greater than <code>r_max</code>.</p>
</td></tr>
<tr><td><code id="season_+3A_r_min">r_min</code></td>
<td>
<p>Threshold is defined as the difference of peak value with
trough value. There are two threshold (left and right). The minimum threshold
should be greater than r_min.</p>
</td></tr>
<tr><td><code id="season_+3A_rtrough_max">rtrough_max</code></td>
<td>
<p><code>ytrough &lt;= rtrough_max*A</code>, A is the amplitude of y.</p>
</td></tr>
<tr><td><code id="season_+3A_maxpeaksperyear">MaxPeaksPerYear</code></td>
<td>
<p>This parameter is used to adjust lambda in iterations.
If PeaksPerYear &gt; MaxPeaksPerYear, then lambda = lambda*2.</p>
</td></tr>
<tr><td><code id="season_+3A_maxtroughsperyear">MaxTroughsPerYear</code></td>
<td>
<p>This parameter is used to adjust lambda in iterations.
If TroughsPerYear &gt; MaxTroughsPerYear, then lambda = lambda*2.</p>
</td></tr>
<tr><td><code id="season_+3A_calendaryear">calendarYear</code></td>
<td>
<p>If true, only one static calendar growing season will be
returned.</p>
</td></tr>
<tr><td><code id="season_+3A_adj.param">adj.param</code></td>
<td>
<p>,
.</p>
</td></tr>
<tr><td><code id="season_+3A_rm.closed">rm.closed</code></td>
<td>
<p>boolean. Whether check the two closest peaks (or troughs).</p>
</td></tr>
<tr><td><code id="season_+3A_is.continuous">is.continuous</code></td>
<td>
<p>boolean. Whether the input is continuous? This parameter
is for fluxsite site-year data.</p>
</td></tr>
<tr><td><code id="season_+3A_.check_season">.check_season</code></td>
<td>
<p>not used (only for debug)</p>
</td></tr>
<tr><td><code id="season_+3A_verbose">verbose</code></td>
<td>
<p>whether to print <code>options_season</code> into console?</p>
</td></tr>
<tr><td><code id="season_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="season_+3A_d_fit">d_fit</code></td>
<td>
<p>A data.frame with the columns of <code>t</code>, <code>y</code>, <code>witer...</code> and <code>ziter...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before growing season division, <code>INPUT</code> should be added a year in head
and tail first by <code>add_HeadTail</code>.
</p>
<p>Finally, use <code><a href="#topic+findpeaks">findpeaks()</a></code> to get local maximum and local minimum values.
Two local minimum define a growing season.
If two local minimum(maximum) are too closed, then only the smaller(biger)
is left.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>fit</code>: A data.table of Rough fitting result, with the columns of
(<code>t</code>, <code>y</code>, <code>witer1</code>, ..., <code>witerN</code>, <code>ziter1</code>, ..., <code>ziterN</code>).
</p>
</li>
<li> <p><code>dt</code>: A data.table of growing season division information, with the columns
of (<code>beg</code>, <code>peak</code>, <code>end</code>, <code>y_beg</code>, <code>y_peak</code>, <code>y_end</code>, <code>len</code>, <code>year</code>,
<code>season</code>, <code>flag</code>).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+findpeaks">findpeaks()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CA_NS6")
d &lt;- CA_NS6

nptperyear &lt;- 23
INPUT &lt;- check_input(d$t, d$y, d$w,
    QC_flag = d$QC_flag,
    nptperyear = nptperyear, south = FALSE,
    maxgap = nptperyear / 4, alpha = 0.02, wmin = 0.2
)
# plot_input(INPUT)

wFUN &lt;- "wTSM"
# all year as a whole
options = list(rFUN = "smooth_wWHIT", wFUN = wFUN, lambda = 10)
brks &lt;- season(INPUT, lambda = 10)
plot_season(INPUT, brks, d)

brks2 = season_input(INPUT, options)
all.equal(brks2, brks)

c(d_fit, info_peak) %&lt;-% roughFit(INPUT)
d_season = find_season.peaks(d_fit, info_peak)

c(t, ypred) %&lt;-% d_fit[, .(t, ziter2)]
d_season = find_season.default(ypred, t)
all.equal(brks$dt, d_season)

# opt &lt;- .options$season
# brks$fit - d_fit # function passed test

# curve fitting by year
brks_mov &lt;- season_mov(INPUT,
    options = list(
        rFUN = "smooth_wWHIT", wFUN = wFUN,
        lambda = 10,
        r_min = 0.05, ypeak_min = 0.05,
        verbose = TRUE
    )
)
plot_season(INPUT, brks_mov)

rfit &lt;- brks2rfit(brks_mov)
r &lt;- get_pheno(rfit)
</code></pre>

<hr>
<h2 id='season_input'>Growing season division (unstable version)</h2><span id='topic+season_input'></span>

<h3>Description</h3>

<p>Growing season division (unstable version)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>season_input(INPUT, options = NULL, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="season_input_+3A_input">INPUT</code></td>
<td>
<p>A list object with the elements of <code>t</code>, <code>y</code>, <code>w</code>,
<code>Tn</code> (optional) and <code>ylu</code>, returned by <code><a href="#topic+check_input">check_input()</a></code>.</p>
</td></tr>
<tr><td><code id="season_input_+3A_options">options</code></td>
<td>
<p>see the following section <code style="white-space: pre;">&#8288;options for season&#8288;</code> for details.</p>
</td></tr>
<tr><td><code id="season_input_+3A_...">...</code></td>
<td>
<p>others parameter to <code><a href="#topic+set_options">set_options()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='season_mov'>Moving growing season division</h2><span id='topic+season_mov'></span>

<h3>Description</h3>

<p>Moving growing season division
</p>


<h3>Usage</h3>

<pre><code class='language-R'>season_mov(INPUT, options = list(), ..., years.run = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="season_mov_+3A_input">INPUT</code></td>
<td>
<p>A list object with the elements of <code>t</code>, <code>y</code>, <code>w</code>,
<code>Tn</code> (optional) and <code>ylu</code>, returned by <code><a href="#topic+check_input">check_input()</a></code>.</p>
</td></tr>
<tr><td><code id="season_mov_+3A_options">options</code></td>
<td>
<p>see the following section <code style="white-space: pre;">&#8288;options for season&#8288;</code> for details.</p>
</td></tr>
<tr><td><code id="season_mov_+3A_...">...</code></td>
<td>
<p>others parameter to <code><a href="#topic+set_options">set_options()</a></code></p>
</td></tr>
<tr><td><code id="season_mov_+3A_years.run">years.run</code></td>
<td>
<p>Numeric vector. Which years to run? If not specified, it is
all years.</p>
</td></tr>
</table>


<h3>options for season</h3>



<h4>(a) Parameters for rough fitting</h4>


<ul>
<li> <p><code>rFUN</code>              : character (default <code>smooth_wWHIT</code>), the name of rough
curve fitting function, can be one of <code>c("smooth_wSG", "smooth_wWHIT", "smooth_wHANTS")</code>, which are corresponding to <code><a href="#topic+smooth_wSG">smooth_wSG()</a></code>,
<code><a href="#topic+smooth_wWHIT">smooth_wWHIT()</a></code> and <code><a href="#topic+smooth_wHANTS">smooth_wHANTS()</a></code>.
</p>
</li>
<li> <p><code>wFUN</code>              : character (default <code>wTSM</code>), the name of weights
updating functions, can be one of c(&quot;wTSM&quot;, &quot;wChen&quot;, &quot;wBisquare&quot;,
&quot;wSELF&quot;). See <code><a href="#topic+wTSM">wTSM()</a></code>, <code><a href="#topic+wChen">wChen()</a></code>, <code><a href="#topic+wBisquare">wBisquare()</a></code> and <code><a href="#topic+wSELF">wSELF()</a></code> for
details.
</p>
</li>
<li> <p><code>iters</code>             : integer (default 2), the number of rough fitting
iterations.
</p>
</li>
<li> <p><code>wmin</code>              : double, the minimum weight of bad points (i.e. snow,
ice and cloud).
</p>
</li>
<li> <p><code>verbose</code>           : logical (default <code>FALSE</code>). If <code>TRUE</code>,
<code>options$season</code> will be printed on the console.
</p>
</li>
<li> <p><code>lambda</code>            : double (default NULL), the smoothing parameter of
<code><a href="#topic+smooth_wWHIT">smooth_wWHIT()</a></code>.
</p>

<ul>
<li><p> If <code>lambda = NULL</code>, V-curve theory will be employed to find the
optimal <code>lambda</code>. See <code><a href="#topic+lambda_vcurve">lambda_vcurve()</a></code> for details.
</p>
</li></ul>

</li>
<li> <p><code>frame</code>             : integer (default NULL), the parameter of
<code><a href="#topic+smooth_wSG">smooth_wSG()</a></code>, moving window size.
</p>

<ul>
<li><p> If <code>frame = NULL</code>, <code>frame</code> will be reset as <code>floor(nptperyear/5)*2 +    1</code> (refered by TIMESAT).
</p>
</li></ul>

</li>
<li> <p><code>nf</code>                : integer (default 4), the number of frequencies in
<code><a href="#topic+smooth_wHANTS">smooth_wHANTS()</a></code>.
</p>
</li>
<li> <p><code>maxExtendMonth</code>: integer (default 12), previous and subsequent
<code>maxExtendMonth</code> (in month) data were added to the current year for rough
fitting.
</p>
</li>
<li> <p><code>nextend</code>           : integer (default NULL), same as <code>maxExtendMonth</code>, but
in points.
</p>

<ul>
<li><p> If <code>nextend</code> provided, <code>maxExtendMonth</code> will be ignored.
</p>
</li>
<li><p> If <code>nextend = NULL</code>, <code>nextend</code> will be reset as
<code>ceiling(maxExtendMonth/12*nptperyear)</code>
</p>
</li></ul>

</li></ul>




<h4>(b) Parameters for growing season division</h4>


<ul>
<li> <p><code>minpeakdistance</code>   : double (default NULL), the minimum distance of two
peaks (in points). If the distance of two maximum extreme value less than
<code>minpeakdistance</code>, only the maximum one will be kept.
</p>

<ul>
<li><p> If <code>minpeakdistance = NULL</code>, it will be reset as <code>nptperyear/6</code>.
</p>
</li></ul>

</li>
<li> <p><code>r_max</code>             : double (default 0.2; in (0, 1)). <code>r_max</code> and <code>r_min</code>
are used to eliminate fake peaks and troughs.
</p>

<ul>
<li><p> The real peaks should satisfy:
</p>

<ol>
<li> <p><code class="reqn">max(h_{peak, L}, h_{peak, R}) &gt; r_{max} A</code>
</p>
</li>
<li> <p><code class="reqn">min(h_{peak, L}, h_{peak, R}) &gt; r_{min} A,</code> where <code class="reqn">h_{peak,
     L}, h_{peak, R}</code> are height difference from the peak to the left- and
right-hand troughs.
</p>
</li></ol>

</li>
<li><p> The troughs should satisfy:
</p>

<ol>
<li> <p><code class="reqn">max(h_{trough, L}, h_{trough, R}) &gt; r_{max} A,</code> where
<code class="reqn">h_{trough, L}, h_{trough, R}</code> are height difference from the trough
to the left- and right-hand peaks.
</p>
</li></ol>

</li></ul>

</li>
<li> <p><code>r_min</code>             : double (default 0.05; in (0, 1)), see above <code>r_max</code>
for details. <code>r_min</code> &lt; <code>r_max</code>.
</p>
</li>
<li> <p><code>rtrough_max</code>       : double (default 0.6, in (0, 1)), <code class="reqn">y_{peak} &lt;=
  rtrough_max * A + ylu[1]</code>.
</p>
</li>
<li> <p><code>ypeak_min</code>         : double 0.1 (in VI unit), <code class="reqn">y_{peak} &gt;= ypeak_min</code>.
</p>
</li>
<li> <p><code>.check_season</code>     : logical (default <code>TRUE</code>). check the growing season
length according to <code>len_min</code> and <code>len_max</code>. If <code>FALSE</code>, <code>len_min</code> and
<code>len_max</code> will lose their effect.
</p>
</li>
<li> <p><code>len_min</code>           : integer (default 45), the minimum length (in days) of
growing season
</p>
</li>
<li> <p><code>len_max</code>           : integer (default 650), the minimum length (in days)
of growing season
</p>
</li>
<li> <p><code>adj.param</code>         : logical. If <code>TRUE</code> (default), if there are too many
or too less peaks and troughs, <code>phenofit</code> will automatically adjust rough
curve fitting function parameters. See <code>MaxPeaksPerYear</code> and
<code>MaxTroughsPerYear</code> for details.
</p>
</li>
<li> <p><code>MaxPeaksPerYear</code> (optional)   : integer (default 2), the max number of
peaks per year. If <code>PeaksPerYear</code> &gt; <code>MaxPeaksPerYear</code>, then <code>lambda = lambda*2</code>.
</p>
</li>
<li> <p><code>MaxTroughsPerYear</code> (optional) : integer (default 3), the max number of
troughs per year. If <code>TroughsPerYear</code> &gt; <code>MaxTroughsPerYear</code>, then <code>lambda = lambda*2</code>.
</p>
</li>
<li> <p><code>calendarYear</code>      : logical (default <code>FALSE</code>). If <code>TRUE</code>, the start and
end of a calendar year will be regarded as growing season division (North
Hemisphere is from 01 Jan to 31 Dec; South Hemisphere is from 01 Jul to 30
Jun).
</p>
</li>
<li> <p><code>rm.closed</code>         : logical (default <code>TRUE</code>). If <code>TRUE</code>, closed peaks (or troughs)
will be further tidied. Only the maximum
</p>
</li>
<li> <p><code>is.continuous</code> (not used): logical (default <code>TRUE</code>). This parameter is for
<code>fluxnet2015</code> fluxsite data, where the input might be not continuous.
</p>
</li></ul>




<h3>References</h3>


<ol>
<li><p> Kong, D., Zhang, Y., Wang, D., Chen, J., &amp; Gu, X. (2020). Photoperiod
Explains the Asynchronization Between Vegetation Carbon Phenology and
Vegetation Greenness Phenology. Journal of Geophysical Research:
Biogeosciences, 125(8), e2020JG005636.
https://doi.org/10.1029/2020JG005636
</p>
</li>
<li><p> Kong, D., Zhang, Y., Gu, X., &amp; Wang, D. (2019). A robust method for
reconstructing global MODIS EVI time series on the Google Earth Engine.
ISPRS Journal of Photogrammetry and Remote Sensing, 155, 13-24.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+season">season()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CA_NS6")
d &lt;- CA_NS6

nptperyear &lt;- 23
INPUT &lt;- check_input(d$t, d$y, d$w,
    QC_flag = d$QC_flag,
    nptperyear = nptperyear, south = FALSE,
    maxgap = nptperyear / 4, alpha = 0.02, wmin = 0.2
)

# curve fitting by year
brks_mov &lt;- season_mov(INPUT,
    options = list(
        rFUN = "smooth_wWHIT", wFUN = "wTSM",
        lambda = 10,
        r_min = 0.05, ypeak_min = 0.05,
        verbose = TRUE
    )
)
plot_season(INPUT, brks_mov)

rfit &lt;- brks2rfit(brks_mov)
# Phenological Metrics from rough fitting
r &lt;- get_pheno(rfit)
</code></pre>

<hr>
<h2 id='set_options'>set and get phenofit option</h2><span id='topic+set_options'></span><span id='topic+get_options'></span>

<h3>Description</h3>

<p>set and get phenofit option
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_options(..., options = NULL)

get_options(names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_options_+3A_...">...</code></td>
<td>
<p>list of phenofit options FUN_season: character, <code>season_mov</code> or
<code>season</code> rFUN: character, rough fitting function. <code>smooth_wWHIT</code>,
<code>smooth_wSG</code> or <code>smooth_wHANTs</code>.</p>
</td></tr>
<tr><td><code id="set_options_+3A_options">options</code></td>
<td>
<p>If not NULL, <code>options</code> will overwrite the default parameters
(<code>get_options()</code>).
</p>

<ul>
<li> <p><code>qcFUN</code>      : function to process qc flag, see <code><a href="#topic+qcFUN">qcFUN()</a></code> for details.
</p>
</li>
<li> <p><code>nptperyear</code> : Integer, number of images per year.
</p>
</li>
<li> <p><code>wFUN</code>       : character (default <code>wTSM</code>), the name of weights updating
functions, can be one of c(&quot;wTSM&quot;, &quot;wChen&quot;, &quot;wBisquare&quot;, &quot;wSELF&quot;). See
<code><a href="#topic+wTSM">wTSM()</a></code>, <code><a href="#topic+wChen">wChen()</a></code>, <code><a href="#topic+wBisquare">wBisquare()</a></code> and <code><a href="#topic+wSELF">wSELF()</a></code> for details.
</p>

<ul>
<li><p> If <code>options$season$wFUN</code> or <code>options$season$wFUN</code> is <code>NULL</code>, the
<code>options$wFUN</code> will overwrite it.
</p>
</li></ul>

</li>
<li> <p><code>wmin</code>       : double, the minimum weigth of bads points (i.e. snow, ice
and cloud).
</p>

<ul>
<li><p> If <code>options$season$wmin</code> or <code>options$season$wmin</code> is <code>NULL</code>, the
<code>options$wmin</code> will overwrite it.
</p>
</li></ul>

</li>
<li> <p><code>season</code>     : See the following part: options for season for details.
</p>
</li>
<li> <p><code>fitting</code>    : See the following part: options for fitting for details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="set_options_+3A_names">names</code></td>
<td>
<p>vector of character, names of options</p>
</td></tr>
</table>


<h3>options for season</h3>



<h4>(a) Parameters for rough fitting</h4>


<ul>
<li> <p><code>rFUN</code>              : character (default <code>smooth_wWHIT</code>), the name of rough
curve fitting function, can be one of <code>c("smooth_wSG", "smooth_wWHIT", "smooth_wHANTS")</code>, which are corresponding to <code><a href="#topic+smooth_wSG">smooth_wSG()</a></code>,
<code><a href="#topic+smooth_wWHIT">smooth_wWHIT()</a></code> and <code><a href="#topic+smooth_wHANTS">smooth_wHANTS()</a></code>.
</p>
</li>
<li> <p><code>wFUN</code>              : character (default <code>wTSM</code>), the name of weights
updating functions, can be one of c(&quot;wTSM&quot;, &quot;wChen&quot;, &quot;wBisquare&quot;,
&quot;wSELF&quot;). See <code><a href="#topic+wTSM">wTSM()</a></code>, <code><a href="#topic+wChen">wChen()</a></code>, <code><a href="#topic+wBisquare">wBisquare()</a></code> and <code><a href="#topic+wSELF">wSELF()</a></code> for
details.
</p>
</li>
<li> <p><code>iters</code>             : integer (default 2), the number of rough fitting
iterations.
</p>
</li>
<li> <p><code>wmin</code>              : double, the minimum weight of bad points (i.e. snow,
ice and cloud).
</p>
</li>
<li> <p><code>verbose</code>           : logical (default <code>FALSE</code>). If <code>TRUE</code>,
<code>options$season</code> will be printed on the console.
</p>
</li>
<li> <p><code>lambda</code>            : double (default NULL), the smoothing parameter of
<code><a href="#topic+smooth_wWHIT">smooth_wWHIT()</a></code>.
</p>

<ul>
<li><p> If <code>lambda = NULL</code>, V-curve theory will be employed to find the
optimal <code>lambda</code>. See <code><a href="#topic+lambda_vcurve">lambda_vcurve()</a></code> for details.
</p>
</li></ul>

</li>
<li> <p><code>frame</code>             : integer (default NULL), the parameter of
<code><a href="#topic+smooth_wSG">smooth_wSG()</a></code>, moving window size.
</p>

<ul>
<li><p> If <code>frame = NULL</code>, <code>frame</code> will be reset as <code>floor(nptperyear/5)*2 +    1</code> (refered by TIMESAT).
</p>
</li></ul>

</li>
<li> <p><code>nf</code>                : integer (default 4), the number of frequencies in
<code><a href="#topic+smooth_wHANTS">smooth_wHANTS()</a></code>.
</p>
</li>
<li> <p><code>maxExtendMonth</code>: integer (default 12), previous and subsequent
<code>maxExtendMonth</code> (in month) data were added to the current year for rough
fitting.
</p>
</li>
<li> <p><code>nextend</code>           : integer (default NULL), same as <code>maxExtendMonth</code>, but
in points.
</p>

<ul>
<li><p> If <code>nextend</code> provided, <code>maxExtendMonth</code> will be ignored.
</p>
</li>
<li><p> If <code>nextend = NULL</code>, <code>nextend</code> will be reset as
<code>ceiling(maxExtendMonth/12*nptperyear)</code>
</p>
</li></ul>

</li></ul>




<h4>(b) Parameters for growing season division</h4>


<ul>
<li> <p><code>minpeakdistance</code>   : double (default NULL), the minimum distance of two
peaks (in points). If the distance of two maximum extreme value less than
<code>minpeakdistance</code>, only the maximum one will be kept.
</p>

<ul>
<li><p> If <code>minpeakdistance = NULL</code>, it will be reset as <code>nptperyear/6</code>.
</p>
</li></ul>

</li>
<li> <p><code>r_max</code>             : double (default 0.2; in (0, 1)). <code>r_max</code> and <code>r_min</code>
are used to eliminate fake peaks and troughs.
</p>

<ul>
<li><p> The real peaks should satisfy:
</p>

<ol>
<li> <p><code class="reqn">max(h_{peak, L}, h_{peak, R}) &gt; r_{max} A</code>
</p>
</li>
<li> <p><code class="reqn">min(h_{peak, L}, h_{peak, R}) &gt; r_{min} A,</code> where <code class="reqn">h_{peak,
     L}, h_{peak, R}</code> are height difference from the peak to the left- and
right-hand troughs.
</p>
</li></ol>

</li>
<li><p> The troughs should satisfy:
</p>

<ol>
<li> <p><code class="reqn">max(h_{trough, L}, h_{trough, R}) &gt; r_{max} A,</code> where
<code class="reqn">h_{trough, L}, h_{trough, R}</code> are height difference from the trough
to the left- and right-hand peaks.
</p>
</li></ol>

</li></ul>

</li>
<li> <p><code>r_min</code>             : double (default 0.05; in (0, 1)), see above <code>r_max</code>
for details. <code>r_min</code> &lt; <code>r_max</code>.
</p>
</li>
<li> <p><code>rtrough_max</code>       : double (default 0.6, in (0, 1)), <code class="reqn">y_{peak} &lt;=
  rtrough_max * A + ylu[1]</code>.
</p>
</li>
<li> <p><code>ypeak_min</code>         : double 0.1 (in VI unit), <code class="reqn">y_{peak} &gt;= ypeak_min</code>.
</p>
</li>
<li> <p><code>.check_season</code>     : logical (default <code>TRUE</code>). check the growing season
length according to <code>len_min</code> and <code>len_max</code>. If <code>FALSE</code>, <code>len_min</code> and
<code>len_max</code> will lose their effect.
</p>
</li>
<li> <p><code>len_min</code>           : integer (default 45), the minimum length (in days) of
growing season
</p>
</li>
<li> <p><code>len_max</code>           : integer (default 650), the minimum length (in days)
of growing season
</p>
</li>
<li> <p><code>adj.param</code>         : logical. If <code>TRUE</code> (default), if there are too many
or too less peaks and troughs, <code>phenofit</code> will automatically adjust rough
curve fitting function parameters. See <code>MaxPeaksPerYear</code> and
<code>MaxTroughsPerYear</code> for details.
</p>
</li>
<li> <p><code>MaxPeaksPerYear</code> (optional)   : integer (default 2), the max number of
peaks per year. If <code>PeaksPerYear</code> &gt; <code>MaxPeaksPerYear</code>, then <code>lambda = lambda*2</code>.
</p>
</li>
<li> <p><code>MaxTroughsPerYear</code> (optional) : integer (default 3), the max number of
troughs per year. If <code>TroughsPerYear</code> &gt; <code>MaxTroughsPerYear</code>, then <code>lambda = lambda*2</code>.
</p>
</li>
<li> <p><code>calendarYear</code>      : logical (default <code>FALSE</code>). If <code>TRUE</code>, the start and
end of a calendar year will be regarded as growing season division (North
Hemisphere is from 01 Jan to 31 Dec; South Hemisphere is from 01 Jul to 30
Jun).
</p>
</li>
<li> <p><code>rm.closed</code>         : logical (default <code>TRUE</code>). If <code>TRUE</code>, closed peaks (or troughs)
will be further tidied. Only the maximum
</p>
</li>
<li> <p><code>is.continuous</code> (not used): logical (default <code>TRUE</code>). This parameter is for
<code>fluxnet2015</code> fluxsite data, where the input might be not continuous.
</p>
</li></ul>




<h3>options for fitting</h3>


<ul>
<li> <p><code>methods</code> (default <code style="white-space: pre;">&#8288;c('AG', 'Beck', 'Elmore', 'Zhang')``): Fine curve fitting methods, can be one or more of &#8288;</code>c('AG', 'Beck', 'Elmore', 'Zhang',
'Gu', 'Klos')&lsquo;. Note that &rsquo;Gu' and 'Klos' are very slow.
</p>
</li>
<li> <p><code>iters</code> (default 2): max iterations of fine fitting.
</p>
</li>
<li> <p><code>wFUN</code> (default <code>wTSM</code>): Character or function, weights updating function
of fine fitting function.
</p>
</li>
<li> <p><code>wmin</code> (default 0.1): min weights in the weights updating procedure.
</p>
</li>
<li> <p><code>use.rough</code> (default FALSE): Whether to use rough fitting smoothed
time-series as input? If <code>false</code>, smoothed VI by rough fitting will be used
for Phenological metrics extraction; If <code>true</code>, original input <code>y</code> will be
used (rough fitting is used to divide growing seasons and update weights.
</p>
</li>
<li> <p><code>use.y0</code> (default TRUE): boolean. whether to use original <code>y0</code> as the input
of <code>plot_input</code>, note that not for curve fitting. <code>y0</code> is the original
value before the process of <code>check_input</code>.
</p>
</li>
<li> <p><code>nextend</code> (default 2): Extend curve fitting window, until <code>nextend</code> good or
marginal points are found in the previous and subsequent growing season.
</p>
</li>
<li> <p><code>maxExtendMonth</code> (default 1): Search good or marginal good values in
previous and subsequent <code>maxExtendMonth</code> period.
</p>
</li>
<li> <p><code>minExtendMonth</code> (default 0.5): Extend period defined by <code>nextend</code> and
<code>maxExtendMonth</code>, should be no shorter than <code>minExtendMonth</code>. When all
points of the input time-series are good value, then the extending period
will be too short. In that situation, we can't make sure the connection
between different growing seasons is smoothing.
</p>
</li>
<li> <p><code>minPercValid</code>: (default 0, not use). If the percentage of good- and
marginal- quality points is less than <code>minPercValid</code>, curve fiting result is
set to <code>NA</code>.
</p>
</li>
<li> <p><code>minT</code>: (not use). If <code>Tn</code> not provided in <code>INPUT</code>, <code>minT</code> will
not be used. <code>minT</code> use night temperature Tn to define backgroud value
(days with <code>Tn &lt; minT</code> treated as ungrowing season).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set_options(verbose = FALSE) 
get_options("season") %&gt;% str()
</code></pre>

<hr>
<h2 id='smooth_wHANTS'>Weighted HANTS SMOOTH</h2><span id='topic+smooth_wHANTS'></span>

<h3>Description</h3>

<p>Weighted HANTS smoother
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_wHANTS(
  y,
  t,
  w,
  nf = 3,
  ylu,
  periodlen = 365,
  nptperyear,
  wFUN = wTSM,
  iters = 2,
  wmin = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_wHANTS_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_t">t</code></td>
<td>
<p>Numeric vector, <code>Date</code> variable</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_nf">nf</code></td>
<td>
<p>number of frequencies to be considered above the zero frequency</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_ylu">ylu</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[low, high]&#8288;</code> of time-series y (curve fitting values are constrained
in the range of <code>ylu</code>.</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_periodlen">periodlen</code></td>
<td>
<p>length of the base period, measured in virtual samples
(days, dekads, months, etc.). nptperyear in timesat.</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_nptperyear">nptperyear</code></td>
<td>
<p>Integer, number of images per year.</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_wfun">wFUN</code></td>
<td>
<p>weights updating function, can be one of 'wTSM', 'wChen' and
'wBisquare'.</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_iters">iters</code></td>
<td>
<p>How many times curve fitting is implemented.</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_wmin">wmin</code></td>
<td>
<p>Double, minimum weigth (i.e. weight of snow, ice and cloud).</p>
</td></tr>
<tr><td><code id="smooth_wHANTS_+3A_...">...</code></td>
<td>
<p>Additional parameters are passed to <code>wFUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>ws</code>: weights of every iteration
</p>
</li>
<li> <p><code>zs</code>: curve fittings of every iteration
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wout Verhoef, NLR, Remote Sensing Dept. June 1998
Mohammad Abouali (2011), Converted to MATLAB
Dongdong Kong (2018), introduced to R and modified into weighted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
data("MOD13A1")
dt &lt;- tidy_MOD13(MOD13A1$dt)
d &lt;- dt[site == "AT-Neu", ]

l &lt;- check_input(d$t, d$y, d$w, nptperyear=23)
r_wHANTS &lt;- smooth_wHANTS(l$y, l$t, l$w, ylu = l$ylu, nptperyear = 23, iters = 2)
</code></pre>

<hr>
<h2 id='smooth_wSG'>Weighted Savitzky-Golay</h2><span id='topic+smooth_wSG'></span>

<h3>Description</h3>

<p>Weighted Savitzky-Golay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_wSG(
  y,
  w,
  nptperyear,
  ylu,
  wFUN = wTSM,
  iters = 2,
  frame = floor(nptperyear/5) * 2 + 1,
  d = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_wSG_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_nptperyear">nptperyear</code></td>
<td>
<p>Integer, number of images per year.</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_ylu">ylu</code></td>
<td>
<p>(optional) <code style="white-space: pre;">&#8288;[low, high]&#8288;</code> value of time-series y (curve fitting values
are constrained in the range of ylu.</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_wfun">wFUN</code></td>
<td>
<p>weights updating function, can be one of 'wTSM', 'wChen' and
'wBisquare'.</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_iters">iters</code></td>
<td>
<p>How many times curve fitting is implemented.</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_frame">frame</code></td>
<td>
<p>Savitzky-Golay windows size</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_d">d</code></td>
<td>
<p>polynomial of degree. When d = 1, it becomes moving average.</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_...">...</code></td>
<td>
<p>Additional parameters are passed to <code>wFUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>ws</code>: weights of every iteration
</p>
</li>
<li> <p><code>zs</code>: curve fittings of every iteration
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> Chen, J., J\&quot;onsson, P., Tamura, M., Gu, Z., Matsushita, B., Eklundh, L.,
2004. A simple method for reconstructing a high-quality NDVI time-series
data set based on the Savitzky-Golay filter. Remote Sens. Environ. 91,
332-344. https://doi.org/10.1016/j.rse.2004.03.014. <br />
</p>
</li>
<li><p> https://en.wikipedia.org/wiki/Savitzky%E2%80%93Golay_filter
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
data("MOD13A1")
dt &lt;- tidy_MOD13(MOD13A1$dt)
d &lt;- dt[site == "AT-Neu", ]

l &lt;- check_input(d$t, d$y, d$w, nptperyear=23)
r_wSG &lt;- smooth_wSG(l$y, l$w, l$ylu, nptperyear = 23, iters = 2)
</code></pre>

<hr>
<h2 id='smooth_wWHIT'>Weigthed Whittaker Smoother</h2><span id='topic+smooth_wWHIT'></span>

<h3>Description</h3>

<p>Weigthed Whittaker Smoother
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_wWHIT(
  y,
  w,
  ylu,
  nptperyear,
  wFUN = wTSM,
  iters = 1,
  lambda = 15,
  second = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_wWHIT_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="smooth_wWHIT_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="smooth_wWHIT_+3A_ylu">ylu</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[low, high]&#8288;</code> of time-series y (curve fitting values are constrained
in the range of <code>ylu</code>.</p>
</td></tr>
<tr><td><code id="smooth_wWHIT_+3A_nptperyear">nptperyear</code></td>
<td>
<p>Integer, number of images per year.</p>
</td></tr>
<tr><td><code id="smooth_wWHIT_+3A_wfun">wFUN</code></td>
<td>
<p>weights updating function, can be one of 'wTSM', 'wChen' and
'wBisquare'.</p>
</td></tr>
<tr><td><code id="smooth_wWHIT_+3A_iters">iters</code></td>
<td>
<p>How many times curve fitting is implemented.</p>
</td></tr>
<tr><td><code id="smooth_wWHIT_+3A_lambda">lambda</code></td>
<td>
<p>scaler or numeric vector, whittaker parameter.
</p>

<ul>
<li><p> If <code>lambda = NULL</code>, <code>V-curve</code> theory will be applied to retrieve the optimal <code>lambda</code>.
</p>
</li>
<li><p> If multiple <code>lambda</code> provided (numeric vector), a list of the smoothing results
with the same length of <code>lambda</code> will be returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="smooth_wWHIT_+3A_second">second</code></td>
<td>
<p>If true, in every iteration, Whittaker will be implemented
twice to make sure curve fitting is smooth. If curve has been smoothed
enough, it will not care about the second smooth. If no, the second one is
just prepared for this situation. If lambda value has been optimized, second
smoothing is unnecessary.</p>
</td></tr>
<tr><td><code id="smooth_wWHIT_+3A_...">...</code></td>
<td>
<p>Additional parameters are passed to <code>wFUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>ws</code>: weights of every iteration
</p>
</li>
<li> <p><code>zs</code>: curve fittings of every iteration
</p>
</li></ul>



<h3>Note</h3>

<p>Whittaker smoother of the second order difference is used!
</p>


<h3>References</h3>


<ol>
<li><p> Eilers, P.H.C., 2003. A perfect smoother. Anal. Chem. <a href="https://doi.org/10.1021/ac034173t">doi:10.1021/ac034173t</a>
</p>
</li>
<li><p> Frasso, G., Eilers, P.H.C., 2015. L- and V-curves for optimal smoothing. Stat.
Modelling 15, 91-111. <a href="https://doi.org/10.1177/1471082X14549288">doi:10.1177/1471082X14549288</a>.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+lambda_vcurve">lambda_vcurve()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("MOD13A1")
dt &lt;- tidy_MOD13(MOD13A1$dt)
d &lt;- dt[site == "AT-Neu", ]

l &lt;- check_input(d$t, d$y, d$w, nptperyear=23)
r_wWHIT &lt;- smooth_wWHIT(l$y, l$w, l$ylu, nptperyear = 23, iters = 2)

## Optimize `lambda` by V-curve theory
# (a) optimize manually
lambda_vcurve(l$y, l$w, plot = TRUE) 

# (b) optimize automatically by setting `lambda = NULL` in smooth_wWHIT
r_wWHIT2 &lt;- smooth_wWHIT(l$y, l$w, l$ylu, nptperyear = 23, iters = 2, lambda = NULL) # 
</code></pre>

<hr>
<h2 id='tidy_MOD13'>tidy_MOD13</h2><span id='topic+tidy_MOD13'></span>

<h3>Description</h3>

<p>Tidy MODIS 'MOD13' VI products' (e.g. MOD13A1, MOD13A2, ...) raw data exported from
Google Earth Engine.
Tidy contents include: <br />
</p>

<ol>
<li><p> add exact compositing date, see <code><a href="#topic+getRealDate">getRealDate()</a></code>. <br />
</p>
</li>
<li><p> Init weigths according <code>SummaryQA</code>, see <code><a href="#topic+qc_summary">qc_summary()</a></code>. <br />
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>tidy_MOD13(infile, outfile, wmin = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_MOD13_+3A_infile">infile</code></td>
<td>
<p>A character csv file path or a data.table</p>
</td></tr>
<tr><td><code id="tidy_MOD13_+3A_outfile">outfile</code></td>
<td>
<p>Output file name. If missing, will not be written to file.</p>
</td></tr>
<tr><td><code id="tidy_MOD13_+3A_wmin">wmin</code></td>
<td>
<p>Double, minimum weight of bad points, which could be smaller
the weight of snow, ice and cloud.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidied data.table, with columns of 'site', 'y', 't', 'w', 'date' and
'SummaryQA'.
</p>

<ul>
<li> <p><code>site</code>: site name
</p>
</li>
<li> <p><code>y</code>: real value of EVI, <code style="white-space: pre;">&#8288;[-1, 1]&#8288;</code>
</p>
</li>
<li> <p><code>date</code>: image date
</p>
</li>
<li> <p><code>t</code>: exact compositing date constructed from <code>DayOfYear</code>
</p>
</li>
<li> <p><code>w</code>: weights
</p>
</li>
<li> <p><code>SummaryQA</code>: A factor, QA types, one of &quot;good&quot;, &quot;margin&quot;, &quot;snow/ice&quot;
or &quot;cloud&quot;.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
data("MOD13A1")
dt &lt;- tidy_MOD13(MOD13A1$dt)
</code></pre>

<hr>
<h2 id='tidy_pheno'>tidy_pheno</h2><span id='topic+tidy_pheno'></span><span id='topic+date2doy'></span><span id='topic+doy2date'></span>

<h3>Description</h3>

<p>Tidy for every method with multiple years phenology data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_pheno(pheno)

date2doy(p_date)

doy2date(p_doy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_pheno_+3A_pheno">pheno</code></td>
<td>
<p>Phenology metrics extracted from <code>get_pheno</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
# simulate vegetation time-series
fFUN &lt;- doubleLog.Beck
par &lt;- c(mn = 0.1, mx = 0.7, sos = 50, rsp = 0.1, eos = 250, rau = 0.1)

t &lt;- seq(1, 365, 8)
tout &lt;- seq(1, 365, 1)
y &lt;- fFUN(par, t)

methods &lt;- c("AG", "Beck", "Elmore", "Gu", "Zhang") # "Klos" too slow
fFITs &lt;- curvefit(y, t, tout, methods)

# multiple years
fits &lt;- list(`2001` = fFITs, `2002` = fFITs)
pheno &lt;- get_pheno(fits, "AG", IsPlot = FALSE)
</code></pre>

<hr>
<h2 id='v_curve'>V-curve theory to optimize Whittaker parameter <code>lambda</code>.</h2><span id='topic+v_curve'></span>

<h3>Description</h3>

<p>V-curve is used to optimize Whittaker parameter <code>lambda</code>.
This function is not for users!!!
</p>
<p>Update 20180605 add weights updating to whittaker lambda selecting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v_curve(INPUT, lg_lambdas = seq(0, 5, by = 0.005), plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v_curve_+3A_input">INPUT</code></td>
<td>
<p>A list object with the elements of <code>t</code>, <code>y</code>, <code>w</code>,
<code>Tn</code> (optional) and <code>ylu</code>, returned by <code><a href="#topic+check_input">check_input()</a></code>.</p>
</td></tr>
<tr><td><code id="v_curve_+3A_lg_lambdas">lg_lambdas</code></td>
<td>
<p>numeric vector, log10(lambda) candidates. The optimal <code>lambda</code>
will be optimized from <code>lg_lambda</code>.</p>
</td></tr>
<tr><td><code id="v_curve_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, the optimized <code>lambda</code> will be printed on the
console.</p>
</td></tr>
<tr><td><code id="v_curve_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>lambda_vcurve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CA_NS6"); d = CA_NS6
nptperyear = 23
INPUT &lt;- check_input(d$t, d$y, d$w, nptperyear = nptperyear,
    maxgap = nptperyear/4, alpha = 0.02, wmin = 0.2)

r &lt;- v_curve(INPUT, lg_lambdas = seq(0, 3, 0.1), plot = TRUE)
</code></pre>

<hr>
<h2 id='whit2'>Weighted Whittaker smoothing with a second order finite difference penalty</h2><span id='topic+whit2'></span>

<h3>Description</h3>

<p>This function smoothes signals with a finite difference penalty of order 2.
This function is modified from <code>ptw</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whit2(y, lambda, w = rep(1, ny))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whit2_+3A_y">y</code></td>
<td>
<p>signal to be smoothed: a vector</p>
</td></tr>
<tr><td><code id="whit2_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter: larger values lead to more smoothing</p>
</td></tr>
<tr><td><code id="whit2_+3A_w">w</code></td>
<td>
<p>weights: a vector of same length as y. Default weights are equal to one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, smoothed signal.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers, Jan Gerretzen
</p>


<h3>References</h3>


<ol>
<li><p> Eilers, P.H.C. (2004) &quot;Parametric Time Warping&quot;, Analytical Chemistry,
<strong>76</strong> (2), 404 &ndash; 411. <br />
</p>
</li>
<li><p> Eilers, P.H.C. (2003) &quot;A perfect smoother&quot;, Analytical Chemistry,
<strong>75</strong>, 3631 &ndash; 3636.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(phenofit)
data("MOD13A1")
dt &lt;- tidy_MOD13(MOD13A1$dt)
y &lt;- dt[site == "AT-Neu", ][1:120, y]

plot(y, type = "b")
lines(whit2(y, lambda = 2), col = 2)
lines(whit2(y, lambda = 10), col = 3)
lines(whit2(y, lambda = 100), col = 4)
legend("bottomleft", paste("lambda = ", c(2, 10, 15)), col = 2:4, lty = rep(1, 3))
</code></pre>

<hr>
<h2 id='wSELF'>Weight updating functions</h2><span id='topic+wSELF'></span><span id='topic+wTSM'></span><span id='topic+wBisquare0'></span><span id='topic+wBisquare'></span><span id='topic+wChen'></span><span id='topic+wKong'></span>

<h3>Description</h3>


<ul>
<li> <p><code>wSELF</code> weigth are not changed and return the original.
</p>
</li>
<li> <p><code>wTSM</code> weight updating method in TIMESAT.
</p>
</li>
<li> <p><code>wBisquare</code> Bisquare weight update method. wBisquare has been
modified to emphasis on upper envelope.
</p>
</li>
<li> <p><code>wBisquare0</code> Traditional Bisquare weight update method.
</p>
</li>
<li> <p><code>wChen</code> Chen et al., (2004) weight updating method.
</p>
</li>
<li> <p><code>wBeck</code> Beck et al., (2006) weigth updating method. wBeck need
sos and eos input. The function parameter is different from others. It is
still not finished.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>wSELF(y, yfit, w, ...)

wTSM(y, yfit, w, iter = 2, nptperyear, wfact = 0.5, ...)

wBisquare0(y, yfit, w, ..., wmin = 0.2)

wBisquare(y, yfit, w, ..., wmin = 0.2, .toUpper = TRUE)

wChen(y, yfit, w, ..., wmin = 0.2)

wKong(y, yfit, w, ..., wmin = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wSELF_+3A_y">y</code></td>
<td>
<p>Numeric vector, vegetation index time-series</p>
</td></tr>
<tr><td><code id="wSELF_+3A_yfit">yfit</code></td>
<td>
<p>Numeric vector curve fitting values.</p>
</td></tr>
<tr><td><code id="wSELF_+3A_w">w</code></td>
<td>
<p>(optional) Numeric vector, weights of <code>y</code>. If not specified,
weights of all <code>NA</code> values will be <code>wmin</code>, the others will be 1.0.</p>
</td></tr>
<tr><td><code id="wSELF_+3A_...">...</code></td>
<td>
<p>other parameters are ignored.</p>
</td></tr>
<tr><td><code id="wSELF_+3A_iter">iter</code></td>
<td>
<p>iteration of curve fitting.</p>
</td></tr>
<tr><td><code id="wSELF_+3A_nptperyear">nptperyear</code></td>
<td>
<p>Integer, number of images per year.</p>
</td></tr>
<tr><td><code id="wSELF_+3A_wfact">wfact</code></td>
<td>
<p>weight adaptation factor (0-1), equal to the reciprocal of
'Adaptation strength' in TIMESAT.</p>
</td></tr>
<tr><td><code id="wSELF_+3A_wmin">wmin</code></td>
<td>
<p>Double, minimum weight of bad points, which could be smaller
the weight of snow, ice and cloud.</p>
</td></tr>
<tr><td><code id="wSELF_+3A_.toupper">.toUpper</code></td>
<td>
<p>Boolean. Whether to approach the upper envelope?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wnew Numeric Vector, adjusted weights.
</p>


<h3>Author(s)</h3>

<p>wTSM is implemented by Per J\&quot;onsson, Malm\&quot;o University, Sweden
<a href="mailto:per.jonsson@ts.mah.se">per.jonsson@ts.mah.se</a> and Lars Eklundh, Lund University, Sweden
<a href="mailto:lars.eklundh@nateko.lu.se">lars.eklundh@nateko.lu.se</a>.
And Translated into Rcpp by Dongdong Kong, 01 May 2018.
</p>


<h3>References</h3>


<ol>
<li><p> Per J\&quot;onsson, P., Eklundh, L., 2004. TIMESAT - A program for analyzing
time-series of satellite sensor data. Comput. Geosci. 30, 833-845.
https://doi.org/10.1016/j.cageo.2004.05.006. <br />
</p>
</li>
<li><p> https://au.mathworks.com/help/curvefit/smoothing-data.html#bq_6ys3-3 <br />
</p>
</li>
<li><p> Garcia, D., 2010. Robust smoothing of gridded data in one and higher
dimensions with missing values. Computational statistics &amp; data analysis,
54(4), pp.1167-1178. <br />
</p>
</li>
<li><p> Chen, J., J\&quot;onsson, P., Tamura, M., Gu, Z., Matsushita, B., Eklundh, L.,
2004. A simple method for reconstructing a high-quality NDVI time-series
data set based on the Savitzky-Golay filter. Remote Sens. Environ. 91,
332-344. https://doi.org/10.1016/j.rse.2004.03.014. <br />
</p>
</li>
<li><p> Beck, P.S.A., Atzberger, C., Hogda, K.A., Johansen, B., Skidmore, A.K.,
2006. Improved monitoring of vegetation dynamics at very high latitudes:
A new method using MODIS NDVI. Remote Sens. Environ.
https://doi.org/10.1016/j.rse.2005.10.021 <br />
</p>
</li>
<li><p> https://github.com/kongdd/phenopix/blob/master/R/FitDoubleLogBeck.R
</p>
</li></ol>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
