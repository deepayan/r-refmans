<!DOCTYPE html><html><head><title>Help for package nlraa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nlraa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#barley'><p>Barley response to nitrogen fertilizer</p></a></li>
<li><a href='#boot_lm'><p>Bootstrapping for linear models</p></a></li>
<li><a href='#boot_lme'><p>Bootstraping for linear mixed models</p></a></li>
<li><a href='#boot_nlme'><p>Bootstraping for generalized nonlinear models and nonlinear mixed models</p></a></li>
<li><a href='#boot_nls'><p>Bootstrapping for nonlinear models</p></a></li>
<li><a href='#fm1.P.at.x.0.4'><p>object for confidence bands vignette fm1.P.at.x.0.4</p></a></li>
<li><a href='#fm1.P.bt'><p>object for confidence bands vignette fm1.P.bt</p></a></li>
<li><a href='#fm1.P.bt.ft'><p>object for confidence bands vignette fm1.P.bt.ft</p></a></li>
<li><a href='#fm2.Lob.bt'><p>object for confidence bands vignette fm2.Lob.bt</p></a></li>
<li><a href='#fmm1.bt'><p>object for confidence bands vignette fmm1.bt</p></a></li>
<li><a href='#IA_tab'><p>Indexes of Agreement Table</p></a></li>
<li><a href='#IC_tab'><p>Information Criteria Table</p></a></li>
<li><a href='#lfmc'><p>Live fuel moisture content</p></a></li>
<li><a href='#Lob.bt.pe'><p>object for confidence bands vignette Lob.bt.pe</p></a></li>
<li><a href='#maizeleafext'><p>Maize leaf extension rate as a response to temperature</p></a></li>
<li><a href='#nlraa.env'><p>Environment to store options and data for nlraa</p></a></li>
<li><a href='#nlsLMList'><p>Create a list of nls objects with the option of using nlsLM in addition to nls</p></a></li>
<li><a href='#nlsLMList.formula'><p>Formula method for nls &lsquo;LM&rsquo; list method</p></a></li>
<li><a href='#predict_gam'><p>Modified prediciton function based on predict.gam</p></a></li>
<li><a href='#predict_nlme'><p>Average predictions from several (non)linear models based on IC weights</p></a></li>
<li><a href='#predict_nls'><p>Average predictions from several (non)linear models based on IC weights</p></a></li>
<li><a href='#predict2_nls'><p>Prediction Bands for Nonlinear Regression</p></a></li>
<li><a href='#print_boot'><p>Print an object of class <code>boot</code></p></a></li>
<li><a href='#R2M'><p>R-squared for nonlinear mixed models</p></a></li>
<li><a href='#simulate_gam'><p>Simulate responses from a generalized additive linear model <code>gam</code></p></a></li>
<li><a href='#simulate_gls'><p>Simulate fitted values from an object of class <code>gls</code></p></a></li>
<li><a href='#simulate_gnls'><p>Simulate fitted values from an object of class <code>gnls</code></p></a></li>
<li><a href='#simulate_lm'><p>Simulate responses from a linear model <code>lm</code></p></a></li>
<li><a href='#simulate_lme'><p>Simulate values from an object of class <code>lme</code></p></a></li>
<li><a href='#simulate_nlme'><p>Simulate samples from a nonlinear mixed model from fixed effects</p></a></li>
<li><a href='#simulate_nlme_one'><p>Simulate fitted values from an object of class <code>nlme</code></p></a></li>
<li><a href='#simulate_nls'><p>Simulate fitted values from an object of class <code>nls</code></p></a></li>
<li><a href='#sm'><p>Sorghum and Maize growth in Greece</p></a></li>
<li><a href='#SSagauss'><p>self start for an asymmetric Gaussian bell-shaped curve</p></a></li>
<li><a href='#SSbell'><p>self start for a bell-shaped curve</p></a></li>
<li><a href='#SSbeta5'><p>self start for Beta 5-parameter function</p></a></li>
<li><a href='#SSbg4rp'><p>self start for the reparameterized Beta growth function with four parameters</p></a></li>
<li><a href='#SSbgf'><p>self start for Beta Growth Function</p></a></li>
<li><a href='#SSbgf4'><p>self start for Beta growth function with four parameters</p></a></li>
<li><a href='#SSbgrp'><p>self start for the reparameterized Beta growth function</p></a></li>
<li><a href='#SSblin'><p>self start for a bilinear Function</p></a></li>
<li><a href='#SScard3'><p>self start for cardinal temperature response</p></a></li>
<li><a href='#SSdlf'><p>self start for Declining Logistic Function</p></a></li>
<li><a href='#SSexpf'><p>self start for an exponential function</p></a></li>
<li><a href='#SSexpfp'><p>self start for an exponential-plateau function</p></a></li>
<li><a href='#SSexplin'><p>self start for the exponential-linear growth equation</p></a></li>
<li><a href='#SSharm1'><p>self start for a harmonic regression model</p></a></li>
<li><a href='#SShill'><p>self start for Hill Function</p></a></li>
<li><a href='#SSlinp'><p>self start for linear-plateau function</p></a></li>
<li><a href='#SSlogis5'><p>self start for five-parameter logistic function</p></a></li>
<li><a href='#SSmoh'><p>self start for modified hyperbola (photosynthesis)</p></a></li>
<li><a href='#SSnrh'><p>self start for non-rectangular hyperbola (photosynthesis)</p></a></li>
<li><a href='#SSpexpf'><p>self start for plateau-exponential function</p></a></li>
<li><a href='#SSplin'><p>self start for plateau-linear function</p></a></li>
<li><a href='#SSpquad'><p>self start for plateau-quadratic function</p></a></li>
<li><a href='#SSpquad3'><p>self start for plateau-quadratic function</p></a></li>
<li><a href='#SSprofd'><p>self start for profile decay function</p></a></li>
<li><a href='#SSquadp'><p>self start for quadratic-plateau function</p></a></li>
<li><a href='#SSquadp3'><p>self start for quadratic-plateau function</p></a></li>
<li><a href='#SSquadp3xs'><p>self start for quadratic-plateau function (xs)</p></a></li>
<li><a href='#SSratio'><p>self start for a rational curve</p></a></li>
<li><a href='#SSricker'><p>self start for Ricker Function</p></a></li>
<li><a href='#SSscard3'><p>self start for smooth cardinal temperature response</p></a></li>
<li><a href='#SSsharp'><p>self start for temperature response</p></a></li>
<li><a href='#SStemp3'><p>self start for Collatz temperature response</p></a></li>
<li><a href='#SStrlin'><p>self start for a trilinear Function</p></a></li>
<li><a href='#summary_simulate'><p>Summarize a matrix of simulations by their mean (median), sd (mad), and quantiles</p></a></li>
<li><a href='#swpg'><p>Water limitations for Soybean growth</p></a></li>
<li><a href='#var_cov'><p>Variance Covariance matrix of for g(n)ls and (n)lme models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.9.7</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear Regression for Agricultural Applications</td>
</tr>
<tr>
<td>Description:</td>
<td>Additional nonlinear regression functions using self-start (SS) algorithms. One of the functions is the Beta growth function proposed by Yin et al. (2003) &lt;<a href="https://doi.org/10.1093%2Faob%2Fmcg029">doi:10.1093/aob/mcg029</a>&gt;. There are several other functions with breakpoints (e.g. linear-plateau, plateau-linear, exponential-plateau, plateau-exponential, quadratic-plateau, plateau-quadratic and bilinear), a non-rectangular hyperbola and a bell-shaped curve. Twenty eight (28) new self-start (SS) functions in total. This package also supports the publication 'Nonlinear regression Models and applications in agricultural research' by Archontoulis and Miguez (2015) &lt;<a href="https://doi.org/10.2134%2Fagronj2012.0506">doi:10.2134/agronj2012.0506</a>&gt;, a book chapter with similar material &lt;<a href="https://doi.org/10.2134%2Fappliedstatistics.2016.0003.c15">doi:10.2134/appliedstatistics.2016.0003.c15</a>&gt; and a publication by Oddi et. al. (2019) in Ecology and Evolution &lt;<a href="https://doi.org/10.1002%2Fece3.5543">doi:10.1002/ece3.5543</a>&gt;. The function 'nlsLMList' uses 'nlsLM' for fitting, but it is otherwise almost identical to 'nlme::nlsList'.In addition, this release of the package provides functions for conducting simulations for 'nlme' and 'gnls' objects as well as bootstrapping. These functions are intended to work with the modeling framework of the 'nlme' package. It also provides four vignettes with extended examples.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/femiguez/nlraa/issues">https://github.com/femiguez/nlraa/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, knitr, MASS, Matrix, mgcv, nlme, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bbmle, car, emmeans, ggplot2, lattice, minpack.lm, NISTnls,
nlstools, nls2, parallel, rmarkdown, segmented</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-18 17:18:51 UTC; fernandomiguez</td>
</tr>
<tr>
<td>Author:</td>
<td>Fernando Miguez <a href="https://orcid.org/0000-0002-4627-8329"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Caio dos Santos [ctb] (author of SSscard),
  José Pinheiro [ctb, cph] (author of nlme::nlsList, nlme::predict.gnls,
    nlme::predict.nlme),
  Douglas Bates [ctb, cph] (author of nlme::nlsList, nlme::predict.gnls,
    nlme::predict.nlme),
  R-core [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fernando Miguez &lt;femiguez@iastate.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 05:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='barley'>Barley response to nitrogen fertilizer</h2><span id='topic+barley'></span>

<h3>Description</h3>

<p>Data from a paper by Arild Vold on response of barley to nitrogen fertilizer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barley
</code></pre>


<h3>Format</h3>

<p>A data frame with 76 rows and 3 columns
</p>

<dl>
<dt>year</dt><dd><p>Year when the trial was conducted (1970-1988).</p>
</dd>
<dt>NF</dt><dd><p>Nitrogen fertilizer (g/m^2).</p>
</dd>
<dt>yield</dt><dd><p>Grain yield of barley (g/m^2).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Aril Vold (1998). A generalization of ordinary yield response functions. Ecological Applications. 108:227-236.
</p>

<hr>
<h2 id='boot_lm'>Bootstrapping for linear models</h2><span id='topic+boot_lm'></span>

<h3>Description</h3>

<p>Bootstraping for linear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_lm(
  object,
  f = NULL,
  R = 999,
  psim = 2,
  resid.type = c("resample", "normal", "wild"),
  data = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_lm_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="boot_lm_+3A_f">f</code></td>
<td>
<p>function to be applied (and bootstrapped), default coef</p>
</td></tr>
<tr><td><code id="boot_lm_+3A_r">R</code></td>
<td>
<p>number of bootstrap samples, default 999</p>
</td></tr>
<tr><td><code id="boot_lm_+3A_psim">psim</code></td>
<td>
<p>simulation level for <code><a href="#topic+simulate_lm">simulate_lm</a></code></p>
</td></tr>
<tr><td><code id="boot_lm_+3A_resid.type">resid.type</code></td>
<td>
<p>either &ldquo;resample&rdquo;, &ldquo;normal&rdquo; or &ldquo;wild&rdquo;.</p>
</td></tr>
<tr><td><code id="boot_lm_+3A_data">data</code></td>
<td>
<p>optional data argument (useful/needed when data are not in an available environment).</p>
</td></tr>
<tr><td><code id="boot_lm_+3A_verbose">verbose</code></td>
<td>
<p>logical (default TRUE) whether to print message if model does not converge. 
(rare for linear models).</p>
</td></tr>
<tr><td><code id="boot_lm_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to function <code><a href="boot.html#topic+boot">boot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The residuals can either be generated by resampling with replacement (default),
from a normal distribution (parameteric) or by changing their signs (wild). This last
one is called &ldquo;wild bootstrap&rdquo;.
</p>


<h3>Note</h3>

<p>at the moment, when the argument data is used, it is not possible to check that it matches the 
original data used to fit the model. It will also override the fetching of data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(car)
data(barley, package = "nlraa")
## Fit a linear model (quadratic)
fit.lm &lt;- lm(yield ~ NF + I(NF^2), data = barley)

## Bootstrap coefficients by default
fit.lm.bt &lt;- boot_lm(fit.lm)
## Compute confidence intervals
confint(fit.lm.bt, type = "perc")
## Visualize
hist(fit.lm.bt, 1, ci = "perc", main = "Intercept")
hist(fit.lm.bt, 2, ci = "perc", main = "NF term")
hist(fit.lm.bt, 3, ci = "perc", main = "I(NF^2) term")


</code></pre>

<hr>
<h2 id='boot_lme'>Bootstraping for linear mixed models</h2><span id='topic+boot_lme'></span><span id='topic+boot_gls'></span>

<h3>Description</h3>

<p>Bootstraping tools for linear mixed-models using a consistent interface
</p>
<p>bootstrap function for objects of class <code><a href="nlme.html#topic+gls">gls</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_lme(
  object,
  f = NULL,
  R = 999,
  psim = 1,
  cores = 1L,
  data = NULL,
  verbose = TRUE,
  ...
)

boot_gls(
  object,
  f = NULL,
  R = 999,
  psim = 1,
  cores = 1L,
  data = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_lme_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="nlme.html#topic+lme">lme</a></code> or <code><a href="nlme.html#topic+gls">gls</a></code></p>
</td></tr>
<tr><td><code id="boot_lme_+3A_f">f</code></td>
<td>
<p>function to be applied (and bootstrapped), default coef (gls) or fixef (lme)</p>
</td></tr>
<tr><td><code id="boot_lme_+3A_r">R</code></td>
<td>
<p>number of bootstrap samples, default 999</p>
</td></tr>
<tr><td><code id="boot_lme_+3A_psim">psim</code></td>
<td>
<p>simulation level for vector of fixed parameters either for <code><a href="#topic+simulate_gls">simulate_gls</a></code> or <code><a href="#topic+simulate_lme">simulate_lme</a></code></p>
</td></tr>
<tr><td><code id="boot_lme_+3A_cores">cores</code></td>
<td>
<p>number of cores to use for parallel computation</p>
</td></tr>
<tr><td><code id="boot_lme_+3A_data">data</code></td>
<td>
<p>optional data argument (useful/needed when data are not in an available environment).</p>
</td></tr>
<tr><td><code id="boot_lme_+3A_verbose">verbose</code></td>
<td>
<p>logical (default TRUE) whether to print a message if model does not converge.</p>
</td></tr>
<tr><td><code id="boot_lme_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to function <code><a href="boot.html#topic+boot">boot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is inspired by <code><a href="car.html#topic+Boot">Boot</a></code>, which does not
seem to work with &lsquo;gls&rsquo; or &lsquo;lme&rsquo; objects. This function makes multiple copies 
of the original data, so it can be very hungry in terms of memory use, but
I do not believe this to be a big problem given the models we typically fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(nlme)
require(car)
data(Orange)

fm1 &lt;- lme(circumference ~ age, random = ~ 1 | Tree, data = Orange)
fm1.bt &lt;- boot_lme(fm1, R = 50)

hist(fm1.bt)



</code></pre>

<hr>
<h2 id='boot_nlme'>Bootstraping for generalized nonlinear models and nonlinear mixed models</h2><span id='topic+boot_nlme'></span><span id='topic+boot_gnls'></span>

<h3>Description</h3>

<p>Bootstraping tools for nonlinear models using a consistent interface
</p>
<p>bootstrap function for objects of class <code><a href="nlme.html#topic+gnls">gnls</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_nlme(
  object,
  f = NULL,
  R = 999,
  psim = 1,
  cores = 1L,
  data = NULL,
  verbose = TRUE,
  ...
)

boot_gnls(
  object,
  f = NULL,
  R = 999,
  psim = 1,
  cores = 1L,
  data = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_nlme_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="nlme.html#topic+nlme">nlme</a></code> or <code><a href="nlme.html#topic+gnls">gnls</a></code></p>
</td></tr>
<tr><td><code id="boot_nlme_+3A_f">f</code></td>
<td>
<p>function to be applied (and bootstrapped), default coef (gnls) or fixef (nlme)</p>
</td></tr>
<tr><td><code id="boot_nlme_+3A_r">R</code></td>
<td>
<p>number of bootstrap samples, default 999</p>
</td></tr>
<tr><td><code id="boot_nlme_+3A_psim">psim</code></td>
<td>
<p>simulation level for vector of fixed parameters either for <code><a href="#topic+simulate_gnls">simulate_gnls</a></code> or <code><a href="#topic+simulate_nlme_one">simulate_nlme_one</a></code></p>
</td></tr>
<tr><td><code id="boot_nlme_+3A_cores">cores</code></td>
<td>
<p>number of cores to use for parallel computation</p>
</td></tr>
<tr><td><code id="boot_nlme_+3A_data">data</code></td>
<td>
<p>optional data argument (useful/needed when data are not in an available environment).</p>
</td></tr>
<tr><td><code id="boot_nlme_+3A_verbose">verbose</code></td>
<td>
<p>logical (default TRUE) whether to print a message if model does not converge.</p>
</td></tr>
<tr><td><code id="boot_nlme_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to function <code><a href="boot.html#topic+boot">boot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is inspired by <code><a href="car.html#topic+Boot">Boot</a></code>, which does not
seem to work with 'gnls' or 'nlme' objects. This function makes multiple copies 
of the original data, so it can be very hungry in terms of memory use, but
I do not believe this to be a big problem given the models we typically fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(car)
require(nlme)
data(barley, package = "nlraa")
barley2 &lt;- subset(barley, year &lt; 1974)
fit.lp.gnls2 &lt;- gnls(yield ~ SSlinp(NF, a, b, xs), data = barley2)
barley2$year.f &lt;- as.factor(barley2$year)
cfs &lt;- coef(fit.lp.gnls2)
fit.lp.gnls3 &lt;- update(fit.lp.gnls2, 
                      params = list(a + b + xs ~ year.f),
                      start = c(cfs[1], 0, 0, 0, 
                                cfs[2], 0, 0, 0,
                                cfs[3], 0, 0, 0))
## This will take a few seconds                               
fit.lp.gnls.Bt3 &lt;- boot_nlme(fit.lp.gnls3, R = 300) 
confint(fit.lp.gnls.Bt3, type = "perc")


</code></pre>

<hr>
<h2 id='boot_nls'>Bootstrapping for nonlinear models</h2><span id='topic+boot_nls'></span>

<h3>Description</h3>

<p>Bootstraping for nonlinear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_nls(
  object,
  f = NULL,
  R = 999,
  psim = 2,
  resid.type = c("resample", "normal", "wild"),
  data = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_nls_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="stats.html#topic+nls">nls</a></code></p>
</td></tr>
<tr><td><code id="boot_nls_+3A_f">f</code></td>
<td>
<p>function to be applied (and bootstrapped), default coef</p>
</td></tr>
<tr><td><code id="boot_nls_+3A_r">R</code></td>
<td>
<p>number of bootstrap samples, default 999</p>
</td></tr>
<tr><td><code id="boot_nls_+3A_psim">psim</code></td>
<td>
<p>simulation level for <code><a href="#topic+simulate_nls">simulate_nls</a></code></p>
</td></tr>
<tr><td><code id="boot_nls_+3A_resid.type">resid.type</code></td>
<td>
<p>either &ldquo;resample&rdquo;, &ldquo;normal&rdquo; or &ldquo;wild&rdquo;.</p>
</td></tr>
<tr><td><code id="boot_nls_+3A_data">data</code></td>
<td>
<p>optional data argument (useful/needed when data are not in an available environment).</p>
</td></tr>
<tr><td><code id="boot_nls_+3A_verbose">verbose</code></td>
<td>
<p>logical (default TRUE) whether to print a message if model does not converge.</p>
</td></tr>
<tr><td><code id="boot_nls_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to function <code><a href="boot.html#topic+boot">boot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The residuals can either be generated by resampling with replacement 
(default or non-parametric), from a normal distribution (parameteric) or by changing 
their signs (wild). This last one is called &ldquo;wild bootstrap&rdquo;. 
There is more information in <code><a href="#topic+boot_lm">boot_lm</a></code>.
</p>


<h3>Note</h3>

<p>at the moment, when the argument data is used, it is not possible to check that it matches the 
original data used to fit the model. It will also override the fetching of data.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Boot">Boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(car)
data(barley, package = "nlraa")
## Fit a linear-plateau
fit.nls &lt;- nls(yield ~ SSlinp(NF, a, b, xs), data = barley)

## Bootstrap coefficients by default
## Keeping R small for simplicity, increase R for a more realistic use
fit.nls.bt &lt;- boot_nls(fit.nls, R = 1e2)
## Compute confidence intervals
confint(fit.nls.bt, type = "perc")
## Visualize
hist(fit.nls.bt, 1, ci = "perc", main = "Intercept")
hist(fit.nls.bt, 2, ci = "perc", main = "linear term")
hist(fit.nls.bt, 3, ci = "perc", main = "xs break-point term")


</code></pre>

<hr>
<h2 id='fm1.P.at.x.0.4'>object for confidence bands vignette fm1.P.at.x.0.4</h2><span id='topic+fm1.P.at.x.0.4'></span>

<h3>Description</h3>

<p>object for confidence bands vignette fm1.P.at.x.0.4
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm1.P.at.x.0.4
</code></pre>


<h3>Format</h3>

<p>An object of class &lsquo;boot&rsquo;
</p>

<dl>
<dt>fm1.P.at.x.0.4</dt><dd><p>object created in the vignette in chunk &lsquo;Puromycin-6&rsquo;</p>
</dd>
</dl>



<h3>Source</h3>

<p>this package vignette
</p>

<hr>
<h2 id='fm1.P.bt'>object for confidence bands vignette fm1.P.bt</h2><span id='topic+fm1.P.bt'></span>

<h3>Description</h3>

<p>object for confidence bands vignette fm1.P.bt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm1.P.bt
</code></pre>


<h3>Format</h3>

<p>An object of class &lsquo;boot&rsquo;
</p>

<dl>
<dt>fm1.P.bt</dt><dd><p>object created in the vignette in chunk &lsquo;Puromycin-2&rsquo;</p>
</dd>
</dl>



<h3>Source</h3>

<p>this package vignette
</p>

<hr>
<h2 id='fm1.P.bt.ft'>object for confidence bands vignette fm1.P.bt.ft</h2><span id='topic+fm1.P.bt.ft'></span>

<h3>Description</h3>

<p>object for confidence bands vignette fm1.P.bt.ft
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm1.P.bt.ft
</code></pre>


<h3>Format</h3>

<p>An object of class &lsquo;boot&rsquo;
</p>

<dl>
<dt>fm1.P.bt.ft</dt><dd><p>object created in the vignette in chunk &lsquo;Puromycin-4&rsquo;</p>
</dd>
</dl>



<h3>Source</h3>

<p>this package vignette
</p>

<hr>
<h2 id='fm2.Lob.bt'>object for confidence bands vignette fm2.Lob.bt</h2><span id='topic+fm2.Lob.bt'></span>

<h3>Description</h3>

<p>object for confidence bands vignette fm2.Lob.bt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fm2.Lob.bt
</code></pre>


<h3>Format</h3>

<p>An object of class &lsquo;boot&rsquo;
</p>

<dl>
<dt>fm2.Lob.bt</dt><dd><p>object created in the vignette in chunk &lsquo;Loblolly-methods-2&rsquo;</p>
</dd>
</dl>



<h3>Source</h3>

<p>this package vignette
</p>

<hr>
<h2 id='fmm1.bt'>object for confidence bands vignette fmm1.bt</h2><span id='topic+fmm1.bt'></span>

<h3>Description</h3>

<p>object for confidence bands vignette fmm1.bt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmm1.bt
</code></pre>


<h3>Format</h3>

<p>An object of class &lsquo;boot&rsquo;
</p>

<dl>
<dt>fmm1.bt</dt><dd><p>object created in the vignette in chunk &lsquo;maizeleafext-2&rsquo;</p>
</dd>
</dl>



<h3>Source</h3>

<p>this package vignette
</p>

<hr>
<h2 id='IA_tab'>Indexes of Agreement Table</h2><span id='topic+IA_tab'></span><span id='topic+print.IA_tab'></span><span id='topic+plot.IA_tab'></span>

<h3>Description</h3>

<p>Indexes of agreement
</p>
<p>printing function for IA_tab
</p>
<p>plotting function for a IA_tab, it requires &lsquo;ggplot2&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IA_tab(obs, sim, object, null.object)

## S3 method for class 'IA_tab'
print(x, ..., digits = 2)

## S3 method for class 'IA_tab'
plot(x, y, ..., type = c("OvsS", "RvsS"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IA_tab_+3A_obs">obs</code></td>
<td>
<p>vector with observed data</p>
</td></tr>
<tr><td><code id="IA_tab_+3A_sim">sim</code></td>
<td>
<p>vector with simulated data (should be the same length as observed)</p>
</td></tr>
<tr><td><code id="IA_tab_+3A_object">object</code></td>
<td>
<p>alternative to the previous two arguments. An object of class &lsquo;lm&rsquo;, &lsquo;nls&rsquo;, &lsquo;lme&rsquo; or &lsquo;nlme&rsquo;</p>
</td></tr>
<tr><td><code id="IA_tab_+3A_null.object">null.object</code></td>
<td>
<p>optional object which represents the &lsquo;null&rsquo; model. It is an intercept-only model
by default. (Not used at the moment).</p>
</td></tr>
<tr><td><code id="IA_tab_+3A_x">x</code></td>
<td>
<p>object of class &lsquo;IA_tab&rsquo;.</p>
</td></tr>
<tr><td><code id="IA_tab_+3A_...">...</code></td>
<td>
<p>additional plotting arguments (none use at the moment).</p>
</td></tr>
<tr><td><code id="IA_tab_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding (default is 2)</p>
</td></tr>
<tr><td><code id="IA_tab_+3A_y">y</code></td>
<td>
<p>not used at the moment</p>
</td></tr>
<tr><td><code id="IA_tab_+3A_type">type</code></td>
<td>
<p>either &ldquo;OvsS&rdquo; (observed vs. simulated) or &ldquo;RvsS&rdquo; (residuals vs. simulated).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns several indexes that might be useful for interpretation
</p>
<p>For objects of class &lsquo;lm&rsquo; and &lsquo;nls&rsquo; <br />
bias: mean(obs - sim) <br />
intercept: intercept of the model obs ~ beta_0 + beta_1 * sim + error <br />
slope: slope of the model obs ~ beta_0 + beta_1 * sim + error <br />
RSS (deviance): residual sum of squares of the previous model <br />
MSE (RSS / n): mean squared error; where n is the number of observations <br />
RMSE: squared root of the previous index <br />
R2.1: R-squared extracted from an &lsquo;lm&rsquo; object <br />
R2.2: R-squared computed as the correlation between observed and simulated to the power of 2. <br />
ME: model efficiency <br />
NME: Normalized model efficiency <br />
Corr: correlation between observed and simulated <br />
ConCorr: concordance correlation  <br />
</p>
<p>For objects of class &lsquo;gls&rsquo;, &lsquo;gnls&rsquo;, &lsquo;lme&rsquo; or &lsquo;nlme&rsquo; there
are additional metrics such as:
</p>
<p><a href="https://en.wikipedia.org/wiki/Coefficient_of_determination">https://en.wikipedia.org/wiki/Coefficient_of_determination</a> <br />
<a href="https://en.wikipedia.org/wiki/Nash-Sutcliffe_model_efficiency_coefficient">https://en.wikipedia.org/wiki/Nash-Sutcliffe_model_efficiency_coefficient</a> <br />
<a href="https://en.wikipedia.org/wiki/Concordance_correlation_coefficient">https://en.wikipedia.org/wiki/Concordance_correlation_coefficient</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC_tab">IC_tab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(nlme)
require(ggplot2)
## Fit a simple model and then compute IAs
data(swpg)
#' ## Linear model
fit0 &lt;- lm(lfgr ~ ftsw + I(ftsw^2), data = swpg)
ias0 &lt;- IA_tab(object = fit0)
ias0
## Nonlinear model
fit1 &lt;- nls(lfgr ~ SSblin(ftsw, a, b, xs, c), data = swpg)
ias1 &lt;- IA_tab(object = fit1)
ias1
plot(ias1)
## Linear Mixed Models
data(barley, package = "nlraa")
fit2 &lt;- lme(yield ~ NF + I(NF^2), random = ~ 1 | year, data = barley)
ias2 &lt;- IA_tab(object = fit2)
ias2
## Nonlinear Mixed Model
barleyG &lt;- groupedData(yield ~ NF | year, data = barley)
fit3L &lt;- nlsLMList(yield ~ SSquadp3(NF, a, b, c), data = barleyG)
fit3 &lt;- nlme(fit3L, random = pdDiag(a + b ~ 1))
ias3 &lt;- IA_tab(object = fit3)
ias3
plot(ias3)
## Plotting model
prds &lt;- predict_nlme(fit3, interval = "conf", plevel = 0)
barleyGA &lt;- cbind(barleyG, prds)
ggplot(data = barleyGA, aes(x = NF, y = yield)) + 
   geom_point() + 
   geom_line(aes(y = Estimate)) + 
   geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), 
               fill = "purple", alpha = 0.2)
## R2M for model 2
R2M(fit2)
## R2M for model 3
R2M(fit3)

## Using IA_tab without a model
IA_tab(obs = swpg$lfgr, sim = fitted(fit0))



</code></pre>

<hr>
<h2 id='IC_tab'>Information Criteria Table</h2><span id='topic+IC_tab'></span>

<h3>Description</h3>

<p>Information criteria table with weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC_tab(..., criteria = c("AIC", "AICc", "BIC"), sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC_tab_+3A_...">...</code></td>
<td>
<p>model fit objects fitted to the same data</p>
</td></tr>
<tr><td><code id="IC_tab_+3A_criteria">criteria</code></td>
<td>
<p>either &lsquo;AIC&rsquo;, &lsquo;AICc&rsquo; or &lsquo;BIC&rsquo;.</p>
</td></tr>
<tr><td><code id="IC_tab_+3A_sort">sort</code></td>
<td>
<p>whether to sort by weights (default to TRUE)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The delta and weights are calculated based on the &lsquo;criteria&rsquo;
</p>


<h3>See Also</h3>

<p><code><a href="bbmle.html#topic+ICtab">ICtab</a></code>
</p>

<hr>
<h2 id='lfmc'>Live fuel moisture content</h2><span id='topic+lfmc'></span>

<h3>Description</h3>

<p>Live fuel moisture content
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfmc
</code></pre>


<h3>Format</h3>

<p>A data frame with 247 rows and 5 variables:
</p>

<dl>
<dt>leaf.type</dt><dd><p> -factor- Species for which data was recorded (&quot;Grass E&quot;, &quot;Grass W&quot;, &quot;M. spinosum&quot;, &quot;S. bracteolactus&quot;)</p>
</dd>
<dt>time</dt><dd><p> -integer- time in days 1-80</p>
</dd>
<dt>plot</dt><dd><p> -factor- plot with levels 1-6 (discrete)</p>
</dd>
<dt>site</dt><dd><p> -factor- either P (&quot;East&quot;) or SR (&quot;West&quot;)</p>
</dd>
<dt>lfmc</dt><dd><p> -numeric- Live fuel moisture content (percent)</p>
</dd>
<dt>group</dt><dd><p>grouping for regression</p>
</dd>
</dl>



<h3>Details</h3>

<p>A dataset containing the leaf.type, time, plot, site and lfmc (live fuel mass concentration)
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1002/ece3.5543">doi:10.1002/ece3.5543</a>
</p>

<hr>
<h2 id='Lob.bt.pe'>object for confidence bands vignette Lob.bt.pe</h2><span id='topic+Lob.bt.pe'></span>

<h3>Description</h3>

<p>object for confidence bands vignette Lob.bt.pe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lob.bt.pe
</code></pre>


<h3>Format</h3>

<p>An object of class &lsquo;boot&rsquo;
</p>

<dl>
<dt>Lob.bt.pe</dt><dd><p>object created in the vignette in chunk &lsquo;Loblolly-bootstrap-estimates-1&rsquo;</p>
</dd>
</dl>



<h3>Source</h3>

<p>this package vignette
</p>

<hr>
<h2 id='maizeleafext'>Maize leaf extension rate as a response to temperature</h2><span id='topic+maizeleafext'></span>

<h3>Description</h3>

<p>Data on leaf extension rate as a response to meristem temperature
in maize. The data are re-created liberally from 
Walls, W.R., 1971. Role of temperature in the regulation of leaf extension in Zea mays. Nature, 229: 46-47. 
The data points are not the same as in the original paper. Some additional
points were inserted to fill in the blanks and allow for reasonable
parameter estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maizeleafext
</code></pre>


<h3>Format</h3>

<p>A data frame with 10 rows and 2 columns
</p>

<dl>
<dt>temp</dt><dd><p>Meristem temperature (in Celsius).</p>
</dd>
<dt>rate</dt><dd><p>Leaf extension rate (relative to 25 degrees).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Walls, W.R., 1971. Role of temperature in the regulation of leaf extension in Zea mays. Nature, 229: 46-47.
</p>

<hr>
<h2 id='nlraa.env'>Environment to store options and data for nlraa</h2><span id='topic+nlraa.env'></span>

<h3>Description</h3>

<p>Environment which stores indecies and data for bootstraping mostly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlraa.env
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 2.
</p>


<h3>Details</h3>

<p>Create an nlraa environment for bootstrapping
</p>

<hr>
<h2 id='nlsLMList'>Create a list of nls objects with the option of using nlsLM in addition to nls</h2><span id='topic+nlsLMList'></span><span id='topic+nlsLMList.selfStart'></span>

<h3>Description</h3>

<p>This function is a copy of 'nlsList' from the 'nlme' package modified
to use the 'nlsLM' function in addition to (optionally) 'nls'. By changing the algorithm argument it is possible
to use 'nls' as well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsLMList(
  model,
  data,
  start,
  control,
  level,
  subset,
  na.action = na.fail,
  algorithm = c("LM", "default", "port", "plinear"),
  lower = NULL,
  upper = NULL,
  pool = TRUE,
  warn.nls = NA
)

## S3 method for class 'selfStart'
nlsLMList(
  model,
  data,
  start,
  control,
  level,
  subset,
  na.action = na.fail,
  algorithm = c("LM", "default", "port", "plinear"),
  lower = NULL,
  upper = NULL,
  pool = TRUE,
  warn.nls = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlsLMList_+3A_model">model</code></td>
<td>
<p>either a nonlinear model formula, with the response on the left of a ~ operator and an expression involving parameters, covariates, and a grouping factor separated by the | operator on the right, or a selfStart function.</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_start">start</code></td>
<td>
<p>list with starting values</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_control">control</code></td>
<td>
<p>control list, see <code><a href="stats.html#topic+nls">nls</a></code></p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_level">level</code></td>
<td>
<p>an optional integer specifying the level of grouping to be used when multiple nested levels of grouping are present.</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_subset">subset</code></td>
<td>
<p>subset of rows to use</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the data contain NAs. The default action (na.fail) causes nlsList to print an error message and terminate if there are any incomplete observations.</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_algorithm">algorithm</code></td>
<td>
<p>choice of algorithm. Default is &lsquo;LM&rsquo; which uses &lsquo;nlsLM&rsquo; from the <a href="https://CRAN.R-project.org/package=minpack.lm"><span class="pkg">minpack.lm</span></a> package. Other options are: &ldquo;default&rdquo;, &ldquo;port&rdquo; and &ldquo;plinear&rdquo; (nls).</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_lower">lower</code></td>
<td>
<p>vectors of lower and upper bounds, replicated to be as long as start. If unspecified, all parameters are assumed to be unconstrained. Bounds can only be used with the &ldquo;port&rdquo; algorithm. They are ignored, with a warning, if given for other algorithms.</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_upper">upper</code></td>
<td>
<p>see &lsquo;lower&rsquo;</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_pool">pool</code></td>
<td>
<p>an optional logical value that is preserved as an attribute of the returned value. This will be used as the default for pool in calculations of standard deviations or standard errors for summaries.</p>
</td></tr>
<tr><td><code id="nlsLMList_+3A_warn.nls">warn.nls</code></td>
<td>
<p>logical indicating if nls errors (all of which are caught by tryCatch) should be signalled as a “summarizing” warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See function <code><a href="nlme.html#topic+nlsList">nlsList</a></code> and <code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code>. This function is a copy of nlsList but with minor changes to use LM instead as the default algorithm. The authors of the original function are Pinheiro and Bates.
</p>


<h3>Value</h3>

<p>an object of class &lsquo;nlsList&rsquo;
</p>
<p>an object of class &lsquo;nlsList&rsquo;
</p>


<h3>Author(s)</h3>

<p>Jose C. Pinheiro and Douglas M. Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a> wrote the original <code><a href="nlme.html#topic+nlsList">nlsList</a></code>. Fernando E. Miguez made minor changes to use <code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code> in addition to (optionally) <code><a href="stats.html#topic+nls">nls</a></code>. R-Core maintains copyright after 2006.
</p>

<hr>
<h2 id='nlsLMList.formula'>Formula method for nls &lsquo;LM&rsquo; list method</h2><span id='topic+nlsLMList.formula'></span>

<h3>Description</h3>

<p>formula method for nlsLMList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
nlsLMList(
  model,
  data,
  start = NULL,
  control,
  level,
  subset,
  na.action = na.fail,
  algorithm = c("LM", "default", "port", "plinear"),
  lower = NULL,
  upper = NULL,
  pool = TRUE,
  warn.nls = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlsLMList.formula_+3A_model">model</code></td>
<td>
<p>see <code><a href="nlme.html#topic+nlsList">nlsList</a></code></p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_data">data</code></td>
<td>
<p>see <code><a href="nlme.html#topic+nlsList">nlsList</a></code></p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_start">start</code></td>
<td>
<p>see <code><a href="nlme.html#topic+nlsList">nlsList</a></code></p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_control">control</code></td>
<td>
<p>see <code><a href="stats.html#topic+nls">nls</a></code></p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_level">level</code></td>
<td>
<p>see <code><a href="nlme.html#topic+nlsList">nlsList</a></code></p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_subset">subset</code></td>
<td>
<p>see <code><a href="nlme.html#topic+nlsList">nlsList</a></code></p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_na.action">na.action</code></td>
<td>
<p>see <code><a href="nlme.html#topic+nlsList">nlsList</a></code></p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_algorithm">algorithm</code></td>
<td>
<p>choice of algorithm default is &lsquo;LM&rsquo; which uses &lsquo;nlsLM&rsquo; from the minpack.lm package.</p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_lower">lower</code></td>
<td>
<p>vectors of lower and upper bounds, replicated to be as long as start. If unspecified, all parameters are assumed to be unconstrained. Bounds can only be used with the &ldquo;port&rdquo; algorithm. They are ignored, with a warning, if given for other algorithms.</p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_upper">upper</code></td>
<td>
<p>see &lsquo;lower&rsquo;</p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_pool">pool</code></td>
<td>
<p>see <code><a href="nlme.html#topic+nlsList">nlsList</a></code></p>
</td></tr>
<tr><td><code id="nlsLMList.formula_+3A_warn.nls">warn.nls</code></td>
<td>
<p>see <code><a href="nlme.html#topic+nlsList">nlsList</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &lsquo;nlsList&rsquo;
</p>

<hr>
<h2 id='predict_gam'>Modified prediciton function based on predict.gam</h2><span id='topic+predict_gam'></span>

<h3>Description</h3>

<p>Largely based on predict.gam, but with some minor modifications to make it compatible
with <code><a href="#topic+predict_nls">predict_nls</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_gam(
  object,
  newdata = NULL,
  type = "link",
  se.fit = TRUE,
  terms = NULL,
  exclude = NULL,
  block.size = NULL,
  newdata.guaranteed = FALSE,
  na.action = na.pass,
  unconditional = FALSE,
  iterms.type = NULL,
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  tvalue = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_gam_+3A_object">object</code></td>
<td>
<p>object of class &lsquo;gam&rsquo; or as returned by function &lsquo;gamm&rsquo;</p>
</td></tr>
<tr><td><code id="predict_gam_+3A_newdata">newdata</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
<tr><td><code id="predict_gam_+3A_type">type</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
<tr><td><code id="predict_gam_+3A_se.fit">se.fit</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>. Notice that the default is changed to TRUE.</p>
</td></tr>
<tr><td><code id="predict_gam_+3A_terms">terms</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
<tr><td><code id="predict_gam_+3A_exclude">exclude</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
<tr><td><code id="predict_gam_+3A_block.size">block.size</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
<tr><td><code id="predict_gam_+3A_newdata.guaranteed">newdata.guaranteed</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
<tr><td><code id="predict_gam_+3A_na.action">na.action</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
<tr><td><code id="predict_gam_+3A_unconditional">unconditional</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
<tr><td><code id="predict_gam_+3A_iterms.type">iterms.type</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
<tr><td><code id="predict_gam_+3A_interval">interval</code></td>
<td>
<p>either &lsquo;none&rsquo;, &lsquo;confidence&rsquo; or &lsquo;prediction&rsquo;.</p>
</td></tr>
<tr><td><code id="predict_gam_+3A_level">level</code></td>
<td>
<p>probability level for the interval (default 0.95)</p>
</td></tr>
<tr><td><code id="predict_gam_+3A_tvalue">tvalue</code></td>
<td>
<p>t-value statistic used for constructing the intervals</p>
</td></tr>
<tr><td><code id="predict_gam_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of the same length as the fitted object when interval is equal to &lsquo;none&rsquo;. 
Otherwise, a data.frame with columns named (for a 0.95 level) 
&lsquo;Estimate&rsquo;, &lsquo;Est.Error&rsquo;, &lsquo;Q2.5&rsquo; and &lsquo;Q97.5&rsquo;
</p>


<h3>Note</h3>

<p>this is a very simple wrapper for <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, <code><a href="stats.html#topic+predict.nls">predict.nls</a></code>, <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>, <code><a href="#topic+simulate_nls">simulate_nls</a></code>, <code><a href="#topic+simulate_gam">simulate_gam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
require(mgcv)
data(barley)

fm.G &lt;- gam(yield ~ s(NF, k = 6), data = barley)

## confidence and prediction intervals
cis &lt;- predict_gam(fm.G, interval = "conf")
pis &lt;- predict_gam(fm.G, interval = "pred")

barleyA.ci &lt;- cbind(barley, cis)
barleyA.pi &lt;- cbind(barley, pis)

ggplot() + 
  geom_point(data = barleyA.ci, aes(x = NF, y = yield)) + 
  geom_line(data = barleyA.ci, aes(x = NF, y = Estimate)) + 
  geom_ribbon(data = barleyA.ci, aes(x = NF, ymin = Q2.5, ymax = Q97.5), 
              color = "red", alpha = 0.3) + 
  geom_ribbon(data = barleyA.pi, aes(x = NF, ymin = Q2.5, ymax = Q97.5), 
              color = "blue", alpha = 0.3) + 
  ggtitle("95% confidence and prediction bands")
  

</code></pre>

<hr>
<h2 id='predict_nlme'>Average predictions from several (non)linear models based on IC weights</h2><span id='topic+predict_nlme'></span><span id='topic+predict_lme'></span><span id='topic+predict_gnls'></span><span id='topic+predict_gls'></span>

<h3>Description</h3>

<p>Computes weights based on AIC, AICc, or BIC and it generates weighted predictions by
the relative value of the IC values
</p>
<p>predict function for objects of class <code><a href="nlme.html#topic+lme">lme</a></code>
</p>
<p>predict function for objects of class <code><a href="nlme.html#topic+gnls">gnls</a></code>
</p>
<p>predict function for objects of class <code><a href="nlme.html#topic+gls">gls</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_nlme(
  ...,
  criteria = c("AIC", "AICc", "BIC"),
  interval = c("none", "confidence", "prediction", "new-prediction"),
  level = 0.95,
  nsim = 1000,
  plevel = 0,
  newdata = NULL,
  weights
)

predict_lme(
  ...,
  criteria = c("AIC", "AICc", "BIC"),
  interval = c("none", "confidence", "prediction", "new-prediction"),
  level = 0.95,
  nsim = 1000,
  plevel = 0,
  newdata = NULL,
  weights
)

predict_gnls(
  ...,
  criteria = c("AIC", "AICc", "BIC"),
  interval = c("none", "confidence", "prediction", "new-prediction"),
  level = 0.95,
  nsim = 1000,
  plevel = 0,
  newdata = NULL,
  weights
)

predict_gls(
  ...,
  criteria = c("AIC", "AICc", "BIC"),
  interval = c("none", "confidence", "prediction", "new-prediction"),
  level = 0.95,
  nsim = 1000,
  plevel = 0,
  newdata = NULL,
  weights
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_nlme_+3A_...">...</code></td>
<td>
<p>nlme, lme, gls or gnls objects.</p>
</td></tr>
<tr><td><code id="predict_nlme_+3A_criteria">criteria</code></td>
<td>
<p>either &lsquo;AIC&rsquo;, &lsquo;AICc&rsquo; or &lsquo;BIC&rsquo;.</p>
</td></tr>
<tr><td><code id="predict_nlme_+3A_interval">interval</code></td>
<td>
<p>either &lsquo;none&rsquo;, &lsquo;confidence&rsquo; or &lsquo;prediction&rsquo;.
It is also possible to choose &lsquo;new-prediction&rsquo;, which is a prediction that
resamples the random effects (only relevant for &lsquo;lme&rsquo; or &lsquo;nlme&rsquo; objects.)</p>
</td></tr>
<tr><td><code id="predict_nlme_+3A_level">level</code></td>
<td>
<p>probability level for the interval (default 0.95)</p>
</td></tr>
<tr><td><code id="predict_nlme_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to perform for intervals. Default 1000.</p>
</td></tr>
<tr><td><code id="predict_nlme_+3A_plevel">plevel</code></td>
<td>
<p>parameter level prediction to be passed to prediciton functions.</p>
</td></tr>
<tr><td><code id="predict_nlme_+3A_newdata">newdata</code></td>
<td>
<p>new data frame for predictions</p>
</td></tr>
<tr><td><code id="predict_nlme_+3A_weights">weights</code></td>
<td>
<p>vector of weights of the same length as the number of models. It should sum up to one and 
it will override the information-criteria based weights. The weights should match the order of the models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of the same length as the fitted object.
</p>


<h3>Note</h3>

<p>all the objects should be fitted to the same data. The weights are
based on the IC value.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+predict.nlme">predict.nlme</a></code> <code><a href="nlme.html#topic+predict.lme">predict.lme</a></code> <code><a href="nlme.html#topic+predict.gnls">predict.gnls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example
require(ggplot2)
require(nlme)
data(Orange)

## All models should be fitted using Maximum Likelihood
fm.L &lt;- nlme(circumference ~ SSlogis(age, Asym, xmid, scal), 
                random = pdDiag(Asym + xmid + scal ~ 1), 
                method = "ML", data = Orange)
fm.G &lt;- nlme(circumference ~ SSgompertz(age, Asym, b2, b3), 
                random = pdDiag(Asym + b2 + b3 ~ 1), 
                method = "ML", data = Orange)
fm.F &lt;- nlme(circumference ~ SSfpl(age, A, B, xmid, scal), 
                random = pdDiag(A + B + xmid + scal ~ 1), 
                method = "ML", data = Orange)
fm.B &lt;- nlme(circumference ~ SSbg4rp(age, w.max, lt.e, ldtm, ldtb), 
                random = pdDiag(w.max + lt.e + ldtm + ldtb ~ 1), 
                method = "ML", data = Orange)

## Print the table with weights
IC_tab(fm.L, fm.G, fm.F, fm.B)

## Each model prediction is weighted according to their AIC values
prd &lt;- predict_nlme(fm.L, fm.G, fm.F, fm.B)

ggplot(data = Orange, aes(x = age, y = circumference)) + 
  geom_point() + 
  geom_line(aes(y = predict(fm.L, level = 0), color = "Logistic")) +
  geom_line(aes(y = predict(fm.G, level = 0), color = "Gompertz")) +
  geom_line(aes(y = predict(fm.F, level = 0), color = "4P-Logistic")) +  
  geom_line(aes(y = predict(fm.B, level = 0), color = "Beta")) +
  geom_line(aes(y = prd, color = "Avg. Model"), linewidth = 1.2)

</code></pre>

<hr>
<h2 id='predict_nls'>Average predictions from several (non)linear models based on IC weights</h2><span id='topic+predict_nls'></span><span id='topic+predict2_gam'></span>

<h3>Description</h3>

<p>Computes weights based on AIC, AICc, or BIC and it generates weighted predictions by
the relative value of the IC values
</p>
<p>predict function for objects of class <code><a href="mgcv.html#topic+gam">gam</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_nls(
  ...,
  criteria = c("AIC", "AICc", "BIC"),
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  nsim = 1000,
  resid.type = c("none", "resample", "normal", "wild"),
  newdata = NULL,
  weights
)

predict2_gam(
  ...,
  criteria = c("AIC", "AICc", "BIC"),
  interval = c("none", "confidence", "prediction"),
  level = 0.95,
  nsim = 1000,
  resid.type = c("none", "resample", "normal", "wild"),
  newdata = NULL,
  weights
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_nls_+3A_...">...</code></td>
<td>
<p>&lsquo;nls&rsquo; or &lsquo;lm&rsquo; objects (&lsquo;glm&rsquo; and &lsquo;gam&rsquo; objects inherit &lsquo;lm&rsquo;).</p>
</td></tr>
<tr><td><code id="predict_nls_+3A_criteria">criteria</code></td>
<td>
<p>either &lsquo;AIC&rsquo;, &lsquo;AICc&rsquo; or &lsquo;BIC&rsquo;.</p>
</td></tr>
<tr><td><code id="predict_nls_+3A_interval">interval</code></td>
<td>
<p>either &lsquo;none&rsquo;, &lsquo;confidence&rsquo; or &lsquo;prediction&rsquo;.</p>
</td></tr>
<tr><td><code id="predict_nls_+3A_level">level</code></td>
<td>
<p>probability level for the interval (default 0.95)</p>
</td></tr>
<tr><td><code id="predict_nls_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to perform for intervals. Default 1000.</p>
</td></tr>
<tr><td><code id="predict_nls_+3A_resid.type">resid.type</code></td>
<td>
<p>either &lsquo;none&rsquo;, &ldquo;resample&rdquo;, &ldquo;normal&rdquo; or &ldquo;wild&rdquo;.</p>
</td></tr>
<tr><td><code id="predict_nls_+3A_newdata">newdata</code></td>
<td>
<p>new data frame for predictions</p>
</td></tr>
<tr><td><code id="predict_nls_+3A_weights">weights</code></td>
<td>
<p>vector of weights of the same length as the number of models. It should sum up to one and 
it will override the information-criteria based weights. The weights should match the order of the models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of the same length as the fitted object when interval is equal to &lsquo;none&rsquo;. Otherwise,
a data.frame with columns named (for a 0.95 level) &lsquo;Estimate&rsquo;, &lsquo;Est.Error&rsquo;, &lsquo;Q2.5&rsquo; and &lsquo;Q97.5&rsquo;
</p>


<h3>Note</h3>

<p>all the objects should be fitted to the same data. Weights are
based on the chosen IC value (exp(-0.5 * delta IC)). 
For models of class <code><a href="mgcv.html#topic+gam">gam</a></code> there is very limited support.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, <code><a href="stats.html#topic+predict.nls">predict.nls</a></code>, <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>, <code><a href="#topic+simulate_nls">simulate_nls</a></code>, <code><a href="#topic+simulate_gam">simulate_gam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example
require(ggplot2)
require(mgcv)
data(barley, package = "nlraa")

fm.L &lt;- lm(yield ~ NF, data = barley)
fm.Q &lt;- lm(yield ~ NF + I(NF^2), data = barley)
fm.A &lt;- nls(yield ~ SSasymp(NF, Asym, R0, lrc), data = barley)
fm.LP &lt;- nls(yield ~ SSlinp(NF, a, b, xs), data = barley)
fm.QP &lt;- nls(yield ~ SSquadp3(NF, a, b, c), data = barley)
fm.BL &lt;- nls(yield ~ SSblin(NF, a, b, xs, c), data = barley)
fm.G &lt;- gam(yield ~ s(NF, k = 6), data = barley)

## Print the table with weights
IC_tab(fm.L, fm.Q, fm.A, fm.LP, fm.QP, fm.BL, fm.G)

## Each model prediction is weighted according to their AIC values
prd &lt;- predict_nls(fm.L, fm.Q, fm.A, fm.LP, fm.QP, fm.BL, fm.G)

ggplot(data = barley, aes(x = NF, y = yield)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fm.L), color = "Linear")) +
  geom_line(aes(y = fitted(fm.Q), color = "Quadratic")) +
  geom_line(aes(y = fitted(fm.A), color = "Asymptotic")) +  
  geom_line(aes(y = fitted(fm.LP), color = "Linear-plateau")) + 
  geom_line(aes(y = fitted(fm.QP), color = "Quadratic-plateau")) + 
  geom_line(aes(y = fitted(fm.BL), color = "Bi-linear")) + 
  geom_line(aes(y = fitted(fm.G), color = "GAM")) + 
  geom_line(aes(y = prd, color = "Avg. Model"), linewidth = 1.2)

</code></pre>

<hr>
<h2 id='predict2_nls'>Prediction Bands for Nonlinear Regression</h2><span id='topic+predict2_nls'></span>

<h3>Description</h3>

<p>The method used in this function is described in Battes and Watts (2007)
Nonlinear Regression Analysis and Its Applications (see pages 58-59). It is 
known as the Delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict2_nls(
  object,
  newdata = NULL,
  interval = c("none", "confidence", "prediction"),
  level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict2_nls_+3A_object">object</code></td>
<td>
<p>object of class &lsquo;nls&rsquo;</p>
</td></tr>
<tr><td><code id="predict2_nls_+3A_newdata">newdata</code></td>
<td>
<p>data frame with values for the predictor</p>
</td></tr>
<tr><td><code id="predict2_nls_+3A_interval">interval</code></td>
<td>
<p>either &lsquo;none&rsquo;, &lsquo;confidence&rsquo; or &lsquo;prediction&rsquo;</p>
</td></tr>
<tr><td><code id="predict2_nls_+3A_level">level</code></td>
<td>
<p>probability level (default is 0.95)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is approximate and it works better when the distribution of the 
parameter estimates are normally distributed. This assumption can be evaluated
by using bootstrap.
</p>
<p>The method currently works well for any nonlinear function, but if predictions
are needed on new data, then it is required that a selfStart function is used.
</p>


<h3>Value</h3>

<p>a data frame with Estimate, Est.Error, lower interval bound and upper 
interval bound. For example, if the level = 0.95, 
the lower bound would be named Q2.5 and the upper bound would be name Q97.5
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.nls">predict.nls</a></code> and <code><a href="#topic+predict_nls">predict_nls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
require(nlme)
data(Soybean)

SoyF &lt;- subset(Soybean, Variety == "F" &amp; Year == 1988)
fm1 &lt;- nls(weight ~ SSlogis(Time, Asym, xmid, scal), data = SoyF)
## The SSlogis also supplies analytical derivatives
## therefore the predict function returns the gradient too
prd1 &lt;- predict(fm1, newdata = SoyF)

## Gradient
head(attr(prd1, "gradient"))
## Prediction method using gradient
prds &lt;- predict2_nls(fm1, interval = "conf")
SoyFA &lt;- cbind(SoyF, prds)
ggplot(data = SoyFA, aes(x = Time, y = weight)) + 
   geom_point() + 
   geom_line(aes(y = Estimate)) + 
   geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), fill = "purple", alpha = 0.3) +
   ggtitle("95% Confidence Bands")
  
## This is equivalent 
fm2 &lt;- nls(weight ~ Asym/(1 + exp((xmid - Time)/scal)), data = SoyF,
           start = c(Asym = 20, xmid = 56, scal = 8))
           
## Prediction interval
prdi &lt;- predict2_nls(fm1, interval = "pred")
SoyFA.PI &lt;- cbind(SoyF, prdi) 
## Make prediction interval plot
ggplot(data = SoyFA.PI, aes(x = Time, y = weight)) + 
   geom_point() + 
   geom_line(aes(y = Estimate)) + 
   geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), fill = "purple", alpha = 0.3) + 
   ggtitle("95% Prediction Band")
   
## For these data we should be using gnls instead with an increasing variance
fmg1 &lt;- gnls(weight ~ SSlogis(Time, Asym, xmid, scal), 
             data = SoyF, weights = varPower())
             
IC_tab(fm1, fmg1)
prdg &lt;- predict_gnls(fmg1, interval = "pred")
SoyFA.GPI &lt;- cbind(SoyF, prdg) 

## These prediction bands are not perfect, but they could be smoothed
## to eliminate the ragged appearance
 ggplot(data = SoyFA.GPI, aes(x = Time, y = weight)) + 
   geom_point() + 
   geom_line(aes(y = Estimate)) + 
   geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), fill = "purple", alpha = 0.3) + 
   ggtitle("95% Prediction Band. NLS model which \n accomodates an increasing variance")

</code></pre>

<hr>
<h2 id='print_boot'>Print an object of class <code><a href="boot.html#topic+boot">boot</a></code></h2><span id='topic+print_boot'></span>

<h3>Description</h3>

<p>This is a copy of boot::print.boot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_boot(x, digits = getOption("digits"), index = 1L:ncol(boot.out$t), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_boot_+3A_x">x</code></td>
<td>
<p>A bootstrap output object of class <code><a href="boot.html#topic+boot">boot</a></code> generated by one of the bootstrap functions.</p>
</td></tr>
<tr><td><code id="print_boot_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed in the summary statistics.</p>
</td></tr>
<tr><td><code id="print_boot_+3A_index">index</code></td>
<td>
<p>Indices indicating for which elements of the bootstrap output summary statistics are required.</p>
</td></tr>
<tr><td><code id="print_boot_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Ripley with a bug fix by John Nash
</p>

<hr>
<h2 id='R2M'>R-squared for nonlinear mixed models</h2><span id='topic+R2M'></span><span id='topic+R2M.nls'></span><span id='topic+R2M.lm'></span><span id='topic+R2M.gls'></span><span id='topic+R2M.gnls'></span><span id='topic+R2M.lme'></span><span id='topic+R2M.nlme'></span>

<h3>Description</h3>

<p>R-squared &lsquo;modified&rsquo; for nonlinear (mixed) models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2M(x, ...)

## S3 method for class 'nls'
R2M(x, ...)

## S3 method for class 'lm'
R2M(x, ...)

## S3 method for class 'gls'
R2M(x, ...)

## S3 method for class 'gnls'
R2M(x, ...)

## S3 method for class 'lme'
R2M(x, ...)

## S3 method for class 'nlme'
R2M(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2M_+3A_x">x</code></td>
<td>
<p>object of class &lsquo;lm&rsquo;, &lsquo;nls&rsquo;, &lsquo;gls&rsquo;, &lsquo;gnls&rsquo;, 
&lsquo;lme&rsquo; or &lsquo;nlme&rsquo; .</p>
</td></tr>
<tr><td><code id="R2M_+3A_...">...</code></td>
<td>
<p>additional arguments (none use at the moment).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I have read some papers about computing an R-squared for (non)linear (mixed) models
and I am not sure that it makes sense at all. However, here they are and
the method is general enough that it extends to nonlinear mixed models. What do
these numbers mean and why would you want to compute them are good questions to 
ponder... <br />
</p>
<p>Recommended reading: <br />
Nakagawa and Schielzeth Methods in Ecology and Evolution <a href="https://doi.org/10.1111/j.2041-210x.2012.00261.x">doi:10.1111/j.2041-210x.2012.00261.x</a> <br />
</p>
<p><a href="https://stats.oarc.ucla.edu/other/mult-pkg/faq/general/faq-what-are-pseudo-r-squareds/">https://stats.oarc.ucla.edu/other/mult-pkg/faq/general/faq-what-are-pseudo-r-squareds/</a> <br />
</p>
<p>Spiess, AN., Neumeyer, N. An evaluation of R2 as an inadequate measure for nonlinear models in 
pharmacological and biochemical research: a Monte Carlo approach. BMC Pharmacol 10, 6 (2010). 
<a href="https://doi.org/10.1186/1471-2210-10-6">doi:10.1186/1471-2210-10-6</a> <br />
</p>
<p><a href="https://stat.ethz.ch/pipermail/r-sig-mixed-models/2010q1/003363.html">https://stat.ethz.ch/pipermail/r-sig-mixed-models/2010q1/003363.html</a> <br />
</p>
<p><a href="https://blog.minitab.com/en/adventures-in-statistics-2/why-is-there-no-r-squared-for-nonlinear-regression">https://blog.minitab.com/en/adventures-in-statistics-2/why-is-there-no-r-squared-for-nonlinear-regression</a> <br />
</p>
<p><a href="https://stats.stackexchange.com/questions/111150/calculating-r2-in-mixed-models-using-nakagawa-schielzeths-2013-r2glmm-me/225334#225334">https://stats.stackexchange.com/questions/111150/calculating-r2-in-mixed-models-using-nakagawa-schielzeths-2013-r2glmm-me/225334#225334</a> <br />
</p>
<p>Other R pacakges which calculate some version of an R-squared: performance, rcompanion, MuMIn
</p>


<h3>Value</h3>

<p>it returns a list with the following structure: <br />
for an object of class &lsquo;lm&rsquo;, &lsquo;nls&rsquo;, &lsquo;gls&rsquo; or &lsquo;gnls&rsquo;, <br />
R2: R-squared <br />
var.comp: variance components with var.fixed and var.resid <br />
var.perc: variance components percents (should add up to 100) <br />
for an object of class &lsquo;lme&rsquo; or &lsquo;nlme&rsquo; in addition it also returns: <br />
R2.marginal: marginal R2 which only includes the fixed effects <br />
R2.conditional: conditional R2 which includes both the fixed and random effects <br />
var.random: the variance contribution of the random effects
</p>


<h3>Note</h3>

<p>The references here strongly discourage the use of R-squared in anything
but linear models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IA_tab">IA_tab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(nlme)
data(barley, package = "nlraa")
fit2 &lt;- lme(yield ~ NF + I(NF^2), random = ~ 1 | year, data = barley)
R2M(fit2)
## Nonlinear Mixed Model
barleyG &lt;- groupedData(yield ~ NF | year, data = barley)
fit3L &lt;- nlsLMList(yield ~ SSquadp3(NF, a, b, c), data = barleyG)
fit3 &lt;- nlme(fit3L, random = pdDiag(a + b ~ 1))
R2M(fit3)

</code></pre>

<hr>
<h2 id='simulate_gam'>Simulate responses from a generalized additive linear model <code><a href="mgcv.html#topic+gam">gam</a></code></h2><span id='topic+simulate_gam'></span>

<h3>Description</h3>

<p>By sampling from the vector of coefficients it is possible to simulate
data from a &lsquo;gam&rsquo; model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_gam(
  object,
  nsim = 1,
  psim = 1,
  resid.type = c("none", "resample", "normal", "wild"),
  value = c("matrix", "data.frame"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_gam_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="mgcv.html#topic+gam">gam</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_gam_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to perform</p>
</td></tr>
<tr><td><code id="simulate_gam_+3A_psim">psim</code></td>
<td>
<p>parameter simulation level (an integer, 0, 1, 2 or 3).</p>
</td></tr>
<tr><td><code id="simulate_gam_+3A_resid.type">resid.type</code></td>
<td>
<p>type of residual to use. &lsquo;none&rsquo;, &lsquo;resample&rsquo;, &lsquo;normal&rsquo; or &lsquo;wild&rsquo;.</p>
</td></tr>
<tr><td><code id="simulate_gam_+3A_value">value</code></td>
<td>
<p>either &lsquo;matrix&rsquo; or &lsquo;data.frame&rsquo;</p>
</td></tr>
<tr><td><code id="simulate_gam_+3A_...">...</code></td>
<td>
<p>additional arguments (none used at the moment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is probably redundant. Simply using <code><a href="stats.html#topic+simulate">simulate</a></code>
generates data from the correct distribution for objects which inherit 
class <code><a href="stats.html#topic+lm">lm</a></code>. The difference is that I'm trying to add the 
uncertainty in the parameter estimates.
</p>
<p>These are the options that control the parameter simulation level
</p>

<dl>
<dt>psim = 0</dt><dd><p>returns the fitted values</p>
</dd>
<dt>psim = 1</dt><dd><p>simulates from a beta vector (mean response)</p>
</dd>
<dt>psim = 2</dt><dd><p>simulates observations according to the residual type (similar to observed data)</p>
</dd>
<dt>psim = 3</dt><dd><p>simulates a beta vector, considers uncertainty in the variance covariance matrix of beta and adds residuals (prediction)</p>
</dd>
</dl>

<p>The residual type (resid.type) controls how the residuals are generated. 
They are either resampled, simulated from a normal distribution or &lsquo;wild&rsquo; where the
Rademacher distribution is used (<a href="https://en.wikipedia.org/wiki/Rademacher_distribution">https://en.wikipedia.org/wiki/Rademacher_distribution</a>).
Resampled and normal both assume iid, but &lsquo;normal&rsquo; makes the stronger assumption of normality.
&lsquo;wild&rsquo; does not assume constant variance, but it assumes symmetry.
</p>


<h3>Value</h3>

<p>matrix or data.frame with responses
</p>


<h3>Note</h3>

<p>psim = 3 is not implemented at the moment.
</p>
<p>The purpose of this function is to make it compatible with other functions in this
package. It has some limitations compared to the functions in the &lsquo;see also&rsquo; section.
</p>


<h3>References</h3>

<p>Generalized Additive Models. An Introduction with R. Second Edition. (2017) Simon N. Wood. CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>, <code><a href="stats.html#topic+simulate">simulate</a></code> and <code><a href="#topic+simulate_lm">simulate_lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
require(mgcv)
## These count data are from GAM book by Simon Wood (pg. 132) - see reference
y &lt;- c(12, 14, 33, 50, 67, 74, 123, 141, 165, 204, 253, 246, 240)
t &lt;- 1:13
dat &lt;- data.frame(y = y, t = t)
fit &lt;- gam(y ~ t + I(t^2), family = poisson, data = dat)
sims &lt;- simulate_gam(fit, nsim = 100, value = "data.frame")

ggplot(data = sims) + 
  geom_line(aes(x = t, y = sim.y, group = ii), 
            color = "gray", alpha = 0.5) + 
  geom_point(aes(x = t, y = y)) 


</code></pre>

<hr>
<h2 id='simulate_gls'>Simulate fitted values from an object of class <code><a href="nlme.html#topic+gls">gls</a></code></h2><span id='topic+simulate_gls'></span>

<h3>Description</h3>

<p>Simulate values from an object of class gls. Unequal variances, 
as modeled using the &lsquo;weights&rsquo; option are supported, and there is experimental
code for dealing with the &lsquo;correlation&rsquo; structure. This generates just one simulation
from these type of models. To generate multiple simulations use <code><a href="#topic+simulate_lme">simulate_lme</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_gls(
  object,
  psim = 1,
  na.action = na.fail,
  naPattern = NULL,
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_gls_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="nlme.html#topic+gls">gls</a></code></p>
</td></tr>
<tr><td><code id="simulate_gls_+3A_psim">psim</code></td>
<td>
<p>parameter simulation level, 0: for fitted values, 1: for simulation from 
fixed parameters (assuming a fixed vcov matrix), 2: for simulation considering the 
uncertainty in the residual standard error (sigma), this returns data which
will appear similar to the observed values</p>
</td></tr>
<tr><td><code id="simulate_gls_+3A_na.action">na.action</code></td>
<td>
<p>default &lsquo;na.fail&rsquo;. See <code><a href="nlme.html#topic+predict.gls">predict.gls</a></code></p>
</td></tr>
<tr><td><code id="simulate_gls_+3A_napattern">naPattern</code></td>
<td>
<p>missing value pattern. See <code><a href="nlme.html#topic+predict.gls">predict.gls</a></code></p>
</td></tr>
<tr><td><code id="simulate_gls_+3A_data">data</code></td>
<td>
<p>the data argument is needed when using this function inside user defined functions.
It should be identical to the data used to fit the model.</p>
</td></tr>
<tr><td><code id="simulate_gls_+3A_...">...</code></td>
<td>
<p>additional arguments (it is possible to supply a newdata this way)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code><a href="nlme.html#topic+predict.gls">predict.gls</a></code> function
</p>
<p>It uses function <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code> to generate new values for the coefficients
of the model using the Variance-Covariance matrix <code><a href="stats.html#topic+vcov">vcov</a></code>. This variance-covariance matrix 
refers to the one for the parameters &lsquo;beta&rsquo;, not the one for the residuals.
</p>


<h3>Value</h3>

<p>It returns a vector with simulated values with length equal to the number of rows 
in the original data
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+predict.gls">predict.gls</a></code> <code><a href="#topic+simulate_lme">simulate_lme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(nlme)
data(Orange)

fit.gls &lt;- gls(circumference ~ age, data = Orange, 
               weights = varPower())

## Visualize covariance matrix
fit.gls.vc &lt;- var_cov(fit.gls)
image(log(fit.gls.vc[,ncol(fit.gls.vc):1]))

sim &lt;- simulate_gls(fit.gls)

</code></pre>

<hr>
<h2 id='simulate_gnls'>Simulate fitted values from an object of class <code><a href="nlme.html#topic+gnls">gnls</a></code></h2><span id='topic+simulate_gnls'></span>

<h3>Description</h3>

<p>Simulate values from an object of class gnls. Unequal variances, 
as modeled using the &lsquo;weights&rsquo; option are supported, and there is experimental
code for dealing with the &lsquo;correlation&rsquo; structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_gnls(
  object,
  psim = 1,
  na.action = na.fail,
  naPattern = NULL,
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_gnls_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="nlme.html#topic+gnls">gnls</a></code></p>
</td></tr>
<tr><td><code id="simulate_gnls_+3A_psim">psim</code></td>
<td>
<p>parameter simulation level, 0: for fitted values, 1: for simulation from 
fixed parameters (assuming a fixed vcov matrix), 2: for simulation considering the 
uncertainty in the residual standard error (sigma), this returns data which
will appear similar to the observed values</p>
</td></tr>
<tr><td><code id="simulate_gnls_+3A_na.action">na.action</code></td>
<td>
<p>default &lsquo;na.fail&rsquo;. See <code><a href="nlme.html#topic+predict.gnls">predict.gnls</a></code></p>
</td></tr>
<tr><td><code id="simulate_gnls_+3A_napattern">naPattern</code></td>
<td>
<p>missing value pattern. See <code><a href="nlme.html#topic+predict.gnls">predict.gnls</a></code></p>
</td></tr>
<tr><td><code id="simulate_gnls_+3A_data">data</code></td>
<td>
<p>the data argument is needed when using this function inside user defined functions.
It should be identical to the data used to fit the model.</p>
</td></tr>
<tr><td><code id="simulate_gnls_+3A_...">...</code></td>
<td>
<p>additional arguments (it is possible to supply a newdata this way)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code><a href="nlme.html#topic+predict.gnls">predict.gnls</a></code> function
</p>
<p>It uses function <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code> to generate new values for the coefficients
of the model using the Variance-Covariance matrix <code><a href="stats.html#topic+vcov">vcov</a></code>. This variance-covariance matrix 
refers to the one for the parameters &lsquo;beta&rsquo;, not the one for the residuals.
</p>


<h3>Value</h3>

<p>It returns a vector with simulated values with length equal to the number of rows 
in the original data
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+predict.gnls">predict.gnls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(nlme)
data(barley, package = "nlraa")

fit.gnls &lt;- gnls(yield ~ SSlinp(NF, a, b, xs), data = barley)

sim &lt;- simulate_gnls(fit.gnls)

</code></pre>

<hr>
<h2 id='simulate_lm'>Simulate responses from a linear model <code><a href="stats.html#topic+lm">lm</a></code></h2><span id='topic+simulate_lm'></span>

<h3>Description</h3>

<p>The function <code><a href="stats.html#topic+simulate">simulate</a></code> does not consider the 
uncertainty in the estimation of the model parameters. This function will attempt 
to do this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_lm(
  object,
  psim = 1,
  nsim = 1,
  resid.type = c("none", "resample", "normal", "wild"),
  value = c("matrix", "data.frame"),
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_lm_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="simulate_lm_+3A_psim">psim</code></td>
<td>
<p>parameter simulation level (an integer, 0, 1, 2, 3 or 4).</p>
</td></tr>
<tr><td><code id="simulate_lm_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to perform</p>
</td></tr>
<tr><td><code id="simulate_lm_+3A_resid.type">resid.type</code></td>
<td>
<p>type of residual to include (none, resample, normal or wild)</p>
</td></tr>
<tr><td><code id="simulate_lm_+3A_value">value</code></td>
<td>
<p>either &lsquo;matrix&rsquo; or &lsquo;data.frame&rsquo;</p>
</td></tr>
<tr><td><code id="simulate_lm_+3A_data">data</code></td>
<td>
<p>the data argument might be needed when using this function inside user defined functions.
At least it is expected to be safer.</p>
</td></tr>
<tr><td><code id="simulate_lm_+3A_...">...</code></td>
<td>
<p>additional arguments (none used at the moment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulate responses from a linear model <code><a href="stats.html#topic+lm">lm</a></code>
</p>
<p>These are the options that control the parameter simulation level
</p>

<dl>
<dt>psim = 0</dt><dd><p>returns the fitted values</p>
</dd>
<dt>psim = 1</dt><dd><p>simulates a beta vector (mean response)</p>
</dd>
<dt>psim = 2</dt><dd><p>simulates a beta vector and adds resampled residuals (similar to observed data)</p>
</dd>
<dt>psim = 3</dt><dd><p>simulates a beta vector, considers uncertainty in the variance covariance matrix of beta and adds residuals (prediction)</p>
</dd>
<dt>psim = 4</dt><dd><p>only adds residuals according to resid.type (similar to simulate.lm)</p>
</dd>
</dl>

<p>The residual type (resid.type) controls how the residuals are generated. 
They are either resampled, simulated from a normal distribution or &lsquo;wild&rsquo; where the
Rademacher distribution is used (<a href="https://en.wikipedia.org/wiki/Rademacher_distribution">https://en.wikipedia.org/wiki/Rademacher_distribution</a>).
Resampled and normal both assume iid, but &lsquo;normal&rsquo; makes the stronger assumption of normality.
When psim = 2 and resid.type = none, <code><a href="stats.html#topic+simulate">simulate</a></code> is used instead.
&lsquo;wild&rsquo; does not assume constant variance, but it assumes symmetry.
</p>


<h3>Value</h3>

<p>matrix or data.frame with responses
</p>


<h3>References</h3>

<p>See
&ldquo;Inference Based on the Wild Bootstrap&rdquo; James G. MacKinnon
<a href="https://www.math.kth.se/matstat/gru/sf2930/papers/wild.bootstrap.pdf">https://www.math.kth.se/matstat/gru/sf2930/papers/wild.bootstrap.pdf</a>
&ldquo;Bootstrap in Nonstationary Autoregression&rdquo; Zuzana Praskova 
<a href="https://dml.cz/bitstream/handle/10338.dmlcz/135473/Kybernetika_38-2002-4_1.pdf">https://dml.cz/bitstream/handle/10338.dmlcz/135473/Kybernetika_38-2002-4_1.pdf</a>
&ldquo;Jackknife, Bootstrap and other Resampling Methods in Regression Analysis&rdquo; C. F. J. Wu.
The Annals of Statistics. 1986. Vol 14. 1261-1295.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
data(Orange)
fit &lt;- lm(circumference ~ age, data = Orange)
sims &lt;- simulate_lm(fit, nsim = 100, value = "data.frame")

ggplot(data = sims) + 
  geom_line(aes(x = age, y = sim.y, group = ii), 
            color = "gray", alpha = 0.5) + 
  geom_point(aes(x = age, y = circumference)) 



</code></pre>

<hr>
<h2 id='simulate_lme'>Simulate values from an object of class <code><a href="nlme.html#topic+lme">lme</a></code></h2><span id='topic+simulate_lme'></span>

<h3>Description</h3>

<p>Simulate values from an object of class lme. Unequal variances, 
as modeled using the &lsquo;weights&rsquo; option are supported, and there is
experimental code for considering the &lsquo;correlation&rsquo; structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_lme(
  object,
  nsim = 1,
  psim = 1,
  value = c("matrix", "data.frame"),
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_lme_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="nlme.html#topic+lme">lme</a></code> or <code><a href="nlme.html#topic+gls">gls</a></code></p>
</td></tr>
<tr><td><code id="simulate_lme_+3A_nsim">nsim</code></td>
<td>
<p>number of samples, default 1</p>
</td></tr>
<tr><td><code id="simulate_lme_+3A_psim">psim</code></td>
<td>
<p>parameter simulation level, 0: for fitted values, 1: for simulation from 
fixed parameters (assuming a fixed vcov matrix), 2: for simulation considering the 
uncertainty in the residual standard error (sigma), this returns data which
will appear similar to the observed values. 3: in addition samples a new set of random effects.</p>
</td></tr>
<tr><td><code id="simulate_lme_+3A_value">value</code></td>
<td>
<p>whether to return a matrix (default) or an augmented data frame</p>
</td></tr>
<tr><td><code id="simulate_lme_+3A_data">data</code></td>
<td>
<p>the data argument is needed when using this function inside user defined functions.</p>
</td></tr>
<tr><td><code id="simulate_lme_+3A_...">...</code></td>
<td>
<p>additional arguments (it is possible to supply a newdata this way)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code><a href="nlme.html#topic+predict.lme">predict.lme</a></code> function
</p>
<p>It uses function <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code> to generate new values for the coefficients
of the model using the Variance-Covariance matrix <code><a href="stats.html#topic+vcov">vcov</a></code>. This variance-covariance matrix 
refers to the one for the parameters 'beta', not the one for the residuals.
</p>


<h3>Value</h3>

<p>It returns a vector with simulated values with length equal to the number of rows 
in the original data
</p>


<h3>Note</h3>

<p>I find the simulate.merMod in the lme4 pacakge confusing. There is use.u and several versions of re.form.
From the documentation it seems that if use.u = TRUE, then the current values of the random effects are used.
This would mean that it is equivalent to psim = 2 in this function. Then use.u = FALSE, would be equivalent 
to psim = 3. re.form allows for specifying the formula of the random effects.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+predict.lme">predict.lme</a></code> and &lsquo;simulate.merMod&rsquo; in the &lsquo;lme4&rsquo; package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(nlme)
data(Orange)

fm1 &lt;- lme(circumference ~ age, random = ~ 1 | Tree, data = Orange)

sims &lt;- simulate_lme(fm1, nsim = 10)


</code></pre>

<hr>
<h2 id='simulate_nlme'>Simulate samples from a nonlinear mixed model from fixed effects</h2><span id='topic+simulate_nlme'></span>

<h3>Description</h3>

<p>Simulate multiple samples from a nonlinear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_nlme(
  object,
  nsim = 1,
  psim = 1,
  value = c("matrix", "data.frame"),
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_nlme_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="nlme.html#topic+gnls">gnls</a></code> or <code><a href="nlme.html#topic+nlme">nlme</a></code></p>
</td></tr>
<tr><td><code id="simulate_nlme_+3A_nsim">nsim</code></td>
<td>
<p>number of samples, default 1</p>
</td></tr>
<tr><td><code id="simulate_nlme_+3A_psim">psim</code></td>
<td>
<p>simulation level for fixed and random parameters see <code><a href="#topic+simulate_nlme_one">simulate_nlme_one</a></code> for more details.</p>
</td></tr>
<tr><td><code id="simulate_nlme_+3A_value">value</code></td>
<td>
<p>whether to return a matrix (default) or an augmented data frame</p>
</td></tr>
<tr><td><code id="simulate_nlme_+3A_data">data</code></td>
<td>
<p>the data argument is needed when using this function inside user defined functions.</p>
</td></tr>
<tr><td><code id="simulate_nlme_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to either <code><a href="#topic+simulate_gnls">simulate_gnls</a></code> or <code><a href="#topic+simulate_nlme_one">simulate_nlme_one</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details can be found in either <code><a href="#topic+simulate_gnls">simulate_gnls</a></code> or <code><a href="#topic+simulate_nlme_one">simulate_nlme_one</a></code>.
This function is very simple and it only sets up a matrix and a loop in order to simulate several instances of 
model outputs.
</p>


<h3>Value</h3>

<p>It returns a matrix with simulated values from the original object
with number of rows equal to the number of rows of <code><a href="stats.html#topic+fitted">fitted</a></code> and number
of columns equal to the number of simulated samples (&lsquo;nsim&rsquo;). In the case of &lsquo;data.frame&rsquo;
it returns an augmented data.frame, which can potentially be a very large object, but which
makes furhter plotting more convenient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(nlme)
data(barley, package = "nlraa")
barley2 &lt;- subset(barley, year &lt; 1974)
fit.lp.gnls2 &lt;- gnls(yield ~ SSlinp(NF, a, b, xs), data = barley2)
barley2$year.f &lt;- as.factor(barley2$year)
cfs &lt;- coef(fit.lp.gnls2)
fit.lp.gnls3 &lt;- update(fit.lp.gnls2, 
                      params = list(a + b + xs ~ year.f),
                      start = c(cfs[1], 0, 0, 0, 
                                cfs[2], 0, 0, 0,
                                cfs[3], 0, 0, 0))
                                
sims &lt;- simulate_nlme(fit.lp.gnls3, nsim = 3)


</code></pre>

<hr>
<h2 id='simulate_nlme_one'>Simulate fitted values from an object of class <code><a href="nlme.html#topic+nlme">nlme</a></code></h2><span id='topic+simulate_nlme_one'></span>

<h3>Description</h3>

<p>This function is based on <code><a href="nlme.html#topic+predict.nlme">predict.nlme</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_nlme_one(
  object,
  psim = 1,
  level = Q,
  asList = FALSE,
  na.action = na.fail,
  naPattern = NULL,
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_nlme_one_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="nlme.html#topic+nlme">nlme</a></code></p>
</td></tr>
<tr><td><code id="simulate_nlme_one_+3A_psim">psim</code></td>
<td>
<p>parameter simulation level, 0: for fitted values, 1: for simulation from 
fixed parameters (assuming a fixed vcov matrix), 2: for simulation considering the 
residual error (sigma), this returns data which will appear similar to the observed values.
Currently, working on psim = 3, which will simulate a new set of random effects. This
can be useful when computing prediction intervals at the subject-level.</p>
</td></tr>
<tr><td><code id="simulate_nlme_one_+3A_level">level</code></td>
<td>
<p>level at which simulations are performed. See <code><a href="nlme.html#topic+predict.nlme">predict.nlme</a></code>. 
An important difference is that for this function multiple levels are not allowed.</p>
</td></tr>
<tr><td><code id="simulate_nlme_one_+3A_aslist">asList</code></td>
<td>
<p>optional logical value. See <code><a href="nlme.html#topic+predict.nlme">predict.nlme</a></code></p>
</td></tr>
<tr><td><code id="simulate_nlme_one_+3A_na.action">na.action</code></td>
<td>
<p>missing value action. See <code><a href="nlme.html#topic+predict.nlme">predict.nlme</a></code></p>
</td></tr>
<tr><td><code id="simulate_nlme_one_+3A_napattern">naPattern</code></td>
<td>
<p>missing value pattern. See <code><a href="nlme.html#topic+predict.nlme">predict.nlme</a></code></p>
</td></tr>
<tr><td><code id="simulate_nlme_one_+3A_data">data</code></td>
<td>
<p>the data argument is needed when using this function inside user defined functions.</p>
</td></tr>
<tr><td><code id="simulate_nlme_one_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed (possible to pass newdata this way)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses function <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code> to generate new values for the coefficients
of the model using the Variance-Covariance matrix <code><a href="stats.html#topic+vcov">vcov</a></code>
</p>


<h3>Value</h3>

<p>This function should return a vector with the same dimensions as 
the original data, unless newdata is provided.
</p>

<hr>
<h2 id='simulate_nls'>Simulate fitted values from an object of class <code><a href="stats.html#topic+nls">nls</a></code></h2><span id='topic+simulate_nls'></span>

<h3>Description</h3>

<p>Simulate values from an object of class nls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_nls(
  object,
  nsim = 1,
  psim = 1,
  resid.type = c("none", "resample", "normal", "wild"),
  value = c("matrix", "data.frame"),
  data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_nls_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="stats.html#topic+nls">nls</a></code></p>
</td></tr>
<tr><td><code id="simulate_nls_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations to perform</p>
</td></tr>
<tr><td><code id="simulate_nls_+3A_psim">psim</code></td>
<td>
<p>parameter simulation level, 0: for fitted values, 1: for simulation from 
fixed parameters (assuming a fixed vcov matrix), 2: simulation from sampling
both from the parameters and the residuals, 3: for simulation considering the 
uncertainty in the residual standard error only (sigma) and fixing the
parameter estimates at their original value; this will result in simulations 
similar to the observed values.</p>
</td></tr>
<tr><td><code id="simulate_nls_+3A_resid.type">resid.type</code></td>
<td>
<p>either &lsquo;none&rsquo;, &ldquo;resample&rdquo;, &ldquo;normal&rdquo; or &ldquo;wild&rdquo;.</p>
</td></tr>
<tr><td><code id="simulate_nls_+3A_value">value</code></td>
<td>
<p>either &lsquo;matrix&rsquo; or &lsquo;data.frame&rsquo;</p>
</td></tr>
<tr><td><code id="simulate_nls_+3A_data">data</code></td>
<td>
<p>the data argument is needed when using this function inside user defined functions.</p>
</td></tr>
<tr><td><code id="simulate_nls_+3A_...">...</code></td>
<td>
<p>additional arguments (it is possible to supply a newdata this way)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code><a href="nlme.html#topic+predict.gnls">predict.gnls</a></code> function
</p>
<p>It uses function <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code> to generate new values for the coefficients
of the model using the Variance-Covariance matrix <code><a href="stats.html#topic+vcov">vcov</a></code>. This variance-covariance matrix 
refers to the one for the parameters &lsquo;beta&rsquo;, not the one for the residuals.
</p>


<h3>Value</h3>

<p>It returns a vector with simulated values with length equal to the number of rows 
in the original data
</p>


<h3>Note</h3>

<p>The default behavior is that simulations are perfomed for the mean function only.
When &lsquo;psim = 2&rsquo; this function will silently choose &lsquo;resample&rsquo; as the 
&lsquo;resid.type&rsquo;. This is not ideal design for this function, but I made this choice for 
compatibility with other types of simulation originating from <code><a href="stats.html#topic+glm">glm</a></code> and
<code><a href="mgcv.html#topic+gam">gam</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+predict.gnls">predict.gnls</a></code>, <code><a href="#topic+predict_nls">predict_nls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(barley, package = "nlraa")

fit &lt;- nls(yield ~ SSlinp(NF, a, b, xs), data = barley)

sim &lt;- simulate_nls(fit, nsim = 100)

</code></pre>

<hr>
<h2 id='sm'>Sorghum and Maize growth in Greece</h2><span id='topic+sm'></span>

<h3>Description</h3>

<p>Sorghum and Maize growth in Greece
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm
</code></pre>


<h3>Format</h3>

<p>A data frame with 235 rows and 5 columns
</p>

<dl>
<dt>DOY</dt><dd><p> -integer- Day of the year 141-303</p>
</dd>
<dt>Block</dt><dd><p> -integer- Block in the experimental design 1-4</p>
</dd>
<dt>Input</dt><dd><p> -integer- Input level 1 (Low) or 2 (High)</p>
</dd>
<dt>Crop</dt><dd><p> -factor- either F (Fiber Sorghum), M (Maize), S (Sweet Sorghum)</p>
</dd>
<dt>Yield</dt><dd><p> -numeric- Biomass yield in Mg/ha</p>
</dd>
</dl>



<h3>Details</h3>

<p>A dataset containing growth data for sorghum and maize in Greece.
</p>
<p>Danalatos, N.G.,  S.V. Archontoulis, and K. Tsiboukas. 2009. 
Comparative analysis of sorghum versus corn growing under optimum and under 
water/nitrogen limited conditions in central Greece. In: From research to 
industry and markets: Proceedings of the 17th European Biomass Conference, 
Hamburg, Germany. 29 June–3 July 2009. ETA–Renewable Energies, Florence, 
Italy. p. 538–544.
</p>


<h3>Source</h3>

<p>See above reference. (Currently available on ResearchGate).
</p>

<hr>
<h2 id='SSagauss'>self start for an asymmetric Gaussian bell-shaped curve</h2><span id='topic+SSagauss'></span><span id='topic+agauss'></span>

<h3>Description</h3>

<p>Self starter for a type of bell-shaped curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agauss(x, eta, beta, delta, sigma1, sigma2)

SSagauss(x, eta, beta, delta, sigma1, sigma2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSagauss_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSagauss_+3A_eta">eta</code></td>
<td>
<p>maximum value of y</p>
</td></tr>
<tr><td><code id="SSagauss_+3A_beta">beta</code></td>
<td>
<p>parameter controlling the lower values</p>
</td></tr>
<tr><td><code id="SSagauss_+3A_delta">delta</code></td>
<td>
<p>break-point separating the first and second half-bell curve</p>
</td></tr>
<tr><td><code id="SSagauss_+3A_sigma1">sigma1</code></td>
<td>
<p>scale for the first half</p>
</td></tr>
<tr><td><code id="SSagauss_+3A_sigma2">sigma2</code></td>
<td>
<p>scale for the second half</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in (doi:10.3390/rs12050827).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>agauss: vector of the same length as x using an asymmetric bell-shaped Gaussian curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- 1:30
y &lt;- agauss(x, 10, 2, 10, 2, 6) + rnorm(length(x), 0, 0.02)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- minpack.lm::nlsLM(y ~ SSagauss(x, eta, beta, delta, sigma1, sigma2), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSbell'>self start for a bell-shaped curve</h2><span id='topic+SSbell'></span><span id='topic+bell'></span>

<h3>Description</h3>

<p>Self starter for a type of bell-shaped curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bell(x, ymax, a, b, xc)

SSbell(x, ymax, a, b, xc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSbell_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSbell_+3A_ymax">ymax</code></td>
<td>
<p>maximum value of y</p>
</td></tr>
<tr><td><code id="SSbell_+3A_a">a</code></td>
<td>
<p>parameter controlling the spread (associated with a quadratic term)</p>
</td></tr>
<tr><td><code id="SSbell_+3A_b">b</code></td>
<td>
<p>parameter controlling the spread (associated with a cubic term)</p>
</td></tr>
<tr><td><code id="SSbell_+3A_xc">xc</code></td>
<td>
<p>centering parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506). One example application is Hammer et al. (2009) (doi:10.2135/cropsci2008.03.0152).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>bell: vector of the same length as x using a bell-shaped curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- 1:20
y &lt;- bell(x, 8, -0.0314, 0.000317, 13) + rnorm(length(x), 0, 0.5)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSbell(x, ymax, a, b, xc), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSbeta5'>self start for Beta 5-parameter function</h2><span id='topic+SSbeta5'></span><span id='topic+beta5'></span>

<h3>Description</h3>

<p>Self starter for Beta 5-parameter function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta5(temp, mu, tb, a, tc, b)

SSbeta5(temp, mu, tb, a, tc, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSbeta5_+3A_temp">temp</code></td>
<td>
<p>input vector which is normally &lsquo;temperature&rsquo;</p>
</td></tr>
<tr><td><code id="SSbeta5_+3A_mu">mu</code></td>
<td>
<p>mu parameter (see equation)</p>
</td></tr>
<tr><td><code id="SSbeta5_+3A_tb">tb</code></td>
<td>
<p>base (low) temperature at which no expansion accurs</p>
</td></tr>
<tr><td><code id="SSbeta5_+3A_a">a</code></td>
<td>
<p>parameter describing the initial increasing phase</p>
</td></tr>
<tr><td><code id="SSbeta5_+3A_tc">tc</code></td>
<td>
<p>critical (high) temperature at which no expasion occurs</p>
</td></tr>
<tr><td><code id="SSbeta5_+3A_b">b</code></td>
<td>
<p>parameter describing the decreasing phase</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the publication by Yin et al. (1995) &ldquo;A nonlinear model for crop development as a function of temperature &rdquo;.
Agricultural and Forest Meteorology 77 (1995) 1-16
</p>
<p>The form of the equation is: </p>
<p style="text-align: center;"><code class="reqn">exp(mu) * (temp - tb)^a * (tc - temp)^b</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>beta5: vector of the same length as x (temp) using the beta5 function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(minpack.lm)
require(ggplot2)
## Temperature response example
data(maizeleafext)
## Fit model
fit &lt;- nlsLM(rate ~ SSbeta5(temp, mu, tb, a, tc, b), data = maizeleafext)
## Visualize
ndat &lt;- data.frame(temp = 0:45)
ndat$rate &lt;- predict(fit, newdata = ndat)
ggplot() + 
   geom_point(data = maizeleafext, aes(temp, rate)) + 
   geom_line(data = ndat, aes(x = temp, y = rate))

</code></pre>

<hr>
<h2 id='SSbg4rp'>self start for the reparameterized Beta growth function with four parameters</h2><span id='topic+SSbg4rp'></span><span id='topic+bg4rp'></span>

<h3>Description</h3>

<p>Self starter for Beta Growth function with parameters w.max, lt.e, ldtm, ldtb
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bg4rp(time, w.max, lt.e, ldtm, ldtb)

SSbg4rp(time, w.max, lt.e, ldtm, ldtb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSbg4rp_+3A_time">time</code></td>
<td>
<p>input vector (x) which is normally &lsquo;time&rsquo;, the smallest value should be close to zero.</p>
</td></tr>
<tr><td><code id="SSbg4rp_+3A_w.max">w.max</code></td>
<td>
<p>value of weight or mass at its peak</p>
</td></tr>
<tr><td><code id="SSbg4rp_+3A_lt.e">lt.e</code></td>
<td>
<p>log of the time at which the maximum weight or mass has been reached.</p>
</td></tr>
<tr><td><code id="SSbg4rp_+3A_ldtm">ldtm</code></td>
<td>
<p>log of the difference between time at which the weight or mass reaches its peak and half its peak.</p>
</td></tr>
<tr><td><code id="SSbg4rp_+3A_ldtb">ldtb</code></td>
<td>
<p>log of the difference between time at which the weight or mass reaches its peak and when it starts growing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the publication by Yin et al. (2003) &ldquo;A Flexible Sigmoid Function of Determinate Growth&rdquo;.
This is a reparameterization of the beta growth function (4 parameters) with guaranteed constraints, so it is expected to 
behave numerically better than <code><a href="#topic+SSbgf4">SSbgf4</a></code>.
</p>
<p>Reparameterizing the four parameter beta growth
</p>

<ul>
<li><p> ldtm = log(t.e - t.m)
</p>
</li>
<li><p> ldtb = log(t.m - t.b)
</p>
</li>
<li><p> t.e = exp(lt.e)
</p>
</li>
<li><p> t.m = exp(lt.e) - exp(ldtm)
</p>
</li>
<li><p> t.b = (exp(lt.e) - exp(ldtm)) - exp(ldtb)
</p>
</li></ul>

<p>The form of the equation is: </p>
<p style="text-align: center;"><code class="reqn">w.max * (1 + (exp(lt.e) - time)/exp(ldtm)) * ((time - (exp(lt.e) - exp(ldtb)))/exp(ldtb))^(exp(ldtb)/exp(ldtm))</code>
</p>

<p>This is a reparameterized version of the Beta-Growth function in which the parameters are unconstrained, but they are expressed in the log-scale.
</p>


<h3>Value</h3>

<p>bg4rp: vector of the same length as x (time) using the beta growth function with four parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- 1:100
y &lt;- bg4rp(x, 20, log(70), log(30), log(20)) + rnorm(100, 0, 1)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSbg4rp(x, w.max, lt.e, ldtm, ldtb), data = dat)
## We are able to recover the original values
exp(coef(fit)[2:4])
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSbgf'>self start for Beta Growth Function</h2><span id='topic+SSbgf'></span><span id='topic+bgf'></span><span id='topic+bgf2'></span>

<h3>Description</h3>

<p>Self starter for Beta Growth function with parameters w.max, t.m and t.e
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgf(time, w.max, t.e, t.m)

SSbgf(time, w.max, t.e, t.m)

bgf2(time, w.max, w.b, t.e, t.m, t.b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSbgf_+3A_time">time</code></td>
<td>
<p>input vector (x) which is normally &lsquo;time&rsquo;, the smallest value should be close to zero.</p>
</td></tr>
<tr><td><code id="SSbgf_+3A_w.max">w.max</code></td>
<td>
<p>value of weight or mass at its peak</p>
</td></tr>
<tr><td><code id="SSbgf_+3A_t.e">t.e</code></td>
<td>
<p>time at which the weight or mass reaches its peak.</p>
</td></tr>
<tr><td><code id="SSbgf_+3A_t.m">t.m</code></td>
<td>
<p>time at which half of the maximum weight or mass has been reached.</p>
</td></tr>
<tr><td><code id="SSbgf_+3A_w.b">w.b</code></td>
<td>
<p>weight or biomass at initial time</p>
</td></tr>
<tr><td><code id="SSbgf_+3A_t.b">t.b</code></td>
<td>
<p>initial time offset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the publication by Yin et al. (2003) &ldquo;A Flexible Sigmoid Function of Determinate Growth&rdquo;.
</p>
<p>The form of the equation is: </p>
<p style="text-align: center;"><code class="reqn">w.max * (1 + (t.e - time)/(t.e - t.m)) * (time/t.e)^(t.e / (t.e - t.m))</code>
</p>
<p>.
Given this function weight is expected to decay and reach zero again at <code class="reqn">2*t.e - t.m</code>.
</p>


<h3>Value</h3>

<p>bgf: vector of the same length as x (time) using the beta growth function
</p>
<p>bgf2: a numeric vector of the same length as x (time) containing parameter estimates for equation specified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## See extended example in vignette 'nlraa-AgronJ-paper'
x &lt;- seq(0, 17, by = 0.25)
y &lt;- bgf(x, 5, 15, 7)
plot(x, y)

</code></pre>

<hr>
<h2 id='SSbgf4'>self start for Beta growth function with four parameters</h2><span id='topic+SSbgf4'></span><span id='topic+bgf4'></span>

<h3>Description</h3>

<p>Self starter for Beta Growth function with parameters w.max, t.e, t.m and t.b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgf4(time, w.max, t.e, t.m, t.b)

SSbgf4(time, w.max, t.e, t.m, t.b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSbgf4_+3A_time">time</code></td>
<td>
<p>input vector (x) which is normally &lsquo;time&rsquo;.</p>
</td></tr>
<tr><td><code id="SSbgf4_+3A_w.max">w.max</code></td>
<td>
<p>value of weight or mass at its peak.</p>
</td></tr>
<tr><td><code id="SSbgf4_+3A_t.e">t.e</code></td>
<td>
<p>time at which the weight or mass reaches its peak.</p>
</td></tr>
<tr><td><code id="SSbgf4_+3A_t.m">t.m</code></td>
<td>
<p>time at which half of the maximum weight or mass has been reached.</p>
</td></tr>
<tr><td><code id="SSbgf4_+3A_t.b">t.b</code></td>
<td>
<p>time at which growth starts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the publication by Yin et al. (2003) &ldquo;A Flexible Sigmoid Function of Determinate Growth&rdquo;.
This is a difficult function to fit because the linear constrains are not explicitly introduced 
in the optimization process. See function <code><a href="#topic+SSbgrp">SSbgrp</a></code> for a reparameterized version.
</p>
<p>This is equation 11 (pg. 368) in the publication by Yin, but with correction (https://doi.org/10.1093/aob/mcg091) and with &lsquo;w.b&rsquo; equal to zero.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x (time) containing parameter estimates for equation specified
</p>
<p>bgf4: vector of the same length as x (time) using the beta growth function with four parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sm)
## Let's just pick one crop
sm2 &lt;- subset(sm, Crop == "M")
fit &lt;- nls(Yield ~ SSbgf4(DOY, w.max, t.e, t.m, t.b), data = sm2)
plot(Yield ~ DOY, data = sm2)
lines(sm2$DOY,fitted(fit))
## For this particular problem it could be better to 'fix' t.b and w.b
fit0 &lt;- nls(Yield ~ bgf2(DOY, w.max, w.b = 0, t.e, t.m, t.b = 141), 
           data = sm2, start = list(w.max = 16, t.e= 240, t.m = 200))

x &lt;- seq(0, 17, by = 0.25)
y &lt;- bgf4(x, 20, 15, 10, 2)
plot(x, y)
</code></pre>

<hr>
<h2 id='SSbgrp'>self start for the reparameterized Beta growth function</h2><span id='topic+SSbgrp'></span><span id='topic+bgrp'></span>

<h3>Description</h3>

<p>Self starter for Beta Growth function with parameters w.max, lt.m and ldt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgrp(time, w.max, lt.e, ldt)

SSbgrp(time, w.max, lt.e, ldt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSbgrp_+3A_time">time</code></td>
<td>
<p>input vector (x) which is normally &lsquo;time&rsquo;, the smallest value should be close to zero.</p>
</td></tr>
<tr><td><code id="SSbgrp_+3A_w.max">w.max</code></td>
<td>
<p>value of weight or mass at its peak</p>
</td></tr>
<tr><td><code id="SSbgrp_+3A_lt.e">lt.e</code></td>
<td>
<p>log of the time at which the maximum weight or mass has been reached.</p>
</td></tr>
<tr><td><code id="SSbgrp_+3A_ldt">ldt</code></td>
<td>
<p>log of the difference between time at which the weight or mass reaches its peak and half its peak (<code class="reqn">log(t.e - t.m)</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see the publication by Yin et al. (2003) &ldquo;A Flexible Sigmoid Function of Determinate Growth&rdquo;.
This is a reparameterization of the beta growth function with guaranteed constraints, so it is expected to 
behave numerically better than <code><a href="#topic+SSbgf">SSbgf</a></code>.
</p>
<p>The form of the equation is: </p>
<p style="text-align: center;"><code class="reqn">w.max * (1 + (exp(lt.e) - time)/exp(ldt)) * (time/exp(lt.e))^(exp(lt.e) / exp(ldt))</code>
</p>
<p>.
Given this function weight is expected to decay and reach zero again at <code class="reqn">2*ldt</code>. This is a reparameterized version 
of the Beta-Growth function in which the parameters are unconstrained, but they are expressed in the log-scale.
</p>


<h3>Value</h3>

<p>bgrp: vector of the same length as x (time) using the beta growth function (reparameterized).
</p>


<h3>Note</h3>

<p>In a few tests it seems that zero values of &lsquo;time&rsquo; can cause the error message &lsquo;NA/NaN/Inf in foreign function call (arg 1)&rsquo;, so it might be better to remove them before running this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
x &lt;- 1:30
y &lt;- bgrp(x, 20, log(25), log(5)) + rnorm(30, 0, 1)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSbgrp(x, w.max, lt.e, ldt), data = dat)
## We are able to recover the original values
exp(coef(fit)[2:3])
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSblin'>self start for a bilinear Function</h2><span id='topic+SSblin'></span><span id='topic+blin'></span>

<h3>Description</h3>

<p>Self starter for a bilinear function with parameters a (intercept), b (first slope), xs (break-point), c (second slope)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blin(x, a, b, xs, c)

SSblin(x, a, b, xs, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSblin_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSblin_+3A_a">a</code></td>
<td>
<p>the intercept</p>
</td></tr>
<tr><td><code id="SSblin_+3A_b">b</code></td>
<td>
<p>the first-phase slope</p>
</td></tr>
<tr><td><code id="SSblin_+3A_xs">xs</code></td>
<td>
<p>break-point of transition between first-phase linear and second-phase linear</p>
</td></tr>
<tr><td><code id="SSblin_+3A_c">c</code></td>
<td>
<p>the second-phase slope</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a special case with just two parts but a more general approach is to consider a segmented 
function with several breakpoints and linear segments. Splines would be even more general. Also this
model assumes that there is a break-point that needs to be estimated.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>blin: vector of the same length as x using the bilinear function
</p>


<h3>See Also</h3>

<p>package <span class="pkg">segmented</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- 1:30
y &lt;- blin(x, 0, 0.75, 15, 1.75) + rnorm(30, 0, 0.5)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSblin(x, a, b, xs, c), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))
## Minimal example
## This is probably about the smallest dataset you 
## should use with this function
dat2 &lt;- data.frame(x = 1:5, y = c(1.1, 1.9, 3.1, 2, 0.9))
fit2 &lt;- nls(y ~ SSblin(x, a, b, xs, c), data = dat2)
ggplot(data = dat2, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit2)))


</code></pre>

<hr>
<h2 id='SScard3'>self start for cardinal temperature response</h2><span id='topic+SScard3'></span><span id='topic+card3'></span>

<h3>Description</h3>

<p>Self starter for cardinal temperature response function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>card3(x, tb, to, tm)

SScard3(x, tb, to, tm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SScard3_+3A_x">x</code></td>
<td>
<p>input vector (x) which is normally &lsquo;temperature&rsquo;.</p>
</td></tr>
<tr><td><code id="SScard3_+3A_tb">tb</code></td>
<td>
<p>base temperature</p>
</td></tr>
<tr><td><code id="SScard3_+3A_to">to</code></td>
<td>
<p>optimum temperature</p>
</td></tr>
<tr><td><code id="SScard3_+3A_tm">tm</code></td>
<td>
<p>maximum temperature</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506)
</p>


<h3>Value</h3>

<p>card3: vector of the same length as x using a card3 function
</p>


<h3>Author(s)</h3>

<p>Caio dos Santos and Fernando Miguez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A temperature response function
require(ggplot2)
set.seed(1234)
x &lt;- 1:50
y &lt;- card3(x, 13, 25, 36) + rnorm(length(x), sd = 0.05)
dat1 &lt;- data.frame(x = x, y = y)
fit1 &lt;- nls(y ~ SScard3(x, tb, to, tm), data = dat1)

ggplot(data = dat1, aes(x, y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit1)))

</code></pre>

<hr>
<h2 id='SSdlf'>self start for Declining Logistic Function</h2><span id='topic+SSdlf'></span><span id='topic+dlf'></span>

<h3>Description</h3>

<p>Self starter for declining logistic function with parameters asym, a2, xmid and scal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlf(time, asym, a2, xmid, scal)

SSdlf(time, asym, a2, xmid, scal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSdlf_+3A_time">time</code></td>
<td>
<p>input vector (x) which is normally &lsquo;time&rsquo;, the smalles value should be close to zero.</p>
</td></tr>
<tr><td><code id="SSdlf_+3A_asym">asym</code></td>
<td>
<p>value of weight or mass at its peak (maximum)</p>
</td></tr>
<tr><td><code id="SSdlf_+3A_a2">a2</code></td>
<td>
<p>value of weight or mass at its trough (minimum)</p>
</td></tr>
<tr><td><code id="SSdlf_+3A_xmid">xmid</code></td>
<td>
<p>time at which half of the maximum weight or mass has bean reached.</p>
</td></tr>
<tr><td><code id="SSdlf_+3A_scal">scal</code></td>
<td>
<p>scale parameter which controls the spread also interpreted in terms of time to go from xmid to approx. 0.63 asym</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Response function:  </p>
<p style="text-align: center;"><code class="reqn">y = (asym - a2) / (1 + exp((xmid - time)/scal))) + a2</code>
</p>
<p>. 
</p>

<ul>
<li><p> asym: upper asymptote
</p>
</li>
<li><p> xmid: time when y is midway between w and a 
</p>
</li>
<li><p> scal: controls the spread
</p>
</li>
<li><p> a2: lower asymptote 
</p>
</li></ul>

<p>The four parameter logistic <code><a href="stats.html#topic+SSfpl">SSfpl</a></code> is essentially equivalent to this function,
but here the interpretation of the parameters is different and this is the form used in 
Oddi et. al. (2019) (see vignette).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x (time) containing parameter estimates for equation specified
</p>
<p>dlf: vector of the same length as x (time) using the declining logistic function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Extended example in the vignette 'nlraa-Oddi-LFMC'
x &lt;- seq(0, 17, by = 0.25)
y &lt;- dlf(x, 2, 10, 8, 1)
plot(x, y, type = "l")

</code></pre>

<hr>
<h2 id='SSexpf'>self start for an exponential function</h2><span id='topic+SSexpf'></span><span id='topic+expf'></span>

<h3>Description</h3>

<p>Self starter for a simple exponential function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expf(x, a, c)

SSexpf(x, a, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSexpf_+3A_x">x</code></td>
<td>
<p>input vector (x)</p>
</td></tr>
<tr><td><code id="SSexpf_+3A_a">a</code></td>
<td>
<p>represents the value at x = 0</p>
</td></tr>
<tr><td><code id="SSexpf_+3A_c">c</code></td>
<td>
<p>represents the exponential rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the exponential function </p>
<p style="text-align: center;"><code class="reqn">y = a * exp(c * x)</code>
</p>

<p>For more details see: Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>expf: vector of the same length as x using the profd function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- 1:15
y &lt;- expf(x, 10, -0.3) + rnorm(15, 0, 0.2)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSexpf(x, a, c), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSexpfp'>self start for an exponential-plateau function</h2><span id='topic+SSexpfp'></span><span id='topic+expfp'></span>

<h3>Description</h3>

<p>Self starter for an exponential-plateau function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expfp(x, a, c, xs)

SSexpfp(x, a, c, xs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSexpfp_+3A_x">x</code></td>
<td>
<p>input vector (x)</p>
</td></tr>
<tr><td><code id="SSexpfp_+3A_a">a</code></td>
<td>
<p>represents the value at x = 0</p>
</td></tr>
<tr><td><code id="SSexpfp_+3A_c">c</code></td>
<td>
<p>represents the exponential rate</p>
</td></tr>
<tr><td><code id="SSexpfp_+3A_xs">xs</code></td>
<td>
<p>represents the breakpoint at which the plateau starts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the exponential-plateua function, where &lsquo;xs&rsquo; is the break-point
</p>
<p style="text-align: center;"><code class="reqn">(x &lt; xs) * a * exp(c * x) + (x &gt;= xs) * (a * exp(c * xs))</code>
</p>

<p>For more details see: Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>expfp: vector of the same length as x using the expfp function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(12345)
x &lt;- 1:30
y &lt;- expfp(x, 10, 0.1, 15) + rnorm(30, 0, 1.5)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSexpfp(x, a, c, xs), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSexplin'>self start for the exponential-linear growth equation</h2><span id='topic+SSexplin'></span><span id='topic+explin'></span>

<h3>Description</h3>

<p>Self starter for an exponential-linear growth equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explin(t, cm, rm, tb)

SSexplin(t, cm, rm, tb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSexplin_+3A_t">t</code></td>
<td>
<p>input vector (time)</p>
</td></tr>
<tr><td><code id="SSexplin_+3A_cm">cm</code></td>
<td>
<p>parameter related to the maximum growth during the linear phase</p>
</td></tr>
<tr><td><code id="SSexplin_+3A_rm">rm</code></td>
<td>
<p>parameter related to the maximum growth during the exponential phase</p>
</td></tr>
<tr><td><code id="SSexplin_+3A_tb">tb</code></td>
<td>
<p>time at which switch happens</p>
</td></tr>
</table>


<h3>Details</h3>

<p>J. GOUDRIAAN, J. L. MONTEITH, A Mathematical Function for Crop Growth Based 
on Light Interception and Leaf Area Expansion, Annals of Botany, Volume 66, 
Issue 6, December 1990, Pages 695–701,
<a href="https://doi.org/10.1093/oxfordjournals.aob.a088084">doi:10.1093/oxfordjournals.aob.a088084</a>
</p>
<p>The equation is: </p>
<p style="text-align: center;"><code class="reqn"> (cm/rm) * log(1 + exp(rm * (t - tb)))</code>
</p>

<p>This function is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>explin: vector of the same length as x using a explin function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(12345)
x &lt;- seq(1,100, by = 5)
y &lt;- explin(x, 20, 0.14, 30) + rnorm(length(x), 0, 5)
y &lt;- abs(y)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSexplin(x, cm, rm, tb), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSharm1'>self start for a harmonic regression model</h2><span id='topic+SSharm1'></span><span id='topic+harm1'></span>

<h3>Description</h3>

<p>Self starter for a harmonic regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harm1(x, b0, b1, cos1, sin1)

SSharm1(x, b0, b1, cos1, sin1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSharm1_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSharm1_+3A_b0">b0</code></td>
<td>
<p>intercept of the harmonic regression</p>
</td></tr>
<tr><td><code id="SSharm1_+3A_b1">b1</code></td>
<td>
<p>slope of the harmonic regression</p>
</td></tr>
<tr><td><code id="SSharm1_+3A_cos1">cos1</code></td>
<td>
<p>coefficient associated with the cosine of the harmonic regression</p>
</td></tr>
<tr><td><code id="SSharm1_+3A_sin1">sin1</code></td>
<td>
<p>coefficient associated with the sine of the harmonic regression</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Harmonic regression is actually a type of linear regression. Just adding it for convenience.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>harm1: vector of the same length as x using a harmonic regression
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- seq(0, 3, length.out = 100)
y &lt;- harm1(x, 0, 0, 0.05, 0) + rnorm(length(x), 0, 0.002)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSharm1(x, b0, b1, cos1, sin1), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SShill'>self start for Hill Function</h2><span id='topic+SShill'></span><span id='topic+hill1'></span><span id='topic+SShill1'></span><span id='topic+hill2'></span><span id='topic+SShill2'></span><span id='topic+hill3'></span><span id='topic+SShill3'></span>

<h3>Description</h3>

<p>Self starter for Hill function with parameters Ka, n and a
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hill1(x, Ka)

SShill1(x, Ka)

hill2(x, Ka, n)

SShill2(x, Ka, n)

hill3(x, Ka, n, a)

SShill3(x, Ka, n, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SShill_+3A_x">x</code></td>
<td>
<p>input vector (x). Concentration of substrate in the original Hill model.</p>
</td></tr>
<tr><td><code id="SShill_+3A_ka">Ka</code></td>
<td>
<p>parameter representing the concentration at which half of maximum y is attained</p>
</td></tr>
<tr><td><code id="SShill_+3A_n">n</code></td>
<td>
<p>parameter which controls the curvature</p>
</td></tr>
<tr><td><code id="SShill_+3A_a">a</code></td>
<td>
<p>parameter which controls the maximum value of the response (asymptote)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see https://en.wikipedia.org/wiki/Hill_equation_(biochemistry)
</p>
<p>The form of the equations are: <br />
hill1: </p>
<p style="text-align: center;"><code class="reqn">1 / (1 + (Ka/x))</code>
</p>
<p>. <br /> 
hill2: </p>
<p style="text-align: center;"><code class="reqn">1 / (1 + (Ka/x)^n)</code>
</p>
<p>. <br />
hill3: </p>
<p style="text-align: center;"><code class="reqn">a / (1 + (Ka/x)^n)</code>
</p>
<p>. <br />
</p>


<h3>Value</h3>

<p>hill1: vector of the same length as x (time) using the Hill 1 function
</p>
<p>hill2: vector of the same length as x (time) using the Hill 2 function
</p>
<p>hill3: vector of the same length as x (time) using the Hill 3 function
</p>


<h3>Note</h3>

<p>Zero values are not allowed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
## Example for hill1
set.seed(1234)
x &lt;- 1:20
y &lt;- hill1(x, 10) + rnorm(20, sd = 0.03)
dat1 &lt;- data.frame(x = x, y = y)
fit1 &lt;- nls(y ~ SShill1(x, Ka), data = dat1)

## Example for hill2
y &lt;- hill2(x, 10, 1.5) + rnorm(20, sd = 0.03)
dat2 &lt;- data.frame(x = x, y = y)
fit2 &lt;- nls(y ~ SShill2(x, Ka, n), data = dat2)

## Example for hill3
y &lt;- hill3(x, 10, 1.5, 5) + rnorm(20, sd = 0.03)
dat3 &lt;- data.frame(x = x, y = y)
fit3 &lt;- nls(y ~ SShill3(x, Ka, n, a), data = dat3)

ggplot(data = dat3, aes(x, y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit3)))

</code></pre>

<hr>
<h2 id='SSlinp'>self start for linear-plateau function</h2><span id='topic+SSlinp'></span><span id='topic+linp'></span>

<h3>Description</h3>

<p>Self starter for linear-plateau function with parameters a (intercept), b (slope), xs (break-point)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linp(x, a, b, xs)

SSlinp(x, a, b, xs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSlinp_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSlinp_+3A_a">a</code></td>
<td>
<p>the intercept</p>
</td></tr>
<tr><td><code id="SSlinp_+3A_b">b</code></td>
<td>
<p>the slope</p>
</td></tr>
<tr><td><code id="SSlinp_+3A_xs">xs</code></td>
<td>
<p>break-point of transition between linear and plateau</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is linear when <code class="reqn">x &lt; xs: (a + b * x)</code> and flat (<code class="reqn">asymptote = a + b * xs</code>) when <code class="reqn">x &gt;= xs</code>.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>linp: vector of the same length as x using the linear-plateau function
</p>


<h3>See Also</h3>

<p>package <a href="https://CRAN.R-project.org/package=segmented"><span class="pkg">segmented</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(123)
x &lt;- 1:30
y &lt;- linp(x, 0, 1, 20) + rnorm(30, 0, 0.5)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSlinp(x, a, b, xs), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))
## Confidence intervals
confint(fit)


</code></pre>

<hr>
<h2 id='SSlogis5'>self start for five-parameter logistic function</h2><span id='topic+SSlogis5'></span><span id='topic+logis5'></span>

<h3>Description</h3>

<p>Self starter for a five-parameter logistic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logis5(x, asym1, asym2, xmid, iscal, theta)

SSlogis5(x, asym1, asym2, xmid, iscal, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSlogis5_+3A_x">x</code></td>
<td>
<p>input vector (x)</p>
</td></tr>
<tr><td><code id="SSlogis5_+3A_asym1">asym1</code></td>
<td>
<p>asymptotic value for low values of x</p>
</td></tr>
<tr><td><code id="SSlogis5_+3A_asym2">asym2</code></td>
<td>
<p>asymptotic value for high values of x</p>
</td></tr>
<tr><td><code id="SSlogis5_+3A_xmid">xmid</code></td>
<td>
<p>value of x at which y = (asym1 + asym2)/2 (only when theta = 1)</p>
</td></tr>
<tr><td><code id="SSlogis5_+3A_iscal">iscal</code></td>
<td>
<p>steepness of transition from asym1 to asym2 (inverse of the scale)</p>
</td></tr>
<tr><td><code id="SSlogis5_+3A_theta">theta</code></td>
<td>
<p>asymmetry parameter, if it is equal to 1, this is the four parameter logistic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation for this function is:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = asym2 + (asym1 - asym2)/(1 + exp(iscal * (log(x) - log(xmid))))^theta</code>
</p>

<p>This is known as the Richards' function or the log-logistic and it is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x (time) containing parameter estimates for equation specified
</p>
<p>logis5: vector of the same length as x (time) using the 5-parameter logistic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- seq(0, 2000, 100)
y &lt;- logis5(x, 35, 10, 800, 5, 2) + rnorm(length(x), 0, 0.5)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSlogis5(x, asym1, asym2, xmid, iscal, theta), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

x &lt;- seq(0, 2000)
y &lt;- logis5(x, 30, 10, 800, 5, 2)
plot(x, y)
</code></pre>

<hr>
<h2 id='SSmoh'>self start for modified hyperbola (photosynthesis)</h2><span id='topic+SSmoh'></span><span id='topic+moh'></span>

<h3>Description</h3>

<p>Self starter for modified Hyperbola with parameters: asymp, xmin and k
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moh(x, asym, xmin, k)

SSmoh(x, asym, xmin, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSmoh_+3A_x">x</code></td>
<td>
<p>input vector (x) which is normally a controlling variable such as nitrogen</p>
</td></tr>
<tr><td><code id="SSmoh_+3A_asym">asym</code></td>
<td>
<p>asymptotic value when x tends to infinity</p>
</td></tr>
<tr><td><code id="SSmoh_+3A_xmin">xmin</code></td>
<td>
<p>value of x for which y equals zero</p>
</td></tr>
<tr><td><code id="SSmoh_+3A_k">k</code></td>
<td>
<p>curvature parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).
See Table S3 (Eq. 3.8)
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>moh: vector of the same length as x (time) using the modified hyperbola
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- seq(3, 30)
y &lt;- moh(x, 35, 3, 0.83) + rnorm(length(x), 0, 0.5)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSmoh(x, asym, xmin, k), data = dat)
## Visualize observed and simulated
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))
## Testing predict function
prd &lt;- predict_nls(fit, interval = "confidence")
datA &lt;- cbind(dat, prd)
## Plotting
ggplot(data = datA, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit))) + 
  geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), 
  fill = "purple", alpha = 0.3)

x &lt;- seq(0, 20)
y &lt;- moh(x, 30, 3, 0.9)
plot(x, y)
</code></pre>

<hr>
<h2 id='SSnrh'>self start for non-rectangular hyperbola (photosynthesis)</h2><span id='topic+SSnrh'></span><span id='topic+nrh'></span>

<h3>Description</h3>

<p>Self starter for Non-rectangular Hyperbola with parameters: asymptote, quantum efficiency, curvature and dark respiration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrh(x, asym, phi, theta, rd)

SSnrh(x, asym, phi, theta, rd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSnrh_+3A_x">x</code></td>
<td>
<p>input vector (x) which is normally light intensity (PPFD, Photosynthetic Photon Flux Density).</p>
</td></tr>
<tr><td><code id="SSnrh_+3A_asym">asym</code></td>
<td>
<p>asymptotic value for photosynthesis</p>
</td></tr>
<tr><td><code id="SSnrh_+3A_phi">phi</code></td>
<td>
<p>quantum efficiency (mol CO2 per mol of photons) or initial slope of the light response</p>
</td></tr>
<tr><td><code id="SSnrh_+3A_theta">theta</code></td>
<td>
<p>curvature parameter for smooth transition between limitations</p>
</td></tr>
<tr><td><code id="SSnrh_+3A_rd">rd</code></td>
<td>
<p>dark respiration or value of CO2 uptake at zero light levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x (time) containing parameter estimates for equation specified
</p>
<p>nrh: vector of the same length as x (time) using the non-rectangular hyperbola
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- seq(0, 2000, 100)
y &lt;- nrh(x, 35, 0.04, 0.83, 2) + rnorm(length(x), 0, 0.5)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSnrh(x, asym, phi, theta, rd), data = dat)
## Visualize observed and simulated
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))
## Testing predict function
prd &lt;- predict_nls(fit, interval = "confidence")
datA &lt;- cbind(dat, prd)
## Plotting
ggplot(data = datA, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit))) + 
  geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), 
  fill = "purple", alpha = 0.3)

x &lt;- seq(0, 2000)
y &lt;- nrh(x, 30, 0.04, 0.85, 2)
plot(x, y)
</code></pre>

<hr>
<h2 id='SSpexpf'>self start for plateau-exponential function</h2><span id='topic+SSpexpf'></span><span id='topic+pexpf'></span>

<h3>Description</h3>

<p>Self starter for an plateau-exponential function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pexpf(x, a, xs, c)

SSpexpf(x, a, xs, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSpexpf_+3A_x">x</code></td>
<td>
<p>input vector (x)</p>
</td></tr>
<tr><td><code id="SSpexpf_+3A_a">a</code></td>
<td>
<p>represents the value for the plateau</p>
</td></tr>
<tr><td><code id="SSpexpf_+3A_xs">xs</code></td>
<td>
<p>represents the breakpoint at which the plateau ends</p>
</td></tr>
<tr><td><code id="SSpexpf_+3A_c">c</code></td>
<td>
<p>represents the exponential rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation is: <code class="reqn">for x &lt; xs: y = a and x &gt;= xs: a * exp(c * (x-xs))</code>.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>pexpf: vector of the same length as x using the pexpf function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- 1:30
y &lt;- pexpf(x, 20, 15, -0.2) + rnorm(30, 0, 1)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSpexpf(x, a, xs, c), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSplin'>self start for plateau-linear function</h2><span id='topic+SSplin'></span><span id='topic+plin'></span>

<h3>Description</h3>

<p>Self starter for plateau-linear function with parameters a (plateau), xs (break-point), b (slope)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plin(x, a, xs, b)

SSplin(x, a, xs, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSplin_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSplin_+3A_a">a</code></td>
<td>
<p>the initial plateau</p>
</td></tr>
<tr><td><code id="SSplin_+3A_xs">xs</code></td>
<td>
<p>break-point of transition between plateau and linear</p>
</td></tr>
<tr><td><code id="SSplin_+3A_b">b</code></td>
<td>
<p>the slope</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initial plateau with a second linear phase. When <code class="reqn">x &lt; xs: y = a</code> and when <code class="reqn">x &gt;= xs: y = a + b * (x - xs)</code>.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>plin: vector of the same length as x using the plateau-linear function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(123)
x &lt;- 1:30
y &lt;- plin(x, 10, 20, 1) + rnorm(30, 0, 0.5)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSplin(x, a, xs, b), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))
## Confidence intervals
confint(fit)


</code></pre>

<hr>
<h2 id='SSpquad'>self start for plateau-quadratic function</h2><span id='topic+SSpquad'></span><span id='topic+pquad'></span>

<h3>Description</h3>

<p>Self starter for plateau-quadratic function with parameters a (plateau), xs (break-point), b (slope), c (quadratic)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pquad(x, a, xs, b, c)

SSpquad(x, a, xs, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSpquad_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSpquad_+3A_a">a</code></td>
<td>
<p>the plateau value</p>
</td></tr>
<tr><td><code id="SSpquad_+3A_xs">xs</code></td>
<td>
<p>break-point of transition between plateau and quadratic</p>
</td></tr>
<tr><td><code id="SSpquad_+3A_b">b</code></td>
<td>
<p>the slope (linear term)</p>
</td></tr>
<tr><td><code id="SSpquad_+3A_c">c</code></td>
<td>
<p>quadratic term</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reference for nonlinear regression Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>pquad: vector of the same length as x using the plateau-quadratic function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(12345)
x &lt;- 1:40
y &lt;- pquad(x, 5, 20, 1.7, -0.04) + rnorm(40, 0, 0.6)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSpquad(x, a, xs, b, c), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))
confint(fit)

</code></pre>

<hr>
<h2 id='SSpquad3'>self start for plateau-quadratic function</h2><span id='topic+SSpquad3'></span><span id='topic+pquad3'></span>

<h3>Description</h3>

<p>Self starter for plateau-quadratic function with (three) parameters a (intercept), b (slope), c (quadratic)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pquad3(x, a, b, c)

SSpquad3(x, a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSpquad3_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSpquad3_+3A_a">a</code></td>
<td>
<p>the intercept</p>
</td></tr>
<tr><td><code id="SSpquad3_+3A_b">b</code></td>
<td>
<p>the slope</p>
</td></tr>
<tr><td><code id="SSpquad3_+3A_c">c</code></td>
<td>
<p>quadratic term</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reference for nonlinear regression Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>quadp: vector of the same length as x using the quadratic-plateau function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
require(minpack.lm)
set.seed(123)
x &lt;- 1:30
y &lt;- pquad3(x, 20.5, 0.36, -0.012) + rnorm(30, 0, 0.3)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nlsLM(y ~ SSpquad3(x, a, b, c), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSprofd'>self start for profile decay function</h2><span id='topic+SSprofd'></span><span id='topic+profd'></span>

<h3>Description</h3>

<p>Self starter for a decay of a variable within a canopy (e.g. nitrogen concentration).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profd(x, a, b, c, d)

SSprofd(x, a, b, c, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSprofd_+3A_x">x</code></td>
<td>
<p>input vector (x)</p>
</td></tr>
<tr><td><code id="SSprofd_+3A_a">a</code></td>
<td>
<p>represents the maximum value</p>
</td></tr>
<tr><td><code id="SSprofd_+3A_b">b</code></td>
<td>
<p>represents the minimum value</p>
</td></tr>
<tr><td><code id="SSprofd_+3A_c">c</code></td>
<td>
<p>represents the rate of decay</p>
</td></tr>
<tr><td><code id="SSprofd_+3A_d">d</code></td>
<td>
<p>represents an empirical coefficient which provides flexibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506) and originally in Johnson et al. (2010) Annals of Botany 106: 735–749, 2010. (doi:10.1093/aob/mcq183).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>profd: vector of the same length as x using the profd function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- 1:10
y &lt;- profd(x, 0.3, 0.05, 0.5, 4) + rnorm(10, 0, 0.01)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSprofd(x, a, b, c, d), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))
## profiling
## It does not work at a lower alphamax level
## Use this if you want to look at all four parameters
## par(mfrow=c(2,2))
plot(profile(fit, alphamax = 0.016))
## Reset graphical parameter as appropriate: par(mfrow=c(1,1))
## parameter 'd' is not well constrained
confint(fit, level = 0.9)


</code></pre>

<hr>
<h2 id='SSquadp'>self start for quadratic-plateau function</h2><span id='topic+SSquadp'></span><span id='topic+quadp'></span>

<h3>Description</h3>

<p>Self starter for quadratic plateau function with parameters a (intercept), b (slope), c (quadratic), xs (break-point)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadp(x, a, b, c, xs)

SSquadp(x, a, b, c, xs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSquadp_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSquadp_+3A_a">a</code></td>
<td>
<p>the intercept</p>
</td></tr>
<tr><td><code id="SSquadp_+3A_b">b</code></td>
<td>
<p>the slope</p>
</td></tr>
<tr><td><code id="SSquadp_+3A_c">c</code></td>
<td>
<p>quadratic term</p>
</td></tr>
<tr><td><code id="SSquadp_+3A_xs">xs</code></td>
<td>
<p>break point of transition between quadratic and plateau</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reference for nonlinear regression Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>quadp: vector of the same length as x using the quadratic-plateau function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(123)
x &lt;- 1:30
y &lt;- quadp(x, 5, 1.7, -0.04, 20) + rnorm(30, 0, 0.6)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSquadp(x, a, b, c, xs), data = dat, algorithm = "port")
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSquadp3'>self start for quadratic-plateau function</h2><span id='topic+SSquadp3'></span><span id='topic+quadp3'></span>

<h3>Description</h3>

<p>Self starter for quadratic plateau function with (three) parameters a (intercept), b (slope), c (quadratic)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadp3(x, a, b, c)

SSquadp3(x, a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSquadp3_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSquadp3_+3A_a">a</code></td>
<td>
<p>the intercept</p>
</td></tr>
<tr><td><code id="SSquadp3_+3A_b">b</code></td>
<td>
<p>the slope</p>
</td></tr>
<tr><td><code id="SSquadp3_+3A_c">c</code></td>
<td>
<p>quadratic term</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation is, for a response (y) and a predictor (x): <br />
<code class="reqn">y ~ (x &lt;= xs) * (a + b * x + c * x^2) + (x &gt; xs) * (a + (-b^2)/(4 * c))</code> <br />
</p>
<p>where the break-point (xs) is -0.5*b/c <br />
and the asymptote is (a + (-b^2)/(4 * c))
</p>
<p>In this model the parameter &lsquo;xs&rsquo; is not directly estimated. If this is required,
the model &lsquo;SSquadp3xs&rsquo; should be used instead.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>quadp: vector of the same length as x using the quadratic-plateau function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(123)
x &lt;- 1:30
y &lt;- quadp3(x, 5, 1.7, -0.04) + rnorm(30, 0, 0.6)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSquadp3(x, a, b, c), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSquadp3xs'>self start for quadratic-plateau function (xs)</h2><span id='topic+SSquadp3xs'></span><span id='topic+quadp3xs'></span>

<h3>Description</h3>

<p>Self starter for quadratic plateau function with (three) parameters a (intercept), b (slope), xs (break-point)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadp3xs(x, a, b, xs)

SSquadp3xs(x, a, b, xs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSquadp3xs_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSquadp3xs_+3A_a">a</code></td>
<td>
<p>the intercept</p>
</td></tr>
<tr><td><code id="SSquadp3xs_+3A_b">b</code></td>
<td>
<p>the slope</p>
</td></tr>
<tr><td><code id="SSquadp3xs_+3A_xs">xs</code></td>
<td>
<p>break-point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation is, for a response (y) and a predictor (x): <br />
<code class="reqn">y ~ (x &lt;= xs) * (a + b * x + (-0.5 * b/xs) * x^2) + (x &gt; xs) * (a + (b^2)/(-2 * b/xs))</code> <br />
</p>
<p>where the quadratic term is (c) is -0.5*b/xs <br />
and the asymptote is (a + (b^2)/(4 * c)).
</p>
<p>This model does not estimate the quadratic parameter &lsquo;c&rsquo; directly. 
If this is required, the model &lsquo;SSquadp3&rsquo; should be used instead.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>quadp3xs: vector of the same length as x using the quadratic-plateau function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(123)
x &lt;- 1:30
y &lt;- quadp3xs(x, 5, 1.7, 20) + rnorm(30, 0, 0.6)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSquadp3xs(x, a, b, xs), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSratio'>self start for a rational curve</h2><span id='topic+SSratio'></span><span id='topic+ratio'></span>

<h3>Description</h3>

<p>Self starter for a rational curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratio(x, a, b, c, d)

SSratio(x, a, b, c, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSratio_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SSratio_+3A_a">a</code></td>
<td>
<p>parameter related to the maximum value of the response (numerator)</p>
</td></tr>
<tr><td><code id="SSratio_+3A_b">b</code></td>
<td>
<p>power exponent for numerator</p>
</td></tr>
<tr><td><code id="SSratio_+3A_c">c</code></td>
<td>
<p>parameter related to the maximum value of the response (denominator)</p>
</td></tr>
<tr><td><code id="SSratio_+3A_d">d</code></td>
<td>
<p>power exponent for denominator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation is: </p>
<p style="text-align: center;"><code class="reqn"> a * x ^ c / (1 + b * x ^ d)</code>
</p>

<p>This function is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506).  
One example application is in Bril et al. (1994) <a href="https://edepot.wur.nl/333930">https://edepot.wur.nl/333930</a> - pages 19 and 21. 
The parameters are difficult to interpret, but the function is very flexible. I have not tested this, 
but it might be beneficial to re-scale x and y to the (0,1) range if this function is hard to fit.
<a href="https://en.wikipedia.org/wiki/Rational_function">https://en.wikipedia.org/wiki/Rational_function</a>.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>ratio: vector of the same length as x using a rational function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
require(minpack.lm)
set.seed(1234)
x &lt;- 1:100
y &lt;- ratio(x, 1, 0.5, 1, 1.5) + rnorm(length(x), 0, 0.025)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nlsLM(y ~ SSratio(x, a, b, c, d), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSricker'>self start for Ricker Function</h2><span id='topic+SSricker'></span><span id='topic+ricker'></span>

<h3>Description</h3>

<p>Self starter for Ricker function with parameters a and b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ricker(time, a, b)

SSricker(time, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSricker_+3A_time">time</code></td>
<td>
<p>input vector (x) which is normally &lsquo;time&rsquo;, the smallest value should be close to zero.</p>
</td></tr>
<tr><td><code id="SSricker_+3A_a">a</code></td>
<td>
<p>which is related to the initial growth slope</p>
</td></tr>
<tr><td><code id="SSricker_+3A_b">b</code></td>
<td>
<p>which is related to the slowing down or decline</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506) and originally in Ricker, W. E. (1954) Stock and Recruitment Journal of the Fisheries Research Board of Canada, 11(5): 559–623. (doi:10.1139/f54-039).
The equation is: <code class="reqn">a * time * exp(-b * time)</code>.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x (time) containing parameter estimates for equation specified
</p>
<p>ricker: vector of the same length as x (time) using the ricker function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(123)
x &lt;- 1:30
y &lt;- 30 * x * exp(-0.3 * x) + rnorm(30, 0, 0.25)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SSricker(x, a, b), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))

</code></pre>

<hr>
<h2 id='SSscard3'>self start for smooth cardinal temperature response</h2><span id='topic+SSscard3'></span><span id='topic+scard3'></span>

<h3>Description</h3>

<p>Self starter for smooth cardinal temperature response function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scard3(x, tb, to, tm, curve = 2)

SSscard3(x, tb, to, tm, curve = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSscard3_+3A_x">x</code></td>
<td>
<p>input vector (x) which is normally &lsquo;temperature&rsquo;.</p>
</td></tr>
<tr><td><code id="SSscard3_+3A_tb">tb</code></td>
<td>
<p>base temperature</p>
</td></tr>
<tr><td><code id="SSscard3_+3A_to">to</code></td>
<td>
<p>optimum temperature</p>
</td></tr>
<tr><td><code id="SSscard3_+3A_tm">tm</code></td>
<td>
<p>maximum temperature</p>
</td></tr>
<tr><td><code id="SSscard3_+3A_curve">curve</code></td>
<td>
<p>curvature (default is 2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An example application can be found in (doi:10.1016/j.envsoft.2014.04.009)
</p>
<p>This function is described in Archontoulis and Miguez (2015) - (doi:10.2134/agronj2012.0506) - Equation 5.1 in Table 1.
</p>


<h3>Value</h3>

<p>scard3: vector of the same length as x using a scard3 function
</p>


<h3>Author(s)</h3>

<p>Caio dos Santos and Fernando Miguez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A temperature response function
require(ggplot2)
set.seed(1234)
x &lt;- 1:50
y &lt;- scard3(x, 13, 25, 36) + rnorm(length(x), sd = 0.05)
dat1 &lt;- data.frame(x = x, y = y)
fit1 &lt;- nls(y ~ SSscard3(x, tb, to, tm), data = dat1)

ggplot(data = dat1, aes(x, y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit1)))

</code></pre>

<hr>
<h2 id='SSsharp'>self start for temperature response</h2><span id='topic+SSsharp'></span><span id='topic+sharp'></span>

<h3>Description</h3>

<p>Self starter for temperature response function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sharp(temp, r_tref, e, el, tl, eh, th, tref = 25)

SSsharp(temp, r_tref, e, el, tl, eh, th, tref = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSsharp_+3A_temp">temp</code></td>
<td>
<p>input vector (x) which is normally &lsquo;temperature&rsquo;.</p>
</td></tr>
<tr><td><code id="SSsharp_+3A_r_tref">r_tref</code></td>
<td>
<p>rate at the standardised temperature, tref</p>
</td></tr>
<tr><td><code id="SSsharp_+3A_e">e</code></td>
<td>
<p>activation energy (eV)</p>
</td></tr>
<tr><td><code id="SSsharp_+3A_el">el</code></td>
<td>
<p>low temperature de-activation energy (eV)</p>
</td></tr>
<tr><td><code id="SSsharp_+3A_tl">tl</code></td>
<td>
<p>temperature at which the enzyme is half active and half suppressed due to low temperatures</p>
</td></tr>
<tr><td><code id="SSsharp_+3A_eh">eh</code></td>
<td>
<p>high temperature de-activation energy (eV)</p>
</td></tr>
<tr><td><code id="SSsharp_+3A_th">th</code></td>
<td>
<p>temperature at which enzyme is half active and half suppressed dut to high temperatures</p>
</td></tr>
<tr><td><code id="SSsharp_+3A_tref">tref</code></td>
<td>
<p>standardisation temperature in degrees centigrade. Temperature at which rates are not inactivated by either high or low temperatures. Typically, 25 degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see Schoolfield, R. M., Sharpe, P. J. &amp; Magnuson, C. E. Non-linear regression of biological temperature-dependent rate models based on absolute reaction-rate theory. Journal of Theoretical Biology 88, 719-731 (1981)
</p>


<h3>Value</h3>

<p>sharp: vector of the same length as x using a sharp function
</p>


<h3>Note</h3>

<p>I do not recommend using this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
require(minpack.lm)

temp &lt;- 0:45
rate &lt;- sharp(temp, 1, 0.03, 1.44, 28, 19, 44) + rnorm(length(temp), 0, 0.05)
dat &lt;- data.frame(temp = temp, rate = rate)
## Fit model
fit &lt;- nlsLM(rate ~ SSsharp(temp, r_tref, e, el, tl, eh, th, tref = 20), data = dat)
## Visualize
ggplot(data = dat, aes(temp, rate)) + geom_point() + geom_line(aes(y = fitted(fit)))


</code></pre>

<hr>
<h2 id='SStemp3'>self start for Collatz temperature response</h2><span id='topic+SStemp3'></span><span id='topic+temp3'></span>

<h3>Description</h3>

<p>Self starter for Collatz temperature response function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp3(x, t.m, t.l, t.h)

SStemp3(x, t.m, t.l, t.h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SStemp3_+3A_x">x</code></td>
<td>
<p>input vector (x) which is normally &lsquo;temperature&rsquo;.</p>
</td></tr>
<tr><td><code id="SStemp3_+3A_t.m">t.m</code></td>
<td>
<p>medium temperature</p>
</td></tr>
<tr><td><code id="SStemp3_+3A_t.l">t.l</code></td>
<td>
<p>low temperature</p>
</td></tr>
<tr><td><code id="SStemp3_+3A_t.h">t.h</code></td>
<td>
<p>high temperature</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Collatz GJ , Ribas-Carbo M Berry JA (1992) Coupled Photosynthesis-Stomatal Conductance Model for Leaves of C4 Plants. Functional Plant Biology 19, 519-538.
https://doi.org/10.1071/PP9920519
</p>


<h3>Value</h3>

<p>temp3: vector of the same length as x using a temp function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A temperature response function
require(ggplot2)
set.seed(1234)
x &lt;- 1:50
y &lt;- temp3(x, 25, 13, 36) + rnorm(length(x), sd = 0.05)
dat1 &lt;- data.frame(x = x, y = y)
fit1 &lt;- nls(y ~ SStemp3(x, t.m, t.l, t.h), data = dat1)

ggplot(data = dat1, aes(x, y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit1)))

</code></pre>

<hr>
<h2 id='SStrlin'>self start for a trilinear Function</h2><span id='topic+SStrlin'></span><span id='topic+trlin'></span>

<h3>Description</h3>

<p>Self starter for a tri-linear function with parameters a (intercept), b (first slope), xs1 (first break-point), c (second slope), xs2 (second break-point) and d (third slope)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trlin(x, a, b, xs1, c, xs2, d)

SStrlin(x, a, b, xs1, c, xs2, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SStrlin_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="SStrlin_+3A_a">a</code></td>
<td>
<p>the intercept</p>
</td></tr>
<tr><td><code id="SStrlin_+3A_b">b</code></td>
<td>
<p>the first-phase slope</p>
</td></tr>
<tr><td><code id="SStrlin_+3A_xs1">xs1</code></td>
<td>
<p>first break-point of transition between first-phase linear and second-phase linear</p>
</td></tr>
<tr><td><code id="SStrlin_+3A_c">c</code></td>
<td>
<p>the second-phase slope</p>
</td></tr>
<tr><td><code id="SStrlin_+3A_xs2">xs2</code></td>
<td>
<p>second break-point of transition between second-phase linear and third-phase linear</p>
</td></tr>
<tr><td><code id="SStrlin_+3A_d">d</code></td>
<td>
<p>the third-phase slope</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a special case with just three parts (and two break points) but a more general approach 
is to consider a segmented function with several breakpoints and linear segments. 
Splines would be even more general. Also this model assumes that there are two break-points that needs 
to be estimated. The guess for the initial values splits the dataset in half, so it this will work
when one break-point is in the first half and the second is in the second half.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x containing parameter estimates for equation specified
</p>
<p>trlin: vector of the same length as x using the tri-linear function
</p>


<h3>See Also</h3>

<p>package <span class="pkg">segmented</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
set.seed(1234)
x &lt;- 1:30
y &lt;- trlin(x, 0.5, 2, 10, 0.1, 20, 1.75) + rnorm(30, 0, 0.5)
dat &lt;- data.frame(x = x, y = y)
fit &lt;- nls(y ~ SStrlin(x, a, b, xs1, c, xs2, d), data = dat)
## plot
ggplot(data = dat, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line(aes(y = fitted(fit)))
## Minimal example
## This is probably about the smallest dataset you 
## should use with this function
dat2 &lt;- data.frame(x = 1:8, y = c(1.1, 1.9, 3.1, 2.5, 1.4, 0.9, 2.2, 2.9))
fit2 &lt;- nls(y ~ SStrlin(x, a, b, xs1, c, xs2, d), data = dat2)
## expangin for plotting
ndat &lt;- data.frame(x = seq(1, 8, by = 0.1))
ndat$prd &lt;- predict(fit2, newdata = ndat)
ggplot() + 
  geom_point(data = dat2, aes(x = x, y = y)) + 
  geom_line(data = ndat, aes(x = x, y = prd))


</code></pre>

<hr>
<h2 id='summary_simulate'>Summarize a matrix of simulations by their mean (median), sd (mad), and quantiles</h2><span id='topic+summary_simulate'></span>

<h3>Description</h3>

<p>Utility function to summarize the output from &lsquo;simulate&rsquo; 
functions in this package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_simulate(
  object,
  probs = c(0.025, 0.975),
  robust = FALSE,
  data,
  by,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_simulate_+3A_object">object</code></td>
<td>
<p>nobs x nsim matrix where nobs are the number of observations in the
dataset and nsim are the number of simulations</p>
</td></tr>
<tr><td><code id="summary_simulate_+3A_probs">probs</code></td>
<td>
<p>the percentiles to be computed by the quantile function</p>
</td></tr>
<tr><td><code id="summary_simulate_+3A_robust">robust</code></td>
<td>
<p>If FALSE (the default) the mean is used as the measure of central tendency 
and the standard deviation as the measure of variability. 
If TRUE, the median and the median absolute deviation (MAD) are applied instead.</p>
</td></tr>
<tr><td><code id="summary_simulate_+3A_data">data</code></td>
<td>
<p>the original data.frame used to fit the model. A data.frame will be
returned instead of a matrix in this case.</p>
</td></tr>
<tr><td><code id="summary_simulate_+3A_by">by</code></td>
<td>
<p>opionally aggregate the results by some factor in the data.frame. It 
will be coarced to a formula. This should either be a character or a formula (starting with &lsquo;~&rsquo;).
The aggregation follows the &lsquo;robust&rsquo; argument above.</p>
</td></tr>
<tr><td><code id="summary_simulate_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed. (none used at the moment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default it returns a matrix unless the &lsquo;data&rsquo; argument is present and then
it will return a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(barley, package = "nlraa")
fit &lt;- nls(yield ~ SSlinp(NF, a, b, xs), data = barley)
sim &lt;- simulate_nls(fit, nsim = 100)
sims &lt;- summary_simulate(sim)

## If we want to combine the data.frame
simd &lt;- summary_simulate(sim, data = barley)
## If we also want to aggregate by nitrogen rate
simda &lt;- summary_simulate(sim, data = barley, by = "NF")
## The robust option uses the median instead
simdar &lt;- summary_simulate(sim, data = barley, by = "NF",
                           robust = TRUE)



</code></pre>

<hr>
<h2 id='swpg'>Water limitations for Soybean growth</h2><span id='topic+swpg'></span>

<h3>Description</h3>

<p>Simulated data based on obseved data presented in Sinclair (1986) - Fig. 1A
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swpg
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 3 columns
</p>

<dl>
<dt>ftsw</dt><dd><p>Fraction of Transpirable Soil Water (0-1)</p>
</dd>
<dt>lfgr</dt><dd><p>Relative Leaf Growth scaled from 0 to 1</p>
</dd>
</dl>



<h3>Details</h3>

<p>Sinclair, T.R. Water and Nitrogen Limitations in Soybean Grain Production I. Model Development.
Field Crops Research. 125-141.
</p>


<h3>Source</h3>

<p>Simluated data (much cleaner than original) based on the above publication
</p>

<hr>
<h2 id='var_cov'>Variance Covariance matrix of for g(n)ls and (n)lme models</h2><span id='topic+var_cov'></span>

<h3>Description</h3>

<p>Extracts the variance covariance matrix (residuals, random or all)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_cov(
  object,
  type = c("residual", "random", "all", "conditional", "marginal"),
  aug = FALSE,
  sparse = FALSE,
  data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_cov_+3A_object">object</code></td>
<td>
<p>object which inherits class <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="nlme.html#topic+gls">gls</a></code> or <code><a href="nlme.html#topic+lme">lme</a></code></p>
</td></tr>
<tr><td><code id="var_cov_+3A_type">type</code></td>
<td>
<p>&ldquo;residual&rdquo; for the variance-covariance for the residuals, &ldquo;random&rdquo;
for the variance-covariance of the random effects or &ldquo;all&rdquo; for the sum of both.</p>
</td></tr>
<tr><td><code id="var_cov_+3A_aug">aug</code></td>
<td>
<p>whether to augment the matrix of the random effects to the dimensions of the data</p>
</td></tr>
<tr><td><code id="var_cov_+3A_sparse">sparse</code></td>
<td>
<p>whether to return a sparse matrix (default is FALSE)</p>
</td></tr>
<tr><td><code id="var_cov_+3A_data">data</code></td>
<td>
<p>optional passing of &lsquo;data&rsquo;, probably needed when using this function inside other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variance Covariance matrix for (non)linear mixed models
</p>


<h3>Value</h3>

<p>It returns a <code><a href="base.html#topic+matrix">matrix</a></code> or a sparse matrix <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>.
</p>


<h3>Note</h3>

<p>See Chapter 5 of Pinheiro and Bates. This returns potentially a very large 
matrix of N x N, where N is the number of rows in the data.frame. 
The function <code><a href="nlme.html#topic+getVarCov">getVarCov</a></code> only works well for  
<code><a href="nlme.html#topic+lme">lme</a></code> objects. <br />
The equivalence is more or less: <br />
getVarCov type = &ldquo;random.effects&rdquo; equivalent to var_cov type = &ldquo;random&rdquo;. <br />
getVarCov type = &ldquo;conditional&rdquo; equivalent to var_cov type = &ldquo;residual&rdquo;. <br />
getVarCov type = &ldquo;marginal&rdquo; equivalent to var_cov type = &ldquo;all&rdquo;. <br />
The difference is that getVarCov has an argument that specifies the individual 
for which the matrix is being retrieved and var_cov returns the full matrix only.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+getVarCov">getVarCov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(graphics)
require(nlme)
data(ChickWeight)
## First a linear model
flm &lt;- lm(weight ~ Time, data = ChickWeight)
vlm &lt;- var_cov(flm)
## First model with no modeling of the Variance-Covariance
fit0 &lt;- gls(weight ~ Time, data = ChickWeight)
v0 &lt;- var_cov(fit0)
## Only modeling the diagonal (weights)
fit1 &lt;- gls(weight ~ Time, data = ChickWeight, weights = varPower())
v1 &lt;- var_cov(fit1)
## Only the correlation structure is defined and there are no groups
fit2 &lt;- gls(weight ~ Time, data = ChickWeight, correlation = corAR1())
v2 &lt;- var_cov(fit2)
## The correlation structure is defined and there are groups present
fit3 &lt;- gls(weight ~ Time, data = ChickWeight, correlation = corCAR1(form = ~ Time | Chick))
v3 &lt;- var_cov(fit3)
## There are both weights and correlations
fit4 &lt;- gls(weight ~ Time, data = ChickWeight, 
            weights = varPower(),
            correlation = corCAR1(form = ~ Time | Chick))
v4 &lt;- var_cov(fit4)
## Tip: you can visualize these matrices using
image(log(v4[,ncol(v4):1]))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
