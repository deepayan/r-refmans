<!DOCTYPE html><html><head><title>Help for package GMCM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GMCM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GMCM-package'><p>Fast optimization of Gaussian Mixture Copula Models</p></a></li>
<li><a href='#as.theta'><p>Coerce a list to a theta object</p></a></li>
<li><a href='#choose.theta'><p>Heuristically chosen starting value of theta</p></a></li>
<li><a href='#classify'><p>Classify observations</p></a></li>
<li><a href='#colSds'><p>Row and column standard deviations</p></a></li>
<li><a href='#cummean'><p>Cumulative mean values</p></a></li>
<li><a href='#dgmcm.loglik'><p>Probability, density, and likelihood functions of the Gaussian mixture</p>
(copula) model</a></li>
<li><a href='#dmvnormal'><p>Multivariate Gaussian density and simulation</p></a></li>
<li><a href='#EMAlgorithm'><p>EM algorithm for Gaussian mixture models</p></a></li>
<li><a href='#EStep'><p>Steps of the EM algorithm for a Gaussian Mixture model</p></a></li>
<li><a href='#fit.full.GMCM'><p>Estimate GMCM parameters of the general model</p></a></li>
<li><a href='#fit.meta.GMCM'><p>Estimate GMCM parameters of the special model</p></a></li>
<li><a href='#freshVsFrozen'><p>Reproducibility between Fresh and Frozen B-cell subtypes</p></a></li>
<li><a href='#full2meta'><p>Convert between parameter formats</p></a></li>
<li><a href='#get.IDR'><p>Posterior class probabilities, local, and adjusted IDRs.</p></a></li>
<li><a href='#goodness.of.fit'><p>Goodness of fit for the general GMCM</p></a></li>
<li><a href='#inv.logit'><p>Logit and inverse logit transforms</p></a></li>
<li><a href='#inv.rho.transform'><p>Transformation of the correlation to real line and its inverse</p></a></li>
<li><a href='#inv.tt'><p>Reparametrization of GMCM parameters</p></a></li>
<li><a href='#is.theta'><p>Check if parameters are valid</p></a></li>
<li><a href='#plot.theta'><p>Plotting method for &quot;theta&quot; objects</p></a></li>
<li><a href='#print.theta'><p>Print method for theta class</p></a></li>
<li><a href='#PseudoEMAlgorithm'><p>EM-like algorithm for the GMCM</p></a></li>
<li><a href='#rtheta'><p>Get random parameters for the Gaussian mixture (copula) model</p></a></li>
<li><a href='#runGMCM'><p>Run the GMCM shiny application</p></a></li>
<li><a href='#SimulateGMCMData'><p>Simulation from Gaussian mixture (copula) models</p></a></li>
<li><a href='#summary.theta'><p>Summary method for theta class</p></a></li>
<li><a href='#u133VsExon'><p>Reproducibility between U133 plus 2 and Exon microarrays</p></a></li>
<li><a href='#Uhat'><p>Fast ranking function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Estimation of Gaussian Mixture Copula Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Unsupervised Clustering and Meta-analysis using Gaussian Mixture
    Copula Models.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AEBilgrau/GMCM">https://github.com/AEBilgrau/GMCM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AEBilgrau/GMCM/issues">https://github.com/AEBilgrau/GMCM/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>KeepSource:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.10.6), ellipse</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>idr, Hmisc, RColorBrewer, foreach, jpeg, testthat (&ge; 0.3),
knitr, rmarkdown, shiny, shinydashboard, shinyBS,
rhandsontable, DT</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-11-05 18:13:37 UTC; anders</td>
</tr>
<tr>
<td>Author:</td>
<td>Anders Ellern Bilgrau
    <a href="https://orcid.org/0000-0001-9875-2902"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Poul Svante Eriksen
    <a href="https://orcid.org/0000-0001-9192-1814"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ths, ctb],
  Martin Boegsted [ths, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-11-05 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GMCM-package'>Fast optimization of Gaussian Mixture Copula Models</h2><span id='topic+GMCM-package'></span><span id='topic+GMCM'></span>

<h3>Description</h3>

<p>Gaussian mixture copula models (GMCM) are a flexible class of statistical
models which can be used for unsupervised clustering, meta analysis, and
many other things. In meta analysis, GMCMs can be used to
quantify and identify which features which have been reproduced across
multiple experiments. This package provides a fast and general
implementation of GMCM cluster analysis and serves as an improvement and
extension of the features available in the <code>idr</code> package.
</p>


<h3>Details</h3>

<p>If the meta analysis of Li et al. (2011) is to be performed, the
function <code><a href="#topic+fit.meta.GMCM">fit.meta.GMCM</a></code> is used to identify the maximum
likelihood estimate of the special Gaussian mixture copula model (GMCM)
defined by Li et al. (2011). The function <code><a href="#topic+get.IDR">get.IDR</a></code>
computes the local and adjusted Irreproducible Discovery Rates defined
by Li et al. (2011) to determine the level of reproducibility.
</p>
<p>Tewari et. al. (2011) proposed using GMCMs as an general unsupervised
clustering tool. If such a general unsupervised clustering is needed, like
above, the function <code><a href="#topic+fit.full.GMCM">fit.full.GMCM</a></code> computes the maximum
likelihood estimate of the general GMCM. The function
<code><a href="#topic+get.prob">get.prob</a></code> is used to estimate the class membership
probabilities of each observation.
</p>
<p><code><a href="#topic+SimulateGMCMData">SimulateGMCMData</a></code> provide easy simulation from the GMCMs.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau,
Martin Boegsted,
Poul Svante Eriksen
</p>
<p>Maintainer: Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Anders Ellern Bilgrau, Poul Svante Eriksen, Jakob Gulddahl Rasmussen,
Hans Erik Johnsen, Karen Dybkaer, Martin Boegsted (2016). GMCM:
Unsupervised Clustering and Meta-Analysis Using Gaussian Mixture Copula
Models. Journal of Statistical Software, 70(2), 1-23.
doi:10.18637/jss.v070.i02
</p>
<p>Li, Q., Brown, J. B. J. B., Huang, H., &amp; Bickel, P. J. (2011).
Measuring reproducibility of high-throughput experiments. The Annals of
Applied Statistics, 5(3), 1752-1779. doi:10.1214/11-AOAS466
</p>
<p>Tewari, A., Giering, M. J., &amp; Raghunathan, A. (2011). Parametric
Characterization of Multimodal Distributions with Non-gaussian Modes.
2011 IEEE 11th International Conference on Data Mining Workshops,
286-292. doi:10.1109/ICDMW.2011.135
</p>


<h3>See Also</h3>

<p>Core user functions: <code><a href="#topic+fit.meta.GMCM">fit.meta.GMCM</a></code>,
<code><a href="#topic+fit.full.GMCM">fit.full.GMCM</a></code>, <code><a href="#topic+get.IDR">get.IDR</a></code>,
<code><a href="#topic+get.prob">get.prob</a></code>, <code><a href="#topic+SimulateGMCMData">SimulateGMCMData</a></code>,
<code><a href="#topic+SimulateGMMData">SimulateGMMData</a></code>, <code><a href="#topic+rtheta">rtheta</a></code>,
<code><a href="#topic+Uhat">Uhat</a></code>, <code><a href="#topic+choose.theta">choose.theta</a></code>,
<code><a href="#topic+full2meta">full2meta</a></code>, <code><a href="#topic+meta2full">meta2full</a></code>
</p>
<p>Package by Li et. al. (2011): <code><a href="idr.html#topic+idr-package">idr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading data
data(u133VsExon)

# Subsetting data to reduce computation time
u133VsExon &lt;- u133VsExon[1:5000, ]

# Ranking and scaling,
# Remember large values should be critical to the null!
uhat &lt;- Uhat(1 - u133VsExon)

# Visualizing P-values and the ranked and scaled P-values
## Not run: 
par(mfrow = c(1,2))
plot(u133VsExon, cex = 0.5, pch = 4, col = "tomato", main = "P-values",
     xlab = "P   (U133)", ylab = "P   (Exon)")
plot(uhat, cex = 0.5, pch = 4, col = "tomato", main = "Ranked P-values",
     xlab = "rank(1-P)   (U133)", ylab = "rank(1-P)   (Exon)")

## End(Not run)

# Fitting using BFGS
fit &lt;- fit.meta.GMCM(uhat, init.par = c(0.5, 1, 1, 0.5), pgtol = 1e-2,
                     method = "L-BFGS", positive.rho = TRUE, verbose = TRUE)

# Compute IDR values and classify
idr &lt;- get.IDR(uhat, par = fit)
table(idr$K) # 1 = irreproducible, 2 = reproducible

## Not run: 
# See clustering results
par(mfrow = c(1,2))
plot(u133VsExon, cex = 0.5, pch = 4, main = "Classified genes",
     col = c("tomato", "steelblue")[idr$K],
     xlab = "P-value (U133)", ylab = "P-value (Exon)")
plot(uhat, cex = 0.5, pch = 4, main = "Classified genes",
     col = c("tomato", "steelblue")[idr$K],
     xlab = "rank(1-P) (U133)", ylab = "rank(1-P) (Exon)")

## End(Not run)
</code></pre>

<hr>
<h2 id='as.theta'>Coerce a list to a theta object</h2><span id='topic+as.theta'></span>

<h3>Description</h3>

<p>A function that attempts to coerce a theta-like list into a proper formatted
object of class <code>theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.theta(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.theta_+3A_x">x</code></td>
<td>
<p>A theta-like object that can be coerced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, if the list is of length 3 and not 5, the number of components and
dimension is assumed to be missing and added.
Secondly, the class is added.
Thirdly, names are added if needed.
Next, matrix means and array covariances are
coerced to list form.
Covariances on array form are assumed to be <code>d</code> by <code>d</code> by <code>m</code>.
Means on matrix form are as assumed to be <code>d</code> by <code>m</code>. I.e.
rows correspond to the dimensions and columns to components, or the mean vectors
as column vectors.
Finally, the sum constraint of 1 for the mixture proportions is enforced.
</p>


<h3>Value</h3>

<p>A theta object. See <code><a href="#topic+rtheta">rtheta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 2
d &lt;- 3
x &lt;- list(m = m,
          d = d,
          pie = c(0.5, 0.5),
          mu = list(comp1=rep(0,d), comp2=rep(1,d)),
          sigma = list(comp1=diag(d), comp2=diag(d)))
print(x)
theta &lt;- as.theta(x)
print(theta)

x2 &lt;- unname(list( # Unnamed
  # missing m and d
  pie = c(1, 1),   # Does not sum to 1
  mu = simplify2array(list(comp1=rep(0,d), comp2=rep(1,d))), # matrix, not a list
  sigma = simplify2array(list(comp1=diag(d), comp2=diag(d)))  # array, not a list
))
theta2 &lt;- as.theta(x2)
print(theta2)
</code></pre>

<hr>
<h2 id='choose.theta'>Heuristically chosen starting value of theta</h2><span id='topic+choose.theta'></span>

<h3>Description</h3>

<p>This function uses a <code>k</code>-means algorithm to heuristically select
suitable starting values for the general model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose.theta(u, m, no.scaling = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choose.theta_+3A_u">u</code></td>
<td>
<p>A matrix of (estimates of) realizations from the GMCM.</p>
</td></tr>
<tr><td><code id="choose.theta_+3A_m">m</code></td>
<td>
<p>The number of components to be fitted.</p>
</td></tr>
<tr><td><code id="choose.theta_+3A_no.scaling">no.scaling</code></td>
<td>
<p>Logical. If TRUE, no scaling of the means and
variance-covariance matrices is done.</p>
</td></tr>
<tr><td><code id="choose.theta_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function selects the centers from the k-means algorithm as an initial
estimate of the means. The proportional sizes of the clusters are selected
as the initial values of the mixture proportions. The within cluster
standard deviations are squared and used as the variance of the clusters
within each dimension. The
correlations between each dimension are taken to be zero.
</p>


<h3>Value</h3>

<p>A list of parameters for the GMCM model on the form described in
<code><a href="#topic+rtheta">rtheta</a></code>.
</p>


<h3>Note</h3>

<p>The function uses the <code>kmeans</code> function from the
<code>stats</code>-package.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)

# Simulating data
data1 &lt;- SimulateGMCMData(n = 10000, m = 3, d = 2)
obs.data &lt;- Uhat(data1$u)  # The ranked observed data

# Using choose.theta to get starting estimates
theta &lt;- choose.theta(u = obs.data, m = 3)
print(theta)

# To illustrate theta, we can simulate from the model
data2 &lt;- SimulateGMMData(n = 10000, theta = theta)

cols &lt;- apply(get.prob(obs.data,theta),1,which.max)

# Plotting
par(mfrow = c(1,3))
plot(data1$z, main = "True latent GMM")
plot(Uhat(data1$u), col = cols,
     main = "Observed GMCM\nColoured by k-means clustering")
plot(data2$z, main = "initial GMM")

# Alteratively, theta can simply be plotted to illustrate the GMM density
par(mfrow = c(1,1))
plot(theta, add.ellipses = TRUE)
points(data2$z, pch = 16, cex = 0.4)
</code></pre>

<hr>
<h2 id='classify'>Classify observations</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p>Classify observations according to the maximum a posterior probabilites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_x">x</code></td>
<td>
<p>Either a <code>matrix</code> of A) observations where rows corresponds to
obsercations and columns to dimensions or B) class probabilities where rows
correspond to obsevations and columns to components.</p>
</td></tr>
<tr><td><code id="classify_+3A_theta">theta</code></td>
<td>
<p>A list of parameters for the full model as described in
<code><a href="#topic+rtheta">rtheta</a></code>. If <code>theta</code> is supplied, <code>x</code> are assumed to
be observations (A). If <code>theta</code> is missing, <code>x</code> are assumed to be
probabilites (B).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A integer vector of class numbers with length equal to the number of
rows in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.prob">get.prob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Classify using probabilites (usually returned from get.prob)
probs &lt;- matrix(runif(75), 25, 3)
classify(probs)

# Classify using a matrix of observations and theta
theta &lt;- rtheta(d = 4, m = 3)
u &lt;- SimulateGMCMData(n = 20, theta = theta)$u
classify(x = u, theta = theta)
</code></pre>

<hr>
<h2 id='colSds'>Row and column standard deviations</h2><span id='topic+colSds'></span><span id='topic+rowSds'></span>

<h3>Description</h3>

<p>The <code>rowSds</code> and <code>colSds</code> respectively computes the
standard deviations of each rows and columns of the given matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colSds(x)

rowSds(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colSds_+3A_x">x</code></td>
<td>
<p>A numeric matrix of size <code>n</code> times <code>m</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>colSds</code> returns a numeric vector of length <code>m</code>.
</p>
<p><code>rowSds</code> returns a numeric vector of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+rowMeans">rowMeans</a></code>, <code><a href="Matrix.html#topic+colMeans">colMeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(50), 10, 5)
GMCM:::colSds(x)
apply(x, 2, sd)  # slower equivalent code
y &lt;- matrix(rnorm(50), 10, 5)
GMCM:::rowSds(y)
</code></pre>

<hr>
<h2 id='cummean'>Cumulative mean values</h2><span id='topic+cummean'></span>

<h3>Description</h3>

<p>Returns a vector whose <code>i</code>'th element is the cumulative mean
(arithmetic mean) of the <code>i</code>'th first elements of the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cummean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cummean_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>length(x)</code> with the cumulative mean. The
<code>i</code>'th entry <code>cummean(x)[i]</code> equals <code>mean(x[1:i])</code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cumsum">cumsum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sort(rnorm(100))
GMCM:::cummean(x)
</code></pre>

<hr>
<h2 id='dgmcm.loglik'>Probability, density, and likelihood functions of the Gaussian mixture
(copula) model</h2><span id='topic+dgmcm.loglik'></span><span id='topic+dgmm.loglik'></span><span id='topic+dgmm.loglik.marginal'></span><span id='topic+pgmm.marginal'></span><span id='topic+qgmm.marginal'></span>

<h3>Description</h3>

<p>Marginal and simultaneous cumulative distribution, log probability density,
and log-likelihood functions of the Gaussian mixture model (GMM) and
Gaussian mixture copula model (GMCM) and the relevant inverse marginal
quantile functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgmcm.loglik(theta, u, marginal.loglik = FALSE, ...)

dgmm.loglik(theta, z, marginal.loglik = FALSE)

dgmm.loglik.marginal(theta, x, marginal.loglik = TRUE)

pgmm.marginal(z, theta)

qgmm.marginal(u, theta, res = 1000, spread = 5, rule = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgmcm.loglik_+3A_theta">theta</code></td>
<td>
<p>A list parameters as described in <code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
<tr><td><code id="dgmcm.loglik_+3A_u">u</code></td>
<td>
<p>A matrix of (estimates of) realizations from the GMCM where each
row corresponds to an observation.</p>
</td></tr>
<tr><td><code id="dgmcm.loglik_+3A_marginal.loglik">marginal.loglik</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the marginal log-likelihood
functions for each multivariate observation (i.e. the log densities) are
returned. In other words, if <code>TRUE</code> the sum of the marginal
likelihoods is not computed.</p>
</td></tr>
<tr><td><code id="dgmcm.loglik_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>qgmm.marginal</code>.</p>
</td></tr>
<tr><td><code id="dgmcm.loglik_+3A_z">z</code></td>
<td>
<p>A matrix of realizations from the latent process where each row
corresponds to an observation.</p>
</td></tr>
<tr><td><code id="dgmcm.loglik_+3A_x">x</code></td>
<td>
<p>A matrix where each row corresponds to an observation.</p>
</td></tr>
<tr><td><code id="dgmcm.loglik_+3A_res">res</code></td>
<td>
<p>The resolution at which the inversion of <code>qgmm.marginal</code> is
done. Default is 1000.</p>
</td></tr>
<tr><td><code id="dgmcm.loglik_+3A_spread">spread</code></td>
<td>
<p>The number of marginal standard deviations from the marginal
means the <code>pgmm.marginal</code> is to be evaluated on.</p>
</td></tr>
<tr><td><code id="dgmcm.loglik_+3A_rule">rule</code></td>
<td>
<p>The extrapolation rule used in <code><a href="stats.html#topic+approxfun">approxfun</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qgmm.marginal</code> distributes approximately <code>res</code> points around the
cluster centers according to the mixture proportions in <code>theta$pie</code> and
evaluates <code>pgmm.marginal</code> on these points. An approximate inverse of
<code>pgmm.marginal</code> function is constructed by linear interpolation of the
flipped evaluated coordinates.
</p>


<h3>Value</h3>

<p>The returned value depends on the value of <code>marginal.loglik</code>.
If <code>TRUE</code>, the non-summed marginal likelihood values are returned. If
<code>FALSE</code>, the scalar sum log-likelihood is returned.
</p>
<p><code>dgmcm.loglik</code>: As above, with the GMCM density.
</p>
<p><code>dgmm.loglik</code>: As above, with the GMM density.
</p>
<p><code>dgmm.loglik.marginal</code>: As above, where the j'th element is evaluated
in the j'th marginal GMM density.
</p>
<p><code>pgmm.marginal</code>: A matrix where the (i,j)'th entry is the (i,j)'th
entry of <code>z</code> evaluated in the jth marginal GMM density.
</p>
<p><code>qgmm.marginal</code>: A matrix where the (i,j)'th entry is the (i,j)'th
entry of <code>u</code> evaluated in the inverse jth marginal GMM density.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data &lt;- SimulateGMCMData(n = 10)
u &lt;- data$u
z &lt;- data$z
print(theta &lt;- data$theta)

GMCM:::dgmcm.loglik(theta, u, marginal.loglik = FALSE)
GMCM:::dgmcm.loglik(theta, u, marginal.loglik = TRUE)

GMCM:::dgmm.loglik(theta, z, marginal.loglik = FALSE)
GMCM:::dgmm.loglik(theta, z, marginal.loglik = TRUE)

GMCM:::dgmm.loglik.marginal(theta, z, marginal.loglik = FALSE)
GMCM:::dgmm.loglik.marginal(theta, z, marginal.loglik = TRUE)

GMCM:::pgmm.marginal(z, theta)
GMCM:::qgmm.marginal(u, theta)
</code></pre>

<hr>
<h2 id='dmvnormal'>Multivariate Gaussian density and simulation</h2><span id='topic+dmvnormal'></span><span id='topic+rmvnormal'></span>

<h3>Description</h3>

<p>Fast simulation from and evaluation of multivariate Gaussian probability
densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvnormal(x, mu, sigma)

rmvnormal(n, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmvnormal_+3A_x">x</code></td>
<td>
<p>A <code>p</code> times <code>k</code> matrix of quantiles. Each rows
correspond to a realization from the density and each column corresponds
to a dimension.</p>
</td></tr>
<tr><td><code id="dmvnormal_+3A_mu">mu</code></td>
<td>
<p>The mean vector of dimension <code>k</code>.</p>
</td></tr>
<tr><td><code id="dmvnormal_+3A_sigma">sigma</code></td>
<td>
<p>The variance-covariance matrix of dimension <code>k</code> times
<code>k</code>.</p>
</td></tr>
<tr><td><code id="dmvnormal_+3A_n">n</code></td>
<td>
<p>The number of observations to be simulated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dmvnormal</code> functions similarly to <code>dmvnorm</code> from the
<code>mvtnorm</code>-package and likewise for <code>rmvnormal</code> and
<code>rmvnorm</code>.
</p>


<h3>Value</h3>

<p><code>dmvnormal</code> returns a <code class="reqn">1</code> by <code class="reqn">p</code> matrix of the
probability densities corresponding to each row of <code>x</code>.
<code>sigma</code>. Each row corresponds to an observation.
</p>
<p><code>rmvnormal</code> returns a <code>p</code> by <code>k</code> matrix of
observations from a multivariate normal distribution with the given mean
<code>mu</code> and covariance
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau
</p>


<h3>See Also</h3>

<p><code>dmvnorm</code> and <code>rmvnorm</code> in the <code>mvtnorm</code>-package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmvnormal(x = matrix(rnorm(300), 100, 3),
          mu = 1:3,
          sigma = diag(3))
rmvnormal(n = 10, mu = 1:4, sigma = diag(4))
</code></pre>

<hr>
<h2 id='EMAlgorithm'>EM algorithm for Gaussian mixture models</h2><span id='topic+EMAlgorithm'></span>

<h3>Description</h3>

<p>The regular expectation-maximization algorithm for general multivariate
Gaussian mixture models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMAlgorithm(x, theta, m, eps = 1e-06, max.ite = 1e+05,
  trace.theta = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EMAlgorithm_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> of observations where each row correspond to an
observation and each columns to a feature/variable.</p>
</td></tr>
<tr><td><code id="EMAlgorithm_+3A_theta">theta</code></td>
<td>
<p>A list of parameters of class <code>theta</code> as described in
<code><a href="#topic+rtheta">rtheta</a></code>.
Optional. If not provided <code>m</code> should be given.</p>
</td></tr>
<tr><td><code id="EMAlgorithm_+3A_m">m</code></td>
<td>
<p><code>numeric</code>. The number of components if <code>theta</code> is not
supplied.</p>
</td></tr>
<tr><td><code id="EMAlgorithm_+3A_eps">eps</code></td>
<td>
<p>The maximal required difference in successive likelihoods to
establish convergence.</p>
</td></tr>
<tr><td><code id="EMAlgorithm_+3A_max.ite">max.ite</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="EMAlgorithm_+3A_trace.theta">trace.theta</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all estimates are stored and
returned. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EMAlgorithm_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> for verbose output. Default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Though not as versatile, the algorithm can be a faster alternative
to <code>Mclust</code> in the <code>mclust</code>-package. If <code>theta</code> is not given,
a k-means clustering is used to determine the initial <code>theta</code>.
</p>


<h3>Value</h3>

<p>A list of length 3 with elements:
</p>
<table>
<tr><td><code>theta</code></td>
<td>
<p>A list of the estimated parameters as described in
<code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
<tr><td><code>loglik.tr</code></td>
<td>
<p>A numeric vector of the log-likelihood trace.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>A matrix where <code>kappa[i,j]</code> is the probability that
<code>x[i, ]</code> is realized from the <code>j</code>'th component.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rtheta">rtheta</a></code>, <code><a href="#topic+PseudoEMAlgorithm">PseudoEMAlgorithm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(3)
true.theta &lt;- rtheta(d = 2, m = 3, method = "old")
true.theta$sigma &lt;- lapply(true.theta$sigma, cov2cor) # Scale
## Not run: 
plot(true.theta, nlevels = 20, add.ellipses = TRUE)

## End(Not run)

data &lt;- SimulateGMCMData(n = 1000, theta = true.theta)
start.theta &lt;- rtheta(d = 2, m = 3)
start.theta$mu &lt;- t(kmeans(data$z, 3)$centers) # More sensible location estimates
start.theta &lt;- as.theta(start.theta) # Coerce the matrix to a list
res &lt;- GMCM:::EMAlgorithm(data$z, theta = start.theta)

par(mfrow = c(1,2))
plot(data$z, cex = 0.5, pch = 16, main = "Simulated data",
     col = rainbow(3)[data$K])
plot(data$z, cex = 0.5, pch = 16, main = "GMM clustering",
     col = rainbow(3)[apply(res$kappa,1,which.max)])
</code></pre>

<hr>
<h2 id='EStep'>Steps of the EM algorithm for a Gaussian Mixture model</h2><span id='topic+EStep'></span><span id='topic+MStep'></span>

<h3>Description</h3>

<p>Functions to perform the expectation and maximization steps of the EM
algorithm for an multivariate Gaussian mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EStep(x, theta)

MStep(x, kappa, meta.special.case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EStep_+3A_x">x</code></td>
<td>
<p>A matrix of observations where rows corresponds to features and
columns to experiments.</p>
</td></tr>
<tr><td><code id="EStep_+3A_theta">theta</code></td>
<td>
<p>A list of parameters formatted as described in
<code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
<tr><td><code id="EStep_+3A_kappa">kappa</code></td>
<td>
<p>A matrix where the (i,j)'th entry is the probability that
<code>x[i,]</code> belongs to the <code>j</code>'th component. Usually the returned
value of <code>EStep</code>.</p>
</td></tr>
<tr><td><code id="EStep_+3A_meta.special.case">meta.special.case</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the maximization step is
performed under the special case of Li et. al. (2011). Default values is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>EStep</code> returns a matrix of probabilities as <code>kappa</code>
above.
</p>
<p><code>MStep</code> returns a list of parameters formatted as described in
<code><a href="#topic+rtheta">rtheta</a></code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Li, Q., Brown, J. B. J. B., Huang, H., &amp; Bickel, P. J. (2011).
Measuring reproducibility of high-throughput experiments. The Annals of
Applied Statistics, 5(3), 1752-1779. doi:10.1214/11-AOAS466
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rtheta">rtheta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
sim &lt;- GMCM:::SimulateGMMData(n = 100)
x &lt;- sim$z
true.theta &lt;- sim$theta
init.theta &lt;- GMCM:::rtheta()  # Generate starting parameters

# Do one EM interation
es &lt;- GMCM:::EStep(x, init.theta)
new.theta &lt;- GMCM:::MStep(x, es)

# Compare current estimate with the true
new.theta
true.theta
</code></pre>

<hr>
<h2 id='fit.full.GMCM'>Estimate GMCM parameters of the general model</h2><span id='topic+fit.full.GMCM'></span><span id='topic+fit.full.gmcm'></span><span id='topic+fit.general.GMCM'></span><span id='topic+fit.general.gmcm'></span>

<h3>Description</h3>

<p>Estimates the parameters of general Gaussian mixture copula models (GMCM).
The function finds the maximum likelihood estimate of a general
GMCM with various optimization procedures. Note, all but the PEM methods
provides the maximum likelihood estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.full.GMCM(u, m, theta = choose.theta(u, m), method = c("NM",
  "SANN", "L-BFGS", "L-BFGS-B", "PEM"), max.ite = 1000, verbose = TRUE,
  ...)

fit.general.GMCM(u, m, theta = choose.theta(u, m), method = c("NM",
  "SANN", "L-BFGS", "L-BFGS-B", "PEM"), max.ite = 1000, verbose = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.full.GMCM_+3A_u">u</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of marginally uniform observations.
Rows corresponds to observations and columns to the dimensions of the
variables. I.e. these are often ranked and scaled test statistics or other
observations.</p>
</td></tr>
<tr><td><code id="fit.full.GMCM_+3A_m">m</code></td>
<td>
<p>The number of components to be fitted.</p>
</td></tr>
<tr><td><code id="fit.full.GMCM_+3A_theta">theta</code></td>
<td>
<p>A list of parameters as defined in <code><a href="#topic+rtheta">rtheta</a></code>. If
<code>theta</code> is not provided, then heuristic starting values are chosen
using the k-means algorithm.</p>
</td></tr>
<tr><td><code id="fit.full.GMCM_+3A_method">method</code></td>
<td>
<p>A character vector of length <code class="reqn">1</code>. The optimization
method used. Should be either <code>"NM"</code>, <code>"SANN"</code>, <code>"L-BFGS"</code>,
<code>"L-BFGS-B"</code>, or <code>"PEM"</code> which are the Nelder-Mead, Simulated
Annealing, limited-memory quasi-Newton method, limited-memory quasi-Newton
method with box constraints, and the pseudo EM algorithm, respectively.
Default is <code>"NM"</code>. See <code><a href="stats.html#topic+optim">optim</a></code> for further details.</p>
</td></tr>
<tr><td><code id="fit.full.GMCM_+3A_max.ite">max.ite</code></td>
<td>
<p>The maximum number of iterations. If the <code>method</code> is
<code>"SANN"</code> this is the number of iterations as there is no other
stopping criterion. (See <code><a href="stats.html#topic+optim">optim</a></code>)</p>
</td></tr>
<tr><td><code id="fit.full.GMCM_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a trace of the parameter estimates
is made.</p>
</td></tr>
<tr><td><code id="fit.full.GMCM_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code>control</code>-list in
<code><a href="stats.html#topic+optim">optim</a></code> when <code>method</code> is not equal to <code>"PEM"</code>.
If <code>method</code> equals <code>"PEM"</code>, the arguments are passed to
<code><a href="#topic+PseudoEMAlgorithm">PseudoEMAlgorithm</a></code> if the <code>method</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"L-BFGS-B"</code> method does not perform a transformation of
the parameters and uses box constraints as implemented in <code>optim</code>. <br />
Note that the many parameter configurations are poorly estimable or
directly unidentifiable.
</p>
<p><code>fit.general.GMCM</code> is simply an alias of <code>fit.full.gmcm</code>.
</p>


<h3>Value</h3>

<p>A list of parameters formatted as described in <code><a href="#topic+rtheta">rtheta</a></code>.
</p>
<p>When <code>method</code> equals <code>"PEM"</code>, a list of extra information
(log-likelihood trace, the matrix of group probabilities, theta trace) is
added as an attribute called &quot;extra&quot;.
</p>


<h3>Note</h3>

<p>All the optimization procedures are strongly dependent on the initial
values and other parameters (such as the cooling scheme for method SANN).
Therefore it is advisable to apply multiple
different initial parameters (and optimization routines) and select the
best fit.
</p>
<p>The <code><a href="#topic+choose.theta">choose.theta</a></code> itself chooses random a initialization.
Hence, the output when <code>theta</code> is not directly supplied can vary.
</p>
<p>See <code><a href="stats.html#topic+optim">optim</a></code> for further details.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Li, Q., Brown, J. B. J. B., Huang, H., &amp; Bickel, P. J. (2011).
Measuring reproducibility of high-throughput experiments. The Annals of
Applied Statistics, 5(3), 1752-1779. doi:10.1214/11-AOAS466
</p>
<p>Tewari, A., Giering, M. J., &amp; Raghunathan, A. (2011). Parametric
Characterization of Multimodal Distributions with Non-gaussian Modes. 2011
IEEE 11th International Conference on Data Mining Workshops, 286-292.
doi:10.1109/ICDMW.2011.135
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+get.prob">get.prob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
sim &lt;- SimulateGMCMData(n = 1000, m = 3, d = 2)

# Plotting simulated data
par(mfrow = c(1,2))
plot(sim$z, col = rainbow(3)[sim$K], main = "Latent process")
plot(sim$u, col = rainbow(3)[sim$K], main = "GMCM process")

# Observed data
uhat &lt;- Uhat(sim$u)

# The model should be fitted multiple times using different starting estimates
start.theta &lt;- choose.theta(uhat, m = 3)  # Random starting estimate
res &lt;- fit.full.GMCM(u = uhat, theta = start.theta,
                     method = "NM", max.ite = 3000,
                     reltol = 1e-2, trace = TRUE)  # Note, 1e-2 is too big

# Confusion matrix
Khat &lt;- apply(get.prob(uhat, theta = res), 1, which.max)
table("Khat" = Khat, "K" = sim$K)  # Note, some components have been swapped

# Simulation from GMCM with the fitted parameters
simfit &lt;- SimulateGMCMData(n = 1000, theta = res)

# As seen, the underlying latent process is hard to estimate.
# The clustering, however, is very good.
par(mfrow = c(2,2))
plot(simfit$z, col = simfit$K, main = "Model check 1\nSimulated GMM")
plot(simfit$u, col = simfit$K, main = "Model check 2\nSimulated GMCM")
plot(sim$u, col = Khat, main = "MAP clustering")
</code></pre>

<hr>
<h2 id='fit.meta.GMCM'>Estimate GMCM parameters of the special model</h2><span id='topic+fit.meta.GMCM'></span><span id='topic+fit.meta.gmcm'></span><span id='topic+fit.special.GMCM'></span><span id='topic+fit.special.gmcm'></span>

<h3>Description</h3>

<p>This function estimates the parameters of the special restricted Gaussian
mixture copula model (GMCM) proposed by Li et. al. (2011).
It is used to perform reproducibility (or meta) analysis using GMCMs.
It features various optimization routines to identify the maximum likelihood
estimate of the special GMCMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.meta.GMCM(u, init.par, method = c("NM", "SANN", "L-BFGS", "L-BFGS-B",
  "PEM"), max.ite = 1000, verbose = TRUE, positive.rho = TRUE,
  trace.theta = FALSE, ...)

fit.special.GMCM(u, init.par, method = c("NM", "SANN", "L-BFGS",
  "L-BFGS-B", "PEM"), max.ite = 1000, verbose = TRUE,
  positive.rho = TRUE, trace.theta = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.meta.GMCM_+3A_u">u</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of test statistics. Rows correspond
to features and columns to experiments. Larger values are assumed to be
indicative of stronger evidence and reproducibility.</p>
</td></tr>
<tr><td><code id="fit.meta.GMCM_+3A_init.par">init.par</code></td>
<td>
<p>A 4-dimensional vector of the initial parameters where,
<code>init.par[1]</code> is the mixture proportion of spurious signals,
<code>init.par[2]</code> is the mean, <code>init.par[3]</code> is the standard
deviation, <code>init.par[4]</code> is the correlation.</p>
</td></tr>
<tr><td><code id="fit.meta.GMCM_+3A_method">method</code></td>
<td>
<p>A character vector of length <code class="reqn">1</code>. The optimization
method used. Should be either <code>"NM"</code>, <code>"SANN"</code>, <code>"L-BFGS"</code>,
<code>"L-BFGS-B"</code>, or <code>"PEM"</code> which are abbreviations of Nelder-Mead,
Simulated Annealing, limited-memory quasi-Newton method, limited-memory
quasi-Newton method with box constraints, and the pseudo EM algorithm,
respectively. Default is <code>"NM"</code>. See <code><a href="stats.html#topic+optim">optim</a></code> for further
details.</p>
</td></tr>
<tr><td><code id="fit.meta.GMCM_+3A_max.ite">max.ite</code></td>
<td>
<p>The maximum number of iterations.  If the <code>method</code> is
<code>"SANN"</code> this is the number of iterations as there is no other
stopping criterion. (See <code><a href="stats.html#topic+optim">optim</a></code>)</p>
</td></tr>
<tr><td><code id="fit.meta.GMCM_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the log-likelihood values are
printed.</p>
</td></tr>
<tr><td><code id="fit.meta.GMCM_+3A_positive.rho">positive.rho</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the correlation parameter
is restricted to be positive.</p>
</td></tr>
<tr><td><code id="fit.meta.GMCM_+3A_trace.theta">trace.theta</code></td>
<td>
<p><code>logical</code>. Extra convergence information is appended
as a list to the output returned if <code>TRUE</code>. The exact behavior is
dependent on the value of <code>method</code>. If <code>method</code> equals
<code>"PEM"</code>, the argument is passed to <code>trace.theta</code> in
<code><a href="#topic+PseudoEMAlgorithm">PseudoEMAlgorithm</a></code>. Otherwise it is passed to the control
argument <code>trace</code> in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="fit.meta.GMCM_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code>control</code>-list in
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="#topic+PseudoEMAlgorithm">PseudoEMAlgorithm</a></code> if <code>method</code> is
<code>"PEM"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"L-BFGS-B"</code> method does not perform a transformation of
the parameters.
</p>
<p><code>fit.special.GMCM</code> is simply an alias of <code>fit.meta.gmcm</code>.
</p>


<h3>Value</h3>

<p>A vector <code>par</code> of length 4 of the fitted parameters where
<code>par[1]</code> is the probability of being from the first (or null)
component, <code>par[2]</code> is the mean, <code>par[3]</code> is the standard
deviation, and <code>par[4]</code> is the correlation.
</p>
<p>If <code>trace.theta</code> is <code>TRUE</code>, then a <code>list</code> is returned where
the first entry is as described above and the second entry is the trace
information (dependent of <code>method</code>.).
</p>


<h3>Note</h3>

<p>Simulated annealing is strongly dependent on the initial values and
the cooling scheme.
</p>
<p>See <code><a href="stats.html#topic+optim">optim</a></code> for further details.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Li, Q., Brown, J. B. J. B., Huang, H., &amp; Bickel, P. J. (2011).
Measuring reproducibility of high-throughput experiments. The Annals of
Applied Statistics, 5(3), 1752-1779. doi:10.1214/11-AOAS466
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

# True parameters
true.par &lt;- c(0.9, 2, 0.7, 0.6)
# Simulation of data from the GMCM model
data &lt;- SimulateGMCMData(n = 1000, par = true.par)
uhat &lt;- Uhat(data$u) # Ranked observed data

init.par &lt;- c(0.5, 1, 0.5, 0.9)  # Initial parameters

# Optimization with Nelder-Mead
nm.par   &lt;- fit.meta.GMCM(uhat, init.par = init.par, method = "NM")

## Not run: 
# Comparison with other optimization methods
# Optimization with simulated annealing
sann.par &lt;- fit.meta.GMCM(uhat, init.par = init.par, method = "SANN",
                          max.ite = 3000, temp = 1)
# Optimization with the Pseudo EM algorithm
pem.par  &lt;- fit.meta.GMCM(uhat, init.par = init.par, method = "PEM")

# The estimates agree nicely
rbind("True" = true.par, "Start" = init.par,
      "NM" = nm.par, "SANN" = sann.par, "PEM" = pem.par)

## End(Not run)

# Get estimated cluster
Khat &lt;- get.IDR(x = uhat, par = nm.par)$Khat
plot(uhat, col = Khat, main = "Clustering\nIDR &lt; 0.05")
</code></pre>

<hr>
<h2 id='freshVsFrozen'>Reproducibility between Fresh and Frozen B-cell subtypes</h2><span id='topic+freshVsFrozen'></span>

<h3>Description</h3>

<p>This dataset contains a <code>data.frame</code> of <code class="reqn">t</code>-scores (from a Linear
mixed effects model) and <code class="reqn">p</code>-values for
differential expression between pre (Im, N) and post germinal (M, PB) centre
cells within peripheral blood.
The first and second column contain the the test for the hypothesis of no
differentially expression between pre and post germinal cells for the
freshly sorted and gene profiled cells.
The third and fourth column contain the the test for the hypothesis of no
differentially expression between pre and post germinal cells for the
cryopreserved (frozen), thawed, sorted, and gene profiled cells.
The fifth and sixth column contain the the test for the hypothesis of no
differentially expression between fresh and frozen cells.
The used array type was Affymetrix Human Exon 1.0 ST microarray.
</p>


<h3>Format</h3>

<p>The format of the <code>data.frame</code> is:
</p>
<p><code>'data.frame':  18708 obs. of  6 variables:</code><br />
<code>$ PreVsPost.Fresh.tstat : num  -1.073 -0.381 -1.105 -0.559 -1.054 ...</code><br />
<code>$ PreVsPost.Fresh.pval  : num  0.283 0.703 0.269 0.576 0.292 ...</code><br />
<code>$ PreVsPost.Frozen.tstat: num  -0.245 -0.731 -0.828 -0.568 -1.083 ...</code><br />
<code>$ PreVsPost.Frozen.pval : num  0.806 0.465 0.408 0.57 0.279 ...</code><br />
<code>$ FreshVsFrozen.tstat   : num  0.836 1.135 -0.221 0.191 -0.783 ...</code><br />
<code>$ FreshVsFrozen.pval    : num  0.403 0.256 0.825 0.849 0.434 ...</code><br /></p>


<h3>Details</h3>

<p>Further details can be found in Rasmussen and Bilgrau et al. (2015).
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Rasmussen SM, Bilgrau AE, Schmitz A, Falgreen S, Bergkvist KS, Tramm AM,
Baech J, Jacobsen CL, Gaihede M, Kjeldsen MK, Boedker JS, Dybkaer K,
Boegsted M, Johnsen HE (2015). &quot;Stable Phenotype Of B-Cell Subsets Following
Cryopreservation and Thawing of Normal Human Lymphocytes Stored in a Tissue
Biobank.&quot; Cytometry Part B: Clinical Cytometry, 88(1), 40-49.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(freshVsFrozen)
str(freshVsFrozen)

# Plot P-values
plot(freshVsFrozen[,c(2,4)], cex = 0.5)

# Plot ranked and scaled P-values
plot(Uhat(abs(freshVsFrozen[,c(1,3)])), cex = 0.5)
</code></pre>

<hr>
<h2 id='full2meta'>Convert between parameter formats</h2><span id='topic+full2meta'></span><span id='topic+meta2full'></span>

<h3>Description</h3>

<p>These functions converts/coerces the parameters between the general Gaussian
mixture (copula) model and the special GMCM.
Most functions of the GMCM packages use the <code>theta</code>
format described in <code><a href="#topic+rtheta">rtheta</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full2meta(theta)

meta2full(par, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full2meta_+3A_theta">theta</code></td>
<td>
<p>A list of parameters for the full model. Formatted as described
in <code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
<tr><td><code id="full2meta_+3A_par">par</code></td>
<td>
<p>A vector of length 4 where <code>par[1]</code> is the probability of
coming from the first component, <code>par[2]</code> is the mean value,
<code>par[3]</code> is the standard deviation, and <code>par[4]</code> is the
correlation of the reproducible component.</p>
</td></tr>
<tr><td><code id="full2meta_+3A_d">d</code></td>
<td>
<p>An integer giving the dimension of the mixture distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a <code>theta</code> is supplied which is not on the form of Li et. al. (2011)
the output is coerced by simply picking the first element of the second
component mean vector as mean,
the square roof of the first diagonal entry of the second component
covariance matrix as standard deviation, and first off-diagonal entry as
correlation (properly scaled).
</p>


<h3>Value</h3>

<p><code>full2meta</code> returns a numeric vector of length 4 formatted as
<code>par</code>.
</p>
<p>meta2full returns a formatted 'theta' list of parameters as described
by <code><a href="#topic+rtheta">rtheta</a></code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Li, Q., Brown, J. B. J. B., Huang, H., &amp; Bickel, P. J. (2011).
Measuring reproducibility of high-throughput experiments. The Annals of
Applied Statistics, 5(3), 1752-1779. doi:10.1214/11-AOAS466
</p>
<p>Tewari, A., Giering, M., &amp; Raghunathan, A. (2011). Parametric
Characterization of Multimodal Distributions with Non-gaussian Modes. IEEE
11th International Conference on Data Mining Workshops, 2011, 286-292.
doi:10.1109/ICDMW.2011.135
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rtheta">rtheta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- GMCM:::rtheta(m = 2, d = 2)
print(par &lt;- full2meta(theta))
print(theta.special.case &lt;- meta2full(par, d = 2))
</code></pre>

<hr>
<h2 id='get.IDR'>Posterior class probabilities, local, and adjusted IDRs.</h2><span id='topic+get.IDR'></span><span id='topic+get.prob'></span><span id='topic+get.idr'></span>

<h3>Description</h3>

<p>Functions for computing posterior cluster probabilities (<code>get.prob</code>)
in the general GMCM as well as local and
adjusted irreproducibility discovery rates (<code>get.IDR</code>) in the
special GMCM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.IDR(x, par, threshold = 0.05, ...)

get.prob(x, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.IDR_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> of observations where rows corresponds to features
and columns to studies.</p>
</td></tr>
<tr><td><code id="get.IDR_+3A_par">par</code></td>
<td>
<p>A vector of length 4 where <code>par[1]</code> is mixture proportion of
the irreproducible component, <code>par[2]</code> is the mean value,
<code>par[3]</code> is the standard deviation, and <code>par[4]</code> is the
correlation of the reproducible component.</p>
</td></tr>
<tr><td><code id="get.IDR_+3A_threshold">threshold</code></td>
<td>
<p>The threshold level of the IDR rate.</p>
</td></tr>
<tr><td><code id="get.IDR_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+qgmm.marginal">qgmm.marginal</a></code>.</p>
</td></tr>
<tr><td><code id="get.IDR_+3A_theta">theta</code></td>
<td>
<p>A list of parameters for the full model as described in
<code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get.IDR</code> returns a list of length 5 with elements:
</p>
<table>
<tr><td><code>idr</code></td>
<td>
<p>A vector of the local idr values. I.e. the posterior
probability that <code>x[i, ]</code> belongs to the irreproducible component.</p>
</td></tr>
<tr><td><code>IDR</code></td>
<td>
<p>A vector of the adjusted IDR values.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>The number of reproducible features at the specified
<code>threshold</code>.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The IDR threshold at which features are deemed
reproducible.</p>
</td></tr>
<tr><td><code>Khat</code></td>
<td>
<p>A vector signifying whether the corresponding feature is
reproducible or not.</p>
</td></tr>
</table>
<p><code>get.prob</code> returns a matrix where entry <code>(i,j)</code> is the
posterior probability that the observation <code>x[i, ]</code> belongs to cluster
<code>j</code>.
</p>


<h3>Note</h3>

<p>From <span class="pkg">GMCM</span> version 1.1 <code>get.IDR</code> has been an internal function.
Use <code>get.prop</code> or <code>get.IDR</code> instead. The function can still be
accessed with <code>GMCM:::get.idr</code>. <code>get.idr</code> returns a vector where
the <code class="reqn">i</code>'th entry is the posterior probability that observation <code class="reqn">i</code>
is irreproducible. It is a simple wrapper for <code>get.prob</code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Li, Q., Brown, J. B. J. B., Huang, H., &amp; Bickel, P. J. (2011).
Measuring reproducibility of high-throughput experiments. The Annals of
Applied Statistics, 5(3), 1752-1779. doi:10.1214/11-AOAS466
</p>
<p>Tewari, A., Giering, M., &amp; Raghunathan, A. (2011). Parametric
Characterization of Multimodal Distributions with Non-gaussian Modes. IEEE
11th International Conference on Data Mining Workshops, 2011, 286-292.
doi:10.1109/ICDMW.2011.135
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1123)

# True parameters
true.par &lt;- c(0.9, 2, 0.7, 0.6)

# Simulation of data from the GMCM model
data &lt;-  SimulateGMCMData(n = 1000, par = true.par, d = 2)

# Initial parameters
init.par &lt;- c(0.5, 1, 0.5, 0.9)

# Nelder-Mead optimization
nm.par   &lt;- fit.meta.GMCM(data$u, init.par = init.par, method = "NM")

# Get IDR values
res &lt;- get.IDR(data$u, nm.par, threshold = 0.05)

# Plot results
plot(data$u, col = res$Khat, pch = c(3,16)[data$K])
</code></pre>

<hr>
<h2 id='goodness.of.fit'>Goodness of fit for the general GMCM</h2><span id='topic+goodness.of.fit'></span>

<h3>Description</h3>

<p>Compute goodness of fit as described in <code><a href="stats.html#topic+AIC">AIC</a></code>. The number of
parameters used correspond to the number of variables free to vary in the
general model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goodness.of.fit(theta, u, method = c("AIC", "BIC"), k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goodness.of.fit_+3A_theta">theta</code></td>
<td>
<p>A <code>list</code> of parameters as defined in <code><a href="#topic+rtheta">rtheta</a></code>.
For t this function, it will usually be the output of
<code><a href="#topic+fit.full.GMCM">fit.full.GMCM</a></code>.</p>
</td></tr>
<tr><td><code id="goodness.of.fit_+3A_u">u</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of marginally uniform observations.
Rows corresponds to observations and columns to the dimensions of the
variables. I.e. these are often ranked and scaled test statistics or other
observations.</p>
</td></tr>
<tr><td><code id="goodness.of.fit_+3A_method">method</code></td>
<td>
<p>A <code>character</code> of length 1 which specifies the goodness of
fit to compute. Default is &quot;AIC&quot;. &quot;BIC&quot; is also a option.</p>
</td></tr>
<tr><td><code id="goodness.of.fit_+3A_k">k</code></td>
<td>
<p>A integer specifying the default used constant &quot;k&quot; in AIC. See
<code><a href="stats.html#topic+AIC">AIC</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number giving the goodness of fit as requested.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
data(u133VsExon)
u &lt;- Uhat(u133VsExon[sample(19577, 500), ])  # Subset for faster fitting
theta1 &lt;- fit.full.GMCM(u, m = 2, method = "L-BFGS")
goodness.of.fit(theta1, u)  # AIC
goodness.of.fit(theta1, u, method = "BIC")
## Not run: 
theta2 &lt;- fit.full.GMCM(u, m = 3, method = "L-BFGS")
goodness.of.fit(theta2, u)
goodness.of.fit(theta2, u, method = "BIC")

## End(Not run)
</code></pre>

<hr>
<h2 id='inv.logit'>Logit and inverse logit transforms</h2><span id='topic+inv.logit'></span><span id='topic+logit'></span>

<h3>Description</h3>

<p>The logit transformation (i.e. the log of the odds) and its inverse (also
called expit).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv.logit(a)

logit(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv.logit_+3A_a">a</code></td>
<td>
<p>A vector of real values.</p>
</td></tr>
<tr><td><code id="inv.logit_+3A_p">p</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>inv.logit</code> returns a vector of the same length as <code>a</code> of the
inverse logit transformed values. This function is also known as the
expit-function.
</p>
<p><code>logit</code> returns a vector of the same length as <code>p</code> with
the log odds of <code>p</code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+tt">tt</a></code> and <code><a href="#topic+inv.tt">inv.tt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- runif(100)
print(a &lt;- GMCM:::logit(p))
p - GMCM:::inv.logit(a)
</code></pre>

<hr>
<h2 id='inv.rho.transform'>Transformation of the correlation to real line and its inverse</h2><span id='topic+inv.rho.transform'></span><span id='topic+rho.transform'></span>

<h3>Description</h3>

<p>A transformation of the correlation coefficient into the real line and the
corresponding inverse. The transform is a translation and scaling of
<code class="reqn">\rho</code> from the interval <code class="reqn">(-1/(d-1), 1)</code> to
<code class="reqn">(0, 1)</code> followed by a logit transformation to the whole real
line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv.rho.transform(a, d)

rho.transform(rho, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv.rho.transform_+3A_a">a</code></td>
<td>
<p>A real number.</p>
</td></tr>
<tr><td><code id="inv.rho.transform_+3A_d">d</code></td>
<td>
<p>The dimension of the space.</p>
</td></tr>
<tr><td><code id="inv.rho.transform_+3A_rho">rho</code></td>
<td>
<p>A correlation coefficient between <code>-1/(d-1)</code> and <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>inv.rho.transform</code> returns a vector of the inversely
transformed values with the same length as <code>a</code>.
</p>
<p><code>rho.transform</code> returns a vector of the transformed values with
the same length as <code>rho</code> or <code>a</code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+tt">tt</a></code> and <code><a href="#topic+inv.tt">inv.tt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 4
rho &lt;- runif(100, -1/(d-1), 1)
a &lt;- GMCM:::rho.transform(rho, d)
rho - GMCM:::inv.rho.transform(a, d)
</code></pre>

<hr>
<h2 id='inv.tt'>Reparametrization of GMCM parameters</h2><span id='topic+inv.tt'></span><span id='topic+tt'></span>

<h3>Description</h3>

<p>These functions map the four GMCM parameters in the model of Li et. al.
(2011) and Tewari et. al. (2011) onto the real line and back. The mixture
proportion is logit transformed. The mean and standard deviation are log
transformed. The correlation is translated and scaled to the interval (0,1)
and logit transformed by <code><a href="#topic+rho.transform">rho.transform</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv.tt(par, d, positive.rho)

tt(tpar, d, positive.rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv.tt_+3A_par">par</code></td>
<td>
<p>A vector of length 4 where <code>par[1]</code> is the mixture
proportion, <code>tpar[2]</code> the mean, <code>tpar[3]</code> the standard deviation,
and <code>tpar[4]</code> the correlation.</p>
</td></tr>
<tr><td><code id="inv.tt_+3A_d">d</code></td>
<td>
<p>The dimension of the space.</p>
</td></tr>
<tr><td><code id="inv.tt_+3A_positive.rho">positive.rho</code></td>
<td>
<p>is logical. If <code>TRUE</code>, the correlation is
transformed by a simple <code><a href="#topic+logit">logit</a></code> transformation. If
<code>FALSE</code> the
<code><a href="#topic+rho.transform">rho.transform</a></code> is used.</p>
</td></tr>
<tr><td><code id="inv.tt_+3A_tpar">tpar</code></td>
<td>
<p>A vector of length 4 of the transformed parameter values where
<code>tpar[1]</code> corresponds to the mixture proportion, <code>tpar[2]</code> the
mean, <code>tpar[3]</code> the standard deviation, and <code>tpar[4]</code> the
correlation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are used only in the wrapper to <code>optim</code> when the GMCM
log-likelihood is optimized.
</p>
<p><code>par[1]</code> should be between 0 and 1. <code>par[2]</code> and <code>par[3]</code>
should be non-negative. If <code>positive.rho</code> is <code>FALSE</code>,
<code>par[4]</code> should be between <code class="reqn">-1/(d-1)</code> and 1. Otherwise,
<code>positive.rho</code> should be between 0 and 1.
</p>


<h3>Value</h3>

<p><code>inv.tt</code> returns <code>tpar</code> as described above.
</p>
<p>A <code>numeric</code> vector of the transformed or inversely transformed
values of length 4.
</p>
<p><code>tt</code> returns <code>par</code> as described above.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Li, Q., Brown, J. B. J. B., Huang, H., &amp; Bickel, P. J. (2011).
Measuring reproducibility of high-throughput experiments. The Annals of
Applied Statistics, 5(3), 1752-1779. doi:10.1214/11-AOAS466
</p>
<p>Tewari, A., Giering, M. J., &amp; Raghunathan, A. (2011). Parametric
Characterization of Multimodal Distributions with Non-gaussian Modes. 2011
IEEE 11th International Conference on Data Mining Workshops, 286-292.
doi:10.1109/ICDMW.2011.135
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par &lt;- c(pie1 = 0.3, mu = 2, sigma = 0.5, rho = 0.8)
tpar &lt;- GMCM:::inv.tt(par, d = 3, positive.rho = FALSE)
GMCM:::tt(tpar, d = 3, positive.rho = FALSE)
</code></pre>

<hr>
<h2 id='is.theta'>Check if parameters are valid</h2><span id='topic+is.theta'></span>

<h3>Description</h3>

<p>Function to check whether the argument is coherent and in the correct
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.theta(theta, check.class = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.theta_+3A_theta">theta</code></td>
<td>
<p>A list on the <code>theta</code>-form described in
<code><a href="#topic+rtheta">rtheta</a></code></p>
</td></tr>
<tr><td><code id="is.theta_+3A_check.class">check.class</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the class of <code>theta</code> is also checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code>. Returns <code>TRUE</code> if <code>theta</code> is coherent and
in the correct format. Otherwise, the function returns <code>FALSE</code> with
an accompanying warning message of the problem.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rtheta">rtheta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta1 &lt;- rtheta()  # Create a random correctly formatted theta
is.theta(theta1)

theta2 &lt;- rtheta(d = 3, m = 5)
theta2$m &lt;- 6  # m is now incoherent with the number of components
is.theta(theta2)

theta3 &lt;- rtheta(d = 4, m = 2)
theta3$sigma$comp1[1, 2] &lt;- 0  # Making the covariance matrix non-symmetric
is.theta(theta3)

theta4 &lt;- rtheta(d = 10, m = 10)
theta4$sigma$comp1[1, 1] &lt;- 0  # Destroy positive semi-definiteness
is.theta(theta4)

theta5 &lt;- rtheta()
names(theta5) &lt;- c("m", "d", "prop", "mu", "sigmas") # Incorrect names
is.theta(theta5)
</code></pre>

<hr>
<h2 id='plot.theta'>Plotting method for &quot;theta&quot; objects</h2><span id='topic+plot.theta'></span>

<h3>Description</h3>

<p>Visualizes the chosen dimensions of the theta object graphically by the GMM
density and possibly the individual gaussian components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'theta'
plot(x, which.dims = c(1L, 2L), n.sd = qnorm(0.99),
  add.means = TRUE, ..., add.ellipses = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.theta_+3A_x">x</code></td>
<td>
<p>An object of class <code>theta</code>.</p>
</td></tr>
<tr><td><code id="plot.theta_+3A_which.dims">which.dims</code></td>
<td>
<p>An integer vector of length 2 choosing which two dimensions
to plot.</p>
</td></tr>
<tr><td><code id="plot.theta_+3A_n.sd">n.sd</code></td>
<td>
<p>An integer choosing the number of standard deviations in each
dimension to determine the plotting window.</p>
</td></tr>
<tr><td><code id="plot.theta_+3A_add.means">add.means</code></td>
<td>
<p>logical. If TRUE, dots corresponding to the means are
added to the plot.</p>
</td></tr>
<tr><td><code id="plot.theta_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>contour</code>.</p>
</td></tr>
<tr><td><code id="plot.theta_+3A_add.ellipses">add.ellipses</code></td>
<td>
<p>logical. If TRUE, ellipses outlining a 95% confidence
regions for each component are added in the bivariate multivariate
distribution defined by theta and <code>which.dims</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots via the <code>contour</code> function. Invisibly returns a list with
x, y, z coordinates that is passed to contour.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
theta &lt;- rtheta(d = 3, m = 2)
## Not run: 
plot(theta)
plot(theta, col = "blue", asp = 1, add.means = FALSE)
plot(theta, col = "blue", asp = 1, add.means = TRUE)
plot(theta, which.dims = c(3L, 2L), asp = 1)

## End(Not run)
plot(theta, asp = 1, n.sd = 3, add.ellipses = TRUE,
     nlevels = 40, axes = FALSE,
     xlab = "Dimension 1", ylab = "Dimension 2")
</code></pre>

<hr>
<h2 id='print.theta'>Print method for theta class</h2><span id='topic+print.theta'></span>

<h3>Description</h3>

<p>Print method for theta class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'theta'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.theta_+3A_x">x</code></td>
<td>
<p>A <code>theta</code> object. See <code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
<tr><td><code id="print.theta_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to subsequent methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- rtheta()
print(theta)
</code></pre>

<hr>
<h2 id='PseudoEMAlgorithm'>EM-like algorithm for the GMCM</h2><span id='topic+PseudoEMAlgorithm'></span>

<h3>Description</h3>

<p>An fast and modified implementation of the Li et. al. (2011) EM-like
algorithm for estimating the maximizing parameters of the GMCM-likelihood
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PseudoEMAlgorithm(x, theta, eps = 1e-04, max.ite = 1000,
  verbose = FALSE, trace.theta = FALSE, meta.special.case = FALSE,
  convergence.criterion = c("absGMCM", "GMCM", "GMM", "Li", "absLi"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PseudoEMAlgorithm_+3A_x">x</code></td>
<td>
<p>A matrix of observations where rows corresponds to features and
columns to experiments.</p>
</td></tr>
<tr><td><code id="PseudoEMAlgorithm_+3A_theta">theta</code></td>
<td>
<p>A list of parameters formatted as described in
<code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
<tr><td><code id="PseudoEMAlgorithm_+3A_eps">eps</code></td>
<td>
<p>The maximum difference required to achieve convergence.</p>
</td></tr>
<tr><td><code id="PseudoEMAlgorithm_+3A_max.ite">max.ite</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="PseudoEMAlgorithm_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Set to <code>TRUE</code> to increase verbosity.</p>
</td></tr>
<tr><td><code id="PseudoEMAlgorithm_+3A_trace.theta">trace.theta</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a trace of the estimated thetas
are returned.</p>
</td></tr>
<tr><td><code id="PseudoEMAlgorithm_+3A_meta.special.case">meta.special.case</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the estimators used are for
the special case GMCM of Li et. al. (2011).</p>
</td></tr>
<tr><td><code id="PseudoEMAlgorithm_+3A_convergence.criterion">convergence.criterion</code></td>
<td>
<p>Character. Sets the convergence criterion.  If
<code>"absGMCM"</code> the absolute value of difference in GMCM is used. If
<code>"GMCM"</code> the difference in GMCM-likelihoods are used as convergence
criterion. If <code>"GMM"</code>, the guaranteed non-decreasing difference of
GMM-likelihoods are used. If <code>"Li"</code>, the convergence criterion used by
Li et. al. (2011) is used. If <code>"absLi"</code>, the absolute values of the Li
et. al. criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When either <code>"absGMCM"</code> or <code>"absLi"</code> are used, the parameters
corresponding to the biggest observed likelihood is returned. This is not
necessarily the last iteration.
</p>


<h3>Value</h3>

<p>A list of 3 or 4 is returned depending on the value of
<code>trace.theta</code> </p>
<table>
<tr><td><code>theta</code></td>
<td>
<p>A list containing the final parameter
estimate in the format of <code><a href="#topic+rtheta">rtheta</a></code></p>
</td></tr> <tr><td><code>loglik.tr</code></td>
<td>
<p>A matrix
with different log-likelihood traces in each row.</p>
</td></tr> <tr><td><code>kappa</code></td>
<td>
<p>A matrix
where the (i,j)'th entry is the probability that <code>x[i, ]</code> belongs to
the j'th component. Usually the returned value of <code>EStep</code>.</p>
</td></tr>
<tr><td><code>theta.tr</code></td>
<td>
<p>A list of each obtained parameter estimates in the format of
<code><a href="#topic+rtheta">rtheta</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The algorithm is highly sensitive to the starting parameters which
therefore should be carefully chosen.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Li, Q., Brown, J. B. J. B., Huang, H., &amp; Bickel, P. J. (2011).
Measuring reproducibility of high-throughput experiments. The Annals of
Applied Statistics, 5(3), 1752-1779. doi:10.1214/11-AOAS466
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rtheta">rtheta</a></code>, <code><a href="#topic+EMAlgorithm">EMAlgorithm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

# Choosing the true parameters and simulating data
true.par &lt;- c(0.8, 3, 1.5, 0.4)
data &lt;- SimulateGMCMData(n = 1000, par = true.par, d = 2)
uhat &lt;- Uhat(data$u)  # Observed ranks

# Plot of latent and observed data colour coded by the true component
par(mfrow = c(1,2))
plot(data$z, main = "Latent data", cex = 0.6,
     xlab = "z (Experiment 1)", ylab = "z (Experiment 2)",
     col = c("red","blue")[data$K])
plot(uhat, main = "Observed data", cex = 0.6,
     xlab = "u (Experiment 1)", ylab = "u (Experiment 2)",
     col = c("red","blue")[data$K])

# Fit the model using the Pseudo EM algorithm
init.par &lt;- c(0.5, 1, 1, 0.5)
res &lt;- GMCM:::PseudoEMAlgorithm(uhat, meta2full(init.par, d = 2),
                                verbose = TRUE,
                                convergence.criterion = "absGMCM",
                                eps = 1e-4,
                                trace.theta = FALSE,
                                meta.special.case = TRUE)

# Compute posterior cluster probabilities
IDRs &lt;- get.IDR(uhat, par = full2meta(res$theta))

# Plot of observed data colour coded by the MAP estimate
plot(res$loglik[3,], main = "Loglikelihood trace", type = "l",
     ylab = "log GMCM likelihood")
abline(v = which.max(res$loglik[3,])) # Chosen MLE
plot(uhat, main = "Clustering\nIDR &lt; 0.05", xlab = "", ylab = "", cex = 0.6,
     col = c("Red","Blue")[IDRs$Khat])

# View parameters
rbind(init.par, true.par, estimate = full2meta(res$theta))

# Confusion matrix
table("Khat" = IDRs$Khat, "K" = data$K)
</code></pre>

<hr>
<h2 id='rtheta'>Get random parameters for the Gaussian mixture (copula) model</h2><span id='topic+rtheta'></span>

<h3>Description</h3>

<p>Generate a random set parameters for the Gaussian mixture
model (GMM) and Gaussian mixture copula model (GMCM). Primarily, it provides
an easy prototype of the <code>theta</code>-format used in <span class="pkg">GMCM</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtheta(m = 3, d = 2, method = c("old", "EqualSpherical",
  "UnequalSpherical", "EqualEllipsoidal", "UnequalEllipsoidal"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtheta_+3A_m">m</code></td>
<td>
<p>The number of components in the mixture.</p>
</td></tr>
<tr><td><code id="rtheta_+3A_d">d</code></td>
<td>
<p>The dimension of the mixture distribution.</p>
</td></tr>
<tr><td><code id="rtheta_+3A_method">method</code></td>
<td>
<p>The method by which the theta should be generated.
See details. Defaults to <code>"old"</code> which is the regular &quot;old&quot; behavior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the <code>method</code> argument the parameters are generated as
follows. The new behavior is inspired by the simulation scenarios in
Friedman (1989) but not exactly the same.
</p>

<ul>
<li><p><code>pie</code>
is generated by <code class="reqn">m</code> draws of a chi-squared distribution with
<code class="reqn">3m</code> degrees of freedom divided by their sum. If
<code>method = "old"</code> the uniform distribution is used instead.
</p>
</li>
<li><p><code>mu</code>
is generated by <code class="reqn">m</code> i.i.d. <code class="reqn">d</code>-dimensional zero-mean
normal vectors with covariance matrix <code>100I</code>.
(unchanged from the old behavior)
</p>
</li>
<li><p><code>sigma</code>
is dependent on <code>method</code>. The covariance matrices for each
component are generated as follows. If the <code>method</code> is
</p>

<ul>
<li><p><code>"EqualSpherical"</code>, then the covariance matrices are the
identity matrix and thus are all equal and spherical.
</p>
</li>
<li><p><code>"UnequalSpherical"</code>, then the covariance matrices are
scaled identity matrices. In component <code class="reqn">h</code>, the covariance
matrix is <code class="reqn">hI</code>
</p>
</li>
<li><p><code>"EqualEllipsoidal"</code>, then highly elliptical covariance
matrices which equal for all components are used.
The square root of the <code class="reqn">d</code> eigenvalues are chosen
equidistantly on
the interval <code class="reqn">10</code> to <code class="reqn">1</code> and a randomly (uniformly)
oriented orthonormal basis is chosen and used for all
components.
</p>
</li>
<li><p><code>"UnqualEllipsoidal"</code>, then highly elliptical covariance
matrices different for all components are used.
The eigenvalues of the covariance matrices equal as in all
components as in <code>"EqualEllipsoidal"</code>. However, they are all
randomly (uniformly) oriented (unlike as described in
Friedman (1989)).
</p>
</li>
<li><p><code>"old"</code>, then the old behavior is used.
The old behavior differs from <code>"EqualEllipsoidal"</code> by using
the absolute value of <code class="reqn">d</code> zero-mean i.i.d. normal
eigenvalues with a standard deviation of 8.
</p>
</li></ul>

<p>In all cases, the orientation is selected uniformly.
</p>
</li></ul>



<h3>Value</h3>

<p>A named list of parameters with the 4 elements:
</p>
<table>
<tr><td><code>m</code></td>
<td>
<p>An integer giving the number of components in the mixture.
Default is 3.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>An integer giving the dimension of the mixture
distribution. Default is 2.</p>
</td></tr>
<tr><td><code>pie</code></td>
<td>
<p>A numeric vector of length <code>m</code> of mixture
proportions between 0 and 1 which sums to one.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>A <code>list</code> of length <code>m</code> of numeric vectors of
length <code>d</code> for each component.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>A <code>list</code> of length <code>m</code> of variance-covariance
matrices (of size <code>d</code> times <code>d</code>) for each
component.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code><a href="#topic+is.theta">is.theta</a></code> checks whether or not <code>theta</code>
is in the correct format.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Friedman, Jerome H. &quot;Regularized discriminant analysis.&quot; Journal of the
American statistical association 84.405 (1989): 165-175.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.theta">is.theta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rtheta()

rtheta(d = 5, m = 2)

rtheta(d = 3, m = 2, method = "EqualEllipsoidal")

test &lt;- rtheta()
is.theta(test)

summary(test)
print(test)
plot(test)

## Not run: 
A &lt;- SimulateGMMData(n = 100, rtheta(d = 2, method = "EqualSpherical"))
plot(A$z, col = A$K, pch = A$K, asp = 1)
B &lt;- SimulateGMMData(n = 100, rtheta(d = 2, method = "UnequalSpherical"))
plot(B$z, col = B$K, pch = B$K, asp = 1)
C &lt;- SimulateGMMData(n = 100, rtheta(d = 2, method = "EqualEllipsoidal"))
plot(C$z, col = C$K, pch = C$K, asp = 1)
D &lt;- SimulateGMMData(n = 100, rtheta(d = 2, method = "UnequalEllipsoidal"))
plot(D$z, col = D$K, pch = D$K, asp = 1)
## End(Not run)
</code></pre>

<hr>
<h2 id='runGMCM'>Run the GMCM shiny application</h2><span id='topic+runGMCM'></span>

<h3>Description</h3>

<p>Function for starting a local instance of the GMCM shiny application.
The online application is found at <a href="https://gmcm.shinyapps.io/GMCM/">https://gmcm.shinyapps.io/GMCM/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runGMCM(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runGMCM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="shiny.html#topic+runApp">runApp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Retuns nothing (usually). See <code><a href="shiny.html#topic+runApp">runApp</a></code>.
Exit or stop the app by interrupting R.
</p>


<h3>See Also</h3>

<p><code><a href="shiny.html#topic+runApp">runApp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
runGMCM()
runGMCM(launch.browser = FALSE, port = 1111)
# Open browser and enter URL http://127.0.0.1:1111/

## End(Not run)
</code></pre>

<hr>
<h2 id='SimulateGMCMData'>Simulation from Gaussian mixture (copula) models</h2><span id='topic+SimulateGMCMData'></span><span id='topic+SimulateGMMData'></span>

<h3>Description</h3>

<p>Easy and fast simulation of data from Gaussian mixture copula models (GMCM)
and Gaussian mixture models (GMM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateGMCMData(n = 1000, par, d = 2, theta, ...)

SimulateGMMData(n = 1000, theta = rtheta(...), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateGMCMData_+3A_n">n</code></td>
<td>
<p>A single integer giving the number of realizations (observations)
drawn from the model. Default is 1000.</p>
</td></tr>
<tr><td><code id="SimulateGMCMData_+3A_par">par</code></td>
<td>
<p>A vector of parameters of length 4 where <code>par[1]</code> is the
mixture proportion, <code>par[2]</code> is the mean, <code>par[3]</code> is the
standard deviation, and <code>par[4]</code> is the correlation.</p>
</td></tr>
<tr><td><code id="SimulateGMCMData_+3A_d">d</code></td>
<td>
<p>The number of dimensions (or, equivalently, experiments) in the
mixture distribution.</p>
</td></tr>
<tr><td><code id="SimulateGMCMData_+3A_theta">theta</code></td>
<td>
<p>A list of parameters for the model as described in
<code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
<tr><td><code id="SimulateGMCMData_+3A_...">...</code></td>
<td>
<p>In <code>SimulateGMCMData</code> the arguments are passed to
<code>SimulateGMMData</code>.  In <code>SimulateGMMData</code> the arguments are passed
to <code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions provide simulation of <code class="reqn">n</code> observations and
<code class="reqn">d</code>-dimensional GMCMs and GMMs with provided parameters.
The <code>par</code> argument specifies the parameters of the Li et. al. (2011)
GMCM. The <code>theta</code> argument specifies an arbitrary GMCM of
Tewari et. al. (2011). Either one can be supplied. If both are missing,
random parameters are chosen for the general model.
</p>


<h3>Value</h3>

<p><code>SimulateGMCMData</code> returns a list of length 4 with elements:
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>A matrix of the realized values of the GMCM.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A matrix of the latent GMM realizations.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>An integer vector denoting the component from which the
realization comes.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>A list containing the used parameters for the simulations
with the format described in <code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
</table>
<p><code>SimulateGMMData</code> returns a list of length 3 with elements:
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>A matrix of GMM realizations.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>An integer vector denoting the component from which the
realization comes.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>As above and in <code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Li, Q., Brown, J. B. J. B., Huang, H., &amp; Bickel, P. J. (2011).
Measuring reproducibility of high-throughput experiments. The Annals of
Applied Statistics, 5(3), 1752-1779. doi:10.1214/11-AOAS466
</p>
<p>Tewari, A., Giering, M. J., &amp; Raghunathan, A. (2011). Parametric
Characterization of Multimodal Distributions with Non-gaussian Modes.
2011 IEEE 11th International Conference on Data Mining Workshops,
286-292. doi:10.1109/ICDMW.2011.135
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rtheta">rtheta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)

# Simulation from the GMM
gmm.data1 &lt;- SimulateGMMData(n = 200, m = 3, d = 2)
str(gmm.data1)

# Plotting the simulated data
plot(gmm.data1$z, col = gmm.data1$K)

# Simulation from the GMCM
gmcm.data1 &lt;- SimulateGMCMData(n = 1000, m = 4, d = 2)
str(gmcm.data1)

# Plotthe 2nd simulation
par(mfrow = c(1,2))
plot(gmcm.data1$z, col = gmcm.data1$K)
plot(gmcm.data1$u, col = gmcm.data1$K)

# Simulation from the special case of GMCM
theta &lt;- meta2full(c(0.7, 2, 1, 0.7), d = 3)
gmcm.data2 &lt;- SimulateGMCMData(n = 5000, theta = theta)
str(gmcm.data2)

# Plotting the 3rd simulation
par(mfrow=c(1,2))
plot(gmcm.data2$z, col = gmcm.data2$K)
plot(gmcm.data2$u, col = gmcm.data2$K)
</code></pre>

<hr>
<h2 id='summary.theta'>Summary method for theta class</h2><span id='topic+summary.theta'></span>

<h3>Description</h3>

<p>Summary method for theta class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'theta'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.theta_+3A_object">object</code></td>
<td>
<p>A <code>theta</code> object. See <code><a href="#topic+rtheta">rtheta</a></code>.</p>
</td></tr>
<tr><td><code id="summary.theta_+3A_...">...</code></td>
<td>
<p>arguments to be passed to subsequent methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- rtheta()
summary(theta)
</code></pre>

<hr>
<h2 id='u133VsExon'>Reproducibility between U133 plus 2 and Exon microarrays</h2><span id='topic+u133VsExon'></span>

<h3>Description</h3>

<p>This dataset contains a <code>data.frame</code> of unadjusted P-values for
differential expression between germinal center cells and other B-cells
within tonsils for two different experiments. The experiments differ
primarily in the microarray platform used. The first column corresponds the
evidence from the Affymetrix GeneChip Human Genome U133 Plus 2.0 Array.
The second column corresponds to the Affymetrix GeneChip Human Exon 1.0 ST
Array.
</p>


<h3>Format</h3>

<p>The format of the <code>data.frame</code> is:
</p>
<p><code>'data.frame':  19577 obs. of  2 variables:</code><br />
<code>$ u133: num  0.17561 0.00178 0.005371 0.000669 0.655261 ...</code><br />
<code>$ exon: num  1.07e-01 6.74e-10 1.51e-03 6.76e-05 3.36e-01 ...</code><br /></p>


<h3>Details</h3>

<p>Further details can be found in Bergkvist et al. (2014) and
Rasmussen and Bilgrau et al. (2014).
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>References</h3>

<p>Bergkvist, Kim Steve, Mette Nyegaard, Martin Boegsted, Alexander Schmitz,
Julie Stoeve Boedker, Simon Mylius Rasmussen, Martin Perez-Andres et al.
(2014). &quot;Validation and Implementation of a Method for Microarray Gene
Expression Profiling of Minor B-Cell Subpopulations in Man&quot;.
BMC immunology, 15(1), 3.
</p>
<p>Rasmussen SM, Bilgrau AE, Schmitz A, Falgreen S, Bergkvist KS, Tramm AM,
Baech J, Jacobsen CL, Gaihede M, Kjeldsen MK, Boedker JS, Dybkaer K,
Boegsted M, Johnsen HE (2015). &quot;Stable Phenotype Of B-Cell Subsets Following
Cryopreservation and Thawing of Normal Human Lymphocytes Stored in a Tissue
Biobank.&quot; Cytometry Part B: Clinical Cytometry, 88(1), 40-49.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(u133VsExon)
str(u133VsExon)

# Plot P-values
plot(u133VsExon, cex = 0.5)

# Plot ranked and scaled P-values
plot(Uhat(1-u133VsExon), cex = 0.5)
</code></pre>

<hr>
<h2 id='Uhat'>Fast ranking function</h2><span id='topic+Uhat'></span>

<h3>Description</h3>

<p>Function for computing the scaled ranks for each column of the input matrix.
In other words, the values are ranked column-wise and divided by
<code>nrow(x) + 1</code>. A &quot;1334&quot; ranking scheme is used where the lowest values
is awarded rank 1, second lowest value rank 2, and ties are given the
maximum available rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Uhat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Uhat_+3A_x">x</code></td>
<td>
<p>A <code>numeric</code> <code>matrix</code> of observations to be ranked. Rows
correspond to features and columns to experiments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the same dimensions as <code>x</code> of the scaled
ranks.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimulateGMMData">SimulateGMMData</a></code>, <code><a href="#topic+SimulateGMCMData">SimulateGMCMData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- SimulateGMMData()
par(mfrow = c(1,2))
plot(data$z, xlab = expression(z[1]), ylab = expression(z[2]))
plot(Uhat(data$z),
     xlab = expression(hat(u)[1]),
     ylab = expression(hat(u)[2]))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
