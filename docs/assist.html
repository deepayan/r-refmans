<!DOCTYPE html><html><head><title>Help for package assist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {assist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='# dsidr '><p>Interface of dsidr subroutines in RKPACK</p></a></li>
<li><a href='# print.anova.ssr'>
<p>Print an anova.ssr Object</p></a></li>
<li><a href='#acid'><p>Lake Acidity Study</p></a></li>
<li><a href='#alogit'><p> Calculate the Inverse Logit Transformation</p></a></li>
<li><a href='#anova.ssr'>
<p>Testing a Non-parametric Function Fitted via Smoothing Splines</p></a></li>
<li><a href='#Arosa'><p>Monthly Mean Ozone Thickness in Arosa of Switzerland</p></a></li>
<li><a href='#bdiag'><p>Construct a Block Diagonal Matrix</p></a></li>
<li><a href='#bond'><p>Treasury and GE bonds</p></a></li>
<li><a href='#canadaTemp'><p>Monthly Mean Temperatures</p></a></li>
<li><a href='#chickenpox'><p> Chickenpox in New York City</p></a></li>
<li><a href='#chol.new'><p>A Modified Cholesky Decomposition</p></a></li>
<li><a href='#climate'><p>Winter Average Temperatures</p></a></li>
<li><a href='#dcrdr'><p>Interface to Fortran Subroutine dcrdr</p></a></li>
<li><a href='#deviance.ssr'><p>Model Deviance</p></a></li>
<li><a href='#dmudr'>
<p>Interface of dmudr subroutine in RKPACK</p></a></li>
<li><a href='#dog'><p>Coronary Ainus Potassium Concentrations</p></a></li>
<li><a href='#dsms'><p>Interface to Fortran Subroutine dsms</p></a></li>
<li><a href='#gdmudr'><p>Interface of dbmdr, dbimdr, dgmdr, dpmdr in GRKPACK.</p></a></li>
<li><a href='#gdsidr'>
<p>Interface of dbsdr, dbisdr, dgsdr, dpsdr in GRKPACK.</p></a></li>
<li><a href='#hat.ssr'>
<p>Extract the Hat Matrix from a ssr Object</p></a></li>
<li><a href='#horm.cort'><p>Hormone Measurements of Cortisol</p></a></li>
<li><a href='#ident'><p>Scaling a Vector</p></a></li>
<li><a href='#inc'>
<p>Fit a Monotone Curve Using a Cubic Spline</p></a></li>
<li><a href='#intervals.nnr'>
<p>Calculate Predictions and Approximate Posterior Standard Deviations for Spline Estimates From a nnr Object</p></a></li>
<li><a href='#intervals.slm'>
<p>Calculate Predictions and Posterior Standard Deviations of Spline Estimates From a slm Object</p></a></li>
<li><a href='#intervals.snm'>
<p>Calculate Predictions and Approximate Posterior Standard Deviations for Spline Estimate From a snm Object</p></a></li>
<li><a href='#intervals.snr'>
<p>Calculate Predictions and Approximate Posterior Standard Deviations for Spline Estimates From a snr Object</p></a></li>
<li><a href='#kron'><p>Calculate reproducing kernels for one-dimensional space</p></a></li>
<li><a href='#lspline'>
<p>Calculate Reproducing Kernels for Some L-splines</p></a></li>
<li><a href='#nnr'>
<p>Nonlinear Non-parametric Regression</p></a></li>
<li><a href='#nnr.control'><p>Set Control Parameters for nnr</p></a></li>
<li><a href='#paramecium'><p>Growth of paramecium caudatum population</p></a></li>
<li><a href='#periodic'><p>Calculate Reproducing Kernels for Periodic Polynomial Splines with Period 1</p></a></li>
<li><a href='#plot.bCI'>
<p>Bayesian Confidence Interval Plot of a Smoothing Spline Fit</p></a></li>
<li><a href='#plot.ssr'><p>Generate Diagnostic Plots for a ssr Object</p></a></li>
<li><a href='#Polynomial'>
<p>Calculate Reproducing Kernels for Polynomial Splines on [0, 1]</p></a></li>
<li><a href='#Polynomial2'>
<p>Calculate Reproducing Kernels for Polynomial Splines on [0, T]</p></a></li>
<li><a href='#predict.slm'>
<p>Predict Method for Semiparametric Linear Mixed Effects Model Fits</p></a></li>
<li><a href='#predict.snm'>
<p>Predictions from a Semiparametric Nonlinear Mixed Effects Model Fit</p></a></li>
<li><a href='#predict.snr'>
<p>Predict Method from a Semiparametric Nonlinear Regression Model Fit</p></a></li>
<li><a href='#predict.ssr'>
<p>Calculate Predictions and Posterior Standard Deviations for a ssr Object</p></a></li>
<li><a href='#print.nnr'>
<p>Print Values</p></a></li>
<li><a href='#print.slm'>
<p>Print Values</p></a></li>
<li><a href='#print.snm'>
<p>Print Values</p></a></li>
<li><a href='#print.snr'>
<p>Print Values</p></a></li>
<li><a href='#print.ssr'>
<p>Print Values</p></a></li>
<li><a href='#print.summary.nnr'><p>Print Vales</p></a></li>
<li><a href='#print.summary.slm'><p>Print Values</p></a></li>
<li><a href='#print.summary.snm'><p>Print Values</p></a></li>
<li><a href='#print.summary.snr'><p>Print Values</p></a></li>
<li><a href='#print.summary.ssr'><p>Print Values</p></a></li>
<li><a href='#rk.prod'>
<p>Calculate product of reproducing kernels</p></a></li>
<li><a href='#seizure'><p>IEEG segments from a seizure patient</p></a></li>
<li><a href='#Shrinkage'><p>Calculate reproducing kernels for Stein shrinkage estimate</p></a></li>
<li><a href='#sine4p'><p>Calculate Reproducing Kernels for Periodic L-Splines with Period 1/2</p></a></li>
<li><a href='#slm'>
<p>Fit a Semi-parametric Linear Mixed Effects Model</p></a></li>
<li><a href='#snm'>
<p>Fit a Semi-parametric Nonlinear Mixed-effects Model</p></a></li>
<li><a href='#snm.control'>
<p>Set Control Parameters for snm</p></a></li>
<li><a href='#snr'>
<p>Fit A Semi-parametric Nonlinear Regression Model</p></a></li>
<li><a href='#snr.control'>
<p>Set Control Parameters for snr</p></a></li>
<li><a href='#sphere'>
<p>Calculate Pseudo Reproducing Kernels for Spherical Splines</p></a></li>
<li><a href='#ssr'><p>Fit a General Smoothing Spline Regression Model</p></a></li>
<li><a href='#ssr.control'><p>Set Control Parameters for &lsquo;ssr&rsquo;</p></a></li>
<li><a href='#ssr.object'><p> A fitted ssr Object</p></a></li>
<li><a href='#star'>
<p>Magnitude of the Mira Variable R Hydrae</p></a></li>
<li><a href='#Stratford'><p>Daily maximum temperatures in Stratford</p></a></li>
<li><a href='#summary.nnr'>
<p>Object Summaries</p></a></li>
<li><a href='#summary.slm'>
<p>Object Summaries</p></a></li>
<li><a href='#summary.snm'>
<p>Object Summaries</p></a></li>
<li><a href='#summary.snr'>
<p>Object Summaries</p></a></li>
<li><a href='#summary.ssr'>
<p>Summarize a ssr object</p></a></li>
<li><a href='#Thin'>
<p>Calculate Reproducing Kernels for Thin Plate Splines</p></a></li>
<li><a href='#TXtemp'><p>Texas Historical Climate Data</p></a></li>
<li><a href='#ultrasound'>
<p>Ultrasound imaging of the tongue shape</p></a></li>
<li><a href='#USAtemp'><p>Average Winter temperature in the United States</p></a></li>
<li><a href='#wesdr'><p>Wisconsin Epidemiological Study of Diabetic Retinopathy</p></a></li>
<li><a href='#xyplot2'><p>Extension of XYPLOT</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Suite of R Functions Implementing Spline Smoothing Techniques</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.9</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit various smoothing spline models. Includes an ssr() function for smoothing 
    spline regression, an nnr() function for nonparametric nonlinear regression, an snr() 
    function for semiparametric nonlinear regression, an slm() function for semiparametric 
    linear mixed-effects models, and an snm() function for semiparametric nonlinear 
    mixed-effects models. See Wang (2011) &lt;<a href="https://doi.org/10.1201%2Fb10954">doi:10.1201/b10954</a>&gt; for an overview.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), nlme, lattice</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://yuedong.faculty.pstat.ucsb.edu/software.html">https://yuedong.faculty.pstat.ucsb.edu/software.html</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 18:28:16 UTC; yuedong</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuedong Wang [aut, cre],
  Chunlei Ke [aut],
  Cleve Moler [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yuedong Wang &lt;yuedong@ucsb.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+20dsidr+20'>Interface of dsidr subroutines in RKPACK</h2><span id='topic+dsidr'></span>

<h3>Description</h3>

<p>To calculate a spline estimate with a single smoothing parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsidr(y, q, s=NULL, weight=NULL, vmu="v", varht=NULL, 
limnla=c(-10, 3), job=-1, tol=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B20dsidr+2B20_+3A_y">y</code></td>
<td>

<p>a numerical vector representing the response.
</p>
</td></tr>
<tr><td><code id="+2B20dsidr+2B20_+3A_q">q</code></td>
<td>

<p>a square matrix of the same order as the length of y, with elements equal to the reproducing kernel evaluated at the design points.
</p>
</td></tr>
<tr><td><code id="+2B20dsidr+2B20_+3A_s">s</code></td>
<td>

<p>the design matrix of the null space <code class="reqn">H_0</code> of size (length(y),dim(<code class="reqn">H_0</code>)), 
with elements equal to the bases of <code class="reqn">H_0</code> evaluated at design points. Default is NULL, representing an empty NULL space.</p>
</td></tr>
<tr><td><code id="+2B20dsidr+2B20_+3A_weight">weight</code></td>
<td>

<p>A weight matrix for penalized weighted least-square: <code class="reqn">(y-f)'W(y-f)+n\lambda J(f)</code>. Default is NULL for iid random errors.
</p>
</td></tr>
<tr><td><code id="+2B20dsidr+2B20_+3A_vmu">vmu</code></td>
<td>

<p>a character string specifying a method for choosing the smoothing  parameter.  &quot;v&quot;, &quot;m&quot; and &quot;u&quot; represent GCV, GML and UBR respectively. 
&quot;u<code class="reqn">\sim</code>&quot;, only used for non-Gaussian family, specifies UBR with estimated variance. Default is &quot;v&quot;.
</p>
</td></tr>
<tr><td><code id="+2B20dsidr+2B20_+3A_varht">varht</code></td>
<td>

<p>needed only when vmu=&quot;u&quot;, which gives the fixed variance in calculation of the UBR function. Default is NULL.
</p>
</td></tr>
<tr><td><code id="+2B20dsidr+2B20_+3A_limnla">limnla</code></td>
<td>

<p>a vector of length 2, specifying a search range for the  n times smoothing parameter on <code class="reqn">log10</code> scale. Default is <code class="reqn">(-10, 3)</code>.
</p>
</td></tr>
<tr><td><code id="+2B20dsidr+2B20_+3A_job">job</code></td>
<td>

<p>an integer representing the optimization method used to find the smoothing parameter. 
The  options are job=-1: golden-section search on (limnla(1), limnla(2)); 
job=0: golden-section search with interval specified automatically; 
job &gt;0: regular grid search on  <code class="reqn">[limnla(1), limnla(2)]</code> with the number of grids = job + 1. Default is -1. 
</p>
</td></tr>
<tr><td><code id="+2B20dsidr+2B20_+3A_tol">tol</code></td>
<td>

<p>tolerance for truncation used in &lsquo;dsidr&rsquo;. Default is 0.0, which sets to square of machine precision.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>info</code></td>
<td>

<p>an integer that provides error message. info=0 indicates normal termination, info=-1 indicates dimension error, info=-2 indicates
<code class="reqn">F_{2}^{T} Q F_{2} !&gt;= 0</code>, info=-3 indicates vmu is out of scope, and info&gt;0 indicates the matrix S is rank 
deficient with info=rank(S)+1. 
</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>

<p>fitted values.
</p>
</td></tr>
<tr><td><code>c</code></td>
<td>

<p>estimates of c.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>estimates of d.
</p>
</td></tr>
<tr><td><code>resi</code></td>
<td>

<p>vector of residuals.
</p>
</td></tr>
<tr><td><code>varht</code></td>
<td>

<p>estimate of variance.
</p>
</td></tr>
<tr><td><code>nlaht</code></td>
<td>

<p>the estimate of log10(nobs*lambda).
</p>
</td></tr>
<tr><td><code>limnla</code></td>
<td>

<p>searching range for nlaht. 
</p>
</td></tr>
<tr><td><code>score</code></td>
<td>

<p>the minimum GCV/GML/UBR score at the estimated smoothing parameter. When job&gt;0, it gives a vector of GCV/GML/UBR functions evaluated at regular grid points.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>equavilent degree of freedom.
</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>

<p>length(y), number of observations.
</p>
</td></tr>
<tr><td><code>nnull</code></td>
<td>

<p>dim(<code class="reqn">H_0</code>), number of bases.
</p>
</td></tr>
<tr><td><code>s</code>, <code>qraux</code>, <code>jpvt</code></td>
<td>

<p>QR decomposition of S=FR, as from Linpack &lsquo;dqrdc&rsquo;.
</p>
</td></tr>
<tr><td><code>q</code></td>
<td>

<p>first dim(<code class="reqn">H_0</code>) columns gives <code class="reqn">F^{T} Q F_{1}</code>, and its bottom-right corner gives tridiagonalization of <code class="reqn">F_{2}^{T} Q F_{2}</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Gu, C. (1989). RKPACK and its applications: Fitting smoothing spline models. Proceedings of the Statistical Computing Section, ASA, 42-51.
</p>
<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmudr">dmudr</a></code>, <code><a href="#topic+gdsidr">gdsidr</a></code>, <code><a href="#topic+gdmudr">gdmudr</a></code>, <code><a href="#topic+ssr">ssr</a></code>
</p>

<hr>
<h2 id='+20print.anova.ssr'>
Print an anova.ssr Object
</h2><span id='topic+print.anova.ssr'></span>

<h3>Description</h3>

<p>Calculate and output p-values for tests available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anova.ssr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B20print.anova.ssr_+3A_x">x</code></td>
<td>

<p>an object inheriting from class anova.ssr, generally obtained by 
applying the anova.ssr method to an ssr object.
</p>
</td></tr>
<tr><td><code id="+2B20print.anova.ssr_+3A_...">...</code></td>
<td>
<p>other available arguments, currently unused.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.ssr">anova.ssr</a></code>, <code><a href="#topic+ssr">ssr</a></code>
</p>

<hr>
<h2 id='acid'>Lake Acidity Study</h2><span id='topic+acid'></span>

<h3>Description</h3>

<p>The <code>acid</code> data frame has 112 rows and 4 columns of data derived based on the Eastern Lakes Survey of 1984 implemented by the Environmental Protection Agency of the USA.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(acid)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>ph a numeric vector of surface pH values.
</p>
<p>t1 a numeric vector of calcium concentrations in log10 milligrams per liter.
</p>
<p>x1, x2 numeric vectors of the lakes' geographic locations.
</p>


<h3>Details</h3>

<p>112 lakes are extracted in the southern Blue Ridge mountains area. The surface pH values were recorded together with the calcium concentration and geographic locations.</p>


<h3>Source</h3>

<p>Douglas, A. and Delampady, M. (1990), Eastern Lake Survey Phase I: Documentation for the Data Base and the Derived Data sets. Tech Report 160 (SIMS), Dept. Statistics, University of British Columbia. 
</p>


<h3>References</h3>

<p>Gu, C. and Wahba, G. (1993) Smoothing Spline ANOVA with component-wise Bayesian confidence intervals. Journal of Computational and Graphic Statistics 55, 353-368.
</p>

<hr>
<h2 id='alogit'> Calculate the Inverse Logit Transformation</h2><span id='topic+alogit'></span>

<h3>Description</h3>

<p>Perform an inverse logit calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alogit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alogit_+3A_x">x</code></td>
<td>
<p>a numeric value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returned is <code class="reqn">e^x/(1+e^x)</code>.
</p>


<h3>Author(s)</h3>

<p>Chunlei ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>

<hr>
<h2 id='anova.ssr'>
Testing a Non-parametric Function Fitted via Smoothing Splines
</h2><span id='topic+anova.ssr'></span>

<h3>Description</h3>

<p>For smoothing spline models with a single smoothing parameter, test
the hypothesis that the unknown funciton 
lies in the null space using the local most powerful (LMP) test and 
a GCV or GML test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssr'
anova(object, simu.size=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.ssr_+3A_object">object</code></td>
<td>

<p>an object of class &quot;ssr&quot; fitted with a single smooting parameter.
</p>
</td></tr>
<tr><td><code id="anova.ssr_+3A_simu.size">simu.size</code></td>
<td>

<p>an optional integer giving the number of simulations to calcualte 
p-values based on simulation. Default is 100.
</p>
</td></tr>
<tr><td><code id="anova.ssr_+3A_...">...</code></td>
<td>
<p>other available arguments, currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Gaussian data with one smoothing parameter, test the hypothesis that the function is in the 
null space <code class="reqn">H_0</code>, i.e. the parametric part of the fitted model is sufficient. 
Available are the LMP and GCV or GML methods. However, the p-values cannot be calculated analytically 
since the null distributions for these testing statistics under <code class="reqn">H_0</code> are unknown. 
Monte Carlo simulation is used to approximate the p-values
for the LMP, and GCV (if spar=&quot;v&quot;) or GML (if spar=&quot;m&quot;) methods. Due to computation burden, 
the smoothing parameters are fixed at their estimate in the currect calculation. 
</p>
<p>When spar=&quot;m&quot;, an approximate p-value based on a mixture of two Chi-square distributions is also provided for the GML test, 
which tends to be conservationve (Pinherio and Bates, 2002). 
</p>
<p>Methods further developed in  Liu and Wang (2004) and Liu, Meiring and Wang (2004) will be implemented in the future.
</p>


<h3>Value</h3>

<p>a list including test values.
</p>


<h3>Author(s)</h3>

<p> Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Cox, D. and Koh, E. (1989). A smoothing spline based test of model adequency
in polynomial regression. Ann. Ins. Stat. Math. 41, 383-400.
</p>
<p>Cox, D., Koh, E., Wahba, G. and Yandell, B.S. (1988). Testing the parameteric null
model hypothesis in semi-parametric partial and generalized spline models. 
Ann. Statist. 16, 113-119.
</p>
<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Pinherio, J. C. and Bates, D. M. (2000) Mixed-effects Models in S and S-Plus. Springer.
</p>
<p>Liu, A. and Wang, Y. (2004) Hypothesis Testing in Smoothing Spline Models. 
Journal of Statistical Computation and Simulation, to appear. 
</p>
<p>Liu, A., Meiring, W. and Wang, Y. (2004), Testing Generalized Linear Models Using Smoothing Spline Methods. Statistica Sinica, to appear,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+print.anova.ssr">print.anova.ssr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(acid)

# fit a partial thin-plate spline
temp &lt;- ssr(ph~t1+x1+x2, rk=tp(t1), data=acid, spar="m")
anova(temp, 500)

## End(Not run)
</code></pre>

<hr>
<h2 id='Arosa'>Monthly Mean Ozone Thickness in Arosa of Switzerland</h2><span id='topic+Arosa'></span>

<h3>Description</h3>

<p> The <code>Arosa</code> data frame has 518 rows and 3 columns of data for monthly mean ozone thickness.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Arosa)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>year a vector of integers from 1 to 46 indicating the years when the measures were taken from 1926. 
</p>
<p>month a vector of integers from 1 to 12 represeting the months in a year.
</p>
<p>thick a numeric vetor of mean ozone thickness (Dobson units).
</p>


<h3>Details</h3>

<p> Monthly mean ozone thickness in Arosa, Switzerland was recorded from 1926-1971.
</p>


<h3>Source</h3>

<p>Andrew,D. F. and Herzberg, A. M. (1985). Data: a collection of problems from many fields for the  
students and research workers. Springer: Berlin: New York.
</p>

<hr>
<h2 id='bdiag'>Construct a Block Diagonal Matrix</h2><span id='topic+bdiag'></span>

<h3>Description</h3>

<p>Return a block diagonal matrix formed from the input list of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdiag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdiag_+3A_x">x</code></td>
<td>
<p>a list of matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returned is a matrix of the form diag(x1, ..., xn) where n is the length of the list.
</p>

<hr>
<h2 id='bond'>Treasury and GE bonds</h2><span id='topic+bond'></span>

<h3>Description</h3>

<p>The <code>bond</code> data frame has 1234 rows and 5 columns of data derived from 144 General Electronic Company bonds and 78 Treasury bonds.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bond)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>name a vector of index for individual bond
</p>
<p>price a numeric vector of current price
</p>
<p>time a numeric vector of future time points at which the payments are made
</p>
<p>payment a numeric vector of future payments
</p>
<p>type a vector of character strings identifying the groups, &quot;govt&quot; or &quot;ge&quot;, which the individual bonds belong to.
</p>


<h3>Source</h3>

<p>Bloomberg
</p>


<h3>references</h3>

<p>Chunlei Ke and Yuedong Wang (2004), Nonlinear Nonparametric Regression Models. Journal of the American Statistical Association 99, 1166-1175.
</p>

<hr>
<h2 id='canadaTemp'>Monthly Mean Temperatures</h2><span id='topic+canadaTemp'></span>

<h3>Description</h3>

<p> The <code>canadaTemp</code> data frame has 420 rows and 3 columns of data for monthly mean temperatures in Canada</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(canadaTemp)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>temp a numeric vector of mean temperatures at some stations in Canada. 
</p>
<p>month a vector of integers from 1 to 12 represeting the months in a year.
</p>
<p>station a vetor of integers from 1 to 35 indicating the sations where the temperatures were recorded.
</p>


<h3>Source</h3>

<p>The data set was downloaded from <a href="https://www.psych.mcgill.ca/misc/fda/downloads/FDAfuns/R/data/">https://www.psych.mcgill.ca/misc/fda/downloads/FDAfuns/R/data/</a>.
</p>


<h3>References</h3>

<p>Ramsay, J. O and Silverman, B. W. (1997). Functional Data Analysis. New York:Springer.
</p>
<p>Ke, C. and Wang, Y. (2001). Semi-parametric Nonlinear Mixed Effects Models and
Their Applications. JASA 96:1272-1298.
</p>

<hr>
<h2 id='chickenpox'> Chickenpox in New York City</h2><span id='topic+chickenpox'></span>

<h3>Description</h3>

<p>The <code>chickenpox</code> data frame has 498 rows and 3 columns of data 
recording the number of Chickenpox occurrences in New York City.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chickenpox)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>count the number of monthly reported Chickenpox cases.
</p>
<p>month a vector of integers from 1 to 12 representing the month for the reported cases.
year a numeric vector representing the year when the cases were reported.
</p>


<h3>Details</h3>

<p> This data frame contains monthly number of reported cases of chickenpox in New York City from 1931 to the first six months of 1972.</p>


<h3>Source</h3>

<p>The data were downloaded from <a href="https://robjhyndman.com/tsdl/">https://robjhyndman.com/tsdl/</a>.
</p>

<hr>
<h2 id='chol.new'>A Modified Cholesky Decomposition</h2><span id='topic+chol.new'></span>

<h3>Description</h3>

<p>Returned a matrix forming Cholesky Decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chol.new(Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol.new_+3A_q">Q</code></td>
<td>
<p>a symmetric matrix, maybe non-positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used internally as an extension of <code>chol</code> that works on a positive matrix.
</p>


<h3>Value</h3>

<p>A mtrix M suth that <code class="reqn">XX^T=Q</code>.
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+chol">chol</a></code></p>

<hr>
<h2 id='climate'>Winter Average Temperatures</h2><span id='topic+climate'></span>

<h3>Description</h3>

<p>The data frame <code>climate</code>, obrained from the Carbon Dioxide Information and Analysis Center, has 690 rows and 5 columns of data representing station winter temperature measurements.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(climate)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>temp a numeric vector of temperatures in celsius.
</p>
<p>lat, long numeric vectors identifying the lattitudes and longitudes of the stations in.
</p>
<p>lat.degree, long.degree  numeric vectors identifying the lattitudes and longitudes of the stations in degree.
</p>


<h3>Details</h3>

<p>The station winter average temperatures were the averages of the December, January and Febuary monthly average temperatures obtained from the Jones/Wigley data files obtainable from the CDIAC at Oak Ridge National Laboratory in the files ndp020r1/jonesnh.data.Z and ndp020r1/jonessh.dat.Z in the pbu directory at 128.219.24.36.
</p>


<h3>Source</h3>

<p>Jones, P., Wigley, T. and Briffa, K.. lobal and hemisphere temperature anaomalies-land and marine instrumental records. In T. Boden, D. Kaiser, R. Sepanski, and F. Stoss, editors, Trends '93: A Compendium of Data on Global Change, ORNL/CDIAC-65, pages  603-608, Oak Ridge, TN 1994. CDIAC, Oak Ridge National Laboratory.
</p>

<hr>
<h2 id='dcrdr'>Interface to Fortran Subroutine dcrdr</h2><span id='topic+dcrdr'></span>

<h3>Description</h3>

<p>Calculate some matrix operations needed to construct Bayesian confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcrdr(rkpk.obj, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcrdr_+3A_rkpk.obj">rkpk.obj</code></td>
<td>
<p>an object returned from calling dsidr</p>
</td></tr>
<tr><td><code id="dcrdr_+3A_r">r</code></td>
<td>
<p>a matrix to evaluate reproducing kernels on grid points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See the document for the corresponding Fortran subroutine.
</p>

<hr>
<h2 id='deviance.ssr'>Model Deviance</h2><span id='topic+deviance.ssr'></span>

<h3>Description</h3>

<p>Extract deviance from a fitted ssr object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssr'
deviance(object,residuals=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.ssr_+3A_object">object</code></td>
<td>
<p>a fitted <code>ssr</code> object</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="deviance.ssr_+3A_residuals">residuals</code></td>
<td>

<p>a logical value. If 'TRUE', deviance residuals are returned. If 'FALSE', the sum of deviance residuals squares is returned. Default is FALSE.</p>
</td></tr>
<tr><td><code id="deviance.ssr_+3A_...">...</code></td>
<td>
<p>other arguments, currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function <code>deviance</code>  for  objects
inheriting from class <code>ssr</code>.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+ssr">ssr</a></code></p>

<hr>
<h2 id='dmudr'>
Interface of dmudr subroutine in RKPACK
</h2><span id='topic+dmudr'></span>

<h3>Description</h3>

<p>To calculate a spline estimate with multiple smoothing parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmudr(y, q, s, weight = NULL, vmu = "v", theta = NULL, varht = NULL, 
    tol = 0, init = 0, prec = 1e-06, maxit = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmudr_+3A_y">y</code></td>
<td>

<p>a numerical vector representing the response.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_q">q</code></td>
<td>

<p>a list, or an array, of square matrices of the same order as the length of y, which are the reproducing kernels evaluated at the design points.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_s">s</code></td>
<td>

<p>the design matrix of the null space <code class="reqn">H_0</code> of size (length-of-y,<code class="reqn">dim(H_0)</code>), with elements equal to the bases of <code class="reqn">H_0</code> evaluated at design points.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_weight">weight</code></td>
<td>

<p>a weight matrix for penalized weighted least-square: <code class="reqn">(y-f)'W(y-f)+n\lambda J(f)</code>. Default is NULL for iid random errors.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_vmu">vmu</code></td>
<td>

<p>a character string specifying a method for choosing the smoothing  parameter.  &quot;v&quot;, &quot;m&quot; and &quot;u&quot; represent GCV, GML and UBR respectively. &quot;u<code class="reqn">\sim</code>&quot;, only used for non-Gaussian family, specifies UBR with estimated variance. Default is &quot;v&quot;.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_theta">theta</code></td>
<td>

<p>If &lsquo;init=1&rsquo;, theta includes intial values for smoothing parameters. Default is NULL.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_varht">varht</code></td>
<td>

<p>needed only when vmu=&quot;u&quot;, which gives the fixed variance in calculation of the UBR function. Default is NULL.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_tol">tol</code></td>
<td>

<p>the tolerance for truncation in the tridiagonalization. Default is 0.0.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_init">init</code></td>
<td>

<p>an integer of 0 or 1 indicating if initial values are provided for theta. If init=1, initial values are provided using theta. Default is 0.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_prec">prec</code></td>
<td>

<p>precision requested for the minimum score value, where precision is the weaker of the absolute and relative precisions. Default is <code class="reqn">1e-06</code>.
</p>
</td></tr>
<tr><td><code id="dmudr_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations allowed. Default is 30.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>info</code></td>
<td>

<p>an integer that provides error message. info=-1 indicates dimension error, 
info=-2 indicates <code class="reqn">F_{2}^{T} Q_{*}^{\theta} F_{2} !&gt;= 0</code>, info=-3 indicates tuning parameters are out of scope, info=-4 indicates fails to converge within maxite steps, info=-5 indicates fails to find a reasonable descent direction, info&gt;0 indicates the matrix S is rank deficient with <code class="reqn">info=rank(S)+1</code>.
</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>

<p>fitted values.
</p>
</td></tr>
<tr><td><code>c</code></td>
<td>

<p>estimates of c.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>estimates of d.
</p>
</td></tr>
<tr><td><code>resi</code></td>
<td>

<p>vector of residuals.
</p>
</td></tr>
<tr><td><code>varht</code></td>
<td>

<p>estimate of variance.
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>estimates of parameters <code class="reqn">log10(\theta)</code>. </p>
</td></tr>
<tr><td><code>nlaht</code></td>
<td>

<p>the estimate of <code class="reqn">log10(nobs*\lambda)</code>.
</p>
</td></tr>
<tr><td><code>score</code></td>
<td>

<p>the minimum GCV/GML/UBR score at the estimated smoothing parameters. 
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>equavilent degree of freedom.
</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>

<p>length(y), number of observations.
</p>
</td></tr>
<tr><td><code>nnull</code></td>
<td>

<p>dim(<code class="reqn">H_0</code>), number of bases.
</p>
</td></tr>
<tr><td><code>nq</code></td>
<td>

<p>length(rk), number of reproducing kernels.
</p>
</td></tr>
<tr><td><code>s</code>, <code>q</code>, <code>y</code></td>
<td>

<p>changed from the inputs.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Gu, C. (1989). RKPACK and its applications: Fitting smoothing spline models. Proceedings of the Statistical Computing Section, ASA, 42-51.
</p>
<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsidr">dsidr</a></code>, <code><a href="#topic+gdsidr">gdsidr</a></code>, <code><a href="#topic+gdmudr">gdmudr</a></code>, <code><a href="#topic+ssr">ssr</a></code>
</p>

<hr>
<h2 id='dog'>Coronary Ainus Potassium Concentrations</h2><span id='topic+dog'></span>

<h3>Description</h3>

<p>The <code>dog</code> data frame has 252 rows and 4 columns of data considered by Grizzle and Alen (1969)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dog)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>y a numeric vector of meansurements of coronary sinus postassium concentrations.
</p>
<p>group a vector of group index for the four groups of dogs.
</p>
<p>dog a vector of integers identifying dogs.
</p>
<p>time a numeric vector of time points measurements were made.
</p>


<h3>Details</h3>

<p>The data are coronary sinus potassium concentrations measured on each of 36 dogs. These 36 dogs were divided into 4 treatment groups, and the measurements on each dog were taken every two minutes from 1 to 13 minutes after occlusion.</p>


<h3>Source</h3>

<p>Grizzle, J. E. and Allen, D. M. (1969). Analysis of growth and dose response curves, Biometrics 25: 357-381.
</p>

<hr>
<h2 id='dsms'>Interface to Fortran Subroutine dsms </h2><span id='topic+dsms'></span>

<h3>Description</h3>

<p>Calculate a matrix operation needed to construct Bayesian confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsms(rkpk.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsms_+3A_rkpk.obj">rkpk.obj</code></td>
<td>
<p>an object returned from calling dsidr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix. See the corresponding Fortran subroutine. 
</p>

<hr>
<h2 id='gdmudr'>Interface of dbmdr, dbimdr, dgmdr, dpmdr in GRKPACK.</h2><span id='topic+gdmudr'></span>

<h3>Description</h3>

<p>To calculate a spline estimate with multiple smoothing parameters for non-Gaussian data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdmudr(y, q, s, family, vmu = "v", varht = NULL, 
    init = 0, theta = NULL, tol1 = 0, tol2 = 0, prec1 = 1e-06, 
    maxit1 = 30, prec2 = 1e-06, maxit2 = 30) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdmudr_+3A_y">y</code></td>
<td>

<p>a numerical vector representing the response, or a matrix of two columns for binomial data with the first column as the largest possible counts and the second column as the counts actually obsered.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_q">q</code></td>
<td>

<p>a list, or an array, of square matrices of the same order as the length of y, which are the reproducing kernels evaluated at the design points.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_s">s</code></td>
<td>

<p>the design matrix of the null space <code class="reqn">H_0</code> of size (length-of-y,<code class="reqn">dim(H_0)</code>), with elements equal to the bases of <code class="reqn">H_0</code> evaluated at design points.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_family">family</code></td>
<td>

<p>a string specifying the family of distribution. Families  supported  are  &quot;binary&quot;, &quot;binomial&quot;, &quot;poisson&quot; and &quot;gamma&quot; for Bernoulli, binomial, poisson, and gamma distributions respectively. Canonical links are used except for Gamma family where log link is used.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_vmu">vmu</code></td>
<td>

<p>a character string specifying a method for choosing the smoothing  parameter.  &quot;v&quot;, &quot;m&quot; and &quot;u&quot; represent GCV, GML and UBR respectively. 
&quot;u<code class="reqn">\sim</code>&quot;, only used for non-Gaussian family, specifies UBR with estimated variance. Default is &quot;v&quot;.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_varht">varht</code></td>
<td>

<p>needed only when vmu=&quot;u&quot;, which gives the fixed variance in calculation of the UBR function. Default is 1.0.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_init">init</code></td>
<td>

<p>an integer of 0 or 1 indicating if initial values are provided for theta. If init=1, initial values are provided using theta. Default is 0.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_theta">theta</code></td>
<td>

<p>If &lsquo;init=1&rsquo;, theta includes intial values for smoothing parameters. Default is NULL.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_tol1">tol1</code></td>
<td>

<p>the tolerance for elements of w's. Default is 0.0 which sets to square of machine precision. 
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_tol2">tol2</code></td>
<td>

<p>tolerance for truncation used in &lsquo;dsidr&rsquo;. Default is 0.0 which sets to square of machine precision.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_prec1">prec1</code></td>
<td>

<p>precision requested for the minimum score value, where precision is the weaker of the absolute and relative precisions. Default is 1e-06.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_maxit1">maxit1</code></td>
<td>

<p>maximum number of iterations allowed for DMUDR subroutine. Default is 30.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_prec2">prec2</code></td>
<td>

<p>precision requested for stopping the iteration. Default is <code class="reqn">1e-06</code>.
</p>
</td></tr>
<tr><td><code id="gdmudr_+3A_maxit2">maxit2</code></td>
<td>

<p>maximum number of iterations allowed for the iteration in GRKPACK. Default is 30.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>info</code></td>
<td>

<p>an integer that provides error message. info=-1 indicates dimension error, 
info=-2 idicates <code class="reqn">F_{2}^{T} Q_{*}^{theta} F_{2} !&gt;= 0</code>, info=-3 indicates tuning parameters are out of scope, info=-4 indicates dmudr fails to converge within maxit1 steps, info=-5 indicates dmudr fails to find a reasonable descent direction, info=-6 indicates GRKPACK fails to converge within maxit2 steps, info=-7 indicates there are some w's equals to zero, 
info&gt;0 indicates the matrix S is rank deficient with <code class="reqn">info=rank(S)+1</code>.
</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>

<p>estimate of the function at design points.
</p>
</td></tr>
<tr><td><code>c</code></td>
<td>

<p>estimates of c.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>estimates of d.
</p>
</td></tr>
<tr><td><code>resi</code></td>
<td>

<p>vector of working residuals.
</p>
</td></tr>
<tr><td><code>varht</code></td>
<td>

<p>estimate of dispersion parameter.
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>estimates of parameters <code class="reqn">log10(theta)</code>. 
</p>
</td></tr>
<tr><td><code>nlaht</code></td>
<td>

<p>the estimate of <code class="reqn">log10(nobs*lambda)</code>.
</p>
</td></tr>
<tr><td><code>score</code></td>
<td>

<p>the minimum GCV/GML/UBR score at the estimated smoothing parameters. 
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>equavilent degree of freedom.
</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>

<p>length-of-y, number of observations.
</p>
</td></tr>
<tr><td><code>nnull</code></td>
<td>

<p><code class="reqn">dim(H_0)</code>, number of bases.
</p>
</td></tr>
<tr><td><code>nq</code></td>
<td>

<p>length(rk), number of reproducing kernels.
</p>
</td></tr>
<tr><td><code>s</code>, <code>q</code>, <code>y</code>, <code>init</code>, <code>maxit2</code></td>
<td>

<p>changed from the inputs.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Wang, Y. (1997). GRKPACK: Fitting Smoothing Spline ANOVA Models for Exponential Families. Communications in Statistics: Simulation and Computation, 24: 1037-1059.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsidr">dsidr</a></code>, <code><a href="#topic+dmudr">dmudr</a></code>, <code><a href="#topic+gdsidr">gdsidr</a></code>, <code><a href="#topic+ssr">ssr</a></code>
</p>

<hr>
<h2 id='gdsidr'>
Interface of dbsdr, dbisdr, dgsdr, dpsdr in GRKPACK.
</h2><span id='topic+gdsidr'></span>

<h3>Description</h3>

<p>To calculate a spline estimate with single smoothing parameter for non-Gaussian data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdsidr(y, q, s, family, vmu="v", varht=NULL, limnla=c(-10, 3), 
maxit=30, job=-1, tol1=0, tol2=0, prec=1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdsidr_+3A_y">y</code></td>
<td>

<p>a numerical vector representing the response, or a matrix of two columns for binomial data with the first column as the largest possible counts and the second column as the counts actually obsered.
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_q">q</code></td>
<td>

<p>a square matrix of the same order as the length of y, with elements equal to the reproducing kernel evaluated at the design points.
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_s">s</code></td>
<td>

<p>the design matrix of the null space <code class="reqn">H_0</code> of size (length-of-y,dim(<code class="reqn">H_0</code>)), with elements equal to the bases of <code class="reqn">H_0</code> evaluated at design points.
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_family">family</code></td>
<td>

<p>a string specifying the family of distribution. Families  supported  are  &quot;binary&quot;, &quot;binomial&quot;, &quot;poisson&quot; and &quot;gamma&quot; for Bernoulli, binomial, poisson, and gamma distributions respectively. Canonical links are used except for Gamma family where a log link is used.
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_vmu">vmu</code></td>
<td>

<p>a character string specifying a method for choosing the smoothing  parameter.  &quot;v&quot;, &quot;m&quot; and &quot;u&quot; represent GCV, GML and UBR respectively. &quot;u<code class="reqn">\sim</code>&quot;, only used for non-Gaussian family, specifies UBR with estimated variance. Default is &quot;v&quot;.
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_varht">varht</code></td>
<td>

<p>needed only when vmu=&quot;u&quot;, which gives the fixed variance in calculation of the UBR function. Default is 1.0.
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_limnla">limnla</code></td>
<td>

<p>a vector of length 2, specifying a search range for the  n times smoothing parameter on log10 scale. Default is (-10, 3).
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations allowed for the iteration in GRKPACK.
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_job">job</code></td>
<td>

<p>an integer representing the optimization method used to find the smoothing parameter. 
The  options are job=-1: golden-section search on (limnla(1), limnla(2)); 
job=0: golden-section search with interval specified automatically; 
job &gt;0: regular grid search on  [limnla(1), limnla(2)] with the number of grids = job + 1. Default is -1. 
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_tol1">tol1</code></td>
<td>

<p>the tolerance for elements of w's. Default is 0.0 which sets to square of machine precision. 
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_tol2">tol2</code></td>
<td>

<p>tolerance for truncation used in &lsquo;dsidr&rsquo;. Default is 0.0 which sets to square of machine precision.
</p>
</td></tr>
<tr><td><code id="gdsidr_+3A_prec">prec</code></td>
<td>

<p>precision requested for stopping the iteration. Default is <code class="reqn">1e-06</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>info</code></td>
<td>

<p>an integer that provides error message. info=0 indicates normal termination, info=-1 indicates dimension error, 
info=-2 indicates <code class="reqn">F_{2}^{T} Q F_{2} !&gt;= 0</code>, info=-3 indicates vmu is out of scope, info=-4 indicates the algorithm fails to converge at the maxiter steps, info=-5 indicates there are some w's equals to zero, and info&gt;0 indicates the matrix S is rank deficient with info=rank(S)+1. 
</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>

<p>estimate of the function at design points.
</p>
</td></tr>
<tr><td><code>c</code></td>
<td>

<p>estimates of c.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>estimates of d.
</p>
</td></tr>
<tr><td><code>resi</code></td>
<td>

<p>vector of working residuals.
</p>
</td></tr>
<tr><td><code>varht</code></td>
<td>

<p>estimate of dispersion parameter.
</p>
</td></tr>
<tr><td><code>nlaht</code></td>
<td>

<p>the estimate of <code class="reqn">log10(nobs*lambda)</code>.
</p>
</td></tr>
<tr><td><code>limnla</code></td>
<td>

<p>searching range for nlaht. 
</p>
</td></tr>
<tr><td><code>score</code></td>
<td>

<p>the minimum GCV/GML/UBR score at the estimated smoothing parameter. When job&gt;0, it gives a vector of GCV/GML/UBR functions evaluated at regular grid points.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>equavilent degree of freedom.
</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>

<p>length-of-y, number of observations.
</p>
</td></tr>
<tr><td><code>nnull</code></td>
<td>

<p><code class="reqn">dim(H_0)</code>, number of bases.
</p>
</td></tr>
<tr><td><code>s</code>, <code>qraux</code>, <code>jpvt</code></td>
<td>

<p>QR decomposition of S=FR, as from Linpack &lsquo;dqrdc&rsquo;.
</p>
</td></tr>
<tr><td><code>q</code></td>
<td>

<p>first <code class="reqn">dim(H_0)</code> columns gives <code class="reqn">F^{T} Q F_{1}</code>, and its bottom-right corner gives tridiagonalization of <code class="reqn">F_{2}^{T} Q F_{2}</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Wang, Y. (1997). GRKPACK: Fitting Smoothing Spline ANOVA Models for Exponential Families. Communications in Statistics: Simulation and Computation, 24: 1037-1059.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsidr">dsidr</a></code>, <code><a href="#topic+dmudr">dmudr</a></code>, <code><a href="#topic+gdmudr">gdmudr</a></code>, <code><a href="#topic+ssr">ssr</a></code>
</p>

<hr>
<h2 id='hat.ssr'>
Extract the Hat Matrix from a ssr Object</h2><span id='topic+hat.ssr'></span>

<h3>Description</h3>

<p>Calculate the hat matrix for a <code>ssr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
hat.ssr(ssr.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hat.ssr_+3A_ssr.obj">ssr.obj</code></td>
<td>

<p>a fitted ssr object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hat matrix may be used for diagnosis. Note that the full name hat.ssr shoud be used since the function hat already exist.
</p>


<h3>Value</h3>

<p>returned is the hat (influence, smoother) matrix.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

 
<p>Eubank, R. L. (1984). The Hat Matrix for Smoothing Splines. Statistics and Probability Letters, 2:9-14.
</p>
<p>Eubank, R. L. (1985). Diagnostics for Smoothing Splines. Journal of the Royal Statistical Society B. 47: 332-341.
</p>
<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: library(MASS)
## Not run: fit1&lt;- ssr(accel~times, data=mcycle, scale=T, rk=cubic(times))
## Not run: h &lt;- hat.ssr(fit1)
</code></pre>

<hr>
<h2 id='horm.cort'>Hormone Measurements of Cortisol</h2><span id='topic+horm.cort'></span>

<h3>Description</h3>

<p>The <code>horm.cort</code> data frame has 425 rows and 4 columns of data representing measurement of cortisol on 36 individuals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(horm.cort)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>ID a vector of index indicating individuals on whom measures were made.
</p>
<p>time a numeric vector of time points of every 2 hours in 24 hours. The time is scaled into [0, 1].
</p>
<p>type a vector of character strings identifying the groups, &quot;normal&quot;, &quot;depressed&quot;, or &quot;cushing&quot;, which the individuals belong to.
</p>
<p>conc cortisol concentration measurements in <code class="reqn">log10</code> scale.
</p>


<h3>Details</h3>

<p>Blood samples were collected every 2 hours for 24 hours from three group of healthy normal volunteers and volunteers with depresession and suchsing syndrome. They were analyzed for parameters that measure hormones of the hypothalamic-pituitary axix. Human circadian thythm is one of the research objective. In this data set, only measurements of cortisol concetration were included.</p>


<h3>Source</h3>

<p>This data set was extracted from a stress study conducted in the medical center of the University of Michigan.
</p>


<h3>References</h3>

<p>Wang, Y. and Brown, M. B. (1996). A Flexible Model for Human Circadian Rhythms. Biometrics 52, 588-596.
</p>
<p>Yuedong Wang, Chunlei Ke and Morton B. Brown (2003), Shape Invariant Modelling of Circadian Rhythms with Random Effects and Smoothing Spline ANOVA Decompositions. Biometrics, 59:804-812.
</p>

<hr>
<h2 id='ident'>Scaling a Vector</h2><span id='topic+ident'></span>

<h3>Description</h3>

<p>Perform standarization of vector relative to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ident(x, y = x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ident_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame</p>
</td></tr>
<tr><td><code id="ident_+3A_y">y</code></td>
<td>
<p>an optional numeric vector, matrix or data frame. Default is x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Scale <code>y</code> based on <code>x</code> component by component. For example, if both are a matrix, 
<code class="reqn">y[,i]=(y[,]-min(x[,i]))/(max(x[,i])-min(x[,i]))</code>.
</p>


<h3>Value</h3>

<p>a scaled <code>y</code>.
</p>

<hr>
<h2 id='inc'>
Fit a Monotone Curve Using a Cubic Spline
</h2><span id='topic+inc'></span>

<h3>Description</h3>

<p>Return a spline fit of a increasing curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inc(y, x, spar = "v", limnla = c(-6, 0), grid = x, prec = 1e-06, maxit = 50, verbose = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inc_+3A_y">y</code></td>
<td>

<p>a vecetor, used as the response data
</p>
</td></tr>
<tr><td><code id="inc_+3A_x">x</code></td>
<td>

<p>a vector, used as the covariate. Assume an increasing relationshop of <code>y</code> on <code>x</code>
</p>
</td></tr>
<tr><td><code id="inc_+3A_spar">spar</code></td>
<td>

<p>a character string specifying a method for choosing the smoothing parameter. &quot;v&quot;, &quot;m&quot; and &quot;u&quot; represent 
GCV, GML and UBR respectively. Default is &quot;v&quot; for GCV</p>
</td></tr>
<tr><td><code id="inc_+3A_limnla">limnla</code></td>
<td>

<p>a vector of length one or two, specifying a search range for log10(n*lambda), where lambda is the smoothing 
parameter and n is the sample size. If it is a single value, the smoothing parameter will be fixed at this value. </p>
</td></tr>
<tr><td><code id="inc_+3A_grid">grid</code></td>
<td>

<p>a vector of <code>x</code> used to assess convergence. Default is <code>x</code>
</p>
</td></tr>
<tr><td><code id="inc_+3A_prec">prec</code></td>
<td>

<p>a numeric value used to assess convergence. Default is 1e-6
</p>
</td></tr>
<tr><td><code id="inc_+3A_maxit">maxit</code></td>
<td>

<p>an integer represeenting the maximum iterations. Default is 50.
</p>
</td></tr>
<tr><td><code id="inc_+3A_verbose">verbose</code></td>
<td>

<p>an optional logical value. If &lsquo;TRUE&rsquo;, detailed iteration results are displayed. Default is &quot;FALSE&quot; 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to fit a increasing fucntion to the data. The monotone function is expressed as integral of an unknown function that a cubic spline is used to estimate.
</p>


<h3>Value</h3>

<p>a split fit together with the convergence information
</p>


<h3>Author(s)</h3>

<p>Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a> and Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> </p>


<h3>See Also</h3>

<p><code>ssr</code>
</p>

<hr>
<h2 id='intervals.nnr'>
Calculate Predictions and Approximate Posterior Standard Deviations for Spline Estimates From a nnr Object
</h2><span id='topic+intervals.nnr'></span>

<h3>Description</h3>

<p>Approximate posterior standard deviations are calculated for the spline estimate of
nonparametric functions from a <code>nnr</code> object, based on which approximate Bayesian
confidence intervals may be constructed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nnr'
intervals(object,level=0.95, newdata=NULL, terms, pstd=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals.nnr_+3A_object">object</code></td>
<td>

<p>an object inheriting from class <code>nnr</code>, representing a 
nonlinear nonparametric regression model fit.
</p>
</td></tr>
<tr><td><code id="intervals.nnr_+3A_newdata">newdata</code></td>
<td>

<p>a data frame on which the fitted spline estimates are to be evaluated. 
Only those predictors, referred in <code>func</code> of <code>nnr</code> fitting, have to
be present. The variable names of the data frame should correspond 
to the function(s)' arguments appearing in the opion func=  of nnr.
Default is NULL, where predictions are made at the same values 
used to fit the object.
</p>
</td></tr>
<tr><td><code id="intervals.nnr_+3A_terms">terms</code></td>
<td>

<p>an optional named list of vectors or matrices containing 0's and 1's  collecting one or several combinations 
of the components of spline estimates in the fitted snr object. The length and names of the list shall match those of 
the unknown functions appearing in the 'snr' fit object. For the case of a single function, a vector of 0's 
and 1's can also be accepted. A value &quot;1&quot; at a particular position means that the component at 
that position is collected. Default is a vector of 1's, representing the overall fits of all unknown functions.  
</p>
</td></tr>
<tr><td><code id="intervals.nnr_+3A_pstd">pstd</code></td>
<td>

<p>an optional logic value.
If TRUE (the default), the posterior standard deviations are calculated. 
Orelse, only the predictions are calculated.
Computation required for posterior standard deviations could be intensive. 
</p>
</td></tr>
<tr><td><code id="intervals.nnr_+3A_level">level</code></td>
<td>
<p>a numeric value set as 0.95.</p>
</td></tr>
<tr><td><code id="intervals.nnr_+3A_...">...</code></td>
<td>
<p>other arguments, currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard deviation returned is based on approximate Bayesian confidence 
intervals as formulated in Ke and Wang (2002). 
</p>


<h3>Value</h3>

<p>an object of class <code>bCI</code> is returned, which is a list of length 2. 
Its first element is a matrix which contains predictions for 
combinations specified by <code>terms</code>, and second element is a matrix which contains 
corresponding posterior standard deviations. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Ke, C. and Wang, Y. (2002). Nonlinear Nonparametric Regression Models. Submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnr">nnr</a></code>, <code><a href="#topic+plot.bCI">plot.bCI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## fit a generalized varying coefficient models
data(Arosa)
Arosa$csmonth &lt;- (Arosa$month-0.5)/12
Arosa$csyear &lt;- (Arosa$year-1)/45
ozone.fit &lt;- nnr(thick~f1(csyear)+exp(f2(csyear))*f3(csmonth),
        func=list(f1(x)~list(~I(x-.5),cubic(x)), f2(x)~list(~I(x-.5)-1,cubic(x)),
        f3(x)~list(~sin(2*pi*x)+cos(2*pi*x)-1,lspline(x,type="sine0"))),
        data=Arosa[Arosa$year%%2==1,], spar="m", start=list(f1=mean(thick),f2=0,f3=sin(csmonth)),
	control=list(backfit=1))

x &lt;- seq(0,1,len=50)
u &lt;- seq(0,1,len=50)

## calculate Bayesian confidence limits for all components of all functions
p.ozone.fit &lt;- intervals(ozone.fit, newdata=list(csyear=x,csmonth=u),
                 terms=list(f1=matrix(c(1,1,1,1,1,0,0,0,1),nrow=3,byrow=TRUE),
	                    f2=matrix(c(1,1,1,0,0,1),nrow=3,byrow=TRUE),
                            f3=matrix(c(1,1,1,1,1,0,0,0,1),nrow=3,byrow=TRUE)))	
plot(p.ozone.fit, x.val=x)

## End(Not run)
</code></pre>

<hr>
<h2 id='intervals.slm'>
Calculate Predictions and Posterior Standard Deviations of Spline Estimates From a slm Object
</h2><span id='topic+intervals.slm'></span>

<h3>Description</h3>

<p>Provide a way  to calculate approximate posterior standard deviations and fitted 
values at any specified values for any combinations of elements of the spline 
estimate of nonparametric functions from a <code>slm</code> object, based on which 
approximate Bayesian confidence intervals may be constructed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
intervals(object, level=0.95, newdata=NULL, terms, pstd=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals.slm_+3A_object">object</code></td>
<td>

<p>an object inheriting from class &quot;slm&quot;, representing a semi-parametric nonlinear regression model fit.
</p>
</td></tr>
<tr><td><code id="intervals.slm_+3A_level">level</code></td>
<td>
<p>set as 0.95, unused currently</p>
</td></tr>
<tr><td><code id="intervals.slm_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame on which the fitted spline estimate is to be evaluated. 
</p>
</td></tr>
<tr><td><code id="intervals.slm_+3A_terms">terms</code></td>
<td>

<p>an optional vector of 0's and 1's collecting a combination of components, or a matrix of 0's and 1's 
collecting several combinations of components, in a fitted ssr object. All components include bases on 
the right side of <code class="reqn">\mbox{\textasciitilde}</code> in the formula and reproducing kernels in the rk list. Note that the first component 
is usually a constant function if it is not specifically excluded in the formula. A value &quot;1&quot; at a particular 
position means that the component at that position is collected. Default is a vector of 1's, 
representing the overall fit. 
</p>
</td></tr>
<tr><td><code id="intervals.slm_+3A_pstd">pstd</code></td>
<td>

<p>an optional logic value.
If TRUE (the default), the posterior standard deviations are calculated. 
Orelse, only the predictions are calculated.
Computation required for posterior standard deviations could be intensive. 
</p>
</td></tr>
<tr><td><code id="intervals.slm_+3A_...">...</code></td>
<td>
<p>other arguments, currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard deviation returned is based on approximate Bayesian confidence intervals as formulated
in Wang (1998). 
</p>


<h3>Value</h3>

<p>an object of class <code>bCI</code> is returned, which is a list of length 2. Its first element is a matrix which contains predictions for 
combinations specified by <code>terms</code>, and second element is a matrix which contains 
corresponding posterior standard deviations. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Wang, Y. (1998). Mixed-effects smoothing spline ANOVA. Journal of the Royal Statistical Society, Series B 60, 159-174.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slm">slm</a></code>, <code><a href="#topic+plot.bCI">plot.bCI</a></code>, <code><a href="#topic+predict.ssr">predict.ssr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dog)
# fit a SLM model with random effects for dogs
dog.fit&lt;-slm(y~group*time, rk=list(cubic(time), shrink1(group),
    rk.prod(kron(time-0.5),shrink1(group)),rk.prod(cubic(time), 
    shrink1(group))), random=list(dog=~1), data=dog)

intervals(dog.fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='intervals.snm'>
Calculate Predictions and Approximate Posterior Standard Deviations for Spline Estimate From a snm Object
</h2><span id='topic+intervals.snm'></span>

<h3>Description</h3>

<p>Provide a way  to calculate approximate posterior standard deviations and fitted 
values at any specified values for any combinations of elements of the spline 
estimate of nonparametric functions from a snm object, based on which 
approximate Bayesian confidence intervals may be constructed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snm'
intervals(object,level=0.95,newdata=NULL, terms, pstd=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals.snm_+3A_object">object</code></td>
<td>

<p>an object inheriting from class snm, representing a semi-parametric 
nonlinear mixed effects model fit.
</p>
</td></tr>
<tr><td><code id="intervals.snm_+3A_newdata">newdata</code></td>
<td>

<p>a data frame on which the fitted spline estimates are to be evaluated. 
Only those predictors, referred in 'func' of 'snm' fitting, have to
be present. The variable names of the data frame should correspond 
to the function(s)' arguments appearing in the opion func=  of snm.
Default is NULL, where predictions are made at the same values 
used to fit the object.
</p>
</td></tr>
<tr><td><code id="intervals.snm_+3A_terms">terms</code></td>
<td>

<p>an optional vector of 0's and 1's collecting a combination of 
components, or a matrix of 0's and 1's collecting several combinations 
of components of spline estimates in a fitted snm object. Note that 
in the cases of multiple functions, the order of all componets is 
collection of base functions for all functions followed by RK's. 
A value &quot;1&quot; at a particular position means that the component at 
that position is collected. Default is a vector of 1's, 
representing the overall fit. 
</p>
</td></tr>
<tr><td><code id="intervals.snm_+3A_pstd">pstd</code></td>
<td>

<p>an optional logic value. If TRUE (the default), approximate posterior 
standard deviations are calculated. Orelse, only the predictions 
are calculated. Computation required for posterior standard deviations 
could be intensive. 
</p>
</td></tr>
<tr><td><code id="intervals.snm_+3A_level">level</code></td>
<td>
<p>a numeric value set as 0.95.</p>
</td></tr>
<tr><td><code id="intervals.snm_+3A_...">...</code></td>
<td>
<p>other arguments, currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard deviation returned is based on approximate Bayesian 
confidence intervals as formulated in Ke and Wang (2001). 
</p>


<h3>Value</h3>

<p>an object of class <code>bCI</code> is returned, which is a list of length 2. 
Its first element is a matrix which contains predictions for 
combinations specified by &quot;terms&quot;, and second element is a matrix 
which contains corresponding posterior standard deviations. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a>.</p>


<h3>References</h3>

<p>Ke, C. and Wang, Y. (2001). Semi-parametric Nonlinear Mixed Effects 
Models and Their Applications. JASA 96:1272-1298.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snm">snm</a></code>, <code><a href="#topic+plot.bCI">plot.bCI</a></code>, <code><a href="#topic+predict.ssr">predict.ssr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(horm.cort)

## extract normal dubjects
cort.nor&lt;- horm.cort[horm.cort$type=="normal",]

## fit a self-modelling model with random effects
cort.fit&lt;- snm(conc~b1+exp(b2)*f(time-alogit(b3)), 
  func=f(u)~list(periodic(u)), fixed=list(b1~1), 
  random=pdDiag(b1+b2+b3~1), data=cort.nor, 
  groups= ~ID,start=mean(cort.nor$conc))

## note the variable name of newdata
intervals(cort.fit, newdata=data.frame(u=seq(0,1,len=50)))

## End(Not run)
</code></pre>

<hr>
<h2 id='intervals.snr'>
Calculate Predictions and Approximate Posterior Standard Deviations for Spline Estimates From a snr Object
</h2><span id='topic+intervals.snr'></span>

<h3>Description</h3>

<p>Approximate posterior standard deviations are calculated for the spline estimate of
nonparametric functions from a snr object, based on which approximate Bayesian
confidence intervals may be constructed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snr'
intervals(object, level=0.95,newdata=NULL, terms=list(), pstd=TRUE,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals.snr_+3A_object">object</code></td>
<td>

<p>an object inheriting from class 'snr', representing a 
semi-parametric nonlinear regression model fit.
</p>
</td></tr>
<tr><td><code id="intervals.snr_+3A_level">level</code></td>
<td>
<p>set as 0.95, unused currently</p>
</td></tr>
<tr><td><code id="intervals.snr_+3A_newdata">newdata</code></td>
<td>

<p>a data frame on which the fitted spline estimates are to be evaluated. 
Only those predictors, referred in 'func' of 'snr' fitting, have to
be present. The variable names of the data frame should correspond 
to the function(s)' arguments appearing in the opion func=  of snr.
Default is NULL, where predictions are made at the same values 
used to fit the object.
</p>
</td></tr>
<tr><td><code id="intervals.snr_+3A_terms">terms</code></td>
<td>

<p>an optional named list of vectors or matrices containing 0's and 1's  collecting one or several combinations 
of the components of spline estimates in the fitted snr object. The length and names of the list shall match those of 
the unknown functions appearing in the 'snr' fit object. For the case of a single function, a vector of 0's 
and 1's can also be accepted. A value &quot;1&quot; at a particular position means that the component at 
that position is collected. Default is a vector of 1's, representing the overall fits of all unknown functions. 
</p>
</td></tr>
<tr><td><code id="intervals.snr_+3A_pstd">pstd</code></td>
<td>

<p>an optional logic value.
If TRUE (the default), the posterior standard deviations are calculated. 
Orelse, only the predictions are calculated.
Computation required for posterior standard deviations could be intensive. 
</p>
</td></tr>
<tr><td><code id="intervals.snr_+3A_...">...</code></td>
<td>
<p>other arguments, currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard deviation returned is based on approximate Bayesian confidence 
intervals as formulated in Ke (2000). 
</p>


<h3>Value</h3>

<p>a named list of objects of class &quot;bCI&quot; is returned, each component of which is a list of length 2. 
Within each component, the first element is a matrix which contains predictions for 
combinations specified by &quot;terms&quot;, and the second element is a matrix which contains 
corresponding posterior standard deviations. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Ke, C. (2000). Semi-parametric Nonlinear Regression and Mixed Effects 
Models. PhD thesis, University of California, Santa Barbara.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snr">snr</a></code>, <code><a href="#topic+plot.bCI">plot.bCI</a></code>, <code><a href="#topic+predict.ssr">predict.ssr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(CO2)
options(contrasts=rep("contr.treatment", 2))  

## get start values  
co2.fit1 &lt;- nlme(uptake~exp(a1)*(1-exp(-exp(a2)*(conc-a3))), 
                 fixed=list(a1+a2~Type*Treatment,a3~1), 
                 random=a1~1, groups=~Plant, 
                 start=c(log(30),0,0,0,log(0.01),0,0,0,50),
                 data=CO2)

M &lt;- model.matrix(~Type*Treatment, data=CO2)[,-1]

## fit a SNR model
co2.fit2 &lt;- snr(uptake~exp(a1)*f(exp(a2)*(conc-a3)),
                func=f(u)~list(~I(1-exp(-u))-1,lspline(u, type="exp")),
                params=list(a1~M-1, a3~1, a2~Type*Treatment),
                start=list(params=co2.fit1$coe$fixed[c(2:4,9,5:8)]), data=CO2)

p.co2.fit2&lt;- intervals(co2.fit2, newdata=data.frame(u=seq(0,10,len=50)))

## End(Not run)
</code></pre>

<hr>
<h2 id='kron'>Calculate reproducing kernels for one-dimensional space</h2><span id='topic+kron'></span>

<h3>Description</h3>

<p>Return a matrix evaluating reproducing kernels for the one-dimensional space usually spanned by a vector</p>


<h3>Usage</h3>

<pre><code class='language-R'> kron(x,y=x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kron_+3A_x">x</code></td>
<td>
<p>a vector or a list of numerical values which spans the one-dimensional space.</p>
</td></tr>
<tr><td><code id="kron_+3A_y">y</code></td>
<td>
<p>a vector or a list of numerical values. Default is x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the numbers of row and column equal to the length of x and y respectively. 
The [i, j] element is the reproducing kernel evaluated at the ith element of x and jth element of y.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+kronecker">kronecker</a></code>,<code><a href="#topic+ssr">ssr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;-runif(10)
kron(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='lspline'>
Calculate Reproducing Kernels for Some L-splines
</h2><span id='topic+lspline'></span>

<h3>Description</h3>

<p>Return a matrix evaluating reproducing kernels for some L-splines at observed points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lspline(x,y=x, type="exp", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lspline_+3A_x">x</code></td>
<td>

<p>a numeric vector on which reproducing kerenls are evaluated.
</p>
</td></tr>
<tr><td><code id="lspline_+3A_y">y</code></td>
<td>

<p>an optional vector, specifying the second argument of reproducing kernels. Default is <code>x</code>.
</p>
</td></tr>
<tr><td><code id="lspline_+3A_type">type</code></td>
<td>

<p>a string indicating the type of L-splines. Available options 
are &quot;exp&quot;, &quot;logit&quot;,&quot;sine&quot;, &quot;sine1&quot;, and &quot;linSinCos&quot;. Default is &quot;exp&quot;.
</p>
</td></tr>
<tr><td><code id="lspline_+3A_...">...</code></td>
<td>

<p>other arguments needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote L as the differential oprator, <code class="reqn">H_0</code> as the null (kernel) space. The available kernels
correspond to the following L:
</p>

<ul>
<li><p> exp: <code class="reqn">L=rD+D^2</code>, <code class="reqn">H_0=span\{1,exp(-rx)\}</code>. <code class="reqn">r&gt;0</code>, default to be 1;<br />
</p>
</li>
<li><p> logit: <code class="reqn">L=D-1/(1+e^t)</code>, <code class="reqn">H_0=span\{e^t/(1+e^t)\}</code>;<br />
</p>
</li>
<li><p> sine0: <code class="reqn">L=D^2+(2\pi)^2</code>, <code class="reqn">H_0=span\{sin(2\pi x),cos(2\pi x)\}</code>;<br />
</p>
</li>
<li><p> sine1: <code class="reqn">L=D(D^2+(2\pi)^2)</code>, <code class="reqn">H_0=span\{1, sin(2\pi x),cos(2\pi x)\}</code>;<br />
</p>
</li>
<li><p> linSinCos: <code class="reqn">L=D^4+D^2</code>, <code class="reqn">H_0=spac\{1, x, sin(x), cos(x)\}</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>a matrix with the numbers of row and column equal to the lengths of x and y respectively.
The [i, j] element is the reproducing kernel evaluated at (x[i], y[j]). 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Heckman, N and Ramsay, J. O. (2000). Penalised regression with model-based penalties.
To appear in Canadian Journal of Statisitcs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;- seq(0,1, len=20)
lspline(x, type="exp", r=1.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='nnr'>
Nonlinear Non-parametric Regression
</h2><span id='topic+nnr'></span>

<h3>Description</h3>

<p>Fit a nonlinear nonparametric regression models with spline smoothing based on extended Gauss-Newton/Newton-Raphson and backfitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnr(formula, func, spar="v", data=list(),
    start=list(),verbose=FALSE,  control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnr_+3A_formula">formula</code></td>
<td>

<p>a model formula, with the response on the left of a <code class="reqn">\mbox{\textasciitilde}</code> operator and on the right an expression representing 
the mean function with a nonparametric function appearing with a symbol, e.g. f. 
</p>
</td></tr>
<tr><td><code id="nnr_+3A_func">func</code></td>
<td>

<p>a required formula specifying the spline components necessary to estimate the non-parametric function. 
On the left of a <code class="reqn">\mbox{\textasciitilde}</code> operator is the unknow function symbol as well as its arguments, while the right side 
is a list of two components, an optional <code>nb</code> and a required <code>rk</code>. <code>nb</code> and <code>rk</code> are 
similar to <code>formula</code> and <code>rk</code> in <code>ssr</code>. A missing <code>nb</code> denotes an empty null space.   
</p>
</td></tr>
<tr><td><code id="nnr_+3A_spar">spar</code></td>
<td>

<p>a character string specifying a method for choosing the smoothing parameter. &quot;v&quot;, &quot;m&quot; and &quot;u&quot; represent  GCV, GML and
UBR respectively. Default is &quot;v&quot; for GCV.
</p>
</td></tr>
<tr><td><code id="nnr_+3A_data">data</code></td>
<td>

<p>an optional data frame.
</p>
</td></tr>
<tr><td><code id="nnr_+3A_start">start</code></td>
<td>

<p>a list of vectors or expressions which input inital values for the unknown functions. If expressions,
the argument(s) inside should be the same as in <code>func</code>. The length of <code>start</code> should be the same as 
the number of unknown functions. If named, the names of the list should match those in &quot;func&quot;. If not named, the order 
of the list is taken as that appearing in &quot;func&quot;.
</p>
</td></tr>
<tr><td><code id="nnr_+3A_verbose">verbose</code></td>
<td>

<p>an optional logical numerical value. If <code>TRUE</code>, information on
the evolution of the iterative algorithm is printed. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="nnr_+3A_control">control</code></td>
<td>

<p>an optional list of control values to be used.  See nnr.control for details.
</p>
</td></tr></table>


<h3>Details</h3>

<p>A nonlinear nonparametric model is fitted using the algorithms developed in Ke and Wang (2002).
</p>


<h3>Value</h3>

<p>an object of class <code>nnr</code> is returned, containing fitted values, fitted function values as well as 
other information used to assess the estimate.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a>.</p>


<h3>References</h3>

<p>Ke, C. and Wang, Y. (2002). Nonlinear Nonparametric Regression Models. Submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnr.control">nnr.control</a></code>, <code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+print.nnr">print.nnr</a></code>, <code><a href="#topic+summary.nnr">summary.nnr</a></code>, <code><a href="#topic+intervals.nnr">intervals.nnr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;- 1:100/100
y&lt;- exp(sin(2*pi*x))+0.3*rnorm(x)
fit&lt;- nnr(y~exp(f(x)), func=list(f(u)~list(~u, cubic(u))), start=list(0))

## fit a generalized varying coefficient models
data(Arosa)
Arosa$csmonth &lt;- (Arosa$month-0.5)/12
Arosa$csyear &lt;- (Arosa$year-1)/45
ozone.vc.fit &lt;- nnr(thick~f1(csyear)+exp(f2(csyear))*f3(csmonth),
        func=list(f1(x)~list(~I(x-.5),cubic(x)), f2(x)~list(~I(x-.5)-1,cubic(x)),
        f3(x)~list(~sin(2*pi*x)+cos(2*pi*x)-1,lspline(x,type="sine0"))),
        data=Arosa[Arosa$year%%2==1,], spar="m", start=list(f1=mean(thick),f2=0,f3=sin(csmonth)),
        control=list(backfit=1))

## End(Not run)
</code></pre>

<hr>
<h2 id='nnr.control'>Set Control Parameters for nnr</h2><span id='topic+nnr.control'></span>

<h3>Description</h3>

<p>Control parameters supplied in the function call replace 
the defaults to be used in calling <code>nnr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnr.control(job = -1, tol = 0, max.iter = 50, init = 0, limnla = c(-10, 
    0), varht = NULL, theta = NULL, prec = 1e-06, maxit = 30, 
    method = "NR", increment = 1e-04, backfit = 5, converg = "coef", 
    toler = 0.001)   
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnr.control_+3A_job">job</code></td>
<td>

<p>an integer representing the optimization method used to find the smoothing parameter. 
The options are job=-1: golden-section search on (limnla(1), limnla(2)); 
job=0: golden-section search with interval specified automatically; 
job &gt;0: regular grid search on  [limnla(1), limnla(2)] with the number of grids = job + 1. 
Default is -1. 
</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_tol">tol</code></td>
<td>

<p>tolerance for truncation used in &lsquo;dsidr&rsquo;. Default is 0.0, which sets to square of machine precision.
</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations allowed for the Gauss-Newton/Newton-Raphson iteration.</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_init">init</code></td>
<td>

<p>an integer of 0 or 1 indicating if initial values are provided for theta. If init=1, initial values are provided using theta. Default is 0.
</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_limnla">limnla</code></td>
<td>

<p>a vector of length 2, specifying a search range for the  n times smoothing parameter on log10 scale. Default is (-10, 0).
</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_varht">varht</code></td>
<td>

<p>needed only when vmu=&quot;u&quot;, which gives the fixed variance in calculation of the UBR function. Default is NULL.
</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_theta">theta</code></td>
<td>

<p>If &lsquo;init=1&rsquo;, theta includes intial values for smoothing parameters. Default is NULL.
</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_prec">prec</code></td>
<td>

<p>precision requested for the minimum score value, where precision is the weaker of the absolute and relative precisions. Default is 1e-06.
</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations allowed. Default is 30.</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_method">method</code></td>
<td>
<p>a character string specifying a method for iterations, &quot;GN&quot; for Gauss-Newton and &quot;NR&quot; for Newton-Raphson. Default is &quot;GN&quot;.</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_increment">increment</code></td>
<td>
<p>specifies a small value as increment to calcuate derivatives. Default is 1e-04.</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_backfit">backfit</code></td>
<td>
<p> an integer representing the number of backfitting iterations for multiple functions. Default is 5.</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_converg">converg</code></td>
<td>
<p>	an optional character, with possible values &quot;coef&quot; and &quot;ortho&quot;, specifying the convergence 
criterion to be used. &quot;coef&quot; uses the change of estimate of parameters and functions to
assess convergence, and &quot;ortho&quot; uses a criterion similar to the relative offset used in nls. Default is &quot;coef&quot;.
</p>
</td></tr>
<tr><td><code id="nnr.control_+3A_toler">toler</code></td>
<td>
<p>tolerance for convergence of the algorithm. Default is 0.001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returned is a list includes all re-seted control parameters.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nnr">nnr</a></code>, <code><a href="#topic+dsidr">dsidr</a></code>,<code><a href="#topic+dmudr">dmudr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## use Newton-Raphson 
nnr.control(method="NR")

## End(Not run)
</code></pre>

<hr>
<h2 id='paramecium'>Growth of paramecium caudatum population</h2><span id='topic+paramecium'></span>

<h3>Description</h3>

<p>The 'paramecium' data frame has 25 rows and 2 columns of data from an experiment that grow paramecium caudatum  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(paramecium)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>day a numeric vector of days since the start of the experiment
</p>
<p>density a numeric vector of mean number of individuals in 0.5 ml of medium of four different cultures started simultaneously 
</p>


<h3>Source</h3>

<p>Gause, G.F. (1934). The Struggle for Existence. Baltimore, MD: Williams &amp; Wilkins.
</p>


<h3>references</h3>

<p>Neal, D. (2004). Introduction to Population Biology. Cambridge University Press.
</p>

<hr>
<h2 id='periodic'>Calculate Reproducing Kernels for Periodic Polynomial Splines with Period 1</h2><span id='topic+periodic'></span>

<h3>Description</h3>

<p>Return a matrix evaluating reproducing kernels for periodic polynomial splines at observed points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodic(s, t=s, order=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodic_+3A_s">s</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="periodic_+3A_t">t</code></td>
<td>
<p>an optional vector. Default is the same as s.</p>
</td></tr>
<tr><td><code id="periodic_+3A_order">order</code></td>
<td>
<p>an optional integer sepcifying the order of the polynomial spline. Default is 2 for the 
periodic cubic spline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general formula of the reproducing kernel is sum of an infinite series, which is approximated
by taking the first 50 terms. For the case of order=2, the close form is available and used.</p>


<h3>Value</h3>

<p>a matrix with the numbers of row and column equal to the lengths of s and t respectively.
The [i, j] element is the reproducing kernel evaluated at (s[i], t[j]). </p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Gu, C. (2001). Smoothing Spline ANOVA Modes. Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cubic">cubic</a></code>, <code><a href="#topic+lspline">lspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;- seq(0, 1, len=100)
periodic(x, order=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.bCI'>
Bayesian Confidence Interval Plot of a Smoothing Spline Fit
</h2><span id='topic+plot.bCI'></span>

<h3>Description</h3>

<p>Create trellis plots of a nonparametric function fit together
with its (approximate) 95% Bayesian confidence intervals from 
a ssr/slm/snr/snm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bCI'
plot(x, x.val=NULL, type.name=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bCI_+3A_x">x</code></td>
<td>

<p>an object of class &quot;bCI&quot; containing point evaluation of the unknown
function and/or corresponding posterior standard devaitions.
</p>
</td></tr>
<tr><td><code id="plot.bCI_+3A_x.val">x.val</code></td>
<td>

<p>an optional vector representing values of argument based on which the 
function is to evaluate.
</p>
</td></tr>
<tr><td><code id="plot.bCI_+3A_type.name">type.name</code></td>
<td>

<p>an optional character vector specifying the names of fits.
</p>
</td></tr>
<tr><td><code id="plot.bCI_+3A_...">...</code></td>
<td>

<p>options suitable for xyplot.
</p>
</td></tr></table>


<h3>Details</h3>

<p>This function is to visualize a spline fit by use of trellis graphic facility 
with Bayesian confidence intervals superposed. Multi-panel plots, based on xyplot,
are suitable for SS ANOVA decomposition of a spline estimate. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.ssr">predict.ssr</a></code>, <code><a href="#topic+intervals.slm">intervals.slm</a></code>, 
<code><a href="#topic+intervals.snr">intervals.snr</a></code>, <code><a href="#topic+intervals.snm">intervals.snm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;- seq(0, 1, len=100)
y&lt;- 2*sin(2*pi*x)+rnorm(x)*0.5

fit&lt;- ssr(y~x, cubic(x))
p.fit&lt;- predict(fit)
plot(p.fit)
plot(p.fit,type.name="fit")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.ssr'>Generate Diagnostic Plots for a ssr Object
</h2><span id='topic+plot.ssr'></span>

<h3>Description</h3>

<p>Creates a set of plots suitable  for  assessing  a  fitted smoothing spline model of class <code>ssr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssr'
plot(x, ask=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ssr_+3A_x">x</code></td>
<td>

<p>a <code>ssr</code> object.
</p>
</td></tr>
<tr><td><code id="plot.ssr_+3A_ask">ask</code></td>
<td>

<p>if TRUE, plot.ssr operates in interactive mode.
</p>
</td></tr>
<tr><td><code id="plot.ssr_+3A_...">...</code></td>
<td>

<p>Other options used for plot, currently inactive.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the  generic  function  plot for  class <code>ssr</code>.  
It can be invoked by calling plot for an object of the appropriate class, 
or  directly  by  calling plot.ssr regardless of the class of the object.
</p>
<p>An appropriate x-y plot is produced to display  diagnostic plots.  These can be one or all of the following choices:
</p>

<ul>
<li><p> Estimate of function with CIs 
</p>
</li>
<li><p> Residuals against Fitted values
</p>
</li>
<li><p> Response against Fitted values
</p>
</li>
<li><p> Normal QQplot of Residuals
</p>
</li></ul>

<p>The first plot of estimate of function with CIs is only useful for univariate smoothing spline fits.      
</p>
<p>When ask=TRUE, rather than produce  each  plot  sequentially,  plot.ssr  displays a menu listing all the plots that can be produced. If the menu is not desired but a  pause  between plots  is  still  wanted  one  must  set par(ask=TRUE) before
invoking this command with argument ask=FALSE.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code>plot</code>, <code>ssr</code>, <code>predict.ssr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: library(MASS)
## Not run: fit1&lt;- ssr(accel~times, data=mcycle, scale=TRUE, rk=cubic(times))
## Not run: plot(fit1,ask=TRUE)
</code></pre>

<hr>
<h2 id='Polynomial'>
Calculate Reproducing Kernels for Polynomial Splines on [0, 1]
</h2><span id='topic+linear'></span><span id='topic+cubic'></span><span id='topic+quintic'></span><span id='topic+septic'></span>

<h3>Description</h3>

<p>Return a matrix evaluating reproducing kernels for polynomial splines at observed points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear(s, t=s)
cubic(s, t=s)
quintic(s, t=s)
septic(s, t=s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Polynomial_+3A_s">s</code></td>
<td>

<p>a vector of values in [0, 1], at which the kernels are evaluated.
</p>
</td></tr>
<tr><td><code id="Polynomial_+3A_t">t</code></td>
<td>

<p>an optional vector in [0, 1]. Default is the same as s.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reproducing kernels implemented in these functions are based on Bernoulli functions 
with domain [0, 1].
</p>


<h3>Value</h3>

<p>a matrix with the numbers of row and column equal to the lengths of s and t respectively.
The [i, j] element is the reproducing kernel of linear, cubic, quintic, or septic spline 
evaluated at (s[i], t[j]). 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@ucsb.edu">yuedong@ucsb.edu</a></p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+linear2">linear2</a></code>, <code><a href="#topic+cubic2">cubic2</a></code>, 
<code><a href="#topic+quintic2">quintic2</a></code>, <code><a href="#topic+septic2">septic2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;-seq(0, 1, len=10)
cubic(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='Polynomial2'>
Calculate Reproducing Kernels for Polynomial Splines on [0, T]
</h2><span id='topic+linear2'></span><span id='topic+cubic2'></span><span id='topic+quintic2'></span><span id='topic+septic2'></span>

<h3>Description</h3>

<p>Return a matrix evaluating reproducing kernels for polynomial splines at observed points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear2(s, t=s)
cubic2(s, t=s)
quintic2(s, t=s)
septic2(s, t=s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Polynomial2_+3A_s">s</code></td>
<td>

<p>a vector of non-negative values, at which the kernels are evaluated.
</p>
</td></tr>
<tr><td><code id="Polynomial2_+3A_t">t</code></td>
<td>

<p>an optional non-negative vector. Default is the same as s.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reproducing kernels implemented in these functions are based on Green functions. The domain is
[0, T], where T is a given positive number.
</p>


<h3>Value</h3>

<p>a matrix with the numbers of row and column equal to the length of s and t respectively.
The [i, j] element is the reproducing kernel of linear, cubic, quintic, or septic spline 
evaluated at (s[i], t[j]). 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+linear">linear</a></code>, <code><a href="#topic+cubic">cubic</a></code>, 
<code><a href="#topic+quintic">quintic</a></code>, <code><a href="#topic+septic">septic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;- seq(0, 5, len=10)
linear2(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.slm'>
Predict Method for Semiparametric Linear Mixed Effects Model Fits 
</h2><span id='topic+predict.slm'></span>

<h3>Description</h3>

<p>Predicted Values on different levels of random effects with the spline fit
as part of fixed effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
predict(object, newdata=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.slm_+3A_object">object</code></td>
<td>

<p>an object inheriting from class <code>slm</code>, representing a semi-parametric linear
mixed effects model fit.
</p>
</td></tr>
<tr><td><code id="predict.slm_+3A_newdata">newdata</code></td>
<td>

<p>a data frame containing the values at which predictions are required.
Only those predictors, referred to in the right side of the formula in
the object, need to be present by name in newdata. Default is NULL, where 
predictions are made at the same values used to  compute the object. 
</p>
</td></tr>
<tr><td><code id="predict.slm_+3A_...">...</code></td>
<td>
<p>other arguments, but currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returned is a data.frame with  columns given by the predictions at different levels
and the grouping factors. Note that the smooth part of the spline fit is
regarded as fixed.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a>.</p>


<h3>References</h3>

<p>Wang, Y. (1998) Mixed Effects Smoothing Spline ANOVA. JRSS, Series B, 
60:159&ndash;174.
</p>
<p>Pinherio, J. C. and Bates, D. M. (2000) Mixed-effects Models in S and S-Plus. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slm">slm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dog)

dog.fit&lt;-slm(y~group*time, rk=list(cubic(time), shrink1(group),
    rk.prod(kron(time-0.5),shrink1(group)),rk.prod(cubic(time), 
    shrink1(group))), random=list(dog=~1), data=dog)

predict(dog.fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.snm'>
Predictions from a Semiparametric Nonlinear Mixed Effects Model Fit
</h2><span id='topic+predict.snm'></span>

<h3>Description</h3>

<p>The predictions are obtained on a semiparametric nonlinear mixed effects model object 
by replacing the unknown functuons and the unknown parameters with their estimates. 
Of note, only a population level of predictions is available. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snm'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.snm_+3A_object">object</code></td>
<td>

<p>a fitted <code>snm</code> object.
</p>
</td></tr>
<tr><td><code id="predict.snm_+3A_newdata">newdata</code></td>
<td>

<p>a data frame containing the values at which predictions are required. 
Default are data used to fit the object.
</p>
</td></tr>
<tr><td><code id="predict.snm_+3A_...">...</code></td>
<td>
<p>other arguments, but currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function predict for class <code>snm</code>. 
</p>


<h3>Value</h3>

<p>a vector of prediction values, obtained by evaluating the model in the frame <code>newdata</code>
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Ke, C. and Wang, Y. (2001). Semi-parametric Nonlinear Mixed Effects Models and
Their Applications. JASA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snm">snm</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>
</p>

<hr>
<h2 id='predict.snr'>
Predict Method from a Semiparametric Nonlinear Regression Model Fit
</h2><span id='topic+predict.snr'></span>

<h3>Description</h3>

<p>The predictions on a semiparametric nonlinear regression model object are obtained by 
substituting the unknwon functions together with unknown parameters with their estimates 
and evaluating the regression functional based on provided or default covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snr'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.snr_+3A_object">object</code></td>
<td>

<p>a fitted <code>snr</code> object.
</p>
</td></tr>
<tr><td><code id="predict.snr_+3A_newdata">newdata</code></td>
<td>

<p>a data frame containing the values at which predictions are required. 
Default are NULL, where data used to produce the fit are to be taken.
</p>
</td></tr>
<tr><td><code id="predict.snr_+3A_...">...</code></td>
<td>
<p>other arguments, but currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function predict for class <code>snr</code> 
</p>


<h3>Value</h3>

<p>a vector of prediction values, obtained by evaluating the model in the frame <code>newdata</code>.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Ke, C. (2000). Semi-parametric Nonlinear Regression and Mixed Effects 
Models. PhD thesis, University of California, Santa Barbara.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snr">snr</a></code>
</p>

<hr>
<h2 id='predict.ssr'> 
Calculate Predictions and Posterior Standard Deviations for a ssr Object 
</h2><span id='topic+predict.ssr'></span>

<h3>Description</h3>

 
<p>Provide a way to calculate predictions at any specified values for any combinations of elements in the fitted model. Posterior standard deviations may be used to construct Bayesian confidence intervals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'ssr'
predict(object, newdata=NULL, terms, pstd=TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="predict.ssr_+3A_object">object</code></td>
<td>

<p>a fitted <code>ssr</code> object. 
</p>
</td></tr>
<tr><td><code id="predict.ssr_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame containing the values at which predictions are required. Default is NULL, where predictions are made at the same values used to  compute the object. Note that if scale=T, the newdata is on the original scale before transformation. 
</p>
</td></tr>
<tr><td><code id="predict.ssr_+3A_terms">terms</code></td>
<td>

<p>an optional vector of 0's and 1's collecting a combination of components, or a matrix of 0's and 1's collecting several combinations of components, in a fitted ssr object. All components include bases on the right side of <code class="reqn">\mbox{\textasciitilde}</code> in the formula and reproducing kernels in the rk list. Note that the first component is usually a constant function if it is not specifically excluded in the formula. A value &quot;1&quot; at a particular position means that the component at that position is collected. Default is a vector of 1's, representing the overall fit. 
</p>
</td></tr>
<tr><td><code id="predict.ssr_+3A_pstd">pstd</code></td>
<td>

<p>an optional logic value. If TRUE (the default), the posterior standard deviations are calculated. Otherwise, only the predictions are calculated. Computation required for posterior standard deviations could be intensive. 
</p>
</td></tr>
<tr><td><code id="predict.ssr_+3A_...">...</code></td>
<td>
<p>other arguments, but currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function predict for class <code>ssr</code>. 
It can be used to construct Bayesian confidence intervals for any combinations 
of components in the fitted model. 
</p>


<h3>Value</h3>

 
<p>an object of class <code>bCI</code> is returned, which is a list of length 2. Its first element is a matrix which contains predictions for combinations specified by <code>terms</code>, and second element is a matrix which contains corresponding posterior standard deviations. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a>.</p>


<h3>References</h3>

 
<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+plot.bCI">plot.bCI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(acid)

# tp.pseudo calculates the pseudo kernel
acid.fit&lt;- ssr( ph ~ t1 + x1 + x2, rk = list(tp.pseudo(t1), 
       tp.pseudo(list(x1, x2))), spar = "m", data=acid)

# extract the main effect of t1 
grid &lt;- seq(min(acid$t1),max(acid$t1),length=100)
p &lt;- predict(acid.fit,data.frame(t1=grid,x1=0,x2=0),
     terms=c(0,1,0,0,1,0))

# extract the main effect of (x1,x2) 
grid &lt;- expand.grid(x1=seq(min(acid$x1),max(acid$x1),length=20),
     x2=seq(min(acid$x2),max(acid$x2),length=20))
p &lt;- predict(acid.fit,data.frame(t1=0,x1=grid$x1,x2=grid$x2),
     terms=c(0,0,1,1,0,1),pstd=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.nnr'>
Print Values
</h2><span id='topic+print.nnr'></span>

<h3>Description</h3>

<p>Print the arguments of a 'nnr' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nnr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nnr_+3A_x">x</code></td>
<td>
<p>a <code>nnr</code> object</p>
</td></tr>
<tr><td><code id="print.nnr_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function <code>print</code>  for  objects
inheriting from class <code>nnr</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nnr">nnr</a></code>
</p>

<hr>
<h2 id='print.slm'>
Print Values
</h2><span id='topic+print.slm'></span>

<h3>Description</h3>

<p>Print the arguments of a <code>slm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.slm_+3A_x">x</code></td>
<td>
<p>a <code>slm</code> object</p>
</td></tr>
<tr><td><code id="print.slm_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function  <code>print</code>  for  objects
inheriting from class <code>slm</code>.  
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+slm">slm</a></code>
</p>

<hr>
<h2 id='print.snm'>
Print Values
</h2><span id='topic+print.snm'></span>

<h3>Description</h3>

<p>Print the arguments of a 'snm' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.snm_+3A_x">x</code></td>
<td>
<p> a <code>snm</code> object</p>
</td></tr>
<tr><td><code id="print.snm_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function <code>print</code>  for  objects
inheriting from class &lsquo;snm&rsquo;. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+slm">slm</a></code>, <code><a href="base.html#topic+print">print</a></code>
</p>

<hr>
<h2 id='print.snr'>
Print Values
</h2><span id='topic+print.snr'></span>

<h3>Description</h3>

<p>Print the arguments of a <code>snr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.snr_+3A_x">x</code></td>
<td>
<p> a <code>snr</code> object</p>
</td></tr>
<tr><td><code id="print.snr_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function  <code>print</code>  for  objects
inheriting from class <code>snr</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+snr">snr</a></code>
</p>

<hr>
<h2 id='print.ssr'>
Print Values
</h2><span id='topic+print.ssr'></span>

<h3>Description</h3>

<p>Print the arguments of a <code>ssr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ssr_+3A_x">x</code></td>
<td>
<p>a <code>ssr</code> object</p>
</td></tr>
<tr><td><code id="print.ssr_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function <code>print</code>  for  objects
inheriting from class <code>ssr</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>
</p>

<hr>
<h2 id='print.summary.nnr'>Print Vales</h2><span id='topic+print.summary.nnr'></span>

<h3>Description</h3>

<p>Print the arguments of a <code>summary.nnr</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.nnr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.nnr_+3A_x">x</code></td>
<td>
<p> an object of class <code>summary.nnr</code></p>
</td></tr>
<tr><td><code id="print.summary.nnr_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function <code>print</code>  for  objects
inheriting from class <code>summary.nnr</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nnr">nnr</a></code>, <code><a href="#topic+summary.nnr">summary.nnr</a></code>
</p>

<hr>
<h2 id='print.summary.slm'>Print Values </h2><span id='topic+print.summary.slm'></span>

<h3>Description</h3>

<p>Print the arguments of a <code>summary.slm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.slm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.slm_+3A_x">x</code></td>
<td>
<p> an object of class <code>summary.slm</code></p>
</td></tr>
<tr><td><code id="print.summary.slm_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function <code>print</code>  for  objects
inheriting from class <code>summary.slm</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+slm">slm</a></code>, <code><a href="#topic+summary.slm">summary.slm</a></code>
</p>

<hr>
<h2 id='print.summary.snm'>Print Values </h2><span id='topic+print.summary.snm'></span>

<h3>Description</h3>

<p>Print the arguments of a <code>summary.snm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.snm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.snm_+3A_x">x</code></td>
<td>
<p> an object of class <code>summary.snm</code></p>
</td></tr>
<tr><td><code id="print.summary.snm_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function <code>print</code>  for  objects
inheriting from class <code>summary.snm</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+snm">snm</a></code>, <code><a href="#topic+summary.snm">summary.snm</a></code>
</p>

<hr>
<h2 id='print.summary.snr'>Print Values </h2><span id='topic+print.summary.snr'></span>

<h3>Description</h3>

<p>Print the arguments of a <code>summary.snr</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.snr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.snr_+3A_x">x</code></td>
<td>
<p> an object of class <code>summary.snr</code></p>
</td></tr>
<tr><td><code id="print.summary.snr_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function <code>print</code>  for  objects
inheriting from class <code>summary.snr</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+snr">snr</a></code>, <code><a href="#topic+summary.snr">summary.snr</a></code>
</p>

<hr>
<h2 id='print.summary.ssr'>Print Values </h2><span id='topic+print.summary.ssr'></span>

<h3>Description</h3>

<p>Print the arguments of a <code>summary.ssr</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ssr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ssr_+3A_x">x</code></td>
<td>
<p> an object of class <code>summary.ssr</code></p>
</td></tr>
<tr><td><code id="print.summary.ssr_+3A_...">...</code></td>
<td>
<p>unused argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for  the  function <code>print</code>  for  objects
inheriting from class <code>summary.ssr</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+summary.ssr">summary.ssr</a></code>
</p>

<hr>
<h2 id='rk.prod'>
Calculate product of reproducing kernels
</h2><span id='topic+rk.prod'></span>

<h3>Description</h3>

<p>Return a matix as product of reproducing kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rk.prod(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rk.prod_+3A_x">x</code></td>
<td>

<p>a matrix evaluating a reproducing kernel, or a vector.
</p>
</td></tr>
<tr><td><code id="rk.prod_+3A_...">...</code></td>
<td>

<p>optional lists of matrices evaluating reproducing kernels or vectors. All matrics
must have the same dimensions. All vectors must have the same length. The length of
each vector must equal to the column  and row numbers of each matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The product of reproducing kernels is agian a reproducing kernel. In SS ANOVA, product
of reproduing kernels is often used to model interaction spline terms.
</p>


<h3>Value</h3>

<p>a matrix as the product of reproducing kernels. If one argument is a vector, a <code>kron</code>
kernel is constructed first.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Gu, C. and Wahba, G. (1993a). Smoothing Spline ANOVA with component-wise Bayesian confidence intervals.
Journal of Computational and Graphical Statistics 55, 353&ndash;368.
</p>
<p>Gu, C. and Wahba, G. (1993b). Semiparametric analysis of variance with tensor product thin plate
splines. JRSS B 55, 353&ndash;368. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kron">kron</a></code>, <code><a href="#topic+ssr">ssr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x1&lt;- 1:10/10
x2&lt;- runif(10)
rk.prod(cubic(x1), periodic(x2))

## End(Not run)
</code></pre>

<hr>
<h2 id='seizure'>IEEG segments from a seizure patient</h2><span id='topic+seizure'></span>

<h3>Description</h3>

<p>The 'seizure' data frame has 60,000 rows and 3 columns of data from an IEEG time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seizure)
</code></pre>


<h3>Details</h3>

<p>The baseline segment contains 5-minute IEEG signal
extracted at least four hours before the seizure's onset.
The preseizure segment contains 5-minute IEEG signal
right before a seizure's clinical onset. The sampling rate 
of the IEEG signal is 200 observations per second.
Therefore there are 60,000 time points in each segment.
</p>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>t a numeric vector of the observation number
</p>
<p>base a numeric vector of the baseline segment
</p>
<p>preseizure a numeric vector of the segment right before a seizure
</p>


<h3>Source</h3>

<p>D'Alessandro, M., Vachtsevanos, G., Esteller, R., Echauz, J. 
and Litt, B. (2001). A Generic Approach to Selecting the 
Optimal Feature for Epileptic Seizure Prediction.
IEEE International Meeting of the Engineering in Medicine and Biology Society.
</p>


<h3>references</h3>

<p>Qin, L. and Wang, Y. (2008), Nonparametric Spectral Analysis
With Applications to Seizure Characterization Using EEG Time Series. Annals of Applied Statistics 2, 1432-1451.
</p>

<hr>
<h2 id='Shrinkage'>Calculate reproducing kernels for Stein shrinkage estimate</h2><span id='topic+shrink0'></span><span id='topic+shrink1'></span>

<h3>Description</h3>

<p>Return a matrix evaluating reproducing kernels for the discrete shrinkage towards zero or the mean estimate</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink0(x, y=x)
shrink1(x, y=x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Shrinkage_+3A_x">x</code></td>
<td>
<p>a vector of numerical values or factor indicating different levels.</p>
</td></tr>
<tr><td><code id="Shrinkage_+3A_y">y</code></td>
<td>
<p>a vector of numerical values or factor indicating different levels. Default is x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the numbers of row and column equal to the length of x and y respectively. 
The <code class="reqn">[i, j]</code> element is the reproducing kernel evaluated at the ith element of x and jth element of y.
</p>
<p><code>shink0</code> shrinks towards zero, and <code>shrink1</code> shinks towards the mean. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+shrink0">shrink0</a></code>,<code><a href="#topic+ssr">ssr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;-rep(1:10,2)
shrink1(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='sine4p'>Calculate Reproducing Kernels for Periodic L-Splines with Period 1/2</h2><span id='topic+sine4p'></span>

<h3>Description</h3>

<p>Return a matrix evaluating reproducing kernels for periodic L-splines at observed points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sine4p(s, t=s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sine4p_+3A_s">s</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="sine4p_+3A_t">t</code></td>
<td>
<p>an optional vector. Default is the same as s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general formula of the reproducing kernel is provided in Gu (2001). The close form is not available, so an approximate based on the first 50 terms of the series
is used.</p>


<h3>Value</h3>

<p>a matrix with the numbers of row and column equal to the lengths of s and t respectively.
The [i, j] element is the reproducing kernel evaluated at (s[i], t[j]). </p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Gu, C. (2001). Smoothing Spline ANOVA Modes. Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cubic">cubic</a></code>, <code><a href="#topic+lspline">lspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;- seq(0, 1, len=100)
sine4p(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='slm'>
Fit a Semi-parametric Linear Mixed Effects Model
</h2><span id='topic+slm'></span>

<h3>Description</h3>

<p>Returns an object of class <code>slm</code> that represents a
semi-parametric linear mixed effects model fit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slm(formula, rk, data=list(), random, weights=NULL, 
correlation=NULL, control=list(apVar=FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slm_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a <code class="reqn">\sim</code> operator, and the bases 
of the null space <code class="reqn">H_0</code> of the non-parametric function and other terms, separated by + operators, on the right.
</p>
</td></tr>
<tr><td><code id="slm_+3A_rk">rk</code></td>
<td>

<p>a list of expressions that specify the reproducing kernels of the spline function(s), <code class="reqn">R^1,\dots,R^p</code> for spaces <code class="reqn">H_1,\dots,H_p</code>. See the help file of ssr for more details.
</p>
</td></tr>
<tr><td><code id="slm_+3A_data">data</code></td>
<td>

<p>An optional data frame containing the variables appearing in <code>formula</code>, <code>random</code>, <code>rk</code>, <code>correlation</code>, <code>weights</code>. 
By default, the variables are taken from the environment from which <code>slm</code> is called.
</p>
</td></tr>
<tr><td><code id="slm_+3A_random">random</code></td>
<td>

<p>A named list of formulae, lists of formulae, or pdMat objects, which defines
nested random effects structures. See help file of lme for more details.
</p>
</td></tr>
<tr><td><code id="slm_+3A_weights">weights</code></td>
<td>

<p>An optional <code>varFun</code> object or one-sided formula describing the within-group heteroscedasticity stucture. 
See the help file of <code>lme</code> for more details.
</p>
</td></tr>
<tr><td><code id="slm_+3A_correlation">correlation</code></td>
<td>

<p>An optional <code>corStruct</code> object specifying the within-group correlation structure. See <code>lme</code> for more details.
</p>
</td></tr>
<tr><td><code id="slm_+3A_control">control</code></td>
<td>

<p>an optional list of any applicable control parameters from <code>lme</code>.
</p>
</td></tr></table>


<h3>Details</h3>

<p>This generic function fits a semi-parametric linear mixed effects model (or non-parametric mixed effects models) 
as described in Wang (1998), but allowing for general random and correlation structures. Because the connection
to a linear mixed effects model is adopted, only GML is available to choose smoothing parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>slm</code> is returned. Generic functions such as print, summary, predict and intervals have
methods to show the results of the fit.
</p>
<p>Note: output from earlier versions of <code>slm</code> shows incorrect smoothing spline parameters for SSANOVA, which is corrected in this version.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a>.</p>


<h3>References</h3>

<p>Wang, Y. (1998) Mixed Effects Smoothing Spline ANOVA. JRSS, Series B, 60:159&ndash;174.
</p>
<p>Pinherio, J. C. and Bates, D. M. (2000) Mixed-effects Models in S and S-Plus. Springer.       
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+predict.slm">predict.slm</a></code>, <code><a href="#topic+intervals.slm">intervals.slm</a></code>,
<code><a href="#topic+print.slm">print.slm</a></code>,<code><a href="#topic+summary.slm">summary.slm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## SS ANOVA is used to model "time" and "group" 
## with random intercept for "dog".
data(dog)

dog.fit&lt;- slm(y~group*time, rk=list(cubic(time), shrink1(group),
    	rk.prod(kron(time-0.5),shrink1(group)),rk.prod(cubic(time), 
    	shrink1(group))), random=list(dog=~1), data=dog)

## End(Not run)
</code></pre>

<hr>
<h2 id='snm'>
Fit a Semi-parametric Nonlinear Mixed-effects Model
</h2><span id='topic+snm'></span>

<h3>Description</h3>

<p>This generic function fits a semi-paramteric nonlinear mixed-effects model 
in the formulation described in Ke and Wang (2001). Current version only allows linear dependence on non-parametric 
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snm(formula, func, data=list(), fixed, random=fixed, 
groups, start, spar="v", verbose=FALSE, method="REML", control=NULL, 
correlation=NULL, weights=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snm_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a ~ operator, and an expression 
of variables, parameters and non-parametric functions on the right.
</p>
</td></tr>
<tr><td><code id="snm_+3A_func">func</code></td>
<td>

<p>a list of spline formulae each specifying the spline components necessary to 
estimate each non-parametric function. On the left of a <code class="reqn">\mbox{\textasciitilde}</code> operator of each component 
is the unknow function symbol(s) as well as its arguments, while the right side is a 
list of two components <code>nb</code>, an optional one-side formula for representing the null 
space's bases, and a required <code>rk</code> structure. <code>nb</code> and <code>rk</code> are similar to <code>formula</code> 
and <code>rk</code> in ssr. A missing <code>nb</code> denotes an empty null space. 
</p>
</td></tr>
<tr><td><code id="snm_+3A_fixed">fixed</code></td>
<td>

<p>a two-sided formula specifying models for the fixed effects.
The syntax of <code>fixed</code> in <code>nlme</code> is adopted.
</p>
</td></tr>
<tr><td><code id="snm_+3A_start">start</code></td>
<td>

<p>a numeric vector, the same length as the number of fixed effects, supplying starting
values for the fixed effects.
</p>
</td></tr>
<tr><td><code id="snm_+3A_spar">spar</code></td>
<td>

<p>a character string specifying a method for choosing the smoothing parameter. &quot;v&quot;, &quot;m&quot; and &quot;u&quot; represent  GCV, GML and
UBR respectively. Default is &quot;v&quot; for GCV.
</p>
</td></tr>
<tr><td><code id="snm_+3A_data">data</code></td>
<td>

<p>An optional data frame containing the variables appearing in <code>formula</code>
, <code>random</code>, <code>rk</code>, <code>correlation</code>, <code>weights</code>. By default, the variables 
are taken from the environment from which <code>snm</code> is called.
</p>
</td></tr>
<tr><td><code id="snm_+3A_random">random</code></td>
<td>

<p>an optional random effects structure specifying models for the random effects.
The same syntax of <code>random</code> in <code>nlme</code> is assumed.
</p>
</td></tr>
<tr><td><code id="snm_+3A_groups">groups</code></td>
<td>

<p>an optional one-sided formula of the form ~g1 (single level) or ~g1/.../gQ 
(multiple levels of nesting), specifying the partitions of the data over 
which the random effects vary. g1,...,gQ must evaluate to factors in data. 
See nlme for details.	 
</p>
</td></tr>
<tr><td><code id="snm_+3A_verbose">verbose</code></td>
<td>

<p>an optional logical numerical value. If <code>TRUE</code>, information on
the evolution of the iterative algorithm is printed. Default is
<code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="snm_+3A_method">method</code></td>
<td>

<p>a character string. If 'REML' the model is fit by maximizing the restricted 
log-likelihood. If 'ML' the log-likelihood is maximized. Default is 'REML. 
</p>
</td></tr>
<tr><td><code id="snm_+3A_control">control</code></td>
<td>

<p>a list of parameters to control the performance of the algorithm.
</p>
</td></tr>
<tr><td><code id="snm_+3A_correlation">correlation</code></td>
<td>

<p>an optional <code>corStruct</code> object describing the within-group correlation 
structure. See the documentation of corClasses for a description of the available corStruct classes. 
Default is NULL, corresponding to no within-in group correlations.
</p>
</td></tr>
<tr><td><code id="snm_+3A_weights">weights</code></td>
<td>

<p>an optional <code>varFunc</code> object or one-sided formula describing the 
within-group heteroscedasticity structure. If given as a formula, 
it is used as the argument to <code>varFixed</code>, corresponding to fixed variance weights. 
See the documentation on varClasses for a description of the available varFunc 
classes. Defaults to NULL, corresponding to homoscesdatic within-group errors.
</p>
</td></tr></table>


<h3>Value</h3>

<p>an object of class <code>snm</code> is returned, representing a semi-parametric nonlinear
mixed effects model fit. Generic functions such as print, summary, predict and
intervals have methods to show the results of the fit.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a>.</p>


<h3>References</h3>

<p>Ke, C. and Wang, Y. (2001). Semi-parametric Nonlinear Mixed Effects Models and
Their Applications. JASA 96:1272-1298.
</p>
<p>Pinheiro, J.C. and Bates, D. M. (2000). Mixed-Effects Models in S
and S-PLUS. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.snm">predict.snm</a></code>, <code><a href="#topic+intervals.snm">intervals.snm</a></code>, <code><a href="#topic+snm.control">snm.control</a></code>,
<code><a href="#topic+print.snm">print.snm</a></code>,<code><a href="#topic+summary.snm">summary.snm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(CO2)

options(contrasts=rep("contr.treatment", 2))	
co2.fit1 &lt;- nlme(uptake~exp(a1)*(1-exp(-exp(a2)*(conc-a3))), 
                 fixed=list(a1+a2~Type*Treatment,a3~1), 
                 random=a1~1, groups=~Plant, 
                 start=c(log(30),0,0,0,log(0.01),0,0,0,50),
                 data=CO2)

M &lt;- model.matrix(~Type*Treatment, data=CO2)[,-1]
co2.fit2 &lt;- snm(uptake~exp(a1)*f(exp(a2)*(conc-a3)),
                func=f(u)~list(~I(1-exp(-u))-1,lspline(u, type="exp")),
                fixed=list(a1~M-1,a3~1,a2~Type*Treatment),
                random=list(a1~1), group=~Plant, verbose=TRUE,
                start=co2.fit1$coe$fixed[c(2:4,9,5:8)], data=CO2)

## End(Not run)
</code></pre>

<hr>
<h2 id='snm.control'>
Set Control Parameters for snm
</h2><span id='topic+snm.control'></span>

<h3>Description</h3>

<p>Control parameters supplied in the function call replace 
the defaults to be used in calling <code>snm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snm.control(rkpk.control, nlme.control, prec.out=0.0005, 
  maxit.out=30, converg="COEF", incDelta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snm.control_+3A_rkpk.control">rkpk.control</code></td>
<td>

<p>a optional list of control parameters for dsidr or dmudr to estimate the unknown
functions.
</p>
</td></tr>
<tr><td><code id="snm.control_+3A_nlme.control">nlme.control</code></td>
<td>

<p>a list of control parameters for the nonlinear regression step, 
the same as nlmeControl. Default is <code>list(returnObject = T, maxIter = 5)</code>.
</p>
</td></tr>
<tr><td><code id="snm.control_+3A_prec.out">prec.out</code></td>
<td>

<p>tolerance for convergence criterion. Default is 0.0005.
</p>
</td></tr>
<tr><td><code id="snm.control_+3A_maxit.out">maxit.out</code></td>
<td>

<p>maximum number of iterations for the algorithm. Default is 30.
</p>
</td></tr>
<tr><td><code id="snm.control_+3A_converg">converg</code></td>
<td>

<p>an optional character, with possible values &quot;COEF&quot; and &quot;PRSS&quot;, specifying the convergence 
criterion to be used. &quot;COEF&quot; uses the change of estimate of parameters and functions to
assess convergence, and &quot;PRSS&quot; uses penalized residual sums of squares. Default is &quot;COEF&quot;.
</p>
</td></tr>
<tr><td><code id="snm.control_+3A_incdelta">incDelta</code></td>
<td>
<p>specifies a small value as increment to calcuate derivatives. Default is 0.001.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returned is a list includes all re-seted control parameters.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+snm">snm</a></code>, <code><a href="#topic+dsidr">dsidr</a></code>, <code><a href="#topic+dmudr">dmudr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## set maximum iteration to be 50
snm.control(maxit.out=50)

## End(Not run)
</code></pre>

<hr>
<h2 id='snr'>
Fit A Semi-parametric Nonlinear Regression Model
</h2><span id='topic+snr'></span>

<h3>Description</h3>

<p>This generic function fits a Semi-parametric Nonlinear Regression Model as formulated in Ke (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snr(formula, func, params, data, start, 
    spar = "v", verbose = FALSE, control = list(), correlation = NULL, 
    weights = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snr_+3A_formula">formula</code></td>
<td>

<p>a model formula, with the response on the left of a <code class="reqn">\mbox{\textasciitilde}</code> operator 
and on the right an expression representing the mean function 
with at least one unknown function appearing with a symbol, 
e.g. f. If &quot;data&quot; is present, all names except the nonparametric 
function(s) used in the formula should be defined as parameters 
or variables in the data frame.
</p>
</td></tr>
<tr><td><code id="snr_+3A_func">func</code></td>
<td>

<p>a list of spline formulae each specifying the spline components 
necessary to estimate each non-parametric function. On the left 
of a  <code class="reqn">\mbox{\textasciitilde}</code> operator of each component is the unknow function symbol(s) 
as well as its arguments, while the right side is a list of two 
components <code>nb</code>, an optional one-side formula for representing 
the null space's bases, and a required <code>rk</code> structure. <code>nb</code> and 
<code>rk</code> are similar to <code>formula</code> and <code>rk</code> in ssr. A missing <code>nb</code> 
denotes an empty null space.   
</p>
</td></tr>
<tr><td><code id="snr_+3A_params">params</code></td>
<td>

<p>a two-sided formula specifying models for the parameters. 
The syntax of <code>params</code> in <code>gnls</code> is adopted. See <code>gnls</code> for details.
</p>
</td></tr>
<tr><td><code id="snr_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables named in model, 
params, correlation and weights. By default the variables are taken 
from the environment from which snr is called.	
</p>
</td></tr>
<tr><td><code id="snr_+3A_start">start</code></td>
<td>

<p>a numeric list with two components: &quot;params=&quot;, a vector of the size of the length of the unknown parameters, 
providing inital values for the paramters, and &quot;f=&quot; a list of vectors or expressions which input inital values for the unknown functions. 
If the unknown functions appear linear in the model, the intial values then are not necessary. 
</p>
</td></tr>
<tr><td><code id="snr_+3A_spar">spar</code></td>
<td>

<p>a character string specifying a method for choosing the smoothing parameter. &quot;v&quot;, &quot;m&quot; and &quot;u&quot; represent  GCV, GML and
UBR respectively. Default is &quot;v&quot; for GCV.
</p>
</td></tr>
<tr><td><code id="snr_+3A_verbose">verbose</code></td>
<td>

<p>an optional logical numerical value. If <code>TRUE</code>, information on
the evolution of the iterative algorithm is printed. Default is
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="snr_+3A_control">control</code></td>
<td>

<p>an optional list of control parameters. See <code>snr.control</code> for details.
</p>
</td></tr>
<tr><td><code id="snr_+3A_correlation">correlation</code></td>
<td>

<p>an optional <code>corStruct</code> as in gnls. Default is NULL, corresponding to uncorrelation.
</p>
</td></tr>
<tr><td><code id="snr_+3A_weights">weights</code></td>
<td>

<p>an optional <code>varFunc</code> structure as in <code>gnls</code>. Default is NULL, representing equal variances.
</p>
</td></tr></table>


<h3>Details</h3>

<p>A semi-parametric regression model is generalization of self-modeling 
regression, nonlinear regression and smoothing spline models, including 
as special cases (nonlinear) partial spline models, varying coefficients 
models, PP regression and some other popular models. 'snr' is 
implemented with an alternate iterative procedures with smoothing splines 
to estimate the unknown functions and general nonlinear regression to
estimate parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>snr</code> is returned, representing a semi-parametric 
nonlinear regression fit. Generic functions such as print, summary, 
intervals and predict have methods to show the results of  the  fit.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a>.</p>


<h3>References</h3>

<p>Ke, C. (2000). Semi-parametric Nonlinear Regression and Mixed Effects 
Models. PhD thesis, University of California, Santa Barbara.
</p>
<p>Pinheiro, J.C. and Bates, D. M. (2000). Mixed-Effects Models in S
and S-PLUS. Springer.
</p>
<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intervals.snr">intervals.snr</a></code>,  <code><a href="#topic+predict.snr">predict.snr</a></code>, <code><a href="#topic+snr.control">snr.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(CO2)
options(contrasts=rep("contr.treatment", 2))    
co2.fit1 &lt;- nlme(uptake~exp(a1)*(1-exp(-exp(a2)*(conc-a3))), 
                 fixed=list(a1+a2~Type*Treatment,a3~1), 
                 random=a1~1, groups=~Plant, 
                 start=c(log(30),0,0,0,log(0.01),0,0,0,50),
                 data=CO2)

M &lt;- model.matrix(~Type*Treatment, data=CO2)[,-1]

## fit a SNR model
co2.fit2 &lt;- snr(uptake~exp(a1)*f(exp(a2)*(conc-a3)),
                func=f(u)~list(~I(1-exp(-u))-1,lspline(u, type="exp")),
                params=list(a1~M-1, a3~1, a2~Type*Treatment),
                start=list(params=co2.fit1$coe$fixed[c(2:4,9,5:8)]), data=CO2)

## End(Not run)
</code></pre>

<hr>
<h2 id='snr.control'>
Set Control Parameters for snr
</h2><span id='topic+snr.control'></span>

<h3>Description</h3>

<p>Control parameters supplied in the function call replace 
the defaults to be used in calling <code>snr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snr.control(rkpk.control = list(job = -1, tol = 0, init = 0, limnla = c(-10, 
    0), varht = NULL, theta = NULL, prec = 1e-06, maxit = 30), 
    nls.control = list(returnObject = TRUE, maxIter = 5), incDelta = 0.001, 
    prec.out = 0.001, maxit.out = 30, converg = "COEF", method = "GN", 
    backfit = 5) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snr.control_+3A_rkpk.control">rkpk.control</code></td>
<td>

<p>a optional list of control parameters for dsidr or dmudr to estimate the unknown
functions. Default is &quot;list(job = -1, tol = 0, init = 0, limnla = c(-10, 
0), varht = NULL, theta = NULL, prec = 1e-06, maxit = 30)&quot;.
</p>
</td></tr>
<tr><td><code id="snr.control_+3A_nls.control">nls.control</code></td>
<td>

<p>a list of control parameters for the nonlinear regression step, 
the same as gnlsControl. Default is &quot;list(returnObject = TRUE, maxIter = 5).
</p>
</td></tr>
<tr><td><code id="snr.control_+3A_incdelta">incDelta</code></td>
<td>
<p>the incremental value to be used to calculate derivatives for the unknown functions. Default is 0.001</p>
</td></tr> 
<tr><td><code id="snr.control_+3A_prec.out">prec.out</code></td>
<td>

<p>tolerance for convergence criterion. Default is 0.0001.
</p>
</td></tr>
<tr><td><code id="snr.control_+3A_maxit.out">maxit.out</code></td>
<td>

<p>maximum number of iterations for the algorithm. Default is 30.
</p>
</td></tr>
<tr><td><code id="snr.control_+3A_converg">converg</code></td>
<td>

<p>an optional character, with possible values <code>COEF</code> and <code>PRSS</code>, specifying the convergence 
criterion to be used. <code>COEF</code> uses the change of estimate of parameters and functions to
assess convergence, and <code>PRSS</code> uses penalized residual sums of squares. Default is <code>COEF</code>.
</p>
</td></tr>
<tr><td><code id="snr.control_+3A_method">method</code></td>
<td>
<p> an optional string of value either <code>GN</code> for Gauss-Newton or <code>NR</code> for Newton-Raphson 
iteration methods to estimate the unknown functions. Default is <code>GN</code>.</p>
</td></tr>
<tr><td><code id="snr.control_+3A_backfit">backfit</code></td>
<td>
<p> an integer to set the number of backfitting iterations inside the loop. Default is 5</p>
</td></tr></table>
<p>.
</p>


<h3>Value</h3>

<p>returned is a list includes all re-seted control parameters.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+snr">snr</a></code>, <code><a href="#topic+dsidr">dsidr</a></code>, <code><a href="#topic+dmudr">dmudr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use Newton-Raphson iteration and only a single backfitting
## Not run: 
snr.control(method="NR", backfit=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='sphere'>
Calculate Pseudo Reproducing Kernels for Spherical Splines
</h2><span id='topic+sphere'></span>

<h3>Description</h3>

<p>Return a matrix evaluating reproducing kernels for splines on a sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere(x, y=x, order=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphere_+3A_x">x</code></td>
<td>

<p>a matrix of two columns or a list of two components, representing observed 
latitude and longitude respectively.
</p>
</td></tr>
<tr><td><code id="sphere_+3A_y">y</code></td>
<td>

<p>a matrix of two columns or a list of two components, representing 
latitude and longitude respectively. Default is the same as x.
</p>
</td></tr>
<tr><td><code id="sphere_+3A_order">order</code></td>
<td>

<p>an optional integer sepcifying the order of the spherical spline. Available are
2, 3, 4, 5 and 6, with a default 2.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The kernel for sperical splines is a series inconvenient to compute. This pseudo kernel
is based on a topological equivalence as described in Wahba (1981), for which cases the
closed form can be derived.
</p>


<h3>Value</h3>

<p>a matrix with the numbers of row and column equal to the lengths of x and y respectively.
The [i, j] element is the reproducing kernel evaluated at <code class="reqn">(x[i,], y[j,])</code> 
(or <code class="reqn">((x[[1]][i], x[[2]][i]), (y[[1]][j], y[[2]][j]))</code> for lists). 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Wahba, G. (1981). Spline Interprolation and Smoothing on the Sphere. SIAM J. Sci. Stat.Comput.,
Vol. 2, No. 1, March 1981.
</p>
<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+periodic">periodic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;- seq(0, 2*pi, len=10)
y&lt;- seq(-pi/2, pi/2, len=10)
s.ker&lt;- sphere(cbind(x, y), order=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='ssr'>Fit a General Smoothing Spline Regression Model</h2><span id='topic+ssr'></span>

<h3>Description</h3>

<p>Returns an object of class ssr which is a general/generalized/correlated smoothing spline fit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssr(formula, rk, data = list(), subset, weights = NULL, 
	correlation = NULL, family = "gaussian", scale = FALSE, 
	spar = "v", varht = NULL, limnla = c(-10, 3), control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssr_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> object, with the response on the left of a <code class="reqn">\mbox{\textasciitilde}</code> operator, and 
the bases of the null space <code class="reqn">H_0</code>, separated by + operators, on the right. 
Thus it specifies the parametric part of the model that contains functions 
which are not penalized. </p>
</td></tr>
<tr><td><code id="ssr_+3A_rk">rk</code></td>
<td>

<p>a list of expressions specifying reproducing kernels <code class="reqn">R^1</code>,...,<code class="reqn">R^p</code> for <code class="reqn">H_1</code>,...,<code class="reqn">H_p</code>. 
For <code class="reqn">p=1</code>, rk may be specified with given functions. Supported functions are: &quot;linear&quot;, 
&quot;cubic&quot;, &quot;quintic&quot;, and &quot;septic&quot; for linear, cubic, quintic and septic polynomial 
splines with &quot;linear2&quot;, &quot;cubic2&quot;, &quot;quintic2&quot;, and &quot;septic2&quot; for another construction;
&quot;periodic&quot; for periodic splines; &quot;shrink0&quot; and &quot;shrink1&quot; for Stein's shrink-toward-zero and 
shrink-toward-mean estimates; &quot;tp&quot; for thin-plate-splines; &quot;lspline&quot; for L-splines. 
For details on these kernels, see their help files. Users may also write their own functions.</p>
</td></tr>
<tr><td><code id="ssr_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables occurring in the formula and the <code>rk</code>. If this option is not specified, 
the variables should be on the search list. Missing values are not allowed. </p>
</td></tr>
<tr><td><code id="ssr_+3A_subset">subset</code></td>
<td>
<p> an optional expression indicating which subset of the rows of the  data should be used in the fit.  
This can be a logical vector (which is replicated to have length equal to the number of observations), 
a numeric vector indicating which observation numbers are to be  included, or a character vector  
of the row names to be included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="ssr_+3A_weights">weights</code></td>
<td>
<p> a vector or a matrix specifying known weights for weighted smoothing, or a varFunc structure 
specifying a variance function structure. Its length, if a vector, or its number of columns and rows, 
if a matrix, must be equal to the length of responses. See documentations of nlme for availabe 
varFunc structures. The default is that all weights are equal. </p>
</td></tr>
<tr><td><code id="ssr_+3A_correlation">correlation</code></td>
<td>
<p>  a corStruct object describing the correlation structure for random errors. See documentations 
of corClasses for availabe correlation structures. Default is NULL for no correlation.</p>
</td></tr>
<tr><td><code id="ssr_+3A_family">family</code></td>
<td>
<p>an optional string specifying the distribution family. Families supported are &quot;binary&quot;, &quot;binomial&quot;, 
&quot;poisson&quot;, &quot;gamma&quot; and &quot;gaussian&quot; for Bernoulli, binomial, poisson, gamma and Gaussian distributions 
respectively. Default is &quot;gaussian&quot;. </p>
</td></tr>
<tr><td><code id="ssr_+3A_scale">scale</code></td>
<td>
<p>an optional logical value. If &lsquo;TRUE&rsquo;, all covariates appearing in &quot;rk&quot; will be scaled into 
interval [0, 1]. This transformation will affect predict.ssr. Default is FALSE. </p>
</td></tr>
<tr><td><code id="ssr_+3A_spar">spar</code></td>
<td>
<p> a character string specifying a method for choosing the smoothing parameter. &quot;v&quot;, &quot;m&quot; and &quot;u&quot; represent 
GCV, GML and UBR respectively. &quot;u<code class="reqn">\sim</code>&quot;, only used for non-Gaussian families, specifies UBR with an estimated variance. 
Default is &quot;v&quot;. </p>
</td></tr>
<tr><td><code id="ssr_+3A_varht">varht</code></td>
<td>
<p> needed only when 'u' is chosen for 'method', which gives the fixed variance in calculation of the UBR function. 
Default is NULL for &lsquo;family=&quot;gaussian&quot;&rsquo; and 1 for all other families. </p>
</td></tr>
<tr><td><code id="ssr_+3A_limnla">limnla</code></td>
<td>
<p>a vector of length one or two, specifying a search range for log10(n*lambda), where lambda is the smoothing 
parameter and n is the sample size. If it is a single value, the smoothing parameter will be fixed at this value. 
This option is only applicable to spline smoothing with a single smoothing parameter. </p>
</td></tr>
<tr><td><code id="ssr_+3A_control">control</code></td>
<td>
<p>a list of iteration and algorithmic constants. See ssr.control for details and default values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>We adopt notations in Wahba (1990) for the general spline and smoothing spline ANOVA models. 
Specifically, the functional relationship between the predictor and independent variable is unknown 
and is assumed to be in a reproducing kernel Hilbert space H. H is decomposed into <code class="reqn">H_0</code> and 
<code class="reqn">H_1+...+H_p</code>, where the null space <code class="reqn">H_0</code> is a finite dimensional space spanned by 
bases specified at the right side of <code class="reqn">\mbox{\textasciitilde}</code> in formula, and 
<code class="reqn">H_1</code>,... ,<code class="reqn">H_p</code> are reproducing kernel Hilbert spaces with reproducing kernel specified in the list rk. 
</p>
<p>The function is estimated from weighted penalized least square. ssr can be used to fit the general spline and smoothing spline ANOVA models (Wahba, 1990), generalized spline models (Wang, 1997) and correlated spline models (Wang, 1998). ssr can also fit partial spline model with additional parametric terms specified in the formula (Wahba, 1990).
</p>
<p>ssr could be slow and memory intensive, especially for large sample size and/or when p is large. 
For fitting a cubic spline with CV or GCV estimate of the smoothing parameter, 
the S-Plus function <code>smooth.spline</code> is more efficient.
</p>
<p>Components can be extracted using extractor functions predict, deviance, residuals, and summary. The output can be modified using update. 
</p>


<h3>Value</h3>

<p>an object of class <code>ssr</code> is  returned. See ssr.object for details. 
</p>
<p>Note: output from earlier versions of <code>ssr</code> shows incorrect smoothing spline parameters for SSANOVA, which is corrected in this version.
</p>


<h3>Author(s)</h3>

<p>Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a> and Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> </p>


<h3>References</h3>

 
<p>Gu, C. (1989). RKPACK and its applications: Fitting smoothing spline models. Proceedings of the Statistical Computing Section, ASA, 42-51.
</p>
<p>Gu, C. (2002). Smoothing Spline ANOVA. Spinger, New York.
</p>
<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Wang, Y. (1995). GRKPACK: Fitting Smoothing Spline ANOVA Models for Exponential Families. Communications in Statistics: Simulation and Computation, 24: 1037-1059.
</p>
<p>Wang, Y. (1998) Smoothing Spline Models with Correlated Random Errors. JASA, 93:341-348.
</p>
<p>Ke, C. and Wang, Y. (2002) ASSIST: A Suite of S-plus functions Implementing Spline smoothing Techniques. 
Available at: <a href="https://yuedong.faculty.pstat.ucsb.edu/">https://yuedong.faculty.pstat.ucsb.edu/</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+deviance.ssr">deviance.ssr</a></code>, <code><a href="#topic+hat.ssr">hat.ssr</a></code>,  <code><a href="#topic+plot.ssr">plot.ssr</a></code>, <code><a href="#topic+ssr.control">ssr.control</a></code>,  
<code><a href="#topic+predict.ssr">predict.ssr</a></code>, <code><a href="#topic+print.ssr">print.ssr</a></code>, 
<code><a href="#topic+ssr.object">ssr.object</a></code>, <code><a href="#topic+summary.ssr">summary.ssr</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(MASS)
# fitting a cubic spline
fit1&lt;- ssr(accel~times, data=mcycle, scale=T, rk=cubic(times))
summary(fit1)

# using GML to choose the smoothing parameter
fit2&lt;- update(fit1, spar="m")

data(acid)
## fit an additive thin plate spline
acid.fit&lt;- ssr( ph ~ t1 + x1 + x2, rk = list(tp(t1), tp(list(x1, x2))), 
        data = acid, spar = "m", scale = FALSE)
acid.fit

## End(Not run)
</code></pre>

<hr>
<h2 id='ssr.control'>Set Control Parameters for &lsquo;ssr&rsquo;</h2><span id='topic+ssr.control'></span>

<h3>Description</h3>

<p>The values supplied in the function call replace the defaults and a
list with all possible arguments is returned. The returned list is
used as the &lsquo;control&rsquo; argument to the &lsquo;ssr&rsquo; function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssr.control(job=-1, tol=0.0, init=0.0, theta, prec=1e-06, 
  maxit=30, tol.g=0.0, prec.g=1e-06, maxit.g=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssr.control_+3A_job">job</code></td>
<td>

<p>an integer representing the optimization method used to find the smoothing parameter. 
The options are job=-1: golden-section search on (limnla(1), limnla(2)); 
job=0: golden-section search with interval specified automatically; 
job &gt;0: regular grid search on <code class="reqn">[limnla(1), limnla(2)]</code> with the number of grids = job + 1. 
Default is -1. This is only applicable to smoothing spline model with 
a single smoothing parameter.
</p>
</td></tr>
<tr><td><code id="ssr.control_+3A_tol">tol</code></td>
<td>

<p>tolerance for truncation used in &lsquo;dsidr&rsquo; or &lsquo;dmudr&rsquo;. Default is 0.0 which sets to square of machine precision.
</p>
</td></tr>
<tr><td><code id="ssr.control_+3A_init">init</code></td>
<td>

<p>init=0 means no initial values are provided for smoothing parameters theta; init=1 means initial values are provided for the theta. 
Default is 0. This option is only applicable to smoothing spline models with multiple smoothing parameters.
</p>
</td></tr>
<tr><td><code id="ssr.control_+3A_theta">theta</code></td>
<td>

<p>If init=1, theta includes intial values for smoothing parameters. Default is NULL. This is only applicable to smoothing spline models with multiple smoothing parameters.
</p>
</td></tr>
<tr><td><code id="ssr.control_+3A_prec">prec</code></td>
<td>

<p>precision requested for the minimum score value in &lsquo;dmudr&rsquo;, where precision is the weaker of the absolute and relative precisions. 
Default is 1e-06. This is only applicable to smoothing spline models with multiple smoothing parameters.
</p>
</td></tr>
<tr><td><code id="ssr.control_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations allowed in &lsquo;dmudr&rsquo;. Default is 30. This is only applicable to smoothing spline model with multiple smoothing parameters.
</p>
</td></tr>
<tr><td><code id="ssr.control_+3A_tol.g">tol.g</code></td>
<td>

<p>the tolerance for elements of w's in GRKPK. Default is 0.0 which means using the machine precision. This is only applicable to generalized spline smoothing.
</p>
</td></tr>
<tr><td><code id="ssr.control_+3A_prec.g">prec.g</code></td>
<td>

<p>precision for stopping the iteration in GRKPK. Default is 1e-06. This is only applicale to generalized spline smoothing.
</p>
</td></tr>
<tr><td><code id="ssr.control_+3A_maxit.g">maxit.g</code></td>
<td>

<p>maximum number of iterations allowed for the iteration in GRKPACK. Default is 30. This is only applicale to generalized spline smoothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# use regular grid seach method with 100 grid points
ssr.control(job=99)

## End(Not run)
</code></pre>

<hr>
<h2 id='ssr.object'> A fitted ssr Object</h2><span id='topic+ssr.object'></span>

<h3>Description</h3>

<p>An object returned by the <code>ssr</code> function, inheriting from class <code>ssr</code>,
and representing a fitted smoothing spline model. Objects of this
class have methods for the generic functions <code>predict</code>, <code>print</code> and
<code>summary</code>. </p>


<h3>Value</h3>

<p>The following components must be included in a legitimate <code>ssr</code> object: 
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>ssr</code> call that produced the object</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>estimated coefficients for the spline estimate</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a vector representing the estimate smoothing parameters</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values of the unknown mean function</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the distribution family used</p>
</td></tr>
<tr><td><code>cor.est</code></td>
<td>
<p>estiamted parameters, if any, in corMatrix</p>
</td></tr>
<tr><td><code>var.est</code></td>
<td>
<p>estiamted parameters, if any, in varFunc</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>design matrix extracted from <code>formula</code></p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>a list of matrices representing reproducing kernels evaluated at design points.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>working residuals from the fit. </p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>equivalent degrees of freedom. It is calculated as the trace of the hat matrix.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>a matrix representing the covariance matrix. It is NULL for iid data.</p>
</td></tr>
<tr><td><code>rkpk.obj</code></td>
<td>
<p>an object representing fits from dsidr/dmudr/gdsidr/gdmudr. See help files 
for dsidr/dmudr/gdsidr/gdmudr for more details.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>a logical value, specifying if scaling is used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+predict.ssr">predict.ssr</a></code>, <code><a href="#topic+summary.ssr">summary.ssr</a></code>, 
<code><a href="#topic+plot.ssr">plot.ssr</a></code>, <code><a href="#topic+dsidr">dsidr</a></code>, <code><a href="#topic+dmudr">dmudr</a></code>, <code><a href="#topic+gdsidr">gdsidr</a></code>,
<code><a href="#topic+gdmudr">gdmudr</a></code>
</p>

<hr>
<h2 id='star'>           
Magnitude of the Mira Variable R Hydrae
</h2><span id='topic+star'></span>

<h3>Description</h3>

<p>The <code>star</code> data frame has 1086 rows and 2 columns of data from the Mira Variable R Hydrae
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(star)
</code></pre>


<h3>Details</h3>

<p>This dataset contains magnitude (brightness) of the Mira variable R Hydrae during 1900-1950.
</p>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>time a numeric vector of the observation time in days
</p>
<p>magnitude a numeric vector of brightness of the Mira variable R Hydrae
</p>


<h3>Source</h3>

<p>Genton, M. G. and Hall, P. (2007). Statistical Inference for Envolving Periodic Functions, Journal of the Royal Statistical Society B 69, 643-657.
</p>


<h3>references</h3>

<p>Yuedong Wang and Chunlei Ke (2009), Smoothing Spline Semi-parametric Nonlinear Regression Models, Journal of Computational and Graphical Statistics 18, 165-183.
</p>

<hr>
<h2 id='Stratford'>Daily maximum temperatures in Stratford</h2><span id='topic+Stratford'></span>

<h3>Description</h3>

<p>The <code>Stratford</code> data frame has 73 rows and 2 columns of data containing daily maximum temperatures in Stratford every five days in 1990
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Stratford)
</code></pre>


<h3>Details</h3>

<p>Daily maximum temperatures from the station in Stratford, Texas, in the year 1990 were extracted. 
The year was divided into 73 five-day periods and measurements on the third day in each period were selected as observations. 
</p>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>x a numeric vector representing time in a year scaled into [0,1]
</p>
<p>y a numeric vector of the observed maximum temperature in Fahrenheit  
</p>


<h3>Source</h3>

<p>This is part of a climate dataset downloaded from the Carbon Dioxide Information Analysis Center at http://cdiac.ornl.gov/ftp/ndp070. 
</p>

<hr>
<h2 id='summary.nnr'>
Object Summaries
</h2><span id='topic+summary.nnr'></span>

<h3>Description</h3>

<p>Summarize a <code>nnr</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nnr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nnr_+3A_object">object</code></td>
<td>
<p>a fitted <code>nnr</code> object.</p>
</td></tr>
<tr><td><code id="summary.nnr_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function  <code>summary</code>  for  objects inheriting from class
<code>nnr</code>.  See summary for the general behavior of this function.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nnr">nnr</a></code>, <code><a href="#topic+print.nnr">print.nnr</a></code>
</p>

<hr>
<h2 id='summary.slm'>
Object Summaries
</h2><span id='topic+summary.slm'></span>

<h3>Description</h3>

<p>Summarize a <code>slm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.slm_+3A_object">object</code></td>
<td>
<p>a fitted <code>slm</code> object.</p>
</td></tr>
<tr><td><code id="summary.slm_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function  <code>summary</code>  for  objects inheriting 
from class <code>slm</code>.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+slm">slm</a></code>, <code><a href="#topic+print.slm">print.slm</a></code>
</p>

<hr>
<h2 id='summary.snm'>
Object Summaries
</h2><span id='topic+summary.snm'></span>

<h3>Description</h3>

<p>Summarize a <code>snm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.snm_+3A_object">object</code></td>
<td>
<p>a fitted 'snm' object.</p>
</td></tr>
<tr><td><code id="summary.snm_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function  <code>summary</code>  for  objects inheriting from class
<code>snm</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+snm">snm</a></code>, <code><a href="#topic+print.snm">print.snm</a></code>
</p>

<hr>
<h2 id='summary.snr'>
Object Summaries
</h2><span id='topic+summary.snr'></span>

<h3>Description</h3>

<p>Summarize a <code>snr</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.snr_+3A_object">object</code></td>
<td>
<p>a fitted <code>snr</code> object.</p>
</td></tr>
<tr><td><code id="summary.snr_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function  <code>summary</code>  for  objects inheriting from class
<code>snr</code>.  See summary for the general behavior of this function.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+snr">snr</a></code>, <code><a href="#topic+print.snr">print.snr</a></code>
</p>

<hr>
<h2 id='summary.ssr'>
Summarize a ssr object
</h2><span id='topic+summary.ssr'></span>

<h3>Description</h3>

<p>Provides a synopsis of a <code>ssr</code> object and perform tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ssr_+3A_object">object</code></td>
<td>
<p> a fitted <code>ssr</code> object. </p>
</td></tr>
<tr><td><code id="summary.ssr_+3A_...">...</code></td>
<td>
<p>unused option.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function  <code>summary</code>  for  objects inheriting 
from class <code>ssr</code>. 
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+print.ssr">print.ssr</a></code>
</p>

<hr>
<h2 id='Thin'>
Calculate Reproducing Kernels for Thin Plate Splines
</h2><span id='topic+tp.pseudo'></span><span id='topic+tp'></span><span id='topic+tp.linear'></span>

<h3>Description</h3>

<p>Return a matrix evaluating reproducing kernels for thin plate splines at observed points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tp.pseudo(s, u=s, order=2)
tp(s, u=s, order=2)
tp.linear(s, u=s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Thin_+3A_s">s</code></td>
<td>

<p>a list or matrix of observations. One component, if a list, and one column, if a matrix,
contains observations on one variable. If a list, all components must be of the same length. 
</p>
</td></tr>
<tr><td><code id="Thin_+3A_u">u</code></td>
<td>

<p>a list or matrix of observations. If a list, all components must be of the same length. The number
of componets of the list, or the number of column of the matrix must be the same as that for s. 
Default is s.
</p>
</td></tr>
<tr><td><code id="Thin_+3A_order">order</code></td>
<td>

<p>an optional integer specifying the order of the thin plate spline. Default is 2. Let d be the
dimension of s (and u). Then order must satisfy <code class="reqn">2*order-d&gt;0</code>.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The pseudo kernel, which is conditional definite positive instead of definite positive, is easy to
calculate, while the true reproducing kernel is complicated. Pseudo Kernels are enough to compute 
spline estimates, but to calcualte Bayesian confidnece intervals, the true kernel is required.
For the special case of d=2 and order=2, the function tp.linear computes evaluations of the reproducing kernel
of the space spanned by linear basis.
</p>


<h3>Value</h3>

<p>a matrix with the numbers of row and column equal to the common length of componets or 
the number of row of s and t respectively. The [i, j] element is the pseudo, true, or linear reproducing kernel
evaluated at the ith element of s and jth element of u.
</p>


<h3>Author(s)</h3>

<p>Chunlei Ke <a href="mailto:chunlei_ke@yahoo.com">chunlei_ke@yahoo.com</a> and Yuedong Wang <a href="mailto:yuedong@pstat.ucsb.edu">yuedong@pstat.ucsb.edu</a></p>


<h3>References</h3>

<p>Wahba, G. (1990). Spline Models for Observational Data. SIAM, Vol. 59.
</p>
<p>Gu, C. and Wahba, G (1993). Smoothing Spline ANOVA with component-wise Bayesian confidence intervals.
Journal of Computational and Graphical Statistics 55, 353&ndash;368.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssr">ssr</a></code>, <code><a href="#topic+cubic">cubic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acid)
## Not run: tp.pseudo(list(acid$x1, acid$x2))
## Not run: tp.pseud0(list(acid$x1, acid$x2), order=3)
</code></pre>

<hr>
<h2 id='TXtemp'>Texas Historical Climate Data</h2><span id='topic+TXtemp'></span>

<h3>Description</h3>

<p>The data frame <code>TXtemp</code>, obtained from the Carbon Dioxide Information and Analysis Center at Oak Ridge National Laboratory, has 17280 rows and 6 columns of data representing monthly temperature records for stations in Texas.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TXtemp)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>stacode a numeric vector of the unique station code formed by combining the two-digit state number 
[state numbers range from 1 to 48] and the four-digit station number (values range from 0008 to 9933);                   
</p>
<p>lat, long numeric vectors identifying the lattitudes and longitudes of the stations in decimal degree.
</p>
<p>year a numeric vector comprising the year for the records
</p>
<p>month a numeric vector of values 1 to 12, represeting the month for the data
</p>
<p>mmtemp a numeric vector of monthly average temperature in Fahrenheit scale.
</p>


<h3>Details</h3>

<p>The data set was extracted from a large national historical climate data, containing data for 48 stations in Texas from 1961 to 1990. Monthly temperature records as well as the latitude and longitude for each station were available.
</p>
<p>Of note, the missing values were coded as -99.99.
</p>


<h3>Source</h3>

<p>Data are downloadable from <a href="https://ess-dive.lbl.gov/">https://ess-dive.lbl.gov/</a>
</p>

<hr>
<h2 id='ultrasound'>
Ultrasound imaging of the tongue shape
</h2><span id='topic+ultrasound'></span>

<h3>Description</h3>

<p>The 'ultrasound' data frame has 1,215 rows and 4 columns of data from an ultrasound experiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ultrasound)
</code></pre>


<h3>Details</h3>

<p>A Russian speaker produced the consonant sequence, /gd/, in three different linguistic environments: '2words', 'cluster' 
and 'Schwa', with three replications for each environment. 15 points from each of 9 slices of toungue curves separated by 30 ms (milliseconds) 
are extracted. Therefore, in total there are 15*9*3*3=1,215 observations.
</p>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>height a numeric vector of toungue height in mm
</p>
<p>length a numeric vector of toungue length in mm
</p>
<p>time a numeric vector of time in ms
</p>
<p>env a factor with three levels: 1 2 and 3 for environment '2words', 'cluster' and 'Schwa' respectively
</p>


<h3>Source</h3>

<p>Phonetics-Phonology Lab of New York University. 
</p>


<h3>references</h3>

<p>Davidson, L. (2006). Comparing Tongue Shapes from Ultrasound Imaging Using Smoothing Spline Analysis of Variance. Journal of the Acoustical Society of America 120, 407-415. 
</p>

<hr>
<h2 id='USAtemp'>Average Winter temperature in the United States</h2><span id='topic+USAtemp'></span>

<h3>Description</h3>

<p>The <code>USAtemp</code> data frame has 1214 rows and 3 columns of data containing average Winter temperatures in 1981 from 1205 stations in USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USAtemp)
</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>
<p>temp a numeric vector of average temperatures (Fahrenheit)
</p>
<p>lat a numeric vector of the latitude of a station       
</p>
<p>long a numeric vector of the longitude of a station       
</p>


<h3>details</h3>

<p>The average Winter temperatures are calculated as the averages of temperatures in December, January and February.
The geological locations of 1214 stations are given in terms of longitude and latitude.
</p>

<hr>
<h2 id='wesdr'>Wisconsin Epidemiological Study of Diabetic Retinopathy</h2><span id='topic+wesdr'></span>

<h3>Description</h3>

<p>The <code>wesdr</code> data frame has 669 rows and 5 columns of data
from an ongoing epidemiological study of a cohort of patients receiving their medical care in an 11-country area in southern Wisconsin.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wesdr)
</code></pre>


<h3>Details</h3>

<p> The progression of diabetic retinopathy was assessed together with a number of medical, demographic, ocular and other covariates and the retinopathy scores.</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>
<p>num a numeric vector giving IDs for individuals.
</p>
<p>dur a numeric vector of duration of at baseline in year.
</p>
<p>gly a numeric vector of glycosylated hemoglobin, a measuer of hyperglycemia.
</p>
<p>bmi a numeric vecttor of body mass index, weight in <code class="reqn">kg/(height in meter)^2</code>.
</p>
<p>prg a vector of 0 or 1's representing disease progression for each individual.
</p>


<h3>Source</h3>

<p>Klein, R., Klein, B. E. K., Moss, S. E., Davis, M. D. and Demets, D. L. (1989a). The Wisconsin epidemiologic study of diabetic retinopathy. IX. Four year incidence and progression of diabetic retinopathy when age at diagnosis is less than 30 years. Arch. Ophthalmal. 107, 237-243.
</p>
<p>Klein, R., Klein, B. E. K., Moss, S. E., Davis, M. D. and Demets, D. L. (1989b). The Wisconsin epidemiologic study of diabetic retinopathy. X. Four year incidence and progression of diabetic retinopathy when age at diagnosis is less than 30 years. Arch. Ophthalmal. 107, 244-249.
</p>

<hr>
<h2 id='xyplot2'>Extension of XYPLOT</h2><span id='topic+xyplot2'></span>

<h3>Description</h3>

<p>Extend <code>xyplot</code> to superpose one or more symbols to each panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyplot2(formula, data, type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyplot2_+3A_formula">formula</code></td>
<td>
<p>a two-sided formula as accepted in <code>xyplot</code></p>
</td></tr>
<tr><td><code id="xyplot2_+3A_data">data</code></td>
<td>
<p>a list of data frames. Each component shall be able to evaluate the vatiables appearing in <code>formula</code></p>
</td></tr>
<tr><td><code id="xyplot2_+3A_type">type</code></td>
<td>
<p>a vector of characters to indicate what type of plots are to draw. Default is line.</p>
</td></tr>
<tr><td><code id="xyplot2_+3A_...">...</code></td>
<td>
<p>any options as accepted in <code>xyplot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>On each panel, several plot types, the length of <code>data</code>, are superposed.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
