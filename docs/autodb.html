<!DOCTYPE html><html lang="en-GB"><head><title>Help for package autodb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {autodb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autodb-package'><p>Database-style normalisation for data.frames</p></a></li>
<li><a href='#attrs'><p>Relational data attributes</p></a></li>
<li><a href='#attrs_order'><p>Relational data attribute order</p></a></li>
<li><a href='#autodb'><p>Create a normalised database from a data frame</p></a></li>
<li><a href='#autoref'><p>Add foreign key references to a normalised database</p></a></li>
<li><a href='#create'><p>Create instance of a schema</p></a></li>
<li><a href='#database'><p>Databases</p></a></li>
<li><a href='#database_schema'><p>Database schemas</p></a></li>
<li><a href='#decompose'><p>Decompose a data frame based on given normalised dependencies</p></a></li>
<li><a href='#dependant'><p>Dependants</p></a></li>
<li><a href='#detset'><p>Determinant sets</p></a></li>
<li><a href='#df_duplicated'><p>Determine Duplicate Elements</p></a></li>
<li><a href='#df_equiv'><p>Test data frames for equivalence under row reordering</p></a></li>
<li><a href='#df_rbind'><p>Combine R Objects by Rows or Columns</p></a></li>
<li><a href='#discover'><p>Dependency discovery with DFD</p></a></li>
<li><a href='#functional_dependency'><p>Functional dependency vectors</p></a></li>
<li><a href='#gv'><p>Generate Graphviz input text to plot objects</p></a></li>
<li><a href='#gv.data.frame'><p>Generate Graphviz input text to plot a data frame</p></a></li>
<li><a href='#gv.database'><p>Generate Graphviz input text to plot databases</p></a></li>
<li><a href='#gv.database_schema'><p>Generate Graphviz input text to plot database schemas</p></a></li>
<li><a href='#gv.relation'><p>Generate Graphviz input text to plot relations</p></a></li>
<li><a href='#gv.relation_schema'><p>Generate Graphviz input text to plot relation schemas</p></a></li>
<li><a href='#insert'><p>Insert data</p></a></li>
<li><a href='#keys'><p>Relational data keys</p></a></li>
<li><a href='#merge_empty_keys'><p>Merge relation schemas with empty keys</p></a></li>
<li><a href='#merge_schemas'><p>Merge relation schemas in given pairs</p></a></li>
<li><a href='#normalise'><p>Create normalised database schemas from functional dependencies</p></a></li>
<li><a href='#nudge'><p>Nudge meta-analysis data</p></a></li>
<li><a href='#records'><p>Relational data records</p></a></li>
<li><a href='#reduce'><p>Remove relations not linked to the main relations</p></a></li>
<li><a href='#reduce.database'><p>Remove database relations not linked to the main relations</p></a></li>
<li><a href='#reduce.database_schema'><p>Remove database schema relations not linked to the given relations</p></a></li>
<li><a href='#references'><p>Schema references</p></a></li>
<li><a href='#rejoin'><p>Join a database into a data frame</p></a></li>
<li><a href='#relation'><p>Relation vectors</p></a></li>
<li><a href='#relation_schema'><p>Relation schema vectors</p></a></li>
<li><a href='#rename_attrs'><p>Rename relational data attributes</p></a></li>
<li><a href='#subrelations'><p>Database subrelations</p></a></li>
<li><a href='#subschemas'><p>Schema subschemas</p></a></li>
<li><a href='#synthesise'><p>Synthesise relation schemas from functional dependencies</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Automatic Database Normalisation for Data Frames</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Automatic normalisation of a data frame to third normal form, with
  the intention of easing the process of data cleaning. (Usage to design your
  actual database for you is not advised.)
  Originally inspired by the 'AutoNormalize' library for 'Python' by 'Alteryx'
  (<a href="https://github.com/alteryx/autonormalize">https://github.com/alteryx/autonormalize</a>), with various changes and
  improvements. Automatic discovery of functional or approximate dependencies,
  normalisation based on those, and plotting of the resulting "database" via
  'Graphviz', with options to exclude some attributes at discovery time, or
  remove discovered dependencies at normalisation time.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, DiagrammeR (&ge; 1.0.7), testthat (&ge; 3.1.4), R.utils
(&ge; 2.11.0), hedgehog (&ge; 0.1), tibble(&ge; 3.2.1), knitr,
rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://charnelmouse.github.io/autodb/">https://charnelmouse.github.io/autodb/</a>,
<a href="https://github.com/CharnelMouse/autodb">https://github.com/CharnelMouse/autodb</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CharnelMouse/autodb/issues">https://github.com/CharnelMouse/autodb/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-17 14:49:55 UTC; Mark</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Webster <a href="https://orcid.org/0000-0002-3351-0686"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark Webster &lt;markwebster204@yahoo.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-19 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='autodb-package'>Database-style normalisation for data.frames</h2><span id='topic+autodb-package'></span>

<h3>Description</h3>

<p>Automatic normalisation of a data.frame to third normal form, with the
intention of easing the process of data cleaning. (Usage to design your
actual database for you is not advised.) Originally inspired by Alteryx's
AutoNormalize Python library (https://github.com/alteryx/autonormalize), with
various changes and improvements. Automatic discovery of functional or
approximate dependencies, normalisation based on those, and plotting of the
resulting &quot;database&quot; via Graphviz, with options to exclude some attributes at
discovery time, or remove discovered dependencies at normalisation time.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mark Webster <a href="mailto:markwebster204@yahoo.co.uk">markwebster204@yahoo.co.uk</a> (<a href="https://orcid.org/0000-0002-3351-0686">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://charnelmouse.github.io/autodb/">https://charnelmouse.github.io/autodb/</a>
</p>
</li>
<li> <p><a href="https://github.com/CharnelMouse/autodb">https://github.com/CharnelMouse/autodb</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/CharnelMouse/autodb/issues">https://github.com/CharnelMouse/autodb/issues</a>
</p>
</li></ul>


<hr>
<h2 id='attrs'>Relational data attributes</h2><span id='topic+attrs'></span><span id='topic+attrs+3C-'></span>

<h3>Description</h3>

<p>Generic function, for fetching attribute sets for elements of a relational
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attrs(x, ...)

attrs(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attrs_+3A_x">x</code></td>
<td>
<p>a relational schema object, such as a <code><a href="#topic+relation_schema">relation_schema</a></code>
or <code><a href="#topic+database_schema">database_schema</a></code> object, or a relational data object, such
as a <code><a href="#topic+relation">relation</a></code> or <code><a href="#topic+database">database</a></code> object.</p>
</td></tr>
<tr><td><code id="attrs_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="attrs_+3A_value">value</code></td>
<td>
<p>A character vector of the same length as <code>attrs(x, ...)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, containing a character vector for each element of <code>x</code>.
</p>

<hr>
<h2 id='attrs_order'>Relational data attribute order</h2><span id='topic+attrs_order'></span><span id='topic+attrs_order+3C-'></span>

<h3>Description</h3>

<p>Generic function, fetching attribute order for relational objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attrs_order(x, ...)

attrs_order(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attrs_order_+3A_x">x</code></td>
<td>
<p>an R object, such as a <code><a href="#topic+functional_dependency">functional_dependency</a></code>,
<code><a href="#topic+relation_schema">relation_schema</a></code>, <code><a href="#topic+relation">relation</a></code>,
<code><a href="#topic+database_schema">database_schema</a></code>, or <code><a href="#topic+database">database</a></code> object.</p>
</td></tr>
<tr><td><code id="attrs_order_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="attrs_order_+3A_value">value</code></td>
<td>
<p>A character vector of the same length as <code>attrs_order(x, ...)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All classes in <code>autodb</code> contain an <code>attrs_order</code> attribute. It
gives an easy way to find a list of all attributes/variables involved in an
object, but its main purpose is to also assign those attributes a consistent
order when printing or plotting the object.
</p>


<h3>Value</h3>

<p>A character vector, giving attributes in the order in which they're
prioritised for sorting within <code>x</code>.
</p>

<hr>
<h2 id='autodb'>Create a normalised database from a data frame</h2><span id='topic+autodb'></span>

<h3>Description</h3>

<p>This is a wrapper function for applying <code><a href="#topic+normalise">normalise</a></code>,
<code><a href="#topic+autoref">autoref</a></code>, and <code><a href="#topic+decompose">decompose</a></code>. This takes a data frame
and converts it straight into a database, which is the main intended use case
for the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autodb(
  df,
  digits = getOption("digits"),
  single_ref = FALSE,
  ensure_lossless = TRUE,
  remove_avoidable = FALSE,
  constants_name = "constants",
  progress = FALSE,
  progress_file = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autodb_+3A_df">df</code></td>
<td>
<p>a data.frame, containing the data to be normalised.</p>
</td></tr>
<tr><td><code id="autodb_+3A_digits">digits</code></td>
<td>
<p>a positive integer, indicating how many significant digits are
to be used for numeric and complex variables. This is used for both
pre-formatting in <code><a href="#topic+discover">discover</a></code>, and for rounding the data before
use in <code><a href="#topic+decompose">decompose</a></code>, so that the data satisfies the resulting
schema. A value of <code>NA</code> results in no rounding. By default, this uses
<code>getOption("digits")</code>, similarly to <code><a href="base.html#topic+format">format</a></code>. See the
&quot;Floating-point variables&quot; section for <code><a href="#topic+discover">discover</a></code> for why this
rounding is necessary for consistent results across different machines. See
the note in <code><a href="base.html#topic+print.default">print.default</a></code> about <code>digits &gt;=
  16</code>.</p>
</td></tr>
<tr><td><code id="autodb_+3A_single_ref">single_ref</code></td>
<td>
<p>a logical, FALSE by default. If TRUE, then only one
reference between each relation pair is kept when generating foreign key
references. If a pair has multiple references, the kept reference refers to
the earliest key for the child relation, as sorted by priority order.</p>
</td></tr>
<tr><td><code id="autodb_+3A_ensure_lossless">ensure_lossless</code></td>
<td>
<p>a logical, indicating whether to check whether the
normalisation is lossless. If it is not, then an additional relation is
added to the final &quot;database&quot;, containing a key for <code>df</code>. This is
enough to make the normalisation lossless.</p>
</td></tr>
<tr><td><code id="autodb_+3A_remove_avoidable">remove_avoidable</code></td>
<td>
<p>a logical, indicating whether to remove avoidable
attributes in relations. If so, then an attribute are removed from
relations if the keys can be changed such that it is not needed to preserve
the given functional dependencies.</p>
</td></tr>
<tr><td><code id="autodb_+3A_constants_name">constants_name</code></td>
<td>
<p>a scalar character, giving the name for any relation
created to store constant attributes. If this is the same as a generated
relation name, it will be changed, with a warning, to ensure that all
relations have a unique name.</p>
</td></tr>
<tr><td><code id="autodb_+3A_progress">progress</code></td>
<td>
<p>a logical, for whether to display progress to the user during
dependency search in <code><a href="#topic+discover">discover</a></code>.</p>
</td></tr>
<tr><td><code id="autodb_+3A_progress_file">progress_file</code></td>
<td>
<p>a scalar character or a connection. If <code>progress</code>
is non-zero, determines where the progress is written to, in the same way
as the <code>file</code> argument for <code><a href="base.html#topic+cat">cat</a></code>.</p>
</td></tr>
<tr><td><code id="autodb_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="#topic+discover">discover</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since <code>decompose</code> only works with functional dependencies, not approximate
dependencies, the accuracy in <code>discover</code> is fixed as 1.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+database">database</a></code>, containing the data in <code>df</code> within the
inferred database schema.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example
autodb(ChickWeight)
</code></pre>

<hr>
<h2 id='autoref'>Add foreign key references to a normalised database</h2><span id='topic+autoref'></span>

<h3>Description</h3>

<p>Adds foreign key references to a <code><a href="#topic+relation_schema">relation_schema</a></code> object
automatically, replacing any existing references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoref(schema, single_ref = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoref_+3A_schema">schema</code></td>
<td>
<p>a <code><a href="#topic+relation_schema">relation_schema</a></code> object, as given by
<code><a href="#topic+synthesise">synthesise</a></code>.</p>
</td></tr>
<tr><td><code id="autoref_+3A_single_ref">single_ref</code></td>
<td>
<p>a logical, FALSE by default. If TRUE, then only one
reference between each relation pair is kept when generating foreign key
references. If a pair has multiple references, the kept reference refers to
the earliest key for the child relation, as sorted by priority order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for generating references is simple. First, it finds every link
between two relation schemas, where the parent contains all the attributes in
one of the child's keys. This can be done separately for all of the child's
keys, so there can be multiple links with the same parent and child if
<code>single_ref</code> is <code>TRUE</code>.
</p>
<p>Second, any transitive references are removed: if there are link relation
pairs a -&gt; b, b -&gt; c, and a -&gt; c, then the latter is transitive, and so is
removed. If there is a cyclic reference, e.g. where c -&gt; a, then the choice
of which link to remove is arbitrary. Cycles cannot occur in sets of relation
schemas resulting from decomposing a single table.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+database_schema">database_schema</a></code> object, containing the given relation
schemas and the created foreign key references.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs &lt;- relation_schema(
  list(
    a_b_c = list(c("a", "b", "c", "d"), list(c("a", "b", "c"))),
    a_b = list(c("a", "b", "d"), list(c("a", "b"), c("b", "d")))
  ),
  letters[1:4]
)
autoref(rs, single_ref = FALSE)
autoref(rs, single_ref = TRUE)
</code></pre>

<hr>
<h2 id='create'>Create instance of a schema</h2><span id='topic+create'></span>

<h3>Description</h3>

<p>Create a relation data object, using the given relational schema object, with
the resulting relations empty and ready for data insertion using
<code><a href="#topic+insert">insert</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_+3A_x">x</code></td>
<td>
<p>a relational schema object, representing the schema to create an
instance of, such as a <code><a href="#topic+relation_schema">relation_schema</a></code> or
<code><a href="#topic+database_schema">database_schema</a></code> object.</p>
</td></tr>
<tr><td><code id="create_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of the schema. For example, calling <code>create</code> on a
<code><a href="#topic+database_schema">database_schema</a></code> creates a <code><a href="#topic+database">database</a></code>, where all
the relations contain zero records.
</p>

<hr>
<h2 id='database'>Databases</h2><span id='topic+database'></span>

<h3>Description</h3>

<p>Enhances a <code><a href="#topic+relation">relation</a></code> object with foreign key reference
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>database(relations, references)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="database_+3A_relations">relations</code></td>
<td>
<p>a <code><a href="#topic+relation">relation</a></code> object.</p>
</td></tr>
<tr><td><code id="database_+3A_references">references</code></td>
<td>
<p>a list of references, each
represented by a list containing four character elements. In order, the
elements are a scalar giving the name of the child (referrer) schema, a
vector giving the child attribute names, a scalar giving the name of the
parent (referee) schema, and a vector giving the parent attribute names. The
vectors must be of the same length and contain names for attributes present
in their respective schemas, and the parent attributes must form a key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="#topic+relation_schema">relation_schema</a></code> and <code><a href="#topic+relation">relation</a></code>, and like
<code><a href="#topic+database_schema">database_schema</a></code>, <code>database</code> is not designed to be
vector-like: it only holds a single database. This adheres to the usual
package use case, where a single data frame is being analysed at a time.
However, it inherits from <code><a href="#topic+relation">relation</a></code>, so is vectorised with
respect to its relations.
</p>
<p>As with <code><a href="#topic+relation">relation</a></code>, duplicate relations, after ordering by
attribute, are allowed, and can be removed with <code><a href="base.html#topic+unique">unique</a></code>.
</p>
<p>References, i.e. foreign key references, are allowed to have different
attribute names in the child and parent relations; this can't occur in the
output for <code><a href="#topic+autoref">autoref</a></code> and <code><a href="#topic+normalise">normalise</a></code>.
</p>
<p>Subsetting removes any references that involve removed relations.
Removing duplicates with <code><a href="base.html#topic+unique">unique</a></code> changes references involving
duplicates to involve the kept equivalent relations instead. Renaming
relations with <code><a href="base.html#topic+names">names&lt;-</a></code> also changes their names
in the references.
</p>


<h3>Value</h3>

<p>A <code>database</code> object, containing <code>relations</code> with
<code>references</code> stored in an attribute of the same name. References
are stored with their attributes in the order they appear in their
respective relations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rels &lt;- relation(
  list(
    a = list(
      df = data.frame(a = logical(), b = logical()),
      keys = list("a")
    ),
    b = list(
      df = data.frame(b = logical(), c = logical()),
      keys = list("b", "c")
    )
  ),
  attrs_order = c("a", "b", "c", "d")
)
db &lt;- database(
  rels,
  list(list("a", "b", "b", "b"))
)
print(db)
attrs(db)
stopifnot(identical(
  attrs(db),
  lapply(records(db), names)
))
keys(db)
attrs_order(db)
names(db)
references(db)

# relations can't reference themselves
## Not run: 
  database(
    relation(
      list(a = list(df = data.frame(a = 1:5), keys = list("a"))),
      c("a", "b")
    ),
    list(list("a", "a", "a", "a"))
  )
  database(
    relation(
      list(a = list(df = data.frame(a = 1:5, b = 6:10), keys = list("a"))),
      c("a", "b")
    ),
    list(list("a", "b", "a", "a"))
  )

## End(Not run)

# an example with references between differently-named attributes
print(database(
  relation(
    list(
      citation = list(df = data.frame(citer = 1:5, citee = 6:10), keys = list(c("citer", "citee"))),
      article = list(df = data.frame(article = 1:10), keys = list("article"))
    ),
    c("citer", "citee", "article")
  ),
  list(
    list("citation", "citer", "article", "article"),
    list("citation", "citee", "article", "article")
  )
))

# inserting data
insert(db, data.frame(a = 1L, b = 2L, c = 3L, d = 4L))
# data is only inserted into relations where all columns are given...
insert(db, data.frame(a = 1L, b = 2L, c = 3L))
# and that are listed in relations argument
insert(
  db,
  data.frame(a = 1L, b = 2L, c = 3L, d = 4L),
  relations = "b"
)
# inserted data can't violate keys
## Not run: 
  insert(
    db,
    data.frame(a = 1L, b = 1:2)
  )

## End(Not run)
# inserted data can't violate foreign key references
## Not run: 
  insert(
    db,
    data.frame(a = 1L, b = 2L, c = 3L, d = 4L),
    relations = "a"
  )

## End(Not run)

# vector operations
db2 &lt;- database(
  relation(
    list(
      e = list(df = data.frame(a = 1:5, e = 6:10), keys = list("e"))
    ),
    attrs_order = c("a", "e")
  ),
  list()
)
c(db, db2) # attrs_order attributes are merged
unique(c(db, db))

# subsetting
db[1]
stopifnot(identical(db[[1]], db[1]))
db[c(1, 2, 1, 2)] # replicates the foreign key references
c(db[c(1, 2)], db[c(1, 2)]) # doesn't reference between separate copies of db
unique(db[c(1, 2, 1, 2)]) # unique() also merges references

# another example of unique() merging references
db_merge &lt;- database(
  relation(
    list(
      a = list(
        df = data.frame(a = logical(), b = logical()),
        keys = list("a")
      ),
      b = list(
        df = data.frame(b = logical(), c = logical(), d = logical()),
        keys = list("b")
      ),
      c_d = list(
        df = data.frame(c = logical(), d = logical(), e = logical()),
        keys = list(c("c", "d"))
      ),
      a.1 = list(
        df = data.frame(a = logical(), b = logical()),
        keys = list("a")
      ),
      b.1 = list(
        df = data.frame(b = logical(), c = logical(), d = logical()),
        keys = list("b")
      )
    ),
    c("a", "b", "c", "d", "e")
  ),
  list(
    list("a", "b", "b", "b"),
    list("b.1", c("c", "d"), "c_d", c("c", "d"))
  )
)
print(db_merge)
unique(db_merge)

# reassignment
# can't change keys included in references
## Not run: keys(db)[[2]] &lt;- list("c")
# can't remove attributes included in keys
## Not run: attrs(db)[[2]] &lt;- list("c", "d")
# can't remove attributes included in references
## Not run: attrs(db)[[1]] &lt;- c("a", "d")
db3 &lt;- db
# can change subset of schema, but loses references between altered and
# non-altered subsets
db3[2] &lt;- database(
  relation(
    list(d = list(df = data.frame(d = logical(), c = logical()), keys = list("d"))),
    attrs_order(db3)
  ),
  list()
)
print(db3) # note the schema's name doesn't change
# names(db3)[2] &lt;- "d" # this would change the name
keys(db3)[[2]] &lt;- list(character()) # removing keys first...
# for a database_schema, we could then change the attrs for
# the second database. For a created relation, this is not
# allowed.
## Not run: 
  attrs(db3)[[2]] &lt;- c("b", "c")
  names(records(db3)[[2]]) &lt;- c("b", "c")

## End(Not run)

# changing appearance priority for attributes
attrs_order(db3) &lt;- c("d", "c", "b", "a")
print(db3)

# changing relation schema names changes them in references
names(db3) &lt;- paste0(names(db3), "_long")
print(db3)

# reconstructing from components
db_recon &lt;- database(
  relation(
    Map(list, df = records(db), keys = keys(db)),
    attrs_order(db)
  ),
  references(db)
)
stopifnot(identical(db_recon, db))
db_recon2 &lt;- database(
  subrelations(db),
  references(db)
)
stopifnot(identical(db_recon2, db))

# can be a data frame column
data.frame(id = 1:2, relation = db)
</code></pre>

<hr>
<h2 id='database_schema'>Database schemas</h2><span id='topic+database_schema'></span>

<h3>Description</h3>

<p>Enhances a <code><a href="#topic+relation_schema">relation_schema</a></code> object with foreign key reference
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>database_schema(relation_schemas, references)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="database_schema_+3A_relation_schemas">relation_schemas</code></td>
<td>
<p>a <code><a href="#topic+relation_schema">relation_schema</a></code> object, as returned
by <code><a href="#topic+synthesise">synthesise</a></code> or <code><a href="#topic+relation_schema">relation_schema</a></code>.</p>
</td></tr>
<tr><td><code id="database_schema_+3A_references">references</code></td>
<td>
<p>a list of references, each
represented by a list containing four character elements. In order, the
elements are a scalar giving the name of the child (referrer) schema, a
vector giving the child attribute names, a scalar giving the name of the
parent (referee) schema, and a vector giving the parent attribute names. The
vectors must be of the same length and contain names for attributes present
in their respective schemas, and the parent attributes must form a key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="#topic+functional_dependency">functional_dependency</a></code> and <code><a href="#topic+relation_schema">relation_schema</a></code>,
<code>database_schema</code> is not designed to be vector-like: it only holds a
single database schema. This adheres to the usual package use case, where a
single data frame is being analysed at a time. However, it inherits from
<code><a href="#topic+relation_schema">relation_schema</a></code>, so is vectorised with respect to its relation
schemas.
</p>
<p>As with <code><a href="#topic+relation_schema">relation_schema</a></code>, duplicate relation schemas, after
ordering by attribute, are allowed, and can be removed with
<code><a href="base.html#topic+unique">unique</a></code>.
</p>
<p>References, i.e. foreign key references, are allowed to have different
attribute names in the child and parent relations; this can't occur in the
output for <code><a href="#topic+autoref">autoref</a></code> and <code><a href="#topic+normalise">normalise</a></code>.
</p>
<p>Subsetting removes any references that involve removed relation schemas.
Removing duplicates with <code><a href="base.html#topic+unique">unique</a></code> changes references involving
duplicates to involve the kept equivalent schemas instead. Renaming relation
schemas with <code><a href="base.html#topic+names">names&lt;-</a></code> also changes their names in
the references.
</p>


<h3>Value</h3>

<p>A <code>database_schema</code> object, containing <code>relation_schemas</code>
with <code>references</code> stored in an attribute of the same name.
References are stored with their attributes in the order they appear in
their respective relation schemas.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attrs">attrs</a></code>, <code><a href="#topic+keys">keys</a></code>, <code><a href="#topic+attrs_order">attrs_order</a></code>,
and <code><a href="#topic+references">references</a></code> for extracting parts of the information in a
<code>database_schema</code>; <code><a href="#topic+create">create</a></code> for creating a
<code><a href="#topic+database">database</a></code> object that uses the given schema; <code><a href="#topic+gv">gv</a></code>
for converting the schema into Graphviz code; <code><a href="#topic+rename_attrs">rename_attrs</a></code>
for renaming the attributes in <code>attrs_order</code>; <code><a href="#topic+reduce">reduce</a></code> for
filtering a schema's relations to those connected to a given relation by
foreign key references; <code><a href="#topic+subschemas">subschemas</a></code> to return the
<code><a href="#topic+relation_schema">relation_schema</a></code> that the given schema contains;
<code><a href="#topic+merge_empty_keys">merge_empty_keys</a></code> for combining relations with an empty key;
<code><a href="#topic+merge_schemas">merge_schemas</a></code> for combining relations with matching sets of
keys.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs &lt;- relation_schema(
  list(
    a = list(c("a", "b"), list("a")),
    b = list(c("b", "c"), list("b", "c"))
  ),
  attrs_order = c("a", "b", "c", "d")
)
ds &lt;- database_schema(
  rs,
  list(list("a", "b", "b", "b"))
)
print(ds)
attrs(ds)
keys(ds)
attrs_order(ds)
names(ds)
references(ds)

# relations can't reference themselves
## Not run: 
  database_schema(
    relation_schema(
      list(a = list("a", list("a"))),
      c("a", "b")
    ),
    list(list("a", "a", "a", "a"))
  )
  database_schema(
    relation_schema(
      list(a = list(c("a", "b"), list("a"))),
      c("a", "b")
    ),
    list(list("a", "b", "a", "a"))
  )

## End(Not run)

# an example with references between differently-named attributes
print(database_schema(
  relation_schema(
    list(
      citation = list(c("citer", "citee"), list(c("citer", "citee"))),
      article = list("article", list("article"))
    ),
    c("citer", "citee", "article")
  ),
  list(
    list("citation", "citer", "article", "article"),
    list("citation", "citee", "article", "article")
  )
))

# vector operations
ds2 &lt;- database_schema(
  relation_schema(
    list(
      e = list(c("a", "e"), list("e"))
    ),
    attrs_order = c("a", "e")
  ),
  list()
)
c(ds, ds2) # attrs_order attributes are merged
unique(c(ds, ds))

# subsetting
ds[1]
stopifnot(identical(ds[[1]], ds[1]))
ds[c(1, 2, 1, 2)] # replicates the foreign key references
c(ds[c(1, 2)], ds[c(1, 2)]) # doesn't reference between separate copies of ds
unique(ds[c(1, 2, 1, 2)]) # unique() also merges references

# another example of unique() merging references
ds_merge &lt;- database_schema(
  relation_schema(
    list(
      a = list(c("a", "b"), list("a")),
      b = list(c("b", "c", "d"), list("b")),
      c_d = list(c("c", "d", "e"), list(c("c", "d"))),
      a.1 = list(c("a", "b"), list("a")),
      b.1 = list(c("b", "c", "d"), list("b"))
    ),
    c("a", "b", "c", "d", "e")
  ),
  list(
    list("a", "b", "b", "b"),
    list("b.1", c("c", "d"), "c_d", c("c", "d"))
  )
)
print(ds_merge)
unique(ds_merge)

# reassignment
# can't change keys included in references
## Not run: keys(ds)[[2]] &lt;- list("c")
# can't remove attributes included in keys
## Not run: attrs(ds)[[2]] &lt;- list("c", "d")
# can't remove attributes included in references
## Not run: attrs(ds)[[1]] &lt;- c("a", "d")
ds3 &lt;- ds
# can change subset of schema, but loses references between altered and
# non-altered subsets
ds3[2] &lt;- database_schema(
  relation_schema(
    list(d = list(c("d", "c"), list("d"))),
    attrs_order(ds3)
  ),
  list()
)
print(ds3) # note the schema's name doesn't change
# names(ds3)[2] &lt;- "d" # this would change the name
keys(ds3)[[2]] &lt;- list(character()) # removing keys first...
attrs(ds3)[[2]] &lt;- c("b", "c") # so we can change the attrs legally
keys(ds3)[[2]] &lt;- list("b", "c") # add the new keys
# add the reference lost during subset replacement
references(ds3) &lt;- c(references(ds3), list(list("a", "b", "b", "b")))
stopifnot(identical(ds3, ds))

# changing appearance priority for attributes
attrs_order(ds3) &lt;- c("d", "c", "b", "a")
print(ds3)

# changing relation schema names changes them in references
names(ds3) &lt;- paste0(names(ds3), "_long")
print(ds3)

# reconstructing from components
ds_recon &lt;- database_schema(
  relation_schema(
    Map(list, attrs(ds), keys(ds)),
    attrs_order(ds)
  ),
  references(ds)
)
stopifnot(identical(ds_recon, ds))
ds_recon2 &lt;- database_schema(
  subschemas(ds),
  references(ds)
)
stopifnot(identical(ds_recon2, ds))

# can be a data frame column
data.frame(id = 1:2, schema = ds)
</code></pre>

<hr>
<h2 id='decompose'>Decompose a data frame based on given normalised dependencies</h2><span id='topic+decompose'></span>

<h3>Description</h3>

<p>Decomposes a data frame into several relations, based on the given database
schema. It's intended that the data frame satisfies all the functional
dependencies implied by the schema, such as if the schema was constructed
from the same data frame. If this is not the case, the function will returns
an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decompose(df, schema)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decompose_+3A_df">df</code></td>
<td>
<p>a data.frame, containing the data to be normalised.</p>
</td></tr>
<tr><td><code id="decompose_+3A_schema">schema</code></td>
<td>
<p>a database schema with foreign key references, such as given by
<code><a href="#topic+autoref">autoref</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the schema was constructed using approximate dependencies for the same
data frame, <code>decompose</code> returns an error, to prevent either duplicate records
or lossy decompositions. This is temporary: for the next update, we plan to
add an option to allow this, or to add &quot;approximate&quot; equivalents of databases
and database schemas.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+database">database</a></code> object, containing the data in <code>df</code>
within the database schema given in <code>schema</code>.
</p>

<hr>
<h2 id='dependant'>Dependants</h2><span id='topic+dependant'></span><span id='topic+dependant+3C-'></span>

<h3>Description</h3>

<p>Generic function, with the only given method fetching dependants for
functional dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dependant(x, ...)

dependant(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dependant_+3A_x">x</code></td>
<td>
<p>an R object. For the given method, a
<code><a href="#topic+functional_dependency">functional_dependency</a></code>.</p>
</td></tr>
<tr><td><code id="dependant_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="dependant_+3A_value">value</code></td>
<td>
<p>A character vector of the same length as <code>dependant(x, ...)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing dependants.
</p>

<hr>
<h2 id='detset'>Determinant sets</h2><span id='topic+detset'></span><span id='topic+detset+3C-'></span>

<h3>Description</h3>

<p>Generic function, with the only given method fetching determinant sets for
functional dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detset(x, ...)

detset(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detset_+3A_x">x</code></td>
<td>
<p>an R object. For the given method, a
<code><a href="#topic+functional_dependency">functional_dependency</a></code>.</p>
</td></tr>
<tr><td><code id="detset_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="detset_+3A_value">value</code></td>
<td>
<p>A character vector of the same length as <code>detset(x, ...)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing determinant sets, each consisting of a character
vector with unique elements.
</p>

<hr>
<h2 id='df_duplicated'>Determine Duplicate Elements</h2><span id='topic+df_duplicated'></span><span id='topic+df_unique'></span><span id='topic+df_anyDuplicated'></span><span id='topic+df_records'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code> &quot;determines which elements of a vector or data frame
are duplicates of elements with smaller subscripts, and returns a logical
vector indicating which elements (rows) are duplicates&quot;. However, as of R
4.1, calling this on a data frame with zero columns always returns an empty
logical vector. This has repercussions on other functions that use
<code>duplicated</code>, such as <code><a href="base.html#topic+unique">unique</a></code> and <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code>.
These functions add zero-column data frames as a special case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_duplicated(x, incomparables = FALSE, fromLast = FALSE, ...)

df_unique(x, incomparables = FALSE, fromLast = FALSE, ...)

df_anyDuplicated(x, incomparables = FALSE, fromLast = FALSE, ...)

df_records(x, use_rownames = FALSE, use_colnames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df_duplicated_+3A_x">x</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="df_duplicated_+3A_incomparables">incomparables</code></td>
<td>
<p>a vector of values that cannot be compared.
<code>FALSE</code> is a special value, meaning that all values can be
compared, and may be the only value accepted for methods other than
the default.  It will be coerced internally to the same type as
<code>x</code>.</p>
</td></tr>
<tr><td><code id="df_duplicated_+3A_fromlast">fromLast</code></td>
<td>
<p>logical indicating if duplication should be considered
from the reverse side, i.e., the last (or rightmost) of identical
elements would correspond to <code>duplicated = FALSE</code>.</p>
</td></tr>
<tr><td><code id="df_duplicated_+3A_...">...</code></td>
<td>
<p>arguments for particular methods.</p>
</td></tr>
<tr><td><code id="df_duplicated_+3A_use_rownames">use_rownames</code></td>
<td>
<p>a logical, FALSE by default, indicating whether row
values should keep the row names from <code>x</code>. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="df_duplicated_+3A_use_colnames">use_colnames</code></td>
<td>
<p>a logical, FALSE by default, indicating whether row
values should keep the column names from <code>x</code> for their elements.
Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>df_duplicated</code>, a logical vector with one element for each
row.
</p>
<p>For <code>df_unique</code>, a data frame is returned with the same
columns, but possible fewer rows (and with row names from the first
occurrences of the unique rows).
</p>
<p>For <code>df_anyDuplicated</code>, an integer or real vector of length
one with value the 1-based index of the first duplicate if any, otherwise
0.
</p>
<p>For <code>df_records</code>, a list of the row values in <code>x</code>. This is
based on a step in <code><a href="base.html#topic+duplicated.data.frame">duplicated.data.frame</a></code>. However, for data
frames with zero columns, special handling returns a list of empty row
values, one for each row in <code>x</code>. Without special handling, this step
returns an empty list. This was the cause for <code><a href="base.html#topic+duplicated">duplicated</a></code>
returning incorrect results for zero-column data frames in older versions
of R.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+df_rbind">df_rbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># row values for a 5x0 data frame
x &lt;- data.frame(a = 1:5)[, FALSE, drop = FALSE]
do.call(Map, unname(c(list, x))) # original step returns empty list
df_records(x) # corrected version preserves row count
</code></pre>

<hr>
<h2 id='df_equiv'>Test data frames for equivalence under row reordering</h2><span id='topic+df_equiv'></span>

<h3>Description</h3>

<p>A convenience function, mostly used to testing that <code><a href="#topic+rejoin">rejoin</a></code>
works as intended. It checks that data frames have the same dimensions and
column names, with duplicates allowed, then checks they contain the same
data. For the latter step, column names are made unique first, so columns
with duplicate names must be presented in the same order in both data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_equiv(df1, df2, digits = getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df_equiv_+3A_df1">df1</code>, <code id="df_equiv_+3A_df2">df2</code></td>
<td>
<p>Data frames.</p>
</td></tr>
<tr><td><code id="df_equiv_+3A_digits">digits</code></td>
<td>
<p>a positive integer, indicating how many significant digits are
to be used for numeric and complex variables. A value of NA results in no
rounding. By default, this uses <code>getOption("digits")</code>, similarly to
<code><a href="base.html#topic+format">format</a></code>. See the note in <code><a href="base.html#topic+print.default">print.default</a></code> about
digits &gt;= 16.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical.
</p>

<hr>
<h2 id='df_rbind'>Combine R Objects by Rows or Columns</h2><span id='topic+df_rbind'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+rbind">rbind</a></code> takes &quot;a sequence of vector, matrix or data-frame
arguments&quot;, and combines by rows for the latter. However, as of R 4.1,
calling this on data frame with zero columns always returns zero rows, due to
the issue mentioned for <code><a href="#topic+df_duplicated">df_duplicated</a></code>. This function adds
zero-column data frames as a special case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_rbind(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df_rbind_+3A_...">...</code></td>
<td>
<p>data frames.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the <code>...</code> arguments row-wise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+df_duplicated">df_duplicated</a></code>
</p>

<hr>
<h2 id='discover'>Dependency discovery with DFD</h2><span id='topic+discover'></span>

<h3>Description</h3>

<p>Finds all the minimal functional dependencies represented in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discover(
  df,
  accuracy,
  digits = getOption("digits"),
  full_cache = TRUE,
  store_cache = TRUE,
  skip_bijections = FALSE,
  exclude = character(),
  exclude_class = character(),
  dependants = names(df),
  detset_limit = ncol(df) - 1L,
  progress = FALSE,
  progress_file = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discover_+3A_df">df</code></td>
<td>
<p>a data.frame, the relation to evaluate.</p>
</td></tr>
<tr><td><code id="discover_+3A_accuracy">accuracy</code></td>
<td>
<p>a numeric in (0, 1]: the accuracy threshold required in order
to conclude a dependency.</p>
</td></tr>
<tr><td><code id="discover_+3A_digits">digits</code></td>
<td>
<p>a positive integer, indicating how many significant digits are
to be used for numeric and complex variables. A value of <code>NA</code> results
in no rounding. By default, this uses <code>getOption("digits")</code>, similarly
to <code><a href="base.html#topic+format">format</a></code>. See the &quot;Floating-point variables&quot; section below
for why this rounding is necessary for consistent results across different
machines. See the note in <code><a href="base.html#topic+print.default">print.default</a></code> about <code>digits &gt;=
  16</code>.</p>
</td></tr>
<tr><td><code id="discover_+3A_full_cache">full_cache</code></td>
<td>
<p>a logical, indicating whether to store information about
how sets of attributes group the relation records (stripped partitions).
Otherwise, only the number of groups is stored. Storing the stripped
partition is expected to let the algorithm run more quickly, but might be
inefficient for small data frames or small amounts of memory.</p>
</td></tr>
<tr><td><code id="discover_+3A_store_cache">store_cache</code></td>
<td>
<p>a logical, indicating whether to keep cached information
to use when finding dependencies for other dependants. This allows the
algorithm to run more quickly by not having to re-calculate information,
but takes up more memory.</p>
</td></tr>
<tr><td><code id="discover_+3A_skip_bijections">skip_bijections</code></td>
<td>
<p>a logical, indicating whether to skip some dependency
searches that are made redundant by discovered bijections between
attributes. This can significantly speed up the search if <code>df</code>
contains equivalent attributes early in column order, but results in
undefined behaviour if <code>accuracy &lt; 1</code>. See Details for more
information.</p>
</td></tr>
<tr><td><code id="discover_+3A_exclude">exclude</code></td>
<td>
<p>a character vector, containing names of attributes to not
consider as members of determinant sets. If names are given that aren't
present in <code>df</code>, the user is given a warning.</p>
</td></tr>
<tr><td><code id="discover_+3A_exclude_class">exclude_class</code></td>
<td>
<p>a character vector, indicating classes of attributes to
not consider as members of determinant_sets. Attributes are excluded if
they inherit from any given class.</p>
</td></tr>
<tr><td><code id="discover_+3A_dependants">dependants</code></td>
<td>
<p>a character vector, containing names of all attributes for
which to find minimal functional dependencies for which they are the
dependant. By default, this is all of the attribute names. A smaller set of
attribute names reduces the amount of searching required, so can reduce the
computation time if only some potential dependencies are of interest.</p>
</td></tr>
<tr><td><code id="discover_+3A_detset_limit">detset_limit</code></td>
<td>
<p>an integer, indicating the largest determinant set size
that should be searched for. By default, this is large enough to allow all
possible determinant sets. See Details for comments about the effect on the
result, and on the computation time.</p>
</td></tr>
<tr><td><code id="discover_+3A_progress">progress</code></td>
<td>
<p>a logical, for whether to display progress to the user during
dependency search in <code><a href="#topic+discover">discover</a></code>.</p>
</td></tr>
<tr><td><code id="discover_+3A_progress_file">progress_file</code></td>
<td>
<p>a scalar character or a connection. If <code>progress</code>
is non-zero, determines where the progress is written to, in the same way
as the <code>file</code> argument for <code><a href="base.html#topic+cat">cat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Column names for <code><a href="stats.html#topic+df">df</a></code> must be unique.
</p>
<p>The algorithm used for finding dependencies is DFD. This searches for
determinant sets for each dependent attribute (dependant) by traversing the
powerset of the other (non-excluded) attributes, and is equivalent to
depth-first.
</p>
<p>The implementation for DFD differs a little from the algorithm presented in
the original paper:
</p>

<ul>
<li><p> Some attributes, or attribute types, can be designated, ahead of
time, as not being candidate members for determinant sets. This reduces the
number of candidate determinant sets to be searched, saving time by not
searching for determinant sets that the user would remove later anyway.
</p>
</li>
<li><p> Attributes that have a single unique value, i.e. are
constant, get attributed a single empty determinant set. In the standard
DFD algorithm, they would be assigned all the other non-excluded attributes
as length-one determinant sets. Assigning them the empty set distinguishes
them as constant, allowing for special treatment at normalisation and later
steps.
</p>
</li>
<li><p> As was done in the original Python library, there is an extra case in
seed generation for when there are no discovered maximal non-dependencies.
In this case, we take all of the single-attribute nodes, then filter out by
minimal dependencies as usual. This is equivalent to taking the empty set
as the single maximal non-dependency.
</p>
</li>
<li><p> There are three results when checking whether a candidate node is
minimal/maximal. TRUE indicates the node is minimal/maximal, as usual.
FALSE has been split into FALSE and NA. NA indicates that we can not yet
determine whether the node is minimal/maximal. FALSE indicates that we have
determined that it is not minimal/maximal, and we can set its category as
such. This is done by checking whether any of its adjacent
subsets/supersets are dependencies/non-dependencies, instead of waiting to
exhaust the adjacent subsets/supersets to visit when picking the next node
to visit.
</p>
</li>
<li><p> We do not yet keep hashmaps to manage subset/superset relationships,
as described in Section 3.5 of the original paper.
</p>
</li>
<li> <p><code>skip_bijections</code> allows for additional optimisation for finding
functional dependencies when there are pairwise-equivalent attributes.
</p>
</li>
<li><p> Missing values (NA) are treated as a normal value, with NA = NA being
true, and x = NA being false for any non-NA value of x.
</p>
</li></ul>



<h4>Floating-point variables</h4>

<p>Numerical/complex values, i.e. floating-point values, represent difficulties
for stating functional dependencies. A fundamental condition for stating
functional dependencies is that we can compare two values for the same
variable, and they are equivalent or not equivalent.
</p>
<p>Usually, this is done by checking they're equal &ndash; this is the approach used
in <code>discover</code> &ndash; but we can use any comparison that is an equivalence
relation.
</p>
<p>However, checking floating-point values for equality is not simple. <code>==</code>
is not appropriate, even when comparing non-calculated values we've read from
a file, because how a given number is converted into a float can vary by
computer architecture, meaning that two values can be considered equal on one
computer, and not equal on another. This can happen even if they're both
using 64-bit R, and even though all R platforms work with values conforming
to the same standard (see <code><a href="base.html#topic+double">double</a></code>). For example,
<code class="reqn">8.54917750000000076227</code> and <code class="reqn">8.54917749999999898591</code> are converted into
different floating-point representations on x86, but the same representation
on ARM, resulting in inequality and equality respectively.
</p>
<p>For this and other reasons, checking numerical/complex values for
(near-)equality in R is usually done with <code><a href="base.html#topic+all.equal">all.equal</a></code>. This
determines values <code class="reqn">x</code> and <code class="reqn">y</code> to be equal if their absolute/relative
absolute difference is within some tolerance value. However, we can not use
this. Equivalence relations must be transitive: if we have values <code class="reqn">x</code>,
<code class="reqn">y</code>, and <code class="reqn">z</code>, and <code class="reqn">x</code> is equivalent to both <code class="reqn">y</code> and <code class="reqn">z</code>,
then <code class="reqn">y</code> and <code class="reqn">z</code> must also be equivalent. This tolerance-based
equivalence is not transitive: it is reasonably straightforward to set up
three values so that the outer values are far enough apart to be considered
non-equivalent, but the middle value is close enough to be considered
equivalent to both of them. Using this to determine functional dependencies,
therefore, could easily result in a large number of inconsistencies.
</p>
<p>This means we have no good option for comparing numerical/complex values
as-is for equivalence, with consistent results across different machines, so
we must treat them differently. We have three options:
</p>

<ul>
<li><p> Round/truncate the values, before comparison, to some low degree of precision;
</p>
</li>
<li><p> Coerce the values to another class before passing them into <code>discover</code>;
</p>
</li>
<li><p> Read values as characters if reading data from a file.
</p>
</li></ul>

<p><code>discover</code> takes the first option, with a default number of significant
digits low enough to ensure consistency across different machines. However,
the user can also use any of these options when processing the data before
passing it to <code>discover</code>. The third option, in particular, is
recommended if reading data from a file.
</p>



<h4>Skipping bijections</h4>

<p>Skipping bijections allows skipping redundant searches. For example, if the
search discovers that <code>A -&gt; B</code> and <code>B -&gt; A</code>, then only one of those
attributes is considered for the remainder of the search. Since the search
time increases exponentially with the number of attributes considered, this
can significantly speed up search times. At the moment, this is only be done
for bijections between single attributes, such as <code>A &lt;-&gt; B</code>; if <code>A
&lt;-&gt; {B, C}</code>, nothing is skipped. Whether bijections are skipped doesn't
affect which functional dependencies are present in the output, but it might
affect their order.
</p>
<p>Skipping bijections for approximate dependencies, i.e. when <code>accuracy &lt; 1</code>,
should be avoided: it can result in incorrect output, since an approximate
bijection doesn't imply equivalent approximate dependencies.
</p>



<h4>Limiting the determinant set size</h4>

<p>Setting <code>detset_limit</code> smaller than the largest-possible value has
different behaviour for different search algorithms, the result is always
that <code>discover(x, 1, detset_limit = n)</code> is equivalent to doing a full
search, <code>fds &lt;- discover(x, 1)</code>, then
filtering by determinant set size post-hoc, <code>fds[lengths(detset(fds)) &lt;=
n]</code>.
</p>
<p>For DFD, the naive way to implement it is by removing determinant sets larger
than the limit from the search tree for possible functional dependencies for
each dependant. However, this usually results in the search taking much more
time than without a limit.
</p>
<p>For example, suppose we search for determinant sets for a dependant that has
none (the dependant is the only key for <code>df</code>, for example). Using DFD,
we begin with a single attribute, then add other attributes one-by-one, since
every set gives a non-dependency. When we reach a maximum-size set, we can
mark all subsets as also being non-dependencies.
</p>
<p>With the default limit, there is only one maximum-size set, containing all of
the available attributes. If there are <code class="reqn">n</code> candidate attributes for
determinants, the search finishes after visiting <code class="reqn">n</code> sets.
</p>
<p>With a smaller limit <code class="reqn">k</code>, there are <code class="reqn">\binom{n}{k}</code> maximum-size sets
to explore. Since a DFD search adds or removes one attribute at each step,
this means the search must take at least <code class="reqn">k - 2 + 2\binom{n}{k}</code> steps,
which is larger than <code class="reqn">n</code> for all non-trivial cases <code class="reqn">0 &lt; k \leq n</code>.
</p>
<p>We therefore use a different approach, where any determinant sets above the
size limit are not allowed to be candidate seeds for new search paths, and
any discovered dependencies with a size above the limit are discard at the
end of the entire DFD search. This means that nodes for determinant sets
above the size limit are only visited in order to determine maximality of
non-dependencies within the size limit. It turns out to be rare that this
results in a significant speed-up, but it never results in the search having
to visit more nodes than it would without a size limit, so the average search
time is never made worse.
</p>



<h3>Value</h3>

<p>A <code><a href="#topic+functional_dependency">functional_dependency</a></code> object, containing the discovered
dependencies. The column names of <code>df</code> are stored in the <code>attrs</code>
attribute, in order, to serve as a default priority order for the
attributes during normalisation.
</p>


<h3>References</h3>

<p>Abedjan Z., Schulze P., Naumann F. (2014) DFD: efficient functional
dependency discovery. <em>Proceedings of the 23rd ACM International Conference
on Conference on Information and Knowledge Management (CIKM '14). New York,
U.S.A.</em>, 949&ndash;958.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example
discover(ChickWeight, 1)

# example with spurious dependencies
discover(CO2, 1)
# exclude attributes that can't be determinants.
# in this case, the numeric attributes are now
# not determined by anything, because of repeat measurements
# with no variable to mark them as such.
discover(CO2, 1, exclude_class = "numeric")
# include only dependencies with dependants of interest.
discover(CO2, 1, dependants = c("Treatment", "uptake"))
</code></pre>

<hr>
<h2 id='functional_dependency'>Functional dependency vectors</h2><span id='topic+functional_dependency'></span>

<h3>Description</h3>

<p>Creates a set of functional dependencies with length-one dependants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional_dependency(FDs, attrs_order, unique = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="functional_dependency_+3A_fds">FDs</code></td>
<td>
<p>a list of functional dependencies, in the form of two-elements
lists: the first element contains a character vector of all attributes in
the determinant set, and the second element contains the single dependent
attribute (dependant).</p>
</td></tr>
<tr><td><code id="functional_dependency_+3A_attrs_order">attrs_order</code></td>
<td>
<p>a character vector, giving the names of all attributes.
These need not be present in <code>FDs</code>, but all attributes in <code>FDs</code>
must be present in <code>attrs</code>.</p>
</td></tr>
<tr><td><code id="functional_dependency_+3A_unique">unique</code></td>
<td>
<p>a logical, TRUE by default, for whether to remove duplicate
dependencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When several sets of functional dependencies are concatenated, their
<code>attrs_order</code> attributes are merged, so as to preserve all of the
original attribute orders, if possible. If this is not possible, because the
orderings disagree, then the returned value of the <code>attrs_order</code>
attribute is their union instead.
</p>


<h3>Value</h3>

<p>A <code>functional_dependency</code> object, containing the list given in
<code>FDs</code>, with <code>attrs_order</code> an attribute of the same name.
Functional dependencies are returned with their determinant sets sorted
according to the attribute order in <code>attrs</code>. Any duplicates found
after sorting are removed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+detset">detset</a></code>, <code><a href="#topic+dependant">dependant</a></code>, and
<code><a href="#topic+attrs_order">attrs_order</a></code> for extracting parts of the information in a
<code>functional_dependency</code>; <code><a href="#topic+rename_attrs">rename_attrs</a></code>
for renaming the attributes in <code>attrs_order</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fds &lt;- functional_dependency(
  list(list(c("a", "b"), "c"), list(character(), "d")),
  attrs_order = c("a", "b", "c", "d")
)
print(fds)
detset(fds)
dependant(fds)
attrs_order(fds)

# vector operations
fds2 &lt;- functional_dependency(list(list("e", "a")), c("a", "e"))
c(fds, fds2) # attrs_order attributes are merged
unique(c(fds, fds))

# subsetting
fds[1]
fds[c(1, 2, 1)]
stopifnot(identical(fds[[2]], fds[2]))

# reassignment
fds3 &lt;- fds
fds3[2] &lt;- functional_dependency(list(list("a", "c")), attrs_order(fds3))
print(fds3)
detset(fds3)[[2]] &lt;- character()
dependant(fds3)[[2]] &lt;- "d"
stopifnot(identical(fds3, fds))
# changing appearance priority for attributes
attrs_order(fds3) &lt;- rev(attrs_order(fds3))
fds3

# reconstructing from components
fds_recon &lt;- functional_dependency(
 Map(list, detset(fds), dependant(fds)),
 attrs_order(fds)
)
stopifnot(identical(fds_recon, fds))

# can be a data frame column
data.frame(id = 1:2, fd = fds)

# (in)equality ignores header
stopifnot(all(fds3 == fds))
stopifnot(!any(fds != fds))
</code></pre>

<hr>
<h2 id='gv'>Generate Graphviz input text to plot objects</h2><span id='topic+gv'></span>

<h3>Description</h3>

<p>Produces text input for Graphviz to make an HTML diagram of a given object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gv(x, name = NA_character_, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gv_+3A_x">x</code></td>
<td>
<p>an object to be plotted.</p>
</td></tr>
<tr><td><code id="gv_+3A_name">name</code></td>
<td>
<p>a scalar character, giving the name of the object, if any. This
name is used for the resulting graph, to allow for easier combining of
graphs into a single diagram if required.</p>
</td></tr>
<tr><td><code id="gv_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of what is plotted are given in individual methods. There are
expected commonalities, which are described below.
</p>
<p>The object is expected to be one of the following:
</p>

<ul>
<li><p> an object whose elements have the same length. Examples would be
data frames, matrices, and other objects that can represent relations, with
names for the elements, and an optional name for the object itself.
</p>
</li>
<li><p> a graph of sub-objects, each of which represent a relation as
described above, possibly with connections between the objects, and an
optional name for the graph as a whole.
</p>
</li></ul>

<p>Each relation is presented as a record-like shape, with the following elements:
</p>

<ul>
<li><p> A optional header with the relation's name, and the number of (unique)
records.
</p>
</li>
<li><p> A set of rows, one for each attribute in the relation. These rows
have the following contents:
</p>

<ul>
<li><p> the attribute names.
</p>
</li>
<li><p> a depiction of the relation's (candidate) keys. Each
column represents a key, and a filled cell indicates that the attribute
in that row is in that key. The keys are given in lexical order, with
precedence given to keys with fewer attributes, and keys with attributes
that appear earlier in the original data frame's attribute order. Default
output from other package functions will thus have the primary key given
first. In the future, this will be changed to always give the primary key
first.
</p>
</li>
<li><p> optionally, the attribute types: specifically, the first element
when passing the attribute's values into <code><a href="base.html#topic+class">class</a></code>.
</p>
</li></ul>

</li></ul>

<p>Any foreign key references between relations are represented by one-way arrows,
one per attribute in the foreign key.
</p>
<p>If the object has a name, this name is attached to the resulting graph in
Graphviz. This is to allow easier combination of several such graphs into a
single image, if a user wishes to do so.
</p>


<h3>Value</h3>

<p>A scalar character, containing text input for Graphviz.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gv.data.frame">gv.data.frame</a></code>, <code><a href="#topic+gv.relation_schema">gv.relation_schema</a></code>,
<code><a href="#topic+gv.database_schema">gv.database_schema</a></code>, <code><a href="#topic+gv.relation">gv.relation</a></code>, and
<code><a href="#topic+gv.database">gv.database</a></code> for individual methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple data.frame example
txt_df &lt;- gv(ChickWeight, "chick")
cat(txt_df)
if (requireNamespace("DiagrammeR", quietly = TRUE)) {
  DiagrammeR::grViz(txt_df)
}
# simple database example
db &lt;- autodb(ChickWeight)
txt_db &lt;- gv(db)
cat(txt_db)
if (requireNamespace("DiagrammeR", quietly = TRUE)) {
  DiagrammeR::grViz(txt_db)
}
# simple relation schemas
rschema &lt;- synthesise(discover(ChickWeight, 1))
txt_rschema &lt;- gv(rschema)
cat(txt_rschema)
if (requireNamespace("DiagrammeR", quietly = TRUE)) {
  DiagrammeR::grViz(txt_rschema)
}
# simple database schema
dschema &lt;- normalise(discover(ChickWeight, 1))
txt_dschema &lt;- gv(dschema)
cat(txt_dschema)
DiagrammeR::grViz(txt_dschema)
# simple relations
rel &lt;- create(synthesise(discover(ChickWeight, 1)))
txt_rel &lt;- gv(rel)
cat(txt_rel)
if (requireNamespace("DiagrammeR", quietly = TRUE)) {
  DiagrammeR::grViz(txt_rel)
}
</code></pre>

<hr>
<h2 id='gv.data.frame'>Generate Graphviz input text to plot a data frame</h2><span id='topic+gv.data.frame'></span>

<h3>Description</h3>

<p>Produces text input for Graphviz to make an HTML diagram of a given data
frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
gv(x, name = NA_character_, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gv.data.frame_+3A_x">x</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="gv.data.frame_+3A_name">name</code></td>
<td>
<p>a character scalar, giving the name of the record, if any. The
name must be non-empty, since it is also used to name the single table in
the plot. Defaults to <code>NA</code>: if left missing, it is set to &quot;data&quot;.</p>
</td></tr>
<tr><td><code id="gv.data.frame_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rows in the plotted data frame include information about the attribute
classes.
</p>


<h3>Value</h3>

<p>A scalar character, containing text input for Graphviz.
</p>


<h3>See Also</h3>

<p>The generic <code><a href="#topic+gv">gv</a></code>.
</p>

<hr>
<h2 id='gv.database'>Generate Graphviz input text to plot databases</h2><span id='topic+gv.database'></span>

<h3>Description</h3>

<p>Produces text input for Graphviz to make an HTML diagram of a given database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'database'
gv(x, name = NA_character_, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gv.database_+3A_x">x</code></td>
<td>
<p>a database, as returned by <code><a href="#topic+autoref">autoref</a></code> or
<code><a href="#topic+autodb">autodb</a></code>.</p>
</td></tr>
<tr><td><code id="gv.database_+3A_name">name</code></td>
<td>
<p>a scalar character, giving the name of the database, if any. This
name is used for the resulting graph, to allow for easier combining of
graphs into a single diagram if required.</p>
</td></tr>
<tr><td><code id="gv.database_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each relation in the database is presented as a set of rows, one for each
attribute in the relation. These rows include information about the attribute
classes.
</p>


<h3>Value</h3>

<p>A scalar character, containing text input for Graphviz.
</p>


<h3>See Also</h3>

<p>The generic <code><a href="#topic+gv">gv</a></code>.
</p>

<hr>
<h2 id='gv.database_schema'>Generate Graphviz input text to plot database schemas</h2><span id='topic+gv.database_schema'></span>

<h3>Description</h3>

<p>Produces text input for Graphviz to make an HTML diagram of a given database
schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'database_schema'
gv(x, name = NA_character_, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gv.database_schema_+3A_x">x</code></td>
<td>
<p>a database schema, as given by <code><a href="#topic+normalise">normalise</a></code>,
<code><a href="#topic+synthesise">synthesise</a></code>, or <code><a href="#topic+autoref">autoref</a></code>.</p>
</td></tr>
<tr><td><code id="gv.database_schema_+3A_name">name</code></td>
<td>
<p>a character scalar, giving the name of the schema, if any.</p>
</td></tr>
<tr><td><code id="gv.database_schema_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each relation in the schema is presented as a set of rows, one for each
attribute in the relation. These rows do not include information about the
attribute classes.
</p>
<p>Any foreign key references are represented by arrows
between the attribute pairs.
</p>


<h3>Value</h3>

<p>A scalar character, containing text input for Graphviz.
</p>


<h3>See Also</h3>

<p>The generic <code><a href="#topic+gv">gv</a></code>.
</p>

<hr>
<h2 id='gv.relation'>Generate Graphviz input text to plot relations</h2><span id='topic+gv.relation'></span>

<h3>Description</h3>

<p>Produces text input for Graphviz to make an HTML diagram of a given relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relation'
gv(x, name = NA_character_, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gv.relation_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+relation">relation</a></code>.</p>
</td></tr>
<tr><td><code id="gv.relation_+3A_name">name</code></td>
<td>
<p>a character scalar, giving the name of the schema, if any.</p>
</td></tr>
<tr><td><code id="gv.relation_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each relation is presented as a set of rows, one for each
attribute in the relation. These rows include information about the
attribute classes.
</p>


<h3>Value</h3>

<p>A scalar character, containing text input for Graphviz.
</p>


<h3>See Also</h3>

<p>The generic <code><a href="#topic+gv">gv</a></code>.
</p>

<hr>
<h2 id='gv.relation_schema'>Generate Graphviz input text to plot relation schemas</h2><span id='topic+gv.relation_schema'></span>

<h3>Description</h3>

<p>Produces text input for Graphviz to make an HTML diagram of a given relation
schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relation_schema'
gv(x, name = NA_character_, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gv.relation_schema_+3A_x">x</code></td>
<td>
<p>a relation schema, as given by <code><a href="#topic+relation_schema">relation_schema</a></code> or
<code><a href="#topic+synthesise">synthesise</a></code>.</p>
</td></tr>
<tr><td><code id="gv.relation_schema_+3A_name">name</code></td>
<td>
<p>a character scalar, giving the name of the schema, if any.</p>
</td></tr>
<tr><td><code id="gv.relation_schema_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each relation in the schema is presented as a set of rows, one for each
attribute in the relation. These rows do not include information about the
attribute classes.
</p>


<h3>Value</h3>

<p>A scalar character, containing text input for Graphviz.
</p>


<h3>See Also</h3>

<p>The generic <code><a href="#topic+gv">gv</a></code>.
</p>

<hr>
<h2 id='insert'>Insert data</h2><span id='topic+insert'></span>

<h3>Description</h3>

<p>Generic function for inserting a data frame of data into an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert(x, vals, relations = names(x), all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insert_+3A_x">x</code></td>
<td>
<p>a relational data object, into which to insert data, such as a
<code><a href="#topic+relation">relation</a></code> or <code><a href="#topic+database">database</a></code> object.</p>
</td></tr>
<tr><td><code id="insert_+3A_vals">vals</code></td>
<td>
<p>a data frame, containing data to insert.</p>
</td></tr>
<tr><td><code id="insert_+3A_relations">relations</code></td>
<td>
<p>a character vector, containing names of elements of <code>x</code>
into which to insert data. By default, <code>insert</code> attempts to insert
data into every element.</p>
</td></tr>
<tr><td><code id="insert_+3A_all">all</code></td>
<td>
<p>a logical, indicating whether <code>vals</code> is required to contain
all attributes of all elements of <code>x[relations]</code>. By default, it is
not, and data is only inserted into elements of <code>x[relations]</code> whose
attributes are all present in <code>vals</code>.</p>
</td></tr>
<tr><td><code id="insert_+3A_...">...</code></td>
<td>
<p>further arguments pass on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended for inserting into an object that is itself
comprised of data frames, such as a <code><a href="#topic+relation">relation</a></code> or a
<code><a href="#topic+database">database</a></code>. The given methods have the following behaviour:
</p>

<ul>
<li><p> If an empty set of data is inserted, into a non-empty object element,
nothing happens.
</p>
</li>
<li><p> If an empty set of data is inserted into an empty object element, the
resulting element is also empty, but takes on the attribute/column classes
of the inserted data. This is done to prevent having to know attribute
classes during object creation.
</p>
</li>
<li><p> Insertion can fail if inserting would violate object constraints. For
example, databases cannot have data inserted that would violate
candidate/foreign key constraints.
</p>
</li>
<li><p> For other cases, the data is inserted in an object element in the
same way as using <code><a href="base.html#topic+rbind">rbind</a></code>, followed by <code><a href="base.html#topic+unique">unique</a></code>.
</p>
</li></ul>

<p>While key violations prevent insertion, re-insertion of existing records in
an object element does not. This makes insertion equivalent to an <code>INSERT OR
IGNORE</code> expression in SQL. In particular, it is somewhat like using this
expression in SQLite, since that implementation uses dynamic typing.
</p>
<p>If <code>vals</code> contains attributes not included in
<code><a href="#topic+attrs_order">attrs_order</a>(x)</code>, <code>insert</code> throws an error, since those
attributes can't be inserted.
</p>
<p>If a partial set of attributes is inserted, and <code>all</code> is <code>FALSE</code>,
then data is only inserted into components of <code>x[relations]</code> whose
required attributes are all present in <code>vals</code>. If <code>all</code> is
<code>TRUE</code>, <code>insert</code> returns an error instead. This is useful when
specifying <code>relations</code>: in that case, you often intend to insert
into all of the specified elements, so not including all the required
attributes is a mistake, and <code>all = TRUE</code> prevents it.
</p>
<p>If <code>all</code> is <code>TRUE</code>, <code>insert</code>
throws an error in this case: This ensures you insert into all members of a
specified value of <code>relations</code>.
</p>


<h3>Value</h3>

<p>An R object of the same class as <code>x</code>, containing the additional
new data.
</p>

<hr>
<h2 id='keys'>Relational data keys</h2><span id='topic+keys'></span><span id='topic+keys+3C-'></span>

<h3>Description</h3>

<p>Generic function, with the only given method fetching candidate key lists for
relation schemas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keys(x, ...)

keys(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keys_+3A_x">x</code></td>
<td>
<p>a relational schema object, such as a <code><a href="#topic+relation_schema">relation_schema</a></code>
or <code><a href="#topic+database_schema">database_schema</a></code> object, or a relational data object, such
as a <code><a href="#topic+relation">relation</a></code> or <code><a href="#topic+database">database</a></code> object.</p>
</td></tr>
<tr><td><code id="keys_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="keys_+3A_value">value</code></td>
<td>
<p>A list of lists of character vectors, of the same length as
<code>keys(x, ...)</code>. The number of keys for an element of <code>x</code> can be
changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing lists of unique character vectors, representing
candidate keys for each element of <code>x</code>.
</p>

<hr>
<h2 id='merge_empty_keys'>Merge relation schemas with empty keys</h2><span id='topic+merge_empty_keys'></span>

<h3>Description</h3>

<p>Merges an object's schemas with empty keys. The remaining such schema
contains all attributes contained in such schemas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_empty_keys(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_empty_keys_+3A_x">x</code></td>
<td>
<p>a relational schema object, such as a <code><a href="#topic+relation_schema">relation_schema</a></code>
or <code><a href="#topic+database_schema">database_schema</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not itself generic, but makes use of the generic functions
<code><a href="#topic+keys">keys</a></code> and <code><a href="#topic+merge_schemas">merge_schemas</a></code>. Any input class with
valid methods for these generic functions can be passed into this function.
</p>
<p>For <code><a href="#topic+database_schema">database_schema</a></code> objects, references involving the
schemas with empty keys are updated to refer to the merged schema.
</p>


<h3>Value</h3>

<p>An R object of the same class as <code>x</code>, where relations with an
empty key have been merged into a single relation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge_schemas">merge_schemas</a></code>, on which this function is based.
</p>

<hr>
<h2 id='merge_schemas'>Merge relation schemas in given pairs</h2><span id='topic+merge_schemas'></span>

<h3>Description</h3>

<p>Generic function that merges pairs of an object's schemas with matching sets
of keys. The remaining schemas contain all the attributes from the schemas
merged into them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_schemas(x, to_remove, merge_into, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_schemas_+3A_x">x</code></td>
<td>
<p>a relational schema object, such as a <code><a href="#topic+relation_schema">relation_schema</a></code>
or <code><a href="#topic+database_schema">database_schema</a></code> object.</p>
</td></tr>
<tr><td><code id="merge_schemas_+3A_to_remove">to_remove</code></td>
<td>
<p>an integer vector, giving the indices for schemas to be
merged into other schemas, then removed.</p>
</td></tr>
<tr><td><code id="merge_schemas_+3A_merge_into">merge_into</code></td>
<td>
<p>an integer vector of the same length as <code>to_remove</code>,
giving the indices for the schemas into which to merge.</p>
</td></tr>
<tr><td><code id="merge_schemas_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R object of the same class as <code>x</code>, where the relations have
been merged as indicated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge_empty_keys">merge_empty_keys</a></code>, which is based on this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs &lt;- relation_schema(
  list(
    a = list(c("a", "b"), list("a")),
    b = list(c("b", "c"), list("b")),
    b.1 = list(c("b", "d"), list("b")),
    d = list(c("d", "e"), list("d", "e"))
  ),
  letters[1:5]
)
ds &lt;- database_schema(
  rs,
  list(
    list("a", "b", "b", "b"),
    list("b.1", "d", "d", "d")
   )
)
merge_schemas(rs, 3, 2) # merging b and b.1
merge_schemas(ds, 3, 2) # also merging their references

# merging a schema into itself just removes it
merge_schemas(rs, 3, 3)
merge_schemas(ds, 3, 3)
</code></pre>

<hr>
<h2 id='normalise'>Create normalised database schemas from functional dependencies</h2><span id='topic+normalise'></span>

<h3>Description</h3>

<p>Creates a database schema from given functional dependencies, satisfying at
least third normal form, using Bernstein's synthesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(
  dependencies,
  single_ref = FALSE,
  ensure_lossless = TRUE,
  reduce_attributes = TRUE,
  remove_avoidable = FALSE,
  constants_name = "constants",
  progress = FALSE,
  progress_file = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise_+3A_dependencies">dependencies</code></td>
<td>
<p>a <code><a href="#topic+functional_dependency">functional_dependency</a></code> object, as given by
<code><a href="#topic+discover">discover</a></code>.</p>
</td></tr>
<tr><td><code id="normalise_+3A_single_ref">single_ref</code></td>
<td>
<p>a logical, FALSE by default. If TRUE, then only one
reference between each relation pair is kept when generating foreign key
references. If a pair has multiple references, the kept reference refers to
the earliest key for the child relation, as sorted by priority order.</p>
</td></tr>
<tr><td><code id="normalise_+3A_ensure_lossless">ensure_lossless</code></td>
<td>
<p>a logical, TRUE by default. If TRUE, and the
decomposition isn't lossless, an extra relation is added to make the
decomposition lossless.</p>
</td></tr>
<tr><td><code id="normalise_+3A_reduce_attributes">reduce_attributes</code></td>
<td>
<p>a logical, TRUE by default. If TRUE,
<code>dependencies</code> are checked for determinant attributes that are made
redundant by the other dependencies. This is redundant if
<code>dependencies</code> is output from <code>discover</code>, since there will be no
such redundant attributes.</p>
</td></tr>
<tr><td><code id="normalise_+3A_remove_avoidable">remove_avoidable</code></td>
<td>
<p>a logical, indicating whether to remove avoidable
attributes in relations. If so, then an attribute are removed from
relations if the keys can be changed such that it is not needed to preserve
the given functional dependencies.</p>
</td></tr>
<tr><td><code id="normalise_+3A_constants_name">constants_name</code></td>
<td>
<p>a scalar character, giving the name for any relation
created to store constant attributes. If this is the same as a generated
relation name, it will be changed, with a warning, to ensure that all
relations have a unique name.</p>
</td></tr>
<tr><td><code id="normalise_+3A_progress">progress</code></td>
<td>
<p>a logical, for whether to display progress to the user during
dependency search in <code><a href="#topic+discover">discover</a></code>.</p>
</td></tr>
<tr><td><code id="normalise_+3A_progress_file">progress_file</code></td>
<td>
<p>a scalar character or a connection. If <code>progress</code>
is non-zero, determines where the progress is written to, in the same way
as the <code>file</code> argument for <code><a href="base.html#topic+cat">cat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for applying <code><a href="#topic+synthesise">synthesise</a></code> and
<code><a href="#topic+autoref">autoref</a></code>, in order. For creating relation schemas and foreign
key references separately, use these functions directly. See both functions
for examples.
</p>
<p>For details on the synthesis algorithm used, see <code><a href="#topic+synthesise">synthesise</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+database_schema">database_schema</a></code> object, containing the synthesis
relation schemas and the created foreign key references.
</p>

<hr>
<h2 id='nudge'>Nudge meta-analysis data</h2><span id='topic+nudge'></span>

<h3>Description</h3>

<p>Data used for a meta-analysis on the effectiveness of nudges, i.e. choice
architecture interventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nudge
</code></pre>


<h3>Format</h3>

<p>A data frame with 447 effect size measurements and 25 columns:
</p>

<ol>
<li><p> publication_id, integer ID number for the publication. Note that
two publications were erroneously assigned the same ID number, so this
is not a unique publication identifier.
</p>
</li>
<li><p> study_id, integer ID number for the study.
</p>
</li>
<li><p> es_id, integer ID number for the effect size measured.
</p>
</li>
<li><p> reference, publication citation in &quot;Author(s) (year)&quot; format. Due
to two publications being assigned the same reference, this is also not a
unique publication identifier.
</p>
</li>
<li><p> title, title of the publication. Due to the error in assigning
publication ID numbers, this is the unique publication identifier within
the data set.
</p>
</li>
<li><p> year, year of the publication.
</p>
</li>
<li><p> location, geographical location of the intervention. This is given
as a factor, rather than an integer, using the information
provided in the codebook.
</p>
</li>
<li><p> domain, factor giving the intervention's behavioural domain.
</p>
</li>
<li><p> intervention_category, factor giving the intervention's category,
based on the taxonomy in Mnscher et al. (2016).
</p>
</li>
<li><p> intervention_technique, factor giving the intervention's technique,
based on the taxonomy in Mnscher et al. (2016).
</p>
</li>
<li><p> type_experiment, factor giving the type of experiment, as defined
by Harrison and List (2004).
</p>
</li>
<li><p> population, factor giving the intervention's target population.
This is given as a factor, rather than an integer, using the information
provided in the codebook.
</p>
</li>
<li><p> n_study, sample size of the overall study.
</p>
</li>
<li><p> n_comparison, combined sample size of the control and the
intervention for the measured effect size.
</p>
</li>
<li><p> n_control, sample size of the control condition for the
measured effect size.
</p>
</li>
<li><p> n_intervention, sample size of the intervention condition
for the measured effect size.
</p>
</li>
<li><p> binary_outcome, logical for whether the outcome scale is binary or
continuous.
</p>
</li>
<li><p> mean_control, mean of outcome for the control condition.
</p>
</li>
<li><p> sd_control, SD of outcome for the control condition.
</p>
</li>
<li><p> mean_intervention, mean of outcome for the intervention condition.
</p>
</li>
<li><p> sd_intervention, SD of outcome for the intervention condition.
</p>
</li>
<li><p> cohens_d, extracted effect size of intervention.
</p>
</li>
<li><p> variance_d, variance of extracted effect size.
</p>
</li>
<li><p> approximation, logical for whether effect size extraction involved
approximation.
</p>
</li>
<li><p> wansink, logical for whether the study was (co-)authored by Brian
Wansink. This was added on revision, because, a few years before
publication, Wansink had many papers retracted or corrected, due to
various questionable practices, resulting in Wansink being determined to
have committed scientific misconduct. This column was added to check
whether the findings were robust to the exclusion of non-retracted
studies by the Cornell Food and Brand Laboratory, of which Wansink was
the director.
</p>
</li></ol>



<h3>Source</h3>

<p><a href="https://osf.io/fywae/">https://osf.io/fywae/</a>
</p>


<h3>References</h3>

<p>Mertens S., Herberz M., Hahnel U. J. J., Brosch T. (2022) The
effectiveness of nudging: A meta-analysis of choice architecture
interventions across behavioral domains. <em>Proc. Natl. Acad. Sci. U.S.A.</em>, <strong>4</strong>,
119(1).
</p>

<hr>
<h2 id='records'>Relational data records</h2><span id='topic+records'></span><span id='topic+records+3C-'></span>

<h3>Description</h3>

<p>Generic function, for retrieving data contained in a database-like structure.
In particular, this is intended for such structures where the individual
relations can't be accessed with subsetting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>records(x, ...)

records(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="records_+3A_x">x</code></td>
<td>
<p>a relational data object, such as a <code><a href="#topic+relation">relation</a></code> or
<code><a href="#topic+database">database</a></code> object.</p>
</td></tr>
<tr><td><code id="records_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="records_+3A_value">value</code></td>
<td>
<p>A list of data frames of the same length as <code>records(x,
  ...)</code>, where each data frame has the same column names as that which it
will replace, in the same order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the relational data objects in <code>autodb</code>, <code><a href="#topic+relation">relation</a></code>
and <code><a href="#topic+database">database</a></code>, have subsetting methods that return relational
data objects, the data contained within them can't be accessed by subsetting.
This function is intended for accessing it instead.
</p>
<p>It's recommended to call <code>records</code> before doing any subsetting, since
subsetting on a relation data object does more work that will be thrown away,
such as subsetting on a <code><a href="#topic+database">database</a></code> checking whether foreign key
references should be removed.
</p>


<h3>Value</h3>

<p>A list containing data frames, with elements named for their
respective relations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- autodb(ChickWeight)
records(db) # data for Chick and Time_Chick relations

# ways to get data for subsets
records(db)[c(1, 2)]
records(db)[[1]]
records(db)$Chick

# subsetting first isn't recommended: removes foreign key
# reference as mentions, and you need to subset again anyway
records(db[[1]])[[1]]
</code></pre>

<hr>
<h2 id='reduce'>Remove relations not linked to the main relations</h2><span id='topic+reduce'></span>

<h3>Description</h3>

<p>Filters an object's relations, keeping only the main relations, and those
considered ancestors via foreign key references. Foreign key
references involving removed relations are also removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_+3A_x">x</code></td>
<td>
<p>An object whose relations are to be filtered.</p>
</td></tr>
<tr><td><code id="reduce_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details on how the main tables are chosen are given in individual methods.
</p>
<p>This function is mostly intended for simplifying a database, or a database
schema, for the purposes of exploration, particularly by examining plots.
While the filtering might remove important auxiliary relations, it's also
likely to remove any based on spurious dependencies, of which some databases
can contain many.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>, with the auxiliary relations
and foreign key references removed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduce.database_schema">reduce.database_schema</a></code>, <code><a href="#topic+reduce.database">reduce.database</a></code>.
</p>

<hr>
<h2 id='reduce.database'>Remove database relations not linked to the main relations</h2><span id='topic+reduce.database'></span>

<h3>Description</h3>

<p>Filters a database's relations, keeping only the main relations, and those
considered ancestors via foreign key references. Foreign
key references involving removed relations are also removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'database'
reduce(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce.database_+3A_x">x</code></td>
<td>
<p>A database, whose relations are to be filtered.</p>
</td></tr>
<tr><td><code id="reduce.database_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main relations are considered to be the relations with the largest number
of records.
</p>
<p>Using <code><a href="#topic+rejoin">rejoin</a></code> on the database resulting from <code>reduce</code> is
likely to fail or return incomplete results.
</p>


<h3>Value</h3>

<p>A database, with the auxiliary relations and foreign key
references removed.
</p>

<hr>
<h2 id='reduce.database_schema'>Remove database schema relations not linked to the given relations</h2><span id='topic+reduce.database_schema'></span>

<h3>Description</h3>

<p>Filters a database schema's relations, keeping only the given relations, and
those considered ancestors via foreign key references. Foreign key
references involving removed relations are also removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'database_schema'
reduce(x, main, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce.database_schema_+3A_x">x</code></td>
<td>
<p>A database schema, whose relations are to be filtered.</p>
</td></tr>
<tr><td><code id="reduce.database_schema_+3A_main">main</code></td>
<td>
<p>A character vector, containing names of relations to be
considered as the &quot;main&quot; relations.</p>
</td></tr>
<tr><td><code id="reduce.database_schema_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method takes a given set of main relations, rather than inferring them.
</p>
<p>Using <code><a href="#topic+rejoin">rejoin</a></code> on the database resulting from decomposing a data
frame with the reduced schema is likely to fail or return incomplete results.
</p>


<h3>Value</h3>

<p>A database schema, with the auxiliary relations and foreign key
references removed.
</p>

<hr>
<h2 id='references'>Schema references</h2><span id='topic+references'></span><span id='topic+references+3C-'></span>

<h3>Description</h3>

<p>Generic function, returning present (foreign key) references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>references(x, ...)

references(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="references_+3A_x">x</code></td>
<td>
<p>an R object with references, such as a <code><a href="#topic+database_schema">database_schema</a></code>
or <code><a href="#topic+database">database</a></code> object.</p>
</td></tr>
<tr><td><code id="references_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="references_+3A_value">value</code></td>
<td>
<p>A list, of the same length as <code>references</code>(x, ...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, giving references.
</p>

<hr>
<h2 id='rejoin'>Join a database into a data frame</h2><span id='topic+rejoin'></span>

<h3>Description</h3>

<p>Rejoins the relations in a database into a single data frame, if possible.
This is the inverse of calling <code><a href="#topic+autodb">autodb</a></code>, except that the rows
might be returned in a different order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rejoin(database)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rejoin_+3A_database">database</code></td>
<td>
<p>A database containing the data to be rejoined, as returned by
<code><a href="#topic+decompose">decompose</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rejoining algorithm might not use all of the given relations: it begins
with the relation with the largest number of records, then joins it with enough
relations to contain all of the present attributes. This is not limited to
relations that the starting relation is linked to by foreign keys, and is not
limited to them either, since in some cases this constraint would make it
impossible to rejoin with all of the present attributes.
</p>
<p>Since the algorithm may not use all of the given relations, the algorithm may
ignore some types of database inconsistency, where different relations hold
data inconsistent with each other. In this case, the rejoining will be lossy.
Rejoining the results of <code><a href="#topic+reduce">reduce</a></code> can also be lossy.
</p>
<p>Due to the above issues, the algorithm will be changed to use all of the
relations in the future.
</p>
<p>Not all databases can be represented as a single data frame. A simple example
is any database where the same attribute name is used for several difference
sources of data, since rejoining results in inappropriate merges.
</p>


<h3>Value</h3>

<p>A data frame, containing all information contained <code>database</code> if
it is lossless and self-consistent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example
db &lt;- autodb(ChickWeight)
rj &lt;- rejoin(db)
rj &lt;- rj[order(as.integer(rownames(rj))), ]
all(rj == ChickWeight) # TRUE

# showing rejoin() doesn't check for inconsistency:
# add another Chick table with the diets swapped
db2 &lt;- db[c(1, 2, 1)]
records(db2)[[3]]$Diet &lt;- rev(records(db2)[[3]]$Diet)
rj2 &lt;- rejoin(db2)
rj2 &lt;- rj2[order(as.integer(rownames(rj2))), ]
all(rj2 == ChickWeight) # TRUE
</code></pre>

<hr>
<h2 id='relation'>Relation vectors</h2><span id='topic+relation'></span>

<h3>Description</h3>

<p>Creates a set of relation schemas, including the relation's attributes and
candidate keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation(relations, attrs_order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relation_+3A_relations">relations</code></td>
<td>
<p>a named list of relations, in the form of two-element lists:
the first element contains a data frame, where the column names are the
attributes in the associated schema, and the second element contains a list
of character vectors, each representing a candidate key.</p>
</td></tr>
<tr><td><code id="relation_+3A_attrs_order">attrs_order</code></td>
<td>
<p>a character vector, giving the names of all attributes.
These need not be present in <code>schemas</code>, but all attributes in
<code>schemas</code> must be present in <code>attrs_order</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Relation vectors are unlikely to be needed by the user directly, since they
are essentially <code><a href="#topic+database">database</a></code> objects that can't have foreign key
references. They are mostly used to mirror the use of the vector-like
<code><a href="#topic+relation_schema">relation_schema</a></code> class for the <code><a href="#topic+database_schema">database_schema</a></code>
class to be a wrapper around. This makes creating a <code><a href="#topic+database">database</a></code>
from a <code><a href="#topic+relation_schema">relation_schema</a></code> a two-step process, where the two steps
can be done in either order: creation with <code><a href="#topic+create">create</a></code> and
<code><a href="#topic+insert">insert</a></code>, and adding references with
<code><a href="#topic+database_schema">database_schema</a></code> or <code><a href="#topic+database">database</a></code>.
</p>
<p>Duplicate schemas, after ordering by attribute, are allowed, and can be
removed with <code><a href="base.html#topic+unique">unique</a></code>.
</p>
<p>When several sets of relation schemas are concatenated, their
<code>attrs_order</code> attributes are merged, so as to preserve all of the original
attribute orders, if possible. If this is not possible, because the orderings
disagree, then the returned value of the <code>attrs_order</code> attribute is their
union instead.
</p>


<h3>Value</h3>

<p>A <code>relation</code> object, containing the list given in
<code>relations</code>, with <code>attrs_order</code> stored in an attribute of the
same name. Relation schemas are returned with their keys' attributes sorted
according to the attribute order in <code>attrs_order</code>, and the keys then
sorted by priority order. Attributes in the data frame are also sorted,
first by order of appearance in the sorted keys, then by order in
<code>attrs_order</code> for non-prime attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+records">records</a></code>, <code><a href="#topic+attrs">attrs</a></code>, <code><a href="#topic+keys">keys</a></code>, and
<code><a href="#topic+attrs_order">attrs_order</a></code> for extracting parts of the information in a
<code>relation_schema</code>; <code><a href="#topic+gv">gv</a></code> for converting the schema into
Graphviz code; <code><a href="#topic+rename_attrs">rename_attrs</a></code> for renaming the attributes in
<code>attrs_order</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rels &lt;- relation(
  list(
    a = list(
      df = data.frame(a = logical(), b = logical()),
      keys = list("a")
    ),
    b = list(
      df = data.frame(b = logical(), c = logical()),
      keys = list("b", "c")
    )
  ),
  attrs_order = c("a", "b", "c", "d")
)
print(rels)
records(rels)
attrs(rels)
stopifnot(identical(
  attrs(rels),
  lapply(records(rels), names)
))
keys(rels)
attrs_order(rels)
names(rels)

# inserting data
insert(rels, data.frame(a = 1L, b = 2L, c = 3L, d = 4L))
# data is only inserted into relations where all columns are given...
insert(rels, data.frame(a = 1L, b = 2L, c = 3L))
# and that are listed in relations argument
insert(
  rels,
  data.frame(a = 1L, b = 2L, c = 3L, d = 4L),
  relations = "a"
)

# vector operations
rels2 &lt;- relation(
  list(
    e = list(
      df = data.frame(a = logical(), e = logical()),
      keys = list("e")
    )
  ),
  attrs_order = c("a", "e")
)
c(rels, rels2) # attrs_order attributes are merged
unique(c(rels, rels))

# subsetting
rels[1]
rels[c(1, 2, 1)]
stopifnot(identical(rels[[1]], rels[1]))

# reassignment
rels3 &lt;- rels
rels3[2] &lt;- relation(
  list(
    d = list(
      df = data.frame(d = logical(), c = logical()),
      keys = list("d")
    )
  ),
  attrs_order(rels3)
)
print(rels3) # note the relation's name doesn't change
# names(rels3)[2] &lt;- "d" # this would change the name
keys(rels3)[[2]] &lt;- list(character()) # removing keys first...
# for a relation_schema, we could then change the attrs for
# the second relation. For a created relation, this is not
# allowed.
## Not run: 
  attrs(rels3)[[2]] &lt;- c("b", "c")
  names(records(rels3)[[2]]) &lt;- c("b", "c")

## End(Not run)

# changing appearance priority for attributes
rels4 &lt;- rels
attrs_order(rels4) &lt;- c("d", "c", "b", "a")
print(rels4)

# reconstructing from components
rels_recon &lt;- relation(
  Map(list, df = records(rels), keys = keys(rels)),
  attrs_order(rels)
)
stopifnot(identical(rels_recon, rels))

# can be a data frame column
data.frame(id = 1:2, relation = rels)
</code></pre>

<hr>
<h2 id='relation_schema'>Relation schema vectors</h2><span id='topic+relation_schema'></span>

<h3>Description</h3>

<p>Creates a set of relation schemas, including the relation's attributes and
candidate keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_schema(schemas, attrs_order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relation_schema_+3A_schemas">schemas</code></td>
<td>
<p>a named list of schemas, in the form of two-element lists: the
first element contains a character vector of all attributes in the relation
schema, and the second element contains a list of character vectors,
each representing a candidate key.</p>
</td></tr>
<tr><td><code id="relation_schema_+3A_attrs_order">attrs_order</code></td>
<td>
<p>a character vector, giving the names of all attributes.
These need not be present in <code>schemas</code>, but all attributes in
<code>schemas</code> must be present in <code>attrs_order</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Duplicate schemas, after ordering by attribute, are allowed, and can be
removed with <code style="white-space: pre;">&#8288;\code{\link{unique}}&#8288;</code>.
</p>
<p>When several sets of relation schemas are concatenated, their
<code>attrs_order</code> attributes are merged, so as to preserve all of the original
attribute orders, if possible. If this is not possible, because the orderings
disagree, then the returned value of the <code>attrs_order</code> attribute is their
union instead.
</p>


<h3>Value</h3>

<p>A <code>relation_schema</code> object, containing the list given in
<code>schemas</code>, with <code>attrs_order</code> stored in an attribute of the same
name. Relation schemas are returned with their keys' attributes sorted
according to the attribute order in <code>attrs_order</code>, and the keys then
sorted by priority order. Attributes in the schema are also sorted, first
by order of appearance in the sorted keys, then by order in
<code>attrs_order</code> for non-prime attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attrs">attrs</a></code>, <code><a href="#topic+keys">keys</a></code>, and
<code><a href="#topic+attrs_order">attrs_order</a></code> for extracting parts of the information in a
<code>relation_schema</code>; <code><a href="#topic+create">create</a></code> for creating a
<code><a href="#topic+relation">relation</a></code> object that uses the given schema; <code><a href="#topic+gv">gv</a></code>
for converting the schema into Graphviz code; <code><a href="#topic+rename_attrs">rename_attrs</a></code>
for renaming the attributes in <code>attrs_order</code>;
<code><a href="#topic+merge_empty_keys">merge_empty_keys</a></code> for combining relations with an empty key;
<code><a href="#topic+merge_schemas">merge_schemas</a></code> for combining relations with matching sets of
keys.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>schemas &lt;- relation_schema(
  list(
    a = list(c("a", "b"), list("a")),
    b = list(c("b", "c"), list("b", "c"))
  ),
  attrs_order = c("a", "b", "c", "d")
)
print(schemas)
attrs(schemas)
keys(schemas)
attrs_order(schemas)
names(schemas)

# vector operations
schemas2 &lt;- relation_schema(
  list(
    e = list(c("a", "e"), list("e"))
  ),
  attrs_order = c("a", "e")
)
c(schemas, schemas2) # attrs_order attributes are merged
unique(c(schemas, schemas))

# subsetting
schemas[1]
schemas[c(1, 2, 1)]
stopifnot(identical(schemas[[1]], schemas[1]))

# reassignment
schemas3 &lt;- schemas
schemas3[2] &lt;- relation_schema(
  list(d = list(c("d", "c"), list("d"))),
  attrs_order(schemas3)
)
print(schemas3) # note the schema's name doesn't change
# names(schemas3)[2] &lt;- "d" # this would change the name
keys(schemas3)[[2]] &lt;- list(character()) # removing keys first...
attrs(schemas3)[[2]] &lt;- c("b", "c") # so we can change the attrs legally
keys(schemas3)[[2]] &lt;- list("b", "c") # add the new keys
stopifnot(identical(schemas3, schemas))

# changing appearance priority for attributes
attrs_order(schemas3) &lt;- c("d", "c", "b", "a")
print(schemas3)

# reconstructing from components
schemas_recon &lt;- relation_schema(
  Map(list, attrs(schemas), keys(schemas)),
  attrs_order(schemas)
)
stopifnot(identical(schemas_recon, schemas))

# can be a data frame column
data.frame(id = 1:2, schema = schemas)
</code></pre>

<hr>
<h2 id='rename_attrs'>Rename relational data attributes</h2><span id='topic+rename_attrs'></span>

<h3>Description</h3>

<p>Generic function, for renaming attributes present in a database-like
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_attrs(x, names, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_attrs_+3A_x">x</code></td>
<td>
<p>an object with an <code>attrs_order</code> attribute. This includes
relational schema objects, such as a <code><a href="#topic+relation_schema">relation_schema</a></code> or
<code><a href="#topic+database_schema">database_schema</a></code> object, relational data objects, such as a
<code><a href="#topic+relation">relation</a></code> or <code><a href="#topic+database">database</a></code> object, and
<code><a href="#topic+functional_dependency">functional_dependency</a></code> objects.</p>
</td></tr>
<tr><td><code id="rename_attrs_+3A_names">names</code></td>
<td>
<p>a character vector of the same length as <code>attrs_order(x)</code>,
with no duplicated elements, to be used as the new attribute names.</p>
</td></tr>
<tr><td><code id="rename_attrs_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has a different intended use to re-assigning
<code><a href="#topic+attrs_order">attrs_order</a></code>: that is intended only for rearranging the order of
the attributes, without renaming them. This is intended for renaming the
attributes without re-ordering them.
</p>


<h3>Value</h3>

<p>A relational object of the same type as <code>x</code>, with attributes
renamed consistently across the whole object.
</p>

<hr>
<h2 id='subrelations'>Database subrelations</h2><span id='topic+subrelations'></span>

<h3>Description</h3>

<p>Generic function, returning subrelations for <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subrelations(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subrelations_+3A_x">x</code></td>
<td>
<p>an R object, intended to be some sort of database-like object that
contains relations, such as a <code><a href="#topic+database">database</a></code> object.</p>
</td></tr>
<tr><td><code id="subrelations_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A relation-type object, or a list of relation-type objects if the
subrelation isn't vectorised. For example, if <code>x</code> is a
<code><a href="#topic+database">database</a></code>, the result is the contained <code><a href="#topic+relation">relation</a></code>.
</p>

<hr>
<h2 id='subschemas'>Schema subschemas</h2><span id='topic+subschemas'></span>

<h3>Description</h3>

<p>Generic function, returning subschemas for <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subschemas(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subschemas_+3A_x">x</code></td>
<td>
<p>an R object, intended to be some sort of schema that contains other
schemas, such as a <code><a href="#topic+database_schema">database_schema</a></code> object.</p>
</td></tr>
<tr><td><code id="subschemas_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A schema-type object, or a list of schema-type objects if the
subschema isn't vectorised. For example, if <code>x</code> is a
<code><a href="#topic+database_schema">database_schema</a></code>, the result is the contained
<code><a href="#topic+relation_schema">relation_schema</a></code>.
</p>

<hr>
<h2 id='synthesise'>Synthesise relation schemas from functional dependencies</h2><span id='topic+synthesise'></span>

<h3>Description</h3>

<p>Synthesises the dependency relationships in dependencies into a database
schema satisfying at least third normal form, using Bernstein's synthesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthesise(
  dependencies,
  ensure_lossless = TRUE,
  reduce_attributes = TRUE,
  remove_avoidable = FALSE,
  constants_name = "constants",
  progress = FALSE,
  progress_file = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="synthesise_+3A_dependencies">dependencies</code></td>
<td>
<p>a <code><a href="#topic+functional_dependency">functional_dependency</a></code> object, as given by
<code><a href="#topic+discover">discover</a></code>.</p>
</td></tr>
<tr><td><code id="synthesise_+3A_ensure_lossless">ensure_lossless</code></td>
<td>
<p>a logical, TRUE by default. If TRUE, and the
decomposition isn't lossless, an extra relation is added to make the
decomposition lossless.</p>
</td></tr>
<tr><td><code id="synthesise_+3A_reduce_attributes">reduce_attributes</code></td>
<td>
<p>a logical, TRUE by default. If TRUE,
<code>dependencies</code> are checked for determinant attributes that are made
redundant by the other dependencies. This is redundant if
<code>dependencies</code> is output from <code>discover</code>, since there will be no
such redundant attributes.</p>
</td></tr>
<tr><td><code id="synthesise_+3A_remove_avoidable">remove_avoidable</code></td>
<td>
<p>a logical, indicating whether to remove avoidable
attributes in relations. If so, then an attribute are removed from
relations if the keys can be changed such that it is not needed to preserve
the given functional dependencies.</p>
</td></tr>
<tr><td><code id="synthesise_+3A_constants_name">constants_name</code></td>
<td>
<p>a scalar character, giving the name for any relation
created to store constant attributes. If this is the same as a generated
relation name, it will be changed, with a warning, to ensure that all
relations have a unique name.</p>
</td></tr>
<tr><td><code id="synthesise_+3A_progress">progress</code></td>
<td>
<p>a logical, for whether to display progress to the user during
dependency search in <code><a href="#topic+discover">discover</a></code>.</p>
</td></tr>
<tr><td><code id="synthesise_+3A_progress_file">progress_file</code></td>
<td>
<p>a scalar character or a connection. If <code>progress</code>
is non-zero, determines where the progress is written to, in the same way
as the <code>file</code> argument for <code><a href="base.html#topic+cat">cat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bernstein's synthesis is a synthesis algorithm for normalisation of a set of
dependencies into a set of relations that are in third normal form. This
implementation is based on the version given in the referenced paper.
</p>
<p>The implementation also includes a common additional step, to ensure that the
resulting decomposition is lossless, i.e. a relation satisfying the given
dependencies can be perfectly reconstructed from the relations given by the
decomposition. This is done by adding an additional relation, containing a
key for all the original attributes, if one is not already present.
</p>
<p>As an additional optional step, schemas are checked for &quot;avoidable&quot;
attributes, that can be removed without loss of information.
</p>
<p>Constant attributes, i.e. those whose only determinant set is empty, get
assigned to a relation with no keys.
</p>
<p>Output is independent of the order of the input dependencies: schemas are
sorted according to their simplest keys.
</p>
<p>Schemas are sorted before ensuring for losslessness, or removing avoidable
attributes. As a result, neither optional step changes the order of the
schemas, and ensuring losslessness can only add an extra schema to the end of
the output vector.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+relation_schema">relation_schema</a></code> object, containing the synthesised
relation schemas.
</p>


<h3>References</h3>

<p>3NF synthesis algorithm: Bernstein P. A. (1976) Synthesizing third normal
form relations from functional dependencies. <em>ACM Trans. Database Syst.</em>,
<strong>1, 4</strong>, 277&ndash;298.
</p>
<p>Removal of avoidable attributes: Ling T., Tompa F. W., Kameda T. (1981) An
improved third normal form for relational databases. <em>ACM Trans. Database
Syst.</em>, <strong>6, 2</strong>, 329&ndash;346.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example 6.24 from The Theory of Relational Databases by David Maier
# A &lt;-&gt; B, AC -&gt; D, AC -&gt; E, BD -&gt; C
deps &lt;- functional_dependency(
  list(
    list("A", "B"),
    list("B", "A"),
    list(c("A", "C"), "D"),
    list(c("A", "C"), "E"),
    list(c("B", "D"), "C")
  ),
  attrs_order = c("A", "B", "C", "D", "E")
)
synthesise(deps, remove_avoidable = FALSE)
synthesise(deps, remove_avoidable = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
