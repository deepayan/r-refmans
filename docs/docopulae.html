<!DOCTYPE html><html lang="en"><head><title>Help for package docopulae</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {docopulae}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#docopulae'><p>Design of Experiments with Copulas</p></a></li>
<li><a href='#buildf'><p>Build probability density or mass Function</p></a></li>
<li><a href='#Defficiency'><p>D Efficiency</p></a></li>
<li><a href='#DerivLogf'><p>Build Derivative Function for Log f</p></a></li>
<li><a href='#design'><p>Design</p></a></li>
<li><a href='#Dsensitivity'><p>D Sensitivity</p></a></li>
<li><a href='#fisherI'><p>Fisher Information</p></a></li>
<li><a href='#getM'><p>Get Fisher Information</p></a></li>
<li><a href='#grow.grid'><p>Grow Grid</p></a></li>
<li><a href='#integrateA'><p>Integrate Alternative</p></a></li>
<li><a href='#nint_ERROR'><p>Space Validation Errors</p></a></li>
<li><a href='#nint_expandSpace'><p>Expand Space</p></a></li>
<li><a href='#nint_funcDim'><p>Function Dimension</p></a></li>
<li><a href='#nint_gridDim'><p>Grid Dimension</p></a></li>
<li><a href='#nint_integrate'><p>Integrate</p></a></li>
<li><a href='#nint_integrateNCube'><p>Integrate Hypercube</p></a></li>
<li><a href='#nint_integrateNFunc'><p>Integrate N Function</p></a></li>
<li><a href='#nint_intvDim'><p>Interval Dimension</p></a></li>
<li><a href='#nint_scatDim'><p>Scatter Dimension</p></a></li>
<li><a href='#nint_space'><p>Space</p></a></li>
<li><a href='#nint_tanTransform'><p>Tangent Transform</p></a></li>
<li><a href='#nint_transform'><p>Transform Integral</p></a></li>
<li><a href='#nint_TYPE'><p>Dimension Type Attribute Values</p></a></li>
<li><a href='#nint_validateSpace'><p>Validate Space</p></a></li>
<li><a href='#numDerivLogf'><p>Build Derivative Function for Log f</p></a></li>
<li><a href='#param'><p>Parametric Model</p></a></li>
<li><a href='#plot.desigh'><p>Plot Design</p></a></li>
<li><a href='#print.nint_space'><p>Print Space</p></a></li>
<li><a href='#reduce'><p>Reduce Design</p></a></li>
<li><a href='#rowmatch'><p>Row Matching</p></a></li>
<li><a href='#roworder'><p>Matrix Ordering Permutation</p></a></li>
<li><a href='#rowsduplicated'><p>Determine Duplicate Rows</p></a></li>
<li><a href='#seq1'><p>Sequence Generation</p></a></li>
<li><a href='#update.param'><p>Update Parametric Model</p></a></li>
<li><a href='#wDefficiency'><p>Weighted D Efficiency</p></a></li>
<li><a href='#wDsensitivity'><p>Weighted D Sensitivity</p></a></li>
<li><a href='#Wynn'><p>Wynn</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Optimal Designs for Copula Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-10-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Rappold [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Rappold &lt;arappold@gmx.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A direct approach to optimal designs for copula models based on
    the Fisher information. Provides flexible functions for building joint PDFs,
    evaluating the Fisher information and finding optimal designs. It includes an
    extensible solution to summation and integration called 'nint', functions for
    transforming, plotting and comparing designs, as well as a set of tools for
    common low-level tasks.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>copula, numDeriv, Deriv (&ge; 3.8.5), cubature, SparseGrid,
mvtnorm, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.tandfonline.com/doi/full/10.1080/02331888.2015.1111892">http://www.tandfonline.com/doi/full/10.1080/02331888.2015.1111892</a>
<a href="https://github.com/arappold/docopulae">https://github.com/arappold/docopulae</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/arappold/docopulae/issues">https://github.com/arappold/docopulae/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-10-26 10:04:33 UTC; arappold</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-10-26 10:20:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='docopulae'>Design of Experiments with Copulas</h2><span id='topic+docopulae'></span><span id='topic+docopulae-package'></span>

<h3>Description</h3>

<p>A direct approach to optimal designs for copula models based on the Fisher information.
Provides flexible functions for building joint PDFs, evaluating the Fisher information and finding optimal designs.
It includes an extensible solution to summation and integration called 'nint', functions for transforming, plotting and comparing designs, as well as a set of tools for common low-level tasks.
</p>


<h3>Details</h3>

<p>This package builds upon the theoretical result on optimal designs for copula models developed by Elisa Perrone and Werner G. Müller.
In their paper named 'Optimal designs for copula models' they introduce an equivalence theorem of Kiefer-Wolfowitz type for D-optimality along with examples and the proof.
The proof for D_A-optimality is analogous and is mentioned in an upcoming paper currently under double blind review.
</p>


<h3>References</h3>

<p>E. Perrone &amp; W.G. Müller (2016) Optimal designs for copula models, Statistics, 50:4, 917-929, DOI: 10.1080/02331888.2015.1111892
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dsensitivity">Dsensitivity</a></code>
</p>

<hr>
<h2 id='buildf'>Build probability density or mass Function</h2><span id='topic+buildf'></span>

<h3>Description</h3>

<p><code>buildf</code> builds a joint probability density or mass function from marginal distributions and a copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildf(margins, continuous, copula, parNames = NULL,
  simplifyAndCache = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildf_+3A_margins">margins</code></td>
<td>
<p>either </p>

<ul>
<li> <p><code>function(y, theta, ...)</code>, where <code>theta</code> is a list of parameters.
It shall return a column matrix of two, the probability densities and cumulative distributions.
</p>
</li>
<li><p> a list of pairs of expressions, each named <code>"pdf"</code> and <code>"cdf"</code>, the probability density and cumulative distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="buildf_+3A_continuous">continuous</code></td>
<td>
<p><code>TRUE</code> if margins are continuous. See details.</p>
</td></tr>
<tr><td><code id="buildf_+3A_copula">copula</code></td>
<td>
<p>if <code>margins</code> is </p>

<ul>
<li><p> a function then either a copula object from package <span class="pkg">copula</span> or <code>function(u, theta, ...)</code>, a probability density function if <code>continuous</code> else a cumulative distribution function.
</p>
</li>
<li><p> a list then either a copula object from package <span class="pkg">copula</span> which contains distribution expressions or an expression for the probability density if <code>continuous</code> else the cumulative distribution which uses <code>u1</code>,<code>u2</code>,...
</p>
</li></ul>
</td></tr>
<tr><td><code id="buildf_+3A_parnames">parNames</code></td>
<td>
<p>if </p>

<ul>
<li><p> (optional) <code>margins</code> is a function and <code>copula</code> is a copula object then a vector of names or indices, the sequence of copula parameters in <code>theta</code>.
<code>0</code> or <code>""</code> identifies copula parameters to skip.
</p>
</li>
<li> <p><code>margins</code> is a list and <code>copula</code> is a copula object then a named list of names or indices, mapping parameters in <code>theta</code> to copula parameter variables.
See <code>copula@exprdist</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="buildf_+3A_simplifyandcache">simplifyAndCache</code></td>
<td>
<p>(if <code>margins</code> is a list) simplify and cache the result using <code><a href="Deriv.html#topic+Simplify">Simplify</a></code> and <code><a href="Deriv.html#topic+Cache">Cache</a></code> from package <span class="pkg">Deriv</span> if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that expressions are not validated.
</p>
<p>If <code>continuous</code> is <code>FALSE</code>, dimensionality shall be 2 and both dimensions shall be discrete.
The joint probability mass is defined by
</p>
<p style="text-align: center;"><code class="reqn">C(F_{1}(y_{1}),F_{2}(y_{2}))-C(F_{1}(y_{1}-1),F_{2}(y_{2}))-C(F_{1}(y_{1}),F_{2}(y_{2}-1))+C(F_{1}(y_{1}-1),F_{2}(y_{2}-1))</code>
</p>

<p>where <code class="reqn">C</code>, <code class="reqn">F_{1}</code>, and <code class="reqn">F_{2}</code> depend on <code class="reqn">\theta</code> and <code class="reqn">y_{i}\ge0</code>.
</p>


<h3>Value</h3>

<p><code>buildf</code> returns <code>function(y, theta, ...)</code>, the joint probability density or mass function.
</p>


<h3>See Also</h3>

<p><span class="pkg">copula</span>, <code><a href="Deriv.html#topic+Simplify">Simplify</a></code>, <code><a href="Deriv.html#topic+Cache">Cache</a></code>, <code><a href="#topic+numDerivLogf">numDerivLogf</a></code>, <code><a href="#topic+DerivLogf">DerivLogf</a></code>, <code><a href="#topic+fisherI">fisherI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## for an actual use case see examples for param

library(copula)
library(mvtnorm)

## build bivariate normal
margins = function(y, theta) {
    mu = c(theta$mu1, theta$mu2)
    cbind(dnorm(y, mean=mu, sd=1), pnorm(y, mean=mu, sd=1))
}
copula = normalCopula()

# args: function, copula object, parNames
f1 = buildf(margins, TRUE, copula, parNames='alpha1')
f1 # uses theta[['alpha1']] as copula parameter

## evaluate and plot
theta = list(mu1=2, mu2=-3, alpha1=0.4)

y1 = seq(0, 4, length.out=51)
y2 = seq(-5, -1, length.out=51)
v1 = outer(y1, y2, function(z1, z2) apply(cbind(z1, z2), 1, f1, theta))
str(v1)
contour(y1, y2, v1, main='f1', xlab='y1', ylab='y2')

## compare with bivariate normal from mvtnorm
copula@parameters = theta$alpha1
v = outer(y1, y2, function(yy1, yy2)
    dmvnorm(cbind(yy1, yy2), mean=c(theta$mu1, theta$mu2),
                             sigma=getSigma(copula)))
all.equal(v1, v)


## build bivariate pdf with normal margins and Clayton copula
margins = list(list(pdf=quote(dnorm(y[1], theta$mu1, 1)),
                    cdf=quote(pnorm(y[1], theta$mu1, 1))),
               list(pdf=quote(dnorm(y[2], theta$mu2, 1)),
                    cdf=quote(pnorm(y[2], theta$mu2, 1))))
copula = claytonCopula()

# args: list, copula object, parNames
f2 = buildf(margins, TRUE, copula, list(alpha='alpha1'))
f2

## evaluate and plot
theta = list(mu1=2, mu2=-3, alpha1=2)

y1 = seq(0, 4, length.out=51)
y2 = seq(-5, -1, length.out=51)
v2 = outer(y1, y2, function(z1, z2) apply(cbind(z1, z2), 1, f2, theta))
str(v2)
contour(y1, y2, v2, main='f2', xlab='y1', ylab='y2')

## build alternatives
cexpr = substituteDirect(copula@exprdist$pdf,
                         list(alpha=quote(theta$alpha1)))
# args: list, expression
f3 = buildf(margins, TRUE, cexpr) # equivalent to f2
f3

margins = function(y, theta) {
    mu = c(theta$mu1, theta$mu2)
    cbind(dnorm(y, mean=mu, sd=1), pnorm(y, mean=mu, sd=1))
}
# args: function, copula object, parNames
f4 = buildf(margins, TRUE, copula, 'alpha1')
f4

cpdf = function(u, theta) {
    copula@parameters = theta$alpha1
    dCopula(u, copula)
}
# args: function, function
f5 = buildf(margins, TRUE, cpdf) # equivalent to f4
f5

# args: function, copula object
copula@parameters = 2
f6 = buildf(margins, TRUE, copula)
f6 # uses copula@parameters

cpdf = function(u, theta) dCopula(u, copula)
# args: function, function
f7 = buildf(margins, TRUE, cpdf) # equivalent to f6
f7

## compare all
vv = lapply(list(f3, f4, f5, f6, f7), function(f)
    outer(y1, y2, function(z1, z2) apply(cbind(z1, z2), 1, f, theta)))
sapply(vv, all.equal, v2)

</code></pre>

<hr>
<h2 id='Defficiency'>D Efficiency</h2><span id='topic+Defficiency'></span>

<h3>Description</h3>

<p><code>Defficiency</code> computes the D-, D_s or D_A-efficiency measure for a design with respect to a reference design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Defficiency(des, ref, mod, A = NULL, parNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Defficiency_+3A_des">des</code></td>
<td>
<p>a design.</p>
</td></tr>
<tr><td><code id="Defficiency_+3A_ref">ref</code></td>
<td>
<p>a design, the reference.</p>
</td></tr>
<tr><td><code id="Defficiency_+3A_mod">mod</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="Defficiency_+3A_a">A</code></td>
<td>
<p>for </p>

<ul>
<li><p> D-efficiency: <code>NULL</code>
</p>
</li>
<li><p> D_s-efficiency: a vector of names or indices, the subset of parameters of interest.
</p>
</li>
<li><p> D_A-efficiency: either </p>

<ul>
<li><p> directly: a matrix without row names.
</p>
</li>
<li><p> indirectly: a matrix with row names corresponding to the parameters.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="Defficiency_+3A_parnames">parNames</code></td>
<td>
<p>a vector of names or indices, the subset of parameters to use.
Defaults to the parameters for which the Fisher information is available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indices supplied to argument <code>A</code> correspond to the subset of parameters defined by argument <code>parNames</code>.
</p>
<p>D efficiency is defined as
</p>
<p style="text-align: center;"><code class="reqn">\left(\frac{\left|M(\xi,\bar{\boldsymbol{\theta}})\right|}{\left|M(\xi^{*},\bar{\boldsymbol{\theta}})\right|}\right)^{1/n}</code>
</p>

<p>and D_A efficiency as
</p>
<p style="text-align: center;"><code class="reqn">\left(\frac{\left|A^{T}M(\xi,\bar{\boldsymbol{\theta}})^{-1}A\right|^{-1}}{\left|A^{T}M(\xi^{*},\bar{\boldsymbol{\theta}})^{-1}A\right|^{-1}}\right)^{1/s}</code>
</p>



<h3>Value</h3>

<p><code>Defficiency</code> returns a single numeric.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+design">design</a></code>, <code><a href="#topic+param">param</a></code>, <code><a href="#topic+wDefficiency">wDefficiency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

<hr>
<h2 id='DerivLogf'>Build Derivative Function for Log f</h2><span id='topic+DerivLogf'></span><span id='topic+Deriv2Logf'></span>

<h3>Description</h3>

<p><code>DerivLogf</code>/<code>Deriv2Logf</code> builds a function that evaluates to the first/second derivative of <code>log(f(y, theta, ...))</code> with respect to <code>theta[[i]]</code>/<code>theta[[i]]</code> and <code>theta[[j]]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DerivLogf(f, parNames, preSimplify = T, ...)

Deriv2Logf(f, parNames, preSimplify = T, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DerivLogf_+3A_f">f</code></td>
<td>
<p><code>function(y, theta, ...)</code>, where <code>theta</code> is a list of parameters.</p>
</td></tr>
<tr><td><code id="DerivLogf_+3A_parnames">parNames</code></td>
<td>
<p>a vector of names or indices, the subset of parameters to use.</p>
</td></tr>
<tr><td><code id="DerivLogf_+3A_presimplify">preSimplify</code></td>
<td>
<p>simplify the body of <code>f</code> using functions from package <span class="pkg">Deriv</span>.</p>
</td></tr>
<tr><td><code id="DerivLogf_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="Deriv.html#topic+Deriv">Deriv</a></code> from package <span class="pkg">Deriv</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code>numDerivLogf</code> relies on the package <span class="pkg">numDeriv</span> and therefore uses finite differences to evaluate the derivatives, <code>DerivLogf</code> utilizes the package <span class="pkg">Deriv</span> to build sub functions for each parameter in <code>parNames</code>.
The same is true for <code>Deriv2Logf</code>.
</p>


<h3>Value</h3>

<p><code>DerivLogf</code> returns <code>function(y, theta, i, ...)</code> which evaluates to the first derivative of <code>log(f(y, theta, ...))</code> with respect to <code>theta[[i]]</code>.
The attribute <code>"d"</code> contains the list of sub functions.
</p>
<p><code>Deriv2Logf</code> returns <code>function(y, theta, i, j, ...)</code> which evaluates to the second derivative of <code>log(f(y, theta, ...))</code> with respect to <code>theta[[i]]</code> and <code>theta[[j]]</code>.
The attribute <code>"d2"</code> contains the list of sub functions.
</p>


<h3>See Also</h3>

<p><span class="pkg">Deriv</span>, <code><a href="Deriv.html#topic+Deriv">Deriv</a></code> in package <span class="pkg">Deriv</span>, <code><a href="#topic+buildf">buildf</a></code>, <code><a href="#topic+numDerivLogf">numDerivLogf</a></code>, <code><a href="#topic+fisherI">fisherI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param
## mind the gain regarding runtime compared to numDeriv

</code></pre>

<hr>
<h2 id='design'>Design</h2><span id='topic+design'></span>

<h3>Description</h3>

<p><code>design</code> creates a custom design object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design(x, w, tag = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_+3A_x">x</code></td>
<td>
<p>a row matrix of points.</p>
</td></tr>
<tr><td><code id="design_+3A_w">w</code></td>
<td>
<p>a vector of weights.
Length shall be equal to the number of rows in <code>x</code> and sum shall be equal to <code>1</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_tag">tag</code></td>
<td>
<p>a list containing additional information about the design.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>design</code> returns an object of <code>class</code> <code>"desigh"</code>.
An object of class <code>"desigh"</code> is a list containing at least this function's arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Wynn">Wynn</a></code>, <code><a href="#topic+reduce">reduce</a></code>, <code><a href="#topic+getM">getM</a></code>, <code><a href="#topic+plot.desigh">plot.desigh</a></code>, <code><a href="#topic+Defficiency">Defficiency</a></code>, <code><a href="#topic+update.param">update.param</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

<hr>
<h2 id='Dsensitivity'>D Sensitivity</h2><span id='topic+Dsensitivity'></span>

<h3>Description</h3>

<p><code>Dsensitivity</code> builds a sensitivity function for the D-, D_s or D_A-optimality criterion which relies on defaults to speed up evaluation.
<code>Wynn</code> for instance requires this behaviour/protocol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dsensitivity(A = NULL, parNames = NULL, defaults = list(x = NULL,
  desw = NULL, desx = NULL, mod = NULL))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dsensitivity_+3A_a">A</code></td>
<td>
<p>for </p>

<ul>
<li><p> D-optimality: <code>NULL</code>
</p>
</li>
<li><p> D_s-optimality: a vector of names or indices, the subset of parameters of interest.
</p>
</li>
<li><p> D_A-optimality: either </p>

<ul>
<li><p> directly: a matrix without row names.
</p>
</li>
<li><p> indirectly: a matrix with row names corresponding to the parameters.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="Dsensitivity_+3A_parnames">parNames</code></td>
<td>
<p>a vector of names or indices, the subset of parameters to use.
Defaults to the parameters for which the Fisher information is available.</p>
</td></tr>
<tr><td><code id="Dsensitivity_+3A_defaults">defaults</code></td>
<td>
<p>a named list of default values.
The value <code>NULL</code> is equivalent to absence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indices and rows of an unnamed matrix supplied to argument <code>A</code> correspond to the subset of parameters defined by argument <code>parNames</code>.
</p>
<p>For efficiency reasons the returned function won't complain about <em>missing arguments</em> immediately, leading to strange errors.
Please ensure that all arguments are specified at all times.
This behaviour might change in future releases.
</p>


<h3>Value</h3>

<p><code>Dsensitivity</code> returns <code>function(x=NULL, desw=NULL, desx=NULL, mod=NULL)</code>, the sensitivity function.
It's attributes contain this function's arguments.
</p>


<h3>References</h3>

<p>E. Perrone &amp; W.G. Müller (2016) Optimal designs for copula models, Statistics, 50:4, 917-929, DOI: 10.1080/02331888.2015.1111892
</p>


<h3>See Also</h3>

<p><code><a href="#topic+docopulae">docopulae</a></code>, <code><a href="#topic+param">param</a></code>, <code><a href="#topic+wDsensitivity">wDsensitivity</a></code>, <code><a href="#topic+Wynn">Wynn</a></code>, <code><a href="#topic+plot.desigh">plot.desigh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

<hr>
<h2 id='fisherI'>Fisher Information</h2><span id='topic+fisherI'></span>

<h3>Description</h3>

<p><code>fisherI</code> utilizes <code>nint_integrate</code> to evaluate the Fisher information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisherI(ff, theta, parNames, yspace, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisherI_+3A_ff">ff</code></td>
<td>
<p>either </p>

<ul>
<li> <p><code>function(y, theta, i, j, ...)</code> which evaluates to the inner part of the expectation integral/sum.
</p>
</li>
<li> <p><code>list(f=function(y, theta, ...), d2logf=function(y, theta, i, j, ...))</code> (recommended)
</p>
</li>
<li> <p><code>list(f=function(y, theta, ...), dlogf=function(y, theta, i, ...))</code>
</p>
</li></ul>

<p>where <code>f</code> is the joint probability density function and <code>dlogf</code>/<code>d2logf</code> is the first/second derivative of <code>log(f)</code> with respect to <code>theta[[i]]</code>/<code>theta[[i]]</code> and <code>theta[[j]]</code>.</p>
</td></tr>
<tr><td><code id="fisherI_+3A_theta">theta</code></td>
<td>
<p>the list of parameters.</p>
</td></tr>
<tr><td><code id="fisherI_+3A_parnames">parNames</code></td>
<td>
<p>a vector of names or indices, the subset of parameters to use.</p>
</td></tr>
<tr><td><code id="fisherI_+3A_yspace">yspace</code></td>
<td>
<p>a space, the support of <code>y</code>.</p>
</td></tr>
<tr><td><code id="fisherI_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>ff</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>ff</code> is a list, it shall contain <code>dlogf</code> xor <code>d2logf</code>.
</p>


<h3>Value</h3>

<p><code>fisherI</code> returns a named matrix, the Fisher information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildf">buildf</a></code>, <code><a href="#topic+numDerivLogf">numDerivLogf</a></code>, <code><a href="#topic+DerivLogf">DerivLogf</a></code>, <code><a href="#topic+nint_space">nint_space</a></code>, <code><a href="#topic+nint_transform">nint_transform</a></code>, <code><a href="#topic+nint_integrate">nint_integrate</a></code>, <code><a href="#topic+param">param</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

<hr>
<h2 id='getM'>Get Fisher Information</h2><span id='topic+getM'></span>

<h3>Description</h3>

<p><code>getM</code> returns the Fisher information corresponding to a model and a design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getM(mod, des)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getM_+3A_mod">mod</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="getM_+3A_des">des</code></td>
<td>
<p>a design.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getM</code> returns a named matrix, the Fisher information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param">param</a></code>, <code><a href="#topic+design">design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

<hr>
<h2 id='grow.grid'>Grow Grid</h2><span id='topic+grow.grid'></span>

<h3>Description</h3>

<p><code>grow.grid</code> creates a data frame like <code>expand.grid</code>.
The order of rows is adjusted to represent a growing grid with respect to resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow.grid(x, random = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grow.grid_+3A_x">x</code></td>
<td>
<p>a list of vectors.</p>
</td></tr>
<tr><td><code id="grow.grid_+3A_random">random</code></td>
<td>
<p><code>TRUE</code> if order of rows within each level of resolution should be random.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>grow.grid</code> returns a data frame like <code>expand.grid</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update.param">update.param</a></code>
</p>

<hr>
<h2 id='integrateA'>Integrate Alternative</h2><span id='topic+integrateA'></span>

<h3>Description</h3>

<p><code>integrateA</code> is a tolerance wrapper for <code>integrate</code>.
It allows <code>integrate</code> to reach the maximum number of subdivisions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateA(f, lower, upper, ..., subdivisions = 100L,
  rel.tol = .Machine$double.eps^0.25, abs.tol = rel.tol,
  stop.on.error = TRUE, keep.xy = FALSE, aux = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="integrateA_+3A_f">f</code>, <code id="integrateA_+3A_lower">lower</code>, <code id="integrateA_+3A_upper">upper</code>, <code id="integrateA_+3A_...">...</code>, <code id="integrateA_+3A_subdivisions">subdivisions</code>, <code id="integrateA_+3A_rel.tol">rel.tol</code>, <code id="integrateA_+3A_abs.tol">abs.tol</code>, <code id="integrateA_+3A_stop.on.error">stop.on.error</code>, <code id="integrateA_+3A_keep.xy">keep.xy</code>, <code id="integrateA_+3A_aux">aux</code></td>
<td>
<p>see <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+integrate">integrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = function(x) ifelse(x &lt; 0, cos(x), sin(x))
#curve(f(x), -1, 1)
try(integrate(f, -1, 1, subdivisions=1)$value)
integrateA(f, -1, 1, subdivisions=1)$value
integrateA(f, -1, 1, subdivisions=2)$value
integrateA(f, -1, 1, subdivisions=3)$value
</code></pre>

<hr>
<h2 id='nint_ERROR'>Space Validation Errors</h2><span id='topic+nint_ERROR'></span><span id='topic+nint_ERROR_DIM_TYPE'></span><span id='topic+nint_ERROR_SCATTER_LENGTH'></span><span id='topic+nint_ERROR_SPACE_TYPE'></span><span id='topic+nint_ERROR_SPACE_DIM'></span>

<h3>Description</h3>

<p>Error codes for space validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_ERROR_DIM_TYPE # = -1001

nint_ERROR_SCATTER_LENGTH # = -1002

nint_ERROR_SPACE_TYPE # = -1003

nint_ERROR_SPACE_DIM # = -1004
</code></pre>


<h3>Format</h3>

<p>integer</p>


<h3>Details</h3>

<p><code>nint_ERROR_DIM_TYPE</code>: dimension type attribute does not exist or is invalid.
</p>
<p><code>nint_ERROR_SCATTER_LENGTH</code>: scatter dimensions have different lengths.
</p>
<p><code>nint_ERROR_SPACE_TYPE</code>: object not of type <code>"nint_space"</code>.
</p>
<p><code>nint_ERROR_SPACE_DIM</code>: subspaces have different number of dimensions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_validateSpace">nint_validateSpace</a></code>, <code><a href="#topic+nint_space">nint_space</a></code>
</p>

<hr>
<h2 id='nint_expandSpace'>Expand Space</h2><span id='topic+nint_expandSpace'></span>

<h3>Description</h3>

<p><code>nint_expandSpace</code> expands a space or list structure of spaces to a list of true subspaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_expandSpace(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_expandSpace_+3A_x">x</code></td>
<td>
<p>a space or list structure of spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nint_expandSpace</code> returns a list of spaces.
Each space is a true subspace.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_space">nint_space</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s = nint_space(list(nint_intvDim(1, 2),
                    nint_intvDim(3, 4)),
               list(nint_intvDim(-Inf, 0),
                    nint_gridDim(c(0)),
                    nint_intvDim(0, Inf))
               )
s
nint_expandSpace(s)
</code></pre>

<hr>
<h2 id='nint_funcDim'>Function Dimension</h2><span id='topic+nint_funcDim'></span>

<h3>Description</h3>

<p><code>nint_funcDim</code> defines a functionally dependent dimension.
It shall depend solely on the previous dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_funcDim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_funcDim_+3A_x">x</code></td>
<td>
<p><code>function(x)</code>, where <code>x</code> is the partially realized point in the space.
It shall return an object of type <code>nint_intvDim</code> or a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obviously if <code>x</code> returns an object of type <code>nint_intvDim</code> the dimension is continuous, and discrete otherwise.
</p>
<p>As the argument to <code>x</code> is only partially defined the user has to ensure that the function solely depends on values up to the current dimension.
</p>


<h3>Value</h3>

<p><code>nint_scatDim</code> returns its argument with the dimension type attribute set to <code>nint_TYPE_FUNC_DIM</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_TYPE">nint_TYPE</a></code>, <code><a href="#topic+nint_space">nint_space</a></code>
</p>

<hr>
<h2 id='nint_gridDim'>Grid Dimension</h2><span id='topic+nint_gridDim'></span>

<h3>Description</h3>

<p><code>nint_gridDim</code> is defined by a sequence of values.
Together with other grid dimensions it defines a dense grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_gridDim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_gridDim_+3A_x">x</code></td>
<td>
<p>a vector of any type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imagine using <code>expand.grid</code> to create a row matrix of points.
</p>


<h3>Value</h3>

<p><code>nint_scatDim</code> returns its argument with the dimension type attribute set to <code>nint_TYPE_GRID_DIM</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_TYPE">nint_TYPE</a></code>, <code><a href="#topic+nint_space">nint_space</a></code>
</p>

<hr>
<h2 id='nint_integrate'>Integrate</h2><span id='topic+nint_integrate'></span>

<h3>Description</h3>

<p><code>nint_integrate</code> performs summation and integration of a scalar-valued function over a space or list structure of spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_integrate(f, space, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_integrate_+3A_f">f</code></td>
<td>
<p>the scalar-valued function (integrand) to be integrated.</p>
</td></tr>
<tr><td><code id="nint_integrate_+3A_space">space</code></td>
<td>
<p>a space or list structure of spaces.</p>
</td></tr>
<tr><td><code id="nint_integrate_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nint_integrate</code> uses <code>nint_integrateNCube</code> and <code>nint_integrateNFunc</code> to handle interval and function dimensions.
See their help pages on how to deploy different solutions.
</p>
<p>The order of dimensions is optimized for efficiency.
Therefore interchangeability (except for function dimensions) is assumed.
</p>


<h3>Value</h3>

<p><code>nint_integrate</code> returns a single numeric.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_space">nint_space</a></code>, <code><a href="#topic+nint_transform">nint_transform</a></code>, <code><a href="#topic+nint_integrateNCube">nint_integrateNCube</a></code>, <code><a href="#topic+nint_integrateNFunc">nint_integrateNFunc</a></code>, <code><a href="#topic+fisherI">fisherI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## discrete
## a) scatter
s = nint_space(nint_scatDim(1:3),
               nint_scatDim(c(0, 2, 5)))
s
## (1, 0), (2, 2), (3, 5)
nint_integrate(function(x) abs(x[1] - x[2]), s) # 1 + 0 + 2 == 3

## b) grid
s = nint_space(nint_gridDim(1:3),
               nint_gridDim(c(0, 2, 5)))
s
## (1, 0), (1, 2), (1, 5), (2, 0), ..., (3, 2), (3, 5)
nint_integrate(function(x) ifelse(sum(x) &lt; 5, 1, 0), s) # 5


## continous
## c)
s = nint_space(nint_intvDim(1, 3),
               nint_intvDim(1, Inf))
s
nint_integrate(function(x) 1/x[2]**2, s) # 2

## d) infinite, no transform
s = nint_space(nint_intvDim(-Inf, Inf))
nint_integrate(sin, s) # 0

## e) infinite, transform
s = nint_space(nint_intvDim(-Inf, Inf),
               nint_intvDim(-Inf, Inf))
## probability integral transform
tt = nint_transform(function(x) prod(dnorm(x)), s, list(list(
    dIdcs=1:2,
    g=function(x) pnorm(x),
    giDg=function(y) { t1 = qnorm(y); list(t1, dnorm(t1)) })))
tt$space
nint_integrate(tt$f, tt$space) # 1


## functionally dependent
## f) area of triangle
s = nint_space(nint_intvDim(0, 1),
               nint_funcDim(function(x) nint_intvDim(x[1]/2, 1 - x[1]/2)) )
s
nint_integrate(function(x) 1, s) # 0.5

## g) area of circle
s = nint_space(
    nint_intvDim(-1, 1),
    nint_funcDim(function(x) nint_intvDim( c(-1, 1) * sin(acos(x[1])) ))
)
s
nint_integrate(function(x) 1, s) # pi

## h) volume of sphere
s = nint_space(s[[1]],
               s[[2]],
               nint_funcDim(function(x) {
                   r = sin(acos(x[1]))
                   nint_intvDim(c(-1, 1) * r*cos(asin(x[2] / r)))
               }) )
s
nint_integrate(function(x) 1, s) # 4*pi/3
</code></pre>

<hr>
<h2 id='nint_integrateNCube'>Integrate Hypercube</h2><span id='topic+nint_integrateNCube'></span><span id='topic+nint_integrateNCube_integrate'></span><span id='topic+nint_integrateNCube_cubature'></span><span id='topic+nint_integrateNCube_SparseGrid'></span>

<h3>Description</h3>

<p>Interface to the integration over interval dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_integrateNCube(f, lowerLimit, upperLimit, ...)

nint_integrateNCube_integrate(integrate)

nint_integrateNCube_cubature(adaptIntegrate)

nint_integrateNCube_SparseGrid(createIntegrationGrid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_integrateNCube_+3A_integrate">integrate</code></td>
<td>
<p><code>function(f, lowerLimit, upperLimit, ...)</code> which calls <code>integrate</code>.</p>
</td></tr>
<tr><td><code id="nint_integrateNCube_+3A_adaptintegrate">adaptIntegrate</code></td>
<td>
<p><code>function(f, lowerLimit, upperLimit, ...)</code> which calls <code>cubature::adaptIntegrate</code>.</p>
</td></tr>
<tr><td><code id="nint_integrateNCube_+3A_createintegrationgrid">createIntegrationGrid</code></td>
<td>
<p><code>function(dimension)</code> which calls <code>SparseGrid::createIntegrationGrid</code>.</p>
</td></tr>
<tr><td><code id="nint_integrateNCube_+3A_f">f</code></td>
<td>
<p>the scalar-valued wrapper function to be integrated.</p>
</td></tr>
<tr><td><code id="nint_integrateNCube_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>the lower limits of integration.</p>
</td></tr>
<tr><td><code id="nint_integrateNCube_+3A_upperlimit">upperLimit</code></td>
<td>
<p>the upper limits of integration.</p>
</td></tr>
<tr><td><code id="nint_integrateNCube_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nint_integrate</code> uses <code>nint_integrateNCube</code> to handle interval dimensions.
See examples below on how to deploy different solutions.
</p>
<p>The function built by <code>nint_integrateNCube_integrate</code> calls <code>integrate</code> (argument) recursively.
The number of function evaluations therefore increases exponentially with the number of dimensions (<code>(subdivisions * 21) ** D</code> if <code>integrate</code>, the default, is used).
At the moment it is the default method because no additional package is required.
However, you most likely want to consider different solutions.
</p>
<p>The function built by <code>nint_integrateNCube_cubature</code> is a trivial wrapper for <code>cubature::adaptIntegrate</code>.
</p>
<p>The function built by <code>nint_integrateNCube_SparseGrid</code> is an almost trivial wrapper for <code>SparseGrid::createIntegrationGrid</code>.
It scales the grid to the integration region.
</p>


<h3>Value</h3>

<p><code>nint_integrateNCube</code> returns a single numeric.
</p>
<p><code>nint_integrateNCube_integrate</code> returns a recursive implementation for <code>nint_integrateNCube</code> based on one dimensional integration.
</p>
<p><code>nint_integrateNCube_cubature</code> returns a trivial implementation for <code>nint_integrateNCube</code> indirectly based on <code>cubature::adaptIntegrate</code>.
</p>
<p><code>nint_integrateNCube_SparseGrid</code> returns an implementation for <code>nint_integrateNCube</code> indirectly based on <code>SparseGrid::createIntegrationGrid</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_integrate">nint_integrate</a></code>
</p>
<p><code><a href="#topic+integrateA">integrateA</a></code>, <code><a href="stats.html#topic+integrate">integrate</a></code>
</p>
<p><code><a href="cubature.html#topic+adaptIntegrate">adaptIntegrate</a></code> in package <span class="pkg">cubature</span>
</p>
<p><code><a href="SparseGrid.html#topic+createIntegrationGrid">createIntegrationGrid</a></code> in package <span class="pkg">SparseGrid</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## integrate with defaults (stats::integrate)
nint_integrate(sin, nint_space(nint_intvDim(pi/4, 3*pi/4)))


dfltNCube = nint_integrateNCube

## prepare for integrateA
ncube = function(f, lowerLimit, upperLimit, ...) {
    cat('using integrateA\n')
    integrateA(f, lowerLimit, upperLimit, ..., subdivisions=2)
}
ncube = nint_integrateNCube_integrate(ncube)
unlockBinding('nint_integrateNCube', environment(nint_integrate))
assign('nint_integrateNCube', ncube, envir=environment(nint_integrate))

## integrate with integrateA
nint_integrate(sin, nint_space(nint_intvDim(pi/4, 3*pi/4)))


## prepare for cubature
ncube = function(f, lowerLimit, upperLimit, ...) {
    cat('using cubature\n')
    r = cubature::adaptIntegrate(f, lowerLimit, upperLimit, ..., maxEval=1e3)
    return(r$integral)
}
unlockBinding('nint_integrateNCube', environment(nint_integrate))
assign('nint_integrateNCube', ncube, envir=environment(nint_integrate))

## integrate with cubature
nint_integrate(sin, nint_space(nint_intvDim(pi/4, 3*pi/4)))


## prepare for SparseGrid
ncube = function(dimension) {
    cat('using SparseGrid\n')
    SparseGrid::createIntegrationGrid('GQU', dimension, 7)
}
ncube = nint_integrateNCube_SparseGrid(ncube)
unlockBinding('nint_integrateNCube', environment(nint_integrate))
assign('nint_integrateNCube', ncube, envir=environment(nint_integrate))

## integrate with SparseGrid
nint_integrate(sin, nint_space(nint_intvDim(pi/4, 3*pi/4)))


assign('nint_integrateNCube', dfltNCube, envir=environment(nint_integrate))
</code></pre>

<hr>
<h2 id='nint_integrateNFunc'>Integrate N Function</h2><span id='topic+nint_integrateNFunc'></span><span id='topic+nint_integrateNFunc_recursive'></span>

<h3>Description</h3>

<p>Inferface to the integration over function dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_integrateNFunc(f, funcs, x0, i0, ...)

nint_integrateNFunc_recursive(integrate1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_integrateNFunc_+3A_integrate1">integrate1</code></td>
<td>
<p><code>function(f, lowerLimit, upperLimit, ...)</code> which performs one dimensional integration.</p>
</td></tr>
<tr><td><code id="nint_integrateNFunc_+3A_f">f</code></td>
<td>
<p>the scalar-valued wrapper function to be integrated.</p>
</td></tr>
<tr><td><code id="nint_integrateNFunc_+3A_funcs">funcs</code></td>
<td>
<p>the list of function dimensions.</p>
</td></tr>
<tr><td><code id="nint_integrateNFunc_+3A_x0">x0</code></td>
<td>
<p>the partially realized point in the space.</p>
</td></tr>
<tr><td><code id="nint_integrateNFunc_+3A_i0">i0</code></td>
<td>
<p>the vector of indices of function dimensions in the space.</p>
</td></tr>
<tr><td><code id="nint_integrateNFunc_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nint_integrate</code> uses <code>nint_integrateNFunc</code> to handle function dimensions.
See examples below on how to deploy different solutions.
</p>
<p>The function built by <code>nint_integrateNFunc_recursive</code> directly sums over discrete dimensions and uses <code>integrate1</code> otherwise.
In conjunction with <code>integrateA</code> this is the default.
</p>


<h3>Value</h3>

<p><code>nint_integrateNFunc</code> returns a single numeric.
</p>
<p><code>nint_integrateNFunc_recursive</code> returns a recursive implementation for <code>nint_integrateNFunc</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_integrate">nint_integrate</a></code>
</p>
<p><code><a href="#topic+integrateA">integrateA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfltNFunc = nint_integrateNFunc

## area of circle
s = nint_space(
    nint_intvDim(-1, 1),
    nint_funcDim(function(x) nint_intvDim(c(-1, 1) * sin(acos(x[1])) ))
)
nint_integrate(function(x) 1, s) # pi
## see nint_integrate's examples for more sophisticated integrals


## prepare for custom recursive implementation
using = TRUE
nfunc = nint_integrateNFunc_recursive(
    function(f, lowerLimit, upperLimit, ...) {
        if (using) { # this function is called many times
            using &lt;&lt;- FALSE
            cat('using integrateA\n')
        }
        integrateA(f, lowerLimit, upperLimit, ..., subdivisions=1)$value
    }
)
unlockBinding('nint_integrateNFunc', environment(nint_integrate))
assign('nint_integrateNFunc', nfunc, envir=environment(nint_integrate))

## integrate with custom recursive implementation
nint_integrate(function(x) 1, s) # pi


## prepare for custom solution
f = function(f, funcs, x0, i0, ...) {
    # add sophisticated code here
    print(list(f=f, funcs=funcs, x0=x0, i0=i0, ...))
    stop('do something')
}
unlockBinding('nint_integrateNFunc', environment(nint_integrate))
assign('nint_integrateNFunc', f, envir=environment(nint_integrate))

## integrate with custom solution
try(nint_integrate(function(x) 1, s))


assign('nint_integrateNFunc', dfltNFunc, envir=environment(nint_integrate))
</code></pre>

<hr>
<h2 id='nint_intvDim'>Interval Dimension</h2><span id='topic+nint_intvDim'></span>

<h3>Description</h3>

<p><code>nint_intvDim</code> defines a fixed interval.
The bounds may be (negative) <code>Inf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_intvDim(x, b = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_intvDim_+3A_x">x</code></td>
<td>
<p>either a single numeric, the lower bound, or a vector of length 2, the lower and upper bound.</p>
</td></tr>
<tr><td><code id="nint_intvDim_+3A_b">b</code></td>
<td>
<p>the upper bound if <code>x</code> is the lower bound.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nint_intvDim</code> returns a vector of length 2 with the dimension type attribute set to <code>nint_TYPE_INTV_DIM</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_TYPE">nint_TYPE</a></code>, <code><a href="#topic+nint_space">nint_space</a></code>
</p>

<hr>
<h2 id='nint_scatDim'>Scatter Dimension</h2><span id='topic+nint_scatDim'></span>

<h3>Description</h3>

<p><code>nint_scatDim</code> is defined by a sequence of values.
Together with other scatter dimensions it defines a sparse grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_scatDim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_scatDim_+3A_x">x</code></td>
<td>
<p>a vector of any type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imagine using <code>cbind</code> to create a row matrix of points.
</p>


<h3>Value</h3>

<p><code>nint_scatDim</code> returns its argument with the dimension type attribute set to <code>nint_TYPE_SCAT_DIM</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_TYPE">nint_TYPE</a></code>, <code><a href="#topic+nint_space">nint_space</a></code>
</p>

<hr>
<h2 id='nint_space'>Space</h2><span id='topic+nint_space'></span>

<h3>Description</h3>

<p><code>nint_space</code> defines an n-dimensional space as a list of dimensions.
A space may consist of subspaces.
A space without subspaces is called true subspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_space(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_space_+3A_...">...</code></td>
<td>
<p>dimensions each of which may be an actual dimension object or a list structure of dimension objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a space contains at least one list structure of dimension objects it consists of subspaces.
Each subspace is then defined by a combination of dimension objects along the dimensions.
See <code><a href="#topic+nint_expandSpace">nint_expandSpace</a></code> on how to expand a space to true subspaces.
</p>


<h3>Value</h3>

<p><code>nint_space</code> returns an object of <code>class</code> <code>"nint_space"</code>.
An object of <code>class</code> <code>"nint_space"</code> is an ordered list of dimension objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_scatDim">nint_scatDim</a></code>, <code><a href="#topic+nint_gridDim">nint_gridDim</a></code>, <code><a href="#topic+nint_intvDim">nint_intvDim</a></code>, <code><a href="#topic+nint_funcDim">nint_funcDim</a></code>, <code><a href="#topic+nint_integrate">nint_integrate</a></code>, <code><a href="#topic+nint_validateSpace">nint_validateSpace</a></code>, <code><a href="#topic+nint_expandSpace">nint_expandSpace</a></code>, <code><a href="#topic+fisherI">fisherI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s = nint_space(nint_gridDim(seq(1, 3, 0.9)),
               nint_scatDim(seq(2, 5, 0.8)),
               nint_intvDim(-Inf, Inf),
               nint_funcDim(function(x) nint_intvDim(0, x[1])),
               list(nint_gridDim(c(0, 10)),
                    list(nint_intvDim(1, 7)))
               )
s
</code></pre>

<hr>
<h2 id='nint_tanTransform'>Tangent Transform</h2><span id='topic+nint_tanTransform'></span>

<h3>Description</h3>

<p><code>nint_tanTransform</code> creates the transformation <code>g(x) = atan((x - center)/scale)</code> to be used in <code>nint_transform</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_tanTransform(center, scale, dIdcs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_tanTransform_+3A_center">center</code>, <code id="nint_tanTransform_+3A_scale">scale</code></td>
<td>
<p>see <code>g(x)</code>.</p>
</td></tr>
<tr><td><code id="nint_tanTransform_+3A_didcs">dIdcs</code></td>
<td>
<p>an integer vector of indices, the dimensions to transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nint_tanTransform</code> returns a named list of two functions <code>"g"</code> and <code>"giDgi"</code> as required by <code>nint_transform</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_transform">nint_transform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu = 1e0
sigma = mu/3
f = function(x) dnorm(x, mean=mu, sd=sigma)
space = nint_space(nint_intvDim(-Inf, Inf))

tt = nint_transform(f, space, list(nint_tanTransform(0, 1, dIdcs=1)))
tt$space
ff = Vectorize(tt$f); curve(ff(x), tt$space[[1]][1], tt$space[[1]][2])

nint_integrate(tt$f, tt$space) # should return 1

# same with larger mu
mu = 1e4
sigma = mu/3
f = function(x) dnorm(x, mean=mu, sd=sigma)

tt = nint_transform(f, space, list(nint_tanTransform(0, 1, dIdcs=1)))
ff = Vectorize(tt$f); curve(ff(x), tt$space[[1]][1], tt$space[[1]][2])

try(nint_integrate(tt$f, tt$space)) # integral is probably divergent

# same with different transformation
tt = nint_transform(f, space, list(nint_tanTransform(mu, sigma, dIdcs=1)))
ff = Vectorize(tt$f); curve(ff(x), tt$space[[1]][1], tt$space[[1]][2])

nint_integrate(tt$f, tt$space) # should return 1
</code></pre>

<hr>
<h2 id='nint_transform'>Transform Integral</h2><span id='topic+nint_transform'></span>

<h3>Description</h3>

<p><code>nint_transform</code> applies monotonic transformations to an integrand and a space or list structure of spaces.
Common use cases include the probability integral transform, the transformation of infinite limits to finite ones and function dimensions to interval dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_transform(f, space, trans, funcDimToF = 0, zeroInf = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_transform_+3A_f">f</code></td>
<td>
<p><code>function(x, ...)</code>, an integrand.</p>
</td></tr>
<tr><td><code id="nint_transform_+3A_space">space</code></td>
<td>
<p>a space or list structure of spaces.</p>
</td></tr>
<tr><td><code id="nint_transform_+3A_trans">trans</code></td>
<td>
<p>a list of named lists, each containing <code>dIdcs</code>, <code>g</code> and <code>giDgi</code> or <code>giDg</code>, where</p>

<ul>
<li> <p><code>dIdcs</code> is an integer vector of indices, the dimensions to transform
</p>
</li>
<li> <p><code>g=function(x[dIdcs])</code> mapping <code>x[dIdcs]</code> to <code>y</code>
</p>
</li>
<li> <p><code>giDgi=function(y)</code> returning a list of two, the inverse <code>gi(y) = x[dIdcs]</code> and the first derivatives of <code>gi(y)</code> with respect to <code>y</code>
</p>
</li>
<li><p> or <code>giDg=function(y)</code> returning the inverse and the first derivatives of <code>g(x[dIdcs])</code> with respect to <code>x[dIdcs]</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nint_transform_+3A_funcdimtof">funcDimToF</code></td>
<td>
<p>an integer vector of indices, the dimensions to look for function dimensions to transform to interval dimensions.
<code>0</code> indicates all dimensions.</p>
</td></tr>
<tr><td><code id="nint_transform_+3A_zeroinf">zeroInf</code></td>
<td>
<p>a single value, used when <code>f</code> returns <code>0</code> and the Jacobian is infinite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interval dimensions and function dimensions returning interval dimensions only.
</p>
<p>If a transformation is vector valued, that is <code>y = c(y1, ..., yn) = g(c(x1, ..., xn))</code>, then each component of <code>y</code> shall exclusively depend on the corresponding component of <code>x</code>.
So <code>y[i] = g[i](x[i])</code> for an implicit function <code>g[i]</code>.
</p>
<p>The transformation of function dimensions to interval dimensions is performed after the transformations defined by <code>trans</code>.
Consecutive linear transformations, <code>g(x[dIdx]) = (x[dIdx] - d(x)[1])/(d(x)[2] - d(x)[1])</code> where <code>d</code> is the function dimension at dimension <code>dIdx</code>, are used.
Deciding against this transformation probably leads to considerable loss in computational performance.
</p>


<h3>Value</h3>

<p><code>nint_transform</code> returns either a named list containing the transformed integrand and space, or a list of such.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_integrate">nint_integrate</a></code>, <code><a href="#topic+nint_space">nint_space</a></code>, <code><a href="#topic+nint_tanTransform">nint_tanTransform</a></code>, <code><a href="#topic+fisherI">fisherI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
library(SparseGrid)

dfltNCube = nint_integrateNCube


## 1D, normal pdf
mu = 137
sigma = mu/6
f = function(x) dnorm(x, mean=mu, sd=sigma)
space = nint_space(nint_intvDim(-Inf, Inf))

tt = nint_transform(f, space,
                    list(nint_tanTransform(mu + 3, sigma*1.01, dIdcs=1)))
tt$space
ff = Vectorize(tt$f); curve(ff(x), tt$space[[1]][1], tt$space[[1]][2])

nint_integrate(tt$f, tt$space) # returns 1


## 2D, normal pdf

## prepare for SparseGrid
ncube = function(dimension)
    SparseGrid::createIntegrationGrid('GQU', dimension, 7) # rather sparse!
ncube = nint_integrateNCube_SparseGrid(ncube)
unlockBinding('nint_integrateNCube', environment(nint_integrate))
assign('nint_integrateNCube', ncube, envir=environment(nint_integrate))

mu = c(1, 2)
sigma = matrix(c(1, 0.7,
                 0.7, 2), nrow=2)
f = function(x) {
    if (all(is.infinite(x))) # dmvnorm returns NaN in this case
        return(0)
    return(dmvnorm(x, mean=mu, sigma=sigma))
}

# plot f
x1 = seq(-1, 3, length.out=51); x2 = seq(-1, 5, length.out=51)
y = outer(x1, x2, function(x1, x2) apply(cbind(x1, x2), 1, f))
contour(x1, x2, y, xlab='x[1]', ylab='x[2]', main='f')

space = nint_space(nint_intvDim(-Inf, Inf),
                   nint_intvDim(-Inf, Inf))

tt = nint_transform(f, space,
                    list(nint_tanTransform(mu, diag(sigma), dIdcs=1:2)))
tt$space

# plot tt$f
x1 = seq(tt$space[[1]][1], tt$space[[1]][2], length.out=51)
x2 = seq(tt$space[[2]][1], tt$space[[2]][2], length.out=51)
y = outer(x1, x2, function(x1, x2) apply(cbind(x1, x2), 1, tt$f))
contour(x1, x2, y, xlab='x[1]', ylab='x[2]', main='tt$f')

nint_integrate(tt$f, tt$space) # doesn't return 1
# tan transform is inaccurate here

# probability integral transform
dsigma = diag(sigma)
t1 = list(g=function(x) pnorm(x, mean=mu, sd=dsigma),
          giDg=function(y) {
              x = qnorm(y, mean=mu, sd=dsigma)
              list(x, dnorm(x, mean=mu, sd=dsigma))
          },
          dIdcs=1:2)

tt = nint_transform(f, space, list(t1))

# plot tt$f
x1 = seq(tt$space[[1]][1], tt$space[[1]][2], length.out=51)
x2 = seq(tt$space[[2]][1], tt$space[[2]][2], length.out=51)
y = outer(x1, x2, function(x1, x2) apply(cbind(x1, x2), 1, tt$f))
contour(x1, x2, y, xlab='x[1]', ylab='x[2]', main='tt$f')

nint_integrate(tt$f, tt$space) # returns almost 1


## 2D, half sphere
f = function(x) sqrt(1 - x[1]^2 - x[2]^2)
space = nint_space(nint_intvDim(-1, 1),
                   nint_funcDim(function(x)
                        nint_intvDim(c(-1, 1)*sqrt(1 - x[1]^2))))

# plot f
x = seq(-1, 1, length.out=51)
y = outer(x, x, function(x1, x2) apply(cbind(x1, x2), 1, f))
persp(x, x, y, theta=45, phi=45, xlab='x[1]', ylab='x[2]', zlab='f')

tt = nint_transform(f, space, list())
tt$space

# plot tt$f
x1 = seq(tt$space[[1]][1], tt$space[[1]][2], length.out=51)
x2 = seq(tt$space[[2]][1], tt$space[[2]][2], length.out=51)
y = outer(x1, x2, function(x1, x2) apply(cbind(x1, x2), 1, tt$f))
persp(x1, x2, y, theta=45, phi=45, xlab='x[1]', ylab='x[2]', zlab='tt$f')

nint_integrate(tt$f, tt$space) # returns almost 4/3*pi / 2


## 2D, constrained normal pdf
f = function(x) prod(dnorm(x, 0, 1))
space = nint_space(nint_intvDim(-Inf, Inf),
                   nint_funcDim(function(x) nint_intvDim(-Inf, x[1]^2)))

tt = nint_transform(f, space, list(nint_tanTransform(0, 1, dIdcs=1:2)))

# plot tt$f
x1 = seq(tt$space[[1]][1], tt$space[[1]][2], length.out=51)
x2 = seq(tt$space[[2]][1], tt$space[[2]][2], length.out=51)
y = outer(x1, x2, function(x1, x2) apply(cbind(x1, x2), 1, tt$f))
persp(x1, x2, y, theta=45, phi=45, xlab='x[1]', ylab='x[2]', zlab='tt$f')

nint_integrate(tt$f, tt$space) # Mathematica returns 0.716315


assign('nint_integrateNCube', dfltNCube, envir=environment(nint_integrate))
</code></pre>

<hr>
<h2 id='nint_TYPE'>Dimension Type Attribute Values</h2><span id='topic+nint_TYPE'></span><span id='topic+nint_TYPE_SCAT_DIM'></span><span id='topic+nint_TYPE_GRID_DIM'></span><span id='topic+nint_TYPE_INTV_DIM'></span><span id='topic+nint_TYPE_FUNC_DIM'></span>

<h3>Description</h3>

<p>A dimension object is identified by its dimension type attribute <code>"nint_dtype"</code>.
On creation it is set to one of the following.
See dimension types in &quot;See Also&quot; below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_TYPE_SCAT_DIM # = 1

nint_TYPE_GRID_DIM # = 2

nint_TYPE_INTV_DIM # = 3

nint_TYPE_FUNC_DIM # = 4
</code></pre>


<h3>Format</h3>

<p>integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_scatDim">nint_scatDim</a></code>, <code><a href="#topic+nint_gridDim">nint_gridDim</a></code>, <code><a href="#topic+nint_intvDim">nint_intvDim</a></code>, <code><a href="#topic+nint_funcDim">nint_funcDim</a></code>, <code><a href="#topic+nint_space">nint_space</a></code>
</p>

<hr>
<h2 id='nint_validateSpace'>Validate Space</h2><span id='topic+nint_validateSpace'></span>

<h3>Description</h3>

<p><code>nint_validateSpace</code> performs a couple of checks on a space or list structure of spaces to ensure it is properly defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nint_validateSpace(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nint_validateSpace_+3A_x">x</code></td>
<td>
<p>a space or list structure of spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nint_validateSpace</code> returns 0 if everything is fine, or an error code.
See <code><a href="#topic+nint_ERROR">nint_ERROR</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_ERROR">nint_ERROR</a></code>, <code><a href="#topic+nint_space">nint_space</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## valid
s = nint_space()
s
nint_validateSpace(s)

s = nint_space(nint_intvDim(-1, 1))
s
nint_validateSpace(s)

## -1001
s = nint_space(1)
s
nint_validateSpace(s)

## -1002
s = nint_space(list(nint_scatDim(c(1, 2)), nint_scatDim(c(1, 2, 3))))
s
nint_validateSpace(s)

s = nint_space(nint_scatDim(c(1, 2)),
               nint_scatDim(c(1, 2, 3)))
s
nint_validateSpace(s)

## -1003
nint_validateSpace(1)
nint_validateSpace(list(nint_space())) # valid
nint_validateSpace(list(1))

## -1004
s1 = nint_space(nint_gridDim(1:3),
                nint_scatDim(c(0, 1)))
s2 = nint_space(s1[[1]])
s1 # 2D
s2 # 1D
nint_validateSpace(list(s1, s2))
</code></pre>

<hr>
<h2 id='numDerivLogf'>Build Derivative Function for Log f</h2><span id='topic+numDerivLogf'></span><span id='topic+numDeriv2Logf'></span>

<h3>Description</h3>

<p><code>numDerivLogf</code>/<code>numDeriv2Logf</code> builds a function that evaluates to the first/second derivative of <code>log(f(y, theta, ...))</code> with respect to <code>theta[[i]]</code>/<code>theta[[i]]</code> and <code>theta[[j]]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numDerivLogf(f, isLogf = FALSE, logZero = .Machine$double.xmin,
  logInf = .Machine$double.xmax/2, method = "Richardson",
  side = NULL, method.args = list())

numDeriv2Logf(f, isLogf = FALSE, logZero = .Machine$double.xmin,
  logInf = .Machine$double.xmax/2, method = "Richardson",
  method.args = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numDerivLogf_+3A_f">f</code></td>
<td>
<p><code>function(y, theta, ...)</code>, where <code>theta</code> is a list of parameters.
A joint probability density function.</p>
</td></tr>
<tr><td><code id="numDerivLogf_+3A_islogf">isLogf</code></td>
<td>
<p>set to <code>TRUE</code> if <code>f</code> is already <code>log(f)</code>.</p>
</td></tr>
<tr><td><code id="numDerivLogf_+3A_logzero">logZero</code></td>
<td>
<p>the value <code>log(f)</code> should return if <code>f</code> evaluates to <code>0</code>.</p>
</td></tr>
<tr><td><code id="numDerivLogf_+3A_loginf">logInf</code></td>
<td>
<p>the value <code>log(f)</code> should return if <code>f</code> evaluates to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="numDerivLogf_+3A_method">method</code>, <code id="numDerivLogf_+3A_side">side</code>, <code id="numDerivLogf_+3A_method.args">method.args</code></td>
<td>
<p>see <code><a href="numDeriv.html#topic+grad">grad</a></code> and <code><a href="numDeriv.html#topic+hessian">hessian</a></code> in package <span class="pkg">numDeriv</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">numDeriv</span> produces <code>NaN</code>s if the log evaluates to (negative) <code>Inf</code> so you may want to specify <code>logZero</code> and <code>logInf</code>.
</p>
<p><code>numDerivLogf</code> passes <code>method</code>, <code>side</code> and <code>method.args</code> directly to <code>numDeriv::grad</code>.
</p>
<p><code>numDeriv2Logf</code> duplicates the internals of <code>numDeriv::hessian</code> to gain speed.
The defaults for <code>method.args</code> are <code>list(eps=1e-4, d=0.1, zero.tol=sqrt(.Machine$double.eps/7e-7), r=4, v=2)</code>.
</p>


<h3>Value</h3>

<p><code>numDerivLogf</code> returns <code>function(y, theta, i, ...)</code> which evaluates to the first derivative of <code>log(f(y, theta, ...))</code> with respect to <code>theta[[i]]</code>.
</p>
<p><code>numDeriv2Logf</code> returns <code>function(y, theta, i, j, ...)</code> which evaluates to the second derivative of <code>log(f(y, theta, ...))</code> with respect to <code>theta[[i]]</code> and <code>theta[[j]]</code>.
</p>


<h3>See Also</h3>

<p><code><a href="numDeriv.html#topic+grad">grad</a></code> and <code><a href="numDeriv.html#topic+hessian">hessian</a></code> in package <span class="pkg">numDeriv</span>, <code><a href="#topic+buildf">buildf</a></code>, <code><a href="#topic+DerivLogf">DerivLogf</a></code>, <code><a href="#topic+fisherI">fisherI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

<hr>
<h2 id='param'>Parametric Model</h2><span id='topic+param'></span>

<h3>Description</h3>

<p><code>param</code> creates an initial parametric model object.
Unlike other model statements this function does not perform any computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param(fisherIf, dDim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_+3A_fisherif">fisherIf</code></td>
<td>
<p><code>function(x, ...)</code>, where <code>x</code> is a vector, usually a point from the design space.
It shall evaluate to the Fisher information matrix.</p>
</td></tr>
<tr><td><code id="param_+3A_ddim">dDim</code></td>
<td>
<p>length of <code>x</code>, usually the dimensionality of the design space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>param</code> returns an object of <code>class</code> <code>"param"</code>.
An object of class <code>"param"</code> is a list containing at least the following components:
</p>

<ul>
<li><p> fisherIf: argument
</p>
</li>
<li><p> x: a row matrix of points where <code>fisherIf</code> has already been evaluated.
</p>
</li>
<li><p> fisherI: a list of Fisher information matrices, for each row in <code>x</code> respectively.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fisherI">fisherI</a></code>, <code><a href="#topic+update.param">update.param</a></code>, <code><a href="#topic+Dsensitivity">Dsensitivity</a></code>, <code><a href="#topic+getM">getM</a></code>, <code><a href="#topic+Defficiency">Defficiency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(copula)


dfltNCube = nint_integrateNCube

## prepare for SparseGrid integration
ncube = function(dimension) {
    SparseGrid::createIntegrationGrid('GQU', dimension, 3)
}
ncube = nint_integrateNCube_SparseGrid(ncube)
unlockBinding('nint_integrateNCube', environment(nint_integrate))
assign('nint_integrateNCube', ncube, envir=environment(nint_integrate))


## general settings
numDeriv = FALSE


## build pdf, derivatives
etas = function(theta) with(theta, {
    xx = x^(0:4)
    c(c(beta1, beta2, beta3) %*% xx[c(1, 2, 3)], # x^c(0, 1, 2)
      c(beta4, beta5, beta6) %*% xx[c(2, 4, 5)]) # x^c(1, 3, 4)
})

copula = claytonCopula()
alphas = c('alpha')

parNames = c(paste('beta', 1:6, sep=''), alphas)

if (numDeriv) {
    margins = function(y, theta, ...) {
        e = etas(theta)
        cbind(dnorm(y, mean=e, sd=1), pnorm(y, mean=e, sd=1))
    }
    f = buildf(margins, TRUE, copula, parNames=alphas)

    d2logf = numDeriv2Logf(f)

} else {
    es = list(
        eta1=quote(theta$beta1 + theta$beta2*theta$x + theta$beta3*theta$x^2),
        eta2=quote(theta$beta4*theta$x + theta$beta5*theta$x^3 + theta$beta6*theta$x^4))

    margins = list(list(pdf=substitute(dnorm(y[1], mean=eta1, sd=1), es),
                        cdf=substitute(pnorm(y[1], mean=eta1, sd=1), es)),
                   list(pdf=substitute(dnorm(y[2], mean=eta2, sd=1), es),
                        cdf=substitute(pnorm(y[2], mean=eta2, sd=1), es)))
    pn = as.list(alphas); names(pn) = alphas # map parameter to variable
    f = buildf(margins, TRUE, copula, parNames=pn)

    cat('building derivatives ...')
    tt = system.time(d2logf &lt;- Deriv2Logf(f, parNames))
    cat('\n')
    print(tt)
}

f
str(d2logf)


## param
model = function(theta) {
    integrand = function(y, theta, i, j)
        -d2logf(y, theta, i, j) * f(y, theta)

    yspace = nint_space(nint_intvDim(-Inf, Inf),
                        nint_intvDim(-Inf, Inf))

    fisherIf = function(x) {
        theta$x = x

        ## probability integral transform
        e = etas(theta)

        tt = nint_transform(integrand, yspace, list(list(
            dIdcs=1:2,
            g=function(y) pnorm(y, mean=e, sd=1),
            giDg=function(z) {
                t1 = qnorm(z, mean=e, sd=1)
                list(t1, dnorm(t1, mean=e, sd=1))
            }
        )))

        fisherI(tt$f, theta, parNames, tt$space)
    }

    return(param(fisherIf, 1))
}

theta = list(beta1=1, beta2=1, beta3=1,
             beta4=1, beta5=1, beta6=1,
             alpha=iTau(copula, 0.5), x=0)
m = model(theta)

## update.param
system.time(m &lt;- update(m, matrix(seq(0, 1, length.out=101), ncol=1)))

## find D-optimal design
D = Dsensitivity(defaults=list(x=m$x, desx=m$x, mod=m))

d &lt;- Wynn(D, 7.0007, maxIter=1e4)
d$tag$Wynn$tolBreak

dev.new(); plot(d, sensTol=7, main='d')

getM(m, d)

rd = reduce(d, 0.05)
cbind(x=rd$x, w=rd$w)

dev.new(); plot(rd, main='rd')

try(getM(m, rd))
m2 = update(m, rd)
getM(m2, rd)

## find Ds-optimal design
s = c(alphas, 'beta1', 'beta2', 'beta3')
Ds = Dsensitivity(A=s, defaults=list(x=m$x, desx=m$x, mod=m))

ds &lt;- Wynn(Ds, 4.0004, maxIter=1e4)
ds$tag$Wynn$tolBreak

dev.new(); plot(reduce(ds, 0.05), sensTol=4, main='ds')

## create custom design
n = 4
d2 = design(x=matrix(seq(0, 1, length.out=n), ncol=1), w=rep(1/n, n))

m = update(m, d2)
dev.new(); plot(d2, sensx=d$x, sens=D(x=d$x, desx=d2$x, desw=d2$w, mod=m),
                sensTol=7, main='d2')

## compare designs
Defficiency(ds, d, m)
Defficiency(d, ds, m, A=s) # Ds-efficiency
Defficiency(d2, d, m)
Defficiency(d2, ds, m) # D-efficiency

## end with nice plot
dev.new(); plot(rd, main='rd')


assign('nint_integrateNCube', dfltNCube, envir=environment(nint_integrate))

</code></pre>

<hr>
<h2 id='plot.desigh'>Plot Design</h2><span id='topic+plot.desigh'></span>

<h3>Description</h3>

<p><code>plot.desigh</code> creates a one-dimensional design plot, optionally together with a specified sensitivity curve.
If the design space has additional dimensions, the design is projected on a specified margin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'desigh'
plot(x, sensx = NULL, sens = NULL, sensTol = NULL,
  ..., margins = NULL, desSens = T, sensPch = "+",
  sensArgs = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.desigh_+3A_x">x</code></td>
<td>
<p>a design.</p>
</td></tr>
<tr><td><code id="plot.desigh_+3A_sensx">sensx</code></td>
<td>
<p>(optional) a row matrix of points.</p>
</td></tr>
<tr><td><code id="plot.desigh_+3A_sens">sens</code></td>
<td>
<p>(optional) either a vector of sensitivities or a sensitivity function.
The latter shall rely on defaults, see <code><a href="#topic+Dsensitivity">Dsensitivity</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.desigh_+3A_senstol">sensTol</code></td>
<td>
<p>(optional) a single numeric.
Adds a horizontal line at this sensitivity level.</p>
</td></tr>
<tr><td><code id="plot.desigh_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot.</p>
</td></tr>
<tr><td><code id="plot.desigh_+3A_margins">margins</code></td>
<td>
<p>a vector of indices, the dimensions to project on.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="plot.desigh_+3A_dessens">desSens</code></td>
<td>
<p>if <code>TRUE</code> and <code>sens</code> is not specified then the sensitivity function which potentially was used in <code>Wynn</code> is taken as <code>sens</code>.</p>
</td></tr>
<tr><td><code id="plot.desigh_+3A_senspch">sensPch</code></td>
<td>
<p>either a character vector of point 'characters' to add to the sensitivity curve or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.desigh_+3A_sensargs">sensArgs</code></td>
<td>
<p>a list of arguments passed to draw calls related to the sensitivity.</p>
</td></tr>
</table>


<h3>References</h3>

<p>uses add.alpha from <a href="http://www.magesblog.com/2013/04/how-to-change-alpha-value-of-colours-in.html">http://www.magesblog.com/2013/04/how-to-change-alpha-value-of-colours-in.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+design">design</a></code>, <code><a href="#topic+Dsensitivity">Dsensitivity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

<hr>
<h2 id='print.nint_space'>Print Space</h2><span id='topic+print.nint_space'></span>

<h3>Description</h3>

<p><code>print.nint_space</code> prints a space in a convenient way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nint_space'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.nint_space_+3A_x">x</code></td>
<td>
<p>a space.</p>
</td></tr>
<tr><td><code id="print.nint_space_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each line represents a dimension.
Format: &quot;&lt;dim idx&gt;: &lt;dim repr&gt;&quot;.
Each dimension has its own representation which should be easy to understand.
<code>nint_scatDim</code> representations are marked by <code>"s()"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nint_space">nint_space</a></code>
</p>

<hr>
<h2 id='reduce'>Reduce Design</h2><span id='topic+reduce'></span>

<h3>Description</h3>

<p><code>reduce</code> drops insignificant points and merges points in a certain neighbourhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce(des, distMax, wMin = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_+3A_des">des</code></td>
<td>
<p>a design.</p>
</td></tr>
<tr><td><code id="reduce_+3A_distmax">distMax</code></td>
<td>
<p>maximum euclidean distance between points to be merged.</p>
</td></tr>
<tr><td><code id="reduce_+3A_wmin">wMin</code></td>
<td>
<p>minimum weight a point shall have to be considered significant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>reduce</code> returns an object of <code>class</code> <code>"desigh"</code>.
See <code><a href="#topic+design">design</a></code> for its structural definition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+design">design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

<hr>
<h2 id='rowmatch'>Row Matching</h2><span id='topic+rowmatch'></span>

<h3>Description</h3>

<p><code>rowmatch</code> returns a vector of the positions of (first) matches of the rows of its first argument in the rows of its second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowmatch(x, table, nomatch = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowmatch_+3A_x">x</code></td>
<td>
<p>a row matrix of doubles, the rows to be matched.</p>
</td></tr>
<tr><td><code id="rowmatch_+3A_table">table</code></td>
<td>
<p>a row matrix of doubles, the rows to be matched against.</p>
</td></tr>
<tr><td><code id="rowmatch_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned in the case when no match is found.
Note that it is coerced to <code>integer</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rowmatch</code> uses compiled C-code.
</p>


<h3>Value</h3>

<p><code>rowmatch</code> returns an integer vector giving the position of the matching row in <code>table</code> for each row in <code>x</code>. And <code>nomatch</code> if there is no matching row.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = as.matrix(expand.grid(as.double(2:3), as.double(3:6)))
a = a[sample(nrow(a)),]
a

b = as.matrix(expand.grid(as.double(3:4), as.double(2:5)))
b = b[sample(nrow(b)),]
b

i = rowmatch(a, b)
i
b[na.omit(i),] # matching rows
a[is.na(i),] # non matching rows
</code></pre>

<hr>
<h2 id='roworder'>Matrix Ordering Permutation</h2><span id='topic+roworder'></span>

<h3>Description</h3>

<p><code>roworder</code> returns a permutation which rearranges the rows of its first argument into ascending order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roworder(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roworder_+3A_x">x</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="roworder_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>order</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>roworder</code> returns an integer vector.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = expand.grid(1:3, 1:2, 3:1)
x = x[sample(seq1(1, nrow(x)), nrow(x)),]
x

ord = roworder(x)
ord

x[ord,]
</code></pre>

<hr>
<h2 id='rowsduplicated'>Determine Duplicate Rows</h2><span id='topic+rowsduplicated'></span>

<h3>Description</h3>

<p><code>rowsduplicated</code> determines which rows of a matrix are duplicates of rows with smaller subscripts, and returns a logical vector indicating which rows are duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowsduplicated(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowsduplicated_+3A_x">x</code></td>
<td>
<p>a row matrix of doubles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rowsduplicated</code> uses compiled C-code.
</p>


<h3>Value</h3>

<p><code>rowsduplicated</code> returns a logical vector with one element for each row.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>

<hr>
<h2 id='seq1'>Sequence Generation</h2><span id='topic+seq1'></span>

<h3>Description</h3>

<p><code>seq1</code> is similar to <code>seq</code>, however <code>by</code> is strictly <code>1</code> by default and <code>integer(0)</code> is returned if the range is empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq1(from, to, by = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq1_+3A_from">from</code>, <code id="seq1_+3A_to">to</code>, <code id="seq1_+3A_by">by</code></td>
<td>
<p>see <code><a href="base.html#topic+seq">seq</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>seq1</code> returns either <code>integer(0)</code> if range is empty or what an appropriate call to <code>seq</code> returns otherwise.
</p>
<p>See examples below.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+seq">seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq1(1, 3)
seq1(3, 1) # different from seq
seq(3, 1)
3:1

seq1(5, 1, -3)
</code></pre>

<hr>
<h2 id='update.param'>Update Parametric Model</h2><span id='topic+update.param'></span>

<h3>Description</h3>

<p><code>update.param</code> evaluates the Fisher information at uncharted points and returns an updated model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'param'
update(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.param_+3A_object">object</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="update.param_+3A_x">x</code></td>
<td>
<p>either a row matrix of points or a design, or a list structure of matrices or designs.
The number of columns/the dimensionality of the design space shall be equal to <code>ncol(object$x)</code>.</p>
</td></tr>
<tr><td><code id="update.param_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the user interrupts execution, the function returns a partially updated model object.
</p>


<h3>Value</h3>

<p><code>update.param</code> returns an object of <code>class</code> <code>"param"</code>.
See <code><a href="#topic+param">param</a></code> for its structural definition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param">param</a></code>, <code><a href="#topic+grow.grid">grow.grid</a></code>, <code><a href="#topic+design">design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

<hr>
<h2 id='wDefficiency'>Weighted D Efficiency</h2><span id='topic+wDefficiency'></span>

<h3>Description</h3>

<p><code>wDefficiency</code> computes the weighted D-, D_s or D_A-efficiency measure for a design with respect to a reference design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wDefficiency(des, ref, mods, modw, A = NULL, parNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wDefficiency_+3A_des">des</code></td>
<td>
<p>a design.</p>
</td></tr>
<tr><td><code id="wDefficiency_+3A_ref">ref</code></td>
<td>
<p>a design, the reference.</p>
</td></tr>
<tr><td><code id="wDefficiency_+3A_mods">mods</code></td>
<td>
<p>a list of models.</p>
</td></tr>
<tr><td><code id="wDefficiency_+3A_modw">modw</code></td>
<td>
<p>a vector of weights.</p>
</td></tr>
<tr><td><code id="wDefficiency_+3A_a">A</code></td>
<td>
<p>for </p>

<ul>
<li><p> D-efficiency: <code>NULL</code>
</p>
</li>
<li><p> D_s-efficiency: a vector of names or indices, the subset of parameters of interest.
</p>
</li>
<li><p> D_A-efficiency: either </p>

<ul>
<li><p> directly: a matrix without row names.
</p>
</li>
<li><p> indirectly: a matrix with row names corresponding to the parameters.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="wDefficiency_+3A_parnames">parNames</code></td>
<td>
<p>a vector of names or indices, the subset of parameters to use.
Defaults to the parameters for which the Fisher information is available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indices supplied to argument <code>A</code> correspond to the subset of parameters defined by argument <code>parNames</code>.
</p>
<p>Weighted D efficiency is defined as
</p>
<p style="text-align: center;"><code class="reqn">\left(\frac{\exp\int_{\mathcal{B}}\log\left|M(\xi,\bar{\boldsymbol{\theta}})\right|\mathrm{d}B}{\exp\int_{\mathcal{B}}\log\left|M(\xi^{*},\bar{\boldsymbol{\theta}})\right|\mathrm{d}B}\right)^{1/n}</code>
</p>

<p>and weighted D_A efficiency as
</p>
<p style="text-align: center;"><code class="reqn">\left(\frac{\exp\int_{\mathcal{B}}\log\left|A^{T}M(\xi,\bar{\boldsymbol{\theta}})^{-1}A\right|^{-1}\mathrm{d}B}{\exp\int_{\mathcal{B}}\log\left|A^{T}M(\xi^{*},\bar{\boldsymbol{\theta}})^{-1}A\right|^{-1}\mathrm{d}B}\right)^{1/s}</code>
</p>



<h3>Value</h3>

<p><code>wDefficiency</code> returns a single numeric.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+design">design</a></code>, <code><a href="#topic+param">param</a></code>, <code><a href="#topic+Defficiency">Defficiency</a></code>
</p>

<hr>
<h2 id='wDsensitivity'>Weighted D Sensitivity</h2><span id='topic+wDsensitivity'></span>

<h3>Description</h3>

<p><code>wDsensitivity</code> builds a sensitivity function for the weighted D-, D_s or D_A-optimality criterion which relies on defaults to speed up evaluation.
<code>Wynn</code> for instance requires this behaviour/protocol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wDsensitivity(A = NULL, parNames = NULL, defaults = list(x = NULL,
  desw = NULL, desx = NULL, mods = NULL, modw = NULL))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wDsensitivity_+3A_a">A</code></td>
<td>
<p>for </p>

<ul>
<li><p> D-optimality: <code>NULL</code>
</p>
</li>
<li><p> D_s-optimality: a vector of names or indices, the subset of parameters of interest.
</p>
</li>
<li><p> D_A-optimality: either </p>

<ul>
<li><p> directly: a matrix without row names.
</p>
</li>
<li><p> indirectly: a matrix with row names corresponding to the parameters.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="wDsensitivity_+3A_parnames">parNames</code></td>
<td>
<p>a vector of names or indices, the subset of parameters to use.
Defaults to the parameters for which the Fisher information is available.</p>
</td></tr>
<tr><td><code id="wDsensitivity_+3A_defaults">defaults</code></td>
<td>
<p>a named list of default values.
The value <code>NULL</code> is equivalent to absence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indices and rows of an unnamed matrix supplied to argument <code>A</code> correspond to the subset of parameters defined by argument <code>parNames</code>.
</p>
<p>For efficiency reasons the returned function won't complain about <em>missing arguments</em> immediately, leading to strange errors.
Please ensure that all arguments are specified at all times.
This behaviour might change in future releases.
</p>


<h3>Value</h3>

<p><code>wDsensitivity</code> returns <code>function(x=NULL, desw=NULL, desx=NULL, mods=NULL, modw=NULL)</code>, the sensitivity function.
It's attributes contain this function's arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+docopulae">docopulae</a></code>, <code><a href="#topic+param">param</a></code>, <code><a href="#topic+Dsensitivity">Dsensitivity</a></code>, <code><a href="#topic+Wynn">Wynn</a></code>, <code><a href="#topic+plot.desigh">plot.desigh</a></code>
</p>

<hr>
<h2 id='Wynn'>Wynn</h2><span id='topic+Wynn'></span>

<h3>Description</h3>

<p><code>Wynn</code> finds an optimal design using a sensitivity function and a Wynn-algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wynn(sensF, tol, maxIter = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Wynn_+3A_sensf">sensF</code></td>
<td>
<p><code>function(x=NULL, desw=NULL, desx=NULL, mod=NULL)</code>, a sensitivity function.
It's attribute <code>"defaults"</code> shall contain identical <code>x</code> and <code>desx</code>, and <code>sensF(desw=w)</code> shall return sensitivities corresponding to each point in <code>x</code>.</p>
</td></tr>
<tr><td><code id="Wynn_+3A_tol">tol</code></td>
<td>
<p>the tolerance level regarding the sensitivities.</p>
</td></tr>
<tr><td><code id="Wynn_+3A_maxiter">maxIter</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Dsensitivity">Dsensitivity</a></code> and it's return value for a reference implementation of a function complying with the requirements for <code>sensF</code>.
</p>
<p>The algorithm starts from a uniform weight design.
In each iteration weight is redistributed to the point which has the highest sensitivity.
Sequence: <code>1/i</code>.
The algorithm stops when all sensitivities are below a specified tolerance level or the maximum number of iterations is reached.
</p>


<h3>Value</h3>

<p><code>Wynn</code> returns an object of <code>class</code> <code>"desigh"</code>.
See <code><a href="#topic+design">design</a></code> for its structural definition.
</p>


<h3>References</h3>

<p>Wynn, Henry P. (1970) The Sequential Generation of D-Optimum Experimental Designs.
<em>The Annals of Mathematical Statistics</em>, 41(5):1655-1664.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dsensitivity">Dsensitivity</a></code>, <code><a href="#topic+design">design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for param

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
