<!DOCTYPE html><html lang="en"><head><title>Help for package flintyR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flintyR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#flintyR-package'><p>Simple and Flexible Tests of Sample Exchangeability</p></a></li>
<li><a href='#blockGaussian'><p>Approximate p-value for Test of Exchangeability (Assuming Large N and P with Block Dependencies)</p></a></li>
<li><a href='#blockLargeP'><p>Approximate p-value for Test of Exchangeability (Assuming Large P with Block Dependencies)</p></a></li>
<li><a href='#blockPermute'><p>p-value Computation for Test of Exchangeability with Block Dependencies</p></a></li>
<li><a href='#buildForward'><p>Map from Indices to Label Pairs</p></a></li>
<li><a href='#buildReverse'><p>Map from Label Pairs to Indices</p></a></li>
<li><a href='#cacheBlockPermute1'><p>Resampling Many V Statistics (Version 1)</p></a></li>
<li><a href='#cacheBlockPermute2'><p>Resampling Many V Statistics (Version 2)</p></a></li>
<li><a href='#cachePermute'><p>Permutation by Caching Distances</p></a></li>
<li><a href='#distDataLargeP'><p>Asymptotic p-value of Exchangeability Using Distance Data</p></a></li>
<li><a href='#distDataPermute'><p>p-value Computation for Test of Exchangeability Using Distance Data</p></a></li>
<li><a href='#distDataPValue'><p>A Non-parametric Test of Sample Exchangeability and Feature Independence (Distance List Version)</p></a></li>
<li><a href='#getBinVStat'><p>V Statistic for Binary Matrices</p></a></li>
<li><a href='#getBlockCov'><p>Covariance Computations Between Pairs of Distances (Block Dependencies Case)</p></a></li>
<li><a href='#getChi2Weights'><p>Get Chi Square Weights</p></a></li>
<li><a href='#getCov'><p>Covariance Computations Between Pairs of Distances (Independent Case)</p></a></li>
<li><a href='#getHammingDistance'><p>A Hamming Distance Vector Calculator</p></a></li>
<li><a href='#getLpDistance'><p>A <code class="reqn">l_p^p</code> Distance Vector Calculator</p></a></li>
<li><a href='#getPValue'><p>A Non-parametric Test of Sample Exchangeability and Feature Independence</p></a></li>
<li><a href='#getRealVStat'><p>V Statistic for Real Matrices</p></a></li>
<li><a href='#hamming_bitwise'><p>Fast Bitwise Hamming Distance Vector Computation</p></a></li>
<li><a href='#indGaussian'><p>Approximate p-value for Test of Exchangeability (Assuming Large N and P)</p></a></li>
<li><a href='#indLargeP'><p>Approximate p-value for Test of Exchangeability (Assuming Large P)</p></a></li>
<li><a href='#lp_distance'><p>Fast <code class="reqn">l_p^p</code> Distance Vector Computation</p></a></li>
<li><a href='#naiveBlockPermute1'><p>Resampling V Statistic (Version 1)</p></a></li>
<li><a href='#naiveBlockPermute2'><p>Resampling V Statistic (Version 2)</p></a></li>
<li><a href='#weightedChi2P'><p>Tail Probability for Chi Square Convolution Random Variable</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simple and Flexible Tests of Sample Exchangeability</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alan Aw &lt;alanaw1@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Given a multivariate dataset and some knowledge about the dependencies 
              between its features, it is customary to fit a statistical model to the features 
              to infer parameters of interest. Such a procedure implicitly assumes that the 
              sample is exchangeable. This package provides a flexible non-parametric test 
              of this exchangeability assumption, allowing the user to specify the feature 
              dependencies by hand as long as features can be grouped into disjoint independent sets. 
              This package also allows users to test a dual hypothesis, which is, given that the 
              sample is exchangeable, does a proposed grouping of the features into disjoint sets
              also produce statistically independent sets of features? See Aw, Spence and Song (2023) 
              for the accompanying paper.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.6), doParallel, foreach, assertthat, testthat,
stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://alanaw1.github.io/flintyR/">https://alanaw1.github.io/flintyR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alanaw1/flintyR/issues">https://github.com/alanaw1/flintyR/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-23 06:56:04 UTC; alanaw</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Author:</td>
<td>Alan Aw <a href="https://orcid.org/0000-0001-9455-7878"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  Jeffrey Spence [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-23 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='flintyR-package'>Simple and Flexible Tests of Sample Exchangeability</h2><span id='topic+flintyR-package'></span><span id='topic+flintyR'></span>

<h3>Description</h3>

<p>Given a multivariate dataset and some knowledge about the dependencies 
              between its features, it is customary to fit a statistical model to the features 
              to infer parameters of interest. Such a procedure implicitly assumes that the 
              sample is exchangeable. This package provides a flexible non-parametric test 
              of this exchangeability assumption, allowing the user to specify the feature 
              dependencies by hand as long as features can be grouped into disjoint independent sets. 
              This package also allows users to test a dual hypothesis, which is, given that the 
              sample is exchangeable, does a proposed grouping of the features into disjoint sets
              also produce statistically independent sets of features? See Aw, Spence and Song (2023) 
              for the accompanying paper.</p>


<h3>Package Content</h3>


<p>Index of help topics:
</p>
<pre>
blockGaussian           Approximate p-value for Test of Exchangeability
                        (Assuming Large N and P with Block
                        Dependencies)
blockLargeP             Approximate p-value for Test of Exchangeability
                        (Assuming Large P with Block Dependencies)
blockPermute            p-value Computation for Test of Exchangeability
                        with Block Dependencies
buildForward            Map from Indices to Label Pairs
buildReverse            Map from Label Pairs to Indices
cacheBlockPermute1      Resampling Many V Statistics (Version 1)
cacheBlockPermute2      Resampling Many V Statistics (Version 2)
cachePermute            Permutation by Caching Distances
distDataLargeP          Asymptotic p-value of Exchangeability Using
                        Distance Data
distDataPValue          A Non-parametric Test of Sample Exchangeability
                        and Feature Independence (Distance List
                        Version)
distDataPermute         p-value Computation for Test of Exchangeability
                        Using Distance Data
flintyR-package         Simple and Flexible Tests of Sample
                        Exchangeability
getBinVStat             V Statistic for Binary Matrices
getBlockCov             Covariance Computations Between Pairs of
                        Distances (Block Dependencies Case)
getChi2Weights          Get Chi Square Weights
getCov                  Covariance Computations Between Pairs of
                        Distances (Independent Case)
getHammingDistance      A Hamming Distance Vector Calculator
getLpDistance           A l_p^p Distance Vector Calculator
getPValue               A Non-parametric Test of Sample Exchangeability
                        and Feature Independence
getRealVStat            V Statistic for Real Matrices
hamming_bitwise         Fast Bitwise Hamming Distance Vector
                        Computation
indGaussian             Approximate p-value for Test of Exchangeability
                        (Assuming Large N and P)
indLargeP               Approximate p-value for Test of Exchangeability
                        (Assuming Large P)
lp_distance             Fast l_p^p Distance Vector Computation
naiveBlockPermute1      Resampling V Statistic (Version 1)
naiveBlockPermute2      Resampling V Statistic (Version 2)
weightedChi2P           Tail Probability for Chi Square Convolution
                        Random Variable
</pre>

<h3>Maintainer</h3>

<p>Alan Aw &lt;alanaw1@berkeley.edu&gt;</p>


<h3>Author(s)</h3>

<p>NA</p>

<hr>
<h2 id='blockGaussian'>Approximate p-value for Test of Exchangeability (Assuming Large N and P with Block Dependencies)</h2><span id='topic+blockGaussian'></span>

<h3>Description</h3>

<p>Computes the large <code class="reqn">(N,P)</code> asymptotic p-value for dataset <code class="reqn">\mathbf{X}</code>,
assuming its <code class="reqn">P</code> features are independent within specified blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockGaussian(X, block_boundaries, block_labels, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockGaussian_+3A_x">X</code></td>
<td>
<p>The binary or real matrix on which to perform test of exchangeability</p>
</td></tr>
<tr><td><code id="blockGaussian_+3A_block_boundaries">block_boundaries</code></td>
<td>
<p>Vector denoting the positions where a new
block of non-independent features starts.</p>
</td></tr>
<tr><td><code id="blockGaussian_+3A_block_labels">block_labels</code></td>
<td>
<p>Length <code class="reqn">P</code> vector recording the block label of each feature.</p>
</td></tr>
<tr><td><code id="blockGaussian_+3A_p">p</code></td>
<td>
<p>The power <code class="reqn">p</code> of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the large <code class="reqn">N</code> and large <code class="reqn">P</code> asymptotics of the permutation test.
</p>
<p>Dependencies: getBinVStat, getRealVStat, getBlockCov, getChi2Weights
</p>


<h3>Value</h3>

<p>The asymptotic p-value
</p>

<hr>
<h2 id='blockLargeP'>Approximate p-value for Test of Exchangeability (Assuming Large P with Block Dependencies)</h2><span id='topic+blockLargeP'></span>

<h3>Description</h3>

<p>Computes the large <code class="reqn">P</code> asymptotic p-value for dataset <code class="reqn">\mathbf{X}</code>,
assuming its <code class="reqn">P</code> features are independent within specified blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockLargeP(X, block_boundaries, block_labels, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockLargeP_+3A_x">X</code></td>
<td>
<p>The binary or real matrix on which to perform test of exchangeability</p>
</td></tr>
<tr><td><code id="blockLargeP_+3A_block_boundaries">block_boundaries</code></td>
<td>
<p>Vector denoting the positions where a new
block of non-independent features starts.</p>
</td></tr>
<tr><td><code id="blockLargeP_+3A_block_labels">block_labels</code></td>
<td>
<p>Length <code class="reqn">P</code> vector recording the block label of each feature.</p>
</td></tr>
<tr><td><code id="blockLargeP_+3A_p">p</code></td>
<td>
<p>The power <code class="reqn">p</code> of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the large <code class="reqn">P</code> asymptotics of the permutation test.
</p>
<p>Dependencies: getBinVStat, getRealVStat, getChi2Weights, weightedChi2P, getBlockCov
</p>


<h3>Value</h3>

<p>The asymptotic p-value
</p>

<hr>
<h2 id='blockPermute'>p-value Computation for Test of Exchangeability with Block Dependencies</h2><span id='topic+blockPermute'></span>

<h3>Description</h3>

<p>Generates a block permutation p-value. Uses a heuristic to
decide whether to use distance caching or simple block permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockPermute(X, block_boundaries = NULL, block_labels = NULL, nruns, type, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockPermute_+3A_x">X</code></td>
<td>
<p>The binary or real matrix on which to perform
permutation resampling</p>
</td></tr>
<tr><td><code id="blockPermute_+3A_block_boundaries">block_boundaries</code></td>
<td>
<p>Vector denoting the positions where a new
block of non-independent features starts. Default is NULL.</p>
</td></tr>
<tr><td><code id="blockPermute_+3A_block_labels">block_labels</code></td>
<td>
<p>Length <code class="reqn">P</code> vector recording the block label of each feature.
Default is NULL.</p>
</td></tr>
<tr><td><code id="blockPermute_+3A_nruns">nruns</code></td>
<td>
<p>The resampling number (use at least 1000)</p>
</td></tr>
<tr><td><code id="blockPermute_+3A_type">type</code></td>
<td>
<p>Either an unbiased estimate ('unbiased'), or exact ('valid') p-value (see Hemerik and Goeman, 2018), or both ('both').</p>
</td></tr>
<tr><td><code id="blockPermute_+3A_p">p</code></td>
<td>
<p>The power p of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependencies: buildForward, buildReverse, cachePermute,
cacheBlockPermute1, cacheBlockPermute2, getHammingDistance,
getLpDistance, naiveBlockPermute1, naiveBlockPermute2
</p>


<h3>Value</h3>

<p>The block permutation p-value
</p>

<hr>
<h2 id='buildForward'>Map from Indices to Label Pairs</h2><span id='topic+buildForward'></span>

<h3>Description</h3>

<p>Builds a map from indexes to pairs of labels. This is
for caching distances, to avoid recomputing Hamming distances
especially when dealing with high-dimensional (large <code class="reqn">P</code>) matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildForward(N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildForward_+3A_n">N</code></td>
<td>
<p>Sample size, i.e., nrow(<code class="reqn">\mathbf{X}</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependencies: None
</p>


<h3>Value</h3>

<p><code class="reqn">N \times N</code> matrix whose entries record the index
corresponding  to the pair of labels (indexed by the matrix dims)
</p>

<hr>
<h2 id='buildReverse'>Map from Label Pairs to Indices</h2><span id='topic+buildReverse'></span>

<h3>Description</h3>

<p>Builds a map from pairs of labels to indexes. This is
for caching distances, to avoid recomputing Hamming distances
especially when dealing with high-dimensional (large <code class="reqn">P</code>) matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildReverse(N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildReverse_+3A_n">N</code></td>
<td>
<p>Sample size, i.e., nrow(<code class="reqn">\mathbf{X}</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependencies: None
</p>


<h3>Value</h3>

<p><code class="reqn">N \times N</code> matrix whose entries record the index
corresponding  to the pair of labels (indexed by the matrix dims)
</p>

<hr>
<h2 id='cacheBlockPermute1'>Resampling Many V Statistics (Version 1)</h2><span id='topic+cacheBlockPermute1'></span>

<h3>Description</h3>

<p>Generates a block permutation distribution of <code class="reqn">V</code> statistic.
Precomputes distances and some indexing arrays to quickly
generate samples from the block permutation distribution of the <code class="reqn">V</code>
statistic of <code class="reqn">\mathbf{X}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cacheBlockPermute1(X, block_labels, nruns, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cacheBlockPermute1_+3A_x">X</code></td>
<td>
<p>The binary or real matrix on which to perform
permutation resampling</p>
</td></tr>
<tr><td><code id="cacheBlockPermute1_+3A_block_labels">block_labels</code></td>
<td>
<p>Length <code class="reqn">P</code> vector recording the block label of each feature</p>
</td></tr>
<tr><td><code id="cacheBlockPermute1_+3A_nruns">nruns</code></td>
<td>
<p>The resampling number (use at least 1000)</p>
</td></tr>
<tr><td><code id="cacheBlockPermute1_+3A_p">p</code></td>
<td>
<p>The power <code class="reqn">p</code> of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version is with block labels specified.
</p>
<p>Dependencies: buildForward, buildReverse, cachePermute, getHammingDistance, getLpDistance
</p>


<h3>Value</h3>

<p>A vector of resampled values of the <code class="reqn">V</code> statistic
</p>

<hr>
<h2 id='cacheBlockPermute2'>Resampling Many V Statistics (Version 2)</h2><span id='topic+cacheBlockPermute2'></span>

<h3>Description</h3>

<p>Generates a block permutation distribution of <code class="reqn">V</code> statistic.
Precomputes distances and some indexing arrays to quickly
generate samples from the block permutation distribution of the <code class="reqn">V</code>
statistic of <code class="reqn">\mathbf{X}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cacheBlockPermute2(X, block_boundaries, nruns, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cacheBlockPermute2_+3A_x">X</code></td>
<td>
<p>The binary or real matrix on which to perform
permutation resampling</p>
</td></tr>
<tr><td><code id="cacheBlockPermute2_+3A_block_boundaries">block_boundaries</code></td>
<td>
<p>Vector denoting the positions where a new
block of non-independent features starts</p>
</td></tr>
<tr><td><code id="cacheBlockPermute2_+3A_nruns">nruns</code></td>
<td>
<p>The resampling number (use at least 1000)</p>
</td></tr>
<tr><td><code id="cacheBlockPermute2_+3A_p">p</code></td>
<td>
<p>The power p of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version is with block boundaries specified.
</p>
<p>Dependencies: buildForward, buildReverse, cachePermute, getHammingDistance, getLpDistance
</p>


<h3>Value</h3>

<p>A vector of resampled values of the <code class="reqn">V</code> statistic
</p>

<hr>
<h2 id='cachePermute'>Permutation by Caching Distances</h2><span id='topic+cachePermute'></span>

<h3>Description</h3>

<p>What do you do when you have to compute pairwise distances many times, and those
damn distances take a long time to compute? Answer: You cache the distances and
permute the underlying sample labels!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cachePermute(dists, forward, reverse)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cachePermute_+3A_dists">dists</code></td>
<td>
<p><code class="reqn">{N \choose 2}</code> by <code class="reqn">B</code> matrix, with each column
containing the distances (ex: Hamming, <code class="reqn">l_p^p</code>) for the block</p>
</td></tr>
<tr><td><code id="cachePermute_+3A_forward">forward</code></td>
<td>
<p><code class="reqn">N \times N</code> matrix mapping the pairs of sample labels
to index of the <code class="reqn">{N \choose 2}</code>-length vector</p>
</td></tr>
<tr><td><code id="cachePermute_+3A_reverse">reverse</code></td>
<td>
<p><code class="reqn">{N \choose 2}\times 2</code> matrix mapping the index to
pairs of sample labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function permutes the distances (Hamming, <code class="reqn">l_p^p</code>, etc.) within blocks.
Permutations respect the fact that we are actually permuting the
underlying labels. Arguments forward and reverse should be
precomputed using buildForward and buildReverse.
</p>
<p>Dependencies: buildForward, buildReverse
</p>


<h3>Value</h3>

<p>A matrix with same dimensions as dists containing
the block-permuted pairwise distances
</p>

<hr>
<h2 id='distDataLargeP'>Asymptotic p-value of Exchangeability Using Distance Data</h2><span id='topic+distDataLargeP'></span>

<h3>Description</h3>

<p>Generates an asymptotic p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distDataLargeP(dist_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distDataLargeP_+3A_dist_list">dist_list</code></td>
<td>
<p>The list (length <code class="reqn">B</code>) of pairwise distance data. 
Each element in list should be either a distance matrix or a table recording
pairwise distances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a weighted convolution of chi-squares distribution of <code class="reqn">V</code> statistic 
by storing the provided list of distance data as an <code class="reqn">{N\choose2} \times B</code> array,
and then using large-<code class="reqn">P</code> theory to generate the asymptotic null distribution 
against which the p-value of observed <code class="reqn">V</code> statistic is computed. 
</p>
<p>Each element of dist_list should be a <code class="reqn">N\times N</code> distance matrix.
</p>
<p>Dependencies: buildReverse, getChi2Weights, weightedChi2P
</p>


<h3>Value</h3>

<p>The asymptotic p-value obtained from the weighted convolution of chi-squares
distribution.
</p>

<hr>
<h2 id='distDataPermute'>p-value Computation for Test of Exchangeability Using Distance Data</h2><span id='topic+distDataPermute'></span>

<h3>Description</h3>

<p>Generates a block permutation p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distDataPermute(dist_list, nruns, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distDataPermute_+3A_dist_list">dist_list</code></td>
<td>
<p>The list (length <code class="reqn">B</code>) of pairwise distance data. 
Each element in list should be either a distance matrix or a table recording
pairwise distances.</p>
</td></tr>
<tr><td><code id="distDataPermute_+3A_nruns">nruns</code></td>
<td>
<p>The resampling number (use at least 1000)</p>
</td></tr>
<tr><td><code id="distDataPermute_+3A_type">type</code></td>
<td>
<p>Either an unbiased estimate ('unbiased'), or exact ('valid') p-value (see Hemerik and Goeman, 2018), or both ('both').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a block permutation distribution of <code class="reqn">V</code> statistic by storing
the provided list of distance data as an <code class="reqn">{N\choose2} \times B</code> array,
and then permuting the underlying indices of each individual to generate 
resampled <code class="reqn">{N\choose2} \times B</code> arrays. The observed <code class="reqn">V</code> statistic is 
also computed from the distance data.   
</p>
<p>Each element of dist_list should be a <code class="reqn">N\times N</code> distance matrix.
</p>
<p>Dependencies: buildForward, buildReverse, cachePermute
</p>


<h3>Value</h3>

<p>The p-value obtained from comparing the empirical tail cdf of the observed 
<code class="reqn">V</code> statistic computed from distance data.
</p>

<hr>
<h2 id='distDataPValue'>A Non-parametric Test of Sample Exchangeability and Feature Independence (Distance List Version)</h2><span id='topic+distDataPValue'></span>

<h3>Description</h3>

<p>The V test computes the p-value of a multivariate dataset, which
informs the user about one of two decisions: (1) whether the sample is exchangeable 
at a given significance level, assuming that the feature dependencies are known; 
or (2) whether the features or groups of features are independent at a given significance
level, assuming that the sample is exchangeable. This version takes in a list of 
distance matrices recording pairwise distances between individuals across <code class="reqn">B</code> 
independent features. It can be used to test one of two hypotheses: (H1) the 
sample is exchangeable, assuming that each feature whose pairwise distance data
is available is statistically independent of any other feature, or (H2) the 
<code class="reqn">B</code> features whose pairwise distance data is available are independent, assuming
that the sample is exchangeable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distDataPValue(dist_list, largeP = FALSE, nruns = 1000, type = "unbiased")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distDataPValue_+3A_dist_list">dist_list</code></td>
<td>
<p>The list of distances.</p>
</td></tr>
<tr><td><code id="distDataPValue_+3A_largep">largeP</code></td>
<td>
<p>Boolean indicating whether to use large <code class="reqn">P</code> asymptotics. Default is FALSE.</p>
</td></tr>
<tr><td><code id="distDataPValue_+3A_nruns">nruns</code></td>
<td>
<p>Resampling number for exact test. Default is 1000.</p>
</td></tr>
<tr><td><code id="distDataPValue_+3A_type">type</code></td>
<td>
<p>Either an unbiased estimate of ('unbiased', default), or valid, but biased estimate of, ('valid') p-value 
(see Hemerik and Goeman, 2018), or both ('both'). Default is 'unbiased'. Note that unbiased estimate can return <code class="reqn">0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependencies: distDataLargeP and distDataPermute from auxiliary.R
</p>


<h3>Value</h3>

<p>The p-value to be used to test the null hypothesis of exchangeability.
</p>

<hr>
<h2 id='getBinVStat'>V Statistic for Binary Matrices</h2><span id='topic+getBinVStat'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">V</code> statistic for a binary matrix <code class="reqn">\mathbf{X}</code>, as defined in
Aw, Spence and Song (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBinVStat(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBinVStat_+3A_x">X</code></td>
<td>
<p>The <code class="reqn">N \times P</code> binary matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependencies: getHammingDistance
</p>


<h3>Value</h3>

<p><code class="reqn">V(\mathbf{X})</code>, the variance of the pairwise Hamming distance between samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(nrow = 5, ncol = 10, rbinom(50, 1, 0.5))
getBinVStat(X)

</code></pre>

<hr>
<h2 id='getBlockCov'>Covariance Computations Between Pairs of Distances (Block Dependencies Case)</h2><span id='topic+getBlockCov'></span>

<h3>Description</h3>

<p>Computes covariance matrix entries and associated alpha, beta
and gamma quantities defined in Aw, Spence and Song (2023),
for partitionable features that are grouped into blocks. Uses
precomputation to compute the unique entries of the asymptotic
covariance matrix of the pairwise Hamming distances in <code class="reqn">O(N^2)</code> time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBlockCov(X, block_boundaries, block_labels, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBlockCov_+3A_x">X</code></td>
<td>
<p>The binary or real matrix</p>
</td></tr>
<tr><td><code id="getBlockCov_+3A_block_boundaries">block_boundaries</code></td>
<td>
<p>Vector denoting the positions where a new
block of non-independent features starts.</p>
</td></tr>
<tr><td><code id="getBlockCov_+3A_block_labels">block_labels</code></td>
<td>
<p>Length <code class="reqn">P</code> vector recording the block label of each feature.</p>
</td></tr>
<tr><td><code id="getBlockCov_+3A_p">p</code></td>
<td>
<p>The power <code class="reqn">p</code> of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used in the large <code class="reqn">P</code> asymptotics of the permutation test.
</p>
<p>Dependencies: buildReverse, getHammingDistance, getLpDistance
</p>


<h3>Value</h3>

<p>The three distinct entries of covariance matrix, <code class="reqn">(\alpha, \beta, \gamma)</code>
</p>

<hr>
<h2 id='getChi2Weights'>Get Chi Square Weights</h2><span id='topic+getChi2Weights'></span>

<h3>Description</h3>

<p>Computes weights for the asymptotic random variable
from the <code class="reqn">\alpha, \beta</code> and <code class="reqn">\gamma</code> computed of data array <code class="reqn">\mathbf{X}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChi2Weights(alpha, beta, gamma, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getChi2Weights_+3A_alpha">alpha</code></td>
<td>
<p>covariance matrix entry computed from getCov</p>
</td></tr>
<tr><td><code id="getChi2Weights_+3A_beta">beta</code></td>
<td>
<p>covariance matrix entry computed from getCov</p>
</td></tr>
<tr><td><code id="getChi2Weights_+3A_gamma">gamma</code></td>
<td>
<p>covariance matrix entry computed from getCov</p>
</td></tr>
<tr><td><code id="getChi2Weights_+3A_n">N</code></td>
<td>
<p>The sample size, i.e., nrow(X) where X is the original dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used in the large <code class="reqn">P</code> asymptotics of the permutation test.
</p>
<p>Dependencies: None
</p>


<h3>Value</h3>

<p>The weights <code class="reqn">(w_1, w_2)</code>
</p>

<hr>
<h2 id='getCov'>Covariance Computations Between Pairs of Distances (Independent Case)</h2><span id='topic+getCov'></span>

<h3>Description</h3>

<p>Computes covariance matrix entries and associated alpha, beta
and gamma quantities defined in Aw, Spence and Song (2023),
assuming the <code class="reqn">P</code> features of the dataset <code class="reqn">\mathbf{X}</code> are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCov(X, p = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCov_+3A_x">X</code></td>
<td>
<p>The binary or real matrix</p>
</td></tr>
<tr><td><code id="getCov_+3A_p">p</code></td>
<td>
<p>The power <code class="reqn">p</code> of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used in the large <code class="reqn">P</code> asymptotics of the permutation test.
</p>
<p>Dependencies: buildReverse, getLpDistance
</p>


<h3>Value</h3>

<p>The three distinct entries of covariance matrix, <code class="reqn">(\alpha, \beta, \gamma)</code>
</p>

<hr>
<h2 id='getHammingDistance'>A Hamming Distance Vector Calculator</h2><span id='topic+getHammingDistance'></span>

<h3>Description</h3>

<p>Computes all pairwise Hamming distances for a binary matrix <code class="reqn">\mathbf{X}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHammingDistance(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHammingDistance_+3A_x">X</code></td>
<td>
<p>The <code class="reqn">N \times P</code> binary matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependencies: hamming_bitwise from fast_dist_calc.cpp
</p>


<h3>Value</h3>

<p>A length <code class="reqn">{N \choose 2}</code> vector of pairwise Hamming distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(nrow = 5, ncol = 10, rbinom(50, 1, 0.5))
getHammingDistance(X)

</code></pre>

<hr>
<h2 id='getLpDistance'>A <code class="reqn">l_p^p</code> Distance Vector Calculator</h2><span id='topic+getLpDistance'></span>

<h3>Description</h3>

<p>Computes all pairwise <code class="reqn">l_p^p</code> distances for a real matrix <code class="reqn">\mathbf{X}</code>,
for a specified choice of Minkowski norm exponent <code class="reqn">p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLpDistance(X, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLpDistance_+3A_x">X</code></td>
<td>
<p>The <code class="reqn">N \times P</code> real matrix</p>
</td></tr>
<tr><td><code id="getLpDistance_+3A_p">p</code></td>
<td>
<p>The power p of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependencies: lp_distance from fast_dist_calc.cpp
</p>


<h3>Value</h3>

<p>A length <code class="reqn">{N \choose 2}</code> vector of pairwise <code class="reqn">l_p^p</code> distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(nrow = 5, ncol = 10, rnorm(50))
getLpDistance(X, p = 2)

</code></pre>

<hr>
<h2 id='getPValue'>A Non-parametric Test of Sample Exchangeability and Feature Independence</h2><span id='topic+getPValue'></span>

<h3>Description</h3>

<p>The V test computes the p-value of a multivariate dataset <code class="reqn">\mathbf{X}</code>, which
informs the user about one of two decisions: (1) whether the sample is exchangeable 
at a given significance level, assuming that the feature dependencies are known; 
or (2) whether the features or groups of features are independent at a given significance
level, assuming that the sample is exchangeable.
See Aw, Spence and Song (2023) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPValue(
  X,
  block_boundaries = NULL,
  block_labels = NULL,
  largeP = FALSE,
  largeN = FALSE,
  nruns = 5000,
  type = "unbiased",
  p = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPValue_+3A_x">X</code></td>
<td>
<p>The binary or real matrix on which to perform test of exchangeability.</p>
</td></tr>
<tr><td><code id="getPValue_+3A_block_boundaries">block_boundaries</code></td>
<td>
<p>Vector denoting the positions where a new
block of non-independent features starts. Default is NULL.</p>
</td></tr>
<tr><td><code id="getPValue_+3A_block_labels">block_labels</code></td>
<td>
<p>Length <code class="reqn">P</code> vector recording the block label of each feature.
Default is NULL.</p>
</td></tr>
<tr><td><code id="getPValue_+3A_largep">largeP</code></td>
<td>
<p>Boolean indicating whether to use large <code class="reqn">P</code> asymptotics. Default is FALSE.</p>
</td></tr>
<tr><td><code id="getPValue_+3A_largen">largeN</code></td>
<td>
<p>Boolean indicating whether to use large <code class="reqn">N</code> asymptotics. Default is FALSE.</p>
</td></tr>
<tr><td><code id="getPValue_+3A_nruns">nruns</code></td>
<td>
<p>Resampling number for exact test. Default is 5000.</p>
</td></tr>
<tr><td><code id="getPValue_+3A_type">type</code></td>
<td>
<p>Either an unbiased estimate of ('unbiased', default), or valid, but biased estimate of, ('valid') p-value 
(see Hemerik and Goeman, 2018), or both ('both'). Default is 'unbiased'. Note that unbiased estimate can return <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="getPValue_+3A_p">p</code></td>
<td>
<p>The power <code class="reqn">p</code> of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code>. Default is 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Automatically detects if dataset is binary, and runs the Hamming
distance version of test if so. Otherwise, computes the squared
Euclidean distance between samples and evaluates whether the
variance of Euclidean distances, <code class="reqn">V</code>, is atypically large under the
null hypothesis of exchangeability. Note the user may tweak the
choice of power <code class="reqn">p</code> if they prefer an <code class="reqn">l_p^p</code> distance other than Euclidean.
</p>
<p>Under the hood, the variance statistic, <code class="reqn">V</code>, is computed efficiently.
Moreover, the user can specify their choice of block permutations,
large <code class="reqn">P</code> asymptotics, or large <code class="reqn">P</code> and large <code class="reqn">N</code> asymptotics. The latter two
return reasonably accurate p-values for moderately large dimensionalities.
</p>
<p>User recommendations: When the number of independent blocks <code class="reqn">B</code> or number of
independent features <code class="reqn">P</code> is at least 50, it is safe to use large <code class="reqn">P</code> asymptotics.
If <code class="reqn">P</code> or <code class="reqn">B</code> is small, however, stick with permutations.
</p>
<p>Dependencies: All functions in auxiliary.R
</p>


<h3>Value</h3>

<p>The p-value to be used to test the null hypothesis of exchangeability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 (get p-value of small matrix with independent features using exact test)
suppressWarnings(require(doParallel))
# registerDoParallel(cores = 2)

X1 &lt;- matrix(nrow = 5, ncol = 10, rbinom(50, 1, 0.5)) # binary matrix, small
getPValue(X1) # perform exact test with 5000 permutations

# should be larger than 0.05

# Example 2 (get p-value of high-dim matrix with independent features using asymptotic test)
X2 &lt;- matrix(nrow = 10, ncol = 1000, rnorm(1e4)) # real matrix, large enough
getPValue(X2, p = 2, largeP = TRUE) # very fast

# should be larger than 0.05
# getPValue(X2, p = 2) # slower, do not run (Output: 0.5764)

# Example 3 (get p-value of high-dim matrix with partitionable features using exact test)

X3 &lt;- matrix(nrow = 10, ncol = 1000, rbinom(1e4, 1, 0.5))
getPValue(X3, block_labels = rep(c(1,2,3,4,5), 200))

# Warning message: # there are features that have zero variation (i.e., all 0s or 1s)
# In getPValue(X3, block_labels = rep(c(1, 2, 3, 4, 5), 200)) :
# There exist columns with all ones or all zeros for binary X.

# Example 4 (get p-value of high-dim matrix with partitionable features using asymptotic test)

## This elaborate example generates binarized versions of time series data.

# Helper function to binarize a marker
# by converting z-scores to {0,1} based on
# standard normal quantiles
binarizeMarker &lt;- function(x, freq, ploidy) {
 if (ploidy == 1) {
   return((x &gt; qnorm(1-freq)) + 0)
 } else if (ploidy == 2) {
   if (x &lt;= qnorm((1-freq)^2)) {
     return(0)
   } else if (x &lt;= qnorm(1-freq^2)) {
     return(1)
   } else return(2)
 } else {
   cat("Specify valid ploidy number, 1 or 2")
 }
}

getAutoRegArray &lt;- function(B, N, maf_l = 0.38, maf_u = 0.5, rho = 0.5, ploid = 1) {
# get minor allele frequencies by sampling from uniform
mafs &lt;- runif(B, min = maf_l, max = maf_u)
# get AR array
ar_array &lt;- t(replicate(N, arima.sim(n = B, list(ar=rho))))
# theoretical column variance
column_var &lt;- 1/(1-rho^2)
# rescale so that variance per marker is 1
ar_array &lt;- ar_array / sqrt(column_var)
# rescale each column of AR array
for (b in 1:B) {
  ar_array[,b] &lt;- sapply(ar_array[,b],
                         binarizeMarker,
                         freq = mafs[b],
                         ploidy = ploid)
}
return(ar_array)
}

## Function to generate the data array with desired number of samples
getExHaplotypes &lt;- function(N) {
  array &lt;- do.call("cbind",
                   lapply(1:50, function(x) {getAutoRegArray(N, B = 20)}))
  return(array)
}

##  Generate data and run test
X4 &lt;- getExHaplotypes(10)
getPValue(X4, block_boundaries = seq(from = 1, to = 1000, by = 25), largeP = TRUE)

# stopImplicitCluster()

</code></pre>

<hr>
<h2 id='getRealVStat'>V Statistic for Real Matrices</h2><span id='topic+getRealVStat'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">V</code> statistic for a real matrix <code class="reqn">\mathbf{X}</code>,
where <code class="reqn">V(\mathbf{X})</code> = scaled variance of <code class="reqn">l_p^p</code> distances between the
row samples of <code class="reqn">\mathbf{X}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRealVStat(X, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRealVStat_+3A_x">X</code></td>
<td>
<p>The <code class="reqn">N \times P</code> real matrix</p>
</td></tr>
<tr><td><code id="getRealVStat_+3A_p">p</code></td>
<td>
<p>The power <code class="reqn">p</code> of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependencies: getLpDistance
</p>


<h3>Value</h3>

<p><code class="reqn">V(\mathbf{X})</code>, the variance of the pairwise <code class="reqn">l_p^p</code> distance between samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(nrow = 5, ncol = 10, rnorm(50))
getRealVStat(X, p = 2)

</code></pre>

<hr>
<h2 id='hamming_bitwise'>Fast Bitwise Hamming Distance Vector Computation</h2><span id='topic+hamming_bitwise'></span>

<h3>Description</h3>

<p>Takes in a binary matrix <code class="reqn">\mathbf{X}</code>, whose transpose <code class="reqn">\mathbf{X}^T</code>
has <code class="reqn">N</code> rows, and computes a vector recording all
<code class="reqn">{N \choose 2}</code> pairwise Hamming distances of <code class="reqn">\mathbf{X}^T</code>,
ordered lexicographically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hamming_bitwise(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hamming_bitwise_+3A_x">X</code></td>
<td>
<p>binary matrix (IntegerMatrix class )</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of Hamming distances (NumericVector class)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># t(X) = [[1,0], [0,1], [1,1]] --&gt; output = [2,1,1]
</code></pre>

<hr>
<h2 id='indGaussian'>Approximate p-value for Test of Exchangeability (Assuming Large N and P)</h2><span id='topic+indGaussian'></span>

<h3>Description</h3>

<p>Computes the large <code class="reqn">(N,P)</code> asymptotic p-value for dataset <code class="reqn">\mathbf{X}</code>,
assuming its <code class="reqn">P</code> features are independent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indGaussian(X, p = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indGaussian_+3A_x">X</code></td>
<td>
<p>The binary or real matrix on which to perform test of exchangeability</p>
</td></tr>
<tr><td><code id="indGaussian_+3A_p">p</code></td>
<td>
<p>The power p of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the large <code class="reqn">N</code> and large <code class="reqn">P</code> asymptotics of the permutation test.
</p>
<p>Dependencies: getBinVStat, getRealVStat, getCov, getChi2Weights
</p>


<h3>Value</h3>

<p>The asymptotic p-value
</p>

<hr>
<h2 id='indLargeP'>Approximate p-value for Test of Exchangeability (Assuming Large P)</h2><span id='topic+indLargeP'></span>

<h3>Description</h3>

<p>Computes the large <code class="reqn">P</code> asymptotic p-value for dataset <code class="reqn">\mathbf{X}</code>,
assuming its <code class="reqn">P</code> features are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indLargeP(X, p = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indLargeP_+3A_x">X</code></td>
<td>
<p>The binary or real matrix on which to perform test of exchangeability</p>
</td></tr>
<tr><td><code id="indLargeP_+3A_p">p</code></td>
<td>
<p>The power p of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the large <code class="reqn">P</code> asymptotics of the permutation test.
</p>
<p>Dependencies: getBinVStat, getRealVStat, getChi2Weights, weightedChi2P, getCov
</p>


<h3>Value</h3>

<p>The asymptotic p-value
</p>

<hr>
<h2 id='lp_distance'>Fast <code class="reqn">l_p^p</code> Distance Vector Computation</h2><span id='topic+lp_distance'></span>

<h3>Description</h3>

<p>Takes in a double matrix <code class="reqn">\mathbf{X}</code>, whose transpose <code class="reqn">\mathbf{X}^T</code>
has <code class="reqn">N</code> rows, and computes a vector recording all
<code class="reqn">{N \choose 2}</code> pairwise <code class="reqn">l_p^p</code> distances of <code class="reqn">\mathbf{X}^T</code>,
ordered lexicographically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_distance(X, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp_distance_+3A_x">X</code></td>
<td>
<p>double matrix (arma::mat class)</p>
</td></tr>
<tr><td><code id="lp_distance_+3A_p">p</code></td>
<td>
<p>numeric Minkowski power (double class)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of <code class="reqn">l_p^p</code> distances (arma::vec class)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># X = [[0.5,0.5],[0,1],[0.3,0.7]] --&gt; lPVec = [x,y,z]
# with x = (0.5^p + 0.5^p)
</code></pre>

<hr>
<h2 id='naiveBlockPermute1'>Resampling V Statistic (Version 1)</h2><span id='topic+naiveBlockPermute1'></span>

<h3>Description</h3>

<p>Generates a new array <code class="reqn">\mathbf{X}'</code> under the permutation null and then
returns the <code class="reqn">V</code> statistic computed for <code class="reqn">\mathbf{X}'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naiveBlockPermute1(X, block_labels, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="naiveBlockPermute1_+3A_x">X</code></td>
<td>
<p>The <code class="reqn">N \times P</code> binary or real matrix</p>
</td></tr>
<tr><td><code id="naiveBlockPermute1_+3A_block_labels">block_labels</code></td>
<td>
<p>A vector of length <code class="reqn">P</code>, whose <code class="reqn">p</code>th component indicates the block membership of feature <code class="reqn">p</code></p>
</td></tr>
<tr><td><code id="naiveBlockPermute1_+3A_p">p</code></td>
<td>
<p>The power <code class="reqn">p</code> of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is Version 1, which takes in the block labels. It is suitable in
the most general setting, where the features are grouped by labels.
Given original <code class="reqn">\mathbf{X}</code> and a list denoting labels of each feature,
independently permutes the rows within each block of <code class="reqn">\mathbf{X}</code> and returns resulting <code class="reqn">V</code>.
If block labels are not specified, then features are assumed independent, which
is to say that block_labels is set to 1:ncol(<code class="reqn">\mathbf{X}</code>).
</p>
<p>Dependencies: getBinVStat, getRealVStat
</p>


<h3>Value</h3>

<p><code class="reqn">V(\mathbf{X}')</code>, where <code class="reqn">\mathbf{X}'</code> is a resampled by permutation of entries blockwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(nrow = 5, ncol = 10, rnorm(50)) # real matrix example
naiveBlockPermute1(X, block_labels = c(1,1,2,2,3,3,4,4,5,5), p = 2) # use Euclidean distance

X &lt;- matrix(nrow = 5, ncol = 10, rbinom(50, 1, 0.5)) # binary matrix example
naiveBlockPermute1(X, block_labels = c(1,1,2,2,3,3,4,4,5,5))

</code></pre>

<hr>
<h2 id='naiveBlockPermute2'>Resampling V Statistic (Version 2)</h2><span id='topic+naiveBlockPermute2'></span>

<h3>Description</h3>

<p>Generates a new array <code class="reqn">\mathbf{X}'</code> under the permutation null and then
returns the <code class="reqn">V</code> statistic computed for <code class="reqn">\mathbf{X}'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naiveBlockPermute2(X, block_boundaries, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="naiveBlockPermute2_+3A_x">X</code></td>
<td>
<p>The <code class="reqn">N \times P</code> binary or real matrix</p>
</td></tr>
<tr><td><code id="naiveBlockPermute2_+3A_block_boundaries">block_boundaries</code></td>
<td>
<p>A vector of length at most P, whose entries indicate positions at which to demarcate blocks</p>
</td></tr>
<tr><td><code id="naiveBlockPermute2_+3A_p">p</code></td>
<td>
<p>The power p of <code class="reqn">l_p^p</code>, i.e., <code class="reqn">||x||_p^p = (x_1^p+...x_n^p)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is Version 2, which takes in the block boundaries. It is suitable
for use when the features are already arranged such that the block
memberships are determined by index delimiters. Given original <code class="reqn">\mathbf{X}</code> and
a list denoting labels of each feature, independently permutes the rows
within each block of <code class="reqn">\mathbf{X}</code> and returns resulting <code class="reqn">V</code>. If block labels are not specified,
then features are assumed independent, which is to say that block_labels is set to 1:ncol(<code class="reqn">\mathbf{X}</code>).
</p>
<p>Dependencies: getBinVStat, getRealVStat
</p>


<h3>Value</h3>

<p><code class="reqn">V(\mathbf{X}')</code>, where <code class="reqn">\mathbf{X}'</code> is a resampled by permutation of entries blockwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(nrow = 5, ncol = 10, rnorm(50)) # real matrix example
naiveBlockPermute2(X, block_boundaries = c(4,7,9), p = 2) # use Euclidean distance

X &lt;- matrix(nrow = 5, ncol = 10, rbinom(50, 1, 0.5)) # binary matrix example
naiveBlockPermute2(X, block_boundaries = c(4,7,9))

</code></pre>

<hr>
<h2 id='weightedChi2P'>Tail Probability for Chi Square Convolution Random Variable</h2><span id='topic+weightedChi2P'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">P(X &gt; val)</code> where <code class="reqn">X = w_1 Y + w_2 Z</code>, where
<code class="reqn">Y</code> is chi square distributed with <code class="reqn">d_1</code> degrees of freedom,
<code class="reqn">Z</code> is chi square distributed with <code class="reqn">d_2</code> degrees of freedom,
and <code class="reqn">w_1</code> and <code class="reqn">w_2</code> are weights with <code class="reqn">w_2</code> assumed positive.
The probability is computed using numerical integration of the
densities of the two chi square distributions. (Method: trapezoidal rule)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedChi2P(val, w1, w2, d1, d2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedChi2P_+3A_val">val</code></td>
<td>
<p>observed statistic</p>
</td></tr>
<tr><td><code id="weightedChi2P_+3A_w1">w1</code></td>
<td>
<p>weight of first chi square rv</p>
</td></tr>
<tr><td><code id="weightedChi2P_+3A_w2">w2</code></td>
<td>
<p>weight of second chi square rv, assumed positive</p>
</td></tr>
<tr><td><code id="weightedChi2P_+3A_d1">d1</code></td>
<td>
<p>degrees of freedom of first chi square rv</p>
</td></tr>
<tr><td><code id="weightedChi2P_+3A_d2">d2</code></td>
<td>
<p>degrees of freedom of second chi square rv</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used in the large <code class="reqn">P</code> asymptotics of the permutation test.
</p>
<p>Dependencies: None
</p>


<h3>Value</h3>

<p>1 - CDF = P(X &gt; val)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
