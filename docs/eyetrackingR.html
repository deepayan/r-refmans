<!DOCTYPE html><html><head><title>Help for package eyetrackingR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eyetrackingR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_aoi'><p>Add an area-of-interest to your dataset, based on x-y coordinates and the AOI rectangle.</p></a></li>
<li><a href='#analyze_boot_splines'><p>Estimate confidence intervals for bootstrapped splines data</p></a></li>
<li><a href='#analyze_time_bins'><p>analyze_time_bins()</p></a></li>
<li><a href='#analyze_time_clusters'><p>Bootstrap analysis of time-clusters.</p></a></li>
<li><a href='#clean_by_trackloss'><p>Clean data by removing high-trackloss trials/subjects.</p></a></li>
<li><a href='#describe_data'><p>Describe dataset</p></a></li>
<li><a href='#eyetrackingR'><p>eyetrackingR: A package for cleaning, analyzing, and visualizing eye-tracking datasets</p></a></li>
<li><a href='#get_time_clusters'><p>Get information about the clusters in a cluster-analysis</p></a></li>
<li><a href='#make_boot_splines_data'><p>Bootstrap resample splines for time-series data.</p></a></li>
<li><a href='#make_eyetrackingr_data'><p>Convert raw data for use in eyetrackingR</p></a></li>
<li><a href='#make_onset_data'><p>Make onset-contingent data.</p></a></li>
<li><a href='#make_switch_data'><p>Summarize data into time-to-switch from initial AOI.</p></a></li>
<li><a href='#make_time_cluster_data'><p>Make data for cluster analysis.</p></a></li>
<li><a href='#make_time_sequence_data'><p>make_time_sequence_data()</p></a></li>
<li><a href='#make_time_window_data'><p>Make a dataset collapsing over a time-window</p></a></li>
<li><a href='#plot.bin_analysis'><p>Plot test-statistic for each time-bin in a time-series</p></a></li>
<li><a href='#plot.boot_splines_analysis'><p>Plot differences in bootstrapped-splines data</p></a></li>
<li><a href='#plot.boot_splines_data'><p>Plot bootstrapped-splines data</p></a></li>
<li><a href='#plot.cluster_analysis'><p>Visualize the results of a cluster analysis.</p></a></li>
<li><a href='#plot.eyetrackingR_data_summary'><p>Plot some summarized data from eyetrackingR</p></a></li>
<li><a href='#plot.onset_data'><p>Plot onset-contingent data</p></a></li>
<li><a href='#plot.switch_data'><p>Plot mean switch-from-initial-AOI times.</p></a></li>
<li><a href='#plot.time_cluster_data'><p>Plot test-statistic for each time-bin in a time-series, highlight clusters.</p>
Plot time_cluster_data, highlights clusters of above-threshold time-bins.</a></li>
<li><a href='#plot.time_sequence_data'><p>Plot time-sequence data</p></a></li>
<li><a href='#plot.time_window_data'><p>Plot a time-window dataset</p></a></li>
<li><a href='#print.cluster_analysis'><p>Print Method for Cluster Analysis</p></a></li>
<li><a href='#reclass'><p>Add the original class/attributes back onto result (usually of dplyr operation)</p></a></li>
<li><a href='#simulate_eyetrackingr_data'><p>Simulate an eyetrackingR dataset</p></a></li>
<li><a href='#subset_by_window'><p>Extract a subset of the dataset within a time-window in each trial.</p></a></li>
<li><a href='#summary.bin_analysis'><p>Summary Method for Time-bin Analysis</p></a></li>
<li><a href='#summary.boot_splines_analysis'><p>Summary Method for Bootstrapped Splines Analysis</p></a></li>
<li><a href='#summary.cluster_analysis'><p>Summary Method for Cluster Analysis</p></a></li>
<li><a href='#summary.time_cluster_data'><p>Summary Method for Cluster Analysis</p></a></li>
<li><a href='#trackloss_analysis'><p>Analyze trackloss.</p></a></li>
<li><a href='#word_recognition'><p>Data collected in an infant eyetracking study</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Eye-Tracking Data Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Addresses tasks along the pipeline from raw
    data to analysis and visualization for eye-tracking data. Offers several
    popular types of analyses, including linear and growth curve time analyses,
    onset-contingent reaction time analyses, as well as several non-parametric
    bootstrapping approaches. For references to the approach see Mirman, 
    Dixon &amp; Magnuson (2008) &lt;<a href="https://doi.org/10.1016%2Fj.jml.2007.11.006">doi:10.1016/j.jml.2007.11.006</a>&gt;, and
    Barr (2008) &lt;<a href="https://doi.org/10.1016%2Fj.jml.2007.09.002">doi:10.1016/j.jml.2007.09.002</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://samforbes.me/eyetrackingR/">http://samforbes.me/eyetrackingR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/samhforbes/eyetrackingR/issues">https://github.com/samhforbes/eyetrackingR/issues</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-15</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), dplyr (&ge; 0.7.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom (&ge; 0.3.7), broom.mixed, ggplot2 (&ge; 2.0), lazyeval (&ge;
0.1.10), rlang, zoo (&ge; 1.7-12), tidyr (&ge; 0.3.1), purrr (&ge;
0.2.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pbapply, knitr, lme4 (&ge; 1.1-10), glmmTMB, MASS, Matrix,
testthat, rmarkdown, doMC, foreach</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-15 12:12:50 UTC; xbxr94</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel Forbes [aut, cre],
  Jacob Dink [aut],
  Brock Ferguson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Samuel Forbes &lt;samuel.h.forbes@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-15 13:42:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_aoi'>Add an area-of-interest to your dataset, based on x-y coordinates and the AOI rectangle.</h2><span id='topic+add_aoi'></span>

<h3>Description</h3>

<p>Eyetracking-R requires that there is a column for each area-of-interest, specifying whether the gaze is 
within that area for each sample. This function creates an AOI column if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_aoi(
  data,
  aoi_dataframe,
  x_col,
  y_col,
  aoi_name,
  x_min_col = "L",
  x_max_col = "R",
  y_min_col = "T",
  y_max_col = "B"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_aoi_+3A_data">data</code></td>
<td>
<p>Your data</p>
</td></tr>
<tr><td><code id="add_aoi_+3A_aoi_dataframe">aoi_dataframe</code></td>
<td>
<p>A dataframe specifying the bounding-box for the AOI</p>
</td></tr>
<tr><td><code id="add_aoi_+3A_x_col">x_col</code>, <code id="add_aoi_+3A_y_col">y_col</code></td>
<td>
<p>What are the column names for the x and y coordinates in your dataset?</p>
</td></tr>
<tr><td><code id="add_aoi_+3A_aoi_name">aoi_name</code></td>
<td>
<p>What is the name of this AOI?</p>
</td></tr>
<tr><td><code id="add_aoi_+3A_x_min_col">x_min_col</code>, <code id="add_aoi_+3A_x_max_col">x_max_col</code></td>
<td>
<p>What are the column names for the left and right edge of the AOI-bounding box?
Default &quot;L&quot;,&quot;R&quot;</p>
</td></tr>
<tr><td><code id="add_aoi_+3A_y_min_col">y_min_col</code>, <code id="add_aoi_+3A_y_max_col">y_max_col</code></td>
<td>
<p>What are the column names for the top and bottom edge of the AOI-bounding box?
Default &quot;T&quot;,&quot;B&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many eyetracking software packages export your data with a column corresponding to each AOI; however, if
your software does not do this, or if you had to define or revise your AOIs after running the experiment,
then this function will add the necessary AOI columns for you. The function takes two dataframes: (1) your
original data, (2) a dataframe specifying the bounding box for the AOI. The latter can specify a different
bounding box for each trial, each subject, each image, or even each video-frame&ndash; anything you like. The
two dataframes are simply joined by matching any columns they have in common (case sensitive!), so if
there's a unique AOI for each &quot;Trial&quot; in the <code>aoi_dataframe</code>, and there's a &quot;Trial&quot; column in the
<code>data</code> dataframe, then the unique AOI coordinates for each trial will be used.
</p>


<h3>Value</h3>

<p>Dataset with a new column indicating whether gaze is in the AOI
</p>

<hr>
<h2 id='analyze_boot_splines'>Estimate confidence intervals for bootstrapped splines data</h2><span id='topic+analyze_boot_splines'></span><span id='topic+analyze_boot_splines.boot_splines_data'></span>

<h3>Description</h3>

<p>Deprecated. Performing this analysis should be done by calling <code>analyze_time_bins(test="boot_splines")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_boot_splines(data)

## S3 method for class 'boot_splines_data'
analyze_boot_splines(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_boot_splines_+3A_data">data</code></td>
<td>
<p>The output of the <code>boot_splines_data</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates a confidence interval over the difference between means (within- or between-subjects)
from <code>boot_splines_data</code>. Confidence intervals are derived from the alpha argument in 
<code>boot_splines_data</code> (e.g., alpha = .05, CI=(.025,.975); alpha=.01, CI=(.005,.0995))
</p>


<h3>Value</h3>

<p>A dataframe indicating means and CIs for each time-bin
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>analyze_boot_splines(boot_splines_data)</code>: 
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition, 
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE )
response_window &lt;- subset_by_window(data, window_start_time = 15500, window_end_time = 21000, 
                                    rezero = FALSE)
response_time &lt;- make_time_sequence_data(response_window, time_bin_size = 500, aois = "Animate", 
                                         predictor_columns = "Sex", 
                                         summarize_by = "ParticipantName")
                                         
# bootstrap resample 500 smoothed splines from the dataset,
# comparing females versus females at an alpha of .05                                         
df_bootstrapped &lt;- make_boot_splines_data(response_time,
                                          predictor_column = 'Sex',
                                          within_subj = FALSE,
                                          bs_samples = 500,
                                          alpha = .05,
                                          smoother = "smooth.spline")

# analyze the divergences that occurred
boot_splines_analysis &lt;- analyze_boot_splines(df_bootstrapped)
summary(boot_splines_analysis)

## End(Not run)
</code></pre>

<hr>
<h2 id='analyze_time_bins'>analyze_time_bins()</h2><span id='topic+analyze_time_bins'></span><span id='topic+analyze_time_bins.time_sequence_data'></span>

<h3>Description</h3>

<p>Runs a test on each time-bin of <code>time_sequence_data</code>. Supports <code>t.test</code>,
<code>wilcox.test</code>, <code>(g)lm</code>, and <code>(g)lmer</code>. Also includes support for
the &quot;bootstrapped-splines&quot; test (see <code>?make_boot_splines_data</code> and
<a href="http://www.eyetracking-r.com/vignettes/divergence">the divergence vignette</a> for more info).
By default, this function uses 'proportion-looking' (<code>Prop</code>) as the DV, which can be changed
by manually specifying the formula. Results can be plotted to see how test-results or parameters
estimates vary over time. P-values can be adjusted for multiple comparisons with <code>p_adjust_method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_time_bins(data, ...)

## S3 method for class 'time_sequence_data'
analyze_time_bins(
  data,
  predictor_column,
  test,
  threshold = NULL,
  alpha = NULL,
  aoi = NULL,
  formula = NULL,
  treatment_level = NULL,
  p_adjust_method = "none",
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_time_bins_+3A_data">data</code></td>
<td>
<p>The output of the 'make_time_sequence_data' function</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_...">...</code></td>
<td>
<p>Any other arguments to be passed to the selected 'test' function (e.g.,
paired, var.equal, etc.)</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_predictor_column">predictor_column</code></td>
<td>
<p>The variable whose test statistic you are interested in. If you are not
interested in a predictor, but the intercept, you can enter &quot;intercept&quot; for this argument.
Interaction terms are not currently supported.</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_test">test</code></td>
<td>
<p>What type of test should be performed in each time bin? Supports
<code>t.test</code>, <code>wilcox.test</code>, <code>(g)lm</code>, and <code>(g)lmer</code>. Also includes support for
the &quot;bootstrapped-splines&quot; test (see <code>?make_boot_splines_data</code> and
<a href="http://www.eyetracking-r.com/vignettes/divergence">the divergence vignette</a> for more info).</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_threshold">threshold</code></td>
<td>
<p>Value of statistic used in determining significance</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for determining significance, ignored if threshold is given</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_aoi">aoi</code></td>
<td>
<p>Which AOI should be analyzed? If not specified (and dataframe has multiple AOIs),
then AOI should be a predictor/covariate in your model (so 'formula' needs
to be specified).</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_formula">formula</code></td>
<td>
<p>What formula should be used for the test? Optional for all but
<code>(g)lmer</code>, if unset will use <code>Prop ~ [predictor_column]</code>. Change this if you want to use a custom DV.</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_treatment_level">treatment_level</code></td>
<td>
<p>If your predictor is a factor, regression functions like 'lm' and 'lmer' by default will
treatment-code it. One option is to sum-code this predictor yourself before entering it
into this function. Another is to use the 'treatment_level' argument, which specifies the
level of the predictor. For example, you are testing a model where 'Target' is a predictor,
which has two levels, 'Animate' and 'Inanimate'. R will code 'Animate' as the reference
level, and code 'Inanimate' as the treatment level. You'd therefore want to set
'treatment_level = Inanimate'.</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p>Method to adjust p.values for multiple corrections (default=&quot;none&quot;).
See <code>p.adjust.methods</code>.</p>
</td></tr>
<tr><td><code id="analyze_time_bins_+3A_quiet">quiet</code></td>
<td>
<p>Should messages and progress bars be suppressed? Default is to show</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe indicating the results of the test at each time-bin.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>analyze_time_bins(time_sequence_data)</code>: 
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition,
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)
response_time &lt;- make_time_sequence_data(data, time_bin_size = 250,
                                         predictor_columns = c("MCDI_Total"),
                                         aois = "Animate", summarize_by = "ParticipantName")
tb_analysis &lt;- analyze_time_bins(response_time, predictor_column = "MCDI_Total",
                                 test = "lm", threshold = 2)
summary(tb_analysis)

## End(Not run)

</code></pre>

<hr>
<h2 id='analyze_time_clusters'>Bootstrap analysis of time-clusters.</h2><span id='topic+analyze_time_clusters'></span><span id='topic+analyze_time_clusters.time_cluster_data'></span>

<h3>Description</h3>

<p>Takes data whose time bins have been clustered by test-statistic (using the <code>make_time_cluster_data</code>
function) and performs a permutation test (Maris &amp; Oostenveld, 2007). This analysis takes a summed
statistic for each cluster, and compares it to the &quot;null&quot; distribution of sum statistics obtained by
shuffling/resampling the data and extracting the largest cluster from each resample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_time_clusters(data, ...)

## S3 method for class 'time_cluster_data'
analyze_time_clusters(
  data,
  within_subj,
  samples = 2000,
  formula = NULL,
  shuffle_by = NULL,
  parallel = FALSE,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_time_clusters_+3A_data">data</code></td>
<td>
<p>The output of the <code>make_time_cluster_data</code> function</p>
</td></tr>
<tr><td><code id="analyze_time_clusters_+3A_...">...</code></td>
<td>
<p>Other args for to selected 'test' function; should be identical to those passed to
<code>make_time_cluster_data</code> function</p>
</td></tr>
<tr><td><code id="analyze_time_clusters_+3A_within_subj">within_subj</code></td>
<td>
<p>Logical indicating whether to perform within-subjects bootstrap resampling.</p>
</td></tr>
<tr><td><code id="analyze_time_clusters_+3A_samples">samples</code></td>
<td>
<p>How many iterations should be performed in the bootstrap resampling procedure?</p>
</td></tr>
<tr><td><code id="analyze_time_clusters_+3A_formula">formula</code></td>
<td>
<p>Formula for test. Should be identical to that passed to make_time_cluster_data fxn (if
arg ignored there, can be ignored here)</p>
</td></tr>
<tr><td><code id="analyze_time_clusters_+3A_shuffle_by">shuffle_by</code></td>
<td>
<p>Along which attribute should the data be resampled? Default is the predictor
column. But if the predictor_column is numeric *and* within-subjects, then observations with the
same predictor value could nevertheless correspond to distinct conditions/categories that
should be shuffled separately. For example, when using vocabulary scores to predict looking
behavior, a participant might get identical vocab scores for verbs and nouns; these are
nevertheless distinct categories that should be re-assigned separately when
bootstrap-resampling data. The 'shuffle_by' argument allows you to specify a column which
indicates these kinds of distinct categories that should be resampled separately&ndash;
but it's only needed if you've specified a numeric *and* within-subjects predictor column.</p>
</td></tr>
<tr><td><code id="analyze_time_clusters_+3A_parallel">parallel</code></td>
<td>
<p>Use foreach for speed boost? By default off. May not work on Windows.</p>
</td></tr>
<tr><td><code id="analyze_time_clusters_+3A_quiet">quiet</code></td>
<td>
<p>Display progress bar/messages? No progress bar when parallel=TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cluster-analysis object, which can be plotted and summarized to examine which temporal periods
show a significant effect of the predictor variable
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>analyze_time_clusters(time_cluster_data)</code>: 
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition,
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE )
response_window &lt;- subset_by_window(data, window_start_time = 15500, window_end_time = 21000,
                                    rezero = FALSE)
response_time &lt;- make_time_sequence_data(response_window, time_bin_size = 500, aois = "Animate",
                                         predictor_columns = "Sex")

time_cluster_data &lt;- make_time_cluster_data(data = response_time, predictor_column = "SexM",
                         aoi = "Animate", test = "lmer",
                         threshold = 1.5,
                         formula = LogitAdjusted ~ Sex + (1|Trial) + (1|ParticipantName))
summary(time_cluster_data)
plot(time_cluster_data)

# analyze time clusters in a non-parametric analysis

tc_analysis &lt;- analyze_time_clusters(time_cluster_data, within_subj = FALSE,
                                     samples = 2000)
plot(tc_analysis)
summary(tc_analysis)

## End(Not run)

</code></pre>

<hr>
<h2 id='clean_by_trackloss'>Clean data by removing high-trackloss trials/subjects.</h2><span id='topic+clean_by_trackloss'></span>

<h3>Description</h3>

<p>Remove trials/participants with too much trackloss, with a customizable threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_by_trackloss(
  data,
  participant_prop_thresh = 1,
  trial_prop_thresh = 1,
  window_start_time = -Inf,
  window_end_time = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_by_trackloss_+3A_data">data</code></td>
<td>
<p>Data already run through <code>make_eyetrackingr_data</code></p>
</td></tr>
<tr><td><code id="clean_by_trackloss_+3A_participant_prop_thresh">participant_prop_thresh</code></td>
<td>
<p>Maximum proportion of trackloss for participants</p>
</td></tr>
<tr><td><code id="clean_by_trackloss_+3A_trial_prop_thresh">trial_prop_thresh</code></td>
<td>
<p>Maximum proportion of trackloss for trials</p>
</td></tr>
<tr><td><code id="clean_by_trackloss_+3A_window_start_time">window_start_time</code>, <code id="clean_by_trackloss_+3A_window_end_time">window_end_time</code></td>
<td>
<p>Time-window within which you want trackloss analysis to
be based. Allows you to keep the entire trial window for data, but clean based on the trackloss
within a subset of it</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cleaned data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition, 
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)

# scrub all trials with greater than 25% trackloss, and all
# participants with greater than 25% trackloss on average
# during the timeperiod 15500-2100
data_clean &lt;- clean_by_trackloss(data,
                                 participant_prop_thresh = .25, 
                                 trial_prop_thresh = .25,
                                 window_start_time = 15500, 
                                 window_end_time = 21000
)

# scrub all trials with greater than 25% trackloss, but leave participants with a high average
data_clean &lt;- clean_by_trackloss(data,
                                 trial_prop_thresh = .25,
                                 window_start_time = 15500, 
                                 window_end_time = 21000
)
  
</code></pre>

<hr>
<h2 id='describe_data'>Describe dataset</h2><span id='topic+describe_data'></span>

<h3>Description</h3>

<p>Returns descriptive statistics about a column of choice. A simple convenience function that wraps
<code>dplyr::group_by</code> and <code>dplyr::summarize</code>, allowing a quick glance at the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe_data(
  data,
  describe_column,
  group_columns,
  quantiles = c(0.025, 0.975)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_data_+3A_data">data</code></td>
<td>
<p>Data already run through <code>make_eyetrackingr_data</code></p>
</td></tr>
<tr><td><code id="describe_data_+3A_describe_column">describe_column</code></td>
<td>
<p>The column to return descriptive statistics about.</p>
</td></tr>
<tr><td><code id="describe_data_+3A_group_columns">group_columns</code></td>
<td>
<p>Any columns to group by when calculating descriptive statistics (e.g., participants,
conditions, etc.)</p>
</td></tr>
<tr><td><code id="describe_data_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector of length two with quantiles to compute (default: <code>c(.025, .975)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe giving descriptive statistics for the <code>describe_column</code>, including mean, SD, var,
min, max, and number of trials
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition, 
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)
describe_data(data, describe_column = "Animate", group_columns = "ParticipantName")
 
</code></pre>

<hr>
<h2 id='eyetrackingR'>eyetrackingR: A package for cleaning, analyzing, and visualizing eye-tracking datasets</h2><span id='topic+eyetrackingR'></span>

<h3>Description</h3>

<p>This package addresses tasks along the pipeline from raw eye-tracking data to analysis and
visualization. It offers several popular types of analyses, including linear and
growth curve time analyses, onset-contingent reaction time analyses, and cluster mass
analyses, as well as novel non-parametric approaches to time-series data.
</p>


<h3>Details</h3>

<p>For more information and tutorials, visit <a href="http://www.eyetracking-r.com/">http://www.eyetracking-r.com/</a>.
</p>

<hr>
<h2 id='get_time_clusters'>Get information about the clusters in a cluster-analysis</h2><span id='topic+get_time_clusters'></span><span id='topic+get_time_clusters.time_cluster_data'></span><span id='topic+get_time_clusters.cluster_analysis'></span>

<h3>Description</h3>

<p>Get information about the clusters in a cluster-analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_time_clusters(object)

## S3 method for class 'time_cluster_data'
get_time_clusters(object)

## S3 method for class 'cluster_analysis'
get_time_clusters(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_time_clusters_+3A_object">object</code></td>
<td>
<p>The output of the <code>analyze_time_clusters</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with information about the clusters
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>get_time_clusters(time_cluster_data)</code>: Get time clusters dataframe
</p>
</li>
<li> <p><code>get_time_clusters(cluster_analysis)</code>: Get time clusters dataframe
</p>
</li></ul>

<hr>
<h2 id='make_boot_splines_data'>Bootstrap resample splines for time-series data.</h2><span id='topic+make_boot_splines_data'></span><span id='topic+make_boot_splines_data.time_sequence_data'></span>

<h3>Description</h3>

<p>Deprecated. Performing this analysis should be done by calling <code>analyze_time_bins(test="boot_splines")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_boot_splines_data(
  data,
  predictor_column,
  within_subj,
  aoi,
  bs_samples,
  smoother,
  resolution,
  alpha,
  ...
)

## S3 method for class 'time_sequence_data'
make_boot_splines_data(
  data,
  predictor_column,
  within_subj,
  aoi = NULL,
  bs_samples = 1000,
  smoother = "smooth.spline",
  resolution = NULL,
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_boot_splines_data_+3A_data">data</code></td>
<td>
<p>The output of <code>time_sequence_data()</code></p>
</td></tr>
<tr><td><code id="make_boot_splines_data_+3A_predictor_column">predictor_column</code></td>
<td>
<p>What predictor var to split by? Maximum two conditions</p>
</td></tr>
<tr><td><code id="make_boot_splines_data_+3A_within_subj">within_subj</code></td>
<td>
<p>Are the two conditions within or between subjects?</p>
</td></tr>
<tr><td><code id="make_boot_splines_data_+3A_aoi">aoi</code></td>
<td>
<p>Which AOI do you wish to perform the analysis on?</p>
</td></tr>
<tr><td><code id="make_boot_splines_data_+3A_bs_samples">bs_samples</code></td>
<td>
<p>How many iterations to run bootstrap resampling? Default 1000</p>
</td></tr>
<tr><td><code id="make_boot_splines_data_+3A_smoother">smoother</code></td>
<td>
<p>Smooth data using &quot;smooth.spline,&quot; &quot;loess,&quot; or &quot;none&quot; for no smoothing</p>
</td></tr>
<tr><td><code id="make_boot_splines_data_+3A_resolution">resolution</code></td>
<td>
<p>What resolution should we return predicted splines at, in ms? e.g., 10ms = 100
intervals per second, or hundredths of a second. Default is the same size as time-bins.</p>
</td></tr>
<tr><td><code id="make_boot_splines_data_+3A_alpha">alpha</code></td>
<td>
<p>p-value when the groups are sufficiently &quot;diverged&quot;</p>
</td></tr>
<tr><td><code id="make_boot_splines_data_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method builds confidence intervals around proportion-looking data by bootstrap resampling.
Data can be smoothed by fitting smoothing splines. This function performs the bootstrap resampling,
<code>analyze_boot_splines</code> generates confidence intervals and tests for divergences.
</p>
<p>Limited to statistical test between two conditions.
</p>


<h3>Value</h3>

<p>A bootstrapped distribution of samples for each time-bin
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>make_boot_splines_data(time_sequence_data)</code>: 
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition, 
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE )
response_window &lt;- subset_by_window(data, window_start_time = 15500, 
                                    window_end_time = 21000, rezero = FALSE)
response_time &lt;- make_time_sequence_data(response_window, time_bin_size = 500, aois = "Animate", 
                                         predictor_columns = "Sex", 
                                         summarize_by = "ParticipantName")
                                         
df_bootstrapped &lt;- make_boot_splines_data(response_time, 
                                          predictor_column = 'Sex', 
                                          within_subj = FALSE, 
                                          bs_samples = 500, 
                                          alpha = .05,
                                          smoother = "smooth.spline") 

## End(Not run)

</code></pre>

<hr>
<h2 id='make_eyetrackingr_data'>Convert raw data for use in eyetrackingR</h2><span id='topic+make_eyetrackingr_data'></span>

<h3>Description</h3>

<p>This should be the first function you use when using eyetrackingR for a project (potentially with
the exception of 'add_aoi', if you need to add AOIs). This function takes your raw dataframe, as 
well as information about your dataframe. It confirms that all the columns are the right format, 
based on this information. Further if <code>treat_non_aoi_looks_as_missing</code> is set to TRUE, it 
converts non-AOI looks to missing data (see the &quot;Preparing your data&quot; vignette for more 
information).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_eyetrackingr_data(
  data,
  participant_column,
  trackloss_column,
  time_column,
  trial_column,
  aoi_columns,
  treat_non_aoi_looks_as_missing,
  item_columns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_eyetrackingr_data_+3A_data">data</code></td>
<td>
<p>Your original data. See details section below.</p>
</td></tr>
<tr><td><code id="make_eyetrackingr_data_+3A_participant_column">participant_column</code></td>
<td>
<p>Column name for participant identifier</p>
</td></tr>
<tr><td><code id="make_eyetrackingr_data_+3A_trackloss_column">trackloss_column</code></td>
<td>
<p>Column name indicating trackloss</p>
</td></tr>
<tr><td><code id="make_eyetrackingr_data_+3A_time_column">time_column</code></td>
<td>
<p>Column name indicating time</p>
</td></tr>
<tr><td><code id="make_eyetrackingr_data_+3A_trial_column">trial_column</code></td>
<td>
<p>Column name indicating trial identifier</p>
</td></tr>
<tr><td><code id="make_eyetrackingr_data_+3A_aoi_columns">aoi_columns</code></td>
<td>
<p>Names of AOIs</p>
</td></tr>
<tr><td><code id="make_eyetrackingr_data_+3A_treat_non_aoi_looks_as_missing">treat_non_aoi_looks_as_missing</code></td>
<td>
<p>This is a logical indicating how you would like to perform
&quot;proportion-looking&quot; calculations, which are central to eyetrackingR's eyetracking analyses. If set to
TRUE, any samples that are not in any of the AOIs (defined with the <code>aoi_columns</code> 
argument) are treated as missing data; when it comes time for eyetrackingR to calculate 
proportion looking to an AOI, this will be calculated as &quot;time looking to that AOI divided by 
time looking to all other AOIs.&quot; In contrast, if this parameter is set to FALSE, proportion 
looking to an AOI will be calculated as &quot;time looking to that AOI divided by total time 
looking.&quot;</p>
</td></tr>
<tr><td><code id="make_eyetrackingr_data_+3A_item_columns">item_columns</code></td>
<td>
<p>Column names indicating items (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>eyetrackingR is designed to deal with data in a (relatively) raw form,
where each row specifies a sample. Each row should represent an equally spaced unit of time
(e.g., if your eye-tracker's sample rate is 100hz, then each row corresponds to the
eye-position every 10ms). This is in contrast to the more parsed data that the software bundled
with eye-trackers can sometimes output (e.g., already parsed into saccades or fixations). For
eyetrackingR, the simplest data is the best. This also maximizes compatibility: eyetrackingR
will work with any eye-tracker's data (e.g., Eyelink, Tobii, etc.), since it requires the most
basic format.
</p>


<h3>Value</h3>

<p>Dataframe ready for use in eyetrackingR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition, 
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)
  
</code></pre>

<hr>
<h2 id='make_onset_data'>Make onset-contingent data.</h2><span id='topic+make_onset_data'></span>

<h3>Description</h3>

<p>Divide trials into which AOI participants started on. Calculate switches away from this AOI, using
a rolling window to determine what length consitutes a switch. Augment original data with a column
indicating whether each row is a switch-away sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_onset_data(
  data,
  onset_time,
  fixation_window_length = NULL,
  target_aoi,
  distractor_aoi = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_onset_data_+3A_data">data</code></td>
<td>
<p>The original (verified) data</p>
</td></tr>
<tr><td><code id="make_onset_data_+3A_onset_time">onset_time</code></td>
<td>
<p>When to check for participants' &quot;starting&quot; AOI?</p>
</td></tr>
<tr><td><code id="make_onset_data_+3A_fixation_window_length">fixation_window_length</code></td>
<td>
<p>Which AOI is currently being fixated is determined by taking a rolling
average of this length (ms). This is the width of window for rolling average.</p>
</td></tr>
<tr><td><code id="make_onset_data_+3A_target_aoi">target_aoi</code></td>
<td>
<p>Which AOI is the target that should be switched *to*</p>
</td></tr>
<tr><td><code id="make_onset_data_+3A_distractor_aoi">distractor_aoi</code></td>
<td>
<p>Which AOI is the distractor that should be switched *from* (default = !target_aoi)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Original dataframe augmented with column indicating switch away from target AOI
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition, 
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)
response_window &lt;- subset_by_window(data, window_start_time = 15500, window_end_time = 21000, 
                                    rezero = FALSE)
inanimate_trials &lt;- subset(response_window, grepl('(Spoon|Bottle)', Trial))
onsets &lt;- make_onset_data(inanimate_trials, onset_time = 15500, target_aoi='Inanimate')

## End(Not run)

</code></pre>

<hr>
<h2 id='make_switch_data'>Summarize data into time-to-switch from initial AOI.</h2><span id='topic+make_switch_data'></span><span id='topic+make_switch_data.onset_data'></span>

<h3>Description</h3>

<p>Take trials split by initial-AOI, and determine how quickly participants switch away from that AOI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_switch_data(data, predictor_columns, summarize_by)

## S3 method for class 'onset_data'
make_switch_data(data, predictor_columns = NULL, summarize_by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_switch_data_+3A_data">data</code></td>
<td>
<p>The output of <code>make_onset_data</code></p>
</td></tr>
<tr><td><code id="make_switch_data_+3A_predictor_columns">predictor_columns</code></td>
<td>
<p>Variables/covariates of interest when analyzing time-to-switch</p>
</td></tr>
<tr><td><code id="make_switch_data_+3A_summarize_by">summarize_by</code></td>
<td>
<p>Should the data be summarized along, e.g., participants, items, etc.? 
If so, give column name(s) here. If left blank, will leave trials distinct. The former is 
needed for more traditional analyses (t.tests, ANOVAs), while the latter is preferable for 
mixed-effects models (lmer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe indicating initial AOI and time-to-switch from that AOI for each
trial/subject/item/etc.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>make_switch_data(onset_data)</code>: 
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition, 
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)
response_window &lt;- subset_by_window(data, window_start_time = 15500, window_end_time = 21000, 
                                    rezero = FALSE)
inanimate_trials &lt;- subset(response_window, grepl('(Spoon|Bottle)', Trial))
onsets &lt;- make_onset_data(inanimate_trials, onset_time = 15500, 
                          fixation_window_length = 100, target_aoi='Inanimate')
                          
df_switch &lt;- make_switch_data(onsets, predictor_columns = "MCDI_Total", 
             summarize_by = "ParticipantName")
plot(df_switch, "MCDI_Total")

## End(Not run)
                          
</code></pre>

<hr>
<h2 id='make_time_cluster_data'>Make data for cluster analysis.</h2><span id='topic+make_time_cluster_data'></span><span id='topic+make_time_cluster_data.time_sequence_data'></span>

<h3>Description</h3>

<p>Takes data that has been summarized into time-bins by <code>make_time_sequence_data()</code>, finds adjacent time
bins that pass some test-statistic threshold, and assigns these adjacent bins into groups (clusters).
Output is ready for a cluster permutation-based analyses (Maris &amp; Oostenveld, 2007). Supports <code>t.test</code>,
<code>wilcox.test</code>, <code>(g)lm</code>, and <code>(g)lmer</code>. Also includes support for
the &quot;bootstrapped-splines&quot; test (see <code>?make_boot_splines_data</code> and
<a href="http://www.eyetracking-r.com/vignettes/divergence">the divergence vignette</a> for more info).
By default, this function uses 'proportion-looking' (<code>Prop</code>) as the DV, which can be changed
by manually specifying the formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_time_cluster_data(data, ...)

## S3 method for class 'time_sequence_data'
make_time_cluster_data(
  data,
  predictor_column,
  aoi = NULL,
  test,
  threshold = NULL,
  formula = NULL,
  treatment_level = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_time_cluster_data_+3A_data">data</code></td>
<td>
<p>The output of the <code>make_time_sequence_data</code> function</p>
</td></tr>
<tr><td><code id="make_time_cluster_data_+3A_...">...</code></td>
<td>
<p>Any other arguments to be passed to the selected 'test' function (e.g., paired,
var.equal, etc.)</p>
</td></tr>
<tr><td><code id="make_time_cluster_data_+3A_predictor_column">predictor_column</code></td>
<td>
<p>The column name containing the variable whose test statistic you are interested in.</p>
</td></tr>
<tr><td><code id="make_time_cluster_data_+3A_aoi">aoi</code></td>
<td>
<p>Which AOI should be analyzed? If not specified (and dataframe has multiple AOIs),
then AOI should be a predictor/covariate in your model (so 'formula' needs
to be specified).</p>
</td></tr>
<tr><td><code id="make_time_cluster_data_+3A_test">test</code></td>
<td>
<p>What type of test should be performed in each time bin? Supports
<code>t.test</code>, <code>(g)lm</code>, or <code>(g)lmer</code>. Also includes experimental support for
the &quot;bootstrapped-splines&quot; test (see <code>?make_boot_splines_data</code> and
<a href="http://www.eyetracking-r.com/vignettes/divergence">the divergence vignette</a>
for more info). Does not support <code>wilcox.test</code>.</p>
</td></tr>
<tr><td><code id="make_time_cluster_data_+3A_threshold">threshold</code></td>
<td>
<p>Time-bins with test-statistics greater than this amount will be grouped into clusters.</p>
</td></tr>
<tr><td><code id="make_time_cluster_data_+3A_formula">formula</code></td>
<td>
<p>What formula should be used for test? Optional (for all but <code>(g)lmer</code>), if unset
uses <code>Prop ~ [predictor_column]</code></p>
</td></tr>
<tr><td><code id="make_time_cluster_data_+3A_treatment_level">treatment_level</code></td>
<td>
<p>If your predictor is a factor, regression functions like 'lm' and 'lmer' by default will
treatment-code it. One option is to sum-code this predictor yourself before entering it
into this function. Another is to use the 'treatment_level' argument, which specifies the
level of the predictor. For example, you are testing a model where 'Target' is a predictor,
which has two levels, 'Animate' and 'Inanimate'. R will code 'Animate' as the reference
level, and code 'Inanimate' as the treatment level. You'd therefore want to set
'treatment_level = Inanimate'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data, augmented with information about clusters. Calling summary on this data will
describe these clusters. The dataset is ready for the <code><a href="#topic+analyze_time_clusters">analyze_time_clusters</a></code> method.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>make_time_cluster_data(time_sequence_data)</code>: Make data for time cluster analysis
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition,
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE )
response_window &lt;- subset_by_window(data, window_start_time = 15500, window_end_time = 21000,
                                    rezero = FALSE)

# identify clusters in the sequence data using a t-test with
# threshold t-value of 2

# (note: t-tests require a summarized dataset)
response_time &lt;- make_time_sequence_data(response_window, time_bin_size = 500, aois = "Animate",
                                         predictor_columns = "Sex",
                                         summarize_by = "ParticipantName")

time_cluster_data &lt;- make_time_cluster_data(data = response_time,
                                            predictor_column = "Sex",
                                            aoi = "Animate",
                                            test = "t.test",
                                            threshold = 2
)

# identify clusters in the sequence data using an lmer() random-effects
# model with a threshold t-value of 1.5.

# random-effects models don't require us to summarize
response_time &lt;- make_time_sequence_data(response_window, time_bin_size = 500, aois = "Animate",
                                         predictor_columns = "Sex")

# but they do require a formula to be specified
time_cluster_data &lt;- make_time_cluster_data(data = response_time,
                           predictor_column = "SexM",
                           aoi = "Animate",
                           test = "lmer",
                           threshold = 1.5,
                           formula = LogitAdjusted ~ Sex + (1|Trial) + (1|ParticipantName)
)

## End(Not run)

</code></pre>

<hr>
<h2 id='make_time_sequence_data'>make_time_sequence_data()</h2><span id='topic+make_time_sequence_data'></span>

<h3>Description</h3>

<p>Creates time-bins and summarizes proportion-looking within each time-bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_time_sequence_data(
  data,
  time_bin_size,
  aois = NULL,
  predictor_columns = NULL,
  other_dv_columns = NULL,
  summarize_by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_time_sequence_data_+3A_data">data</code></td>
<td>
<p>The output of <code>make_eyetrackingr_data</code></p>
</td></tr>
<tr><td><code id="make_time_sequence_data_+3A_time_bin_size">time_bin_size</code></td>
<td>
<p>How large should each time bin be? Units are whatever units your <code>time</code> column is in</p>
</td></tr>
<tr><td><code id="make_time_sequence_data_+3A_aois">aois</code></td>
<td>
<p>Which AOI(s) is/are of interest? Defaults to all specified in
<code>make_eyetracking_r_data</code></p>
</td></tr>
<tr><td><code id="make_time_sequence_data_+3A_predictor_columns">predictor_columns</code></td>
<td>
<p>Which columns indicate predictor variables, and therefore should be
preserved in grouping operations?</p>
</td></tr>
<tr><td><code id="make_time_sequence_data_+3A_other_dv_columns">other_dv_columns</code></td>
<td>
<p>Within each time-bin, this function will calculate not only proportion-
looking, but also the mean of any columns specified here.</p>
</td></tr>
<tr><td><code id="make_time_sequence_data_+3A_summarize_by">summarize_by</code></td>
<td>
<p>Should the data be summarized along, e.g., participants, items, etc.? If
so, give column name(s) here. If left blank, will leave trials distinct. The former is needed
for more traditional analyses (<code>t.test</code>, <code>ANOVA</code>), while the latter is preferable for
mixed-effects models (<code>lmer</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aside from proportion looking (<code>Prop</code>), this function returns several columns useful for subsequent
analysis:
</p>

<ul>
<li> <p><code>LogitAdjusted</code> - The logit is defined as <code>log( Prop / (1 - Prop) )</code>. This
transformation attempts to map bounded <code>0,1</code> data to the real number line. Unfortunately,
for data that is exactly 0 or 1, this is undefined. One solution is add a very small value to
any datapoints that equal 0, and subtract a small value to any datapoints that equal 1 (we use
1/2 the smallest nonzero value for this adjustment).
</p>
</li>
<li> <p><code>Elog</code> - Another way of calculating a corrected logit transformation is to
add a small value <code>epsilon</code> to both the numerator and denominator of the logit equation (we
use 0.5).
</p>
</li>
<li> <p><code>Weights</code> - These attempt to further correct the Elog transformation, since the
variance of the logit depends on the mean. They can be used in a mixed effects model by setting
the <code>weights=Weights</code> in <code>lmer</code> (note that this is the reciprocal of the
weights calculated in <a href="https://talklab.psy.gla.ac.uk/tvw/elogit-wt.html">this empirical logit
walkthrough</a>, so you do *not* set <code>weights = 1/Weights</code> as done there.)
</p>
</li>
<li> <p><code>ArcSin</code> - The arcsine-root transformation of the raw proportions, defined as
<code>asin(sqrt(Prop))</code>
</p>
</li>
<li> <p><code>ot</code> - These columns (ot1-ot7) represent (centered) orthogonal time polynomials,
needed for growth curve analysis. See
<a href="http://www.eyetracking-r.com/vignettes/growth_curve_analysis">the vignette on growth curve
models</a> for more details.
</p>
</li></ul>



<h3>Value</h3>

<p>Data binned into time-bins, with proportion-looking and transformations as well as orthogonal
time-polynomials for growth curve analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition,
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)

# bin data in 250ms bins, and generate a dataframe
# with a single AOI (Animate) predicted by Sex, and summarized by ParticipantName
response_time &lt;- make_time_sequence_data(data,
                                         time_bin_size = 250,
                                         predictor_columns = c("Sex"),
                                         aois = "Animate",
                                         summarize_by = "ParticipantName"
)

# optionally specify other columns in the data
# to be included in the generated dataframe
# (e.g., for use in statistical models)
# bin data in 250ms bins, and generate a dataframe
# with Animate and MCDI_Total summarized by ParticipantName
response_time &lt;- make_time_sequence_data(data,
                                         time_bin_size = 250,
                                         predictor_columns = c("Sex","MCDI_Total"),
                                         aois = "Animate",
                                         summarize_by = "ParticipantName"
)

</code></pre>

<hr>
<h2 id='make_time_window_data'>Make a dataset collapsing over a time-window</h2><span id='topic+make_time_window_data'></span>

<h3>Description</h3>

<p>Collapse time across our entire window and return a dataframe ready for analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_time_window_data(
  data,
  aois = NULL,
  predictor_columns = NULL,
  other_dv_columns = NULL,
  summarize_by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_time_window_data_+3A_data">data</code></td>
<td>
<p>The output of <code>make_eyetrackingr_data</code></p>
</td></tr>
<tr><td><code id="make_time_window_data_+3A_aois">aois</code></td>
<td>
<p>Which AOI(s) is/are of interest? Defaults to all specified in
<code>make_eyetracking_r_data</code></p>
</td></tr>
<tr><td><code id="make_time_window_data_+3A_predictor_columns">predictor_columns</code></td>
<td>
<p>Which columns indicate predictor vars, and therefore should be preserved in
grouping operations?</p>
</td></tr>
<tr><td><code id="make_time_window_data_+3A_other_dv_columns">other_dv_columns</code></td>
<td>
<p>Within each participant/trial (or whatever is specified in <code>summarize_by</code>),
this function will calculate not only proportion-looking, but also the mean of any columns specified here.</p>
</td></tr>
<tr><td><code id="make_time_window_data_+3A_summarize_by">summarize_by</code></td>
<td>
<p>Should the data be summarized along, e.g., participants, items, etc.? If so, give
column names here. If left blank, will leave trials distinct. The former is needed for more traditional
analyses (<code>t.test</code>, <code>ANOVA</code>), while the latter is preferable for mixed-effects models (<code>lmer</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aside from proportion looking (<code>Prop</code>), this function returns several columns useful for subsequent
analysis:
</p>

<ul>
<li> <p><code>LogitAdjusted</code> - The logit is defined as <code>log( Prop / (1 - Prop) )</code>. This
transformation attempts to map bounded <code>0,1</code> data to the real number line. Unfortunately,
for data that is exactly 0 or 1, this is undefined. One solution is add a very small value to
any datapoints that equal 0, and subtract a small value to any datapoints that equal 1 (we use
1/2 the smallest nonzero value for this adjustment).
</p>
</li>
<li> <p><code>Elog</code> - Another way of calculating a corrected logit transformation is to
add a small value <code>epsilon</code> to both the numerator and denominator of the logit equation (we
use 0.5).
</p>
</li>
<li> <p><code>Weights</code> - These attempt to further correct the Elog transformation, since the
variance of the logit depends on the mean. They can be used in a mixed effects model by setting
the <code>weights=Weights</code> in <code>lmer</code> (note that this is the reciprocal of the
weights calculated in <a href="https://talklab.psy.gla.ac.uk/tvw/elogit-wt.html">this empirical logit
walkthrough</a>, so you do *not* set <code>weights = 1/Weights</code> as done there.)
</p>
</li>
<li> <p><code>ArcSin</code> - The arcsine-root transformation of the raw proportions, defined as
<code>asin(sqrt(Prop))</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Data with proportion-looking and transformations (logit, arc-sin, etc.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition,
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)

# generate a dataset summarizing an AOI (Animate) by ParticipantName
response_window_agg_by_sub &lt;- make_time_window_data(data,
                                                    aois='Animate',
                                                    summarize_by = "ParticipantName"
)

## Not run: 
# optionally included additional columns for use as predictors
# in later statistical models
response_window_agg_by_sub &lt;- make_time_window_data(data,
                                                    aois='Animate',
                                                    predictor_columns=c('Age','MCDI_Total'),
                                                    summarize_by = "ParticipantName"
)

# plot the aggregated data for sanity check
plot(response_window_agg_by_sub, predictor_columns="Age", dv = "LogitAdjusted")

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.bin_analysis'>Plot test-statistic for each time-bin in a time-series</h2><span id='topic+plot.bin_analysis'></span>

<h3>Description</h3>

<p>Plot the result from the <code>analyze_time_bins</code> function, with the statistic and threshold for each bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bin_analysis'
plot(x, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bin_analysis_+3A_x">x</code></td>
<td>
<p>The output of <code>analyze_time_bins</code></p>
</td></tr>
<tr><td><code id="plot.bin_analysis_+3A_type">type</code></td>
<td>
<p>This function can plot the test-statistic (&quot;statistic&quot;), the parameter estimate +/-
std. error (&quot;estimate&quot;), the p-value (&quot;pvalue&quot;) or the negative-log-pvalue (&quot;neg_log_pvalue&quot;).
When test gives critical-statistic, default is to plot the test-statistic. Otherwise, default
is to plot the estimate. For wilcox, only p-values can be plotted.</p>
</td></tr>
<tr><td><code id="plot.bin_analysis_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot.boot_splines_analysis'>Plot differences in bootstrapped-splines data</h2><span id='topic+plot.boot_splines_analysis'></span>

<h3>Description</h3>

<p>Plot the means and CIs of bootstrapped spline difference estimates and intervals
(either within-subjects or between-subjects)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot_splines_analysis'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.boot_splines_analysis_+3A_x">x</code></td>
<td>
<p>The output of the <code>analyze_boot_splines</code> function</p>
</td></tr>
<tr><td><code id="plot.boot_splines_analysis_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot.boot_splines_data'>Plot bootstrapped-splines data</h2><span id='topic+plot.boot_splines_data'></span>

<h3>Description</h3>

<p>Plot the means and CIs of bootstrapped splines (either within-subjects or between-subjects)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot_splines_data'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.boot_splines_data_+3A_x">x</code></td>
<td>
<p>The output of the <code>make_boot_splines_data</code> function</p>
</td></tr>
<tr><td><code id="plot.boot_splines_data_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot.cluster_analysis'>Visualize the results of a cluster analysis.</h2><span id='topic+plot.cluster_analysis'></span>

<h3>Description</h3>

<p>Plots the result of the bootstrapping cluster analysis. A histogram of the sum statistics for the
shuffled (null) distribution, with the sum statisics for each of the clusters indicated by dashed lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_analysis'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cluster_analysis_+3A_x">x</code></td>
<td>
<p>object returned by cluster_analysis()</p>
</td></tr>
<tr><td><code id="plot.cluster_analysis_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot.eyetrackingR_data_summary'>Plot some summarized data from eyetrackingR</h2><span id='topic+plot.eyetrackingR_data_summary'></span>

<h3>Description</h3>

<p>Plots the data returned from <code>describe_data</code>. Like that function, this is a convenient 
wrapper good for sanity checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eyetrackingR_data_summary'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.eyetrackingR_data_summary_+3A_x">x</code></td>
<td>
<p>The data returned by <code>make_time_window_data()</code></p>
</td></tr>
<tr><td><code id="plot.eyetrackingR_data_summary_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot.onset_data'>Plot onset-contingent data</h2><span id='topic+plot.onset_data'></span>

<h3>Description</h3>

<p>Divide trials into which AOI participants started on; plot proportion looking away from that AOI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'onset_data'
plot(x, predictor_columns = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.onset_data_+3A_x">x</code></td>
<td>
<p>The output of the <code>make_onset_data</code> function</p>
</td></tr>
<tr><td><code id="plot.onset_data_+3A_predictor_columns">predictor_columns</code></td>
<td>
<p>Column(s) by which to facet the data. Maximum two columns. Will perform
median split if numeric.</p>
</td></tr>
<tr><td><code id="plot.onset_data_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot.switch_data'>Plot mean switch-from-initial-AOI times.</h2><span id='topic+plot.switch_data'></span>

<h3>Description</h3>

<p>Boxplot of mean switch time aggregated by subjects within each FirstAOI, potentially faceted by
predictor_columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'switch_data'
plot(x, predictor_columns = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.switch_data_+3A_x">x</code></td>
<td>
<p>The output of the <code>make_switch_data</code> function</p>
</td></tr>
<tr><td><code id="plot.switch_data_+3A_predictor_columns">predictor_columns</code></td>
<td>
<p>Column(s) by which to facet the data. Maximum two columns. Will perform
median split if numeric.</p>
</td></tr>
<tr><td><code id="plot.switch_data_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot.time_cluster_data'>Plot test-statistic for each time-bin in a time-series, highlight clusters.
Plot time_cluster_data, highlights clusters of above-threshold time-bins.</h2><span id='topic+plot.time_cluster_data'></span>

<h3>Description</h3>

<p>Plot test-statistic for each time-bin in a time-series, highlight clusters.
Plot time_cluster_data, highlights clusters of above-threshold time-bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'time_cluster_data'
plot(x, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.time_cluster_data_+3A_x">x</code></td>
<td>
<p>The output of <code>make_time_cluster_data</code></p>
</td></tr>
<tr><td><code id="plot.time_cluster_data_+3A_type">type</code></td>
<td>
<p>This function can plot the test-statistic (&quot;statistic&quot;), the parameter estimate +/-
std. error (&quot;estimate&quot;), the p-value (&quot;pvalue&quot;) or the negative-log-pvalue (&quot;neg_log_pvalue&quot;).
When test gives critical-statistic, default is to plot the test-statistic. Otherwise, default
is to plot the estimate. For wilcox, only p-values can be plotted; for boot-splines, p-values
cannot be plotted.</p>
</td></tr>
<tr><td><code id="plot.time_cluster_data_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot.time_sequence_data'>Plot time-sequence data</h2><span id='topic+plot.time_sequence_data'></span>

<h3>Description</h3>

<p>Plot the timecourse of looking. Each AOI will be plotted in a separate pane, and data can be
split into groups by a predictor column. Data is collapsed by subject for plotting. Supports
overlaying the predictions of a growth-curve mixed effects model on the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'time_sequence_data'
plot(x, predictor_column = NULL, dv = "Prop", model = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.time_sequence_data_+3A_x">x</code></td>
<td>
<p>Your data from <code>make_time_sequence_data</code>. Will be collapsed by
subject for plotting (unless already collapsed by some other factor).</p>
</td></tr>
<tr><td><code id="plot.time_sequence_data_+3A_predictor_column">predictor_column</code></td>
<td>
<p>Data can be grouped by a predictor column (median split is performed if
numeric)</p>
</td></tr>
<tr><td><code id="plot.time_sequence_data_+3A_dv">dv</code></td>
<td>
<p>What measure of gaze do you want to use? (<code>Prop</code>, <code>Elog</code>, or
<code>ArcSin</code>)</p>
</td></tr>
<tr><td><code id="plot.time_sequence_data_+3A_model">model</code></td>
<td>
<p>(Optional) A growth-curve mixed effects model (from <code>lmer</code>) that
was used on the <code>time_sequence_data</code>. If model is given, this function will overlay the
predictions of that model on the data</p>
</td></tr>
<tr><td><code id="plot.time_sequence_data_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition,
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)
response_time &lt;- make_time_sequence_data(data, time_bin_size = 250,
                                         predictor_columns = c("MCDI_Total"),
                                         aois = "Animate", summarize_by = "ParticipantName")

# visualize time results
plot(response_time, predictor_column = "MCDI_Total")

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.time_window_data'>Plot a time-window dataset</h2><span id='topic+plot.time_window_data'></span>

<h3>Description</h3>

<p>Plots the data returned from <code>make_time_window_data</code>. Data can be mapped onto (up to two)
predictor columns. If no predictor columns are supplied, AOI is placed on the x-axis; otherwise,
data for each AOI is set in a separate facet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'time_window_data'
plot(x, predictor_columns = NULL, dv = "Prop", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.time_window_data_+3A_x">x</code></td>
<td>
<p>The data returned by make_time_window_data()</p>
</td></tr>
<tr><td><code id="plot.time_window_data_+3A_predictor_columns">predictor_columns</code></td>
<td>
<p>Up to two columns indicating predictors. The first maps to the X-axis,
the second to group/color. If the latter is numeric, a median split is performed.</p>
</td></tr>
<tr><td><code id="plot.time_window_data_+3A_dv">dv</code></td>
<td>
<p>Which dv should be used in plotting? Raw proportion-looking (&quot;Prop&quot;), empirical logit
(&quot;Elog&quot;), or &quot;ArcSin&quot;?</p>
</td></tr>
<tr><td><code id="plot.time_window_data_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are collapsed by-participants for plotting.
</p>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition,
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE)
response_window_agg_by_sub &lt;- make_time_window_data(data,
                                                    aois='Animate',
                                                    predictor_columns=c('Age','MCDI_Total'))

plot(response_window_agg_by_sub, predictor_columns="Age", dv = "LogitAdjusted")

## End(Not run)

</code></pre>

<hr>
<h2 id='print.cluster_analysis'>Print Method for Cluster Analysis</h2><span id='topic+print.cluster_analysis'></span>

<h3>Description</h3>

<p>Print Method for Cluster Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_analysis'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cluster_analysis_+3A_x">x</code></td>
<td>
<p>The output of the <code>analyze_clusters</code> function</p>
</td></tr>
<tr><td><code id="print.cluster_analysis_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints information about the bootstrapped null distribution, as well as information about each cluster.
</p>

<hr>
<h2 id='reclass'>Add the original class/attributes back onto result (usually of dplyr operation)</h2><span id='topic+reclass'></span><span id='topic+reclass.eyetrackingR_df'></span>

<h3>Description</h3>

<p>Add the original class/attributes back onto result (usually of dplyr operation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclass(x, result, ...)

## S3 method for class 'eyetrackingR_df'
reclass(x, result, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reclass_+3A_x">x</code></td>
<td>
<p>The original object, class inforamation you want to restore.</p>
</td></tr>
<tr><td><code id="reclass_+3A_result">result</code></td>
<td>
<p>Some transformation of <code>x</code>, which may have removed its class/attributes.</p>
</td></tr>
<tr><td><code id="reclass_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>result</code>, now with class/attribute information restored.
</p>
<p>The <code>result</code>, now with class/attribute information restored.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>reclass(eyetrackingR_df)</code>: Add the original class/attributes back onto result (usually of dplyr operation)
</p>
</li></ul>

<hr>
<h2 id='simulate_eyetrackingr_data'>Simulate an eyetrackingR dataset</h2><span id='topic+simulate_eyetrackingr_data'></span>

<h3>Description</h3>

<p>This function creates an eyetrackingR dataset (i.e., already run through make_eyetrackingr_data).
This can be helpful for examining the false-alarm and sensitivity of analysis-techniques via
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_eyetrackingr_data(
  num_participants = 16,
  num_items_per_condition = 6,
  trial_length = 5000,
  pref = 0.5,
  pref_window = c(1, trial_length),
  noisy_window = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_eyetrackingr_data_+3A_num_participants">num_participants</code></td>
<td>
<p>Number of participants</p>
</td></tr>
<tr><td><code id="simulate_eyetrackingr_data_+3A_num_items_per_condition">num_items_per_condition</code></td>
<td>
<p>Number of trials per-subject per-condition.</p>
</td></tr>
<tr><td><code id="simulate_eyetrackingr_data_+3A_trial_length">trial_length</code></td>
<td>
<p>How long is the trial (in ms)?</p>
</td></tr>
<tr><td><code id="simulate_eyetrackingr_data_+3A_pref">pref</code></td>
<td>
<p>Their preference between the two AOIs in the &quot;high&quot; condition,
where 1 is 100
preference). In the &quot;low&quot; condition, their preference between the two AOIs is equal, so default
is no effect of condition.</p>
</td></tr>
<tr><td><code id="simulate_eyetrackingr_data_+3A_pref_window">pref_window</code></td>
<td>
<p>Vector of length two, specifying start and end of time-window in
which participants expressed the preference specified in <code>pref</code>. Default is the entire trial</p>
</td></tr>
<tr><td><code id="simulate_eyetrackingr_data_+3A_noisy_window">noisy_window</code></td>
<td>
<p>Vector of length two, specifying start and end of time-window in
which there was substantial trackloss during the trial.</p>
</td></tr>
<tr><td><code id="simulate_eyetrackingr_data_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with eye-tracking data
</p>

<hr>
<h2 id='subset_by_window'>Extract a subset of the dataset within a time-window in each trial.</h2><span id='topic+subset_by_window'></span>

<h3>Description</h3>

<p>One of the more annoying aspects of preparing raw eyetracking data is filtering data down into the relevant
window within the trial, since for many experiments the precise start and end time of this window can vary 
from trial to trial. This function allows for several approaches to subsetting data into the relevant time-
window&ndash; see 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_by_window(
  data,
  rezero = TRUE,
  remove = TRUE,
  window_start_msg = NULL,
  window_end_msg = NULL,
  msg_col = NULL,
  window_start_col = NULL,
  window_end_col = NULL,
  window_start_time = NULL,
  window_end_time = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_by_window_+3A_data">data</code></td>
<td>
<p>Your original dataset</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_rezero">rezero</code></td>
<td>
<p>Should the beginning of the window be considered the zero point of the timestamp?
Default TRUE</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_remove">remove</code></td>
<td>
<p>Should everything before the beginning and after the end of the window be removed? 
Default TRUE. If set to FALSE and <code>rezero</code> is set to FALSE, an error is thrown (since in this case,
the function would not do anything).</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_window_start_msg">window_start_msg</code></td>
<td>
<p>For method (1). A message that is present only in the row whose time corresponds 
to the trial start time. Common for eyetrackers that send a message at trial/stimuli start.</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_window_end_msg">window_end_msg</code></td>
<td>
<p>For method (1). A message that is present only in the row whose time corresponds 
to the trial end time. Common for eyetrackers that send a message at trial-end/keypress/lookaway/etc.</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_msg_col">msg_col</code></td>
<td>
<p>For method (1). If you are indicating the trial start/end with a message column,
this is the name of that column.</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_window_start_col">window_start_col</code></td>
<td>
<p>For method (2). A column that gives the start time for each trial.</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_window_end_col">window_end_col</code></td>
<td>
<p>For method (2). A column that gives the end time for each trial.</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_window_start_time">window_start_time</code></td>
<td>
<p>For method (3). Number indicating a start time that applies to all trials.</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_window_end_time">window_end_time</code></td>
<td>
<p>For method (3). Number indicating an end time that applies to all trials.</p>
</td></tr>
<tr><td><code id="subset_by_window_+3A_quiet">quiet</code></td>
<td>
<p>Suppress messages? Default FALSE</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> The trial start/end times can be indicated by a message that is sent (e.g., TRIAL_START) in a 
particular row for each trial. In this case, the timestamp of that row is used.
</p>
</li>
<li><p> The trial start/end times can be indicated in by a column that specifies trial start/end times for each
trial.
</p>
</li>
<li><p> The trial start/end times can be indicated by the actual start and stop time, the same across all
trials (the simplest case).
</p>
</li></ol>

<p>If you only have a start time but the end time doesn't need adjusting, then leave the end time argument blank;
and vice versa.
</p>
<p>This function can either rezero your data (the trial start time you select is the new zero-time-point), or 
not. The former is useful when performing initial data-cleaning (e.g., different trial-starts on each 
trial, as indicated by a message), and the latter is useful if you want to &quot;zoom in&quot; on a particular 
portion of your data while keeping obvious the fact that there were other parts of the trial (e.g., an 
image always appears 5000ms-7000ms in the trial, so for one analysis you are only interested in this 
portion).
</p>


<h3>Value</h3>

<p>Subsetted data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("word_recognition")
data &lt;- make_eyetrackingr_data(word_recognition, 
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)

# zoom in to 15500-21000ms
response_window &lt;- subset_by_window(data,
                                    window_start_time = 15500,
                                    window_end_time = 21000, rezero = FALSE, remove = TRUE)

# zoom in to 15500-21000ms and re-zero so timestamps start at 0
response_window &lt;- subset_by_window(data,
                                    window_start_time = 15500, 
                                    window_end_time = 21000, 
                                    rezero = TRUE, 
                                    remove = TRUE)

# keep all data, but re-zero it
response_window &lt;- subset_by_window(data,
                                    window_start_time = 0, 
                                    rezero = TRUE, 
                                    remove = FALSE)

</code></pre>

<hr>
<h2 id='summary.bin_analysis'>Summary Method for Time-bin Analysis</h2><span id='topic+summary.bin_analysis'></span>

<h3>Description</h3>

<p>Summary Method for Time-bin Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bin_analysis'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bin_analysis_+3A_object">object</code></td>
<td>
<p>The output of the <code>analyze_time_bins</code> function</p>
</td></tr>
<tr><td><code id="summary.bin_analysis_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints information about each run of statistically significant time-bins, separately for
positive and negative
</p>

<hr>
<h2 id='summary.boot_splines_analysis'>Summary Method for Bootstrapped Splines Analysis</h2><span id='topic+summary.boot_splines_analysis'></span>

<h3>Description</h3>

<p>Summary Method for Bootstrapped Splines Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot_splines_analysis'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.boot_splines_analysis_+3A_object">object</code></td>
<td>
<p>The output of the <code>boot_splines_data</code> function</p>
</td></tr>
<tr><td><code id="summary.boot_splines_analysis_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a list of divergence-times.
</p>

<hr>
<h2 id='summary.cluster_analysis'>Summary Method for Cluster Analysis</h2><span id='topic+summary.cluster_analysis'></span>

<h3>Description</h3>

<p>Summary Method for Cluster Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_analysis'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cluster_analysis_+3A_object">object</code></td>
<td>
<p>The output of the <code>analyze_clusters</code> function</p>
</td></tr>
<tr><td><code id="summary.cluster_analysis_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints information about the bootstrapped null distribution, as well as information about each cluster.
</p>

<hr>
<h2 id='summary.time_cluster_data'>Summary Method for Cluster Analysis</h2><span id='topic+summary.time_cluster_data'></span>

<h3>Description</h3>

<p>Summary Method for Cluster Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'time_cluster_data'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.time_cluster_data_+3A_object">object</code></td>
<td>
<p>The output of the <code>analyze_clusters</code> function</p>
</td></tr>
<tr><td><code id="summary.time_cluster_data_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints information about the bootstrapped null distribution, as well as information about each cluster.
</p>

<hr>
<h2 id='trackloss_analysis'>Analyze trackloss.</h2><span id='topic+trackloss_analysis'></span>

<h3>Description</h3>

<p>Get information on trackloss in your data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackloss_analysis(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trackloss_analysis_+3A_data">data</code></td>
<td>
<p>The output of <code>make_eyetrackingr_data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe describing trackloss by-trial and by-participant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(word_recognition)
data &lt;- make_eyetrackingr_data(word_recognition, 
                               participant_column = "ParticipantName",
                               trial_column = "Trial",
                               time_column = "TimeFromTrialOnset",
                               trackloss_column = "TrackLoss",
                               aoi_columns = c('Animate','Inanimate'),
                               treat_non_aoi_looks_as_missing = TRUE
)

tl_analysis &lt;- trackloss_analysis(data)

</code></pre>

<hr>
<h2 id='word_recognition'>Data collected in an infant eyetracking study</h2><span id='topic+word_recognition'></span>

<h3>Description</h3>

<p>Data from a simple 2-alternative forced choice (2AFC) word recognition task administered to 19- 
and 24-month-olds. On each trial, infants were shown a picture of an animate object (e.g., a 
horse) and an inanimate object (e.g., a spoon). After inspecting the images, they disappeared and
they heard a label referring to one of them (e.g., &quot;The horse is nearby!&quot;). Finally, the objects 
re-appeared on the screen and they were prompted to look at the target (e.g., &quot;Look at the 
horse!&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>word_recognition
</code></pre>


<h3>Format</h3>

<p>A data frame with 53940 rows and 10 variables: </p>
 <dl>
<dt>ParticipantName</dt><dd><p>Uniaue 
participant ID</p>
</dd> <dt>Sex</dt><dd><p>M or F</p>
</dd> <dt>Age</dt><dd><p>Age, in months</p>
</dd> <dt>TrialNum</dt><dd><p>Unique Trial 
Number</p>
</dd> <dt>Trial</dt><dd><p>Name of item shown on trial (also unique for each participant)</p>
</dd> 
<dt>TimeFromTrialOnset</dt><dd><p>Time within trial</p>
</dd> <dt>Subphase</dt><dd><p>Subphase within trial (see above)</p>
</dd>
<dt>TimeFromSubphaseOnset</dt><dd><p>Time within subphase</p>
</dd> <dt>AOI</dt><dd><p>Which AOI are they looking at</p>
</dd> 
<dt>Animate</dt><dd><p>Are they looking at the animate AOI?</p>
</dd> <dt>Inanimate</dt><dd><p>Are they looking at the 
inanimate AOI?</p>
</dd> <dt>TrackLoss</dt><dd><p>Does current sample not have valid tracking data?</p>
</dd> 
<dt>MCDI_Total</dt><dd><p>Total vocabulary score on MCDI</p>
</dd> <dt>MCDI_Nouns</dt><dd><p>Noun vocabulary score on 
MCDI</p>
</dd> <dt>MCDI_Verbs</dt><dd><p>Verb vocabulary score on MCDI</p>
</dd></dl>
<p> ... 
</p>


<h3>Source</h3>

<p>Ferguson, B., Graf, E., &amp; Waxman, S. R. (2014). Infants use known verbs to learn novel
nouns: Evidence from 15- and 19-month-olds. Cognition, 131(1), 139-146.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
