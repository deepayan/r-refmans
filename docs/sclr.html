<!DOCTYPE html><html><head><title>Help for package sclr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sclr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_baseline'><p>Check for baseline boundary</p></a></li>
<li><a href='#coef.sclr'><p>ML estimate components</p></a></li>
<li><a href='#find_prot_titre_val'><p>Search function for scaled logit protection covariate levels</p></a></li>
<li><a href='#get_protection_level'><p>Protection level calculations</p></a></li>
<li><a href='#new_sclr'><p>Create a new <code>sclr</code> object</p></a></li>
<li><a href='#one_titre_data'><p>Simulated one-titre antibody data</p></a></li>
<li><a href='#predict.sclr'><p>Predict method for scaled logit model x.</p></a></li>
<li><a href='#print.sclr'><p>Print a <code>sclr</code> object.</p></a></li>
<li><a href='#sclr'><p>Fits the scaled logit model</p></a></li>
<li><a href='#sclr_fit'><p>Fitter function for the scaled logit model</p></a></li>
<li><a href='#sclr_ideal_data'><p>Generate ideal data for the scaled logit model</p></a></li>
<li><a href='#sclr_log_likelihood'><p>Log-likelihood</p></a></li>
<li><a href='#tidy.sclr'><p>Tidy a <code>sclr</code> object.</p></a></li>
<li><a href='#two_titre_data'><p>Simulated two-titre antibody data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Scaled Logistic Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Maximum likelihood estimation of the scaled logit model parameters
    proposed in Dunning (2006) &lt;<a href="https://doi.org/10.1002%2Fsim.2282">doi:10.1002/sim.2282</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://khvorov45.github.io/sclr/">https://khvorov45.github.io/sclr/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, tibble, dplyr, rlang, stats, purrr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-02 00:49:05 UTC; khvorova2</td>
</tr>
<tr>
<td>Author:</td>
<td>Arseniy Khvorov [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arseniy Khvorov &lt;khvorov45@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-02 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_baseline'>Check for baseline boundary</h2><span id='topic+check_baseline'></span>

<h3>Description</h3>

<p>Fits the scaled logit model as well as logistic regression. Does
a likelihood ratio test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_baseline(
  formula = NULL,
  data = NULL,
  fit_sclr = NULL,
  fit_lr = NULL,
  conf_lvl = 0.95,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_baseline_+3A_formula">formula</code></td>
<td>
<p>Formula to use for model fitting.</p>
</td></tr>
<tr><td><code id="check_baseline_+3A_data">data</code></td>
<td>
<p>Optional dataframe.</p>
</td></tr>
<tr><td><code id="check_baseline_+3A_fit_sclr">fit_sclr</code></td>
<td>
<p>Fit object returned by <code><a href="#topic+sclr">sclr</a></code>.</p>
</td></tr>
<tr><td><code id="check_baseline_+3A_fit_lr">fit_lr</code></td>
<td>
<p>Fit object returned by <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="check_baseline_+3A_conf_lvl">conf_lvl</code></td>
<td>
<p>Confidence level for the test</p>
</td></tr>
<tr><td><code id="check_baseline_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print message based on test result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with a summary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sclr)
l1 &lt;- sclr_ideal_data(n = 50, theta = 1e6, seed = 20191104)
check_baseline(status ~ logHI, l1)
</code></pre>

<hr>
<h2 id='coef.sclr'>ML estimate components</h2><span id='topic+coef.sclr'></span><span id='topic+vcov.sclr'></span><span id='topic+confint.sclr'></span><span id='topic+model.matrix.sclr'></span><span id='topic+model.frame.sclr'></span><span id='topic+logLik.sclr'></span>

<h3>Description</h3>

<p><code>coef</code> returns MLE's.
<code>vcov</code> returns the estimated variance-covariance matrix at MLE's. 
<code>confint</code> returns the confidence interval.
<code>model.matrix</code> returns the model matrix (x).
<code>model.frame</code> returns the model frame (x and y in one matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sclr'
coef(object, ...)

## S3 method for class 'sclr'
vcov(object, ...)

## S3 method for class 'sclr'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'sclr'
model.matrix(object, ...)

## S3 method for class 'sclr'
model.frame(formula, ...)

## S3 method for class 'sclr'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.sclr_+3A_object">object</code>, <code id="coef.sclr_+3A_formula">formula</code></td>
<td>
<p>An object returned by <code><a href="#topic+sclr">sclr</a></code>.</p>
</td></tr>
<tr><td><code id="coef.sclr_+3A_...">...</code></td>
<td>
<p>Not used. Needed to match generic signature.</p>
</td></tr>
<tr><td><code id="coef.sclr_+3A_parm">parm</code></td>
<td>
<p>Parameter name, if missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="coef.sclr_+3A_level">level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
</table>

<hr>
<h2 id='find_prot_titre_val'>Search function for scaled logit protection covariate levels</h2><span id='topic+find_prot_titre_val'></span>

<h3>Description</h3>

<p>The search engine behind <code><a href="#topic+get_protection_level">get_protection_level</a></code>. Should not
usually be necessary to call this directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_prot_titre_val(
  fit,
  var_name,
  newdata = NULL,
  prot_var_name = "prot_point",
  lvl = 0.5,
  ci_level = 0.95,
  tol = 10^(-7)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_prot_titre_val_+3A_fit">fit</code></td>
<td>
<p>Object returned by <code><a href="#topic+sclr">sclr</a></code>.</p>
</td></tr>
<tr><td><code id="find_prot_titre_val_+3A_var_name">var_name</code></td>
<td>
<p>Name of the covariate for which the protection values should
be calculated. This name should appear in the formula of the call to
<code><a href="#topic+sclr">sclr</a></code> which was used to generate <code>fit</code>.</p>
</td></tr>
<tr><td><code id="find_prot_titre_val_+3A_newdata">newdata</code></td>
<td>
<p>A dataframe with all covariates except the one for which
protection values should be calculated.</p>
</td></tr>
<tr><td><code id="find_prot_titre_val_+3A_prot_var_name">prot_var_name</code></td>
<td>
<p>A variable name among those returned by
<code><a href="#topic+predict.sclr">predict.sclr</a></code> which needs to equal <code>lvl</code> at the value of
<code>var_name</code> that is supposed to be found.</p>
</td></tr>
<tr><td><code id="find_prot_titre_val_+3A_lvl">lvl</code></td>
<td>
<p>Protection level to find titre values for. Default is 0.5 (50%).</p>
</td></tr>
<tr><td><code id="find_prot_titre_val_+3A_ci_level">ci_level</code></td>
<td>
<p>Confidence level for the calculated interval. 
Default is 0.95.</p>
</td></tr>
<tr><td><code id="find_prot_titre_val_+3A_tol">tol</code></td>
<td>
<p>Tolerance. The values will be found numerically,
once the algorithm converges within <code>tol</code> of <code>lvl</code> 
it stops looking. Default is <code class="reqn">10^(-7)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe. Will have the same variables as <code>newdata</code> with
the addition of the <code>var_name</code> variable.
</p>

<hr>
<h2 id='get_protection_level'>Protection level calculations</h2><span id='topic+get_protection_level'></span>

<h3>Description</h3>

<p>Calculates covariate values corresponding to a particular protection level.
Only accepts one covariate at a time, fixed values of all the others should
be provided. The search engine is <code><a href="#topic+find_prot_titre_val">find_prot_titre_val</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_protection_level(
  fit,
  var_name,
  newdata = NULL,
  lvl = 0.5,
  ci_level = 0.95,
  tol = 10^(-7)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_protection_level_+3A_fit">fit</code></td>
<td>
<p>Object returned by <code><a href="#topic+sclr">sclr</a></code>.</p>
</td></tr>
<tr><td><code id="get_protection_level_+3A_var_name">var_name</code></td>
<td>
<p>Name of the covariate for which to find values corresponding
to a protection level. This name should appear in the formula in the call
to <code><a href="#topic+sclr">sclr</a></code> which was used to generate <code>fit</code>.</p>
</td></tr>
<tr><td><code id="get_protection_level_+3A_newdata">newdata</code></td>
<td>
<p>A dataframe with all covariates except the one for which
protection values should be calculated. If there is only one covariate, can
be left as <code>NULL</code> (the default)</p>
</td></tr>
<tr><td><code id="get_protection_level_+3A_lvl">lvl</code></td>
<td>
<p>Protection level to find covariate values for. Default is 0.5
(50%)</p>
</td></tr>
<tr><td><code id="get_protection_level_+3A_ci_level">ci_level</code></td>
<td>
<p>Confidence level for the calculated interval. Default is
0.95.</p>
</td></tr>
<tr><td><code id="get_protection_level_+3A_tol">tol</code></td>
<td>
<p>Tolerance. The values will be found numerically, once the
algorithm converges within <code>tol</code> of <code>lvl</code> it stops looking.
Default is <code class="reqn">10^(-7)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code>. Will have the same variables as
<code>newdata</code> with the addition of the <code>var_name</code> variable.
</p>

<hr>
<h2 id='new_sclr'>Create a new <code>sclr</code> object</h2><span id='topic+new_sclr'></span><span id='topic+is_sclr'></span>

<h3>Description</h3>

<p><code>new_sclr</code> creates the object <code><a href="#topic+sclr">sclr</a></code> returns.
<code>is_sclr</code> checks if the object is of class <code>sclr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sclr(fit, x, y, cl, mf, mt)

is_sclr(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_sclr_+3A_fit">fit</code></td>
<td>
<p>A list returned by <code><a href="#topic+sclr_fit">sclr_fit</a></code>.</p>
</td></tr>
<tr><td><code id="new_sclr_+3A_x">x</code></td>
<td>
<p>Model matrix.</p>
</td></tr>
<tr><td><code id="new_sclr_+3A_y">y</code></td>
<td>
<p>Model response.</p>
</td></tr>
<tr><td><code id="new_sclr_+3A_cl">cl</code></td>
<td>
<p>Call.</p>
</td></tr>
<tr><td><code id="new_sclr_+3A_mf">mf</code></td>
<td>
<p>Model frame.</p>
</td></tr>
<tr><td><code id="new_sclr_+3A_mt">mt</code></td>
<td>
<p>Model terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sclr</code> object
</p>

<hr>
<h2 id='one_titre_data'>Simulated one-titre antibody data</h2><span id='topic+one_titre_data'></span>

<h3>Description</h3>

<p>A simulated dataset containing 5000 independent observations on antibody
titres and the corresponding infection status. The data was simulated to
resemble real influenza infection and haemagglutinin titre data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_titre_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 observations and 2 variables:
</p>

<dl>
<dt>logHI</dt><dd><p>haemagglutinin-inhibiting (HI) titre. True simulated titre on
a log scale.</p>
</dd>
<dt>status</dt><dd><p>influenza infection status. 1 - infected. 0 - not infected</p>
</dd>
</dl>


<h3>Model</h3>

<p>The model behind the simulation was
</p>
<p style="text-align: center;"><code class="reqn">\lambda * (1 - f(\beta_0 + \beta_1 * HI))</code>
</p>

<p>Where
</p>

<ul>
<li> <p><code class="reqn">f</code> - Inverse logit function </p>
</li>
<li> <p><code class="reqn">\lambda</code> = 0.5
</p>
</li>
<li> <p><code class="reqn">\beta_0</code> = -5 </p>
</li>
<li> <p><code class="reqn">\beta_1</code> = 2
</p>
</li></ul>


<hr>
<h2 id='predict.sclr'>Predict method for scaled logit model x.</h2><span id='topic+predict.sclr'></span>

<h3>Description</h3>

<p>Returns only the protection estimates. The only supported interval is
a confidence interval (i.e. the interval for the estimated expected value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sclr'
predict(object, newdata, ci_lvl = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sclr_+3A_object">object</code></td>
<td>
<p>Object returned by <code><a href="#topic+sclr">sclr</a></code>.</p>
</td></tr>
<tr><td><code id="predict.sclr_+3A_newdata">newdata</code></td>
<td>
<p>A dataframe with all covariates. Names should be as they
appear in the formula in the call to <code><a href="#topic+sclr">sclr</a></code>.</p>
</td></tr>
<tr><td><code id="predict.sclr_+3A_ci_lvl">ci_lvl</code></td>
<td>
<p>Confidence level for the calculated interval.</p>
</td></tr>
<tr><td><code id="predict.sclr_+3A_...">...</code></td>
<td>
<p>Not used. Needed to match generic signature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is </p>
<p style="text-align: center;"><code class="reqn">P(Y = 1) = \lambda(1 - logit^{-1}(\beta_0 +
\beta_1X_1 + \beta_2X_2 + ... + \beta_kX_k))</code>
</p>
<p> Where <code class="reqn">Y</code> is the binary
outcome indicator, (e.g. 1 - infected, 0 - not infected). <code class="reqn">X</code> - 
covariate.
<code class="reqn">k</code> - number of covariates.
This function calculates </p>
<p style="text-align: center;"><code class="reqn">\beta_0 + \beta_1X_1 + \beta_2X_2 + ..
. + \beta_kX_k</code>
</p>
<p> transformations at the covariate values found in 
<code>newdata</code> as well as the variance-covariance matrices of those
transformations. This is used to calculate the confidence intervals at the
given parameter values. The inverse logit transformation is then applied
to point estimates and interval bounds.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> obtained by adding the following
columns to <code>newdata</code>:
</p>
<table>
<tr><td><code>prot_point_lin prot_l_lin prot_u_lin</code></td>
<td>
<p>Point estimate, low and high 
bounds of the linear transformation.</p>
</td></tr>
<tr><td><code>prot_sd_lin</code></td>
<td>
<p>Estimated standard deviation of the linear 
transformation.</p>
</td></tr>
<tr><td><code>prot_point prot_l prot_u</code></td>
<td>
<p>Inverse logit-transformed 
point estimate, low and high bounds of the linear transformation.</p>
</td></tr>
</table>

<hr>
<h2 id='print.sclr'>Print a <code>sclr</code> object.</h2><span id='topic+print.sclr'></span><span id='topic+summary.sclr'></span>

<h3>Description</h3>

<p>Summarises a <code>sclr</code> object for printing. For a dataframe summary, see
<code><a href="#topic+tidy.sclr">tidy</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sclr'
print(x, level = 0.95, ...)

## S3 method for class 'sclr'
summary(object, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sclr_+3A_x">x</code>, <code id="print.sclr_+3A_object">object</code></td>
<td>
<p>An object returned by <code><a href="#topic+sclr">sclr</a></code>.</p>
</td></tr>
<tr><td><code id="print.sclr_+3A_level">level</code></td>
<td>
<p>Confidence level for the intervals.</p>
</td></tr>
<tr><td><code id="print.sclr_+3A_...">...</code></td>
<td>
<p>Not used. Needed to match generic signature.</p>
</td></tr>
</table>

<hr>
<h2 id='sclr'>Fits the scaled logit model</h2><span id='topic+sclr'></span>

<h3>Description</h3>

<p>Used to fit the scaled logit model from Dunning (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sclr(
  formula,
  data = NULL,
  ci_lvl = 0.95,
  tol = 10^(-7),
  algorithm = c("newton-raphson", "gradient-ascent"),
  nr_iter = 2000,
  ga_iter = 2000,
  n_conv = 3,
  conventional_names = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sclr_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot;: a symbolic description of the
model to be fitted.</p>
</td></tr>
<tr><td><code id="sclr_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="sclr_+3A_ci_lvl">ci_lvl</code></td>
<td>
<p>Confidence interval level for the parameter estimates.</p>
</td></tr>
<tr><td><code id="sclr_+3A_tol">tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
<tr><td><code id="sclr_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithms to run. &quot;newton-raphson&quot; or &quot;gradient-ascent&quot;.
If a character vector, the algorithms will be applied in the order they
are present in the vector.</p>
</td></tr>
<tr><td><code id="sclr_+3A_nr_iter">nr_iter</code></td>
<td>
<p>Maximum allowed iterations for Newton-Raphson.</p>
</td></tr>
<tr><td><code id="sclr_+3A_ga_iter">ga_iter</code></td>
<td>
<p>Maximum allowed iterations for gradient ascent.</p>
</td></tr>
<tr><td><code id="sclr_+3A_n_conv">n_conv</code></td>
<td>
<p>Number of times the algorithm has to converge (to work around
local maxima).</p>
</td></tr>
<tr><td><code id="sclr_+3A_conventional_names">conventional_names</code></td>
<td>
<p>If <code>TRUE</code>, estimated parameter names will be
(Baseline), (Intercept) and the column names in the model matrix. Otherwise
- lambda, beta_0 and beta_ prefix in front of column names in the model
matrix.</p>
</td></tr>
<tr><td><code id="sclr_+3A_seed">seed</code></td>
<td>
<p>Seed for the algorithms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is logistic regression with an added parameter for the top
asymptote. That parameter is reported as <code>theta</code> (or <code>(Baseline)</code>
if <code>conventional_names = TRUE</code>). Note that it is reported on the logit
scale. See <code>vignette("sclr-math")</code> for model specification,
log-likelihood, scores and second derivatives. The main default optimisation
algorithm is Newton-Raphson. Gradient ascent is used as a fallback by
default. Computing engine behind the fitting is <code><a href="#topic+sclr_fit">sclr_fit</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>sclr</code>. This is a list with the following
elements:
</p>
<table>
<tr><td><code>parameters</code></td>
<td>
<p>Maximum likelihood estimates of the parameter values.</p>
</td></tr>
<tr><td><code>covariance_mat</code></td>
<td>
<p>The variance-covariance matrix of the parameter
estimates.</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>Algorithm used.</p>
</td></tr>
<tr><td><code>algorithm_return</code></td>
<td>
<p>Everything the algorithm returned.</p>
</td></tr>
<tr><td><code>n_converge</code></td>
<td>
<p>The number of Newton-Raphson iterations (including
resets) that were required for convergence.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Model matrix derived from <code>formula</code> and <code>data</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Response matrix derived from <code>formula</code> and <code>data</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>sclr</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Model frame object derived from <code>formula</code> and
<code>data</code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>Terms object derived from model frame.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>Confidence intervals of the parameter estimates.</p>
</td></tr>
<tr><td><code>log_likelihood</code></td>
<td>
<p>Value of log-likelihood calculated at the ML
estimates of parameters.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>Passed formula.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Passed data.</p>
</td></tr>
</table>
<p>Methods supported: <code><a href="#topic+print.sclr">print</a></code>,
<code><a href="#topic+vcov.sclr">vcov</a></code>, <code><a href="#topic+coef.sclr">coef</a></code>,
<code><a href="#topic+model.frame.sclr">model.frame</a></code>,
<code><a href="#topic+model.matrix.sclr">model.matrix</a></code>,
<code><a href="#topic+summary.sclr">summary</a></code>, <code><a href="#topic+predict.sclr">predict</a></code>,
<code><a href="#topic+tidy.sclr">tidy</a></code> (<code><a href="broom.html#topic+broom">broom</a></code> package),
<code><a href="#topic+logLik.sclr">logLik</a></code>.
</p>


<h3>References</h3>

<p>Dunning AJ (2006). &quot;A model for immunological correlates of
protection.&quot; Statistics in Medicine, 25(9), 1485-1497.
<a href="https://doi.org/10.1002/sim.2282">https://doi.org/10.1002/sim.2282</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sclr)
fit1 &lt;- sclr(status ~ logHI, one_titre_data)
summary(fit1)
</code></pre>

<hr>
<h2 id='sclr_fit'>Fitter function for the scaled logit model</h2><span id='topic+sclr_fit'></span>

<h3>Description</h3>

<p>Computing engine behind <code><a href="#topic+sclr">sclr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sclr_fit(
  y,
  x,
  tol = 10^(-7),
  algorithm = c("newton-raphson", "gradient-ascent"),
  nr_iter = 2000,
  ga_iter = 2000,
  n_conv = 3,
  conventional_names = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sclr_fit_+3A_y">y</code></td>
<td>
<p>A vector of observations.</p>
</td></tr>
<tr><td><code id="sclr_fit_+3A_x">x</code></td>
<td>
<p>A design matrix.</p>
</td></tr>
<tr><td><code id="sclr_fit_+3A_tol">tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
<tr><td><code id="sclr_fit_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithms to run. &quot;newton-raphson&quot; or &quot;gradient-ascent&quot;.
If a character vector, the algorithms will be applied in the order they
are present in the vector.</p>
</td></tr>
<tr><td><code id="sclr_fit_+3A_nr_iter">nr_iter</code></td>
<td>
<p>Maximum allowed iterations for Newton-Raphson.</p>
</td></tr>
<tr><td><code id="sclr_fit_+3A_ga_iter">ga_iter</code></td>
<td>
<p>Maximum allowed iterations for gradient ascent.</p>
</td></tr>
<tr><td><code id="sclr_fit_+3A_n_conv">n_conv</code></td>
<td>
<p>Number of times the algorithm has to converge (to work around
local maxima).</p>
</td></tr>
<tr><td><code id="sclr_fit_+3A_conventional_names">conventional_names</code></td>
<td>
<p>If <code>TRUE</code>, estimated parameter names will be
(Baseline), (Intercept) and the column names in the model matrix. Otherwise
- lambda, beta_0 and beta_ prefix in front of column names in the model
matrix.</p>
</td></tr>
<tr><td><code id="sclr_fit_+3A_seed">seed</code></td>
<td>
<p>Seed for the algorithms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood maximisation can use the Newton-Raphson or the gradient
ascent algorithms.
</p>

<hr>
<h2 id='sclr_ideal_data'>Generate ideal data for the scaled logit model</h2><span id='topic+sclr_ideal_data'></span>

<h3>Description</h3>

<p>Allows variation of all parameters and the creation of an arbitrary number of
covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sclr_ideal_data(
  n = 1000,
  theta = 0,
  beta_0 = -5,
  covariate_list = list(logHI = list(gen_fun = function(n) rnorm(n, 2, 2), true_par =
    2)),
  outcome_name = "status",
  seed = NULL,
  attach_true_vals = FALSE,
  attach_seed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sclr_ideal_data_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="sclr_ideal_data_+3A_theta">theta</code></td>
<td>
<p>Baseline risk parameter on the logit scale.</p>
</td></tr>
<tr><td><code id="sclr_ideal_data_+3A_beta_0">beta_0</code></td>
<td>
<p>Intercept of the linear part.</p>
</td></tr>
<tr><td><code id="sclr_ideal_data_+3A_covariate_list">covariate_list</code></td>
<td>
<p>A list in the form of <code>name = list(gen_fun,
true_par)</code> where <code>gen_fun</code> is a function that takes <code>n</code> as an
argument and returns a vector of observations, <code>true_par</code> is the true
parameter value of that covariate. See examples.</p>
</td></tr>
<tr><td><code id="sclr_ideal_data_+3A_outcome_name">outcome_name</code></td>
<td>
<p>Name to give to the outcome</p>
</td></tr>
<tr><td><code id="sclr_ideal_data_+3A_seed">seed</code></td>
<td>
<p>Seed to set. If <code>NULL</code>, no seed will be set.</p>
</td></tr>
<tr><td><code id="sclr_ideal_data_+3A_attach_true_vals">attach_true_vals</code>, <code id="sclr_ideal_data_+3A_attach_seed">attach_seed</code></td>
<td>
<p>Whether to attach additional attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One titre
one_titre &lt;- sclr_ideal_data(
  covariate_list = list(
    logHI = list(gen_fun = function(n) rnorm(n, 2, 2), true_par = 2)
  )
)
sclr(status ~ logHI, one_titre) # Verify

# Two titres
two_titre &lt;- sclr_ideal_data(
  covariate_list = list(
    logHI = list(gen_fun = function(n) rnorm(n, 2, 2), true_par = 2),
    logNI = list(gen_fun = function(n) rnorm(n, 2, 2), true_par = 1)
  )
)
sclr(status ~ logHI + logNI, two_titre) # Verify

</code></pre>

<hr>
<h2 id='sclr_log_likelihood'>Log-likelihood</h2><span id='topic+sclr_log_likelihood'></span>

<h3>Description</h3>

<p>Computes the log-likelihood of the scaled logit model at a given set of
parameter estimates (or the MLE if <code>pars</code> is not supplied). Either
<code>fit</code> or <code>x</code>, <code>y</code> and <code>pars</code> need to be supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sclr_log_likelihood(fit = NULL, x = NULL, y = NULL, pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sclr_log_likelihood_+3A_fit">fit</code></td>
<td>
<p>An object returned by <code><a href="#topic+sclr">sclr</a></code>. Or a list with
parameters, x and y entries corresponding to the parameter matrix, model
matrix and model response.</p>
</td></tr>
<tr><td><code id="sclr_log_likelihood_+3A_x">x</code></td>
<td>
<p>Model matrix. Will be taken from <code>fit</code> if <code>fit</code> is
provided.</p>
</td></tr>
<tr><td><code id="sclr_log_likelihood_+3A_y">y</code></td>
<td>
<p>Model response. Will be taken from <code>fit</code> if <code>fit</code> is
provided.</p>
</td></tr>
<tr><td><code id="sclr_log_likelihood_+3A_pars">pars</code></td>
<td>
<p>A named vector of parameter values. Will be taken from <code>fit</code>
if <code>fit</code> is provided.</p>
</td></tr>
</table>

<hr>
<h2 id='tidy.sclr'>Tidy a <code>sclr</code> object.</h2><span id='topic+tidy.sclr'></span>

<h3>Description</h3>

<p>Summarises the objects returned by <code><a href="#topic+sclr">sclr</a></code> 
into a <code><a href="tibble.html#topic+tibble">tibble</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sclr'
tidy(x, ci_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.sclr_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+sclr">sclr</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.sclr_+3A_ci_level">ci_level</code></td>
<td>
<p>Confidence level for the intervals.</p>
</td></tr>
<tr><td><code id="tidy.sclr_+3A_...">...</code></td>
<td>
<p>Not used. Needed to match generic signature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with one row per model parameter. 
Columns:
</p>
<table>
<tr><td><code>term</code></td>
<td>
<p>Name of model parameter.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Point estimate.</p>
</td></tr>
<tr><td><code>std_error</code></td>
<td>
<p>Standard error.</p>
</td></tr>
<tr><td><code>conf_low</code></td>
<td>
<p>Lower bound of the confidence interval.</p>
</td></tr>
<tr><td><code>conf_high</code></td>
<td>
<p>Upper bound of the confidence interval.</p>
</td></tr>
</table>

<hr>
<h2 id='two_titre_data'>Simulated two-titre antibody data</h2><span id='topic+two_titre_data'></span>

<h3>Description</h3>

<p>A simulated dataset containing 5000 independent observations on antibody
titres and the corresponding infection status. The data was simulated to
resemble real influenza infection and haemagglutinin + neuraminidase titre
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_titre_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 observations and 3 variables:
</p>

<dl>
<dt>logHI</dt><dd><p>haemagglutinin-inhibiting (HI) titre. True simulated titre on
a log scale.</p>
</dd>
<dt>logNI</dt><dd><p>neuraminidase-inhibiting titre. True simulated titre on a log
scale.</p>
</dd>
<dt>status</dt><dd><p>influenza infection status. 1 - infected. 0 - not infected</p>
</dd> </dl>


<h3>Model</h3>

<p>The model behind the simulation was
</p>
<p style="text-align: center;"><code class="reqn">\lambda * (1 - f(\beta_0 + \beta_1 * HI + \beta_2 * NI))</code>
</p>

<p>Where
</p>

<ul>
<li> <p><code class="reqn">f</code> - Inverse logit function
</p>
</li>
<li> <p><code class="reqn">\lambda</code> = 0.5
</p>
</li>
<li> <p><code class="reqn">\beta_0</code> = -7.5
</p>
</li>
<li> <p><code class="reqn">\beta_1</code> = 2
</p>
</li>
<li> <p><code class="reqn">\beta_2</code> = 2 </p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
