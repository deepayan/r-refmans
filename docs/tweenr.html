<!DOCTYPE html><html><head><title>Help for package tweenr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tweenr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tweenr-package'><p>tweenr: Interpolate Data for Smooth Animations</p></a></li>
<li><a href='#.complete_states'><p>Fill in missing rows using enter and exit functions</p></a></li>
<li><a href='#.get_last_frame'><p>Helpers for working with tweened data</p></a></li>
<li><a href='#.max_id'><p>Get the highest id occuring in a dataset</p></a></li>
<li><a href='#col_classes'><p>Generator internals</p></a></li>
<li><a href='#display_ease'><p>Display an easing function</p></a></li>
<li><a href='#gen_along'><p>Generator for tweening along a variable</p></a></li>
<li><a href='#gen_at'><p>Generator for interpolating between two data frames</p></a></li>
<li><a href='#gen_components'><p>Generator for tweening components separately from each other</p></a></li>
<li><a href='#gen_events'><p>Generator for tweening the appearance of elements</p></a></li>
<li><a href='#gen_keyframe'><p>Generator for keyframe based tweening</p></a></li>
<li><a href='#get_frame'><p>Extract a frame from a generator</p></a></li>
<li><a href='#interpolate_custom_at'><p>Fallback for keyframe vector support</p></a></li>
<li><a href='#prepare_keyframes'><p>Prepare keyframes for generator</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tween'><p>Create simple tweens</p></a></li>
<li><a href='#tween_along'><p>Interpolate data along a given dimension</p></a></li>
<li><a href='#tween_appear'><p>Tween a data.frame of appearances</p></a></li>
<li><a href='#tween_at'><p>Get a specific position between two states</p></a></li>
<li><a href='#tween_at_t'><p>Get several specific position between two states</p></a></li>
<li><a href='#tween_components'><p>Interpolate individual component</p></a></li>
<li><a href='#tween_elements'><p>Create frames based on individual element states</p></a></li>
<li><a href='#tween_events'><p>Transition in and out of events</p></a></li>
<li><a href='#tween_fill'><p>Fill out missing values by interpolation</p></a></li>
<li><a href='#tween_state'><p>Compose tweening between states</p></a></li>
<li><a href='#tween_states'><p>Tween a list of data.frames representing states</p></a></li>
<li><a href='#vec_tween_class'><p>Get the nominal class of a vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interpolate Data for Smooth Animations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In order to create smooth animation between states of data,
    tweening is necessary. This package provides a range of functions for
    creating tweened data that can be used as basis for animation. Furthermore 
    it adds a number of vectorized interpolaters for common R data 
    types such as numeric, date and colour.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thomasp85/tweenr">https://github.com/thomasp85/tweenr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/tweenr/issues">https://github.com/thomasp85/tweenr/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>farver, magrittr, rlang, vctrs</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11 (&ge; 0.4.2)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 13:06:33 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-26 13:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='tweenr-package'>tweenr: Interpolate Data for Smooth Animations</h2><span id='topic+tweenr'></span><span id='topic+tweenr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>In order to create smooth animation between states of data, tweening is necessary. This package provides a range of functions for creating tweened data that can be used as basis for animation. Furthermore it adds a number of vectorized interpolaters for common R data types such as numeric, date and colour.
</p>


<h3>Details</h3>

<p>tweenr is a small collection of functions to help you in creating
intermediary representations of your data, i.e. interpolating states of data.
As such it's a great match for packages such as animate and gganimate, since
it can work directly with data.frames of data, but it also provide fast and
efficient interpolaters for numeric, date, datetime and colour that are
vectorized and thus more efficient to use than the build in interpolation
functions (mainly <code><a href="stats.html#topic+approxfun">stats::approx()</a></code> and
<code><a href="grDevices.html#topic+colorRamp">grDevices::colorRamp()</a></code>).
</p>
<p>The main functions for data.frames are <code><a href="#topic+tween_states">tween_states()</a></code>,
<code><a href="#topic+tween_elements">tween_elements()</a></code> and <code><a href="#topic+tween_appear">tween_appear()</a></code>, while the
standard interpolaters can be found at <code><a href="#topic+tween">tween()</a></code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/thomasp85/tweenr">https://github.com/thomasp85/tweenr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/tweenr/issues">https://github.com/thomasp85/tweenr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.complete_states'>Fill in missing rows using enter and exit functions</h2><span id='topic+.complete_states'></span>

<h3>Description</h3>

<p>This function figures out which rows are missing in either state and applies
the provided <code>enter</code> and <code>exit</code>  functions to fill in the blanks and provide
a 1-to-1 relation between the rows in <code>from</code> and <code>to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.complete_states(from, to, id, enter, exit, max_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".complete_states_+3A_from">from</code>, <code id=".complete_states_+3A_to">to</code></td>
<td>
<p>Data.frames to tween between</p>
</td></tr>
<tr><td><code id=".complete_states_+3A_id">id</code></td>
<td>
<p>The name of the column that holds the matching id</p>
</td></tr>
<tr><td><code id=".complete_states_+3A_enter">enter</code>, <code id=".complete_states_+3A_exit">exit</code></td>
<td>
<p>functions to fill out missing rows in <code>from</code> and <code>to</code>
respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements <code>from</code> and <code>to</code> holding the filled out
versions of <code>from</code> and <code>to</code>
</p>

<hr>
<h2 id='.get_last_frame'>Helpers for working with tweened data</h2><span id='topic+.get_last_frame'></span><span id='topic+.get_first_frame'></span><span id='topic+.with_prior_frames'></span><span id='topic+.with_later_frames'></span><span id='topic+.has_frames'></span>

<h3>Description</h3>

<p>These are internal helpers for extracting and inserting data into a
data.frame of tweened states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_last_frame(data)

.get_first_frame(data)

.with_prior_frames(prior, new_tween, nframes)

.with_later_frames(later, new_tween, nframes)

.has_frames(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_last_frame_+3A_data">data</code>, <code id=".get_last_frame_+3A_prior">prior</code>, <code id=".get_last_frame_+3A_later">later</code></td>
<td>
<p>A data.frame. If a <code>.frame</code> column exists it will be interpreted
as a data.frame containing multiple states</p>
</td></tr>
<tr><td><code id=".get_last_frame_+3A_new_tween">new_tween</code></td>
<td>
<p>The result of a tweening</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>

<hr>
<h2 id='.max_id'>Get the highest id occuring in a dataset</h2><span id='topic+.max_id'></span>

<h3>Description</h3>

<p>This is helper for <code>tween_state</code> related functions to get the currently
highest <code>.id</code> in a frame collection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.max_id(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".max_id_+3A_data">data</code></td>
<td>
<p>A data.frame as returned by <code>tween_state</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer giving the currently highest id
</p>

<hr>
<h2 id='col_classes'>Generator internals</h2><span id='topic+col_classes'></span><span id='topic+gen_internal'></span><span id='topic+PHASE_LEVELS'></span><span id='topic+is_generator'></span><span id='topic+generator_settings'></span><span id='topic+generator_settings+3C-'></span><span id='topic+ease_type'></span><span id='topic+ease_type+3C-'></span><span id='topic+col_types'></span><span id='topic+col_types+3C-'></span><span id='topic+gen_data'></span><span id='topic+gen_data+3C-'></span><span id='topic+gen_to_data_frame'></span><span id='topic+data_frame_to_gen'></span><span id='topic+keyframes'></span><span id='topic+keyframes+3C-'></span><span id='topic+frame_times'></span><span id='topic+frame_times+3C-'></span>

<h3>Description</h3>

<p>Generator internals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_classes(data)

PHASE_LEVELS

is_generator(x)

generator_settings(x)

generator_settings(x) &lt;- value

ease_type(x)

ease_type(x) &lt;- value

col_types(x)

col_types(x) &lt;- value

gen_data(x)

gen_data(x) &lt;- value

gen_to_data_frame(...)

data_frame_to_gen(x)

keyframes(x)

keyframes(x) &lt;- value

frame_times(x)

frame_times(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_classes_+3A_x">x</code></td>
<td>
<p>A generator object</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 5.
</p>


<h3>Value</h3>

<p>Various data
</p>

<hr>
<h2 id='display_ease'>Display an easing function</h2><span id='topic+display_ease'></span>

<h3>Description</h3>

<p>This simple helper lets you explore how the different easing functions govern
the interpolation of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_ease(ease)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_ease_+3A_ease">ease</code></td>
<td>
<p>The name of the easing function to display (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>How transitions proceed between states are defined by an easing function. The
easing function converts the parameterized progression from one state to the
next to a new number between 0 and 1. <code>linear</code> easing is equivalent to
an identity function that returns the input unchanged. In addition there are
a range of additional easers available, each with three modifiers.
</p>
<p><strong>Easing modifiers:</strong>
</p>

<dl>
<dt>-in</dt><dd><p>The easing function is applied as-is</p>
</dd>
<dt>-out</dt><dd><p>The easing function is applied in reverse</p>
</dd>
<dt>-in-out</dt><dd><p>The first half of the transition it is applied as-is, while
in the last half it is reversed</p>
</dd>
</dl>

<p><strong>Easing functions</strong>
</p>

<dl>
<dt>quadratic</dt><dd><p>Models a power-of-2 function</p>
</dd>
<dt>cubic</dt><dd><p>Models a power-of-3 function</p>
</dd>
<dt>quartic</dt><dd><p>Models a power-of-4 function</p>
</dd>
<dt>quintic</dt><dd><p>Models a power-of-5 function</p>
</dd>
<dt>sine</dt><dd><p>Models a sine function</p>
</dd>
<dt>circular</dt><dd><p>Models a pi/2 circle arc</p>
</dd>
<dt>exponential</dt><dd><p>Models an exponential function</p>
</dd>
<dt>elastic</dt><dd><p>Models an elastic release of energy</p>
</dd>
<dt>back</dt><dd><p>Models a pullback and relase</p>
</dd>
<dt>bounce</dt><dd><p>Models the bouncing of a ball</p>
</dd>
</dl>

<p>In addition to this function a good animated explanation can be found
<a href="https://easings.net">here</a>.
</p>


<h3>Value</h3>

<p>This function is called for its side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The default - identity
display_ease('linear')

# A more fancy easer
display_ease('elastic-in')

</code></pre>

<hr>
<h2 id='gen_along'>Generator for tweening along a variable</h2><span id='topic+gen_along'></span>

<h3>Description</h3>

<p>This is a generator version of <code><a href="#topic+tween_along">tween_along()</a></code>. It returns a generator that
can be used with <code><a href="#topic+get_frame">get_frame()</a></code> and <code><a href="#topic+get_raw_frames">get_raw_frames()</a></code> to extract frames for
a specific time point scaled between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_along(
  .data,
  ease,
  along,
  id = NULL,
  range = NULL,
  history = TRUE,
  keep_last = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_along_+3A_.data">.data</code></td>
<td>
<p>A data.frame with components at different stages</p>
</td></tr>
<tr><td><code id="gen_along_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="gen_along_+3A_along">along</code></td>
<td>
<p>The &quot;time&quot; point for each row</p>
</td></tr>
<tr><td><code id="gen_along_+3A_id">id</code></td>
<td>
<p>An unquoted expression giving the component id for each row. Will
be evaluated in the context of <code>.data</code> so can refer to a column from that</p>
</td></tr>
<tr><td><code id="gen_along_+3A_range">range</code></td>
<td>
<p>The range of time points to include in the tween. If <code>NULL</code> it
will use the range of <code>time</code></p>
</td></tr>
<tr><td><code id="gen_along_+3A_history">history</code></td>
<td>
<p>Should earlier datapoints be kept in subsequent frames</p>
</td></tr>
<tr><td><code id="gen_along_+3A_keep_last">keep_last</code></td>
<td>
<p>Should the last point of each id be kept beyond its time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>along_generator</code> object
</p>


<h3>See Also</h3>

<p>Other Other generators: 
<code><a href="#topic+gen_at">gen_at</a>()</code>,
<code><a href="#topic+gen_components">gen_components</a>()</code>,
<code><a href="#topic+gen_events">gen_events</a>()</code>,
<code><a href="#topic+gen_keyframe">gen_keyframe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default behaviour
gen &lt;- gen_along(airquality, ease = "linear", along = Day, id = Month)
get_frame(gen, 0.22)

# Overwrite keep_last or history in get_frame
get_frame(gen, 0.67, history = FALSE)
</code></pre>

<hr>
<h2 id='gen_at'>Generator for interpolating between two data frames</h2><span id='topic+gen_at'></span>

<h3>Description</h3>

<p>This is a generator version of <code><a href="#topic+tween_at">tween_at()</a></code> with the additional functionality
of supporting enter and exit functions. It returns a generator that can be
used with <code><a href="#topic+get_frame">get_frame()</a></code> and <code><a href="#topic+get_raw_frames">get_raw_frames()</a></code> to extract frames for a
specific time point scaled between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_at(from, to, ease, id = NULL, enter = NULL, exit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_at_+3A_from">from</code>, <code id="gen_at_+3A_to">to</code></td>
<td>
<p>A data.frame or vector of the same type. If either is of
length/nrow 1 it will get repeated to match the length of the other</p>
</td></tr>
<tr><td><code id="gen_at_+3A_ease">ease</code></td>
<td>
<p>A character vector giving valid easing functions. Recycled to
match the ncol of <code>from</code></p>
</td></tr>
<tr><td><code id="gen_at_+3A_id">id</code></td>
<td>
<p>The column to match observations on. If <code>NULL</code> observations will be
matched by position. See the <em>Match, Enter, and Exit</em> section for more
information.</p>
</td></tr>
<tr><td><code id="gen_at_+3A_enter">enter</code>, <code id="gen_at_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>keyframe_generator</code> object
</p>


<h3>See Also</h3>

<p>Other Other generators: 
<code><a href="#topic+gen_along">gen_along</a>()</code>,
<code><a href="#topic+gen_components">gen_components</a>()</code>,
<code><a href="#topic+gen_events">gen_events</a>()</code>,
<code><a href="#topic+gen_keyframe">gen_keyframe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen &lt;- gen_at(mtcars[1:6, ], mtcars[6:1, ], 'cubic-in-out')

get_frame(gen, 0.3)
</code></pre>

<hr>
<h2 id='gen_components'>Generator for tweening components separately from each other</h2><span id='topic+gen_components'></span>

<h3>Description</h3>

<p>This is a generator versions of <code><a href="#topic+tween_components">tween_components()</a></code>. It returns a generator
that can be used with <code><a href="#topic+get_frame">get_frame()</a></code> and <code><a href="#topic+get_raw_frames">get_raw_frames()</a></code> to extract frames
for a specific time point scaled between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_components(
  .data,
  ease,
  nframes,
  time,
  id = NULL,
  range = NULL,
  enter = NULL,
  exit = NULL,
  enter_length = 0,
  exit_length = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_components_+3A_.data">.data</code></td>
<td>
<p>A data.frame with components at different stages</p>
</td></tr>
<tr><td><code id="gen_components_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="gen_components_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to calculate for the tween</p>
</td></tr>
<tr><td><code id="gen_components_+3A_time">time</code></td>
<td>
<p>An unquoted expression giving the timepoint for the different
stages of the components. Will be evaluated in the context of <code>.data</code> so can
refer to a column from that</p>
</td></tr>
<tr><td><code id="gen_components_+3A_id">id</code></td>
<td>
<p>An unquoted expression giving the component id for each row. Will
be evaluated in the context of <code>.data</code> so can refer to a column from that</p>
</td></tr>
<tr><td><code id="gen_components_+3A_range">range</code></td>
<td>
<p>The range of time points to include in the tween. If <code>NULL</code> it
will use the range of <code>time</code></p>
</td></tr>
<tr><td><code id="gen_components_+3A_enter">enter</code>, <code id="gen_components_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
<tr><td><code id="gen_components_+3A_enter_length">enter_length</code>, <code id="gen_components_+3A_exit_length">exit_length</code></td>
<td>
<p>The lenght of the opening and closing
transitions if <code>enter</code> and/or <code>exit</code> is given. Measured in the same units as
<code>time</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>component_generator</code> object
</p>


<h3>See Also</h3>

<p>Other Other generators: 
<code><a href="#topic+gen_along">gen_along</a>()</code>,
<code><a href="#topic+gen_at">gen_at</a>()</code>,
<code><a href="#topic+gen_events">gen_events</a>()</code>,
<code><a href="#topic+gen_keyframe">gen_keyframe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>from_zero &lt;- function(x) {x$x &lt;- 0; x}

data &lt;- data.frame(
  x = c(1, 2, 2, 1, 2, 2),
  y = c(1, 2, 2, 2, 1, 1),
  time = c(1, 4, 8, 4, 8, 10),
  id = c(1, 1, 1, 2, 2, 2)
)

gen &lt;- gen_components(data, 'cubic-in-out', time = time, id = id,
                      enter = from_zero, enter_length = 4)

get_frame(gen, 0.3)
</code></pre>

<hr>
<h2 id='gen_events'>Generator for tweening the appearance of elements</h2><span id='topic+gen_events'></span>

<h3>Description</h3>

<p>This is a generator version of <code><a href="#topic+tween_events">tween_events()</a></code>. It returns a generator
that can be used with <code><a href="#topic+get_frame">get_frame()</a></code> and <code><a href="#topic+get_raw_frames">get_raw_frames()</a></code> to extract frames
for a specific time point scaled between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_events(
  .data,
  ease,
  start,
  end = NULL,
  range = NULL,
  enter = NULL,
  exit = NULL,
  enter_length = 0,
  exit_length = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_events_+3A_.data">.data</code></td>
<td>
<p>A data.frame with components at different stages</p>
</td></tr>
<tr><td><code id="gen_events_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="gen_events_+3A_start">start</code>, <code id="gen_events_+3A_end">end</code></td>
<td>
<p>The start (and potential end) of the event encoded in the
row, as unquoted expressions. Will be evaluated in the context of <code>.data</code> so
can refer to columns in it. If <code>end = NULL</code> the event will be without extend
and only visible in a single frame, unless <code>enter</code> and/or <code>exit</code> is given.</p>
</td></tr>
<tr><td><code id="gen_events_+3A_range">range</code></td>
<td>
<p>The range of time points to include in the tween. If <code>NULL</code> it
will use the range of <code>time</code></p>
</td></tr>
<tr><td><code id="gen_events_+3A_enter">enter</code>, <code id="gen_events_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
<tr><td><code id="gen_events_+3A_enter_length">enter_length</code>, <code id="gen_events_+3A_exit_length">exit_length</code></td>
<td>
<p>The lenght of the opening and closing
transitions if <code>enter</code> and/or <code>exit</code> is given. Measured in the same units as
<code>time</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>component_generator</code> object
</p>


<h3>See Also</h3>

<p>Other Other generators: 
<code><a href="#topic+gen_along">gen_along</a>()</code>,
<code><a href="#topic+gen_at">gen_at</a>()</code>,
<code><a href="#topic+gen_components">gen_components</a>()</code>,
<code><a href="#topic+gen_keyframe">gen_keyframe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(
  x = runif(20),
  y = runif(20),
  time = runif(20),
  duration = runif(20, max = 0.1)
)
from_left &lt;- function(x) {
  x$x &lt;- -0.5
  x
}
to_right &lt;- function(x) {
  x$x &lt;- 1.5
  x
}

gen &lt;- gen_events(d, 'cubic-in-out', start = time, end = time + duration,
                  enter = from_left, exit = to_right, enter_length = 0.1,
                  exit_length = 0.05)

get_frame(gen, 0.65)

</code></pre>

<hr>
<h2 id='gen_keyframe'>Generator for keyframe based tweening</h2><span id='topic+gen_keyframe'></span><span id='topic+add_pause'></span><span id='topic+add_keyframe'></span>

<h3>Description</h3>

<p>This is a generator version of <code><a href="#topic+tween_state">tween_state()</a></code> and its utility functions. It
returns a generator that can be used with <code><a href="#topic+get_frame">get_frame()</a></code> and
<code><a href="#topic+get_raw_frames">get_raw_frames()</a></code> to extract frames for a specific time point scaled between
0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_keyframe(keyframe = NULL, pause = 0)

add_pause(.data, pause = 0)

add_keyframe(
  .data,
  keyframe,
  ease,
  length,
  id = NULL,
  enter = NULL,
  exit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_keyframe_+3A_keyframe">keyframe</code></td>
<td>
<p>A data frame to use as a keyframe state</p>
</td></tr>
<tr><td><code id="gen_keyframe_+3A_pause">pause</code></td>
<td>
<p>The length of the pause at the current keyframe</p>
</td></tr>
<tr><td><code id="gen_keyframe_+3A_.data">.data</code></td>
<td>
<p>A data.frame to start from. If <code>.data</code> is the result of a prior
tween, only the last frame will be used for the tween. The new tween will
then be added to the prior tween</p>
</td></tr>
<tr><td><code id="gen_keyframe_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="gen_keyframe_+3A_length">length</code></td>
<td>
<p>The length of the transition</p>
</td></tr>
<tr><td><code id="gen_keyframe_+3A_id">id</code></td>
<td>
<p>The column to match observations on. If <code>NULL</code> observations will be
matched by position. See the <em>Match, Enter, and Exit</em> section for more
information.</p>
</td></tr>
<tr><td><code id="gen_keyframe_+3A_enter">enter</code>, <code id="gen_keyframe_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>keyframe_generator</code> object
</p>


<h3>See Also</h3>

<p>Other Other generators: 
<code><a href="#topic+gen_along">gen_along</a>()</code>,
<code><a href="#topic+gen_at">gen_at</a>()</code>,
<code><a href="#topic+gen_components">gen_components</a>()</code>,
<code><a href="#topic+gen_events">gen_events</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
  country = c('Denmark', 'Sweden', 'Norway'),
  population = c(5e6, 10e6, 3.5e6)
)
df2 &lt;- data.frame(
  country = c('Denmark', 'Sweden', 'Norway', 'Finland'),
  population = c(6e6, 10.5e6, 4e6, 3e6)
)
df3 &lt;- data.frame(
  country = c('Denmark', 'Norway'),
  population = c(10e6, 6e6)
)
to_zero &lt;- function(x) {
  x$population &lt;- 0
  x
}
gen &lt;- gen_keyframe(df1, 10) %&gt;%
  add_keyframe(df2, 'cubic-in-out', 35, id = country, enter = to_zero) %&gt;%
  add_pause(10) %&gt;%
  add_keyframe(df3, 'cubic-in-out', 35, id = country, enter = to_zero,
               exit = to_zero) %&gt;%
  add_pause(10)

get_frame(gen, 0.25)
</code></pre>

<hr>
<h2 id='get_frame'>Extract a frame from a generator</h2><span id='topic+get_frame'></span><span id='topic+get_raw_frames'></span>

<h3>Description</h3>

<p>Using the generators in tweenr you can avoid calculating all needed frames up
front, which can be prohibitive in memory. With a generator you can use
<code>get_frame()</code> to extract any frame at a fractional location between 0 and 1
one by one as you need them. You can further get all raw data before and/or
after a given point in time using <code>get_raw_frames()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_frame(generator, at, ...)

get_raw_frames(generator, at, before = 0, after = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_frame_+3A_generator">generator</code></td>
<td>
<p>A <code>frame_generator</code> object</p>
</td></tr>
<tr><td><code id="get_frame_+3A_at">at</code></td>
<td>
<p>A scalar numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="get_frame_+3A_...">...</code></td>
<td>
<p>Arguments passed on to methods</p>
</td></tr>
<tr><td><code id="get_frame_+3A_before">before</code>, <code id="get_frame_+3A_after">after</code></td>
<td>
<p>Scalar numerics that define the time before and after
<code>at</code> to search for raw data</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  x = c(1, 2, 2, 1, 2, 2),
  y = c(1, 2, 2, 2, 1, 1),
  time = c(1, 4, 8, 4, 8, 10),
  id = c(1, 1, 1, 2, 2, 2)
)

gen &lt;- gen_components(data, 'cubic-in-out', time = time, id = id)

get_frame(gen, 0.3)

get_raw_frames(gen, 0.5, before = 0.5, after = 0.2)
</code></pre>

<hr>
<h2 id='interpolate_custom_at'>Fallback for keyframe vector support</h2><span id='topic+interpolate_custom_at'></span>

<h3>Description</h3>

<p>Fallback for keyframe vector support
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_custom_at(from, to, at, ease)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_custom_at_+3A_from">from</code>, <code id="interpolate_custom_at_+3A_to">to</code></td>
<td>
<p>vectors to interpolate between</p>
</td></tr>
<tr><td><code id="interpolate_custom_at_+3A_at">at</code></td>
<td>
<p>value between 0 and 1 defining the point</p>
</td></tr>
<tr><td><code id="interpolate_custom_at_+3A_ease">ease</code></td>
<td>
<p>the easing function to use</p>
</td></tr>
</table>

<hr>
<h2 id='prepare_keyframes'>Prepare keyframes for generator</h2><span id='topic+prepare_keyframes'></span>

<h3>Description</h3>

<p>Prepare keyframes for generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_keyframes(.data, keyframe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_keyframes_+3A_.data">.data</code></td>
<td>
<p>A keyframe generator</p>
</td></tr>
<tr><td><code id="prepare_keyframes_+3A_keyframe">keyframe</code></td>
<td>
<p>A keyframe to add</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A valid keyframe generator
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='tween'>Create simple tweens</h2><span id='topic+tween'></span><span id='topic+tween_t'></span><span id='topic+tween_colour'></span><span id='topic+tween_color'></span><span id='topic+tween_colour_t'></span><span id='topic+tween_color_t'></span><span id='topic+tween_constant'></span><span id='topic+tween_constant_t'></span><span id='topic+tween_date'></span><span id='topic+tween_date_t'></span><span id='topic+tween_datetime'></span><span id='topic+tween_datetime_t'></span><span id='topic+tween_numeric'></span><span id='topic+tween_numeric_t'></span>

<h3>Description</h3>

<p>This set of functions can be used to interpolate between single data types,
i.e. data not part of data.frames but stored in vectors. All functions come
in two flavours: the standard and a *_t version. The standard reads the data
as a list of states, each tween matched element-wise from state to state. The
*_t version uses the transposed representation where each element is a vector
of states. The standard approach can be used when each tween has the same
number of states and you want to control the number of point in each state
transition. The latter is useful when each tween consists of different
numbers of states and/or you want to specify the total number of points for
each tween.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween(data, n, ease = "linear")

tween_t(data, n, ease = "linear")

tween_colour(data, n, ease = "linear")

tween_color(data, n, ease = "linear")

tween_colour_t(data, n, ease = "linear")

tween_color_t(data, n, ease = "linear")

tween_constant(data, n, ease = "linear")

tween_constant_t(data, n, ease = "linear")

tween_date(data, n, ease = "linear")

tween_date_t(data, n, ease = "linear")

tween_datetime(data, n, ease = "linear")

tween_datetime_t(data, n, ease = "linear")

tween_numeric(data, n, ease = "linear")

tween_numeric_t(data, n, ease = "linear")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_+3A_data">data</code></td>
<td>
<p>A list of vectors or a single vector. In the standard functions
each element in the list must be of equal length; for the *_t functions
lengths can differ. If a single vector is used it will be eqivalent to using
<code>as.list(data)</code> for the standard functions and <code>list(data)</code> for the
*_t functions.</p>
</td></tr>
<tr><td><code id="tween_+3A_n">n</code></td>
<td>
<p>The number of elements per transition or tween. See details</p>
</td></tr>
<tr><td><code id="tween_+3A_ease">ease</code></td>
<td>
<p>The easing function to use for each transition or tween. See
details. Defaults to <code>'linear'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tween</code> and <code>tween_t</code> are wrappers around the other functions that tries to guess
the type of input data and choose the appropriate tween function. Unless you
have data that could be understood as a colour but is in fact a character
vector it should be safe to use these wrappers. It is probably safer and more
verbose to use the explicit functions within package code as they circumvent
the type inference and checks whether the input data matches the tween
function.
</p>
<p><code>tween_numeric</code> will provide a linear interpolation between the points based on
the sequence returned by the easing function. <code>tween_date</code> and <code>tween_datetime</code>
converts to numeric, produces the tweening, and converts back again.
<code>tween_colour</code> converts colours into Lab and does the interpolation there,
converting back to sRGB after the tweening is done. <code>tween_constant</code> is a
catchall that converts the input into character and interpolates by switching
between states halfway through the transition.
</p>
<p>The meaning of the <code>n</code> and <code>ease</code> arguments differs somewhat
between the standard and *_t versions of the functions. In the standard
function <code>n</code> and <code>ease</code> refers to the length and easing function of
each transition, being recycled if necessary to <code>length(data) - 1</code>. In
the *_t functions <code>n</code> and <code>ease</code> refers to the total length of each
tween and the easing function to be applied to all transition for each tween.
The will both be recycled to <code>length(data)</code>.
</p>


<h3>Value</h3>

<p>A list with an element for each tween. That means that the length of
the return is equal to the length of the elements in <code>data</code> for the
standard functions and equal to the length of <code>data</code> for the *_t
functions.
</p>


<h3>Difference Between <code>tween_numeric</code> and <code>approx()</code></h3>

<p><code>tween_numeric</code> (and <code>tween_numeric_t</code>) is superficially equivalent to
<code><a href="stats.html#topic+approxfun">stats::approx()</a></code>, but there are differences.
<code><a href="stats.html#topic+approxfun">stats::approx()</a></code> will create evenly spaced points, at the expense
of not including the actual points in the input, while the reverse is true
for <code>tween_numeric</code>. Apart from that <code>tween_numeric</code> of course supports easing
functions and is vectorized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tween_numeric(list(1:3, 10:8, c(20, 60, 30)), 10)

tween_colour_t(list(colours()[1:4], colours()[1:2], colours()[25:100]), 100)

</code></pre>

<hr>
<h2 id='tween_along'>Interpolate data along a given dimension</h2><span id='topic+tween_along'></span>

<h3>Description</h3>

<p>This tween takes groups of rows along with the time for each row and
calculates the exact value at each at each frame. Further it allows for
keeping the subsequent raw data from previous frame as well as letting the
final row linger beyond its time. It especially useful for data that should
be visualised as lines that are drawn along the x-axis, but can of course
also be used for other dimensions as well (even dimensions not corresponding
to any axis).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_along(
  .data,
  ease,
  nframes,
  along,
  id = NULL,
  range = NULL,
  history = TRUE,
  keep_last = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_along_+3A_.data">.data</code></td>
<td>
<p>A data.frame with components at different stages</p>
</td></tr>
<tr><td><code id="tween_along_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="tween_along_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to calculate for the tween</p>
</td></tr>
<tr><td><code id="tween_along_+3A_along">along</code></td>
<td>
<p>The &quot;time&quot; point for each row</p>
</td></tr>
<tr><td><code id="tween_along_+3A_id">id</code></td>
<td>
<p>An unquoted expression giving the component id for each row. Will
be evaluated in the context of <code>.data</code> so can refer to a column from that</p>
</td></tr>
<tr><td><code id="tween_along_+3A_range">range</code></td>
<td>
<p>The range of time points to include in the tween. If <code>NULL</code> it
will use the range of <code>time</code></p>
</td></tr>
<tr><td><code id="tween_along_+3A_history">history</code></td>
<td>
<p>Should earlier datapoints be kept in subsequent frames</p>
</td></tr>
<tr><td><code id="tween_along_+3A_keep_last">keep_last</code></td>
<td>
<p>Should the last point of each id be kept beyond its time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the same columns as <code>.data</code> along with <code>.id</code> giving
the component id, <code>.phase</code> giving the state of each component in each frame,
and <code>.frame</code> giving the frame membership of each row.
</p>


<h3>See Also</h3>

<p>Other data.frame tween: 
<code><a href="#topic+tween_appear">tween_appear</a>()</code>,
<code><a href="#topic+tween_components">tween_components</a>()</code>,
<code><a href="#topic+tween_elements">tween_elements</a>()</code>,
<code><a href="#topic+tween_events">tween_events</a>()</code>,
<code><a href="#topic+tween_states">tween_states</a>()</code>
</p>

<hr>
<h2 id='tween_appear'>Tween a data.frame of appearances</h2><span id='topic+tween_appear'></span>

<h3>Description</h3>

<p>This function is intended for use when you have a data.frame of events at
different time points. This could be the appearance of an observation for
example. This function replicates your data <code>nframes</code> times and
calculates the duration of each frame. At each frame each row is
assigned an age based on the progression of frames and the entry point of in
time for that row. A negative age means that the row has not appeared yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_appear(data, time, timerange, nframes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_appear_+3A_data">data</code></td>
<td>
<p>A data.frame to tween</p>
</td></tr>
<tr><td><code id="tween_appear_+3A_time">time</code></td>
<td>
<p>The name of the column that holds the time dimension. This does
not need to hold time data in the strictest sence - any numerical type will
do</p>
</td></tr>
<tr><td><code id="tween_appear_+3A_timerange">timerange</code></td>
<td>
<p>The range of time to create the tween for. If missing it
will defaults to the range of the time column</p>
</td></tr>
<tr><td><code id="tween_appear_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to create for the tween. If missing it
will create a frame for each full unit in <code>timerange</code> (e.g.
<code>timerange = c(1, 10)</code> will give <code>nframes = 10</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame as <code>data</code> but repeated <code>nframes</code> times and
with the additional columns <code>.age</code> and <code>.frame</code>
</p>


<h3>See Also</h3>

<p>Other data.frame tween: 
<code><a href="#topic+tween_along">tween_along</a>()</code>,
<code><a href="#topic+tween_components">tween_components</a>()</code>,
<code><a href="#topic+tween_elements">tween_elements</a>()</code>,
<code><a href="#topic+tween_events">tween_events</a>()</code>,
<code><a href="#topic+tween_states">tween_states</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  x = rnorm(100),
  y = rnorm(100),
  time = sample(50, 100, replace = TRUE)
)

data &lt;- tween_appear(data, 'time', nframes = 200)

</code></pre>

<hr>
<h2 id='tween_at'>Get a specific position between two states</h2><span id='topic+tween_at'></span>

<h3>Description</h3>

<p>This tween allows you to query a specific postion between two states rather
than generate evenly spaced states. It can work with either data.frames or
single vectors and each row/element can have its own position and easing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_at(from, to, at, ease)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_at_+3A_from">from</code>, <code id="tween_at_+3A_to">to</code></td>
<td>
<p>A data.frame or vector of the same type. If either is of
length/nrow 1 it will get repeated to match the length of the other</p>
</td></tr>
<tr><td><code id="tween_at_+3A_at">at</code></td>
<td>
<p>A numeric between 0 and 1 recycled to match the nrow/length of
<code>from</code></p>
</td></tr>
<tr><td><code id="tween_at_+3A_ease">ease</code></td>
<td>
<p>A character vector giving valid easing functions. Recycled to
match the ncol of <code>from</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>from</code>/<code>to</code> is a data.frame then a data.frame with the same
columns. If <code>from</code>/<code>to</code> is a vector then a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tween_at(mtcars[1:6, ], mtcars[6:1, ], runif(6), 'cubic-in-out')

</code></pre>

<hr>
<h2 id='tween_at_t'>Get several specific position between two states</h2><span id='topic+tween_at_t'></span>

<h3>Description</h3>

<p>This tween is a variation of <code><a href="#topic+tween_at">tween_at()</a></code>. Instead of having <code>at</code> refer to
the tweening position of each row, each <code>at</code> will interpolate the full data
at that position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_at_t(from, to, at, ease)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_at_t_+3A_from">from</code>, <code id="tween_at_t_+3A_to">to</code></td>
<td>
<p>A data.frame or vector of the same type. If either is of
length/nrow 1 it will get repeated to match the length of the other</p>
</td></tr>
<tr><td><code id="tween_at_t_+3A_at">at</code></td>
<td>
<p>A numeric vector with values between 0 and 1.</p>
</td></tr>
<tr><td><code id="tween_at_t_+3A_ease">ease</code></td>
<td>
<p>A character vector giving valid easing functions. Recycled to
match the ncol of <code>from</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>from</code>/<code>to</code> is a data.frame then a data.frame with the same
columns. If <code>from</code>/<code>to</code> is a vector then a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tween_at_t(mtcars[1:6, ], mtcars[6:1, ], runif(3), 'cubic-in-out')

</code></pre>

<hr>
<h2 id='tween_components'>Interpolate individual component</h2><span id='topic+tween_components'></span>

<h3>Description</h3>

<p>This function is much like <code><a href="#topic+tween_elements">tween_elements()</a></code> but with a slightly different
syntax and support for many of the newer features such as enter/exits and
tween phase identification. Furthermore it uses tidy evaluation for time and
id, making it easier to change these on the fly. The biggest change in terms
of functionality compared to <code>tween_elements()</code> is that the easing function
is now given per column and not per row. If different easing functions are
needed for each transition then <code>tween_elements()</code> is needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_components(
  .data,
  ease,
  nframes,
  time,
  id = NULL,
  range = NULL,
  enter = NULL,
  exit = NULL,
  enter_length = 0,
  exit_length = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_components_+3A_.data">.data</code></td>
<td>
<p>A data.frame with components at different stages</p>
</td></tr>
<tr><td><code id="tween_components_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="tween_components_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to calculate for the tween</p>
</td></tr>
<tr><td><code id="tween_components_+3A_time">time</code></td>
<td>
<p>An unquoted expression giving the timepoint for the different
stages of the components. Will be evaluated in the context of <code>.data</code> so can
refer to a column from that</p>
</td></tr>
<tr><td><code id="tween_components_+3A_id">id</code></td>
<td>
<p>An unquoted expression giving the component id for each row. Will
be evaluated in the context of <code>.data</code> so can refer to a column from that</p>
</td></tr>
<tr><td><code id="tween_components_+3A_range">range</code></td>
<td>
<p>The range of time points to include in the tween. If <code>NULL</code> it
will use the range of <code>time</code></p>
</td></tr>
<tr><td><code id="tween_components_+3A_enter">enter</code>, <code id="tween_components_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
<tr><td><code id="tween_components_+3A_enter_length">enter_length</code>, <code id="tween_components_+3A_exit_length">exit_length</code></td>
<td>
<p>The lenght of the opening and closing
transitions if <code>enter</code> and/or <code>exit</code> is given. Measured in the same units as
<code>time</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the same columns as <code>.data</code> along with <code>.id</code> giving
the component id, <code>.phase</code> giving the state of each component in each frame,
and <code>.frame</code> giving the frame membership of each row.
</p>


<h3>See Also</h3>

<p>Other data.frame tween: 
<code><a href="#topic+tween_along">tween_along</a>()</code>,
<code><a href="#topic+tween_appear">tween_appear</a>()</code>,
<code><a href="#topic+tween_elements">tween_elements</a>()</code>,
<code><a href="#topic+tween_events">tween_events</a>()</code>,
<code><a href="#topic+tween_states">tween_states</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
from_zero &lt;- function(x) {x$x &lt;- 0; x}

data &lt;- data.frame(
  x = c(1, 2, 2, 1, 2, 2),
  y = c(1, 2, 2, 2, 1, 1),
  time = c(1, 4, 10, 4, 8, 10),
  id = c(1, 1, 1, 2, 2, 2)
)

data &lt;- tween_components(data, 'cubic-in-out', nframes = 100, time = time,
                         id = id, enter = from_zero, enter_length = 4)

</code></pre>

<hr>
<h2 id='tween_elements'>Create frames based on individual element states</h2><span id='topic+tween_elements'></span>

<h3>Description</h3>

<p>This function creates tweens for each observation individually, in cases
where the data doesn't pass through collective states but consists of fully
independent transitions. Each observation is identified by an id and each
state must have a time associated with it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_elements(data, time, group, ease, timerange, nframes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_elements_+3A_data">data</code></td>
<td>
<p>A data.frame consisting at least of a column giving the
observation id, a column giving timepoints for each state and a column giving
the easing to apply when transitioning away from the state.</p>
</td></tr>
<tr><td><code id="tween_elements_+3A_time">time</code></td>
<td>
<p>The name of the column holding timepoints</p>
</td></tr>
<tr><td><code id="tween_elements_+3A_group">group</code></td>
<td>
<p>The name of the column holding the observation id</p>
</td></tr>
<tr><td><code id="tween_elements_+3A_ease">ease</code></td>
<td>
<p>The name of the column holding the easing function name</p>
</td></tr>
<tr><td><code id="tween_elements_+3A_timerange">timerange</code></td>
<td>
<p>The range of time to span. If missing it will default to
<code>range(data[[time]])</code></p>
</td></tr>
<tr><td><code id="tween_elements_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to generate. If missing it will default
to <code>ceiling(diff(timerange) + 1)</code> (At least one frame for each
individual timepoint)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the same columns as <code>data</code> except for the
group and ease columns, but replicated <code>nframes</code> times. Two additional
columns called <code>.frame</code> and <code>.group</code> will be added giving the frame
number and observation id for each row.
</p>


<h3>See Also</h3>

<p>Other data.frame tween: 
<code><a href="#topic+tween_along">tween_along</a>()</code>,
<code><a href="#topic+tween_appear">tween_appear</a>()</code>,
<code><a href="#topic+tween_components">tween_components</a>()</code>,
<code><a href="#topic+tween_events">tween_events</a>()</code>,
<code><a href="#topic+tween_states">tween_states</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  x = c(1, 2, 2, 1, 2, 2),
  y = c(1, 2, 2, 2, 1, 1),
  time = c(1, 4, 10, 4, 8, 10),
  group = c(1, 1, 1, 2, 2, 2),
  ease = rep('cubic-in-out', 6)
)

data &lt;- tween_elements(data, 'time', 'group', 'ease', nframes = 100)

</code></pre>

<hr>
<h2 id='tween_events'>Transition in and out of events</h2><span id='topic+tween_events'></span>

<h3>Description</h3>

<p>This tweening function is a more powerful version of <code><a href="#topic+tween_appear">tween_appear()</a></code>, with
support for newer features such as enter/exits and tween phase
identification. The tweener treats each row in the data as unique events in
time, and creates frames with the correct events present at any given time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_events(
  .data,
  ease,
  nframes,
  start,
  end = NULL,
  range = NULL,
  enter = NULL,
  exit = NULL,
  enter_length = 0,
  exit_length = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_events_+3A_.data">.data</code></td>
<td>
<p>A data.frame with components at different stages</p>
</td></tr>
<tr><td><code id="tween_events_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="tween_events_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to calculate for the tween</p>
</td></tr>
<tr><td><code id="tween_events_+3A_start">start</code>, <code id="tween_events_+3A_end">end</code></td>
<td>
<p>The start (and potential end) of the event encoded in the
row, as unquoted expressions. Will be evaluated in the context of <code>.data</code> so
can refer to columns in it. If <code>end = NULL</code> the event will be without extend
and only visible in a single frame, unless <code>enter</code> and/or <code>exit</code> is given.</p>
</td></tr>
<tr><td><code id="tween_events_+3A_range">range</code></td>
<td>
<p>The range of time points to include in the tween. If <code>NULL</code> it
will use the range of <code>time</code></p>
</td></tr>
<tr><td><code id="tween_events_+3A_enter">enter</code>, <code id="tween_events_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
<tr><td><code id="tween_events_+3A_enter_length">enter_length</code>, <code id="tween_events_+3A_exit_length">exit_length</code></td>
<td>
<p>The lenght of the opening and closing
transitions if <code>enter</code> and/or <code>exit</code> is given. Measured in the same units as
<code>time</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the same columns as <code>.data</code> along with <code>.id</code> giving
the component id, <code>.phase</code> giving the state of each component in each frame,
and <code>.frame</code> giving the frame membership of each row.
</p>


<h3>See Also</h3>

<p>Other data.frame tween: 
<code><a href="#topic+tween_along">tween_along</a>()</code>,
<code><a href="#topic+tween_appear">tween_appear</a>()</code>,
<code><a href="#topic+tween_components">tween_components</a>()</code>,
<code><a href="#topic+tween_elements">tween_elements</a>()</code>,
<code><a href="#topic+tween_states">tween_states</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(
  x = runif(20),
  y = runif(20),
  time = runif(20),
  duration = runif(20, max = 0.1)
)
from_left &lt;- function(x) {
  x$x &lt;- -0.5
  x
}
to_right &lt;- function(x) {
  x$x &lt;- 1.5
  x
}

tween_events(d, 'cubic-in-out', 50, start = time, end = time + duration,
             enter = from_left, exit = to_right, enter_length = 0.1,
             exit_length = 0.05)

</code></pre>

<hr>
<h2 id='tween_fill'>Fill out missing values by interpolation</h2><span id='topic+tween_fill'></span>

<h3>Description</h3>

<p>This tween fills out <code>NA</code> elements (or <code>NULL</code> elements if <code>data</code> is a list)
by interpolating between the prior and next non-missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_fill(data, ease)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_fill_+3A_data">data</code></td>
<td>
<p>A data.frame or vector.</p>
</td></tr>
<tr><td><code id="tween_fill_+3A_ease">ease</code></td>
<td>
<p>A character vector giving valid easing functions. Recycled to
match the ncol of <code>data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>data</code> is a data.frame then a data.frame with the same
columns. If <code>data</code> is a vector then a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single vector
tween_fill(c(1, NA, NA, NA, NA, NA, 2, 6, NA, NA, NA, -2), 'cubic-in-out')

# Data frame
tween_fill(mtcars[c(1, NA, NA, NA, NA, 4, NA, NA, NA, 10), ], 'cubic-in')

</code></pre>

<hr>
<h2 id='tween_state'>Compose tweening between states</h2><span id='topic+tween_state'></span><span id='topic+keep_state'></span><span id='topic+open_state'></span><span id='topic+close_state'></span>

<h3>Description</h3>

<p>The <code>tween_state()</code> is a counterpart to <code>tween_states()</code> that is aimed at
letting you gradually build up a scene by composing state changes one by one.
This setup lets you take more control over each state change and allows you
to work with datasets with uneven number of rows, flexibly specifying what
should happen with entering and exiting data. <code>keep_state()</code> is a simple
helper for letting you pause at a state. <code>open_state()</code> is a shortcut from
tweening from an empty dataset with a given <code>enter()</code> function while
<code>close_state()</code> is the same but will instead tween into an empty dataset with
a given <code>exit()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_state(.data, to, ease, nframes, id = NULL, enter = NULL, exit = NULL)

keep_state(.data, nframes)

open_state(.data, ease, nframes, enter)

close_state(.data, ease, nframes, exit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_state_+3A_.data">.data</code></td>
<td>
<p>A data.frame to start from. If <code>.data</code> is the result of a prior
tween, only the last frame will be used for the tween. The new tween will
then be added to the prior tween</p>
</td></tr>
<tr><td><code id="tween_state_+3A_to">to</code></td>
<td>
<p>A data.frame to end at. It must contain the same columns as .data
(exluding <code>.frame</code>)</p>
</td></tr>
<tr><td><code id="tween_state_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="tween_state_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to calculate for the tween</p>
</td></tr>
<tr><td><code id="tween_state_+3A_id">id</code></td>
<td>
<p>The column to match observations on. If <code>NULL</code> observations will be
matched by position. See the <em>Match, Enter, and Exit</em> section for more
information.</p>
</td></tr>
<tr><td><code id="tween_state_+3A_enter">enter</code>, <code id="tween_state_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing all the intermediary states in the tween,
each state will be enumerated by the <code>.frame</code> column
</p>


<h3>Match, Enter, and Exit</h3>

<p>When there are discrepancies between the two states to tweeen between you
need a way to resolve the discrepancy before calculating the intermediary
states. With discrepancies we mean that some data points are present in the
start state and not in the end state, and/or some are present in the end
state but not in the start state. A simple example is that the start state
contains 100 rows and the end state contains 70. There are 30 missing rows
that we need to do something about before we can calculate the tween.
</p>
<p><strong>Making pairs</strong>
The first question to answer is &quot;How do we know which observations are
disappearing (<em>exiting</em>) and/or appearing (<em>entering</em>)?&quot;. This is done with
the <code>id</code> argument which should give a column name to match rows between the
two states on. If <code>id = NULL</code> the rows will be matched by position (in the
above example the last 30 rows in the start state will be entering). The <code>id</code>
column must only contain unique values in order to work.
</p>
<p><strong>Making up states</strong>
Once the rows in each state has been paired you'll end up with three sets of
data. One containing rows that is present in both the start and end state,
one containing rows only present in the start state, and one only containing
rows present in the end state. The first group is easy - here you just tween
between each rows - but for the other two we'll need some state to start or
end the tween with. This is really the purpose of the <code>enter</code> and <code>exit</code>
functions. They take a data frame containing the subset of data that has not
been matched and must return a new data frame giving the state that these
rows must be tweened from/into. A simple example could be an <code>enter</code> function
that sets the variable giving the opacity in the plot to 0 - this will make
the new points fade into view during the transition.
</p>
<p><strong>Ignoring discrepancies</strong>
The default values for <code>enter</code> and <code>exit</code> is <code>NULL</code>. This value indicate that
non-matching rows should simply be ignored for the transition and simply
appear in the last frame of the tween. This is the default.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data1 &lt;- data.frame(
  x = 1:20,
  y = 0,
  colour = 'forestgreen',
  stringsAsFactors = FALSE
)
data2 &lt;- data1
data2$x &lt;- 20:1
data2$y &lt;- 1

data &lt;- data1 %&gt;%
  tween_state(data2, 'linear', 50) %&gt;%
  keep_state(20) %&gt;%
  tween_state(data1, 'bounce-out', 50)

# Using enter and exit (made up numbers)
df1 &lt;- data.frame(
  country = c('Denmark', 'Sweden', 'Norway'),
  population = c(5e6, 10e6, 3.5e6)
)
df2 &lt;- data.frame(
  country = c('Denmark', 'Sweden', 'Norway', 'Finland'),
  population = c(6e6, 10.5e6, 4e6, 3e6)
)
df3 &lt;- data.frame(
  country = c('Denmark', 'Norway'),
  population = c(10e6, 6e6)
)
to_zero &lt;- function(x) {
  x$population &lt;- 0
  x
}
pop_devel &lt;- df1 %&gt;%
  tween_state(df2, 'cubic-in-out', 50, id = country, enter = to_zero) %&gt;%
  tween_state(df3, 'cubic-in-out', 50, id = country, enter = to_zero,
              exit = to_zero)

</code></pre>

<hr>
<h2 id='tween_states'>Tween a list of data.frames representing states</h2><span id='topic+tween_states'></span>

<h3>Description</h3>

<p>This function is intended to create smooth transitions between states of
data. States are defined as full data.frames or data.frames containing only
the columns with change. Each state can have a defined period of pause, the
transition length between each states can be defined as well as the easing
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_states(data, tweenlength, statelength, ease, nframes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_states_+3A_data">data</code></td>
<td>
<p>A list of data.frames. Each data.frame must contain the same
number of rows, but only the first data.frame needs to contain all columns.
Subsequent data.frames need only contain the columns that shows change.</p>
</td></tr>
<tr><td><code id="tween_states_+3A_tweenlength">tweenlength</code></td>
<td>
<p>The lengths of the transitions between each state.</p>
</td></tr>
<tr><td><code id="tween_states_+3A_statelength">statelength</code></td>
<td>
<p>The length of the pause at each state.</p>
</td></tr>
<tr><td><code id="tween_states_+3A_ease">ease</code></td>
<td>
<p>The easing functions to use for the transitions. See details.</p>
</td></tr>
<tr><td><code id="tween_states_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to generate. The actual number of frames
might end up being higher depending on the regularity of <code>tweenlength</code>
and <code>statelength</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the same columns as the first data.frame in
<code>data</code>, but replicated <code>nframes</code> times. An additional column called
<code>.frame</code> will be added giving the frame number.
</p>


<h3>See Also</h3>

<p>Other data.frame tween: 
<code><a href="#topic+tween_along">tween_along</a>()</code>,
<code><a href="#topic+tween_appear">tween_appear</a>()</code>,
<code><a href="#topic+tween_components">tween_components</a>()</code>,
<code><a href="#topic+tween_elements">tween_elements</a>()</code>,
<code><a href="#topic+tween_events">tween_events</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data1 &lt;- data.frame(
  x = 1:20,
  y = 0,
  colour = 'forestgreen',
  stringsAsFactors = FALSE
)
data2 &lt;- data1
data2$x &lt;- 20:1
data2$y &lt;- 1

data &lt;- tween_states(list(data1, data2), 3, 1, 'cubic-in-out', 100)

</code></pre>

<hr>
<h2 id='vec_tween_class'>Get the nominal class of a vector</h2><span id='topic+vec_tween_class'></span>

<h3>Description</h3>

<p>Get the nominal class of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_tween_class(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_tween_class_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
