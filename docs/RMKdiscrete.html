<!DOCTYPE html><html><head><title>Help for package RMKdiscrete</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RMKdiscrete}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biLGP'><p>The bivariate Lagrangian Poisson (LGP) distribution</p></a></li>
<li><a href='#binegbin'><p>The bivariate negative binomial distribution</p></a></li>
<li><a href='#LGP'><p>The (univariate) Lagrangian Poisson (LGP) Distribution</p></a></li>
<li><a href='#ManaClash'><p>The Mana Clash distributions (just for fun!)</p></a></li>
<li><a href='#negbin'>
<p>Helper functions for the (unvariate) negative binomial distribution.</p></a></li>
<li><a href='#RMKdiscrete-package'><p>Sundry discrete probability distributions.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Sundry Discrete Probability Distributions</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert M. Kirkpatrick &lt;rkirkpatrick2@vcu.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert M. Kirkpatrick &lt;rkirkpatrick2@vcu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Sundry discrete probability distributions and helper functions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, R (&ge; 2.15.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-07 20:10:28 UTC; rmk</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-07 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='biLGP'>The bivariate Lagrangian Poisson (LGP) distribution</h2><span id='topic+biLGP'></span><span id='topic+dbiLGP'></span><span id='topic+biLGP.logMV'></span><span id='topic+rbiLGP'></span>

<h3>Description</h3>

<p>Density, random-number generation, and moments of the log-transformed distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbiLGP(y, theta, lambda, nc=NULL, log=FALSE, add.carefully=FALSE)
biLGP.logMV(theta,lambda,nc=NULL,const.add=1,tol=1e-14,add.carefully=FALSE)
rbiLGP(n, theta, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biLGP_+3A_y">y</code></td>
<td>
<p>Numeric vector or two-column matrix of bivariate data.  If matrix, each row corresponds to an observation.</p>
</td></tr>
<tr><td><code id="biLGP_+3A_theta">theta</code></td>
<td>
<p>Numeric vector or three-column matrix of non-negative values for index parameters <code class="reqn">\theta _0</code>, <code class="reqn">\theta _1</code>, and <code class="reqn">\theta _2</code>, in that order.  If matrix, is read by row.</p>
</td></tr>
<tr><td><code id="biLGP_+3A_lambda">lambda</code></td>
<td>
<p>Numeric vector or three-column matrix of values for multiplicative parameters <code class="reqn">\lambda _0</code>, <code class="reqn">\lambda _1</code>, and <code class="reqn">\lambda _2</code>, in that order.  If matrix, is read by row.  Values must be on the interval [-1,1].</p>
</td></tr>
<tr><td><code id="biLGP_+3A_nc">nc</code></td>
<td>
<p>Numeric vector or three-column matrix of (reciprocals of) the normalizing constants.  These constants differ from 1 only if the corresponding <code>lambda</code> parameter is negative; see <code><a href="#topic+dLGP">dLGP</a>()</code> for details. If matrix, is read by row. Defaults to <code>NULL</code>, in which case the normalizing constants are computed automatically.</p>
</td></tr>
<tr><td><code id="biLGP_+3A_log">log</code></td>
<td>
<p>Logical; should the natural log of the probability be returned?  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="biLGP_+3A_add.carefully">add.carefully</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the program takes extra steps to try to prevent round-off error during the addition of probabilities.  Defaults to <code>FALSE</code>, which is recommended, since using <code>TRUE</code> is slower and rarely makes a noticeable difference in practice.</p>
</td></tr>
<tr><td><code id="biLGP_+3A_const.add">const.add</code></td>
<td>
<p>Numeric vector of positive constants to add to the non-negative integers before taking their natural logarithm.  Defaults to 1, for the typical <code class="reqn">\log (y+1)</code> transformation.</p>
</td></tr>
<tr><td><code id="biLGP_+3A_tol">tol</code></td>
<td>
<p>Numeric; must be positive.  When <code>biLGP.logMV()</code> is calculating the second moment of the log-transformed distribution, it stops when the next term in the series is smaller than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="biLGP_+3A_n">n</code></td>
<td>
<p>Integer; number of observations to be randomly generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate LGP is constructed from three independent latent random variables, <code class="reqn">X_0</code>, <code class="reqn">X_1</code>, and <code class="reqn">X_2</code>, where
</p>
<p style="text-align: center;"><code class="reqn">X_0 \sim LGP(\theta _0, \lambda _0)</code>
</p>

<p style="text-align: center;"><code class="reqn">X_1 \sim LGP(\theta _1, \lambda _1)</code>
</p>

<p style="text-align: center;"><code class="reqn">X_2 \sim LGP(\theta _2, \lambda _2)</code>
</p>

<p>The observable variables, <code class="reqn">Y_1</code> and <code class="reqn">Y_2</code>, are defined as <code class="reqn">Y_1 = X_0 + X_1</code> and <code class="reqn">Y_2 = X_0 + X_2</code>, and thus the dependence between <code class="reqn">Y_1</code> and <code class="reqn">Y_2</code> arises because of the common term <code class="reqn">X_0</code>.  The joint PMF of <code class="reqn">Y_1</code> and <code class="reqn">Y_2</code> is derived from the joint PMF of the three independent latent variables, with <code class="reqn">X_1</code> and <code class="reqn">X_2</code> re-expressed as <code class="reqn">Y_1 - X_0</code> and <code class="reqn">Y_2 - X_0</code>, and after <code class="reqn">X_0</code> is marginalized out.
</p>
<p>Function <code>dbiLGP()</code> is the bivariate LGP density (PMF).  Function <code>rbiLGP()</code> generates random draws from the bivariate LGP distribution, via calls to <code><a href="#topic+rLGP">rLGP</a>()</code>.  Function <code>biLGP.logMV()</code> numerically computes the means, variances, and covariance of a bivariate LGP distribution, after it has been log transformed following addition of a positive constant.
</p>
<p>Vectors of numeric arguments other than <code>tol</code> are cycled, whereas only the first element of logical and integer arguments is used.
</p>


<h3>Value</h3>

<p><code>dbiLGP()</code> returns a numeric vector of probabilities.  <code>rbiLGP()</code> returns a matrix of random draws, which is of type 'numeric' (rather than 'integer', even though the bivariate LGP only has support on the non-negative integers).  <code>biLGP.logMV()</code> returns a numeric matrix with the following five named columns:
</p>

<ol>
<li> <p><code>EY1</code>: Post-tranformation expectation of <code class="reqn">Y_1</code>.
</p>
</li>
<li> <p><code>EY2</code>: Post-tranformation expectation of <code class="reqn">Y_2</code>.
</p>
</li>
<li> <p><code>VY1</code>: Post-tranformation variance of <code class="reqn">Y_1</code>.
</p>
</li>
<li> <p><code>VY2</code>: Post-tranformation variance of <code class="reqn">Y_2</code>.
</p>
</li>
<li> <p><code>COV</code>: Post-tranformation covariance of <code class="reqn">Y_1</code> and <code class="reqn">Y_2</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Robert M. Kirkpatrick <a href="mailto:rkirkpatrick2@vcu.edu">rkirkpatrick2@vcu.edu</a>
</p>


<h3>References</h3>

<p>Famoye, F., &amp; Consul, P. C.  (1995).  Bivariate generalized Poisson distribution with some applications.  <em>Metrika</em>, 42, 127-138.
</p>
<p>Consul, P. C., &amp; Famoye, F.  (2006).  <em>Lagrangian Probability Distributions</em>.  Boston: Birkhauser.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LGP">LGP</a></code>, <code><a href="stats.html#topic+Poisson">dpois</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The following two lines do the same thing:
dbiLGP(y=1,theta=1,lambda=0.1)
dbiLGP(y=c(1,1),theta=c(1,1,1),lambda=c(0.1,0.1,0.1))

dbiLGP(y=c(1,1,2,2,3,5),theta=c(1,1,1,2,2,2),lambda=0.1)
## Due to argument cycling, the above line is doing the following three steps:
dbiLGP(y=c(1,1),theta=c(1,1,1),lambda=c(0.1,0.1,0.1))
dbiLGP(y=c(2,2),theta=c(2,2,2),lambda=c(0.1,0.1,0.1))
dbiLGP(y=c(3,5),theta=c(1,1,1),lambda=c(0.1,0.1,0.1))

## Inputs to dbiLGP() can be matrices, too:
dbiLGP(y=matrix(c(1,1,2,2,3,5),ncol=2,byrow=TRUE),
  theta=matrix(c(1,1,1,2,2,2,1,1,1),ncol=3,byrow=TRUE),
  lambda=0.1)

## theta0 = 0 implies independence:
a &lt;- dbiLGP(y=c(1,3),theta=c(0,1,2),lambda=c(0.1,-0.1,0.5))
b &lt;- dLGP(x=1,theta=1,lambda=-0.1) * dLGP(x=3,theta=2,lambda=0.5)
a-b #&lt;--near zero.
## lambdas of zero yield the ordinary Poisson:
a &lt;- dbiLGP(y=c(1,3), theta=c(0,1,2),lambda=0)
b &lt;- dpois(x=1,lambda=1) * dpois(x=3,lambda=2) #&lt;--LGP theta is pois lambda
a-b #&lt;--near zero

( y &lt;- rbiLGP(10,theta=c(1.1,0.87,5.5),lambda=c(0.87,0.89,0.90)) )
dbiLGP(y=y,theta=c(1.1,0.87,5.5),lambda=c(0.87,0.89,0.90))

biLGP.logMV(theta=c(0.65,0.35,0.35),lambda=0.7,tol=1e-8)
</code></pre>

<hr>
<h2 id='binegbin'>The bivariate negative binomial distribution</h2><span id='topic+dbinegbin'></span><span id='topic+binegbin.logMV'></span><span id='topic+rbinegbin'></span>

<h3>Description</h3>

<p>Functions for the bivariate negative binomial distribution, as generated via trivariate reduction: density, random-number generation, and moments of the log-transformed distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbinegbin(y, nu, p, log=FALSE, add.carefully=FALSE)
binegbin.logMV(nu,p,const.add=1,tol=1e-14,add.carefully=FALSE)
rbinegbin(n, nu, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binegbin_+3A_y">y</code></td>
<td>
<p>Numeric vector or two-column matrix of bivariate data.  If matrix, each row corresponds to an observation.</p>
</td></tr>
<tr><td><code id="binegbin_+3A_nu">nu</code></td>
<td>
<p>Numeric vector or three-column matrix of non-negative values for index parameters <code class="reqn">\nu _0</code>, <code class="reqn">\nu _1</code>, and <code class="reqn">\nu _2</code>, in that order.  If matrix, is read by row.</p>
</td></tr>
<tr><td><code id="binegbin_+3A_p">p</code></td>
<td>
<p>Numeric vector or three-column matrix of values for Bernoulli parameters <code class="reqn">p_0</code>, <code class="reqn">p_1</code>, and <code class="reqn">p_2</code>, in that order.  If matrix, is read by row.  Values must be on the interval (0,1].</p>
</td></tr>
<tr><td><code id="binegbin_+3A_log">log</code></td>
<td>
<p>Logical; should the natural log of the probability be returned?  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="binegbin_+3A_add.carefully">add.carefully</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the program takes extra steps to try to prevent round-off error during the addition of probabilities.  Defaults to <code>FALSE</code>, which is recommended, since using <code>TRUE</code> is slower and rarely makes a noticeable difference in practice.</p>
</td></tr>
<tr><td><code id="binegbin_+3A_const.add">const.add</code></td>
<td>
<p>Numeric vector of positive constants to add to the non-negative integers before taking their natural logarithm.  Defaults to 1, for the typical <code class="reqn">\log (y+1)</code> transformation.</p>
</td></tr>
<tr><td><code id="binegbin_+3A_tol">tol</code></td>
<td>
<p>Numeric; must be positive.  When <code>binegbin.logMV()</code> is calculating the second moment of the log-transformed distribution, it stops when the next term in the series is smaller than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="binegbin_+3A_n">n</code></td>
<td>
<p>Integer; number of observations to be randomly generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This bivariate negative binomial distribution is constructed from three independent latent variables, in the same manner as the <a href="#topic+biLGP">bivariate Lagrangian Poisson</a> distribution.
</p>
<p>Function <code>dbinegbin()</code> is the bivariate negative binomial density (PMF).  Function <code>rbinegbin()</code> generates random draws from the bivariate negative binomial distribution, via calls to <code><a href="stats.html#topic+rnbinom">rnbinom</a>()</code>.  Function <code>binegbin.logMV()</code> numerically computes the means, variances, and covariance of a bivariate LGP distribution, after it has been log transformed following addition of a positive constant.
</p>
<p>Vectors of numeric arguments other than <code>tol</code> are cycled, whereas only the first element of logical and integer arguments is used.
</p>


<h3>Value</h3>

<p><code>dbinegbin()</code> returns a numeric vector of probabilities.  <code>rbinegbin()</code> returns a matrix of random draws, which is of type 'numeric' (rather than 'integer', even though the negative binomial only has support on the non-negative integers).  <code>binegbin.logMV()</code> returns a numeric matrix with the following five named columns:
</p>

<ol>
<li> <p><code>EY1</code>: Post-tranformation expectation of <code class="reqn">Y_1</code>.
</p>
</li>
<li> <p><code>EY2</code>: Post-tranformation expectation of <code class="reqn">Y_2</code>.
</p>
</li>
<li> <p><code>VY1</code>: Post-tranformation variance of <code class="reqn">Y_1</code>.
</p>
</li>
<li> <p><code>VY2</code>: Post-tranformation variance of <code class="reqn">Y_2</code>.
</p>
</li>
<li> <p><code>COV</code>: Post-tranformation covariance of <code class="reqn">Y_1</code> and <code class="reqn">Y_2</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Robert M. Kirkpatrick <a href="mailto:rkirkpatrick2@vcu.edu">rkirkpatrick2@vcu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbiLGP">dbiLGP</a></code>, <code><a href="stats.html#topic+dnbinom">dnbinom</a>()</code>,  <code><a href="stats.html#topic+rnbinom">rnbinom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The following two lines do the same thing:
dbinegbin(y=1,nu=1,p=0.9)
dbinegbin(y=c(1,1),nu=c(1,1,1),p=c(0.9,0.9,0.9))

dbinegbin(y=c(1,1,2,2,3,5),nu=c(1,1,1,2,2,2),p=0.9)
## Due to argument cycling, the above line is doing the following three steps:
dbinegbin(y=c(1,1),nu=c(1,1,1),p=c(0.9,0.9,0.9))
dbinegbin(y=c(2,2),nu=c(2,2,2),p=c(0.9,0.9,0.9))
dbinegbin(y=c(3,5),nu=c(1,1,1),p=c(0.9,0.9,0.9))

## Inputs to dbinegbin() can be matrices, too:
dbinegbin(y=matrix(c(1,1,2,2,3,5),ncol=2,byrow=TRUE),
  nu=matrix(c(1,1,1,2,2,2,1,1,1),ncol=3,byrow=TRUE),
  p=0.9)
  
## nu0 = 0 implies independence:
a &lt;- dbinegbin(y=c(1,3),nu=c(0,1,2),p=c(0.1,0.5,0.9))
b &lt;- dnegbin(x=1,nu=1,p=0.5) * dnegbin(x=3,nu=2,p=0.9)
a-b #&lt;--near zero.

( y &lt;- rbinegbin(10,nu=c(1.1,0.87,5.5),p=c(0.87,0.89,0.90)) )
dbinegbin(y=y,nu=c(1.1,0.87,5.5),p=c(0.87,0.89,0.90))
( mv &lt;- negbinMVP(nu=c(1.1,0.87,5.5),p=c(0.87,0.89,0.90)) )
mv[1,2] #&lt;--Covariance of this distribution
mv[1,2]+mv[2,2] #&lt;--Marginal variance of Y1
mv[1,2]+mv[3,2] #&lt;--Marginal variance of Y2
mv[1,2]/(sqrt(mv[1,2]+mv[2,2])*sqrt(mv[1,2]+mv[3,2])) #&lt;--Correlation
logmv &lt;- binegbin.logMV(nu=c(1.1,0.87,5.5),p=c(0.87,0.89,0.90))
## Log transformation nearly cuts the correlation in half:
logmv[1,5]/sqrt(logmv[1,3]*logmv[1,4])
</code></pre>

<hr>
<h2 id='LGP'>The (univariate) Lagrangian Poisson (LGP) Distribution</h2><span id='topic+LGP'></span><span id='topic+LGPMVP'></span><span id='topic+LGP.findmax'></span><span id='topic+LGP.get.nc'></span><span id='topic+dLGP'></span><span id='topic+pLGP'></span><span id='topic+qLGP'></span><span id='topic+rLGP'></span><span id='topic+sLGP'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, summary, random number generation, and utility functions for the (univariate) Lagrangian Poisson distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLGP(x,theta,lambda,nc=NULL,log=FALSE)
pLGP(q,theta,lambda,nc=NULL,lower.tail=TRUE,log.p=FALSE,add.carefully=FALSE)
qLGP(p,theta,lambda,nc=NULL,lower.tail=TRUE,log.p=FALSE,add.carefully=FALSE)
rLGP(n,theta,lambda)
sLGP(theta,lambda,nc=NULL,do.numerically=FALSE,add.carefully=FALSE)
LGP.findmax(theta,lambda)
LGP.get.nc(theta,lambda,nctol=1e-14,add.carefully=FALSE)
LGPMVP(mu,sigma2,theta,lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LGP_+3A_x">x</code>, <code id="LGP_+3A_q">q</code></td>
<td>
<p>Numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="LGP_+3A_p">p</code></td>
<td>
<p>Numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="LGP_+3A_n">n</code></td>
<td>
<p>Integer; number of observations to be randomly generated.</p>
</td></tr>
<tr><td><code id="LGP_+3A_theta">theta</code></td>
<td>
<p>Numeric; the index (or &quot;additive&quot;) parameter of the LGP distribution.  Must be non-negative.</p>
</td></tr>
<tr><td><code id="LGP_+3A_lambda">lambda</code></td>
<td>
<p>Numeric; the dispersion (or &quot;Lagrangian&quot; or &quot;multiplicative&quot;) parameter of the LGP distribution.  Must not exceed 1 in absolute value.  When equal to zero, the LGP reduces to the ordinary Poisson distribution, with mean equal to <code>theta</code>.  When negative, then the distribution has an upper limit to its support, which may be found with <code>LGP.findmax()</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="LGP_+3A_nc">nc</code></td>
<td>
<p>Numeric; the reciprocal of the normalizing constant of the distribution, by which the raw PMF must be multiplied so that it is a proper PMF, with values that sum to 1 across the support, when <code>lambda</code> is negative.  Defaults to <code>NULL</code>, in which case it is computed numerically by a call to <code>LGP.get.nc()</code>.</p>
</td></tr>
<tr><td><code id="LGP_+3A_log">log</code>, <code id="LGP_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if <code>TRUE</code>, then probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="LGP_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities are <code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="LGP_+3A_nctol">nctol</code></td>
<td>
<p>Numeric; while numerically computing the normalizing constant, how close to 1 should it be before stopping?  Ignored unless <code>lambda</code> is negative, and the upper support limit exceeds 200,000.</p>
</td></tr>
<tr><td><code id="LGP_+3A_add.carefully">add.carefully</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the program takes extra steps to try to prevent round-off error during the addition of probabilities.  Defaults to <code>FALSE</code>, which is recommended, since using <code>TRUE</code> is slower and rarely makes a noticeable difference in practice.</p>
</td></tr>
<tr><td><code id="LGP_+3A_do.numerically">do.numerically</code></td>
<td>
<p>Logical; should moments be computed numerically when <code>lambda</code>&lt;0?  Defaults to <code>FALSE</code>, which is recommended unless the upper support limit is fairly small (say, less than 10).</p>
</td></tr>
<tr><td><code id="LGP_+3A_mu">mu</code></td>
<td>
<p>Numeric vector of mean parameters.</p>
</td></tr>
<tr><td><code id="LGP_+3A_sigma2">sigma2</code></td>
<td>
<p>&quot;Sigma squared&quot;&ndash;numeric vector of variance parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lagrangian Poisson (LGP) distribution has density
</p>
<p style="text-align: center;"><code class="reqn">p(x)=\frac{\theta (\theta + \lambda x)^{x-1} \exp(- \theta - \lambda x)}{x!}</code>
</p>
<p> for <code class="reqn">0,1,2,\ldots</code>,
</p>
<p style="text-align: center;"><code class="reqn">p(x)=0</code>
</p>
<p> for <code class="reqn">x&gt;m</code> if <code class="reqn">\lambda&lt;0</code>,
and zero otherwise, where <code class="reqn">\theta&gt;0</code>, <code class="reqn">m=\lfloor-\theta / \lambda\rfloor</code> if <code class="reqn">\lambda&lt;0</code>, and <code class="reqn">\max(-1,-\theta / m)\leq\lambda\leq 1</code>.  So, when <code class="reqn">\lambda</code> is negative, there is an upper limit to the distribution's support, <code class="reqn">m</code>, equal to <code class="reqn">-\theta / \lambda</code>, rounded down to the next-smallest integer.  When <code class="reqn">\lambda</code> is negative, the PMF must also be normalized numerically if it is to describe a proper probability distribution.  When <code class="reqn">\lambda=0</code>, the Lagrangian Poisson reduces to the ordinary Poisson, with mean equal to <code class="reqn">\theta</code>.  When <code class="reqn">\theta=0</code>, we define the distribution as having unit mass on the event <code class="reqn">X=0</code>.
</p>
<p>Function <code>LGP.findmax()</code> calculates the value of upper support limit <code class="reqn">m</code>; <code>LGP.get.nc()</code> calculates the (reciprocal of) the normalizing constant.
</p>
<p>Function <code>LGPMVP()</code> accepts exactly two of its four arguments, and returns the corresponding values of the other two arguments.  For example, if given values for <code>theta</code> and <code>lambda</code>, it will return the corresponding means (<code>mu</code>) and variances (<code>sigma2</code>) of an LGP distribution with the given values of <code class="reqn">\theta</code> and <code class="reqn">\lambda</code>.  <code>LGPMVP()</code> does not enforce the parameter space as strictly as other functions, but will throw a warning for bad parameter values.
</p>
<p>When the upper support limit is 5 or smaller, <code>rLGP()</code> uses simple inversion (i.e., random unit-uniform draws passed to <code>qLGP()</code>).  Otherwise, it uses random-number generation algorithms from Consul &amp; Famoye (2006); exactly which algorithm is used depends upon the values of <code>theta</code> and <code>lambda</code>.  All four of <code>rLGP()</code>, <code>dLGP()</code>, <code>pLGP()</code>, and <code>qLGP()</code> make calls to the corresponding functions for the ordinary Poisson distribution (<code><a href="stats.html#topic+dpois">dpois</a>()</code>,etc.) when <code>lambda</code>=0.
</p>
<p>Vectors of numeric arguments are cycled, whereas only the first element of logical and integer arguments is used.
</p>


<h3>Value</h3>

<p><code>dLGP()</code> and <code>pLGP()</code> return numeric vectors of probabilities.  <code>qLGP()</code>, <code>rLGP()</code>, and <code>LGP.findmax()</code> return  vectors of quantiles, which are of class 'numeric' rather than 'integer' for the sake of compatibility with very large values.  <code>LGP.get.nc()</code> returns a numeric vector of reciprocal normalizing constants.  <code>LGPMVP()</code> returns a numeric matrix with two columns, named for the missing arguments in the function call.
</p>
<p><code>sLGP()</code> returns a numeric matrix with 10 columns, with the mostly self-explanatory names <code>"Mean"</code>, <code>"Median"</code>, <code>"Mode"</code>, <code>"Variance"</code>, <code>"SD"</code>, <code>"ThirdCentralMoment"</code>, <code>"FourthCentralMoment"</code>, <br /> <code>"PearsonsSkewness"</code>, <code>"Skewness"</code>, and <code>"Kurtosis"</code>.  Here, <code>"Kurtosis"</code> refers to excess kurtosis (greater than 3), and <code>"PearsonsSkewness"</code> equals <code class="reqn">\frac{(mean - mode)}{SD}</code>.  A <code>"Mode"</code> of 0.5 indicates that the point probabilities at <code class="reqn">x=0</code> and <code class="reqn">x=1</code> are tied for highest density; other than this possibility, the LGP is strictly unimodal. 
</p>


<h3>Warning</h3>

<p>There is a known issue with <code>sLGP()</code>: when <code>lambda</code> is negative and <code>theta</code> is large, the third and fourth moments returned by <code>sLGP()</code>, with <code>do.numerically=TRUE</code>, can be quite incorrect due to numerical imprecision.
</p>


<h3>Author(s)</h3>

<p>Robert M. Kirkpatrick <a href="mailto:rkirkpatrick2@vcu.edu">rkirkpatrick2@vcu.edu</a>
</p>


<h3>References</h3>

<p>Consul, P. C.  (1989).  <em>Generalized Poisson Distributions: Properties and Applications</em>.  New York:  Marcel Dekker, Inc.
</p>
<p>Consul, P. C., &amp; Famoye, F.  (2006).  <em>Lagrangian Probability Distributions</em>.  Boston: Birkhauser.
</p>
<p>Johnson, N. L., Kemp, A. W., &amp; Kotz, S.  (2005).  <em>Univariate Discrete Distributions</em> (3rd. ed.).  Hoboken, NJ: John Wiley &amp; Sons, Inc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LGP.findmax(theta=2, lambda=0.2) #&lt;--No upper support limit
LGP.findmax(theta=2, lambda=-0.2) #&lt;--Upper support limit of 9
LGP.get.nc(theta=2, lambda=0.2)-1==0 #&lt;--TRUE
LGP.get.nc(theta=2, lambda=-0.2)-1 #&lt;--nc differs appreciably from 1
LGP.get.nc(theta=2, lambda=-0.1)-1 #&lt;--nc doesn't differ appreciably from 1
LGPMVP(theta=2, lambda=0.9)
LGPMVP(mu=20, sigma2=2000)
sLGP(theta=2, lambda=0.9)
dLGP(x=0:10,theta=1,lambda=0.1)
dLGP(x=0:10,theta=1,lambda=0)
dLGP(x=0:10,theta=1,lambda=-0.1) #&lt;--Upper support limit of 9
pLGP(q=0:10,theta=1,lambda=0.1)
pLGP(q=0:10,theta=1,lambda=0)
pLGP(q=0:10,theta=1,lambda=-0.1) 
qLGP(p=(0:9)/10,theta=1,lambda=0.1)
qLGP(p=(0:9)/10,theta=1,lambda=0)
qLGP(p=(0:9)/10,theta=1,lambda=-0.1) 
rLGP(n=5,theta=1e12,lambda=-0.0001)
</code></pre>

<hr>
<h2 id='ManaClash'>The Mana Clash distributions (just for fun!)</h2><span id='topic+ManaClash'></span><span id='topic+dmanaclash.net'></span><span id='topic+dmanaclash.dmg'></span><span id='topic+dmanaclash.xyN'></span><span id='topic+rmanaclash'></span>

<h3>Description</h3>

<p>Density and random-number functions for distributions pertinent to <a href="http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=83159">&quot;Mana Clash&quot;</a>, a card from the <em>Magic: The Gathering</em> trading-card game.  As of 08/29/2014, the official card text read: &quot;You and target opponent each flip a coin. Mana Clash deals 1 damage to each player whose coin comes up tails. Repeat this process until both players' coins come up heads on the same flip.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmanaclash.dmg(x,y,N=NULL,pA=0.25,pB=0.25,pC=0.25,pD=0.25,log=FALSE)
dmanaclash.xyN(x,y,N,pA=0.25,pB=0.25,pC=0.25,pD=0.25,log=FALSE)
dmanaclash.net(z,pA=0.25,pB=0.25,pC=0.25,pD=0.25,rel.eps=1e-8,log=FALSE)
rmanaclash(n,pA=0.25,pB=0.25,pC=0.25,pD=0.25,N=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ManaClash_+3A_x">x</code></td>
<td>
<p>Numeric amount of damage dealt to opponent.</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_y">y</code></td>
<td>
<p>Numeric amount of damage dealt to Mana Clash's controller (hereinafter, &quot;you&quot;).</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_n">N</code></td>
<td>
<p>Numeric.  Number of rounds of coin-tossing that <em>precede</em> the last round, when double heads occurs.  That is, <code>N</code> is the number of rounds of coin-tossing in which at least one player takes damage.</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_z">z</code></td>
<td>
<p>Numeric; <em>net</em> damage dealt to opponent; negative values are allowed.</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_n">n</code></td>
<td>
<p>Integer number of random vectors to generate.</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_pa">pA</code></td>
<td>
<p>Numeric; probability that both players take damage in a round of coin-tossing (i.e., double tails).</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_pb">pB</code></td>
<td>
<p>Numeric; probability that you take damage but opponent does not in a round of coin-tossing.</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_pc">pC</code></td>
<td>
<p>Numeric; probability that opponent takes damage but you do not in a round of coin-tossing.</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_pd">pD</code></td>
<td>
<p>Numeric; probability that neither player takes damage in a round of coin-tossing (i.e., double heads).</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_log">log</code></td>
<td>
<p>Logical; should the natural log of the probability be returned?  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ManaClash_+3A_rel.eps">rel.eps</code></td>
<td>
<p>Numeric; when computing the sum of an infinite series, how small should the relative change in the sum get before stopping?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability arguments&ndash;<code>pA</code>, <code>pB</code>, <code>pC</code>, and <code>pD</code>&ndash;are named as in a two-way contingency table.  They cannot be negative, although <code>rmanaclash</code> accepts values of zero for <code>pA</code>, <code>pB</code>, and <code>pC</code>.  If they do not sum to 1, they are automatically normalized.  They default to the scenario of two independent fair coins.
</p>
<p>Vectors of numeric arguments other than <code>rel.eps</code> are cycled, whereas only the first element of logical and integer arguments is used.
</p>
<p>Function <code>dmanaclash.dmg()</code> is the bivariate PMF of the amount of damage dealt to opponent and you.  If <code>N = NULL</code> (default), the probabilities are marginal with respect to the number of rounds of damage-dealing.  Otherwise, the probabilities are conditioned upon the given value of <code>N</code>.
</p>
<p>Function <code>dmanaclash.xyN()</code> is the trivariate joint PMF of the amount of damage dealt to opponent, the amount dealt to you, and the number of rounds of damage-dealing.
</p>
<p>Function <code>dmanaclash.net</code> is the univariate PMF of the <em>net</em> amount of damage dealt to opponent, i.e. damage dealt to opponent minus damage dealt to you.  This distribution has support on the set of integers&ndash;including negative values.
</p>
<p>Function <code>rmanaclash()</code> generates random draws from the trivariate joint distribution of <code class="reqn">x</code>, <code class="reqn">y</code>, and <code class="reqn">N</code>; if a non-<code>NULL</code> value for <code>N</code> is supplied, the random draws are generated conditionally on that number of damage-dealing rounds.
</p>


<h3>Value</h3>

<p><code>dmanaclash.dmg()</code>, <code>dmanaclash.xyN()</code>, and <code>dmanaclash.net()</code> all return numeric vectors of probabilities.  <code>rmanaclash()</code> returns a numeric matrix, with <code>n</code> rows, and three columns, named &quot;x&quot;, &quot;y&quot;, and &quot;N&quot;.  Each row is a random draw.
</p>


<h3>Derivation</h3>

<p>Note:  This section is only displayed in the PDF of the package documentation.

</p>


<h3>Author(s)</h3>

<p>Robert M. Kirkpatrick <a href="mailto:rkirkpatrick2@vcu.edu">rkirkpatrick2@vcu.edu</a></p>


<h3>References</h3>

<p><em>Magic: The Gathering</em> is a trademark of Wizards of the Coast, LLC, a subsidiary of Hasbro, Inc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Same outcome, with and without conditioning on N:
dmanaclash.dmg(x=1,y=1,N=1)
dmanaclash.dmg(x=1,y=1)

## Same damage amounts, with N fixed versus random:
dmanaclash.dmg(x=1,y=1,N=2)
dmanaclash.xyN(x=1,y=1,N=2)

## Net damage distribution is symmetric with defaults:
dmanaclash.net(z=c(-3,-2,-1,0,1,2,3))
## But if coins are biased against opponent...:
dmanaclash.net(z=c(-3,-2,-1,0,1,2,3),pA=0.1,pB=0.1,pC=0.7,pD=0.1)

## Random draws:
rmanaclash(n=10)
rmanaclash(n=10,pA=0.1,pB=0.1,pC=0.7,pD=0.1)
rmanaclash(n=10,N=5)
</code></pre>

<hr>
<h2 id='negbin'>
Helper functions for the (unvariate) negative binomial distribution.
</h2><span id='topic+dnegbin'></span><span id='topic+negbinMVP'></span>

<h3>Description</h3>

<p>Helper functions for the (unvariate) negative binomial distribution: change-of-parameter, wrapper function for density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnegbin(x,nu,p,mu,log=FALSE)
negbinMVP(nu, p, mu, sigma2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negbin_+3A_x">x</code></td>
<td>
<p>Numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="negbin_+3A_nu">nu</code></td>
<td>
<p>Numeric; equivalent to argument <code>size</code> in <code><a href="stats.html#topic+NegBinomial">dnbinom</a>()</code>, etc.</p>
</td></tr>
<tr><td><code id="negbin_+3A_p">p</code></td>
<td>
<p>Numeric; equivalent to argument <code>prob</code> in <code><a href="stats.html#topic+NegBinomial">dnbinom</a>()</code>, etc.</p>
</td></tr>
<tr><td><code id="negbin_+3A_mu">mu</code></td>
<td>
<p>Numeric vector of mean parameters.</p>
</td></tr>
<tr><td><code id="negbin_+3A_sigma2">sigma2</code></td>
<td>
<p>&quot;Sigma squared&quot;&ndash;numeric vector of variance parameters.</p>
</td></tr>
<tr><td><code id="negbin_+3A_log">log</code></td>
<td>
<p>Logical; should the natural log of the probability be returned?  Defaults to <code>FALSE</code>.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Function <code>dnegbin()</code> is a wrapper for <code><a href="stats.html#topic+NegBinomial">dnbinom</a>()</code>.  Two of the three arguments <code>nu</code>, <code>p</code>, and <code>mu</code> must be provided.  Unlike <code><a href="stats.html#topic+NegBinomial">dnbinom</a>()</code>, <code>dnegbin()</code> will accept <code>mu</code> and <code>p</code>(<code>prob</code>) with <code>nu</code>(<code>size</code>) missing.  In that case, it calculates <code>nu</code> as <code>mu * p/(1-p)</code>, and passes <code>nu</code> and <code>p</code> to <code><a href="stats.html#topic+NegBinomial">dnbinom</a>()</code>.
</p>
<p>Function <code>negbinMVP()</code> accepts exactly two of its four arguments, and returns the corresponding values of the other two arguments.  For example, if given values for <code>nu</code> and <code>p</code>, it will return the corresponding means (<code>mu</code>) and variances (<code>sigma2</code>) of a negative binomial distribution with the given values of <code>nu</code> and <code>p</code>.  <code>negbinMVP()</code> does not strictly enforce the parameter space, but will throw a warning for bad input values.
</p>


<h3>Value</h3>

<p><code>dnegbin()</code> returns a numeric vector of probabilities.  <code>negbinMVP()</code> returns a numeric matrix with two columns, named for the missing arguments in the function call.
</p>


<h3>Author(s)</h3>

<p>Robert M. Kirkpatrick <a href="mailto:rkirkpatrick2@vcu.edu">rkirkpatrick2@vcu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+NegBinomial">dnbinom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## These two lines do the same thing:
dnegbin(x=1,nu=2,p=0.5)
dnbinom(x=1,size=2,prob=0.5)

## What is the mean of this distribution?
negbinMVP(nu=2,p=0.5) #&lt;--mu=2

## These two lines also do the same thing:
dnegbin(x=1,nu=2,mu=2)
dnbinom(x=1,size=2,mu=2)

## Parametrize with mu &amp; p:
dnegbin(x=1,mu=2,p=0.5)
## Not run (will throw an error):
## dnbinom(x=1,prob=0.5,mu=2) 
</code></pre>

<hr>
<h2 id='RMKdiscrete-package'>Sundry discrete probability distributions.</h2><span id='topic+RMKdiscrete-package'></span><span id='topic+RMKdiscrete'></span>

<h3>Description</h3>

<p><em>RMKdiscrete</em> implements several univariate and bivariate discrete probability distributions:
</p>

<ul>
<li><p> The univariate Lagrangian Poisson distribution has five functions: <code><a href="#topic+dLGP">dLGP</a>()</code>, <code><a href="#topic+pLGP">pLGP</a>()</code>, <code><a href="#topic+qLGP">qLGP</a>()</code>, <code><a href="#topic+rLGP">rLGP</a>()</code>, <code><a href="#topic+sLGP">sLGP</a>()</code>, <code><a href="#topic+LGP.findmax">LGP.findmax</a>()</code>, <code><a href="#topic+LGP.get.nc">LGP.get.nc</a>()</code>, and <code><a href="#topic+LGPMVP">LGPMVP</a>()</code>.
</p>
</li>
<li><p> The bivariate Lagrangian Poisson distribution has three functions: <code><a href="#topic+dbiLGP">dbiLGP</a>()</code>, <code><a href="#topic+rbiLGP">rbiLGP</a>()</code>, and <code><a href="#topic+biLGP.logMV">biLGP.logMV</a>()</code>.
</p>
</li>
<li><p> The bivariate negative binomial distribution has three functions: <code><a href="#topic+dbinegbin">dbinegbin</a>()</code>, <code><a href="#topic+rbinegbin">rbinegbin</a>()</code>, and <code><a href="#topic+binegbin.logMV">binegbin.logMV</a>()</code>.
</p>
</li>
<li><p> Although the <a href="stats.html#topic+NegBinomial">univariate negative binomial</a> distribution is implemented in base <span class="rlang"><b>R</b></span>, <em>RMKdiscrete</em> provides two helper functions for it: <code><a href="#topic+dnegbin">dnegbin</a>()</code> and <code><a href="#topic+negbinMVP">negbinMVP</a>()</code>.
</p>
</li></ul>

<p>Finally, the <code><a href="#topic+ManaClash">ManaClash</a></code> distributions are provided just for fun.
</p>
<p>The package is presently in an unoptimized but functional &quot;beta&quot; state.  Additional helper functions and distributions, including multivariate distributions in more than two dimensions, are planned for subsequent versions of the package.  Contact the maintainer, <a href="mailto:rkirkpatrick2@vcu.edu">rkirkpatrick2@vcu.edu</a>, with suggestions, bug reports, and feature requests.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> RMKdiscrete</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014/10/17</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.15.0), stats</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Author(s)</h3>

<p>Robert M. Kirkpatrick <a href="mailto:rkirkpatrick2@vcu.edu">rkirkpatrick2@vcu.edu</a>
Maintainer: Robert M. Kirkpatrick
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
