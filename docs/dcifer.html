<!DOCTYPE html><html lang="en"><head><title>Help for package dcifer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dcifer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calcAfreq'><p>Calculate Allele Frequencies</p></a></li>
<li><a href='#dres'><p>Dcifer results</p></a></li>
<li><a href='#dsmp'><p>Sample data</p></a></li>
<li><a href='#format'><p>Read and Reformat Data</p></a></li>
<li><a href='#generateReval'><p>Grid of Parameter Values</p></a></li>
<li><a href='#getCOI'><p>Calculate COI</p></a></li>
<li><a href='#ibdDat'><p>Pairwise Relatedness</p></a></li>
<li><a href='#ibdEstM'><p>Estimate Relatedness and a Number of Related Strains</p></a></li>
<li><a href='#ibdPair'><p>Relatedness Between Two Samples</p></a></li>
<li><a href='#logReval'><p>Logarithms of <code>reval</code></p></a></li>
<li><a href='#matchAfreq'><p>Match Samples and Allele Frequencies</p></a></li>
<li><a href='#plotColorbar'><p>Colorbar</p></a></li>
<li><a href='#plotRel'><p>Plot Relatedness Estimates</p></a></li>
<li><a href='#probUxUy'><p>Likelihood for</p>
U<sub>x</sub>,
U<sub>y</sub></a></li>
<li><a href='#revals'><p>Parameter grid</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genetic Relatedness Between Polyclonal Infections</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Inna Gerlovina &lt;innager@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of Dcifer (Distance for complex infections: fast estimation of relatedness), an identity by descent (IBD) based method to calculate genetic relatedness between polyclonal infections from biallelic and multiallelic data. The package includes functions that format and preprocess the data, implement the method, and visualize the results. 
    Gerlovina et al. (2022) &lt;<a href="https://doi.org/10.1093%2Fgenetics%2Fiyac126">doi:10.1093/genetics/iyac126</a>&gt;. </td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/EPPIcenter/dcifer">https://github.com/EPPIcenter/dcifer</a>,
<a href="https://eppicenter.github.io/dcifer/">https://eppicenter.github.io/dcifer/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 09:04:28 UTC; innars</td>
</tr>
<tr>
<td>Author:</td>
<td>Inna Gerlovina <a href="https://orcid.org/0000-0002-7772-7473"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calcAfreq'>Calculate Allele Frequencies</h2><span id='topic+calcAfreq'></span>

<h3>Description</h3>

<p>Calculates population allele frequencies from data, adjusting for COI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcAfreq(dsmp, coi, tol = 1e-04, qstart = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcAfreq_+3A_dsmp">dsmp</code></td>
<td>
<p>a list with each element corresponding to one sample.</p>
</td></tr>
<tr><td><code id="calcAfreq_+3A_coi">coi</code></td>
<td>
<p>a vector containing complexity of infection for each sample.</p>
</td></tr>
<tr><td><code id="calcAfreq_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance for frequency estimates.</p>
</td></tr>
<tr><td><code id="calcAfreq_+3A_qstart">qstart</code></td>
<td>
<p>a starting value for frequencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of allele frequencies, where each element is a numeric vector
containing frequencies for a single locus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coi   &lt;- getCOI(dsmp, lrank = 2)           # estimate COI first
afreq &lt;- calcAfreq(dsmp, coi, tol = 1e-5)
</code></pre>

<hr>
<h2 id='dres'>Dcifer results</h2><span id='topic+dres'></span>

<h3>Description</h3>

<p>Results of relatedness estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dres
</code></pre>


<h3>Format</h3>

<p>A three-dimensional array with 52 columns, 52 rows, and 4 matrices.
Dimension names correspond to sample ID's (rows and columns) and types of
results <code>c("estimate", "p_value", "CI_lower", "CI_upper")</code> (matrices).
</p>

<hr>
<h2 id='dsmp'>Sample data</h2><span id='topic+dsmp'></span>

<h3>Description</h3>

<p>Microhaplotype data from two clinics in Mozambique. Samples are sorted by location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsmp
</code></pre>


<h3>Format</h3>

<p>A list of 52 elements (samples), each element is a list of 87
elements (loci), which are integer vectors (alleles).
</p>

<hr>
<h2 id='format'>Read and Reformat Data</h2><span id='topic+format'></span><span id='topic+readDat'></span><span id='topic+formatDat'></span><span id='topic+readAfreq'></span><span id='topic+formatAfreq'></span>

<h3>Description</h3>

<p><code>readDat</code> and <code>readAfreq</code> read data and population allele
frequencies from <code>csv</code> files and reformat them for further processing.
<code>formatDat</code> and <code>formatAfreq</code> reformat corresponding data frames.
Original data are assumed to be in a long format, with one row per allele.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDat(sfile, svar, lvar, avar, ...)

formatDat(dlong, svar, lvar, avar)

readAfreq(afile, lvar, avar, fvar, ...)

formatAfreq(aflong, lvar, avar, fvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_+3A_sfile">sfile</code></td>
<td>
<p>the name of the file containing sample data.</p>
</td></tr>
<tr><td><code id="format_+3A_svar">svar</code></td>
<td>
<p>the name of the variable for sample ID.</p>
</td></tr>
<tr><td><code id="format_+3A_lvar">lvar</code></td>
<td>
<p>the name of the variable for locus/marker.</p>
</td></tr>
<tr><td><code id="format_+3A_avar">avar</code></td>
<td>
<p>the name of the variable for allele/haplotype.</p>
</td></tr>
<tr><td><code id="format_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>read.csv()</code>.</p>
</td></tr>
<tr><td><code id="format_+3A_dlong">dlong</code></td>
<td>
<p>a data frame containing sample data.</p>
</td></tr>
<tr><td><code id="format_+3A_afile">afile</code></td>
<td>
<p>the name of the file containing population allele frequencies.</p>
</td></tr>
<tr><td><code id="format_+3A_fvar">fvar</code></td>
<td>
<p>the name of the variable for population allele frequiency.</p>
</td></tr>
<tr><td><code id="format_+3A_aflong">aflong</code></td>
<td>
<p>a data frame containing population allele frequencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>readDat</code> and <code>formatDat</code>, a list with elements
corresponding to samples. Each element of the list is itself a list of
binary vectors, one vector for each locus. For <code>readAfreq</code> and
<code>formatAfreq</code>, a list with elements corresponding to loci. The
frequencies at each locus are normalized and sum to 1. Samples, loci, and
alleles are ordered by their IDs/names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchAfreq">matchAfreq</a></code> for making sure that the list containing
sample data is conformable to provided population allele frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfile &lt;- system.file("extdata", "MozParagon.csv", package = "dcifer")
dsmp  &lt;- readDat(sfile, svar = "sampleID", lvar = "locus", avar = "allele")

# OR, if the dataset is provided as an R data frame, e.g.
dlong &lt;- read.csv(sfile)
# reformat only:
dsmp &lt;- formatDat(dlong, svar = "sampleID", lvar = "locus", avar = "allele")

afile  &lt;- system.file("extdata", "MozAfreq.csv", package = "dcifer")
afreq2 &lt;- readAfreq(afile, lvar = "locus", avar = "allele", fvar = "freq")

# OR, if allele frequencies are provided as an R data frame, e.g.
aflong &lt;- read.csv(afile)
# reformat only:
afreq2 &lt;- formatAfreq(aflong, lvar = "locus", avar = "allele", fvar = "freq")

dsmp2  &lt;- matchAfreq(dsmp, afreq2)

</code></pre>

<hr>
<h2 id='generateReval'>Grid of Parameter Values</h2><span id='topic+generateReval'></span>

<h3>Description</h3>

<p>Generates a grid of parameter values to evaluate over.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateReval(M, rval = NULL, nr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateReval_+3A_m">M</code></td>
<td>
<p>an integer.</p>
</td></tr>
<tr><td><code id="generateReval_+3A_rval">rval</code></td>
<td>
<p>a numeric vector with parameter values for the grid. If not
provided, it will be generated by dividing [0,
  1] into <code>nr</code> equal intervals.</p>
</td></tr>
<tr><td><code id="generateReval_+3A_nr">nr</code></td>
<td>
<p>an integer. Ignored if <code>rval</code> is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A a matrix with <code>M</code> rows and <code>nr + 1</code> or
<code>length(rval)</code> columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reval &lt;- generateReval(M = 2, nr = 1e2)
dim(reval)

</code></pre>

<hr>
<h2 id='getCOI'>Calculate COI</h2><span id='topic+getCOI'></span>

<h3>Description</h3>

<p>Calculates complexity of infection for a list of samples, using the number of
detected alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCOI(dsmp, lrank = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCOI_+3A_dsmp">dsmp</code></td>
<td>
<p>a list with each element corresponding to one sample.</p>
</td></tr>
<tr><td><code id="getCOI_+3A_lrank">lrank</code></td>
<td>
<p>the rank of the locus that will determine a sample's COI (loci
are ranked by the number of detected alleles).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with estimated COI for each sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coi &lt;- getCOI(dsmp, lrank = 2)
</code></pre>

<hr>
<h2 id='ibdDat'>Pairwise Relatedness</h2><span id='topic+ibdDat'></span>

<h3>Description</h3>

<p>Provides pairwise relatedness estimates within a dataset or
between two datasets along with optional p-values and confidence intervals
(CI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdDat(
  dsmp,
  coi,
  afreq,
  dsmp2 = NULL,
  coi2 = NULL,
  pval = TRUE,
  confint = FALSE,
  rnull = 0,
  alpha = 0.05,
  nr = 1000,
  reval = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ibdDat_+3A_dsmp">dsmp</code></td>
<td>
<p>a list with each element corresponding to one sample.</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_coi">coi</code></td>
<td>
<p>a vector containing complexity of infection for each sample.</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_afreq">afreq</code></td>
<td>
<p>a list of allele frequencies. Each element of the list
corresponds to a locus.</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_dsmp2">dsmp2</code></td>
<td>
<p>a list representing a second dataset.</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_coi2">coi2</code></td>
<td>
<p>a vector with complexities of infection for a second dataset.</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_pval">pval</code></td>
<td>
<p>a logical value specifying if p-values should be returned.</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_confint">confint</code></td>
<td>
<p>a logical value specifying if confidence intervals should be
returned.</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_rnull">rnull</code></td>
<td>
<p>a null value of relatedness parameter for hypothesis testing
(needed if <code>pval = TRUE</code>).</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_alpha">alpha</code></td>
<td>
<p>significance level for a 1 -
&alpha; confidence region.</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_nr">nr</code></td>
<td>
<p>an integer specifying precision of the estimate: resolution of
a grid of parameter values ([0, 1]
divided into <code>nr</code> equal intervals), over which the likelihood will be
calculated. Ignored if non-null <code>reval</code> is provided.</p>
</td></tr>
<tr><td><code id="ibdDat_+3A_reval">reval</code></td>
<td>
<p>a vector or a single-row matrix. A grid of parameter values,
over which the likelihood will be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function, M is set to 1. If
<code>confint = FALSE</code>, Newton's method is used to find the estimates,
otherwise the likelihood is calculated for a grid of parameter values.
</p>


<h3>Value</h3>

<p>A matrix if <code>pval</code> and <code>confint</code> are <code>FALSE</code> and
3-dimensional arrays otherwise. The matrices are lower triangular if
distances are calculated within a dataset. For a 3-dimensional array,
stacked matrices contain relatedness estimates, p-values, and endpoints of
confidence intervals (if requested).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ibdPair">ibdPair</a></code> for genetic relatedness between two samples
and <code><a href="#topic+ibdEstM">ibdEstM</a></code> for estimating the number of related pairs of
strains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coi   &lt;- getCOI(dsmp, lrank = 2)           # estimate COI
afreq &lt;- calcAfreq(dsmp, coi, tol = 1e-5)  # estimate allele frequencies

# subset of samples for faster processing
i1 &lt;- 1:15     # from Maputo
i2 &lt;- 31:40    # from Inhambane
isub &lt;- c(i1, i2)

# matrix is returned
dres1 &lt;- ibdDat(dsmp[isub], coi[isub], afreq, pval = FALSE)
dim(dres1)

# test a null hypothesis H0: r = 0, change precision
dres2 &lt;- ibdDat(dsmp[isub], coi[isub], afreq, pval = TRUE, rnull = 0,
                nr = 1e2)
dim(dres2)

# test H0: r = 0.2, include 99% confidence intervals
dres3 &lt;- ibdDat(dsmp[isub], coi[isub], afreq, pval = TRUE, confint = TRUE,
                rnull = 0.2, alpha = 0.01)
dres3[2, 1, ]

# pairwise relatedness between two datasets, H0: r = 0
drbetween &lt;- ibdDat(dsmp[i1], coi[i1], afreq,
                    dsmp2 = dsmp[i2], coi2 = coi[i2])
dim(drbetween)
drbetween[1, 2, ]
sum(is.na(drbetween[, , 1]))

</code></pre>

<hr>
<h2 id='ibdEstM'>Estimate Relatedness and a Number of Related Strains</h2><span id='topic+ibdEstM'></span>

<h3>Description</h3>

<p>Estimates the number of related pairs of strains between two
infections along with corresponding relatedness estimates and optional
inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdEstM(
  pair,
  coi,
  afreq,
  Mmax = 6,
  pval = FALSE,
  confreg = FALSE,
  llik = FALSE,
  rnull = 0,
  alpha = 0.05,
  equalr = FALSE,
  freqlog = FALSE,
  nrs = c(1000, 100, 32, 16, 12, 10),
  revals = NULL,
  tol0 = 1e-09,
  logrs = NULL,
  nevals = NULL,
  nloc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ibdEstM_+3A_pair">pair</code></td>
<td>
<p>a list of length two containing data for a pair of samples.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_coi">coi</code></td>
<td>
<p>a vector containing complexity of infection for each sample.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_afreq">afreq</code></td>
<td>
<p>a list of allele frequencies. Each element of the list
corresponds to a locus.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_mmax">Mmax</code></td>
<td>
<p>a maximum number of related pairs of strains to evaluate over.
If greater than <code>min(coi)</code>, will be set to <code>min(coi)</code>.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_pval">pval</code>, <code id="ibdEstM_+3A_confreg">confreg</code>, <code id="ibdEstM_+3A_llik">llik</code></td>
<td>
<p>logical values specifying if p-value, confidence
region, and log-likelihood for a range of <code class="reqn">r</code> values should be
returned.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_rnull">rnull</code></td>
<td>
<p>a null value of relatedness parameter for hypothesis testing
(needed if <code>pval = TRUE</code>).</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_alpha">alpha</code></td>
<td>
<p>significance level for a 1 -
&alpha; confidence region.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_equalr">equalr</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the same level of relatedness
is assumed for M pairs of strains
(r<sub>1</sub> = ... =
r<sub>M</sub>).</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_freqlog">freqlog</code></td>
<td>
<p>a logical value indicating if <code>afreq</code> is on the log
scale.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_nrs">nrs</code></td>
<td>
<p>an integer vector where <code>i</code>'th element correspons to
M = i and indicates precision of the
estimate (resolution of a grid of parameter values). Ignored if non-null
<code>revals</code> is provided.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_revals">revals</code></td>
<td>
<p>a list where <code>i</code>'th element corresponds to
M = i and is a matrix representing a grid
of parameter values (a matrix where each column represents a single
(r<sub>1</sub>, ..., r<sub>M</sub>) combination).</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_tol0">tol0</code></td>
<td>
<p>a tolerance value for an estimate to be considered zero.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_logrs">logrs</code></td>
<td>
<p>a list where <code>i</code>'th element corresponds to
M = i and is a list as returned by
<code><a href="#topic+logReval">logReval</a></code>.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_nevals">nevals</code></td>
<td>
<p>a vector where <code>i</code>'th element corresponds to
M = i and provides the number of
relatedness values/combinations to evaluate over.</p>
</td></tr>
<tr><td><code id="ibdEstM_+3A_nloc">nloc</code></td>
<td>
<p>the number of loci.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list if multiple output logical values are <code>TRUE</code> - or a
vector if only <code>rhat = TRUE</code>. The output includes:
</p>

<ul>
<li><p> a relatedness estimate (numeric vector of length corresponding to the
estimated number of related pairs);
</p>
</li>
<li><p> a p-value if <code>pval = TRUE</code>;
</p>
</li>
<li><p> parameter values from the grid in <code>revals</code> that are within the
confidence region if <code>confreg = TRUE</code>;
</p>
</li>
<li><p> log-likelihood values for the parameter grid in <code>revals</code> if
<code>llik = TRUE</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ibdPair">ibdPair</a></code> for estimates of relatedness between two
samples and <code><a href="#topic+ibdDat">ibdDat</a></code> for pairwise relatedness estimates within
a dataset or between two datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coi   &lt;- getCOI(dsmp, lrank = 2)           # estimate COI
afreq &lt;- calcAfreq(dsmp, coi, tol = 1e-5)  # estimate allele frequencies

# two samples
ipair &lt;- c(21, 17)
# for higher COI: c(33, 5): COI = 5-6; c(37, 20): 4-3, c(41, 50): 5-4

Mmax  &lt;- min(coi[ipair])
# choose resolution of the grid for different M
nrs   &lt;- c(1e3, 1e2, 32, 16, 12, 10)[1:Mmax]
revals &lt;- mapply(generateReval, 1:Mmax, nr = nrs)

(res1 &lt;- ibdEstM(dsmp[ipair], coi[ipair], afreq, Mmax = Mmax, equalr = FALSE,
                 reval = revals))
(res2 &lt;- ibdEstM(dsmp[ipair], coi[ipair], afreq, Mmax = Mmax, equalr = TRUE))
# number of related pairs of strains (M')
sum(res1 &gt; 0)
sum(res2 &gt; 0)  # can be 0's

</code></pre>

<hr>
<h2 id='ibdPair'>Relatedness Between Two Samples</h2><span id='topic+ibdPair'></span>

<h3>Description</h3>

<p>Provides estimates of relatedness between a pair of samples
along with an optional support curve and inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdPair(
  pair,
  coi,
  afreq,
  M,
  rhat = TRUE,
  pval = FALSE,
  confreg = FALSE,
  llik = FALSE,
  maxllik = FALSE,
  rnull = 0,
  alpha = 0.05,
  equalr = FALSE,
  mnewton = NULL,
  freqlog = FALSE,
  nr = 1000,
  reval = NULL,
  tol = NULL,
  logr = NULL,
  neval = NULL,
  inull = NULL,
  nloc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ibdPair_+3A_pair">pair</code></td>
<td>
<p>a list of length two containing data for a pair of samples.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_coi">coi</code></td>
<td>
<p>a vector containing complexity of infection for each sample.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_afreq">afreq</code></td>
<td>
<p>a list of allele frequencies. Each element of the list
corresponds to a locus.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_m">M</code></td>
<td>
<p>the number of related pairs of strains.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_rhat">rhat</code>, <code id="ibdPair_+3A_pval">pval</code>, <code id="ibdPair_+3A_confreg">confreg</code>, <code id="ibdPair_+3A_llik">llik</code>, <code id="ibdPair_+3A_maxllik">maxllik</code></td>
<td>
<p>logical values specifying if
relatedness estimate, p-value, confidence region, log-likelihood for a
range of <code class="reqn">r</code> values, and maximum log-likelihood should be returned.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_rnull">rnull</code></td>
<td>
<p>a null value of relatedness parameter for hypothesis testing
(needed if <code>pval = TRUE</code>).</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_alpha">alpha</code></td>
<td>
<p>significance level for a 1 -
&alpha; confidence region.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_equalr">equalr</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the same level of relatedness
is assumed for M pairs of strains
(r<sub>1</sub> = ... =
r<sub>M</sub>).</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_mnewton">mnewton</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, Newton's method, adapted for
a bounded parameter space, will be used to find MLE. Ignored (set to
<code>FALSE</code>) if <code>M &gt; 1</code>, <code>confreg = TRUE</code>, or <code>llik =
  TRUE</code>.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_freqlog">freqlog</code></td>
<td>
<p>a logical value indicating if <code>afreq</code> is on the log
scale.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_nr">nr</code></td>
<td>
<p>an integer specifying precision of the estimate: resolution of
a grid of parameter values ([0, 1]
divided into <code>nr</code> equal intervals), over which the likelihood will be
calculated. Ignored if non-null <code>reval</code> is provided.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_reval">reval</code></td>
<td>
<p>a matrix representing a grid of
(r<sub>1</sub>, ..., r<sub>M</sub>) combinations, over which the likelihood will be calculated. Each
column is a single combination.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_tol">tol</code></td>
<td>
<p>tolerance for calculating an estimate if <code>mnewton = TRUE</code>.
Set to <code>1/nr</code> if not provided.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_logr">logr</code></td>
<td>
<p>a list as returned by <code>logReval</code> with logs of <code>reval</code>
and other quantities.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_neval">neval</code></td>
<td>
<p>the number of relatedness values/combinations to evaluate over.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_inull">inull</code></td>
<td>
<p>an index of the value/column of <code>reval</code> that is closest to
<code>rnull</code>.</p>
</td></tr>
<tr><td><code id="ibdPair_+3A_nloc">nloc</code></td>
<td>
<p>the number of loci.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Handling of irregular cases:
</p>

<ul>
<li><p> Allele with population frequency of 0 is present: locus is skipped
(does not contribute any information).
</p>
</li>
<li><p> Number of unique alleles at a locus is greater than COI: COI will be
increased for that locus only.
</p>
</li></ul>



<h3>Value</h3>

<p>A named list if multiple output logical values are <code>TRUE</code> - or a
vector if only <code>rhat = TRUE</code> or <code>llik = TRUE</code>. Depending on
these logical values, the following quantities are included:
</p>

<ul>
<li><p> If <code>rhat = TRUE</code>, a relatedness estimate (a vector of length 1 if
<code>equalr = TRUE</code> or of length M if <code>equalr = FALSE</code>);
</p>
</li>
<li><p> If <code>pval = TRUE</code>, a p-value;
</p>
</li>
<li><p> If <code>confreg = TRUE</code>, relatedness parameter values from the grid
<code>reval</code> that are within 1 - &alpha; confidence region;
</p>
</li>
<li><p> If <code>llik = TRUE</code>, log-likelihood values for relatedness parameter
grid (provided in <code>reval</code> or determined by <code>nr</code>);
</p>
</li>
<li><p> If <code>maxllik = TRUE</code>, maximum log-likelihood.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ibdEstM">ibdEstM</a></code> for estimating the number of related pairs of
strains and <code><a href="#topic+ibdDat">ibdDat</a></code> for processing multi-sample data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coi   &lt;- getCOI(dsmp, lrank = 2)
afreq &lt;- calcAfreq(dsmp, coi, tol = 1e-5)

# two samples
ipair &lt;- c(21, 17)
pair &lt;- dsmp[ipair]
coip &lt;-  coi[ipair]
M    &lt;- 2

res1 &lt;- ibdPair(pair, coip, afreq, M = M, confreg = TRUE, alpha = 0.05,
                equalr = FALSE, reval = revals[[M]])
res2 &lt;- ibdPair(pair, coip, afreq, M = M, llik = TRUE,
                equalr = TRUE, reval = revals[[1]])
res1$rhat
rep(res2$rhat, M)

# plot confidence region
creg &lt;- cbind(res1$confreg, res1$confreg[2:1, ])
plot(creg[1, ], creg[2, ], xlim = c(0, 1), ylim = c(0, 1), pch = 15,
     cex = 0.6, col = "cadetblue3", xlab = expression(hat(r)[1]),
     ylab = expression(hat(r)[2]))
points(res1$rhat, rev(res1$rhat), pch = 16)

# plot log-likelihood
plot(revals[[1]], res2$llik, type = "l", xlab = "r", ylab = "log-likelihood")

ipair &lt;- c(41, 50)
pair &lt;- dsmp[ipair]
coip &lt;-  coi[ipair]

# rtotal at different values of M with and without equality constraint
Mmax &lt;- min(coip)
for (M in 1:Mmax) {
  print(paste0("M = ", M))
  print(c(sum(ibdPair(pair, coip, afreq, M = M, pval = FALSE,
                      equalr = FALSE, reval = revals[[M]])),
          ibdPair(pair, coip, afreq, M = M, pval = FALSE, equalr = TRUE)*M))
  cat("\n")
}

# M = 1
# log-likelihood for specific r values
ibdPair(pair, coip, afreq, M = 1, rhat = FALSE, pval = FALSE, llik = TRUE,
        reval = c(0, 0.15, 0.38, 1))
# grid vs Newton's method
system.time(
  ibdPair(pair, coip, afreq, M = 1, mnewton = TRUE,  tol = 1e-5))
system.time(
  ibdPair(pair, coip, afreq, M = 1, mnewton = FALSE, nr  = 1e5))

</code></pre>

<hr>
<h2 id='logReval'>Logarithms of <code>reval</code></h2><span id='topic+logReval'></span>

<h3>Description</h3>

<p>Calculates logarithms of <code>reval</code> and <code>1 - reval</code>, as well as other
associated quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logReval(reval, M = NULL, neval = NULL, equalr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logReval_+3A_reval">reval</code></td>
<td>
<p>a matrix representing a grid of
(r<sub>1</sub>, ..., r<sub>M</sub>) combinations, over which the likelihood will be calculated. Each
column is a single combination.</p>
</td></tr>
<tr><td><code id="logReval_+3A_m">M</code></td>
<td>
<p>the number of related pairs of strains.</p>
</td></tr>
<tr><td><code id="logReval_+3A_neval">neval</code></td>
<td>
<p>the number of relatedness values/combinations to evaluate over.</p>
</td></tr>
<tr><td><code id="logReval_+3A_equalr">equalr</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the same level of relatedness
is assumed for M pairs of strains
(r<sub>1</sub> = ... =
r<sub>M</sub>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>equalr = TRUE</code> relatedness estimation, <code>reval</code> should
be a <code>1 x neval</code> matrix.
</p>


<h3>Value</h3>

<p>A list of length 5 that contains <code>log(reval)</code>, <code>log(1 -
  reval)</code>, the number of <code>reval = 1</code> for each column, the number of
<code>0 &lt; reval &lt; 1</code> for each column, and <code>sum(log(1 - reval[reval &lt;
  1]))</code> for each column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reval &lt;- generateReval(M = 2, nr = 1e2)
logr  &lt;- logReval(reval, M = 2, equalr = FALSE)

reval &lt;- generateReval(M = 1, nr = 1e3)
logr3  &lt;- logReval(reval, M = 3, equalr = TRUE)
logr1  &lt;- logReval(reval, M = 1)
all(logr3$sum1r == logr1$sum1r*3)

</code></pre>

<hr>
<h2 id='matchAfreq'>Match Samples and Allele Frequencies</h2><span id='topic+matchAfreq'></span>

<h3>Description</h3>

<p>Checks if the list containing sample data is conformable to provided
population allele frequencies and reformats it if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchAfreq(dsmp, afreq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matchAfreq_+3A_dsmp">dsmp</code></td>
<td>
<p>a list with each element corresponding to one sample.</p>
</td></tr>
<tr><td><code id="matchAfreq_+3A_afreq">afreq</code></td>
<td>
<p>a list of allele frequencies. Each element of the list
corresponds to a locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reorders loci and alleles in <code>dsmp</code> to match those
in <code>afreq</code> and inserts alleles into <code>dsmp</code> if they are present in
<code>afreq</code> and not in <code>dsmp</code>; doesn't handle cases when alleles are
present in <code>dsmp</code> but not in <code>afreq</code>. Allele names are required
for this procedure.
</p>


<h3>Value</h3>

<p>A list of the same length as <code>dsmp</code>, with each element matching
the lengths and the names of <code>afreq</code> and its elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readDat">readDat</a></code> and <code><a href="#topic+readAfreq">readAfreq</a></code> for reading in and
reformating data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>afile  &lt;- system.file("extdata", "MozAfreq.csv", package = "dcifer")
afreq2 &lt;- readAfreq(afile, lvar = "locus", avar = "allele", fvar = "freq")
dsmp2  &lt;- matchAfreq(dsmp, afreq2)

</code></pre>

<hr>
<h2 id='plotColorbar'>Colorbar</h2><span id='topic+plotColorbar'></span>

<h3>Description</h3>

<p>Creates a colorbar for a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotColorbar(
  rlim = c(0, 1),
  by = 0.1,
  at = NULL,
  horiz = FALSE,
  col = grDevices::hcl.colors(301, "YlGnBu", rev = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotColorbar_+3A_rlim">rlim</code></td>
<td>
<p>the range of values to be represented by colors.</p>
</td></tr>
<tr><td><code id="plotColorbar_+3A_by">by</code></td>
<td>
<p>increment size for tickmark locations. Ignored if <code>at</code> is provided.</p>
</td></tr>
<tr><td><code id="plotColorbar_+3A_at">at</code></td>
<td>
<p>a vector of tickmark locations.</p>
</td></tr>
<tr><td><code id="plotColorbar_+3A_horiz">horiz</code></td>
<td>
<p>a logical value specifying if the colorbar should be drawn horizontally.</p>
</td></tr>
<tr><td><code id="plotColorbar_+3A_col">col</code></td>
<td>
<p>the colors for the colorbar.</p>
</td></tr>
<tr><td><code id="plotColorbar_+3A_...">...</code></td>
<td>
<p>other graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The colorbar will fill the whole plotting region, which needs to be
specified outside of this function to control proportions and location of
the colorbar (see examples). To match the colors in the main plot,
<code>rlim</code> values should be the same for <code>plotRel</code> and
<code>plotColorbar</code>; if <code>rlim = NULL</code> or <code>rlim = NA</code> in
<code>plotRel</code>, provide the actual range of relatedness estimates for
<code>plotColorbar</code> (see examples).
</p>


<h3>Value</h3>

<p><code>NULL</code>; called for plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotRel">plotRel</a></code> for plotting relatedness estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parstart &lt;- par(no.readonly = TRUE)   # save starting graphical parameters

# colorbar on the side of the main plot
layout(matrix(1:2, 1), width = c(7, 1))
par(mar = c(2, 0, 2, 0) + 0.1)
# make symmetric matrix
dmat &lt;- dres[, , "estimate"]
dmat[upper.tri(dmat)] &lt;- t(dmat)[upper.tri(t(dmat))]
isig &lt;- which(dres[, , "p_value"] &lt;= 0.05, arr.ind = TRUE)
plotRel(dmat, draw_diag = TRUE, isig = rbind(isig, isig[, 2:1]))
abline(v = 26, h = 26, col = "gray45", lty = 5)
par(mar = c(2, 1, 2, 2) + 0.1)
plotColorbar()

# shorter colorbar, tick mark locations provided
par(mar = c(2, 0, 2, 0) + 0.1)
plotRel(dmat, draw_diag = TRUE, isig = rbind(isig, isig[, 2:1]))
par(mar = c(5, 0.5, 5, 2.5) + 0.1)
plotColorbar(at = c(0.0625, 0.125, 0.25, 0.5, 0.78))
par(parstart)

# triangular matrix, inset horizontal colorbar
par(mar = c(1, 1, 1, 1))
plotRel(dres, rlim = NULL, draw_diag = TRUE, border_diag = 1, alpha = 0.05)
par(fig = c(0.3, 1.0, 0.73, 0.83), new = TRUE)
rlim &lt;- range(dres[, , 1], na.rm = TRUE)
plotColorbar(rlim = rlim, at = c(0.2, 0.4, 0.6, 0.8), horiz = TRUE)
par(parstart)

</code></pre>

<hr>
<h2 id='plotRel'>Plot Relatedness Estimates</h2><span id='topic+plotRel'></span>

<h3>Description</h3>

<p>Represents a matrix of pairwise relatedness estimates with colors
corresponding to the levels of relatedness. Optionally, also outlines results
of a hypothesis testing. The plot follows a matrix layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRel(
  r,
  rlim = c(0, 1),
  isig = NULL,
  alpha = NULL,
  col = grDevices::hcl.colors(101, "YlGnBu", rev = TRUE),
  draw_diag = FALSE,
  col_diag = "gray",
  border_diag = NA,
  lwd_diag = 0.5,
  border_sig = "orangered2",
  lwd_sig = 1.5,
  xlab = "",
  ylab = "",
  add = FALSE,
  idlab = FALSE,
  side_id = c(1, 2),
  col_id = 1,
  cex_id = 0.5,
  srt_id = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotRel_+3A_r">r</code></td>
<td>
<p>a matrix or a 3-dimensional array as returned by
<code><a href="#topic+ibdDat">ibdDat</a></code>.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_rlim">rlim</code></td>
<td>
<p>the range of values for colors. If <code>NULL</code> or <code>NA</code>, will
be calculated from <code>r</code>.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_isig">isig</code></td>
<td>
<p>a matrix with two columns providing indices of relatedness matrix
entries to be outlined (&quot;significant&quot; sample pairs). Takes precedence over
<code>alpha</code>.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_alpha">alpha</code></td>
<td>
<p>significance level for hypothesis testing; determines
relatedness matrix entries to be outlined. Ignored if <code>isig</code> is not
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_col">col</code></td>
<td>
<p>the colors for the range of relatedness values.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_draw_diag">draw_diag</code></td>
<td>
<p>a logical value specifying if diagonal cells should be
distinguished from others by a separate color.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_col_diag">col_diag</code>, <code id="plotRel_+3A_border_diag">border_diag</code>, <code id="plotRel_+3A_lwd_diag">lwd_diag</code></td>
<td>
<p>the color for the fill, the color for
the border, and the line width for the border of diagonal entries. Ignored
if <code>draw_diag = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_border_sig">border_sig</code>, <code id="plotRel_+3A_lwd_sig">lwd_sig</code></td>
<td>
<p>the color and the line width for outlining entries
specified by <code>isig</code> or <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_xlab">xlab</code>, <code id="plotRel_+3A_ylab">ylab</code></td>
<td>
<p>axis labels.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_add">add</code></td>
<td>
<p>a logical value specifying if the graphics should be added to the
existing plot (useful for triangular matrices).</p>
</td></tr>
<tr><td><code id="plotRel_+3A_idlab">idlab</code></td>
<td>
<p>a logical value specifying if sample ID's should be displayed.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_side_id">side_id</code></td>
<td>
<p>an integer vector specifying plot sides for sample ID labels.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_col_id">col_id</code>, <code id="plotRel_+3A_cex_id">cex_id</code></td>
<td>
<p>numeric vectors for the color and the size of sample ID
labels.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_srt_id">srt_id</code></td>
<td>
<p>a vector of the same length as <code>side_id</code> specifying
rotation angles for sample ID labels. If <code>NULL</code>, the labels will be
perpendicular to the axes.</p>
</td></tr>
<tr><td><code id="plotRel_+3A_...">...</code></td>
<td>
<p>other graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>; called for plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotColorbar">plotColorbar</a></code> for a colorbar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parstart &lt;- par(no.readonly = TRUE)   # save starting graphical parameters

par(mar = c(0.5, 0.5, 0.5, 0.5))
plotRel(dres, alpha = 0.05, draw_diag = TRUE)

# draw log of p-values in the upper triangle
pmat &lt;- matrix(NA, nrow(dres), ncol(dres))
pmat[upper.tri(pmat)] &lt;- t(log(dres[, , "p_value"]))[upper.tri(pmat)]
pmat[pmat == -Inf] &lt;- min(pmat[is.finite(pmat)])
plotRel(pmat, rlim = NULL, draw_diag = TRUE, col = hcl.colors(101, "PuRd"),
        add = TRUE, col_diag = "slategray2", border_diag = 1)

# symmetric matrix, outline significant in upper triangle, display sample ID
par(mar = c(3, 3, 0.5, 0.5))
dmat &lt;- dres[, , "estimate"]
dmat[upper.tri(dmat)] &lt;- t(dmat)[upper.tri(t(dmat))]
isig &lt;- which(dres[, , "p_value"] &lt;= 0.05, arr.ind = TRUE)
col_id &lt;- rep(c("plum4", "lightblue4"), each = 26)
plotRel(dmat, isig = isig[, 2:1], draw_diag = TRUE, idlab = TRUE,
        col_id = col_id)
abline(v = 26, h = 26, col = "gray45", lty = 5)

# rotated sample ID labels on all sides
par(mar = c(3, 3, 3, 3))
plotRel(dmat, isig = rbind(isig, isig[, 2:1]), border_sig = "magenta2",
        draw_diag = TRUE, idlab = TRUE, side_id = 1:4, col_id = col_id,
        srt_id = c(-55, 25, 65, -35))
par(parstart)

</code></pre>

<hr>
<h2 id='probUxUy'>Likelihood for
U<sub>x</sub>,
U<sub>y</sub></h2><span id='topic+probUxUy'></span>

<h3>Description</h3>

<p>Calculates log-likelihood for a pair of samples at a single locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probUxUy(
  Ux,
  Uy,
  nx,
  ny,
  probs,
  M,
  logj,
  factj,
  equalr = FALSE,
  mnewton = TRUE,
  reval = NULL,
  logr = NULL,
  neval = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probUxUy_+3A_ux">Ux</code>, <code id="probUxUy_+3A_uy">Uy</code></td>
<td>
<p>sets of unique alleles for two samples at a given locus. Vectors
of indices corresponding to ordered probabilities in <code>probs</code>.</p>
</td></tr>
<tr><td><code id="probUxUy_+3A_nx">nx</code>, <code id="probUxUy_+3A_ny">ny</code></td>
<td>
<p>complexity of infection for two samples. Vectors of length 1.</p>
</td></tr>
<tr><td><code id="probUxUy_+3A_probs">probs</code></td>
<td>
<p>a vector of population allele frequencies (on a log scale) at a
given locus. It is not checked if frequencies on a regular scale sum to 1.</p>
</td></tr>
<tr><td><code id="probUxUy_+3A_m">M</code></td>
<td>
<p>the number of related pairs of strains.</p>
</td></tr>
<tr><td><code id="probUxUy_+3A_logj">logj</code>, <code id="probUxUy_+3A_factj">factj</code></td>
<td>
<p>numeric vectors containing precalculated logarithms and
factorials.</p>
</td></tr>
<tr><td><code id="probUxUy_+3A_equalr">equalr</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the same level of relatedness
is assumed for M pairs of strains
(r<sub>1</sub> = ... =
r<sub>M</sub>).</p>
</td></tr>
<tr><td><code id="probUxUy_+3A_mnewton">mnewton</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the coefficients for using
Newton's method will be calculated.</p>
</td></tr>
<tr><td><code id="probUxUy_+3A_reval">reval</code></td>
<td>
<p>a matrix representing a grid of
(r<sub>1</sub>, ..., r<sub>M</sub>) combinations, over which the likelihood will be calculated. Each
column is a single combination.</p>
</td></tr>
<tr><td><code id="probUxUy_+3A_logr">logr</code></td>
<td>
<p>a list of length 5 as returned by <code><a href="#topic+logReval">logReval</a></code>.</p>
</td></tr>
<tr><td><code id="probUxUy_+3A_neval">neval</code></td>
<td>
<p>the number of relatedness values/combinations to evaluate over.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> If <code>mnewton = TRUE</code>, a vector of length 2 containing
coefficients for fast likelihood calculation;
</p>
</li>
<li><p> If <code>mnewton = FALSE</code>, a vector of length <code>neval</code> containing
log-likelihoods for a range of parameter values.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Ux &lt;- c(1, 3, 7)                       # detected alleles at locus t
Uy &lt;- c(2, 7)
coi &lt;- c(5, 6)
aft &lt;- runif(7)                        # allele frequencies for locus t
aft &lt;- log(aft/sum(aft))

logj  &lt;- log(1:max(coi))
factj &lt;- lgamma(0:max(coi) + 1)

# M = 2, equalr = FALSE
M &lt;- 2
reval &lt;- generateReval(M, nr = 1e2)
logr  &lt;- logReval(reval, M = M)
llikt &lt;- probUxUy(Ux, Uy, coi[1], coi[2], aft, M, logj, factj,
                  equalr = FALSE, logr = logr, neval = ncol(reval))
length(llikt)

# M = 2, equalr = TRUE
reval &lt;- matrix(seq(0, 1, 0.001), 1)
logr  &lt;- logReval(reval, M = M, equalr = TRUE)
llikt &lt;- probUxUy(Ux, Uy, coi[1], coi[2], aft, M, logj, factj,
                  equalr = TRUE, logr = logr, neval = ncol(reval))

# M = 1, mnewton = FALSE
M &lt;- 1
reval &lt;- matrix(seq(0, 1, 0.001), 1)
logr  &lt;- logReval(reval, M = M)
llikt &lt;- probUxUy(Ux, Uy, coi[1], coi[2], aft, M, logj, factj,
                  mnewton = FALSE, reval = reval, logr = logr,
                  neval = ncol(reval))

# M = 1, mnewton = TRUE
probUxUy(Ux, Uy, coi[1], coi[2], aft, M, logj, factj, mnewton = TRUE)

</code></pre>

<hr>
<h2 id='revals'>Parameter grid</h2><span id='topic+revals'></span>

<h3>Description</h3>

<p>Precalculated parameter grids for a range of values of M (from 1 to 5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revals
</code></pre>


<h3>Format</h3>

<p>A list of length 5, where each element corresponds to a single value
of M and is a matrix with M rows. Each column of a matrix is a
r<sub>1</sub> = ... =
r<sub>M</sub>) combination.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
