<!DOCTYPE html><html><head><title>Help for package accelerometry</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {accelerometry}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accelerometry'><p>Functions for Processing Accelerometer Data</p></a></li>
<li><a href='#artifacts'><p>Accelerometer Artifact Correction</p></a></li>
<li><a href='#blockaves'><p>Block Averages</p></a></li>
<li><a href='#blocksums'><p>Block Sums</p></a></li>
<li><a href='#bouts'><p>Physical Activity Bout Detection</p></a></li>
<li><a href='#cut_counts'><p>Cut Count Values into Intensity Ranges</p></a></li>
<li><a href='#intensities'><p>Physical Activity Intensities</p></a></li>
<li><a href='#inverse_rle2'><p>Inverse Run Length Encoding (Alternate Implementation)</p></a></li>
<li><a href='#movingaves'><p>Moving Averages</p></a></li>
<li><a href='#personvars'><p>Calculating Daily Averages for Physical Activity Variables</p></a></li>
<li><a href='#process_tri'><p>Process Triaxial Minute-to-Minute Accelerometer Data</p></a></li>
<li><a href='#process_uni'><p>Process Uniaxial Minute-to-Minute Accelerometer Data</p></a></li>
<li><a href='#rle2'><p>Run Length Encoding (Alternate Implementation)</p></a></li>
<li><a href='#sedbreaks'><p>Sedentary Breaks</p></a></li>
<li><a href='#tridata'><p>Triaxial Sample Data</p></a></li>
<li><a href='#unidata'><p>Uniaxial Sample Data</p></a></li>
<li><a href='#weartime'><p>Wear Time Classification</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Processing Accelerometer Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-08-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Dane R. Van Domelen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dane R. Van Domelen &lt;vandomed@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions that perform operations on time-series accelerometer data, such as identify non-wear time, flag minutes that are part of an activity bout, and find the maximum 10-minute average count value. The functions are generally very flexible, allowing for a variety of algorithms to be implemented. Most of the functions are written in C++ for efficiency.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.15), dvmisc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, pander</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-24 02:11:39 UTC; Dane</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-24 09:14:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='accelerometry'>Functions for Processing Accelerometer Data</h2><span id='topic+accelerometry'></span><span id='topic+accelerometry-package'></span>

<h3>Description</h3>

<p>A collection of functions that perform operations on time-series 
accelerometer data, such as identify non-wear time, flag minutes that are 
part of an activity bout, and find the maximum 10-minute average count value. 
The functions are generally very flexible, allowing for a variety of 
algorithms to be implemented. Most of the functions are written in C++ for 
efficiency.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> accelerometry </td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.1.2 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-08-23 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See 
<a href="https://cran.r-project.org/package=accelerometry">CRAN documentation</a> 
for full list of functions.
</p>


<h3>Author(s)</h3>

<p>Dane R. Van Domelen <br /> <a href="mailto:vandomed@gmail.com">vandomed@gmail.com</a>
</p>


<h3>References</h3>

<p>Centers for Disease Control and Prevention (CDC). National Center for Health 
Statistics (NCHS). National Health and Nutrition Examination Survey Data. 
Hyattsville, MD: US Department of Health and Human Services, Centers for 
Disease Control and Prevention, 2003-6. Available at: 
<a href="https://wwwn.cdc.gov/nchs/nhanes/Default.aspx">https://wwwn.cdc.gov/nchs/nhanes/Default.aspx</a>. Accessed Aug. 19, 2018.
</p>
<p>Eddelbuettel, D. and Francois, R. (2011) Rcpp: Seamless R and C++ 
Integration. Journal of Statistical Software, 40(8), 1-18. 
<a href="http://www.jstatsoft.org/v40/i08/">http://www.jstatsoft.org/v40/i08/</a>.
</p>
<p>Eddelbuettel, D. (2013) Seamless R and C++ Integration with Rcpp. Springer, 
New York. ISBN 978-1-4614-6867-7.
</p>
<p>Eddelbuettel, D. and Balamuta, J.J. (2017). Extending R with C++: A Brief 
Introduction to Rcpp. PeerJ Preprints 5:e3188v1. 
<a href="https://doi.org/10.7287/peerj.preprints.3188v1">https://doi.org/10.7287/peerj.preprints.3188v1</a>.
</p>
<p>National Cancer Institute. Risk factor monitoring and methods: SAS programs 
for analyzing NHANES 2003-2004 accelerometer data. Available at: 
<a href="http://riskfactor.cancer.gov/tools/nhanes_pam">http://riskfactor.cancer.gov/tools/nhanes_pam</a>. Accessed Aug. 19, 2018.
</p>
<p>Van Domelen, D.R., Pittard, W.S. and Harris, T.B. (2018) 
nhanesaccel: Process accelerometer data from NHANES 2003-2006. R package 
version 3.1.1. <a href="https://github.com/vandomed/accelerometry">https://github.com/vandomed/accelerometry</a>. 
</p>
<p>Acknowledgment: This material is based upon work supported by the National 
Science Foundation Graduate Research Fellowship under Grant No. DGE-0940903.
</p>

<hr>
<h2 id='artifacts'>Accelerometer Artifact Correction</h2><span id='topic+artifacts'></span>

<h3>Description</h3>

<p>Corrects abnormally high count values in accelerometer data by replacing 
such values with the average of neighboring count values. Returns integer 
vector despite the average calculation often producing a decimal; this 
follows the convention used in the NCI's SAS programs 
(<a href="http://riskfactor.cancer.gov/tools/nhanes_pam">http://riskfactor.cancer.gov/tools/nhanes_pam</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artifacts(counts, thresh, counts_classify = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artifacts_+3A_counts">counts</code></td>
<td>
<p>Integer vector with accelerometer count values.</p>
</td></tr>
<tr><td><code id="artifacts_+3A_thresh">thresh</code></td>
<td>
<p>Integer value specifying the smallest count value that should 
be considered an artifact.</p>
</td></tr>
<tr><td><code id="artifacts_+3A_counts_classify">counts_classify</code></td>
<td>
<p>Integer vector with accelerometer count values to 
base artifact classification on, but not to adjust. Mainly included for 
triaxial data, where you might want to define artifacts based on 
vertical-axis counts but then actually adjust the triaxial sum or vector 
magnitude counts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector equivalent to <code>counts</code> except where artifacts 
were adjusted.
</p>


<h3>References</h3>

<p>National Cancer Institute. Risk factor monitoring and methods: SAS programs 
for analyzing NHANES 2003-2004 accelerometer data. Available at: 
<a href="http://riskfactor.cancer.gov/tools/nhanes_pam">http://riskfactor.cancer.gov/tools/nhanes_pam</a>. Accessed Aug. 19, 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load accelerometer data for first 5 participants in NHANES 2003-2004
data(unidata)

# Get data from ID number 21007
counts.part3 &lt;- unidata[unidata[, "seqn"] == 21007, "paxinten"]

# Replace counts &gt; 10,000 with average of neighboring values
counts.part3.corrected &lt;- artifacts(counts = counts.part3, thresh = 10000)

</code></pre>

<hr>
<h2 id='blockaves'>Block Averages</h2><span id='topic+blockaves'></span>

<h3>Description</h3>

<p>Calculates block averages (i.e. moving averages but for non-overlapping 
intervals) or maximum block average. For optimal speed, use 
<code>integer = TRUE</code> if <code>x</code> is an integer vector and 
<code>integer = FALSE</code> otherwise. If <code>length(x)</code> is not an exact 
multiple of <code>window</code>, the last partial segment is dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockaves(x, window, integer = FALSE, max = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockaves_+3A_x">x</code></td>
<td>
<p>Integer or numeric vector.</p>
</td></tr>
<tr><td><code id="blockaves_+3A_window">window</code></td>
<td>
<p>Integer value specifying window length.</p>
</td></tr>
<tr><td><code id="blockaves_+3A_integer">integer</code></td>
<td>
<p>Logical value for whether <code>x</code> is an integer vector.</p>
</td></tr>
<tr><td><code id="blockaves_+3A_max">max</code></td>
<td>
<p>Logical value for whether to return maximum moving average (as 
opposed to vector of moving averages).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value or vector depending on <code>max</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load accelerometer data for first 5 participants in NHANES 2003-2004
data(unidata)

# Get data from ID number 21005, Saturday only
counts.sat &lt;- unidata[unidata[, "seqn"] == 21005 &amp; unidata[, "paxday"] == 7, 
                      "paxinten"]
                      
# Calculate and plot hourly count averages
hourly.averages &lt;- blockaves(x = counts.sat, window = 60, integer = TRUE)
plot(hourly.averages)


</code></pre>

<hr>
<h2 id='blocksums'>Block Sums</h2><span id='topic+blocksums'></span>

<h3>Description</h3>

<p>Calculates block sums (i.e. moving sums but for non-overlapping intervals) or 
maximum block sum. For optimal speed, use <code>integer = TRUE</code> if <code>x</code> 
is an integer vector and <code>integer = FALSE</code> otherwise. If 
<code>length(x)</code> is not an exact multiple of <code>window</code>, the last partial 
segment is dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocksums(x, window, integer = FALSE, max = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blocksums_+3A_x">x</code></td>
<td>
<p>Integer or numeric vector.</p>
</td></tr>
<tr><td><code id="blocksums_+3A_window">window</code></td>
<td>
<p>Integer value specifying window length.</p>
</td></tr>
<tr><td><code id="blocksums_+3A_integer">integer</code></td>
<td>
<p>Logical value for whether <code>x</code> is an integer vector.</p>
</td></tr>
<tr><td><code id="blocksums_+3A_max">max</code></td>
<td>
<p>Logical value for whether to return maximum moving average (as 
opposed to vector of moving averages).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value or vector depending on <code>max</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load accelerometer data for first 5 participants in NHANES 2003-2004
data(unidata)

# Get data from ID number 21005, Saturday only
counts.sat &lt;- unidata[unidata[, "seqn"] == 21005 &amp; unidata[, "paxday"] == 7, 
                      "paxinten"]
                      
# Calculate and plot hourly count sums
hourly.sums &lt;- blocksums(x = counts.sat, window = 60, integer = TRUE)
plot(hourly.sums)


</code></pre>

<hr>
<h2 id='bouts'>Physical Activity Bout Detection</h2><span id='topic+bouts'></span>

<h3>Description</h3>

<p>Identify bouts of physical activity based on a vector of accelerometer count 
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bouts(counts, weartime = NULL, bout_length = 10L, thresh_lower = 0L,
  thresh_upper = 100000L, tol = 0L, tol_lower = 0L, tol_upper = 100000L,
  nci = FALSE, days_distinct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bouts_+3A_counts">counts</code></td>
<td>
<p>Integer vector with accelerometer count values.</p>
</td></tr>
<tr><td><code id="bouts_+3A_weartime">weartime</code></td>
<td>
<p>Integer vector with 1's for wear time minutes and 0's for 
non-wear time minutes.</p>
</td></tr>
<tr><td><code id="bouts_+3A_bout_length">bout_length</code></td>
<td>
<p>Integer value specifying minimum length of an activity 
bout.</p>
</td></tr>
<tr><td><code id="bouts_+3A_thresh_lower">thresh_lower</code></td>
<td>
<p>Integer value specifying lower bound for count values to 
be included for the intensity level.</p>
</td></tr>
<tr><td><code id="bouts_+3A_thresh_upper">thresh_upper</code></td>
<td>
<p>Integer value specifying upper bound for count values to 
be included for the intensity level.</p>
</td></tr>
<tr><td><code id="bouts_+3A_tol">tol</code></td>
<td>
<p>Integer value specifying number of minutes with count values 
outside of [<code>thresh_lower</code>, <code>thresh_upper</code>] to allow during an 
activity bout.</p>
</td></tr>
<tr><td><code id="bouts_+3A_tol_lower">tol_lower</code></td>
<td>
<p>Integer value specifying lower cut-off for count values 
outside of intensity range during an activity bout.</p>
</td></tr>
<tr><td><code id="bouts_+3A_tol_upper">tol_upper</code></td>
<td>
<p>Integer value specifying upper cut-off for count values 
outside of intensity range during an activity bout.</p>
</td></tr>
<tr><td><code id="bouts_+3A_nci">nci</code></td>
<td>
<p>Logical value for whether to use algorithm from NCI's SAS 
programs. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="bouts_+3A_days_distinct">days_distinct</code></td>
<td>
<p>Logical value for whether to treat each day of data as 
distinct, i.e. identify non-wear time and activity bouts for day 1, then day 
2, etc. If <code>FALSE</code>, algorithm is applied to full monitoring period 
continuously. If protocol has participants remove accelerometer for sleep, 
strongly recommend setting to <code>FALSE</code> to capture non-wear periods that 
start between 11 pm and midnight. Function assumes that first 1440 data 
points are day 1, next 1440 are day 2, and so on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nci = FALSE</code>, the algorithm uses a moving window to go through 
every possible interval of length <code>bout_length</code> in <code>counts</code>. Any 
interval in which all counts are &gt;= <code>tol_lower</code> and &lt;= 
<code>tol_upper</code>, and no more than <code>tol</code> counts are less than 
<code>thresh_lower</code> or greater than <code>thresh_upper</code>, is classified as an 
activity bout.
</p>
<p>If <code>nci = TRUE</code>, activity bouts are classified according to the 
algorithm used in the NCI's SAS programs. Briefly, this algorithm defines an 
activity bout as an interval of length <code>bout_length</code> that starts with a 
count value in <code>[thresh_lower, thresh_upper]</code> and has no more than 
<code>tol</code> counts outside of that range. If these criteria are met, the bout 
continues until there are <code>(tol + 1)</code> consecutive minutes outside of 
<code>[thresh_lower, thresh_upper]</code>. The parameters <code>tol_lower</code> and 
<code>tol_upper</code> are not used.
</p>
<p>If the user allows for a tolerance (e.g. <code>tol = 2</code>) and does not use 
the NCI algorithm (i.e. <code>nci = FALSE</code>), specifying a non-zero value for 
<code>tol_lower</code> is highly recommended. Otherwise the algorithm will tend to 
classify minutes immediately before and after an activity bout as being part 
of the bout.
</p>
<p>Specifying <code>thresh_lower</code> while using an arbitrarily large value for 
<code>thresh_upper</code> is generally recommended. Specifying both of these 
parameters can be overly restrictive in that the algorithm may miss bouts of 
activity in which counts are consistently high, but not exclusively in one 
intensity range.
</p>


<h3>Value</h3>

<p>Integer vector with 1's for minutes that are part of an activity 
bout and 0's for minutes that are not.
</p>


<h3>References</h3>

<p>National Cancer Institute. Risk factor monitoring and methods: SAS programs 
for analyzing NHANES 2003-2004 accelerometer data. Available at: 
<a href="http://riskfactor.cancer.gov/tools/nhanes_pam">http://riskfactor.cancer.gov/tools/nhanes_pam</a>. Accessed Aug. 19, 2018.
</p>
<p>Acknowledgment: This material is based upon work supported by the National 
Science Foundation Graduate Research Fellowship under Grant No. DGE-0940903.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load accelerometer data for first 5 participants in NHANES 2003-2004
data(unidata)

# Get data from ID number 21005
counts.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "paxinten"]

# Identify periods of valid wear time
wear.part1 &lt;- weartime(counts = counts.part1)

# Identify moderate-to-vigorous activity bouts
mvpa.bouts &lt;- bouts(counts = counts.part1, weartime = wear.part1, 
                    thresh_lower = 2020)


</code></pre>

<hr>
<h2 id='cut_counts'>Cut Count Values into Intensity Ranges</h2><span id='topic+cut_counts'></span>

<h3>Description</h3>

<p>Given a vector of accelerometer count values, classifies each count value 
into intensity level 1, 2, 3, 4, or 5 (typically representing sedentary, 
light, lifestyle, moderate, and vigorous).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_counts(counts, int_cuts = as.integer(c(100, 760, 2020, 5999)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_counts_+3A_counts">counts</code></td>
<td>
<p>Integer vector with accelerometer count values.</p>
</td></tr>
<tr><td><code id="cut_counts_+3A_int_cuts">int_cuts</code></td>
<td>
<p>Numeric vector with four cutpoints from which five intensity 
ranges are derived. For example, <code>int_cuts = c(100, 760, 2020, 5999)</code> 
creates: 0-99 = intensity 1; 100-759 = intensity level 2; 760-2019 = 
intensity 3; 2020-5998 = intensity 4; &gt;= 5999 = intensity 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load accelerometer data for first 5 participants in NHANES 2003-2004
data(unidata)

# Get data from ID number 21005
counts.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "paxinten"]

# Cut into 5 intensity levels and plot
intensity.part1 &lt;- cut_counts(counts = counts.part1)
plot(intensity.part1)


</code></pre>

<hr>
<h2 id='intensities'>Physical Activity Intensities</h2><span id='topic+intensities'></span>

<h3>Description</h3>

<p>Given a vector of accelerometer count values, calculates time spent in 5 
mutually exclusive user-defined intensity levels (typically representing
sedentary, light, lifestyle, moderate, and vigorous) as well as the total 
counts accumulated in various intensities. Non-wear time should be removed 
from <code>counts</code> before calling <code>intensities</code> to avoid overestimating 
sedentary time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intensities(counts, int_cuts = as.integer(c(100, 760, 2020, 5999)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensities_+3A_counts">counts</code></td>
<td>
<p>Integer vector with accelerometer count values.</p>
</td></tr>
<tr><td><code id="intensities_+3A_int_cuts">int_cuts</code></td>
<td>
<p>Numeric vector with four cutpoints from which five intensity 
ranges are derived. For example, <code>int_cuts = c(100, 760, 2020, 5999)</code> 
creates: 0-99 = intensity 1; 100-759 = intensity level 2; 760-2019 = 
intensity 3; 2020-5998 = intensity 4; &gt;= 5999 = intensity 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector of length 16 in which the first eight values are 
minutes in intensities 1, 2, 3, 4, 5, 2-3, 4-5, and 2-5, and the next eight 
are counts accumulated during time spent in each of those intensities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load accelerometer data for first 5 participants in NHANES 2003-2004
data(unidata)

# Get data from ID number 21005
counts.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "paxinten"]

# Create vector of counts during valid wear time only
counts.part1.wear &lt;- counts.part1[weartime(counts = counts.part1) == 1]

# Calculate physical activity intensity variables
intensity.variables &lt;- intensities(counts = counts.part1.wear)


</code></pre>

<hr>
<h2 id='inverse_rle2'>Inverse Run Length Encoding (Alternate Implementation)</h2><span id='topic+inverse_rle2'></span>

<h3>Description</h3>

<p>Re-constructs vector compressed by <code><a href="#topic+rle2">rle2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_rle2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_rle2_+3A_x">x</code></td>
<td>
<p>Object returned by <code><a href="#topic+rle2">rle2</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer or numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummie vector x
x &lt;- c(0, 0, 0, -1, -1, 10, 10, 4, 6, 6)

# Summarize x using rle2
x.summarized &lt;- rle2(x)

# Reconstruct x
x.reconstructed &lt;- inverse_rle2(x.summarized)


</code></pre>

<hr>
<h2 id='movingaves'>Moving Averages</h2><span id='topic+movingaves'></span>

<h3>Description</h3>

<p>Calculates moving averages or maximum moving average. For optimal speed, use 
<code>integer = TRUE</code> if <code>x</code> is an integer vector and 
<code>integer = FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movingaves(x, window, integer = FALSE, max = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movingaves_+3A_x">x</code></td>
<td>
<p>Integer or numeric vector.</p>
</td></tr>
<tr><td><code id="movingaves_+3A_window">window</code></td>
<td>
<p>Integer value specifying window length.</p>
</td></tr>
<tr><td><code id="movingaves_+3A_integer">integer</code></td>
<td>
<p>Logical value for whether <code>x</code> is an integer vector.</p>
</td></tr>
<tr><td><code id="movingaves_+3A_max">max</code></td>
<td>
<p>Logical value for whether to return maximum moving average (as 
opposed to vector of moving averages).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value or vector depending on <code>max</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load accelerometer data for first 5 participants in NHANES 2003-2004
data(unidata)

# Get data from ID number 21005
id.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "seqn"]
counts.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "paxinten"]

# Create vector of all 10-minute moving averages
all.movingaves &lt;- movingaves(x = counts.part1, window = 10, integer = TRUE)

# Calculate maximum 10-minute moving average
max.movingave &lt;- movingaves(x = counts.part1, window = 10, integer = TRUE, 
                            max = TRUE)


</code></pre>

<hr>
<h2 id='personvars'>Calculating Daily Averages for Physical Activity Variables</h2><span id='topic+personvars'></span>

<h3>Description</h3>

<p>Not intended for direct use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>personvars(dayvars, rows, days, wk, we)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="personvars_+3A_dayvars">dayvars</code></td>
<td>
<p>Numeric matrix with daily physical activity variables.</p>
</td></tr>
<tr><td><code id="personvars_+3A_rows">rows</code></td>
<td>
<p>Numeric value specifying number of rows in the matrix to be 
returned.</p>
</td></tr>
<tr><td><code id="personvars_+3A_days">days</code></td>
<td>
<p>Integer value specifying minimum number of valid days a 
participant must have to be included.</p>
</td></tr>
<tr><td><code id="personvars_+3A_wk">wk</code></td>
<td>
<p>Integer value specifying minimum number of valid weekdays a 
participant must have to be included.</p>
</td></tr>
<tr><td><code id="personvars_+3A_we">we</code></td>
<td>
<p>Integer value specifying minimum number of valid weekend days a 
participant must have to be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix.
</p>

<hr>
<h2 id='process_tri'>Process Triaxial Minute-to-Minute Accelerometer Data</h2><span id='topic+process_tri'></span>

<h3>Description</h3>

<p>Calculates a variety of physical activity variables based on triaxial 
minute-to-minute accelerometer count values for individual participants. 
Assumes first 1440 minutes are day 1, next 1440 are day 2, and so on. If 
final day has less than 1440 minutes, it is excluded. A data dictionary for 
the variables created is available here: 
<a href="https://github.com/vandomed/accelerometry/blob/master/process_tri_dictionary.csv">https://github.com/vandomed/accelerometry/blob/master/process_tri_dictionary.csv</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_tri(counts, steps = NULL, nci_methods = FALSE, start_day = 1,
  start_date = NULL, id = NULL, brevity = 1, hourly_var = "cpm",
  hourly_wearmin = 0, hourly_normalize = FALSE, valid_days = 1,
  valid_wk_days = 0, valid_we_days = 0, int_axis = "vert",
  int_cuts = c(100, 760, 2020, 5999), cpm_nci = FALSE,
  days_distinct = FALSE, nonwear_axis = "vert", nonwear_window = 60,
  nonwear_tol = 0, nonwear_tol_upper = 99, nonwear_nci = FALSE,
  weartime_minimum = 600, weartime_maximum = 1440,
  active_bout_length = 10, active_bout_tol = 0, mvpa_bout_tol_lower = 0,
  vig_bout_tol_lower = 0, active_bout_nci = FALSE, sed_bout_tol = 0,
  sed_bout_tol_maximum = int_cuts[2] - 1, artifact_axis = "vert",
  artifact_thresh = 25000, artifact_action = 1, weekday_weekend = FALSE,
  return_form = "daily")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_tri_+3A_counts">counts</code></td>
<td>
<p>Integer matrix with three columns of count values, e.g. 
vertical-axis counts, anteroposterior (AP)-axis counts, and 
mediolateral (ML)-axis counts.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_steps">steps</code></td>
<td>
<p>Integer vector with steps.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_nci_methods">nci_methods</code></td>
<td>
<p>Logical value for whether to set all arguments so as to 
replicate the data processing methods used in the NCI's SAS programs. More 
specifically: 
</p>
<p><code>valid_days = 4</code>
</p>
<p><code>valid_wk_days = 0</code>
</p>
<p><code>valid_we_days = 0</code>
</p>
<p><code>int_axis = "vert"</code>
</p>
<p><code>int_cuts = c(100, 760, 2020, 5999)</code>
</p>
<p><code>cpm_nci = TRUE</code>
</p>
<p><code>days_distinct = TRUE</code>
</p>
<p><code>nonwear_axis = "vert"</code>
</p>
<p><code>nonwear_window = 60</code>
</p>
<p><code>nonwear_tol = 2</code>
</p>
<p><code>nonwear_tolupper = 100</code>
</p>
<p><code>nonwear_nci = TRUE</code>
</p>
<p><code>weartime_minimum = 600</code>
</p>
<p><code>weartime_maximum = 1440</code>
</p>
<p><code>active_bout_length = 10</code>
</p>
<p><code>active_bout_tol = 2</code>
</p>
<p><code>mvpa_bout_tol_lower = 0</code>
</p>
<p><code>vig_bout_tol_lower = 0</code>
</p>
<p><code>active_bout_nci = TRUE</code>
</p>
<p><code>sed_bout_tol = 0</code>
</p>
<p><code>sed_bout_tol_maximum = 759</code>
</p>
<p><code>artifact_thresh = 32767</code>
</p>
<p><code>artifact_action = 3</code>
</p>
<p>If <code>TRUE</code>, you can still specify non-default values for <code>brevity</code> 
and <code>weekday_weekend</code>.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_start_day">start_day</code></td>
<td>
<p>Integer value specifying day of week for first day of 
monitoring, with 1 = Sunday, ..., 7 = Satuday.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_start_date">start_date</code></td>
<td>
<p>Date for first day of monitoring, which function can use to 
figure out <code>start_day</code>.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_id">id</code></td>
<td>
<p>Numeric value specifying ID number of participant.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_brevity">brevity</code></td>
<td>
<p>Integer value controlling the number of physical activity 
variables generated. Choices are 1 for basic indicators of physical activity 
volume, 2 for addditional indicators of activity intensities, activity bouts, 
sedentary behavior, and peak activity, and 3 for additional hourly count 
averages.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_hourly_var">hourly_var</code></td>
<td>
<p>Character string specifying what hourly activity variable 
to record, if <code>brevity = 3</code>. Choices are &quot;counts_vert&quot;, &quot;counts_ap&quot;, 
&quot;counts_ml&quot;, &quot;counts_sum&quot;, &quot;counts_vm&quot;, &quot;cpm_vert&quot;, &quot;cpm_ap&quot;, &quot;cpm_ml&quot;, 
&quot;sed_min&quot;, &quot;sed_bouted_10min&quot;, and &quot;sed_breaks&quot;.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_hourly_wearmin">hourly_wearmin</code></td>
<td>
<p>Integer value specifying minimum number of wear time 
minutes needed during a given hour to record a value for the hourly activity 
variable.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_hourly_normalize">hourly_normalize</code></td>
<td>
<p>Logical value for whether to normalize hourly 
activity by number of wear time minutes.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_valid_days">valid_days</code></td>
<td>
<p>Integer value specifying minimum number of valid days to 
be considered valid for analysis.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_valid_wk_days">valid_wk_days</code></td>
<td>
<p>Integer value specifying minimum number of valid 
weekdays to be considered valid for analysis.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_valid_we_days">valid_we_days</code></td>
<td>
<p>Integer value specifying minimum number of valid weekend 
days to be considered valid for analysis.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_int_axis">int_axis</code></td>
<td>
<p>Character string specifying which axis should be used to 
classify intensities. Choices are &quot;vert&quot;, &quot;ap&quot;, &quot;ml&quot;, &quot;sum&quot; (for triaxial 
sum), and &quot;vm (for triaxial vector magnitude).</p>
</td></tr>
<tr><td><code id="process_tri_+3A_int_cuts">int_cuts</code></td>
<td>
<p>Numeric vector with four cutpoints from which five intensity 
ranges are derived. For example, <code>int_cuts = c(100, 760, 2020, 5999)</code> 
creates: 0-99 = intensity 1; 100-759 = intensity level 2; 760-2019 = 
intensity 3; 2020-5998 = intensity 4; &gt;= 5999 = intensity 5. Intensities 1-5 
are typically viewed as sedentary, light, lifestyle, moderate, and vigorous.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_cpm_nci">cpm_nci</code></td>
<td>
<p>Logical value for whether to calculate average counts per 
minute by dividing average daily counts by average daily wear time, as 
opposed to taking the average of each day's counts per minute value. Strongly 
recommend leave as <code>FALSE</code> unless you wish to replicate the NCI's SAS 
programs.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_days_distinct">days_distinct</code></td>
<td>
<p>Logical value for whether to treat each day of data as 
distinct, as opposed to analyzing the entire monitoring period as one 
continuous segment.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_nonwear_axis">nonwear_axis</code></td>
<td>
<p>Character string specifying which axis should be used to 
classify non-wear time. Choices are &quot;vert&quot;, &quot;ap&quot;, &quot;ml&quot;, &quot;sum&quot; (for triaxial 
sum), and &quot;vm&quot; (for triaxial vector magnitude).</p>
</td></tr>
<tr><td><code id="process_tri_+3A_nonwear_window">nonwear_window</code></td>
<td>
<p>Integer value specifying minimum length of a non-wear 
period.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_nonwear_tol">nonwear_tol</code></td>
<td>
<p>Integer value specifying tolerance for non-wear algorithm, 
i.e. number of minutes with non-zero counts allowed during a non-wear 
interval.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_nonwear_tol_upper">nonwear_tol_upper</code></td>
<td>
<p>Integer value specifying maximum count value for a 
minute with non-zero counts during a non-wear interval.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_nonwear_nci">nonwear_nci</code></td>
<td>
<p>Logical value for whether to use non-wear algorithm from 
NCI's SAS programs.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_weartime_minimum">weartime_minimum</code></td>
<td>
<p>Integer value specifying minimum number of wear time 
minutes for a day to be considered valid.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_weartime_maximum">weartime_maximum</code></td>
<td>
<p>Integer value specifying maximum number of wear time 
minutes for a day to be considered valid. The default is 1440, but you may 
want to use a lower value (e.g. 1200) if participants were instructed to 
remove devices for sleeping, but often did not.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_active_bout_length">active_bout_length</code></td>
<td>
<p>Integer value specifying minimum length of an 
active bout.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_active_bout_tol">active_bout_tol</code></td>
<td>
<p>Integer value specifying number of minutes with counts 
outside the required range to allow during an active bout. If non-zero and 
<code>active_bout_nci = FALSE</code>, specifying non-zero values for 
<code>mvpa_bout_tol_lower</code> and <code>vig_bout_tol_lower</code> is highly 
recommended. Otherwise minutes immediately before and after an active bout 
will tend to be classified as part of the bout.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_mvpa_bout_tol_lower">mvpa_bout_tol_lower</code></td>
<td>
<p>Integer value specifying lower cut-off for count 
values outside of required intensity range for an MVPA bout.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_vig_bout_tol_lower">vig_bout_tol_lower</code></td>
<td>
<p>Integer value specifying lower cut-off for count 
values outside of required intensity range for a vigorous bout.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_active_bout_nci">active_bout_nci</code></td>
<td>
<p>Logical value for whether to use algorithm from the 
NCI's SAS programs for classifying active bouts.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_sed_bout_tol">sed_bout_tol</code></td>
<td>
<p>Integer value specifying number of minutes with counts 
outside sedentary range to allow during a sedentary bout.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_sed_bout_tol_maximum">sed_bout_tol_maximum</code></td>
<td>
<p>Integer value specifying upper cut-off for count 
values outside sedentary range during a sedentary bout.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_artifact_axis">artifact_axis</code></td>
<td>
<p>Character string specifying which axis should be used to 
identify artifacts (impossibly high count values). Choices are &quot;vert&quot;, &quot;ap&quot;, 
&quot;ml&quot;, &quot;sum&quot; (for triaxial sum), and &quot;vm&quot; (for triaxial vector magnitude).</p>
</td></tr>
<tr><td><code id="process_tri_+3A_artifact_thresh">artifact_thresh</code></td>
<td>
<p>Integer value specifying the smallest count value that 
should be considered an artifact.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_artifact_action">artifact_action</code></td>
<td>
<p>Integer value controlling method of correcting 
artifacts. Choices are 1 to exclude days with one or more artifacts, 2 to 
lump artifacts into non-wear time, 3 to replace artifacts with the average of 
neighboring count values, and 4 to take no action.</p>
</td></tr>
<tr><td><code id="process_tri_+3A_weekday_weekend">weekday_weekend</code></td>
<td>
<p>Logical value for whether to calculate averages for 
weekdays and weekend days separately (in addition to all valid days).</p>
</td></tr>
<tr><td><code id="process_tri_+3A_return_form">return_form</code></td>
<td>
<p>Character string controlling how variables are returned. 
Choices are &quot;daily&quot; for per-day summaries, &quot;averages&quot; for averages across 
all valid days, and &quot;both&quot; for a list containing both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix or list of two numeric matrices, depending on 
<code>return_form</code>.
</p>


<h3>References</h3>

<p>National Cancer Institute. Risk factor monitoring and methods: SAS programs 
for analyzing NHANES 2003-2004 accelerometer data. Available at: 
<a href="http://riskfactor.cancer.gov/tools/nhanes_pam">http://riskfactor.cancer.gov/tools/nhanes_pam</a>. Accessed Aug. 19, 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note that the 'tridata' dataset contains 7 days of fake triaxial 
# accelerometer data

# Process data using default parameters and request per-day variables
accel.days &lt;- process_tri(
  counts = tridata, 
  return_form = "daily"
)

# Repeat, but request averages across all valid days
accel.averages &lt;- process_tri(
  counts = tridata,
  return_form = "averages"
)

# Create per-day summary again, but with many more variables
accel.days2 &lt;- process_tri(
  counts = tridata, 
  brevity = 2,
  return_form = "daily"
)
names(accel.days2)


</code></pre>

<hr>
<h2 id='process_uni'>Process Uniaxial Minute-to-Minute Accelerometer Data</h2><span id='topic+process_uni'></span>

<h3>Description</h3>

<p>Calculates a variety of physical activity variables based on uniaxial 
minute-to-minute accelerometer count values for individual participants. 
Assumes first 1440 minutes are day 1, next 1440 are day 2, and so on. If 
final day has less than 1440 minutes, it is excluded. A data dictionary for 
the variables created is available here: 
<a href="https://github.com/vandomed/accelerometry/blob/master/process_uni_dictionary.csv">https://github.com/vandomed/accelerometry/blob/master/process_uni_dictionary.csv</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_uni(counts, steps = NULL, nci_methods = FALSE, start_day = 1,
  start_date = NULL, id = NULL, brevity = 1, hourly_var = "cpm",
  hourly_wearmin = 0, hourly_normalize = FALSE, valid_days = 1,
  valid_wk_days = 0, valid_we_days = 0, int_cuts = c(100, 760, 2020,
  5999), cpm_nci = FALSE, days_distinct = FALSE, nonwear_window = 60,
  nonwear_tol = 0, nonwear_tol_upper = 99, nonwear_nci = FALSE,
  weartime_minimum = 600, weartime_maximum = 1440,
  active_bout_length = 10, active_bout_tol = 0, mvpa_bout_tol_lower = 0,
  vig_bout_tol_lower = 0, active_bout_nci = FALSE, sed_bout_tol = 0,
  sed_bout_tol_maximum = int_cuts[2] - 1, artifact_thresh = 25000,
  artifact_action = 1, weekday_weekend = FALSE, return_form = "averages")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_uni_+3A_counts">counts</code></td>
<td>
<p>Integer vector with accelerometer count values.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_steps">steps</code></td>
<td>
<p>Integer vector with steps.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_nci_methods">nci_methods</code></td>
<td>
<p>Logical value for whether to set all arguments so as to 
replicate the data processing methods used in the NCI's SAS programs. More 
specifically: 
</p>
<p><code>valid_days = 4</code>
</p>
<p><code>valid_wk_days = 0</code>
</p>
<p><code>valid_we_days = 0</code>
</p>
<p><code>int_cuts = c(100, 760, 2020, 5999)</code>
</p>
<p><code>cpm_nci = TRUE</code>
</p>
<p><code>days_distinct = TRUE</code>
</p>
<p><code>nonwear_window = 60</code>
</p>
<p><code>nonwear_tol = 2</code>
</p>
<p><code>nonwear_tolupper = 100</code>
</p>
<p><code>nonwear_nci = TRUE</code>
</p>
<p><code>weartime_minimum = 600</code>
</p>
<p><code>weartime_maximum = 1440</code>
</p>
<p><code>active_bout_length = 10</code>
</p>
<p><code>active_bout_tol = 2</code>
</p>
<p><code>mvpa_bout_tol_lower = 0</code>
</p>
<p><code>vig_bout_tol_lower = 0</code>
</p>
<p><code>active_bout_nci = TRUE</code>
</p>
<p><code>sed_bout_tol = 0</code>
</p>
<p><code>sed_bout_tol_maximum = 759</code>
</p>
<p><code>artifact_thresh = 32767</code>
</p>
<p><code>artifact_action = 3</code>
</p>
<p>If <code>TRUE</code>, you can still specify non-default values for <code>brevity</code> 
and <code>weekday_weekend</code>.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_start_day">start_day</code></td>
<td>
<p>Integer value specifying day of week for first day of 
monitoring, with 1 = Sunday, ..., 7 = Satuday.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_start_date">start_date</code></td>
<td>
<p>Date for first day of monitoring, which function can use to 
figure out <code>start_day</code>.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_id">id</code></td>
<td>
<p>Numeric value specifying ID number of participant.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_brevity">brevity</code></td>
<td>
<p>Integer value controlling the number of physical activity 
variables generated. Choices are 1 for basic indicators of physical activity 
volume, 2 for addditional indicators of activity intensities, activity bouts, 
sedentary behavior, and peak activity, and 3 for additional hourly count 
averages.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_hourly_var">hourly_var</code></td>
<td>
<p>Character string specifying what hourly activity variable 
to record, if <code>brevity = 3</code>. Choices are &quot;counts&quot;, &quot;cpm&quot;, &quot;sed_min&quot;, 
&quot;sed_bouted_10min&quot;, and &quot;sed_breaks&quot;.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_hourly_wearmin">hourly_wearmin</code></td>
<td>
<p>Integer value specifying minimum number of wear time 
minutes needed during a given hour to record a value for the hourly activity 
variable.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_hourly_normalize">hourly_normalize</code></td>
<td>
<p>Logical value for whether to normalize hourly 
activity by number of wear time minutes.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_valid_days">valid_days</code></td>
<td>
<p>Integer value specifying minimum number of valid days to 
be considered valid for analysis.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_valid_wk_days">valid_wk_days</code></td>
<td>
<p>Integer value specifying minimum number of valid 
weekdays to be considered valid for analysis.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_valid_we_days">valid_we_days</code></td>
<td>
<p>Integer value specifying minimum number of valid weekend 
days to be considered valid for analysis.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_int_cuts">int_cuts</code></td>
<td>
<p>Numeric vector with four cutpoints from which five intensity 
ranges are derived. For example, <code>int_cuts = c(100, 760, 2020, 5999)</code> 
creates: 0-99 = intensity 1; 100-759 = intensity level 2; 760-2019 = 
intensity 3; 2020-5998 = intensity 4; &gt;= 5999 = intensity 5. Intensities 1-5 
are typically viewed as sedentary, light, lifestyle, moderate, and vigorous.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_cpm_nci">cpm_nci</code></td>
<td>
<p>Logical value for whether to calculate average counts per 
minute by dividing average daily counts by average daily wear time, as 
opposed to taking the average of each day's counts per minute value. Strongly 
recommend leave as <code>FALSE</code> unless you wish to replicate the NCI's SAS 
programs.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_days_distinct">days_distinct</code></td>
<td>
<p>Logical value for whether to treat each day of data as 
distinct, as opposed to analyzing the entire monitoring period as one 
continuous segment.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_nonwear_window">nonwear_window</code></td>
<td>
<p>Integer value specifying minimum length of a non-wear 
period.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_nonwear_tol">nonwear_tol</code></td>
<td>
<p>Integer value specifying tolerance for non-wear algorithm, 
i.e. number of minutes with non-zero counts allowed during a non-wear 
interval.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_nonwear_tol_upper">nonwear_tol_upper</code></td>
<td>
<p>Integer value specifying maximum count value for a 
minute with non-zero counts during a non-wear interval.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_nonwear_nci">nonwear_nci</code></td>
<td>
<p>Logical value for whether to use non-wear algorithm from 
NCI's SAS programs.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_weartime_minimum">weartime_minimum</code></td>
<td>
<p>Integer value specifying minimum number of wear time 
minutes for a day to be considered valid.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_weartime_maximum">weartime_maximum</code></td>
<td>
<p>Integer value specifying maximum number of wear time 
minutes for a day to be considered valid. The default is 1440, but you may 
want to use a lower value (e.g. 1200) if participants were instructed to 
remove devices for sleeping, but often did not.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_active_bout_length">active_bout_length</code></td>
<td>
<p>Integer value specifying minimum length of an 
active bout.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_active_bout_tol">active_bout_tol</code></td>
<td>
<p>Integer value specifying number of minutes with counts 
outside the required range to allow during an active bout. If non-zero and 
<code>active_bout_nci = FALSE</code>, specifying non-zero values for 
<code>mvpa_bout_tol_lower</code> and <code>vig_bout_tol_lower</code> is highly 
recommended. Otherwise minutes immediately before and after an active bout 
will tend to be classified as part of the bout.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_mvpa_bout_tol_lower">mvpa_bout_tol_lower</code></td>
<td>
<p>Integer value specifying lower cut-off for count 
values outside of required intensity range for an MVPA bout.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_vig_bout_tol_lower">vig_bout_tol_lower</code></td>
<td>
<p>Integer value specifying lower cut-off for count 
values outside of required intensity range for a vigorous bout.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_active_bout_nci">active_bout_nci</code></td>
<td>
<p>Logical value for whether to use algorithm from the 
NCI's SAS programs for classifying active bouts.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_sed_bout_tol">sed_bout_tol</code></td>
<td>
<p>Integer value specifying number of minutes with counts 
outside sedentary range to allow during a sedentary bout.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_sed_bout_tol_maximum">sed_bout_tol_maximum</code></td>
<td>
<p>Integer value specifying upper cut-off for count 
values outside sedentary range during a sedentary bout.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_artifact_thresh">artifact_thresh</code></td>
<td>
<p>Integer value specifying the smallest count value that 
should be considered an artifact.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_artifact_action">artifact_action</code></td>
<td>
<p>Integer value controlling method of correcting 
artifacts. Choices are 1 to exclude days with one or more artifacts, 2 to 
lump artifacts into non-wear time, 3 to replace artifacts with the average of 
neighboring count values, and 4 to take no action.</p>
</td></tr>
<tr><td><code id="process_uni_+3A_weekday_weekend">weekday_weekend</code></td>
<td>
<p>Logical value for whether to calculate averages for 
weekdays and weekend days separately (in addition to all valid days).</p>
</td></tr>
<tr><td><code id="process_uni_+3A_return_form">return_form</code></td>
<td>
<p>Character string controlling how variables are returned. 
Choices are &quot;daily&quot; for per-day summaries, &quot;averages&quot; for averages across 
all valid days, and &quot;both&quot; for a list containing both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix or list of two numeric matrices, depending on 
<code>return_form</code>.
</p>


<h3>References</h3>

<p>National Cancer Institute. Risk factor monitoring and methods: SAS programs 
for analyzing NHANES 2003-2004 accelerometer data. Available at: 
<a href="http://riskfactor.cancer.gov/tools/nhanes_pam">http://riskfactor.cancer.gov/tools/nhanes_pam</a>. Accessed Aug. 19, 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note that the 'unidata' dataset contains accelerometer data for first 5 
# subjects in NHANES 2003-2004

# Get data from ID number 21005
id.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "seqn"]
counts.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "paxinten"]

# Process data from ID 21005 and request per-day variables
accel.days &lt;- process_uni(
  counts = counts.part1, 
  id = id.part1, 
  return_form = "daily"
)

# Repeat, but request averages across all valid days
accel.averages &lt;- process_uni(
  counts = counts.part1, 
  id = id.part1, 
  return_form = "averages"
)
                          
# Process data according to methods used in NCI's SAS programs
accel.nci1 &lt;- process_uni(
  counts = counts.part1, 
  id = id.part1, 
  brevity = 2, 
  valid_days = 4, 
  cpm_nci = TRUE, 
  days_distinct = TRUE, 
  nonwear_tol = 2, 
  nonwear_tol_upper = 100,
  nonwear_nci = TRUE, 
  weartime_maximum = 1440,
  active_bout_tol = 2, 
  active_bout_nci = TRUE, 
  artifact_thresh = 32767,
  artifact_action = 3, 
  return_form = "averages"
)
                          
# Repeat, but use nci_methods input for convenience
accel.nci2 &lt;- process_uni(
  counts = counts.part1, 
  id = id.part1, 
  nci_methods = TRUE, 
  brevity = 2, 
  return_form = "averages"
)
                          
# Results are identical
all.equal(accel.nci1, accel.nci2)


</code></pre>

<hr>
<h2 id='rle2'>Run Length Encoding (Alternate Implementation)</h2><span id='topic+rle2'></span>

<h3>Description</h3>

<p>Summarizes vector containing runs of repeated values. Very similar to 
<code><a href="base.html#topic+rle">rle</a></code>, but sometimes much faster, and with an option to 
return the start/end indices for each run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rle2(x, class = NULL, indices = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rle2_+3A_x">x</code></td>
<td>
<p>Vector (see <code>class</code>).</p>
</td></tr>
<tr><td><code id="rle2_+3A_class">class</code></td>
<td>
<p>Character string specifying class of <code>x</code>. If unspecified, 
function figures it out (at cost of slightly slower run time).</p>
</td></tr>
<tr><td><code id="rle2_+3A_indices">indices</code></td>
<td>
<p>Logical value for whether to record start/stop positions in 
addition to values and lengths for each run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer or numeric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummie vector x
x &lt;- c(0, 0, 0, -1, -1, 10, 10, 4, 6, 6)

# Summarize x using rle2
x.summarized &lt;- rle2(x)

# Repeat, but also record start/stop indices for each run
x.summarized &lt;- rle2(x = x, indices = TRUE)


</code></pre>

<hr>
<h2 id='sedbreaks'>Sedentary Breaks</h2><span id='topic+sedbreaks'></span>

<h3>Description</h3>

<p>Identifies sedentary breaks in accelerometer count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sedbreaks(counts, weartime = NULL, thresh = 100, flags = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sedbreaks_+3A_counts">counts</code></td>
<td>
<p>Integer vector with accelerometer count values.</p>
</td></tr>
<tr><td><code id="sedbreaks_+3A_weartime">weartime</code></td>
<td>
<p>Integer vector with 1's for wear time minutes and 0's for 
non-wear time minutes.</p>
</td></tr>
<tr><td><code id="sedbreaks_+3A_thresh">thresh</code></td>
<td>
<p>Integer value specifying minimum count value to consider a 
break from sedentary time.</p>
</td></tr>
<tr><td><code id="sedbreaks_+3A_flags">flags</code></td>
<td>
<p>Logical value for whether to return a vector of 1's and 0's 
flagging the sedentary breaks (as opposed to the total number of sedentary 
breaks).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer value or vector depending on <code>flags</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load accelerometer data for first 5 participants in NHANES 2003-2004
data(unidata)

# Get data from ID number 21005
id.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "seqn"]
counts.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "paxinten"]

# Identify periods of valid wear time
wear.part1 &lt;- weartime(counts = counts.part1)

# Count number of sedentary breaks (over full week)
n.sedbreaks &lt;- sedbreaks(counts = counts.part1, weartime = wear.part1)

# Flag sedentary breaks
sedbreaks.flagged &lt;- sedbreaks(counts = counts.part1, weartime = wear.part1, 
                               flags = TRUE)


</code></pre>

<hr>
<h2 id='tridata'>Triaxial Sample Data</h2><span id='topic+tridata'></span>

<h3>Description</h3>

<p>Toy dataset with triaxial minute-to-minute counts generated from a trivariate 
normal distribution. Does not closely resemble real accelerometer data.
</p>

<hr>
<h2 id='unidata'>Uniaxial Sample Data</h2><span id='topic+unidata'></span>

<h3>Description</h3>

<p>Accelerometer data for the first 5 participants in the National Health and 
Nutrition Examination Survey (NHANES) 2003-2004 dataset.
</p>


<h3>Source</h3>

<p><a href="https://wwwn.cdc.gov/nchs/nhanes/search/datapage.aspx?Component=Examination&amp;CycleBeginYear=2003">https://wwwn.cdc.gov/nchs/nhanes/search/datapage.aspx?Component=Examination&amp;CycleBeginYear=2003</a>
</p>

<hr>
<h2 id='weartime'>Wear Time Classification</h2><span id='topic+weartime'></span>

<h3>Description</h3>

<p>Classifies wear time vs. non-wear time based on a vector of accelerometer 
count values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weartime(counts, window = 60L, tol = 0L, tol_upper = 99L, nci = FALSE,
  days_distinct = FALSE, units_day = 1440L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weartime_+3A_counts">counts</code></td>
<td>
<p>Integer vector with accelerometer count values.</p>
</td></tr>
<tr><td><code id="weartime_+3A_window">window</code></td>
<td>
<p>Integer value specifying minimum length of a non-wear 
period.</p>
</td></tr>
<tr><td><code id="weartime_+3A_tol">tol</code></td>
<td>
<p>Integer value specifying tolerance for non-wear algorithm, i.e. 
number of seconds/minutes with non-zero counts allowed during a non-wear 
interval.</p>
</td></tr>
<tr><td><code id="weartime_+3A_tol_upper">tol_upper</code></td>
<td>
<p>Integer value specifying maximum count value for a 
second/minute with non-zero counts during a non-wear interval.</p>
</td></tr>
<tr><td><code id="weartime_+3A_nci">nci</code></td>
<td>
<p>Logical value for whether to use algorithm from NCI's SAS 
programs. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="weartime_+3A_days_distinct">days_distinct</code></td>
<td>
<p>Logical value for whether to treat each day of data as 
distinct, as opposed to analyzing the entire monitoring period as one 
continuous segment. For minute-to-minute counts, strongly recommend setting 
to <code>FALSE</code> to correctly classify time near midnight.</p>
</td></tr>
<tr><td><code id="weartime_+3A_units_day">units_day</code></td>
<td>
<p>Integer value specifying how many data point are in a day. 
Typically either 1440 or 86400 depending on whether count values are 
minute-to-minute or second-to-second.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nci = FALSE</code>, the algorithm uses a moving window to go through 
every possible interval of length <code>window</code> in <code>counts</code>. Any 
interval in which no more than <code>tol</code> counts are non-zero, and those 
are still &lt; <code>tol.upper</code>, is classified as non-wear time.
</p>
<p>If <code>nci = TRUE</code>, non-wear time is classified according to the algorithm 
used in the NCI's SAS programs. Briefly, this algorithm defines a non-wear 
period as an interval of length <code>window</code> that starts with a count value 
of 0, does not contain any periods with <code>(tol + 1)</code> consecutive 
non-zero count values, and does not contain any counts &gt; <code>tol.upper</code>. 
If these criteria are met, the non-wear period continues until there are 
<code>(tol + 1)</code> consecutive non-zero count values or a single count value &gt; 
<code>tol.upper</code>.
</p>


<h3>Value</h3>

<p>Integer vector with 1's for valid wear time and 0's for non-wear 
time.
</p>


<h3>References</h3>

<p>National Cancer Institute. Risk factor monitoring and methods: SAS programs 
for analyzing NHANES 2003-2004 accelerometer data. Available at: 
<a href="http://riskfactor.cancer.gov/tools/nhanes_pam">http://riskfactor.cancer.gov/tools/nhanes_pam</a>. Accessed Aug. 19, 2018.
</p>
<p>Acknowledgment: This material is based upon work supported by the National 
Science Foundation Graduate Research Fellowship under Grant No. DGE-0940903.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load accelerometer data for first 5 participants in NHANES 2003-2004
data(unidata)

# Get data from ID number 21005
counts.part1 &lt;- unidata[unidata[, "seqn"] == 21005, "paxinten"]

# Identify periods of valid wear time
weartime.flag &lt;- weartime(counts = counts.part1)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
