<!DOCTYPE html><html><head><title>Help for package smfsb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smfsb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abcRun'><p>Run a set of simulations initialised with parameters sampled from a given prior distribution, and compute statistics required for an ABC analaysis</p></a></li>
<li><a href='#abcSmc'><p>Run an ABC-SMC algorithm for infering the parameters of a forward model</p></a></li>
<li><a href='#as.timedData'><p>Convert a time series object to a timed data matrix</p></a></li>
<li><a href='#discretise'><p>Discretise output from a discrete event simulation algorithm</p></a></li>
<li><a href='#gillespie'><p>Simulate a sample path from a stochastic kinetic model described by a stochastic Petri net</p></a></li>
<li><a href='#gillespied'><p>Simulate a sample path from a stochastic kinetic model described by a stochastic Petri net</p></a></li>
<li><a href='#imdeath'><p>Simulate a sample path from the homogeneous immigration-death process</p></a></li>
<li><a href='#LVdata'><p>Example simulated time courses from a stochastic Lotka&ndash;Volterra model</p></a></li>
<li><a href='#mcmcSummary'><p>Summarise and plot tabular MCMC output</p></a></li>
<li><a href='#metrop'><p>Run a simple Metropolis sampler with standard normal target and uniform innovations</p></a></li>
<li><a href='#metropolisHastings'><p>Run a Metropolis-Hastings MCMC algorithm for the parameters of a</p>
Bayesian posterior distribution</a></li>
<li><a href='#mytable'><p>Simple example data frame</p></a></li>
<li><a href='#normgibbs'><p>A simple Gibbs sampler for Bayesian inference for the mean and precision of a normal random sample</p></a></li>
<li><a href='#pfMLLik'><p>Create a function for computing the log of an unbiased estimate of marginal likelihood of a time course data set</p></a></li>
<li><a href='#pfMLLik1'><p>Create a function for computing the log of an unbiased estimate of marginal likelihood of a time course data set</p></a></li>
<li><a href='#rcfmc'><p>Simulate a continuous time finite state space Markov chain</p></a></li>
<li><a href='#rdiff'><p>Simulate a sample path from a univariate diffusion process</p></a></li>
<li><a href='#rfmc'><p>Simulate a finite state space Markov chain</p></a></li>
<li><a href='#simpleEuler'><p>Simulate a sample path from an ODE model</p></a></li>
<li><a href='#simSample'><p>Simulate a many realisations of a model at a given fixed time in the future given an initial time and state, using a function (closure) for advancing the state of the model</p></a></li>
<li><a href='#simTimes'><p>Simulate a model at a specified set of times, using a function (closure) for advancing the state of the model</p></a></li>
<li><a href='#simTs'><p>Simulate a model on a regular grid of times, using a function (closure) for advancing the state of the model</p></a></li>
<li><a href='#simTs1D'><p>Simulate a model on a regular grid of times, using a function (closure) for advancing the state of the model</p></a></li>
<li><a href='#simTs2D'><p>Simulate a model on a regular grid of times, using a function (closure) for advancing the state of the model</p></a></li>
<li><a href='#smfsb-package'><p>Stochastic Modelling for Systems Biology</p></a></li>
<li><a href='#spnModels'><p>Example SPN models</p></a></li>
<li><a href='#StepCLE'><p>Create a function for advancing the state of an SPN by using a simple Euler-Maruyama integration method for the approximating CLE</p></a></li>
<li><a href='#StepCLE1D'><p>Create a function for advancing the state of an SPN by using a simple Euler-Maruyama discretisation of the CLE on a 1D regular grid</p></a></li>
<li><a href='#StepCLE2D'><p>Create a function for advancing the state of an SPN by using a simple Euler-Maruyama discretisation of the CLE on a 2D regular grid</p></a></li>
<li><a href='#StepEuler'><p>Create a function for advancing the state of an ODE model by using a simple Euler integration method</p></a></li>
<li><a href='#StepEulerSPN'><p>Create a function for advancing the state of an SPN by using a simple continuous deterministic Euler integration method</p></a></li>
<li><a href='#StepFRM'><p>Create a function for advancing the state of an SPN by using Gillespie's first reaction method</p></a></li>
<li><a href='#StepGillespie'><p>Create a function for advancing the state of an SPN by using the Gillespie algorithm</p></a></li>
<li><a href='#StepGillespie1D'><p>Create a function for advancing the state of an SPN by using the</p>
Gillespie algorithm on a 1D regular grid</a></li>
<li><a href='#StepGillespie2D'><p>Create a function for advancing the state of an SPN by using the</p>
Gillespie algorithm on a 2D regular grid</a></li>
<li><a href='#stepLVc'><p>A function for advancing the state of a Lotka-Volterra model by using the Gillespie algorithm</p></a></li>
<li><a href='#StepODE'><p>Create a function for advancing the state of an ODE model by using the deSolve package</p></a></li>
<li><a href='#StepPTS'><p>Create a function for advancing the state of an SPN by using a simple approximate Poisson time stepping method</p></a></li>
<li><a href='#StepSDE'><p>Create a function for advancing the state of an SDE model by using a simple Euler-Maruyama integration method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stochastic Modelling for Systems Biology</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Darren Wilkinson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Darren Wilkinson &lt;darrenjwilkinson@btinternet.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Code and data for modelling and simulation of stochastic kinetic biochemical network models. It contains the code and data associated with the second and third editions of the book Stochastic Modelling for Systems Biology, published by Chapman &amp; Hall/CRC Press.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.9.0), abind (&ge; 1.3), parallel (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>deSolve (&ge; 1.9)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-12 09:01:21 UTC; darren</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 13:00:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='abcRun'>Run a set of simulations initialised with parameters sampled from a given prior distribution, and compute statistics required for an ABC analaysis</h2><span id='topic+abcRun'></span>

<h3>Description</h3>

<p>Run a set of simulations initialised with parameters sampled from a given prior distribution, and compute statistics required for an ABC analaysis. Typically used to calculate &quot;distances&quot; of simulated synthetic data from observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcRun(n, rprior, rdist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abcRun_+3A_n">n</code></td>
<td>
<p>An integer representing the number of simulations to run.</p>
</td></tr>
<tr><td><code id="abcRun_+3A_rprior">rprior</code></td>
<td>
<p>A function without arguments generating a single parameter (vector) from prior distribution.</p>
</td></tr>
<tr><td><code id="abcRun_+3A_rdist">rdist</code></td>
<td>
<p>A function taking a parameter (vector) as argument and returning the required statistic of interest. This will typically be computed by first using the parameter to run a forward model, then computing required summary statistics, then computing a distance. See the example for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements 'param' and 'dist'. These will be returned as matrices or vectors depending on whether the parameters and distances are scalars or vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfMLLik">pfMLLik</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+abcSmc">abcSmc</a></code>,
<code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+stepLVc">stepLVc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LVdata)
rprior &lt;- function() { exp(c(runif(1, -3, 3),runif(1,-8,-2),runif(1,-4,2))) }
rmodel &lt;- function(th) { simTs(c(50,100), 0, 30, 2, stepLVc, th) }
sumStats &lt;- identity
ssd = sumStats(LVperfect)
distance &lt;- function(s) {
    diff = s - ssd
    sqrt(sum(diff*diff))
}
rdist &lt;- function(th) { distance(sumStats(rmodel(th))) }
out = abcRun(10000, rprior, rdist)
q=quantile(out$dist, c(0.01, 0.05, 0.1))
print(q)
accepted = out$param[out$dist &lt; q[1],]
print(summary(accepted))
print(summary(log(accepted)))

</code></pre>

<hr>
<h2 id='abcSmc'>Run an ABC-SMC algorithm for infering the parameters of a forward model</h2><span id='topic+abcSmc'></span>

<h3>Description</h3>

<p>Run an ABC-SMC algorithm for infering the parameters of a forward model. This sequential Monte Carlo algorithm often performs better than simple rejection-ABC in practice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcSmc(N, rprior, dprior, rdist, rperturb, dperturb, factor=10,
                   steps=15, verb=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abcSmc_+3A_n">N</code></td>
<td>
<p>An integer representing the number of simulations to pass on at each stage of the SMC algorithm. Note that the TOTAL number of forward simulations required by the algorithm will be (roughly) 'N*steps*factor'.</p>
</td></tr>
<tr><td><code id="abcSmc_+3A_rprior">rprior</code></td>
<td>
<p>A function without arguments generating a single parameter (vector) from prior distribution.</p>
</td></tr>
<tr><td><code id="abcSmc_+3A_dprior">dprior</code></td>
<td>
<p>A function with required argument a model parameter (such as generated by 'rprior') and optional parameter 'log' returing the (log) density of the parameter under the prior distribution.</p>
</td></tr>
<tr><td><code id="abcSmc_+3A_rdist">rdist</code></td>
<td>
<p>A function taking a parameter (vector) as argument and returning a scalar &quot;distance&quot; representing a measure of how good the chosen parameter is. This will typically be computed by first using the parameter to run a forward model, then computing required summary statistics, then computing a distance. See the example for details.</p>
</td></tr>
<tr><td><code id="abcSmc_+3A_rperturb">rperturb</code></td>
<td>
<p>A function which takes a parameter as its argument and returns a perturbed parameter from an appropriate kernel.</p>
</td></tr>
<tr><td><code id="abcSmc_+3A_dperturb">dperturb</code></td>
<td>
<p>A function which takes a pair of parameters as its first two arguments (new first and old second), and has an optional argument 'log' for whether to return the log of the density associated with this perturbation kernel.</p>
</td></tr>
<tr><td><code id="abcSmc_+3A_factor">factor</code></td>
<td>
<p>At each step of the algorithm, 'N*factor' proposals are generated and the best 'N' of these are weighted and passed on to the next stage. Note that the effective sample size of the parameters passed on to the next step may be (much) smaller than 'N', since some of the particles may be assigned small (or zero) weight.</p>
</td></tr>
<tr><td><code id="abcSmc_+3A_steps">steps</code></td>
<td>
<p>The number of steps of the ABC-SMC algorithm. Typically, somewhere between 5 and 100 steps seems to be used in practice.</p>
</td></tr>
<tr><td><code id="abcSmc_+3A_verb">verb</code></td>
<td>
<p>Boolean indicating whether some progress should be printed to the console (the number of steps remaining).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) with rows (or elements) representing samples from the approximate posterior distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfMLLik">pfMLLik</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+abcRun">abcRun</a></code>,
<code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+stepLVc">stepLVc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(LVdata)
rprior &lt;- function() { c(runif(1, -3, 3), runif(1, -8, -2), runif(1, -4, 2)) }
dprior &lt;- function(x, ...) { dunif(x[1], -3, 3, ...) + 
                dunif(x[2], -8, -2, ...) + dunif(x[3], -4, 2, ...) }
rmodel &lt;- function(th) { simTs(c(50,100), 0, 30, 2, stepLVc, exp(th)) }
rperturb &lt;- function(th){th + rnorm(3, 0, 0.5)}
dperturb &lt;- function(thNew, thOld, ...){sum(dnorm(thNew, thOld, 0.5, ...))}
sumStats &lt;- identity
ssd = sumStats(LVperfect)
distance &lt;- function(s) {
    diff = s - ssd
    sqrt(sum(diff*diff))
}
rdist &lt;- function(th) { distance(sumStats(rmodel(th))) }
out = abcSmc(5000, rprior, dprior, rdist, rperturb,
             dperturb, verb=TRUE, steps=6, factor=5)
print(summary(out))

</code></pre>

<hr>
<h2 id='as.timedData'>Convert a time series object to a timed data matrix</h2><span id='topic+as.timedData'></span>

<h3>Description</h3>

<p>This function converts a time series object to a timed data matrix,
similar to that produced by <code><a href="#topic+simTimes">simTimes</a></code>. The main purpose is
for passing data to the function <code><a href="#topic+pfMLLik">pfMLLik</a></code>, which expects
data encoded in this format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.timedData(timeseries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.timedData_+3A_timeseries">timeseries</code></td>
<td>
<p>An R timeseries object, such as produced by the functions <code><a href="stats.html#topic+ts">ts</a></code> or <code><a href="#topic+simTs">simTs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R matrix object with row names corresponding to observation times, similar to that produced by <code><a href="#topic+simTimes">simTimes</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simTs">simTs</a></code>, <code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="#topic+simTimes">simTimes</a></code>, <code><a href="#topic+pfMLLik">pfMLLik</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>truth=simTs(c(x1=50,x2=100),0,20,2,stepLVc)
simData=truth+rnorm(prod(dim(truth)),0,5)
timedData=as.timedData(simData)
print(timedData)
</code></pre>

<hr>
<h2 id='discretise'>Discretise output from a discrete event simulation algorithm</h2><span id='topic+discretise'></span>

<h3>Description</h3>

<p>This function discretise output from a discrete event simulation algorithm such as <code><a href="#topic+gillespie">gillespie</a></code> onto a regular time grid, and returns the results as an R <code><a href="stats.html#topic+ts">ts</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretise(out, dt=1, start=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretise_+3A_out">out</code></td>
<td>
<p>A list containing discrete event simulation output in the form of that produced by <code><a href="#topic+gillespie">gillespie</a></code>.</p>
</td></tr>
<tr><td><code id="discretise_+3A_dt">dt</code></td>
<td>
<p>The time step required for the output of the discretisation process. Defaults to one time unit.</p>
</td></tr>
<tr><td><code id="discretise_+3A_start">start</code></td>
<td>
<p>The start time for the output. Defaults to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R <code><a href="stats.html#topic+ts">ts</a></code> object containing the discretised output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simpleEuler">simpleEuler</a></code>, <code><a href="#topic+rdiff">rdiff</a></code>, <code><a href="#topic+gillespie">gillespie</a></code>, <code><a href="#topic+gillespied">gillespied</a></code>, <code><a href="stats.html#topic+ts">ts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load LV model
data(spnModels)
# simulate a realisation of the process and plot it
out = gillespie(LV,10000)
op=par(mfrow=c(2,2))
plot(stepfun(out$t,out$x[,1]),pch="")
plot(stepfun(out$t,out$x[,2]),pch="")
plot(out$x,type="l")

# use the "discretise" function to map it to an R "ts" object
plot(discretise(out,dt=0.01),plot.type="single",lty=c(1,2))
par(op)
</code></pre>

<hr>
<h2 id='gillespie'>Simulate a sample path from a stochastic kinetic model described by a stochastic Petri net</h2><span id='topic+gillespie'></span>

<h3>Description</h3>

<p>This function simulates a single realisation from a discrete stochastic
kinetic model described by a stochastic Petri net (SPN).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gillespie(N, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gillespie_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net (SPN). Should contain <code>N$M</code>, a vector representing
the initial marking of the net, <code>N$Pre</code>, a matrix representing
the LHS stoichiometries, <code>N$Post</code>, a matrix representing the
RHS stoichiometries, and <code>N$h</code>, a function representing the
rates of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the current state of
the system, and
second argument <code>t</code>, a scalar representing the current
simulation time (in the typical time-homogeneous case, <code>N$h</code>
will ignore this argument).
<code>N$h</code> may posses additional arguments, representing reaction rates, for example.</p>
</td></tr>
<tr><td><code id="gillespie_+3A_n">n</code></td>
<td>
<p>An integer representing the number of events to simulate, excluding the initial state, <code>N$M</code>.</p>
</td></tr>
<tr><td><code id="gillespie_+3A_...">...</code></td>
<td>
<p>Additional arguments (such as reactions rates) will be passed into the function <code>N$h</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with first component <code>t</code>, a vector of length <code>n</code> containing event times and second component <code>x</code>, a matrix with <code>n+1</code> rows containing the state of the system. The <code>i</code>th row of <code>x</code> contains the state of the system prior to the <code>i</code>th event.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simpleEuler">simpleEuler</a></code>, <code><a href="#topic+rdiff">rdiff</a></code>,
<code><a href="#topic+discretise">discretise</a></code>, <code><a href="#topic+gillespied">gillespied</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load the LV model
data(spnModels)
# simulate a realisation of the process and plot it
out = gillespie(LV,10000)
op = par(mfrow=c(2,2))
plot(stepfun(out$t,out$x[,1]),pch="")
plot(stepfun(out$t,out$x[,2]),pch="")
plot(out$x,type="l")

# use the "discretise" function to map it to an R "ts" object
plot(discretise(out,dt=0.01),plot.type="single",lty=c(1,2))
par(op)
</code></pre>

<hr>
<h2 id='gillespied'>Simulate a sample path from a stochastic kinetic model described by a stochastic Petri net</h2><span id='topic+gillespied'></span>

<h3>Description</h3>

<p>This function simulates a single realisation from a discrete stochastic kinetic model described by a stochastic Petri net and discretises the output onto a regular time grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gillespied(N, T=100, dt=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gillespied_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net (SPN). Should contain <code>N$M</code>, a vector representing
the initial marking of the net, <code>N$Pre</code>, a matrix representing
the LHS stoichiometries, <code>N$Post</code>, a matrix representing the
RHS stoichiometries, and <code>N$h</code>, a function representing the
rates of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the current state of
the system, and
second argument <code>t</code>, a scalar representing the current
simulation time (in the typical time-homogeneous case, <code>N$h</code>
will ignore this argument).
<code>N$h</code> may posses additional arguments, representing reaction rates, for example.
</p>
</td></tr>
<tr><td><code id="gillespied_+3A_t">T</code></td>
<td>
<p>The required length of simulation time. Defaults to 100 time units.</p>
</td></tr>
<tr><td><code id="gillespied_+3A_dt">dt</code></td>
<td>
<p>The grid size for the output. Note that this parameter simply determines the volume of output. It has no bearing on the correctness of the simulation algorithm. Defaults to one time unit.</p>
</td></tr>
<tr><td><code id="gillespied_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed into the function <code>N$h</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R <code><a href="stats.html#topic+ts">ts</a></code> object containing the simulated realisation of the process. </p>


<h3>See Also</h3>

<p><code><a href="#topic+simpleEuler">simpleEuler</a></code>, <code><a href="#topic+rdiff">rdiff</a></code>,
<code><a href="#topic+discretise">discretise</a></code>, <code><a href="#topic+gillespie">gillespie</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load LV model
data(spnModels)
# simulate and plot a realisation
plot(gillespied(LV,T=100,dt=0.01))
</code></pre>

<hr>
<h2 id='imdeath'>Simulate a sample path from the homogeneous immigration-death process</h2><span id='topic+imdeath'></span>

<h3>Description</h3>

<p>This function simulates a single realisation from a time-homogeneous immigration-death process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imdeath(n=20,x0=0,lambda=1,mu=0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imdeath_+3A_n">n</code></td>
<td>
<p>The number of states to be sampled from the process, not including the initial state, <code>x0</code></p>
</td></tr>
<tr><td><code id="imdeath_+3A_x0">x0</code></td>
<td>
<p>The initial state of the process, which defaults to zero.</p>
</td></tr>
<tr><td><code id="imdeath_+3A_lambda">lambda</code></td>
<td>
<p>The rate at which new individual immigrate into the population. Defaults to 1.</p>
</td></tr>
<tr><td><code id="imdeath_+3A_mu">mu</code></td>
<td>
<p>The rate at which individuals within the population die, independently of all other individuals. Defaults to 0.1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R <code><a href="stats.html#topic+stepfun">stepfun</a></code> object containing the sampled path of the process.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcfmc">rcfmc</a></code>, <code><a href="#topic+rdiff">rdiff</a></code>,
<code><a href="stats.html#topic+stepfun">stepfun</a></code>, <code><a href="#topic+gillespie">gillespie</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(imdeath(50))
</code></pre>

<hr>
<h2 id='LVdata'>Example simulated time courses from a stochastic Lotka&ndash;Volterra model</h2><span id='topic+LVdata'></span><span id='topic+LVperfect'></span><span id='topic+LVprey'></span><span id='topic+LVnoise10Scale10'></span><span id='topic+LVpreyNoise10'></span><span id='topic+LVpreyNoise10Scale10'></span><span id='topic+LVnoise10'></span><span id='topic+LVnoise30'></span><span id='topic+LVnoise3010'></span><span id='topic+LVirregular'></span><span id='topic+LVirregularNoise10'></span>

<h3>Description</h3>

<p>Collection of simulated time courses from a stochastic Lotka&ndash;Volterra
model.
<code>LVperfect</code> is direct output from a Gillespie simulation.
<code>LVprey</code> is the prey component.
<code>LVnoise10</code> has Gaussian noise with standard deviation 10 added.
<code>LVnoise30</code> has Gaussian noise with standard deviation 30 added.
<code>LVpreyNoise10</code> is the prey component with 10 SD noise added.
<code>LVnoise3010</code> has Gaussian noise added. The noise added to the prey
component has standard deviation 30 and the noise added to the predator
component has standard deviation 10.
<code>LVnoise10scale10</code> has Gaussian noise with standard deviation 10
added, and is then rescaled by a factor of 10 to mimic a scenario of an
uncalibrated measurement scale.
<code>LVirregular</code> is direct output from a Gillespie simulator, but on
an irregular time grid.
<code>LVirregularNoise10</code> is output on an irregular time grid with
Gaussian noise of standard deviation 10 added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LVdata)</code></pre>


<h3>Format</h3>

<p>All datasets beginning
<code>LVirregular</code> are R matrices such as output by
<code><a href="#topic+simTimes">simTimes</a></code>, and the rest are R <code><a href="stats.html#topic+ts">ts</a></code> objects
such as output by <code><a href="#topic+simTs">simTs</a></code>.</p>

<hr>
<h2 id='mcmcSummary'>Summarise and plot tabular MCMC output</h2><span id='topic+mcmcSummary'></span>

<h3>Description</h3>

<p>This function summarises and plots tabular MCMC output such as that
generated by the function <code><a href="#topic+normgibbs">normgibbs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcSummary(mat, rows = 4, lag.max=100, bins=30, show = TRUE, plot = TRUE, truth = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcSummary_+3A_mat">mat</code></td>
<td>
<p>Matrix of MCMC output, where the columns represent
variables and the rows represent iterations.</p>
</td></tr>
<tr><td><code id="mcmcSummary_+3A_rows">rows</code></td>
<td>
<p>Number of variables to plot per page on the graphics
device.</p>
</td></tr>
<tr><td><code id="mcmcSummary_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum lag for the ACF plots.</p>
</td></tr>
<tr><td><code id="mcmcSummary_+3A_bins">bins</code></td>
<td>
<p>Approximate number of bins to use for the histograms.</p>
</td></tr>
<tr><td><code id="mcmcSummary_+3A_show">show</code></td>
<td>
<p>If <code>TRUE</code>, will display numerical summaries on the R
console.</p>
</td></tr>
<tr><td><code id="mcmcSummary_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, will plot graphical summaries on the
default graphics device.</p>
</td></tr>
<tr><td><code id="mcmcSummary_+3A_truth">truth</code></td>
<td>
<p>Optional vector of &quot;true values&quot;, one for each variable, for the case where an algorithm is being tested on synthetic data for known parameters. The plots will be annotated with a red line indicating the true value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R <code><a href="base.html#topic+summary">summary</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normgibbs">normgibbs</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+acf">acf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>out=normgibbs(N=1000,n=15,a=3,b=11,cc=10,d=1/100,xbar=25,ssquared=20)
names(out)=c("mu","tau")
mcmcSummary(out,rows=2,bins=10,truth=c(25,1/20))
</code></pre>

<hr>
<h2 id='metrop'>Run a simple Metropolis sampler with standard normal target and uniform innovations</h2><span id='topic+metrop'></span>

<h3>Description</h3>

<p>This function runs a simple Metropolis sampler with standard normal target distribution and uniform innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrop(n, alpha) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrop_+3A_n">n</code></td>
<td>
<p>The number of iterations of the Metropolis sampler.</p>
</td></tr>
<tr><td><code id="metrop_+3A_alpha">alpha</code></td>
<td>
<p>The tuning parameter of the sampler. The innovations of the sampler are of the form U(-alpha,alpha).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R vector containing the output of the sampler.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normgibbs">normgibbs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>normvec=metrop(1000,1)
op=par(mfrow=c(2,1))
plot(ts(normvec))
hist(normvec,20)
par(op)
</code></pre>

<hr>
<h2 id='metropolisHastings'>Run a Metropolis-Hastings MCMC algorithm for the parameters of a
Bayesian posterior distribution</h2><span id='topic+metropolisHastings'></span>

<h3>Description</h3>

<p>Run a Metropolis-Hastings MCMC algorithm for the parameters of a
Bayesian posterior distribution. Note that the algorithm carries over
the old likelihood from the previous iteration, making it suitable for
problems with expensive likelihoods, and also for &quot;exact approximate&quot;
pseudo-marginal or particle marginal MH algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metropolisHastings(init, logLik, rprop, dprop=function(new, old, ...){1},
                   dprior=function(x, ...){1}, iters=10000, thin=10,
                   verb=TRUE, debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metropolisHastings_+3A_init">init</code></td>
<td>
<p>An parameter vector with which to initialise the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="metropolisHastings_+3A_loglik">logLik</code></td>
<td>
<p>A function which takes a parameter (such as <code>init</code>) as
its only required argument and returns the log-likelihood of the
data. Note that it is fine for this to return the log of an unbiased
estimate of the likelihood, in which case the algorithm will be an
&quot;exact approximate&quot; pseudo-marginal MH algorithm.</p>
</td></tr>
<tr><td><code id="metropolisHastings_+3A_rprop">rprop</code></td>
<td>
<p>A function which takes a parameter as its only required
argument and returns a single sample from a proposal distribution.</p>
</td></tr>
<tr><td><code id="metropolisHastings_+3A_dprop">dprop</code></td>
<td>
<p>A function which takes a new and old parameter as its
first two required arguments and returns the (log) density of the
new value conditional on the old. It should accept an optional
parameter <code>log</code>, and must return the log-density when <code>log</code> is
<code>TRUE</code>. Defaults to a flat function which causes this term to drop
out of the acceptance probability. It is fine to use the default for
_any_ _symmetric_ proposal, since the term will also drop out for
any symmetric proposal.</p>
</td></tr>
<tr><td><code id="metropolisHastings_+3A_dprior">dprior</code></td>
<td>
<p>A function which take a parameter as its only required
argument and returns the (log) density of the parameter value under
the prior. It should accept an optional
parameter <code>log</code>, and must return the log-density when <code>log</code> is
<code>TRUE</code>. Defaults to a flat function which causes this term to drop
out of the acceptance probability. People often use a flat prior
when they are trying to be &quot;uninformative&quot; or &quot;objective&quot;, but this
is slightly naive. In particular, what is &quot;flat&quot; is clearly
dependent on the parametrisation of the model.</p>
</td></tr>
<tr><td><code id="metropolisHastings_+3A_iters">iters</code></td>
<td>
<p>The number of MCMC iterations required (_after_
thinning).</p>
</td></tr>
<tr><td><code id="metropolisHastings_+3A_thin">thin</code></td>
<td>
<p>The required thinning factor. eg. only store every <code>thin</code>
iterations.</p>
</td></tr>
<tr><td><code id="metropolisHastings_+3A_verb">verb</code></td>
<td>
<p>Boolean indicating whether some progress information
should be printed to the console. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="metropolisHastings_+3A_debug">debug</code></td>
<td>
<p>Boolean indicating whether debugging information is required. Prints
information about each iteration to console, to, eg., debug a crashing sampler.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with rows representing samples from the posterior distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfMLLik">pfMLLik</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+abcRun">abcRun</a></code>,
<code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+stepLVc">stepLVc</a></code>, <code><a href="#topic+metrop">metrop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## First simulate some synthetic data
data = rnorm(250,5,2)
## Now use MH to recover the parameters
llik = function(x) { sum(dnorm(data,x[1],x[2],log=TRUE)) }
prop = function(x) { rnorm(2,x,0.1) }
prior = function(x, log=TRUE) {
    l = dnorm(x[1],0,100,log=TRUE) + dgamma(x[2],1,0.0001,log=TRUE)
    if (log) l else exp(l)
}
out = metropolisHastings(c(mu=1,sig=1), llik, prop,
                         dprior=prior, verb=FALSE)
out = out[1000:10000,]
mcmcSummary(out, truth=c(5,2), rows=2, plot=FALSE)
</code></pre>

<hr>
<h2 id='mytable'>Simple example data frame</h2><span id='topic+mytable'></span>

<h3>Description</h3>

<p>Trivial example of a very small data frame. Used as part of the R tutorial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mytable)</code></pre>


<h3>Format</h3>

<p>A very small example data frame.</p>

<hr>
<h2 id='normgibbs'>A simple Gibbs sampler for Bayesian inference for the mean and precision of a normal random sample</h2><span id='topic+normgibbs'></span>

<h3>Description</h3>

<p>This function runs a simple Gibbs sampler for the Bayesian posterior distribution of the mean and precision given a normal random sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normgibbs(N, n, a, b, cc, d, xbar, ssquared)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normgibbs_+3A_n">N</code></td>
<td>
<p>The number of iterations of the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="normgibbs_+3A_n">n</code></td>
<td>
<p>The sample size of the normal random sample.</p>
</td></tr>
<tr><td><code id="normgibbs_+3A_a">a</code></td>
<td>
<p>The shape parameter of the gamma prior on the sample precision.</p>
</td></tr>
<tr><td><code id="normgibbs_+3A_b">b</code></td>
<td>
<p>The scale parameter of the gamma prior on the sample precision.</p>
</td></tr>
<tr><td><code id="normgibbs_+3A_cc">cc</code></td>
<td>
<p>The mean of the normal prior on the sample mean.</p>
</td></tr>
<tr><td><code id="normgibbs_+3A_d">d</code></td>
<td>
<p>The precision of the normal prior on the sample mean.</p>
</td></tr>
<tr><td><code id="normgibbs_+3A_xbar">xbar</code></td>
<td>
<p>The sample mean of the data. eg. <code>mean(x)</code> for a vector <code>x</code>.</p>
</td></tr>
<tr><td><code id="normgibbs_+3A_ssquared">ssquared</code></td>
<td>
<p>The sample variance of the data. eg. <code>var(x)</code> for a vector <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R matrix object containing the samples of the Gibbs sampler.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcfmc">rcfmc</a></code>, <code><a href="#topic+metrop">metrop</a></code>, <code><a href="#topic+mcmcSummary">mcmcSummary</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>postmat=normgibbs(N=1100,n=15,a=3,b=11,cc=10,d=1/100,xbar=25,ssquared=20)
postmat=postmat[101:1100,]
op=par(mfrow=c(3,3))
plot(postmat)
plot(postmat,type="l")
plot.new()
plot(ts(postmat[,1]))
plot(ts(postmat[,2]))
plot(ts(sqrt(1/postmat[,2])))
hist(postmat[,1],30)
hist(postmat[,2],30)
hist(sqrt(1/postmat[,2]),30)
par(op)
</code></pre>

<hr>
<h2 id='pfMLLik'>Create a function for computing the log of an unbiased estimate of marginal likelihood of a time course data set</h2><span id='topic+pfMLLik'></span>

<h3>Description</h3>

<p>Create a function for computing the log of an unbiased estimate of marginal likelihood of a time course data set using a simple bootstrap particle filter. This version uses the &quot;log-sum-exp trick&quot; for avoiding numerical underflow of weights. See <code><a href="#topic+pfMLLik1">pfMLLik1</a></code> for a version which doesn't.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfMLLik(n,simx0,t0,stepFun,dataLik,data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfMLLik_+3A_n">n</code></td>
<td>
<p>An integer representing the number of particles to use in the particle filter.</p>
</td></tr>
<tr><td><code id="pfMLLik_+3A_simx0">simx0</code></td>
<td>
<p>A function with interface <code>simx0(n,t0,...)</code>, where <code>n</code> is the number of rows of a matrix and <code>t0</code> is a time at which to simulate from an initial distribution for the state of the particle filter. The return value should be a matrix whose rows are random samples from this distribution. The function therefore represents a prior distribution on the initial state of the Markov process.</p>
</td></tr>
<tr><td><code id="pfMLLik_+3A_t0">t0</code></td>
<td>
<p>The time corresponding to the starting point of the Markov process. Can be no bigger than the smallest observation time.</p>
</td></tr>
<tr><td><code id="pfMLLik_+3A_stepfun">stepFun</code></td>
<td>
<p>A function for advancing the state of the Markov process, such as returned by <code><a href="#topic+StepGillespie">StepGillespie</a></code>.</p>
</td></tr>
<tr><td><code id="pfMLLik_+3A_datalik">dataLik</code></td>
<td>
<p>A function with interface
<code>dataLik(x,t,y,log=TRUE,...)</code>, where <code>x</code> and <code>t</code>
represent the true state and time of the process, and <code>y</code> is
the observed data. The return value should be the (log of the)
likelihood of the observation. The function therefore represents the
observation model.</p>
</td></tr>
<tr><td><code id="pfMLLik_+3A_data">data</code></td>
<td>
<p>A timed data matrix representing the observations, such as produced by <code><a href="#topic+simTimes">simTimes</a></code> or <code><a href="#topic+as.timedData">as.timedData</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function with interface <code>(...)</code> which evaluates to the log of the particle filter's unbiased estimate of the marginal likelihood of the data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfMLLik1">pfMLLik1</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+as.timedData">as.timedData</a></code>,
<code><a href="#topic+simTimes">simTimes</a></code>, <code><a href="#topic+stepLVc">stepLVc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>noiseSD=5
# first simulate some data
truth=simTs(c(x1=50,x2=100),0,20,2,stepLVc)
data=truth+rnorm(prod(dim(truth)),0,noiseSD)
data=as.timedData(data)
# measurement error model
dataLik &lt;- function(x,t,y,log=TRUE,...)
{
    ll=sum(dnorm(y,x,noiseSD,log=TRUE))
    if (log)
        return(ll)
    else
        return(exp(ll))
}
# now define a sampler for the prior on the initial state
simx0 &lt;- function(N,t0,...)
{
    mat=cbind(rpois(N,50),rpois(N,100))
    colnames(mat)=c("x1","x2")
    mat
}
mLLik=pfMLLik(1000,simx0,0,stepLVc,dataLik,data)
print(mLLik())
print(mLLik(th=c(th1 = 1, th2 = 0.005, th3 = 0.6)))
print(mLLik(th=c(th1 = 1, th2 = 0.005, th3 = 0.5)))
</code></pre>

<hr>
<h2 id='pfMLLik1'>Create a function for computing the log of an unbiased estimate of marginal likelihood of a time course data set</h2><span id='topic+pfMLLik1'></span>

<h3>Description</h3>

<p>Create a function for computing the log of an unbiased estimate of marginal likelihood of a time course data set using a simple bootstrap particle filter. This version does not use the &quot;log-sum-exp trick&quot; for avoiding numerical underflow. 
See <code><a href="#topic+pfMLLik">pfMLLik</a></code> for a version which does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfMLLik1(n,simx0,t0,stepFun,dataLik,data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfMLLik1_+3A_n">n</code></td>
<td>
<p>An integer representing the number of particles to use in the particle filter.</p>
</td></tr>
<tr><td><code id="pfMLLik1_+3A_simx0">simx0</code></td>
<td>
<p>A function with interface <code>simx0(n,t0,...)</code>, where <code>n</code> is the number of rows of a matrix and <code>t0</code> is a time at which to simulate from an initial distribution for the state of the particle filter. The return value should be a matrix whose rows are random samples from this distribution. The function therefore represents a prior distribution on the initial state of the Markov process.</p>
</td></tr>
<tr><td><code id="pfMLLik1_+3A_t0">t0</code></td>
<td>
<p>The time corresponding to the starting point of the Markov process. Can be no bigger than the smallest observation time.</p>
</td></tr>
<tr><td><code id="pfMLLik1_+3A_stepfun">stepFun</code></td>
<td>
<p>A function for advancing the state of the Markov process, such as returned by <code><a href="#topic+StepGillespie">StepGillespie</a></code>.</p>
</td></tr>
<tr><td><code id="pfMLLik1_+3A_datalik">dataLik</code></td>
<td>
<p>A function with interface
<code>dataLik(x,t,y,log=TRUE,...)</code>, where <code>x</code> and <code>t</code>
represent the true state and time of the process, and <code>y</code> is
the observed data. The return value should be the (log of the)
likelihood of the observation. The function therefore represents the
observation model.</p>
</td></tr>
<tr><td><code id="pfMLLik1_+3A_data">data</code></td>
<td>
<p>A timed data matrix representing the observations, such as produced by <code><a href="#topic+simTimes">simTimes</a></code> or <code><a href="#topic+as.timedData">as.timedData</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function with interface <code>(...)</code> which evaluates to the log of the particle filter's unbiased estimate of the marginal likelihood of the data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfMLLik">pfMLLik</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+as.timedData">as.timedData</a></code>,
<code><a href="#topic+simTimes">simTimes</a></code>, <code><a href="#topic+stepLVc">stepLVc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>noiseSD=5
# first simulate some data
truth=simTs(c(x1=50,x2=100),0,20,2,stepLVc)
data=truth+rnorm(prod(dim(truth)),0,noiseSD)
data=as.timedData(data)
# measurement error model
dataLik &lt;- function(x,t,y,log=TRUE,...)
{
    ll=sum(dnorm(y,x,noiseSD,log=TRUE))
    if (log)
        return(ll)
    else
        return(exp(ll))
}
# now define a sampler for the prior on the initial state
simx0 &lt;- function(N,t0,...)
{
    mat=cbind(rpois(N,50),rpois(N,100))
    colnames(mat)=c("x1","x2")
    mat
}
mLLik=pfMLLik1(1000,simx0,0,stepLVc,dataLik,data)
print(mLLik())
print(mLLik(th=c(th1 = 1, th2 = 0.005, th3 = 0.6)))
print(mLLik(th=c(th1 = 1, th2 = 0.005, th3 = 0.5)))
</code></pre>

<hr>
<h2 id='rcfmc'>Simulate a continuous time finite state space Markov chain</h2><span id='topic+rcfmc'></span>

<h3>Description</h3>

<p>This function simulates a single realisation from a continuous time Markov chain having a finite state space based on a given transition rate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcfmc(n,Q,pi0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcfmc_+3A_n">n</code></td>
<td>
<p>The number of states to be sampled from the Markov chain, including the initial state, which will be sampled using <code>pi0</code>.</p>
</td></tr>
<tr><td><code id="rcfmc_+3A_q">Q</code></td>
<td>
<p>The transition rate matrix of the Markov chain, where each off-diagonal element <code>Q[i,j]</code> represents the rate of transition from state <code>i</code> to state <code>j</code>. This matrix is assumed to be square, having rows summing to zero.</p>
</td></tr>
<tr><td><code id="rcfmc_+3A_pi0">pi0</code></td>
<td>
<p>A vector representing the probability distribution of the
initial state of the Markov chain. If this vector is of length <code>r</code>,
then the transition matrix <code>P</code> is assumed to be <code>r x r</code>. The elements of this vector are assumed to be non-negative and sum to one, though in fact, they will be normalised by the sampling procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R <code><a href="stats.html#topic+stepfun">stepfun</a></code> object containing the sampled path of the process.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfmc">rfmc</a></code>, <code><a href="stats.html#topic+stepfun">stepfun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(rcfmc(20,matrix(c(-0.5,0.5,1,-1),ncol=2,byrow=TRUE),c(1,0)))
</code></pre>

<hr>
<h2 id='rdiff'>Simulate a sample path from a univariate diffusion process</h2><span id='topic+rdiff'></span>

<h3>Description</h3>

<p>This function simulates a single realisation from a time-homogeneous univariate diffusion process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdiff(afun, bfun, x0 = 0, t = 50, dt = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdiff_+3A_afun">afun</code></td>
<td>
<p>A scalar-valued function representing the infinitesimal
mean (drift) of the diffusion process. The first argument of <code>afun</code> is the current state of the process.</p>
</td></tr>
<tr><td><code id="rdiff_+3A_bfun">bfun</code></td>
<td>
<p>A scalar-valued function representing the infinitesimal standard deviation of the process. The first argument of <code>bfun</code> is the current state of the process.</p>
</td></tr>
<tr><td><code id="rdiff_+3A_x0">x0</code></td>
<td>
<p>The initial state of the diffusion process.</p>
</td></tr>
<tr><td><code id="rdiff_+3A_t">t</code></td>
<td>
<p>The length of the time interval over which the diffusion process is to be simulated. Defaults to 50 time units.</p>
</td></tr>
<tr><td><code id="rdiff_+3A_dt">dt</code></td>
<td>
<p>The step size to be used both for the time step of the Euler
integration method and the recording interval for the output. It
would probably be better to have separate parameters for these two
things (see <code><a href="#topic+StepSDE">StepSDE</a></code> and <code><a href="#topic+simTs">simTs</a></code>). Defaults to 0.01 time units.</p>
</td></tr>
<tr><td><code id="rdiff_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed into <code>afun</code> and <code>bfun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R <code><a href="stats.html#topic+ts">ts</a></code> object containing the sampled path of the process.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcfmc">rcfmc</a></code>, <code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="#topic+StepSDE">StepSDE</a></code>, <code><a href="#topic+simTs">simTs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a diffusion approximation to an immigration-death process
# infinitesimal mean
afun&lt;-function(x,lambda,mu)
{
        lambda-mu*x
}
# infinitesimal standard deviation
bfun&lt;-function(x,lambda,mu)
{
        sqrt(lambda+mu*x)
}
# plot a sample path
plot(rdiff(afun,bfun,lambda=1,mu=0.1,t=30))
</code></pre>

<hr>
<h2 id='rfmc'>Simulate a finite state space Markov chain</h2><span id='topic+rfmc'></span>

<h3>Description</h3>

<p>This function simulates a single realisation from a discrete time Markov chain having a finite state space based on a given transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfmc(n,P,pi0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfmc_+3A_n">n</code></td>
<td>
<p>The number of states to be sampled from the Markov chain, including the initial state, which will be sampled using <code>pi0</code>.</p>
</td></tr>
<tr><td><code id="rfmc_+3A_p">P</code></td>
<td>
<p>The transition matrix of the Markov chain. This is assumed to be a stochastic matrix, having non-negative elements and rows summing to one, though in fact, the rows will in any case be normalised by the sampling procedure.</p>
</td></tr>
<tr><td><code id="rfmc_+3A_pi0">pi0</code></td>
<td>
<p>A vector representing the probability distribution of the initial state of the Markov chain. If this vector is of length <code>r</code>, then the transition matrix <code>P</code> is assumed to be <code>r x r</code>. The elements of this vector are assumed to be non-negative and sum to one, though in fact, they will be normalised by the sampling procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R <code><a href="stats.html#topic+ts">ts</a></code> object containing the sampled values from the Markov chain.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcfmc">rcfmc</a></code>, <code><a href="stats.html#topic+ts">ts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># example for sampling a finite Markov chain
P = matrix(c(0.9,0.1,0.2,0.8),ncol=2,byrow=TRUE)
pi0 = c(0.5,0.5)
samplepath = rfmc(200,P,pi0)
plot(samplepath)
summary(samplepath)
table(samplepath)
table(samplepath)/length(samplepath) # empirical distribution
# now compute the exact stationary distribution...
e = eigen(t(P))$vectors[,1]
e/sum(e)
</code></pre>

<hr>
<h2 id='simpleEuler'>Simulate a sample path from an ODE model</h2><span id='topic+simpleEuler'></span>

<h3>Description</h3>

<p>This function integrates an Ordinary Differential Equation (ODE) model
using a simple first order Euler method. The function is pedagogic and
not intended for serious use. See the <code><a href="deSolve.html#topic+deSolve">deSolve</a></code>
package for better, more robust ODE solvers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleEuler(t=50, dt=0.001, fun, ic, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleEuler_+3A_t">t</code></td>
<td>
<p>The length of the time interval over which the ODE model is to be integrated. Defaults to 50 time units.</p>
</td></tr>
<tr><td><code id="simpleEuler_+3A_dt">dt</code></td>
<td>
<p>The step size to be used both for the time step of the Euler
integration method and the recording interval for the output. It
would probably be better to have separate parameters for these two
things (see <code><a href="#topic+StepEuler">StepEuler</a></code> and
<code><a href="#topic+simTs">simTs</a></code>). Defaults to 0.01 time units.</p>
</td></tr> 
<tr><td><code id="simpleEuler_+3A_fun">fun</code></td>
<td>
<p>A vector-valued function representing the right hand side
of the ODE model.
The first argument is a vector representing the current state of the
model, <code>x</code>. 
The second argument of <code>fun</code> is the current simulation time,
<code>t</code>. In the case of a homogeneous ODE model, this argument will
be unused within the function. The function may have additional arguments, representing
model parameters.
The output of <code>fun</code> should be a vector of the same dimension as <code>x</code>.</p>
</td></tr>
<tr><td><code id="simpleEuler_+3A_ic">ic</code></td>
<td>
<p>The initial conditions for the ODE model. This should be a vector of the same dimensions as the output from <code>fun</code>, and the second argument of <code>fun</code>.</p>
</td></tr>
<tr><td><code id="simpleEuler_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed into <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R <code><a href="stats.html#topic+ts">ts</a></code> object containing the sampled path of the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdiff">rdiff</a></code>, <code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="#topic+StepEuler">StepEuler</a></code>,
<code><a href="#topic+simTs">simTs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simple Lotka-Volterra example
lv &lt;- function(x,t,k=c(k1=1,k2=0.1,k3=0.1))
{
        with(as.list(c(x,k)),{
                c( k1*x1 - k2*x1*x2 ,
                      k2*x1*x2 - k3*x2 )
        })
}
plot(simpleEuler(t=100,fun=lv,ic=c(x1=4,x2=10)),plot.type="single",lty=1:2)

# now an example which instead uses deSolve...
require(deSolve)
times = seq(0,50,by=0.01)
k = c(k1=1,k2=0.1,k3=0.1)
lvlist = function(t,x,k)
        list(lv(x,t,k))
plot(ode(y=c(x1=4,x2=10),times=times,func=lvlist,parms=k))

</code></pre>

<hr>
<h2 id='simSample'>Simulate a many realisations of a model at a given fixed time in the future given an initial time and state, using a function (closure) for advancing the state of the model</h2><span id='topic+simSample'></span>

<h3>Description</h3>

<p>This function 
simulates 
many realisations of a model at a given fixed time in the future given an initial time and state, using a function (closure) for advancing the state of the model
, such as created by <code><a href="#topic+StepGillespie">StepGillespie</a></code> or <code><a href="#topic+StepSDE">StepSDE</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simSample(n=100,x0,t0=0,deltat,stepFun,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simSample_+3A_n">n</code></td>
<td>
<p>The number of samples required. Defaults to 100.</p>
</td></tr>
<tr><td><code id="simSample_+3A_x0">x0</code></td>
<td>
<p>The initial state of the process at time <code>t0</code>.</p>
</td></tr>
<tr><td><code id="simSample_+3A_t0">t0</code></td>
<td>
<p>The initial time to be associated with the initial state <code>x0</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="simSample_+3A_deltat">deltat</code></td>
<td>
<p>The amount of time in the future of <code>t0</code> at which samples of the system state are required.</p>
</td></tr>
<tr><td><code id="simSample_+3A_stepfun">stepFun</code></td>
<td>
<p>A function (closure) for advancing the state of the process, such as produced by <code><a href="#topic+StepGillespie">StepGillespie</a></code> or <code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>.</p>
</td></tr>
<tr><td><code id="simSample_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed to <code>stepFun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R matrix whose rows represent the simulated states of the process at time <code>t0+deltat</code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepSDE">StepSDE</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+simTimes">simTimes</a></code>, <code><a href="#topic+simTs">simTs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>out3 = simSample(100,c(x1=50,x2=100),0,20,stepLVc)
hist(out3[,"x2"])
</code></pre>

<hr>
<h2 id='simTimes'>Simulate a model at a specified set of times, using a function (closure) for advancing the state of the model</h2><span id='topic+simTimes'></span>

<h3>Description</h3>

<p>This function simulates a single realisation from a Markovian model and
records the state at a specified set of times using a function (closure) for advancing the state of the model, such as created by <code><a href="#topic+StepGillespie">StepGillespie</a></code> or <code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTimes(x0,t0=0,times,stepFun,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTimes_+3A_x0">x0</code></td>
<td>
<p>The initial state of the process at time <code>t0</code>.</p>
</td></tr>
<tr><td><code id="simTimes_+3A_t0">t0</code></td>
<td>
<p>The initial time to be associated with the initial state <code>x0</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="simTimes_+3A_times">times</code></td>
<td>
<p>A vector of times at which the state of the process is required. It is assumed that the times are in increasing order, and that the first time is at least as big as <code>t0</code>.</p>
</td></tr>
<tr><td><code id="simTimes_+3A_stepfun">stepFun</code></td>
<td>
<p>A function (closure) for advancing the state of the process, such as produced by <code><a href="#topic+StepGillespie">StepGillespie</a></code> or <code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>.</p>
</td></tr>
<tr><td><code id="simTimes_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed to <code>stepFun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R matrix where each row represents the state of the process at one of the required times. The row names contain the sampled times.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code>,
<code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+simSample">simSample</a></code>,
<code><a href="#topic+as.timedData">as.timedData</a></code>, <code><a href="#topic+pfMLLik">pfMLLik</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load the LV model
data(spnModels)
# create a stepping function
stepLV = StepGillespie(LV)
# simulate a realisation using simTimes
times = seq(0,100,by=0.1)
plot(ts(simTimes(c(x1=50,x2=100),0,times,stepLV),start=0,deltat=0.1),plot.type="single",lty=1:2)
# simulate a realisation at irregular times
times = c(0,10,20,50,100)
out2 = simTimes(c(x1=50,x2=100),0,times,stepLV)
print(out2)
</code></pre>

<hr>
<h2 id='simTs'>Simulate a model on a regular grid of times, using a function (closure) for advancing the state of the model</h2><span id='topic+simTs'></span>

<h3>Description</h3>

<p>This function simulates single realisation of a model on a regular grid of times using a function (closure) for advancing the state of the model, such as created by <code><a href="#topic+StepGillespie">StepGillespie</a></code> or <code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTs(x0,t0=0,tt=100,dt=0.1,stepFun,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTs_+3A_x0">x0</code></td>
<td>
<p>The initial state of the process at time <code>t0</code>.</p>
</td></tr>
<tr><td><code id="simTs_+3A_t0">t0</code></td>
<td>
<p>The initial time to be associated with the initial state <code>x0</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="simTs_+3A_tt">tt</code></td>
<td>
<p>The terminal time of the simulation.</p>
</td></tr>
<tr><td><code id="simTs_+3A_dt">dt</code></td>
<td>
<p>The time step of the output. Note that this time step
relates only to the recorded output, and has no bearing on the accuracy of the simulation process.</p>
</td></tr>
<tr><td><code id="simTs_+3A_stepfun">stepFun</code></td>
<td>
<p>A function (closure) for advancing the state of the process, such as produced by <code><a href="#topic+StepGillespie">StepGillespie</a></code> or <code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>.</p>
</td></tr>
<tr><td><code id="simTs_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed to <code>stepFun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R <code><a href="stats.html#topic+ts">ts</a></code> object representing the simulated process.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code>,
<code><a href="#topic+StepSDE">StepSDE</a></code>, <code><a href="#topic+simTimes">simTimes</a></code>, <code><a href="#topic+simSample">simSample</a></code>, <code><a href="#topic+as.timedData">as.timedData</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load the LV model
data(spnModels)
# create a stepping function
stepLV = StepGillespie(LV)
# simulate a realisation of the process and plot it
out = simTs(c(x1=50,x2=100),0,100,0.1,stepLV)
plot(out)
plot(out,plot.type="single",lty=1:2)
</code></pre>

<hr>
<h2 id='simTs1D'>Simulate a model on a regular grid of times, using a function (closure) for advancing the state of the model</h2><span id='topic+simTs1D'></span>

<h3>Description</h3>

<p>This function simulates single realisation of a model on a 1D regular
spatial grid and regular grid of times using a function (closure) for advancing the state of the model, such as created by <code><a href="#topic+StepGillespie1D">StepGillespie1D</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTs1D(x0,t0=0,tt=100,dt=0.1,stepFun,verb=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTs1D_+3A_x0">x0</code></td>
<td>
<p>The initial state of the process at time <code>t0</code>, a matrix
with rows corresponding to reacting species and columns
corresponding to spatial location.</p>
</td></tr>
<tr><td><code id="simTs1D_+3A_t0">t0</code></td>
<td>
<p>The initial time to be associated with the initial state <code>x0</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="simTs1D_+3A_tt">tt</code></td>
<td>
<p>The terminal time of the simulation.</p>
</td></tr>
<tr><td><code id="simTs1D_+3A_dt">dt</code></td>
<td>
<p>The time step of the output. Note that this time step
relates only to the recorded output, and has no bearing on the accuracy of the simulation process.</p>
</td></tr>
<tr><td><code id="simTs1D_+3A_stepfun">stepFun</code></td>
<td>
<p>A function (closure) for advancing the state of the
process, such as produced by <code><a href="#topic+StepGillespie1D">StepGillespie1D</a></code>.</p>
</td></tr>
<tr><td><code id="simTs1D_+3A_verb">verb</code></td>
<td>
<p>Output progress to the console (this function can be very slow).</p>
</td></tr>
<tr><td><code id="simTs1D_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed to <code>stepFun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R 3d array representing the simulated process. The dimensions are
species, space, and time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie1D">StepGillespie1D</a></code>, <code><a href="#topic+simTs">simTs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(spnModels)
N=20; T=30
x0=matrix(0,nrow=2,ncol=N)
rownames(x0)=c("x1","x2")
x0[,round(N/2)]=LV$M
stepLV1D = StepGillespie1D(LV,c(0.6,0.6))
xx = simTs1D(x0,0,T,0.2,stepLV1D,verb=TRUE)
op=par(mfrow=c(1,2))
image(xx[1,,],main="Prey",xlab="Space",ylab="Time")
image(xx[2,,],main="Predator",xlab="Space",ylab="Time")
par(op)

</code></pre>

<hr>
<h2 id='simTs2D'>Simulate a model on a regular grid of times, using a function (closure) for advancing the state of the model</h2><span id='topic+simTs2D'></span>

<h3>Description</h3>

<p>This function simulates single realisation of a model on a 2D regular
spatial grid and regular grid of times using a function (closure) for advancing the state of the model, such as created by <code><a href="#topic+StepGillespie2D">StepGillespie2D</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTs2D(x0,t0=0,tt=100,dt=0.1,stepFun,verb=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTs2D_+3A_x0">x0</code></td>
<td>
<p>The initial state of the process at time <code>t0</code>, a 3d array
with dimensions corresponding to reacting species and two spatial dimensions.</p>
</td></tr>
<tr><td><code id="simTs2D_+3A_t0">t0</code></td>
<td>
<p>The initial time to be associated with the initial state <code>x0</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="simTs2D_+3A_tt">tt</code></td>
<td>
<p>The terminal time of the simulation.</p>
</td></tr>
<tr><td><code id="simTs2D_+3A_dt">dt</code></td>
<td>
<p>The time step of the output. Note that this time step
relates only to the recorded output, and has no bearing on the accuracy of the simulation process.</p>
</td></tr>
<tr><td><code id="simTs2D_+3A_stepfun">stepFun</code></td>
<td>
<p>A function (closure) for advancing the state of the
process, such as produced by <code><a href="#topic+StepGillespie2D">StepGillespie2D</a></code>.</p>
</td></tr>
<tr><td><code id="simTs2D_+3A_verb">verb</code></td>
<td>
<p>Output progress to the console and graphics window (this function can be very slow).</p>
</td></tr>
<tr><td><code id="simTs2D_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed to <code>stepFun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R 4d array representing the simulated process. The dimensions are
species, 2 space, and time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie2D">StepGillespie2D</a></code>, <code><a href="#topic+simTs1D">simTs1D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(spnModels)
m=20; n=30; T=15
x0=array(0,c(2,m,n))
dimnames(x0)[[1]]=c("x1","x2")
x0[,round(m/2),round(n/2)]=LV$M
stepLV2D = StepGillespie2D(LV,c(0.6,0.6))
xx = simTs2D(x0,0,T,0.2,stepLV2D,verb=TRUE)
N = dim(xx)[4]
op=par(mfrow=c(1,2))
image(xx[1,,,N],main="Prey",xlab="Space",ylab="Time")
image(xx[2,,,N],main="Predator",xlab="Space",ylab="Time")
par(op)
</code></pre>

<hr>
<h2 id='smfsb-package'>Stochastic Modelling for Systems Biology</h2><span id='topic+smfsb'></span><span id='topic+smfsb2e'></span><span id='topic+smfsb3e'></span><span id='topic+SMfSB'></span><span id='topic+SMfSB2e'></span><span id='topic+SMfSB3e'></span>

<h3>Description</h3>

<p>This package contains code and data for modelling and simulation of
stochastic kinetic biochemical network models. It contains the code and
data associated with the second and third editions of the book Stochastic Modelling
for Systems Biology, published by Chapman &amp; Hall/CRC Press.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Darren Wilkinson &lt;darrenjwilkinson@btinternet.com&gt;
</p>


<h3>References</h3>

<p>See <a href="https://darrenjw.github.io/work/smfsb/">https://darrenjw.github.io/work/smfsb/</a>
or <a href="https://github.com/darrenjw/smfsb">https://github.com/darrenjw/smfsb</a>
for further details.</p>

<hr>
<h2 id='spnModels'>Example SPN models</h2><span id='topic+spnModels'></span><span id='topic+LV'></span><span id='topic+ID'></span><span id='topic+BD'></span><span id='topic+Dimer'></span><span id='topic+MM'></span><span id='topic+LVV'></span><span id='topic+SIR'></span><span id='topic+SEIR'></span>

<h3>Description</h3>

<p>Collection of example stochastic Petri net (SPN) models. Includes <code>LV</code>, a Lotka&ndash;Volterra
model, <code>ID</code>, an immigration&ndash;death process, <code>BD</code>, a birth&ndash;death
process, <code>SIR</code>, a simple SIR model, <code>SEIR</code>, an SEIR epidemic model, <code>Dimer</code>, a simple dimerisation kinetics model, and
<code>MM</code>, a Michaelis&ndash;Menten enzyme kinetic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spnModels)</code></pre>


<h3>Format</h3>

<p>Each model is a list, with components <code>Pre</code>, <code>Post</code>,
and <code>h</code>. Some models also include an initial state, <code>M</code>. See
<code><a href="#topic+gillespie">gillespie</a></code> and <code><a href="#topic+StepGillespie">StepGillespie</a></code> for further details, and
examples of use.</p>

<hr>
<h2 id='StepCLE'>Create a function for advancing the state of an SPN by using a simple Euler-Maruyama integration method for the approximating CLE</h2><span id='topic+StepCLE'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model using a simple Euler-Maruyama integration method for the approximating chemical Langevin equation (CLE). The resulting function (closure) can be used in conjunction with other functions (such as <code><a href="#topic+simTs">simTs</a></code>) for simulating realisations of SPN models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepCLE(N,dt=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepCLE_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net. Should contain <code>N$Pre</code>, a matrix representing the
LHS stoichiometries, <code>N$Post</code>, a matrix representing the RHS
stoichiometries, and <code>N$h</code>, a function representing the rates
of the reaction processes.
<code>N$h</code> should have
first argument <code>x</code>, a vector representing the current state of
the system, and second argument <code>t</code>, a scalar
representing the current simulation time (in the typical
time-homogeneous case, <code>N$h</code> will ignore this argument).
<code>N$h</code> may posses additional arguments, representing reaction rates, for example. <code>N</code> does not need to contain an initial marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions which use the resulting function closure.</p>
</td></tr>
<tr><td><code id="StepCLE_+3A_dt">dt</code></td>
<td>
<p>Time step to be used by the Euler-Maruyama integration method. Defaults to 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model <code>N</code> by using an Euler-Maruyama method on the approximating CLE with step size <code>dt</code>. The function closure has interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> and <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>,
<code><a href="#topic+StepSDE">StepSDE</a></code>, <code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+simSample">simSample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load the LV model
data(spnModels)
# create a stepping function
stepLV = StepCLE(LV)
# step the function
print(stepLV(c(x1=50,x2=100),0,1))
# integrate the process and plot it
out = simTs(c(x1=50,x2=100),0,20,0.1,stepLV)
plot(out)
plot(out,plot.type="single",lty=1:2)
</code></pre>

<hr>
<h2 id='StepCLE1D'>Create a function for advancing the state of an SPN by using a simple Euler-Maruyama discretisation of the CLE on a 1D regular grid</h2><span id='topic+StepCLE1D'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model
using a simple Euler-Maruyama discretisation of the CLE on a 1D regular grid. The resulting function (closure) can be
used in conjunction with other functions (such as <code><a href="#topic+simTs1D">simTs1D</a></code>)
for simulating realisations of SPN models in space and time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepCLE1D(N,d,dt=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepCLE1D_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net (SPN). Should contain <code>N$Pre</code>, a matrix representing
the LHS stoichiometries, <code>N$Post</code>, a matrix representing the
RHS stoichiometries, and <code>N$h</code>, a function representing the
rates of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the
current state of the system, and
second
argument <code>t</code>, a scalar representing the current simulation time
(in the typical time-homogeneous case, <code>N$h</code> will ignore this
argument).
<code>N$h</code> may possess additional arguments, representing reaction
rates, for example. <code>N</code> does not need to contain an initial
marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions
which use the resulting function closure.</p>
</td></tr>
<tr><td><code id="StepCLE1D_+3A_d">d</code></td>
<td>
<p>A vector of diffusion coefficients - one coefficient for each
reacting species, in order. The coefficient is the reaction rate for a
reaction for a molecule moving into an adjacent compartment. The hazard
for a given molecule leaving the compartment is therefore twice this
value (as it can leave to the left or the right).</p>
</td></tr>
<tr><td><code id="StepCLE1D_+3A_dt">dt</code></td>
<td>
<p>Time step for the Euler-Maruyama discretisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model
<code>N</code> by using a simple Euler-Maruyama algorithm. The function closure has
interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> is a matrix
with rows corresponding to species and columns corresponding to voxels,
representing the initial condition, <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a matrix representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie1D">StepGillespie1D</a></code>,<code><a href="#topic+StepCLE">StepCLE</a></code>,
<code><a href="#topic+simTs1D">simTs1D</a></code>, <code><a href="#topic+StepCLE2D">StepCLE2D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
N=200
T=40
data(spnModels)
x0=matrix(0,nrow=2,ncol=N)
rownames(x0)=c("x1","x2")
x0[,round(N/2)]=LV$M
stepLV1D = StepCLE1D(LV,c(0.6,0.6),dt=0.05)
xx = simTs1D(x0,0,T,0.2,stepLV1D)
op=par(mfrow=c(1,2))
image(xx[1,,],main="Prey",xlab="Space",ylab="Time")
image(xx[2,,],main="Predator",xlab="Space",ylab="Time")
par(op)

</code></pre>

<hr>
<h2 id='StepCLE2D'>Create a function for advancing the state of an SPN by using a simple Euler-Maruyama discretisation of the CLE on a 2D regular grid</h2><span id='topic+StepCLE2D'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model
using a simple Euler-Maruyama discretisation of the CLE on a 2D regular grid. The resulting function (closure) can be
used in conjunction with other functions (such as <code><a href="#topic+simTs2D">simTs2D</a></code>)
for simulating realisations of SPN models in space and time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepCLE2D(N,d,dt=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepCLE2D_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net (SPN). Should contain <code>N$Pre</code>, a matrix representing
the LHS stoichiometries, <code>N$Post</code>, a matrix representing the
RHS stoichiometries, and <code>N$h</code>, a function representing the
rates of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the
current state of the system, and
second
argument <code>t</code>, a scalar representing the current simulation time
(in the typical time-homogeneous case, <code>N$h</code> will ignore this
argument).
<code>N$h</code> may possess additional arguments, representing reaction
rates, for example. <code>N</code> does not need to contain an initial
marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions
which use the resulting function closure.</p>
</td></tr>
<tr><td><code id="StepCLE2D_+3A_d">d</code></td>
<td>
<p>A vector of diffusion coefficients - one coefficient for each
reacting species, in order. The coefficient is the reaction rate for a
reaction for a molecule moving into an adjacent compartment. The hazard
for a given molecule leaving the compartment is therefore four times this
value (as it can leave in one of 4 directions).</p>
</td></tr>
<tr><td><code id="StepCLE2D_+3A_dt">dt</code></td>
<td>
<p>Time step for the Euler-Maruyama discretisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model
<code>N</code> by using a simple Euler-Maruyama algorithm. The function closure has
interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> is a 3D array
with rows corresponding to species and columns corresponding to voxels,
representing the initial condition (with dimensions species, x, and y), <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a matrix representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie2D">StepGillespie2D</a></code>,<code><a href="#topic+StepCLE">StepCLE</a></code>,
<code><a href="#topic+simTs1D">simTs1D</a></code>, <code><a href="#topic+StepCLE1D">StepCLE1D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
m=150
n=100
T=15
data(spnModels)
x0=array(0,c(2,m,n))
dimnames(x0)[[1]]=c("x1","x2")
x0[,round(m/2),round(n/2)]=LV$M
stepLV2D = StepCLE2D(LV,c(0.6,0.6),dt=0.05)
xx = simTs2D(x0,0,T,0.5,stepLV2D,verb=TRUE)
N = dim(xx)[4]
op=par(mfrow=c(1,2))
image(xx[1,,,N],main="Prey",xlab="Space",ylab="Time")
image(xx[2,,,N],main="Predator",xlab="Space",ylab="Time")
par(op)

</code></pre>

<hr>
<h2 id='StepEuler'>Create a function for advancing the state of an ODE model by using a simple Euler integration method</h2><span id='topic+StepEuler'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an ODE model
using a simple Euler integration method. The resulting function
(closure) can be used in conjunction with other functions (such as
<code><a href="#topic+simTs">simTs</a></code>) for simulating realisations of ODE models. This
function is intended to be pedagogic. See <code><a href="#topic+StepODE">StepODE</a></code> for a
more accurate integration function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepEuler(RHSfun,dt=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepEuler_+3A_rhsfun">RHSfun</code></td>
<td>
<p>A function representing the RHS of the ODE
model. <code>RHSfun</code> should have prototype <code>RHSfun(x,t,...)</code>,
with  <code>x</code> representing current system state and <code>t</code> representing current system time. The value of the function should be a vector of the same dimension as <code>x</code>, representing the infinitesimal change in state.</p>
</td></tr>
<tr><td><code id="StepEuler_+3A_dt">dt</code></td>
<td>
<p>Time step to be used by the simple Euler integration method. Defaults to 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the ODE model <code>RHSfun</code> by using an Euler method with step size <code>dt</code>. The function closure has interface <code>function(x0,t0,deltat,...)</code>, where <code>t0</code> and <code>x0</code> represent the initial time and state, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>, <code><a href="#topic+StepODE">StepODE</a></code>, <code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+simSample">simSample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Build a RHS for the Lotka-Volterra system
LVrhs &lt;- function(x,t,th=c(c1=1,c2=0.005,c3=0.6))
{
        with(as.list(c(x,th)),{
                c( c1*x1 - c2*x1*x2 ,
                      c2*x1*x2 - c3*x2 )
        })
}
# create a stepping function
stepLV = StepEuler(LVrhs)
# step the function
print(stepLV(c(x1=50,x2=100),0,1))
# integrate the process and plot it
out = simTs(c(x1=50,x2=100),0,20,0.1,stepLV)
plot(out,plot.type="single",lty=1:2)
</code></pre>

<hr>
<h2 id='StepEulerSPN'>Create a function for advancing the state of an SPN by using a simple continuous deterministic Euler integration method</h2><span id='topic+StepEulerSPN'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model using a simple continuous deterministic Euler integration method. The resulting function (closure) can be used in conjunction with other functions (such as <code><a href="#topic+simTs">simTs</a></code>) for simulating realisations of SPN models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepEulerSPN(N,dt=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepEulerSPN_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net. Should contain <code>N$Pre</code>, a matrix representing the
LHS stoichiometries, <code>N$Post</code>, a matrix representing the RHS
stoichiometries, and <code>N$h</code>, a function representing the rates
of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the current state of
the system, and
second argument <code>t</code>, a scalar representing the current
simulation time (in the typical time-homogeneous case, <code>N$h</code>
will ignore this argument).
<code>N$h</code> may possess additional arguments, representing reaction rates, for example. <code>N</code> does not need to contain an initial marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions which use the resulting function closure.</p>
</td></tr>
<tr><td><code id="StepEulerSPN_+3A_dt">dt</code></td>
<td>
<p>Time step to be used by the simple Euler integration method. Defaults to 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model <code>N</code> by using an Euler method with step size <code>dt</code>. The function closure has interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> and <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+StepODE">StepODE</a></code>, <code><a href="#topic+StepCLE">StepCLE</a></code>, <code><a href="#topic+simpleEuler">simpleEuler</a></code>, <code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+simSample">simSample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load the LV model
data(spnModels)
# create a stepping function
stepLV = StepEulerSPN(LV)
# step the function
print(stepLV(c(x1=50,x2=100),0,1))
# integrate the process and plot it
out = simTs(c(x1=50,x2=100),0,100,0.1,stepLV)
plot(out)
plot(out,plot.type="single",lty=1:2)
</code></pre>

<hr>
<h2 id='StepFRM'>Create a function for advancing the state of an SPN by using Gillespie's first reaction method</h2><span id='topic+StepFRM'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model using Gillespie's first reaction method. The resulting function (closure) can be used in conjunction with other functions (such as <code><a href="#topic+simTs">simTs</a></code>) for simulating realisations of SPN models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepFRM(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepFRM_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net. Should contain <code>N$Pre</code>, a matrix representing the
LHS stoichiometries, <code>N$Post</code>, a matrix representing the RHS
stoichiometries, and <code>N$h</code>, a function representing the rates
of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the current state of
the system, and
second argument <code>t</code>, a scalar representing the current
simulation time (in the typical time-homogeneous case, <code>N$h</code>
will ignore this argument).
<code>N$h</code> may possess additional arguments, representing reaction rates, for example. <code>N</code> does not need to contain an initial marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions which use the resulting function closure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model <code>N</code> by using Gillespie's first reaction method. The function closure has interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> and <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>, <code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+simSample">simSample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load the LV model
data(spnModels)
# create a stepping function
stepLV = StepFRM(LV)
# step the function
print(stepLV(c(x1=50,x2=100),0,1))
# simulate a realisation of the process and plot it
out = simTs(c(x1=50,x2=100),0,100,0.1,stepLV)
plot(out,plot.type="single",lty=1:2)
</code></pre>

<hr>
<h2 id='StepGillespie'>Create a function for advancing the state of an SPN by using the Gillespie algorithm</h2><span id='topic+StepGillespie'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model using the Gillespie algorithm. The resulting function (closure) can be used in conjunction with other functions (such as <code><a href="#topic+simTs">simTs</a></code>) for simulating realisations of SPN models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepGillespie(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepGillespie_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net (SPN). Should contain <code>N$Pre</code>, a matrix representing
the LHS stoichiometries, <code>N$Post</code>, a matrix representing the
RHS stoichiometries, and <code>N$h</code>, a function representing the
rates of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the
current state of the system, and
second
argument <code>t</code>, a scalar representing the current simulation time
(in the typical time-homogeneous case, <code>N$h</code> will ignore this
argument).
<code>N$h</code> may possess additional arguments, representing reaction rates, for example. <code>N</code> does not need to contain an initial marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions which use the resulting function closure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model <code>N</code> by using the Gillespie algorithm. The function closure has interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> and <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>, <code><a href="#topic+StepGillespie1D">StepGillespie1D</a></code>,
<code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+simTimes">simTimes</a></code>, <code><a href="#topic+simSample">simSample</a></code>, <code><a href="#topic+StepFRM">StepFRM</a></code>,
<code><a href="#topic+StepPTS">StepPTS</a></code>, <code><a href="#topic+StepCLE">StepCLE</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load up the Lotka-Volterra (LV) model
data(spnModels)
LV
# create a stepping function
stepLV = StepGillespie(LV)
# step the function
print(stepLV(c(x1=50,x2=100),0,1))
# simulate a realisation of the process and plot it
out = simTs(c(x1=50,x2=100),0,100,0.1,stepLV)
plot(out)
plot(out,plot.type="single",lty=1:2)
# simulate a realisation using simTimes
times = seq(0,100,by=0.1)
plot(ts(simTimes(c(x1=50,x2=100),0,times,stepLV),start=0,deltat=0.1),plot.type="single",lty=1:2)
# simulate a realisation at irregular times
times = c(0,10,20,50,100)
out2 = simTimes(c(x1=50,x2=100),0,times,stepLV)
print(out2)
</code></pre>

<hr>
<h2 id='StepGillespie1D'>Create a function for advancing the state of an SPN by using the
Gillespie algorithm on a 1D regular grid</h2><span id='topic+StepGillespie1D'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model
using the Gillespie algorithm. The resulting function (closure) can be
used in conjunction with other functions (such as <code><a href="#topic+simTs1D">simTs1D</a></code>)
for simulating realisations of SPN models in space and time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepGillespie1D(N,d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepGillespie1D_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net (SPN). Should contain <code>N$Pre</code>, a matrix representing
the LHS stoichiometries, <code>N$Post</code>, a matrix representing the
RHS stoichiometries, and <code>N$h</code>, a function representing the
rates of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the
current state of the system, and
second
argument <code>t</code>, a scalar representing the current simulation time
(in the typical time-homogeneous case, <code>N$h</code> will ignore this
argument).
<code>N$h</code> may possess additional arguments, representing reaction
rates, for example. <code>N</code> does not need to contain an initial
marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions
which use the resulting function closure.</p>
</td></tr>
<tr><td><code id="StepGillespie1D_+3A_d">d</code></td>
<td>
<p>A vector of diffusion coefficients - one coefficient for each
reacting species, in order. The coefficient is the reaction rate for a
reaction for a molecule moving into an adjacent compartment. The hazard
for a given molecule leaving the compartment is therefore twice this
value (as it can leave to the left or the right).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model
<code>N</code> by using the Gillespie algorithm. The function closure has
interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> is a matrix
with rows corresponding to species and columns corresponding to voxels,
representing the initial condition, <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a matrix representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie">StepGillespie</a></code>,
<code><a href="#topic+simTs1D">simTs1D</a></code>, <code><a href="#topic+StepGillespie2D">StepGillespie2D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(spnModels)
N=20; T=30
x0=matrix(0,nrow=2,ncol=N)
rownames(x0)=c("x1","x2")
x0[,round(N/2)]=LV$M
stepLV1D = StepGillespie1D(LV,c(0.6,0.6))
xx = simTs1D(x0,0,T,0.2,stepLV1D,verb=TRUE)
op=par(mfrow=c(1,2))
image(xx[1,,],main="Prey",xlab="Space",ylab="Time")
image(xx[2,,],main="Predator",xlab="Space",ylab="Time")
par(op)

</code></pre>

<hr>
<h2 id='StepGillespie2D'>Create a function for advancing the state of an SPN by using the
Gillespie algorithm on a 2D regular grid</h2><span id='topic+StepGillespie2D'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model
using the Gillespie algorithm. The resulting function (closure) can be
used in conjunction with other functions (such as <code><a href="#topic+simTs2D">simTs2D</a></code>)
for simulating realisations of SPN models in space and time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepGillespie2D(N,d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepGillespie2D_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net (SPN). Should contain <code>N$Pre</code>, a matrix representing
the LHS stoichiometries, <code>N$Post</code>, a matrix representing the
RHS stoichiometries, and <code>N$h</code>, a function representing the
rates of the reaction processes. <code>N$h</code> should have
first argument <code>x</code>, a vector representing the
current state of the system, and
second
argument <code>t</code>, a scalar representing the current simulation time
(in the typical time-homogeneous case, <code>N$h</code> will ignore this
argument).
<code>N$h</code> may possess additional arguments, representing reaction
rates, for example. <code>N</code> does not need to contain an initial
marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions
which use the resulting function closure.</p>
</td></tr>
<tr><td><code id="StepGillespie2D_+3A_d">d</code></td>
<td>
<p>A vector of diffusion coefficients - one coefficient for each
reacting species, in order. The coefficient is the reaction rate for a
reaction for a molecule moving into an adjacent compartment. The hazard
for a given molecule leaving the compartment is therefore four times this
value (as it can leave in one of 4 directions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model
<code>N</code> by using the Gillespie algorithm. The function closure has
interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> is a 3d array
with dimensions corresponding to species followed by two spatial dimensions,
representing the initial condition, <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns an array representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie">StepGillespie</a></code>,
<code><a href="#topic+simTs2D">simTs2D</a></code>, <code><a href="#topic+StepGillespie1D">StepGillespie1D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(spnModels)
m=20; n=30; T=10
x0=array(0,c(2,m,n))
dimnames(x0)[[1]]=c("x1","x2")
x0[,round(m/2),round(n/2)]=LV$M
stepLV2D = StepGillespie2D(LV,c(0.6,0.6))
xx = simTs2D(x0,0,T,0.2,stepLV2D,verb=TRUE)
N = dim(xx)[4]
op=par(mfrow=c(1,2))
image(xx[1,,,N],main="Prey",xlab="Space",ylab="Time")
image(xx[2,,,N],main="Predator",xlab="Space",ylab="Time")
par(op)
</code></pre>

<hr>
<h2 id='stepLVc'>A function for advancing the state of a Lotka-Volterra model by using the Gillespie algorithm</h2><span id='topic+stepLVc'></span>

<h3>Description</h3>

<p>A function for advancing the state of a Lotka-Volterra model by calling some C code implementing the Gillespie algorithm. The function can be used in conjunction with other functions (such as <code><a href="#topic+simTs">simTs</a></code>) for simulating realisations of Lotka-Volterra models. Should be functionally identical to the function obtained by <code>data(spnModels)</code>, <code>stepLV=StepGillespie(LV)</code>, but much faster. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepLVc(x0,t0,deltat,th=c(1,0.005,0.6))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepLVc_+3A_x0">x0</code></td>
<td>
<p>A vector representing the state of the system at the initial time, <code>t0</code>.</p>
</td></tr>
<tr><td><code id="stepLVc_+3A_t0">t0</code></td>
<td>
<p>The time corresponding to the initial state, <code>x0</code>.</p>
</td></tr>
<tr><td><code id="stepLVc_+3A_deltat">deltat</code></td>
<td>
<p>The time in advance of the initial time at which the new state is required.</p>
</td></tr>
<tr><td><code id="stepLVc_+3A_th">th</code></td>
<td>
<p>A vector of length 3 representing the rate constants associated with the 3 LV reactions. Defaults to <code>c(1,0.005,0.6)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-vector representing the new state of the LV system.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code>spnModels</code>, <code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+simSample">simSample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load the LV model
data(spnModels)
# create a stepping function
stepLV = StepGillespie(LV)
# step the function
print(stepLV(c(x1=50,x2=100),0,1))
# simulate a realisation of the process and plot it
out = simTs(c(x1=50,x2=100),0,100,0.1,stepLV)
plot(out)
# now use "stepLVc" instead...
out = simTs(c(x1=50,x2=100),0,100,0.1,stepLVc)
plot(out)
</code></pre>

<hr>
<h2 id='StepODE'>Create a function for advancing the state of an ODE model by using the deSolve package</h2><span id='topic+StepODE'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an ODE model
using an integration method from the <code><a href="deSolve.html#topic+deSolve">deSolve</a></code> package. The
resulting function (closure) can be used in conjunction with other
functions (such as <code><a href="#topic+simTs">simTs</a></code>) for simulating realisations of
ODE models. This function is used similarly to <code><a href="#topic+StepEuler">StepEuler</a></code>,
but <code><a href="#topic+StepODE">StepODE</a></code> should be more accurate and efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepODE(RHSfun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepODE_+3A_rhsfun">RHSfun</code></td>
<td>
<p>A function representing the RHS of the ODE model. <code>RHSfun</code> should have prototype <code>RHSfun(x,t,parms,...)</code>, with <code>t</code> representing current system time, <code>x</code> representing current system state and <code>parms</code> representing the model parameters. The value of the function should be a vector of the same dimension as <code>x</code>, representing the infinitesimal change in state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the ODE model
<code>RHSfun</code> by using an efficient ODE solver. The function closure has interface <code>function(x0,t0,deltat,parms,...)</code>, where <code>t0</code> and <code>x0</code> represent the initial time and state, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepEulerSPN">StepEulerSPN</a></code>, <code><a href="#topic+StepEuler">StepEuler</a></code>,
<code><a href="#topic+simTs">simTs</a></code>, <code><a href="deSolve.html#topic+ode">ode</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Build a RHS for the Lotka-Volterra system
LVrhs &lt;- function(x,t,parms)
{
        with(as.list(c(x,parms)),{
                c( c1*x1 - c2*x1*x2 ,
                      c2*x1*x2 - c3*x2 )
        })
}
# create a stepping function
stepLV = StepODE(LVrhs)
# step the function
print(stepLV(c(x1=50,x2=100),0,1,parms=c(c1=1,c2=0.005,c3=0.6)))
# integrate the process and plot it
out = simTs(c(x1=50,x2=100),0,50,0.1,stepLV,parms=c(c1=1,c2=0.005,c3=0.6))
plot(out,plot.type="single",lty=1:2)
</code></pre>

<hr>
<h2 id='StepPTS'>Create a function for advancing the state of an SPN by using a simple approximate Poisson time stepping method</h2><span id='topic+StepPTS'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SPN model using a simple approximate Poisson time stepping method. The resulting function (closure) can be used in conjunction with other functions (such as <code><a href="#topic+simTs">simTs</a></code>) for simulating realisations of SPN models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepPTS(N,dt=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepPTS_+3A_n">N</code></td>
<td>
<p>An R list with named components representing a stochastic
Petri net. Should contain <code>N$Pre</code>, a matrix representing the
LHS stoichiometries, <code>N$Post</code>, a matrix representing the RHS
stoichiometries, and <code>N$h</code>, a function representing the rates
of the reaction processes. <code>N$h</code> should have first argument
<code>x</code>, a vector representing the current state of the system, second argument
<code>t</code>, a scalar representing the current simulation time (in the
typical time-homogeneous case, <code>N$h</code> will ignore this argument).
<code>N$h</code> may posses additional arguments, representing reaction rates, for example. <code>N</code> does not need to contain an initial marking, <code>N$M</code>. <code>N$M</code> will be ignored by most functions which use the resulting function closure.</p>
</td></tr>
<tr><td><code id="StepPTS_+3A_dt">dt</code></td>
<td>
<p>Time step to be used by the Poisson time stepping integration method. Defaults to 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SPN model <code>N</code> by using a Poisson time stepping method with step size <code>dt</code>. The function closure has interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> and <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepGillespie">StepGillespie</a></code>, <code><a href="#topic+StepCLE">StepCLE</a></code>, <code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+simSample">simSample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load up the LV model
data(spnModels)
# create a stepping function
stepLV=StepPTS(LV)
# step the function
print(stepLV(c(x1=50,x2=100),0,1))
# integrate the process and plot it
out = simTs(c(x1=50,x2=100),0,20,0.1,stepLV)
plot(out)
plot(out,plot.type="single",lty=1:2)
</code></pre>

<hr>
<h2 id='StepSDE'>Create a function for advancing the state of an SDE model by using a simple Euler-Maruyama integration method</h2><span id='topic+StepSDE'></span>

<h3>Description</h3>

<p>This function creates a function for advancing the state of an SDE model using a simple Euler-Maruyama integration method. The resulting function (closure) can be used in conjunction with other functions (such as <code><a href="#topic+simTs">simTs</a></code>) for simulating realisations of SDE models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepSDE(drift,diffusion,dt=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepSDE_+3A_drift">drift</code></td>
<td>
<p>A function representing the drift vector of the SDE model
(corresponding roughly to the RHS of an ODE model). <code>drift</code>
should have prototype <code>drift(x,t,...)</code>, with
<code>x</code> representing current system state and
<code>t</code> representing current system time.
The value of the function should be a vector of the same dimension as <code>x</code>, representing the infinitesimal mean of the Ito SDE.</p>
</td></tr>
<tr><td><code id="StepSDE_+3A_diffusion">diffusion</code></td>
<td>
<p>A function representing the diffusion matrix of the SDE model (the square root of the infinitesimal variance matrix). <code>diffusion</code> should have prototype <code>diffusion(x,t,...)</code>, with <code>x</code> representing current system state and <code>t</code> representing current system time. The value of the function should be a square matrix with both dimensions the same as the length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="StepSDE_+3A_dt">dt</code></td>
<td>
<p>Time step to be used by the simple Euler-Maruyama integration method. Defaults to 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R function which can be used to advance the state of the SDE model with given drift vector and diffusion matrix, by using an Euler-Maruyama method with step size <code>dt</code>. The function closure has interface <code>function(x0,t0,deltat,...)</code>, where <code>x0</code> and <code>t0</code> represent the initial state and time, and <code>deltat</code> represents the amount of time by which the process should be advanced. The function closure returns a vector representing the simulated state of the system at the new time.</p>


<h3>See Also</h3>

<p><code><a href="#topic+StepEuler">StepEuler</a></code>, <code><a href="#topic+StepCLE">StepCLE</a></code>, <code><a href="#topic+simTs">simTs</a></code>, <code><a href="#topic+simSample">simSample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Immigration-death diffusion approx with death rate a CIR process
myDrift &lt;- function(x,t,th=c(lambda=1,alpha=1,mu=0.1,sigma=0.1))
     {
             with(as.list(c(x,th)),{
                     c( lambda - x*y ,
                           alpha*(mu-y) )
             })
     }
myDiffusion &lt;- function(x,t,th=c(lambda=1,alpha=1,mu=0.1,sigma=0.1))
     {
             with(as.list(c(x,th)),{
                     matrix(c( sqrt(lambda + x*y) , 0,
                           0, sigma*sqrt(y) ),ncol=2,nrow=2,byrow=TRUE)
             })
     }
# create a stepping function
stepProc = StepSDE(myDrift,myDiffusion)
# integrate the process and plot it
out = simTs(c(x=5,y=0.1),0,20,0.1,stepProc)
plot(out)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
