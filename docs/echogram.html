<!DOCTYPE html><html lang="en"><head><title>Help for package echogram</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {echogram}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.echogram'>
<p>Add two echograms</p></a></li>
<li><a href='#bottom.hac'>
<p>Read detected bottom range from an HAC file</p></a></li>
<li><a href='#echo.noise'>
<p>Sample echogram data (120 kHz)</p></a></li>
<li><a href='#echogram'>
<p>Echogram visualisation</p></a></li>
<li><a href='#join.echogram'>
<p>Merge echograms</p></a></li>
<li><a href='#mask.echogram'>
<p>Mask an echogram</p></a></li>
<li><a href='#match.echogram'>
<p>Match ping times from two echograms</p></a></li>
<li><a href='#mergeSvmat'>
<p>Merge inequal Sv data matrices</p></a></li>
<li><a href='#navigation.hac'>
<p>Compute bearing, navigated distance and speed</p></a></li>
<li><a href='#noise.echogram'>
<p>Modelling ambient noise in echograms</p></a></li>
<li><a href='#palette.echogram'>
<p>Design color palettes for echograms</p></a></li>
<li><a href='#position.hac'>
<p>Read geographic position data from an HAC file</p></a></li>
<li><a href='#read.echogram'>
<p>Read echogram data from an HAC file</p></a></li>
<li><a href='#sample.echogram'>
<p>Select and sample data values from an echogram</p></a></li>
<li><a href='#trim.echogram'>
<p>Trim an echogram vertically or horizontally</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Echogram Visualisation and Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-15</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Héctor Villalobos [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Héctor Villalobos &lt;hvillalo@ipn.mx&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Easily import multi-frequency acoustic data stored in 'HAC' files (see <a href="http://biblio.uqar.ca/archives/30005500.pdf">http://biblio.uqar.ca/archives/30005500.pdf</a> for more information on the format), and produce echogram visualisations with predefined or customized color palettes. It is also possible to merge consecutive echograms; mask or delete unwanted echogram areas; model and subtract background noise; and more important, develop, test and interpret different combinations of frequencies in order to perform acoustic filtering of the echogram's data. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hvillalo/echogram">https://github.com/hvillalo/echogram</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hvillalo/echogram/issues">https://github.com/hvillalo/echogram/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>geosphere, readHAC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-15 23:51:05 UTC; hecvi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-16 05:30:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.echogram'>
Add two echograms
</h2><span id='topic+add.echogram'></span>

<h3>Description</h3>

<p>This function allows addition or subtraction of Sv data matrices of corresponding echograms from two frequencies in the linear or logarithmic domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.echogram(echogram1, echogram2, operator = c("plus", "minus"), 
    domain = c("linear", "dB"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.echogram_+3A_echogram1">echogram1</code></td>
<td>
<p>an object of <code>class</code> &ldquo;echogram&rdquo; as returned by <code><a href="#topic+read.echogram">read.echogram</a></code>.</p>
</td></tr>
<tr><td><code id="add.echogram_+3A_echogram2">echogram2</code></td>
<td>
<p>an object of <code>class</code> &ldquo;echogram&rdquo; from a different acoustic frequency than <code>echogram1</code> above.</p>
</td></tr>
<tr><td><code id="add.echogram_+3A_operator">operator</code></td>
<td>
<p> a string indicating addition (&ldquo;plus&rdquo;) or subtraction (&ldquo;minus&rdquo;). May be abbreviatted. </p>
</td></tr>
<tr><td><code id="add.echogram_+3A_domain">domain</code></td>
<td>
<p> a string indicating the domain where the operation will be performed (see details). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Corresponding echograms refers to data acquired at the same time with different acoustic frequencies. In order to add echograms, the Sv data matrices must have the same dimensions. If they don't, <code><a href="#topic+match.echogram">match.echogram</a></code> can be used for this purpose. It is also important to mask undesired echoes beforehand, as those belonging  to the bottom and below. When <code>domain = "dB"</code> (the default), the Sv matrices are added as they are. When <code>domain = "linear"</code>, the Sv values are transformed with 10^(Sv/10) before addition, and the result (X) is then back transformed to dB (10*log10(X)).
</p>


<h3>Value</h3>

<p>An object of <code>class</code> &ldquo;echogram&rdquo; where the Sv component is the result of  the performed operation.
</p>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.echogram">match.echogram</a></code>, <code><a href="#topic+mask.echogram">mask.echogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import 38 and 120 kHz data from an HAC file 
hacfile &lt;- system.file("hac", "D20150510-T202500.hac", package = "echogram")
echo2.038 &lt;- read.echogram(hacfile, channel = 1)
echo2.120 &lt;- read.echogram(hacfile, channel = 2)

## Not run: 
# attempting to add the two frequencies with unequal number of pings gives an error
add.echogram(echo2.038, echo2.120, "plus", "dB")

## End(Not run)

# running match.echogram() solves this
tmp &lt;- match.echogram(echo2.038, echo2.120)
str(tmp) # both frequencies are in a list, need to split
echo2.038 &lt;- tmp$echogram1
echo2.120 &lt;- tmp$echogram2

# we don't want to add bottom echoes, mask bottom and surface from both frequencies
echo2.038m &lt;- mask.echogram(echo2.038, surf.off = 2, bott.off = 0.2)
echo2.120m &lt;- mask.echogram(echo2.120, surf.off = 2, bott.off = 0.2)

# adding Sv values and plot result
echo.sum &lt;- add.echogram(echo2.038m, echo2.120m, "plus", "dB")
Min &lt;- min(as.vector(echo.sum$Sv), na.rm=TRUE) # useful to set Sv threshold
echogram(echo.sum, Svthr=floor(Min), scheme = "EK500")

# subtract 38 from 120 kHz
echo.minus &lt;- add.echogram(echo2.120m, echo2.038m, "minus", "dB")
Min &lt;- min(as.vector(echo.minus$Sv), na.rm=TRUE)
echogram(echo.minus, Svthr=floor(Min), scheme = "EK500")
</code></pre>

<hr>
<h2 id='bottom.hac'>
Read detected bottom range from an HAC file
</h2><span id='topic+bottom.hac'></span>

<h3>Description</h3>

<p>This function imports, for a given acoustic channel, the detected bottom range stored in the ping tuple of an HAC file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bottom.hac(hac, channel = NULL, plot = FALSE, maxDepth = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bottom.hac_+3A_hac">hac</code></td>
<td>
<p> name of an HAC file. </p>
</td></tr>
<tr><td><code id="bottom.hac_+3A_channel">channel</code></td>
<td>
<p> acoustic channel number. </p>
</td></tr>
<tr><td><code id="bottom.hac_+3A_plot">plot</code></td>
<td>
<p> logical. if <code>TRUE</code> a plot is produced. </p>
</td></tr>
<tr><td><code id="bottom.hac_+3A_maxdepth">maxDepth</code></td>
<td>
<p> maximum depth (in m) represented in the plot. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The acoustic channel is an integer, normally between 1 and <code>n</code>, where <code>n</code> is the number of frequencies used during data acquisition. When <code>channel = 1</code>, data from the lowest acoustic frequency is imported, while <code>channel = n</code> refers to the highest frequency present in the HAC file. By default, the function finds out the smallest channel number, because in some HAC files <code>channel = 0</code>. When a graphical representation is desired (<code>plot = TRUE</code>), the maximum displayed in the echogram depth can be provided as a negative integer with argument <code>maxDepth</code>.
</p>


<h3>Value</h3>

<p>A data frame with two variables where every row represents one emitted ping:
</p>
<table role = "presentation">
<tr><td><code>pingTime</code></td>
<td>
<p>time of emitted ping.</p>
</td></tr>
<tr><td><code>detBottom</code></td>
<td>
<p>detected depth range in m.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hacfile &lt;- system.file("hac", "D20150510-T202221.hac", package="echogram")
bottom.hac( hacfile )
bottom.hac( hacfile, plot = TRUE )
</code></pre>

<hr>
<h2 id='echo.noise'>
Sample echogram data (120 kHz)
</h2><span id='topic+echo.noise'></span>

<h3>Description</h3>

<p>Echogram for background noise estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("echo.noise")</code></pre>


<h3>Details</h3>

<p>For this echogram, recording range (500 m) has been set above the sea bottom, and there is no evident presence of biological scatteres in order to facilitate the background noise estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("echo.noise")
echogram(echo.noise)
</code></pre>

<hr>
<h2 id='echogram'>
Echogram visualisation 
</h2><span id='topic+echogram'></span>

<h3>Description</h3>

<p>This function allows to produce echogram visualisations from imported hac data. The user can define the visualisation Sv threshold and select between two built-in color schemes or define a custom scheme.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>echogram(echogram, xref = c("ping", "distance", "time"), scheme = "echov", 
  Svthr = -80, Svmax = NULL, col.sep = 1, colbar = TRUE, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="echogram_+3A_echogram">echogram</code></td>
<td>
<p>an object of <code>class</code> &ldquo;echogram&rdquo; as returned by <code><a href="#topic+read.echogram">read.echogram</a></code>.</p>
</td></tr>
<tr><td><code id="echogram_+3A_xref">xref</code></td>
<td>
<p> horizontal reference in echogram: &ldquo;ping&rdquo; (the default), &ldquo;distance&rdquo; or &ldquo;time&rdquo;.</p>
</td></tr>
<tr><td><code id="echogram_+3A_scheme">scheme</code></td>
<td>
<p> color scheme for echogram, either: &ldquo;echov&rdquo; (the default) or &ldquo;EK500&rdquo;. It can also be a vector of valid color names.</p>
</td></tr>
<tr><td><code id="echogram_+3A_svthr">Svthr</code></td>
<td>
<p> Sv visualisation threshold, in decibels (dB). </p>
</td></tr>
<tr><td><code id="echogram_+3A_svmax">Svmax</code></td>
<td>
<p> maximum Sv visualisation value, in dB. </p>
</td></tr>
<tr><td><code id="echogram_+3A_col.sep">col.sep</code></td>
<td>
<p> separation between colors in dB.</p>
</td></tr>
<tr><td><code id="echogram_+3A_colbar">colbar</code></td>
<td>
<p> logical. If <code>TRUE</code> a color bar is added to the echogram. </p>
</td></tr>
<tr><td><code id="echogram_+3A_main">main</code></td>
<td>
<p> the acoustic frequency, by default.</p>
</td></tr>
<tr><td><code id="echogram_+3A_...">...</code></td>
<td>
<p>other options to <code>image</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Besides the two built-in color schemes, the user can define its own by specifying a vector of valid color names (see examples). This function uses <code>imageScale</code> function from <code>sinkr</code> package by Marc Taylor.
</p>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+palette.echogram">palette.echogram</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import hac file
hacfile &lt;- system.file("hac", "D20150510-T202500.hac", package = "echogram")
echo2.038 &lt;- read.echogram(hacfile)

# echogram by default 
echogram(echo2.038)

# using alternative color schemes
echogram(echo2.038, Svthr = -70, col.sep = 1.5, scheme = "EK500")
echogram(echo2.038, Svthr = -70, col.sep = 3, scheme = c("white", "blue", "grey", "black"))
</code></pre>

<hr>
<h2 id='join.echogram'>
Merge echograms
</h2><span id='topic+join.echogram'></span>

<h3>Description</h3>

<p>This function allows to join two echograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join.echogram(echogram1, echogram2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join.echogram_+3A_echogram1">echogram1</code></td>
<td>
<p>an object of <code>class</code> &ldquo;echogram&rdquo; as returned by <code><a href="#topic+read.echogram">read.echogram</a></code>. </p>
</td></tr>
<tr><td><code id="join.echogram_+3A_echogram2">echogram2</code></td>
<td>
<p>an object of <code>class</code> &ldquo;echogram&rdquo;, preferentially contiguous in space and time with <code>echogram1</code> above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to join echograms of the same acoustic frequency, giving an error if frequencies differ. Desirably, echograms should be contiguous in space and time, but as this is not verified, it is possible to join non-contiguous echograms.
</p>


<h3>Value</h3>

<p>An object of <code>class</code> &ldquo;echogram&rdquo; resulting from the merging operation.
</p>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import 38 kHz data from two consecutive HAC files
hacfile1 &lt;- system.file("hac", "D20150510-T202221.hac", package = "echogram")
echo1.038 &lt;- read.echogram(hacfile1, channel = 1)

hacfile2 &lt;- system.file("hac", "D20150510-T202500.hac", package = "echogram")
echo2.038 &lt;- read.echogram(hacfile2, channel = 1)

# join into one echogram
echo.038 &lt;- join.echogram(echo1.038, echo2.038)
str(echo.038)
echogram(echo.038)
</code></pre>

<hr>
<h2 id='mask.echogram'>
Mask an echogram
</h2><span id='topic+mask.echogram'></span>

<h3>Description</h3>

<p>This function creates, and optionally applies, a mask by &ldquo;blanking&rdquo; portions of the Sv data matrix of an echogram. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask.echogram(echogram, surf.off = NULL, bott.off = NULL, mask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mask.echogram_+3A_echogram">echogram</code></td>
<td>
<p> an object of <code>class</code> &ldquo;echogram&rdquo; as returned by <code><a href="#topic+read.echogram">read.echogram</a></code>. </p>
</td></tr>
<tr><td><code id="mask.echogram_+3A_surf.off">surf.off</code></td>
<td>
<p> surface offset in m defining the upper layer (refered to the surface) to be masked. </p>
</td></tr>
<tr><td><code id="mask.echogram_+3A_bott.off">bott.off</code></td>
<td>
<p> bottom offset in m defining the bottom layer (refered to the bottom) to be masked. </p>
</td></tr>
<tr><td><code id="mask.echogram_+3A_mask">mask</code></td>
<td>
<p> logical. If <code>FALSE</code>, the function returns a masking matrix. If <code>TRUE</code> (the default), the function returns a masked echogram (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The masking process consists in producing a matrix of the same dimensions as the original Sv data matrix with <code>NA</code>'s in the masked portion and 1's otherwise. The product of both matrices gives the masked echogram.
</p>


<h3>Value</h3>

<p>When <code>mask = FALSE</code>, a masking matrix is returned. When <code>mask = TRUE</code> (the default), an object of <code>class</code> &ldquo;echogram&rdquo; with the mask applied.
</p>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import 38 kHz data from HAC file
hacfile &lt;- system.file("hac", "D20150510-T202500.hac", package = "echogram")
echo2.038 &lt;- read.echogram(hacfile, channel = 1)

# make a copy of the original echogram
tmp &lt;- echo2.038

# Create a mask, which is a matrix with 1's and NA's 
mask &lt;- mask.echogram(tmp, surf.off = 1, bott.off = -1, mask = FALSE)
image(t(mask[nrow(mask):1, ])) 

# Apply mask to echogram
tmp$Sv &lt;- tmp$Sv * mask 
echogram(tmp)

# By default, the function returns the masked echogram
echo2.038mask &lt;- mask.echogram(echo2.038, surf.off = 2, bott.off = 0.2)
echogram(echo2.038mask)
</code></pre>

<hr>
<h2 id='match.echogram'>
Match ping times from two echograms
</h2><span id='topic+match.echogram'></span>

<h3>Description</h3>

<p>This function verifies ping times between corresponding echograms from two frequencies, eliminating non-matching and duplicated pings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.echogram(echogram1, echogram2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.echogram_+3A_echogram1">echogram1</code></td>
<td>
<p>an object of <code>class</code> &ldquo;echogram&rdquo; as returned by <code><a href="#topic+read.echogram">read.echogram</a></code>. </p>
</td></tr>
<tr><td><code id="match.echogram_+3A_echogram2">echogram2</code></td>
<td>
<p>an object of <code>class</code> &ldquo;echogram&rdquo; from a different acoustic frequency than <code>echogram1</code> above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Corresponding echograms refers to data acquired at the same time with different acoustic frequencies. Unmatching pings, i.e. those present in only one frequency, and duplicated pings, are identified by it's associated time and subsequently eliminated.
</p>


<h3>Value</h3>

<p>A list with the two matched echograms.
</p>


<h3>Author(s)</h3>

<p>Héctor Villalobos and Violeta E. González-Maynez
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+add.echogram">add.echogram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import 38 and 120 kHz data from an HAC file 
hacfile &lt;- system.file("hac", "D20150510-T202221.hac", package = "echogram")
echo1.038 &lt;- read.echogram(hacfile, channel = 1)
echo1.120 &lt;- read.echogram(hacfile, channel = 2)

# Sv matrices have different number of pings
dim(echo1.038$Sv); dim(echo1.120$Sv)

# Apply match ping times
tmp &lt;- match.echogram(echo1.038, echo1.120)

# split the list in the two echograms 
echo1.038 &lt;- tmp$echogram1
echo1.120 &lt;- tmp$echogram2

# number of pings and ping times are now the same for both frequencies
dim(echo1.038$Sv); dim(echo1.120$Sv)
</code></pre>

<hr>
<h2 id='mergeSvmat'>
Merge inequal Sv data matrices
</h2><span id='topic+mergeSvmat'></span>

<h3>Description</h3>

<p>Internal function called by <code>read.echogram</code> and <code>merge.echogram</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeSvmat(m1, m2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeSvmat_+3A_m1">m1</code></td>
<td>

<p>First Sv data matrix.
</p>
</td></tr>
<tr><td><code id="mergeSvmat_+3A_m2">m2</code></td>
<td>

<p>Second Sv data matrix.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>

<hr>
<h2 id='navigation.hac'>
Compute bearing, navigated distance and speed
</h2><span id='topic+navigation.hac'></span>

<h3>Description</h3>

<p>This function computes navigation course (bearing), navigated distance, time diference and navigation speed between GPS fixes in position data imported from an HAC file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>navigation.hac(pos)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="navigation.hac_+3A_pos">pos</code></td>
<td>
<p> geographic position data from an HAC file, as imported with <code>position.hac</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bearing and navigated distance are computed with functions  <code>bearingRhumb</code> and <code>distVincentyEllipsoid</code>  from package <code>geosphere</code>. This function is intended to be called inside <code>read.echogram</code>, rather than being used directly.
</p>


<h3>Value</h3>

<p>A data frame with seven variables:
</p>
<table role = "presentation">
<tr><td><code>time.cpu</code></td>
<td>
<p>date and time from the computer CPU during data acquisition.</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>longitudes.</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>latitudes.</p>
</td></tr>
<tr><td><code>bearing</code></td>
<td>
<p>navigation course between two consecutive GPS fixes.</p>
</td></tr>
<tr><td><code>navdist</code></td>
<td>
<p>navigated distance between two consecutive GPS fixes.</p>
</td></tr>
<tr><td><code>time.dif</code></td>
<td>
<p>time difference between two consecutive GPS fixes.</p>
</td></tr>
<tr><td><code>navspeed</code></td>
<td>
<p>navigation speed between two consecutive GPS fixes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+position.hac">position.hac</a></code>, <code>bearingRhumb</code>, <code>distVincentyEllipsoid</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> hacfile &lt;- system.file("hac", "D20150510-T202221.hac", package="echogram")
 pos &lt;- position.hac( hacfile )
 pos
 pos2 &lt;- navigation.hac(pos)
 pos2
</code></pre>

<hr>
<h2 id='noise.echogram'>
Modelling ambient noise in echograms 
</h2><span id='topic+noise.echogram'></span>

<h3>Description</h3>

<p>This function allows to estimate a model of the background noise in an echogram by fitting the equation proposed by De Robertis and Higginbottom (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise.echogram(echogram, ping = NULL, dB1m = NULL, alpha = NULL, plot = TRUE, out = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise.echogram_+3A_echogram">echogram</code></td>
<td>
<p>an object of <code>class</code> &ldquo;echogram&rdquo;.</p>
</td></tr>
<tr><td><code id="noise.echogram_+3A_ping">ping</code></td>
<td>
<p> ping number for which the Sv values are to be modeled.</p>
</td></tr>
<tr><td><code id="noise.echogram_+3A_db1m">dB1m</code></td>
<td>
<p> noise level at 1m from the face of the transducer.</p>
</td></tr>
<tr><td><code id="noise.echogram_+3A_alpha">alpha</code></td>
<td>
<p> absortion coefficient of sound in sea water for echogram's frequency. </p>
</td></tr>
<tr><td><code id="noise.echogram_+3A_plot">plot</code></td>
<td>
<p> logical. If  <code>TRUE</code> (the default) a plot of the data and adjusted model is produced.</p>
</td></tr>
<tr><td><code id="noise.echogram_+3A_out">out</code></td>
<td>
<p> logical. If  <code>TRUE</code> an echogram with the modeled noise is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation of an ambient noise model for a particular acoustic frequency, eventually allows the &ldquo;cleaning&rdquo; of echograms by subtracting this noise. 
</p>


<h3>Value</h3>

<p>When <code>plot = TRUE</code> and <code>out = FALSE</code> (the default), only a plot is produced. With <code>out = TRUE</code>, the function returns an object of  <code>class</code> &ldquo;echogram&rdquo; with the noise modelled.
</p>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>References</h3>

<p>De Robertis, A. and I. Higginbottom. 2007. A post-processing technique to estimate the signal-to-noise ratio and remove echosounder background noise 64:1282–1291.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load echogram for noise estimation at 120 kHz (deep waters, no scatterers)
data("echo.noise")
attr(echo.noise$Sv, "frequency")
echogram(echo.noise, xref = "ping")

# a first look to the Sv values at ping 2
noise.echogram(echo.noise, ping = 2)

# To better adjust the model, we need to provide the absortion coefficient for 120 kHz and adjust
# the dB1m parameter. For this example, using data from a nearby CTD profile, alpha was calculated
# as being 0.03550554, while -131 dB is choosen for dB1m
noise &lt;- noise.echogram(echo.noise, ping = 2, dB1m = -131, alpha = 0.03550554, out = TRUE)
echogram(noise)
</code></pre>

<hr>
<h2 id='palette.echogram'>
Design color palettes for echograms
</h2><span id='topic+palette.echogram'></span>

<h3>Description</h3>

<p>This function allows to design and visualise color palettes to be used in echograms. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette.echogram(Svthr = -70, Svmax = 0, col.sep = 1, scheme = "echov", visu = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="palette.echogram_+3A_svthr">Svthr</code></td>
<td>
<p>lower visualisation limit in decibels (dB).</p>
</td></tr>
<tr><td><code id="palette.echogram_+3A_svmax">Svmax</code></td>
<td>
<p>upper visualisation limit in dB.</p>
</td></tr>
<tr><td><code id="palette.echogram_+3A_col.sep">col.sep</code></td>
<td>
<p>separation between colors in dB.</p>
</td></tr>
<tr><td><code id="palette.echogram_+3A_scheme">scheme</code></td>
<td>
<p>color scheme for echogram, either: &ldquo;echov&rdquo; (the default) or &ldquo;EK500&rdquo;. It can also be a vector of valid color names.</p>
</td></tr>
<tr><td><code id="palette.echogram_+3A_visu">visu</code></td>
<td>
<p>logical. If <code>TRUE</code>, a visual representation of the palette is created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly intended to be called by <code>plot.echogram</code>, however it is possible to use it directly in order to have a first impression of a custom color palette.</p>


<h3>Value</h3>

<p>A list with two elements
</p>
<table role = "presentation">
<tr><td><code>palette</code></td>
<td>
<p>a vector of colors</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>a vector of color breaks</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+echogram">echogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>palette.echogram()
palette.echogram(Svthr=-75, col.sep=1.5, scheme="EK500", visu=TRUE)
palette.echogram(Svthr=-81, col.sep=3, scheme=c("white", "blue", "black"), visu=TRUE)
</code></pre>

<hr>
<h2 id='position.hac'>
Read geographic position data from an HAC file
</h2><span id='topic+position.hac'></span>

<h3>Description</h3>

<p>This function imports time and geographic positions recorded by a GPS in an HAC file during data acquisition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> position.hac(hac)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="position.hac_+3A_hac">hac</code></td>
<td>
<p> name of an HAC file </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function looks for the Position tuple (20) in the HAC file, and if found, imports the time, latitude and longitude of GPS fixes stored in the digital echogram, as well as the CPU time of the acquisition PC.  
</p>


<h3>Value</h3>

<p>A data frame with four variables:
</p>
<table role = "presentation">
<tr><td><code>time.gps</code></td>
<td>
<p>date and time from the GPS during data acquisition.</p>
</td></tr>
<tr><td><code>time.cpu</code></td>
<td>
<p>date and time from the computer CPU during data acquisition.</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>longitudes.</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>latitudes.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If during acoustic data acqusition the PC clock is set to UTC time, as recomended, time.gps and time.cpu will be approximately equal, because a fraction of a second is added to time.cpu to obtain a precision of 0.0001 s.
</p>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>References</h3>

<p>ICES, 2005. Description of the ICES HAC Standard Data Exchange Format, Version 1.60. Technical Report 278, ICES Cooperative Research Report.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+navigation.hac">navigation.hac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> hacfile &lt;- system.file("hac", "D20150510-T202221.hac", package="echogram")
 pos &lt;- position.hac( hacfile )
 pos
</code></pre>

<hr>
<h2 id='read.echogram'>
Read echogram data from an HAC file
</h2><span id='topic+read.echogram'></span>

<h3>Description</h3>

<p>This function imports from different tuples in the HAC file, the necessary information to visualise and analyse an echogram in R. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> read.echogram(hac, channel = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.echogram_+3A_hac">hac</code></td>
<td>
<p> name of an HAC file. </p>
</td></tr>
<tr><td><code id="read.echogram_+3A_channel">channel</code></td>
<td>
<p> acoustic channel number. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls internally other <code>echogram</code>'s functions (<code>postion.hac</code>, <code>navigation.hac</code> and <code>bottom.hac</code>) to import data from an HAC file. The acoustic channel is an integer, normally between 1 and <code>n</code>, where <code>n</code> is the number of frequencies used during data acquisition. When <code>channel = 1</code>, data from the lowest acoustic frequency is imported, while <code>channel = n</code> refers to the highest frequency present in the HAC file. By default, the function finds out the smallest channel number, because in some HAC files <code>channel = 0</code>.  A text string with the frequency value (in kilohertz) is stored as an attribute of the Sv matrix (see examples below). 
</p>


<h3>Value</h3>

<p>An object of  <code>class</code> &ldquo;echogram&rdquo; (a list) with components:
</p>
<table role = "presentation">
<tr><td><code>depth</code></td>
<td>
<p>a vector of mean sample depth (in m) of length p.</p>
</td></tr>
<tr><td><code>Sv</code></td>
<td>
<p>a p by k matrix of sampled values, currently the mean volume backscattering strength (Sv, in dB).</p>
</td></tr>
<tr><td><code>pings</code></td>
<td>
<p>a k by four data frame with ping time, detected bottom depth, vessel speed and cummulated traveled distance.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, <code>read.echogram</code> has been successfully tested importing HAC data from the following ping tuples: 10000 (U-32); 10030 (U-16) and 10040 (C-16).
</p>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>References</h3>

<p>ICES, 2005. Description of the ICES HAC Standard Data Exchange Format, Version 1.60. Technical Report 278, ICES Cooperative Research Report.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hacfile &lt;- system.file("hac", "D20150510-T202221.hac", package = "echogram")
echo1 &lt;- read.echogram(hacfile, channel = 1)
class(echo1)
str(echo1)
attr(echo1$Sv, "frequency")
echogram(echo1)
</code></pre>

<hr>
<h2 id='sample.echogram'>
Select and sample data values from an echogram
</h2><span id='topic+sample.echogram'></span>

<h3>Description</h3>

<p>This function allows to select individual pixels from an echogram and returns the Sv value, ping time and depth of the sampled pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.echogram(echogram, plot = TRUE, coords = NULL, col = "black") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample.echogram_+3A_echogram">echogram</code></td>
<td>
<p>an object of <code>class</code> &ldquo;echogram&rdquo; as returned by <code><a href="#topic+read.echogram">read.echogram</a></code>.</p>
</td></tr>
<tr><td><code id="sample.echogram_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default), the echogram to be sampled is plotted. </p>
</td></tr>
<tr><td><code id="sample.echogram_+3A_coords">coords</code></td>
<td>
<p> (x, y) coordinates (in plot units) of the desired samples. They could result from previous sampling of another frequency. </p>
</td></tr>
<tr><td><code id="sample.echogram_+3A_col">col</code></td>
<td>
<p> color for the sampled points pixels. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selection of pixels to sample can be done by clicking on the echogram or by passing the coordinates of the desired pixels to the function. The coordinates should be in plot units, and therefore, these typically come from a previous selection by clicking on another frequency's echogram (see examples). 
</p>
<p><code>sample.echogram</code> makes use of <code>locator</code> function, and therefore it only works in devices supported by the latter, such as <code>X11</code>, <code>windows</code> and <code>quartz</code>.
</p>


<h3>Value</h3>

<p>A data frame with seven variables:
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p> pixel id. </p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> x coordinate in plot units. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> y coordinate in plot units. </p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p> distance in plot units from the selected location to a valid pixel. </p>
</td></tr>
<tr><td><code>pingTime</code></td>
<td>
<p> time of sampled  ping. </p>
</td></tr>
<tr><td><code>depth</code></td>
<td>
<p> depth of the sample. </p>
</td></tr>
<tr><td><code>Sv</code></td>
<td>
<p> Sv value. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import 38 and 120 kHz data from an HAC file 
hacfile &lt;- system.file("hac", "D20150510-T202500.hac", package = "echogram")
echo2.038 &lt;- read.echogram(hacfile, channel = 1)
echo2.120 &lt;- read.echogram(hacfile, channel = 2)

# plot 38 kHz echogram 
echogram(echo2.038)

## Not run:  
# select points coordinates with the mouse 
# click to select several locations and escape when done
pts038 &lt;- sample.echogram(echo2.038) 
pts038

# plot 120 kHz echogram 
echogram(echo2.120)

# use the points previously selected for 38 kHz
pts120 &lt;- sample.echogram(echo2.120, coords = pts038[ , 2:3])
pts120

## End(Not run)
</code></pre>

<hr>
<h2 id='trim.echogram'>
Trim an echogram vertically or horizontally
</h2><span id='topic+trim.echogram'></span>

<h3>Description</h3>

<p>This function allows to trim an echogram by depth or ping number by actually trimming the underlying data matrices and vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim.echogram(echogram, depth.max = NULL, ping.ini = 1, ping.end = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim.echogram_+3A_echogram">echogram</code></td>
<td>
<p> an object of <code>class</code> &ldquo;echogram&rdquo; as returned by <code><a href="#topic+read.echogram">read.echogram</a></code>. </p>
</td></tr>
<tr><td><code id="trim.echogram_+3A_depth.max">depth.max</code></td>
<td>
<p> maximum depth to keep in the echogram. </p>
</td></tr>
<tr><td><code id="trim.echogram_+3A_ping.ini">ping.ini</code></td>
<td>
<p> start ping to keep. </p>
</td></tr>
<tr><td><code id="trim.echogram_+3A_ping.end">ping.end</code></td>
<td>
<p> end ping to keep. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This funcion has been conceived to discard undesired data below a given depth (e.g. the sea bottom), therefore, the initial depth is always the surface, so the vertical trimming is limited to select the maximum depth.  
</p>


<h3>Value</h3>

<p>An object of  <code><a href="base.html#topic+class">class</a></code> &ldquo;echogram&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Héctor Villalobos
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import 38 kHz data from an HAC file 
hacfile &lt;- system.file("hac", "D20150510-T202500.hac", package = "echogram")
echo2.038 &lt;- read.echogram(hacfile, channel = 1)

# echogram by default
echogram(echo2.038)

# trim the echogram
echo.tmp &lt;- trim.echogram(echo2.038, depth.max = 70, ping.end = 250)
echogram(echo.tmp)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
