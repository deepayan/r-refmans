<!DOCTYPE html><html lang="en"><head><title>Help for package gramEvol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gramEvol}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#c'>
<p>Grammar Rule Concatenation</p></a></li>
<li><a href='#CreateGrammar'><p>Context-free Grammar Object</p></a></li>
<li><a href='#EvalExpressions'>
<p>Evaluate a collection of Expressions</p></a></li>
<li><a href='#EvolutionStrategy.int'>
<p>Evolution Strategy with Integer Chromosomes</p></a></li>
<li><a href='#GeneticAlg.int'>
<p>Genetic Algorithm with Integer Chromosomes</p></a></li>
<li><a href='#GrammarGetNextSequence'><p>Grammar Iterator</p></a></li>
<li><a href='#GrammarIsTerminal'>
<p>Non-terminal Phenotype test.</p></a></li>
<li><a href='#GrammarMap'>
<p>Sequence to Expression Mapping using Context-free Grammar</p></a></li>
<li><a href='#GrammarRandomExpression'><p>Random Expression Generation</p></a></li>
<li><a href='#GrammaticalEvolution'><p>Grammatical Evolution</p></a></li>
<li><a href='#GrammaticalExhaustiveSearch'><p>Exhaustive Search</p></a></li>
<li><a href='#GrammaticalRandomSearch'><p>Random Search</p></a></li>
<li><a href='#ReplaceInExpression'><p>Replace as sub-expression isnide an expression</p></a></li>
<li><a href='#summary'><p>Context-free Grammar Object Information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Grammatical Evolution for R</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-07-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Farzad Noorian, Anthony Mihirana de Silva</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Farzad Noorian &lt;farzad.noorian@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A native R implementation of grammatical evolution (GE).
    GE facilitates the discovery of programs that can achieve a desired goal.
    This is done by performing an evolutionary optimisation over a population
    of R expressions generated via a user-defined context-free grammar (CFG)
    and cost function.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fnoorian/gramEvol/">https://github.com/fnoorian/gramEvol/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fnoorian/gramEvol/issues">https://github.com/fnoorian/gramEvol/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>rex, knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-18 13:47:29 UTC; mint</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-18 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='c'>
Grammar Rule Concatenation
</h2><span id='topic+c.GERule'></span>

<h3>Description</h3>

<p>Concatenates two or more grammar rule objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'GERule'
c(..., recursive=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_+3A_...">...</code></td>
<td>

<p>Grammar rule objects to be concatenated.
</p>
</td></tr>
<tr><td><code id="c_+3A_recursive">recursive</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new grammar rule object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateGrammar">CreateGrammar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rule1 &lt;- grule(Func1, Func2)
rule2 &lt;- grule(`*`, `/`)

rule.all &lt;- c(rule1, rule2)

print(rule.all)
</code></pre>

<hr>
<h2 id='CreateGrammar'>Context-free Grammar Object</h2><span id='topic+CreateGrammar'></span><span id='topic+grule'></span><span id='topic+gsrule'></span><span id='topic+gvrule'></span><span id='topic+print.grammar'></span><span id='topic+print.GERule'></span>

<h3>Description</h3>

 
<p>Creates a context-free grammar object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  grule(...)

  gsrule(...)

  gvrule(vec)

  CreateGrammar(ruleDef, startSymb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateGrammar_+3A_...">...</code></td>
<td>

<p>A series of comma separated strings or expressions, for <code>gsrule</code> and
<code>grule</code> respectively. Expressions can be wrapped in <code>.()</code> to preserve their 
commas or assignment operators.
</p>
</td></tr>
<tr><td><code id="CreateGrammar_+3A_vec">vec</code></td>
<td>

<p>An iterable vector or list.
</p>
</td></tr>
<tr><td><code id="CreateGrammar_+3A_ruledef">ruleDef</code></td>
<td>

<p>Grammatical rule definition. Either a list of grammar rule objects (<code>GERule</code>) created using <code>grule</code> and <code>gsrule</code>
with a syntax similar to Backus-Naur form,
or a list of character strings representing symbols and sequences in Backus-Naur form,
or a filename or <code><a href="base.html#topic+connection">connection</a></code> to a .bnf file. 
</p>
<p>See details. 
</p>
</td></tr>
<tr><td><code id="CreateGrammar_+3A_startsymb">startSymb</code></td>
<td>

<p>The symbol where the generation of a new expression should start.
If not given, the first rule in <code>ruleDef</code> is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rule definition is the grammar described in Backus-Naur context-free grammatical format.
The preferred way of defining a grammar is to create a <code>list</code> simulating BNF format,
which collects several named grammar rule objects (<code>GERule</code>).
Each name defines the <em>non-terminal symbol</em>, and each rule 
in the collection determines the <em>production rule</em>, 
i.e., possible <em>sequences</em> that will replace the symbol.
</p>
<p>Defining a grammar rule object (<code>GERule</code>) can take three forms:
</p>
<p>1. The first form uses <code>grule</code> (Grammar Rule), where R expressions are accepted. In the mapping process,
variables are looked up and replaced using the production rules.
</p>
<p>2. The second form uses <code>gsrule</code> (Grammar String Rule) and uses character strings. The input to <code>gsrule</code> are character string values, where any value surrounded by '&lt;' or '&gt;' is considered as <em>non-terminal symbols</em> and
will be replaced using the rule with the same name in the mapping process. Other symbols are considered terminals. This form allows generation of sequences that are not syntactically valid in R (such as <code>`var op var`</code>).
</p>
<p>3. The third form uses <code>gvrule</code> (Grammar Vector Rule), where objects within an iterable (vector or list) containing all of the expressions are used as individual rules. 
</p>
<p>Alternatively, <code>CreateGrammar</code> can read and parse .bnf text files.
</p>


<h3>Value</h3>

<p><code>CreateGrammar</code> returns a <code>grammar</code> object.
</p>
<p><code>grule</code> and <code>gsrule</code> return a <code>GERule</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c.GERule">c</a></code>,
<code><a href="#topic+GrammarMap">GrammarMap</a></code>,
<code><a href="#topic+GrammaticalEvolution">GrammaticalEvolution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define a simple grammar in BNF format
# &lt;expr&gt; ::= &lt;var&gt;&lt;op&gt;&lt;var&gt;
# &lt;op&gt;   ::= + | - | *
# &lt;var&gt;  ::= A | B
ruleDef &lt;- list(expr = gsrule("&lt;var&gt;&lt;op&gt;&lt;var&gt;"),
                op   = gsrule("+", "-", "*"),
                var  = gsrule("A", "B"))

# print rules
print(ruleDef)

# create and display a vector rule
vectorRule = gvrule(1:5)
print(vectorRule)

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)

# print grammar object
print(grammarDef)

# Creating the same grammar using R expressions
ruleDef &lt;- list(expr = grule(op(var, var)),
                op   = grule(`+`, `-`, `*`),
                var  = grule(A, B))

grammarDef &lt;- CreateGrammar(ruleDef)

print(grammarDef)

# Two rules with commas and assignments, preserved using .()
ruleDef &lt;- list(expr = grule(data.frame(dat)),
                dat  = grule(.(x = 1, y = 2), .(x = 5, y = 6)))
grammarDef &lt;- CreateGrammar(ruleDef)
print(GrammarMap(c(0), grammarDef))
print(GrammarMap(c(1), grammarDef))
</code></pre>

<hr>
<h2 id='EvalExpressions'>
Evaluate a collection of Expressions
</h2><span id='topic+EvalExpressions'></span>

<h3>Description</h3>

<p><code>EvalExpressions</code> evaluates one or more expressions, either in string format
or as <code>expression</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvalExpressions(expressions, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EvalExpressions_+3A_expressions">expressions</code></td>
<td>

<p>an expression, or a collection of expressions.
</p>
</td></tr>
<tr><td><code id="EvalExpressions_+3A_envir">envir</code></td>
<td>

<p>the <code>environment</code> in which expressions are to be evaluated.  May
also be <code>NULL</code>, a list, a data frame, a pair-list or an
integer as specified in <code>sys.call</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>EvalExpressions</code> is a wrapper around 
<code>eval</code> and <code>parse</code> functions in R base package.
It can handle a single, a vector or a list of expressions,
character strings or <code>GEPhenotype</code> objects.
</p>
<p>The <code>envir</code> argument is directly passed to <code>eval</code> function. If it is not specified,
the parent frame (i.e., the environment where the call to <code>eval</code> was made) is used instead.	
</p>
<p><code>EvalExpressions</code> only evaluates terminal expressions and character strings.
Evaluating non-terminal expressions will result in a warning and <code>NA</code> is returned.
</p>


<h3>Value</h3>

<p>If one expression is evaluated, a vector of numeric values is returned.
Otherwise a data frame with result of each expression in a separate column is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GrammarMap">GrammarMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- 1:6
B &lt;- 1

EvalExpressions("A - B")

# a vector of text strings
exprs &lt;- c("A + B", "A - B")
EvalExpressions(exprs, data.frame(A = A, B = B))

# a vector of expressions
exprs &lt;- expression(A + B, A - B)
EvalExpressions(exprs, data.frame(A = A, B = B))
</code></pre>

<hr>
<h2 id='EvolutionStrategy.int'> 
Evolution Strategy with Integer Chromosomes
</h2><span id='topic+EvolutionStrategy.int'></span><span id='topic+print.EvolutionStrategy.int'></span>

<h3>Description</h3>

<p>Uses evolution strategy to find the minima of a given cost function.
It evolves chromosomes with limited-range integers as codons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvolutionStrategy.int(genomeLen, codonMin, codonMax, 
    genomeMin = rep.int(codonMin, genomeLen), 
    genomeMax = rep.int(codonMax, genomeLen), 
    suggestion = NULL, popSize=4, newPerGen = 4,
    iterations = 500, terminationCost = NA, 
    mutationChance = 1/(genomeLen+1), 
    monitorFunc = NULL, evalFunc, allowrepeat = TRUE, 
    showSettings = FALSE, verbose = FALSE, plapply = lapply)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EvolutionStrategy.int_+3A_genomelen">genomeLen</code></td>
<td>

<p>Number of integers (i.e, codons) in chromosome.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_codonmin">codonMin</code></td>
<td>

<p>Minimum integer value range for all codons.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_codonmax">codonMax</code></td>
<td>

<p>Maximum integer value range for all codons.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_genomemin">genomeMin</code></td>
<td>

<p>A vector of length <code>genomeLen</code> containing fine-grained control
over each codon's minimum. Overrides <code>codonMin</code>.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_genomemax">genomeMax</code></td>
<td>

<p>A vector of length <code>genomeLen</code> containing fine-grained control
over each codon's maximum. Overrides <code>codonMax</code>.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_suggestion">suggestion</code></td>
<td>

<p>A list of suggested chromosomes to be used in the initial population.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_popsize">popSize</code></td>
<td>

<p>Size of the population generated by mutating the parent.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_newpergen">newPerGen</code></td>
<td>

<p>Number of the new randomly generated chromosome in each generation.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_iterations">iterations</code></td>
<td>

<p>Number of generations to evolve the population.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_terminationcost">terminationCost</code></td>
<td>

<p>Target cost. If the best chromosome's cost reaches this value,
the algorithm terminates.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_mutationchance">mutationChance</code></td>
<td>

<p>The chance of a codon being mutated. It must be between 0 and 1.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_monitorfunc">monitorFunc</code></td>
<td>

<p>A function that is called at each generation. Can be used to monitor evolution of population.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_evalfunc">evalFunc</code></td>
<td>

<p>The cost function.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_allowrepeat">allowrepeat</code></td>
<td>

<p>Allows or forbids repeated integers in the chromosome.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_showsettings">showSettings</code></td>
<td>

<p>Enables printing GA settings.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_verbose">verbose</code></td>
<td>

<p>Enables verbose debugging info.
</p>
</td></tr>
<tr><td><code id="EvolutionStrategy.int_+3A_plapply">plapply</code></td>
<td>

<p><code>lapply</code> function used for mapping chromosomes to the cost function.
See details for parallelization tips.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>EvolutionStrategy.int</code> implements evolutionary strategy search algorithm with
chromosomes created from integer values in the range of <code>codonMin</code> to
<code>codonMax</code>. <code>genomeMin</code> and <code>genomeMax</code> allow fine-grained
control of range for individual codons.
It first creates an initial population, using suggested input
<code>suggestion</code> or a randomly generated chromosome.
Score of each chromosome is evaluated using the cost function
<code>costFunc</code>. If the best chromosome reaches
<code>terminationCost</code>, the algorithm terminates; 
otherwise only the best candidate is selected and mutated to create a new generation,
and the cycle is repeated.
This iteration continues until the required cost is reached
or the number of generations exceeds <code>iterations</code>.
</p>
<p>At each generation, the supplied <code>monitorFunc</code> is called with a
list similar to <code>EvolutionStrategy.int</code> returning value as its argument. 
</p>
<p>The <code>evalFunc</code> receives integer sequences and must return a numeric value.
The goal of optimization would be to find a chromosome which minimizes this value.
</p>
<p>To parallelize cost function evaluation, set <code>plapply</code> to a parallelized
<code>lapply</code>, such as <code>mclapply</code> from package <code>parallel</code>. 
In functions that do not handle data dependencies such as <code>parLapply</code>, 
variables and functions required for correct execution of <code>evalFunc</code> 
must be exported to worker nodes before invoking <code>EvolutionStrategy.int</code>.
</p>


<h3>Value</h3>

<p>A list containing information about 
<code>settings</code>, <code>population</code>, and the <code>best</code> chromosome.
</p>
<table role = "presentation">
<tr><td><code>settings$genomeMin</code></td>
<td>

<p>Minimum of each codon. 
</p>
</td></tr>
<tr><td><code>Settings$genomeMax</code></td>
<td>

<p>Maximum of each codon. 
</p>
</td></tr>
<tr><td><code>settings$popSize</code></td>
<td>

<p>Size of the population created using mutation.
</p>
</td></tr>
<tr><td><code>settings$newPerGen</code></td>
<td>

<p>Number of the new randomly generated chromosome in each generation.
</p>
</td></tr>
<tr><td><code>settings$totalPopulation</code></td>
<td>

<p>Size of the total population.
</p>
</td></tr>
<tr><td><code>settings$iterations</code></td>
<td>

<p>Number of maximum generations.</p>
</td></tr>
<tr><td><code>settings$suggestion</code></td>
<td>

<p>Suggested chromosomes.</p>
</td></tr>
<tr><td><code>settings$mutationChance</code></td>
<td>

<p>Mutation chance.</p>
</td></tr>
<tr><td><code>population$population</code></td>
<td>

<p>The genomic data of the current population.</p>
</td></tr>
<tr><td><code>population$evaluations</code></td>
<td>

<p>Cost of the latest generation.</p>
</td></tr>
<tr><td><code>population$best</code></td>
<td>

<p>Historical cost of the best chromosomes.</p>
</td></tr>
<tr><td><code>population$mean</code></td>
<td>

<p>Historical mean cost of population.</p>
</td></tr>
<tr><td><code>population$currentIteration</code></td>
<td>

<p>Number of generations evolved until now.</p>
</td></tr>
<tr><td><code>best$genome</code></td>
<td>

<p>The best chromosome in integer sequence format.</p>
</td></tr>
<tr><td><code>best$cost</code></td>
<td>

<p>The cost of the best chromosome.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GrammaticalEvolution">GrammaticalEvolution</a></code>, 
<code><a href="#topic+GeneticAlg.int">GeneticAlg.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define the evaluate function
evalfunc &lt;- function(l) {
    # maximize the odd indices and minimize the even indices
    # no repeated values are allowed
    odd &lt;- seq(1, 20, 2)
    even &lt;- seq(2, 20, 2)
    err &lt;- sum(l[even]) - sum(l[odd]);

    stopifnot(!any(duplicated(l))) # no duplication allowed

    return (err)
}

monitorFunc &lt;- function(result) {
    cat("Best of gen: ", min(result$best$cost), "\n")
}

x &lt;- EvolutionStrategy.int(genomeLen = 20, codonMin = 0, codonMax = 20,
                allowrepeat = FALSE, terminationCost = -110,
                monitorFunc = monitorFunc, evalFunc = evalfunc)

print(x)

best.result &lt;- x$best$genome
print("Odds:")
print(sort(best.result[seq(1, 20, 2)]))
print("Evens:")
print(sort(best.result[seq(2, 20, 2)]))
</code></pre>

<hr>
<h2 id='GeneticAlg.int'> 
Genetic Algorithm with Integer Chromosomes
</h2><span id='topic+GeneticAlg.int'></span><span id='topic+print.GeneticAlg.int'></span>

<h3>Description</h3>

<p>Uses genetic algorithm to find the minima of a given cost function.
It evolves chromosomes with limited-range integers as codons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneticAlg.int(genomeLen, codonMin, codonMax, 
    genomeMin = rep.int(codonMin, genomeLen), 
    genomeMax = rep.int(codonMax, genomeLen), 
    suggestions = NULL, popSize = 50, 
    iterations = 100, terminationCost = NA, 
    mutationChance = 1/(genomeLen+1), elitism = floor(popSize/10), 
    geneCrossoverPoints = NULL,
    monitorFunc = NULL, evalFunc, allowrepeat = TRUE, 
    showSettings = FALSE, verbose = FALSE, plapply = lapply)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeneticAlg.int_+3A_genomelen">genomeLen</code></td>
<td>

<p>Number of integers (i.e, codons) in chromosome.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_codonmin">codonMin</code></td>
<td>

<p>Minimum integer value range for all codons.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_codonmax">codonMax</code></td>
<td>

<p>Maximum integer value range for all codons.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_genomemin">genomeMin</code></td>
<td>

<p>A vector of length <code>genomeLen</code> containing fine-grained control
over each codon's minimum. Overrides <code>codonMin</code>.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_genomemax">genomeMax</code></td>
<td>

<p>A vector of length <code>genomeLen</code> containing fine-grained control
over each codon's maximum. Overrides <code>codonMax</code>.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_suggestions">suggestions</code></td>
<td>

<p>A list of suggested chromosomes to be used in the initial population.
Alternatively, an m-by-n matrix, where m is the number of suggestions and n is the chromosome length.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_popsize">popSize</code></td>
<td>

<p>Size of the population.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_iterations">iterations</code></td>
<td>

<p>Number of generations to evolve the population.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_terminationcost">terminationCost</code></td>
<td>

<p>Target cost. If the best chromosome's cost reaches this value
the algorithm terminates.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_mutationchance">mutationChance</code></td>
<td>

<p>The chance of a codon being mutated. It must be between 0 and 1.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_genecrossoverpoints">geneCrossoverPoints</code></td>
<td>

<p>Codon groupings (genes) to be considered while crossover occurs. 
If given, odd and even codon groups are exchanged between parents.
Otherwise random points are selected and a classic single-point crossover is performed.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_elitism">elitism</code></td>
<td>

<p>Number of top ranking chromosomes that are directly transfered to next generation without
going through evolutionary operations.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_monitorfunc">monitorFunc</code></td>
<td>

<p>A function that is called at each generation. Can be used to monitor evolution of population.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_evalfunc">evalFunc</code></td>
<td>

<p>The cost function.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_allowrepeat">allowrepeat</code></td>
<td>

<p>Allows or forbids repeated integers in the chromosome.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_showsettings">showSettings</code></td>
<td>

<p>Enables printing GA settings.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_verbose">verbose</code></td>
<td>

<p>Enables verbose debugging info.
</p>
</td></tr>
<tr><td><code id="GeneticAlg.int_+3A_plapply">plapply</code></td>
<td>

<p><code>lapply</code> function used for mapping chromosomes to cost function.
See details for parallelization tips.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GeneticAlg.int</code> implements evolutionary algorithms with
chromosomes created from integer values in the range of <code>codonMin</code> to
<code>codonMax</code>. <code>genomeMin</code> and <code>genomeMax</code> allow fine-grained
control of range for individual codons.
It first creates an initial population, using suggested inputs
<code>suggestions</code> and randomly generated chromosomes. 
Cost of each chromosome is evaluated using the cost function
<code>evalFunc</code>. If one of the chromosomes reaches
<code>terminationCost</code>, the algorithm terminates; 
Otherwise evolutionary operators including selection, cross-over
and mutation are applied to the population to create a new generation.
This iteration is continued until the required cost is reached
or the number of generations exceeds <code>iterations</code>.
</p>
<p>At each generation, the supplied <code>monitorFunc</code> is called with a
list similar to <code>GeneticAlg.int</code> returning value as its argument. 
</p>
<p>The <code>evalFunc</code> receives integer sequences and must return a numeric value.
The goal of optimization would be to find a chromosome which minimizes this value.
</p>
<p>To parallelize cost function evaluation, set <code>plapply</code> to a parallelized
<code>lapply</code>, such as <code>mclapply</code> from package <code>parallel</code>. 
In functions that do not handle data dependencies such as <code>parLapply</code>, 
variables and functions required for correct execution of <code>evalFunc</code> 
must be exported to worker nodes before invoking <code>GeneticAlg.int</code>.
</p>


<h3>Value</h3>

<p>A list containing information about 
<code>settings</code>, <code>population</code>, and the <code>best</code> chromosome.
</p>
<table role = "presentation">
<tr><td><code>settings$genomeMin</code></td>
<td>

<p>Minimum of each codon. </p>
</td></tr>
<tr><td><code>Settings$genomeMax</code></td>
<td>

<p>Maximum of each codon. </p>
</td></tr>
<tr><td><code>settings$popSize</code></td>
<td>

<p>Size of the population.</p>
</td></tr>
<tr><td><code>settings$elitism</code></td>
<td>

<p>Number of elite individuals.</p>
</td></tr>
<tr><td><code>settings$iterations</code></td>
<td>

<p>Number of maximum generations.</p>
</td></tr>
<tr><td><code>settings$suggestions</code></td>
<td>

<p>Suggested chromosomes.</p>
</td></tr>
<tr><td><code>settings$mutationChance</code></td>
<td>

<p>Mutation chance.</p>
</td></tr>
<tr><td><code>settings$geneCrossoverPoints</code></td>
<td>

<p>Cross-over points.</p>
</td></tr>
<tr><td><code>population$population</code></td>
<td>

<p>The genomic data of the current population.</p>
</td></tr>
<tr><td><code>population$evaluations</code></td>
<td>

<p>Cost of the latest generation.</p>
</td></tr>
<tr><td><code>population$best</code></td>
<td>

<p>Historical cost of the best chromosomes.</p>
</td></tr>
<tr><td><code>population$mean</code></td>
<td>

<p>Historical mean cost of population.</p>
</td></tr>
<tr><td><code>population$currentIteration</code></td>
<td>

<p>Number of generations evolved until now.</p>
</td></tr>
<tr><td><code>best$genome</code></td>
<td>

<p>The best chromosome.</p>
</td></tr>
<tr><td><code>best$cost</code></td>
<td>

<p>The cost of the best chromosome.</p>
</td></tr>
</table>


<h3>References</h3>

<p>This function is partially inspired by <code>genalg</code> package
by Egon Willighagen. See <a href="https://cran.r-project.org/package=genalg">https://cran.r-project.org/package=genalg</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GrammaticalEvolution">GrammaticalEvolution</a></code>, 
<code><a href="#topic+EvolutionStrategy.int">EvolutionStrategy.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define the evaluate function
evalfunc &lt;- function(l) {
    # maximize the odd indices and minimize the even indices
    # no repeated values are allowed
    odd &lt;- seq(1, 20, 2)
    even &lt;- seq(2, 20, 2)
    err &lt;- sum(l[even]) - sum(l[odd]);

    stopifnot(!any(duplicated(l))) # no duplication allowed

    return (err)
}

monitorFunc &lt;- function(result) {
    cat("Best of gen: ", min(result$best$cost), "\n")
}

x &lt;- GeneticAlg.int(genomeLen = 20, codonMin = 0, codonMax = 20,
                allowrepeat = FALSE, terminationCost = -110,
                monitorFunc = monitorFunc, evalFunc = evalfunc)

print(x)

best.result &lt;- x$best$genome
print("Odds:")
print(sort(best.result[seq(1, 20, 2)]))
print("Evens:")
print(sort(best.result[seq(2, 20, 2)]))
</code></pre>

<hr>
<h2 id='GrammarGetNextSequence'>Grammar Iterator</h2><span id='topic+GrammarGetNextSequence'></span><span id='topic+GrammarGetFirstSequence'></span><span id='topic+is.GrammarOverflow'></span><span id='topic+print.GrammarOverflow'></span>

<h3>Description</h3>

 
<p>Iterates through grammar's valid sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
GrammarGetFirstSequence(grammar, 
            seqStart = NULL, 
            startSymb = GrammarStartSymbol(grammar),
            max.depth = GrammarGetDepth(grammar),
            max.len = GrammarMaxSequenceLen(grammar, max.depth, startSymb))

GrammarGetNextSequence(grammar, 
            seqStart = NULL, 
            startSymb = GrammarStartSymbol(grammar),
            max.depth = GrammarGetDepth(grammar),
            max.len = GrammarMaxSequenceLen(grammar, max.depth, startSymb))
  
is.GrammarOverflow(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GrammarGetNextSequence_+3A_grammar">grammar</code></td>
<td>

<p>A <code><a href="#topic+CreateGrammar">grammar</a></code> object.
</p>
</td></tr>
<tr><td><code id="GrammarGetNextSequence_+3A_seqstart">seqStart</code></td>
<td>

<p>The sequence to be incremented. 
For a value of <code>NULL</code>, the first sequence is returned.
Partial sequences are completed and returned.
</p>
</td></tr>
<tr><td><code id="GrammarGetNextSequence_+3A_startsymb">startSymb</code></td>
<td>

<p>The non-terminal symbol where the generation of a new expression should start.
</p>
</td></tr>
<tr><td><code id="GrammarGetNextSequence_+3A_max.depth">max.depth</code></td>
<td>

<p>Maximum depth of recursion, in case of a cyclic grammar.
By default it is limited to the number of production rules in the grammar.
</p>
</td></tr>
<tr><td><code id="GrammarGetNextSequence_+3A_max.len">max.len</code></td>
<td>

<p>Maximum length of sequence to return. Used to avoid recursion.
</p>
</td></tr>
<tr><td><code id="GrammarGetNextSequence_+3A_object">object</code></td>
<td>

<p>An object to be tested.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GrammarGetFirstSequence</code> returns the first sequence that creates a valid expression
with the given <code><a href="#topic+CreateGrammar">grammar</a></code> object.
<code>GrammarGetNextSequence</code> allows iterating through all valid sequences in a grammar.
If a <code>seqStart = NULL</code> is used, <code>GrammarGetFirstSequence</code> is called to 
and the first sequence in the grammar is returned.
Calling <code>GrammarGetNextSequence</code> or <code>GrammarGetFirstSequence</code> with an incomplete
sequence returns a full-length sequence starting with the given <code>seqStart</code>.
</p>
<p>When <code>GrammarGetNextSequence</code> reaches the last of all valid sequences, it returns
a <code>GrammarOverflow</code> object. This object can be identified using <code>is.GrammarOverflow</code>.
</p>


<h3>Value</h3>

<p><code>GrammarGetFirstSequence</code> returns a numeric vector representing the first sequence of the grammar.
</p>
<p><code>GrammarGetNextSequence</code> returns a numeric vector or a <code>GrammarOverflow</code> object.
</p>
<p><code>is.GrammarOverflow</code> returns TRUE if <code>object</code> is a <code>GrammarOverflow</code>, otherwise FALSE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GrammaticalExhaustiveSearch">GrammaticalExhaustiveSearch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple grammar
# &lt;expr&gt; ::= &lt;var&gt;&lt;op&gt;&lt;var&gt;
# &lt;op&gt;   ::= + | - | *
# &lt;var&gt;  ::= A | B
ruleDef &lt;- list(expr = gsrule("&lt;var&gt;&lt;op&gt;&lt;var&gt;"),
                op   = gsrule("+", "-", "*"),
                var  = gsrule("A", "B"))

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)			   

# Iterate and print all valid sequence and expressions
string &lt;- NULL
while (TRUE) {
  string &lt;- GrammarGetNextSequence(grammarDef, string)

  if (is.GrammarOverflow(string)) {
    break
  }

  expr &lt;- GrammarMap(string, grammarDef)
  cat(string, " -&gt; ", as.character(expr), "\n")
}

# test a partial string
GrammarGetNextSequence(grammarDef, c(0, 0, 2))

</code></pre>

<hr>
<h2 id='GrammarIsTerminal'>
Non-terminal Phenotype test.
</h2><span id='topic+GrammarIsTerminal'></span>

<h3>Description</h3>

<p>Checks a phenotype object for containing non-terminal symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GrammarIsTerminal(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GrammarIsTerminal_+3A_x">x</code></td>
<td>

<p>A <code><a href="#topic+GrammarMap">GEPhenotype</a></code> object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if phenotype is terminal, <code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GrammarMap">GrammarMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a recursive grammar
# &lt;expr&gt; ::= &lt;expr&gt;+&lt;expr&gt; | var
# &lt;var&gt;  ::= A | B | C
ruleDef &lt;- list(expr = grule(expr+expr, var),
                var =  grule(A, B, C))

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)

# a short sequence leading to infinite recursion
sq &lt;- c(0)
expr &lt;- GrammarMap(sq, grammarDef)

print(expr)

# check the phenotype for being non-terminal
print(GrammarIsTerminal(expr))


# a terminal sequence
sq &lt;- c(0, 1, 0, 1, 2)
expr &lt;- GrammarMap(sq, grammarDef)

print(expr)
print(GrammarIsTerminal(expr))
</code></pre>

<hr>
<h2 id='GrammarMap'>
Sequence to Expression Mapping using Context-free Grammar
</h2><span id='topic+GrammarMap'></span><span id='topic+GrammarGenotypeToPhenotype'></span><span id='topic+as.character.GEPhenotype'></span><span id='topic+as.expression.GEPhenotype'></span><span id='topic+print.GEPhenotype'></span>

<h3>Description</h3>

<p>Converts a sequence of integer numbers to an expression
using a <code>grammar</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GrammarMap(inputString, grammar, wrappings = 3, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GrammarMap_+3A_inputstring">inputString</code></td>
<td>

<p>A vector of integers to define the path of symbol selection in grammar tree. It uses
zero-based indexing to address production rules in the grammar.
</p>
</td></tr>
<tr><td><code id="GrammarMap_+3A_grammar">grammar</code></td>
<td>

<p>A <code><a href="#topic+CreateGrammar">grammar</a></code> object.
</p>
</td></tr>
<tr><td><code id="GrammarMap_+3A_wrappings">wrappings</code></td>
<td>

<p>The number of times the function is allowed to wrap around <code>inputString</code>
if non-terminal symbols are still remaining.
</p>
</td></tr>
<tr><td><code id="GrammarMap_+3A_verbose">verbose</code></td>
<td>

<p>Prints out each steps of grammar mapping.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GrammarMap</code> starts from the <code>startExpr</code> defined in the 
<code><a href="#topic+CreateGrammar">grammar</a></code> object;
then it iterates through <code>inputString</code>, replacing symbols in the expression
with associated replacements in the grammar using the current value of
<code>inputString</code>.
</p>
<p>If the function exhausts all non-terminal symbols in the expression, it terminates.
If the end of <code>inputString</code> is reached and  still non-terminal symbols
exist, the algorithm will restart from the beginning of the current <code>inputString</code>. 
To avoid unlimited recursions in case of a cyclic grammar,
<code>wrappings</code> variable limits the number of this restart.
</p>
<p>If <code>verbose = TRUE</code>, step-by-step replacement of symbols with production rules are displayed.
</p>
<p><code>GrammarMap</code> returns a <code>GEPhenotype</code> object, which can be converted to
a character string using <code>as.character</code>, or an R expression with <code>as.expression</code>.
</p>


<h3>Value</h3>

<p>A <code>GrammarMap</code> returns a <code>GEPhenotype</code> object.
</p>
<table role = "presentation">
<tr><td><code>expr</code></td>
<td>
<p>The generated expression as a character string.</p>
</td></tr>
<tr><td><code>parsed</code></td>
<td>
<p>The generated expression. NULL if the expression still 
contains non-terminal symbols.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>&quot;T&quot; if the expression is valid, &quot;NT&quot; if the expression still 
contains non-terminal symbols. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GrammarIsTerminal">GrammarIsTerminal</a></code>
<code><a href="#topic+CreateGrammar">CreateGrammar</a></code>,
<code><a href="#topic+GrammarRandomExpression">GrammarRandomExpression</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple grammar
# &lt;expr&gt; ::= &lt;var&gt;&lt;op&gt;&lt;var&gt;
# &lt;op&gt;   ::= + | - | *
# &lt;var&gt;  ::= A | B | C
ruleDef &lt;- list(expr = gsrule("&lt;var&gt;&lt;op&gt;&lt;var&gt;"),
                op =   gsrule("+", "-", "*"),
                var =  grule(A, B, C))

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)

# this should create the expression "A - C"
# &lt;expr&gt;         -&gt; 0 -&gt; &lt;var&gt;&lt;op&gt;&lt;var&gt;
# &lt;var&gt;&lt;op&gt;&lt;var&gt; -&gt; 0 -&gt; A&lt;op&gt;&lt;var&gt;
# A&lt;op&gt;&lt;var&gt;     -&gt; 1 -&gt; A - &lt;var&gt;
# A - &lt;var&gt;      -&gt; 2 -&gt; A - C
sq &lt;- c(0, 0, 1, 2)
expr &lt;- GrammarMap(sq, grammarDef, verbose = TRUE)

print(expr)

# check the expression as a character string
stopifnot(as.character(expr) == "A - C")

# evaluate the expression
A = 5; C = 1
eval(as.expression(expr))
</code></pre>

<hr>
<h2 id='GrammarRandomExpression'>Random Expression Generation
</h2><span id='topic+GrammarRandomExpression'></span>

<h3>Description</h3>

<p>Creates random expressions from context-free grammar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GrammarRandomExpression(grammar, 
          numExpr = 1, 
          max.depth = length(grammar$def), 
          startSymb = GrammarStartSymbol(grammar),
          max.string = GrammarMaxSequenceRange(grammar, max.depth, startSymb, 
                                               approximate = TRUE), 
          wrappings = 3, 
          retries = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GrammarRandomExpression_+3A_grammar">grammar</code></td>
<td>

<p>A <code><a href="#topic+CreateGrammar">grammar</a></code> object.
</p>
</td></tr>
<tr><td><code id="GrammarRandomExpression_+3A_numexpr">numExpr</code></td>
<td>

<p>Number of random expressions to generate.
</p>
</td></tr>
<tr><td><code id="GrammarRandomExpression_+3A_max.depth">max.depth</code></td>
<td>

<p>Maximum depth of recursion, in case of a cyclic grammar. 
By default it is limited to the number of production rules in the grammar.
</p>
</td></tr>
<tr><td><code id="GrammarRandomExpression_+3A_startsymb">startSymb</code></td>
<td>

<p>The symbol where the generation of a new expression should start.
</p>
</td></tr>
<tr><td><code id="GrammarRandomExpression_+3A_max.string">max.string</code></td>
<td>

<p>Maximum value for each element of the sequence.
</p>
</td></tr>
<tr><td><code id="GrammarRandomExpression_+3A_wrappings">wrappings</code></td>
<td>

<p>The number of times the function is allowed to wrap around <code>inputString</code>
if non-terminal symbols are still remaining.
</p>
</td></tr>
<tr><td><code id="GrammarRandomExpression_+3A_retries">retries</code></td>
<td>

<p>Number of retries until a terminal and valid expressions is found.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GrammarRandomExpression</code> creates <code>num.expr</code> random expressions from the given <code>grammar</code>.
It can be used to quickly examine the expressibility of the grammar, 
or as a form of random search over the grammar.
</p>


<h3>Value</h3>

<p>An <code>expressions</code>, or a <code>list</code> of <code>expressions</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple grammar
# &lt;expr&gt; ::= &lt;var&gt;&lt;op&gt;&lt;var&gt;
# &lt;op&gt;   ::= + | - | *
# &lt;var&gt;  ::= A | B | C
ruleDef &lt;- list(expr = gsrule("&lt;var&gt;&lt;op&gt;&lt;var&gt;"),
                op =   gsrule("+", "-", "*"),
                var =  grule(A, B, C))

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)

# Generate 5 random expressions
exprs &lt;- GrammarRandomExpression(grammarDef, 5)
print(exprs)
</code></pre>

<hr>
<h2 id='GrammaticalEvolution'>Grammatical Evolution</h2><span id='topic+GrammaticalEvolution'></span><span id='topic+print.GrammaticalEvolution'></span>

<h3>Description</h3>

<p>Evolves an expression using a context-free grammar
to minimize a given cost function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GrammaticalEvolution(grammarDef, evalFunc, 
              numExpr = 1, 
              max.depth = GrammarGetDepth(grammarDef),
              startSymb = GrammarStartSymbol(grammarDef),
              seqLen = GrammarMaxSequenceLen(grammarDef, max.depth, startSymb),
              wrappings = 3, 
              suggestions = NULL,
              optimizer = c("auto", "es", "ga"),
              popSize = "auto", newPerGen = "auto", elitism = 2,
              mutationChance = NA,
              iterations = "auto",
              terminationCost = NA,
              monitorFunc = NULL,
              disable.warnings=FALSE,
              plapply = lapply, ...)

## S3 method for class 'GrammaticalEvolution'
print(x, ..., show.genome = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GrammaticalEvolution_+3A_grammardef">grammarDef</code></td>
<td>

<p>A <code><a href="#topic+CreateGrammar">grammar</a></code> object.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_evalfunc">evalFunc</code></td>
<td>

<p>The cost function, taking a string or a collection of strings
containing the expression(s) as its input
and returning the cost of the expression(s).
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_numexpr">numExpr</code></td>
<td>

<p>Number of expressions generated and given to <code>evalFunc</code>.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_max.depth">max.depth</code></td>
<td>

<p>Maximum depth of search in case of a cyclic grammar. 
By default it is limited to the number of production rules in the grammar.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_startsymb">startSymb</code></td>
<td>

<p>The symbol where the generation of a new expression should start.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_seqlen">seqLen</code></td>
<td>

<p>Length of integer vector used to create the expression.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_wrappings">wrappings</code></td>
<td>

<p>Number of wrappings in case the length of chromosome is not enough for conversion to an expression.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_suggestions">suggestions</code></td>
<td>

<p>Suggested chromosomes to be added to the initial population pool. if <code>optimizer</code> parameter is set to <code>"es"</code>, 
only a single chromosome (as a numeric vector) is acceptable. For <code>"ga"</code> mode, a list of numeric vectors.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_optimizer">optimizer</code></td>
<td>

<p>The evolutionary optimizer. <code>"es"</code> uses evolution strategy as in <code><a href="#topic+EvolutionStrategy.int">EvolutionStrategy.int</a></code>
and <code>"ga"</code> uses genetic algorithm as in <code><a href="#topic+GeneticAlg.int">GeneticAlg.int</a></code>. 
<code>"auto"</code> chooses evolution strategy when <code>numExpr = 1</code>, and genetic algorithm otherwise.
If <code>"auto"</code> is used, <code>popSize</code> and <code>iterations</code> are tweaked based on the grammar as well.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_popsize">popSize</code></td>
<td>

<p>Population size in the evolutionary optimizer. By default, 8 for ES and 48 for GA.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_newpergen">newPerGen</code></td>
<td>

<p>Number of randomly generated individuals in evolution strategy.
If &ldquo;auto&quot;, it is set to 25% of population of grammar if it is not recursive,
otherwise to all of it.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_elitism">elitism</code></td>
<td>

<p>Number of top ranking chromosomes that are directly transfered to the next generation without
going through evolutionary operations, used in genetic algorithm optimizer.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_iterations">iterations</code></td>
<td>

<p>Number of maximum iterations in the evolutionary optimizer. By default, 1000 for <code>"es"</code>
optimizer and 200 for <code>"ga"</code>.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_terminationcost">terminationCost</code></td>
<td>

<p>Target cost. If a sequence with this cost or less is found,
the algorithm terminates.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_mutationchance">mutationChance</code></td>
<td>

<p>Mutation chance in the evolutionary optimizer. It must be between 0 and 1.
By default it is set to <code>1/(1+chromosome size))</code> for genetic algorithm and
<code>10/(1+chromosome size))</code> for evolution strategy.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_monitorfunc">monitorFunc</code></td>
<td>

<p>A function that is called at each generation. It can be used to monitor evolution of population.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_disable.warnings">disable.warnings</code></td>
<td>

<p>If <code>TRUE</code>, suppresses any warnings generated while evaulating <code>evalFunc</code>s.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_plapply">plapply</code></td>
<td>

<p><code>lapply</code> function used for mapping chromosomes to the cost function.
See details for parallelization tips.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_...">...</code></td>
<td>

<p>Additional parameters are passed to <code><a href="#topic+GeneticAlg.int">GeneticAlg.int</a></code> or <code><a href="#topic+EvolutionStrategy.int">EvolutionStrategy.int</a></code>.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_x">x</code></td>
<td>

<p>Grammatical Evolution results.
</p>
</td></tr>
<tr><td><code id="GrammaticalEvolution_+3A_show.genome">show.genome</code></td>
<td>

<p>Prints the numeric value of genome if TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs an evolutionary search over the grammar, better known as Grammatical Evolution.
It evolves integer sequences and converts them to a collection containing
<code>numExpr</code> expression. These expressions can be evaluated using <code>eval</code> function.
The <code>evalFunc</code> receives these expressions and must return a numeric value.
The goal of optimization would be to find a chromosome which minimizes this function.
</p>
<p>Two evolutionary optimizers are supported: Genetic algorithm and evolution strategy,
which are set by the <code>optimizer</code> parameter.
</p>
<p>Only valid (i.e., terminal) expressions are passed to <code>evalFunc</code>,
and it is guaranteed that <code>evalFunc</code> receives at least one expression.
</p>
<p>If the grammar contains recursive elements, it is advisable that <code>chromosomeLen</code> is 
defined manually, as in such cases the possible search space grows explosively
with the recursion. The evolutionary algorithm automatically removes
the recursive chromosomes from the population by imposing a penalty for
chromosomes creating expressions with non-terminal elements.
</p>
<p><code>monitorFunc</code> receives a list similar to the <code>GrammaticalEvolution</code>'s return value.
</p>


<h3>Value</h3>

<p>The results of <code><a href="#topic+GeneticAlg.int">GeneticAlg.int</a></code> or <code><a href="#topic+EvolutionStrategy.int">EvolutionStrategy.int</a></code> with an additional item:
</p>
<table role = "presentation">
<tr><td><code>best$expressions</code></td>
<td>
<p>Expression(s) with the best cost.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+CreateGrammar">CreateGrammar</a></code>, 
<code><a href="#topic+GeneticAlg.int">GeneticAlg.int</a></code>,
<code><a href="#topic+EvolutionStrategy.int">EvolutionStrategy.int</a></code>,
<code><a href="#topic+EvalExpressions">EvalExpressions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Grammar Definition
ruleDef &lt;- list(expr     = gsrule("&lt;der.expr&gt;&lt;op&gt;&lt;der.expr&gt;"),
                der.expr = grule(func(var), var),
                func     = grule(log, exp, sin, cos),
                op       = gsrule("+", "-", "*"),
                var      = grule(A, B, n),
                n        = grule(1, 2, 3, 4))

# Creating the grammar object
grammarDef &lt;- CreateGrammar(ruleDef)

# cost function
evalFunc &lt;- function(expr) {
  # expr: a string containing a symbolic expression
  # returns: Symbolic regression Error
  A &lt;- 1:6
  B &lt;- c(2, 5, 8, 3, 4, 1)
  
  result &lt;- eval(as.expression(expr))
  
  X &lt;- log(A) * B
  err &lt;- sum((result - X)^2)
  
  return(err)
}

# invoke grammatical evolution (with default parameters)
ge &lt;- GrammaticalEvolution(grammarDef, evalFunc, terminationCost = 0.001)

# print results
print(ge, sequence = TRUE)
</code></pre>

<hr>
<h2 id='GrammaticalExhaustiveSearch'>Exhaustive Search</h2><span id='topic+GrammaticalExhaustiveSearch'></span><span id='topic+print.GESearch'></span>

<h3>Description</h3>

 
<p>Exhaustive Search within context-free grammar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
GrammaticalExhaustiveSearch(grammar, evalFunc,
                max.depth = GrammarGetDepth(grammar),
                startSymb = GrammarStartSymbol(grammar),
                max.len = GrammarMaxSequenceLen(grammar, max.depth, startSymb),
                wrappings = 3,
                terminationCost = NA,
                monitorFunc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GrammaticalExhaustiveSearch_+3A_grammar">grammar</code></td>
<td>

<p>A <code><a href="#topic+CreateGrammar">grammar</a></code> object.
</p>
</td></tr>
<tr><td><code id="GrammaticalExhaustiveSearch_+3A_evalfunc">evalFunc</code></td>
<td>

<p>The evaluation function, taking an expression as its input
and returning the cost (i.e., the score) of the expression.
</p>
</td></tr>
<tr><td><code id="GrammaticalExhaustiveSearch_+3A_max.depth">max.depth</code></td>
<td>

<p>Maximum depth of recursion, in case of a cyclic grammar. 
By default it is limited to the number of production rules in the grammar.
</p>
</td></tr>
<tr><td><code id="GrammaticalExhaustiveSearch_+3A_startsymb">startSymb</code></td>
<td>

<p>The symbol where the generation of a new expression should start.
</p>
</td></tr>
<tr><td><code id="GrammaticalExhaustiveSearch_+3A_max.len">max.len</code></td>
<td>

<p>Maximum length of the sequences to search. 
By default it is determined by <code>max.depth</code>.
</p>
</td></tr>
<tr><td><code id="GrammaticalExhaustiveSearch_+3A_wrappings">wrappings</code></td>
<td>

<p>The number of times the function is allowed to wrap around <code>inputString</code>
if non-terminal symbols are still remaining.
</p>
</td></tr>
<tr><td><code id="GrammaticalExhaustiveSearch_+3A_terminationcost">terminationCost</code></td>
<td>

<p>Target cost. If an expression with this cost or less is found,
the algorithm terminates.
</p>
</td></tr>
<tr><td><code id="GrammaticalExhaustiveSearch_+3A_monitorfunc">monitorFunc</code></td>
<td>

<p>A function that is called at each iteration. It can be used to monitor the search.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GrammaticalExhaustiveSearch</code> performs an exhaustive search,
iterating through all possible expressions that can be generated by the <code>grammar</code>,
to find the expression that minimises <code>evalFunc</code>.
</p>
<p>The search terminates when all possible expressions are exhausted,
or when an expression with a cost less than <code>terminationCost</code> is discovered.
</p>
<p>If a <code>monitorFunc</code> is given, it is called for each expression, and it receives a 
list similar to the <code>GrammaticalExhaustiveSearch</code>'s return value with the information
availabe for that expression.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bestExpression</code></td>
<td>
<p>The Best expresssion.</p>
</td></tr>
<tr><td><code>bestSequence</code></td>
<td>
<p>Best expresssion's generating sequence.</p>
</td></tr>
<tr><td><code>bestCost</code></td>
<td>
<p>Best expresssion's cost.</p>
</td></tr>
<tr><td><code>numExpr</code></td>
<td>
<p>Number of evaluated expressions.</p>
</td></tr>
</table>
<p>In addition, the <code>monitorFunc</code> receives the following additional slots: 
</p>
<table role = "presentation">
<tr><td><code>currentExpression</code></td>
<td>
<p>The current expresssion.</p>
</td></tr>
<tr><td><code>currentSequence</code></td>
<td>
<p>Current expresssion's generating sequence.</p>
</td></tr>
<tr><td><code>currentCost</code></td>
<td>
<p>Current expresssion's cost.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GrammarGetNextSequence">GrammarGetNextSequence</a></code>,
<code><a href="#topic+GrammaticalEvolution">GrammaticalEvolution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("gramEvol")

ruleDef &lt;- list(expr = gsrule("&lt;var&gt;&lt;op&gt;&lt;var&gt;"),
                op   = gsrule("+", "-", "*"),
                var  = gsrule("A", "B"))

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)         


# use exhaustive search to find the sequence for creating "B - A"
evalFunc &lt;- function(expr) {
  if (as.character(expr) == "B - A") {
    return(0) # Minimum error
  } else {
    return(1) # maximum error
  }
}

res &lt;- GrammaticalExhaustiveSearch(grammarDef, evalFunc, terminationCost = 0)

print(res)

</code></pre>

<hr>
<h2 id='GrammaticalRandomSearch'>Random Search</h2><span id='topic+GrammaticalRandomSearch'></span>

<h3>Description</h3>

 
<p>Random Search within context-free grammar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
GrammaticalRandomSearch(grammar, evalFunc,
                        max.depth = GrammarGetDepth(grammar),
                        startSymb = GrammarStartSymbol(grammar),
                        wrappings = 3,
                        iterations = 1000, 
                        terminationCost = NA,
                        monitorFunc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GrammaticalRandomSearch_+3A_grammar">grammar</code></td>
<td>

<p>A <code><a href="#topic+CreateGrammar">grammar</a></code> object.
</p>
</td></tr>
<tr><td><code id="GrammaticalRandomSearch_+3A_evalfunc">evalFunc</code></td>
<td>

<p>The evaluation function, taking an expression as its input
and returning the cost (i.e., the score) of the expression.
</p>
</td></tr>
<tr><td><code id="GrammaticalRandomSearch_+3A_max.depth">max.depth</code></td>
<td>

<p>Maximum depth of recursion, in case of a cyclic grammar. 
By default it is limited to the number of production rules in the grammar.
</p>
</td></tr>
<tr><td><code id="GrammaticalRandomSearch_+3A_startsymb">startSymb</code></td>
<td>

<p>The symbol where the generation of a new expression should start.
</p>
</td></tr>
<tr><td><code id="GrammaticalRandomSearch_+3A_wrappings">wrappings</code></td>
<td>

<p>The number of times the function is allowed to wrap around <code>inputString</code>
if non-terminal symbols are still remaining.
</p>
</td></tr>
<tr><td><code id="GrammaticalRandomSearch_+3A_iterations">iterations</code></td>
<td>

<p>Number of random expressions to test.
</p>
</td></tr>
<tr><td><code id="GrammaticalRandomSearch_+3A_terminationcost">terminationCost</code></td>
<td>

<p>Target cost. If an expression with this cost or less is found,
the algorithm terminates.
</p>
</td></tr>
<tr><td><code id="GrammaticalRandomSearch_+3A_monitorfunc">monitorFunc</code></td>
<td>

<p>A function that is called at each generation. It can be used to monitor evolution of population.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GrammaticalRandomSearch</code> performs a random search within expressions 
that can be generated by the <code>grammar</code>,
to find the expression that minimises <code>evalFunc</code>.
</p>
<p>The search terminates when either the predetermined number of <code>iterations</code> are reached, 
or when an expression with a cost less than <code>terminationCost</code> is discovered.
</p>
<p>If a <code>monitorFunc</code> is given, it is called for each expression, and it receives a 
list similar to the <code>GrammaticalExhaustiveSearch</code>'s return value with the information
availabe for that expression.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bestExpression</code></td>
<td>
<p>The Best expresssion.</p>
</td></tr>
<tr><td><code>bestSequence</code></td>
<td>
<p>Best expresssion's generating sequence.</p>
</td></tr>
<tr><td><code>bestCost</code></td>
<td>
<p>Best expresssion's cost.</p>
</td></tr>
<tr><td><code>numExpr</code></td>
<td>
<p>Number of evaluated expressions.</p>
</td></tr>
<tr><td><code>population</code></td>
<td>
<p>A matrix of sequences that were tested.</p>
</td></tr>
<tr><td><code>populationCost</code></td>
<td>
<p>Numeric value of cost of sequences that were tested.</p>
</td></tr>
</table>
<p>In addition, the <code>monitorFunc</code> receives the following additional slots: 
</p>
<table role = "presentation">
<tr><td><code>currentExpression</code></td>
<td>
<p>The current expresssion.</p>
</td></tr>
<tr><td><code>currentSequence</code></td>
<td>
<p>Current expresssion's generating sequence.</p>
</td></tr>
<tr><td><code>currentCost</code></td>
<td>
<p>Current expresssion's cost.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GrammarGetNextSequence">GrammarGetNextSequence</a></code>,
<code><a href="#topic+GrammaticalEvolution">GrammaticalEvolution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("gramEvol")

ruleDef &lt;- list(expr = gsrule("&lt;var&gt;&lt;op&gt;&lt;var&gt;"),
                op   = gsrule("+", "-", "*"),
                var  = gsrule("A", "B"))

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)         


# use exhaustive search to find the sequence for creating "B - A"
evalFunc &lt;- function(expr) {
  if (as.character(expr) == "B - A") {
    return(0) # Minimum error
  } else {
    return(1) # maximum error
  }
}

# search and terminate after getting to cost = 0
res &lt;- GrammaticalRandomSearch(grammarDef, evalFunc, terminationCost = 0)

print(res)

</code></pre>

<hr>
<h2 id='ReplaceInExpression'>Replace as sub-expression isnide an expression</h2><span id='topic+ReplaceInExpression'></span>

<h3>Description</h3>

<p>Replace every subexpression equal to or starting with <code>what</code> in <code>expr</code>.
Replacement is performed by passing the whole subexpression to <code>replacer.func</code>,
which should be a <code>function(x, ...)</code>, where <code>x</code> is the expression and return the desirable expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReplaceInExpression(expr, what, replacer.func, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReplaceInExpression_+3A_expr">expr</code></td>
<td>
<p>An <code><a href="base.html#topic+expression">expression</a></code>.</p>
</td></tr>
<tr><td><code id="ReplaceInExpression_+3A_what">what</code></td>
<td>
<p>A backquoted expression to find in <code>expr</code>.</p>
</td></tr>
<tr><td><code id="ReplaceInExpression_+3A_replacer.func">replacer.func</code></td>
<td>
<p>A <code>function(x, ...)</code> to process the subexpression.</p>
</td></tr>
<tr><td><code id="ReplaceInExpression_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>replacer.func</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was designed to be used as a runtime processing tool for
grammar generated expression. This allows the user to modify the resulting
expression on the fly based on runtime variables, without including them
in the grammar. See examples section.
</p>


<h3>Value</h3>

<p>An expression
</p>


<h3>References</h3>

<p>See <a href="http://adv-r.had.co.nz/Expressions.html">http://adv-r.had.co.nz/Expressions.html</a> by Hadley Wickham.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expr = expression(function(x) {
    cbind(f1(x),
          f2(x),
          g3(y))
})
expr
ReplaceInExpression(expr, bquote(f2), function(x) {NULL})
ReplaceInExpression(expr, bquote(f2), function(x) {bquote(f2(y))})
ReplaceInExpression(expr, bquote(g3), function(x) {bquote(f3(x))})
ReplaceInExpression(expr, bquote(g3), function(x, b) {if (b &gt; 1) x else NULL}, b = 0)
ReplaceInExpression(expr, bquote(g3), function(x, b) {if (b &gt; 1) x else NULL}, b = 2)
</code></pre>

<hr>
<h2 id='summary'>Context-free Grammar Object Information</h2><span id='topic+summary.grammar'></span><span id='topic+print.summary.grammar'></span><span id='topic+GrammarStartSymbol'></span><span id='topic+GrammarGetDepth'></span><span id='topic+GrammarMaxRuleSize'></span><span id='topic+GrammarMaxSequenceLen'></span><span id='topic+GrammarNumOfExpressions'></span><span id='topic+GrammarIsRecursive'></span><span id='topic+GrammarMaxSequenceRange'></span><span id='topic+GetGrammarDepth'></span><span id='topic+GetGrammarMaxRuleSize'></span><span id='topic+GetGrammarMaxSequenceLen'></span><span id='topic+GetGrammarNumOfExpressions'></span>

<h3>Description</h3>

 
<p>Examines a context-free grammar object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'grammar'
summary(object, ...)

GrammarStartSymbol(grammar)

GrammarIsRecursive(grammar, startSymb = GrammarStartSymbol(grammar), ...)

GrammarGetDepth(grammar, max.depth = max(length(grammar$def), 4), 
    startSymb = GrammarStartSymbol(grammar), ...)

GrammarMaxSequenceLen(grammar, max.depth = GetGrammarDepth(grammar), 
    startSymb = GrammarStartSymbol(grammar), ...)

GrammarMaxRuleSize(grammar)

GrammarMaxSequenceRange(grammar, max.depth = GrammarGetDepth(grammar), 
    startSymb = GrammarStartSymbol(grammar), approximate = FALSE, ...) 

GrammarNumOfExpressions(grammar, max.depth = GrammarGetDepth(grammar), 
    startSymb = GrammarStartSymbol(grammar), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_grammar">grammar</code>, <code id="summary_+3A_object">object</code></td>
<td>

<p>A <code><a href="#topic+CreateGrammar">grammar</a></code> object.
</p>
</td></tr>
<tr><td><code id="summary_+3A_max.depth">max.depth</code></td>
<td>

<p>Maximum depth of search in case of a cyclic grammar. 
By default it is limited to the maximum of 4 or
the number of production rules in the grammar.
</p>
</td></tr>
<tr><td><code id="summary_+3A_startsymb">startSymb</code></td>
<td>

<p>The symbol where the generation of a new expression should start.
</p>
</td></tr>
<tr><td><code id="summary_+3A_approximate">approximate</code></td>
<td>

<p>If True, results are approximated. Useful for recursive grammars, where number of valid expressions prohibits an accurate measurement.
</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>

<p>unused inputs.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary</code> returns a <code>summary.grammar</code> object, with the following slots which
are obtained from the other functions:
</p>
<table role = "presentation">
<tr><td><code>Start.Symbol</code></td>
<td>
<p><code>GrammarStartSymbol</code> returns the grammar's starting symbol.</p>
</td></tr>
<tr><td><code>Is.Recursive</code></td>
<td>
<p><code>GrammarIsRecursive</code> returns TRUE if grammar contains a recursive element.</p>
</td></tr>
<tr><td><code>Tree.Depth</code></td>
<td>
<p><code>GrammarGetDepth</code> returns the depth of the grammar.
It is limited to <code>max.depth</code> for a recursive grammar.</p>
</td></tr>
<tr><td><code>Maximum.Sequence.Length</code></td>
<td>
<p><code>GrammarMaxSequenceLen</code> returns the maximum length of a sequence needed to
generate an expression without wrapping.</p>
</td></tr>
<tr><td><code>Maximum.Rule.Size</code></td>
<td>
<p><code>GrammarMaxRuleSize</code> returns the largest rule size in the grammar.</p>
</td></tr>
<tr><td><code>Maximum.Sequence.Variation</code></td>
<td>
<p><code>GrammarMaxSequenceRange</code> returns a numeric sequence, with each of its elements
holding the highest range that the same position in all sequences can hold.</p>
</td></tr>
<tr><td><code>No.of.Unique.Expressions</code></td>
<td>
<p><code>GrammarNumOfExpressions</code> returns the number of expressions a grammar can generate.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+CreateGrammar">CreateGrammar</a></code>,
<code><a href="#topic+GrammarMap">GrammarMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple grammar
# &lt;expr&gt; ::= &lt;var&gt;&lt;op&gt;&lt;var&gt;
# &lt;op&gt;   ::= + | - | *
# &lt;var&gt;  ::= A | B
ruleDef &lt;- list(expr = gsrule("&lt;var&gt;&lt;op&gt;&lt;var&gt;"),
                op   = gsrule("+", "-", "*"),
                var  = gsrule("A", "B"))

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)			   

# summarize grammar object
summary(grammarDef)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
