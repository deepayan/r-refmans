<!DOCTYPE html><html><head><title>Help for package Rdistance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rdistance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rdistance-package'><p>Rdistance - Distance Sampling Analyses for Abundance Estimation</p></a></li>
<li><a href='#abundEstim'><p>Estimate abundance from distance-sampling data</p></a></li>
<li><a href='#AIC.dfunc'><p>AICc and related fit statistics for detection function objects</p></a></li>
<li><a href='#autoDistSamp'><p>Automated classical distance analysis</p></a></li>
<li><a href='#coef.dfunc'><p>Coefficients of an estimated detection function</p></a></li>
<li><a href='#colorize'><p>colorize - Add color to result if terminal accepts it</p></a></li>
<li><a href='#cosine.expansion'><p>calculation of cosine expansion for detection function likelihoods</p></a></li>
<li><a href='#dfuncEstim'><p>Estimate a detection function from distance-sampling data</p></a></li>
<li><a href='#dfuncSmu'><p>Estimate a non-parametric smooth detection function</p>
from distance-sampling data</a></li>
<li><a href='#EDR'><p>Effective Detection Radius (EDR) for estimated detection functions</p>
with point transects</a></li>
<li><a href='#effectiveDistance'><p>Calculates the effective sampling distance for</p>
estimated detection functions</a></li>
<li><a href='#estimateN'><p>Abundance point estimates</p></a></li>
<li><a href='#ESW'><p>Line transect Effective Strip Width (ESW)</p></a></li>
<li><a href='#F.double.obs.prob'><p>Compute double observer probability of detection (No external covariates allowed)</p></a></li>
<li><a href='#F.gx.estim'><p>F.gx.estim - Estimate g(0) or g(x)</p></a></li>
<li><a href='#F.maximize.g'><p>Find the coordinate of the maximum of a distance function</p></a></li>
<li><a href='#F.nLL'><p>Return the negative log likelihood for</p>
a set of distance values</a></li>
<li><a href='#F.start.limits'><p>Set starting values and limits for parameters of Rdistance functions</p></a></li>
<li><a href='#Gamma.like'><p>Gamma.like - Gamma distance function</p></a></li>
<li><a href='#Gamma.start.limits'><p>Gamma.start.limits - Start and limit values for Gamma parameters.</p></a></li>
<li><a href='#getDfuncModelFrame'><p>Return model frame for dfunc</p></a></li>
<li><a href='#halfnorm.like'><p>Half-normal likelihood function for distance analyses</p></a></li>
<li><a href='#hazrate.like'><p>hazrate.like - Hazard rate likelihood</p></a></li>
<li><a href='#hermite.expansion'><p>Calculation of Hermite expansion for detection function likelihoods</p></a></li>
<li><a href='#integration.constant'><p>Compute the integration constant for distance density functions</p></a></li>
<li><a href='#isUnitless'><p>isUnitless - Test whether object is unitless</p></a></li>
<li><a href='#likeParamNames'><p>Likelihood parameter names</p></a></li>
<li><a href='#lines.dfunc'><p>lines.dfunc - Lines method for distance (detection) functions</p></a></li>
<li><a href='#logistic.like'><p>logistic.like - Logistic distance function likelihood</p></a></li>
<li><a href='#logistic.start.limits'><p>logistic.start.limits - Start and limit values for logistic distance function</p></a></li>
<li><a href='#negexp.like'><p>negexp.like - Negative exponential distance function</p></a></li>
<li><a href='#perpDists'><p>Compute off-transect distances from sighting distances and angles</p></a></li>
<li><a href='#plot.dfunc'><p>plot.dfunc - Plot method for distance (detection) functions</p></a></li>
<li><a href='#predict.dfunc'><p>Predict method for dfunc objects</p></a></li>
<li><a href='#print.abund'><p>Print abundance estimates</p></a></li>
<li><a href='#print.dfunc'><p>Print a distance function object</p></a></li>
<li><a href='#RdistanceControls'><p>Control parameters for <code>Rdistance</code> optimization.</p></a></li>
<li><a href='#secondDeriv'><p>Numeric second derivatives</p></a></li>
<li><a href='#simple.expansion'><p>Calculate simple polynomial expansion for detection function likelihoods</p></a></li>
<li><a href='#smu.like'><p>Smoothed likelihood function for distance analyses</p></a></li>
<li><a href='#sparrowDetectionData'><p>Brewer's Sparrow detection data</p></a></li>
<li><a href='#sparrowSiteData'><p>Brewer's Sparrow site data</p></a></li>
<li><a href='#thrasherDetectionData'><p>Sage Thrasher detection data</p></a></li>
<li><a href='#thrasherSiteData'><p>thrasherSiteData - Sage Thrasher site data.</p></a></li>
<li><a href='#uniform.like'><p>uniform.like - Uniform distance likelihood</p></a></li>
<li><a href='#uniform.start.limits'><p>uniform.start.limits - Start and limit values for uniform distance function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Distance-Sampling Analyses for Density and Abundance Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-25</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trent McDonald &lt;trent@mcdonalddatasciences.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Distance-sampling analyses estimate density and 
  abundance of organisms in ecology when detection probability declines with 
  increasing distance from the observers. Distance-sampling is popular 
  in most branches of ecology and especially when 
  organisms are observed from aerial platforms (e.g., airplane or drone), 
  surface vessels (e.g., boat or truck), or along walking transects. 
  Rdistance analyzes data collected on both point and line transects, 
  estimates overall (study area) and site-level (transect or point) 
  density, and allows users to specify regression-like formula (similar 
  to lm or glm) for covariates. A large suite of classical, 
  parametric detection functions are 
  included along with some uncommon parametric 
  functions (e.g., Gamma, negative exponential) and non-parametric
  smoothed distance functions. Custom (user-defined) detection functions
  can be implemented (see vignette).  Measurement unit integrity is 
  enforced with internal unit conversion when necessary. 
  The help files and vignettes have been 
  vetted by multiple authors and tested in workshop 
  settings. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GNU General Public License]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tmcd82070/Rdistance/wiki">https://github.com/tmcd82070/Rdistance/wiki</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tmcd82070/Rdistance/issues">https://github.com/tmcd82070/Rdistance/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), devtools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, units, crayon</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-13 03:21:26 UTC; trent</td>
</tr>
<tr>
<td>Author:</td>
<td>Trent McDonald [cre, aut],
  Jason Carlisle [aut],
  Aidan McDonald [aut] (point transect methods),
  Ryan Nielson [ctb] (smoothed likelihood),
  Ben Augustine [ctb] (maximization method),
  James Griswald [ctb] (maximization method),
  Patrick McKann [ctb] (maximization method),
  Lacey Jeroue [ctb] (vignettes),
  Hoffman Abigail [ctb] (vignettes),
  Kleinsausser Michael [ctb] (vignettes),
  Joel Reynolds [ctb] (Gamma likelihood),
  Pham Quang [ctb] (Gamma likelihood),
  Earl Becker [ctb] (Gamma likelihood),
  Aaron Christ [ctb] (Gamma likelihood),
  Brook Russelland [ctb] (Gamma likelihood),
  Stefan Emmons [ctb] (Automated tests),
  Will McDonald [ctb] (Automated tests),
  Reid Olson [ctb] (Automated tests and bug fixes)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-13 07:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rdistance-package'>Rdistance - Distance Sampling Analyses for Abundance Estimation</h2><span id='topic+Rdistance-package'></span><span id='topic+distance'></span><span id='topic+Rdistance'></span><span id='topic+point-transect'></span><span id='topic+line-transect'></span>

<h3>Description</h3>

<p><code>Rdistance</code> contains functions and associated routines to analyze
distance-sampling data collected on point or line transects. 
Some of <code>Rdistance</code>'s features include:
</p>

<ul>
<li><p> Accommodation of both point and line transect analyses 
in one routine (<code><a href="#topic+dfuncEstim">dfuncEstim</a></code>).
</p>
</li>
<li><p> Regression-like formula for inclusion of covariate in 
distance functions (<code><a href="#topic+dfuncEstim">dfuncEstim</a></code>).
</p>
</li>
<li><p> Automatic bootstrap confidence intervals 
(<code><a href="#topic+abundEstim">abundEstim</a></code>).
</p>
</li>
<li><p> Availability of both study-area and site-level abundance
estimates (<code><a href="#topic+abundEstim">abundEstim</a></code>).
</p>
</li>
<li><p> Classical, parametric distance functions
(<code><a href="#topic+halfnorm.like">halfnorm.like</a></code>, <code><a href="#topic+hazrate.like">hazrate.like</a></code>), and
expansion functions (<code><a href="#topic+cosine.expansion">cosine.expansion</a></code>, 
<code><a href="#topic+hermite.expansion">hermite.expansion</a></code>, <code><a href="#topic+simple.expansion">simple.expansion</a></code>).
</p>
</li>
<li><p> Non-classic distance functions (<code><a href="#topic+Gamma.like">Gamma.like</a></code>, 
<code><a href="#topic+negexp.like">negexp.like</a></code>, <code><a href="#topic+uniform.like">uniform.like</a></code>) 
and a non-parametric smoother 
<code><a href="#topic+dfuncSmu">dfuncSmu</a></code>).
</p>
</li>
<li><p> User defined distance functions. 
</p>
</li>
<li><p> Automated distance function fits and selection 
<code><a href="#topic+autoDistSamp">autoDistSamp</a></code>.
</p>
</li>
<li><p> Extended vignettes.
</p>
</li>
<li> <p><code>print</code>, <code>plot</code>, <code>predict</code>, <code>coef</code>, 
and <code>summary</code> 
methods for distance function objects and abundance classes.
</p>
</li></ul>



<h3>Background</h3>

<p>Distance-sampling is a popular method for abundance estimation in
ecology. Line transect surveys are conducted by traversing
randomly placed transects in a study area with the objective of
sighting animals and estimating density or abundance.  Data collected
during line transect surveys consists of sighting records for
<em>targets</em>, usually either individuals or groups of individuals.  Among
the collected data, off-transect distances are 
recorded or computed from
other information (see
<code><a href="#topic+perpDists">perpDists</a></code>).  Off-transect distances are the perpendicular
distances from the transect to the location of the initial sighting cue.
The actual locations of sighted targets are often recorded or computed.
When groups are the target, the number of individuals in the group is
recorded.
</p>
<p>Point transect surveys are similar except that observers stop one 
or more times along the transect to observe targets.  This is a 
popular method for avian surveys where detections are often auditory 
cues, but is also appropriate when automated detectors are placed along
a route.  Point transect surveys collect distances from the observer to 
the target and are sometimes called <em>radial</em> distances.   
</p>
<p>A fundamental characteristic of both line and point-based 
distance sampling analyses is that
probability of detecting a target declines as
off-transect or radial distances increase. Targets far from 
the observer are usually 
harder to detect than closer targets.  In most
classical line transect studies, targets on the transect (off-transect
distance = 0) are assume to be sighted with 100% probability.  This
assumption allows estimation of the proportion of targets missed during the
survey, and thus it is possible to adjust the actual number of 
sighted targets for the proportion of targets missed. 
Some studies utilize two observers searching the same areas to
estimate the proportion of individuals missed and thereby eliminating the
assumption that all individuals on the line have been observed.
</p>


<h3>Relationship to other software</h3>

<p>A detailed comparison of
<code>Rdistance</code> to other options for distance sampling analysis (e.g.,
Program DISTANCE, R package <code>Distance</code>, and R package <code>unmarked</code>)
is forthcoming.  While some of the functionality in <code>Rdistance</code> 
is not unique, our aim is to provide an easy-to-use, rigorous,
and flexible analysis option for distance-sampling data.  
We understand that beginning
users often need software that is both easy to use and easy to understand,
and that advanced users often require greater flexibility and customization.
Our aim is to meet the demands of both user groups.  <code>Rdistance</code> is
under active development, so please contact us with issues, feature
requests, etc. through the package's GitHub website
(<a href="https://github.com/tmcd82070/Rdistance">https://github.com/tmcd82070/Rdistance</a>).
</p>


<h3>Data sets</h3>

<p><code>Rdistance</code> contains four example data sets: two collected using 
line-transect methods (i.e., <code><a href="#topic+sparrowDetectionData">sparrowDetectionData</a></code> and
<code><a href="#topic+sparrowSiteData">sparrowSiteData</a></code>) and two collected using point-transect
(sometimes called a point count) methods (i.e.,
<code><a href="#topic+thrasherDetectionData">thrasherDetectionData</a></code> and <code><a href="#topic+thrasherSiteData">thrasherSiteData</a></code>).
</p>
<p>These datasets demonstrate the type and format of input data required by
<code>Rdistance</code> to estimate a detection function and abundance from
distance sampling data collected by surveying line transects or point
transects.  They also allow the user to step through the tutorials described
in the package vignettes.  
</p>
<p><code>Rdistance</code> requires only  detection data to fit 
detection functions, assuming  no covariates in the detection function
(see <code><a href="#topic+dfuncEstim">dfuncEstim</a></code>).  Both detection and
site data are required to estimate abundance or to include
site-level covariates in the detection function (see
<code><a href="#topic+abundEstim">abundEstim</a></code>).
</p>


<h3>Resources</h3>

<p>The best place to start learning about <code>Rdistance</code>
is at the package's GitHub Wiki, which hosts several tutorial vignettes and
FAQs (<a href="https://github.com/tmcd82070/Rdistance/wiki">https://github.com/tmcd82070/Rdistance/wiki</a>).
Additionally, the examples in the help files for
<code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+abundEstim">abundEstim</a></code>, and
<code><a href="#topic+autoDistSamp">autoDistSamp</a></code> highlight the package's primary functionality.
</p>
<p>A list of routines can be obtained by loading <code>Rdistance</code> and issuing
<code>help(package="Rdistance")</code>.
</p>


<h3>Author(s)</h3>

<p>Main author and maintainer: Trent McDonald
&lt;trent@mcdonalddatasciences.com&gt;
</p>
<p>Coauthors: Ryan Nielson, Jason Carlisle, and Aidan McDonald
</p>
<p>Contributors: Ben Augustine, James Griswald, Joel Reynolds, Pham Quang, Earl
Becker, Aaron Christ, Brook Russelland, Patrick McKann, Lacey Jeroue, 
Abigail Hoffman, Michael Kleinsasser, and Ried Olson
</p>

<hr>
<h2 id='abundEstim'>Estimate abundance from distance-sampling data</h2><span id='topic+abundEstim'></span>

<h3>Description</h3>

<p>Estimate abundance (or density) given an estimated detection
function and supplemental information on observed group sizes, transect
lengths, area surveyed, etc.  Also computes confidence intervals on
abundance (or density) using a the bias corrected bootstrap method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abundEstim(
  dfunc,
  detectionData,
  siteData,
  area = NULL,
  singleSided = FALSE,
  ci = 0.95,
  R = 500,
  lengthColumn = "length",
  plot.bs = FALSE,
  showProgress = TRUE,
  control = RdistanceControls()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abundEstim_+3A_dfunc">dfunc</code></td>
<td>
<p>An estimated 'dfunc' object produced by <code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_detectiondata">detectionData</code></td>
<td>
<p>A data frame containing detection distances 
(either perpendicular for line-transect or radial for point-transect
designs), with one row per detected object or group.   
This data frame must contain at least the following 
information: 
</p>

<ul>
<li><p> Detection Distances: A single column containing 
detection distances must be specified on the left-hand 
side of <code>formula</code>.  As of Rdistance version 3.0.0, 
the detection distances must have measurement units attached. 
Attach measurements units to distances using <code>library(units);units()&lt;-</code>.
For example, <code>library(units)</code> followed by <code>units(df$dist) &lt;- "m"</code> or 
<code>units(df$dist) &lt;- "ft"</code> will work. Alternatively, 
<code>df$dist &lt;- units::set_units(df$dist, "m")</code> also works.
</p>
</li>
<li><p> Site IDs: The ID of the transect or point 
(i.e., the 'site') where each object or group was detected.
The site ID  column(s) (see arguments <code>transectID</code> and
<code>pointID</code>) must 
specify the site (transect or point) so that this 
data frame can be merged with <code>siteData</code>.    
</p>
</li>
<li><p> In a later release, <code>Rdistance</code> will allow detection-level 
covariates.  When that happens, detection-level 
covariates will appear in this data frame. 
</p>
</li></ul>

<p>See example data set <code><a href="#topic+sparrowDetectionData">sparrowDetectionData</a></code>.
See also <b>Input data frames</b> below 
for information on when <code>detectionData</code> and 
<code>siteData</code> are required inputs.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_sitedata">siteData</code></td>
<td>
<p>A data.frame containing site (transect or point)
IDs and any 
<em>site level</em> covariates to include in the detection function. 
Every unique surveyed site (transect or point) is represented on
one row of this data set, whether or not targets were sighted 
at the site.  See arguments <code>transectID</code> and 
<code>pointID</code> for an explanation of the way in which distance and site 
data frames are merged.  See 
section <b>Relationship between data frames (transect and point ID's)</b>
for additional details.
</p>
<p>See <b>Data frame requirements</b> for situations in which 
<code>detectionData</code> only, <code>detectionData</code> and <code>siteData</code>, or 
neither are required.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_area">area</code></td>
<td>
<p>A scalar containing the total area of 
inference. Commonly, this is study area size.  
If <code>area</code> is NULL (the default), 
<code>area</code> will be set to 1 square unit of the output units and this
produces abundance estimates equal density estimates. 
If <code>area</code> is not NULL, it must have measurement units 
assigned by the <code>units</code> package. 
The units on <code>area</code> must be convertible
to squared output units. Units 
on <code>area</code> must be two-dimensional. 
For example, if output units are &quot;foo&quot;, 
units on area must be convertible to &quot;foo^2&quot; by the <code>units</code>
package. 
Units of &quot;km^2&quot;, &quot;cm^2&quot;, &quot;ha&quot;, &quot;m^2&quot;, &quot;acre&quot;, &quot;mi^2&quot;, and many
others are acceptable.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_singlesided">singleSided</code></td>
<td>
<p>Logical scaler. If only one side of the transect was 
observed, set <code>singleSided</code> = TRUE. If both sides of line-transects were 
observed, <code>singleSided</code> = FALSE. Some surveys
observe only one side of transect lines for a variety of logistical reasons. 
For example, some aerial line-transect surveys place observers on only one
side of the aircraft. This parameter effects only line-transects.  When 
<code>singleSided</code> = TRUE, surveyed area is halved and the density 
estimator's denominator (see <b>Details</b>)
is <code class="reqn">(ESW)(L)</code>, not <code class="reqn">2(ESW)(L)</code>.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_ci">ci</code></td>
<td>
<p>A scalar indicating the confidence level of confidence intervals. 
Confidence intervals are computed using a bias corrected bootstrap
method. If <code>ci = NULL</code>, confidence intervals are not computed.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_r">R</code></td>
<td>
<p>The number of bootstrap iterations to conduct when <code>ci</code> is not
NULL.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_lengthcolumn">lengthColumn</code></td>
<td>
<p>Character string specifying the (single) column in 
<code>siteData</code> that contains transect lengths. This is ignored if 
<code>pointSurvey</code> = TRUE. This column must have measurement units.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_plot.bs">plot.bs</code></td>
<td>
<p>A logical scalar indicating whether to plot individual
bootstrap iterations.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_showprogress">showProgress</code></td>
<td>
<p>A logical indicating whether to show a text-based
progress bar during bootstrapping. Default is <code>TRUE</code>. 
It is handy to shut off the 
progress bar if running this within another function. Otherwise, 
it is handy to see progress of the bootstrap iterations.</p>
</td></tr>
<tr><td><code id="abundEstim_+3A_control">control</code></td>
<td>
<p>A list containing optimization control parameters such 
as the maximum number of iterations, tolerance, the optimizer to use, 
etc.  See the 
<code><a href="#topic+RdistanceControls">RdistanceControls</a></code> function for explanation of each value,
the defaults, and the requirements for this list. 
See examples below for how to change controls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The abundance estimate for line-transect surveys (if no covariates
are included in the detection function and both sides of the transect 
were observed) is 
</p>
<p style="text-align: center;"><code class="reqn">N =\frac{n(A)}{2(ESW)(L)}</code>
</p>
 
<p>where <em>n</em> is total number of sighted individuals 
(i.e., <code>sum(dfunc$detections$groupSizes)</code>), <em>L</em> is the total length of 
surveyed transect (i.e., <code>sum(siteData[,lengthColumn])</code>),
and <em>ESW</em> is effective strip width
computed from the estimated distance function (i.e., <code>ESW(dfunc)</code>).
If only one side of transects were observed, the &quot;2&quot; in the denominator 
is not present (or, replaced with a &quot;1&quot;). 
</p>
<p>The abundance estimate for point transect surveys (if no covariates are
included) is 
</p>
<p style="text-align: center;"><code class="reqn">N =\frac{n(A)}{\pi(ESR^2)(P)}</code>
</p>
 
<p>where <em>n</em> is total number of sighted individuals,
<em>P</em> is the total number of surveyed points, 
and <em>ESR</em> is effective search radius 
computed from the estimated distance function (i.e., <code>ESR(dfunc)</code>).
</p>
<p>Setting <code>plot.bs=FALSE</code> and <code>showProgress=FALSE</code> 
suppresses all intermediate output.
</p>


<h3>Value</h3>

<p>An 'abundance estimate' object, which is a list of
class <code>c("abund", "dfunc")</code>, containing all the components of a &quot;dfunc&quot;
object (see <code><a href="#topic+dfuncEstim">dfuncEstim</a></code>), plus the following: 
</p>
<table>
<tr><td><code>density</code></td>
<td>
<p>Estimated density on the sampled area with units. The <em>effectively</em>
sampled area is 2*L*ESW (not 2*L*w.hi). Density has squared units of the 
requested output units.  Convert density to other units with  
<code>units::set_units(x$density, "&lt;units&gt;").</code></p>
</td></tr> 
<tr><td><code>n.hat</code></td>
<td>
<p>Estimated abundance on the study area (if <code>area</code> &gt;
1) or estimated density on the study area (if <code>area</code> = 1), without units.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of detections (not individuals, unless all group sizes = 1) 
on non-NA length transects
used to compute density and abundance.</p>
</td></tr>
<tr><td><code>n.seen</code></td>
<td>
<p>The total number of individuals seen on transects with non-NA
length. Sum of group sizes used 
to estimate density and abundance.</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>Total area of inference in squared output units.</p>
</td></tr>
<tr><td><code>surveyedUnits</code></td>
<td>
<p>The total length of sampled transect with units. This is the sum 
of the <code>lengthColumn</code> column of <code>siteData</code>. </p>
</td></tr>
<tr><td><code>avg.group.size</code></td>
<td>
<p>Average group size on transects with non-NA length transects.</p>
</td></tr>
<tr><td><code>rng.group.size</code></td>
<td>
<p>Minimum and maximum groupsizes observed on non-NA length transects.</p>
</td></tr>
<tr><td><code>effDistance</code></td>
<td>
<p>A vector containing effective sample distance.  If covariates
are not included, length of this vector is 1 because effective sampling distance 
is constant over detections. If covariates are included, this vector has length
equal to the number of detections (i.e., <code>x$n</code>).  This vector was produced 
by a call to <code>effectiveDistance()</code> with <code>newdata</code> set to NULL.</p>
</td></tr>
<tr><td><code>n.hat.ci</code></td>
<td>
<p>A vector containing the lower and upper limits of the 
bias corrected bootstrap confidence interval for
abundance. </p>
</td></tr> 
<tr><td><code>density.ci</code></td>
<td>
<p>A vector containing the lower and upper limits of the 
bias corrected bootstrap confidence interval for
density, with units.
</p>
</td></tr>
<tr><td><code>effDistance.ci</code></td>
<td>
<p>A vector containing the lower and upper limits of the 
bias corrected bootstrap confidence interval for <em>average</em>
effective sampling distance.
</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>A data frame containing bootstrap values of coefficients, 
density, and effective distances.  Number of rows is always 
<code>R</code>, the requested number of bootstrap 
iterations.  If a particular iteration did not converge, the
corresponding row in <code>B</code> is <code>NA</code> (hence, use 'na.rm = TRUE' 
when computing summaries). Columns 1 through <code>length(coef(dfunc))</code>
contain bootstrap realizations of the distance function's coefficients. 
The second to last column contains bootstrap values of
density (with units).  The last column of B contains bootstrap 
values of effective sampling distance or radius (with units). If the 
distance function contains covariates,
the effective sampling distance column is the average 
effective distance over detections 
used during the associated bootstrap iteration. </p>
</td></tr>
<tr><td><code>nItersConverged</code></td>
<td>
<p>The number of bootstrap iterations that converged.  </p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The (scalar) confidence level of the
confidence interval for <code>n.hat</code>.</p>
</td></tr>
</table>


<h3>Bootstrap Confidence Intervals</h3>

<p>The bootstrap confidence interval for abundance 
assumes that the fundamental units of
replication (lines or points, hereafter &quot;sites&quot;) are independent.
The bias corrected bootstrap
method used here resamples the units of replication (sites), 
refits the distance function, and estimates abundance using 
the resampled counts and re-estimated distance function. 
The original data frames, <code>detectionData</code> and <code>siteData</code>, 
are needed here for bootstrapping because they contain the transect 
and detection information.
If a double-observer data
frame is included in <code>dfunc</code>, rows of the double-observer data frame
are re-sampled each bootstrap iteration. 
</p>
<p>This routine does not 
re-select the distance model fitted to resampled data.  The 
model in the input object is re-fitted every iteration.  
</p>
<p>By default, <code>R</code> = 500 iterations are performed, after which the bias
corrected confidence intervals are computed (Manly, 1997, section 3.4).
</p>
<p>During bootstrap iterations, the distance function can fail 
to converge on the resampled data.   An iteration can fail 
to converge for a two reasons:
(1) no detections on the iteration, and (2) bad configuration 
of distances on the iteration which pushes parameters to their 
bounds. When an iteration fails to produce a valid 
distance function, <code>Rdistance</code> 
simply skips the intration, effectively ignoring these 
non-convergent iterations. 
If the proportion of non-convergent iterations is small 
(less than 20
on abundance is 
probably valid.  If the proportion of non-convergent iterations 
is not small (exceeds 20
The print method (<code>print.abund</code>) is the routine that  issues this 
warning. The warning can be 
turned off by setting <code>maxBSFailPropForWarning</code> in the 
print method to 1.0, or by modifying the code in <code>RdistanceControls()</code>
to re-set the default threshold and storing the modified 
function in your <code>.GlobalEnv</code>.  Additional iterations may be needed 
to achieve an adequate number. Check number of convergent iterations by 
counting non-NA rows in output data frame 'B'.
</p>


<h3>Missing Transect Lengths</h3>

<p><b>Line transects</b>: The transect length column of <code>siteData</code> can contain missing values. 
NA length transects are equivalent
to 0 [m] transects and do not count toward total surveyed units.  NA length
transects are handy if some off-transect distance observations should be included
when estimating the distance function, but not when estimating abundance. 
To do this, include the &quot;extra&quot; distance observations in the detection data frame, with valid
site IDs, but set the length of those site IDs to NA in the site data frame. 
Group sizes associated with NA length transects are dropped and not counted toward density
or abundance. Among other things, this allows estimation of abundance on one 
study area using off-transect distance observations from another.  
</p>
<p><b>Point transects</b>: Point transects do not have length. The &quot;length&quot; of point transects
is the number of points on the transect. <code>Rdistance</code> treats individual points as independent 
and bootstrap resampmles them to estimate variance. To include distance obervations
from some points but not the number of targets seen, include a separate &quot;length&quot; column 
in the site data frame with NA for the &quot;extra&quot; points. Like NA length line transects, 
NA &quot;length&quot; point transects are dropped from the count of points and group sizes on these 
transects are dropped from the counts of targets.  This allows users to estimate their distance 
function on one set of observations while inflating counts from another set of observations.  
A transect &quot;length&quot; column is not required for point transects. Values in the <code>lengthColumn</code>
do not matter except for NA (e.g., a column of 1's mixed with NA's is acceptable).
</p>


<h3>References</h3>

<p>Manly, B.F.J. (1997) <em>Randomization, bootstrap, and 
Monte-Carlo methods in biology</em>, London: Chapman and Hall.
</p>
<p>Buckland, S.T., D.R. Anderson, K.P. Burnham, J.L. Laake, D.L. Borchers,
and L. Thomas. (2001) <em>Introduction to distance sampling: estimating
abundance of biological populations</em>. Oxford University Press, Oxford, UK.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+autoDistSamp">autoDistSamp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example sparrow data (line transect survey type)
data(sparrowDetectionData)
data(sparrowSiteData)

# Fit half-normal detection function
dfunc &lt;- dfuncEstim(formula=dist ~ groupsize(groupsize)
                    , detectionData=sparrowDetectionData
                    , likelihood="halfnorm"
                    , w.hi=units::set_units(100, "m")
                    )

# Estimate abundance given a detection function
# No variance on density or abundance estimated here 
# due to time constraints.  Set ci=0.95 (or another value)
# to estimate bootstrap variances on ESW, density, and abundance.

fit &lt;- abundEstim(dfunc
                , detectionData = sparrowDetectionData
                , siteData = sparrowSiteData
                , area = units::set_units(4105, "km^2")
                , ci = NULL
                )
         
</code></pre>

<hr>
<h2 id='AIC.dfunc'>AICc and related fit statistics for detection function objects</h2><span id='topic+AIC.dfunc'></span>

<h3>Description</h3>

<p>Computes AICc, AIC, or BIC for estimated distance functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfunc'
AIC(object, ..., criterion = "AICc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.dfunc_+3A_object">object</code></td>
<td>
<p>An estimated detection function object.  An estimated detection 
function object has class 'dfunc', and is usually produced by a call to 
<code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="AIC.dfunc_+3A_...">...</code></td>
<td>
<p>Required for compatibility with the general <code>AIC</code> method.  Any 
extra arguments to this function are ignored.</p>
</td></tr>
<tr><td><code id="AIC.dfunc_+3A_criterion">criterion</code></td>
<td>
<p>String specifying the criterion to compute. Either 
&quot;AICc&quot;, &quot;AIC&quot;, or &quot;BIC&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regular Akaike's information criterion 
(<a href="https://en.wikipedia.org/wiki/Akaike_information_criterion">https://en.wikipedia.org/wiki/Akaike_information_criterion</a>) (<code class="reqn">AIC</code>) is 
</p>
<p style="text-align: center;"><code class="reqn">AIC = LL + 2p,</code>
</p>

<p>where <code class="reqn">LL</code> is the maximized value of the log likelihood 
(the minimized value of the negative log 
likelihood) and <code class="reqn">p</code> is the 
number of coefficients estimated in the detection function.  For 
<code>dfunc</code> objects, <code class="reqn">AIC</code> = <code>obj$loglik + 2*length(coef(obj))</code>.  
</p>
<p>A correction 
for small sample size, <code class="reqn">AIC_c</code>, is 
</p>
<p style="text-align: center;"><code class="reqn">AIC_c = LL + 2p + \frac{2p(p+1)}{n-p-1},</code>
</p>
 
<p>where <code class="reqn">n</code> is sample 
size or number of detected groups for distance analyses.  By default, this function 
computes <code class="reqn">AIC_c</code>.   <code class="reqn">AIC_c</code> converges quickly to <code class="reqn">AIC</code> 
as <code class="reqn">n</code> increases.
</p>
<p>The Bayesian Information Criterion (BIC) is
</p>
<p style="text-align: center;"><code class="reqn">BIC = LL + log(n)p,</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>A scalar. By default, the value of AICc for the 
estimated distance function <code>obj</code>.
</p>


<h3>References</h3>

<p>Burnham, K. P., and D. R. Anderson, 2002. 
<em>Model selection and multi-model inference: 
A practical information-theoretic approach, Second ed.</em> 
Springer-Verlag. ISBN 0-387-95364-7.
</p>
<p>McQuarrie, A. D. R., and Tsai, C.-L., 1998. <em>Regression and 
time series model selection.</em> 
World Scientific. ISBN 981023242X
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="#topic+dfuncEstim">dfuncEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(sparrowDetectionData)
  dfunc &lt;- dfuncEstim(dist~1,
                      detectionData=sparrowDetectionData, 
                      w.hi=units::set_units(150, "m"))
  
  # Compute fit statistics
  AIC(dfunc)  # AICc
  AIC(dfunc, criterion="AIC")  # AIC
  AIC(dfunc, criterion="BIC")  # BIC
</code></pre>

<hr>
<h2 id='autoDistSamp'>Automated classical distance analysis</h2><span id='topic+autoDistSamp'></span>

<h3>Description</h3>

<p>Perform automated classical detection function selection and 
estimation of abundance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoDistSamp(
  formula,
  detectionData,
  siteData,
  w.lo = 0,
  w.hi = NULL,
  likelihoods = c("halfnorm", "hazrate", "uniform", "negexp", "Gamma"),
  series = c("cosine", "hermite", "simple"),
  expansions = 0:3,
  pointSurvey = FALSE,
  warn = TRUE,
  area = NULL,
  ci = 0.95,
  R = 500,
  plot.bs = FALSE,
  showProgress = TRUE,
  plot = TRUE,
  criterion = "AICc",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoDistSamp_+3A_formula">formula</code></td>
<td>
<p>This parameter is passed to <code>dfuncEstim</code>.
See <code>dfuncEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_detectiondata">detectionData</code></td>
<td>
<p>This parameter is passed to <code>dfuncEstim</code> 
and <code>abundEstim</code>. See <code>abundEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_sitedata">siteData</code></td>
<td>
<p>This parameter is passed to <code>abundEstim</code>.
See <code>abundEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_w.lo">w.lo</code></td>
<td>
<p>This parameter is passed to <code>dfuncEstim</code>.
See <code>dfuncEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_w.hi">w.hi</code></td>
<td>
<p>This parameter is passed to <code>dfuncEstim</code>.
See <code>dfuncEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_likelihoods">likelihoods</code></td>
<td>
<p>Vector of strings specifying the 
likelihoods to consider during model selection. Valid values 
at present are &quot;uniform&quot;, &quot;halfnorm&quot;, &quot;hazrate&quot;, &quot;negexp&quot;, 
and &quot;Gamma&quot;. See Details for the models this routine considers.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_series">series</code></td>
<td>
<p>Vector of series types to consider during model selection. 
Valid values are 'simple', 'hermite', and 'cosine'. See Details for 
the models this routine considers.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_expansions">expansions</code></td>
<td>
<p>Vector of the number of expansion terms to 
consider during model selection. Valid values are 0 through 3. 
See Details for the models this routine considers. Note, expansion terms are not currently
allowed in models with covariates.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>This parameter is passed to <code>dfuncEstim</code>.
See <code>dfuncEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_warn">warn</code></td>
<td>
<p>This parameter is passed to <code>dfuncEstim</code>.
<code>dfuncEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_area">area</code></td>
<td>
<p>This parameter is passed to <code>abundEstim</code>.
See <code>abundEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_ci">ci</code></td>
<td>
<p>This parameter is passed to <code>abundEstim</code>.
See <code>abundEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_r">R</code></td>
<td>
<p>This parameter is passed to <code>abundEstim</code>.
See <code>abundEstim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_plot.bs">plot.bs</code></td>
<td>
<p>Logical for whether to plot bootstrap 
iterations after the top model has been selected and 
during final estimation of confidence intervals.  
This parameter is passed unchanged to <code>abundEstim</code>.
See <code>abundEstim</code> help for additional information.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_showprogress">showProgress</code></td>
<td>
<p>Logical for whether to 
suppress intermediate output.  If <code>showProgress=TRUE</code>, 
a table of model fitting results appears in the console as they 
are estimated, and a progress bar shows progress through 
the bootstrap iterations at the end.  If <code>showProgress=FALSE</code>, 
all intermediate output is suppressed which is handy for programming
and simulations.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_plot">plot</code></td>
<td>
<p>Logical scalar specifying whether to plot models during model selection. 
If <code>TRUE</code>, a histogram with fitted distance function is plotted for every fitted model. 
The function pauses between each plot and prompts the user for whether they want to continue or not. 
For completely automated estimation, set <code>plot</code> = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_criterion">criterion</code></td>
<td>
<p>A string specifying the criterion to use when assessing model fit.
The best fitting model from this routine is the one with lowest value 
of this fit criterion.  This must be one of &quot;AICc&quot; (the default), 
&quot;AIC&quot;, or &quot;BIC&quot;.  See <code><a href="#topic+AIC.dfunc">AIC.dfunc</a></code> for formulas.</p>
</td></tr>
<tr><td><code id="autoDistSamp_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>dfuncEstim</code>, which in turn are passed to <code>F.gx.estim</code>. 
These include <code>x.scl</code>, <code>g.x.scl</code>, and <code>observer</code> for estimating double observer probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>During model selection, each series and number of expansions is crossed with 
each of the likelihoods. For example, if <code>likelihoods</code> has 3 elements, 
<code>series</code> has 2 elements, and <code>expansions</code> has 4 elements, 
the total number of models fitted is 3 (likelihoods) * 2 (series) * 4 (expansions) 
= 24 models.  The default specification fits 41 detection functions 
from the &quot;halfnorm&quot;, &quot;hazrate&quot;, &quot;uniform&quot;, &quot;negexp&quot;, and &quot;Gamma&quot; likelihoods 
(note that Gamma does not currently implement expansions, see 
<code><a href="#topic+Gamma.like">Gamma.like</a></code>). Note, expansion terms are not currently
allowed in models with covariates.  The model with lowest AIC is selected 
as 'best', and estimation of abundance proceeds using that model.
</p>
<p>Suppress all intermediate output using <code>plot.bs=FALSE</code>, 
<code>showProgress=FALSE</code>, and <code>plot=FALSE</code>.
</p>


<h3>Value</h3>

<p>If <code>bySite==FALSE</code>, an 'abundance estimate' object is returned.
See <code>abundEstim</code> 
and <code>dfuncEstim</code> for an explanation of components. 
Returned abundance estimates are based 
on the best fitting distance function among those fitted.
A fit table, sorted by the criterion, is returned as component
<code>$fitTable</code>.  The fit table component contains columns
<code>like</code> (likelihood), <code>series</code>, <code>expansions</code>,
<code>converge</code> (0=converged,1=not), <code>scale</code> (1=passed scale
check,0=did not pass), and 
<code>aic</code> (the criterion used). 
</p>
<p>If <code>bySite==TRUE</code>, a data frame containing site-level
abundance based on the best-fitting detection function is returned.
See <code><a href="#topic+abundEstim">abundEstim</a></code> for description of columns in 
the data frame.  The best-fitting likelihood form, series, 
and number of expansions are returned as attributes of the 
data frame (e.g., best-fitting likelihood is <code>attr(out,"like.form")</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+abundEstim">abundEstim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example sparrow data (line transect survey type)
data(sparrowDetectionData)
data(sparrowSiteData)

# Automate fitting multiple detection functions, and estimate abundance
# (density per ha in this case), given the 'best' detection function
autoDistSamp(formula = dist ~ groupsize(groupsize)
           , detectionData = sparrowDetectionData
           , siteData = sparrowSiteData
           , likelihood = c("halfnorm", "hazrate")
           , w.hi = units::set_units(100, "m")
           , expansions = 0
           , area = units::set_units( 4105, "km^2" )
           , ci = NULL
           , plot = FALSE
           )
           
</code></pre>

<hr>
<h2 id='coef.dfunc'>Coefficients of an estimated detection function</h2><span id='topic+coef.dfunc'></span>

<h3>Description</h3>

<p>Extract the coefficients and estimated parameters (if any) from 
a estimated detection function object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfunc'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.dfunc_+3A_object">object</code></td>
<td>
<p>An estimated distance function object.  An estimated distance 
function object has class 'dfunc', and is usually produced by a call to 
<code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="coef.dfunc_+3A_...">...</code></td>
<td>
<p>Required for compatibility with the general <code>coef</code> method.  Any 
extra arguments to this function are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an extractor function for the parameters of an estimated detection function. 
This function is equivalent to <code>obj$parameters</code> for classical detection functions.
</p>


<h3>Value</h3>

<p>The estimated parameter vector for the detection function. Length and interpretation of values 
in this vector vary depending on the form of the detection function and expansion terms.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="#topic+dfuncEstim">dfuncEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example sparrow data (line transect survey type)
data(sparrowDetectionData)

# Fit half-normal detection function
dfunc &lt;- dfuncEstim(formula=dist~1
                  , detectionData=sparrowDetectionData)

# Print results
dfunc
  
# Extract the coefficient(s)
coef(dfunc)

</code></pre>

<hr>
<h2 id='colorize'>colorize - Add color to result if terminal accepts it</h2><span id='topic+colorize'></span>

<h3>Description</h3>

<p>Add ANSI color to a string using the 
<code>crayon</code> package, if the R environment accepts color. 
This function is needed because of the need to determine whether 
output can be colorized.  This determination is left up to 
<code>crayon::has_color()</code>. 
</p>
<p>In addition, for Rdistance results, we want to only colorize 
numbers, not the reporting units.  Everything between the last set 
of square brackets (<code>[...]</code>) is NOT colorized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorize(STR, col = NULL, bg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorize_+3A_str">STR</code></td>
<td>
<p>The string to colorize.</p>
</td></tr>
<tr><td><code id="colorize_+3A_col">col</code></td>
<td>
<p>A string specifying the desired foreground color.
This is passed straight to <code>crayon::style</code> and so must be 
recognized as one of the 8 base crayon colors. i.e., 
&quot;black&quot;, &quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;magenta&quot;, &quot;cyan&quot;, 
&quot;white&quot;, and &quot;silver&quot; (silver = gray). By default, numbers 
are styled in &quot;green&quot;.</p>
</td></tr>
<tr><td><code id="colorize_+3A_bg">bg</code></td>
<td>
<p>A string specifying the desired background color. 
Must be one of &quot;bgBlack&quot;, &quot;bgRed&quot;, &quot;bgGreen&quot;, &quot;bgYellow&quot;, &quot;bgBlue&quot;
&quot;bgMagenta&quot;, &quot;bgCyan&quot;, or &quot;bgWhite&quot;.  By default, no background 
is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If color is not allowed in the terminal, the input 
string is returned unperturbed.  If color is allowed, the input 
string is returned with color and background ANSI code surrounding 
the initial part of the string from character 1 to the character 
before the [ in the last pair of [].
</p>


<h3>See Also</h3>

<p><code>crayon::style</code>
</p>

<hr>
<h2 id='cosine.expansion'>calculation of cosine expansion for detection function likelihoods</h2><span id='topic+cosine.expansion'></span>

<h3>Description</h3>

<p>Computes the cosine expansion terms used in the likelihood of a distance analysis. 
More generally, will compute a cosine expansion of any numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosine.expansion(x, expansions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosine.expansion_+3A_x">x</code></td>
<td>
<p>In a distance analysis, <code>x</code> is a numeric vector of the proportion of a strip transect's half-width 
at which a group of individuals were sighted.  If <code class="reqn">w</code> is the strip transect half-width or maximum sighting 
distance, and <code class="reqn">d</code> is the perpendicular off-transect distance to a sighted group (<code class="reqn">d\leq w</code>), 
<code>x</code> is usually <code class="reqn">d/w</code>.  More generally, <code>x</code> is a vector of numeric values</p>
</td></tr>
<tr><td><code id="cosine.expansion_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of expansion terms to compute. Must be one of the 
integers 1, 2, 3, 4, or 5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are, in general, several expansions that can be called cosine. The cosine expansion used here is:
</p>

<ul>
<li> <p><b>First term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_1(x)=\cos(2\pi x),</code>
</p>

</li>
<li> <p><b>Second term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_2(x)=\cos(3\pi x),</code>
</p>

</li>
<li> <p><b>Third term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_3(x)=\cos(4\pi x),</code>
</p>

</li>
<li> <p><b>Fourth term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_4(x)=\cos(5\pi x),</code>
</p>

</li>
<li> <p><b>Fifth term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_5(x)=\cos(6\pi x),</code>
</p>

</li></ul>

<p>The maximum number of expansion terms computed is 5.
</p>


<h3>Value</h3>

<p>A matrix of size <code>length(x)</code> X <code>expansions</code>.  The columns of this matrix are the cosine expansions of 
<code>x</code>. Column 1 is the first expansion term of <code>x</code>, column 2 is the second expansion term of <code>x</code>, and so on 
up to <code>expansions</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+hermite.expansion">hermite.expansion</a></code>, <code><a href="#topic+simple.expansion">simple.expansion</a></code>, and the discussion 
of user defined likelihoods in <code><a href="#topic+dfuncEstim">dfuncEstim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(33328)
  x &lt;- rnorm(1000) * 100
  x &lt;- x[ 0 &lt; x &amp; x &lt; 100 ]
  cos.expn &lt;- cosine.expansion(x, 5)
</code></pre>

<hr>
<h2 id='dfuncEstim'>Estimate a detection function from distance-sampling data</h2><span id='topic+dfuncEstim'></span>

<h3>Description</h3>

<p>Fit a specific detection function to off-transect 
or off-point (radial) distances using maximum likelihood. 
Distance functions are fitted to individual 
distance observations, not histogram bin heights, despite plot methods 
that draw histogram bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfuncEstim(
  formula,
  detectionData,
  siteData,
  likelihood = "halfnorm",
  pointSurvey = FALSE,
  w.lo = units::set_units(0, "m"),
  w.hi = NULL,
  expansions = 0,
  series = "cosine",
  x.scl = units::set_units(0, "m"),
  g.x.scl = 1,
  observer = "both",
  warn = TRUE,
  transectID = NULL,
  pointID = "point",
  outputUnits = NULL,
  control = RdistanceControls()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfuncEstim_+3A_formula">formula</code></td>
<td>
<p>A standard formula object (e.g., <code>dist ~ 1</code>, 
<code>dist ~ covar1 + covar2</code>). The left-hand side (before <code>~</code>)
is the name of the vector containing distances (off-transect or 
radial).  The right-hand side (after <code>~</code>)
contains the names of covariate vectors to fit in the detection
function. Covariates can be either detection level and appear in <code>detectionData</code> 
or transect level and appear in  <code>siteData</code>. Regular R scoping 
rules apply.  
</p>
<p><b>Group Sizes:</b> Non-unity group sizes are specified using <code>groupsize()</code>
in the formula. That is, when group sizes are not all 1, they must 
be entered as a column in <code>detectionData</code> and specified 
using <code>groupsize()</code> as part of <code>formula</code>.  For example, 
<code>d ~ habitat + groupsize(number)</code> specifies that 
distances appear in variable <code>d</code>, one covariate 
named <code>habitat</code> is to be fitted, and column <code>number</code> 
contains the number of individuals 
associated with each detection.  If group sizes are not specified, 
all group sizes are assumed to be 1.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_detectiondata">detectionData</code></td>
<td>
<p>A data frame containing detection distances 
(either perpendicular for line-transect or radial for point-transect
designs), with one row per detected object or group.   
This data frame must contain at least the following 
information: 
</p>

<ul>
<li><p> Detection Distances: A single column containing 
detection distances must be specified on the left-hand 
side of <code>formula</code>.  As of Rdistance version 3.0.0, 
the detection distances must have measurement units attached. 
Attach measurements units to distances using <code>library(units);units()&lt;-</code>.
For example, <code>library(units)</code> followed by <code>units(df$dist) &lt;- "m"</code> or 
<code>units(df$dist) &lt;- "ft"</code> will work. Alternatively, 
<code>df$dist &lt;- units::set_units(df$dist, "m")</code> also works.
</p>
</li>
<li><p> Site IDs: The ID of the transect or point 
(i.e., the 'site') where each object or group was detected.
The site ID  column(s) (see arguments <code>transectID</code> and
<code>pointID</code>) must 
specify the site (transect or point) so that this 
data frame can be merged with <code>siteData</code>.    
</p>
</li>
<li><p> In a later release, <code>Rdistance</code> will allow detection-level 
covariates.  When that happens, detection-level 
covariates will appear in this data frame. 
</p>
</li></ul>

<p>See example data set <code><a href="#topic+sparrowDetectionData">sparrowDetectionData</a></code>.
See also <b>Input data frames</b> below 
for information on when <code>detectionData</code> and 
<code>siteData</code> are required inputs.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_sitedata">siteData</code></td>
<td>
<p>A data.frame containing site (transect or point)
IDs and any 
<em>site level</em> covariates to include in the detection function. 
Every unique surveyed site (transect or point) is represented on
one row of this data set, whether or not targets were sighted 
at the site.  See arguments <code>transectID</code> and 
<code>pointID</code> for an explanation of the way in which distance and site 
data frames are merged.  See 
section <b>Relationship between data frames (transect and point ID's)</b>
for additional details.
</p>
<p>See <b>Data frame requirements</b> for situations in which 
<code>detectionData</code> only, <code>detectionData</code> and <code>siteData</code>, or 
neither are required.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_likelihood">likelihood</code></td>
<td>
<p>String specifying the likelihood to fit. Built-in 
likelihoods at present are &quot;uniform&quot;, &quot;halfnorm&quot;, 
&quot;hazrate&quot;, &quot;negexp&quot;, and &quot;Gamma&quot;. See vignette for a way to use 
user-define likelihoods.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>A logical scalar specifying whether input data come
from point-transect surveys (TRUE),
or line-transect surveys (FALSE).</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_w.lo">w.lo</code></td>
<td>
<p>Lower or left-truncation limit of the distances in distance data. 
This is the minimum possible off-transect distance. Default is 0.  If 
<code>w.lo</code> is greater than 0, it must be assigned measurement units
using <code>units(w.lo) &lt;- "&lt;units&gt;"</code> or 
<code>w.lo &lt;- units::set_units(w.lo, "&lt;units&gt;")</code>. 
See examples in the help for <code>set_units</code>.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_w.hi">w.hi</code></td>
<td>
<p>Upper or right-truncation limit of the distances 
in <code>dist</code>. This is the maximum off-transect distance that 
could be observed. If unspecified (i.e., NULL), 
right-truncation is set to the maximum of the observed 
distances.  If <code>w.hi</code> is specified, it must have associated 
measurement units.  Assign measurement units
using <code>units(w.hi) &lt;- "&lt;units&gt;"</code> or 
<code>w.hi &lt;- units::set_units(w.hi, "&lt;units&gt;")</code>. 
See examples in the help for <code>set_units</code>.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms 
in <code>series</code> to compute. Depending on the series, 
this could be 0 through 5.  The default of 0 equates 
to no expansion terms of any type.  No expansion terms 
are allowed (i.e., <code>expansions</code> is forced to 0) if 
covariates are present in the detection function 
(i.e., right-hand side of <code>formula</code> includes
something other than <code>1</code>).</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_series">series</code></td>
<td>
<p>If <code>expansions</code> &gt; 0, this string 
specifies the type of expansion to use. Valid values at 
present are 'simple', 'hermite', and 'cosine'.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_x.scl">x.scl</code></td>
<td>
<p>The x coordinate (a distance) at which to scale the 
sightability function to <code>g.x.scl</code>, or the string &quot;max&quot;.  
When <code>x.scl</code> is specified (i.e., not 0 or &quot;max&quot;), it must have measurement 
units assigned using either <code>library(units);units(x.scl) &lt;- '&lt;units&gt;'</code>
or <code>x.scl &lt;- units::set_units(x.scl, &lt;units&gt;)</code>. See
<code>units::valid_udunits()</code> for valid symbolic units. See 
Details for more on 
scaling the sightability function.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_g.x.scl">g.x.scl</code></td>
<td>
<p>Height of the distance function at coordinate <em>x</em>. 
The distance function 
will be scaled so that g(<code>x.scl</code>) = <code>g.x.scl</code>. 
If <code>g.x.scl</code> is not 
a data frame, it must be a numeric value (vector of length 1) 
between 0 and 1. 
See Details.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_observer">observer</code></td>
<td>
<p>A numeric scalar or text string specifying whether observer 1 
or observer 2 or both were full-time observers. 
This parameter dictates which set of observations form the denominator 
of a double observer system.   
If, for example, observer 2 was a data recorder and part-time observer, 
or if observer 2 was the pilot, set <code>observer</code> = 1.  
If <code>observer</code> = 1, observations by observer 1 not seen 
by observer 2 are ignored. The estimate of detection in this case is the 
ratio of number of targets seen by both observers 
to the number seen by both plus the number seen by just observer 2. 
If observer = &quot;both&quot;, the 
computation goes both directions.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_warn">warn</code></td>
<td>
<p>A logical scalar specifying whether to issue 
an R warning if the estimation did not converge or if one 
or more parameter estimates are at their boundaries.  
For estimation, <code>warn</code> should generally be left at
its default value of <code>TRUE</code>.  When computing bootstrap 
confidence intervals, setting <code>warn = FALSE</code> 
turns off annoying warnings when an iteration does 
not converge.  Regardless of <code>warn</code>, after 
completion all messages about 
convergence and boundary conditions are printed 
by <code>print.dfunc</code>, <code>print.abund</code>, and 
<code>plot.dfunc</code>.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_transectid">transectID</code></td>
<td>
<p>A character vector naming the transect ID column(s) in
<code>detectionData</code> and <code>siteData</code>.  If transects are 
not identified in columns named 'siteID' (the default for both data frames), you need 
to specify which column(s) uniquely identify transects. <code>transectID</code> can have length
greater than 1, in which case unique transects are identified by the composite columns.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_pointid">pointID</code></td>
<td>
<p>When point-transects are used, this is the 
ID of points on a transect.  When <code>pointSurvey</code>=TRUE, 
the combination of <code>transectID</code> and 
<code>pointID</code> specify unique sampling sites.  
See <b>Input data frames</b>.  
</p>
<p>If single points are surveyed, 
meaning surveyed points were not grouped into transects, each 'transect' consists
of one point. In this case, set <code>transectID</code> equal to 
the point's ID and set <code>pointID</code> equal to 1 for all points.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_outputunits">outputUnits</code></td>
<td>
<p>A string giving the symbolic measurment 
units that results should be reported in.   Any 
distance measurement unit in <code>units::valid_udunits()</code> 
will work.  The strings for common distance symbolic units are: 
&quot;m&quot; for meters, &quot;ft&quot; for feet, &quot;cm&quot; for centimeters, &quot;mm&quot; for 
millimeters, &quot;mi&quot; for miles, &quot;nmile&quot; for 
nautical miles (&quot;nm&quot; is nano meters), &quot;in&quot; for inches, 
&quot;yd&quot; for yards, &quot;km&quot; for kilometers, &quot;fathom&quot; for fathoms, 
&quot;chains&quot; for chains, and &quot;furlong&quot; for furlongs.  
If <code>outputUnits</code> is unspecified (NULL),
output units are the same as distance measurements units in 
<code>data</code>.</p>
</td></tr>
<tr><td><code id="dfuncEstim_+3A_control">control</code></td>
<td>
<p>A list containing optimization control parameters such 
as the maximum number of iterations, tolerance, the optimizer to use, 
etc.  See the 
<code><a href="#topic+RdistanceControls">RdistanceControls</a></code> function for explanation of each value,
the defaults, and the requirements for this list. 
See examples below for how to change controls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'dfunc'.  Objects of class 'dfunc' 
are lists containing the following components:
</p>
<table>
<tr><td><code>parameters</code></td>
<td>
<p>The vector of estimated parameter values. 
Length of this vector for built-in likelihoods is one 
(for the function's parameter) plus the 
number of expansion terms plus one if the likelihood is 
either 'hazrate' or 'uniform' (hazrate and uniform have
two parameters). </p>
</td></tr>
<tr><td><code>varcovar</code></td>
<td>
<p>The variance-covariance matrix for coefficients 
of the distance function, estimated by the inverse of the Hessian
of the fit evaluated at the estimates.  There is no guarantee this 
matrix is positive-definite and should be viewed with caution.  
Error estimates derived from bootstrapping are generally 
more reliable.</p>
</td></tr>   
<tr><td><code>loglik</code></td>
<td>
<p>The maximized value of the log likelihood 
(more specifically, the minimized value of the negative 
log likelihood).</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>The convergence code. This code 
is returned by <code>optim</code>.  Values other than 0 indicate suspect 
convergence.</p>
</td></tr>
<tr><td><code>like.form</code></td>
<td>
<p>The name of the likelihood. This is 
the value of the argument <code>likelihood</code>. </p>
</td></tr>
<tr><td><code>w.lo</code></td>
<td>
<p>Left-truncation value used during the fit.</p>
</td></tr>
<tr><td><code>w.hi</code></td>
<td>
<p>Right-truncation value used during the fit.</p>
</td></tr>
<tr><td><code>detections</code></td>
<td>
<p>A data frame of detections within the strip 
or circle used in the fit.  Column 'dist' contains the 
observed distances. 
Column 'groupSize' contains group sizes associated with 
the values of 'dist'. Group 
sizes are only used in <code>abundEstim</code>.  This data frame 
contains only distances between <code>w.lo</code> and <code>w.hi</code>. 
Another component of the returned object, i.e., <code>model.frame</code> 
contains all observations in the input data, including those outside the strip.</p>
</td></tr>
<tr><td><code>covars</code></td>
<td>
<p>Either NULL if no covariates are included in the 
detection function, or a <code>model.matrix</code> containing the covariates
used in the fit. Factors in in the model.matrix version have been expanded
into 0-1 indicator variables based on R contrasts in effect at the time 
of the call. Only covariates associated with distances inside the strip 
or circle are included. </p>
</td></tr>
<tr><td><code>model.frame</code></td>
<td>
<p>A <code>model.frame</code> object containing observed distances 
(the 'response'), covariates specified in the formula, and group sizes if they
were specified.  If specified, the name of the group size column is &quot;offset(-variable-)&quot;, 
not &quot;groupsize(-variable-)&quot;, because internally it is easier to treat group sizes  
as an offset in the model.  This component is a proper <code>model.frame</code> and contains
both 'terms' and 'contrasts' attributes. </p>
</td></tr>
<tr><td><code>siteID.cols</code></td>
<td>
<p>A vector containing the transect ID column names in <code>detectionData</code>
and <code>siteData</code>. Transect IDs can be a composite of two or more columns and hence 
this component can have length greater than 1. </p>
</td></tr>
<tr><td><code>expansions</code></td>
<td>
<p>The number of expansion terms used 
during estimation.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>The type of expansion used during estimation.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The original call of this function.</p>
</td></tr>
<tr><td><code>call.x.scl</code></td>
<td>
<p>The <em>input</em> or user requested 
distance at which the distance function is scaled. </p>
</td></tr>
<tr><td><code>call.g.x.scl</code></td>
<td>
<p>The <code>input</code> value specifying the 
height of the distance function at a distance 
of <code>call.x.scl</code>.  </p>
</td></tr>
<tr><td><code>call.observer</code></td>
<td>
<p>The value of input parameter <code>observer</code>.
The input <code>observer</code> parameter is only applicable when 
<code>g.x.scl</code> is a data frame.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The fitted object returned by <code>optim</code>.  
See documentation for <code>optim</code>.</p>
</td></tr>
<tr><td><code>factor.names</code></td>
<td>
<p>The names of any factors in <code>formula</code>. </p>
</td></tr>
<tr><td><code>pointSurvey</code></td>
<td>
<p>The input value of <code>pointSurvey</code>. 
This is TRUE if distances are radial from a point. FALSE 
if distances are perpendicular off-transect. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula specified for the detection function.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>A list containing values of the 'control' parameters 
set by <code>RdistanceControls</code>.</p>
</td></tr>
<tr><td><code>outputUnits</code></td>
<td>
<p>The measurement units used for output.  All 
distance measurements are converted to these units internally. </p>
</td></tr>
<tr><td><code>x.scl</code></td>
<td>
<p>The <em>actual</em> distance at which 
the distance function is scaled to some value.  
i.e., this is the actual <em>x</em> at 
which g(<em>x</em>) = <code>g.x.scl</code>.
Note that <code>call.x.scl</code> = <code>x.scl</code> unless 
<code>call.x.scl</code> == &quot;max&quot;, in which case <code>x.scl</code> is the 
distance at which <em>g</em>() is maximized. </p>
</td></tr> 
<tr><td><code>g.x.scl</code></td>
<td>
<p>The <em>actual</em> height of the distance function 
at a distance of <code>x.scl</code>. Note that <code>g.x.scl</code> = 
<code>call.g.x.scl</code> unless <code>call.g.x.scl</code>
is a multiple observer data frame, in which case <code>g.x.scl</code> is the 
actual height of the distance function at <code>x.scl</code> computed 
from the multiple observer data frame.   </p>
</td></tr>
</table>


<h3>Transect types</h3>

<p><code>Rdistance</code> 
accommodates two kinds of transects: continuous and point.  
On continuous transects detections can occur at
any point along the route, and these are line-transects. 
On point transects detections can only 
occur at a series of stops (points), and these are 
point-transects.  
Transects are the basic sampling unit in both cases. 
Columns named in <code>transectID</code> are  
sufficient to specify unique line-transects. 
The combination of <code>transectID</code> and 
<code>pointID</code> specify unique sampling locations along point-transects.  
See <b>Input data frames</b> below for more detail.
</p>


<h3>Input data frames</h3>

<p>To save space and to easily specify 
sites without detections, 
all site ID's, regardless of whether a detection occurred there,
and <em>site level</em> covariates are stored in 
the <code>siteData</code> data frame.  Detection distances and group
sizes are measured at the <em>detection level</em> and 
are stored in the 
<code>detectionData</code> data frame.  
</p>


<h4>Data frame requirements</h4>

<p>The following explains  
conditions under which various combinations of the input data frames 
are required.
</p>

<ol>
<li> <p><b>Detection data and site data both required:</b><br />
Both <code>detectionData</code> and <code>siteData</code>  
are required if <em>site level</em> covariates are 
specified on the right-hand side of <code>formula</code>. 
<em>Detection level</em> covariates are not currently allowed.
Both <code>detectionData</code> and 
<code>siteData</code> data frames are required to estimate abundance 
later in <code>abundEstim</code>.
</p>
</li>
<li> <p><b>Detection data only required:</b><br />
<code>detectionData</code> only is required when 
covariates are are not included in the distance function (i.e., the right-hand side of 
<code>formula</code> is &quot;~1&quot; or &quot;~groupsize(groupSize)&quot;). Note that <code>dfuncEstim</code>
does not need to know transect IDs (or group sizes)  
in order to estimate a distance function; but, group sizes and 
transect IDs are stored and used to estimate abundance 
in function <code>abundEstim</code>. Both the <code>detectionData</code> and 
<code>siteData</code> data frames are required in <code>abundEstim</code>. 
</p>
</li>
<li> <p><b>Neither detection data nor site data required</b><br />
Neither <code>detectionData</code> nor <code>siteData</code>  
are required if all variables specified in <code>formula</code> 
are within the scope of <code>dfuncEstim</code> (e.g., in the global working
environment) and abundance estimates are not required. 
Regular R scoping rules apply when the call 
to <code>dfuncEstim</code> is embedded in a function. 
This case is will produce distance functions only.
Abundance cannot later be estimated because transects and transect lengths cannot
be specified outside of a data frame.  If abundance will be estimated, 
use either case 1 or 2.  
</p>
</li></ol>




<h4>Relationship between data frames (transect and point ID's)</h4>

<p>The input data frames, <code>detectionData</code> and <code>siteData</code>,
must be merge-able on unique sites.  For line-transects, 
site ID's specify transects or routes and are unique values of 
the <code>transectID</code> column in <code>siteData</code>.  In this case,
the following merge must work:  
<code>merge(detectionData,siteData,by=transectID)</code>.
</p>
<p>For point-transects, 
site ID's specify individual points and are unique values 
of the combination <code>paste(transectID,pointID)</code>.
In this case, the following merge must work:    
<code>merge(detectionData,siteData,by=c(transectID, pointID)</code>.
</p>
<p>By default, <em>transects</em> are unique combinations of the
common variables in the <code>detectionData</code> and <code>siteData</code> data frames
if both data frames are specified (i.e., unique values of
<code>intersect(names(detectionData), names(siteData))</code>). If <code>siteData</code>
is not specified and <code>transectID</code> is not given, transects are assumed to 
be identified in a column named <code>siteID</code> in <code>detectionData</code>. 
</p>
<p>Either way
(i.e., either <code>transectID</code> = &quot;siteID&quot; or specified as something else), 
the column(s) containing transect ID's must be correct here if abundance is to be 
estimated later. Routine <code><a href="#topic+abundEstim">abundEstim</a></code> requires transect ID's for bootstrapping
because it resamples unique values of the composite transect ID column(s). <code>abundEstim</code>
uses the value of <code>transectID</code> specified here and hence users cannot change transect ID's between 
calls to <code>dfuncEstim</code> and <code>abundEstim</code> and all <code>transectID</code> columns 
must be present in both data frames even though they may not be used until later.
</p>
<p>An error occurs if both <code>detectionData</code> and <code>siteData</code> are specified 
but no common columns exist.  Duplicate <code>transectID</code> values are not allowed in <code>siteData</code>
but are allowed in <code>detectionData</code> because multiple detections can occur on a single transect
or at a single site. If the same site is surveyed in multiple years, specify another level of transect ID; 
for example, <code>transectID</code> = <code>c("year","transectID")</code>. 
</p>



<h3>Measurement Units</h3>

<p>As of <code>Rdistance</code> version 3.0.0, measurement units are 
require on all distances.  This includes off-transect 
distances, radial 
distances, truncation distances (<code>w.lo</code> and <code>w.hi</code>), 
transect lengths, and study size area. 
In <code>dfuncEstim</code>, units are required on the following: 
<code>detectionData$dist</code>; <code>w.lo</code> (unless it is zero); 
<code>w.hi</code> (unless it is NULL); 
and <code>x.scl</code>. In <code>abundEstim</code>, units are 
required on <code>siteData$length</code> and <code>area</code>. All units are 
1-dimensional except those on <code>area</code>, which are 2-dimensional. 
</p>
<p>Requiring units ensures that internal calculations and results 
(e.g., ESW and abundance) are correct 
and that output units are clear.   
Input distances can have variable units. For example, 
input distances can be in specified in &quot;m&quot;, <code>w.hi</code> in &quot;in&quot;, 
and <code>w.lo</code> in &quot;km&quot;.  Internally, all distances are 
converted to the units specified by <code>outputUnits</code> 
(or the units of input distances if 
<code>outputUnits</code> is NULL), and 
all output is reported 
in units of <code>outputUnits</code>. 
</p>
<p>Measurement units can be assigned using  
<code>units()&lt;-</code> after attaching the <code>units</code> 
package or with <code>x &lt;- units::set_units(x, "&lt;units&gt;")</code>. 
See <code>units::valid_udunits()</code>
for a list of valid symbolic units. 
</p>
<p>If measurements are truly unit-less, or measurement units are unknown, 
set <code>RdistanceControls(requireUnits = FALSE)</code>.  This suppresses 
all unit checks and conversions.  Users are on their own 
to make sure inputs are scaled correctly and that output units are known.
</p>


<h3>References</h3>

<p>Buckland, S.T., D.R. Anderson, K.P. Burnham, J.L. Laake, D.L. Borchers,
and L. Thomas. (2001) <em>Introduction to distance sampling: estimating
abundance of biological populations</em>. Oxford University Press, Oxford, UK.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abundEstim">abundEstim</a></code>, <code><a href="#topic+autoDistSamp">autoDistSamp</a></code>.
Likelihood-specific help files (e.g., <code><a href="#topic+halfnorm.like">halfnorm.like</a></code>). 
See package vignettes for additional options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example sparrow data (line transect survey type)
data(sparrowDetectionData)

dfunc &lt;- dfuncEstim(formula = dist ~ 1
                  , detectionData = sparrowDetectionData)
dfunc
plot(dfunc)                   

</code></pre>

<hr>
<h2 id='dfuncSmu'>Estimate a non-parametric smooth detection function 
from distance-sampling data</h2><span id='topic+dfuncSmu'></span>

<h3>Description</h3>

<p>Estimates a smooth detection function for 
line-transect perpendicular distances or point-transect 
radial distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfuncSmu(
  formula,
  detectionData,
  siteData,
  bw = "SJ-dpi",
  adjust = 1,
  kernel = "gaussian",
  pointSurvey = FALSE,
  w.lo = units::set_units(0, "m"),
  w.hi = NULL,
  x.scl = "max",
  g.x.scl = 1,
  observer = "both",
  warn = TRUE,
  transectID = NULL,
  pointID = "point",
  outputUnits = NULL,
  length = "length",
  control = RdistanceControls()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfuncSmu_+3A_formula">formula</code></td>
<td>
<p>A formula object (e.g., dist ~ 1). 
The left-hand side (before ~)
is the name of the vector containing distances (perpendicular or 
radial).  The right-hand side (after ~)
must be the intercept-only model as <code>Rdistance</code> does not 
currently allow covariates in smoothed distance functions. 
If names in <code>formula</code> do not appear in <code>detectionData</code>, 
the normal scoping rules for model fitting routines (e.g., 
<code>lm</code> and <code>glm</code>) apply.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_detectiondata">detectionData</code></td>
<td>
<p>A data frame containing detection distances 
(either perpendicular for line-transect or radial for point-transect
designs), with one row per detected object or group.   
This data frame must contain at least the following 
information: 
</p>

<ul>
<li><p> Detection Distances: A single column containing 
detection distances must be specified on the left-hand 
side of <code>formula</code>.
</p>
</li>
<li><p> Site IDs: The ID of the transect or point 
(i.e., the 'site') where each object or group was detected.
The site ID  column(s) (see argument <code>siteID</code>) must 
specify the site (transect or point) so that this 
data frame can be merged with <code>siteData</code>.    
</p>
</li></ul>
 
<p>Optionally, this data frame can contain the following 
variables: 
</p>

<ul>
<li><p> Group Sizes: The number of individuals in the group
associated with each detection.  If unspecified, <code>Rdistance</code>
assumes all detections are of single individuals (i.e., 
all group sizes are 1). 
</p>
</li>
<li><p> When <code>Rdistance</code> allows detection-level 
covariates in some version after 2.1.1, detection-level 
covariates will appear in this data frame. 
</p>
</li></ul>

<p>See example data set <code><a href="#topic+sparrowDetectionData">sparrowDetectionData</a></code>).
See also <b>Input data frames</b> below 
for information on when <code>detectionData</code> and 
<code>siteData</code> are required inputs.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_sitedata">siteData</code></td>
<td>
<p>A data.frame containing site (transect or point)
IDs and any 
<em>site level</em> covariates to include in the detection function. 
Every unique surveyed site (transect or point) is represented on
one row of this data set, whether or not targets were sighted 
at the site.  See arguments <code>transectID</code> and 
<code>pointID</code> for an explanation of site and transect ID's. 
</p>
<p>If sites are transects, 
this data frame must also contain transect length. By 
default, transect length is assumed to be in column 'length' 
but can be specified using argument <code>length</code>. 
</p>
<p>The total number of sites surveyed is <code>nrow(siteData)</code>. 
Duplicate site-level IDs are not allowed in <code>siteData</code>. 
</p>
<p>See <b>Input data frames</b> 
for when <code>detectionData</code> and <code>siteData</code> are required inputs.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_bw">bw</code></td>
<td>
<p>Bandwidth of the smooth, which controls
smoothness.  Smoothing is done by <code>stats::density</code>, and 
<code>bw</code> is 
passed straight to it's <code>bw</code> argument.  <code>bw</code> can be 
numeric, in which case it is the standard deviation of the 
Gaussian smoothing kernel. Or, <code>bw</code> can be  
a character string specifying the 
bandwidth selection rule.  Valid character string values 
of <code>bw</code> are the following:
</p>

<ul>
<li><p> &quot;nrd0&quot; : Silverman's 'rule-of-thumb' equal to 
<code class="reqn">\frac{0.9s}{1.34n^{-0.2}}</code>, where 
<code class="reqn">s</code> is the minimum of standard deviation of the distances 
and the interquartile range.  See <code><a href="stats.html#topic+bw.nrd0">bw.nrd0</a></code>.
</p>
</li>
<li><p> &quot;nrd&quot; : The more common 'rule-of-thumb' variation given by 
Scott (1992). This rule uses 1.06 in the denominator of the 
&quot;nrd0&quot; bandwidth. See <code><a href="stats.html#topic+bw.nrd">bw.nrd</a></code>
</p>
</li>
<li><p> &quot;bcv&quot; : The biased cross-validation method. See <code><a href="MASS.html#topic+bcv">bcv</a></code>. 
</p>
</li>
<li><p> &quot;ucv&quot; : The unbiased cross-validation method. See <code><a href="MASS.html#topic+ucv">ucv</a></code>.
</p>
</li>
<li><p> &quot;SJ&quot; or &quot;SJ-ste&quot; : The 'solve-the-equation' bandwidth of Sheather &amp; 
Jones (1991).  See <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code> or <code><a href="MASS.html#topic+width.SJ">width.SJ</a></code>.
</p>
</li>
<li><p> &quot;SJ-dpi&quot; (default) : The 'direct-plug-in' bandwidth of Sheather &amp; 
Jones (1991). See <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code> or <code><a href="MASS.html#topic+width.SJ">width.SJ</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_adjust">adjust</code></td>
<td>
<p>Bandwidth adjustment for the amount of smooth. 
Smoothing is done by <code><a href="stats.html#topic+density">density</a></code>, and 
this parameter is 
passed straight to it's <code>adjust</code> argument.  
In <code>stats::density</code>, the bandwidth used is 
actually <code>adjust*bw</code>, and inclusion of this parameters makes 
it easier to specify values like 'half the default' bandwidth.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_kernel">kernel</code></td>
<td>
<p>Character string specifying the smoothing kernel function. 
This parameters is passed unmodified to <code>stats::density</code>.  Valid 
values are:
</p>

<ul>
<li><p> &quot;gaussian&quot; : Gaussian (normal) kernel, the default
</p>
</li>
<li><p> &quot;rectangular&quot; : Uniform or flat kernel
</p>
</li>
<li><p> &quot;triangular&quot; : Equilateral triangular kernel
</p>
</li>
<li><p> &quot;epanechnikov&quot; : the Epanechnikov kernel
</p>
</li>
<li><p> &quot;biweight&quot; : the biweight kernel
</p>
</li>
<li><p> &quot;cosine&quot; : the S version of the cosine kernel
</p>
</li>
<li><p> &quot;optcosine&quot; : the optimal cosine kernel which is the usual 
one reported in the literature 
</p>
</li></ul>

<p>Values of <code>kernel</code> may be abbreviated to the first letter of 
each string. The numeric value of <code>bw</code> used in the smooth 
is stored in the <code>$fit</code> component of the returned object 
(i.e., in <code>returned$fit$bw</code>).</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>A logical scalar specifying whether input data come
from point-transect surveys (TRUE),
or line-transect surveys (FALSE).  Point surveys (TRUE) have not been 
implemented yet.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_w.lo">w.lo</code></td>
<td>
<p>Lower or left-truncation limit of the distances in distance data. 
This is the minimum possible off-transect distance. Default is 0.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_w.hi">w.hi</code></td>
<td>
<p>Upper or right-truncation limit of the distances 
in <code>dist</code>. This is the maximum off-transect distance that 
could be observed. If left unspecified (i.e., at the default of 
NULL), right-truncation is set to the maximum of the 
observed distances.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_x.scl">x.scl</code></td>
<td>
<p>This parameter is passed to <code>F.gx.estim</code>. 
See <code>F.gx.estim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_g.x.scl">g.x.scl</code></td>
<td>
<p>This parameter is passed to <code>F.gx.estim</code>. 
See <code>F.gx.estim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_observer">observer</code></td>
<td>
<p>This parameter is passed to <code>F.gx.estim</code>. 
See <code>F.gx.estim</code> documentation for definition.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_warn">warn</code></td>
<td>
<p>A logical scalar specifying whether to issue 
an R warning if the estimation did not converge or if one 
or more parameter estimates are at their boundaries.  
For estimation, <code>warn</code> should generally be left at
its default value of <code>TRUE</code>.  When computing bootstrap 
confidence intervals, setting <code>warn = FALSE</code> 
turns off annoying warnings when an iteration does 
not converge.  Regardless of <code>warn</code>, messages about 
convergence and boundary conditions are printed 
by <code>print.dfunc</code>, <code>print.abund</code>, and 
<code>plot.dfunc</code>, so there should be little harm in 
setting <code>warn = FALSE</code>.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_transectid">transectID</code></td>
<td>
<p>A character vector naming the transect ID column(s) in
<code>detectionData</code> and <code>siteData</code>.  Transects can be the 
basic sampling unit (when <code>pointSurvey</code>=FALSE) or 
contain multiple sampling units (e.g., when <code>pointSurvey</code>=TRUE). 
For line-transects, the <code>transectID</code> column(s) alone is 
sufficient to specify unique sample sites. 
For point-transects, the amalgamation of <code>transectID</code> and 
<code>pointID</code> specify unique sampling sites.  
See <b>Input data frames</b>.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_pointid">pointID</code></td>
<td>
<p>When point-transects are used, this is the 
ID of points on a transect.  When <code>pointSurvey</code>=TRUE, 
the amalgamation of <code>transectID</code> and 
<code>pointID</code> specify unique sampling sites.  
See <b>Input data frames</b>.  
</p>
<p>If single points are surveyed, 
meaning surveyed points were not grouped into transects, each 'transect' consists
of one point. In this case, set <code>transectID</code> equal to 
the point's ID and set <code>pointID</code> equal to 1 for all points.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_outputunits">outputUnits</code></td>
<td>
<p>A string giving the symbolic measurment 
units that results should be reported in.   Any 
distance measurement unit in <code>units::valid_udunits()</code> 
will work.  The strings for common distance symbolic units are: 
&quot;m&quot; for meters, &quot;ft&quot; for feet, &quot;cm&quot; for centimeters, &quot;mm&quot; for 
millimeters, &quot;mi&quot; for miles, &quot;nmile&quot; for 
nautical miles (&quot;nm&quot; is nano meters), &quot;in&quot; for inches, 
&quot;yd&quot; for yards, &quot;km&quot; for kilometers, &quot;fathom&quot; for fathoms, 
&quot;chains&quot; for chains, and &quot;furlong&quot; for furlongs.  
If <code>outputUnits</code> is unspecified (NULL),
output units are the same as distance measurements units in 
<code>data</code>.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_length">length</code></td>
<td>
<p>Character string specifying the (single) column in 
<code>siteData</code> that contains transect length. This is ignored if 
<code>pointSurvey</code> = TRUE.</p>
</td></tr>
<tr><td><code id="dfuncSmu_+3A_control">control</code></td>
<td>
<p>A list containing optimization control parameters such 
as the maximum number of iterations, tolerance, the optimizer to use, 
etc.  See the 
<code><a href="#topic+RdistanceControls">RdistanceControls</a></code> function for explanation of each value,
the defaults, and the requirements for this list. 
See examples below for how to change controls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distances are reflected about <code>w.lo</code> before being passed 
to <code>density</code>.  Distances exactly equal to <code>w.lo</code> are not
reflected.  Reflection around <code>w.lo</code> greatly improves
performance of the kernel methods near the <code>w.lo</code> boundary 
where substantial non-zero probability of sighting typically exists.
</p>


<h3>Value</h3>

<p>An object of class 'dfunc'.  Objects of class 'dfunc' 
are lists containing the following components:
</p>
<table>
<tr><td><code>parameters</code></td>
<td>
<p>A data frame containing the $x and $y
components of the smooth. $x is a vector of length 
512 (default for <code>density</code>) evenly spaced points
between <code>w.lo</code> and <code>w.hi</code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The value of the log likelihood. Specifically, 
the sum of the negative log heights of the smooth at observed
distances, after the smoothed function has been scaled to integrate
to one. </p>
</td></tr>
<tr><td><code>w.lo</code></td>
<td>
<p>Left-truncation value used during the fit.</p>
</td></tr>
<tr><td><code>w.hi</code></td>
<td>
<p>Right-truncation value used during the fit.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>The input vector of observed distances.</p>
</td></tr>
<tr><td><code>covars</code></td>
<td>
<p>NULL. Covariates are not allowed in the 
smoothed distance function (yet). </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The original call of this function.</p>
</td></tr>
<tr><td><code>call.x.scl</code></td>
<td>
<p>The distance at which the distance function 
is scaled. This is the x at which g(x) = <code>g.x.scl</code>.
Normally, <code>call.x.scl</code> = 0.</p>
</td></tr>
<tr><td><code>call.g.x.scl</code></td>
<td>
<p>The value of the distance function at distance
<code>call.x.scl</code>.  Normally, <code>call.g.x.scl</code> = 1.</p>
</td></tr>
<tr><td><code>call.observer</code></td>
<td>
<p>The value of input parameter <code>observer</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The smoothed object returned by <code>stats::density</code>. All
information returned by <code>stats::density</code> is preserved, and 
in particular the numeric value of the bandwidth used during the 
smooth is returned in <code>fit$bw</code></p>
</td></tr>
<tr><td><code>pointSurvey</code></td>
<td>
<p>The input value of <code>pointSurvey</code>. 
This is TRUE if distances are radial from a point. FALSE 
if distances are perpendicular off-transect. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula specified for the detection function.</p>
</td></tr>
</table>


<h3>Input data frames</h3>

<p>To save space and to easily specify 
sites without detections, 
all site ID's, regardless whether a detection occurred there,
and <em>site level</em> covariates are stored in 
the <code>siteData</code> data frame.  Detection distances and group
sizes are measured at the <em>detection level</em> and 
are stored in the 
<code>detectionData</code> data frame.  
</p>


<h4>Data frame requirements</h4>

<p>The following explains  
conditions under which various combinations of the input data frames 
are required.
</p>

<ol>
<li> <p><b>Detection data and site data both required:</b><br />
Both <code>detectionData</code> and <code>siteData</code>  
are required if <em>site level</em> covariates are 
specified on the right-hand side of <code>formula</code>. 
<em>Detection level</em> covariates are not currently allowed.
</p>
</li>
<li> <p><b>Detection data only required:</b><br />
The <code>detectionData</code> data frame alone can be 
specified if no covariates 
are included in the distance function (i.e., right-hand side of 
<code>formula</code> is &quot;~1&quot;). Note that this routine (<code>dfuncEstim</code>)
does not need to know about sites where zero targets were detected, hence
<code>siteData</code> can be missing when no covariates are involved.
</p>
</li>
<li> <p><b>Neither detection data nor site data required</b><br />
Neither <code>detectionData</code> nor <code>siteData</code>  
are required if all variables specified in <code>formula</code> 
are within the scope of this routine (e.g., in the global working
environment). Scoping rules here work the same as for other modeling 
routines in R such as <code>lm</code> and <code>glm</code>. Like other modeling 
routines, it is possible to mix and match the location of variables in 
the model.  Some variables can be in the <code>.GlobalEnv</code> while others 
are in either <code>detectionData</code> or <code>siteData</code>. 
</p>
</li></ol>




<h4>Relationship between data frames (transect and point ID's)</h4>

<p>The input data frames, <code>detectionData</code> and <code>siteData</code>,
must be merge-able on unique sites.  For line-transects, 
site ID's (i.e., transect ID's) are unique values of 
the <code>transectID</code> column in <code>siteData</code>.  In this case,
the following merge must work:  
<code>merge(detectionData,siteData,by=transectID)</code>.
For point-transects, 
site ID's (i.e., point ID's) are unique values 
of the combination <code>paste(transectID,pointID)</code>.
In this case, the following merge must work:    
<code>merge(detectionData,siteData,by=c(transectID, pointID)</code>.
</p>
<p>By default,<code>transectID</code> and <code>pointID</code> are NULL and
the merge is done on all common columns.
That is, when <code>transectID</code> is NULL, this routine assumes unique
<em>transects</em> are specified by unique combinations of the 
common variables (i.e., unique values of
<code>intersect(names(detectionData), names(siteData))</code>). 
</p>
<p>An error occurs if there are no common column names between 
<code>detectionData</code> and <code>siteData</code>.
Duplicate site IDs are not allowed in <code>siteData</code>. 
If the same site is surveyed in
multiple years, specify another transect ID column (e.g., <code>transectID =
c("year","transectID")</code>).  Duplicate site ID's are allowed in 
<code>detectionData</code>.  
</p>
<p>To help explain the relationship between data frames, bear in 
mind that  during bootstrap estimation of variance
in <code><a href="#topic+abundEstim">abundEstim</a></code>, 
unique <em>transects</em> (i.e., unique values of 
the transect ID column(s)), not <em>detections</em> or 
<em>points</em>, are resampled with replacement. 
</p>



<h3>References</h3>

<p>Buckland, S.T., D.R. Anderson, K.P. Burnham, J.L. Laake, D.L. Borchers,
and L. Thomas. (2001) <em>Introduction to distance sampling: estimating
abundance of biological populations</em>. Oxford University Press, Oxford, UK.
</p>
<p>Scott, D. W. (1992) <em>Multivariate Density Estimation: Theory, 
Practice, and Visualization.</em> Wiley.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991) A reliable data-based 
bandwidth selection method for kernel density estimation. <em>Journal of 
the Royal Statistical Society series B</em>, 53, 683-690.
</p>
<p>Silverman, B. W. (1986) <em>Density Estimation</em>. London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abundEstim">abundEstim</a></code>, <code><a href="#topic+autoDistSamp">autoDistSamp</a></code>, 
<code><a href="#topic+dfuncEstim">dfuncEstim</a></code> for the parametric version.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example sparrow data (line transect survey type)
data(sparrowDetectionData)
data(sparrowSiteData)

# Compare smoothed and half-normal detection function
dfuncSmu &lt;- dfuncSmu(dist~1, sparrowDetectionData, w.hi=units::set_units(150, "m"))
dfuncHn  &lt;- dfuncEstim(formula=dist~1,sparrowDetectionData,w.hi=units::set_units(150, "m"))

# Print and plot results
dfuncSmu
dfuncHn
plot(dfuncSmu,main="",nbins=50)

x &lt;- seq(0,150,length=200)
y &lt;- dnorm(x, 0, predict(dfuncHn)[1])
y &lt;- y/y[1]
lines(x,y, col="orange", lwd=2)
legend("topright", legend=c("Smooth","Halfnorm"), 
  col=c("red","orange"), lwd=2)

</code></pre>

<hr>
<h2 id='EDR'>Effective Detection Radius (EDR) for estimated detection functions
with point transects</h2><span id='topic+EDR'></span>

<h3>Description</h3>

<p>Computes Effective Detection Radius (EDR) for estimated 
detection functions with point transects.  The point-transect equivalent to
Effective Strip Width (ESW).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EDR(obj, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EDR_+3A_obj">obj</code></td>
<td>
<p>An estimated detection function object.  An estimated detection 
function object has class 'dfunc', and is usually produced by a call to 
<code>dfuncEstim</code>. The estimated detection function may optionally contain 
a <code class="reqn">g(0)</code> component.  If no <code class="reqn">g(0)</code> component is found, <code class="reqn">g(0)</code> =
1 is assumed.</p>
</td></tr>
<tr><td><code id="EDR_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing new values of the covariates at which
EDR's are sought. If NULL or missing and 
<code>obj</code> contains covariates, the covariates stored in <code>obj</code>
are used.  See <b>Value</b> section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The point-transect equivalent to Effective Strip Width (ESW).
</p>


<h3>Value</h3>

<p>If <code>newdata</code> is not missing and not NULL and 
covariates are present in <code>obj</code>, returned value is 
a vector with length equal to the number of rows in <code>newdata</code>. 
If <code>newdata</code> is missing or NULL and covariates are present
in <code>obj</code>, returned value is a vector with length equal to 
the number of detections in <code>obj$detections</code>. In either of the 
above cases, elements in the returned vector are 
the effective detection radii for the corresponding set of 
covariates.  
</p>
<p>If <code>obj</code> does not contain covariates, <code>newdata</code> is ignored and 
a scalar equal to the (constant) effective detection radius for all 
detections is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+ESW">ESW</a></code>, 
<code><a href="#topic+effectiveDistance">effectiveDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example thrasher data (point transect survey type)
data(thrasherDetectionData)

# Fit half-normal detection function
dfunc &lt;- dfuncEstim(formula=dist~1
                  , detectionData=thrasherDetectionData
                  , likelihood="halfnorm"
                  , w.hi=units::set_units(175, "m")
                  , pointSurvey=TRUE)

# Compute effective detection radius (EDR)
EDR(dfunc)

# EDR only applies to point transect surveys
# ESW is the line transect equivalent
# The effectiveDistance function tests whether the dfunc was
# fit to line or point data, and returns either ESW or EDR accordingly
effectiveDistance(dfunc)
  
</code></pre>

<hr>
<h2 id='effectiveDistance'>Calculates the effective sampling distance for 
estimated detection functions</h2><span id='topic+effectiveDistance'></span>

<h3>Description</h3>

<p>Computes Effective Strip Width (ESW) for line-transect detection
functions, or the analogous Effective Detection Radius (EDR) for point-transect
detection functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectiveDistance(obj, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectiveDistance_+3A_obj">obj</code></td>
<td>
<p>An estimated detection function object.  An estimated detection 
function object has class 'dfunc', and is usually produced by a call to 
<code>dfuncEstim</code>. The estimated detection function may optionally contain 
a <code class="reqn">g(0)</code> component.  If no <code class="reqn">g(0)</code> component is found, <code class="reqn">g(0)</code> =
1 is assumed.</p>
</td></tr>
<tr><td><code id="effectiveDistance_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing new values of the covariates at which
ESW's or EDR's are sought. If NULL or missing and 
<code>obj</code> contains covariates, the  
covariates stored in
<code>obj</code> are used. See <b>Value</b> section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Serves as a wrapper for <code><a href="#topic+ESW">ESW</a></code> and <code><a href="#topic+EDR">EDR</a></code>.
</p>


<h3>Value</h3>

<p>If <code>newdata</code> is not missing or NULL and 
covariates are present in <code>obj</code>, returned value is 
a vector with length equal to the number of rows in <code>newdata</code>. 
If <code>newdata</code> is missing or NULL and covariates are present
in <code>obj</code>, returned value is a vector with length equal to 
the number of detections in <code>obj$detections</code>. In either of the 
above cases, elements in the returned vector are 
the effective sampling distances for the corresponding set of 
covariates.  
</p>
<p>If <code>obj</code> does not contain covariates, <code>newdata</code> is ignored and 
a scalar equal to the (constant) effective sampling distance for all 
detections is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code> <code><a href="#topic+ESW">ESW</a></code> <code><a href="#topic+EDR">EDR</a></code>
</p>

<hr>
<h2 id='estimateN'>Abundance point estimates</h2><span id='topic+estimateN'></span>

<h3>Description</h3>

<p>Estimate abundance given a distance function, 
a &quot;merged&quot; data frame containing detections and transect lengths, area, 
and the number of sides surveyed (if line-transects).   
This is called internally by <code>abundEstim</code>.  Most users will call 
<code>abundEstim</code> to estimate abundance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateN(
  dfunc,
  data,
  area = NULL,
  surveyedSides,
  lengthColumn,
  control = RdistanceControls()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateN_+3A_dfunc">dfunc</code></td>
<td>
<p>An estimate distance function (see <code>dfuncEstim</code>).</p>
</td></tr>
<tr><td><code id="estimateN_+3A_data">data</code></td>
<td>
<p>A data frame containing distance observations, transects, 
and lengths.  This data frame must have a column named 'siteID' that identifies
unique sites (transects or points). If observations were made on  line-transects, this 
data frame must also have a column named 
by the <code>lengthColumn</code> parameter that contains transect lengths. NA
length transects are accepted and are dropped when computing total 
transect length. Only observations on non-NA-length transects are toward density.</p>
</td></tr>
<tr><td><code id="estimateN_+3A_area">area</code></td>
<td>
<p>A scalar containing the total area of 
inference. Commonly, this is study area size.  
If <code>area</code> is NULL (the default), 
<code>area</code> will be set to 1 square unit of the output units and this
produces abundance estimates equal density estimates. 
If <code>area</code> is not NULL, it must have measurement units 
assigned by the <code>units</code> package. 
The units on <code>area</code> must be convertible
to squared output units. Units 
on <code>area</code> must be two-dimensional. 
For example, if output units are &quot;foo&quot;, 
units on area must be convertible to &quot;foo^2&quot; by the <code>units</code>
package. 
Units of &quot;km^2&quot;, &quot;cm^2&quot;, &quot;ha&quot;, &quot;m^2&quot;, &quot;acre&quot;, &quot;mi^2&quot;, and many
others are acceptable.</p>
</td></tr>
<tr><td><code id="estimateN_+3A_surveyedsides">surveyedSides</code></td>
<td>
<p>The number of sides of the transect that were surveyed. Either 
1 or 2.  Only applies to line transects.</p>
</td></tr>
<tr><td><code id="estimateN_+3A_lengthcolumn">lengthColumn</code></td>
<td>
<p>Character string specifying the (single) column in 
<code>siteData</code> that contains transect lengths. This is ignored if 
<code>pointSurvey</code> = TRUE. This column must have measurement units.</p>
</td></tr>
<tr><td><code id="estimateN_+3A_control">control</code></td>
<td>
<p>A list containing optimization control parameters such 
as the maximum number of iterations, tolerance, the optimizer to use, 
etc.  See the 
<code><a href="#topic+RdistanceControls">RdistanceControls</a></code> function for explanation of each value,
the defaults, and the requirements for this list. 
See examples below for how to change controls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The abundance estimate for line-transect surveys (if no covariates
are included in the detection function and both sides of the transect 
were observed) is 
</p>
<p style="text-align: center;"><code class="reqn">N =\frac{n(A)}{2(ESW)(L)}</code>
</p>
 
<p>where <em>n</em> is total number of sighted individuals 
(i.e., <code>sum(dfunc$detections$groupSizes)</code>), <em>L</em> is the total length of 
surveyed transect (i.e., <code>sum(siteData[,lengthColumn])</code>),
and <em>ESW</em> is effective strip width
computed from the estimated distance function (i.e., <code>ESW(dfunc)</code>).
If only one side of transects were observed, the &quot;2&quot; in the denominator 
is not present (or, replaced with a &quot;1&quot;). 
</p>
<p>The abundance estimate for point transect surveys (if no covariates are
included) is 
</p>
<p style="text-align: center;"><code class="reqn">N =\frac{n(A)}{\pi(ESR^2)(P)}</code>
</p>
 
<p>where <em>n</em> is total number of sighted individuals,
<em>P</em> is the total number of surveyed points, 
and <em>ESR</em> is effective search radius 
computed from the estimated distance function (i.e., <code>ESR(dfunc)</code>).
</p>
<p>Setting <code>plot.bs=FALSE</code> and <code>showProgress=FALSE</code> 
suppresses all intermediate output.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>density</code></td>
<td>
<p>Estimated density in the surveyed area.</p>
</td></tr>
<tr><td><code>abundance</code></td>
<td>
<p>Estimated abundance on the study area.</p>
</td></tr>
<tr><td><code>n.groups</code></td>
<td>
<p>The number of detections (not individuals, unless all group sizes = 1) 
used to estimate density and abundance.</p>
</td></tr>
<tr><td><code>n.seen</code></td>
<td>
<p>The number of individuals (sum of group sizes) used to 
estimate density and abundance.</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>Total area of inference. Study area size</p>
</td></tr>
<tr><td><code>surveyedUnits</code></td>
<td>
<p>Number of surveyed sites.  This is total transect length
for line-transects and number of points for point-transects. This total transect
length does not include NA transects.</p>
</td></tr>
<tr><td><code>surveyedSides</code></td>
<td>
<p>Number of sides (1 or 2) of transects surveyed. Only relevant for line-transects.</p>
</td></tr>
<tr><td><code>avg.group.size</code></td>
<td>
<p>Average group size on non-NA transects</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Strip width. </p>
</td></tr>
<tr><td><code>pDetection</code></td>
<td>
<p>Probability of detection.</p>
</td></tr>
</table>
<p>For line-transects that do not involve covariates, x$density  
is x$n.seen / (x$surveyedSides * x$w * x$pDetection * x$surveyedUnits)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+abundEstim">abundEstim</a></code>
</p>

<hr>
<h2 id='ESW'>Line transect Effective Strip Width (ESW)</h2><span id='topic+ESW'></span>

<h3>Description</h3>

<p>Returns effective strip width (ESW) from an estimated 
line transect detection
functions. This function applies only to line transect information.
Function <code>EDR</code> is for point transect data. Function 
<code>effectiveDistance</code> accepts either point or line transect data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESW(obj, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESW_+3A_obj">obj</code></td>
<td>
<p>An estimated detection function object.  An estimated detection 
function object has class 'dfunc', and is usually produced by a call to 
<code>dfuncEstim</code>. The estimated detection function may optionally contain 
a <code class="reqn">g(0)</code> component that specifies detection probability 
on the transect.  If no <code class="reqn">g(0)</code> component is found, <code class="reqn">g(0)</code> =
1 is assumed.</p>
</td></tr>
<tr><td><code id="ESW_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing new values of 
the covariates at which ESW's are sought. If NULL or missing and 
<code>obj</code> contains covariates, the  
covariates stored in <code>obj</code> are used. See <b>Value</b> section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Effective strip width (ESW) of a distance function is its
integral. That is, ESW is the area under the distance function from its
left-truncation limit (<code>obj$w.lo</code>) to its right-truncation limit
(<code>obj$w.hi</code>). 
</p>
<p>If detection does not decline with distance, area under the detection 
function is the entire half-width of 
the strip transect (i.e., <code>obj$w.hi - obj$w.lo</code>).  
In this case density is the number sighted targets 
divided by area surveyed, where area surveyed is 
<code>obj$w.hi-obj$w.lo</code> times
total length of transects.
</p>
<p>When detection declines with distance, less than the total half-width is
<em>effectively</em> covered. In this case, Buckland <em>et al.</em> (1993) show that the
denominator of the density estimator is total length of 
surveyed transects times area under the detection function (i.e., this
integral). By analogy with the non-declining detection case, ESW is the 
transect half-width that observers <em>effectively</em>
cover. In other words, if ESW = X, the study 
effectively covers the same area as a study with non-declining detection out to a
distance of X.
</p>
<p><em>A technical consideration</em>: Rdistance uses the trapezoid rule to numerically 
integrate under the distance
function from <code>obj$w.lo</code> to <code>obj$w.hi</code>. Two-hundred
trapezoids are used in the approximation to speed calculations.  In some
rare cases, two hundred trapezoids may not be enough.  In these cases, 
users should modify this function's code and bump <code>seq.length</code> to 
a value greater than 200.
</p>


<h3>Value</h3>

<p>If <code>newdata</code> is not missing and not NULL and 
covariates are present in <code>obj</code>, the returned value is 
a vector of ESW values associated with covariates in the 
distance function and equal in length to the number of rows in <code>newdata</code>. 
If <code>newdata</code> is missing or NULL and covariates are present
in <code>obj</code>, an ESW vector with length equal to 
the number of detections in <code>obj$detections</code> is returned. 
</p>
<p>If <code>obj</code> does not contain covariates, <code>newdata</code> is ignored and 
a scalar equal to the (constant) effective strip width for all 
detections is returned.
</p>


<h3>References</h3>

<p>Buckland, S.T., Anderson, D.R., Burnham, K.P. and Laake, J.L.
1993. <em>Distance Sampling: Estimating Abundance of Biological
Populations</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+EDR">EDR</a></code>, 
<code><a href="#topic+effectiveDistance">effectiveDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example sparrow data (line transect survey type)
data(sparrowDetectionData)

dfunc &lt;- dfuncEstim(formula=dist~1
                  , detectionData = sparrowDetectionData)

# Compute effective strip width (ESW)
ESW(dfunc)

</code></pre>

<hr>
<h2 id='F.double.obs.prob'>Compute double observer probability of detection (No external covariates allowed)</h2><span id='topic+F.double.obs.prob'></span>

<h3>Description</h3>

<p>Estimates the probability of detection in a two-observer system when observations are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.double.obs.prob(df, observer = "both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.double.obs.prob_+3A_df">df</code></td>
<td>
<p>A data frame containing the components <code>$obsby.1</code> and <code>$obsby.2</code>.
These components are either 0/1 (0 = missed, 1 = seen) or TRUE/FALSE (logical) vectors indicating whether
observer 1 (<code>obsby.1</code>) or observer 2 (<code>obsby.2</code>) spotted the target. There is 
no flexibility 
on naming these columns of <code>df</code>.  They must be named <code>$obsby.1</code> and <code>$obsby.2</code>.</p>
</td></tr>
<tr><td><code id="F.double.obs.prob_+3A_observer">observer</code></td>
<td>
<p>A number of text string indicating the primary observer.  Primary observers can be 
observer 1, or observer 2, or &quot;both&quot;.
If, for example, observer 2 was a data recorder and part-time observer, or if observer 2
was the pilot, set <code>observer</code> = 1.  This dictates which set of observations form the denominator
of the double observer system.  For example, if <code>observer</code> = 1, observations by observer 1 that were not seen
by observer 2 are ignored. The estimate in this case uses targets seen by both observers and
those seen by observer 2 but not observer 1. If observer = &quot;both&quot;, the denominator is computed twice, once 
assuming observer 1 was the primary, once assuming observer 2 was the primary, and then computes 
the probability of one or more observers sighting a target.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>observer</code> = &quot;both&quot;, the observers are assumed to be independent. In this case the estimate 
of detection is 
</p>
<p style="text-align: center;"><code class="reqn">p = p_1 + p_2 - p_1p_2</code>
</p>
  
<p>where <code class="reqn">p_1</code> is the proportion of targets seen by observer 2 that were also seen by observer 1, 
<code class="reqn">p_2</code> is the proportion of targets seen by observer 1 that were also seen by observer 2.
This estimator is very close to unbiased when observers are actually independent.
</p>


<h3>Value</h3>

<p>A single scalar, the probability of detection estimate.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+abundEstim">abundEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   Fake observers
  set.seed(538392)
  obsrv &lt;- data.frame( obsby.1=rbinom(100,1,.75), obsby.2=rbinom(100,1,.5) )
  
  F.double.obs.prob( obsrv, observer=1 )
  F.double.obs.prob( obsrv, observer=2 )
  F.double.obs.prob( obsrv, observer="both" )
</code></pre>

<hr>
<h2 id='F.gx.estim'>F.gx.estim - Estimate g(0) or g(x)</h2><span id='topic+F.gx.estim'></span>

<h3>Description</h3>

<p>Estimate g(0) or g(x) for a specified distance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.gx.estim(fit, x.scl = NULL, g.x.scl = NULL, observer = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.gx.estim_+3A_fit">fit</code></td>
<td>
<p>An estimated <code>dfunc</code> object.  See <code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="F.gx.estim_+3A_x.scl">x.scl</code></td>
<td>
<p>The x coordinate (a distance) at which to scale the 
sightability function to <code>g.x.scl</code>, or the string &quot;max&quot;.  
When <code>x.scl</code> is specified (i.e., not 0 or &quot;max&quot;), it must have measurement 
units assigned using either <code>library(units);units(x.scl) &lt;- '&lt;units&gt;'</code>
or <code>x.scl &lt;- units::set_units(x.scl, &lt;units&gt;)</code>. See
<code>units::valid_udunits()</code> for valid symbolic units. See 
Details for more on 
scaling the sightability function.</p>
</td></tr>
<tr><td><code id="F.gx.estim_+3A_g.x.scl">g.x.scl</code></td>
<td>
<p>Height of the distance function at coordinate <em>x</em>. 
The distance function 
will be scaled so that g(<code>x.scl</code>) = <code>g.x.scl</code>. 
If <code>g.x.scl</code> is not 
a data frame, it must be a numeric value (vector of length 1) 
between 0 and 1. 
See Details.</p>
</td></tr>
<tr><td><code id="F.gx.estim_+3A_observer">observer</code></td>
<td>
<p>A numeric scalar or text string specifying whether observer 1 
or observer 2 or both were full-time observers. 
This parameter dictates which set of observations form the denominator 
of a double observer system.   
If, for example, observer 2 was a data recorder and part-time observer, 
or if observer 2 was the pilot, set <code>observer</code> = 1.  
If <code>observer</code> = 1, observations by observer 1 not seen 
by observer 2 are ignored. The estimate of detection in this case is the 
ratio of number of targets seen by both observers 
to the number seen by both plus the number seen by just observer 2. 
If observer = &quot;both&quot;, the 
computation goes both directions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine scales sightability such that 
g(<code>x.scl</code>) = <code>g.x.scl</code>, where g() is the sightability function.
Specification of <code>x.scl</code> and <code>g.x.scl</code> covers several estimation cases:
</p>
  
<ol>
<li> <p><b>g(0) = 1</b> : (the default) Inputs are <code>x.scl</code> = 0, <code>g.x.scl</code> = 1. 
If <code>w.lo</code> &gt; 0, <code>x.scl</code> will be set to <code>w.lo</code>
so technically this case is g(<code>w.low</code>) = 1.
</p>
</li>
<li> <p><b>User supplied probability at specified distance</b>: Inputs are 
<code>x.scl</code> = a number greater than or equal 
to <code>w.lo</code>, <code>g.x.scl</code> = a number between 0 and 1.  This case 
covers situations where sightability on the transect (distance 0) is 
not perfect.  This case  assumes researchers have an independent 
estimate of sightability at distance 
<code>x.scl</code> off the transect.  For example, researchers could be
using multiple 
observers to estimate that sightability at distance <code>x.scl</code> 
is <code>g.x.scl</code>. 
</p>
</li>
<li> <p><b>Maximum sightability specified</b>: Inputs 
are <code>x.scl</code>=&quot;max&quot;, <code>g.x.scl</code> =  a number 
between 0 and 1.  In this case, 
g() is scaled such that its maximum value is <code>g.x.scl</code>.  
This routine computes the distance at which g() is maximum, sets 
g()'s height there to <code>g.x.scl</code>, and returns <code>x.max</code> where 
x.max is the distance at which g is maximized. This case covers the 
common aerial survey situation where maximum sightability is slightly 
off the transect, but the distance at which the maximum occurs 
is unknown. This case is the default, with <code>g.x.scl</code> = 1, 
when gamma distance functions are estimated. 
</p>
</li>
<li> <p><b>Double observer system</b>: Inputs are 
<code>x.scl</code>=&quot;max&quot;, <code>g.x.scl</code> = &lt;a data frame&gt;. 
In this case, g(<em>x</em>) = <em>h</em>, where <em>x</em> is the distance that 
maximizes g and <em>h</em> is the height of g() at <em>x</em> 
computed from the double observer data frame (see below for 
structure of the double observer data frame).
</p>
</li>
<li> <p><b>Distance of independence specified, height computed from double 
observer system</b>: Inputs are 
<code>x.scl</code> = a number greater than or equal to <code>w.lo</code>
<code>g.x.scl</code> = a data frame.  In this case, g(<code>x.scl</code>) = <em>h</em>, 
where <em>h</em> is computed from the double observer data frame 
(see below for structure of the double observer data frame). 
</p>
</li></ol>
   
<p>When <code>x.scl</code>, <code>g.x.scl</code>, or <code>observer</code> are NULL, the routine 
will look for and use <code>$call.x.scl</code>, or <code>$call.g.x.scl</code>, or 
<code>$call.observer</code> components of the <code>fit</code> object for whichever 
of these three parameters is missing.  Later, different 
values can be specified in a direct call to <code>F.gx.estim</code> 
without having to re-estimate the distance function. Because of this feature, 
the default values in <code>dfuncEstim</code> are <code>x.scl</code> = 0 and 
<code>g.x.scl</code> = 1 and <code>observer</code> = &quot;both&quot;.
</p>


<h3>Value</h3>

<p>A list comprised of the following components:
</p>
<table>
<tr><td><code>x.scl</code></td>
<td>
<p>The value of x (distance) at which g() is evaluated.  </p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>The estimated value of g() when evaluated at <code>x.scl</code>.  </p>
</td></tr>
</table>


<h3>Structure of the double observer data frame</h3>

<p>When <code>g.x.scl</code> is a data frame, it is assumed to contain 
the components <code>$obsby.1</code> and <code>$obsby.2</code> (no flexibility on names). 
Each row in the data frame contains data from one sighted target. 
The <code>$obsby.1</code> and <code>$obsby.2</code> components are 
TRUE/FALSE (logical) vectors indicating whether 
observer 1 (<code>obsby.1</code>) or observer 2 (<code>obsby.2</code>) spotted the target.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(555574)
  x &lt;- rnorm(1000) * 100
  x &lt;- x[ 0 &lt; x &amp; x &lt; 100 ]
  x &lt;- units::set_units(x, "m")
  un.dfunc &lt;- dfuncEstim( x ~ 1
                       , likelihood = "logistic")    
  F.gx.estim(un.dfunc)
  
  x &lt;- rgamma(1000, shape = 5)
  x &lt;- units::set_units(x, "m")
  gam.dfunc &lt;- dfuncEstim( x ~ 1
                         , likelihood="Gamma")    
  F.gx.estim(gam.dfunc)
  
</code></pre>

<hr>
<h2 id='F.maximize.g'>Find the coordinate of the maximum of a distance function</h2><span id='topic+F.maximize.g'></span>

<h3>Description</h3>

<p>Find the x coordinate that maximizes g(x).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.maximize.g(fit, covars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.maximize.g_+3A_fit">fit</code></td>
<td>
<p>An estimated 'dfunc' object produced by <code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="F.maximize.g_+3A_covars">covars</code></td>
<td>
<p>Covariate values to calculate maximum for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of x that maximizes g(x) in <code>fit</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fake data
set.seed(22223333)
x &lt;- rgamma(100, 10, 1)

fit &lt;- dfuncEstim( x, likelihood="Gamma", x.scl="max" )

F.maximize.g( fit )  # should be near 10.
fit$x.scl            # same thing

## End(Not run)

</code></pre>

<hr>
<h2 id='F.nLL'>Return the negative log likelihood for 
a set of distance values</h2><span id='topic+F.nLL'></span>

<h3>Description</h3>

<p>Return value of the negative log likelihood for 
a vector of observed distances given a specified likelihood, 
number of expansion terms, and estimated parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.nLL(
  a,
  dist,
  covars = NULL,
  like,
  w.lo = 0,
  w.hi = max(dist),
  series,
  expansions = 0,
  pointSurvey,
  for.optim = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.nLL_+3A_a">a</code></td>
<td>
<p>A vector of parameter values for
the likelihood. Length of this vector must be 
<code>expansions + 1 + 1*(like %in% c("hazrate", "uniform"))</code>.</p>
</td></tr>
<tr><td><code id="F.nLL_+3A_dist">dist</code></td>
<td>
<p>A vector of observed distances. All values must be between 
<code>w.lo</code> and <code>w.hi</code> (see below).</p>
</td></tr>
<tr><td><code id="F.nLL_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates 
at each observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="F.nLL_+3A_like">like</code></td>
<td>
<p>String specifying the form of the likelihood.
Built-in distance functions at present are &quot;uniform&quot;, &quot;halfnorm&quot;, 
&quot;hazrate&quot;, &quot;negexp&quot;, and &quot;Gamma&quot;.  To be valid, a function 
named <code>paste(like,".like")</code> (e.g., &quot;uniform.like&quot;) must exist
somewhere in this routine's scope.  This routine finds the &quot;.like&quot; 
function and calls it with the appropriate parameters.  
A user-defined likelihood can be implemented by simply defining a 
function with the &quot;.like&quot; extension and giving the root name here. 
For example, define a function named &quot;myLike.like&quot; in the 
<code>.GlobalEnv</code> and set <code>like="myLike"</code> here.  See 
the vignette on this topic.</p>
</td></tr>
<tr><td><code id="F.nLL_+3A_w.lo">w.lo</code></td>
<td>
<p>Lower or left-truncation limit of the distances.
This is the minimum possible off-transect distance. Default is 0.</p>
</td></tr>
<tr><td><code id="F.nLL_+3A_w.hi">w.hi</code></td>
<td>
<p>Upper or right-truncation limit of the distances. 
This is the maximum off-transect distance that could be observed. 
Default is the maximum observed distance.</p>
</td></tr>
<tr><td><code id="F.nLL_+3A_series">series</code></td>
<td>
<p>String specifying the type of expansion to 
use series if <code>expansions</code> &gt; 0. Valid values at present 
are 'simple', 'hermite', and 'cosine'.</p>
</td></tr>
<tr><td><code id="F.nLL_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms 
in <code>series</code> to compute. Depending on the series, this 
could be 0 through 5. The default of 0 equates to no 
expansion terms of any type.</p>
</td></tr>
<tr><td><code id="F.nLL_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if <code>dist</code> is point 
transect data, FALSE if line transect data.</p>
</td></tr>
<tr><td><code id="F.nLL_+3A_for.optim">for.optim</code></td>
<td>
<p>Boolean. If TRUE, values are multiplied 
by 10^9 to help <code>optim</code> converge more consistently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, the negative of the log likelihood evaluated at 
parameters <code>a</code>, including expansion terms.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+uniform.like">uniform.like</a></code> and links there; 
<code><a href="#topic+dfuncEstim">dfuncEstim</a></code>
</p>

<hr>
<h2 id='F.start.limits'>Set starting values and limits for parameters of Rdistance functions</h2><span id='topic+F.start.limits'></span>

<h3>Description</h3>

<p>Return reasonable starting values and limits (boundaries) for the parameters of 
distance functions.  Starting values and limits are specified for 
all likelihoods and expansion terms.  This function is called by 
other routines in <code>Rdistance</code>, and is not intended to 
be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.start.limits(
  like,
  expan,
  w.lo,
  w.hi,
  dist,
  covars = NULL,
  pointSurvey = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.start.limits_+3A_like">like</code></td>
<td>
<p>String specifying the likelihood for the distance function.  Possible values are 
&quot;hazrate&quot; for hazard rate likelihood, &quot;halfnorm&quot; for the half 
normal likelihood, &quot;uniform&quot; for the uniform likelihood, 
&quot;negexp&quot; for the negative exponential likelihood, and 
&quot;Gamma&quot; for the gamma likelihood.</p>
</td></tr>
<tr><td><code id="F.start.limits_+3A_expan">expan</code></td>
<td>
<p>Number of expansion terms to include. Valid values are 0, 1, ..., 3.</p>
</td></tr>
<tr><td><code id="F.start.limits_+3A_w.lo">w.lo</code></td>
<td>
<p>Lower or left-truncation limit of the distances.  Normally, 0.</p>
</td></tr>
<tr><td><code id="F.start.limits_+3A_w.hi">w.hi</code></td>
<td>
<p>Upper or right-truncation limit of the distances. This is the maximum off-transect distance that could be observed.</p>
</td></tr>
<tr><td><code id="F.start.limits_+3A_dist">dist</code></td>
<td>
<p>The vector of observed off-transect distances being analyzed.  This vector is only required for <code>like</code> = &quot;Gamma&quot; and &quot;halfnorm&quot;.</p>
</td></tr>
<tr><td><code id="F.start.limits_+3A_covars">covars</code></td>
<td>
<p>Matrix of covariate values.</p>
</td></tr>
<tr><td><code id="F.start.limits_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if point transect data, FALSE if line transect data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of parameters to be fitted is 
<code>expan + 1 + 1*(like %in% c("hazrate", "uniform"))</code>.
This is the length of all vectors returned in the output list.
</p>


<h3>Value</h3>

<p>A list containing the following components
</p>
<table>
<tr><td><code>start</code></td>
<td>
<p>Vector of reasonable starting values for parameters of the likelihood and expansion terms. </p>
</td></tr>
<tr><td><code>lowlimit</code></td>
<td>
<p>Vector of lower limits for the likelihood parameters and expansion terms.</p>
</td></tr>
<tr><td><code>uplimit</code></td>
<td>
<p>Vector of upper limits for the likelihood parameters and expansion terms.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>Vector of names for the likelihood parameters and expansion terms.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(sparrowDetectionData)
  dist &lt;- sparrowDetectionData$dist
  units(dist) &lt;- "m"
  wl &lt;- units::as_units(0, "m")
  wh &lt;- units::as_units(1000, "m")
  
  F.start.limits("uniform", 0, wl, wh, dist)
  F.start.limits("uniform", 1, wl, wh, dist)
  F.start.limits("uniform", 2, wl, wh, dist)
  F.start.limits("uniform", 3, wl, wh, dist)
  
  F.start.limits("halfnorm", 0, wl, wh, dist)
  F.start.limits("halfnorm", 1, wl, wh, dist)
  F.start.limits("halfnorm", 2, wl, wh, dist)
  F.start.limits("halfnorm", 3, wl, wh, dist)
  
  F.start.limits("halfnorm", 0, wl, wh, dist, pointSurvey = TRUE)
  F.start.limits("halfnorm", 1, wl, wh, dist, pointSurvey = TRUE)
  F.start.limits("halfnorm", 2, wl, wh, dist, pointSurvey = TRUE)
  F.start.limits("halfnorm", 3, wl, wh, dist, pointSurvey = TRUE)
  
  F.start.limits("halfnorm", 0, wl, wh, dist, data.frame(A=1, B=2))
  F.start.limits("halfnorm", 1, wl, wh, dist, data.frame(A=1, B=2))
  F.start.limits("halfnorm", 2, wl, wh, dist, data.frame(A=1, B=2))
  F.start.limits("halfnorm", 3, wl, wh, dist, data.frame(A=1, B=2))
  
  F.start.limits("halfnorm", 0, wl, wh, dist, data.frame(A=1, B=2), TRUE)
  F.start.limits("halfnorm", 1, wl, wh, dist, data.frame(A=1, B=2), TRUE)
  F.start.limits("halfnorm", 2, wl, wh, dist, data.frame(A=1, B=2), TRUE)
  F.start.limits("halfnorm", 3, wl, wh, dist, data.frame(A=1, B=2), TRUE)
  
  F.start.limits("hazrate", 0, wl, wh, dist)
  F.start.limits("hazrate", 1, wl, wh, dist)
  F.start.limits("hazrate", 2, wl, wh, dist)
  F.start.limits("hazrate", 3, wl, wh, dist)
  
  F.start.limits("negexp", 0, wl, wh, dist)
  F.start.limits("negexp", 1, wl, wh, dist)
  F.start.limits("negexp", 2, wl, wh, dist)
  F.start.limits("negexp", 3, wl, wh, dist)
  
  F.start.limits("Gamma", 0, wl, wh, dist)
</code></pre>

<hr>
<h2 id='Gamma.like'>Gamma.like - Gamma distance function</h2><span id='topic+Gamma.like'></span>

<h3>Description</h3>

<p>Computes the gamma likelihood, 
scaled appropriately, for use as a likelihood 
in estimating a distance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gamma.like(
  a,
  dist,
  covars = NULL,
  w.lo = units::set_units(0, "m"),
  w.hi = max(dist),
  series = "cosine",
  expansions = 0,
  scale = TRUE,
  pointSurvey = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gamma.like_+3A_a">a</code></td>
<td>
<p>A vector of likelihood parameter values. Length and meaning depend on <code>series</code> and <code>expansions</code>. If no expansion terms were called for
(i.e., <code>expansions = 0</code>), the distance likelihoods contain one or two canonical parameters (see Details). If one or more expansions are called for,
coefficients for the expansion terms follow coefficients for the canonical parameters.  If <code>p</code> is the number of canonical parameters, coefficients
for the expansion terms are <code>a[(p+1):length(a)]</code>.</p>
</td></tr>
<tr><td><code id="Gamma.like_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing the observed distances.</p>
</td></tr>
<tr><td><code id="Gamma.like_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates at each observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="Gamma.like_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance.  This is the <em>left truncation</em> of sighting distances in <code>dist</code>. Same units as <code>dist</code>.
Values less than <code>w.lo</code> are allowed in <code>dist</code>, but are ignored and their contribution to the likelihood is set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="Gamma.like_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance.
This is the <em>right truncation</em> of sighting distances in 
<code>dist</code>.  Same units as <code>dist</code>.
Values greater than <code>w.hi</code> are allowed in <code>dist</code>, but are ignored and their contribution to the likelihood is set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="Gamma.like_+3A_series">series</code></td>
<td>
<p>A string specifying the type of expansion to use.  Currently, valid values are 'simple', 'hermite', and 'cosine'; but, see 
<code><a href="#topic+dfuncEstim">dfuncEstim</a></code> about defining other series.</p>
</td></tr>
<tr><td><code id="Gamma.like_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms in <code>series</code>. Depending on the series, this could be 0 through 5.
The default of 0 equates to no expansion terms of any type.</p>
</td></tr>
<tr><td><code id="Gamma.like_+3A_scale">scale</code></td>
<td>
<p>Logical scalar indicating whether or not to scale the likelihood so it integrates to 1. This parameter is used to stop recursion in other functions.
If <code>scale</code> equals TRUE, a numerical integration routine (<code><a href="#topic+integration.constant">integration.constant</a></code>) is called, which in turn calls this likelihood function again
with <code>scale</code> = FALSE. Thus, this routine knows when its values are being used to compute the likelihood and when its value is being used to compute the 
constant of integration.  All user defined likelihoods must have and use this parameter.</p>
</td></tr>
<tr><td><code id="Gamma.like_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if <code>dist</code> is point transect data, FALSE if line transect data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilizes the built-in R function <code>dgamma</code> to evaluate the gamma density function.  Using the parameterization of <code>dgamma</code>, 
the gamma shape parameter is <code>a[1]</code> while the gamma scale parameter is <code>(a[2]/gamma(r)) * (((r - 1)/exp(1))^(r - 1))</code>. Currently, this function 
implements a non-covariate version of the gamma detection function used by Becker and Quang (2009).  In future, linear equations will relate covariate values 
to values of the gamma parameters.  This future implementation will fully replicate the distance functions of Becker and Quang (2009).
</p>


<h3>Value</h3>

<p>A numeric vector the same length and order as <code>dist</code> containing the likelihood contribution for distances in <code>dist</code>.  Assuming 
<code>L=gamma.like(c(r,lam),dist)</code>, the full log likelihood of all the data is <code>-sum(log(L), na.rm=T)</code>. Note that the returned likelihood value for 
distances less than <code>w.lo</code> or greater than <code>w.hi</code> is <code>NA</code>, and thus it is prudent to use <code>na.rm=TRUE</code> in the sum. If <code>scale</code> = TRUE, 
the integral of the likelihood from <code>w.lo</code> to <code>w.hi</code> is 1.0. If <code>scale</code> = FALSE, the integral of the likelihood is an arbitrary constant.
</p>


<h3>References</h3>

<p>Becker, E. F., and P. X. Quang, 2009. <em>A Gamma-Shaped Detection Function for Line-Transect Surveys with Mark-Recapture and Covariate Data.</em>
Journal of Agricultural, Biological, and Environmental Statistics 14(2):207-223.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+halfnorm.like">halfnorm.like</a></code>, <code><a href="#topic+hazrate.like">hazrate.like</a></code>, <code><a href="#topic+uniform.like">uniform.like</a></code>, <code><a href="#topic+negexp.like">negexp.like</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(238642)
x &lt;- seq(0, 100, length=100)

# Plots showing effects of changes in shape
plot(x, Gamma.like(c(20,20), x), type="l", col="red")
plot(x, Gamma.like(c(40,20), x), type="l", col="blue")

# Plots showing effects of changes in scale
plot(x, Gamma.like(c(20,20), x), type="l", col="red")
plot(x, Gamma.like(c(20,40), x), type="l", col="blue")

# Estimate 'Gamma' distance function
r &lt;- 5
lam &lt;- 10
b &lt;- (1/gamma(r)) * (((r - 1)/exp(1))^(r - 1))
x &lt;- rgamma(1000, shape=r, scale=b*lam)
dfunc &lt;- dfuncEstim(x~1, likelihood="Gamma", x.scl="max")
plot(dfunc)

## End(Not run)
</code></pre>

<hr>
<h2 id='Gamma.start.limits'>Gamma.start.limits - Start and limit values for Gamma parameters.</h2><span id='topic+Gamma.start.limits'></span>

<h3>Description</h3>

<p>Compute starting values and limits for the Gamma likelihood
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gamma.start.limits(dist, covars, expansions, w.lo, w.hi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gamma.start.limits_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing observed distances with measurement
units.</p>
</td></tr>
<tr><td><code id="Gamma.start.limits_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates at 
each observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="Gamma.start.limits_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms 
in <code>series</code>. Depending on the series, this could be 0 through 5.
The default of 0 equates to no expansion terms of any type.</p>
</td></tr>
<tr><td><code id="Gamma.start.limits_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance, with measurement
units.  
This is the <em>left truncation</em> sighting distance.  Values less than 
<code>w.lo</code> are allowed in <code>dist</code>, but are ignored and 
their likelihood value is set to
<code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="Gamma.start.limits_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance, with measurement
units.  
This is the <em>right truncation</em> sighting distance.
Values greater than <code>w.hi</code> are allowed in <code>dist</code>, 
but are ignored and their likelihood value is 
set to <code>NA</code> in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li> <p><code>start</code> : a vector of starting values
</p>
</li>
<li> <p><code>lowlimit</code> : a vector of lower limits (can be -Inf)
</p>
</li>
<li> <p><code>highlimit</code> : a vector of upper limits (can be Inf)
</p>
</li>
<li> <p><code>nms</code> : a vector containing names of the parameters
</p>
</li></ul>


<hr>
<h2 id='getDfuncModelFrame'>Return model frame for dfunc</h2><span id='topic+getDfuncModelFrame'></span>

<h3>Description</h3>

<p>Returns the model frame from a formula and 
data set. This routine is intended to only be called from within other Rdistance
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDfuncModelFrame(formula, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDfuncModelFrame_+3A_formula">formula</code></td>
<td>
<p>A dfunc formula object.  See <code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="getDfuncModelFrame_+3A_data">data</code></td>
<td>
<p>The data frame from which variables in formula (potentially) come.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine is needed to get the scoping correct in <code>dfuncEstim</code>. 
In <code>dfuncEstim</code>, we first merge the detection and site data frames, then 
call this routine.
</p>


<h3>Value</h3>

<p>a model frame containing the response and covariates resulting from 
evaluating formula in data.
</p>

<hr>
<h2 id='halfnorm.like'>Half-normal likelihood function for distance analyses</h2><span id='topic+halfnorm.like'></span>

<h3>Description</h3>

<p>This function computes the likelihood contributions for 
sighting distances, scaled appropriately, for use as a 
distance likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halfnorm.like(
  a,
  dist,
  covars = NULL,
  w.lo = units::set_units(0, "m"),
  w.hi = max(dist),
  series = "cosine",
  expansions = 0,
  scale = TRUE,
  pointSurvey = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="halfnorm.like_+3A_a">a</code></td>
<td>
<p>A vector of likelihood parameter values. Length and 
meaning depend on <code>series</code> and <code>expansions</code>. If no expansion 
terms were called for (i.e., <code>expansions = 0</code>), the distance 
likelihoods contain one or two canonical parameters (see Details). 
If one or more expansions are called for, coefficients for the 
expansion terms follow coefficients for the canonical parameters.  
i.e., if <code>p</code> is the number of canonical parameters, coefficients
for the expansion terms are <code>a[(p+1):length(a)]</code>.</p>
</td></tr>
<tr><td><code id="halfnorm.like_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing the observed distances.</p>
</td></tr>
<tr><td><code id="halfnorm.like_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates at 
each observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="halfnorm.like_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance.
This is the <em>left truncation</em> of sighting distances 
in <code>dist</code>. Same units as <code>dist</code>. Values less than 
<code>w.lo</code> are allowed in <code>dist</code>, but are ignored and 
their contribution to the likelihood is set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="halfnorm.like_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance.
This is the <em>right truncation</em> of sighting distances 
in <code>dist</code>.  Same units as <code>dist</code>. Values greater 
than <code>w.hi</code> are allowed in <code>dist</code>, but are ignored 
and their contribution to the likelihood is set to <code>NA</code> 
in the output.</p>
</td></tr>
<tr><td><code id="halfnorm.like_+3A_series">series</code></td>
<td>
<p>A string specifying the type of expansion to use.
Currently, valid values are 'simple', 'hermite', and 'cosine'; but, see 
<code><a href="#topic+dfuncEstim">dfuncEstim</a></code> about defining other series.</p>
</td></tr>
<tr><td><code id="halfnorm.like_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms 
in <code>series</code>. Depending on the series, this could be 0 through 5.
The default of 0 equates to no expansion terms of any type.</p>
</td></tr>
<tr><td><code id="halfnorm.like_+3A_scale">scale</code></td>
<td>
<p>Logical scalar indicating whether or not to 
scale the likelihood so it integrates to 1. This parameter is 
used to stop recursion in other functions. If <code>scale</code> 
equals TRUE, a numerical integration routine 
(<code><a href="#topic+integration.constant">integration.constant</a></code>) is called, which in turn 
calls this likelihood function again with <code>scale</code> = FALSE. 
Thus, this routine knows when its values are being used to compute 
the likelihood and when its value is being used to compute the 
constant of integration.  All user defined likelihoods must have 
and use this parameter.</p>
</td></tr>
<tr><td><code id="halfnorm.like_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if distances in <code>dist</code> are 
radial from point 
transects, FALSE if distances are perpendicular off-transect distances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The half-normal likelihood is 
</p>
<p style="text-align: center;"><code class="reqn">f(x|a) = \exp(-x^2 / (2*a^2))</code>
</p>

<p>where <code class="reqn">a</code> is the parameter to be estimated.
Some half-normal distance functions in the literature 
do not use a &quot;2&quot; in the 
denominator of the exponent.  <code>Rdistance</code> uses a 
&quot;2&quot; in the denominator of the exponent to make quantiles of this 
function agree with 
the standard normal which means <em>a</em> can be interpreted as a 
normal standard error.  e.g., approximately 95% of all observations 
will occur between 0 and 2<em>a</em>.
</p>
<p><b>Expansion Terms</b>: If <code>expansions</code> = k (k &gt; 0), the expansion function specified by <code>series</code> is called (see for example
<code><a href="#topic+cosine.expansion">cosine.expansion</a></code>). Assuming <code class="reqn">h_{ij}(x)</code> is the <code class="reqn">j^{th}</code> expansion term for the <code class="reqn">i^{th}</code> distance and that 
<code class="reqn">c_1, c_2, \dots, c_k</code>are (estimated) coefficients for the expansion terms, the likelihood contribution for the <code class="reqn">i^{th}</code> 
distance is, </p>
<p style="text-align: center;"><code class="reqn">f(x|a,b,c_1,c_2,\dots,c_k) = f(x|a,b)(1 + \sum_{j=1}^{k} c_j h_{ij}(x)).</code>
</p>

<p>f(x|a,b,c_1,c_2,...,c_k) = f(x|a,b)(1 + c(1) h_i1(x) + c(2) h_i2(x) + ... + c(k) h_ik(x)). 
</p>


<h3>Value</h3>

<p>A numeric vector the same length and order as <code>dist</code> containing the 
likelihood contribution for corresponding distances in <code>dist</code>. 
Assuming <code>L</code> is the returned vector from one of these functions, 
the negative log likelihood of all the data is <code>-sum(log(L), na.rm=T)</code>. 
Note that the returned likelihood value for distances less 
than <code>w.lo</code> or greater than <code>w.hi</code> is <code>NA</code>, 
hence <code>na.rm=TRUE</code> in the sum. 
If <code>scale</code> = TRUE, the integral of the likelihood from
<code>w.lo</code> to <code>w.hi</code> is 1.0. If <code>scale</code> = FALSE, 
the integral of the likelihood is something else. 
Values are always greater than or equal to zero.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>,
<code><a href="#topic+hazrate.like">hazrate.like</a></code>,
<code><a href="#topic+uniform.like">uniform.like</a></code>,
<code><a href="#topic+negexp.like">negexp.like</a></code>,
<code><a href="#topic+Gamma.like">Gamma.like</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
set.seed(238642)
x &lt;- seq(0, 100, length=100)

# Plots showing effects of changes in parameter Sigma
plot(x, halfnorm.like(20, x), type="l", col="red")
plot(x, halfnorm.like(40, x), type="l", col="blue")

# Estimate 'halfnorm' distance function
a &lt;- 5
x &lt;- rnorm(1000, mean=0, sd=a)
x &lt;- x[x &gt;= 0]
dfunc &lt;- dfuncEstim(x~1, likelihood="halfnorm")
plot(dfunc)

# evaluate the log Likelihood
L &lt;- halfnorm.like(dfunc$parameters, dfunc$detections$dist, covars=dfunc$covars, 
    w.lo=dfunc$w.lo, w.hi=dfunc$w.hi, 
    series=dfunc$series, expansions=dfunc$expansions, 
    scale=TRUE)
-sum(log(L), na.rm=TRUE)  # the negative log likelihood

## End(Not run)
</code></pre>

<hr>
<h2 id='hazrate.like'>hazrate.like - Hazard rate likelihood</h2><span id='topic+hazrate.like'></span>

<h3>Description</h3>

<p>Computes the hazard rate likelihood of  
off-transect distances, given parameters. Primarily used as 
a minimization objective during distance function estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazrate.like(
  a,
  dist,
  covars = NULL,
  w.lo = units::set_units(0, "m"),
  w.hi = max(dist),
  series = "cosine",
  expansions = 0,
  scale = TRUE,
  pointSurvey = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazrate.like_+3A_a">a</code></td>
<td>
<p>A vector of likelihood parameter values. Length and meaning 
depend on <code>series</code> and <code>expansions</code>. If no expansion terms 
were called for
(i.e., <code>expansions = 0</code>), the distance likelihoods contain 
one or two canonical parameters (see Details). If one or more 
expansions are called for,
coefficients for the expansion terms follow coefficients for the 
canonical parameters.  If <code>p</code> is the number of canonical 
parameters, coefficients
for the expansion terms are <code>a[(p+1):length(a)]</code>.</p>
</td></tr>
<tr><td><code id="hazrate.like_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing the observed distances.</p>
</td></tr>
<tr><td><code id="hazrate.like_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates at 
each observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="hazrate.like_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance.
This is the <em>left truncation</em> of sighting distances in 
<code>dist</code>. Same units as <code>dist</code>.
Values less than <code>w.lo</code> are allowed in <code>dist</code>, 
but are ignored and their contribution to the likelihood is 
set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="hazrate.like_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance.
This is the <em>right truncation</em> of sighting distances in 
<code>dist</code>.  Same units as <code>dist</code>.
Values greater than <code>w.hi</code> are allowed in <code>dist</code>, 
but are ignored and their contribution to the likelihood is 
set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="hazrate.like_+3A_series">series</code></td>
<td>
<p>A string specifying the type of expansion to use.
Currently, valid values are 'simple', 'hermite', and 'cosine'; but, see 
<code><a href="#topic+dfuncEstim">dfuncEstim</a></code> about defining other series.</p>
</td></tr>
<tr><td><code id="hazrate.like_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms in 
<code>series</code>. Depending on the series, this could be 0 through 5.
The default of 0 equates to no expansion terms of any type.</p>
</td></tr>
<tr><td><code id="hazrate.like_+3A_scale">scale</code></td>
<td>
<p>Logical scalar indicating whether or not to scale 
the likelihood so it integrates to 1. This parameter is used to 
stop recursion in other functions.
If <code>scale</code> equals TRUE, a numerical integration 
routine (<code><a href="#topic+integration.constant">integration.constant</a></code>) is called, which 
in turn calls this likelihood function again
with <code>scale</code> = FALSE. Thus, this routine knows when its 
values are being used to compute the likelihood and when its 
value is being used to compute the 
constant of integration.  All user defined likelihoods must have 
and use this parameter.</p>
</td></tr>
<tr><td><code id="hazrate.like_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if <code>dist</code> is point 
transect data, FALSE if line transect data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hazard rate likelihood is 
</p>
<p style="text-align: center;"><code class="reqn">f(x|\sigma,k) = 1 - \exp(-(x/\sigma)^{-k})</code>
</p>
 
<p>where <code class="reqn">\sigma</code> determines location 
(i.e., distance at which the function equals 1 - exp(-1) = 0.632), 
and <code class="reqn">k</code> determines slope of the function 
at <code class="reqn">\sigma</code> (i.e., larger k equals steeper 
slope at <code class="reqn">\sigma</code>). For distance analysis, 
the valid range for both <code class="reqn">\sigma</code> and k is
<code class="reqn">\geq 0</code>.  
</p>
<p><b>Expansion Terms</b>: If <code>expansions</code> = e 
(e &gt; 0), the expansion function specified by 
<code>series</code> is called (see for example
<code><a href="#topic+cosine.expansion">cosine.expansion</a></code>). Assuming 
<code class="reqn">h_{ij}(x)</code> is the <code class="reqn">j^{th}</code> 
expansion term for the <code class="reqn">i^{th}</code> distance and that 
<code class="reqn">c_1, c_2, \dots, c_k</code> are 
(estimated) coefficients for the expansion terms, the 
likelihood contribution for the <code class="reqn">i^{th}</code> 
distance is, </p>
<p style="text-align: center;"><code class="reqn">f(x|a,b,c_1,c_2,\dots,c_e) = f(x|a,b)(1 + 
  \sum_{j=1}^{e} c_j h_{ij}(x)).</code>
</p>



<h3>Value</h3>

<p>A numeric vector the same length and order as 
<code>dist</code> containing the likelihood contribution for 
corresponding distances in <code>dist</code>. 
Assuming <code>L</code> is the returned vector from one of these 
functions, the full log likelihood of all the data is 
<code>-sum(log(L), na.rm=T)</code>. Note that the
returned likelihood value for distances less than 
<code>w.lo</code> or greater than <code>w.hi</code> is <code>NA</code>, 
and thus it is prudent to use <code>na.rm=TRUE</code> in the
sum. If <code>scale</code> = TRUE, the integral of the likelihood 
from <code>w.lo</code> to <code>w.hi</code> is 1.0. If <code>scale</code> = 
FALSE, the integral of the likelihood is
arbitrary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>,
<code><a href="#topic+halfnorm.like">halfnorm.like</a></code>,
<code><a href="#topic+uniform.like">uniform.like</a></code>,
<code><a href="#topic+negexp.like">negexp.like</a></code>,
<code><a href="#topic+Gamma.like">Gamma.like</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- seq(0, 100, length=100)

# Plots showing effects of changes in sigma
plot(x, hazrate.like(c(20, 5), x), type="l", col="red")
plot(x, hazrate.like(c(40, 5), x), type="l", col="blue")

# Plots showing effects of changes in beta
plot(x, hazrate.like(c(50, 20), x), type="l", col="red")
plot(x, hazrate.like(c(50, 2), x), type="l", col="blue")

## End(Not run)
         
</code></pre>

<hr>
<h2 id='hermite.expansion'>Calculation of Hermite expansion for detection function likelihoods</h2><span id='topic+hermite.expansion'></span>

<h3>Description</h3>

<p>Computes the Hermite expansion terms used in the likelihood of a distance analysis. 
More generally, will compute a Hermite expansion of any numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hermite.expansion(x, expansions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hermite.expansion_+3A_x">x</code></td>
<td>
<p>In a distance analysis, <code>x</code> is a numeric vector containing the proportion of a strip 
transect's half-width at which a group of individuals was sighted.  If <code class="reqn">w</code> is the strip transect 
half-width or maximum sighting distance, and <code class="reqn">d</code> is the perpendicular off-transect distance 
to a sighted group (<code class="reqn">d\leq w</code>), <code>x</code> is usually <code class="reqn">d/w</code>.  More generally, <code>x</code> 
is a vector of numeric values.</p>
</td></tr>
<tr><td><code id="hermite.expansion_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of expansion terms to compute. Must be one of the integers 1, 2, 3, or 4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are, in general, several expansions that can be called Hermite. The Hermite expansion used here is:
</p>

<ul>
<li> <p><b>First term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_1(x)=x^4 - 6x^2 + 3,</code>
</p>

</li>
<li> <p><b>Second term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_2(x)=x^6 - 15x^4 + 45x^2 - 15,</code>
</p>

</li>
<li> <p><b>Third term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_3(x)=x^8 - 28x^6 + 210x^4 - 420x^2 + 105,</code>
</p>

</li>
<li> <p><b>Fourth term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_4(x)=x^10 - 45x^8 + 630x^6 - 3150x^4 + 4725x^2 - 945,</code>
</p>

</li></ul>

<p>The maximum number of expansion terms computed is 4.
</p>


<h3>Value</h3>

<p>A matrix of size <code>length(x)</code> X <code>expansions</code>.  The columns of this matrix are the Hermite polynomial expansions of <code>x</code>. 
Column 1 is the first expansion term of <code>x</code>, column 2 is the second expansion term of <code>x</code>, and so on up to <code>expansions</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+cosine.expansion">cosine.expansion</a></code>, <code><a href="#topic+simple.expansion">simple.expansion</a></code>, and the discussion 
of user defined likelihoods in <code><a href="#topic+dfuncEstim">dfuncEstim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(83828233)
  x &lt;- rnorm(1000) * 100
  x &lt;- x[0 &lt; x &amp; x &lt; 100]
  herm.expn &lt;- hermite.expansion(x, 3)
</code></pre>

<hr>
<h2 id='integration.constant'>Compute the integration constant for distance density functions</h2><span id='topic+integration.constant'></span>

<h3>Description</h3>

<p>Using numerical integration, this function computes
the area under a distance function between two limits (<code>w.lo</code>
and <code>w.hi</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integration.constant(
  dist,
  density,
  a,
  covars,
  w.lo,
  w.hi,
  series,
  expansions,
  pointSurvey
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integration.constant_+3A_dist">dist</code></td>
<td>
<p>Vector of detection distance values.</p>
</td></tr>
<tr><td><code id="integration.constant_+3A_density">density</code></td>
<td>
<p>A likelihood function for which the
integration constant is sought. This function
must be capable of evaluating values between <code>w.lo</code>
and <code>w.hi</code> and have the following parameters:
</p>

<ul>
<li> <p>&lsquo;<span class="samp">&#8288;a&#8288;</span>&rsquo; = Parameter vector.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;dist&#8288;</span>&rsquo; = Vector of distances.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;covars&#8288;</span>&rsquo; = If the density allows covariates, 
the covariate matrix.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;w.lo&#8288;</span>&rsquo; = Lower limit or left truncation value.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;w.hi&#8288;</span>&rsquo; = Upper limit or right truncation value.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;series&#8288;</span>&rsquo; = Form of the series expansions, if any.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;expansions&#8288;</span>&rsquo; = Number of expansion terms.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;scale&#8288;</span>&rsquo; = Whether to scale function to integrate to 1.
</p>
</li></ul>
</td></tr>
<tr><td><code id="integration.constant_+3A_a">a</code></td>
<td>
<p>Vector of parameters to pass to <code>density</code>.</p>
</td></tr>
<tr><td><code id="integration.constant_+3A_covars">covars</code></td>
<td>
<p>Matrix of covariate values.</p>
</td></tr>
<tr><td><code id="integration.constant_+3A_w.lo">w.lo</code></td>
<td>
<p>The lower limit of integration, or the left truncation
value for perpendicular distances.</p>
</td></tr>
<tr><td><code id="integration.constant_+3A_w.hi">w.hi</code></td>
<td>
<p>The upper limit of integration, or the right truncation
value for perpendicular distances.</p>
</td></tr>
<tr><td><code id="integration.constant_+3A_series">series</code></td>
<td>
<p>The series to use for expansions. 
If <code>expansions</code> &gt; 0, this string 
specifies the type of expansion. Valid values at 
present are 'simple', 'hermite', and 'cosine'.</p>
</td></tr>
<tr><td><code id="integration.constant_+3A_expansions">expansions</code></td>
<td>
<p>Number of expansions in <code>density</code>.</p>
</td></tr>
<tr><td><code id="integration.constant_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if point transect data,
FALSE if line transect data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trapezoid rule is used to numerically integrate
<code>density</code> from <code>w.lo</code> to <code>w.hi</code>. Two-hundred
(200) equal-sized trapezoids are used in the integration.  The number
of trapezoids to use is fixed and cannot be changed without
re-writing this routine.
</p>


<h3>Value</h3>

<p>A scalar (or vector of scalars if covariates are present)
that is the area under <code>density</code> between <code>w.lo</code> and <code>w.hi</code>.
This scalar can be used as a divisor to scale density such that
it integrates to 1.0. If x = density(...), then
x / <code>integration.constant(density, ...)</code> will integrate to 1.0.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+halfnorm.like">halfnorm.like</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Can put any number for first argument (1 used here)
scl &lt;- integration.constant(dist=units::set_units(1,"m")
                          , density=logistic.like
                          , covars = NULL
                          , pointSurvey = FALSE
                          , w.lo = units::set_units(0,"m")
                          , w.hi = units::set_units(100,"m")
                          , expansions = 0
                          , a=c(75,25))
print(scl) # Should be 75.1

x &lt;- units::set_units(seq(0,100,length=200), "m")
y &lt;- logistic.like( c(75,25), x, scale=FALSE ) / scl
int.y &lt;- (x[2]-x[1]) * sum(y[-length(y)]+y[-1]) / 2  # the trapezoid rule, should be 1.0
print(int.y) # Should be 1

</code></pre>

<hr>
<h2 id='isUnitless'>isUnitless - Test whether object is unitless</h2><span id='topic+isUnitless'></span>

<h3>Description</h3>

<p>Tests whether a 'units' object is actually 
unitless.  
Unitless objects, such as ratios, should be assigned
units of '[1]'.  Often they are, but  
sometimes unitless ratios are assigned units like '[m/m]'.
The <code>units</code> package should always convert '[m/m]' to 
'[1]', but it does not always. 
Sometimes units like '[m/m]' mess things up, so it is 
better to remove them before calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isUnitless(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isUnitless_+3A_obj">obj</code></td>
<td>
<p>A numeric scaler or vector, with or without units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if <code>obj</code> has units and they 
are either '[1]' or the denominator units equal
the numerator units.  Otherwise, return FALSE.
If <code>obj</code> does not have units, this routine
returns TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- units::set_units(2, "m")
b &lt;- a / a
isUnitless(a)
isUnitless(b)
isUnitless(3)

</code></pre>

<hr>
<h2 id='likeParamNames'>Likelihood parameter names</h2><span id='topic+likeParamNames'></span>

<h3>Description</h3>

<p>Returns names of the likelihood parameters. This is 
a helper function and is not
necessary for estimation.  It is a nice to label some 
outputs in <code>Rdistance</code> with 
parameter names like &quot;sigma&quot; or &quot;knee&quot;, depending on the likelihood, 
and this routine provides a way to do that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likeParamNames(like.form)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likeParamNames_+3A_like.form">like.form</code></td>
<td>
<p>A text string naming the form of the likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For user defined functions, ensure that the 
user defined start-limits function named &lt;likelihood&gt;.start.limits
can be evaluated on a distance of 1, can accept 0 expansions, 
a low limit of 0 
a high limit of 1, and that it returns the parameter names as 
the <code>$names</code> component of the result. That is, the 
code that returns user-defined parameter names is, 
<code>fn &lt;- match.fun( paste0(like.form, ".start.limits"));
ans &lt;- fn(1, 0, 0, 1);
ans$names</code>
</p>


<h3>Value</h3>

<p>A vector of parameter names for that likelihood
</p>

<hr>
<h2 id='lines.dfunc'>lines.dfunc - Lines method for distance (detection) functions</h2><span id='topic+lines.dfunc'></span>

<h3>Description</h3>

<p>Lines method for objects of class '<code>dfunc</code>'. Distance 
function line methods add distance functions to existing plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfunc'
lines(x, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.dfunc_+3A_x">x</code></td>
<td>
<p>An estimated distance function resulting from a call to
<code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="lines.dfunc_+3A_newdata">newdata</code></td>
<td>
<p>Data frame similar to the <code>newdata</code> parameter 
to <code><a href="stats.html#topic+lm">lm</a></code> containing new values for covariates in the distance function.
One distance function is computed and plotted for each row in the data frame. 
If <code>newdata</code> is NULL, the routine computes the mean of all numeric covariates
in the distance function and the mode of all factor covariates in 
the distance function. The new mean and mode vector is used to predict 
and plot a distance function.</p>
</td></tr>
<tr><td><code id="lines.dfunc_+3A_...">...</code></td>
<td>
<p>Parameters to <code>lines</code> used to control attributes like 
color, line width, line type, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the x and y coordinates of the 
plotted line(s) is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+plot.dfunc">plot.dfunc</a></code>,
<code><a href="#topic+print.abund">print.abund</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(87654)
x &lt;- rnorm(1000, mean=0, sd=20)
x &lt;- x[x &gt;= 0]
x &lt;- units::set_units(x, "mi")
dfunc &lt;- dfuncEstim(x~1, likelihood="halfnorm")
plot(dfunc, nbins = 40, col="lightgrey", border=NA, vertLines=FALSE)
lines(dfunc, col="grey", lwd=15)
lines(dfunc, col="black", lwd=5, lty = 2)

# Multiple lines 
data(sparrowDetectionData)
data(sparrowSiteData)
dfuncObs &lt;- dfuncEstim(formula = dist ~ observer 
                     , likelihood = "halfnorm"
                     , detectionData = sparrowDetectionData
                     , siteData = sparrowSiteData)
plot(dfuncObs
   , vertLines = FALSE
   , lty = 0
   , col = c("grey","lightgrey")
   , border=NA
   , main="Detection by observer"
   , legend = FALSE)
y &lt;- lines(dfuncObs
   , newdata = data.frame(observer = levels(sparrowSiteData$observer))
   , col = palette.colors(length(levels(sparrowSiteData$observer)))
   , lty = 1
   , lwd = 4)
head(y) # values returned, same as predict method

</code></pre>

<hr>
<h2 id='logistic.like'>logistic.like - Logistic distance function likelihood</h2><span id='topic+logistic.like'></span>

<h3>Description</h3>

<p>Computes a two parameter logistic distance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.like(
  a,
  dist,
  covars = NULL,
  w.lo = units::set_units(0, "m"),
  w.hi = max(dist),
  series = "cosine",
  expansions = 0,
  scale = TRUE,
  pointSurvey = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic.like_+3A_a">a</code></td>
<td>
<p>A vector of likelihood parameter values. Length and meaning 
depend on whether covariates and <code>expansions</code> are present as follows:
</p>

<ul>
<li><p> If no covariates and no expansions: <code>a</code> = [a, b] (see Details)
</p>
</li>
<li><p> If no covariates and <em>k</em> expansions: <code>a</code> = [a, b, e1, ..., e<em>k</em>] 
</p>
</li>
<li><p> If <em>p</em> covariates and no expansions: <code>a</code> = [a, b, b1, ..., b<em>p</em>] 
</p>
</li>
<li><p> If <em>p</em> covariates and <em>k</em> expansions: <code>a</code> = [a, b, b1, ..., b<em>p</em>, e1, ..., e<em>k</em>] 
</p>
</li></ul>
</td></tr>
<tr><td><code id="logistic.like_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing observed distances with measurement
units.</p>
</td></tr>
<tr><td><code id="logistic.like_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates at 
each observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="logistic.like_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance, with measurement
units.  
This is the <em>left truncation</em> sighting distance.  Values less than 
<code>w.lo</code> are allowed in <code>dist</code>, but are ignored and 
their likelihood value is set to
<code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="logistic.like_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance, with measurement
units.  
This is the <em>right truncation</em> sighting distance.
Values greater than <code>w.hi</code> are allowed in <code>dist</code>, 
but are ignored and their likelihood value is 
set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="logistic.like_+3A_series">series</code></td>
<td>
<p>A string specifying the type of expansion to 
use.  Currently, valid values are 'simple', 'hermite', and 
'cosine'; but, see <code><a href="#topic+dfuncEstim">dfuncEstim</a></code> about 
defining other series.</p>
</td></tr>
<tr><td><code id="logistic.like_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms 
in <code>series</code>. Depending on the series, this could be 0 through 5.
The default of 0 equates to no expansion terms of any type.</p>
</td></tr>
<tr><td><code id="logistic.like_+3A_scale">scale</code></td>
<td>
<p>Logical scalar indicating whether or not to scale 
the likelihood into a density function, i.e., so that it integrates 
to 1. This parameter is used 
to stop recursion in other functions.
If <code>scale</code> equals TRUE, a numerical integration 
routine (<code><a href="#topic+integration.constant">integration.constant</a></code>) is called, which 
in turn calls this likelihood function again
with <code>scale</code> = FALSE. Thus, this routine knows when its 
values are being used to compute the likelihood and when its 
values are being used to compute the constant of integration.  
All user defined likelihoods must have and use this parameter.</p>
</td></tr>
<tr><td><code id="logistic.like_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if <code>dist</code> is point 
transect data, FALSE if line transect data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'logistic' likelihood contains two 
parameters.  Parameter <code class="reqn">a</code> determines the scale and is 
labeled 'threshold' in Rdistance.  Parameter <code class="reqn">b</code> determines 
sharpness (slope) of the likelihood's decrease at <code class="reqn">a</code> and is labeled
'knee' in Rdistance.  
This function is sometimes called the 
<em>heavy side</em> function (e.g., engineering).  The technical form 
of the function is, 
</p>
<p style="text-align: center;"><code class="reqn">f(x|a,b) = 1 - \frac{1}{1 + \exp(-b(x-a))} = 
\frac{\exp( -b(x-a) )}{1 + exp( -b(x-a) )},</code>
</p>
 
<p>Parameter <code class="reqn">a</code> is the location (distance) of 
0.5. That is, the inverse likelihood of 0.5 
is <code class="reqn">a</code> before scaling 
(i.e., <code>logistic.like( c(a,b), a, scale=FALSE)</code> equals 
<code>0.5</code>). 
</p>
<p>Parameter <code class="reqn">b</code> is slope of function 
at <code class="reqn">a</code>.  
Prior to scaling, 
slope of the likelihood at <code class="reqn">a</code> is <code class="reqn">-b/4</code>. 
If <code class="reqn">b</code>
is large, the &quot;knee&quot; is sharp and the likelihood can look 
uniform with support from 
<code>w.lo</code> to <code class="reqn">a/f(0)</code>.  If <code class="reqn">b</code> is small, the 
&quot;knee&quot; is shallow and the density of observations declines 
in an elongated &quot;S&quot; shape pivoting at <code class="reqn">a/f(0)</code>.  
As <code class="reqn">b</code> grows large and assuming f(0) = 1, the effective 
strip width approaches <code class="reqn">a</code>.  
</p>
<p>See plots in Examples.
</p>


<h3>Value</h3>

<p>A numeric vector the same length and order as <code>dist</code> 
containing the likelihood contribution for corresponding distances 
in <code>dist</code>. 
Assuming <code>L</code> is the returned vector, 
the log likelihood of all data is <code>-sum(log(L), na.rm=T)</code>. 
Note that the returned likelihood value for distances less than 
<code>w.lo</code> or greater than <code>w.hi</code> is <code>NA</code>, and thus it is 
essential to use <code>na.rm=TRUE</code> in the sum. If <code>scale</code> = TRUE, 
the integral of the likelihood from <code>w.lo</code> to <code>w.hi</code> is 1.0. 
If <code>scale</code> = FALSE, the integral of the likelihood is
arbitrary.
</p>


<h3>Expansion Terms</h3>

<p>If <code>expansions</code> = k (k &gt; 0), the 
expansion function specified by <code>series</code> is called (see for example
<code><a href="#topic+cosine.expansion">cosine.expansion</a></code>). Assuming 
<code class="reqn">h_{ij}(x)</code> is the <code class="reqn">j^{th}</code> expansion term 
for the <code class="reqn">i^{th}</code> distance and that 
<code class="reqn">c_1, c_2, \dots, c_k</code> are (estimated) 
coefficients, the likelihood contribution 
for the <code class="reqn">i^{th}</code> distance is, 
</p>
<p style="text-align: center;"><code class="reqn">f(x|a,b,c_1,c_2,\dots,c_k) = f(x|a,b)(1 + 
\sum_{j=1}^{k} c_j h_{ij}(x)).</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>,
<code><a href="#topic+halfnorm.like">halfnorm.like</a></code>,
<code><a href="#topic+hazrate.like">hazrate.like</a></code>,
<code><a href="#topic+negexp.like">negexp.like</a></code>,
<code><a href="#topic+Gamma.like">Gamma.like</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- units::set_units(seq(0, 100, length=100), "m")

# Plots showing effects of changes in Threshold
plot(x, logistic.like(c(20, 20), x), type="l", col="red")
lines(x, logistic.like(c(40, 20), x), type="l", col="blue")

# Plots showing effects of changes in Knee
plot(x, logistic.like(c(50, 100), x), type="l", col="red")
lines(x, logistic.like(c(50, 1), x), type="l", col="blue")
lines(x, logistic.like(c(50, .1), x), type="l", col="orange")

         
</code></pre>

<hr>
<h2 id='logistic.start.limits'>logistic.start.limits - Start and limit values for logistic distance function</h2><span id='topic+logistic.start.limits'></span>

<h3>Description</h3>

<p>Starting values and limits for parameters of the logistic 
distance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.start.limits(dist, covars, expansions, w.lo, w.hi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic.start.limits_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing observed distances with measurement
units.</p>
</td></tr>
<tr><td><code id="logistic.start.limits_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates at 
each observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="logistic.start.limits_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms 
in <code>series</code>. Depending on the series, this could be 0 through 5.
The default of 0 equates to no expansion terms of any type.</p>
</td></tr>
<tr><td><code id="logistic.start.limits_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance, with measurement
units.  
This is the <em>left truncation</em> sighting distance.  Values less than 
<code>w.lo</code> are allowed in <code>dist</code>, but are ignored and 
their likelihood value is set to
<code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="logistic.start.limits_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance, with measurement
units.  
This is the <em>right truncation</em> sighting distance.
Values greater than <code>w.hi</code> are allowed in <code>dist</code>, 
but are ignored and their likelihood value is 
set to <code>NA</code> in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called within 
<code>F.start.limits</code>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li> <p><code>start</code> : a vector of starting values
</p>
</li>
<li> <p><code>lowlimit</code> : a vector of lower limits (can be -Inf)
</p>
</li>
<li> <p><code>highlimit</code> : a vector of upper limits (can be Inf)
</p>
</li>
<li> <p><code>nms</code> : a vector containing names of the parameters
</p>
</li></ul>


<hr>
<h2 id='negexp.like'>negexp.like - Negative exponential distance function</h2><span id='topic+negexp.like'></span>

<h3>Description</h3>

<p>Computes the negative exponential form of 
a distance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negexp.like(
  a,
  dist,
  covars = NULL,
  w.lo = units::set_units(0, "m"),
  w.hi = max(dist),
  series = "cosine",
  expansions = 0,
  scale = TRUE,
  pointSurvey = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negexp.like_+3A_a">a</code></td>
<td>
<p>A vector of likelihood parameter values. Length and 
meaning depend on <code>series</code> and <code>expansions</code>. If 
no expansion terms were called for
(i.e., <code>expansions = 0</code>), the distance likelihood 
contains only one canonical parameter, which 
is the first element of <code>a</code> (see Details). If one 
or more expansions are called for,
coefficients for the expansion terms follow 
coefficients for the canonical parameter.</p>
</td></tr>
<tr><td><code id="negexp.like_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing the observed distances.</p>
</td></tr>
<tr><td><code id="negexp.like_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates at each 
observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="negexp.like_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance.  This is the <em>left truncation</em> of sighting distances in <code>dist</code>. Same units as <code>dist</code>.
Values less than <code>w.lo</code> are allowed in <code>dist</code>, but are ignored and their contribution to the likelihood is set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="negexp.like_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance.  This is the <em>right truncation</em> of sighting distances in <code>dist</code>.  Same units as <code>dist</code>.
Values greater than <code>w.hi</code> are allowed in <code>dist</code>, but are ignored and their contribution to the likelihood is set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="negexp.like_+3A_series">series</code></td>
<td>
<p>A string specifying the type of expansion to use.  Currently, valid values are 'simple', 'hermite', and 'cosine'; but, see 
<code><a href="#topic+dfuncEstim">dfuncEstim</a></code> about defining other series.</p>
</td></tr>
<tr><td><code id="negexp.like_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms in <code>series</code>. Depending on the series, this could be 0 through 5.
The default of 0 equates to no expansion terms of any type.</p>
</td></tr>
<tr><td><code id="negexp.like_+3A_scale">scale</code></td>
<td>
<p>Logical scalar indicating whether or not to scale the likelihood so it integrates to 1. This parameter is used to stop recursion in other functions.
If <code>scale</code> equals TRUE, a numerical integration routine (<code><a href="#topic+integration.constant">integration.constant</a></code>) is called, which in turn calls this likelihood function again
with <code>scale</code> = FALSE. Thus, this routine knows when its values are being used to compute the likelihood and when its value is being used to compute the 
constant of integration.  All user defined likelihoods must have and use this parameter.</p>
</td></tr>
<tr><td><code id="negexp.like_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if <code>dist</code> is point transect data, FALSE if line transect data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The negative exponential likelihood is 
</p>
<p style="text-align: center;"><code class="reqn">f(x|a) = \exp(-ax)</code>
</p>
<p> where <code class="reqn">a</code> is a 
slope parameter to be estimated. 
</p>
<p><b>Expansion Terms</b>: If the number of <code>expansions</code> = k (k &gt; 0), the expansion 
function specified by <code>series</code> is called (see for example
<code><a href="#topic+cosine.expansion">cosine.expansion</a></code>). Assuming <code class="reqn">h_{ij}(x)</code> is 
the <code class="reqn">j^{th}</code> expansion term for the <code class="reqn">i^{th}</code> distance and that 
<code class="reqn">c_1, c_2, \dots, c_k</code>are (estimated) coefficients for the expansion terms, the likelihood contribution for the <code class="reqn">i^{th}</code> 
distance is, 
</p>
<p style="text-align: center;"><code class="reqn">f(x|a,b,c_1,c_2,\dots,c_k) = f(x|a,b)(1 + \sum_{j=1}^{k} c_j h_{ij}(x)).</code>
</p>



<h3>Value</h3>

<p>A numeric vector the same length and order as <code>dist</code> containing the likelihood contribution for corresponding distances in <code>dist</code>. 
Assuming <code>L</code> is the returned vector from one of these functions, the full log likelihood of all the data is <code>-sum(log(L), na.rm=T)</code>. Note that the
returned likelihood value for distances less than <code>w.lo</code> or greater than <code>w.hi</code> is <code>NA</code>, and thus it is prudent to use <code>na.rm=TRUE</code> in the
sum. If <code>scale</code> = TRUE, the integral of the likelihood from <code>w.lo</code> to <code>w.hi</code> is 1.0. If <code>scale</code> = FALSE, the integral of the likelihood is
arbitrary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>,
<code><a href="#topic+halfnorm.like">halfnorm.like</a></code>,
<code><a href="#topic+uniform.like">uniform.like</a></code>,
<code><a href="#topic+hazrate.like">hazrate.like</a></code>,
<code><a href="#topic+Gamma.like">Gamma.like</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(238642)
x &lt;- seq(0, 100, length=100)

# Plots showing effects of changes in parameter Beta
plot(x, negexp.like(0.01, x), type="l", col="red")
plot(x, negexp.like(0.05, x), type="l", col="blue")

# Estimate 'negexp' distance function
Beta &lt;- 0.01
x &lt;- rexp(1000, rate=Beta)
dfunc &lt;- dfuncEstim(x~1, likelihood="negexp")
plot(dfunc)

## End(Not run)
         
</code></pre>

<hr>
<h2 id='perpDists'>Compute off-transect distances from sighting distances and angles</h2><span id='topic+perpDists'></span>

<h3>Description</h3>

<p>Computes off-transect (also called 'perpendicular') distances from measures of sighting distance and sighting angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perpDists(sightDist, sightAngle, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perpDists_+3A_sightdist">sightDist</code></td>
<td>
<p>Character, name of column in <code>data</code> that contains the observed or sighting distances from the observer to the detected objects.</p>
</td></tr>
<tr><td><code id="perpDists_+3A_sightangle">sightAngle</code></td>
<td>
<p>Character, name of column in <code>data</code> that contains the observed or sighting angles from the line transect to the detected 
objects.  Angles must be measured in degrees.</p>
</td></tr>
<tr><td><code id="perpDists_+3A_data">data</code></td>
<td>
<p>data.frame object containing sighting distance and sighting angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If observers recorded sighting distance and sighting angle (as is often common in line transect surveys), use this function to convert 
to off-transect distances, the required input data for <code>F.dfunc.estim</code>.
</p>


<h3>Value</h3>

<p>A vector of off-transect (or perpendicular) distances.  Units are the same as <code>sightDist</code>.
</p>


<h3>References</h3>

<p>Buckland, S.T., Anderson, D.R., Burnham, K.P. and Laake, J.L. 1993. 
<em>Distance Sampling: Estimating Abundance of Biological Populations</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the example dataset of sparrow detections from package
data(sparrowDetectionData)
# Compute perpendicular, off-transect distances from the observer's sight distance and angle
sparrowDetectionData$perpDist &lt;- perpDists(sightDist="sightdist", sightAngle="sightangle",
                                           data=sparrowDetectionData)
</code></pre>

<hr>
<h2 id='plot.dfunc'>plot.dfunc - Plot method for distance (detection) functions</h2><span id='topic+plot.dfunc'></span>

<h3>Description</h3>

<p>Plot method for objects of class '<code>dfunc</code>'.  Objects of 
class '<code>dfunc</code>' are estimated distance functions produced by 
<code><a href="#topic+dfuncEstim">dfuncEstim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfunc'
plot(
  x,
  include.zero = FALSE,
  nbins = "Sturges",
  newdata = NULL,
  legend = TRUE,
  vertLines = TRUE,
  plotBars = TRUE,
  density = -1,
  angle = 45,
  xlab = NULL,
  ylab = NULL,
  border = TRUE,
  col = "grey85",
  col.dfunc = NULL,
  lty.dfunc = NULL,
  lwd.dfunc = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dfunc_+3A_x">x</code></td>
<td>
<p>An estimated distance function resulting from a call to
<code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_include.zero">include.zero</code></td>
<td>
<p>Boolean value specifying whether to include 0 on the x-axis 
of the plot.  A value of TRUE will include 0 on the left hand end of the x-axis
regardless of the range of distances.  A value of FALSE will plot only the
input distance range (<code>w.lo</code> to <code>w.hi</code>).</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_nbins">nbins</code></td>
<td>
<p>Internally, this function uses <code>hist</code> to compute histogram
bars for the plot. This argument is the <code>breaks</code> argument to
<code>hist</code>.  This can be either a vector giving the breakpoints between
bars, the suggested number of bars (a single number), a string naming
an algorithm to compute the number of bars, or a function to compute the
number of bars.  See <code><a href="graphics.html#topic+hist">hist</a></code> for all options.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_newdata">newdata</code></td>
<td>
<p>Data frame similar to the <code>newdata</code> parameter 
to <code><a href="stats.html#topic+lm">lm</a></code> containing new values for covariates in the distance function.
One distance function is computed and plotted for each row in the data frame. 
If <code>newdata</code> is NULL, the routine computes the mean of all numeric covariates
in the distance function and the mode of all factor covariates in 
the distance function. The new mean and mode vector is used to predict 
and plot a distance function.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_legend">legend</code></td>
<td>
<p>Logical scalar for whether to include a legend. 
If TRUE, a legend will be included on the plot detailing
the covariate values use to generate the plot.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_vertlines">vertLines</code></td>
<td>
<p>Logical scalar specifying whether to plot vertical 
lines at <code>w.lo</code> and <code>w.hi</code> from 0 to the  
distance function.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_plotbars">plotBars</code></td>
<td>
<p>Logical scalar for whether to plot the histogram 
of distances behind the distance function.  If FALSE, no histogram 
is plotted, only the distance function line(s).</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_density">density</code></td>
<td>
<p>If <code>plotBars=TRUE</code>, a vector giving the density of 
shading lines, in lines per inch, for the bars underneath 
the distance function, repeated as necessary to exceed the number 
of bars. Values of NULL or a number strictly less than 0 
mean solid fill using colors from parameter <code>col</code>. 
If <code>density = 0</code>, bars are not filled and only the borders are rendered. 
If <code>density</code> &gt;0, bars are shaded with colors and angles from 
parameters <code>col</code> and <code>angle</code>.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_angle">angle</code></td>
<td>
<p>When <code>density</code> is &gt;0, the slope of bar shading lines, 
given as an angle in degrees (counter-clockwise), repeated as necessary
to exceed the number of bars.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_border">border</code></td>
<td>
<p>The color of bar borders when bars are plotted, 
repeated as necessary to exceed the number of bars. A 
value of NA or FALSE means no borders. If bars are shaded with lines 
(i.e., <code>density&gt;0</code>), <code>border = TRUE</code> uses the same 
color for the border as for the shading lines.  Otherwise, fill color
or shaded line color are specified in <code>col</code> while 
border color is specified in <code>border</code>.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_col">col</code></td>
<td>
<p>A vector of bar fill colors or line colors when bars are 
drawn and <code>density != 0</code>, repeated as necessary to exceed the number
of bars. Also used for the bar borders when
<code>border = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_col.dfunc">col.dfunc</code></td>
<td>
<p>Color of the distance function(s).
If only one distance function (one line) is being plotted, 
the default color is &quot;red&quot;.
If covariates or <code>newdata</code> are present, 
the default value uses <code>graphics::rainbow(n)</code>, 
where <code>n</code> is the number 
of plotted distance functions.  Otherwise, <code>col.dfunc</code> 
is replicated to the required length.  Plot all 
distance functions in the same color by setting 
<code>col.dfunc</code> to
a scalar. Plot blue-red pairs of distance functions 
by setting <code>col.dfunc</code> = <code>c("blue", "red")</code>. Etc.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_lty.dfunc">lty.dfunc</code></td>
<td>
<p>Line type of the distance function(s).
If covariates or <code>newdata</code> is present, 
the default uses line types  
to <code>1:n</code>, where <code>n</code> is the number 
of plotted distance functions.  Otherwise, <code>lty.dfunc</code> 
is replicated to the required length. Plot solid lines
by specifying <code>lty.dfunc = 1</code>. Plot solid-dashed line pairs
by specifying <code>lty.dfunc = c(1,2)</code>. Etc.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_lwd.dfunc">lwd.dfunc</code></td>
<td>
<p>Line width of the distance function(s), replicated 
to the required length. Default is 2 for all lines.</p>
</td></tr>
<tr><td><code id="plot.dfunc_+3A_...">...</code></td>
<td>
<p>When bars are plotted, this routine 
uses <code>graphics::barplot</code> to set up the 
plotting region and plot bars. When bars are not plotted,
this routine sets up the plot with <code>graphics::plot</code>.
... can be any other 
argument to <code>barplot</code> or <code>plot</code> EXCEPT  
<code>width</code>, <code>ylim</code>, <code>xlim</code>, 
<code>density</code>, <code>angle</code>, and <code>space</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plotBars</code> is TRUE, a scaled histogram is plotted
and the estimated distance function
is plotted over the top of it.  When bars are plotted, 
this routine uses <code>graphics::barplot</code> 
for setting up the initial plotting region and
most parameters to <code>graphics::barplot</code> can 
be specified (exceptions noted above in description of '...').
</p>
<p>The form of the likelihood and any series
expansions is printed in the main title (overwrite this with 
<code>main="&lt;my title&gt;"</code>). Convergence of the distance
function is checked.  If the distance function did not converge, a warning
is printed over the top of the histogram.  If one or more parameter
estimates are at their limits (likely indicating non-convergence or poor
fit), another warning is printed.
</p>


<h3>Value</h3>

<p>The input distance function is returned, with two additional
components than can be used to reconstruct the plotted bars.  To 
obtain values of the plotted distance functions, use <code>predict</code>
with <code>type = "distances"</code>. 
The additional components are:
</p>
<table>
<tr><td><code>barHeights</code></td>
<td>
<p>A vector containing the scaled bar heights drawn 
on the plot.</p>
</td></tr>
<tr><td><code>barWidths</code></td>
<td>
<p>A vector or scaler of the bar widths drawn on 
the plot, with measurement units.  </p>
</td></tr>
</table>
<p>Re-plot the bars with <code>barplot( return$barHeights, 
  width = return$barWidths )</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+print.dfunc">print.dfunc</a></code>,
<code><a href="#topic+print.abund">print.abund</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(87654)
x &lt;- rnorm(1000, mean=0, sd=20)
x &lt;- x[x &gt;= 0]
x &lt;- units::set_units(x, "ft")
dfunc &lt;- dfuncEstim(x~1, likelihood="halfnorm")
plot(dfunc)
plot(dfunc, nbins=25)

# showing effects of plot params
plot(dfunc
  , col=c("red","blue","orange")
  , border="black"
  , xlab="Off-transect distance"
  , ylab="Prob"
  , vertLines = FALSE
  , main="Showing plot params")
 
plot(dfunc
   , col="wheat"
   , density=30
   , angle=c(-45,0,45)
   , cex.axis=1.5
   , cex.lab=2
   , ylab="Probability") 

plot(dfunc
   , col=c("grey","lightgrey")
   , border=NA) 

plot(dfunc
   , col="grey"
   , border=0
   , col.dfunc="blue"
   , lty.dfunc=2
   , lwd.dfunc=4
   , vertLines=FALSE)

plot(dfunc
   , plotBars=FALSE
   , cex.axis=1.5
   , col.axis="blue")
rug(dfunc$detections$dist)

# Plot showing f(0)
hist(dfunc$detections$dist
   , n = 40
   , border = NA
   , prob = TRUE)
x &lt;- seq(dfunc$w.lo, dfunc$w.hi, length=200)
y &lt;- predict(dfunc, type="dfunc", distances = x)
lines(x, c(y)/attr(y, "scaler"))
c(attr(y,"scaler") / y[1], ESW(dfunc))  # 1/f(0) = ESW

# Covariates: detection by observer
data(sparrowDetectionData)
data(sparrowSiteData)
dfuncObs &lt;- dfuncEstim(formula = dist ~ observer + groupsize(groupsize)
                     , likelihood = "hazrate"
                     , detectionData = sparrowDetectionData
                     , siteData = sparrowSiteData)
plot(dfuncObs
   , newdata = data.frame(observer = levels(sparrowSiteData$observer))
   , vertLines = FALSE
   , lty = c(1,1)
   , col.dfunc = heat.colors(length(levels(sparrowSiteData$observer)))
   , col = c("grey","lightgrey")
   , border=NA
   , main="Detection by observer")

</code></pre>

<hr>
<h2 id='predict.dfunc'>Predict method for dfunc objects</h2><span id='topic+predict.dfunc'></span>

<h3>Description</h3>

<p>Predict likelihood parameters for distance function objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfunc'
predict(object, newdata = NULL, type = c("parameters"), distances = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dfunc_+3A_object">object</code></td>
<td>
<p>An estimated dfunc object.  See <code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="predict.dfunc_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing new values of 
the covariates at which predictions are to be computed. If <code>newdata</code>
is NULL, predictions are made at values of the observed
covariates and results in one prediction (either parameters or 
distance function, see parameter <code>type</code>) for every observed distance. 
If <code>newdata</code> is not NULL and the model does not contains covariates, 
this routine returns one prediction (either parameters or 
distance function) for each row in <code>newdata</code>, but 
columns and values in <code>newdata</code> are ignored.</p>
</td></tr>
<tr><td><code id="predict.dfunc_+3A_type">type</code></td>
<td>
<p>The type of predictions desired. 
</p>

<ul>
<li> <p><b>If <code>type</code> = &quot;parameters&quot;</b>: Return 
predicted parameters of the likelihood function, one value for each observation
(row) in <code>newdata</code>.  If <code>newdata</code> is NULL, return one predicted parameter
value for every detection in <code>object$detections</code>.
</p>
</li>
<li> <p><b>If <code>type</code> is not &quot;parameters&quot;</b>: Return  
scaled distance functions. Distance functions are evaluated at the distances   
specified in <code>distances</code>. The number of distance functions returned 
depends on <code>newdata</code> and whether <code>object</code> contains covariates:
</p>

<ul>
<li><p> If <code>object</code> does NOT contain covariates, the distance 
function does not vary (by covariate) and only one distance function
will be returned, even if <code>newdata</code> is specified.
</p>
</li>
<li><p> If <code>object</code> contains covariates, one distance function 
will be returned for each observation (row) in <code>newdata</code>. 
If <code>newdata</code> is NULL, one distance function will be returned 
for every detection in <code>object$detections</code>. 
</p>
</li></ul>

</li></ul>

<p>If <code>object</code> is a smoothed distance function, it does not have parameters
and this routine will always return a scaled distance function. That is, 
<code>type</code> = &quot;parameters&quot; when <code>object</code> is smoothed 
does not make sense and the smoothed distance function estimate will be returned.</p>
</td></tr>
<tr><td><code id="predict.dfunc_+3A_distances">distances</code></td>
<td>
<p>A vector of distances when distance functions 
are requested.  <code>distances</code> must have measurement units. 
Any distances outside the observation 
strip (<code>object$w.lo</code> to <code>object$w.hi</code>) are discarded.  If 
<code>distances</code> is NULL, this routine uses a sequence of 200 evenly 
spaced distances between 
<code>object$w.lo</code> and <code>object$w.hi</code>, inclusive</p>
</td></tr>
<tr><td><code id="predict.dfunc_+3A_...">...</code></td>
<td>
<p>Included for compatibility with generic <code>predict</code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing one of two types of predictions: 
</p>

<ul>
<li> <p><b>If <code>type</code> is &quot;parameters&quot;</b>, the returned matrix 
contains predicted likelihood parameters. The extent of the first dimension (rows) in 
the returned matrix is equal to either the number of detection distances 
in <code>object$detections</code> 
or number of rows in <code>newdata</code>. 
The returned matrix's second dimension (columns) is 
the number of parameters in the likelihood 
plus the number of expansion terms.  Without expansion terms, the number 
of columns in the returned matrix 
is either 1 or 2 depending on the likelihood (e.g., <code>halfnorm</code> has 
one parameter, <code>hazrate</code> has two). See the help 
for each likelihoods to interpret the returned parameter values.
</p>
</li>
<li> <p><b>If <code>type</code> is not &quot;parameters&quot;</b>, the returned matrix 
contains scaled distance functions.  The extent of the first 
dimension (rows) is either the number of distances specified in <code>distance</code>
or 200 if <code>distances</code> is not specified.
The extent of the second dimension (columns) is: 
</p>

<ul>
<li><p> 1: if <code>object</code> does NOT contain covariates.
</p>
</li>
<li><p> the number of detections: if <code>object</code> contains covariates and <code>newdata</code> is NULL.
</p>
</li>
<li><p> the number of rows in <code>newdata</code>: if <code>object</code> contains covariates 
and <code>newdata</code> is specified.
</p>
</li></ul>

<p>All distance functions in columns of the return are scaled 
to <code>object$g.x.scale</code> at <code>object$x.scl</code>.
</p>
<p>When <code>type</code> is not &quot;parameters&quot;, the returned matrix has 
additional attributes containing the distances 
at which the functions are scaled and ESW's.  
<code>attr(return, "x0")</code> is the vector of distances at which each 
distance function in <code>&lt;return&gt;</code> is scaled. i.e., the vector of 
<code>x.scl</code>.
<code>attr(return, "scaler")</code> is a vector scaling factors  
corresponding to each 
distance function in <code>return</code>. i.e., the vector of 
<code>1/f(x.scl)</code> where <code>f()</code> is the unscaled distance function. 
If <code>object</code> contains line transects, <code>attr(return, "scaler")</code>
is a vector of ESW corresponding to each distance function.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+halfnorm.like">halfnorm.like</a></code>, <code><a href="#topic+negexp.like">negexp.like</a></code>, 
<code><a href="#topic+uniform.like">uniform.like</a></code>, <code><a href="#topic+hazrate.like">hazrate.like</a></code>, <code><a href="#topic+Gamma.like">Gamma.like</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sparrowDetectionData)
data(sparrowSiteData)
# No covariates
dfuncObs &lt;- dfuncEstim(formula = dist ~ 1
                     , detectionData = sparrowDetectionData
                     , w.hi = units::as_units(100, "m"))
predict(dfuncObs)
# values in newdata ignored because no covariates
predict(dfuncObs, newdata = data.frame(x = 1:5)) 

predict(dfuncObs, type = "dfunc") # one function

d &lt;- units::set_units(c(0, 20, 40), "ft")
predict(dfuncObs, distances = d, type = "dfunc") 

# Covariates
dfuncObs &lt;- dfuncEstim(formula = dist ~ observer
                     , detectionData = sparrowDetectionData
                     , siteData = sparrowSiteData
                     , w.hi = units::as_units(100, "m"))
predict(dfuncObs)  # 356 X 1

Observers &lt;- data.frame(observer = levels(sparrowSiteData$observer))
predict(dfuncObs, newdata = Observers) # 5 X 1

predict(dfuncObs, type = "dfunc") # 200 X 356
predict(dfuncObs, newdata = Observers, type = "dfunc") # 200 X 5
predict(dfuncObs, newdata = Observers, distances = d, type = "dfunc") # 3 X 5

</code></pre>

<hr>
<h2 id='print.abund'>Print abundance estimates</h2><span id='topic+print.abund'></span>

<h3>Description</h3>

<p>Print an object of class <code>c("abund","dfunc")</code> 
that is output by <code>abundEstim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'abund'
print(
  x,
  criterion = "AICc",
  maxBSFailPropForWarning = RdistanceControls()$maxBSFailPropForWarning,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.abund_+3A_x">x</code></td>
<td>
<p>An object output by <code>abundEstim</code>.  This is a distance function object that 
also contains abundance estimates, and has class <code>c("abund", "dfunc")</code>.</p>
</td></tr>
<tr><td><code id="print.abund_+3A_criterion">criterion</code></td>
<td>
<p>A string specifying the criterion to print.
Must be one of &quot;AICc&quot; (the default), 
&quot;AIC&quot;, or &quot;BIC&quot;.  See <code><a href="#topic+AIC.dfunc">AIC.dfunc</a></code> for formulas.</p>
</td></tr>
<tr><td><code id="print.abund_+3A_maxbsfailpropforwarning">maxBSFailPropForWarning</code></td>
<td>
<p>The proportion of bootstrap 
iterations that can fail without a warning. If the proportion 
of bootstrap iterations that did not converge exceeds this 
parameter, a warning about the validity of CI's is issued and 
a diagnostic message printed.  Increasing this to a number greater 
than 1 will kill the warning, but ignoring a large number of non-convergent
bootstrap iterations may be a bad idea (i.e., validity of the CI is 
questionable).</p>
</td></tr>
<tr><td><code id="print.abund_+3A_...">...</code></td>
<td>
<p>Included for compatibility to other print methods.
Ignored here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default print method for class 'dfunc' is called, then the abundance estimates 
contained in <code>obj</code> are printed.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+abundEstim">abundEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example sparrow data (line transect survey type)
data(sparrowDetectionData)
data(sparrowSiteData)

# Fit half-normal detection function
dfunc &lt;- dfuncEstim(formula=dist ~ 1 + offset(groupsize)
                  , detectionData=sparrowDetectionData)

# Estimate abundance given a detection function
# Note: a person should do more than R=20 bootstrap iterations
fit &lt;- abundEstim(dfunc
                , detectionData = sparrowDetectionData
                , siteData = sparrowSiteData
                , area = units::set_units(4105, "km^2")
                , R=20
                , ci=0.95)

# Print results
print(fit)

</code></pre>

<hr>
<h2 id='print.dfunc'>Print a distance function object</h2><span id='topic+print.dfunc'></span>

<h3>Description</h3>

<p>Print method for distance functions produced by <code>dfuncEstim</code>,
which are of class <code>dfunc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfunc'
print(x, criterion = "AICc", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dfunc_+3A_x">x</code></td>
<td>
<p>An estimated distance function resulting from a call to <code>dfuncEstim</code>.</p>
</td></tr>
<tr><td><code id="print.dfunc_+3A_criterion">criterion</code></td>
<td>
<p>A string specifying the criterion to print.
Must be one of &quot;AICc&quot; (the default), 
&quot;AIC&quot;, or &quot;BIC&quot;.  See <code><a href="#topic+AIC.dfunc">AIC.dfunc</a></code> for formulas.</p>
</td></tr>
<tr><td><code id="print.dfunc_+3A_...">...</code></td>
<td>
<p>Included for compatibility with other print methods.  Ignored here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call, coefficients of the distanced function, whether the estimation converged, 
the likelihood and expansion function, and other statistics are printed.  At the bottom
of the output, the following quantities are printed,
</p>
  
<ul>
<li> <p>&lsquo;<span class="samp">&#8288;Strip&#8288;</span>&rsquo; : The left (<code>w.lo</code>) and right (<code>w.hi</code>) truncation values.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;Effective strip width or detection radius&#8288;</span>&rsquo; : ESW or EDR as computed by <code>effectiveDistance</code>.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;Scaling&#8288;</span>&rsquo; : The horizontal and vertical coordinates used to scale the distance function. 
Usually, the horizontal coordinate is 0 and the vertical coordinate is 1 (i.e., g(0) = 1).
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;Log likelihood&#8288;</span>&rsquo; : Value of the maximized log likelihood.
</p>
</li>
<li> <p>&lsquo;<span class="samp">&#8288;Criterion&#8288;</span>&rsquo; : Value of the specified fit criterion (AIC, AICc, or BIC).
</p>
</li></ul>

<p>The number of digits printed is controlled by <code>options()$digits</code>.
</p>


<h3>Value</h3>

<p>The input value of <code>obj</code> is invisibly returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+plot.dfunc">plot.dfunc</a></code>, <code><a href="#topic+print.abund">print.abund</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example sparrow data (line transect survey type)
data(sparrowDetectionData)

# Fit half-normal detection function
dfunc &lt;- dfuncEstim(formula=dist~1,
                    detectionData=sparrowDetectionData)

# Print results
dfunc
print(dfunc, criterion="BIC")

</code></pre>

<hr>
<h2 id='RdistanceControls'>Control parameters for <code>Rdistance</code> optimization.</h2><span id='topic+RdistanceControls'></span>

<h3>Description</h3>

<p>Returns a list of optimization controls used in 
<code>Rdistance</code> and provides a way to change them if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RdistanceControls(
  optimizer = "nlminb",
  evalMax = 2000,
  maxIters = 1000,
  likeTol = 1e-08,
  coefTol = 1.5e-08,
  hessEps = 1e-08,
  requireUnits = TRUE,
  maxBSFailPropForWarning = 0.2,
  contrasts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RdistanceControls_+3A_optimizer">optimizer</code></td>
<td>
<p>A string specifying the optimizer 
to use.  Results
vary between optimizers, so switching algorithms sometimes 
makes a poorly behaved distance function converge.  The valid 
values are &quot;optim&quot; which uses <code>optim::optim</code>,
and &quot;nlminb&quot; which uses <code>stats:nlminb</code>.  The authors 
have had better luck with &quot;nlminb&quot; than &quot;optim&quot; and &quot;nlminb&quot; 
runs noticeably faster.  Problems with solutions near parameter 
boundaries may require use of &quot;optim&quot;.</p>
</td></tr>
<tr><td><code id="RdistanceControls_+3A_evalmax">evalMax</code></td>
<td>
<p>The maximum number of objective function
evaluations allowed.</p>
</td></tr>
<tr><td><code id="RdistanceControls_+3A_maxiters">maxIters</code></td>
<td>
<p>The maximum number of optimization 
iterations allowed.</p>
</td></tr>
<tr><td><code id="RdistanceControls_+3A_liketol">likeTol</code></td>
<td>
<p>The maximum change in the likelihood 
(the objective) between
iterations that is tolerated during optimization.  
If the likelihood changes by less than this amount, 
optimization stops and a solution is declared.</p>
</td></tr>
<tr><td><code id="RdistanceControls_+3A_coeftol">coefTol</code></td>
<td>
<p>The maximum change in the model coefficients 
between
iterations that is tolerated during optimization.  
If the sum of squared coefficient differences changes 
by less than this amount between iterations, 
optimization stops and a solution is declared.</p>
</td></tr>
<tr><td><code id="RdistanceControls_+3A_hesseps">hessEps</code></td>
<td>
<p>A vector of parameter distances used during 
computation of numeric second derivatives. Should have length 
1 or the number of parameters in the model. See function 
<code><a href="#topic+secondDeriv">secondDeriv</a></code>.</p>
</td></tr>
<tr><td><code id="RdistanceControls_+3A_requireunits">requireUnits</code></td>
<td>
<p>A logical specifying whether measurement 
units are required on distances and areas.  If TRUE, 
measurement units are required on off-transect and radial 
distances in the input data frame.  Likewise, measurement 
units are required on transect length and study area size. 
Assign units with statement like <code>units(detectionDf$dist) &lt;- "m"</code>
or <code>units(df$transectDf) &lt;- "km"</code>.  Measurement units do not 
need to be the same.  All units are converted appropriately during 
internal computations.  <code>Rdistance</code> recognizes 
units listed in <code>units::valid_udunits()</code>.</p>
</td></tr>
<tr><td><code id="RdistanceControls_+3A_maxbsfailpropforwarning">maxBSFailPropForWarning</code></td>
<td>
<p>The proportion of bootstrap 
iterations that can fail without a warning. If the proportion 
of bootstrap iterations that did not converge exceeds this 
parameter, a warning about the validity of CI's is issued in 
the print method for
abundance objects.</p>
</td></tr>
<tr><td><code id="RdistanceControls_+3A_contrasts">contrasts</code></td>
<td>
<p>A list, whose entries are values 
(numeric matrices, functions or character strings naming functions) 
to be used as replacement values for the default contrasts function 
and whose names are the names of columns of data containing factors.
</p>
<p>There are several ways to change the contrasts used for factors 
in Rdistance because all methods used in linear models (<code>lm</code>)
work.  To summarize contrast methods in R, if this parameter is NULL, Rdistance uses 
the global contrasts specified in 
<code>options()</code>.  To change the global contrasts, use a statement
like <code>options(contrasts = c(unordered = "contr.SAS", 
ordered = "contr.poly"))</code>.
One can also set contrasts for a factor using <code>contrasts(a)</code> 
(e.g., <code>contrasts(a) &lt;- "contr.sum"</code>) 
Lastly, one can set this parameter to a  
list that explicitely states the non-global contrasts to use for 
which factors in 
the Rdistance model.  For example, <code>list(a = "contr.helmert")</code> 
will use Helmert contrasts for <code>a</code> 
and the global contrast option for all other factors. The 
built-in R contrast functions are &quot;contr.treatment&quot;, &quot;contr.helmert&quot;, 
&quot;contr.SAS&quot;, &quot;contr.sum&quot;, and &quot;contr.poly&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing named components for each of the 
controls.  This list has the same components as this function 
has input parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># increase number of iterations
RdistanceControls(maxIters=2000)

# change optimizer and decrease tolerance
RdistanceControls(optimizer="optim", likeTol=1e-6) 

</code></pre>

<hr>
<h2 id='secondDeriv'>Numeric second derivatives</h2><span id='topic+secondDeriv'></span>

<h3>Description</h3>

<p>Computes numeric second derivatives (hessian) of an 
arbitrary multidimensional function at a particular location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secondDeriv(x, FUN, eps = 1e-08, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secondDeriv_+3A_x">x</code></td>
<td>
<p>The location (a vector) where the second derivatives 
of <code>FUN</code> are desired.</p>
</td></tr>
<tr><td><code id="secondDeriv_+3A_fun">FUN</code></td>
<td>
<p>An R function for which the second derivatives are 
sought.  
This must be a function of the form FUN &lt;- function(x, ...)...
where x is a vector of variable parameters to FUN at which 
to evaluate the 2nd derivative, 
and ... are additional parameters needed to evaluate the function.
FUN must return a single value (scalar), the height of the 
surface above <code>x</code>, i.e., FUN evaluated at x.</p>
</td></tr>
<tr><td><code id="secondDeriv_+3A_eps">eps</code></td>
<td>
<p>A vector of small relative 
distances to add to <code>x</code> 
when evaluating derivatives.   This determines the '<code class="reqn">dx</code>' of 
the numerical derivatives.  That is, the function 
is evaluated at <code>x</code>, <code>x+dx</code>, and <code>x+2*dx</code>, where 
<code class="reqn">dx</code> = <code>x*eps^0.25</code>, in order to compute the second 
derivative. 
<code>eps</code> defaults to 1e-8 for all 
dimensions which equates to setting <code class="reqn">dx</code> to one percent
of each <code>x</code> (i.e., by default the function is 
evaluate at <code>x</code>, <code>1.01*x</code> and <code>1.02*x</code> 
to compute the second derivative).  
</p>
<p>One might want to change <code>eps</code> if the scale 
of dimensions in <code>x</code> varies wildly (e.g., kilometers and millimeters), 
or if changes between 
<code>FUN(x)</code> and <code>FUN(x*1.01)</code> are below machine precision.
If length of <code>eps</code> is less than length of <code>x</code>,
<code>eps</code> is replicated to the length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="secondDeriv_+3A_...">...</code></td>
<td>
<p>Any arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the &quot;5-point&quot; numeric second derivative 
method advocated in numerous numerical recipe texts.  During computation
of the 2nd derivative, FUN must be 
capable of being evaluated at numerous locations within a hyper-ellipsoid 
with cardinal radii 2*<code>x</code>*(<code>eps</code>)^0.25 = 0.02*<code>x</code> at the 
default value of <code>eps</code>.   
</p>
<p>A handy way to use this function is to call an optimization routine 
like <code>nlminb</code> with FUN, then call this function with the 
optimized values (solution) and FUN.  This will yield the hessian 
at the solution and this is can produce a better 
estimate of the variance-covariance
matrix than using the hessian returned by some optimization routines. 
Some optimization routines return the hessian evaluated 
at the next-to-last step of optimization. 
</p>
<p>An estimate of the variance-covariance matrix, which is used in 
<code>Rdistance</code>, is <code>solve(hessian)</code> where <code>hessian</code> is
<code>secondDeriv(&lt;parameter estimates&gt;, &lt;likelihood&gt;)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
func &lt;- function(x){-x*x} # second derivative should be -2
secondDeriv(0,func)
secondDeriv(3,func)

func &lt;- function(x){3 + 5*x^2 + 2*x^3} # second derivative should be 10+12x
secondDeriv(0,func)
secondDeriv(2,func)

func &lt;- function(x){x[1]^2 + 5*x[2]^2} # should be rbind(c(2,0),c(0,10))
secondDeriv(c(1,1),func)

</code></pre>

<hr>
<h2 id='simple.expansion'>Calculate simple polynomial expansion for detection function likelihoods</h2><span id='topic+simple.expansion'></span>

<h3>Description</h3>

<p>Computes simple polynomial expansion terms used in the likelihood of a distance analysis. More generally, will compute
polynomial expansions of any numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple.expansion(x, expansions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple.expansion_+3A_x">x</code></td>
<td>
<p>In a distance analysis, <code>x</code> is a numeric vector of the proportion of a strip transect's half-width 
at which a group of individuals were sighted.  If <code class="reqn">w</code> is the strip transect half-width or maximum sighting 
distance, and <code class="reqn">d</code> is the perpendicular off-transect distance to a sighted group (<code class="reqn">d\leq w</code>), 
<code>x</code> is usually <code class="reqn">d/w</code>.  More generally, <code>x</code> is a vector of numeric values</p>
</td></tr>
<tr><td><code id="simple.expansion_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of expansion terms to compute. Must be one of the integers 1, 2, 3, or 4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The polynomials computed here are:
</p>

<ul>
<li> <p><b>First term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_1(x)=x^4,</code>
</p>

</li>
<li> <p><b>Second term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_2(x)=x^6,</code>
</p>

</li>
<li> <p><b>Third term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_3(x)=x^8,</code>
</p>

</li>
<li> <p><b>Fourth term</b>: </p>
<p style="text-align: center;"><code class="reqn">h_4(x)=x^10,</code>
</p>

</li></ul>

<p>The maximum number of expansion terms computed is 4.
</p>


<h3>Value</h3>

<p>A matrix of size <code>length(x)</code> X <code>expansions</code>.  The columns of this matrix are the Hermite polynomial expansions of <code>x</code>. 
Column 1 is the first expansion term of <code>x</code>, column 2 is the second expansion term of <code>x</code>, and so on up to <code>expansions</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncEstim">dfuncEstim</a></code>, <code><a href="#topic+cosine.expansion">cosine.expansion</a></code>, <code><a href="#topic+hermite.expansion">hermite.expansion</a></code>, and the discussion 
of user defined likelihoods in <code><a href="#topic+dfuncEstim">dfuncEstim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(883839)
  x &lt;- rnorm(1000) * 100
  x &lt;- x[ 0 &lt; x &amp; x &lt; 100 ]
  simp.expn &lt;- simple.expansion(x, 4)
</code></pre>

<hr>
<h2 id='smu.like'>Smoothed likelihood function for distance analyses</h2><span id='topic+smu.like'></span>

<h3>Description</h3>

<p>Computes the likelihood of 
sighting distances given 
a kernel smooth of the histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smu.like(
  a,
  dist,
  covars = NULL,
  w.lo = 0,
  w.hi,
  scale = TRUE,
  series = NULL,
  expansions = 0,
  pointSurvey = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smu.like_+3A_a">a</code></td>
<td>
<p>A data frame containing the smooth.  This data frame 
must contain at least an <code>$x</code> and <code>$y</code> components. 
These components are generally the output 
of function <code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
<tr><td><code id="smu.like_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing the observed distances.</p>
</td></tr>
<tr><td><code id="smu.like_+3A_covars">covars</code></td>
<td>
<p>Not used in smoothed distance functions.
Included for compatibility with other distance likelihoods
in <code>Rdistance</code>.</p>
</td></tr>
<tr><td><code id="smu.like_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance.
This is the <em>left truncation</em> of sighting distances 
in <code>dist</code>. Same units as <code>dist</code>. Values less than 
<code>w.lo</code> are allowed in <code>dist</code>, but are ignored and 
their contribution to the likelihood is set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="smu.like_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance.
This is the <em>right truncation</em> of sighting distances 
in <code>dist</code>.  Same units as <code>dist</code>. Values greater 
than <code>w.hi</code> are allowed in <code>dist</code>, but are ignored 
and their contribution to the likelihood is set to <code>NA</code> 
in the output.</p>
</td></tr>
<tr><td><code id="smu.like_+3A_scale">scale</code></td>
<td>
<p>Logical scalar indicating whether or not to 
scale the likelihood so it integrates to 1. This parameter is 
used to stop recursion in other functions. If <code>scale</code> 
equals TRUE, a numerical integration routine 
(<code><a href="#topic+integration.constant">integration.constant</a></code>) is called, which in turn 
calls this likelihood function again with <code>scale</code> = FALSE. 
Thus, this routine knows when its values are being used to compute 
the likelihood and when its value is being used to compute the 
constant of integration.  All user defined likelihoods must have 
and use this parameter.</p>
</td></tr>
<tr><td><code id="smu.like_+3A_series">series</code></td>
<td>
<p>Not used in smoothed distance functions.
Included for compatibility with other distance likelihoods
in <code>Rdistance</code>.</p>
</td></tr>
<tr><td><code id="smu.like_+3A_expansions">expansions</code></td>
<td>
<p>Not used in smoothed distance functions.
Included for compatibility with other distance likelihoods
in <code>Rdistance</code>.</p>
</td></tr>
<tr><td><code id="smu.like_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if distances in <code>dist</code> are 
radial from point 
transects, FALSE if distances are perpendicular off-transect distances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="stats.html#topic+approx">approx</a></code> function is used to evaluate 
the smooth function at all sighting distances.  
</p>
<p>Distances outside the range <code>w.lo</code> to <code>w.hi</code> are 
set to <code>NA</code> and hence not included.
</p>


<h3>Value</h3>

<p>A numeric vector the same length and order 
as <code>dist</code> containing the 
likelihood contribution (height of the smoothed function) for 
all distances in <code>dist</code>. 
Assuming <code>L</code> is the vector returned by this function, 
the negative log likelihood of the sighting distances 
is <code>-sum(log(L), na.rm=T)</code>. 
Note that the returned likelihood value for distances less 
than <code>w.lo</code> or greater than <code>w.hi</code> is <code>NA</code>, 
hence <code>na.rm=TRUE</code> in the sum. 
If <code>scale</code> = TRUE, the area under the smoothed curve 
between <code>w.lo</code> and <code>w.hi</code> is 1.0. If <code>scale</code> = FALSE, 
the integral of the smoothed curve is something else.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfuncSmu">dfuncSmu</a></code>,
<code><a href="#topic+hazrate.like">hazrate.like</a></code>,
<code><a href="#topic+uniform.like">uniform.like</a></code>,
<code><a href="#topic+negexp.like">negexp.like</a></code>,
<code><a href="#topic+halfnorm.like">halfnorm.like</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
set.seed(238642)
d &lt;- units::set_units(abs(rnorm(100)), "in")
dfunc &lt;- dfuncSmu(d~1)

L &lt;- smu.like(a=dfunc$parameters, 
       dist=dfunc$detections$dist, 
       w.lo=dfunc$w.lo, 
       w.hi=dfunc$w.hi, 
       scale=TRUE)
-sum(log(L), na.rm=TRUE)  # the negative log likelihood

</code></pre>

<hr>
<h2 id='sparrowDetectionData'>Brewer's Sparrow detection data</h2><span id='topic+sparrowDetectionData'></span>

<h3>Description</h3>

<p>Detection data from line transect surveys for 
Brewer's sparrow on 72 transects 
located on a 4105 km^2 study 
area in central Wyoming. Data were collected by 
Dr. Jason Carlisle of the Wyoming Cooperative Fish &amp; Wildlife
Research Unit in 2012. Each transect was 500 meters long.
See the package vignettes for tutorials of the basic analysis.
</p>


<h3>Format</h3>

<p>A data.frame containing 356 rows and 5 columns.  Each row represents
a detected group of sparrows.  Column descriptions: 
</p>
 
<ol>
<li> <p><code>siteID</code>: Factor (72 levels), the site or transect where the detection
was made.  
</p>
</li>
<li> <p><code>groupsize</code>: Number, the number of individuals within
the detected group.  
</p>
</li>
<li> <p><code>sightdist</code>: Number, distance (m) from the observer to the detected group.  
</p>
</li>
<li> <p><code>sightangle</code>: Number, the angle (degrees) from the transect 
line to the detected group.  
</p>
</li>
<li> <p><code>dist</code>: Number, the perpendicular, off-transect distance (m) from the
transect to the detected group.  This is the distance used in analysis.
Calculated using <code><a href="#topic+perpDists">perpDists</a></code>.  </p>
</li></ol>



<h3>Source</h3>

<p>The Brewer's sparrow data are a subset of the data collected 
by Jason Carlisle and various field technicians for his Ph.D. from the 
Department of Ecology, University of Wyoming, in 2017.  This portion of 
Jason's work was funded by the Wyoming Game and Fish Department through agreements 
with the University of Wyoming's  Cooperative Fish &amp; Wildlife
Research Unit (2012).
</p>


<h3>References</h3>

<p>Carlisle, J.D. 2017. The effect of sage-grouse conservation on
wildlife species of concern: implications for the umbrella species concept.
Dissertation. University of Wyoming, Laramie, Wyoming, USA.
</p>
<p>Carlisle, J. D., and A. D. Chalfoun. 2020. The abundance of Greater 
Sage-Grouse as a proxy for the abundance of sagebrush-associated songbirds 
in Wyoming, USA. <em>Avian Conservation and Ecology</em> 15(2):16. 
<a href="https://doi.org/10.5751/ACE-01702-150216">doi:10.5751/ACE-01702-150216</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparrowSiteData">sparrowSiteData</a></code>
</p>

<hr>
<h2 id='sparrowSiteData'>Brewer's Sparrow site data</h2><span id='topic+sparrowSiteData'></span>

<h3>Description</h3>

<p>Site data from line transect surveys for 
Brewer's sparrow on 72 transects 
located on a 4105 km^2 study 
area in central Wyoming. Data were collected by 
Dr. Jason Carlisle of the Wyoming Cooperative Fish &amp; Wildlife
Research Unit in 2012. Each transect was 500 meters long.
See the package vignettes for tutorials of the basic analysis.
</p>


<h3>Format</h3>

<p>A data.frame containing 72 rows and 8 columns.  Each row represents
a site (transect) surveyed.  Column descriptions: 
</p>
 
<ol>
<li> <p><code>siteID</code>: Factor (72 levels), the site or transect surveyed.  
</p>
</li>
<li> <p><code>length</code>: Number, the length (m) of each transect.  
</p>
</li>
<li> <p><code>observer</code>: Factor (five levels), identity of the observer 
who surveyed the transect.
</p>
</li>
<li> <p><code>bare</code>: Number, the mean bare ground cover (%) within 100 m of each transect.
</p>
</li>
<li> <p><code>herb</code>: Number, the mean herbaceous cover (%) within 100 m of
each transect.
</p>
</li>
<li> <p><code>shrub</code>: Number, the mean shrub cover (%) within
100 m of each transect.
</p>
</li>
<li> <p><code>height</code>: Number, the mean shrub height 
(cm) within 100 m of each transect.
</p>
</li>
<li> <p><code>shrubclass</code>: Factor (two levels), shrub class is &quot;Low&quot;&quot; when 
shrub cover is &lt; 10%, &quot;High&quot; otherwise.  
</p>
</li></ol>



<h3>Source</h3>

<p>The Brewer's sparrow data are a subset of the data collected 
by Jason Carlisle and various field technicians for his Ph.D. from the 
Department of Ecology, University of Wyoming, in 2017.  This portion of 
Jason's work was funded by the Wyoming Game and Fish Department through agreements 
with the University of Wyoming's  Cooperative Fish &amp; Wildlife
Research Unit (2012).
</p>


<h3>References</h3>

<p>Carlisle, J.D. 2017. The effect of sage-grouse conservation on
wildlife species of concern: Implications for the umbrella species concept.
Dissertation. University of Wyoming, Laramie, Wyoming, USA.
</p>
<p>Carlisle, J. D., and A. D. Chalfoun. 2020. The abundance of Greater 
Sage-Grouse as a proxy for the abundance of sagebrush-associated songbirds 
in Wyoming, USA. <em>Avian Conservation and Ecology</em> 15(2):16. 
<a href="https://doi.org/10.5751/ACE-01702-150216">doi:10.5751/ACE-01702-150216</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparrowDetectionData">sparrowDetectionData</a></code>
</p>

<hr>
<h2 id='thrasherDetectionData'>Sage Thrasher detection data</h2><span id='topic+thrasherDetectionData'></span>

<h3>Description</h3>

<p>Point transect data collected in central Wyoming from 120 points
surveyed for Sage Thrashers by the Wyoming Cooperative Fish &amp; Wildlife Research Unit in 2013.
See package vignettes for tutorials of the basic analysis.
</p>


<h3>Format</h3>

<p>A data.frame containing 193 rows and 3 columns.  Each row represents
a detected group of thrashers.  Column descriptions: 
</p>
 
<ol>
<li> <p><code>siteID</code>: Factor (120 levels), the site or point where the detection
was made.  
</p>
</li>
<li> <p><code>groupsize</code>: Number, the number of individuals within
the detected group.  
</p>
</li>
<li> <p><code>dist</code>: Number, the radial distance (m) from
the transect to the detected group.  This is the distance used in analysis.
</p>
</li></ol>



<h3>Source</h3>

<p>The Sage Thrasher data are a subset of the data collected 
by Jason Carlisle and various field technicians for his Ph.D. from the 
Department of Ecology, University of Wyoming, in 2017.  This portion of 
Jason's work was funded by the Wyoming Game and Fish Department through agreements 
with the University of Wyoming's  Cooperative Fish &amp; Wildlife
Research Unit (2012).
</p>


<h3>References</h3>

<p>Carlisle, J.D. 2017. The effect of sage-grouse conservation on
wildlife species of concern: implications for the umbrella species concept.
Dissertation. University of Wyoming, Laramie, Wyoming, USA.
</p>
<p>Carlisle, J. D., A. D. Chalfoun, K. T. Smith, and J. L. Beck. 2018. 
Nontarget effects on songbirds from habitat manipulation for Greater 
Sage-Grouse: Implications for the umbrella species concept. 
<em>The Condor: Ornithological Applications</em> 120:439455. 
<a href="https://doi.org/10.1650/CONDOR-17-200.1">doi:10.1650/CONDOR-17-200.1</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thrasherSiteData">thrasherSiteData</a></code>
</p>

<hr>
<h2 id='thrasherSiteData'>thrasherSiteData - Sage Thrasher site data.</h2><span id='topic+thrasherSiteData'></span>

<h3>Description</h3>

<p>Point transect data collected in central 
Wyoming from 120 points surveyed for Sage Thrashers by the Wyoming 
Cooperative Fish &amp; Wildlife Research Unit in 2013.
See package vignettes for tutorials of the basic analysis.
</p>


<h3>Format</h3>

<p>A data.frame containing 120 rows and 6 columns.  Each row represents
a surveyed site (point).  Column descriptions: 
</p>
 
<ol>
<li> <p><code>siteID</code>: Factor (120 levels), the site or point surveyed.  
</p>
</li>
<li> <p><code>observer</code>: Factor (six levels), identity of the observer who surveyed
the point.  
</p>
</li>
<li> <p><code>bare</code>: Number, the mean bare ground cover (%)
within 100 m of each point.  
</p>
</li>
<li> <p><code>herb</code>: Number, the mean herbaceous
cover (%) within 100 m of each point.  
</p>
</li>
<li> <p><code>shrub</code>: Number, the mean
shrub cover (%) within 100 m of each point.  
</p>
</li>
<li> <p><code>height</code>: Number,
the mean shrub height (cm) within 100 m of each point.  </p>
</li></ol>



<h3>Source</h3>

<p>The Sage Thrasher data are a subset of data collected 
by Jason Carlisle and field technicians for his Ph.D. from the 
Department of Ecology, University of Wyoming, in 2017.  This portion of 
Jason's work was funded by the Wyoming Game and Fish Department through agreements 
with the University of Wyoming's  Cooperative Fish &amp; Wildlife
Research Unit (2012).
</p>


<h3>References</h3>

<p>Carlisle, J.D. 2017. The effect of sage-grouse conservation on
wildlife species of concern: implications for the umbrella species concept.
Dissertation. University of Wyoming, Laramie, Wyoming, USA.
</p>
<p>Carlisle, J. D., A. D. Chalfoun, K. T. Smith, and J. L. Beck. 2018. 
Nontarget effects on songbirds from habitat manipulation for Greater 
Sage-Grouse: Implications for the umbrella species concept. 
<em>The Condor: Ornithological Applications</em> 120:439455. 
<a href="https://doi.org/10.1650/CONDOR-17-200.1">doi:10.1650/CONDOR-17-200.1</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thrasherDetectionData">thrasherDetectionData</a></code>
</p>

<hr>
<h2 id='uniform.like'>uniform.like - Uniform distance likelihood</h2><span id='topic+uniform.like'></span>

<h3>Description</h3>

<p>Compute uniform-like distribution for 
distance functions.  This function was present in <code>Rdistance</code>
version &lt; 2.2.0.  It has been replaced by the more appropriately named
<code><a href="#topic+logistic.like">logistic.like</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform.like(
  a,
  dist,
  covars = NULL,
  w.lo = 0,
  w.hi = max(dist),
  series = "cosine",
  expansions = 0,
  scale = TRUE,
  pointSurvey = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniform.like_+3A_a">a</code></td>
<td>
<p>A vector of likelihood parameter values. Length and meaning 
depend on whether covariates and <code>expansions</code> are present as follows:
</p>

<ul>
<li><p> If no covariates and no expansions: <code>a</code> = [a, b] (see Details)
</p>
</li>
<li><p> If no covariates and <em>k</em> expansions: <code>a</code> = [a, b, e1, ..., e<em>k</em>] 
</p>
</li>
<li><p> If <em>p</em> covariates and no expansions: <code>a</code> = [a, b, b1, ..., b<em>p</em>] 
</p>
</li>
<li><p> If <em>p</em> covariates and <em>k</em> expansions: <code>a</code> = [a, b, b1, ..., b<em>p</em>, e1, ..., e<em>k</em>] 
</p>
</li></ul>
</td></tr>
<tr><td><code id="uniform.like_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing observed distances with measurement
units.</p>
</td></tr>
<tr><td><code id="uniform.like_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates at 
each observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="uniform.like_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance, with measurement
units.  
This is the <em>left truncation</em> sighting distance.  Values less than 
<code>w.lo</code> are allowed in <code>dist</code>, but are ignored and 
their likelihood value is set to
<code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="uniform.like_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance, with measurement
units.  
This is the <em>right truncation</em> sighting distance.
Values greater than <code>w.hi</code> are allowed in <code>dist</code>, 
but are ignored and their likelihood value is 
set to <code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="uniform.like_+3A_series">series</code></td>
<td>
<p>A string specifying the type of expansion to 
use.  Currently, valid values are 'simple', 'hermite', and 
'cosine'; but, see <code><a href="#topic+dfuncEstim">dfuncEstim</a></code> about 
defining other series.</p>
</td></tr>
<tr><td><code id="uniform.like_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms 
in <code>series</code>. Depending on the series, this could be 0 through 5.
The default of 0 equates to no expansion terms of any type.</p>
</td></tr>
<tr><td><code id="uniform.like_+3A_scale">scale</code></td>
<td>
<p>Logical scalar indicating whether or not to scale 
the likelihood into a density function, i.e., so that it integrates 
to 1. This parameter is used 
to stop recursion in other functions.
If <code>scale</code> equals TRUE, a numerical integration 
routine (<code><a href="#topic+integration.constant">integration.constant</a></code>) is called, which 
in turn calls this likelihood function again
with <code>scale</code> = FALSE. Thus, this routine knows when its 
values are being used to compute the likelihood and when its 
values are being used to compute the constant of integration.  
All user defined likelihoods must have and use this parameter.</p>
</td></tr>
<tr><td><code id="uniform.like_+3A_pointsurvey">pointSurvey</code></td>
<td>
<p>Boolean. TRUE if <code>dist</code> is point 
transect data, FALSE if line transect data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the same length and order as <code>dist</code> 
containing the likelihood contribution for corresponding distances 
in <code>dist</code>. 
Assuming <code>L</code> is the returned vector, 
the log likelihood of all data is <code>-sum(log(L), na.rm=T)</code>. 
Note that the returned likelihood value for distances less than 
<code>w.lo</code> or greater than <code>w.hi</code> is <code>NA</code>, and thus it is 
essential to use <code>na.rm=TRUE</code> in the sum. If <code>scale</code> = TRUE, 
the integral of the likelihood from <code>w.lo</code> to <code>w.hi</code> is 1.0. 
If <code>scale</code> = FALSE, the integral of the likelihood is
arbitrary.
</p>


<h3>Expansion Terms</h3>

<p>If <code>expansions</code> = k (k &gt; 0), the 
expansion function specified by <code>series</code> is called (see for example
<code><a href="#topic+cosine.expansion">cosine.expansion</a></code>). Assuming 
<code class="reqn">h_{ij}(x)</code> is the <code class="reqn">j^{th}</code> expansion term 
for the <code class="reqn">i^{th}</code> distance and that 
<code class="reqn">c_1, c_2, \dots, c_k</code> are (estimated) 
coefficients, the likelihood contribution 
for the <code class="reqn">i^{th}</code> distance is, 
</p>
<p style="text-align: center;"><code class="reqn">f(x|a,b,c_1,c_2,\dots,c_k) = f(x|a,b)(1 + 
\sum_{j=1}^{k} c_j h_{ij}(x)).</code>
</p>


<hr>
<h2 id='uniform.start.limits'>uniform.start.limits - Start and limit values for uniform distance function</h2><span id='topic+uniform.start.limits'></span>

<h3>Description</h3>

<p>DEPRECATED.: Starting values and limits for parameters of the uniform 
distance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform.start.limits(dist, covars, expansions, w.lo, w.hi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniform.start.limits_+3A_dist">dist</code></td>
<td>
<p>A numeric vector containing observed distances with measurement
units.</p>
</td></tr>
<tr><td><code id="uniform.start.limits_+3A_covars">covars</code></td>
<td>
<p>Data frame containing values of covariates at 
each observation in <code>dist</code>.</p>
</td></tr>
<tr><td><code id="uniform.start.limits_+3A_expansions">expansions</code></td>
<td>
<p>A scalar specifying the number of terms 
in <code>series</code>. Depending on the series, this could be 0 through 5.
The default of 0 equates to no expansion terms of any type.</p>
</td></tr>
<tr><td><code id="uniform.start.limits_+3A_w.lo">w.lo</code></td>
<td>
<p>Scalar value of the lowest observable distance, with measurement
units.  
This is the <em>left truncation</em> sighting distance.  Values less than 
<code>w.lo</code> are allowed in <code>dist</code>, but are ignored and 
their likelihood value is set to
<code>NA</code> in the output.</p>
</td></tr>
<tr><td><code id="uniform.start.limits_+3A_w.hi">w.hi</code></td>
<td>
<p>Scalar value of the largest observable distance, with measurement
units.  
This is the <em>right truncation</em> sighting distance.
Values greater than <code>w.hi</code> are allowed in <code>dist</code>, 
but are ignored and their likelihood value is 
set to <code>NA</code> in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called within 
<code>F.start.limits</code>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li> <p><code>start</code> : a vector of starting values
</p>
</li>
<li> <p><code>lowlimit</code> : a vector of lower limits (can be -Inf)
</p>
</li>
<li> <p><code>highlimit</code> : a vector of upper limits (can be Inf)
</p>
</li>
<li> <p><code>nms</code> : a vector containing names of the parameters
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
