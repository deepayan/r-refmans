<!DOCTYPE html><html><head><title>Help for package bnstruct</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bnstruct}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.observations&lt;-'><p>add further evidence to an existing list of observations of an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#asia'><p>load <code>Asia</code> dataset.</p></a></li>
<li><a href='#asia_10000'><p><code>Asia</code> dataset.</p></a></li>
<li><a href='#asia_2_layers'><p>load a two-layers dataset derived from the <code>Asia</code> dataset.</p></a></li>
<li><a href='#belief.propagation'><p>perform belief propagation.</p></a></li>
<li><a href='#bn'><p>get the <code>BN</code> object contained in an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#BN-class'><p>BN class definition.</p></a></li>
<li><a href='#bn&lt;-'><p>set the original <code>BN</code> object contained in an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#BNDataset-class'><p>BNDataset class.</p></a></li>
<li><a href='#boot'><p>get selected element of bootstrap list.</p></a></li>
<li><a href='#boots'><p>get list of bootstrap samples of a <code>BNDataset</code>.</p></a></li>
<li><a href='#boots&lt;-'><p>set list of bootstrap samples of a <code>BNDataset</code>.</p></a></li>
<li><a href='#bootstrap'><p>Perform bootstrap.</p></a></li>
<li><a href='#build.junction.tree'><p>build a JunctionTree.</p></a></li>
<li><a href='#child'><p>load <code>Child</code> dataset.</p></a></li>
<li><a href='#child_NA_5000'><p><code>Child</code> dataset.</p></a></li>
<li><a href='#complete'><p>Subset a <code>BNDataset</code> to get only complete cases.</p></a></li>
<li><a href='#cpts'><p>get the list of conditional probability tables of a <code>BN</code>.</p></a></li>
<li><a href='#cpts&lt;-'><p>set the list of conditional probability tables of a network.</p></a></li>
<li><a href='#dag'><p>get adjacency matrix of a network.</p></a></li>
<li><a href='#dag.to.cpdag'><p>convert a DAG to a CPDAG</p></a></li>
<li><a href='#dag&lt;-'><p>set adjacency matrix of an object.</p></a></li>
<li><a href='#data.file'><p>get data file of a <code>BNDataset</code>.</p></a></li>
<li><a href='#data.file&lt;-'><p>set data file of a <code>BNDataset</code>.</p></a></li>
<li><a href='#discreteness'><p>get status (discrete or continuous) of the variables of an object.</p></a></li>
<li><a href='#discreteness&lt;-'><p>set status (discrete or continuous) of the variables of an object.</p></a></li>
<li><a href='#edge.dir.wpdag'><p>counts the edges in a WPDAG with their directionality</p></a></li>
<li><a href='#em'><p>expectation-maximization algorithm.</p></a></li>
<li><a href='#get.most.probable.values'><p>compute the most probable values to be observed.</p></a></li>
<li><a href='#has.boots'><p>check whether a <code>BNDataset</code> has bootstrap samples or not.</p></a></li>
<li><a href='#has.imputed.boots'><p>check whether a <code>BNDataset</code> has bootstrap samples from imputed data or not.</p></a></li>
<li><a href='#has.imputed.data'><p>check if a BNDataset contains impited data.</p></a></li>
<li><a href='#has.raw.data'><p>check if a BNDataset contains raw data.</p></a></li>
<li><a href='#header.file'><p>get header file of a <code>BNDataset</code>.</p></a></li>
<li><a href='#header.file&lt;-'><p>set header file of a <code>BNDataset</code>.</p></a></li>
<li><a href='#imp.boots'><p>get list of bootstrap samples from imputed data of a <code>BNDataset</code>.</p></a></li>
<li><a href='#imp.boots&lt;-'><p>set list of bootstrap samples from imputed data of a <code>BNDataset</code>.</p></a></li>
<li><a href='#impute'><p>Impute a <code>BNDataset</code> raw data with missing values.</p></a></li>
<li><a href='#imputed.data'><p>get imputed data of a BNDataset.</p></a></li>
<li><a href='#imputed.data&lt;-'><p>add imputed data.</p></a></li>
<li><a href='#InferenceEngine-class'><p>InferenceEngine class.</p></a></li>
<li><a href='#interventions'><p>get the list of interventions of an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#interventions&lt;-'><p>set the list of interventions for an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#jpts'><p>get the list of joint probability tables compiled by an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#jpts&lt;-'><p>set the list of joint probability tables compiled by an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#jt.cliques'><p>get the list of cliques of the junction tree of an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#jt.cliques&lt;-'><p>set the list of cliques of the junction tree of an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#junction.tree'><p>get the junction tree of an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#junction.tree&lt;-'><p>set the junction tree of an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#knn.impute'><p>Perform imputation of a data frame using k-NN.</p></a></li>
<li><a href='#layering'><p>return the layering of the nodes.</p></a></li>
<li><a href='#learn.dynamic.network'><p>learn a dynamic network (structure and parameters) of a BN from a BNDataset.</p></a></li>
<li><a href='#learn.network'><p>learn a network (structure and parameters) of a BN from a BNDataset.</p></a></li>
<li><a href='#learn.params'><p>learn the parameters of a BN.</p></a></li>
<li><a href='#learn.structure'><p>learn the structure of a network.</p></a></li>
<li><a href='#marginals'><p>compute the list of inferred marginals of a BN.</p></a></li>
<li><a href='#name'><p>get name of an object.</p></a></li>
<li><a href='#name&lt;-'><p>set name of an object.</p></a></li>
<li><a href='#node.sizes'><p>get size of the variables of an object.</p></a></li>
<li><a href='#node.sizes&lt;-'><p>set the size of variables of an object.</p></a></li>
<li><a href='#num.boots'><p>get number of bootstrap samples of a <code>BNDataset</code>.</p></a></li>
<li><a href='#num.boots&lt;-'><p>set number of bootstrap samples of a <code>BNDataset</code>.</p></a></li>
<li><a href='#num.items'><p>get number of items of a <code>BNDataset</code>.</p></a></li>
<li><a href='#num.items&lt;-'><p>set number of items of a <code>BNDataset</code>.</p></a></li>
<li><a href='#num.nodes'><p>get number of nodes of an object.</p></a></li>
<li><a href='#num.nodes&lt;-'><p>set number of nodes of an object.</p></a></li>
<li><a href='#num.time.steps'><p>get number of time steps observed in a <code>BN</code> or a <code>BNDataset</code>.</p></a></li>
<li><a href='#num.time.steps&lt;-'><p>set number of time steps of a <code>BN</code> or a <code>BNDataset</code>.</p></a></li>
<li><a href='#num.variables'><p>get number of variables of a <code>BNDataset</code>.</p></a></li>
<li><a href='#num.variables&lt;-'><p>set number of variables of a <code>BNDataset</code>.</p></a></li>
<li><a href='#observations'><p>get the list of observations of an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#observations&lt;-'><p>set the list of observations of an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#plot'><p>plot a <code>BN</code> as a picture.</p></a></li>
<li><a href='#print'><p>print a <code>BN</code>, <code>BNDataset</code> or <code>InferenceEngine</code> to <code>stdout</code>.</p></a></li>
<li><a href='#quantiles'><p>get the list of quantiles of an object.</p></a></li>
<li><a href='#quantiles&lt;-'><p>set the list of quantiles of an object.</p></a></li>
<li><a href='#raw.data'><p>get raw data of a BNDataset.</p></a></li>
<li><a href='#raw.data&lt;-'><p>add raw data.</p></a></li>
<li><a href='#read.bif'><p>Read a network from a <code>.bif</code> file.</p></a></li>
<li><a href='#read.dataset'><p>Read a dataset from file.</p></a></li>
<li><a href='#read.dsc'><p>Read a network from a <code>.dsc</code> file.</p></a></li>
<li><a href='#read.net'><p>Read a network from a <code>.net</code> file.</p></a></li>
<li><a href='#sample.dataset'><p>sample a <code>BNDataset</code> from a network of an inference engine.</p></a></li>
<li><a href='#sample.row'><p>sample a row vector of values for a network.</p></a></li>
<li><a href='#save.to.eps'><p>save a <code>BN</code> picture as <code>.eps</code> file.</p></a></li>
<li><a href='#scoring.func'><p>Read the scoring function used to learn the structure of a network.</p></a></li>
<li><a href='#scoring.func&lt;-'><p>Set the scoring function used to learn the structure of a network.</p></a></li>
<li><a href='#shd'><p>compute the Structural Hamming Distance between two adjacency matrices.</p></a></li>
<li><a href='#show'><p>Show method for objects.</p></a></li>
<li><a href='#struct.algo'><p>Read the algorithm used to learn the structure of a network.</p></a></li>
<li><a href='#struct.algo&lt;-'><p>Set the algorithm used to learn the structure of a network.</p></a></li>
<li><a href='#test.updated.bn'><p>check if an updated <code>BN</code> is present in an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#tune.knn.impute'><p>tune the parameter k of the knn algorithm used in imputation.</p></a></li>
<li><a href='#updated.bn'><p>get the updated <code>BN</code> object contained in an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#updated.bn&lt;-'><p>set the updated <code>BN</code> object contained in an <code>InferenceEngine</code>.</p></a></li>
<li><a href='#variables'><p>get variables of an object.</p></a></li>
<li><a href='#variables&lt;-'><p>set variables of an object.</p></a></li>
<li><a href='#wpdag'><p>get the WPDAG of an object.</p></a></li>
<li><a href='#wpdag.from.dag'><p>Initialize a WPDAG from a DAG.</p></a></li>
<li><a href='#wpdag&lt;-'><p>set WPDAG of the object.</p></a></li>
<li><a href='#write_xgmml'><p>Write a network saving it in an <code>XGMML</code> file.</p></a></li>
<li><a href='#write.dsc'><p>Write a network saving it in a <code>.dsc</code> file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Description:</td>
<td>Bayesian Network Structure Learning from Data with Missing Values.
    The package implements the Silander-Myllymaki complete search,
    the Max-Min Parents-and-Children, the Hill-Climbing, the
    Max-Min Hill-climbing heuristic searches, and the Structural
    Expectation-Maximization algorithm. Available scoring functions are
    BDeu, AIC, BIC. The package also implements methods for generating and using
    bootstrap samples, imputed data, inference.</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Network Structure Learning from Data with Missing
Values</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.15</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-09</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), bitops, igraph, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>graph, Rgraphviz, qgraph, knitr, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 18:29:57 UTC; alberto</td>
</tr>
<tr>
<td>Author:</td>
<td>Francesco Sambo [aut],
  Alberto Franzin [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alberto Franzin &lt;afranzin@ulb.ac.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 23:43:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.observations+26lt+3B-'>add further evidence to an existing list of observations of an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+add.observations+3C-'></span><span id='topic+add.observations+3C-+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>Add a list of observations to an InferenceEngine that already has observations,
using a list composed by the two following vectors:
</p>

<dl>
<dt><code>observed.vars</code></dt><dd><p>vector of observed variables;</p>
</dd>
<dt><code>observed.vals</code></dt><dd><p>vector of values observed for the variables in <code>observed.vars</code> in the corresponding position.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>add.observations(x) &lt;- value

## S4 replacement method for signature 'InferenceEngine'
add.observations(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.observations+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="add.observations+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the list of observations of the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of multiple observations of the same variable, the last observation is the one used, as the most recent.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+observations+3C-">observations&lt;-</a></code>
</p>

<hr>
<h2 id='asia'>load <code>Asia</code> dataset.</h2><span id='topic+asia'></span>

<h3>Description</h3>

<p>Wrapper for a loader for the <code>Asia</code> dataset, with only raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asia()
</code></pre>


<h3>Details</h3>

<p>The dataset has 10000 items, no missing data, so no imputation needs to be performed.
</p>


<h3>Value</h3>

<p>a BNDataset containing the <code>Child</code> dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asia_10000">asia_10000</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- asia()
print(dataset)

</code></pre>

<hr>
<h2 id='asia_10000'><code>Asia</code> dataset.</h2><span id='topic+asia_10000'></span>

<h3>Description</h3>

<p>The <code>Asia</code> dataset contains 10000 complete (no missing data, no latent variables) randomly generated items of the <code>Asia</code> Bayesian Network.
No imputation needs to be performed, so only raw data is present.
</p>


<h3>Format</h3>

<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> with raw data slow filled.
</p>


<h3>Details</h3>

<p>The data the BNDataset object is built from is located in files <code>pkg_folder/extdata/asia_10000.header</code> and <code>pkg_folder/extdata/asia_10000.data</code>.
</p>


<h3>References</h3>

<p>S. Lauritzen, D. Spiegelhalter. Local Computation with Probabilities on Graphical Structures and their Application to Expert Systems
(with discussion). Journal of the Royal Statistical Society: Series B (Statistical Methodology), 50(2):157-224, 1988.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asia">asia</a></code>
</p>

<hr>
<h2 id='asia_2_layers'>load a two-layers dataset derived from the <code>Asia</code> dataset.</h2><span id='topic+asia_2_layers'></span>

<h3>Description</h3>

<p>Wrapper for a loader for a 2-layers dataset derived from the <code>Asia</code> dataset, with only raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asia_2_layers()
</code></pre>


<h3>Details</h3>

<p>The dataset has 100 items, no missing data, so no imputation needs to be performed.
</p>


<h3>Value</h3>

<p>a BNDataset containing the <code>Child</code> dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asia_10000">asia_10000</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- asia_2_layers()
print(dataset)

</code></pre>

<hr>
<h2 id='belief.propagation'>perform belief propagation.</h2><span id='topic+belief.propagation'></span><span id='topic+belief.propagation+2CInferenceEngine-method'></span><span id='topic+belief.propagation+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Perform belief propagation for the network of an InferenceEngine, given a set of observations.
In the current version of <code>bnstruct</code>, belief propagation can be computed only over a junction tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belief.propagation(ie, observations = NULL, return.potentials = FALSE)

## S4 method for signature 'InferenceEngine'
belief.propagation(ie, observations = NULL, return.potentials = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="belief.propagation_+3A_ie">ie</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> object.</p>
</td></tr>
<tr><td><code id="belief.propagation_+3A_observations">observations</code></td>
<td>
<p>list of observations, consisting in two vector, <code>observed.vars</code> for the observed variables,
and <code>observed.vals</code> for the values taken by the variables listed in <code>observed.vars</code>. If no observations
are provided, the <code>InferenceEngine</code> will use the ones it already contains.</p>
</td></tr>
<tr><td><code id="belief.propagation_+3A_return.potentials">return.potentials</code></td>
<td>
<p>if TRUE only the potentials are returned, instead of the default <code><a href="#topic+BN">BN</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset("file.header", "file.data")
bn &lt;- BN(dataset)
ie &lt;- InferenceEngine(bn)
ie &lt;- belief.propagation(ie)

observations(ie) &lt;- list("observed.vars"=("A","G","X"), "observed.vals"=c(1,2,1))
belief.propagation(ie)

## End(Not run)

</code></pre>

<hr>
<h2 id='bn'>get the <code><a href="#topic+BN">BN</a></code> object contained in an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+bn'></span><span id='topic+bn+2CInferenceEngine-method'></span><span id='topic+bn+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Return a network contained in an InferenceEngine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bn(x)

## S4 method for signature 'InferenceEngine'
bn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bn_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code><a href="#topic+BN">BN</a></code> object contained in an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.
</p>

<hr>
<h2 id='BN-class'>BN class definition.</h2><span id='topic+BN-class'></span><span id='topic+BN+2CBN-class'></span><span id='topic+BN'></span><span id='topic+initialize+2CBN-method'></span>

<h3>Description</h3>

<p>Instantiate a <code><a href="#topic+BN">BN</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BN'
initialize(.Object, dataset = NULL, ...)

BN(dataset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BN-class_+3A_.object">.Object</code></td>
<td>
<p>a BN</p>
</td></tr>
<tr><td><code id="BN-class_+3A_dataset">dataset</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object containing the dataset the network is built upon, if any. The remaining parameters
are considered only if a starting dataset is provided.</p>
</td></tr>
<tr><td><code id="BN-class_+3A_...">...</code></td>
<td>
<p>potential further arguments of methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor may be invoked without parameters &ndash; in this case an empty network will be created, and its slots will be filled manually by the user.
This is usually viable only if the user already has knowledge about the network structure.
</p>


<h3>Value</h3>

<p>BN object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>name of the network</p>
</dd>
<dt><code>num.nodes</code>:</dt><dd><p>number of nodes in the network</p>
</dd>
<dt><code>variables</code>:</dt><dd><p>names of the variables in the network</p>
</dd>
<dt><code>discreteness</code>:</dt><dd><p><code>TRUE</code> if variable is discrete, <code>FALSE</code> if variable is continue</p>
</dd>
<dt><code>node.sizes</code>:</dt><dd><p>if variable <code>i</code> is discrete, <code>node.sizes[i]</code> contains the cardinality of <code>i</code>,
if <code>i</code> is instead discrete the value is the number of states variable <code>i</code> takes when discretized</p>
</dd>
<dt><code>cpts</code>:</dt><dd><p>list of conditional probability tables of the network</p>
</dd>
<dt><code>dag</code>:</dt><dd><p>adjacency matrix of the network</p>
</dd>
<dt><code>wpdag</code>:</dt><dd><p>weighted partially dag</p>
</dd>
<dt><code>scoring.func</code>:</dt><dd><p>scoring function used in structure learning (when performed)</p>
</dd>
<dt><code>struct.algo</code>:</dt><dd><p>algorithm used in structure learning (when performed)</p>
</dd>
<dt><code>num.time.steps</code>:</dt><dd><p>number of instants in which the network is observed (1, unless it is a Dynamic Bayesian Network)</p>
</dd>
<dt><code>discreteness</code>:</dt><dd><p><code>TRUE</code> if variable is discrete, <code>FALSE</code> if variable is continue</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
net.1 &lt;- BN()

dataset &lt;- BNDataset()
dataset &lt;- read.dataset(dataset, "file.header", "file.data")
net.2 &lt;- BN(dataset)

## End(Not run)


</code></pre>

<hr>
<h2 id='bn+26lt+3B-'>set the original <code><a href="#topic+BN">BN</a></code> object contained in an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+bn+3C-'></span><span id='topic+bn+3C-+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>Add an original network to an InferenceEngine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bn(x) &lt;- value

## S4 replacement method for signature 'InferenceEngine'
bn(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bn+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="bn+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the <code><a href="#topic+BN">BN</a></code> object contained in an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='BNDataset-class'>BNDataset class.</h2><span id='topic+BNDataset-class'></span><span id='topic+BNDataset+2CBNDataset-class'></span><span id='topic+BNDataset'></span><span id='topic+initialize+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Contains the all of the data that can be extracted from a given dataset:
raw data, imputed data, raw and imputed data with bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BNDataset(data, discreteness, variables = NULL, node.sizes = NULL, ...)

## S4 method for signature 'BNDataset'
initialize(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BNDataset-class_+3A_.object">.Object</code></td>
<td>
<p>an empty BNDataset.</p>
</td></tr>
<tr><td><code id="BNDataset-class_+3A_data">data</code></td>
<td>
<p>raw data.frame or path/name of the file containing the raw dataset (see 'Details').</p>
</td></tr>
<tr><td><code id="BNDataset-class_+3A_discreteness">discreteness</code></td>
<td>
<p>a vector of booleans indicating if the variables are discrete or continuous
(<code>TRUE</code> and <code>FALSE</code>, respectively),
or path/name of the file containing header information for the dataset (discreteness, variable names, cardinality - see 'Details').</p>
</td></tr>
<tr><td><code id="BNDataset-class_+3A_variables">variables</code></td>
<td>
<p>vector of variable names.</p>
</td></tr>
<tr><td><code id="BNDataset-class_+3A_node.sizes">node.sizes</code></td>
<td>
<p>vector of variable cardinalities (for discrete variables) or quantization ranges (for continuous variables).</p>
</td></tr>
<tr><td><code id="BNDataset-class_+3A_...">...</code></td>
<td>
<p>further arguments for reading a dataset from files (see documentation for <code>read.dataset</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways to build a BNDataset: using two files containing respectively header informations
and data, and manually providing the data table and the related header informations
(variable names, cardinality and discreteness).
</p>
<p>The key informations needed are:
1. the data;
2. the state of variables (discrete or continuous);
3. the names of the variables;
4. the cardinalities of the variables (if discrete), or the number of levels they have to be quantized into
(if continuous). 
Names and cardinalities/leves can be guessed by looking at the data, but it is strongly advised to provide
_all_ of the informations, in order to avoid problems later on during the execution.
</p>
<p>Data can be provided in form of data.frame or matrix. It can contain NAs. By default, NAs are indicated with '?';
to specify a different character for NAs, it is possible to provide also the <code>na.string.symbol</code> parameter.
The values contained in the data have to be numeric (real for continuous variables, integer for discrete ones).
The default range of values for a discrete variable <code>X</code> is <code>[1,|X|]</code>, with <code>|X|</code> being
the cardinality of <code>X</code>. The same applies for the levels of quantization for continuous variables.
If the value ranges for the data are different from the expected ones, it is possible to specify a different
starting value (for the whole dataset) with the <code>starts.from</code> parameter. E.g. by <code>starts.from=0</code>
we assume that the values of the variables in the dataset have range <code>[0,|X|-1]</code>.
Please keep in mind that the internal representation of bnstruct starts from 1,
and the original starting values are then lost. 
</p>
<p>It is possible to use two files, one for the data and one for the metadata,
instead of providing manually all of the info. 
bnstruct requires the data files to be in a format subsequently described.
The actual data has to be in (a text file containing data in) tabular format, one tuple per row,
with the values for each variable separated by a space or a tab. Values for each variable have to be
numbers, starting from <code>1</code> in case of discrete variables.
Data files can have a first row containing the names of the corresponding variables.
</p>
<p>In addition to the data file, a header file containing additional informations can also be provided.
An header file has to be composed by three rows of tab-delimited values:
1. list of names of the variables, in the same order of the data file;
2. a list of integers representing the cardinality of the variables, in case of discrete variables,
or the number of levels each variable has to be quantized in, in case of continuous variables;
3. a list that indicates, for each variable, if the variable is continuous
(<code>c</code> or <code>C</code>), and thus has to be quantized before learning,
or discrete (<code>d</code> or <code>D</code>).
In case of need of more advanced options when reading a dataset from files, please refer to the
documentation of the <code><a href="#topic+read.dataset">read.dataset</a></code> method. Imputation and bootstrap are also available
as separate routines (<code><a href="#topic+impute">impute</a></code> and <code><a href="#topic+bootstrap">bootstrap</a></code>, respectively).
</p>
<p>In case of an evolving system to be modeled as a Dynamic Bayesian Network, it is possible to specify 
only the description of the variables of a single instant; the information will be replicated for all
the <code>num.time.steps</code> instants that compose the dataset, where <code>num.time.steps</code> needs to be
set as parameter. In this case, it is assumed that the N variables v1, v2, ..., vN of a single instant 
appear in the dataset as v1_t1, v2_t1, ..., vN_t1, v1_t2, v2_t2, ..., in this exact order.
The user can however provide information for all the variables in all the instants; if it is not the case,
the name of the variables will be edited to include the instant. In case of an evolving system, the
<code>num.variables</code> slots refers anyway to the total number of variables observed in all the instants
(the number of columns in the dataset), and not to a single instant.
</p>


<h3>Value</h3>

<p>BNDataset object.
</p>
<p>a BNDataset object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>name of the dataset</p>
</dd>
<dt><code>header.file</code>:</dt><dd><p>name and location of the header file</p>
</dd>
<dt><code>data.file</code>:</dt><dd><p>name and location of the data file</p>
</dd>
<dt><code>variables</code>:</dt><dd><p>names of the variables in the network</p>
</dd>
<dt><code>node.sizes</code>:</dt><dd><p>cardinality of each variable of the network</p>
</dd>
<dt><code>num.variables</code>:</dt><dd><p>number of variables (columns) in the dataset</p>
</dd>
<dt><code>discreteness</code>:</dt><dd><p><code>TRUE</code> if variable is discrete, <code>FALSE</code> if variable is continue</p>
</dd>
<dt><code>quantiles</code>:</dt><dd><p>list of vectors containing the quantiles, one vector per variable. Each vector is <code>NULL</code> if the variable is discrete, and contains the quantiles if it is continuous</p>
</dd>
<dt><code>num.items</code>:</dt><dd><p>number of observations (rows) in the dataset</p>
</dd>
<dt><code>has.raw.data</code>:</dt><dd><p>TRUE if the dataset contains data read from a file</p>
</dd>
<dt><code>has.imputed.data</code>:</dt><dd><p>TRUE if the dataset contains imputed data (computed from raw data)</p>
</dd>
<dt><code>raw.data</code>:</dt><dd><p>matrix containing raw data</p>
</dd>
<dt><code>imputed.data</code>:</dt><dd><p>matrix containing imputed data</p>
</dd>
<dt><code>has.boots</code>:</dt><dd><p>dataset has bootstrap samples</p>
</dd>
<dt><code>boots</code>:</dt><dd><p>list of bootstrap samples</p>
</dd>
<dt><code>has.imputed.boots</code>:</dt><dd><p>dataset has imputed bootstrap samples</p>
</dd>
<dt><code>imp.boots</code>:</dt><dd><p>list of imputed bootstrap samples</p>
</dd>
<dt><code>num.boots</code>:</dt><dd><p>number of bootstrap samples</p>
</dd>
<dt><code>num.time.steps</code>:</dt><dd><p>number of instants in which the network is observed (1, unless it is a dynamic system)</p>
</dd>
</dl>



<h3>See Also</h3>

<p>read.dataset, impute, bootstrap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create from files
dataset &lt;- BNDataset("file.data", "file.header")

# other way: create from raw dataset and metadata
data &lt;- matrix(c(1:16), nrow = 4, ncol = 4)
dataset &lt;- BNDataset(data = data,
                     discreteness = rep('d',4),
                     variables = c("a", "b", "c", "d"),
                     node.sizes = c(4,8,12,16))

## End(Not run)

</code></pre>

<hr>
<h2 id='boot'>get selected element of bootstrap list.</h2><span id='topic+boot'></span><span id='topic+boot+2CBNDataset+2Cnumeric-method'></span><span id='topic+boot+2CBNDataset'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+BNDataset">BNDataset</a></code>, return the sample corresponding to given index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot(dataset, index, use.imputed.data = FALSE)

## S4 method for signature 'BNDataset,numeric'
boot(dataset, index, use.imputed.data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_+3A_dataset">dataset</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="boot_+3A_index">index</code></td>
<td>
<p>the index of the requested sample.</p>
</td></tr>
<tr><td><code id="boot_+3A_use.imputed.data">use.imputed.data</code></td>
<td>
<p><code>TRUE</code> if samples from imputed dataset are to be used. Default if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>bootstrap
</p>
<p><code><a href="#topic+bootstrap">bootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset("file.data", "file.header")
dataset &lt;- bootstrap(dataset, num.boots = 1000)

for (i in 1:num.boots(dataset))
   print(boot(dataset, i))

## End(Not run)

</code></pre>

<hr>
<h2 id='boots'>get list of bootstrap samples of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+boots'></span><span id='topic+boots+2CBNDataset-method'></span><span id='topic+boots+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the list of samples computed from raw data of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boots(x)

## S4 method for signature 'BNDataset'
boots(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boots_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of bootstrap samples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+has.boots">has.boots</a></code>, <code><a href="#topic+has.imputed.boots">has.imputed.boots</a></code>, <code><a href="#topic+imp.boots">imp.boots</a></code>
</p>

<hr>
<h2 id='boots+26lt+3B-'>set list of bootstrap samples of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+boots+3C-'></span><span id='topic+boots+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Add to a dataset a list of samples from raw data computed using bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boots(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
boots(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boots+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="boots+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the list of bootstrap samples.</p>
</td></tr>
</table>

<hr>
<h2 id='bootstrap'>Perform bootstrap.</h2><span id='topic+bootstrap'></span><span id='topic+bootstrap+2CBNDataset-method'></span><span id='topic+bootstrap+2CBNDataset'></span>

<h3>Description</h3>

<p>Create a list of <code>num.boots</code> samples of the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(object, num.boots = 100, seed = 0, imputation = FALSE, k.impute = 10)

## S4 method for signature 'BNDataset'
bootstrap(object, num.boots = 100, seed = 0, imputation = FALSE, k.impute = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_num.boots">num.boots</code></td>
<td>
<p>number of sampled datasets for bootstrap.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_seed">seed</code></td>
<td>
<p>random seed.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_imputation">imputation</code></td>
<td>
<p><code>TRUE</code> if imputation has to be performed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_k.impute">k.impute</code></td>
<td>
<p>number of neighbours to be used; for discrete variables we use mode, for continuous variables the median value is instead taken (useful only if imputation == TRUE).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset("file.data", "file.header")
dataset &lt;- bootstrap(dataset, num.boots = 1000)

## End(Not run)

</code></pre>

<hr>
<h2 id='build.junction.tree'>build a JunctionTree.</h2><span id='topic+build.junction.tree'></span><span id='topic+build.junction.tree+2CInferenceEngine-method'></span><span id='topic+build.junction.tree+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Starting from the adjacency matrix of the directed acyclic graph of the network
contained in an InferenceEngine, build a JunctionTree for the network
and store it into an InferenceEngine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.junction.tree(object, ...)

## S4 method for signature 'InferenceEngine'
build.junction.tree(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.junction.tree_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> object.</p>
</td></tr>
<tr><td><code id="build.junction.tree_+3A_...">...</code></td>
<td>
<p>potential further arguments for methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>InferenceEngine
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset("file.header", "file.data")
net &lt;- BN(dataset)
eng &lt;- InferenceEngine()
eng &lt;- build.junction.tree(eng)

## End(Not run)

</code></pre>

<hr>
<h2 id='child'>load <code>Child</code> dataset.</h2><span id='topic+child'></span>

<h3>Description</h3>

<p>Wrapper for a loader for the <code>Child</code> raw dataset; also perform imputation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>child()
</code></pre>


<h3>Details</h3>

<p>The dataset has 5000 items, with random missing values (no latent variables). BNDataset object contains the raw dataset and imputed dataset, with <code>k=10</code>
(see <code><a href="#topic+impute">impute</a></code> for related explanation).
</p>


<h3>Value</h3>

<p>a BNDataset containing the <code>Child</code> dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+child_NA_5000">child_NA_5000</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- child()
print(dataset)

</code></pre>

<hr>
<h2 id='child_NA_5000'><code>Child</code> dataset.</h2><span id='topic+child_NA_5000'></span>

<h3>Description</h3>

<p>The <code>Child</code> dataset contains 5000 randomly generated items with missing data (no latent variables) of the <code>Child</code> Bayesian Network.
Imputation is performed, so both raw and imputed data is present.
</p>


<h3>Format</h3>

<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> with a raw and imputed data slow filled with 5000 items.
</p>


<h3>Details</h3>

<p>The data the BNDataset object is built from is located in files <code>pkg_folder/extdata/extdata/Child_data_na_5000.header</code> and <code>pkg_folder/extdata/extdata/Child_data_na_5000.data</code>.
</p>


<h3>References</h3>

<p>D. J. Spiegelhalter, R. G. Cowell (1992). Learning in probabilistic expert systems. In Bayesian Statistics 4
(J. M. Bernardo, J. 0. Berger, A. P. Dawid and A. F. M. Smith, eds.) 447-466. Clarendon Press, Oxford.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+child">child</a></code>
</p>

<hr>
<h2 id='complete'>Subset a <code><a href="#topic+BNDataset">BNDataset</a></code> to get only complete cases.</h2><span id='topic+complete'></span><span id='topic+complete+2CBNDataset-method'></span><span id='topic+complete+2CBNDataset'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+BNDataset">BNDataset</a></code>, return a copy of the original object where
the <code>raw.data</code> consists only in the observations that do not contain missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete(x, complete.vars = seq_len(num.variables(x)))

## S4 method for signature 'BNDataset'
complete(x, complete.vars = seq_len(num.variables(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
<tr><td><code id="complete_+3A_complete.vars">complete.vars</code></td>
<td>
<p>vector containing the indices of the variables to be considered
for the subsetting; variables not included in the vector can still contain <code>NA</code>s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-missingness can be required on a subset of variables (by default, on all variables).
</p>
<p>If present, imputed data and bootstrap samples are eliminated from the
new <code><a href="#topic+BNDataset">BNDataset</a></code>, as using this method *after* using <code><a href="#topic+impute">impute</a></code>
or <code><a href="#topic+bootstrap">bootstrap</a></code>, there may likely be a loss of correspondence between
the subsetted <code>raw.data</code> and the previously generated <code>imputed.data</code>
and <code>bootstrap</code> samples.
</p>


<h3>Value</h3>

<p>a copy of the original <code><a href="#topic+BNDataset">BNDataset</a></code> containing only complete observations.
</p>

<hr>
<h2 id='cpts'>get the list of conditional probability tables of a <code><a href="#topic+BN">BN</a></code>.</h2><span id='topic+cpts'></span><span id='topic+cpts+2CBN-method'></span><span id='topic+cpts+2CBN'></span>

<h3>Description</h3>

<p>Return the list of conditional probability tables of the variables of a <code><a href="#topic+BN">BN</a></code> object.
Each probability table is associated to the corresponding variable, and its dimensions are named according
to the variable they represent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpts(x)

## S4 method for signature 'BN'
cpts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpts_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each conditional probability table is represented as a multidimensional array. 
The ordering of the dimensions of each variable is not guaranteed to follow the actual conditional distribution.
E.g. dimensions for conditional probability <code>P(C|A,B)</code> can be either <code>(C,A,B)</code> or <code>(A,B,C)</code>, depending on
if some operations have been performed, or how the probability table has been computed.
Users should not rely on dimension numbers, but should instead select the dimensions using their names.
</p>


<h3>Value</h3>

<p>list of the conditional probability tables of the desired object.
</p>

<hr>
<h2 id='cpts+26lt+3B-'>set the list of conditional probability tables of a network.</h2><span id='topic+cpts+3C-'></span><span id='topic+cpts+3C-+2CBN-method'></span>

<h3>Description</h3>

<p>Set the list of conditional probability tables of a <code><a href="#topic+BN">BN</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpts(x) &lt;- value

## S4 replacement method for signature 'BN'
cpts(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpts+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="cpts+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>list of the conditional probability tables of the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each conditional probability table is represented as a multidimensional array. 
To retrieve single dimensions (e.g. to compute marginals), users should provide dimensions names.
</p>

<hr>
<h2 id='dag'>get adjacency matrix of a network.</h2><span id='topic+dag'></span><span id='topic+dag+2CBN-method'></span><span id='topic+dag+2CBN'></span>

<h3>Description</h3>

<p>Return the adjacency matrix of the directed acyclic graph representing the structure of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag(x)

## S4 method for signature 'BN'
dag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix containing the adjacency matrix of the directed acyclic graph representing
the structure of the object.
</p>

<hr>
<h2 id='dag.to.cpdag'>convert a DAG to a CPDAG</h2><span id='topic+dag.to.cpdag'></span>

<h3>Description</h3>

<p>Convert the adjacency matrix representing the DAG of a <code><a href="#topic+BN">BN</a></code>
into the adjacency matrix representing a CPDAG for the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.to.cpdag(dag.adj.matrix, layering = NULL, layer.struct = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag.to.cpdag_+3A_dag.adj.matrix">dag.adj.matrix</code></td>
<td>
<p>the adjacency matrix representing the DAG of a <code><a href="#topic+BN">BN</a></code>.</p>
</td></tr>
<tr><td><code id="dag.to.cpdag_+3A_layering">layering</code></td>
<td>
<p>vector containing the layers where each node belongs.</p>
</td></tr>
<tr><td><code id="dag.to.cpdag_+3A_layer.struct">layer.struct</code></td>
<td>
<p>layer.struct <code>0/1</code> matrix for indicating which layers can contain parent nodes
for nodes in a layer (only for <code>mmhc</code>, <code>mmpc</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the adjacency matrix representing a CPDAG for the network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpdag.from.dag">wpdag.from.dag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
net &lt;- learn.network(dataset, layering=layering, layer.struct=layer.struct)
pdag &lt;- dag.to.cpdag(dag(net), layering, layer.struct)
wpdag(net) &lt;- pdag

## End(Not run)

</code></pre>

<hr>
<h2 id='dag+26lt+3B-'>set adjacency matrix of an object.</h2><span id='topic+dag+3C-'></span><span id='topic+dag+3C-+2CBN-method'></span>

<h3>Description</h3>

<p>Set the adjacency matrix of the directed acyclic graph representing the structure of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag(x) &lt;- value

## S4 replacement method for signature 'BN'
dag(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="dag+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>matrix containing the adjacency matrix of the directed acyclic graph representing
the structure of the object.</p>
</td></tr>
</table>

<hr>
<h2 id='data.file'>get data file of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+data.file'></span><span id='topic+data.file+2CBNDataset-method'></span><span id='topic+data.file+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the data filename of a dataset (with the path to its position, as given by the user).
The data filename may contain a header in the first row, containing the list of names of the variables,
in the same order as in the header file.
After the header, if present, the file contains a data.frame with the observations, one item per row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.file(x)

## S4 method for signature 'BNDataset'
data.file(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.file_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data filename of the dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.file">data.file</a></code>
</p>

<hr>
<h2 id='data.file+26lt+3B-'>set data file of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+data.file+3C-'></span><span id='topic+data.file+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the data filename of a dataset (with the path to its position, as given by the user).
The data filename may contain a header in the first row, containing the list of names of the variables,
in the same order as in the header file.
After the header, if present, the file contains a data.frame with the observations, one item per row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.file(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
data.file(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.file+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
<tr><td><code id="data.file+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>data filename.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+header.file+3C-">header.file&lt;-</a></code>
</p>

<hr>
<h2 id='discreteness'>get status (discrete or continuous) of the variables of an object.</h2><span id='topic+discreteness'></span><span id='topic+discreteness+2CBN-method'></span><span id='topic+discreteness+2CBN'></span><span id='topic+discreteness+2CBNDataset-method'></span><span id='topic+discreteness+2CBNDataset'></span>

<h3>Description</h3>

<p>Get a vector representing the status of the variables (with their names) of a <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+BNDataset">BNDataset</a></code>.
Elements of the vector are <code>c</code> if the variable is continue, and <code>d</code> if the variable is discrete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discreteness(x)

## S4 method for signature 'BN'
discreteness(x)

## S4 method for signature 'BNDataset'
discreteness(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discreteness_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector contaning, for each variable of the desired object,
<code>c</code> if the variable is continue, and <code>d</code> if the variable is discrete.
</p>

<hr>
<h2 id='discreteness+26lt+3B-'>set status (discrete or continuous) of the variables of an object.</h2><span id='topic+discreteness+3C-'></span><span id='topic+discreteness+3C-+2CBN-method'></span><span id='topic+discreteness+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the list of variable status for the variables in a network or a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discreteness(x) &lt;- value

## S4 replacement method for signature 'BN'
discreteness(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
discreteness(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discreteness+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="discreteness+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a vector of elements in {<code>c</code>,<code>d</code>} for continuous and discrete variables (respectively).</p>
</td></tr>
</table>

<hr>
<h2 id='edge.dir.wpdag'>counts the edges in a WPDAG with their directionality</h2><span id='topic+edge.dir.wpdag'></span>

<h3>Description</h3>

<p>Given a <code>BN</code> with a <code>WPDAG</code>, it counts the edges, with
their directionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.dir.wpdag(x, use.node.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge.dir.wpdag_+3A_x">x</code></td>
<td>
<p>the <code>BN</code></p>
</td></tr>
<tr><td><code id="edge.dir.wpdag_+3A_use.node.names">use.node.names</code></td>
<td>
<p>use node names rather than number (<code>TRUE</code> by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the node pairs with the count of the edges
between them in the <code>WPDAG</code>.
</p>

<hr>
<h2 id='em'>expectation-maximization algorithm.</h2><span id='topic+em'></span><span id='topic+em+2CInferenceEngine+2CBNDataset-method'></span><span id='topic+em+2CInferenceEngine+2CBNDataset'></span>

<h3>Description</h3>

<p>Learn parameters of a network using the Expectation-Maximization algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>em(x, dataset, threshold = 0.001, max.em.iterations = 10, ess = 1)

## S4 method for signature 'InferenceEngine,BNDataset'
em(x, dataset, threshold = 0.001, max.em.iterations = 10, ess = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="em_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="em_+3A_dataset">dataset</code></td>
<td>
<p>observed dataset with missing values for the Bayesian Network of <code>x</code>.</p>
</td></tr>
<tr><td><code id="em_+3A_threshold">threshold</code></td>
<td>
<p>threshold for convergence, used as stopping criterion.</p>
</td></tr>
<tr><td><code id="em_+3A_max.em.iterations">max.em.iterations</code></td>
<td>
<p>maximum number of iterations to run in case of no convergence.</p>
</td></tr>
<tr><td><code id="em_+3A_ess">ess</code></td>
<td>
<p>Equivalent Sample Size value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing: an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> with a new updated network (<code>"InferenceEngine"</code>),
and the imputed dataset (<code>"BNDataset"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
em(x, dataset)

## End(Not run)

</code></pre>

<hr>
<h2 id='get.most.probable.values'>compute the most probable values to be observed.</h2><span id='topic+get.most.probable.values'></span><span id='topic+get.most.probable.values+2CBN-method'></span><span id='topic+get.most.probable.values+2CBN'></span><span id='topic+get.most.probable.values+2CInferenceEngine-method'></span><span id='topic+get.most.probable.values+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Return an array containing the values that each variable of the network is more likely to take, according to the CPTS.
In case of ties take the first value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.most.probable.values(x, prev.values = NULL)

## S4 method for signature 'BN'
get.most.probable.values(x, prev.values = NULL)

## S4 method for signature 'InferenceEngine'
get.most.probable.values(x, prev.values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.most.probable.values_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> object.</p>
</td></tr>
<tr><td><code id="get.most.probable.values_+3A_prev.values">prev.values</code></td>
<td>
<p>vector of size <code><a href="#topic+num.nodes">num.nodes</a></code> containing an existing observation to complete (NULL if none).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array containing, in each position, the most probable value for the corresponding variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# try with a BN object x
get.most.probable.values(x)

# now build an InferenceEngine object
eng &lt;- InferenceEngine(x)
get.most.probable.values(eng)

## End(Not run)
 
</code></pre>

<hr>
<h2 id='has.boots'>check whether a <code><a href="#topic+BNDataset">BNDataset</a></code> has bootstrap samples or not.</h2><span id='topic+has.boots'></span><span id='topic+has.boots+2CBNDataset-method'></span><span id='topic+has.boots+2CBNDataset'></span>

<h3>Description</h3>

<p>Return <code>TRUE</code> if the given dataset contains samples for bootstrap, <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.boots(x)

## S4 method for signature 'BNDataset'
has.boots(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has.boots_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if dataset has bootstrap samples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+has.imputed.boots">has.imputed.boots</a></code>, <code><a href="#topic+boots">boots</a></code>, <code><a href="#topic+imp.boots">imp.boots</a></code>
</p>

<hr>
<h2 id='has.imputed.boots'>check whether a <code><a href="#topic+BNDataset">BNDataset</a></code> has bootstrap samples from imputed data or not.</h2><span id='topic+has.imputed.boots'></span><span id='topic+has.imputed.boots+2CBNDataset-method'></span><span id='topic+has.imputed.boots+2CBNDataset'></span>

<h3>Description</h3>

<p>Return <code>TRUE</code> if the given dataset contains samples for bootstrap from inputed dataset, <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.imputed.boots(x)

## S4 method for signature 'BNDataset'
has.imputed.boots(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has.imputed.boots_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if dataset has bootstrap samples from imputed data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+has.boots">has.boots</a></code>, <code><a href="#topic+boots">boots</a></code>, <code><a href="#topic+imp.boots">imp.boots</a></code>
</p>

<hr>
<h2 id='has.imputed.data'>check if a BNDataset contains impited data.</h2><span id='topic+has.imputed.data'></span><span id='topic+has.imputed.data+2CBNDataset-method'></span><span id='topic+has.imputed.data+2CBNDataset'></span>

<h3>Description</h3>

<p>Check whether a <code><a href="#topic+BNDataset">BNDataset</a></code> object actually contains imputed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.imputed.data(x)

## S4 method for signature 'BNDataset'
has.imputed.data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has.imputed.data_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+has.raw.data">has.raw.data</a></code>, <code><a href="#topic+raw.data">raw.data</a></code>, <code><a href="#topic+imputed.data">imputed.data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- BNDataset()
has.imputed.data(x) # FALSE

x &lt;- read.dataset(x, "file.header", "file.data")
has.imputed.data(x) # FALSE, since read.dataset() actually reads raw data.

x &lt;- impute(x)
has.imputed.data(x) # TRUE

## End(Not run)

</code></pre>

<hr>
<h2 id='has.raw.data'>check if a BNDataset contains raw data.</h2><span id='topic+has.raw.data'></span><span id='topic+has.raw.data+2CBNDataset-method'></span><span id='topic+has.raw.data+2CBNDataset'></span>

<h3>Description</h3>

<p>Check whether a <code><a href="#topic+BNDataset">BNDataset</a></code> object actually contains raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.raw.data(x)

## S4 method for signature 'BNDataset'
has.raw.data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has.raw.data_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+has.imputed.data">has.imputed.data</a></code>, <code><a href="#topic+raw.data">raw.data</a></code>, <code><a href="#topic+imputed.data">imputed.data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- BNDataset()
has.raw.data(x) # FALSE

x &lt;- read.dataset(x, "file.header", "file.data")
has.raw.data(x) # TRUE, since read.dataset() actually reads raw data.

## End(Not run)

</code></pre>

<hr>
<h2 id='header.file'>get header file of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+header.file'></span><span id='topic+header.file+2CBNDataset-method'></span><span id='topic+header.file+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the header filename of a dataset (with the path to its position, as given by the user),
present if the dataset has been read from a file and not manually inserted.
The header file contains three rows:
</p>

<ol>
<li><p> list of names of the variables, in the same order as in the data file;
</p>
</li>
<li><p> list of cardinalities of the variables, if discrete, or levels for quantization if continuous;
</p>
</li>
<li><p> list of status of the variables: <code>c</code> for continuous variables, <code>d</code> for discrete ones.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>header.file(x)

## S4 method for signature 'BNDataset'
header.file(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="header.file_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>header filename of the dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.file">data.file</a></code>
</p>

<hr>
<h2 id='header.file+26lt+3B-'>set header file of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+header.file+3C-'></span><span id='topic+header.file+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the header filename of a dataset (with the path to its position, as given by the user).
The header file has to contain three rows:
</p>

<ol>
<li><p> list of names of the variables, in the same order as in the data file;
</p>
</li>
<li><p> list of cardinalities of the variables, if discrete, or levels for quantization if continuous;
</p>
</li>
<li><p> list of status of the variables: <code>c</code> for continuous variables, <code>d</code> for discrete ones.
</p>
</li></ol>

<p>Further rows are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>header.file(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
header.file(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="header.file+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
<tr><td><code id="header.file+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>header filename.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+data.file+3C-">data.file&lt;-</a></code>
</p>

<hr>
<h2 id='imp.boots'>get list of bootstrap samples from imputed data of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+imp.boots'></span><span id='topic+imp.boots+2CBNDataset-method'></span><span id='topic+imp.boots+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the list of samples computed from raw data of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imp.boots(x)

## S4 method for signature 'BNDataset'
imp.boots(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imp.boots_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of bootstrap samples from imputed data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+has.boots">has.boots</a></code>, <code><a href="#topic+has.imputed.boots">has.imputed.boots</a></code>, <code><a href="#topic+boots">boots</a></code>
</p>

<hr>
<h2 id='imp.boots+26lt+3B-'>set list of bootstrap samples from imputed data of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+imp.boots+3C-'></span><span id='topic+imp.boots+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Add to a dataset a list of samples from imputed data computed using bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imp.boots(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
imp.boots(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imp.boots+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="imp.boots+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the list of bootstrap samples from imputed data.</p>
</td></tr>
</table>

<hr>
<h2 id='impute'>Impute a <code><a href="#topic+BNDataset">BNDataset</a></code> raw data with missing values.</h2><span id='topic+impute'></span><span id='topic+impute+2CBNDataset-method'></span><span id='topic+impute+2CBNDataset'></span>

<h3>Description</h3>

<p>Impute a <code><a href="#topic+BNDataset">BNDataset</a></code> raw data with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute(object, k.impute = 10)

## S4 method for signature 'BNDataset'
impute(object, k.impute = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="impute_+3A_k.impute">k.impute</code></td>
<td>
<p>number of neighbours to be used; for discrete variables we use mode,
for continuous variables the median value is instead taken.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset("file.data", "file.header")
dataset &lt;- impute(dataset)

## End(Not run)

</code></pre>

<hr>
<h2 id='imputed.data'>get imputed data of a BNDataset.</h2><span id='topic+imputed.data'></span><span id='topic+imputed.data+2CBNDataset-method'></span><span id='topic+imputed.data+2CBNDataset'></span>

<h3>Description</h3>

<p>Return imputed data contained in a <code><a href="#topic+BNDataset">BNDataset</a></code> object, if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputed.data(x)

## S4 method for signature 'BNDataset'
imputed.data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputed.data_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+has.raw.data">has.raw.data</a></code>, <code><a href="#topic+has.imputed.data">has.imputed.data</a></code>, <code><a href="#topic+raw.data">raw.data</a></code>
</p>

<hr>
<h2 id='imputed.data+26lt+3B-'>add imputed data.</h2><span id='topic+imputed.data+3C-'></span><span id='topic+imputed.data+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Insert imputed data in a <code><a href="#topic+BNDataset">BNDataset</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputed.data(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
imputed.data(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputed.data+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
<tr><td><code id="imputed.data+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a matrix of integers containing a dataset.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+has.imputed.data">has.imputed.data</a></code>, <code><a href="#topic+imputed.data">imputed.data</a></code>, <code><a href="#topic+read.dataset">read.dataset</a></code>
</p>

<hr>
<h2 id='InferenceEngine-class'>InferenceEngine class.</h2><span id='topic+InferenceEngine-class'></span><span id='topic+InferenceEngine+2CInferenceEngine-class'></span><span id='topic+InferenceEngine'></span><span id='topic+initialize+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>InferenceEngine class.
</p>
<p>Constructor method of <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> class.
</p>
<p>constructor for <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InferenceEngine'
initialize(.Object, ...)

InferenceEngine(bn = NULL, observations = NULL, interventions = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InferenceEngine-class_+3A_.object">.Object</code></td>
<td>
<p>an empty InferenceEngine object.</p>
</td></tr>
<tr><td><code id="InferenceEngine-class_+3A_...">...</code></td>
<td>
<p>potential further arguments of methods.</p>
</td></tr>
<tr><td><code id="InferenceEngine-class_+3A_bn">bn</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
<tr><td><code id="InferenceEngine-class_+3A_observations">observations</code></td>
<td>
<p>a list of observations composed by the two following vectors:
</p>

<dl>
<dt><code>observed.vars</code>:</dt><dd><p>vector of observed variables;</p>
</dd>
<dt><code>observed.vals</code>:</dt><dd><p>vector of values observed for the variables in <code>observed.vars</code> in the corresponding position.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="InferenceEngine-class_+3A_interventions">interventions</code></td>
<td>
<p>a list of interventions composed of the following two vectors:
</p>

<dl>
<dt><code>intervention.vars</code>:</dt><dd><p>vector of variables for which an intervention has been performed;</p>
</dd>
<dt><code>intervention.vals</code>:</dt><dd><p>vector of values chosen for the variables in <code>intervention.vals</code> in the corresponding position.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>an InferenceEngine object.
</p>
<p>InferenceEngine object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>junction.tree</code>:</dt><dd><p>junction tree adjacency matrix.</p>
</dd>
<dt><code>num.nodes</code>:</dt><dd><p>number of nodes in the junction tree.</p>
</dd>
<dt><code>cliques</code>:</dt><dd><p>list of cliques composing the nodes of the junction tree.</p>
</dd>
<dt><code>triangulated.graph</code>:</dt><dd><p>adjacency matrix of the original triangulated graph.</p>
</dd>
<dt><code>jpts</code>:</dt><dd><p>inferred joint probability tables.</p>
</dd>
<dt><code>bn</code>:</dt><dd><p>original Bayesian Network (as object of class <code><a href="#topic+BN">BN</a></code>) as provided by the user, or learnt from a dataset.
<code>NULL</code> if missing.</p>
</dd>
<dt><code>updated.bn</code>:</dt><dd><p>Bayesian Network  (as object of class <code><a href="#topic+BN">BN</a></code>) as modified by a belief propagation computation. In particular,
it will have different conditional probability tables with respect to its original version. <code>NULL</code> if missing.</p>
</dd>
<dt><code>observed.vars</code>:</dt><dd><p>list of observed variables, by name or number.</p>
</dd>
<dt><code>observed.vals</code>:</dt><dd><p>list of observed values for the corresponding variables in <code>observed.vars</code>.</p>
</dd>
<dt><code>intervention.vars</code>:</dt><dd><p>list of manipulated variables, by name or number.</p>
</dd>
<dt><code>intervention.vals</code>:</dt><dd><p>list of specified values for the corresponding variables in <code>intervention.vars</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset()
dataset &lt;- read.dataset(dataset, "file.header", "file.data")
bn &lt;- BN(dataset)
eng &lt;- InferenceEngine(bn)

obs &lt;- list(c("A","G,"X),c(1,2,1))
eng.2 &lt;- InferenceEngine(bn, obs)

## End(Not run)

</code></pre>

<hr>
<h2 id='interventions'>get the list of interventions of an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+interventions'></span><span id='topic+interventions+2CInferenceEngine-method'></span><span id='topic+interventions+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Return the list of interventions added to an InferenceEngine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interventions(x)

## S4 method for signature 'InferenceEngine'
interventions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interventions_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output is a list in the following format:
</p>

<dl>
<dt><code>intervention.vars</code></dt><dd><p>vector of manipulated variables;</p>
</dd>
<dt><code>intervention.vals</code></dt><dd><p>vector of values for the variables in <code>observed.vars</code> in the corresponding position.</p>
</dd>
</dl>



<h3>Value</h3>

<p>the list of interventions of the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.
</p>

<hr>
<h2 id='interventions+26lt+3B-'>set the list of interventions for an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+interventions+3C-'></span><span id='topic+interventions+3C-+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>Add a list of interventions to an InferenceEngine, using a list composed by the two following vectors:
</p>

<dl>
<dt><code>intervention.vars</code></dt><dd><p>vector of the variables we manipulate;</p>
</dd>
<dt><code>intervention.vals</code></dt><dd><p>vector of values for the variables in <code>observed.vars</code> in the corresponding position.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>interventions(x) &lt;- value

## S4 replacement method for signature 'InferenceEngine'
interventions(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interventions+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="interventions+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the list of interventions of the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An intervention can be applied only when building an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.
</p>
<p>In case of multiple interventions of the same variable, the last intervention is the one used.
</p>

<hr>
<h2 id='jpts'>get the list of joint probability tables compiled by an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+jpts'></span><span id='topic+jpts+2CInferenceEngine-method'></span><span id='topic+jpts+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Return the list of joint probability tables for the cliques of the junction tree 
obtained after belief propagation has been performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jpts(x)

## S4 method for signature 'InferenceEngine'
jpts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jpts_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each joint probability table is represented as a multidimensional array. 
To retrieve single dimensions (e.g. to compute marginals), users should not rely on dimension numbers,
but should instead select the dimensions using their names.
</p>


<h3>Value</h3>

<p>the list of joint probability tables compiled by the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.
</p>

<hr>
<h2 id='jpts+26lt+3B-'>set the list of joint probability tables compiled by an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+jpts+3C-'></span><span id='topic+jpts+3C-+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>Add a list of joint probability tables for the cliques of the junction tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jpts(x) &lt;- value

## S4 replacement method for signature 'InferenceEngine'
jpts(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jpts+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="jpts+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the list of joint probability tables compiled by the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each joint probability table is represented as a multidimensional array. 
To retrieve single dimensions (e.g. to compute marginals), users should provide dimension names.
</p>

<hr>
<h2 id='jt.cliques'>get the list of cliques of the junction tree of an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+jt.cliques'></span><span id='topic+jt.cliques+2CInferenceEngine-method'></span><span id='topic+jt.cliques+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Return the list of cliques containing the variables associated to each node of a junction tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jt.cliques(x)

## S4 method for signature 'InferenceEngine'
jt.cliques(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jt.cliques_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of cliques of the junction tree contained in the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.
</p>

<hr>
<h2 id='jt.cliques+26lt+3B-'>set the list of cliques of the junction tree of an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+jt.cliques+3C-'></span><span id='topic+jt.cliques+3C-+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>Add to the InferenceEngine a list containing the cliques of variables composing the nodes of the junction tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jt.cliques(x) &lt;- value

## S4 replacement method for signature 'InferenceEngine'
jt.cliques(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jt.cliques+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="jt.cliques+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the list of cliques of the junction tree contained in the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='junction.tree'>get the junction tree of an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+junction.tree'></span><span id='topic+junction.tree+2CInferenceEngine-method'></span><span id='topic+junction.tree+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Return the adjacency matrix representing the junction tree computed for a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>junction.tree(x)

## S4 method for signature 'InferenceEngine'
junction.tree(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="junction.tree_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rows and columns are named after the (variables in the) cliques that each node of the junction tree represent.
</p>


<h3>Value</h3>

<p>the junction tree contained in the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build.junction.tree">build.junction.tree</a></code>
</p>

<hr>
<h2 id='junction.tree+26lt+3B-'>set the junction tree of an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+junction.tree+3C-'></span><span id='topic+junction.tree+3C-+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>Set the adjacency matrix of the junction tree computed for a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>junction.tree(x) &lt;- value

## S4 replacement method for signature 'InferenceEngine'
junction.tree(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="junction.tree+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="junction.tree+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the junction tree to be inserted in the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='knn.impute'>Perform imputation of a data frame using k-NN.</h2><span id='topic+knn.impute'></span>

<h3>Description</h3>

<p>Perform imputation of missing data in a data frame using the k-Nearest Neighbour algorithm.
For discrete variables we use the mode, for continuous variables the median value is instead taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn.impute(
  data,
  k = 10,
  cat.var = 1:ncol(data),
  to.impute = 1:nrow(data),
  using = 1:nrow(data)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn.impute_+3A_data">data</code></td>
<td>
<p>a numerical matrix.</p>
</td></tr>
<tr><td><code id="knn.impute_+3A_k">k</code></td>
<td>
<p>number of neighbours to be used; for categorical variables 
the mode of the neighbours is used, for continuous variables 
the median value is used instead. Default: 10.</p>
</td></tr>
<tr><td><code id="knn.impute_+3A_cat.var">cat.var</code></td>
<td>
<p>vector containing the indices of the variables to be 
considered as categorical. Default: all variables.</p>
</td></tr>
<tr><td><code id="knn.impute_+3A_to.impute">to.impute</code></td>
<td>
<p>vector indicating which rows of the dataset are to be imputed. 
Default: impute all rows.</p>
</td></tr>
<tr><td><code id="knn.impute_+3A_using">using</code></td>
<td>
<p>vector indicating which rows of the dataset are to be used 
to search for neighbours. Default: use all rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>imputed matrix.
</p>

<hr>
<h2 id='layering'>return the layering of the nodes.</h2><span id='topic+layering'></span><span id='topic+layering+2CBN-method'></span><span id='topic+layering+2CBN'></span>

<h3>Description</h3>

<p>Compute the topological ordering of the nodes of a network, in order to divide the network in layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layering(x)

## S4 method for signature 'BN'
layering(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layering_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing layers the nodes can be divided into.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset("file.header", "file.data")
x &lt;- BN(dataset)
x &lt;- learn.network(x, dataset)
layering(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='learn.dynamic.network'>learn a dynamic network (structure and parameters) of a <a href="#topic+BN">BN</a> from a <a href="#topic+BNDataset">BNDataset</a>.</h2><span id='topic+learn.dynamic.network'></span><span id='topic+learn.dynamic.network+2CBN-method'></span><span id='topic+learn.dynamic.network+2CBN'></span><span id='topic+learn.dynamic.network+2CBNDataset-method'></span><span id='topic+learn.dynamic.network+2CBNDataset'></span>

<h3>Description</h3>

<p>Learn a dynamic network (structure and parameters) of a <a href="#topic+BN">BN</a> from a <a href="#topic+BNDataset">BNDataset</a> (see the <code>Details</code> section).
This method is a wrapper for <code><a href="#topic+learn.network">learn.network</a></code> to simplify the learning of a dynamic network.
It provides an automated generation of the <code>layering</code> required to represent the set of time constraints
encoded in a dynamic network. In this function, it is assumed that the dataset contains the observations for each variable
in all the time steps:
<code>V_1^{t_1}, V_2^{t_1}, V_n^{t_1}, V_1^{t_2}, ... , V_n^{t_k}</code>.
Variables in time step <code>j</code> can be parents for any variable in time steps <code>k&gt;=j</code>, but not for variables <code>i&lt;j</code>.
If a layering is provided for a time step, it is valid in each time step, and not throughout the whole dynamic network;
a global layering can however be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn.dynamic.network(x, ...)

## S4 method for signature 'BN'
learn.dynamic.network(
  x,
  y = NULL,
  num.time.steps = num.time.steps(y),
  algo = "mmhc",
  scoring.func = "BDeu",
  initial.network = NULL,
  alpha = 0.05,
  ess = 1,
  bootstrap = FALSE,
  layering = c(),
  max.fanin = num.variables(y) - 1,
  max.fanin.layers = NULL,
  max.parents = num.variables(y) - 1,
  max.parents.layers = NULL,
  layer.struct = NULL,
  cont.nodes = c(),
  use.imputed.data = FALSE,
  use.cpc = TRUE,
  mandatory.edges = NULL,
  ...
)

## S4 method for signature 'BNDataset'
learn.dynamic.network(
  x,
  num.time.steps = num.time.steps(x),
  algo = "mmhc",
  scoring.func = "BDeu",
  initial.network = NULL,
  alpha = 0.05,
  ess = 1,
  bootstrap = FALSE,
  layering = c(),
  max.fanin = num.variables(x) - 1,
  max.fanin.layers = NULL,
  max.parents = num.variables(x) - 1,
  max.parents.layers = NULL,
  layer.struct = NULL,
  cont.nodes = c(),
  use.imputed.data = FALSE,
  use.cpc = TRUE,
  mandatory.edges = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn.dynamic.network_+3A_x">x</code></td>
<td>
<p>can be a <code><a href="#topic+BN">BN</a></code> or a <code><a href="#topic+BNDataset">BNDataset</a></code>. If <code>x</code> is a <code><a href="#topic+BN">BN</a></code>,
then also the <code>dataset</code> parameter must be given.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_...">...</code></td>
<td>
<p>potential further arguments for methods.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_y">y</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object, to be provided only if <code>x</code> is a <code><a href="#topic+BN">BN</a></code>.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_num.time.steps">num.time.steps</code></td>
<td>
<p>the number of time steps to be represented in the dynamic BN.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_algo">algo</code></td>
<td>
<p>the algorithm to use. Currently, one among <code>sm</code> (Silander-Myllymaki), <code>mmpc</code>
(Max-Min Parent-and-Children), <code>mmhc</code> (Max-Min Hill Climbing, default), <code>hc</code>
(Hill Climbing) and <code>sem</code> (Structural Expectation Maximization).</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_scoring.func">scoring.func</code></td>
<td>
<p>the scoring function to use. Currently, one among
<code>BDeu</code>, <code>AIC</code>, <code>BIC</code>.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_initial.network">initial.network</code></td>
<td>
<p>network structure to be used as starting point for structure search.
Can take different values:
a <code>BN</code> object, a matrix containing the adjacency matrix of the structure of the network,
or the string <code>random.chain</code> to sample a random chain as starting point.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_alpha">alpha</code></td>
<td>
<p>confidence threshold (only for <code>mmhc</code>).</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_ess">ess</code></td>
<td>
<p>Equivalent Sample Size value.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_bootstrap">bootstrap</code></td>
<td>
<p><code>TRUE</code> to use bootstrap samples.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_layering">layering</code></td>
<td>
<p>vector containing the layers each node belongs to.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_max.fanin">max.fanin</code></td>
<td>
<p>maximum number of parents for each node (only for <code>hc</code>, <code>mmhc</code>).</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_max.fanin.layers">max.fanin.layers</code></td>
<td>
<p>matrix of available parents in each layer (only for <code>sm</code> &ndash;
DEPRECATED, use <code>max.parents.layers</code> instead).</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_max.parents">max.parents</code></td>
<td>
<p>maximum number of parents for each node (for <code>sm</code>, <code>hc</code>, <code>mmhc</code>).</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_max.parents.layers">max.parents.layers</code></td>
<td>
<p>matrix of available parents in each layer (only for <code>sm</code>).</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_layer.struct">layer.struct</code></td>
<td>
<p><code>0/1</code> matrix for indicating which layers can contain parent nodes
for nodes in a layer (only for <code>mmhc</code>, <code>mmpc</code>).</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_cont.nodes">cont.nodes</code></td>
<td>
<p>vector containing the index of continuous variables.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_use.imputed.data">use.imputed.data</code></td>
<td>
<p><code>TRUE</code> to learn the structure from the imputed dataset
(if available, a check is performed). Default is to use raw dataset</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_use.cpc">use.cpc</code></td>
<td>
<p>(when using <code>mmhc</code>) compute Candidate Parent-and-Children sets instead of 
starting the Hill Climbing from an empty graph.</p>
</td></tr>
<tr><td><code id="learn.dynamic.network_+3A_mandatory.edges">mandatory.edges</code></td>
<td>
<p>binary matrix, where a <code>1</code> in cell <code>[i,j]</code>
indicates that an edge from node <code>i</code> to node <code>j</code> must be present
in the final network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The other parameters available are the ones of <code><a href="#topic+learn.network">learn.network</a></code>, refer to the documentation of that function 
for more details. See also the documentation for <code><a href="#topic+learn.structure">learn.structure</a></code> and <code><a href="#topic+learn.params">learn.params</a></code> for more informations.
</p>


<h3>Value</h3>

<p>new <code><a href="#topic+BN">BN</a></code> object with structure (DAG) and conditional probabilities
as learnt from the given dataset.
</p>


<h3>See Also</h3>

<p>learn.network learn.structure learn.params
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mydataset &lt;- BNDataset("data.file", "header.file")

net &lt;- learn.dynamic.network(mydataset, num.time.steps=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='learn.network'>learn a network (structure and parameters) of a <a href="#topic+BN">BN</a> from a <a href="#topic+BNDataset">BNDataset</a>.</h2><span id='topic+learn.network'></span><span id='topic+learn.network+2CBN-method'></span><span id='topic+learn.network+2CBN'></span><span id='topic+learn.network+2CBNDataset-method'></span><span id='topic+learn.network+2CBNDataset'></span>

<h3>Description</h3>

<p>Learn a network (structure and parameters) of a <a href="#topic+BN">BN</a> from a <a href="#topic+BNDataset">BNDataset</a> (see the <code>Details</code> section).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn.network(x, ...)

## S4 method for signature 'BN'
learn.network(
  x,
  y = NULL,
  algo = "mmhc",
  scoring.func = "BDeu",
  initial.network = NULL,
  alpha = 0.05,
  ess = 1,
  bootstrap = FALSE,
  layering = c(),
  max.fanin = num.variables(y) - 1,
  max.fanin.layers = NULL,
  max.parents = num.variables(y) - 1,
  max.parents.layers = NULL,
  layer.struct = NULL,
  cont.nodes = c(),
  use.imputed.data = FALSE,
  use.cpc = TRUE,
  mandatory.edges = NULL,
  ...
)

## S4 method for signature 'BNDataset'
learn.network(
  x,
  algo = "mmhc",
  scoring.func = "BDeu",
  initial.network = NULL,
  alpha = 0.05,
  ess = 1,
  bootstrap = FALSE,
  layering = c(),
  max.fanin = num.variables(x) - 1,
  max.fanin.layers = NULL,
  max.parents = num.variables(x) - 1,
  max.parents.layers = NULL,
  layer.struct = NULL,
  cont.nodes = c(),
  use.imputed.data = FALSE,
  use.cpc = TRUE,
  mandatory.edges = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn.network_+3A_x">x</code></td>
<td>
<p>can be a <code><a href="#topic+BN">BN</a></code> or a <code><a href="#topic+BNDataset">BNDataset</a></code>. If <code>x</code> is a <code><a href="#topic+BN">BN</a></code>,
then also the <code>dataset</code> parameter must be given.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_...">...</code></td>
<td>
<p>potential further arguments for methods.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_y">y</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object, to be provided only if <code>x</code> is a <code><a href="#topic+BN">BN</a></code>.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_algo">algo</code></td>
<td>
<p>the algorithm to use. Currently, one among <code>sm</code> (Silander-Myllymaki), <code>mmpc</code>
(Max-Min Parent-and-Children), <code>mmhc</code> (Max-Min Hill Climbing, default), <code>hc</code>
(Hill Climbing) and <code>sem</code> (Structural Expectation Maximization).</p>
</td></tr>
<tr><td><code id="learn.network_+3A_scoring.func">scoring.func</code></td>
<td>
<p>the scoring function to use. Currently, one among
<code>BDeu</code>, <code>AIC</code>, <code>BIC</code>.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_initial.network">initial.network</code></td>
<td>
<p>network structure to be used as starting point for structure search.
Can take different values:
a <code>BN</code> object, a matrix containing the adjacency matrix of the structure of the network,
or the string <code>random.chain</code> to sample a random chain as starting point.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_alpha">alpha</code></td>
<td>
<p>confidence threshold (only for <code>mmhc</code>).</p>
</td></tr>
<tr><td><code id="learn.network_+3A_ess">ess</code></td>
<td>
<p>Equivalent Sample Size value.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_bootstrap">bootstrap</code></td>
<td>
<p><code>TRUE</code> to use bootstrap samples.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_layering">layering</code></td>
<td>
<p>vector containing the layers each node belongs to.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_max.fanin">max.fanin</code></td>
<td>
<p>maximum number of parents for each node (only for <code>hc</code>, <code>mmhc</code>).</p>
</td></tr>
<tr><td><code id="learn.network_+3A_max.fanin.layers">max.fanin.layers</code></td>
<td>
<p>matrix of available parents in each layer (only for <code>sm</code> &ndash;
DEPRECATED, use <code>max.parents.layers</code> instead).</p>
</td></tr>
<tr><td><code id="learn.network_+3A_max.parents">max.parents</code></td>
<td>
<p>maximum number of parents for each node (for <code>sm</code>, <code>hc</code>, <code>mmhc</code>).</p>
</td></tr>
<tr><td><code id="learn.network_+3A_max.parents.layers">max.parents.layers</code></td>
<td>
<p>matrix of available parents in each layer (only for <code>sm</code>).</p>
</td></tr>
<tr><td><code id="learn.network_+3A_layer.struct">layer.struct</code></td>
<td>
<p><code>0/1</code> matrix for indicating which layers can contain parent nodes
for nodes in a layer (only for <code>mmhc</code>, <code>mmpc</code>).</p>
</td></tr>
<tr><td><code id="learn.network_+3A_cont.nodes">cont.nodes</code></td>
<td>
<p>vector containing the index of continuous variables.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_use.imputed.data">use.imputed.data</code></td>
<td>
<p><code>TRUE</code> to learn the structure from the imputed dataset
(if available, a check is performed). Default is to use raw dataset</p>
</td></tr>
<tr><td><code id="learn.network_+3A_use.cpc">use.cpc</code></td>
<td>
<p>(when using <code>mmhc</code>) compute Candidate Parent-and-Children sets instead of 
starting the Hill Climbing from an empty graph.</p>
</td></tr>
<tr><td><code id="learn.network_+3A_mandatory.edges">mandatory.edges</code></td>
<td>
<p>binary matrix, where a <code>1</code> in cell <code>[i,j]</code>
indicates that an edge from node <code>i</code> to node <code>j</code> must be present
in the final network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Learn the structure (the directed acyclic graph) of a <code><a href="#topic+BN">BN</a></code> object according to a <code><a href="#topic+BNDataset">BNDataset</a></code>.
We provide five algorithms for learning the structure of the network, that can be chosen with the <code>algo</code> parameter.
The first one is the Silander-Myllym\&quot;aki (<code>sm</code>)
exact search-and-score algorithm, that performs a complete evaluation of the search space in order to discover
the best network; this algorithm may take a very long time, and can be inapplicable when discovering networks
with more than 25&ndash;30 nodes. Even for small networks, users are strongly encouraged to provide
meaningful parameters such as the layering of the nodes, or the maximum number of parents &ndash; refer to the 
documentation in package manual for more details on the method parameters.
</p>
<p>The second method is the constraint-based Max-Min Parents-and-Children (<code>mmpc</code>), that returns the skeleton of the network.
Given the possible presence of loops, due to the non-directionality of the edges discovered, no parameter learning
is possible using this algorithm. Also note that in the case of a very dense network and lots of obsevations, the statistical evaluation
of the search space may take a long time. Also for this algorithm there are parameters that may need to be tuned,
mainly the confidence threshold of the statistical pruning. Please refer to the rest of this documentation for their explanation.
</p>
<p>The third algorithm is another heuristic, the Hill-Climbing (<code>hc</code>). It can start from the complete space of possibilities
(default) or from a reduced subset of possible edges, using the <code>cpc</code> argument.
</p>
<p>The fourth algorithm (and the default one) is the Max-Min Hill-Climbing heuristic (<code>mmhc</code>), that performs a statistical
sieving of the search space followed by a greedy evaluation, by combining the MMPC and the HC algorithms.
It is considerably faster than the complete method, at the cost of a (likely)
lower quality. As for MMPC, the computational time depends on the density of the network, the number of observations and
the tuning of the parameters.
</p>
<p>The fifth method is the Structural Expectation-Maximization (<code>sem</code>) algorithm,
for learning a network from a dataset with missing values. It iterates a sequence of Expectation-Maximization (in order to &ldquo;fill in&rdquo;
the holes in the dataset) and structure learning from the guessed dataset, until convergence. The structure learning used inside SEM,
due to computational reasons, is MMHC. Convergence of SEM can be controlled with the parameters <code>struct.threshold</code>
and <code>param.threshold</code>, for the structure and the parameter convergence, respectively.
</p>
<p>Search-and-score methods also need a scoring function to compute an estimated measure of each configuration of nodes.
We provide three of the most popular scoring functions, <code>BDeu</code> (Bayesian-Dirichlet equivalent uniform, default),
<code>AIC</code> (Akaike Information Criterion) and <code>BIC</code> (Bayesian Information Criterion). The scoring function
can be chosen using the <code>scoring.func</code> parameter.
</p>
<p>Structure learning sets the <code>dag</code> field of the <code>BN</code> under study, unless bootstrap or the <code>mmpc</code> algorithm
are employed. In these cases, given the possible presence of loops, the <code>wpdag</code> field is set.
</p>
<p>In case of missing data, the default behaviour (with no other indication from the user)
is to learn the structure using <code>mmhc</code> starting from the raw dataset, using only the
available cases with no imputation.
</p>
<p>In case of learning from a dataset containing observations of a dynamic system, <code><a href="#topic+learn.dynamic.network">learn.dynamic.network</a></code>
will be employed.
</p>
<p>Then, the parameters of the network are learnt using MAP (Maximum A Posteriori) estimation (when not using bootstrap or <code>mmpc</code>).
</p>
<p>See documentation for <code><a href="#topic+learn.structure">learn.structure</a></code> and <code><a href="#topic+learn.params">learn.params</a></code> for more informations.
</p>


<h3>Value</h3>

<p>new <code><a href="#topic+BN">BN</a></code> object with structure (DAG) and conditional probabilities
as learnt from the given dataset.
</p>


<h3>See Also</h3>

<p>learn.structure learn.params learn.dynamic.network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mydataset &lt;- BNDataset("data.file", "header.file")

# starting from a BN
net &lt;- BN(mydataset)
net &lt;- learn.network(net, mydataset)

# start directly from the dataset
net &lt;- learn.network(mydataset)

## End(Not run)

</code></pre>

<hr>
<h2 id='learn.params'>learn the parameters of a <a href="#topic+BN">BN</a>.</h2><span id='topic+learn.params'></span><span id='topic+learn.params+2CBN+2CBNDataset-method'></span><span id='topic+learn.params+2CBN+2CBNDataset'></span>

<h3>Description</h3>

<p>Learn the parameters of a <a href="#topic+BN">BN</a> object according to a <a href="#topic+BNDataset">BNDataset</a>
using MAP (Maximum A Posteriori) estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn.params(bn, dataset, ess = 1, use.imputed.data = F)

## S4 method for signature 'BN,BNDataset'
learn.params(bn, dataset, ess = 1, use.imputed.data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn.params_+3A_bn">bn</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
<tr><td><code id="learn.params_+3A_dataset">dataset</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="learn.params_+3A_ess">ess</code></td>
<td>
<p>Equivalent Sample Size value.</p>
</td></tr>
<tr><td><code id="learn.params_+3A_use.imputed.data">use.imputed.data</code></td>
<td>
<p>use imputed data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameter learning is not possible in case of networks learnt using the <code>mmpc</code> algorithm,
or from bootstrap samples, as there may be loops.
</p>


<h3>Value</h3>

<p>new <code><a href="#topic+BN">BN</a></code> object with conditional probabilities.
</p>


<h3>See Also</h3>

<p>learn.network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## first create a BN and learn its structure from a dataset
dataset &lt;- BNDataset("file.header", "file.data")
bn &lt;- BN(dataset)
bn &lt;- learn.structure(bn, dataset)
bn &lt;- learn.params(bn, dataset, ess=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='learn.structure'>learn the structure of a network.</h2><span id='topic+learn.structure'></span><span id='topic+learn.structure+2CBN+2CBNDataset-method'></span><span id='topic+learn.structure+2CBN+2CBNDataset'></span>

<h3>Description</h3>

<p>Learn the structure (the directed acyclic graph) of a <code><a href="#topic+BN">BN</a></code> object according to a <code><a href="#topic+BNDataset">BNDataset</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn.structure(
  bn,
  dataset,
  algo = "mmhc",
  scoring.func = "BDeu",
  initial.network = NULL,
  alpha = 0.05,
  ess = 1,
  bootstrap = FALSE,
  layering = c(),
  max.fanin = num.variables(dataset),
  max.fanin.layers = NULL,
  max.parents = num.variables(dataset),
  max.parents.layers = NULL,
  layer.struct = NULL,
  cont.nodes = c(),
  use.imputed.data = FALSE,
  use.cpc = TRUE,
  mandatory.edges = NULL,
  ...
)

## S4 method for signature 'BN,BNDataset'
learn.structure(
  bn,
  dataset,
  algo = "mmhc",
  scoring.func = "BDeu",
  initial.network = NULL,
  alpha = 0.05,
  ess = 1,
  bootstrap = FALSE,
  layering = c(),
  max.fanin = num.variables(dataset) - 1,
  max.fanin.layers = NULL,
  max.parents = num.variables(dataset) - 1,
  max.parents.layers = NULL,
  layer.struct = NULL,
  cont.nodes = c(),
  use.imputed.data = FALSE,
  use.cpc = TRUE,
  mandatory.edges = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn.structure_+3A_bn">bn</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_dataset">dataset</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_algo">algo</code></td>
<td>
<p>the algorithm to use. Currently, one among <code>sm</code> (Silander-Myllymaki), <code>mmpc</code>
(Max-Min Parent-and-Children), <code>mmhc</code> (Max-Min Hill Climbing, default), <code>hc</code>
(Hill Climbing) and <code>sem</code> (Structural Expectation Maximization).</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_scoring.func">scoring.func</code></td>
<td>
<p>the scoring function to use. Currently, one among <code>BDeu</code>, <code>AIC</code>, <code>BIC</code>.</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_initial.network">initial.network</code></td>
<td>
<p>network srtructure to be used as starting point for structure search.
Can take different values:
a <code>BN</code> object, a matrix containing the adjacency matrix of the structure of the network,
or the string <code>random.chain</code> to sample a random chain as starting point.</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_alpha">alpha</code></td>
<td>
<p>confidence threshold (only for <code>mmhc</code>).</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_ess">ess</code></td>
<td>
<p>Equivalent Sample Size value.</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_bootstrap">bootstrap</code></td>
<td>
<p><code>TRUE</code> to use bootstrap samples.</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_layering">layering</code></td>
<td>
<p>vector containing the layers each node belongs to (only for <code>sm</code>).</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_max.fanin">max.fanin</code></td>
<td>
<p>maximum number of parents for each node (only for <code>hc</code>, <code>mmhc</code>).</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_max.fanin.layers">max.fanin.layers</code></td>
<td>
<p>matrix of available parents in each layer (only for <code>sm</code> &ndash;
DEPRECATED, use <code>max.parents.layers</code> instead).</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_max.parents">max.parents</code></td>
<td>
<p>maximum number of parents for each node (for <code>sm</code>, <code>hc</code>, <code>mmhc</code>).</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_max.parents.layers">max.parents.layers</code></td>
<td>
<p>matrix of available parents in each layer (only for <code>sm</code>).</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_layer.struct">layer.struct</code></td>
<td>
<p><code>0/1</code> matrix for indicating which layers can contain parent nodes
for nodes in a layer (only for <code>mmhc</code>, <code>mmpc</code>).</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_cont.nodes">cont.nodes</code></td>
<td>
<p>vector containing the index of continuous variables.</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_use.imputed.data">use.imputed.data</code></td>
<td>
<p><code>TRUE</code> to learn the structure from the imputed dataset
(if available, a check is performed). Default is to use raw dataset</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_use.cpc">use.cpc</code></td>
<td>
<p>(when using <code>mmhc</code>) compute Candidate Parent-and-Children sets instead of 
starting the Hill Climbing from an empty graph.</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_mandatory.edges">mandatory.edges</code></td>
<td>
<p>binary matrix, where a <code>1</code> in cell <code>[i,j]</code>
indicates that an edge from node <code>i</code> to node <code>j</code> must be present
in the final network.</p>
</td></tr>
<tr><td><code id="learn.structure_+3A_...">...</code></td>
<td>
<p>potential further arguments for method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We provide three algorithms in order to learn the structure of the network, that can be chosen with the <code>algo</code> parameter.
The first is the Silander-Myllym\&quot;aki (<code>sm</code>)
exact search-and-score algorithm, that performs a complete evaluation of the search space in order to discover
the best network; this algorithm may take a very long time, and can be inapplicable when discovering networks
with more than 25&ndash;30 nodes. Even for small networks, users are strongly encouraged to provide
meaningful parameters such as the layering of the nodes, or the maximum number of parents &ndash; refer to the 
documentation in package manual for more details on the method parameters.
</p>
<p>The second method is the constraint-based Max-Min Parents-and-Children (<code>mmpc</code>), that returns the skeleton of the network.
Given the possible presence of loops, due to the non-directionality of the edges discovered, no parameter learning
is possible using this algorithm. Also note that in the case of a very dense network and lots of obsevations, the statistical evaluation
of the search space may take a long time. Also for this algorithm there are parameters that may need to be tuned,
mainly the confidence threshold of the statistical pruning. Please refer to the rest of this documentation for their explanation.
</p>
<p>The third algorithm is another heuristic, the Hill-Climbing (<code>hc</code>). It can start from the complete space of possibilities
(default) or from a reduced subset of possible edges, using the <code>cpc</code> argument.
</p>
<p>The fourth algorithm (and the default one) is the Max-Min Hill-Climbing heuristic (<code>mmhc</code>), that performs a statistical
sieving of the search space followed by a greedy evaluation, by combining the MMPC and the HC algorithms.
It is considerably faster than the complete method, at the cost of a (likely)
lower quality. As for MMPC, the computational time depends on the density of the network, the number of observations and
the tuning of the parameters.
</p>
<p>The fifth method is the Structural Expectation-Maximization (<code>sem</code>) algorithm,
for learning a network from a dataset with missing values. It iterates a sequence of Expectation-Maximization (in order to &ldquo;fill in&rdquo;
the holes in the dataset) and structure learning from the guessed dataset, until convergence. The structure learning used inside SEM,
due to computational reasons, is MMHC. Convergence of SEM can be controlled with the parameters <code>struct.threshold</code>
and <code>param.threshold</code>, for the structure and the parameter convergence, respectively.
for learning a network from a dataset with missing values. It iterates a sequence of Expectation-Maximization (in order to &ldquo;fill in&rdquo;
the holes in the dataset) and structure learning from the guessed dataset, until convergence. The structure learning used inside SEM,
due to computational reasons, is MMHC. Convergence of SEM can be controlled with the parameters <code>struct.threshold</code>
and <code>param.threshold</code>, for the structure and the parameter convergence, respectively.
</p>
<p>Search-and-score methods also need a scoring function to compute an estimated measure of each configuration of nodes.
We provide three of the most popular scoring functions, <code>BDeu</code> (Bayesian-Dirichlet equivalent uniform, default),
<code>AIC</code> (Akaike Information Criterion) and <code>BIC</code> (Bayesian Information Criterion). The scoring function
can be chosen using the <code>scoring.func</code> parameter.
</p>
<p>Structure learning sets the <code>dag</code> field of the <code>BN</code> under study, unless bootstrap or the <code>mmpc</code> algorithm
are employed. In these cases, given the possible presence of loops, the <code>wpdag</code> field is set.
</p>
<p>In case of missing data, the default behaviour (with no other indication from the user)
is to learn the structure using <code>mmhc</code> starting from the raw dataset.
</p>


<h3>Value</h3>

<p>new <code><a href="#topic+BN">BN</a></code> object with DAG.
</p>


<h3>See Also</h3>

<p>learn.network learn.dynamic.network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset("file.header", "file.data")
bn &lt;- BN(dataset)
# use MMHC
bn &lt;- learn.structure(bn, dataset, alpha=0.05, ess=1, bootstrap=FALSE)

# now use Silander-Myllymaki
layers &lt;- layering(bn)
mfl &lt;- as.matrix(read.table(header=F,
text='0 1 1 1 1 0 1 1 1 1 0 0 8 7 7 0 0 0 14 6 0 0 0 0 19'))
bn &lt;- learn.structure(bn, dataset, algo='sm', max.fanin=3, cont.nodes=c(),
                      layering=layers, max.fanin.layers=mfl, use.imputed.data=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='marginals'>compute the list of inferred marginals of a BN.</h2><span id='topic+marginals'></span><span id='topic+marginals+2CInferenceEngine-method'></span><span id='topic+marginals+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Given an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>, it returns a list containing the marginals for the variables
in the network, according to the propagated beliefs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginals(x, ...)

## S4 method for signature 'InferenceEngine'
marginals(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginals_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code></p>
</td></tr>
<tr><td><code id="marginals_+3A_...">...</code></td>
<td>
<p>potential further arguments of methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the marginals of each variable, as probability tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
eng &lt;- InferenceEngine(net)
marginals(eng)

## End(Not run)

</code></pre>

<hr>
<h2 id='name'>get name of an object.</h2><span id='topic+name'></span><span id='topic+name+2CBN-method'></span><span id='topic+name+2CBN'></span><span id='topic+name+2CBNDataset-method'></span><span id='topic+name+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the name of an object, of class <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+BNDataset">BNDataset</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name(x)

## S4 method for signature 'BN'
name(x)

## S4 method for signature 'BNDataset'
name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>name of the object.
</p>

<hr>
<h2 id='name+26lt+3B-'>set name of an object.</h2><span id='topic+name+3C-'></span><span id='topic+name+3C-+2CBN-method'></span><span id='topic+name+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the <code>name</code> slot of an object of type <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+BNDataset">BNDataset</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name(x) &lt;- value

## S4 replacement method for signature 'BN'
name(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
name(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="name+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the new name of the object.</p>
</td></tr>
</table>

<hr>
<h2 id='node.sizes'>get size of the variables of an object.</h2><span id='topic+node.sizes'></span><span id='topic+node.sizes+2CBN-method'></span><span id='topic+node.sizes+2CBN'></span><span id='topic+node.sizes+2CBNDataset-method'></span><span id='topic+node.sizes+2CBNDataset'></span>

<h3>Description</h3>

<p>Return a list containing the size of the variables of an object. It is the actual cardinality
of discrete variables, and the cardinality of the discretized variable for continuous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node.sizes(x)

## S4 method for signature 'BN'
node.sizes(x)

## S4 method for signature 'BNDataset'
node.sizes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node.sizes_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector contaning the size of each variable of the desired object.
</p>

<hr>
<h2 id='node.sizes+26lt+3B-'>set the size of variables of an object.</h2><span id='topic+node.sizes+3C-'></span><span id='topic+node.sizes+3C-+2CBN-method'></span><span id='topic+node.sizes+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the size of the variables of a BN or BNDataset object. It represents the actual cardinality
of discrete variables, and the cardinality of the discretized variable for continuous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node.sizes(x) &lt;- value

## S4 replacement method for signature 'BN'
node.sizes(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
node.sizes(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node.sizes+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="node.sizes+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>vector contaning the size of each variable of the object.</p>
</td></tr>
</table>

<hr>
<h2 id='num.boots'>get number of bootstrap samples of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+num.boots'></span><span id='topic+num.boots+2CBNDataset-method'></span><span id='topic+num.boots+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the number of bootstrap samples computed from a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.boots(x)

## S4 method for signature 'BNDataset'
num.boots(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.boots_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of bootstrap samples.
</p>

<hr>
<h2 id='num.boots+26lt+3B-'>set number of bootstrap samples of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+num.boots+3C-'></span><span id='topic+num.boots+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the length of the list of samples of a dataset computed using bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.boots(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
num.boots(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.boots+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="num.boots+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the number of bootstrap samples.</p>
</td></tr>
</table>

<hr>
<h2 id='num.items'>get number of items of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+num.items'></span><span id='topic+num.items+2CBNDataset-method'></span><span id='topic+num.items+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the number of items in a dataset, that is, the number of rows in its data slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.items(x)

## S4 method for signature 'BNDataset'
num.items(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.items_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of items of the desired dataset.
</p>

<hr>
<h2 id='num.items+26lt+3B-'>set number of items of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+num.items+3C-'></span><span id='topic+num.items+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the number of observed items (rows) in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.items(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
num.items(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.items+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="num.items+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>number of items of the desired dataset.</p>
</td></tr>
</table>

<hr>
<h2 id='num.nodes'>get number of nodes of an object.</h2><span id='topic+num.nodes'></span><span id='topic+num.nodes+2CBN-method'></span><span id='topic+num.nodes+2CBN'></span><span id='topic+num.nodes+2CInferenceEngine-method'></span><span id='topic+num.nodes+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Return the name of an object, of class <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.nodes(x)

## S4 method for signature 'BN'
num.nodes(x)

## S4 method for signature 'InferenceEngine'
num.nodes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.nodes_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of nodes of the desired object.
</p>

<hr>
<h2 id='num.nodes+26lt+3B-'>set number of nodes of an object.</h2><span id='topic+num.nodes+3C-'></span><span id='topic+num.nodes+3C-+2CBN-method'></span><span id='topic+num.nodes+3C-+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>Set the number of nodes of an object of type <code><a href="#topic+BN">BN</a></code> (number of nodes of the network)
or <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> (where parameter contains the number of nodes of the junction tree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.nodes(x) &lt;- value

## S4 replacement method for signature 'BN'
num.nodes(x) &lt;- value

## S4 replacement method for signature 'InferenceEngine'
num.nodes(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.nodes+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="num.nodes+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the number of nodes in the object.</p>
</td></tr>
</table>

<hr>
<h2 id='num.time.steps'>get number of time steps observed in a <code><a href="#topic+BN">BN</a></code> or a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+num.time.steps'></span><span id='topic+num.time.steps+2CBN-method'></span><span id='topic+num.time.steps+2CBN'></span><span id='topic+num.time.steps+2CBNDataset-method'></span><span id='topic+num.time.steps+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the number of time steps observed in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.time.steps(x)

## S4 method for signature 'BN'
num.time.steps(x)

## S4 method for signature 'BNDataset'
num.time.steps(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.time.steps_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> or a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of time steps.
</p>

<hr>
<h2 id='num.time.steps+26lt+3B-'>set number of time steps of a <code><a href="#topic+BN">BN</a></code> or a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+num.time.steps+3C-'></span><span id='topic+num.time.steps+3C-+2CBN-method'></span><span id='topic+num.time.steps+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the number of time steps of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.time.steps(x) &lt;- value

## S4 replacement method for signature 'BN'
num.time.steps(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
num.time.steps(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.time.steps+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> or a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="num.time.steps+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the number of time steps.</p>
</td></tr>
</table>

<hr>
<h2 id='num.variables'>get number of variables of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+num.variables'></span><span id='topic+num.variables+2CBNDataset-method'></span><span id='topic+num.variables+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the number of the variables contained in a dataset. This value corresponds to the value
of <code><a href="#topic+num.nodes">num.nodes</a></code> of a network built upon the same dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.variables(x)

## S4 method for signature 'BNDataset'
num.variables(x)

## S4 method for signature 'BNDataset'
num.variables(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.variables_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of variables of the desired dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.nodes">num.nodes</a></code>
</p>

<hr>
<h2 id='num.variables+26lt+3B-'>set number of variables of a <code><a href="#topic+BNDataset">BNDataset</a></code>.</h2><span id='topic+num.variables+3C-'></span><span id='topic+num.variables+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the number of variables observed in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.variables(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
num.variables(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.variables+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="num.variables+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>number of variables of the dataset.</p>
</td></tr>
</table>

<hr>
<h2 id='observations'>get the list of observations of an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+observations'></span><span id='topic+observations+2CInferenceEngine-method'></span><span id='topic+observations+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Return the list of observations added to an InferenceEngine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observations(x)

## S4 method for signature 'InferenceEngine'
observations(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="observations_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output is a list in the following format:
</p>

<dl>
<dt><code>observed.vars</code></dt><dd><p>vector of observed variables;</p>
</dd>
<dt><code>observed.vals</code></dt><dd><p>vector of values observed for the variables in <code>observed.vars</code> in the corresponding position.</p>
</dd>
</dl>



<h3>Value</h3>

<p>the list of observations of the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.
</p>

<hr>
<h2 id='observations+26lt+3B-'>set the list of observations of an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+observations+3C-'></span><span id='topic+observations+3C-+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>Add a list of observations to an InferenceEngine, using a list of observations composed by the two following vectors:
</p>

<dl>
<dt><code>observed.vars</code></dt><dd><p>vector of observed variables;</p>
</dd>
<dt><code>observed.vals</code></dt><dd><p>vector of values observed for the variables in <code>observed.vars</code> in the corresponding position.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>observations(x) &lt;- value

## S4 replacement method for signature 'InferenceEngine'
observations(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="observations+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="observations+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the list of observations of the <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replace previous list of observations, if present. In order to add evidence, and not just replace it,
one must use the <code><a href="#topic+add.observations+3C-">add.observations&lt;-</a></code> method.
</p>
<p>In case of multiple observations of the same variable, the last observation is the one used, as the most recent.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.observations+3C-">add.observations&lt;-</a></code>
</p>

<hr>
<h2 id='plot'>plot a <code><a href="#topic+BN">BN</a></code> as a picture.</h2><span id='topic+plot'></span><span id='topic+plot.BN'></span><span id='topic+plot+2CBN'></span><span id='topic+plot.BN+2CBN'></span>

<h3>Description</h3>

<p>plot a <code><a href="#topic+BN">BN</a></code> as a picture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BN'
plot(
  x,
  method = "default",
  use.node.names = TRUE,
  frac = 0.2,
  max.weight = max(dag(x)),
  node.size.lab = 14,
  node.col = rep("white", num.nodes(x)),
  plot.wpdag = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_+3A_method">method</code></td>
<td>
<p>either <code>default</code> of <code>qgraph</code>. The <code>default</code> method requires
the <code>Rgraphviz</code> package, while <code>qgraph</code> requires the <code>qgraph</code> package
and allows for a greater customization.</p>
</td></tr>
<tr><td><code id="plot_+3A_use.node.names">use.node.names</code></td>
<td>
<p><code>TRUE</code> if node names have to be printed. If <code>FALSE</code>, numbers are used instead.</p>
</td></tr>
<tr><td><code id="plot_+3A_frac">frac</code></td>
<td>
<p>minimum fraction [0,1] of presence of an edge to be plotted (used in case of <code>plot.wpdag=TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_max.weight">max.weight</code></td>
<td>
<p>maximum possible weight of an edge (used in case of <code>plot.wpdag=TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_node.size.lab">node.size.lab</code></td>
<td>
<p>font size for the node labels in the default mode.</p>
</td></tr>
<tr><td><code id="plot_+3A_node.col">node.col</code></td>
<td>
<p>list of (<code>R</code>) colors for the nodes.</p>
</td></tr>
<tr><td><code id="plot_+3A_plot.wpdag">plot.wpdag</code></td>
<td>
<p>if <code>TRUE</code> plot the network according to the WPDAG computed using bootstrap instead of the DAG.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>potential further arguments when using <code>method="qgraph"</code>. Please refer to the
<code>qgraph</code> documentation for the parameters available for the <code>qgraph()</code> method.</p>
</td></tr>
</table>

<hr>
<h2 id='print'>print a <code><a href="#topic+BN">BN</a></code>, <code><a href="#topic+BNDataset">BNDataset</a></code> or <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> to <code>stdout</code>.</h2><span id='topic+print'></span><span id='topic+print.BN'></span><span id='topic+print+2CBN'></span><span id='topic+print.BN+2CBN'></span><span id='topic+print.BNDataset'></span><span id='topic+print+2CBNDataset'></span><span id='topic+print.BNDataset+2CBNDataset'></span><span id='topic+print.InferenceEngine'></span><span id='topic+print+2CInferenceEngine'></span><span id='topic+print.InferenceEngine+2CInferenceEngine'></span>

<h3>Description</h3>

<p>print a <code><a href="#topic+BN">BN</a></code>, <code><a href="#topic+BNDataset">BNDataset</a></code> or <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> to <code>stdout</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BN'
print(x, ...)

## S3 method for class 'BNDataset'
print(x, show.raw.data = FALSE, show.imputed.data = FALSE, ...)

## S3 method for class 'InferenceEngine'
print(x, engine = "jt", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code>, <code><a href="#topic+BNDataset">BNDataset</a></code> or <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>potential other arguments.</p>
</td></tr>
<tr><td><code id="print_+3A_show.raw.data">show.raw.data</code></td>
<td>
<p>if <code>x</code> is a <code><a href="#topic+BNDataset">BNDataset</a></code>, print also raw dataset, if available.</p>
</td></tr>
<tr><td><code id="print_+3A_show.imputed.data">show.imputed.data</code></td>
<td>
<p>if <code>x</code> is a <code><a href="#topic+BNDataset">BNDataset</a></code>, print also imputed dataset, if available.</p>
</td></tr>
<tr><td><code id="print_+3A_engine">engine</code></td>
<td>
<p>if <code>x</code> is an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>, specify the inference engine to be shown. Currently only <code>engine = 'jt'</code> is supported.</p>
</td></tr>
</table>

<hr>
<h2 id='quantiles'>get the list of quantiles of an object.</h2><span id='topic+quantiles'></span><span id='topic+quantiles+2CBN-method'></span><span id='topic+quantiles+2CBN'></span><span id='topic+quantiles+2CBNDataset-method'></span><span id='topic+quantiles+2CBNDataset'></span>

<h3>Description</h3>

<p>Return the list of quantiles of a <code><a href="#topic+BN">BN</a></code> or a <code><a href="#topic+BNDataset">BNDataset</a></code>. It is set when a discretization needs to be performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantiles(x)

## S4 method for signature 'BN'
quantiles(x)

## S4 method for signature 'BNDataset'
quantiles(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantiles_+3A_x">x</code></td>
<td>
<p>a list of vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output is a list of <code><a href="#topic+num.nodes">num.nodes</a></code> vectors, one per variable. Each vector is <code>NULL</code>
if the corresponding variable is discrete in the original dataset, and contains the cut points for the quantiles
if the corresponding variable is continuous.
</p>


<h3>Value</h3>

<p>the list of quantiles of the <code><a href="#topic+BN">BN</a></code> of <code><a href="#topic+BNDataset">BNDataset</a></code>.
</p>

<hr>
<h2 id='quantiles+26lt+3B-'>set the list of quantiles of an object.</h2><span id='topic+quantiles+3C-'></span><span id='topic+quantiles+3C-+2CBN-method'></span><span id='topic+quantiles+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the list of quantiles of a <code><a href="#topic+BN">BN</a></code> or a <code><a href="#topic+BNDataset">BNDataset</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantiles(x) &lt;- value

## S4 replacement method for signature 'BN'
quantiles(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
quantiles(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantiles+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
<tr><td><code id="quantiles+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a list of vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is used when a discretization needs to be performed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantiles">quantiles</a></code>
</p>

<hr>
<h2 id='raw.data'>get raw data of a BNDataset.</h2><span id='topic+raw.data'></span><span id='topic+raw.data+2CBNDataset-method'></span><span id='topic+raw.data+2CBNDataset'></span>

<h3>Description</h3>

<p>Return raw data contained in a <code><a href="#topic+BNDataset">BNDataset</a></code> object, if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw.data(x)

## S4 method for signature 'BNDataset'
raw.data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw.data_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+has.raw.data">has.raw.data</a></code>, <code><a href="#topic+has.imputed.data">has.imputed.data</a></code>
</p>

<hr>
<h2 id='raw.data+26lt+3B-'>add raw data.</h2><span id='topic+raw.data+3C-'></span><span id='topic+raw.data+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Insert raw data in a <code><a href="#topic+BNDataset">BNDataset</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw.data(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
raw.data(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw.data+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>.</p>
</td></tr>
<tr><td><code id="raw.data+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a matrix of integers containing a dataset.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+has.raw.data">has.raw.data</a></code>, <code><a href="#topic+raw.data">raw.data</a></code>, <code><a href="#topic+read.dataset">read.dataset</a></code>
</p>

<hr>
<h2 id='read.bif'>Read a network from a <code>.bif</code> file.</h2><span id='topic+read.bif'></span><span id='topic+read.bif+2Ccharacter-method'></span><span id='topic+read.bif+2Ccharacter'></span>

<h3>Description</h3>

<p>Read a network described in a <code>.bif</code>-formatted file, and
build a <code><a href="#topic+BN">BN</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.bif(x)

## S4 method for signature 'character'
read.bif(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.bif_+3A_x">x</code></td>
<td>
<p>the <code>.bif</code> file, with absolute/relative position.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method relies on a coherent ordering of variable values and parameters in the file.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+BN">BN</a></code> object.
</p>

<hr>
<h2 id='read.dataset'>Read a dataset from file.</h2><span id='topic+read.dataset'></span><span id='topic+read.dataset+2CBNDataset+2Ccharacter+2Ccharacter-method'></span><span id='topic+read.dataset+2CBNDataset+2Ccharacter+2Ccharacter'></span>

<h3>Description</h3>

<p>There are two ways to build a BNDataset: using two files containing respectively header informations
and data, and manually providing the data table and the related header informations
(variable names, cardinality and discreteness).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dataset(
  object,
  data.file,
  header.file,
  data.with.header = FALSE,
  na.string.symbol = "?",
  sep.symbol = "",
  starts.from = 1,
  num.time.steps = 1
)

## S4 method for signature 'BNDataset,character,character'
read.dataset(
  object,
  data.file,
  header.file,
  data.with.header = FALSE,
  na.string.symbol = "?",
  sep.symbol = "",
  starts.from = 1,
  num.time.steps = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.dataset_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+BNDataset">BNDataset</a></code> object.</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_data.file">data.file</code></td>
<td>
<p>the <code>data</code> file.</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_header.file">header.file</code></td>
<td>
<p>the <code>header</code> file.</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_data.with.header">data.with.header</code></td>
<td>
<p><code>TRUE</code> if the first row of <code>dataset</code> file is an header (e.g. it contains the variable names).</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_na.string.symbol">na.string.symbol</code></td>
<td>
<p>character that denotes <code>NA</code> in the dataset.</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_sep.symbol">sep.symbol</code></td>
<td>
<p>separator among values in the dataset.</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_starts.from">starts.from</code></td>
<td>
<p>starting value for entries in the dataset (observed values, default is 1).</p>
</td></tr>
<tr><td><code id="read.dataset_+3A_num.time.steps">num.time.steps</code></td>
<td>
<p>number of instants composing the observations (1, unless it is a dynamic system).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key informations needed are:
1. the data;
2. the state of variables (discrete or continuous);
3. the names of the variables;
4. the cardinalities of the variables (if discrete), or the number of levels they have to be quantized into
(if continuous). 
Names and cardinalities/leves can be guessed by looking at the data, but it is strongly advised to provide
_all_ of the informations, in order to avoid problems later on during the execution.
</p>
<p>Data can be provided in form of data.frame or matrix. It can contain NAs. By default, NAs are indicated with '?';
to specify a different character for NAs, it is possible to provide also the <code>na.string.symbol</code> parameter.
The values contained in the data have to be numeric (real for continuous variables, integer for discrete ones).
The default range of values for a discrete variable <code>X</code> is <code>[1,|X|]</code>, with <code>|X|</code> being
the cardinality of <code>X</code>. The same applies for the levels of quantization for continuous variables.
If the value ranges for the data are different from the expected ones, it is possible to specify a different
starting value (for the whole dataset) with the <code>starts.from</code> parameter. E.g. by <code>starts.from=0</code>
we assume that the values of the variables in the dataset have range <code>[0,|X|-1]</code>.
Please keep in mind that the internal representation of bnstruct starts from 1,
and the original starting values are then lost. 
</p>
<p>It is possible to use two files, one for the data and one for the metadata,
instead of providing manually all of the info. 
bnstruct requires the data files to be in a format subsequently described.
The actual data has to be in (a text file containing data in) tabular format, one tuple per row,
with the values for each variable separated by a space or a tab. Values for each variable have to be
numbers, starting from <code>1</code> in case of discrete variables.
Data files can have a first row containing the names of the corresponding variables.
</p>
<p>In addition to the data file, a header file containing additional informations can also be provided.
An header file has to be composed by three rows of tab-delimited values:
1. list of names of the variables, in the same order of the data file;
2. a list of integers representing the cardinality of the variables, in case of discrete variables,
or the number of levels each variable has to be quantized in, in case of continuous variables;
3. a list that indicates, for each variable, if the variable is continuous
(<code>c</code> or <code>C</code>), and thus has to be quantized before learning,
or discrete (<code>d</code> or <code>D</code>).
</p>


<h3>See Also</h3>

<p>BNDataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset()
dataset &lt;- read.dataset(dataset, "file.data", "file.header")

## End(Not run)

</code></pre>

<hr>
<h2 id='read.dsc'>Read a network from a <code>.dsc</code> file.</h2><span id='topic+read.dsc'></span><span id='topic+read.dsc+2Ccharacter-method'></span><span id='topic+read.dsc+2Ccharacter'></span>

<h3>Description</h3>

<p>Read a network described in a <code>.dsc</code>-formatted file, and
build a <code><a href="#topic+BN">BN</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dsc(x)

## S4 method for signature 'character'
read.dsc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.dsc_+3A_x">x</code></td>
<td>
<p>the <code>.dsc</code> file, with absolute/relative position.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method relies on a coherent ordering of variable values and parameters in the file.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+BN">BN</a></code> object.
</p>

<hr>
<h2 id='read.net'>Read a network from a <code>.net</code> file.</h2><span id='topic+read.net'></span><span id='topic+read.net+2Ccharacter-method'></span><span id='topic+read.net+2Ccharacter'></span>

<h3>Description</h3>

<p>Read a network described in a <code>.net</code>-formatted file, and
build a <code><a href="#topic+BN">BN</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.net(x)

## S4 method for signature 'character'
read.net(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.net_+3A_x">x</code></td>
<td>
<p>the <code>.net</code> file, with absolute/relative position.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method relies on a coherent ordering of variable values and parameters in the file.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+BN">BN</a></code> object.
</p>

<hr>
<h2 id='sample.dataset'>sample a <code><a href="#topic+BNDataset">BNDataset</a></code> from a network of an inference engine.</h2><span id='topic+sample.dataset'></span><span id='topic+sample.dataset+2CBN-method'></span><span id='topic+sample.dataset+2CBN'></span><span id='topic+sample.dataset+2CInferenceEngine-method'></span><span id='topic+sample.dataset+2CInferenceEngine'></span>

<h3>Description</h3>

<p>sample a <code><a href="#topic+BNDataset">BNDataset</a></code> from a network of an inference engine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.dataset(x, n = 100, mar = 0)

## S4 method for signature 'BN'
sample.dataset(x, n = 100, mar = 0)

## S4 method for signature 'InferenceEngine'
sample.dataset(x, n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.dataset_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> object.</p>
</td></tr>
<tr><td><code id="sample.dataset_+3A_n">n</code></td>
<td>
<p>number of items to sample.</p>
</td></tr>
<tr><td><code id="sample.dataset_+3A_mar">mar</code></td>
<td>
<p>fraction [0,1]  of missing values in the sampled dataset 
(missing at random), default value is 0 (no missing values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+BNDataset">BNDataset</a></code>
</p>

<hr>
<h2 id='sample.row'>sample a row vector of values for a network.</h2><span id='topic+sample.row'></span><span id='topic+sample.row+2CBN-method'></span><span id='topic+sample.row+2CBN'></span>

<h3>Description</h3>

<p>sample a row vector of values for a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.row(x, mar = 0)

## S4 method for signature 'BN'
sample.row(x, mar = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.row_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> object.</p>
</td></tr>
<tr><td><code id="sample.row_+3A_mar">mar</code></td>
<td>
<p>fraction [0,1] of missing values in the sampled vector 
(missing at random), default value is 0 (no missing values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of values.
</p>

<hr>
<h2 id='save.to.eps'>save a <code><a href="#topic+BN">BN</a></code> picture as <code>.eps</code> file.</h2><span id='topic+save.to.eps'></span><span id='topic+save.to.eps+2CBN+2Ccharacter-method'></span><span id='topic+save.to.eps+2CBN+2Ccharacter'></span>

<h3>Description</h3>

<p>Save an image of a Bayesian Network as an <code>.eps</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.to.eps(x, filename, ...)

## S4 method for signature 'BN,character'
save.to.eps(x, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.to.eps_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> object</p>
</td></tr>
<tr><td><code id="save.to.eps_+3A_filename">filename</code></td>
<td>
<p>name (with path, if needed) of the file to be created</p>
</td></tr>
<tr><td><code id="save.to.eps_+3A_...">...</code></td>
<td>
<p>parameters for the <code><a href="#topic+plot">plot</a></code> method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
save.to.eps(x, "out.eps")

## End(Not run)

</code></pre>

<hr>
<h2 id='scoring.func'>Read the scoring function used to learn the structure of a network.</h2><span id='topic+scoring.func'></span><span id='topic+scoring.func+2CBN-method'></span><span id='topic+scoring.func+2CBN'></span>

<h3>Description</h3>

<p>Read the scoring function used in the <code><a href="#topic+learn.structure">learn.structure</a></code> method.
Outcome is meaningful only if the structure of a network has been learnt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoring.func(x)

## S4 method for signature 'BN'
scoring.func(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoring.func_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the scoring function used.
</p>

<hr>
<h2 id='scoring.func+26lt+3B-'>Set the scoring function used to learn the structure of a network.</h2><span id='topic+scoring.func+3C-'></span><span id='topic+scoring.func+3C-+2CBN-method'></span>

<h3>Description</h3>

<p>Set the scoring function used in the <code><a href="#topic+learn.structure">learn.structure</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoring.func(x) &lt;- value

## S4 replacement method for signature 'BN'
scoring.func(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoring.func+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
<tr><td><code id="scoring.func+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the scoring function used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated BN.
</p>

<hr>
<h2 id='shd'>compute the Structural Hamming Distance between two adjacency matrices.</h2><span id='topic+shd'></span>

<h3>Description</h3>

<p>Compute the Structural Hamming Distance between two adjacency matrices, that is,
the distance, in terms of edges, between two network structures. The lower the <code>shd</code>,
the more similar are the two network structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shd(g1, g2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shd_+3A_g1">g1</code></td>
<td>
<p>first adjacency matrix.</p>
</td></tr>
<tr><td><code id="shd_+3A_g2">g2</code></td>
<td>
<p>second adjacency matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='show'>Show method for objects.</h2><span id='topic+show'></span><span id='topic+show+2CAllTheClasses-method'></span><span id='topic+show+2CBN-method'></span><span id='topic+show+2CBNDataset-method'></span><span id='topic+show+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>The <code>show</code> method allows to provide a custom aspect for the output that is generated
when the name of an instance is gives as command in an R session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>

<hr>
<h2 id='struct.algo'>Read the algorithm used to learn the structure of a network.</h2><span id='topic+struct.algo'></span><span id='topic+struct.algo+2CBN-method'></span><span id='topic+struct.algo+2CBN'></span>

<h3>Description</h3>

<p>Read the algorithm used in the <code><a href="#topic+learn.structure">learn.structure</a></code> method.
Outcome is meaningful only if the structure of a network has been learnt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct.algo(x)

## S4 method for signature 'BN'
struct.algo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct.algo_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the structure learning algorithm used.
</p>

<hr>
<h2 id='struct.algo+26lt+3B-'>Set the algorithm used to learn the structure of a network.</h2><span id='topic+struct.algo+3C-'></span><span id='topic+struct.algo+3C-+2CBN-method'></span>

<h3>Description</h3>

<p>Set the algorithm used in the <code><a href="#topic+learn.structure">learn.structure</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct.algo(x) &lt;- value

## S4 replacement method for signature 'BN'
struct.algo(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct.algo+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
<tr><td><code id="struct.algo+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the scoring function used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated BN.
</p>

<hr>
<h2 id='test.updated.bn'>check if an updated <code><a href="#topic+BN">BN</a></code> is present in an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+test.updated.bn'></span><span id='topic+test.updated.bn+2CInferenceEngine-method'></span><span id='topic+test.updated.bn+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Check if an InferenceEngine actually contains an updated network, in order to provide the chance of
a fallback and use the original network if no belief propagation has been performed.
An <code><a href="#topic+InferenceEngine">InferenceEngine</a></code> built specifying a set of interventions will contain
an updated <code><a href="#topic+BN">BN</a></code> with altered structure and no conditional probability tables
(unless they are computed by a belief propagation operation.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.updated.bn(x)

## S4 method for signature 'InferenceEngine'
test.updated.bn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.updated.bn_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if an updated network is contained in the InferenceEngine, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset &lt;- BNDataset("file.header", "file.data")
bn &lt;- BN(dataset)
ie &lt;- InferenceEngine(bn)
test.updated.bn(ie) # FALSE

observations(ie) &lt;- list("observed.vars"=("A","G","X"), "observed.vals"=c(1,2,1))
ie &lt;- belief.propagation(ie)
test.updated.bn(ie) # TRUE

interventions &lt;- list("intervention.vars"=("A","G","X"), "intervention.vals"=c(1,2,1))
ie2 &lt;- InferenceEngine(bn, interventions = interventions)
test.updated.bn(ie2) # TRUE

## End(Not run)

</code></pre>

<hr>
<h2 id='tune.knn.impute'>tune the parameter k of the knn algorithm used in imputation.</h2><span id='topic+tune.knn.impute'></span>

<h3>Description</h3>

<p>tune the parameter k of the knn algorithm used in imputation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune.knn.impute(
  data,
  cat.var = 1:ncol(data),
  k.min = 1,
  k.max = 20,
  frac.miss = 0.1,
  n.iter = 20,
  seed = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune.knn.impute_+3A_data">data</code></td>
<td>
<p>a numerical matrix.</p>
</td></tr>
<tr><td><code id="tune.knn.impute_+3A_cat.var">cat.var</code></td>
<td>
<p>vector containing the categorical variables</p>
</td></tr>
<tr><td><code id="tune.knn.impute_+3A_k.min">k.min</code></td>
<td>
<p>minimum value for k</p>
</td></tr>
<tr><td><code id="tune.knn.impute_+3A_k.max">k.max</code></td>
<td>
<p>maximum value for k</p>
</td></tr>
<tr><td><code id="tune.knn.impute_+3A_frac.miss">frac.miss</code></td>
<td>
<p>fraction of missing values to add</p>
</td></tr>
<tr><td><code id="tune.knn.impute_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iterations for each k</p>
</td></tr>
<tr><td><code id="tune.knn.impute_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of error distributions
</p>

<hr>
<h2 id='updated.bn'>get the updated <code><a href="#topic+BN">BN</a></code> object contained in an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+updated.bn'></span><span id='topic+updated.bn+2CInferenceEngine-method'></span><span id='topic+updated.bn+2CInferenceEngine'></span>

<h3>Description</h3>

<p>Return an updated network contained in an InferenceEngine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updated.bn(x)

## S4 method for signature 'InferenceEngine'
updated.bn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updated.bn_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the updated <code><a href="#topic+BN">BN</a></code> object contained in an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.
</p>

<hr>
<h2 id='updated.bn+26lt+3B-'>set the updated <code><a href="#topic+BN">BN</a></code> object contained in an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</h2><span id='topic+updated.bn+3C-'></span><span id='topic+updated.bn+3C-+2CInferenceEngine-method'></span>

<h3>Description</h3>

<p>Add an updated network to an InferenceEngine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updated.bn(x) &lt;- value

## S4 replacement method for signature 'InferenceEngine'
updated.bn(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updated.bn+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
<tr><td><code id="updated.bn+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the updated <code><a href="#topic+BN">BN</a></code> object contained in an <code><a href="#topic+InferenceEngine">InferenceEngine</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='variables'>get variables of an object.</h2><span id='topic+variables'></span><span id='topic+variables+2CBN-method'></span><span id='topic+variables+2CBN'></span><span id='topic+variables+2CBNDataset-method'></span><span id='topic+variables+2CBNDataset'></span>

<h3>Description</h3>

<p>Get the list of variables (with their names) of a <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+BNDataset">BNDataset</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variables(x)

## S4 method for signature 'BN'
variables(x)

## S4 method for signature 'BNDataset'
variables(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variables_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of the variables names of the desired object.
</p>

<hr>
<h2 id='variables+26lt+3B-'>set variables of an object.</h2><span id='topic+variables+3C-'></span><span id='topic+variables+3C-+2CBN-method'></span><span id='topic+variables+3C-+2CBNDataset-method'></span>

<h3>Description</h3>

<p>Set the list of variable names in a <code><a href="#topic+BN">BN</a></code> or <code><a href="#topic+BNDataset">BNDataset</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variables(x) &lt;- value

## S4 replacement method for signature 'BN'
variables(x) &lt;- value

## S4 replacement method for signature 'BNDataset'
variables(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variables+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="variables+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>vector containing the variable names of the object.
Overwrites <code>num.nodes</code> slot if non-matching.</p>
</td></tr>
</table>

<hr>
<h2 id='wpdag'>get the WPDAG of an object.</h2><span id='topic+wpdag'></span><span id='topic+wpdag+2CBN-method'></span><span id='topic+wpdag+2CBN'></span>

<h3>Description</h3>

<p>Return the weighted partially directed acyclic graph of a network, when available (e.g. when bootstrap on dataset is performed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpdag(x)

## S4 method for signature 'BN'
wpdag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpdag_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix contaning the WPDAG of the object.
</p>

<hr>
<h2 id='wpdag.from.dag'>Initialize a WPDAG from a DAG.</h2><span id='topic+wpdag.from.dag'></span><span id='topic+wpdag.from.dag+2CBN-method'></span><span id='topic+wpdag.from.dag+2CBN'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+BN">BN</a></code> object with a <code>dag</code>, return a network
with its <code>wpdag</code> set as the CPDAG computed starting from the <code>dag</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpdag.from.dag(x, layering = NULL, layer.struct = NULL)

## S4 method for signature 'BN'
wpdag.from.dag(x, layering = NULL, layer.struct = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpdag.from.dag_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
<tr><td><code id="wpdag.from.dag_+3A_layering">layering</code></td>
<td>
<p>vector containing the layers each node belongs to.</p>
</td></tr>
<tr><td><code id="wpdag.from.dag_+3A_layer.struct">layer.struct</code></td>
<td>
<p><code>0/1</code> matrix for indicating which layers can contain parent nodes
for nodes in a layer (only for <code>mmhc</code>, <code>mmpc</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+BN">BN</a></code> object with an initialized <code>wpdag</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.to.cpdag">dag.to.cpdag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
net &lt;- learn.network(dataset, layering=layering, layer.struct=layer.struct)
wp.net &lt;- wpdag.from.dag(net, layering, layer.struct=layer.struct)

## End(Not run)

</code></pre>

<hr>
<h2 id='wpdag+26lt+3B-'>set WPDAG of the object.</h2><span id='topic+wpdag+3C-'></span><span id='topic+wpdag+3C-+2CBN-method'></span>

<h3>Description</h3>

<p>Set the weighted partially directed acyclic graph of a network (e.g. in case bootstrap on dataset is performed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpdag(x) &lt;- value

## S4 replacement method for signature 'BN'
wpdag(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpdag+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="wpdag+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>matrix contaning the WPDAG of the object.</p>
</td></tr>
</table>

<hr>
<h2 id='write_xgmml'>Write a network saving it in an <code>XGMML</code> file.</h2><span id='topic+write_xgmml'></span><span id='topic+write_xgmml+2CBN'></span><span id='topic+write_xgmml+2CBN-method'></span>

<h3>Description</h3>

<p>Write a network on disk, saving it in an <code>XGMML</code> file,
for importing it in Cytoscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_xgmml(
  x,
  path = "./network",
  write.wpdag = FALSE,
  node.col = rep("white", num.nodes(x)),
  frac = 0.2,
  max.weight = max(wpdag(x))
)

## S4 method for signature 'BN'
write_xgmml(
  x,
  path = "./network",
  write.wpdag = FALSE,
  node.col = rep("white", num.nodes(x)),
  frac = 0.2,
  max.weight = max(wpdag(x))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_xgmml_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
<tr><td><code id="write_xgmml_+3A_path">path</code></td>
<td>
<p>file name with relative or absolute path to be written.</p>
</td></tr>
<tr><td><code id="write_xgmml_+3A_write.wpdag">write.wpdag</code></td>
<td>
<p>write the weighted PDAG computed using bootstrap samples or the MMPC 
structure algorithm, instead of the normaldag (default FALSE).</p>
</td></tr>
<tr><td><code id="write_xgmml_+3A_node.col">node.col</code></td>
<td>
<p>vector of colors for each node of the network (in R colornames).</p>
</td></tr>
<tr><td><code id="write_xgmml_+3A_frac">frac</code></td>
<td>
<p>minimum fraction [0,1] of presence of an edge to be plotted (used in case of <code>write.wpdag=TRUE</code>).</p>
</td></tr>
<tr><td><code id="write_xgmml_+3A_max.weight">max.weight</code></td>
<td>
<p>maximum possible weight of an edge (used in case of <code>write.wpdag=TRUE</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='write.dsc'>Write a network saving it in a <code>.dsc</code> file.</h2><span id='topic+write.dsc'></span><span id='topic+write.dsc+2CBN-method'></span><span id='topic+write.dsc+2CBN'></span>

<h3>Description</h3>

<p>Write a network on disk, saving it in a <code>.dsc</code>-formatted file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.dsc(x, path = "./")

## S4 method for signature 'BN'
write.dsc(x, path = "./")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.dsc_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+BN">BN</a></code> object.</p>
</td></tr>
<tr><td><code id="write.dsc_+3A_path">path</code></td>
<td>
<p>the relative or absolute path of the directory of the created file.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
