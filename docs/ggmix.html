<!DOCTYPE html><html lang="en"><head><title>Help for package ggmix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggmix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#admixed'><p>Simulated Dataset with 1D Geography</p></a></li>
<li><a href='#gen_structured_model'><p>Simulation Scenario from Bhatnagar et al. (2018+) ggmix paper</p></a></li>
<li><a href='#ggmix'><p>Fit Linear Mixed Model with Lasso or Group Lasso Regularization</p></a></li>
<li><a href='#ggmix_data_object'><p>Constructor functions for the different ggmix objects</p></a></li>
<li><a href='#gic'><p>Generalised Information Criterion</p></a></li>
<li><a href='#gr_eta_lasso_fullrank'><p>Functions related to eta parameter used in optim and kkt checks</p></a></li>
<li><a href='#karim'><p>Karim's Simulated Data</p></a></li>
<li><a href='#kkt_check'><p>Check of KKT Conditions for Linear Mixed Model</p></a></li>
<li><a href='#lambdalasso'><p>Estimation of Lambda Sequence for Linear Mixed Model with Lasso Penalty</p></a></li>
<li><a href='#lmmlasso'><p>Estimation of Linear Mixed Model with Lasso Penalty</p></a></li>
<li><a href='#logliklasso'><p>Estimation of Log-likelihood for Linear Mixed Model with Lasso Penalty</p></a></li>
<li><a href='#plot.ggmix_fit'><p>Plot Method for <code>ggmix_fit</code> object</p></a></li>
<li><a href='#plot.ggmix_gic'><p>Plot the Generalised Information Criteria curve produced by <code>gic</code></p></a></li>
<li><a href='#predict.ggmix_fit'><p>Make predictions from a <code>ggmix_fit</code> object</p></a></li>
<li><a href='#predict.ggmix_gic'><p>Make predictions from a <code>ggmix_gic</code> object</p></a></li>
<li><a href='#print.ggmix_fit'><p>Print Method for Objects of Class <code>ggmix_fit</code></p></a></li>
<li><a href='#ranef'><p>Extract Random Effects</p></a></li>
<li><a href='#sigma2lasso'><p>Estimation of Sigma2 for Linear Mixed Model with Lasso Penalty</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variable Selection in Linear Mixed Models for SNP Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit penalized multivariable linear mixed models with a single 
    random effect to control for population structure in genetic association 
    studies. The goal is to simultaneously fit many genetic variants at the 
    same time, in order to select markers that are independently associated 
    with the response. Can also handle prior annotation information, 
    for example, rare variants, in the form of variable weights. For more 
    information, see the website below and the accompanying paper: 
    Bhatnagar et al., "Simultaneous SNP selection and adjustment for 
    population structure in high dimensional prediction models", 2020, 
    &lt;<a href="https://doi.org/10.1371%2Fjournal.pgen.1008766">doi:10.1371/journal.pgen.1008766</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, methods, stats, MASS, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RSpectra, popkin, bnpsd, testthat, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sahirbhatnagar/ggmix/issues">https://github.com/sahirbhatnagar/ggmix/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sahirbhatnagar/ggmix">https://github.com/sahirbhatnagar/ggmix</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-10 04:23:08 UTC; sahir</td>
</tr>
<tr>
<td>Author:</td>
<td>Sahir Bhatnagar [aut, cre] (https://sahirbhatnagar.com/),
  Karim Oualkacha [aut] (http://karimoualkacha.uqam.ca/),
  Yi Yang [aut] (http://www.math.mcgill.ca/yyang/),
  Celia Greenwood [aut] (http://www.mcgill.ca/statisticalgenetics/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sahir Bhatnagar &lt;sahir.bhatnagar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-13 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='admixed'>Simulated Dataset with 1D Geography</h2><span id='topic+admixed'></span>

<h3>Description</h3>

<p>A simulated dataset to show the utility of this package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admixed
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 21.
</p>


<h3>Details</h3>

<p>The code used to simulate the data is available at
<a href="https://github.com/sahirbhatnagar/ggmix/blob/master/data-raw/bnpsd-data.R">https://github.com/sahirbhatnagar/ggmix/blob/master/data-raw/bnpsd-data.R</a>.
See <code><a href="#topic+gen_structured_model">gen_structured_model</a></code> for more details on the output and
how the function used to simulate the data.
</p>


<h3>Value</h3>

<p>A list with the following elements </p>
<dl>
<dt>ytrain</dt><dd><p>simulated
response vector for training set</p>
</dd> <dt>ytune</dt><dd><p>simulated response vector
for tuning parameter selection set</p>
</dd> <dt>ytest</dt><dd><p>simulated response vector
for test set</p>
</dd> <dt>xtrain</dt><dd><p>simulated design matrix for training
set</p>
</dd><dt>xtune</dt><dd><p>simulated design matrix for tuning parameter selection
set</p>
</dd><dt>xtest</dt><dd><p>simulated design matrix for testing set</p>
</dd>
<dt>xtrain_lasso</dt><dd><p>simulated design matrix for training set for lasso
model. This is the same as xtrain, but also includes the nPC principal
components</p>
</dd> <dt>xtune_lasso</dt><dd><p>simulated design matrix for tuning parameter
selection set for lasso model. This is the same as xtune, but also includes
the nPC principal components</p>
</dd><dt>xtest</dt><dd><p>simulated design matrix for
testing set for lasso model. This is the same as xtest, but also includes
the nPC principal components</p>
</dd> <dt>causal</dt><dd><p>character vector of the names
of the causal SNPs</p>
</dd> <dt>beta</dt><dd><p>the vector of true regression coefficients</p>
</dd>
<dt>kin_train</dt><dd><p>2 times the estimated kinship for the training set
individuals</p>
</dd> <dt>kin_tune_train</dt><dd><p>The covariance matrix between the tuning
set and the training set individuals</p>
</dd> <dt>kin_test_train</dt><dd><p>The covariance
matrix between the test set and training set individuals</p>
</dd>
<dt>Xkinship</dt><dd><p>the matrix of SNPs used to estimate the kinship matrix</p>
</dd>
<dt>not_causal</dt><dd><p>character vector of the non-causal SNPs</p>
</dd> <dt>PC</dt><dd><p>the
principal components for population structure adjustment</p>
</dd> </dl>



<h3>References</h3>

<p>Ochoa, Alejandro, and John D. Storey. 2016a. &quot;FST And Kinship for
Arbitrary Population Structures I: Generalized Definitions.&quot; bioRxiv
doi:10.1101/083915.
</p>
<p>Ochoa, Alejandro, and John D. Storey. 2016b. &quot;FST And Kinship for
Arbitrary Population Structures II: Method of Moments Estimators.&quot; bioRxiv
doi:10.1101/083923.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admixed)
str(admixed)
</code></pre>

<hr>
<h2 id='gen_structured_model'>Simulation Scenario from Bhatnagar et al. (2018+) ggmix paper</h2><span id='topic+gen_structured_model'></span>

<h3>Description</h3>

<p>Function that generates data of the different simulation studies
presented in the accompanying paper. This function requires the
<code>popkin</code> and <code>bnpsd</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_structured_model(
  n,
  p_design,
  p_kinship,
  k,
  s,
  Fst,
  b0,
  nPC = 10,
  eta,
  sigma2,
  geography = c("ind", "1d", "circ"),
  percent_causal,
  percent_overlap,
  train_tune_test = c(0.6, 0.2, 0.2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_structured_model_+3A_n">n</code></td>
<td>
<p>number of observations to simulate</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_p_design">p_design</code></td>
<td>
<p>number of variables in X_test, i.e., the design matrix</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_p_kinship">p_kinship</code></td>
<td>
<p>number of variable in X_kinship, i.e., matrix used to
calculate kinship</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_k">k</code></td>
<td>
<p>number of intermediate subpopulations.</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_s">s</code></td>
<td>
<p>the desired bias coefficient, which specifies sigma indirectly.
Required if sigma is missing</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_fst">Fst</code></td>
<td>
<p>The desired final FST of the admixed individuals. Required if
sigma is missing</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_b0">b0</code></td>
<td>
<p>the true intercept parameter</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_npc">nPC</code></td>
<td>
<p>number of principal components to include in the design matrix
used for regression adjustment for population structure via principal
components. This matrix is used as the input in a standard lasso regression
routine, where there are no random effects.</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_eta">eta</code></td>
<td>
<p>the true eta parameter, which has to be <code>0 &lt; eta &lt; 1</code></p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_sigma2">sigma2</code></td>
<td>
<p>the true sigma2 parameter</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_geography">geography</code></td>
<td>
<p>the type of geography for simulation the kinship matrix.
&quot;ind&quot; is independent populations where every individuals is actually
unadmixed, &quot;1d&quot; is a 1D geography and &quot;circ&quot; is circular geography.
Default: &quot;ind&quot;. See the functions in the <code>bnpsd</code> for details on how
this data is actually generated.</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_percent_causal">percent_causal</code></td>
<td>
<p>percentage of <code>p_design</code> that is causal. must be
<code class="reqn">0 \leq percent_causal \leq 1</code>. The true regression coefficients are
generated from a standard normal distribution.</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_percent_overlap">percent_overlap</code></td>
<td>
<p>this represents the percentage of causal SNPs that
will also be included in the calculation of the kinship matrix</p>
</td></tr>
<tr><td><code id="gen_structured_model_+3A_train_tune_test">train_tune_test</code></td>
<td>
<p>the proportion of sample size used for training tuning
parameter selection and testing. default is 60/20/20 split</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The kinship is estimated using the <code>popkin</code> function from the
<code>popkin</code> package. This function will multiple that kinship matrix by 2
to give the expected covariance matrix which is subsequently used in the
linear mixed models
</p>


<h3>Value</h3>

<p>A list with the following elements </p>
<dl>
<dt>ytrain</dt><dd><p>simulated
response vector for training set</p>
</dd> <dt>ytune</dt><dd><p>simulated response vector
for tuning parameter selection set</p>
</dd> <dt>ytest</dt><dd><p>simulated response vector
for test set</p>
</dd> <dt>xtrain</dt><dd><p>simulated design matrix for training
set</p>
</dd><dt>xtune</dt><dd><p>simulated design matrix for tuning parameter selection
set</p>
</dd><dt>xtest</dt><dd><p>simulated design matrix for testing set</p>
</dd>
<dt>xtrain_lasso</dt><dd><p>simulated design matrix for training set for lasso
model. This is the same as xtrain, but also includes the nPC principal
components</p>
</dd> <dt>xtune_lasso</dt><dd><p>simulated design matrix for tuning parameter
selection set for lasso model. This is the same as xtune, but also includes
the nPC principal components</p>
</dd><dt>xtest</dt><dd><p>simulated design matrix for
testing set for lasso model. This is the same as xtest, but also includes
the nPC principal components</p>
</dd> <dt>causal</dt><dd><p>character vector of the names
of the causal SNPs</p>
</dd> <dt>beta</dt><dd><p>the vector of true regression coefficients</p>
</dd>
<dt>kin_train</dt><dd><p>2 times the estimated kinship for the training set
individuals</p>
</dd> <dt>kin_tune_train</dt><dd><p>The covariance matrix between the tuning
set and the training set individuals</p>
</dd> <dt>kin_test_train</dt><dd><p>The covariance
matrix between the test set and training set individuals</p>
</dd>
<dt>Xkinship</dt><dd><p>the matrix of SNPs used to estimate the kinship matrix</p>
</dd>
<dt>not_causal</dt><dd><p>character vector of the non-causal SNPs</p>
</dd> <dt>PC</dt><dd><p>the
principal components for population structure adjustment</p>
</dd> </dl>



<h3>See Also</h3>

<p><code><a href="bnpsd.html#topic+admix_prop_1d_linear">admix_prop_1d_linear</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>admixed &lt;- gen_structured_model(n = 100,
                                p_design = 50,
                                p_kinship = 5e2,
                                geography = "1d",
                                percent_causal = 0.10,
                                percent_overlap = "100",
                                k = 5, s = 0.5, Fst = 0.1,
                                b0 = 0, nPC = 10,
                                eta = 0.1, sigma2 = 1,
                                train_tune_test = c(0.8, 0.1, 0.1))
names(admixed)
</code></pre>

<hr>
<h2 id='ggmix'>Fit Linear Mixed Model with Lasso or Group Lasso Regularization</h2><span id='topic+ggmix'></span>

<h3>Description</h3>

<p>Main function to fit the linear mixed model with lasso or group
lasso penalty for a sequence of tuning parameters. This is a penalized
regression method that accounts for population structure using either the
kinship matrix or the factored realized relationship matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggmix(
  x,
  y,
  U,
  D,
  kinship,
  K,
  n_nonzero_eigenvalues,
  n_zero_eigenvalues,
  estimation = c("full"),
  penalty = c("lasso"),
  group,
  penalty.factor = rep(1, p_design),
  lambda = NULL,
  lambda_min_ratio = ifelse(n_design &lt; p_design, 0.01, 1e-04),
  nlambda = 100,
  eta_init = 0.5,
  maxit = 100,
  fdev = 1e-20,
  standardize = FALSE,
  alpha = 1,
  thresh_glmnet = 1e-08,
  epsilon = 1e-04,
  dfmax = p_design + 2,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggmix_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension n x p; where n is the number of
observations and p are the number of predictors.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_y">y</code></td>
<td>
<p>response variable. must be a quantitative variable</p>
</td></tr>
<tr><td><code id="ggmix_+3A_u">U</code></td>
<td>
<p>left singular vectors corresponding to the non-zero eigenvalues
provided in the <code>D</code> argument.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_d">D</code></td>
<td>
<p>non-zero eigenvalues. This option is provided to the user should
they decide or need to calculate the eigen decomposition of the kinship
matrix or the singular value decomposition of the matrix of SNPs used to
calculate the kinship outside of this function. This may occur, if for
example, it is easier (e.g. because of memory issues, it's easier to
calculate in plink). This should correspond to the non-zero eigenvalues
only. Note that if you are doing an <code>svd</code> on the matrix of SNPs used
to calculate the kinship matrix, then you must provide the square of the
singular values so that they correspond to the eigenvalues of the kinship
matrix. If you want to use the low rank estimation algorithm, you must
provide the truncated eigenvalues and eigenvectors to the <code>D</code> and
<code>U</code> arguments, respectively. If you want <code>ggmix</code> to truncate the
eigenvectors and eigenvalues for low rank estimation, then provide either
<code>K</code> or <code>kinship</code> instead and specify
<code>n_nonzero_eigenvalues</code>.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_kinship">kinship</code></td>
<td>
<p>positive definite kinship matrix</p>
</td></tr>
<tr><td><code id="ggmix_+3A_k">K</code></td>
<td>
<p>the matrix of SNPs used to determine the kinship matrix</p>
</td></tr>
<tr><td><code id="ggmix_+3A_n_nonzero_eigenvalues">n_nonzero_eigenvalues</code></td>
<td>
<p>the number of nonzero eigenvalues. This argument
is only used when <code>estimation="low"</code> and either <code>kinship</code> or
<code>K</code> is provided. This argument will limit the function to finding the
<code>n_nonzero_eigenvalues</code> largest eigenvalues. If <code>U</code> and <code>D</code>
have been provided, then <code>n_nonzero_eigenvalues</code> defaults to the
length of <code>D</code>.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_n_zero_eigenvalues">n_zero_eigenvalues</code></td>
<td>
<p>Currently not being used. Represents the number of
zero eigenvalues. This argument must be specified when <code>U</code> and
<code>D</code> are specified and <code>estimation="low"</code>. This is required for
low rank estimation because the number of zero eigenvalues and their
corresponding eigenvalues appears in the likelihood. In general this would
be the rank of the matrix used to calculate the eigen or singular value
decomposition. When <code>kinship</code> is provided and <code>estimation="low"</code>
the default value will be <code>nrow(kinship) - n_nonzero_eigenvalues</code>.
When <code>K</code> is provided and <code>estimation="low"</code>, the default value is
<code>rank(K) - n_nonzero_eigenvalues</code></p>
</td></tr>
<tr><td><code id="ggmix_+3A_estimation">estimation</code></td>
<td>
<p>type of estimation. Currently only <code>type="full"</code> has
been implemented.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_penalty">penalty</code></td>
<td>
<p>type of regularization penalty. Currently, only
penalty=&quot;lasso&quot; has been implemented.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_group">group</code></td>
<td>
<p>a vector of consecutive integers describing the grouping of the
coefficients. Currently not implemented, but will be used when
penalty=&quot;gglasso&quot; is implemented.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to each
coefficient. This is a number that multiplies lambda to allow differential
shrinkage. Can be 0 for some variables, which implies no shrinkage, and
that variable is always included in the model. Default is 1 for all
variables</p>
</td></tr>
<tr><td><code id="ggmix_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied lambda sequence (this is the tuning parameter).
Typical usage is to have the program compute its own lambda sequence based
on nlambda and lambda.min.ratio. Supplying a value of lambda overrides
this. WARNING: use with care. Do not supply a single value for lambda (for
predictions after CV use predict() instead). Supply instead a decreasing
sequence of lambda values. glmnet relies on its warms starts for speed, and
its often faster to fit a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_lambda_min_ratio">lambda_min_ratio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of
lambda.max, the (data derived) entry value (i.e. the smallest value for
which all coefficients are zero). The default depends on the sample size
nobs relative to the number of variables nvars. If nobs &gt; nvars, the
default is 0.0001, close to zero. If nobs &lt; nvars, the default is 0.01. A
very small value of lambda.min.ratio will lead to a saturated fit in the
nobs &lt; nvars case.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_nlambda">nlambda</code></td>
<td>
<p>the number of lambda values - default is 100.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_eta_init">eta_init</code></td>
<td>
<p>initial value for the eta parameter, with <code class="reqn">0 &lt; \eta &lt; 1</code>
used in determining lambda.max and starting value for fitting algorithm.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda values;
default is 10^2.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_fdev">fdev</code></td>
<td>
<p>Fractional deviance change threshold. If change in deviance
between adjacent lambdas is less than fdev, the solution path stops early.
factory default = 1.0e-5</p>
</td></tr>
<tr><td><code id="ggmix_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on the
original scale. Default is standardize=FALSE. If variables are in the same
units already, you might not wish to standardize.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0 \leq \alpha \leq
1</code>. alpha=1 is the lasso penalty, and alpha=0 the ridge penalty.</p>
</td></tr>
<tr><td><code id="ggmix_+3A_thresh_glmnet">thresh_glmnet</code></td>
<td>
<p>Convergence threshold for coordinate descent for
updating beta parameters. Each inner coordinate-descent loop continues
until the maximum change in the objective after any coefficient update is
less than thresh times the null deviance. Defaults value is 1E-7</p>
</td></tr>
<tr><td><code id="ggmix_+3A_epsilon">epsilon</code></td>
<td>
<p>Convergence threshold for block relaxation of the entire
parameter vector <code class="reqn">\Theta = ( \beta, \eta, \sigma^2 )</code>. The algorithm
converges when </p>
<p style="text-align: center;"><code class="reqn">crossprod(\Theta_{j+1} - \Theta_{j}) &lt; \epsilon</code>
</p>
<p>.
Defaults value is 1E-4</p>
</td></tr>
<tr><td><code id="ggmix_+3A_dfmax">dfmax</code></td>
<td>
<p>limit the maximum number of variables in the model. Useful for
very large <code>p</code> (the total number of predictors in the design matrix),
if a partial path is desired. Default is the number of columns in the
design matrix + 2 (for the variance components)</p>
</td></tr>
<tr><td><code id="ggmix_+3A_verbose">verbose</code></td>
<td>
<p>display progress. Can be either 0,1 or 2. 0 will not display
any progress, 2 will display very detailed progress and 1 is somewhere in
between. Default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list which includes the fitted object, lambda sequence, 
solution path, variance-covariance parameters, degrees of freedom, 
and singular values, vectors of kinship matrix
</p>


<h3>References</h3>

<p>Bhatnagar, Sahir R, Yang, Yi, Lu, Tianyuan, Schurr, Erwin,
Loredo-Osti, JC, Forest, Marie, Oualkacha, Karim, and Greenwood, Celia MT.
(2020) <em>Simultaneous SNP selection and adjustment for population
structure in high dimensional prediction models</em>
doi: <a href="https://doi.org/10.1101/408484">10.1101/408484</a>
</p>
<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008) <em>Regularization
Paths for Generalized Linear Models via Coordinate Descent</em>,
<a href="https://web.stanford.edu/~hastie/Papers/glmnet.pdf">https://web.stanford.edu/~hastie/Papers/glmnet.pdf</a> <em>Journal of
Statistical Software, Vol. 33(1), 1-22 Feb 2010</em>
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>
<p>Yang, Y., &amp; Zou, H. (2015). A fast unified algorithm for solving
group-lasso penalize learning problems. <em>Statistics and Computing</em>,
25(6), 1129-1141.
<a href="https://www.math.mcgill.ca/yyang/resources/papers/STCO_gglasso.pdf">https://www.math.mcgill.ca/yyang/resources/papers/STCO_gglasso.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admixed)
fitlmm &lt;- ggmix(x = admixed$xtrain, y = admixed$ytrain,
                kinship = admixed$kin_train,
                estimation = "full")
gicfit &lt;- gic(fitlmm)
coef(gicfit, type = "nonzero")
predict(gicfit, newx = admixed$xtest)[1:5,,drop=FALSE]
plot(gicfit)
plot(fitlmm)

</code></pre>

<hr>
<h2 id='ggmix_data_object'>Constructor functions for the different ggmix objects</h2><span id='topic+ggmix_data_object'></span><span id='topic+new_fullrank_kinship'></span><span id='topic+new_fullrank_K'></span><span id='topic+new_fullrank_UD'></span><span id='topic+new_lowrank_kinship'></span><span id='topic+new_lowrank_K'></span><span id='topic+new_lowrank_UD'></span>

<h3>Description</h3>

<p><code>new_fullrank_kinship</code>, <code>new_fullrank_K</code>, <code>new_fullrank_UD</code>,
<code>new_lowrank_kinship</code>, <code>new_lowrank_K</code> and <code>new_lowrank_UD</code>
create the ggmix objects from the provided data that are necessary to fit the
penalized linear mixed model according to the user's parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_fullrank_kinship(x, y, kinship)

new_fullrank_K(x, y, K)

new_fullrank_UD(x, y, U, D)

new_lowrank_kinship(x, y, kinship, n_nonzero_eigenvalues, n_zero_eigenvalues)

new_lowrank_K(x, y, K, n_nonzero_eigenvalues, n_zero_eigenvalues)

new_lowrank_UD(x, y, U, D, n_nonzero_eigenvalues, n_zero_eigenvalues)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggmix_data_object_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension n x p; where n is the number of
observations and p are the number of predictors.</p>
</td></tr>
<tr><td><code id="ggmix_data_object_+3A_y">y</code></td>
<td>
<p>response variable. must be a quantitative variable</p>
</td></tr>
<tr><td><code id="ggmix_data_object_+3A_kinship">kinship</code></td>
<td>
<p>positive definite kinship matrix</p>
</td></tr>
<tr><td><code id="ggmix_data_object_+3A_k">K</code></td>
<td>
<p>the matrix of SNPs used to determine the kinship matrix</p>
</td></tr>
<tr><td><code id="ggmix_data_object_+3A_u">U</code></td>
<td>
<p>left singular vectors corresponding to the non-zero eigenvalues
provided in the <code>D</code> argument.</p>
</td></tr>
<tr><td><code id="ggmix_data_object_+3A_d">D</code></td>
<td>
<p>non-zero eigenvalues. This option is provided to the user should
they decide or need to calculate the eigen decomposition of the kinship
matrix or the singular value decomposition of the matrix of SNPs used to
calculate the kinship outside of this function. This may occur, if for
example, it is easier (e.g. because of memory issues, it's easier to
calculate in plink). This should correspond to the non-zero eigenvalues
only. Note that if you are doing an <code>svd</code> on the matrix of SNPs used
to calculate the kinship matrix, then you must provide the square of the
singular values so that they correspond to the eigenvalues of the kinship
matrix. If you want to use the low rank estimation algorithm, you must
provide the truncated eigenvalues and eigenvectors to the <code>D</code> and
<code>U</code> arguments, respectively. If you want <code>ggmix</code> to truncate the
eigenvectors and eigenvalues for low rank estimation, then provide either
<code>K</code> or <code>kinship</code> instead and specify
<code>n_nonzero_eigenvalues</code>.</p>
</td></tr>
<tr><td><code id="ggmix_data_object_+3A_n_nonzero_eigenvalues">n_nonzero_eigenvalues</code></td>
<td>
<p>the number of nonzero eigenvalues. This argument
is only used when <code>estimation="low"</code> and either <code>kinship</code> or
<code>K</code> is provided. This argument will limit the function to finding the
<code>n_nonzero_eigenvalues</code> largest eigenvalues. If <code>U</code> and <code>D</code>
have been provided, then <code>n_nonzero_eigenvalues</code> defaults to the
length of <code>D</code>.</p>
</td></tr>
<tr><td><code id="ggmix_data_object_+3A_n_zero_eigenvalues">n_zero_eigenvalues</code></td>
<td>
<p>the number of desired or specified zero eigenvalues.
This is only needed when <code>estimation="lowrank"</code>, and is calculated
internally by the <code><a href="#topic+ggmix">ggmix</a></code> function. It is equal to the number
of observations minus <code>n_nonzero_eigenvalues</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggmix object, of the class that corresponds to the estimation
method. These objects are lists that contain the data necessary for
computation. These functions are not meant to be called directly by the
user
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggmix">ggmix</a></code>
</p>

<hr>
<h2 id='gic'>Generalised Information Criterion</h2><span id='topic+gic'></span><span id='topic+gic.default'></span><span id='topic+gic.ggmix_fit'></span>

<h3>Description</h3>

<p>Calculates the generalised information criterion for each value
of the tuning parameter lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gic(ggmix_fit, ...)

## Default S3 method:
gic(ggmix_fit, ...)

## S3 method for class 'ggmix_fit'
gic(ggmix_fit, ..., an = log(log(n)) * log(p))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gic_+3A_ggmix_fit">ggmix_fit</code></td>
<td>
<p>An object of class <code>ggmix_fit</code> which is outputted by
the <code><a href="#topic+ggmix">ggmix</a></code> function</p>
</td></tr>
<tr><td><code id="gic_+3A_...">...</code></td>
<td>
<p>other parameters. currently ignored.</p>
</td></tr>
<tr><td><code id="gic_+3A_an">an</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default is an =
log(log(n))*log(p) where n is the number of subjects and p is the number of
parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the generalised information criterion used for gaussian response is
given by </p>
<p style="text-align: center;"><code class="reqn">-2 * loglikelihood(\hat{\Theta}) + an * df</code>
</p>
<p> where df is the
number of non-zero estimated parameters, including variance components
</p>


<h3>Value</h3>

<p>an object with S3 class <code>"ggmix_gic"</code>, <code>"ggmix_fit"</code>,
<code>"*"</code> and <code>"**"</code> where <code>"*"</code> is &quot;lasso&quot; or &quot;gglasso&quot; and
<code>"**"</code> is fullrank or lowrank. Results are provided for converged
values of lambda only. </p>
<dl>
<dt>ggmix_fit</dt><dd><p>the ggmix_fit
object</p>
</dd><dt>lambda</dt><dd><p>the sequence of converged tuning parameters</p>
</dd>
<dt>nzero</dt><dd><p>the number of non-zero estimated coefficients including the 2
variance parameters which are not penalized and therefore always
included</p>
</dd><dt>gic</dt><dd><p>gic value. a numeric vector with length equal to
<code>length(lambda)</code></p>
</dd> <dt>lambda.min.name</dt><dd><p>a character corresponding to
the name of the tuning parameter lambda which minimizes the
gic</p>
</dd><dt>lambda.min</dt><dd><p>the value of lambda which minimizes the gic</p>
</dd></dl>



<h3>References</h3>

<p>Fan Y, Tang CY. Tuning parameter selection in high dimensional
penalized likelihood. Journal of the Royal Statistical Society: Series B
(Statistical Methodology). 2013 Jun 1;75(3):531-52.
</p>
<p>Nishii R. Asymptotic properties of criteria for selection of variables in
multiple regression. The Annals of Statistics. 1984;12(2):758-65.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggmix">ggmix</a></code>
</p>

<hr>
<h2 id='gr_eta_lasso_fullrank'>Functions related to eta parameter used in optim and kkt checks</h2><span id='topic+gr_eta_lasso_fullrank'></span><span id='topic+fn_eta_lasso_fullrank'></span>

<h3>Description</h3>

<p>Used for gradient of eta. Currently being passed to optim in
<code><a href="#topic+lmmlasso">lmmlasso</a></code> and used in <code><a href="#topic+kkt_check">kkt_check</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr_eta_lasso_fullrank(eta, sigma2, beta, eigenvalues, x, y, nt)

fn_eta_lasso_fullrank(eta, sigma2, beta, eigenvalues, x, y, nt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gr_eta_lasso_fullrank_+3A_eta">eta</code></td>
<td>
<p>current estimate of the eta parameter</p>
</td></tr>
<tr><td><code id="gr_eta_lasso_fullrank_+3A_sigma2">sigma2</code></td>
<td>
<p>current estimate of the sigma2 parameter</p>
</td></tr>
<tr><td><code id="gr_eta_lasso_fullrank_+3A_beta">beta</code></td>
<td>
<p>current estimate of the beta parameter including the intercept.
this should be of length p+1, where p is the number of variables.</p>
</td></tr>
<tr><td><code id="gr_eta_lasso_fullrank_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>non-zero eigenvalues of the kinship matrix, or the square
of the singular values of the matrix used to construct the kinship matrix</p>
</td></tr>
<tr><td><code id="gr_eta_lasso_fullrank_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension n x p; where n is the number of
observations and p are the number of predictors.</p>
</td></tr>
<tr><td><code id="gr_eta_lasso_fullrank_+3A_y">y</code></td>
<td>
<p>response variable. must be a quantitative variable</p>
</td></tr>
<tr><td><code id="gr_eta_lasso_fullrank_+3A_nt">nt</code></td>
<td>
<p>total number of observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the value of the function and gradient for the eta variance parameter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logliklasso">logliklasso</a></code>, <code><a href="#topic+kkt_check">kkt_check</a></code>, <code><a href="#topic+lmmlasso">lmmlasso</a></code>
</p>

<hr>
<h2 id='karim'>Karim's Simulated Data</h2><span id='topic+karim'></span>

<h3>Description</h3>

<p>A simulated dataset with a kinship matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karim
</code></pre>


<h3>Format</h3>

<p>A list with 6 elements: </p>
 <dl>
<dt>b</dt><dd><p>vector of length 1000
representing the true regression coefficients. 10 non-zero coefficients,
the rest are 0.</p>
</dd><dt>kin1</dt><dd><p>the true kinship matrix</p>
</dd><dt>s.g</dt><dd><p>polygenic
variance, set to be 1.26</p>
</dd><dt>s.e</dt><dd><p>error variance, set to be
1</p>
</dd><dt>h.tot</dt><dd><p>the total trait heritability. Set to be 60
of genotypes of dimension 600 x 1000 SNPs, with approximately 800 common
and 200 rare SNPs</p>
</dd></dl>



<h3>Details</h3>

<p>If you simulate data using the scenario provided in the example,
then the QTL heritability of y will be 8
of the trait’s total heritability), and the trait total heritability is set
to be 60
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karim)
# Simulate a response using the genotype matrix and the kinship matrix
Phi &lt;- 2 * karim$kin1
intercept &lt;- 1
P &lt;- MASS::mvrnorm(1, rep(0,600), karim$s.g * Phi)
y &lt;- intercept + karim$G %*% karim$b + P + rnorm(600,0,karim$s.e)
</code></pre>

<hr>
<h2 id='kkt_check'>Check of KKT Conditions for Linear Mixed Model</h2><span id='topic+kkt_check'></span><span id='topic+grr_sigma2'></span><span id='topic+grr_beta0'></span>

<h3>Description</h3>

<p>This function checks the KKT conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kkt_check(eta, sigma2, beta, eigenvalues, x, y, nt, lambda, tol.kkt = 0.001)

grr_sigma2(eta, sigma2, beta, eigenvalues, x, y, nt)

grr_beta0(eta, sigma2, beta, eigenvalues, x, y, nt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kkt_check_+3A_eta">eta</code></td>
<td>
<p>current estimate of the eta parameter</p>
</td></tr>
<tr><td><code id="kkt_check_+3A_sigma2">sigma2</code></td>
<td>
<p>current estimate of the sigma2 parameter</p>
</td></tr>
<tr><td><code id="kkt_check_+3A_beta">beta</code></td>
<td>
<p>current estimate of the beta parameter including the intercept.
this should be of length p+1, where p is the number of variables.</p>
</td></tr>
<tr><td><code id="kkt_check_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>non-zero eigenvalues of the kinship matrix, or the square
of the singular values of the matrix used to construct the kinship matrix</p>
</td></tr>
<tr><td><code id="kkt_check_+3A_x">x</code></td>
<td>
<p>rotated x. Should be U^T X, where U is the matrix of eigenvectors
and X contains the first column of ones for the intercept. x should be a
mtrix of dimension n x (p+1). These are outputted by the constructor
functions. See <code><a href="#topic+ggmix_data_object">ggmix_data_object</a></code> for details</p>
</td></tr>
<tr><td><code id="kkt_check_+3A_y">y</code></td>
<td>
<p>rotated y. Should be U^T Y, where U is the matrix of eigenvectors
and Y is the response.</p>
</td></tr>
<tr><td><code id="kkt_check_+3A_nt">nt</code></td>
<td>
<p>total number of observations</p>
</td></tr>
<tr><td><code id="kkt_check_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied lambda sequence (this is the tuning parameter).
Typical usage is to have the program compute its own lambda sequence based
on nlambda and lambda.min.ratio. Supplying a value of lambda overrides
this. WARNING: use with care. Do not supply a single value for lambda (for
predictions after CV use predict() instead). Supply instead a decreasing
sequence of lambda values. glmnet relies on its warms starts for speed, and
its often faster to fit a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="kkt_check_+3A_tol.kkt">tol.kkt</code></td>
<td>
<p>Tolerance for determining if an entry of the subgradient is
zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the values of the gradient for each of the parameters
</p>


<h3>Note</h3>

<p><code>grr_sigma2</code> and <code>grr_beta0</code> are functions for the gradient
of sigma2 and beta0, respectively
</p>

<hr>
<h2 id='lambdalasso'>Estimation of Lambda Sequence for Linear Mixed Model with Lasso Penalty</h2><span id='topic+lambdalasso'></span><span id='topic+lambdalasso.default'></span><span id='topic+lambdalasso.fullrank'></span>

<h3>Description</h3>

<p><code>lambdalasso</code> estimates a decreasing sequence of tuning
parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdalasso(ggmix_object, ...)

## Default S3 method:
lambdalasso(ggmix_object, ...)

## S3 method for class 'fullrank'
lambdalasso(
  ggmix_object,
  ...,
  penalty.factor,
  lambda_min_ratio,
  epsilon = 1e-14,
  tol.kkt = 1e-09,
  eta_init = 0.5,
  nlambda = 100,
  scale_x = FALSE,
  center_y = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambdalasso_+3A_ggmix_object">ggmix_object</code></td>
<td>
<p>A ggmix_object object of class <code>lowrank</code> or
<code>fullrank</code></p>
</td></tr>
<tr><td><code id="lambdalasso_+3A_...">...</code></td>
<td>
<p>Extra parameters. Currently ignored.</p>
</td></tr>
<tr><td><code id="lambdalasso_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to each
coefficient. This is a number that multiplies lambda to allow differential
shrinkage. Can be 0 for some variables, which implies no shrinkage, and
that variable is always included in the model. Default is 1 for all
variables</p>
</td></tr>
<tr><td><code id="lambdalasso_+3A_lambda_min_ratio">lambda_min_ratio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of
lambda.max, the (data derived) entry value (i.e. the smallest value for
which all coefficients are zero). The default depends on the sample size
nobs relative to the number of variables nvars. If nobs &gt; nvars, the
default is 0.0001, close to zero. If nobs &lt; nvars, the default is 0.01. A
very small value of lambda.min.ratio will lead to a saturated fit in the
nobs &lt; nvars case.</p>
</td></tr>
<tr><td><code id="lambdalasso_+3A_epsilon">epsilon</code></td>
<td>
<p>Convergence threshold for block relaxation of the entire
parameter vector <code class="reqn">\Theta = ( \beta, \eta, \sigma^2 )</code>. The algorithm
converges when </p>
<p style="text-align: center;"><code class="reqn">crossprod(\Theta_{j+1} - \Theta_{j}) &lt; \epsilon</code>
</p>
<p>.
Defaults value is 1E-4</p>
</td></tr>
<tr><td><code id="lambdalasso_+3A_tol.kkt">tol.kkt</code></td>
<td>
<p>KKT tolerance. Currently ignored</p>
</td></tr>
<tr><td><code id="lambdalasso_+3A_eta_init">eta_init</code></td>
<td>
<p>initial value for the eta parameter, with <code class="reqn">0 &lt; \eta &lt; 1</code>
used in determining lambda.max and starting value for fitting algorithm.</p>
</td></tr>
<tr><td><code id="lambdalasso_+3A_nlambda">nlambda</code></td>
<td>
<p>the number of lambda values - default is 100.</p>
</td></tr>
<tr><td><code id="lambdalasso_+3A_scale_x">scale_x</code></td>
<td>
<p>should the columns of x be scaled - default is FALSE</p>
</td></tr>
<tr><td><code id="lambdalasso_+3A_center_y">center_y</code></td>
<td>
<p>should y be mean centered - default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A decreasing sequence of tuning parameters
</p>


<h3>Note</h3>

<p>This function isn't meant to be called directly by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggmix">ggmix</a></code>
</p>

<hr>
<h2 id='lmmlasso'>Estimation of Linear Mixed Model with Lasso Penalty</h2><span id='topic+lmmlasso'></span><span id='topic+lmmlasso.default'></span><span id='topic+lmmlasso.fullrank'></span>

<h3>Description</h3>

<p><code>lmmlasso</code> estimates the linear mixed model with lasso
penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmmlasso(ggmix_object, ...)

## Default S3 method:
lmmlasso(ggmix_object, ...)

## S3 method for class 'fullrank'
lmmlasso(
  ggmix_object,
  ...,
  penalty.factor,
  lambda,
  lambda_min_ratio,
  nlambda,
  n_design,
  p_design,
  eta_init,
  maxit,
  fdev,
  standardize,
  alpha,
  thresh_glmnet,
  epsilon,
  dfmax,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmmlasso_+3A_ggmix_object">ggmix_object</code></td>
<td>
<p>A ggmix_object object of class <code>lowrank</code> or
<code>fullrank</code></p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_...">...</code></td>
<td>
<p>Extra parameters. Currently ignored.</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to each
coefficient. This is a number that multiplies lambda to allow differential
shrinkage. Can be 0 for some variables, which implies no shrinkage, and
that variable is always included in the model. Default is 1 for all
variables</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied lambda sequence (this is the tuning parameter).
Typical usage is to have the program compute its own lambda sequence based
on nlambda and lambda.min.ratio. Supplying a value of lambda overrides
this. WARNING: use with care. Do not supply a single value for lambda (for
predictions after CV use predict() instead). Supply instead a decreasing
sequence of lambda values. glmnet relies on its warms starts for speed, and
its often faster to fit a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_lambda_min_ratio">lambda_min_ratio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of
lambda.max, the (data derived) entry value (i.e. the smallest value for
which all coefficients are zero). The default depends on the sample size
nobs relative to the number of variables nvars. If nobs &gt; nvars, the
default is 0.0001, close to zero. If nobs &lt; nvars, the default is 0.01. A
very small value of lambda.min.ratio will lead to a saturated fit in the
nobs &lt; nvars case.</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_nlambda">nlambda</code></td>
<td>
<p>the number of lambda values - default is 100.</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_n_design">n_design</code></td>
<td>
<p>total number of observations</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_p_design">p_design</code></td>
<td>
<p>number of variables in the design matrix, excluding the
intercept column</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_eta_init">eta_init</code></td>
<td>
<p>initial value for the eta parameter, with <code class="reqn">0 &lt; \eta &lt; 1</code>
used in determining lambda.max and starting value for fitting algorithm.</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda values;
default is 10^2.</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_fdev">fdev</code></td>
<td>
<p>Fractional deviance change threshold. If change in deviance
between adjacent lambdas is less than fdev, the solution path stops early.
factory default = 1.0e-5</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on the
original scale. Default is standardize=FALSE. If variables are in the same
units already, you might not wish to standardize.</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0 \leq \alpha \leq
1</code>. alpha=1 is the lasso penalty, and alpha=0 the ridge penalty.</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_thresh_glmnet">thresh_glmnet</code></td>
<td>
<p>Convergence threshold for coordinate descent for
updating beta parameters. Each inner coordinate-descent loop continues
until the maximum change in the objective after any coefficient update is
less than thresh times the null deviance. Defaults value is 1E-7</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_epsilon">epsilon</code></td>
<td>
<p>Convergence threshold for block relaxation of the entire
parameter vector <code class="reqn">\Theta = ( \beta, \eta, \sigma^2 )</code>. The algorithm
converges when </p>
<p style="text-align: center;"><code class="reqn">crossprod(\Theta_{j+1} - \Theta_{j}) &lt; \epsilon</code>
</p>
<p>.
Defaults value is 1E-4</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_dfmax">dfmax</code></td>
<td>
<p>limit the maximum number of variables in the model. Useful for
very large <code>p</code> (the total number of predictors in the design matrix),
if a partial path is desired. Default is the number of columns in the
design matrix + 2 (for the variance components)</p>
</td></tr>
<tr><td><code id="lmmlasso_+3A_verbose">verbose</code></td>
<td>
<p>display progress. Can be either 0,1 or 2. 0 will not display
any progress, 2 will display very detailed progress and 1 is somewhere in
between. Default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object of class <code>ggmix</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggmix">ggmix</a></code>
</p>

<hr>
<h2 id='logliklasso'>Estimation of Log-likelihood for Linear Mixed Model with Lasso Penalty</h2><span id='topic+logliklasso'></span><span id='topic+logliklasso.default'></span><span id='topic+logliklasso.fullrank'></span>

<h3>Description</h3>

<p><code>sigma2lasso</code> estimates the value of the sigma2 for the
linear mixed model with lasso penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logliklasso(ggmix_object, ...)

## Default S3 method:
logliklasso(ggmix_object, ...)

## S3 method for class 'fullrank'
logliklasso(ggmix_object, ..., eta, sigma2, beta, nt, x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logliklasso_+3A_ggmix_object">ggmix_object</code></td>
<td>
<p>A ggmix_object object of class <code>lowrank</code> or
<code>fullrank</code></p>
</td></tr>
<tr><td><code id="logliklasso_+3A_...">...</code></td>
<td>
<p>Extra parameters. Currently ignored.</p>
</td></tr>
<tr><td><code id="logliklasso_+3A_eta">eta</code></td>
<td>
<p>current estimate of the eta parameter</p>
</td></tr>
<tr><td><code id="logliklasso_+3A_sigma2">sigma2</code></td>
<td>
<p>current estimate of the sigma2 parameter</p>
</td></tr>
<tr><td><code id="logliklasso_+3A_beta">beta</code></td>
<td>
<p>current estimate of the beta parameter including the intercept.
this should be of length p+1, where p is the number of variables.</p>
</td></tr>
<tr><td><code id="logliklasso_+3A_nt">nt</code></td>
<td>
<p>total number of observations</p>
</td></tr>
<tr><td><code id="logliklasso_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension n x p; where n is the number of
observations and p are the number of predictors.</p>
</td></tr>
<tr><td><code id="logliklasso_+3A_y">y</code></td>
<td>
<p>response variable. must be a quantitative variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A decreasing sequence of tuning parameters
</p>


<h3>Note</h3>

<p>This function isn't meant to be called directly by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggmix">ggmix</a></code>
</p>
<p><code><a href="#topic+ggmix_data_object">ggmix_data_object</a></code>
</p>

<hr>
<h2 id='plot.ggmix_fit'>Plot Method for <code>ggmix_fit</code> object</h2><span id='topic+plot.ggmix_fit'></span><span id='topic+plotCoef'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient paths for
a fitted <code>ggmix_fit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggmix_fit'
plot(x, ..., xvar = c("norm", "lambda", "dev"), label = FALSE, sign.lambda = 1)

plotCoef(
  beta,
  norm,
  lambda,
  df,
  dev,
  label = FALSE,
  xvar = c("norm", "lambda", "dev"),
  xlab = iname,
  ylab = "Coefficients",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ggmix_fit_+3A_x">x</code></td>
<td>
<p>a <code>ggmix_fit</code> object</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_...">...</code></td>
<td>
<p>other graphical parameters passed to <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_xvar">xvar</code></td>
<td>
<p>What is on the X-axis. &quot;norm&quot; plots against the L1-norm of the
coefficients, &quot;lambda&quot; against the log-lambda sequence, and &quot;dev&quot; against
the percent deviance explained.</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_label">label</code></td>
<td>
<p>If TRUE, label the curves with variable sequence numbers.</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>Either plot against log(lambda) (default) or its negative
if sign.lambda=-1</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_beta">beta</code></td>
<td>
<p>fixed effects estimates</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_norm">norm</code></td>
<td>
<p>l1 norm of fixed effect estimates. if missing, (default) this
function will calculate it</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_lambda">lambda</code></td>
<td>
<p>sequence of tuning parameters</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_df">df</code></td>
<td>
<p>number of non-zero fixed + random effects</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_dev">dev</code></td>
<td>
<p>percent deviance</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plot.ggmix_fit_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coefficient profile plot is produced
</p>


<h3>Value</h3>

<p>A plot is produced and nothing is returned
</p>

<hr>
<h2 id='plot.ggmix_gic'>Plot the Generalised Information Criteria curve produced by <code>gic</code></h2><span id='topic+plot.ggmix_gic'></span><span id='topic+plotGIC'></span>

<h3>Description</h3>

<p>Plots the Generalised Information Criteria curve, as a function
of the lambda values used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggmix_gic'
plot(
  x,
  ...,
  sign.lambda = 1,
  type = c("gic", "QQranef", "QQresid", "predicted", "Tukey-Anscombe"),
  s = "lambda.min",
  newy,
  newx
)

plotGIC(x, sign.lambda, lambda.min, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ggmix_gic_+3A_x">x</code></td>
<td>
<p>fitted linear mixed model object of class <code>ggmix_gic</code> from the
<code><a href="#topic+gic">gic</a></code> function</p>
</td></tr>
<tr><td><code id="plot.ggmix_gic_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to plot</p>
</td></tr>
<tr><td><code id="plot.ggmix_gic_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>Either plot against log(lambda) (default) or its negative
if sign.lambda=-1</p>
</td></tr>
<tr><td><code id="plot.ggmix_gic_+3A_type">type</code></td>
<td>
<p><code>gic</code> returns a plot of the GIC vs. log(lambda).
<code>QQranef</code> return a qqplot of the random effects. <code>QQresid</code>
returns a qqplot of the residuals which is <code class="reqn">y - X\beta - b_i</code> where b_i
is the subject specific random effect. <code>predicted</code> returns a plot of
the predicted response (<code class="reqn">X \beta</code> + b_i) vs. the observed response,
where b_i is the subject specific random effect. <code>Tukey-Anscombe</code>
returns a plot of the residuals vs. fitted values (<code class="reqn">X \beta</code>)</p>
</td></tr>
<tr><td><code id="plot.ggmix_gic_+3A_s">s</code></td>
<td>
<p>Value of the penalty parameter <code>lambda</code> at which predictions
are required. Default is the value <code>s="lambda.min"</code>. If <code>s</code> is
numeric, it is taken as the value of <code>lambda</code> to be used. Must be a
single value of the penalty parameter <code>lambda</code> at which coefficients
will be extracted via the <code>coef</code> method for objects of class
<code>ggmix_gic</code>. If more than one is supplied, only the first one will be
used.</p>
</td></tr>
<tr><td><code id="plot.ggmix_gic_+3A_newy">newy</code></td>
<td>
<p>the response variable that was provided to <code>ggmix</code>. this is
only required for <code>type="QQresis"</code>, <code>type="Tukey-Anscombe"</code> and
<code>type="predicted"</code></p>
</td></tr>
<tr><td><code id="plot.ggmix_gic_+3A_newx">newx</code></td>
<td>
<p>matrix of values for <code>x</code> at which predictions are to be
made. Do not include the intercept. this is only required for
<code>type="QQresis"</code>, <code>type="Tukey-Anscombe"</code> and
<code>type="predicted"</code></p>
</td></tr>
<tr><td><code id="plot.ggmix_gic_+3A_lambda.min">lambda.min</code></td>
<td>
<p>the value of lambda which minimizes the gic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot is produced, and nothing is returned.
</p>


<h3>Value</h3>

<p>plot depends on the type selected
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gic">gic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("admixed")
fit &lt;- ggmix(x = admixed$xtrain,
             y = admixed$ytrain,
             kinship = admixed$kin_train)
hdbic &lt;- gic(fit)

# plot solution path
plot(fit)

# plot HDBIC curve as a function of lambda
plot(hdbic)
</code></pre>

<hr>
<h2 id='predict.ggmix_fit'>Make predictions from a <code>ggmix_fit</code> object</h2><span id='topic+predict.ggmix_fit'></span><span id='topic+coef.ggmix_fit'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted
values, coefficients and more from a fitted <code>ggmix_fit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggmix_fit'
predict(
  object,
  newx,
  s = NULL,
  type = c("link", "response", "coefficients", "all", "nonzero", "individual"),
  covariance,
  ...
)

## S3 method for class 'ggmix_fit'
coef(object, s = NULL, type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ggmix_fit_+3A_object">object</code></td>
<td>
<p>Fitted <code>ggmix_fit</code> model object from the
<code><a href="#topic+ggmix">ggmix</a></code> function</p>
</td></tr>
<tr><td><code id="predict.ggmix_fit_+3A_newx">newx</code></td>
<td>
<p>matrix of values for <code>x</code> at which predictions are to be
made. Do not include the intercept. Must be a matrix. This argument is not
used for <code>type = c("coefficients","nonzero","all")</code>. This matrix must
have the same number of columns originally supplied to the
<code><a href="#topic+ggmix">ggmix</a></code> fitting function.</p>
</td></tr>
<tr><td><code id="predict.ggmix_fit_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which predictions
are required. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="predict.ggmix_fit_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type <code>"link"</code> gives the fitted
values <code class="reqn">X \beta</code>. Type <code>"response"</code> is equivalent to type
<code>"link"</code>. Type <code>"coefficients"</code> computes the coefficients at the
requested values for <code>s</code> and returns the regression coefficients only,
including the intercept. Type <code>"all"</code> returns both the regression
coefficients and variance components at the requested value of <code>s</code>.
Type <code>"nonzero"</code> returns a 1 column matrix of the the nonzero fixed
effects, as well as variance components for each value of <code>s</code>. If more
than one <code>s</code> is provided, then <code>"nonzero"</code> will return a list of
1 column matrices. Default: &quot;link&quot;</p>
</td></tr>
<tr><td><code id="predict.ggmix_fit_+3A_covariance">covariance</code></td>
<td>
<p>covariance between test and training individuals. if there
are q testing individuals and N-q training individuals, then this
covariance matrix is q x (N-q)</p>
</td></tr>
<tr><td><code id="predict.ggmix_fit_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to predict function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are requested. If
<code>s</code> is not in the lambda sequence used for fitting the model, the
predict function will use linear interpolation to make predictions. The new
values are interpolated using a fraction of predicted values from both left
and right lambda indices. <code>coef(...)</code> is equivalent to
<code>predict(ggmix_fit, type="coefficients",...)</code>. To get individual level
predictions at each value of lambda, you must provide the lambda sequence
to the s argument. You can pass either a ggmix_fit or ggmix_gic object. See
examples for more details.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("admixed")
fitlmm &lt;- ggmix(x = admixed$xtrain, y = admixed$ytrain,
                kinship = admixed$kin_train,
                estimation = "full")
bicGGMIX &lt;- gic(fitlmm,
                an = log(length(admixed$ytrain)))
plot(bicGGMIX)
coef(bicGGMIX, s = "lambda.min")
yhat_test &lt;- predict(bicGGMIX, s="lambda.min",
                     newx = admixed$xtest, type = "individual",
                     covariance = admixed$kin_test_train)
cor(yhat_test, admixed$ytest)
yhat_test_population &lt;- predict(bicGGMIX, s="lambda.min",
                                newx = admixed$xtest,
                                type = "response")
</code></pre>

<hr>
<h2 id='predict.ggmix_gic'>Make predictions from a <code>ggmix_gic</code> object</h2><span id='topic+predict.ggmix_gic'></span><span id='topic+coef.ggmix_gic'></span>

<h3>Description</h3>

<p>This function makes predictions from a <code>ggmix_gic</code> object,
using the stored &quot;ggmix_fit&quot; object, and the optimal value chosen for
lambda using the gic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggmix_gic'
predict(object, newx, s = c("lambda.min"), ...)

## S3 method for class 'ggmix_gic'
coef(object, s = c("lambda.min"), type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ggmix_gic_+3A_object">object</code></td>
<td>
<p>fitted <code>ggmix_gic</code> object</p>
</td></tr>
<tr><td><code id="predict.ggmix_gic_+3A_newx">newx</code></td>
<td>
<p>matrix of values for <code>x</code> at which predictions are to be
made. Do not include the intercept. Must be a matrix. This argument is not
used for <code>type = c("coefficients","nonzero","all")</code>. This matrix must
have the same number of columns originally supplied to the
<code><a href="#topic+ggmix">ggmix</a></code> fitting function.</p>
</td></tr>
<tr><td><code id="predict.ggmix_gic_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which predictions
are required. Default is the value <code>s="lambda.min"</code> can be used. If
<code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be
used.</p>
</td></tr>
<tr><td><code id="predict.ggmix_gic_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+predict.ggmix_fit">predict.ggmix_fit</a></code></p>
</td></tr>
<tr><td><code id="predict.ggmix_gic_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type <code>"link"</code> gives the fitted
values <code class="reqn">X \beta</code>. Type <code>"response"</code> is equivalent to type
<code>"link"</code>. Type <code>"coefficients"</code> computes the coefficients at the
requested values for <code>s</code> and returns the regression coefficients only,
including the intercept. Type <code>"all"</code> returns both the regression
coefficients and variance components at the requested value of <code>s</code>.
Type <code>"nonzero"</code> returns a 1 column matrix of the the nonzero fixed
effects, as well as variance components for each value of <code>s</code>. If more
than one <code>s</code> is provided, then <code>"nonzero"</code> will return a list of
1 column matrices. Default: &quot;link&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of gic chosen model
to make a prediction.
</p>


<h3>Value</h3>

<p>The object returned depends the ... argument which is passed on to
the predict method for <code>ggmix_fit</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.ggmix_fit">predict.ggmix_fit</a></code>
</p>

<hr>
<h2 id='print.ggmix_fit'>Print Method for Objects of Class <code>ggmix_fit</code></h2><span id='topic+print.ggmix_fit'></span><span id='topic+print.ggmix_gic'></span>

<h3>Description</h3>

<p>print method for objects of class <code>ggmix_fit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggmix_fit'
print(x, ..., digits = max(3, getOption("digits") - 3))

## S3 method for class 'ggmix_gic'
print(x, ..., digits = max(3, getOption("digits") - 3))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ggmix_fit_+3A_x">x</code></td>
<td>
<p>an object of class objects of class <code>ggmix_fit</code></p>
</td></tr>
<tr><td><code id="print.ggmix_fit_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>print</code></p>
</td></tr>
<tr><td><code id="print.ggmix_fit_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout. Default: <code>max(3,
getOption("digits") - 3)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The call that produced the object <code>x</code> is printed, followed by a
three-column matrix with columns <code>Df</code>, <code>%Dev</code>, and and
<code>Lambda</code>. The <code>Df</code> columns correspond to the number of nonzero
coefficients including variance components. <code>%dev</code> is the percent
deviance explained (relative to the null deviance). <code>Lambda</code> is the
sequence of converged tuning parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggmix">ggmix</a></code>
</p>

<hr>
<h2 id='ranef'>Extract Random Effects</h2><span id='topic+ranef'></span><span id='topic+random.effects'></span><span id='topic+random.effects.default'></span><span id='topic+ranef.default'></span><span id='topic+ranef.ggmix_gic'></span>

<h3>Description</h3>

<p>Generic function for extracting the random effects. This is the
same generic (and same name) defined in the nlme and lme4 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranef(object, ...)

random.effects(object, ...)

## Default S3 method:
random.effects(object, ...)

## Default S3 method:
ranef(object, ...)

## S3 method for class 'ggmix_gic'
ranef(object, s = "lambda.min", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranef_+3A_object">object</code></td>
<td>
<p>any fitted model object from which random effects estimates can
be extracted. Currently supports &quot;ggmix_gic&quot; objects outputted by the
<code><a href="#topic+gic">gic</a></code> function</p>
</td></tr>
<tr><td><code id="ranef_+3A_...">...</code></td>
<td>
<p>other parameters. currently ignored</p>
</td></tr>
<tr><td><code id="ranef_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which predictions
are required. Default is the value <code>s="lambda.min"</code> can be used. If
<code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects of class &quot;ggmix_gic&quot;, this function returns the
subject-specific random effect value for the model which minimizes the GIC
using the maximum a posteriori principle
</p>


<h3>Value</h3>

<p>a numeric vector of length equal to the number of observations of
subject-specific random effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gic">gic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("admixed")
fit &lt;- ggmix(x = admixed$xtrain, y = admixed$ytrain,
            kinship = admixed$kin_train)
gicfit &lt;- gic(fit)
# random effect at selected value of lambda
plot(ggmix::ranef(gicfit))
# random effects at specific values of lambda
head(ggmix::ranef(gicfit, s = c(0.1,0.2)))
</code></pre>

<hr>
<h2 id='sigma2lasso'>Estimation of Sigma2 for Linear Mixed Model with Lasso Penalty</h2><span id='topic+sigma2lasso'></span><span id='topic+sigma2lasso.default'></span><span id='topic+sigma2lasso.fullrank'></span>

<h3>Description</h3>

<p><code>sigma2lasso</code> estimates the value of the sigma2 for the
linear mixed model with lasso penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma2lasso(ggmix_object, ...)

## Default S3 method:
sigma2lasso(ggmix_object, ...)

## S3 method for class 'fullrank'
sigma2lasso(ggmix_object, ..., n, beta, eta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma2lasso_+3A_ggmix_object">ggmix_object</code></td>
<td>
<p>A ggmix_object object of class <code>lowrank</code> or
<code>fullrank</code></p>
</td></tr>
<tr><td><code id="sigma2lasso_+3A_...">...</code></td>
<td>
<p>Extra parameters. Currently ignored.</p>
</td></tr>
<tr><td><code id="sigma2lasso_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="sigma2lasso_+3A_beta">beta</code></td>
<td>
<p>current estimate of the beta parameter including the intercept.
this should be of length p+1, where p is the number of variables.</p>
</td></tr>
<tr><td><code id="sigma2lasso_+3A_eta">eta</code></td>
<td>
<p>current estimate of the eta parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A decreasing sequence of tuning parameters
</p>


<h3>Note</h3>

<p>There is a closed form solution for sigma^2, given beta and eta. This
function isn't meant to be called directly by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggmix">ggmix</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
