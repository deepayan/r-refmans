<!DOCTYPE html><html><head><title>Help for package splinetree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splinetree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#avSize'><p>Compute the average tree size in a forest</p></a></li>
<li><a href='#flatten_predictors'><p>Flattens predictor variable data into one row per person</p></a></li>
<li><a href='#forest'><p>Sample forest used in vignettes</p></a></li>
<li><a href='#getBasisMat'><p>Get the basis matrix to be used for this spline tree</p></a></li>
<li><a href='#getNodeData'><p>Retrieve the subset of the data found at a given terminal node</p></a></li>
<li><a href='#importance'><p>Sample importance used in vignettes</p></a></li>
<li><a href='#individual_spline'><p>Get spline coefficients for a single person</p></a></li>
<li><a href='#nlsySample'><p>Baseline socioeconomic information and BMI of 100 individuals.</p></a></li>
<li><a href='#nodePlot'><p>Plots the trajectories of each terminal node side by side.</p></a></li>
<li><a href='#plotImp'><p>Create a barplot of relative variable importance scores.</p></a></li>
<li><a href='#plotNode'><p>Plot the predicted trajectory for a single node</p></a></li>
<li><a href='#predict_y_training'><p>Predict responses for the training data</p></a></li>
<li><a href='#predictCoeffs'><p>Predict spline coefficients for a testset using a spline tree</p></a></li>
<li><a href='#predictCoeffsForest'><p>Predict spline coefficients for a testset using a splineforest.</p></a></li>
<li><a href='#predictY'><p>Predictions from a spline tree</p></a></li>
<li><a href='#predictYForest'><p>Predict responses for a testset using a splineforest.</p></a></li>
<li><a href='#projectedR2'><p>Computes percent of variation in projected response explained by a splinetree.</p></a></li>
<li><a href='#projectedR2Forest'><p>Computes a level-based or shape-based evaluation metric for a splineforest.</p></a></li>
<li><a href='#pruneForest'><p>Prune each tree in forest using a given complexity parameter.</p></a></li>
<li><a href='#rpartco'><p>Calculates coordinates for tree plot</p></a></li>
<li><a href='#spaghettiPlot'><p>Create a faceted spaghetti plot of a splinetree model</p></a></li>
<li><a href='#spline_eval'><p>Custom rpart eval function.</p></a></li>
<li><a href='#spline_init'><p>Custom rpart init function</p></a></li>
<li><a href='#spline_split'><p>Custom rpart split function.</p></a></li>
<li><a href='#splineForest'><p>Build a spline random forest.</p></a></li>
<li><a href='#splineforest_split'><p>Custom rpart split function for spline random forests</p></a></li>
<li><a href='#splineTree'><p>Build a splinetree model.</p></a></li>
<li><a href='#splineTreePlot'><p>Creates a tree plot of a spline tree.</p></a></li>
<li><a href='#stPlot'><p>Plots a splinetree.</p></a></li>
<li><a href='#stPrint'><p>Print a spline tree in the style of print.rpart</p></a></li>
<li><a href='#terminalNodeSummary'><p>Prints a summary of a terminal node in a tree</p></a></li>
<li><a href='#tree'><p>Sample tree used in examples</p></a></li>
<li><a href='#tree.depth'><p>Given a list of node numbers, returns the depth at which these appear in the tree.</p></a></li>
<li><a href='#treeSimilarity'><p>Returns a measure of how similar the two trees are.</p></a></li>
<li><a href='#treeSize'><p>Returns number of terminal nodes in a tree.</p></a></li>
<li><a href='#treeSummary'><p>Returns the tree frame.</p></a></li>
<li><a href='#varImpCoeff'><p>Random Forest Variable Importance based on spline coefficients</p></a></li>
<li><a href='#varImpY'><p>Random Forest Variable Importance based on Y</p></a></li>
<li><a href='#yR2'><p>Computes percent of variation in response explained by spline tree.</p></a></li>
<li><a href='#yR2Forest'><p>Computes a level-based evaluation metric for a splineforest that was built WITH an intercept.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Longitudinal Regression Trees and Forests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Builds regression trees and random forests for longitudinal or functional data using a spline projection method. Implements and extends the work of Yu and Lambert (1999) &lt;<a href="https://doi.org/10.1080%2F10618600.1999.10474847">doi:10.1080/10618600.1999.10474847</a>&gt;. This method allows trees and forests to be built while considering either level and shape or only shape of response trajectories. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), rpart, nlme, splines</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>mosaic, ggplot2, treeClust, mclust</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/anna-neufeld/splinetree/issues">https://github.com/anna-neufeld/splinetree/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/anna-neufeld/splinetree">https://github.com/anna-neufeld/splinetree</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-16 17:59:24 UTC; annaneufeld</td>
</tr>
<tr>
<td>Author:</td>
<td>Anna Neufeld [aut, cre],
  Brianna Heggeseth [aut, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anna Neufeld &lt;aneufeld@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-18 06:36:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='avSize'>Compute the average tree size in a forest</h2><span id='topic+avSize'></span>

<h3>Description</h3>

<p>Returns the average number of terminal nodes for trees in a forest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avSize(forest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avSize_+3A_forest">forest</code></td>
<td>
<p>A model returned by splineForest()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The average number of terminal nodes in forest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>avSize(forest)
</code></pre>

<hr>
<h2 id='flatten_predictors'>Flattens predictor variable data into one row per person</h2><span id='topic+flatten_predictors'></span>

<h3>Description</h3>

<p>Assumes that splitting explanatory variables do not vary with time. Spline Tree is not meant to handle time-varying covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_predictors(idvar, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_predictors_+3A_idvar">idvar</code></td>
<td>
<p>The string name of the ID variable (used to group observations)</p>
</td></tr>
<tr><td><code id="flatten_predictors_+3A_data">data</code></td>
<td>
<p>The full dataset to be flattened (long form)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A wide format dataset with spline coefficients as the responses.
</p>

<hr>
<h2 id='forest'>Sample forest used in vignettes</h2><span id='topic+forest'></span>

<h3>Description</h3>

<p>Sample forest used in vignettes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forest
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 15.</p>

<hr>
<h2 id='getBasisMat'>Get the basis matrix to be used for this spline tree</h2><span id='topic+getBasisMat'></span>

<h3>Description</h3>

<p>Using the user-specified parameters or the default parameters, computes the basis matrix that will be used for building the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBasisMat(yvar, tvar, idvar, data, knots = NULL, df, degree, intercept,
  gridPoints, nGrid = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBasisMat_+3A_yvar">yvar</code></td>
<td>
<p>Name of response variable (string)</p>
</td></tr>
<tr><td><code id="getBasisMat_+3A_tvar">tvar</code></td>
<td>
<p>Name of time variable (string)</p>
</td></tr>
<tr><td><code id="getBasisMat_+3A_idvar">idvar</code></td>
<td>
<p>Name of ID variable (string)</p>
</td></tr>
<tr><td><code id="getBasisMat_+3A_data">data</code></td>
<td>
<p>Full dataset</p>
</td></tr>
<tr><td><code id="getBasisMat_+3A_knots">knots</code></td>
<td>
<p>Knots argument specified by user. Specifies location of INTERNAL knots.</p>
</td></tr>
<tr><td><code id="getBasisMat_+3A_df">df</code></td>
<td>
<p>Degrees of freedom argument specified by user</p>
</td></tr>
<tr><td><code id="getBasisMat_+3A_degree">degree</code></td>
<td>
<p>The degree of the spline polynomial</p>
</td></tr>
<tr><td><code id="getBasisMat_+3A_intercept">intercept</code></td>
<td>
<p>Whether or not to use an intercept</p>
</td></tr>
<tr><td><code id="getBasisMat_+3A_gridpoints">gridPoints</code></td>
<td>
<p>Optional. A vector of numbers that will be used as the grid on which to evaluate the
projection sum of squares. Should fall roughly within the range of the time variable.</p>
</td></tr>
<tr><td><code id="getBasisMat_+3A_ngrid">nGrid</code></td>
<td>
<p>Number of grid points to evaluate split function at.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The basis matrix to be used for the tree building process
</p>

<hr>
<h2 id='getNodeData'>Retrieve the subset of the data found at a given terminal node</h2><span id='topic+getNodeData'></span>

<h3>Description</h3>

<p>Given a terminal node number, this function returns the data belonging to
this terminal node. If the dataType argument is 'all', returns all rows of data from the
original dataset that fall in this node.  Otherwise, the flattened data that belongs to
this node is returned (one row of data per ID, original responses replaced by spline coefficients).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNodeData(tree, node, dataType = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNodeData_+3A_tree">tree</code></td>
<td>
<p>a model returned from splineTree()</p>
</td></tr>
<tr><td><code id="getNodeData_+3A_node">node</code></td>
<td>
<p>The number of the node to retrieve data from. Must be valid
number of a terminal node. Node numbers can be seen using stPrint(tree)
or treeSummary(tree).</p>
</td></tr>
<tr><td><code id="getNodeData_+3A_datatype">dataType</code></td>
<td>
<p>If &quot;all&quot;, the data returned is from the original dataset (one row per individual observation
with original response values). If &quot;flat&quot;, the data returned is the flattened data (one row per person/unit),
with individual spline coefficients instead of response values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe which holds all the data that falls into this node of the tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
split_formula &lt;- BMI ~ HISP + WHITE + BLACK + SEX +
  Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, 'ID', nlsySample, degree=1,
  df=3, intercept=TRUE, cp=0.006, minNodeSize=20)

## End(Not run)
node6data &lt;- getNodeData(tree, 6, dataType = 'all')
plot(BMI~AGE, data=node6data)
</code></pre>

<hr>
<h2 id='importance'>Sample importance used in vignettes</h2><span id='topic+importance'></span>

<h3>Description</h3>

<p>Sample importance used in vignettes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importance
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.</p>

<hr>
<h2 id='individual_spline'>Get spline coefficients for a single person</h2><span id='topic+individual_spline'></span>

<h3>Description</h3>

<p>Get spline coefficients for a single person
</p>


<h3>Usage</h3>

<pre><code class='language-R'>individual_spline(person, idvar, yvar, tvar, data, boundaryKnots,
  innerKnots, degree, intercept)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="individual_spline_+3A_person">person</code></td>
<td>
<p>ID of this person</p>
</td></tr>
<tr><td><code id="individual_spline_+3A_idvar">idvar</code></td>
<td>
<p>name of the id variable (string)</p>
</td></tr>
<tr><td><code id="individual_spline_+3A_yvar">yvar</code></td>
<td>
<p>the name of the response variable</p>
</td></tr>
<tr><td><code id="individual_spline_+3A_tvar">tvar</code></td>
<td>
<p>name of time variable (string)</p>
</td></tr>
<tr><td><code id="individual_spline_+3A_data">data</code></td>
<td>
<p>full dataset</p>
</td></tr>
<tr><td><code id="individual_spline_+3A_boundaryknots">boundaryKnots</code></td>
<td>
<p>the boundary knots for the bspline</p>
</td></tr>
<tr><td><code id="individual_spline_+3A_innerknots">innerKnots</code></td>
<td>
<p>the inner knots for the bspline</p>
</td></tr>
<tr><td><code id="individual_spline_+3A_degree">degree</code></td>
<td>
<p>the degree of the bspline</p>
</td></tr>
<tr><td><code id="individual_spline_+3A_intercept">intercept</code></td>
<td>
<p>whether or not to include an intercept</p>
</td></tr>
</table>

<hr>
<h2 id='nlsySample'>Baseline socioeconomic information and BMI of 100 individuals.</h2><span id='topic+nlsySample'></span>

<h3>Description</h3>

<p>A dataset containing the body mass index (BMI) and baseline
socioeconomic information of 100 individuals from the National
Longitudinal Survey of Youth 1979 (NLSY), a freely available longitudinal dataset.
The 1000 individuals were drawn randomly from among all NLSY respondents with at least 10
non-missing height/weight responses spread out over at least 20 years.
This dataset is used in the package vignettes and code examples. Only a small
subset of the variables available from the NLSY are included here.
See https://www.bls.gov/nls/nlsy79.htm for more
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsySample
</code></pre>


<h3>Format</h3>

<p>A data frame with 16126 rows and 34 columns.
</p>

<dl>
<dt>ID</dt><dd><p>Unique identifier for each NLSY respondent</p>
</dd>
<dt>SEX</dt><dd><p>Respondent's sex. 1 denotes male, 2 denotes female.</p>
</dd>
<dt>AGE</dt><dd><p>Respondent's age</p>
</dd>
<dt>BLACK</dt><dd><p>Indicator for whether or not respondent's identified as Black</p>
</dd>
<dt>BMI</dt><dd><p>Respondent's body mass index - calculated from reported height and weight</p>
</dd>
<dt>HGC_FATHER</dt><dd><p>Highest grade completed by respondent's father</p>
</dd>
<dt>HGC_MOTHER</dt><dd><p>Highest grade completed by respondent's mother</p>
</dd>
<dt>HISP</dt><dd><p>Indicator for whether or not respondent's race identified as Hispanic</p>
</dd>
<dt>Num_sibs</dt><dd><p>Number of siblings of respondent</p>
</dd>
<dt>WHITE</dt><dd><p>Indicator for whether or not respondent identified as white.</p>
</dd>
<dt>HGC</dt><dd><p>Highest grade completed by respondent</p>
</dd>
<dt>Age_first_smoke</dt><dd><p>Age that respondent reported first using tobacco. If they reported never using tobacco, recorded as 100.</p>
</dd>
<dt>Age_first_alc</dt><dd><p>Age that respondent reported first drinking alcohol. If they reported never drinking alcohol, recorded as 100.</p>
</dd>
<dt>RACE</dt><dd><p>Race, as recorded by NLSY. 1 denotes Hispanic, 2 denotes Black, 3 denotes White.</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="https://www.bls.gov/nls/nlsy79.htm">https://www.bls.gov/nls/nlsy79.htm</a>
</p>

<hr>
<h2 id='nodePlot'>Plots the trajectories of each terminal node side by side.</h2><span id='topic+nodePlot'></span>

<h3>Description</h3>

<p>Corresponds to plotting only the second panel of stPlot(). If model$intercept==FALSE, estimated
intercepts are added to each trajectory so that the trajectories are plotted at the level of reasonable
response values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodePlot(model, colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodePlot_+3A_model">model</code></td>
<td>
<p>A model returned from splineTree()</p>
</td></tr>
<tr><td><code id="nodePlot_+3A_colors">colors</code></td>
<td>
<p>A list of colors to use. By default, uses colors drawn from a rainbow.</p>
</td></tr>
</table>

<hr>
<h2 id='plotImp'>Create a barplot of relative variable importance scores.</h2><span id='topic+plotImp'></span>

<h3>Description</h3>

<p>Given a named vector of variable importance measures, this function makes a barplot of the relative importances.
The importances are scaled to sum to 1. An appropriate input is one column of the output from
varImpY() or varImpCoeff().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImp(importance_vector, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotImp_+3A_importance_vector">importance_vector</code></td>
<td>
<p>a named vector where the names are the variables and the vector stores the importances.</p>
</td></tr>
<tr><td><code id="plotImp_+3A_...">...</code></td>
<td>
<p>additional arguments to plot, such as &quot;main&quot;, &quot;cex&quot;, etc.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>imp &lt;- varImpCoeff(forest)[,3]
plotImp(imp, main="Standardized Variable Importance")
</code></pre>

<hr>
<h2 id='plotNode'>Plot the predicted trajectory for a single node</h2><span id='topic+plotNode'></span>

<h3>Description</h3>

<p>Creates a simple plot of the predicted trajectory at a given node. Option to include
the data that falls in the node on the same plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNode(tree, node, includeData = FALSE, estimateIntercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNode_+3A_tree">tree</code></td>
<td>
<p>A model returned from splineTree()</p>
</td></tr>
<tr><td><code id="plotNode_+3A_node">node</code></td>
<td>
<p>A node number. Must be a valid terminal node for the given spline tree.
To view valid terminal node numbers, use stPrint() or treeSummary().</p>
</td></tr>
<tr><td><code id="plotNode_+3A_includedata">includeData</code></td>
<td>
<p>Would you like to see the data from the node
plotted along with the predicted trajectory?</p>
</td></tr>
<tr><td><code id="plotNode_+3A_estimateintercept">estimateIntercept</code></td>
<td>
<p>If the tree was built without an intercept, should
the average starting response of all the individuals in the node be added to the trajectory
to give the plot interpretable values? Or should the shape of the
trajectory be plotted without any regard to the intercept?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
split_formula &lt;- ~HISP + WHITE + BLACK + SEX + Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, idvar = "ID",
   data = nlsySample, degree = 1, df = 3,
   intercept = TRUE, cp = 0.005)

plotNode(tree, 6, includeData=TRUE)
</code></pre>

<hr>
<h2 id='predict_y_training'>Predict responses for the training data</h2><span id='topic+predict_y_training'></span>

<h3>Description</h3>

<p>Calling predictY(model) and predict_y_training(model) return identical results, because when no test data is
provided to predictY(), the default is to use the training set. This is a slightly faster version that
can be used when you know that you wish to predict on the training data. It is faster because it takes advantage
of the relationship between model$parms$flat_data and model$parms$data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_y_training(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_y_training_+3A_model">model</code></td>
<td>
<p>a model created with splineTree()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted responses where each element in the vector corresponds to a row in model$parms$data.
</p>

<hr>
<h2 id='predictCoeffs'>Predict spline coefficients for a testset using a spline tree</h2><span id='topic+predictCoeffs'></span>

<h3>Description</h3>

<p>Returns a matrix of spline coefficients for each observation in the testset. If no testset is provided,
returns predicted coefficients for the individuals in training set; in this case, the columns of the
returned predictions correspond to the rows of the flattened training dataset (found in tree$parms$flat_data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictCoeffs(tree, testset = tree$parms$flat_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictCoeffs_+3A_tree">tree</code></td>
<td>
<p>A model created with splineTree()</p>
</td></tr>
<tr><td><code id="predictCoeffs_+3A_testset">testset</code></td>
<td>
<p>The dataset to predict coefficients for. Default is the flattened dataset used to make the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>importFrom treeClust rpart.predict.leaves
</p>


<h3>Value</h3>

<p>A matrix of spline coefficients. The dimension of the matrix is the degrees of freedom of
the spline by the number of units in the test set. The ith column of the matrix holds the predicted
coefficients for the ith row in the testset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
split_formula &lt;- ~HISP + WHITE + BLACK + SEX + Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, idvar = "ID",
   data = nlsySample, degree = 1, df = 3,
   intercept = TRUE, cp = 0.005)

preds &lt;- predictCoeffs(tree)
</code></pre>

<hr>
<h2 id='predictCoeffsForest'>Predict spline coefficients for a testset using a splineforest.</h2><span id='topic+predictCoeffsForest'></span>

<h3>Description</h3>

<p>Uses the forest to predict spline coefficients. Returns a matrix of predicted spline coefficients where the columns
of the returned matrix correspond to rows of the testdata. The number of rows of the returned matrix is equal to the
degrees of freedom of the forest. If no testdata is provided, forest$flat_data is used. When testdata is not provided,
predictions will be made according to one of three methods. The &quot;method&quot; parameter must be either
&quot;oob&quot;, &quot;itb&quot;, or &quot;all&quot;. This parameter specifies which trees are used in making a prediction for a certain datapoint.
This parameter is not relevant when predicting for a testset that is distinct from the training set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictCoeffsForest(forest, method = "oob", testdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictCoeffsForest_+3A_forest">forest</code></td>
<td>
<p>A model returned from splineForest()</p>
</td></tr>
<tr><td><code id="predictCoeffsForest_+3A_method">method</code></td>
<td>
<p>A string; either &quot;oob&quot;, &quot;itb&quot;, or &quot;all&quot;.
If &quot;oob&quot; (the default), predictions for a given data point are made only using trees for which this
data point was &quot;out of the bag&quot; (not in the random subsample). If &quot;itb&quot;, predictions for
a given data point are made using only the trees for which this datapoint was &quot;in the bag&quot;
(in the random subsample). If &quot;all&quot;, all trees are used for every datapoint.</p>
</td></tr>
<tr><td><code id="predictCoeffsForest_+3A_testdata">testdata</code></td>
<td>
<p>The test data to make predictions for. If this is provided, then
all trees are used for all datapoints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of predicted spline coefficients. The dimensions are forest$df x nrow(testdata). Each column of the matrix
corresponds to a row of the testdata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trainingSetPreds &lt;- predictCoeffsForest(forest)
newData &lt;- data.frame("WHITE" = 0, "BLACK"=1, "HISP"=0, "Num_sibs"=3,
   "HGC_MOTHER"=12, "HGC_FATHER"=12, "SEX"=1)
predictCoeffsForest(forest, testdata = newData)
</code></pre>

<hr>
<h2 id='predictY'>Predictions from a spline tree</h2><span id='topic+predictY'></span>

<h3>Description</h3>

<p>Returns a vector of predicted responses for the testData. If testData is ommitted,
returns predictions for the training data. This function is most meaningful if model$intercept==TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictY(model, testData = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictY_+3A_model">model</code></td>
<td>
<p>A model created with splineTree()</p>
</td></tr>
<tr><td><code id="predictY_+3A_testdata">testData</code></td>
<td>
<p>The data to return predictions for. If ommitted, uses the training data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predictions with rows corresponding to the testdata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
split_formula &lt;- ~HISP + WHITE + BLACK + SEX + Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, idvar = "ID",
   data = nlsySample, degree = 1, df = 3,
   intercept = TRUE, cp = 0.005)

plot(predictY(tree), tree$parms$data[[tree$parms$yvar]])
</code></pre>

<hr>
<h2 id='predictYForest'>Predict responses for a testset using a splineforest.</h2><span id='topic+predictYForest'></span>

<h3>Description</h3>

<p>Uses the forest to make predictions of responses for individuals. This method should only be used
on forests where forest$intercept=TRUE. If the testdata parameter is
null, makes predictions for each row of the training data. In this case, the methods parameter (which should
be set to &quot;oob&quot;, &quot;itb&quot;, or &quot;all&quot;) determines the method used for prediction. If the testdata parameter is not
null, the methods parameter is ignored and all trees are used for the prediction of every datapoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictYForest(forest, method = "oob", testdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictYForest_+3A_forest">forest</code></td>
<td>
<p>A model returned from splineForest()</p>
</td></tr>
<tr><td><code id="predictYForest_+3A_method">method</code></td>
<td>
<p>A string. Must be either &quot;oob&quot;, &quot;itb&quot;, or &quot;all&quot;. Only relevant when testdata is NULL.
The default value is &quot;oob&quot;. If &quot;oob&quot;, predictions for a given data point are made only using
trees for which this data point was &quot;out of the bag&quot; (not in the random subsample).
If &quot;itb&quot;, predictions for a given data point are made using only the trees for which this datapoint
was in the bag (in the random subsample). If &quot;all&quot;, all trees are used for every datapoint.</p>
</td></tr>
<tr><td><code id="predictYForest_+3A_testdata">testdata</code></td>
<td>
<p>the Test data to make predictions for. If this is provided, then
all trees are used for all datapoints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted responses. The indices of the vector correspond to rows of the testdata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trainingSetPreds &lt;- predictYForest(forest)
newData &lt;- data.frame("AGE"=21, "WHITE" = 0, "BLACK"=1, "HISP"=0,
   "Num_sibs"=3, "HGC_MOTHER"=12, "HGC_FATHER"=12, "SEX"=1)
predictYForest(forest, testdata = newData)
</code></pre>

<hr>
<h2 id='projectedR2'>Computes percent of variation in projected response explained by a splinetree.</h2><span id='topic+projectedR2'></span>

<h3>Description</h3>

<p>Computes an R^2 measure for a splinetree based on the projected sum of squared errors. Returns 1-SSE/SST.
SSE is the sum of projection squared errors between individual smoothed trajectories and predicted smoothed
trajectories evaluated on a fixed grid. SST is the sum of projection squared errors between individual smoothed
trajectories and the overall population mean trajectory, evaluated on the same fixed grid.
If model$intercept==TRUE, then there is the option to ignore the intercept coefficient when computing this metric.
When the intercept is ignored, the metric captures how well the model explains variation in shape, and ignores
any variation in intercept explained by the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectedR2(model, includeIntercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectedR2_+3A_model">model</code></td>
<td>
<p>a model created with splineTree()</p>
</td></tr>
<tr><td><code id="projectedR2_+3A_includeintercept">includeIntercept</code></td>
<td>
<p>If FALSE and if the model was built with an intercept, the projected squared errors are computed
while ignoring the intercept. If the model was built without an intercept, this parameter does not do anything.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The percentage of variation in projected trajectory explained by the model. Computed as 1-SSE/SST. See description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r2 &lt;- projectedR2(tree)
</code></pre>

<hr>
<h2 id='projectedR2Forest'>Computes a level-based or shape-based evaluation metric for a splineforest.</h2><span id='topic+projectedR2Forest'></span>

<h3>Description</h3>

<p>Computes an R-squared-like evaluation metric for a spline forest. Goal is to see how well the predicted spline coefficients for each individual
match the spline coefficients obtained when fitting a spline only to this individual's data (we call these coefficients the true coefficients). Computes 1-SSE/SST, where SSE is the total
sum of squared projection errors of the true coefficients compared
to the predicted coefficients, and SST is the total sum of squared projection errors of the true coefficients compared to
the population mean coefficients. If this is an intercept forest, have the option to compute these sum of squares either with the intercept included or with the intercept ignored to isolate the shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectedR2Forest(forest, method = "oob", removeIntercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectedR2Forest_+3A_forest">forest</code></td>
<td>
<p>The output of a call to splineForest()</p>
</td></tr>
<tr><td><code id="projectedR2Forest_+3A_method">method</code></td>
<td>
<p>How would you like to compute this metric? The choices are &quot;oob&quot;, &quot;itb&quot;, or &quot;all&quot;.
&quot;oob&quot; means that predictions for a datapoint can only be made using trees for which that datapoint was
&quot;out of the bag&quot; (not in the random subsample). &quot;all&quot; means that all trees are used in the prediction for every
datapoint. &quot;itb&quot; means that predictions for a datapoint are made using only the trees for which this datapoint was IN the random subsample.</p>
</td></tr>
<tr><td><code id="projectedR2Forest_+3A_removeintercept">removeIntercept</code></td>
<td>
<p>If true, the projection sum of squared error is computed while ignoring the intercept coefficient.
This will help capture the tree's performance at clustering based on shape, not based on level.
This parameter is only meaningful if this forest was built using an intercept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns 1-SSE/SST, where SSE is the total sum of squared projection errors of the true coefficients compared
to the predicted coefficients, and SST is the total sum of squared projection errors of the true coefficients compared to
the population mean coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>projectedR2Forest(forest, method="all", removeIntercept=TRUE)

projectedR2Forest(forest, method="all", removeIntercept=FALSE)

</code></pre>

<hr>
<h2 id='pruneForest'>Prune each tree in forest using a given complexity parameter.</h2><span id='topic+pruneForest'></span>

<h3>Description</h3>

<p>Prunes each tree in the list forest$Trees according to the provided complexity parameter. Returns a new forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruneForest(forest, cp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pruneForest_+3A_forest">forest</code></td>
<td>
<p>A model returned by splineForest()</p>
</td></tr>
<tr><td><code id="pruneForest_+3A_cp">cp</code></td>
<td>
<p>The complexity parameter that will be used to prune each tree (see rpart package documentation for detailed description of complexity parameter)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new spline forest model (named list) where each tree has been pruned to the desired level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(avSize(forest))
print(avSize(pruneForest(forest, cp=0.007)))
print(avSize(pruneForest(forest, cp=0.01)))
</code></pre>

<hr>
<h2 id='rpartco'>Calculates coordinates for tree plot</h2><span id='topic+rpartco'></span>

<h3>Description</h3>

<p>Figures out the coordinates on the tree plot for the each mini trajectory plots.
Modified from code from the longRPart package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpartco(tree, parms = paste(".rpart.parms", dev.cur(), sep = "."))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpartco_+3A_tree">tree</code></td>
<td>
<p>a SplineTree object</p>
</td></tr>
<tr><td><code id="rpartco_+3A_parms">parms</code></td>
<td>
<p>a string</p>
</td></tr>
</table>

<hr>
<h2 id='spaghettiPlot'>Create a faceted spaghetti plot of a splinetree model</h2><span id='topic+spaghettiPlot'></span>

<h3>Description</h3>

<p>Uses ggplot to create a paneled spaghetti plot of the data, where each panel corresponds to a terminal node in the tree.
Allows users to visualize homogeneity of trajectories within the terminal nodes of the tree while also looking
at the trajectories of different nodes side by side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spaghettiPlot(model, colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spaghettiPlot_+3A_model">model</code></td>
<td>
<p>a model returned from splineTree()</p>
</td></tr>
<tr><td><code id="spaghettiPlot_+3A_colors">colors</code></td>
<td>
<p>optional argument specifying colors to be used for each panel.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
nlsySubset &lt;- nlsySample[nlsySample$ID %in% sample(unique(nlsySample$ID), 400),]
split_formula &lt;- ~HISP + WHITE + BLACK + SEX + Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, idvar = "ID",
   data = nlsySubset, degree = 1, df = 3,
   intercept = TRUE, cp = 0.005)

spaghettiPlot(tree)
</code></pre>

<hr>
<h2 id='spline_eval'>Custom rpart eval function.</h2><span id='topic+spline_eval'></span>

<h3>Description</h3>

<p>The eval function is required for custom rpart functionality. The split criterion is the total sum of squared errors of the projected or smoothed outcome values around their mean.
Note that this is the node purity measure introduced by Yu and Lambert, 1999.
The calling of this function is always handled internally by rpart; the user will never directly call this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_eval(y, wt = NULL, parms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_eval_+3A_y">y</code></td>
<td>
<p>the responses at this node, which will be estimated spline coefficients for individuals in the node.</p>
</td></tr>
<tr><td><code id="spline_eval_+3A_wt">wt</code></td>
<td>
<p>Used to weight observations differently. Required by rpart, but not supported by splinetree, so its value will always be NULL.</p>
</td></tr>
<tr><td><code id="spline_eval_+3A_parms">parms</code></td>
<td>
<p>rpart's custom split functionality allows optional parameters to be passed through the splitting functions.
In the splinetree package, the parms parameter is used to hold a list of length 1 or 2 containing either just a spline basis matrix (for a tree), or
a spline basis matrix and the probability that a variable will be selected at a split (for a random forest).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A description for the node. This description includes the label, which is the mean response at the node,
and the deviance, which in this case is the total projected sum of squares.
</p>

<hr>
<h2 id='spline_init'>Custom rpart init function</h2><span id='topic+spline_init'></span>

<h3>Description</h3>

<p>The init function is required for custom rpart functionality. This function initializes every node. The init function is responsible for defining the summary function
that will be used by rpart's summary function if you call summary() on this tree object. The init function also passes forward its arguments and tells rpart
the dimension of the response variable. This function is called internally by rpart; the details are not important for the end user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_init(y, offset = NULL, parms = NULL, wt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_init_+3A_y">y</code></td>
<td>
<p>Response data, which will be estimated spline coefficients</p>
</td></tr>
<tr><td><code id="spline_init_+3A_offset">offset</code></td>
<td>
<p>Required by rpart, but never used by splinetree, so its value will always be NULL</p>
</td></tr>
<tr><td><code id="spline_init_+3A_parms">parms</code></td>
<td>
<p>rpart's custom split functionality allows optional parameters to be passed through the
splitting functions. In the splinetree package, the parms parameter is used to hold a list of length
1 or 2 containing a spline basis matrix and the probability that a variable will be selected at a split.
The probability is only used in splineforests. For splinetrees, only the basis matrix is needed.</p>
</td></tr>
<tr><td><code id="spline_init_+3A_wt">wt</code></td>
<td>
<p>Used to weight observations differently. Required by rpart, but not supported by splinetree, so its value will always be NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of information for this node that is used internally by rpart.
</p>

<hr>
<h2 id='spline_split'>Custom rpart split function.</h2><span id='topic+spline_split'></span>

<h3>Description</h3>

<p>The split function is required for the custom rpart functionality. This function is called once per covariate per node during the tree construction,
and is responsible for choosing the covariate and threshold for the best split point. This implements the split function suggested by Yu and Lambert.
When the covariate is categorical, this code uses a shortcut for computational efficiency. Instead of trying
every possible combination of categories as a potential split point, the categories are ordered using the first principal component of the average spline coefficient vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_split(y, wt, x, parms = NULL, continuous)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_split_+3A_y">y</code></td>
<td>
<p>The responses at this node</p>
</td></tr>
<tr><td><code id="spline_split_+3A_wt">wt</code></td>
<td>
<p>Used to weight observations differently. Required by rpart, but not supported by splinetree, so its value will always be NULL.</p>
</td></tr>
<tr><td><code id="spline_split_+3A_x">x</code></td>
<td>
<p>The data for a particular covariate</p>
</td></tr>
<tr><td><code id="spline_split_+3A_parms">parms</code></td>
<td>
<p>rpart's custom split functionality allows optional parameters to be passed through the splitting functions.
In the splinetree package, the parms parameter is used to hold a list of length 1 or 2 containing either just a spline basis matrix (for a tree), or
a spline basis matrix and the probability that a variable will be selected at a split (for a random forest).</p>
</td></tr>
<tr><td><code id="spline_split_+3A_continuous">continuous</code></td>
<td>
<p>Value is handled internally by rpart - tells us if this covariate is continuous (TRUE) or categorical (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components, goodness and direction, describing the goodness of fit and direction for each possible split for this covariate.
The goodness component holds the utility of the split (projected sum of squares) for each possible split.
If the continuous parameter is TRUE, goodness and direction each have length n-1, here n is the length of x.
The ith value of goodness describes utility of splitting observations 1 to i from i + 1 to n.
The values of direction will be <code class="reqn">-1</code> and <code class="reqn">+1</code>, where <code class="reqn">-1</code> suggests that values with y &lt; cutpoint be sent to the left side of the tree,
and a value of +1 that values with y cutpoint be sent to the right. This is not really an important choice,
it only matters for tree reading conventions.
If the continuous parameter is FALSE, then the predictor variable x is categorical with
k classes and there are potentially almost 2k different ways to split the node.
When invoking custom split functions, rpart assumes that a reasonable approximation can be
computed by first ordering the groups by their
first principal component of the average y vector and then using the
usual splitting rule on this ordered variable.
In this case, the direction vector has k values giving the ordering of the groups, and the goodness vector
has k-1 values giving the utility of the splits.
</p>

<hr>
<h2 id='splineForest'>Build a spline random forest.</h2><span id='topic+splineForest'></span>

<h3>Description</h3>

<p>Builds an ensemble of regression trees for longitudinal or functional data using the spline projection method. The resulting model
contains a list of spline trees along with some additional information. All parameters are used in the same way that they are used in
the splineTree() function. The additional parameter ntree specifies how many trees should be in the ensemble, and prob controls the
probability of selecting a given variable for split consideration at a node. This method may take several minutes to run- saving the forest after
building it is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineForest(splitFormula, tformula, idvar, data, knots = NULL,
  df = NULL, degree = 3, intercept = FALSE, nGrid = 7,
  gridPoints = NULL, ntree = 50, prob = 0.3, cp = 0.001,
  minNodeSize = 1, bootstrap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineForest_+3A_splitformula">splitFormula</code></td>
<td>
<p>Formula specifying the longitudinal response variable and the time-constant variables that will be used for splitting in the tree.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_tformula">tformula</code></td>
<td>
<p>Formula specifying the longitudinal response variable and the variable that acts as the time variable.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_idvar">idvar</code></td>
<td>
<p>The name of the variable that serves as the ID variable for grouping observations. Must be in quotes</p>
</td></tr>
<tr><td><code id="splineForest_+3A_data">data</code></td>
<td>
<p>dataframe that contains all variables specified in the formulas- in long format.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_knots">knots</code></td>
<td>
<p>Specified locations for internal knots in the spline basis. Defaults to NULL, which corresponds to no internal knots.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the spline basis. If this is specified but the knots parameter is NULL, then the appropriate number of internal knots
will be added at quantiles of the training data. If both df and knots are unspecified, the spline basis will have no internal knots.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_degree">degree</code></td>
<td>
<p>Specifies degree of spline basis used in the tree.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_intercept">intercept</code></td>
<td>
<p>Specifies whether or not the splitting process will consider the intercept coefficient of the spline projections.
Defaults to FALSE, which means that the tree will split based on trajectory shape, ignoring response level.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_ngrid">nGrid</code></td>
<td>
<p>Number of grid points to evaluate projection sum of squares at. If gridPoints is not supplied, then this is the
number of grid points that will be automatically placed at quantiles of the time variable. The default is 7.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_gridpoints">gridPoints</code></td>
<td>
<p>Optional. A vector of numbers that will be used as the grid on which to evaluate the projection
sum of squares. Should fall roughly within the range of the time variable.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_ntree">ntree</code></td>
<td>
<p>Number of trees in the forest.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_prob">prob</code></td>
<td>
<p>Probability of selecting a variable to included as a candidate for each split.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_cp">cp</code></td>
<td>
<p>Complexity parameter passed to the rpart building process. Default is the rpart default of 0.01</p>
</td></tr>
<tr><td><code id="splineForest_+3A_minnodesize">minNodeSize</code></td>
<td>
<p>Minimum number of observational units that can be in a terminal node. Controls tree size and helps avoid overfitting.
Default is 10.</p>
</td></tr>
<tr><td><code id="splineForest_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Boolean specifying whether bootstrap sampling should be used when choosing data to
use for each tree. When set to FALSE (the default), sampling without replacement is used and 63.5
is used for each tree. When set to TRUE, a bootstrap sample is used for each tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ensemble method is highly similar to the random forest methodology of Breiman (2001). Each tree in the ensemble is fit to a random sample
of 63.5
the subset of variables considered at each node is determined by a random process. The prob parameter specifies the probability that a given variable
will be selected at a certain node. Because the method is based on probability, the same number of variables are not considered for splitting at each node
(as in the randomForest package). Note that if prob is small and the number of variables in the splitFormula is also small, there is a high probability that
no variables will be considered for splitting at a certain node, which is problematic. The fewer total variables there are, the larger prob should be to
ensure good results.
</p>


<h3>Value</h3>

<p>A spline forest model, which is a named list with 15 components.
The list stores a list of trees (in model$Trees), along with information about the
spline basis used (model$intercept, model$innerKnots, model$boundaryKnots, etc.), and information about which datapoints were
used to build each tree (model$oob_indices and model$index). Note that each element in model$Trees is an rpart object but
it is not the same as a model returned from splineTree() because it does not store all relevant information in model$parms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nlsySubset &lt;- nlsySample[nlsySample$ID %in% sample(unique(nlsySample$ID), 400),]
splitForm &lt;-~HISP+WHITE+BLACK+HGC_MOTHER+HGC_FATHER+SEX+Num_sibs
sampleForest &lt;- splineForest(splitForm, BMI~AGE, 'ID', nlsySubset, degree=1, cp=0.005, ntree=10)

</code></pre>

<hr>
<h2 id='splineforest_split'>Custom rpart split function for spline random forests</h2><span id='topic+splineforest_split'></span>

<h3>Description</h3>

<p>Wrapper for split function required for the random forest functionality. This function is called once per covariate at each potential split.
Implements the random selection of variables; each variable is randomly selected to be included or excluded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineforest_split(y, wt, x, parms = NULL, continuous)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineforest_split_+3A_y">y</code></td>
<td>
<p>the responses at this node</p>
</td></tr>
<tr><td><code id="splineforest_split_+3A_wt">wt</code></td>
<td>
<p>the weight of the responses</p>
</td></tr>
<tr><td><code id="splineforest_split_+3A_x">x</code></td>
<td>
<p>the X data for this covariate</p>
</td></tr>
<tr><td><code id="splineforest_split_+3A_parms">parms</code></td>
<td>
<p>the basis matrix for the spline and the proportion of variables randomly sampled (diceProb)</p>
</td></tr>
<tr><td><code id="splineforest_split_+3A_continuous">continuous</code></td>
<td>
<p>value is handled internally by rpart - tells us if this covariate is continuous or categorical (factor).</p>
</td></tr>
</table>

<hr>
<h2 id='splineTree'>Build a splinetree model.</h2><span id='topic+splineTree'></span>

<h3>Description</h3>

<p>Builds a regression tree for longitudinal or functional data using the spline projection method. The underlying tree building process uses the rpart package,
and the resulting spline tree is an rpart object with additional stored information. The parameters df, knots, degree, intercept allow for flexibility
in customizing the spline basis used for projection. The parameters nGrid and gridPoints allow for flexibility in the grid on which the
projection sum of squares is evaluated. The parameters minNodeSize and cp allow for flexibility in controlling the size of the final tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineTree(splitFormula, tformula, idvar, data, knots = NULL,
  df = NULL, degree = 3, intercept = FALSE, nGrid = 7,
  gridPoints = NULL, minNodeSize = 10, cp = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineTree_+3A_splitformula">splitFormula</code></td>
<td>
<p>Formula specifying the longitudinal response variable and the time-constant variables that will be used for splitting in the tree.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_tformula">tformula</code></td>
<td>
<p>Formula specifying the longitudinal response variable and the variable that acts as the time variable.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_idvar">idvar</code></td>
<td>
<p>The name of the variable that serves as the ID variable for grouping observations. Must be a string.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_data">data</code></td>
<td>
<p>dataframe in long format that contains all variables specified in the formulas.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_knots">knots</code></td>
<td>
<p>Specified locations for internal knots in the spline basis. Defaults to NULL, which corresponds to no internal knots.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the spline basis. If this is specified but the knots parameter is NULL, then the appropriate number of internal knots
will be added at quantiles of the training data. If both df and knots are unspecified, the spline basis will have no internal knots. If knots is specified,
this parameter will be ignored.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_degree">degree</code></td>
<td>
<p>Specifies degree of spline basis used for projection.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_intercept">intercept</code></td>
<td>
<p>Specifies whether or not the set of basis functions will include the intercept function.
Defaults to FALSE, which means that the tree will split based on trajectory shape, ignoring response level.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_ngrid">nGrid</code></td>
<td>
<p>Number of grid points to evaluate projection sum of squares at. If gridPoints
is not supplied, this argument will be used and the appropriate number of grid points will be placed at
equally spaced quantiles of the time variable. The default is 7.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_gridpoints">gridPoints</code></td>
<td>
<p>Optional. A vector of numbers that will be used as the grid on which to evaluate the
projection sum of squares. Should fall roughly within the range of the time variable.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_minnodesize">minNodeSize</code></td>
<td>
<p>Minimum number of observational units that can be in a terminal node. Controls tree size
and helps avoid overfitting. Defaults to 10.</p>
</td></tr>
<tr><td><code id="splineTree_+3A_cp">cp</code></td>
<td>
<p>Complexity parameter passed to the rpart building process. Controls tree size. Defaults to
the rpart default of 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rpart object with additional splinetree-specific information stored in model$parms. The important
attributes of the rpart object include model$frame, model$where, and model$cptable. model$frame holds information
about each node in the tree. The ith entry in model$where tells us which row of model$frame describes the node that
the ith individual in the flattened dataset falls into. model$parms$flat_data holds the flattened dataset that
was used to build the tree. model$cptable displays the complexity parameters that would be needed to prune the tree
to various desired sizes. Apart from holding the flattened dataset, model$parms holds the boundary knots and the internal
knots of the spline basis used to build the tree. These are sometimes important to recover later.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nlsySample_subset &lt;- nlsySample[nlsySample$ID %in% sample(unique(nlsySample$ID), 500),]
splitForm &lt;- ~HISP+WHITE+BLACK+HGC_MOTHER+HGC_FATHER+SEX+Num_sibs
tree1 &lt;- splineTree(splitForm, BMI~AGE, 'ID', nlsySample_subset, degree=3, intercept=TRUE, cp=0.005)
stPrint(tree1)
stPlot(tree1)
</code></pre>

<hr>
<h2 id='splineTreePlot'>Creates a tree plot of a spline tree.</h2><span id='topic+splineTreePlot'></span>

<h3>Description</h3>

<p>Creates a tree plot of a spline tree. This corresponds to plotting only the first panel of
stPlot(). Code for this function was borrowed from the longRPart package on github.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineTreePlot(model, colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineTreePlot_+3A_model">model</code></td>
<td>
<p>a model returned from splineTree()</p>
</td></tr>
<tr><td><code id="splineTreePlot_+3A_colors">colors</code></td>
<td>
<p>a list of colors that will be used for the terminal nodes (if NULL, will use a rainbow)</p>
</td></tr>
</table>

<hr>
<h2 id='stPlot'>Plots a splinetree.</h2><span id='topic+stPlot'></span>

<h3>Description</h3>

<p>Creates a two paneled plot of a splinetree that shows both the tree and the trajectories side by side.
Note that this function has trouble when the plot window is not wide enough. If nothing shows up in RStudio,
try increasing the size of the plot window and trying again. For a tree without an intercept, intercepts are
estimated after-the-fact for each node using the average starting value in the data so that the plotted
trajectories have reasonable response values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stPlot(model, colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stPlot_+3A_model">model</code></td>
<td>
<p>A model returned from splineTree()</p>
</td></tr>
<tr><td><code id="stPlot_+3A_colors">colors</code></td>
<td>
<p>A list of colors that will be used for the trajectories (if NULL, will automatically select colors from
rainbow color scheme.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
split_formula &lt;- ~HISP + WHITE + BLACK + SEX + Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, idvar = "ID",
   data = nlsySample, degree = 1, df = 3,
   intercept = TRUE, cp = 0.005)

stPlot(tree, colors = c("red", "orange", "green", "blue", "cyan", "magenta"))
</code></pre>

<hr>
<h2 id='stPrint'>Print a spline tree in the style of print.rpart</h2><span id='topic+stPrint'></span>

<h3>Description</h3>

<p>The printout provides numbered labels for the terminal nodes,
a description of the split at each node, the number of observations found at each node,
and the predicted spline coefficients for each node. This code is primarily taken from rpart base code for print.rpart. It has been modified to
ensure that the full vector of coefficients is printed for each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stPrint(t, cp, digits = getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stPrint_+3A_t">t</code></td>
<td>
<p>A model returned by splineTree()</p>
</td></tr>
<tr><td><code id="stPrint_+3A_cp">cp</code></td>
<td>
<p>Optional- if provided, a pruned version of the tree will be printed. The tree will be
pruned using the provided cp as the complexity parameter.</p>
</td></tr>
<tr><td><code id="stPrint_+3A_digits">digits</code></td>
<td>
<p>Specifies how many digits of each coefficient should be printed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
split_formula &lt;- ~HISP + WHITE + BLACK + SEX + Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, idvar = "ID",
   data = nlsySample, degree = 1, df = 3,
   intercept = TRUE, cp = 0.005)

stPrint(tree)
</code></pre>

<hr>
<h2 id='terminalNodeSummary'>Prints a summary of a terminal node in a tree</h2><span id='topic+terminalNodeSummary'></span>

<h3>Description</h3>

<p>If no argument is provided for the parameter <code>node</code>, summaries are printed for every
terminal node. Otherwise, the summary of just the requested node is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terminalNodeSummary(tree, node = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terminalNodeSummary_+3A_tree">tree</code></td>
<td>
<p>A model returned by splineTree().</p>
</td></tr>
<tr><td><code id="terminalNodeSummary_+3A_node">node</code></td>
<td>
<p>The number of the node that you want summarized. To see which nodes correspond to
which numbers, see stPrint(tree) or treeSummary(tree). If this parameter is provided, must correspond
to a valid terminal node in the tree.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
split_formula &lt;- ~HISP + WHITE + BLACK + SEX + Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, idvar = "ID",
   data = nlsySample, degree = 1, df = 3,
   intercept = TRUE, cp = 0.005)

terminalNodeSummary(tree)
</code></pre>

<hr>
<h2 id='tree'>Sample tree used in examples</h2><span id='topic+tree'></span>

<h3>Description</h3>

<p>Sample tree used in examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree
</code></pre>


<h3>Format</h3>

<p>An object of class <code>rpart</code> of length 14.</p>

<hr>
<h2 id='tree.depth'>Given a list of node numbers, returns the depth at which these appear in the tree.</h2><span id='topic+tree.depth'></span>

<h3>Description</h3>

<p>Used in printing and plotting.
Source: rpart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.depth(nodes)
</code></pre>

<hr>
<h2 id='treeSimilarity'>Returns a measure of how similar the two trees are.</h2><span id='topic+treeSimilarity'></span>

<h3>Description</h3>

<p>Computes the Adjusted Rand Index of the clusterings of the population created by the two trees.
In the case of correlated covariates, two trees that split on entirely different variables may actually
describe similar partitions of the population. This metric allows us to detect when two trees are partitioning
the population similarly. A value close to 1 indicates a similar clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeSimilarity(tree1, tree2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeSimilarity_+3A_tree1">tree1</code></td>
<td>
<p>a model returned from splineTree()</p>
</td></tr>
<tr><td><code id="treeSimilarity_+3A_tree2">tree2</code></td>
<td>
<p>a model returned from splineTree()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Adjusted Rand Index of the clusterings created by the two trees.
</p>


<h3>See Also</h3>

<p>mclust::adjustedRandIndex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
splitForm &lt;- ~SEX+Num_sibs+HGC_MOTHER+HGC_FATHER
nlsySubset &lt;- nlsySample[nlsySample$ID %in% sample(unique(nlsySample$ID), 400),]
tree1 &lt;- splineTree(splitForm, BMI~AGE, "ID", nlsySubset, degree=1, df=2, intercept=FALSE, cp=0.005)
tree2 &lt;- splineTree(splitForm, BMI~AGE, "ID", nlsySubset, degree=1, df=3, intercept=TRUE, cp=0.005)
treeSimilarity(tree1, tree2)

</code></pre>

<hr>
<h2 id='treeSize'>Returns number of terminal nodes in a tree.</h2><span id='topic+treeSize'></span>

<h3>Description</h3>

<p>Returns number of terminal nodes in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeSize(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeSize_+3A_model">model</code></td>
<td>
<p>A model returned by splineTree(). Also works on any rpart object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of terminal nodes in the tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
split_formula &lt;- ~ HISP + WHITE + BLACK + SEX + HGC_FATHER + HGC_MOTHER + Num_sibs
tree &lt;- splineTree(split_formula, BMI~AGE, 'ID', nlsySample, degree=1,
  df=3, intercept=TRUE, cp=0.006, minNodeSize=20)

## End(Not run)
treeSize(tree)
</code></pre>

<hr>
<h2 id='treeSummary'>Returns the tree frame.</h2><span id='topic+treeSummary'></span>

<h3>Description</h3>

<p>Provides a similar output to model$frame, but with the redundant information of yval and
yval2 removed. Also omits the deviance, the complexity, and the weight. Useful for viewing
node numbers and for extracting coefficients for a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeSummary(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeSummary_+3A_model">model</code></td>
<td>
<p>A model built with splineTree()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe. The number of rows is the same as the number of nodes in the tree.
The row names display the node labels of each node. The &quot;var&quot; attribute either displays
the split variable selected at each node, or &lt;leaf&gt; if this node is a terminal node. The &quot;n&quot;
attribute displays the number of individuals in the node. The &quot;dev&quot; attribute reports the
projected sum of squares at this node; terminal nodes have the smallest values for &quot;dev&quot; because
this is what the tree building process is supposed to minimize. The &quot;coeffs&quot; attribute displays
the coefficients predicted for each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nlsySubset &lt;- nlsySample[nlsySample$ID %in% sample(unique(nlsySample$ID), 400),]
split_formula &lt;- ~HISP + WHITE + BLACK + SEX + Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, idvar = "ID",
   data = nlsySubset, degree = 1, df = 3,
   intercept = TRUE, cp = 0.005)

treeSummary(tree)
</code></pre>

<hr>
<h2 id='varImpCoeff'>Random Forest Variable Importance based on spline coefficients</h2><span id='topic+varImpCoeff'></span>

<h3>Description</h3>

<p>Returns the random forest variable importance based on the permutation accuracy measure, which is calculated as the difference in mean squared error between the original data and from randomly permuting the values of a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varImpCoeff(forest, removeIntercept = TRUE, method = "oob")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varImpCoeff_+3A_forest">forest</code></td>
<td>
<p>a random forest, generated from splineForest()</p>
</td></tr>
<tr><td><code id="varImpCoeff_+3A_removeintercept">removeIntercept</code></td>
<td>
<p>a boolean value, TRUE if you want to exclude the intercept in the calculations, FALSE otherwise.</p>
</td></tr>
<tr><td><code id="varImpCoeff_+3A_method">method</code></td>
<td>
<p>the method to be used. This must be one of &quot;oob&quot; (out of bag), &quot;all&quot;, &quot;itb&quot; (in the bag).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of variable importance metrics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
importanceMatrix &lt;- varImpCoeff(forest, removeIntercept=TRUE)

</code></pre>

<hr>
<h2 id='varImpY'>Random Forest Variable Importance based on Y</h2><span id='topic+varImpY'></span>

<h3>Description</h3>

<p>Returns the random forest variable importance based on the permutation accuracy measure, which is calculated as the difference in mean squared error between the original data and from randomly permuting the values of a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varImpY(forest, method = "oob")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varImpY_+3A_forest">forest</code></td>
<td>
<p>a random forest, generated from splineForest()</p>
</td></tr>
<tr><td><code id="varImpY_+3A_method">method</code></td>
<td>
<p>the method to be used. This must be one of &quot;oob&quot; (out of bag), &quot;all&quot;, &quot;itb&quot; (in the bag).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;method&quot; parameter deals with the way in which forest performance should be measured. Since variable importance is based on a change
in performance, the &quot;method&quot; parameter is necessary for a variable importance measure. The choices are &quot;oob&quot; (out of bag), &quot;all&quot;, or &quot;itb&quot; (in the bag).
</p>


<h3>Value</h3>

<p>A matrix storing variable importance metrics. The rows correspond to split variables.
The columns are different methods of measuring importance. The first column is the absolute importance
(mean difference in performance between permuted and unpermuted datasets). The second column measures the
mean percent difference in performance. The third column standardizes the differences by dividing them
by their standard deviation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
importanceMatrix &lt;- varImpY(forest, method="oob")
plotImp(importanceMatrix[,3])

</code></pre>

<hr>
<h2 id='yR2'>Computes percent of variation in response explained by spline tree.</h2><span id='topic+yR2'></span>

<h3>Description</h3>

<p>Computes the percentage of variation in response explained by the spline tree.
This metric is only meaningful if model$intercept==TRUE.
If the tree includes an intercept, the measure will be between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yR2(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yR2_+3A_model">model</code></td>
<td>
<p>a model created with splineTree()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R^2 goodness measure. 1-SSE/SST where SSE is the sum of squared errors between predicted responses and true
responses, and SST is sum of squared errors of true responses around population mean. Note that if the tree passed in was built
without an intercept, this function will return NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
split_formula &lt;- ~HISP + WHITE + BLACK + SEX + Num_sibs + HGC_FATHER + HGC_MOTHER
tree &lt;- splineTree(split_formula, BMI~AGE, idvar = "ID",
   data = nlsySample, degree = 1, df = 3,
   intercept = TRUE, cp = 0.005)

yR2(tree)
</code></pre>

<hr>
<h2 id='yR2Forest'>Computes a level-based evaluation metric for a splineforest that was built WITH an intercept.</h2><span id='topic+yR2Forest'></span>

<h3>Description</h3>

<p>Computes the R-squared metric for a spline forest. Goal is to see how well the predicted response values match the
actual response values. Note that this function should only be used on forests where the intercept parameter is TRUE.
A simple 1-SSE/SST calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yR2Forest(forest, method = "oob")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yR2Forest_+3A_forest">forest</code></td>
<td>
<p>The output from a call to splineForest()</p>
</td></tr>
<tr><td><code id="yR2Forest_+3A_method">method</code></td>
<td>
<p>How would you like to compute this metric? The choices are &quot;oob&quot;, &quot;itb&quot;, or &quot;all&quot;.
&quot;oob&quot; means that predictions for a datapoint can only be made using trees for which that datapoint was
&quot;out of the bag&quot; (not in the random subsample). &quot;all&quot; means that all trees are used in the prediction for every
datapoint. &quot;itb&quot; means that predictions for a datapoint are made using only the trees for which this datapoint was IN the random subsample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns 1-SSE/SST, where SSE is the total sum of squared errors of the true responses and predicted responses,
and SST is the total sum of squared errors of the responses around their mean. If this forest was not built with an intercept, returns NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yR2Forest(forest, method="all")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
