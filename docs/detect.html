<!DOCTYPE html><html lang="en"><head><title>Help for package detect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {detect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#detect-package'>
<p>Analyzing Wildlife Data with Detection Error</p></a></li>
<li><a href='#AUC'>
<p>AUC ROC plot for fitted models</p></a></li>
<li><a href='#bootstrap'>
<p>Do bootstrap and extract bootstrap results</p></a></li>
<li><a href='#cmulti'>
<p>Conditional Multinomial Maximum Likelihood Estimation</p></a></li>
<li><a href='#cmulti.fit0'>
<p>Internal functions</p></a></li>
<li><a href='#convertEDT'>
<p>Conversion between truncated and unlimited effective detection distance (EDR)</p></a></li>
<li><a href='#databu'>
<p>Simulated example for abundance model</p></a></li>
<li><a href='#datocc'>
<p>Simulated example for occupancy model</p></a></li>
<li><a href='#hbootindex'>
<p>Hierarchical bootstrap indices</p></a></li>
<li><a href='#load_BAM_QPAD'>
<p>Load BAM QPAD parameter estimates and support functions</p></a></li>
<li><a href='#oven'>
<p>Ovenbird abundances</p></a></li>
<li><a href='#svabu'>
<p>Single visit N-mixture abundance models</p></a></li>
<li><a href='#svocc'>
<p>ZI Binomial model with single visit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyzing Wildlife Data with Detection Error</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Solymos [cre, aut], Monica Moreno [aut], Subhash R. Lele [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Solymos &lt;psolymos@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.13.0), Formula, stats4, pbapply</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dclone, dcmle</td>
</tr>
<tr>
<td>Description:</td>
<td>Models for analyzing site occupancy and count data models
  with detection error, including single-visit based models,
  conditional distance sampling and time-removal models.
  Package development was supported by the
  Alberta Biodiversity Monitoring Institute
  and the Boreal Avian Modelling Project.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/psolymos/detect">https://github.com/psolymos/detect</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/psolymos/detect/issues">https://github.com/psolymos/detect/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-08 14:44:59 UTC; Peter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-08 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='detect-package'>
Analyzing Wildlife Data with Detection Error
</h2><span id='topic+detect-package'></span><span id='topic+detect'></span>

<h3>Description</h3>

<p>Models for analyzing site occupancy and count data models
with detection error, including single-visit based models,
conditional distance sampling and time-removal models.
Package development was supported by the
Alberta Biodiversity Monitoring Institute
and the Boreal Avian Modelling Project.
</p>


<h3>Details</h3>

<p><code><a href="#topic+svocc">svocc</a></code>: single visit occupancy model
(Lele et al. 2011, Moreno et al. 2010).
</p>
<p><code><a href="#topic+svabu">svabu</a></code>: single visit abundance model
based on conditional maximum likelihood
(Solymos et al. 2012, Solymos and Lele 2016, Denes et al. 2016).
</p>
<p><code><a href="#topic+cmulti">cmulti</a></code>: conditional multinomial maximum likelihood
estimation for removal and (point count) distance sampling,
efficient and flexible setup for varying methodologies
(Solymos et al. 2013, Solymos et al. 2018).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos, Monica Moreno, Subhash R Lele
</p>
<p>Maintainer: Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>References</h3>

<p>Denes, F., Solymos, P., Lele, S. R., Silveira, L. &amp; Beissinger, S. 2017.
Biome scale signatures of land use change on raptor abundance:
insights from single-visit detection-based models.
<em>Journal of Applied Ecology</em>, <b>54</b>, 1268&ndash;1278.
&lt;doi:10.1111/1365-2664.12818&gt;
</p>
<p>Lele, S.R., Moreno, M. and Bayne, E. 2011.
Dealing with detection error in site occupancy surveys:
What can we do with a single survey?
<em>Journal of Plant Ecology</em>, <b>5(1)</b>, 22&ndash;31.
&lt;doi:10.1093/jpe/rtr042&gt;
</p>
<p>Moreno, M. and Lele, S. R. 2010.
Improved estimation of site occupancy using penalized likelihood.
<em>Ecology</em>, <b>91</b>, 341&ndash;346.
&lt;doi:10.1890/09-1073.1&gt;
</p>
<p>Solymos, P., Lele, S. R. and Bayne, E. 2012.
Conditional likelihood approach for analyzing single visit
abundance survey data in the presence of zero inflation and
detection error.
<em>Environmetrics</em>, <b>23</b>, 197&ndash;205.
&lt;doi:10.1002/env.1149&gt;
</p>
<p>Solymos, P., Matsuoka, S. M., Bayne, E. M., Lele, S. R., Fontaine, P.,
Cumming, S. G., Stralberg, D., Schmiegelow, F. K. A. &amp; Song, S. J., 2013.
Calibrating indices of avian density from non-standardized survey data:
making the most of a messy situation.
<em>Methods in Ecology and Evolution</em>, <b>4</b>, 1047&ndash;1058.
&lt;doi:10.1111/2041-210X.12106&gt;
</p>
<p>Solymos, P., Lele, S. R. 2016.
Revisiting resource selection probability functions and single-visit methods:
clarification and extensions.
<em>Methods in Ecology and Evolution</em>, <b>7</b>, 196&ndash;205.
&lt;doi:10.1111/2041-210X.12432&gt;
</p>
<p>Solymos, P., Matsuoka, S. M., Cumming, S. G., Stralberg, D., Fontaine, P.,
Schmiegelow, F. K. A., Song, S. J., and Bayne, E. M., 2018.
Evaluating time-removal models for estimating availability of boreal birds
during point-count surveys: sample size requirements and model complexity.
<em>Condor</em>, <b>120</b>, 765&ndash;786.
&lt;doi:10.1650/CONDOR-18-32.1&gt;
</p>
<p>Supporting info, including a tutorial for the QPAD method:
<a href="https://github.com/psolymos/QPAD/tree/master/inst/doc/v2">https://github.com/psolymos/QPAD/tree/master/inst/doc/v2</a>
</p>

<hr>
<h2 id='AUC'>
AUC ROC plot for fitted models
</h2><span id='topic+AUC'></span><span id='topic+rocplot'></span>

<h3>Description</h3>

<p>Area under the receiver-operator (ROC) curve (AUC), and ROC plot methods for fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC(object, ...)
rocplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AUC_+3A_object">object</code>, <code id="AUC_+3A_x">x</code></td>
<td>

<p>a fitted model object
</p>
</td></tr>
<tr><td><code id="AUC_+3A_...">...</code></td>
<td>

<p>other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>AUC</code> returns AUC value for a model, or a data frame with values for more models.
</p>
<p><code>rocplot</code> returns the values used for the plot invisibly, and as a side effect it draws a graph.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos and Monica Moreno
</p>

<hr>
<h2 id='bootstrap'>
Do bootstrap and extract bootstrap results
</h2><span id='topic+bootstrap'></span><span id='topic+extractBOOT'></span>

<h3>Description</h3>

<p>Do bootstrap and extract bootstrap results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(object, ...)
extractBOOT(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_+3A_object">object</code></td>
<td>

<p>a fitted model object
</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>

<p>other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bootstrap</code> performs bootstrap.
</p>
<p><code>extractBOOT</code> is used to extract bootstrap results.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>

<hr>
<h2 id='cmulti'>
Conditional Multinomial Maximum Likelihood Estimation
</h2><span id='topic+cmulti'></span><span id='topic+cmulti.fit'></span><span id='topic+cmulti2.fit'></span><span id='topic+fitted.cmulti'></span><span id='topic+model.frame.cmulti'></span><span id='topic+model.matrix.cmulti'></span><span id='topic+predict.cmulti'></span>

<h3>Description</h3>

<p>Conditional Multinomial Maximum Likelihood Estimation
for different sampling methodologies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmulti(formula, data, type = c("rem", "mix", "dis", "fmix"),
    inits = NULL, method = "Nelder-Mead", ...)
cmulti.fit(Y, D, X=NULL, type=c("rem", "mix", "dis", "fmix"),
    inits=NULL, method="Nelder-Mead", ...)

cmulti2.fit(Y, D1, D2, X1=NULL, X2=NULL,
    inits=NULL, method="Nelder-Mead", ...)

## S3 method for class 'cmulti'
fitted(object, ...)
## S3 method for class 'cmulti'
model.frame(formula, ...)
## S3 method for class 'cmulti'
model.matrix(object, ...)
## S3 method for class 'cmulti'
predict(object, newdata = NULL,
    type = c("link", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cmulti_+3A_formula">formula</code></td>
<td>

<p>formula, LHS takes 2 matrices in the form of <code>Y | D</code>,
RHS is either <code>1</code> or some covariates, see Examples.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_data">data</code></td>
<td>

<p>data.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_type">type</code></td>
<td>

<p>character, one of <code>"rem"</code> (removal sampling, homogeneous
singing rates), <code>"mix"</code> and <code>"fmix"</code> (removal sampling, heterogeneous
singing rates, <code>"mix"</code> implies that 'phi' is constant but 'c' can vary;
<code>"fmix"</code> implies that 'c' is constant but 'phi' can vary),
<code>"dis"</code> (distance sampling, half-normal detection
function for point counts, circular area).
For the <code>predict</code> method it is the <code>type</code>
of prediction required; the default is on the scale of the linear predictors;
the alternative <code>"response"</code> is on the scale of the response variable.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_y">Y</code></td>
<td>

<p>this contains the cell counts.
<code>cmulti.fit</code> requires
that <code>Y</code> is a matrix (observations x intervals),
dimensions and pattern in <code>NA</code>s must match that of <code>D</code>.
<code>cmulti2.fit</code> requires that <code>Y</code> is a 3-dimensional array
(observations x time intervals x distance intervals),
dimensions and pattern in <code>NA</code>s must match that of
<code>D1</code> and <code>D2</code>.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_d">D</code>, <code id="cmulti_+3A_d1">D1</code>, <code id="cmulti_+3A_d2">D2</code></td>
<td>

<p>design matrices, that describe the interval endpoints for the sampling
methodology, dimensions must match dimensions of <code>Y</code>.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_x">X</code>, <code id="cmulti_+3A_x1">X1</code>, <code id="cmulti_+3A_x2">X2</code></td>
<td>

<p>design matrices, <code>X</code> is the matrix with covariates for the
removal/distance sampling parameters.
<code>X1</code> is the matrix with covariates for the removal,
<code>X2</code> is the matrix with covariates for the distance
sampling parameters.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_inits">inits</code></td>
<td>

<p>optional initial values.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_method">method</code></td>
<td>

<p>method for <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_object">object</code></td>
<td>

<p>fitted model object.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_newdata">newdata</code></td>
<td>

<p>optionally, a data frame in which to look for variables with which to predict.
If omitted, the fitted linear predictors are used.
</p>
</td></tr>
<tr><td><code id="cmulti_+3A_...">...</code></td>
<td>

<p>additional options for <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conditional Multinomial Maximum Likelihood Estimation
for different sampling methodologies.
</p>


<h3>Value</h3>

<p>An object of class 'cmulti'.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>References</h3>

<p>Solymos, P., Matsuoka, S. M., Bayne, E. M., Lele, S. R., Fontaine, P.,
Cumming, S. G., Stralberg, D., Schmiegelow, F. K. A. &amp; Song, S. J., 2013.
Calibrating indices of avian density from non-standardized survey data:
making the most of a messy situation.
<em>Methods in Ecology and Evolution</em>, <b>4</b>, 1047&ndash;1058.
&lt;doi:10.1111/2041-210X.12106&gt;
</p>
<p>Solymos, P., Matsuoka, S. M., Cumming, S. G., Stralberg, D., Fontaine, P.,
Schmiegelow, F. K. A., Song, S. J., and Bayne, E. M., 2018.
Evaluating time-removal models for estimating availability of boreal birds
during point-count surveys: sample size requirements and model complexity.
<em>Condor</em>, <b>120</b>, 765&ndash;786.
&lt;doi:10.1650/CONDOR-18-32.1&gt;
</p>
<p>Supporting info, including a tutorial for the QPAD method:
<a href="https://github.com/psolymos/QPAD/tree/master/inst/doc/v2">https://github.com/psolymos/QPAD/tree/master/inst/doc/v2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simfun1 &lt;- function(n = 10, phi = 0.1, c=1, tau=0.8, type="rem") {
    if (type=="dis") {
        Dparts &lt;- matrix(c(0.5, 1, NA,
                      0.5, 1, Inf,
                      1, Inf, NA), 3, 3, byrow=TRUE)
        D &lt;- Dparts[sample.int(3, n, replace=TRUE),]
        CP &lt;- 1-exp(-(D/tau)^2)
    } else {
        Dparts &lt;- matrix(c(5, 10, NA,
                      3, 5, 10,
                      3, 5, NA), 3, 3, byrow=TRUE)
        D &lt;- Dparts[sample.int(3, n, replace=TRUE),]
        CP &lt;- 1-c*exp(-D*phi)
    }
    k &lt;- ncol(D)
    P &lt;- CP - cbind(0, CP[, -k, drop=FALSE])
    Psum &lt;- rowSums(P, na.rm=TRUE)
    PPsum &lt;- P / Psum
    Pok &lt;- !is.na(PPsum)
    N &lt;- rpois(n, 10)
    Y &lt;- matrix(NA, ncol(PPsum), nrow(PPsum))
    Ypre &lt;- sapply(1:n, function(i) rmultinom(1, N, PPsum[i,Pok[i,]]))
    Y[t(Pok)] &lt;- unlist(Ypre)
    Y &lt;- t(Y)
    list(Y=Y, D=D)
}

n &lt;- 200
x &lt;- rnorm(n)
X &lt;- cbind(1, x)

## removal, constant
vv &lt;- simfun1(n=n, phi=exp(-1.5))
m1 &lt;- cmulti(vv$Y | vv$D ~ 1, type="rem")
coef(m1)
## mixture, constant (mix and fmix are identical)
vv &lt;- simfun1(n=n, phi=exp(-1.5), c=plogis(0.8))
m2 &lt;- cmulti(vv$Y | vv$D ~ 1, type="mix")
coef(m2)
m2f &lt;- cmulti(vv$Y | vv$D ~ 1, type="fmix")
coef(m2f)
## dist, constant
vv &lt;- simfun1(n=n, tau=exp(-0.2), type="dis")
m3 &lt;- cmulti(vv$Y | vv$D ~ 1, type="dis")
coef(m3)

## removal, not constant
log.phi &lt;- crossprod(t(X), c(-2,-1))
vv &lt;- simfun1(n=n, phi=exp(cbind(log.phi, log.phi, log.phi)))
m1 &lt;- cmulti(vv$Y | vv$D ~ x, type="rem")
coef(m1)
## mixture, fixed phi, varying c
logit.c &lt;- crossprod(t(X), c(-2,1))
vv &lt;- simfun1(n=n, phi=exp(-1.5), c=plogis(cbind(logit.c, logit.c, logit.c)))
m2 &lt;- cmulti(vv$Y | vv$D ~ x, type="mix")
coef(m2)
## mixture, varying phi, fixed c
log.phi &lt;- crossprod(t(X), c(-2,-1))
vv &lt;- simfun1(n=n, phi=exp(cbind(log.phi, log.phi, log.phi)), c=plogis(0.8))
m2f &lt;- cmulti(vv$Y | vv$D ~ x, type="fmix")
coef(m2f)
## dist, not constant
log.tau &lt;- crossprod(t(X), c(-0.5,-0.2))
vv &lt;- simfun1(n=n, tau=exp(cbind(log.tau, log.tau, log.tau)), type="dis")
m3 &lt;- cmulti(vv$Y | vv$D ~ x, type="dis")
coef(m3)

summary(m3)
coef(m3)
vcov(m3)
AIC(m3)
confint(m3)
logLik(m3)

## fitted values
plot(exp(log.tau), fitted(m3))

## prediction for new locations (type = 'rem')
ndf &lt;- data.frame(x=seq(-1, 1, by=0.1))
summary(predict(m1, newdata=ndf, type="link"))
summary(pr1 &lt;- predict(m1, newdata=ndf, type="response"))
## turing singing rates into probabilities requires total duration
## 5 minutes used here
psing &lt;- 1-exp(-5*pr1)
plot(ndf$x, psing, type="l", ylim=c(0,1))

## prediction for new locations (type = 'dis')
summary(predict(m3, newdata=ndf, type="link"))
summary(pr3 &lt;- predict(m3, newdata=ndf, type="response"))
## turing EDR into probabilities requires finite truncation distances
## r=0.5 used here (50 m)
r &lt;- 0.5
pdet &lt;- pr3^2*(1-exp(-r^2/pr3^2))/r^2
plot(ndf$x, pdet, type="l", ylim=c(0,1))

## joint removal-distance estimation
## is not different from 2 orthogonal estimations

simfun12 &lt;- function(n = 10, phi = 0.1, c=1, tau=0.8, type="rem") {
    Flat &lt;- function(x, DIM, dur=TRUE) {
        x &lt;- array(x, DIM)
        if (!dur) {
            x &lt;- aperm(x,c(1,3,2))
        }
        dim(x) &lt;- c(DIM[1], DIM[2]*DIM[3])
        x
    }
    Dparts1 &lt;- matrix(c(5, 10, NA,
                        3, 5, 10,
                        3, 5, NA), 3, 3, byrow=TRUE)
    D1 &lt;- Dparts1[sample.int(3, n, replace=TRUE),]
    CP1 &lt;- 1-c*exp(-D1*phi)
    Dparts2 &lt;- matrix(c(0.5, 1, NA,
                        0.5, 1, Inf,
                        1, Inf, NA), 3, 3, byrow=TRUE)
    D2 &lt;- Dparts2[sample.int(3, n, replace=TRUE),]
    CP2 &lt;- 1-exp(-(D2/tau)^2)
    k1 &lt;- ncol(D1)
    k2 &lt;- ncol(D2)
    DIM &lt;- c(n, k1, k2)
    P1 &lt;- CP1 - cbind(0, CP1[, -k1, drop=FALSE])
    P2 &lt;- CP2 - cbind(0, CP2[, -k2, drop=FALSE])
    Psum1 &lt;- rowSums(P1, na.rm=TRUE)
    Psum2 &lt;- rowSums(P2, na.rm=TRUE)
    Pflat &lt;- Flat(P1, DIM, dur=TRUE) * Flat(P2, DIM, dur=FALSE)
    PsumFlat &lt;- Psum1 * Psum2
    PPsumFlat &lt;- Pflat / PsumFlat
    PokFlat &lt;- !is.na(PPsumFlat)
    N &lt;- rpois(n, 10)
    Yflat &lt;- matrix(NA, ncol(PPsumFlat), nrow(PPsumFlat))
    YpreFlat &lt;- sapply(1:n, function(i) rmultinom(1, N, PPsumFlat[i,PokFlat[i,]]))
    Yflat[t(PokFlat)] &lt;- unlist(YpreFlat)
    Yflat &lt;- t(Yflat)
    Y &lt;- array(Yflat, DIM)
    k1 &lt;- dim(Y)[2]
    k2 &lt;- dim(Y)[3]
    Y1 &lt;- t(sapply(1:n, function(i) {
        count &lt;- rowSums(Y[i,,], na.rm=TRUE)
        nas &lt;- rowSums(is.na(Y[i,,]))
        count[nas == k2] &lt;- NA
        count
    }))
    Y2 &lt;- t(sapply(1:n, function(i) {
        count &lt;- colSums(Y[i,,], na.rm=TRUE)
        nas &lt;- colSums(is.na(Y[i,,]))
        count[nas == k2] &lt;- NA
        count
    }))
    list(Y=Y, D1=D1, D2=D2, Y1=Y1, Y2=Y2)
}

## removal and distance, constant
vv &lt;- simfun12(n=n, phi=exp(-1.5), tau=exp(-0.2))
res &lt;- cmulti2.fit(vv$Y, vv$D1, vv$D2)
res1 &lt;- cmulti.fit(vv$Y1, vv$D1, NULL, "rem")
res2 &lt;- cmulti.fit(vv$Y2, vv$D2, NULL, "dis")
## points estimates are identical
cbind(res$coef, c(res1$coef, res2$coef))
## standard errors are identical
cbind(sqrt(diag(res$vcov)),
    c(sqrt(diag(res1$vcov)),sqrt(diag(res2$vcov))))

## removal and distance, not constant
vv &lt;- simfun12(n=n,
    phi=exp(cbind(log.phi, log.phi, log.phi)),
    tau=exp(cbind(log.tau, log.tau, log.tau)))
res &lt;- cmulti2.fit(vv$Y, vv$D1, vv$D2, X1=X, X2=X)
res1 &lt;- cmulti.fit(vv$Y1, vv$D1, X, "rem")
res2 &lt;- cmulti.fit(vv$Y2, vv$D2, X, "dis")

## points estimates are identical
cbind(res$coef, c(res1$coef, res2$coef))
## standard errors are identical
cbind(sqrt(diag(res$vcov)),
    c(sqrt(diag(res1$vcov)),sqrt(diag(res2$vcov))))
</code></pre>

<hr>
<h2 id='cmulti.fit0'>
Internal functions
</h2><span id='topic+cmulti.fit0'></span><span id='topic+drop.scope.svisit'></span>

<h3>Description</h3>

<p>Internal functions, not intended for use on their own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmulti.fit0(Y, D, type=c("rem", "mix", "dis", "fmix"),
    interval=c(-25, 25), ...)
drop.scope.svisit(terms1, terms2, model = c("sta", "det"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cmulti.fit0_+3A_y">Y</code></td>
<td>

<p>this contains the cell counts. See <code><a href="#topic+cmulti.fit">cmulti.fit</a></code>.
</p>
</td></tr>
<tr><td><code id="cmulti.fit0_+3A_d">D</code></td>
<td>

<p>design matrix, that describe the interval endpoints for the sampling
methodology, dimensions must match dimensions of <code>Y</code>.
See <code><a href="#topic+cmulti.fit">cmulti.fit</a></code>.
</p>
</td></tr>
<tr><td><code id="cmulti.fit0_+3A_type">type</code></td>
<td>

<p>character, one of <code>"rem"</code> (removal sampling, homogeneous
singing rates), <code>"mix"</code> and <code>"fmix"</code> (removal sampling, heterogeneous
singing rates), <code>"dis"</code> (distance sampling, half-normal detection
function for point counts, circular area). See <code><a href="#topic+cmulti.fit">cmulti.fit</a></code>.
</p>
</td></tr>
<tr><td><code id="cmulti.fit0_+3A_interval">interval</code></td>
<td>

<p>the interval used in <code><a href="stats.html#topic+optimize">optimize</a></code>.
</p>
</td></tr>
<tr><td><code id="cmulti.fit0_+3A_terms1">terms1</code></td>
<td>

<p>the terms or formula for the upper/lower scope. See <code><a href="stats.html#topic+drop.scope">drop.scope</a></code>.
</p>
</td></tr>
<tr><td><code id="cmulti.fit0_+3A_model">model</code></td>
<td>

<p>character, the type of model to be considered.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>

<hr>
<h2 id='convertEDT'>
Conversion between truncated and unlimited effective detection distance (EDR)
</h2><span id='topic+convertEDR'></span>

<h3>Description</h3>

<p>Conversion between truncated and unlimited effective detection distance (EDR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertEDR(edr, r, truncated=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertEDT_+3A_edr">edr</code></td>
<td>

<p>effective detection distance. In same units as <code>r</code>.
</p>
</td></tr>
<tr><td><code id="convertEDT_+3A_r">r</code></td>
<td>

<p>truncation distance (radius of point count). In same units as <code>edr</code>.
</p>
</td></tr>
<tr><td><code id="convertEDT_+3A_truncated">truncated</code></td>
<td>

<p>logical, see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>truncated = FALSE</code> means that <code>edr</code> is unlimited
EDR, and the function returns the truncated EDR given <code>r</code>.
</p>
<p><code>truncated = TRUE</code> means that <code>edr</code> is truncated
EDR given <code>r</code>, and the function returns the unlimited EDR.
</p>


<h3>Value</h3>

<p>A numeric vector with converted EDR values.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>References</h3>

<p>Matsuoka, S. M., Bayne, E. M., Solymos, P., Fontaine, P.,
Cumming, S. G., Schmiegelow, F. K. A., &amp; Song, S. A., 2012.
Using binomial distance-sampling models to estimate the effective
detection radius of point-counts surveys across boreal Canada.
<em>Auk</em>, <b>129</b>, 268&ndash;282.
&lt;doi:10.1525/auk.2012.11190&gt;
</p>
<p>Solymos, P., Matsuoka, S. M., Bayne, E. M., Lele, S. R., Fontaine, P.,
Cumming, S. G., Stralberg, D., Schmiegelow, F. K. A. &amp; Song, S. J., 2013.
Calibrating indices of avian density from non-standardized survey data:
making the most of a messy situation.
<em>Methods in Ecology and Evolution</em>, <b>4</b>, 1047&ndash;1058.
&lt;doi:10.1111/2041-210X.12106&gt;
</p>
<p>Supporting info, including a tutorial for the above paper:
<a href="https://github.com/psolymos/QPAD/tree/master/inst/doc/v2">https://github.com/psolymos/QPAD/tree/master/inst/doc/v2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convertEDR(1, 0.5, truncated=FALSE)
## should be close to 1
convertEDR(convertEDR(1, 0.5, truncated=FALSE), 0.5, truncated=TRUE)
</code></pre>

<hr>
<h2 id='databu'>
Simulated example for abundance model
</h2><span id='topic+databu'></span>

<h3>Description</h3>

<p>Simulated example for abundance model, see code below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(databu)</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations on the following 11 variables.
</p>

<dl>
<dt><code>N</code></dt><dd><p>true counts</p>
</dd>
<dt><code>Y</code></dt><dd><p>observed counts</p>
</dd>
<dt><code>x1</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>x2</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>x3</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>x4</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>x5</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>x6</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>p</code></dt><dd><p>probability of detection</p>
</dd>
<dt><code>lambda</code></dt><dd><p>mean of the linear predictor</p>
</dd>
<dt><code>A</code></dt><dd><p>occupancy</p>
</dd>
<dt><code>phi</code></dt><dd><p>zero inflation probabilities</p>
</dd>
</dl>



<h3>Details</h3>

<p>This simulated example corresponds to the Binomial - ZIP model implemented in the function <code><a href="#topic+svabu">svabu</a></code>.
</p>


<h3>Source</h3>

<p>Simulated example.
</p>


<h3>References</h3>

<p>Solymos, P., Lele, S. R. and Bayne, E. 2012.
Conditional likelihood approach for analyzing single visit
abundance survey data in the presence of zero inflation and
detection error.
<em>Environmetrics</em>, <b>23</b>, 197&ndash;205.
&lt;doi:10.1002/env.1149&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(databu)
str(databu)
## Not run: 
## simulation
n &lt;- 1000
set.seed(1234)
x1 &lt;- runif(n,0,1)
x2 &lt;- rnorm(n,0,1)
x3 &lt;- runif(n,-1,1)
x4 &lt;- runif(n,-1,1)
x5 &lt;- rbinom(n,1,0.6)
x6 &lt;- rbinom(n,1,0.4)
x7 &lt;- rnorm(n,0,1)
X &lt;- model.matrix(~ x1 + x5)
Z &lt;- model.matrix(~ x2 + x5)
Q &lt;- model.matrix(~ x7)
beta &lt;- c(2,-0.8,0.5)
theta &lt;- c(1, 2, -0.5)
phi &lt;- 0.3
p &lt;- drop(binomial("logit")$linkinv(Z %*% theta))
lambda &lt;- drop(exp(X %*% beta))
A &lt;- rbinom(n, 1, 1-phi)
N &lt;- rpois(n, lambda * A)
Y &lt;- rbinom(n, N, p)
databu &lt;- data.frame(N=N, Y=Y, x1, x2, x3, x4, x5, x6, p=p, lambda=lambda, A, phi)

## End(Not run)
</code></pre>

<hr>
<h2 id='datocc'>
Simulated example for occupancy model
</h2><span id='topic+datocc'></span>

<h3>Description</h3>

<p>Simulated example for occupancy model, see code below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(datocc)</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations on the following 6 variables.
</p>

<dl>
<dt><code>Y</code></dt><dd><p>true occupancy</p>
</dd>
<dt><code>W</code></dt><dd><p>observations</p>
</dd>
<dt><code>x1</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>x2</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>x3</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>x4</code></dt><dd><p>random variables used as covariates</p>
</dd>
<dt><code>p.occ</code></dt><dd><p>probability of occurrence</p>
</dd>
<dt><code>p.det</code></dt><dd><p>probability of detection</p>
</dd>
</dl>



<h3>Details</h3>

<p>This simulated example corresponds to the ZI Binomial model implemented in the function <code><a href="#topic+svocc">svocc</a></code>.
</p>


<h3>Source</h3>

<p>Simulated example.
</p>


<h3>References</h3>

<p>Lele, S.R., Moreno, M. and Bayne, E. (2011)
Dealing with detection error in site occupancy surveys:
What can we do with a single survey?
<em>Journal of Plant Ecology</em>, <b>5(1)</b>, 22&ndash;31.
&lt;doi:10.1093/jpe/rtr042&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(datocc)
str(datocc)
## Not run: 
## simulation
n &lt;- 1000
set.seed(1234)
x1 &lt;- runif(n, -1, 1)
x2 &lt;- as.factor(rbinom(n, 1, 0.5))
x3 &lt;- rnorm(n)
x4 &lt;- rnorm(n)
beta &lt;- c(0.6, 0.5)
theta &lt;- c(0.4, -0.5, 0.3)
X &lt;- model.matrix(~ x1)
Z &lt;- model.matrix(~ x1 + x3)
mu &lt;- drop(X %*% beta)
nu &lt;- drop(Z %*% theta)
p.occ &lt;- binomial("cloglog")$linkinv(mu)
p.det &lt;- binomial("logit")$linkinv(nu)
Y &lt;- rbinom(n, 1, p.occ)
W &lt;- rbinom(n, 1, Y * p.det)
datocc &lt;- data.frame(Y, W, x1, x2, x3, x4, p.occ, p.det)

## End(Not run)
</code></pre>

<hr>
<h2 id='hbootindex'>
Hierarchical bootstrap indices
</h2><span id='topic+hbootindex'></span>

<h3>Description</h3>

<p>Generates hierarchical bootstrap indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbootindex(groups, strata, B = 199)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbootindex_+3A_groups">groups</code></td>
<td>

<p>group membership vector.
</p>
</td></tr>
<tr><td><code id="hbootindex_+3A_strata">strata</code></td>
<td>

<p>strata, optional.
</p>
</td></tr>
<tr><td><code id="hbootindex_+3A_b">B</code></td>
<td>

<p>number of bootstrap iterations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Resampling with replacement with weights proportional to the number of 
observations in each of the group level (unique values in <code>groups</code>).
</p>
<p>Values of <code>groups</code> within levels (unique values) of <code>strata</code>
are resampled independently of other <code>strata</code> levels.
</p>


<h3>Value</h3>

<p>A matrix with bootstrapped indices, number of columns is <code>B</code> + 1.
The column is a resample without 
replacement (random subsets can be selected without further
reshuffling). Other elements contain indices according to rules
described in Details section (these also randomly reshuffled).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## equal group sizes
groups &lt;- rep(1:4, each=5)
strata &lt;- rep(1:2, each=10)
hbootindex(groups, strata, 3)

## unequal group sizes
groups &lt;- groups[-c(5,9,10,11)]
strata &lt;- strata[-c(5,9,10,11)]
hbootindex(groups, strata, 3)
</code></pre>

<hr>
<h2 id='load_BAM_QPAD'>
Load BAM QPAD parameter estimates and support functions
</h2><span id='topic+load_BAM_QPAD'></span>

<h3>Description</h3>

<p>Load BAM QPAD parameter estimates and support functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_BAM_QPAD(version)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_BAM_QPAD_+3A_version">version</code></td>
<td>

<p>version of the BAM QPAD estimates. List of selection is
provided if missing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>load_BAM_QPAD</code> function in the 'detect' package is deprecated.
Use the <code>load_BAM_QPAD</code> function 'QPAD' package instead.
See <a href="https://github.com/psolymos/QPAD">https://github.com/psolymos/QPAD</a> for more information.
</p>


<h3>Value</h3>

<p>It returns a message.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>References</h3>

<p>Solymos, P., Matsuoka, S. M., Bayne, E. M., Lele, S. R., Fontaine, P.,
Cumming, S. G., Stralberg, D., Schmiegelow, F. K. A. &amp; Song, S. J., 2013.
Calibrating indices of avian density from non-standardized survey data:
making the most of a messy situation.
<em>Methods in Ecology and Evolution</em>, <b>4</b>, 1047&ndash;1058.
&lt;doi:10.1111/2041-210X.12106&gt;
</p>
<p>Supporting info, including a tutorial for the above paper:
<a href="https://github.com/psolymos/QPAD/tree/master/inst/doc/v2">https://github.com/psolymos/QPAD/tree/master/inst/doc/v2</a>
</p>

<hr>
<h2 id='oven'>
Ovenbird abundances
</h2><span id='topic+oven'></span>

<h3>Description</h3>

<p>Ovenbird abundances from BBS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oven)</code></pre>


<h3>Format</h3>

<p>A data frame with 891 observations on the following 11 variables.
</p>

<dl>
<dt><code>count</code></dt><dd><p>observations</p>
</dd>
<dt><code>route</code></dt><dd><p>route id</p>
</dd>
<dt><code>stop</code></dt><dd><p>stop id within route</p>
</dd>
<dt><code>pforest</code></dt><dd><p>proportion of forest</p>
</dd>
<dt><code>pdecid</code></dt><dd><p>proportion of deciduous forest</p>
</dd>
<dt><code>pagri</code></dt><dd><p>proportion of agricultural areas</p>
</dd>
<dt><code>long</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
<dt><code>observ</code></dt><dd><p>observer, a factor with levels <code>ARS</code> <code>DW</code> <code>RDW</code> <code>SVW</code></p>
</dd>
<dt><code>julian</code></dt><dd><p>Julian day</p>
</dd>
<dt><code>timeday</code></dt><dd><p>time of day</p>
</dd>
</dl>



<h3>Source</h3>

<p>BBS, Erin Bayne (Univ. Alberta), unpublished data set used in Solymos et al. 2012.
</p>


<h3>References</h3>

<p>Solymos, P., Lele, S. R. and Bayne, E. 2012.
Conditional likelihood approach for analyzing single visit
abundance survey data in the presence of zero inflation and
detection error.
<em>Environmetrics</em>, <b>23</b>, 197&ndash;205.
&lt;doi:10.1002/env.1149&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oven)
str(oven)
</code></pre>

<hr>
<h2 id='svabu'>
Single visit N-mixture abundance models
</h2><span id='topic+svabu'></span><span id='topic+svabu.fit'></span><span id='topic+svabu_nb.fit'></span><span id='topic+zif'></span><span id='topic+is.present'></span><span id='topic+predictMCMC'></span><span id='topic+svabu.step'></span>

<h3>Description</h3>

<p>Binomial-Poisson, Binomial-NegBin, Binomial-ZIP, and Binomial-ZINB models with single visit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svabu(formula, data, zeroinfl = TRUE, area = 1, N.max = NULL,
    inits, link.det = "logit", link.zif = "logit",
    model = TRUE, x = FALSE, distr = c("P", "NB"), ...)

svabu.fit(Y, X, Z, Q = NULL, zeroinfl = TRUE, area = 1, N.max = NULL,
    inits, link.det = "logit", link.zif = "logit", ...)
svabu_nb.fit(Y, X, Z, Q = NULL, zeroinfl = TRUE, area = 1, N.max = NULL,
    inits, link.det = "logit", link.zif = "logit", ...)

zif(x)
is.present(object, ...)
predictMCMC(object, ...)
svabu.step(object, model, trace = 1, steps = 1000,
    criter = c("AIC", "BIC"), test = FALSE, k = 2, control, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svabu_+3A_formula">formula</code></td>
<td>

<p>formula of the form <code>y ~ x | z</code>, where <code>y</code> is a vector of observations,
<code>x</code> is the set of covariates for the occurrence model,
<code>z</code> is the set of covariates for the detection model.
<code>x</code> can further expanded as <code>x1 + zif(x2)</code> into terms for
the nonzero count data part (<code>x1</code>) and the zero inflation
component (<code>zif(x2)</code>) using the <code>zif</code> special.
</p>
</td></tr>
<tr><td><code id="svabu_+3A_y">Y</code>, <code id="svabu_+3A_x">X</code>, <code id="svabu_+3A_z">Z</code>, <code id="svabu_+3A_q">Q</code></td>
<td>

<p>vector of observation, design matrix for abundance model, design matrix for detection
and design matrix for zero inflation model
</p>
</td></tr>
<tr><td><code id="svabu_+3A_data">data</code></td>
<td>

<p>data
</p>
</td></tr>
<tr><td><code id="svabu_+3A_area">area</code></td>
<td>

<p>area
</p>
</td></tr>
<tr><td><code id="svabu_+3A_n.max">N.max</code></td>
<td>

<p>maximum of true count values (for calculating the integral)
</p>
</td></tr>
<tr><td><code id="svabu_+3A_zeroinfl">zeroinfl</code></td>
<td>

<p>logical, if the Binomial-ZIP model should be fitted
</p>
</td></tr>
<tr><td><code id="svabu_+3A_inits">inits</code></td>
<td>

<p>initial values used by <code>link{optim}</code>
</p>
</td></tr>
<tr><td><code id="svabu_+3A_link.det">link.det</code>, <code id="svabu_+3A_link.zif">link.zif</code></td>
<td>

<p>link function for the detection and zero inflation parts of the model
</p>
</td></tr>
<tr><td><code id="svabu_+3A_model">model</code></td>
<td>

<p>a logical value indicating whether model frame should be included as a component of the returned value,
or true state or detection model
</p>
</td></tr>
<tr><td><code id="svabu_+3A_x">x</code></td>
<td>

<p>logical values indicating whether the response vector and model matrix used in the
fitting process should be returned as components of the returned value.
For the function <code>zif</code> it is any object to be returned.
</p>
</td></tr>
<tr><td><code id="svabu_+3A_object">object</code></td>
<td>

<p>a fitted object.
</p>
</td></tr>
<tr><td><code id="svabu_+3A_trace">trace</code></td>
<td>

<p>info returned during the procedure
</p>
</td></tr>
<tr><td><code id="svabu_+3A_steps">steps</code></td>
<td>

<p>max number of steps
</p>
</td></tr>
<tr><td><code id="svabu_+3A_criter">criter</code></td>
<td>

<p>criterion to be minimized (cAUC=1-AUC)
</p>
</td></tr>
<tr><td><code id="svabu_+3A_test">test</code></td>
<td>

<p>logical, if decrease in deviance should be tested
</p>
</td></tr>
<tr><td><code id="svabu_+3A_k">k</code></td>
<td>

<p>penalty to be used with AIC
</p>
</td></tr>
<tr><td><code id="svabu_+3A_control">control</code></td>
<td>

<p>controls for optimization, if missing taken from object
</p>
</td></tr>
<tr><td><code id="svabu_+3A_distr">distr</code></td>
<td>

<p>character, abundance distribution: <code>"P"</code> for Poisson,
<code>"NB"</code> for Negative Binomial.
</p>
</td></tr>
<tr><td><code id="svabu_+3A_...">...</code></td>
<td>

<p>other arguments passed to the functions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Examples.
</p>
<p>The right hand side of the formula must contain at least one
continuous (i.e. non discrete/categorical) covariate.
This is the necessary condition for the single-visit
method to be valid and parameters to be identifiable.
See References for more detailed description.
</p>
<p>The Binomial-Poisson model is the single visit special case
of the <em>N</em>-mixture model proposed by Royle (2004)
and explained in Solymos et a. (2012) and Solymos and Lele (2016).
</p>


<h3>Value</h3>

<p>An object of class 'svabu'.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos and Subhash Lele
</p>


<h3>References</h3>

<p>Royle, J. A. 2004.
<em>N</em>-Mixture Models for Estimating Population Size from Spatially Replicated Counts.
<em>Biometrics</em>, <b>60(1)</b>, 108&ndash;115.
&lt;doi:10.1111/j.0006-341X.2004.00142.x&gt;
</p>
<p>Solymos, P., Lele, S. R. and Bayne, E. 2012.
Conditional likelihood approach for analyzing single visit
abundance survey data in the presence of zero inflation and
detection error.
<em>Environmetrics</em>, <b>23</b>, 197&ndash;205.
&lt;doi:10.1002/env.1149&gt;
</p>
<p>Solymos, P., Lele, S. R. 2016.
Revisiting resource selection probability functions and single-visit methods:
clarification and extensions.
<em>Methods in Ecology and Evolution</em>, <b>7</b>, 196&ndash;205.
&lt;doi:10.1111/2041-210X.12432&gt;
</p>
<p>Denes, F., Solymos, P., Lele, S. R., Silveira, L. &amp; Beissinger, S. 2017.
Biome scale signatures of land use change on raptor abundance:
insights from single-visit detection-based models.
<em>Journal of Applied Ecology</em>, <b>54</b>, 1268&ndash;1278.
&lt;doi:10.1111/1365-2664.12818&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(databu)

## fit BZIP and BP models
m00 &lt;- svabu(Y ~ x1 + x5 | x2 + x5, databu[1:200,])

## print method
m00
## summary: CMLE
summary(m00)
## coef
coef(m00)
coef(m00, model="sta") ## state (abundance)
coef(m00, model="det") ## detection
coef(m00, model="zif") ## zero inflation (this is part of the 'true state'!)

## Not run: 
## Diagnostics and model comparison

m01 &lt;- svabu(Y ~ x1 + x5 | x2 + x5, databu[1:200,], zeroinfl=FALSE)
## compare estimates (note, zero inflation is on the logit scale!)
cbind(truth=c(2,-0.8,0.5, 1,2,-0.5, plogis(0.3)),
"B-ZIP"=coef(m00), "B-P"=c(coef(m01), NA))

## fitted
plot(fitted(m00), fitted(m01))
abline(0,1)

## compare models
AIC(m00, m01)
BIC(m00, m01)
logLik(m00)
logLik(m01)
## diagnostic plot
plot(m00)
plot(m01)

## Bootstrap

## non parametric bootstrap
## - initial values are the estimates
m02 &lt;- bootstrap(m00, B=25)
attr(m02, "bootstrap")
extractBOOT(m02)
summary(m02)
summary(m02, type="cmle")
summary(m02, type="boot")
## vcov
vcov(m02, type="cmle")
vcov(m02, type="boot")
vcov(m02, model="sta")
vcov(m02, model="det")
## confint
confint(m02, type="cmle") ## Wald-type
confint(m02, type="boot") ## quantile based
## parametric bootstrap
simulate(m00, 5)
m03 &lt;- bootstrap(m00, B=5, type="param")
extractBOOT(m03)
summary(m03)

## Model selection

m04 &lt;- svabu(Y ~ x1 + x5 | x2 + x5 + x3, databu[1:200,], phi.boot=0)
m05 &lt;- drop1(m04, model="det")
m05
m06 &lt;- svabu.step(m04, model="det")
summary(m06)
m07 &lt;- update(m04, . ~ . | . - x3)
m07

## Controls

m00$control
getOption("detect.optim.control")
getOption("detect.optim.method")
options("detect.optim.method"="BFGS")
m08 &lt;- svabu(Y ~ x1 + x5 | x2 + x5, databu[1:100,])
m08$control ## but original optim method is retained during model selection and bootstrap
## fitted models can be used to provide initial values
options("detect.optim.method"="Nelder-Mead")
m09 &lt;- svabu(Y ~ x1 + x5 | x2 + x5, databu[1:100,], inits=coef(m08))

## Ovenbirds dataset

data(oven)
ovenc &lt;- oven
ovenc[, c(4:8,10:11)][] &lt;- lapply(ovenc[, c(4:8,10:11)], scale)
moven &lt;- svabu(count ~ pforest | observ + pforest + julian + timeday, ovenc)
summary(moven)
drop1(moven, model="det")
moven2 &lt;- update(moven, . ~ . | . - timeday)
summary(moven2)
moven3 &lt;- update(moven2, . ~ . | ., zeroinfl=FALSE)
summary(moven3)
BIC(moven, moven2, moven3)

## End(Not run)
</code></pre>

<hr>
<h2 id='svocc'>
ZI Binomial model with single visit
</h2><span id='topic+svocc'></span><span id='topic+svocc.fit'></span><span id='topic+extractMLE'></span><span id='topic+svocc.step'></span>

<h3>Description</h3>

<p>ZI Binomial model with single visit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svocc(formula, data, link.sta = "cloglog", link.det = "logit",
    penalized = FALSE, method = c("optim", "dc"), inits,
    model = TRUE, x = FALSE, ...)
svocc.fit(Y, X, Z, link.sta = "cloglog", link.det = "logit",
    penalized = FALSE, auc = FALSE, method = c("optim", "dc"),
    inits, ...)

extractMLE(object, ...)
svocc.step(object, model, trace = 1, steps = 1000,
    criter = c("AIC", "BIC", "cAUC"), test = FALSE, k = 2,
    control, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svocc_+3A_formula">formula</code></td>
<td>

<p>formula of the form <code>y ~ x | z</code>, where <code>y</code> is a vector of observations,
<code>x</code> is the set of covariates for the occurrence model,
<code>z</code> is the set of covariates for the detection model
</p>
</td></tr>
<tr><td><code id="svocc_+3A_y">Y</code>, <code id="svocc_+3A_x">X</code>, <code id="svocc_+3A_z">Z</code></td>
<td>

<p>vector of observation, design matrix for occurrence model, and design matrix for detection model
</p>
</td></tr>
<tr><td><code id="svocc_+3A_data">data</code></td>
<td>

<p>data
</p>
</td></tr>
<tr><td><code id="svocc_+3A_link.sta">link.sta</code>, <code id="svocc_+3A_link.det">link.det</code></td>
<td>

<p>link function for the occurrence (true state) and detection model
</p>
</td></tr>
<tr><td><code id="svocc_+3A_penalized">penalized</code></td>
<td>

<p>logical, if penalized likelihood estimate should be computed
</p>
</td></tr>
<tr><td><code id="svocc_+3A_method">method</code></td>
<td>

<p>optimization or data cloning to be used as optimization
</p>
</td></tr>
<tr><td><code id="svocc_+3A_inits">inits</code></td>
<td>

<p>initial values
</p>
</td></tr>
<tr><td><code id="svocc_+3A_model">model</code></td>
<td>

<p>a logical value indicating whether model frame should be included as a component of the returned value,
or true state or detection model
</p>
</td></tr>
<tr><td><code id="svocc_+3A_x">x</code></td>
<td>

<p>logical values indicating whether the response vector and model matrix used in the
fitting process should be returned as components of the returned value
</p>
</td></tr>
<tr><td><code id="svocc_+3A_auc">auc</code></td>
<td>

<p>logical, if AUC should be calculated
</p>
</td></tr>
<tr><td><code id="svocc_+3A_object">object</code></td>
<td>

<p>a fitted model object
</p>
</td></tr>
<tr><td><code id="svocc_+3A_trace">trace</code></td>
<td>

<p>info returned during the procedure
</p>
</td></tr>
<tr><td><code id="svocc_+3A_steps">steps</code></td>
<td>

<p>max number of steps
</p>
</td></tr>
<tr><td><code id="svocc_+3A_criter">criter</code></td>
<td>

<p>criterion to be minimized (cAUC=1-AUC)
</p>
</td></tr>
<tr><td><code id="svocc_+3A_test">test</code></td>
<td>

<p>logical, if decrease in deviance should be tested
</p>
</td></tr>
<tr><td><code id="svocc_+3A_k">k</code></td>
<td>

<p>penalty to be used with AIC
</p>
</td></tr>
<tr><td><code id="svocc_+3A_control">control</code></td>
<td>

<p>controls for optimization, if missing taken from object
</p>
</td></tr>
<tr><td><code id="svocc_+3A_...">...</code></td>
<td>

<p>other arguments passed to the functions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Examples.
</p>
<p>The right hand side of the formula must contain at least one
continuous (i.e. non discrete/categorical) covariate.
This is the necessary condition for the single-visit
method to be valid and parameters to be identifiable.
See References for more detailed description.
</p>


<h3>Value</h3>

<p>An object of class 'svocc'.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos and Monica Moreno
</p>


<h3>References</h3>

<p>Lele, S.R., Moreno, M. and Bayne, E. 2011.
Dealing with detection error in site occupancy surveys:
What can we do with a single survey?
<em>Journal of Plant Ecology</em>, <b>5(1)</b>, 22&ndash;31.
&lt;doi:10.1093/jpe/rtr042&gt;
</p>
<p>Moreno, M. and Lele, S. R. 2010.
Improved estimation of site occupancy using penalized likelihood.
<em>Ecology</em>, <b>91</b>, 341&ndash;346.
&lt;doi:10.1890/09-1073.1&gt;
</p>
<p>Solymos, P., Lele, S. R. 2016.
Revisiting resource selection probability functions and single-visit methods:
clarification and extensions.
<em>Methods in Ecology and Evolution</em>, <b>7</b>, 196&ndash;205.
&lt;doi:10.1111/2041-210X.12432&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(datocc)
## MLE
m00 &lt;- svocc(W ~ x1 | x1 + x3, datocc)
## PMLE
m01 &lt;- svocc(W ~ x1 | x1 + x3, datocc, penalized=TRUE)

## print
m00
## summary
summary(m00)
## coefficients
coef(m00)
## state (occupancy) model estimates
coef(m00, "sta")
## detection model estimates
coef(m00, "det")
## compare estimates
cbind(truth=c(0.6, 0.5, 0.4, -0.5, 0.3),
mle=coef(m00), pmle=coef(m01))

## AIC, BIC
AIC(m00)
BIC(m00)
## log-likelihood
logLik(m00)
## variance-covariance matrix
vcov(m00)
vcov(m00, model="sta")
vcov(m00, model="det")
## confidence intervals
confint(m00)
confint(m00, model="sta")
confint(m00, model="det")

## fitted values
## (conditional probability of occurrence given detection history:
## if W=1, fitted=1,
## if W=0, fitted=(phi*(1-delta)) / ((1-delta) + phi * (1-delta))
summary(fitted(m00))
## estimated probabilities: (phi*(1-delta)) / ((1-delta) + phi * (1-delta))
summary(m00$estimated.probabilities)
## probability of occurrence (phi)
summary(m00$occurrence.probabilities)
## probability of detection (delta)
summary(m00$detection.probabilities)

## Not run: 
## model selection
m02 &lt;- svocc(W ~ x1 | x3 + x4, datocc)
m03 &lt;- drop1(m02, model="det")
## dropping one term at a time, resulting change in AIC
m03
## updating the model
m04 &lt;- update(m02, . ~ . | . - x4)
m04
## automatic model selection
## part of the model (sta/det) must be specified
m05 &lt;- svocc.step(m02, model="det")
summary(m05)

## nonparametric bootstrap
m06 &lt;- bootstrap(m01, B=25)
attr(m06, "bootstrap")
extractBOOT(m06)
summary(m06, type="mle")
summary(m06, type="pmle") ## no SEs! PMLE!!!
summary(m06, type="boot")
## vcov
#vcov(m06, type="mle") ## this does not work with PMLE
vcov(m06, type="boot") ## this works
## confint
confint(m06, type="boot") ## quantile based

## parametric bootstrap
## sthis is how observations are simulated
head(simulate(m01, 5))
m07 &lt;- bootstrap(m01, B=25, type="param")
extractBOOT(m07)
summary(m07)

data(oven)
ovenc &lt;- oven
ovenc[, c(4:8,10:11)][] &lt;- lapply(ovenc[, c(4:8,10:11)], scale)
ovenc$count01 &lt;- ifelse(ovenc$count &gt; 0, 1, 0)
moven &lt;- svocc(count01 ~ pforest | julian + timeday, ovenc)
summary(moven)
drop1(moven, model="det")
moven2 &lt;- update(moven, . ~ . | . - timeday)
summary(moven)

BIC(moven, moven2)
AUC(moven, moven2)
rocplot(moven)
rocplot(moven2, col=2, add=TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
