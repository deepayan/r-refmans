<!DOCTYPE html><html><head><title>Help for package brokenstick</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {brokenstick}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brokenstick'><p>Fit a <code>brokenstick</code> model to irregular data</p></a></li>
<li><a href='#brokenstick-class'><p>Class <code>brokenstick</code></p></a></li>
<li><a href='#brokenstick-pkg'><p><span class="pkg">brokenstick</span>: A package for irregular longitudinal data.</p></a></li>
<li><a href='#coef.brokenstick'><p>Extract Model Coefficients from brokenstick Object</p></a></li>
<li><a href='#control_kr'><p>Set controls for Kasim-Raudenbush sampler</p></a></li>
<li><a href='#EB'><p>Empirical Bayes predictor for random effects</p></a></li>
<li><a href='#fit_200'><p>Broken stick model with nine lines for 200 children</p></a></li>
<li><a href='#fit_200_light'><p>Broken stick model with nine lines for 200 children (light)</p></a></li>
<li><a href='#fitted.brokenstick'><p>Calculate fitted values</p></a></li>
<li><a href='#get_knots'><p>Obtain the knots from a broken stick model</p></a></li>
<li><a href='#get_omega'><p>Extract Variance and Correlation Components</p></a></li>
<li><a href='#get_r2'><p>Obtain proportion of explained variance from a broken stick model</p></a></li>
<li><a href='#kr'><p>Kasim-Raudenbush sampler for two-level normal model</p></a></li>
<li><a href='#make_basis'><p>Create linear splines basis</p></a></li>
<li><a href='#parse_formula'><p>Parse formula for brokenstick model</p></a></li>
<li><a href='#plot_trajectory'><p>Plot observed and fitted trajectories from fitted brokenstick model</p></a></li>
<li><a href='#plot.brokenstick'><p>Plot observed and fitted trajectories by group</p></a></li>
<li><a href='#predict.brokenstick'><p>Predict from a <code>brokenstick</code> model</p></a></li>
<li><a href='#print.brokenstick'><p>Print brokenstick object</p></a></li>
<li><a href='#residuals.brokenstick'><p>Extract residuals from brokenstick model</p></a></li>
<li><a href='#set_control'><p>Set controls to steer calculations</p></a></li>
<li><a href='#smocc_200'><p>Infant growth of 0-2 years, SMOCC data extract</p></a></li>
<li><a href='#summary.brokenstick'><p>Create summary of brokenstick object</p></a></li>
<li><a href='#weightloss'><p>Weight loss self-measurement data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Broken Stick Model for Irregular Longitudinal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Data on multiple individuals through time are often sampled at 
    times that differ between persons. Irregular observation times can severely 
    complicate the statistical analysis of the data. The broken stick model 
    approximates each subjectâ€™s trajectory by one or more connected line segments. 
    The times at which segments connect (breakpoints) are identical for all 
    subjects and under control of the user. A well-fitting broken stick model 
    effectively transforms individual measurements made at irregular times into 
    regular trajectories with common observation times. Specification of the 
    model requires three variables: time, measurement and subject. The 
    model is a special case of the linear mixed model, with time as a linear 
    B-spline and subject as the grouping factor. The main assumptions are: 
    subjects are exchangeable, trajectories between consecutive breakpoints are 
    straight, random effects follow a multivariate normal distribution, and 
    unobserved data are missing at random. The package contains functions for 
    fitting the broken stick model to data, for predicting curves in new data 
    and for plotting broken stick estimates. The package supports two 
    optimization methods, and includes options to structure the 
    variance-covariance matrix of the random effects. The analyst may use the 
    software to smooth growth curves by a series of connected straight lines, to 
    align irregularly observed curves to a common time grid, to create synthetic 
    curves at a user-specified set of breakpoints, to estimate the time-to-time 
    correlation matrix and to predict future observations. See 
    &lt;<a href="https://doi.org/10.18637%2Fjss.v106.i07">doi:10.18637/jss.v106.i07</a>&gt; for additional documentation on background, 
    methodology and applications.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, dplyr, lme4, matrixsampling, methods, rlang, splines,
stats, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AGD, bookdown, ggplot2, grDevices, gridExtra, knitr, lattice,
MASS, Matrix, mice, mvtnorm, plyr, svglite, testthat, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td>doi:10.18637/jss.v106.i07, <a href="https://growthcharts.org/brokenstick/">https://growthcharts.org/brokenstick/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/growthcharts/brokenstick/issues">https://github.com/growthcharts/brokenstick/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-22 19:56:46 UTC; buurensv</td>
</tr>
<tr>
<td>Author:</td>
<td>Stef van Buuren [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stef van Buuren &lt;stef.vanbuuren@tno.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 23:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='brokenstick'>Fit a <code>brokenstick</code> model to irregular data</h2><span id='topic+brokenstick'></span>

<h3>Description</h3>

<p>The <code>brokenstick()</code> function fits an irregularly observed series
of measurements onto a user-specified grid of points (knots).
The model codes the grid by a series of linear B-splines.
Each modelled trajectory consists of straight lines that join at
the chosen knots and look like a broken stick. Differences between
observations are expressed by a random effect per knot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brokenstick(
  formula,
  data,
  knots = NULL,
  boundary = NULL,
  k = 5L,
  degree = 1L,
  method = c("kr", "lmer"),
  control = set_control(method = method, ...),
  na.action = na.exclude,
  light = FALSE,
  hide = c("right", "left", "boundary", "internal", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brokenstick_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the outcome, the predictor and the group
variable in <code>data</code>. The generic shape is <code>formula = y ~ x | group</code>. The
left-hand side is the outcome, the right-hand side the predictor, and the
name of the grouping variable occurs after the <code>|</code> sign. Formula treatment
is non-standard: 1) <code>y</code> and <code>x</code> should be numeric, 2) only one variable
is allowed in each model term (additional variables will be ignored).</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the outcome (numeric),
predictor (numeric) and group (numeric, factor, character) variable.</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_knots">knots</code></td>
<td>
<p>Optional, but recommended. Numerical vector with the
locations of the internal knots to be placed on the values of the predictor.
The function sorts the internal knots in increasing order.</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_boundary">boundary</code></td>
<td>
<p>Optional, but recommended. Numerical vector of
length 2 with the left and right boundary knot. The <code>boundary</code>
setting is passed to <code><a href="splines.html#topic+bs">splines::bs()</a></code> as the <code>Boundary.knots</code> argument.
If not specified, the function determines the boundary knots as
<code>range(x)</code>. When specified, the <code>boundary</code> range is internally
expanded to include at least <code>range(knots)</code>.</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_k">k</code></td>
<td>
<p>Optional, a convenience parameter for the number of
internal knots. If specified, then <code>k</code> internal knots are placed
at equidense quantiles of the predictor. For example,
specifying <code>k = 1</code> puts a knot at the 50th quantile (median),
setting <code>k = 3</code> puts knots at the 25th, 50th and 75th quantiles,
and so on. If the user specifies both <code>k</code> and <code>knots</code> arguments
then <code>knots</code> takes precedence. The default is <code>k = 5</code>, so if the user
does not specify any of <code>knots</code>, <code>boundary</code> or <code>k</code>, then the knots
will be at the 16th, 33th, 50th, 66th and 84th quantile of the
predictor.</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_degree">degree</code></td>
<td>
<p>the degree of the spline. The broken stick model
requires linear splines, so the default is <code>degree = 1</code>.
Setting <code>degree = 0</code> yields (crisp) dummy coding, and one
column less than for <code>degree = 1</code>. The <code>brokenstick</code> package supports
only <code>degree = 0</code> and <code>degree = 1</code>.</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_method">method</code></td>
<td>
<p>Estimation method. Either <code>"kr"</code> (for the
Kasim-Raudenbush sampler) or <code>"lmer"</code> (for <code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code>).
Version 1.1.1.9000 changed the default to <code>method = "kr"</code>.</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_control">control</code></td>
<td>
<p>List of control options returned by <code><a href="#topic+set_control">set_control()</a></code> used
to set algorithmic details. A list with parameters. When not specified,
the functions sets to defaults
for method <code>"kr"</code> by <code><a href="#topic+control_kr">control_kr()</a></code>, and
for method <code>"lmer"</code> by <code><a href="lme4.html#topic+lmerControl">lme4::lmerControl()</a></code>. For ease of use, the user
may set individual options to <code>"kr"</code> (e.g. <code>niter = 500</code>) via the ...
arguments.</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_na.action">na.action</code></td>
<td>
<p>A function that indicates what <code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code> should so
when the data contain <code>NA</code>s. Default set to <code>na.exclude</code>. Only used by
method <code>"lmer"</code>.</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_light">light</code></td>
<td>
<p>Should the returned object be lighter? If <code>light = TRUE</code>
the returned object will contain only the model settings and parameter
estimates and not store the <code>data</code>, <code>imp</code> and <code>mod</code> elements. The light
object can be used to predict broken stick estimates for new data, but
does not disclose the training data and is very small (often &lt;20 Kb).</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_hide">hide</code></td>
<td>
<p>Should output for knots be hidden in get, print, summary and plot
functions? Can be <code>"left"</code>, <code>"right"</code>, <code>"boundary"</code>, <code>"internal"</code> or <code>"none"</code>.
The default is <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="brokenstick_+3A_...">...</code></td>
<td>
<p>Forwards arguments to <code><a href="#topic+control_kr">control_kr()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The choice between <code>method = "kr"</code> and <code>method = "lmer"</code> depends on the size
of the data and the complexity of the model. In general, setting <code>method = "lmer"</code>
can require substantial calculation time for more complex models
(say &gt; 8 internal knots) and may not converge. Method <code>"kr"</code> is less
sensitive to model complexity and small samples, and has the added benefit that the
variance-covariance matrix of the random effects can be constrained through the
<code>cormodel</code> argument. On the other hand, <code>"lmer"</code> is the better-researched
method, and is more efficient for simpler models and datasets with many
rows.
</p>
<p>The default algorithm since version 2.0 is the Bayesian Kasim-Raudenbush
sampler (<code>method = "kr"</code>). The variance-covariance matrix of the broken stick
estimates absorbs the relations over time. The <code>"kr"</code> method allows
enforcing a simple structure on this variance-covariance matrix. Currently,
there are three such correlation models: <code>"none"</code> (default), <code>"argyle"</code>
and <code>"cole"</code>. Specify the <code>seed</code> argument for reproducibility.
See <code><a href="#topic+control_kr">control_kr()</a></code> for more details.
</p>
<p>The alternative <code>method = "lmer"</code> fits the broken stick model by
<code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code>. With this method, the variance-covariance matrix can only be
unstructured. This estimate may be unstable if the number of children is
small relative to the number of specified knots. The default setting
in <code><a href="lme4.html#topic+lmerControl">lme4::lmerControl()</a></code> is  <code>check.nobs.vs.nRE= "stop"</code>. The
<code style="white-space: pre;">&#8288;[set_control()]&#8288;</code> function changes this to <code>check.nobs.vs.nRE= "warning"</code>
by default, since otherwise many broken stick models would not run at all.
The method throws warnings that estimates are not stable. It can be time
for models with many internal knots. Despite the warnings,
the results often look reasonable.
</p>
<p>Diagnostics with <span class="pkg">coda</span> and <span class="pkg">lme4</span>: The function returns an object
of class <code>brokenstick</code>. For <code>method = "kr"</code> the list component named
<code>"mod"</code> contains a list of <code>mcmc</code> objects that can be further analysed with
<code><a href="coda.html#topic+trellisplots">coda::acfplot()</a></code>, <code><a href="coda.html#topic+autocorr">coda::autocorr()</a></code>, <code><a href="coda.html#topic+crosscorr">coda::crosscorr()</a></code>, <code><a href="coda.html#topic+cumuplot">coda::cumuplot()</a></code>,
<code><a href="coda.html#topic+densplot">coda::densplot()</a></code>, <code><a href="coda.html#topic+effectiveSize">coda::effectiveSize()</a></code>, <code><a href="coda.html#topic+geweke.plot">coda::geweke.plot()</a></code>,
<code><a href="coda.html#topic+raftery.diag">coda::raftery.diag()</a></code>, <code><a href="coda.html#topic+traceplot">coda::traceplot()</a></code> and the usual <code>plot()</code>
and <code>summary()</code> functions. For <code>method = "lmer"</code> the list component named
<code>"mod"</code> contains an object of class <a href="lme4.html#topic+merMod-class">lme4::merMod</a>. These model objects
are omitted in light <code>brokenstick</code> objects.
</p>


<h3>Value</h3>

<p>A object of class <code>brokenstick</code>.
</p>


<h3>Note</h3>

<p>Note that automatic knot specification is data-dependent, and may not reproduce
on other data. Likewise, knots specified via <code>k</code> are data-dependent and do not transfer
to other  data sets. Fixing the model requires specifying both <code>knots</code> and
<code>boundary</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- smocc_200[1:1198, ]

# using kr method, default
f1 &lt;- brokenstick(hgt_z ~ age | id, data, knots = 0:2, seed = 123)
plot(f1, data, n_plot = 9)

# study sampling behaviour of the sigma2 parameter with coda
library("coda")
plot(f1$mod$sigma2)
acfplot(f1$mod$sigma2)

# using lmer method
f2 &lt;- brokenstick(hgt_z ~ age | id, data, knots = 0:2, method = "lmer")
plot(f2, data, n_plot = 9)

# drill down into merMod object with standard diagnostics in lme4
summary(f2$mod)
plot(f2$mod)

# a model with more knots
knots &lt;- round(c(0, 1, 2, 3, 6, 9, 12, 15, 18, 24, 36) / 12, 4)

# method kr takes about 2 seconds
f3 &lt;- brokenstick(hgt_z ~ age | id, data, knots, seed = 222)
plot(f3, data, n_plot = 9)

# method lmer takes about 40 seconds
f4 &lt;- brokenstick(hgt_z ~ age | id, data, knots, method = "lmer")
plot(f4, data, n_plot = 9)

</code></pre>

<hr>
<h2 id='brokenstick-class'>Class <code>brokenstick</code></h2><span id='topic+brokenstick-class'></span>

<h3>Description</h3>

<p>The main fitting function <code><a href="#topic+brokenstick">brokenstick()</a></code> returns an object of class
<code>brokenstick</code>. This object collects the fitted broken stick model.
</p>


<h3>Details</h3>

<p>The package exports S3 methods for the <code>brokenstick</code> class for the following
generic functions: <code><a href="stats.html#topic+coef">coef()</a></code>, <code><a href="stats.html#topic+fitted">fitted()</a></code>, <code><a href="stats.html#topic+model.frame">model.frame()</a></code>, <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>,
<code><a href="graphics.html#topic+plot">plot()</a></code>, <code><a href="stats.html#topic+predict">predict()</a></code>, <code><a href="base.html#topic+print">print()</a></code>, <code><a href="stats.html#topic+residuals">residuals()</a></code> and <code><a href="base.html#topic+summary">summary()</a></code>.
</p>
<p>The package exports the following helper functions for <code>brokenstick</code> objects:
<code><a href="#topic+get_knots">get_knots()</a></code>, <code><a href="#topic+get_omega">get_omega()</a></code> and <code><a href="#topic+get_r2">get_r2()</a></code>.
</p>
<p>A <code>brokenstick</code> object is a list with the following named elements:
</p>


<h3>Elements</h3>


<dl>
<dt><code>call</code></dt><dd><p>Call that created the object</p>
</dd>
<dt><code>names</code></dt><dd><p>A named list with three elements (<code>"x"</code>, <code>"y"</code>, <code>"g"</code>)
providing the variable name for time, outcome and subject, respectively.</p>
</dd>
<dt><code>internal</code></dt><dd><p>Numeric vector of with internal knots.</p>
</dd>
<dt><code>boundary</code></dt><dd><p>Numeric vector of length 2 with the boundary knots.</p>
</dd>
<dt><code>degree</code></dt><dd><p>The <code>degree</code> of the B-spline. See <code><a href="splines.html#topic+bs">splines::bs()</a></code>. Support
only the values of 0 (step model) or 1 (broken stick model).</p>
</dd>
<dt><code>method</code></dt><dd><p>String, either <code>"kr"</code> or <code>"lmer"</code>, identifying the fitting model.</p>
</dd>
<dt><code>control</code></dt><dd><p>List of control options returned by <code><a href="#topic+set_control">set_control()</a></code> used
to set algorithmic details.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Numeric vector with fixed effect estimates.</p>
</dd>
<dt><code>omega</code></dt><dd><p>Numeric matrix with variance-covariance estimates of the
broken stick estimates.</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>Numeric scalar with the mean residual variance.</p>
</dd>
<dt><code>sample</code></dt><dd><p>A numeric vector with descriptives of the training data.</p>
</dd>
<dt><code>light</code></dt><dd><p>Should the returned object be lighter? If <code>light = TRUE</code>
the returned object will contain only the model settings and parameter
estimates and not store the <code>sigma2j</code>, <code>sample</code>, <code>data</code>, <code>imp</code> and
<code>mod</code> elements.
The light object can be used to predict broken stick estimates for
new data, but does not disclose the training data and is small.</p>
</dd>
<dt><code>hide</code></dt><dd><p>Should the output for boundary knots be hidden? Can
be <code>"right"</code>, <code>"left"</code>, <code>"boundary"</code>, <code>"internal"</code> or <code>"none"</code>.
The default is <code>"right"</code>.</p>
</dd>
<dt><code>sigma2j</code></dt><dd><p>Numeric vector with estimates of the residual variance per
group. Only used by method <code>"kr"</code>.</p>
</dd>
<dt><code>data</code></dt><dd><p>The training data used to fit the model.</p>
</dd>
<dt><code>imp</code></dt><dd><p>The imputations generated for the missing outcome data. Only
for <code>method = "kr"</code>.</p>
</dd>
<dt><code>mod</code></dt><dd><p>For <code>method = "kr"</code>: A named list with four components, each of
class <a href="coda.html#topic+mcmc">coda::mcmc</a>. For <code>method = "lmer"</code>: An object of class
<a href="lme4.html#topic+merMod-class">lme4::merMod</a>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stef van Buuren 2023
</p>


<h3>References</h3>

<p><a href="doi:10.18637/jss.v106.i07">doi:10.18637/jss.v106.i07</a>
</p>

<hr>
<h2 id='brokenstick-pkg'><span class="pkg">brokenstick</span>: A package for irregular longitudinal data.</h2><span id='topic+brokenstick-pkg'></span>

<h3>Description</h3>

<p>The broken stick model describes a set of individual curves
by a linear mixed model using second-order linear B-splines. The
main use of the model is to align irregularly observed data to a
user-specified grid of break ages.
</p>


<h3>Details</h3>

<p>The <span class="pkg">brokenstick</span> package contains functions for
fitting a broken stick model to data, for predicting broken
stick curves for new data, and for plotting the results.
</p>


<h3>brokenstick functions</h3>

<p>The main functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>brokenstick()</code> </td><td style="text-align: left;"> Fit a broken stick model to irregular data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>plot()</code> </td><td style="text-align: left;"> Plot observed and fitted trajectories by group </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>predict()</code> </td><td style="text-align: left;"> Obtain predictions on new data</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>summary()</code> </td><td style="text-align: left;"> Extract object summaries</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The following functions are user-oriented helpers:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>coef()</code> </td><td style="text-align: left;"> Extract estimated parameters</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>fitted()</code> </td><td style="text-align: left;"> Calculate fitted values</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>get_knots()</code> </td><td style="text-align: left;"> Obtain the knots from a broken stick model</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>get_omega()</code> </td><td style="text-align: left;"> Extract variance-covariance of random effects</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>get_r2()</code> </td><td style="text-align: left;"> Obtain proportion of explained variance </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>model.frame()</code> </td><td style="text-align: left;"> Extract model frame</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>model.matrix()</code> </td><td style="text-align: left;"> Extract design matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>residuals()</code> </td><td style="text-align: left;"> Extract residuals from broken stick model</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The following functions perform calculations:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>set_control()</code></td><td style="text-align: left;"> Set controls to steer calculations</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>control_kr()</code></td><td style="text-align: left;"> Set controls for the <code>kr</code> method</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>This work was supported by the Bill &amp; Melinda Gates Foundation. The contents
are the sole responsibility of the authors and may not necessarily represent
the official views of the Bill &amp; Melinda Gates Foundation or other agencies
that may have supported the primary data studies used in the present study.
</p>


<h3>References</h3>

<p>van Buuren, S. (2023). Broken Stick Model for Irregular Longitudinal Data.
<em>Journal of Statistical Software</em>, 106(7), 1&ndash;51.
<a href="doi:10.18637/jss.v106.i07">doi:10.18637/jss.v106.i07</a>
</p>
<p>van Buuren, S. (2018). <em>Flexible Imputation of Missing Data. Second Edition</em>.
Chapman &amp; Hall/CRC. Chapter 11.
<a href="https://stefvanbuuren.name/fimd/sec-rastering.html#sec:brokenstick">https://stefvanbuuren.name/fimd/sec-rastering.html#sec:brokenstick</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brokenstick">brokenstick</a></code>,
<code><a href="#topic+EB">EB</a></code>, <code><a href="#topic+predict.brokenstick">predict.brokenstick</a></code>
</p>

<hr>
<h2 id='coef.brokenstick'>Extract Model Coefficients from brokenstick Object</h2><span id='topic+coef.brokenstick'></span>

<h3>Description</h3>

<p>Extract Model Coefficients from brokenstick Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brokenstick'
coef(
  object,
  complete = TRUE,
  ...,
  hide = c("right", "left", "boundary", "internal", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.brokenstick_+3A_object">object</code></td>
<td>
<p>A <code>brokenstick</code> object</p>
</td></tr>
<tr><td><code id="coef.brokenstick_+3A_complete">complete</code></td>
<td>
<p>for the default (used for <code>lm</code>, etc) and
<code>aov</code> methods:
logical indicating if the full coefficient vector should be returned
also in case of an over-determined system where some coefficients
will be set to <code><a href="base.html#topic+NA">NA</a></code>, see also <code><a href="stats.html#topic+alias">alias</a></code>.  Note
that the default <em>differs</em> for <code><a href="stats.html#topic+lm">lm</a>()</code> and
<code><a href="stats.html#topic+aov">aov</a>()</code> results.</p>
</td></tr>
<tr><td><code id="coef.brokenstick_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
<tr><td><code id="coef.brokenstick_+3A_hide">hide</code></td>
<td>
<p>Should output for boundary knots be hidden in the print,
summary and plot functions? Can be <code>"right"</code>, <code>"left"</code>, <code>"boundary"</code>,
<code>"internal"</code> or <code>"none"</code>.
If not specified, it is read from <code>object$hide</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='control_kr'>Set controls for Kasim-Raudenbush sampler</h2><span id='topic+control_kr'></span>

<h3>Description</h3>

<p>Set controls for Kasim-Raudenbush sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_kr(
  niter = 200L,
  nimp = 0L,
  start = 101L,
  thin = 1L,
  seed = NA_integer_,
  cormodel = c("none", "argyle", "cole"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_kr_+3A_niter">niter</code></td>
<td>
<p>Integer. Number of samples from posterior. Default:  <code>200</code>.</p>
</td></tr>
<tr><td><code id="control_kr_+3A_nimp">nimp</code></td>
<td>
<p>Integer. Number of multiple imputations. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="control_kr_+3A_start">start</code></td>
<td>
<p>Integer. The iteration number of the first observation</p>
</td></tr>
<tr><td><code id="control_kr_+3A_thin">thin</code></td>
<td>
<p>Integer. The thinning interval between consecutive observations</p>
</td></tr>
<tr><td><code id="control_kr_+3A_seed">seed</code></td>
<td>
<p>Integer. Seed number for <code><a href="base.html#topic+Random">base::set.seed()</a></code>. Use <code>NA</code> to
bypass seed setting.</p>
</td></tr>
<tr><td><code id="control_kr_+3A_cormodel">cormodel</code></td>
<td>
<p>String indicating the correlation model:
<code>"none"</code> (default), <code>"argyle"</code> or <code>"cole"</code></p>
</td></tr>
<tr><td><code id="control_kr_+3A_...">...</code></td>
<td>
<p>Allow for dot parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with eight components. The function calculates parameters
<code>end</code> (the iteration number of the last iteration) and <code>thin_imp</code>
(thinning factor for multiple imputations) from the other inputs.
</p>

<hr>
<h2 id='EB'>Empirical Bayes predictor for random effects</h2><span id='topic+EB'></span>

<h3>Description</h3>

<p>This function can estimate random effect for a given set of
model estimates and new user data. The unit may be
new to the model. The methods implements the
EB estimate (also known as BLUP)
as described in Skrondral and Rabe-Hasketh, 2009, p. 683.
This function can also provide the broken stick estimate for a given level,
the sum of the global (fixed) and individual (random) effects.
The current implementation does not provide prediction errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EB(model, y, X, Z = X, BS = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EB_+3A_model">model</code></td>
<td>
<p>An object of class <code>brokenstick</code>.</p>
</td></tr>
<tr><td><code id="EB_+3A_y">y</code></td>
<td>
<p>A vector of new measurements for unit j, scaled in the same metric as the fitted model.</p>
</td></tr>
<tr><td><code id="EB_+3A_x">X</code></td>
<td>
<p>A <code>nj * p</code> matrix with fixed effects for unit j, typically produced by <code>bs()</code>.</p>
</td></tr>
<tr><td><code id="EB_+3A_z">Z</code></td>
<td>
<p>A <code>nj * q</code> matrix with random effects for unit j. The default sets <code>Z</code> equal to <code>X</code>.</p>
</td></tr>
<tr><td><code id="EB_+3A_bs">BS</code></td>
<td>
<p>A logical indicating whether broken stick estimates should be
returned (<code>BS = TRUE</code>) or the random effects (<code>BS = FALSE</code>).
The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length q containing the random effect or broken stick  estimates for unit j.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren 2023
</p>


<h3>References</h3>

<p>Skrondal, A., Rabe-Hesketh, S. (2009).
Prediction in multilevel generalized linear models.
J. R. Statist. Soc. A, 172, 3, 659-687.
</p>

<hr>
<h2 id='fit_200'>Broken stick model with nine lines for 200 children</h2><span id='topic+fit_200'></span>

<h3>Description</h3>

<p>Object <code>fit_200</code> has class <code>brokenstick</code> and
contains the fitted broken stick model, including the training data and
diagnostics.
</p>


<h3>Format</h3>

<p>An object of class <a href="#topic+brokenstick-class">brokenstick</a>, fitted by the
<code><a href="#topic+brokenstick">brokenstick()</a></code>.
</p>


<h3>Details</h3>

<p>The dataset was constructed as
</p>
<div class="sourceCode r"><pre>knots &lt;- round(c(0, 1, 2, 3, 6, 9, 12, 15, 18, 24)/12, 4)
fit_200 &lt;- brokenstick(hgt_z ~ age | id, data = smocc_200,
                       knots = knots, seed = 1)
</pre></div>

<hr>
<h2 id='fit_200_light'>Broken stick model with nine lines for 200 children (light)</h2><span id='topic+fit_200_light'></span>

<h3>Description</h3>

<p>Object <code>fit_200_light</code> has class <code>brokenstick</code> and stores the
the model settings and parameter estimates.
</p>


<h3>Format</h3>

<p>An object of class <a href="#topic+brokenstick-class">brokenstick</a>, fitted by the
<code><a href="#topic+brokenstick">brokenstick()</a></code>.
</p>


<h3>Details</h3>

<p>The datasets was constructed as
</p>
<div class="sourceCode r"><pre>knots &lt;- round(c(0, 1, 2, 3, 6, 9, 12, 15, 18, 24)/12, 4)
fit_200_light &lt;- brokenstick(hgt_z ~ age | id, data = smocc_200,
                       knots = knots,
                       light = TRUE, seed = 1)
</pre></div>

<hr>
<h2 id='fitted.brokenstick'>Calculate fitted values</h2><span id='topic+fitted.brokenstick'></span>

<h3>Description</h3>

<p>Calculate fitted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brokenstick'
fitted(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.brokenstick_+3A_object">object</code></td>
<td>
<p>A <code>brokenstick</code> object.</p>
</td></tr>
<tr><td><code id="fitted.brokenstick_+3A_newdata">newdata</code></td>
<td>
<p>Optional. A data frame in which to look for variables with
which to predict. The training data are used if omitted and
if <code>object$light</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitted.brokenstick_+3A_...">...</code></td>
<td>
<p>Additional arguments. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with predictions. The number of elements equals the
number of rows in <code>newdata</code>. If <code>newdata</code> is not specified, the function
looks for the training data in <code>object</code> as the element named <code>data</code>.
</p>


<h3>See Also</h3>

<p>Other brokenstick: 
<code><a href="#topic+residuals.brokenstick">residuals.brokenstick</a>()</code>
</p>

<hr>
<h2 id='get_knots'>Obtain the knots from a broken stick model</h2><span id='topic+get_knots'></span>

<h3>Description</h3>

<p>Obtain the knots from a broken stick model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_knots(
  object,
  hide = c("right", "left", "boundary", "internal", "none"),
  whatknots = "all",
  what = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_knots_+3A_object">object</code></td>
<td>
<p>An object of class <code>brokenstick</code></p>
</td></tr>
<tr><td><code id="get_knots_+3A_hide">hide</code></td>
<td>
<p>Should output for knots be hidden in get, print, summary and plot
functions? Can be <code>"left"</code>, <code>"right"</code>, <code>"boundary"</code>, <code>"internal"</code> or <code>"none"</code>.
The default is <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="get_knots_+3A_whatknots">whatknots</code></td>
<td>
<p>Deprecated. Use <code>hide</code> instead.</p>
</td></tr>
<tr><td><code id="get_knots_+3A_what">what</code></td>
<td>
<p>Deprecated. Use <code>hide</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with knot locations, either both, internal only or
boundary only, depending on <code>hide</code>.
The result is <code>NULL</code> if <code>object</code> does not
have proper class. Returns <code>numeric(0)</code> if
there are no internal knots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_knots(fit_200, hide = "bo")
</code></pre>

<hr>
<h2 id='get_omega'>Extract Variance and Correlation Components</h2><span id='topic+get_omega'></span>

<h3>Description</h3>

<p>Extracts variance-covariance or correlation matrix from a
<code>brokenstick</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_omega(
  x,
  hide = c("right", "left", "boundary", "internal", "none"),
  cor = FALSE,
  whatknots = "all",
  what = "cov"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_omega_+3A_x">x</code></td>
<td>
<p>Object of class <code>brokenstick</code></p>
</td></tr>
<tr><td><code id="get_omega_+3A_hide">hide</code></td>
<td>
<p>Should output for knots be hidden in get, print, summary and plot
functions? Can be <code>"left"</code>, <code>"right"</code>, <code>"boundary"</code>, <code>"internal"</code> or <code>"none"</code>.
The default is <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="get_omega_+3A_cor">cor</code></td>
<td>
<p>Logical. Should the function return the correlation matrix
instead of the covariance matrix? The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_omega_+3A_whatknots">whatknots</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="get_omega_+3A_what">what</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix, possibly with zero rows and columns if no names match
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- brokenstick(hgt_z ~ age | id, smocc_200[1:1000, ], knots = 0:2, seed = 1)
get_omega(f1, cor = TRUE, hide = "boundary")
</code></pre>

<hr>
<h2 id='get_r2'>Obtain proportion of explained variance from a broken stick model</h2><span id='topic+get_r2'></span>

<h3>Description</h3>

<p>Obtain proportion of explained variance from a broken stick model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_r2(object, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_r2_+3A_object">object</code></td>
<td>
<p>An object of class <code>brokenstick</code></p>
</td></tr>
<tr><td><code id="get_r2_+3A_newdata">newdata</code></td>
<td>
<p>Data on which <code>r.squared</code> must be calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Proportion of explained variance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_r2(fit_200)
get_r2(fit_200_light, newdata = smocc_200)
</code></pre>

<hr>
<h2 id='kr'>Kasim-Raudenbush sampler for two-level normal model</h2><span id='topic+kr'></span>

<h3>Description</h3>

<p>Simulates posterior distributions of parameters from a two-level
normal model with heterogeneous within-cluster variances
(Kasim and Raudenbush, 1998). Imputations can be drawn as an
extra step to the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kr(y, x, g, control = control_kr())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kr_+3A_y">y</code></td>
<td>
<p>Vector with outcome value</p>
</td></tr>
<tr><td><code id="kr_+3A_x">x</code></td>
<td>
<p>Matrix with predictor value</p>
</td></tr>
<tr><td><code id="kr_+3A_g">g</code></td>
<td>
<p>Vector with group values</p>
</td></tr>
<tr><td><code id="kr_+3A_control">control</code></td>
<td>
<p>A list created by <code><a href="#topic+control_kr">control_kr()</a></code> that sets algorithmic options
of the sampler and correlation model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The speed of the Kasim-Raudenbush sampler is almost
independent of the number of random effect, and foremost depends
on the total number of iterations.
</p>
<p>The defaults <code>start = 100</code>, <code>n = 200</code> and <code>thin = 1</code> provide 200 parameter
draws with a <em>reasonable</em> approximation to the variance-covariance
matrix of the random effects.
</p>
<p>For a closer approximations with 200 draws set <code>control = control_kr(thin = 10)</code>
(<em>better</em>) or <code>thin = 20</code> (<em>best</em>), at the expense of a linear increase in calculation
time. Drawing fewer than 50 observations is not recommended, and such
results are best treated as <em>indicative</em>.
</p>
<p>It is possible to draw multiple imputations by setting the <code>nimp</code> parameter.
For example, to draw five imputations for each missing outcome specify
<code>control = control_kr(nimp = 5)</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>kr</code>, basically a list with components:
</p>
<div class="sourceCode"><pre>* `beta`  Fixed effects
* `omega` Variance-covariance of random effects
* `sigma2_j` Residual variance per group
* `sigma2` Average residual variance
* `sample` Descriptive statistics about the data
* `imp`   Numeric matrix with `nimp` multiple imputations.
* `mod`   A list of objects of class [coda::mcmc()]
</pre></div>
<p>The number of rows in <code>imp</code> is equal to the number of missing values in the
outcome vector <code>y</code>. The number of columns equals <code>nimp</code>.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren, based on <code><a href="mice.html#topic+mice.impute.2l.norm">mice::mice.impute.2l.norm()</a></code>
</p>


<h3>References</h3>

<p>Kasim RM, Raudenbush SW. (1998). Application of Gibbs sampling to nested
variance components models with heterogeneous within-group variance. Journal
of Educational and Behavioral Statistics, 23(2), 93&ndash;116.
</p>

<hr>
<h2 id='make_basis'>Create linear splines basis</h2><span id='topic+make_basis'></span>

<h3>Description</h3>

<p>This function creates the basis function of a second-order (linear) splines
at a user-specific set of break points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_basis(
  x,
  xname = "x",
  internal = NULL,
  boundary = range(x),
  degree = 1L,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_basis_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="make_basis_+3A_xname">xname</code></td>
<td>
<p>predictor name. Default is <code>"x"</code></p>
</td></tr>
<tr><td><code id="make_basis_+3A_internal">internal</code></td>
<td>
<p>a vector of internal knots, excluding boundary knots</p>
</td></tr>
<tr><td><code id="make_basis_+3A_boundary">boundary</code></td>
<td>
<p>vector of external knots</p>
</td></tr>
<tr><td><code id="make_basis_+3A_degree">degree</code></td>
<td>
<p>the degree of the spline. The broken stick model
requires linear splines, so the default is <code>degree = 1</code>.
Setting <code>degree = 0</code> yields (crisp) dummy coding, and one
column less than for <code>degree = 1</code>.</p>
</td></tr>
<tr><td><code id="make_basis_+3A_warn">warn</code></td>
<td>
<p>a logical indicating whether warnings from <code>splines::bs()</code>
should be given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>length(x)</code> rows and <code>length(breaks)</code>
columns, with some extra attributes described by <code>bs()</code>.
</p>


<h3>Note</h3>

<p>Before version 0.54, it was standard practice that the <code>knots</code>
array always included <code>boundary[1L]</code>.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren 2023
</p>

<hr>
<h2 id='parse_formula'>Parse formula for brokenstick model</h2><span id='topic+parse_formula'></span>

<h3>Description</h3>

<p>A bare bones formula parser to extract variables names from
formulas of <code>y ~ x | g</code>. It return the name of
the first variable mentioned in each formula component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_formula(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_formula_+3A_f">f</code></td>
<td>
<p>formula object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with elements <code>x</code>, <code>y</code> and <code>g</code>.
Each element has length 1.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren 2023
</p>

<hr>
<h2 id='plot_trajectory'>Plot observed and fitted trajectories from fitted brokenstick model</h2><span id='topic+plot_trajectory'></span>

<h3>Description</h3>

<p>Plot observed and fitted trajectories from fitted brokenstick model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trajectory(
  x,
  newdata = NULL,
  hide = c("right", "left", "boundary", "internal", "none"),
  .x = NULL,
  group = NULL,
  color_y = c(grDevices::hcl(240, 100, 40, 0.7), grDevices::hcl(240, 100, 40, 0.8)),
  size_y = 2,
  linetype_y = 1,
  shape_y = 19,
  color_yhat = c(grDevices::hcl(0, 100, 40, 0.7), grDevices::hcl(0, 100, 40, 0.8)),
  size_yhat = 2,
  linetype_yhat = 1,
  shape_yhat = 19,
  color_imp = c("grey80", "grey80"),
  size_imp = 2,
  ncol = 3L,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  show = c(TRUE, TRUE, FALSE),
  n_plot = 3L,
  scales = "fixed",
  theme = ggplot2::theme_light(),
  whatknots = "droplast",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_trajectory_+3A_x">x</code></td>
<td>
<p>An object of class <code>brokenstick</code>.</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code></p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_hide">hide</code></td>
<td>
<p>Character indicating which knots should</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_.x">.x</code></td>
<td>
<p>The <code>x</code> argument of the <code><a href="#topic+predict.brokenstick">predict.brokenstick()</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_group">group</code></td>
<td>
<p>A vector with group identifications</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_color_y">color_y</code></td>
<td>
<p>A character vector with two elements specifying the symbol and line color of the measured data points</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_size_y">size_y</code></td>
<td>
<p>Dot size of measured data points</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_linetype_y">linetype_y</code></td>
<td>
<p>Line type of data points</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_shape_y">shape_y</code></td>
<td>
<p>Symbol for data points</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_color_yhat">color_yhat</code></td>
<td>
<p>A character vector with two elements specifying the symbol and line color of the predicted data points</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_size_yhat">size_yhat</code></td>
<td>
<p>Dot size of predicted data points</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_linetype_yhat">linetype_yhat</code></td>
<td>
<p>Line type of predicted data</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_shape_yhat">shape_yhat</code></td>
<td>
<p>Symbol for predicted data</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_color_imp">color_imp</code></td>
<td>
<p>A character vector with two elements specifying the symbol and line color of the imputed data</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_size_imp">size_imp</code></td>
<td>
<p>Dot size of imputed data</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns in plot</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_xlab">xlab</code></td>
<td>
<p>The label of the x-axis</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_ylab">ylab</code></td>
<td>
<p>The label of the y-axis</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_xlim">xlim</code></td>
<td>
<p>Vector of length 2 with range of x-axis</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_ylim">ylim</code></td>
<td>
<p>Vector of length 2 with range of y-axis</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_show">show</code></td>
<td>
<p>A logical vector of length 3. Element 1 specifies
whether the observed data are plotted, element 2 specifies
whether the broken stick are plotted, element 3 specifies
whether imputations are plotted. The default is
<code>c(TRUE, TRUE, FALSE)</code>.</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_n_plot">n_plot</code></td>
<td>
<p>A integer indicating the number of individual plots.
The default is 3, which plots the trajectories of the first three
groups. The <code>n_plot</code> is a safety measure to prevent unintended
plots of the entire data set.</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_scales">scales</code></td>
<td>
<p>Axis scaling, e.g. <code>"fixed"</code>, <code>"free"</code>, and so on</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_theme">theme</code></td>
<td>
<p>Plotting theme</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_whatknots">whatknots</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="plot_trajectory_+3A_...">...</code></td>
<td>
<p>Extra arguments passed down to <code><a href="#topic+predict.brokenstick">predict.brokenstick()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ggplot</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.brokenstick">plot.brokenstick</a>
</p>

<hr>
<h2 id='plot.brokenstick'>Plot observed and fitted trajectories by group</h2><span id='topic+plot.brokenstick'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for a <code>brokenstick</code> object plots the observed and
fitted trajectories of one or more groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brokenstick'
plot(x, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.brokenstick_+3A_x">x</code></td>
<td>
<p>An object of class <code>brokenstick</code>.</p>
</td></tr>
<tr><td><code id="plot.brokenstick_+3A_newdata">newdata</code></td>
<td>
<p>Optional. A data frame in which to look for variables with
which to predict. The training data are used if omitted and
if <code>object$light</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.brokenstick_+3A_...">...</code></td>
<td>
<p>Extra arguments passed down to <code><a href="#topic+predict.brokenstick">predict.brokenstick()</a></code>
and <code><a href="#topic+plot_trajectory">plot_trajectory()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>plot(fit)</code> will plot the observed and fitted data for the
first three groups in the data. The default setting drops the fitted value
at the right boundary knot from the display.
</p>


<h3>Value</h3>

<p>An object of class <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a>.
</p>


<h3>Author(s)</h3>

<p>Stef van Buuren 2023
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.brokenstick">predict.brokenstick</a>, <a href="#topic+plot_trajectory">plot_trajectory</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# fit model on raw hgt with knots at 0, 1, 2 and 3 years
fit1 &lt;- brokenstick(hgt ~ age | id, smocc_200, knots = 0:2)
gp &lt;- c(10001, 10005, 10022)
plot(fit1, group = gp, xlab = "Age (years)", ylab = "Length (cm)")

# fit model on standard deviation score
fit2 &lt;- brokenstick(hgt_z ~ age | id, smocc_200, knots = 0:2)
plot(fit2, group = gp, xlab = "Age (years)", ylab = "Length (SDS)")

# built-in model with 11 knots
plot(fit_200, group = gp, xlab = "Age (years)", ylab = "Length (SDS)")

# black and white version
plot(fit_200, group = gp, xlab = "Age (years)", ylab = "Length (SDS)",
    color_y = rep("black", 2), shape_y = 1, linetype_y = 3,
    color_yhat = rep("grey20", 2), shape_yhat = NA)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.brokenstick'>Predict from a <code>brokenstick</code> model</h2><span id='topic+predict.brokenstick'></span>

<h3>Description</h3>

<p>The predictions from a broken stick model coincide with the
group-conditional means of the random effects. This function takes
an object of class <code>brokenstick</code> and returns predictions
in one of several formats. The user can calculate predictions
for new persons, i.e., for persons who are not part of
the fitted model, through the <code>x</code> and <code>y</code> arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brokenstick'
predict(
  object,
  newdata = NULL,
  ...,
  x = NULL,
  y = NULL,
  group = NULL,
  hide = c("right", "left", "boundary", "internal", "none"),
  shape = c("long", "wide", "vector"),
  include_data = TRUE,
  strip_data = TRUE,
  whatknots = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.brokenstick_+3A_object">object</code></td>
<td>
<p>A <code>brokenstick</code> object.</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_newdata">newdata</code></td>
<td>
<p>Optional. A data frame in which to look for variables with
which to predict. The training data are used if omitted and
if <code>object$light</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_...">...</code></td>
<td>
<p>Not used, but required for extensibility.</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_x">x</code></td>
<td>
<p>Optional. A numeric vector with values of the predictor. It could
also be the special keyword <code>x = "knots"</code> replaces <code>x</code> by the
positions of the knots.</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_y">y</code></td>
<td>
<p>Optional. A numeric vector with measurements.</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_group">group</code></td>
<td>
<p>A vector with group identifications</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_hide">hide</code></td>
<td>
<p>Should output for knots be hidden in get, print, summary and plot
functions? Can be <code>"left"</code>, <code>"right"</code>, <code>"boundary"</code>, <code>"internal"</code> or <code>"none"</code>.
The default is <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_shape">shape</code></td>
<td>
<p>A string: <code>"long"</code> (default), <code>"wide"</code> or <code>"vector"</code>
specifying the shape of the return value. Note that use of <code>"wide"</code>
with many unique values in <code>x</code> creates an unwieldy, large
and sparse matrix.</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_include_data">include_data</code></td>
<td>
<p>A logical indicating whether the observed data
from <code>object$data</code> and <code>newdata</code> should be included into the
return value. The default is <code>TRUE</code>. Use <code>include_data = FALSE</code> to
keep only added data points (e.g. knots or observed data specified
by <code>x</code> and <code>y</code>). Setting <code>include_data = FALSE</code> is useful in
combination with <code>shape = "wide"</code> to avoid the warning
<code style="white-space: pre;">&#8288;Values from '.pred' are not uniquely identified.&#8288;</code> For convenience,
in the special case <code>x = "knots"</code> the function overwrites
<code>include_data</code> to <code>FALSE</code> to evade observed ages to show up in the
wide matrix.</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_strip_data">strip_data</code></td>
<td>
<p>Deprecated. Use <code>include_data</code> instead.</p>
</td></tr>
<tr><td><code id="predict.brokenstick_+3A_whatknots">whatknots</code></td>
<td>
<p>Deprecated. Use <code>hide</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>predict()</code> calculates predictions for every row in
<code>newdata</code>. If the user specifies no <code>newdata</code> argument, then the
function sets <code>newdata</code> equal to the training data (<code>object$data</code>
if <code>object$light</code> is <code>FALSE</code>). For a light object without a
<code>newdata</code> argument, the function throws the warning
&quot;Argument 'newdata' is required for a light brokenstick object.&quot; and
returns <code>NULL</code>.
</p>
<p>It is possible to tailor the behaviour of <code>predict()</code> through the
<code>x</code>, <code>y</code> and <code>group</code> arguments. What exactly happens depends on
which of these arguments is specified:
</p>

<ol>
<li><p> If the user specifies <code>x</code>, but no <code>y</code> and <code>group</code>, the function
returns - for every group in <code>newdata</code> - predictions at the
specified <code>x</code> values. This method will use the data from <code>newdata</code>.
</p>
</li>
<li><p> If the user specifies <code>x</code> and <code>y</code> but no <code>group</code>, the function
forms a hypothetical new group with the <code>x</code> and <code>y</code> values. This
method uses no information from <code>newdata</code>, and also works for
a light <code>brokenstick</code> object.
</p>
</li>
<li><p> If the user specifies <code>group</code>, but no <code>x</code> or <code>y</code>, the function
searches for the relevant data in <code>newdata</code> and limits its
predictions to those groups. This is useful if the user needs
a prediction for only one or a few groups. This does not work for
a light <code>brokenstick</code> object.
</p>
</li>
<li><p> If the user specifies <code>x</code> and <code>group</code>, but no <code>y</code>, the function
will create new values for <code>x</code> in each <code>group</code>, search for the relevant
data in <code>newdata</code> and provide predictions at values of <code>x</code> in those
groups.
</p>
</li>
<li><p> If the user specifies <code>x</code>, <code>y</code> and <code>group</code>, the function
assumes that these vectors contain additional data on top on what is
already available in <code>newdata</code>. The lengths of <code>x</code>,
<code>y</code> and <code>group</code> must match.
For a light <code>brokenstick</code> object, case effectively becomes
case 6. See below.
</p>
</li>
<li><p> As case 5, but now without <code>newdata</code> available. All data are
specified through <code>x</code>, <code>y</code> and <code>group</code> and form a data frame.
Matching to <code>newdata</code> is attempted, but as long as group id's are
different from the training sample effectively new cases will be
made.
</p>
</li></ol>



<h3>Value</h3>

<p>If <code>shape == "long"</code> a long <code>data.frame</code> of predictions. If <code>x</code>, <code>y</code> and <code>group</code>
are not specified, the number of rows in the data frame is guaranteed to
be the same as the number of rows in <code>newdata</code>.
</p>
<p>If <code>shape == "wide"</code> a wide <code>data.frame</code> of predictions, one record per group. Note
that this format could be inefficient if observations times vary between
subjects.
</p>
<p>If <code>shape == "vector"</code> a vector of predicted values, of all x-values and groups.
</p>
<p>If the function finds no data, it throws a warnings and returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")

# -- Data

train &lt;- smocc_200[1:1198, ]
test &lt;- smocc_200[1199:1940, ]
## Not run: 
# -- Fit model

fit &lt;- brokenstick(hgt_z ~ age | id, data = train, knots = 0:2, seed = 1)
fit_light &lt;- brokenstick(hgt_z ~ age | id,
  data = train, knots = 0:2,
  light = TRUE, seed = 1
)

# -- Predict, standard cases

# Use train data, return column with predictions
pred &lt;- predict(fit)
identical(nrow(train), nrow(pred))

# Predict without newdata, not possible for light object
predict(fit_light)

# Use test data
pred &lt;- predict(fit, newdata = test)
identical(nrow(test), nrow(pred))

# Predict, same but using newdata with the light object
pred_light &lt;- predict(fit_light, newdata = test)
identical(pred, pred_light)


# -- Predict, special cases


# -- Case 1: x, -y, -group

# Case 1: x as "knots", standard estimates, train sample (n = 124)
z &lt;- predict(fit, x = "knots", shape = "wide")
head(z, 3)

# Case 1: x as values, linearly interpolated, train sample (n = 124)
z &lt;- predict(fit, x = c(0.5, 1, 1.5), shape = "wide", include_data = FALSE)
head(z, 3)

# Case 1: x as values, linearly interpolated, test sample (n = 76)
z &lt;- predict(fit, test, x = c(0.5, 1, 1.5), shape = "wide", include_data = FALSE)
head(z, 3)

# Case 1: x, not possible for light object
z &lt;- predict(fit_light, x = "knots")

# -- Case 2: x, y, -group

# Case 2: form one new group with id = 0
predict(fit, x = "knots", y = c(1, 1, 0.5, 0), shape = "wide")

# Case 2: works also for a light object
predict(fit_light, x = "knots", y = c(1, 1, 0.5, 0), shape = "wide")


# -- Case 3: -x, -y, group

# Case 3: Predict at observed age for subset of groups, training sample
pred &lt;- predict(fit, group = c(10001, 10005, 10022))
head(pred, 3)

# Case 3: Of course, we cannot do this for light objects
pred_light &lt;- predict(fit_light, group = c(10001, 10005, 10022))

# Case 3: We can use another sample. Note there is no child 999
pred &lt;- predict(fit, test, group = c(11045, 11120, 999))
tail(pred, 3)

# Case 3: Works also for a light object
pred_light &lt;- predict(fit_light, test, group = c(11045, 11120, 999))
identical(pred, pred_light)

# -- Case 4: x, -y, group

# Case 4: Predict at specified x, only in selected groups, train sample
pred &lt;- predict(fit, x = c(0.5, 1, 1.25), group = c(10001, 10005, 10022),
        include_data = FALSE)
pred

# Case 4: Same, but include observed data and sort
pred_all &lt;- predict(fit,
  x = c(0.5, 1, 1.25), group = c(10001, 10005, 10022)) %&gt;%
  dplyr::arrange(id, age)

# Case 4: Applies also to test sample
pred &lt;- predict(fit, test, x = c(0.5, 1, 1.25), group = c(11045, 11120, 999),
 include_data = FALSE)
pred

# Case 4: Works also with light object
pred_light &lt;- predict(fit_light, test, x = c(0.5, 1, 1.25),
  group = c(11045, 11120, 999), include_data = FALSE)
identical(pred_light, pred)

# -- Case 5: x, y, group

# Case 5: Add new data to training sample, and refreshes broken stick
# estimate at age x.
# Note that novel child (not in train) 999 has one data point
predict(fit,
  x = c(0.9, 0.9, 0.9), y = c(1, 1, 1),
  group = c(10001, 10005, 999), include_data = FALSE)

# Case 5: Same, but now for test sample. Novel child 899 has two data points
predict(fit, test,
  x = c(0.5, 0.9, 0.6, 0.9),
  y = c(0, 0.5, 0.5, 0.6), group = c(11045, 11120, 899, 899),
  include_data = FALSE)

# Case 5: Also works for light object
predict(fit_light, test,
  x = c(0.5, 0.9, 0.6, 0.9),
  y = c(0, 0.5, 0.5, 0.6), group = c(11045, 11120, 899, 899),
  include_data = FALSE)


# -- Case 6: As Case 5, but without previous data

# Case 6: Same call as last, but now without newdata = test
# All children are de facto novel as they do not occur in the training
# or test samples.
# Note: Predictions for 11045 and 11120 differ from prediction in Case 5.
predict(fit,
  x = c(0.5, 0.9, 0.6, 0.9),
  y = c(0, 0.5, 0.5, 0.6), group = c(11045, 11120, 899, 899))

# This also work for the light brokenstick object
predict(fit_light,
  x = c(0.5, 0.9, 0.6, 0.9),
  y = c(0, 0.5, 0.5, 0.6), group = c(11045, 11120, 899, 899))

## End(Not run)
</code></pre>

<hr>
<h2 id='print.brokenstick'>Print brokenstick object</h2><span id='topic+print.brokenstick'></span>

<h3>Description</h3>

<p>Print brokenstick object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brokenstick'
print(
  x,
  digits = getOption("digits"),
  ...,
  hide = c("right", "left", "boundary", "internal", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.brokenstick_+3A_x">x</code></td>
<td>
<p>A <code>brokenstick</code> object</p>
</td></tr>
<tr><td><code id="print.brokenstick_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.brokenstick_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.brokenstick_+3A_hide">hide</code></td>
<td>
<p>Should output for boundary knots be hidden in the print,
summary and plot functions? Can be  <code>"right"</code>, <code>"left"</code>,<code>"boundary"</code>,
<code>"internal"</code> or <code>"none"</code>.
If not specified, it is read from the field <code>x$hide</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='residuals.brokenstick'>Extract residuals from brokenstick model</h2><span id='topic+residuals.brokenstick'></span>

<h3>Description</h3>

<p>Extract residuals from brokenstick model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brokenstick'
residuals(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.brokenstick_+3A_object">object</code></td>
<td>
<p>A <code>brokenstick</code> object.</p>
</td></tr>
<tr><td><code id="residuals.brokenstick_+3A_newdata">newdata</code></td>
<td>
<p>Optional. A data frame in which to look for variables with
which to predict. The training data are used if omitted and
if <code>object$light</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="residuals.brokenstick_+3A_...">...</code></td>
<td>
<p>Additional arguments. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with residuals The number of elements equals the
number of rows in <code>newdata</code>. If <code>newdata</code> is not specified, the function
looks for the training data in <code>object</code> as the element named <code>data</code>.
</p>


<h3>See Also</h3>

<p>Other brokenstick: 
<code><a href="#topic+fitted.brokenstick">fitted.brokenstick</a>()</code>
</p>

<hr>
<h2 id='set_control'>Set controls to steer calculations</h2><span id='topic+set_control'></span>

<h3>Description</h3>

<p>Set controls to steer calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_control(
  method = c("kr", "lmer"),
  kr = control_kr(...),
  lmer = lmerControl(check.nobs.vs.nRE = "warning"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_control_+3A_method">method</code></td>
<td>
<p>String indicating estimation method: <code>"kr"</code> or <code>"lmer"</code></p>
</td></tr>
<tr><td><code id="set_control_+3A_kr">kr</code></td>
<td>
<p>A list generated by <a href="#topic+control_kr">control_kr</a>.</p>
</td></tr>
<tr><td><code id="set_control_+3A_lmer">lmer</code></td>
<td>
<p>A list generated by <a href="lme4.html#topic+lmerControl">lme4::lmerControl</a>. The default
is set to <code>lmerControl(check.nobs.vs.nRE = "warning")</code>, which turns
fatal errors with respect the number of parameters into warnings. Use
<code>lmerControl(check.nobs.vs.nRE = "ignore")</code> to silence <code>lmer()</code>.</p>
</td></tr>
<tr><td><code id="set_control_+3A_...">...</code></td>
<td>
<p>Forwards arguments to <code><a href="#topic+control_kr">control_kr()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For method <code>"kr"</code>, a list returned by <code><a href="#topic+control_kr">control_kr()</a></code>.
For method <code>"lmer"</code>, an object of class <code>lmerControl</code>.
For other methods, <code>set_control()</code> returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># defaults
control &lt;- set_control()
control
</code></pre>

<hr>
<h2 id='smocc_200'>Infant growth of 0-2 years, SMOCC data extract</h2><span id='topic+smocc_200'></span>

<h3>Description</h3>

<p>Longitudinal height and weight measurements during ages 0-2 years for a
representative sample of 1933 Dutch children born in 1988-1989. The dataset
<code>smocc_200</code> is sample of size 200 from the full data.
</p>


<h3>Format</h3>

<p>A tibble with 1942 rows and 7 columns:
</p>

<dl>
<dt>id</dt><dd><p>ID, unique <code>id</code> of each child (numeric)</p>
</dd>
<dt>age</dt><dd><p>Decimal age, 0-2.68 years (numeric)</p>
</dd>
<dt>sex</dt><dd><p>Sex, <code>"male"</code> or <code>"female"</code> (character)</p>
</dd>
<dt>ga</dt><dd><p>Gestational age, completed weeks (numeric)</p>
</dd>
<dt>bw</dt><dd><p>Birth weight in grammes (numeric)</p>
</dd>
<dt>hgt</dt><dd><p>Height measurement in cm (numeric)</p>
</dd>
<dt>hgt_z</dt><dd><p>Height in SDS relative Fourth Dutch Growth Study 1997 (numeric)</p>
</dd></dl>



<h3>Source</h3>

<p>Herngreen WP, van Buuren S, van Wieringen JC, Reerink JD,
Verloove-Vanhorick SP &amp; Ruys JH (1994). Growth in length and weight from
birth to 2 years of a representative sample of Netherlands children (born
in 1988-89) related to socio-economic status and other background
characteristics. <em>Annals of Human Biology</em>, <b>21</b>, 449-463.
</p>

<hr>
<h2 id='summary.brokenstick'>Create summary of brokenstick object</h2><span id='topic+summary.brokenstick'></span>

<h3>Description</h3>

<p>Create summary of brokenstick object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brokenstick'
summary(
  object,
  ...,
  cor = FALSE,
  lower = TRUE,
  hide = c("right", "left", "boundary", "internal", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.brokenstick_+3A_object">object</code></td>
<td>
<p>A <code>brokenstick</code> object</p>
</td></tr>
<tr><td><code id="summary.brokenstick_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
<tr><td><code id="summary.brokenstick_+3A_cor">cor</code></td>
<td>
<p>Logical. Should the function return the correlation matrix
instead of the covariance matrix? The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.brokenstick_+3A_lower">lower</code></td>
<td>
<p>Logical. Print lower triangle of correlation/covariance
matrix?</p>
</td></tr>
<tr><td><code id="summary.brokenstick_+3A_hide">hide</code></td>
<td>
<p>Should output for boundary knots be hidden in the print,
summary and plot functions? Can be <code>"left"</code>, <code>"right"</code>, <code>"boundary"</code>,
<code>"internal"</code> or <code>"none"</code>.
If not specified, it is read from the field <code>object$hide</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='weightloss'>Weight loss self-measurement data</h2><span id='topic+weightloss'></span>

<h3>Description</h3>

<p>Longitudinal weight measurements from 12 individuals with 63 daily
measurement under three conditions.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> with 695 rows and 6 columns:
</p>

<dl>
<dt>subject</dt><dd><p>ID, consecutive person number 1-12 (integer)</p>
</dd>
<dt>day</dt><dd><p>Measurement day, 0-62 (integer)</p>
</dd>
<dt>sex</dt><dd><p>Sex, 1 = male, 0 = female (integer)</p>
</dd>
<dt>week</dt><dd><p>Week number, 1-9 (integer)</p>
</dd>
<dt>condition</dt><dd><p>Condition (control, diet, activity) (factor)</p>
</dd>
<dt>body_weight</dt><dd><p>Body weight in kg (numeric)</p>
</dd>
</dl>



<h3>Note</h3>

<p>Constructed from file <code>pone.0232680.s001.csv</code>. We renumbered <code>subject</code>
to consecutive integers 1-2 (as in the paper), corrected an error in the
<code>condition</code> variable for subjects 4 and 12 to match the paper's Figure 4,
and filtered the records to the ones woth an observed <code>body_weight</code> variable.
</p>


<h3>Source</h3>

<p>Krone T, Boessen R, Bijlsma S, van Stokkum R, Clabbers NDS, Pasman WJ (2020).
The possibilities of the use of N-of-1 and do-it-yourself trials in nutritional research.
<em>PloS ONE</em>, <b>15</b>, 5, e0232680.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
