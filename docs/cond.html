<!DOCTYPE html><html><head><title>Help for package cond</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cond}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aids'><p>AIDS Symptoms and AZT Use Data</p></a></li>
<li><a href='#airway'><p>Airway Data</p></a></li>
<li><a href='#babies'><p>Crying Babies Data</p></a></li>
<li><a href='#cond'>
<p>Approximate Conditional Inference - Generic Function</p></a></li>
<li><a href='#cond-package'>
<p>Approximate conditional inference for logistic and loglinear</p>
models</a></li>
<li><a href='#cond.glm'>
<p>Approximate Conditional Inference for Logistic and Loglinear Models</p></a></li>
<li><a href='#cond.object'>
<p>Approximate Conditional Inference Object</p></a></li>
<li><a href='#dormicum'><p>Dormicum Data</p></a></li>
<li><a href='#family.cond'>
<p>Use family() on a &ldquo;cond&rdquo; object</p></a></li>
<li><a href='#family.summary.cond'>
<p>Use family() on a &ldquo;summary.cond&rdquo; object</p></a></li>
<li><a href='#fraudulent'><p>Fraudulent Automobile Insurance Claims Data</p></a></li>
<li><a href='#fungal'><p>Fungal Infections Treatment Data</p></a></li>
<li><a href='#plot.cond'>
<p>Generate Plots for an Approximate Conditional Inference Object</p></a></li>
<li><a href='#print.cond'>
<p>Use print() on a &ldquo;cond&rdquo; object</p></a></li>
<li><a href='#print.summary.cond'>
<p>Use print() on a &ldquo;summary.cond&rdquo; object</p></a></li>
<li><a href='#rabbits'><p>Rabbits Data</p></a></li>
<li><a href='#summary.cond'>
<p>Summary Method for Objects of Class &ldquo;cond&rdquo;</p></a></li>
<li><a href='#urine'><p>Urine Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2-3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2014-06-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximate Conditional Inference for Logistic and Loglinear
Models</td>
</tr>
<tr>
<td>Author:</td>
<td>S original by Alessandra R. Brazzale &lt;alessandra.brazzale@unipd.it&gt;.
  R port by Alessandra R. Brazzale &lt;alessandra.brazzale@unipd.it&gt;, following 
  earlier work by Douglas Bates.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessandra R. Brazzale &lt;alessandra.brazzale@unipd.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), statmod, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, csampling, marg, nlreg</td>
</tr>
<tr>
<td>Description:</td>
<td>Higher order likelihood-based inference for logistic and 
  loglinear models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENCE [expanded from: GPL (&ge; 2) | file LICENCE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>, <a href="http://statwww.epfl.ch/AA/">http://statwww.epfl.ch/AA/</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-16 14:54:21 UTC; hornik</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-16 15:01:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='aids'>AIDS Symptoms and AZT Use Data</h2><span id='topic+aids'></span>

<h3>Description</h3>

<p>The <code>aids</code> data frame has 4 rows and 4 columns.
</p>
<p>On February 15, 1991, the <em> New York Times</em> published the
results of a study on the presence of AIDS symptoms and AZT use.
The data were cross-classified according to the race of the
patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aids)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>yes</code></dt><dd>
<p>the number of patients with AIDS symptoms;
</p>
</dd>
<dt><code>no</code></dt><dd>
<p>the number of patients without AIDS symptoms;
</p>
</dd>
<dt><code>azt</code></dt><dd>
<p>an indicator variable for AZT use;
</p>
</dd>
<dt><code>race</code></dt><dd>
<p>an indicator variable for the race (<code>w</code>=white, <code>b</code>=black).
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were obtained from the <em>New York Times</em> (2/15/91).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aids)
summary(aids)
</code></pre>

<hr>
<h2 id='airway'>Airway Data</h2><span id='topic+airway'></span>

<h3>Description</h3>

<p>The <code>airway</code> data frame has 35 rows and 6 columns.
</p>
<p>Study to compare two devices (tracheal tube and laryngeal mask) used
to secure airway in patients undergoing surgery.  The response
variable is the presence of a sore throat.  Further information on
age, sex, use of a lubricant, and duration of the surgery is
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(airway)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>response</code></dt><dd>
<p>an indicator variable for sore throat (1=yes, 0=no);
</p>
</dd>
<dt><code>type</code></dt><dd>
<p>the type of airway used (1=tracheal tube, 0=laryngeal mask);
</p>
</dd>
<dt><code>age</code></dt><dd>
<p>the age of the patient (in years);
</p>
</dd>
<dt><code>sex</code></dt><dd>
<p>an indicator variable for sex (1=male, 0=female);
</p>
</dd>
<dt><code>lubricant</code></dt><dd>
<p>an indicator variable for lubricant use (1=yes, 0=no);
</p>
</dd>
<dt><code>duration</code></dt><dd>
<p>the duration of the surgery (in minutes).
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were obtained from
</p>
<p>&ldquo;Binary Data&rdquo; by D. Collet in <em>Encyclopedia of 
Biostatistics</em> (1998).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(airway)
summary(airway)
par(mfrow=c(1,2))
plot(age ~ response, data = airway)
plot(duration ~ response, data = airway)
</code></pre>

<hr>
<h2 id='babies'>Crying Babies Data</h2><span id='topic+babies'></span>

<h3>Description</h3>

<p>The <code>babies</code> data frame has 36 rows and 4 columns.
</p>
<p>Matched pairs of binary observations concerning the crying of
babies.  The babies were observed on 18 days and on each day one
child was lulled.  Interest focuses on the treatment effect 
&ldquo;lulling&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(babies)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>r1</code></dt><dd>
<p>number of children not crying on one day;
</p>
</dd>
<dt><code>r2</code></dt><dd>
<p>number of children crying on one day;
</p>
</dd>
<dt><code>lull</code></dt><dd>
<p>indicator variable for the treatment;
</p>
</dd>
<dt><code>day</code></dt><dd>
<p>factor variable for the days.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were obtained from
</p>
<p>Cox, D. R. (1970) <em>Analysis of Binary Data</em> (page 61).  London:
Chapman \&amp; Hall.
</p>


<h3>References</h3>

<p>Davison, A. C. (1988) Approximate conditional inference in 
generalized linear models.  <em> J. R. Statist. Soc.</em> B, 
<b>50</b>, 445&ndash;461.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(babies)
coplot(r2/(r1+r2) ~ day | lull, data = babies)
##
babies.glm &lt;- glm(formula = cbind(r1, r2) ~ day + lull - 1, 
                  family = binomial, data = babies)
babies.cond &lt;- cond(object = babies.glm, offset = lullyes)
babies.cond
##
## If one wishes to avoid the generalized linear model fit:
babies.cond &lt;- cond.glm(formula = cbind(r1, r2) ~ day + lull - 1, 
                        family = binomial, data = babies, offset = lullyes)
babies.cond
</code></pre>

<hr>
<h2 id='cond'>
Approximate Conditional Inference - Generic Function
</h2><span id='topic+cond'></span>

<h3>Description</h3>

<p>Performs approximate conditional inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond(object, offset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_+3A_object">object</code></td>
<td>

<p>a fitted model object.  Families supported are binomial and 
Poisson with canonical link function (class <code>glm</code>), and 
regression-scale models (class <code>rsm</code>).  
</p>
</td></tr>
<tr><td><code id="cond_+3A_offset">offset</code></td>
<td>

<p>the covariate occurring in the model formula whose coefficient
represents the parameter of interest.  May be numerical or a 
two-level factor.  In case of a two-level factor, it must be 
coded by contrasts and not appear as two dummy variables in the 
model.  Can also be a call to a mathematical function (such as 
<code>exp</code>, <code>sin</code>, ...) or to a mathematical 
operator (<code>\^</code>, <code>/</code>, ...) applied to a 
numerical variable.  The call must always agree with the label 
used to identify the corresponding parameter in the fitted model 
object passed through the <code>object</code> argument.  Beware that 
the label includes the identity function <code>I()</code> if an 
arithmetic operator was used.  Other function types (e.g. 
<code>factor</code>) and interactions are not admitted.
</p>
</td></tr>
<tr><td><code id="cond_+3A_...">...</code></td>
<td>

<p>absorbs any additional arguments.  See <code><a href="#topic+cond.glm">cond.glm</a></code> 
and <code><a href="marg.html#topic+cond.rsm">cond.rsm</a></code> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is generic (see <code><a href="utils.html#topic+methods">methods</a></code>); method
functions can be written to handle specific classes of data.  
Classes which already have methods for this function include: 
<code>glm</code> and <code>rsm</code>. 
</p>


<h3>Value</h3>

<p>The returned value is an <em>approximate conditional inference</em>
object.  Classes already supported are <code>cond</code> and 
<code>marg</code> depending on whether the fitted model object passed 
through the <code>object</code> argument has class <code>glm</code> or 
<code>rsm</code>.  See <code><a href="#topic+cond.object">cond.object</a></code> or 
<code><a href="marg.html#topic+marg.object">marg.object</a></code> for more details.
</p>


<h3>References</h3>

<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss 
Federal Institute of Technology Lausanne.  Chapter 6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond.glm">cond.glm</a></code>, <code><a href="marg.html#topic+cond.rsm">cond.rsm</a></code>, 
<code><a href="#topic+cond.object">cond.object</a></code>, <code><a href="marg.html#topic+marg.object">marg.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Urine Data 
data(urine)
urine.glm &lt;- glm(r ~ gravity + ph + osmo + conduct + urea + log(calc), 
                 family = binomial, data = urine)
##
## function call as offset variable 
labels(coef(urine.glm))
cond(urine.glm, log(calc))
##
## large estimate of regression coefficient
urine.glm &lt;- glm(r ~ gravity + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
coef(urine.glm)
urine.glm &lt;- glm(r ~ I(gravity * 100) + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
coef(urine.glm)
urine.cond &lt;- cond(urine.glm, I(gravity * 100))
plot(urine.cond, which = 4)

## House Price Data
## Not run: 
data(houses)
houses.rsm &lt;- rsm(price ~ ., family = student(5), data = houses)
##
## parameter of interest: scale parameter
houses.marg &lt;- cond(houses.rsm, scale)
plot(houses.marg, which = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='cond-package'>
Approximate conditional inference for logistic and loglinear
models
</h2><span id='topic+cond-package'></span>

<h3>Description</h3>

<p>Higher order likelihood-based inference for logistic and
loglinear models
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> cond</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2009-10-03</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.6.0), statmod, survival</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> csampling, marg, nlreg</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> http://www.r-project.org, http://statwww.epfl.ch/AA/</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index:
</p>
<pre>
Functions:
=========
cond                    Approximate Conditional Inference - Generic
                        Function
cond.glm                Approximate Conditional Inference for Logistic
                        and Loglinear Models
cond.object             Approximate Conditional Inference Object
family.cond             Use family() on a "cond" object
family.summary.cond     Use family() on a "summary.cond" object
plot.cond               Generate Plots for an Approximate Conditional
                        Inference Object
print.summary.cond      Use print() on a "summary.cond" object
summary.cond            Summary Method for Objects of Class "cond"


Datasets:
========
aids                    AIDS Symptoms and AZT Use Data
airway                  Airway Data
babies                  Crying Babies Data
dormicum                Dormicum Data
fraudulent              Fraudulent Automobile Insurance Claims Data
fungal                  Fungal Infections Treatment Data
rabbits                 Rabbits Data
urine                   Urine Data
</pre>
<p>Further information is available in the following vignettes:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>Rnews-paper</code> </td><td style="text-align: left;"> hoa: An R Package Bundle for Higher Order Likelihood Inference (source, pdf)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>S original by Alessandra R. Brazzale &lt;alessandra.brazzale@unimore.it&gt;.
R port by Alessandra R. Brazzale &lt;alessandra.brazzale@unimore.it&gt;, following 
earlier work by Douglas Bates.
</p>
<p>Maintainer: Alessandra R. Brazzale &lt;alessandra.brazzale@unimore.it&gt;
</p>

<hr>
<h2 id='cond.glm'>
Approximate Conditional Inference for Logistic and Loglinear Models
</h2><span id='topic+cond.glm'></span>

<h3>Description</h3>

<p>Performs approximate conditional inference on a scalar parameter of 
interest in logistic and loglinear models.  The output is stored in
an object of class <code>cond</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
cond(object, offset, formula = NULL, family = NULL, 
         data = sys.frame(sys.parent()), pts = 20, 
         n = max(100, 2*pts), tms = 0.6, from = NULL, to = NULL, 
         control = glm.control(...), trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond.glm_+3A_object">object</code></td>
<td>

<p>a <code>glm</code> object.  Families supported are binomial and Poisson
with canonical link function.  
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_offset">offset</code></td>
<td>

<p>the covariate occurring in the model formula whose coefficient
represents the parameter of interest.  May be numerical or a 
two-level factor.  In case of a two-level factor, it must be 
coded by contrasts and not appear as two dummy variables in the 
model.  Can also be a call to a mathematical function (such as 
<code>exp</code>, <code>sin</code>, ...) or to  a mathematical operator 
(<code>^</code>, <code>/</code>, ...) applied to a numerical variable.
The call must always agree with the label used to identify the
corresponding parameter in the <code>glm</code> object passed through 
the <code>object</code> argument or defined by <code>formula</code> and 
<code>family</code>.  Beware that the label includes the identity 
function <code>I()</code> if an  arithmetic operator was used.  Other 
function types (e.g. <code>factor</code>) and interactions are not 
admitted.
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_formula">formula</code></td>
<td>

<p>a formula expression (only if no <code>glm</code> object is defined).  
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_family">family</code></td>
<td>

<p>a <code>family</code> object defining the variance function (only if no
<code>glm</code> object is defined).  Families supported are binomial 
and Poisson with canonical link function. 
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_data">data</code></td>
<td>

<p>an optional data frame in which to interpret the variables 
occurring in the formula (only if no <code>glm</code> object is 
defined).  
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_pts">pts</code></td>
<td>

<p>number of output points (minimum 10) that are calculated exactly.
The default is 20. 
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_n">n</code></td>
<td>

<p>approximate number of output points (minimum 50) produced by the
spline interpolation.  The default is the maximum between 100 and 
twice <code>pts</code>.
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_tms">tms</code></td>
<td>

<p>defines the range <abbr><span class="acronym">MLE</span></abbr> +/- <code>tms</code> * <abbr><span class="acronym">s.e.</span></abbr> 
where cubic spline interpolation is replaced by polynomial 
interpolation.  The default is 0.6.
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_from">from</code></td>
<td>

<p>starting value of the sequence that contains the values of the 
parameter of interest for which output points are calculated 
exactly.  The default is <abbr><span class="acronym">MLE</span></abbr> - 3.5 * <abbr><span class="acronym">s.e.</span></abbr>
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_to">to</code></td>
<td>

<p>ending value of the sequence that contains the values of the 
parameter of interest for which output points are calculated 
exactly.  The default is <abbr><span class="acronym">MLE</span></abbr> +  3.5 * <abbr><span class="acronym">s.e.</span></abbr>
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_control">control</code></td>
<td>

<p>a list of iteration and algorithmic constants that controls the 
<abbr><span class="acronym">GLM</span></abbr> fit.  See \ <code><a href="stats.html#topic+glm.control">glm.control</a></code> for their 
names and default values.  
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_trace">trace</code></td>
<td>

<p>if <code>TRUE</code>, iteration numbers will be printed.
</p>
</td></tr>
<tr><td><code id="cond.glm_+3A_...">...</code></td>
<td>

<p>additional arguments, such as <code>subset</code> etc., used by the 
<code>glm</code> fitting routine if the <code>glm</code> object 
is defined through <code>formula</code> and <code>family</code>.  See 
<code><a href="stats.html#topic+glm">glm</a></code> for their definition and use.  The
arguments <code>weights</code>, <code>offset</code> and <code>contrasts</code> are 
not admitted.  The returned value is an object of class <code>cond</code>; 
see <code><a href="#topic+cond.object">cond.object</a></code> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function <code>cond</code> for 
class <code>glm</code>.  It can be invoked by calling <code><a href="#topic+cond">cond</a></code> 
for an object of the appropriate class, or directly by calling 
<code>cond.glm</code> regardless of the class of the object.  
<code>cond.glm</code> has also to be used if the <code>glm</code> object is not
provided throught the <code>object</code> argument but specified by 
<code>formula</code> and <code>family</code>.
</p>
<p>The function <code>cond.glm</code> implements several small sample 
asymptotic methods for approximate conditional inference in 
logistic and loglinear models.  Approximations for both the 
conditional log likelihood function and conditional tail area 
probabilities are available (see <code><a href="#topic+cond.object">cond.object</a></code> for 
details).  Attention is restricted to a scalar parameter of 
interest.  The associated covariate can be either numerical or 
a two-level factor. 
</p>
<p>Approximate conditional inference is performed by either updating a
fitted generalized linear model or defining the model formula and 
family.  All approximations are calculated exactly for <code>pts</code> 
equally spaced points ranging from <code>from</code> to <code>to</code>.  A 
cubic spline interpolation is used to extend them over the whole 
interval of interest, except for the range of values defined by 
<abbr><span class="acronym">MLE</span></abbr> +/- <code>tms</code> * <abbr><span class="acronym">s.e.</span></abbr> where the spline 
interpolation is replaced by a higher order polynomial 
interpolation.  This is done in order to avoid numerical 
instabilities which are likely to occur for values of the parameter 
of interest close to the <abbr><span class="acronym">MLE</span></abbr>.  Results are stored in an 
object of class <code>cond</code>.  Method functions like <code>print</code>, 
<code>summary</code> and <code>plot</code> can be used to examine the output or 
represent it graphically.  Components can be extracted using 
<code>coef</code>, <code>formula</code> and <code>family</code>.
</p>
<p>Main references for the methods considered are the papers by 
<cite>Pierce and Peters (1992)</cite> and <cite>Davison (1988)</cite>.  More 
details on the implementation are given in <cite>Brazzale (1999, 
2000)</cite>.
</p>


<h3>Value</h3>

<p>The returned value is an object of class <code>cond</code>; see 
<code><a href="#topic+cond.object">cond.object</a></code> for details.
</p>


<h3>Note</h3>

<p>In rare occasions, <code>cond.glm</code> dumps because of non-convergence
of the function <code>glm</code> which is used to refit the model for a 
fixed value of the parameter of interest.  This happens for instance
if this value is too extreme.  The arguments <code>from</code> and 
<code>to</code> may then be used to limit the default range of 
<abbr><span class="acronym">MLE</span></abbr> +/- 3.5 * <abbr><span class="acronym">s.e.</span></abbr>  A further possibility is to
fine-tuning the constants (number of iterations, convergence 
threshold) that control the <abbr><span class="acronym">GLM</span></abbr> fit through the 
<code>control</code> argument. 
</p>
<p><code>cond.glm</code> may also dump if the estimate of the parameter of 
interest is large (tipically &gt; 400) in absolute value.  This may be
avoided by reparametrizing the model.
</p>
<p>The output of <code>cond.glm</code> may be unreliable if part of the data
have a degenerate distribution.  For example take the fungal 
infections treatment data contained in the <code><a href="#topic+fungal">fungal</a></code> data
frame.  Of the five <code class="reqn">2\times 2</code> contingency tables, two 
(the first and the third) are degenerate.  As they make no 
contribution to the exact conditional likelihood, they should be 
omitted from the approximate conditional fit.  
</p>


<h3>References</h3>

<p>Brazzale, A. R. (1999) Approximate conditional inference for 
logistic and loglinear models.  <em>J. Comput. Graph. Statist.</em>, 
<b>8</b>, 1999, 653&ndash;661.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric 
Inference</em>.  Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.
</p>
<p>Davison, A. C. (1988) Approximate conditional inference in 
generalized linear models.  <em>J. R. Statist. Soc.</em> B, <b>50</b>,
445&ndash;461.
</p>
<p>Pierce, D. A. and Peters, D. (1992) Practical use of higher order 
asymptotics for multiparameter exponential families (with 
Discussion).  <em>J. R. Statist. Soc.</em> B, <b>54</b>, 701&ndash;737.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond.object">cond.object</a></code>, <code><a href="#topic+summary.cond">summary.cond</a></code>, 
<code><a href="#topic+plot.cond">plot.cond</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Crying Babies Data
data(babies)
babies.glm &lt;- glm(formula = cbind(r1, r2) ~ day + lull - 1, 
                  family = binomial, data = babies)
babies.cond &lt;- cond(object = babies.glm, offset = lullyes)
babies.cond
##
## If one wishes to avoid the generalized linear model fit:
babies.cond &lt;- cond.glm(formula = cbind(r1, r2) ~ day + lull - 1, 
                        family = binomial, data = babies, offset = lullyes)
babies.cond

## Urine Data 
## (function call as offset variable) 
data(urine)
urine.glm &lt;- glm(r ~ gravity + ph + osmo + conduct + urea + log(calc), 
                 family = binomial, data = urine)
labels(coef(urine.glm))
urine.cond &lt;- cond(urine.glm, log(calc))
##
## (large estimate of regression coefficient)
urine.glm &lt;- glm(r ~ gravity + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
coef(urine.glm)
urine.glm &lt;- glm(r ~ I(gravity * 100) + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
coef(urine.glm)
urine.cond &lt;- cond(urine.glm, I(gravity * 100))

## Fungal Infections Treatment Data (numerical instabilities around the
##                                   MLE)
## (full data analysis)
data(fungal)
fungal.glm &lt;- glm(cbind(success, failure) ~ center + group - 1, 
                  family = binomial, data = fungal, 
                  control = glm.control(maxit = 50, epsilon = 1e-005))
fungal.cond &lt;- cond(fungal.glm, groupT)
plot(fungal.cond, which = 2)
## (partial data analysis)
fungal.glm &lt;- glm(cbind(success, failure) ~ center + group - 1, 
                  family = binomial, data = fungal, subset = -c(1,2,5,6), 
                  control = glm.control(maxit = 50, epsilon = 1e-005))
fungal.cond &lt;- cond(fungal.glm, groupT)
plot(fungal.cond, which = 2)
## (Tables 1 and 3 are omitted).
</code></pre>

<hr>
<h2 id='cond.object'>
Approximate Conditional Inference Object
</h2><span id='topic+cond.object'></span>

<h3>Description</h3>

<p>Class of objects returned when performing approximate conditional
inference for logistic and loglinear models.
</p>


<h3>Arguments</h3>

<p>Objects of class <code>cond</code> are implemented as a list.  The 
following components are included: 
</p>
<table>
<tr><td><code id="cond.object_+3A_workspace">workspace</code></td>
<td>

<p>a list whose elements are the spline interpolations of several 
first order and higher order statistics. They are used to
implement the following likelihood quantities:
</p>
<p>- the profile and modified profile log likelihoods;
</p>
<p>- the Wald pivots from the unconditional and conditional 
<abbr><span class="acronym">MLE</span></abbr>s;
</p>
<p>- the profile and modified likelihood roots (the latter one
with a suitable continuity correction);
</p>
<p>- the Lugannani-Rice tail area approximation (with suitable 
continuity correction);
</p>
<p>- the correction term used in the higher order statistics;
</p>
<p>- the information and nuisance parameter aspects.
</p>
<p>Method functions work mainly on this part of the object.  In order
to avoid errors in the calculation of confidence intervals and
tail probabilities, this part of the object should not be 
modified.
</p>
</td></tr>
<tr><td><code id="cond.object_+3A_coefficients">coefficients</code></td>
<td>

<p>a <code class="reqn">2\times 2</code> matrix containing the unconditional and 
approximate conditional <abbr><span class="acronym">MLE</span></abbr>s and their standard errors.
</p>
</td></tr>
<tr><td><code id="cond.object_+3A_call">call</code></td>
<td>

<p>function call that created the <code>cond</code> object.
</p>
</td></tr>
<tr><td><code id="cond.object_+3A_formula">formula</code></td>
<td>

<p>the model formula.
</p>
</td></tr>
<tr><td><code id="cond.object_+3A_family">family</code></td>
<td>

<p>the variance function.
</p>
</td></tr>
<tr><td><code id="cond.object_+3A_offset">offset</code></td>
<td>

<p>the covariate occurring in the model formula whose coefficient 
represents the parameter of interest.
</p>
</td></tr>
<tr><td><code id="cond.object_+3A_diagnostics">diagnostics</code></td>
<td>

<p>diagnostics related to the decomposition of the higher order
adjustments into an information and a nuisance parameters term. 
A value larger than 0.2 in absolute value is an index that 
higher order methods are needed.  See <cite>Pierce and Peters 
(1992)</cite> for details.
</p>
</td></tr>
<tr><td><code id="cond.object_+3A_n.approx">n.approx</code></td>
<td>

<p>number of output points that have been calculated exactly. 
</p>
</td></tr>
<tr><td><code id="cond.object_+3A_omitted.val">omitted.val</code></td>
<td>

<p>range of values omitted in the spline interpolation of some of the
higher order statistics considered.  The aim is to avoid 
numerical instabilities around the maximum likelihood estimate.
</p>
</td></tr>
<tr><td><code id="cond.object_+3A_is.scalar">is.scalar</code></td>
<td>

<p>a logical value indicating whether there are any nuisance 
parameters.  If <code>FALSE</code> there are none.
</p>
</td></tr>
</table>
<p>Main references for the methods considered are the papers by 
<cite>Pierce and Peters (1992)</cite> and <cite>Davison (1988)</cite>.  More 
details on the implementation and the methods considered are given
in <cite>Brazzale (1999, 2000)</cite>.
</p>


<h3>Generation</h3>

<p>This class of objects is returned from calls to the function 
<code><a href="#topic+cond.glm">cond.glm</a></code>. 
</p>


<h3>Methods</h3>

<p>The class <code>cond</code> has methods for <code><a href="base.html#topic+summary">summary</a></code>, 
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code>, 
<code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+family">family</a></code>, amongst 
others.
</p>


<h3>References</h3>

<p>Brazzale, A. R. (1999) Approximate conditional inference for 
logistic and loglinear models.  <em>J. Comput. Graph. Statist.</em>, 
<b>8</b>, 653&ndash;661.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric
Inference</em>, Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.
</p>
<p>Davison, A. C. (1988) Approximate conditional inference in 
generalized linear models.  <em>J. R. Statist. Soc.</em> B, 
<b>50,</b> 445&ndash;461.
</p>
<p>Pierce, D. A. and Peters, D. (1992) Practical use of higher order 
asymptotics for multiparameter exponential families (with 
Discussion).  <em>J. R. Statist. Soc.</em> B, <b>54</b>, 701&ndash;737.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond.glm">cond.glm</a></code>, <code><a href="#topic+summary.cond">summary.cond</a></code>, 
<code><a href="#topic+plot.cond">plot.cond</a></code>
</p>

<hr>
<h2 id='dormicum'>Dormicum Data</h2><span id='topic+dormicum'></span>

<h3>Description</h3>

<p>The <code>dormicum</code> data frame has 37 rows and 3 columns.
</p>
<p>37 children in a pediatric intensive care unit were treated with 
varying doses and for varying duration with the drug 
<em>Dormicum</em>.  The response variable is 1 if withdrawal symptoms 
were exhibited and 0 otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dormicum)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>symp</code></dt><dd>
<p>indicator of the presence of withdrawal symptoms;
</p>
</dd>
<dt><code>dose</code></dt><dd>
<p>the drug dose in mg/kg;
</p>
</dd>
<dt><code>days</code></dt><dd>
<p>the number of days treated.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were supplied by <em>Spadille Biostatistik</em>, Denmark.
</p>


<h3>References</h3>

<p>Mehta, C. R., Patel, N. T. and Senchaudhuri, P. (2000) Efficient 
Monte Carlo methods for conditional logistic regression. 
<em>J. Amer. Statist. Ass.</em>, <b>95</b>, 99&ndash;108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dormicum)
par(mfrow = c(1,2))
plot(dose ~ symp, data = dormicum, xlab = "presence of withdrawal symptoms",
     ylab = "treatment dose (mg/kg)")
plot(days ~ symp, data = dormicum, xlab = "presence of withdrawal symptoms",
     ylab = "treatment days")
</code></pre>

<hr>
<h2 id='family.cond'>
Use family() on a &ldquo;cond&rdquo; object
</h2><span id='topic+family.cond'></span>

<h3>Description</h3>

<p>This is a method for the function <code>family()</code> for objects
inheriting from class <code>cond</code>.  See <code><a href="stats.html#topic+family">family</a></code>
for the general behaviour of this function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond'
family(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.cond_+3A_object">object</code></td>
<td>

<p>any object from which a <code>family</code> object can be extracted.   
</p>
</td></tr>
<tr><td><code id="family.cond_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.  
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+family">family</a></code>
</p>

<hr>
<h2 id='family.summary.cond'>
Use family() on a &ldquo;summary.cond&rdquo; object
</h2><span id='topic+family.summary.cond'></span>

<h3>Description</h3>

<p>This is a method for the function <code>family()</code> for objects 
inheriting from class <code>summary.cond</code>.  See 
<code><a href="stats.html#topic+family">family</a></code> for the general behaviour of this 
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.cond'
family(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.summary.cond_+3A_object">object</code></td>
<td>

<p>any object from which a <code>family</code> object can be extracted.   
</p>
</td></tr>
<tr><td><code id="family.summary.cond_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.  
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+family">family</a></code>
</p>

<hr>
<h2 id='fraudulent'>Fraudulent Automobile Insurance Claims Data</h2><span id='topic+fraudulent'></span>

<h3>Description</h3>

<p>The <code>fraudulent</code> data frame has 42 rows and 12 columns.
</p>
<p>127 claims arising from automobile accidents in 1989 in
Massachusetts (USA).  Each claim was classified as either
fraudulent 
or legitimate by consensus among four independent claims adjusters 
who examined each case file thoroughly.  An exploratory analysis by 
Derrig and Weisberg (1993) identified 10 binary indicators, each of 
which denotes the presence or absence of a potential fraud 
characteristic in the claim situation.  They fall into three broad 
groups relating to &ldquo;Accident&rdquo; (AC1, AC9 and AC16), 
&ldquo;Claimant&rdquo; (CL7 and CL11), and &ldquo;Injury&rdquo; (IJ2, IJ3, 
IJ4, IJ6 and IJ12).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fraudulent)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>r1</code></dt><dd>
<p>the number of frauds detected;
</p>
</dd>
<dt><code>r2</code></dt><dd>
<p>the total number of automobile insurance claims;
</p>
</dd>
<dt><code>AC1</code>,<code>AC9</code>,<code>AC16</code></dt><dd>
<p>potential fraud characteristics pertaining to &ldquo;Accident&rdquo;.  
The presence of the fraud characteristic is indicated by a 1, the 
absence is indicated by a 0.
</p>
</dd>
<dt><code>CL7</code>,<code>CL11</code></dt><dd>
<p>potential fraud characteristics pertaining to &ldquo;Claimer&rdquo;.  
The presence of the fraud characteristic is indicated by a 1, the 
absence is indicated by a 0.
</p>
</dd>
<dt><code>IJ2</code>,<code>IJ3</code>,<code>IJ4</code>,<code>IJ6</code>,<code>IJ12</code></dt><dd>
<p>potential fraud characteristics pertaining to &ldquo;Injury&rdquo;.  
The presence of the fraud characteristic is indicated by a 1, the 
absence is indicated by a 0.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were supplied by Dr. Richard Derrig of the Automobile 
Insurers Bureau of Massachusetts.
</p>


<h3>References</h3>

<p>Mehta, C. R., Patel, N. T. and Senchaudhuri, P. (2000) Efficient 
Monte Carlo methods for conditional logistic regression. 
<em>J. Amer. Statist. Ass.</em>, <b>95</b>, 99&ndash;108.
</p>
<p>Derrig, R. A. and Weisberg, H. I. (1993).  Quantitative methods for
detecting fraudulent automobile bodily injury claims.  
<em>Manuscript.</em>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fraudulent)
summary(fraudulent)
</code></pre>

<hr>
<h2 id='fungal'>Fungal Infections Treatment Data</h2><span id='topic+fungal'></span>

<h3>Description</h3>

<p>The <code>fungal</code> data frame has 10 rows and 4 columns.
</p>
<p>Clinical trial on the success of a particular treatment for
fungal infections.  The study was carried out in five different
research units.  Interest focuses on the treatment effect.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fungal)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>success</code></dt><dd>
<p>the number of patients that benefited from the treatment;
</p>
</dd>
<dt><code>failure</code></dt><dd>
<p>the number of patients with no benefit from the treatment;
</p>
</dd>
<dt><code>group</code></dt><dd>
<p>an indicator variable for treatment (<code>T</code>=treatment, 
<code>P</code>=placebo);
</p>
</dd>
<dt><code>center</code></dt><dd>
<p>a factor variable indicating the research unit where the study 
was carried out.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were supplied by <em>Sandoz Pharmaceuticals.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (full data analysis)
data(fungal)
fungal.glm &lt;- glm(cbind(success, failure) ~ center + group - 1, 
                  family = binomial, data = fungal, 
                  control = glm.control(maxit = 50, epsilon = 1e-005))
fungal.cond &lt;- cond(fungal.glm, groupT)
plot(fungal.cond, which = 2)
## (partial data analysis) 
fungal.glm &lt;- glm(cbind(success, failure) ~ center + group - 1, 
                  family = binomial, data = fungal, subset = -c(1,2,5,6), 
                  control = glm.control(maxit = 50, epsilon = 1e-005))
fungal.cond &lt;- cond(fungal.glm, groupT)
plot(fungal.cond, which = 2)
## (Tables 1 and 3 are omitted).
</code></pre>

<hr>
<h2 id='plot.cond'>
Generate Plots for an Approximate Conditional Inference Object
</h2><span id='topic+plot.cond'></span>

<h3>Description</h3>

<p>Creates a set of plots for an object of class <code>cond</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond'
plot(x = stop("nothing to plot"), from = x.axis[1], to = x.axis[n], 
     which = NULL, alpha = 0.05, add.leg = TRUE, loc.leg = FALSE,
     add.labs = TRUE, cex = 0.7, cex.lab = 1, cex.axis = 1, 
     cex.main = 1, lwd1 = 1, lwd2 = 2, lty1 = "solid", 
     lty2 = "dashed", col1 = "black", col2 = "blue", tck = 0.02, 
     las = 1, adj = 0.5, lab = c(15, 15, 5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cond_+3A_x">x</code></td>
<td>

<p>a <code>cond</code> object.  This is assumed to be the result returned 
by the <code><a href="#topic+cond.glm">cond.glm</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_from">from</code></td>
<td>

<p>starting value for the x-axis range. The default value has been 
set by <code><a href="#topic+cond.glm">cond.glm</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_to">to</code></td>
<td>

<p>ending value for the x-axis range. The default value has been set
by <code><a href="#topic+cond.glm">cond.glm</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_which">which</code></td>
<td>

<p>which plot should be printed.  Admissible values are <code>2</code> to 
<code>8</code> corresponding to the choices in the menu below.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_alpha">alpha</code></td>
<td>

<p>the level used to read off confidence intervals; default is 5%.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_add.leg">add.leg</code></td>
<td>

<p>if <code>TRUE</code>, a legend is added to each plot; default is 
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_loc.leg">loc.leg</code></td>
<td>

<p>if <code>TRUE</code>, position of the legend can be located by hand; 
default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_add.labs">add.labs</code></td>
<td>

<p>if <code>TRUE</code>, labels are added; default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_cex">cex</code>, <code id="plot.cond_+3A_cex.lab">cex.lab</code>, <code id="plot.cond_+3A_cex.axis">cex.axis</code>, <code id="plot.cond_+3A_cex.main">cex.main</code></td>
<td>

<p>character expansions relative to the standard size of the device 
to be used for printing text, labels, axes and main title.  See 
<code><a href="graphics.html#topic+par">par</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_lwd1">lwd1</code>, <code id="plot.cond_+3A_lwd2">lwd2</code></td>
<td>

<p>line width used to compare different curves in the same plot; 
default is <code>lwd2 = 2</code> for higher order solutions and 
<code>lwd1 = 1</code> for first order solutions.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_lty1">lty1</code>, <code id="plot.cond_+3A_lty2">lty2</code></td>
<td>

<p>line type used to compare different curves in the same plot; 
default is <code>lty2 = "dashed"</code> for the Wald statistic and 
<code>lty1 = "solid"</code> for the remaining first- and higher order 
statistics.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_col1">col1</code>, <code id="plot.cond_+3A_col2">col2</code></td>
<td>

<p>colors used to compare different curves in the same plot; default 
is <code>col2 = "blue"</code> for higher order solutions, and 
<code>col1 = "black"</code> for the remaining first order statistics.
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_tck">tck</code>, <code id="plot.cond_+3A_las">las</code>, <code id="plot.cond_+3A_adj">adj</code>, <code id="plot.cond_+3A_lab">lab</code></td>
<td>

<p>further graphical parameters.  See <code><a href="graphics.html#topic+par">par</a></code> for 
details. 
</p>
</td></tr>
<tr><td><code id="plot.cond_+3A_...">...</code></td>
<td>

<p>optional graphical parameters; see <code><a href="graphics.html#topic+par">par</a></code> for 
details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several plots are produced for an object of class <code>cond</code>. A 
menu lists all the plots that can be produced.  They may be one or 
all of the following ones:
</p>
<pre>
 Make a plot selection (or 0 to exit)

1:plot: All
2:plot: Profile and modified profile log likelihoods
3:plot: Profile and modified profile likelihood ratios
4:plot: Profile and modified likelihood roots
5:plot: Modified and continuity corrected likelihood roots
6:plot: Lugannani-Rice approximations
7:plot: Confidence intervals
8:plot: Diagnostics based on INF/NP decomposition

Selection:
  </pre>
<p>If no nuisance parameters are presented, a subset of the above 
pictures is produced.  More details on the implementation are given
in <cite>Brazzale (1999, 2000)</cite>.
</p>
<p>This function is a method for the generic function <code>plot()</code> 
for class <code>cond</code>.  It can be invoked by calling <code>plot</code> 
or directly <code>plot.cond</code> for an object of the appropriate class.
</p>


<h3>Value</h3>

<p>A plot is created on the current graphics device.
</p>


<h3>Side Effects</h3>

<p>The current device is cleared.  When <code>add.leg = TRUE</code>, a legend
is added to each plot, and if <code>loc.leg = TRUE</code>, it can be set 
by the user.  All screens are closed, but not cleared, on 
termination of the function.
</p>


<h3>Note</h3>

<p>The diagnostic plots only represent a preliminary version and need
further development.  
</p>
<p>The two panels on the right trace the information and nuisance
correction terms, <abbr><span class="acronym">INF</span></abbr> and <abbr><span class="acronym">NP</span></abbr>, against the 
likelihood root statistic.  These are generally smooth functions
and used to approximate the information and nuisance parameter
aspects as a function of the parameter of interest, as shown in the
two panels on the left.  This procedure has the advantage of largely
eliminating the numerical instabilities that affect the statistics
around the <abbr><span class="acronym">MLE</span></abbr>.  The circles in the two leftmost panels
represent the limit of <abbr><span class="acronym">INF</span></abbr> and <abbr><span class="acronym">NP</span></abbr> at the
<abbr><span class="acronym">MLE</span></abbr> calculated exactly using numerical derivatives.  All
four pictures are intended to give an idea of the order of
magnitude of the two correction terms while trying to deal with the
numerical problems that likely occur for these kinds of data.
</p>
<p>More details can be found in <cite>Brazzale (2000, Appendix B.2)</cite>.  
</p>


<h3>References</h3>

<p>Brazzale, A. R. (1999) Approximate conditional inference for 
logistic and loglinear models.  <em>J. Comput. Graph. Statist.</em>, 
<b>8</b>, 1999, 653&ndash;661.
</p>
<p>Brazzale, A. R. (2000) <em>Practical Small-Sample Parametric
Inference</em>, Ph.D. Thesis N. 2230, Department of Mathematics, Swiss
Federal Institute of Technology Lausanne.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond.glm">cond.glm</a></code>, <code><a href="#topic+cond.object">cond.object</a></code>, 
<code><a href="#topic+summary.cond">summary.cond</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Crying Babies Data
data(babies)
babies.glm &lt;- glm(formula = cbind(r1, r2) ~ day + lull - 1, 
                  family = binomial, data = babies)
babies.cond &lt;- cond(object = babies.glm, offset = lullyes)
## Not run: 
plot(babies.cond)

## End(Not run)

## Urine Data 
data(urine)
urine.glm &lt;- glm(r ~ I(gravity * 100) + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
urine.cond &lt;- cond(urine.glm, I(gravity * 100))
plot(urine.cond, which=4)
</code></pre>

<hr>
<h2 id='print.cond'>
Use print() on a &ldquo;cond&rdquo; object
</h2><span id='topic+print.cond'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects 
inheriting from class <code>cond</code>.  See <code><a href="base.html#topic+print">print</a></code> 
and <code><a href="base.html#topic+print.default">print.default</a></code> for the general behaviour of 
this function and for the interpretation of <code>digits</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond'
print(x, digits=max(3, getOption("digits")-3), ...)
## S3 method for class 'cond'
print(x, digits, ...)</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+cond.object">cond.object</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+print.default">print.default</a></code>
</p>

<hr>
<h2 id='print.summary.cond'>
Use print() on a &ldquo;summary.cond&rdquo; object
</h2><span id='topic+print.summary.cond'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects 
inheriting from class <code>summary.cond</code>.  See 
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+print.default">print.default</a></code>
for the general  behaviour of this function and for the 
interpretation of <code>digits</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.cond'
print(x, all = x$all, Coef = x$cf, int = x$int, test = x$hyp,
      digits = if(!is.null(x$digits)) x$digits else max(3, getOption("digits")-3), 
      ...)
## S3 method for class 'summary.cond'
print(x, all, Coef, int, test, digits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.cond_+3A_x">x</code></td>
<td>

<p>a <code>summary.cond</code> object.  This is assumed to be the result 
returned by the <code>summary.cond</code> function.
</p>
</td></tr>
<tr><td><code id="print.summary.cond_+3A_all">all</code></td>
<td>

<p>if <code>TRUE</code> all the information stored in the 
<code>summary.cond</code> object is printed, else only a subset of it.  
The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.cond_+3A_coef">Coef</code></td>
<td>

<p>if <code>TRUE</code>, the unconditional and conditional parameter 
estimates are printed.  The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.cond_+3A_int">int</code></td>
<td>

<p>if <code>TRUE</code>, confidence intervals are printed.  The default is 
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.cond_+3A_test">test</code></td>
<td>

<p>if <code>TRUE</code>, tests statistics and tail probabilities are 
printed.  The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.cond_+3A_digits">digits</code></td>
<td>

<p>number of significant digits to be printed.  The default 
depends on the value of <code>digits</code> set by <code>options</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.cond_+3A_...">...</code></td>
<td>

<p>additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Changing the default values of <code>all</code>, <code>Coef</code>, <code>int</code> 
and <code>test</code> allows only a subset of the information in the 
<code>summary.cond</code> object to be printed.  With <code>all = FALSE</code>,
one-sided confidence intervals and the Lugannani-Rice tail
approximations are omitted.  See <code><a href="#topic+summary.cond">summary.cond</a></code> for more
details.
</p>


<h3>Note</h3>

<p>The amount of information printed may vary depending on whether 
there are any nuisance parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.cond">summary.cond</a></code>, <code><a href="#topic+cond.object">cond.object</a></code>, 
<code><a href="base.html#topic+print.default">print.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Urine Data 
data(urine)
urine.glm &lt;- glm(r ~ gravity + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
urine.cond &lt;- cond(urine.glm, urea)
print(summary(urine.cond, all = TRUE), digits = 4)
print(summary(urine.cond), Coef = FALSE)
</code></pre>

<hr>
<h2 id='rabbits'>Rabbits Data</h2><span id='topic+rabbits'></span>

<h3>Description</h3>

<p>The <code>rabbits</code> data frame has 10 rows and 4 columns.
</p>
<p>Five different doses of penicillin were administered to rabbits
suffering from a streptococci infection and the number of recovering 
rabbits recorded.  The rabbits are cross-classified according to 
whether the drug is administered immediately or delayed by an hour 
and a half.  Interest focuses on whether the delay effects the 
treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rabbits)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>cured</code></dt><dd>
<p>the number of rabbits that recovered;
</p>
</dd>
<dt><code>died</code></dt><dd>
<p>the number of rabbits that died;
</p>
</dd>
<dt><code>delay</code></dt><dd>
<p>an indicator variable indicating whether the administration of
penicillin was delayed by 1 1/2 hours;
</p>
</dd>
<dt><code>penicil</code></dt><dd>
<p>the penicillin dose.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Unknown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rabbits)
attach(rabbits)
fc &lt;- cured/(cured + died)
coplot(fc ~ log(penicil) | delay, data = rabbits)
</code></pre>

<hr>
<h2 id='summary.cond'>
Summary Method for Objects of Class &ldquo;cond&rdquo;
</h2><span id='topic+summary.cond'></span>

<h3>Description</h3>

<p>Returns a summary list for objects of class <code>cond</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond'
summary(object, alpha = 0.05, test = NULL, all = FALSE, coef = TRUE, 
        int = ifelse( (is.null(test) || all), TRUE, FALSE), 
        digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cond_+3A_object">object</code></td>
<td>

<p>a <code>cond</code> object.  This is assumed to be the result returned 
by the <code><a href="#topic+cond.glm">cond.glm</a></code> function.
</p>
</td></tr>
<tr><td><code id="summary.cond_+3A_alpha">alpha</code></td>
<td>

<p>vector of levels for confidence intervals.  The default is 5%.
</p>
</td></tr>
<tr><td><code id="summary.cond_+3A_test">test</code></td>
<td>

<p>vector of values of the parameter of interest one wants to test
for.  If <code>NULL</code>, no test is performed.  The default is 
<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="summary.cond_+3A_all">all</code></td>
<td>

<p>logical value; if <code>TRUE</code>, all the information stored in the 
<code>summary.cond</code> object is printed, else only a subset of it.  
The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="summary.cond_+3A_coef">coef</code></td>
<td>

<p>logical value; if <code>TRUE</code>, the unconditional and conditional 
parameter estimates are printed.  The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.cond_+3A_int">int</code></td>
<td>

<p>logical value; if <code>TRUE</code> confidence intervals are printed.  
The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="summary.cond_+3A_digits">digits</code></td>
<td>

<p>number of significant digits to be printed.  The default depends 
on the value of <code>digits</code> set by <code>options</code>.
</p>
</td></tr>
<tr><td><code id="summary.cond_+3A_...">...</code></td>
<td>

<p>absorbs any additional argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function <code>summary()</code> 
for objects of class <code>cond</code>.  It can be invoked by calling 
<code>summary</code> or directly <code>summary.cond</code> for an object of the 
appropriate class.
</p>


<h3>Value</h3>

<p>A list is returned with the following components.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>

<p>a <code class="reqn">2\times 2</code> matrix containing the unconditional and 
approximate conditional <abbr><span class="acronym">MLE</span></abbr>s and their standard errors.
</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>

<p>a matrix containing, for each level given in <code>alpha</code>, the 
upper and lower confidence bounds derived from several first- and 
higher order test statistics.  One-sided and two-sided confidence 
intervals are considered.  See <code><a href="#topic+cond.object">cond.object</a></code> for 
details on the test statistics.
</p>
</td></tr>
<tr><td><code>signif.tests</code></td>
<td>

<p>a list with two elements.  The first (<code>stats</code>) contains, for 
each value given in <code>test</code>, the values and tail probabilities
of several first- and higher order test statistics.  See 
<code><a href="#topic+cond.object">cond.object</a></code> for details on the test statistics.The
second element of the list (<code>qTerm</code>) contains for each tested
hypothesis the correction term used in the higher order solutions.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the function call that created the <code>cond</code> object.
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>

<p>the model formula.
</p>
</td></tr>
<tr><td><code>family</code></td>
<td>

<p>the variance function.
</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>

<p>the covariate occurring in the model formula whose coefficient 
represents the parameter of interest.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>

<p>vector of levels used to compute the confidence intervals.
</p>
</td></tr>
<tr><td><code>hypotheses</code></td>
<td>

<p>values for the parameter of interest that have been tested for.
</p>
</td></tr>
<tr><td><code>diagnostics</code></td>
<td>

<p>information and nuisance parameters aspects; see 
<code><a href="#topic+cond.object">cond.object</a></code> for details.
</p>
</td></tr>
<tr><td><code>n.approx</code></td>
<td>

<p>number of output points that have been calculated exactly. 
</p>
</td></tr>
<tr><td><code>all</code></td>
<td>

<p>logical value; if <code>TRUE</code>, all the information stored in the 
<code>summary.cond</code> object is printed.
</p>
</td></tr>
<tr><td><code>cf</code></td>
<td>

<p>logical value; if <code>TRUE</code>, the unconditional and conditional 
parameter estimates are printed.
</p>
</td></tr>
<tr><td><code>int</code></td>
<td>

<p>logical value; if <code>TRUE</code>, confidence intervals are printed.
</p>
</td></tr>
<tr><td><code>is.scalar</code></td>
<td>

<p>a logical value indicating whether there are any nuisance 
parameters.  If <code>FALSE</code> there are none.
</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>

<p>number of significant digits to be printed.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The amount of information calculated may vary depending on whether 
there are any nuisance parameters.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+cond.object">cond.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Crying Babies Data
data(babies)
babies.glm &lt;- glm(formula = cbind(r1, r2) ~ day + lull - 1, 
                  family = binomial, data = babies)
babies.cond &lt;- cond(object = babies.glm, offset = lullyes)
summary(babies.cond, test = 0, coef = FALSE)
</code></pre>

<hr>
<h2 id='urine'>Urine Data</h2><span id='topic+urine'></span>

<h3>Description</h3>

<p>The <code>urine</code> data frame has 77 rows and 7 columns.
</p>
<p>79 urine specimens were analyzed in an effort to determine if 
certain physical characteristics of the urine might be related to 
the formation of calcium oxalate crystals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(urine)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>r</code></dt><dd>
<p>indicator of the presence of calcium oxalate crystals;
</p>
</dd>
<dt><code>gravity</code></dt><dd>
<p>the specific gravity of the urine, i.e. the density of urine
relative to water;
</p>
</dd>
<dt><code>ph</code></dt><dd>
<p>the pH reading of the urine;
</p>
</dd>
<dt><code>osmo</code></dt><dd>
<p>the osmolarity of the urine.  Osmolarity is proportional
to the concentration of molecules in solution (mOsm).
</p>
</dd>
<dt><code>conduct</code></dt><dd>
<p>The  conductivity of the urine.  Conductivity is proportional  
to the concentration of charged ions in solution (mMho milliMho).
</p>
</dd>
<dt><code>urea</code></dt><dd>
<p>the urea concentration in millimoles per litre;
</p>
</dd>
<dt><code>calc</code></dt><dd>
<p>the calcium concentration in millimoles per litre.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were obtained from
</p>
<p>Andrews, D. F. and Herzberg, A. M. (1985)  <em>Data: A Collection  
of Problems from Many Fields for the Student and Research Worker</em>,
Cambridge: Cambridge University Press.
</p>


<h3>References</h3>

<p>Davison, A. C. and Hinkley, D. V. (1997).  <em>Bootstrap Methods 
and Their Application </em> (Example 7.8).  Cambridge: Cambridge 
University Press.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(urine)
summary(urine)
pairs(urine)
##
data(urine)
urine.glm &lt;- glm(r ~ gravity + ph + osmo + conduct + urea + log(calc), 
                 family = binomial, data = urine)
labels(coef(urine.glm))
urine.cond &lt;- cond(urine.glm, log(calc))
##
## (large estimate of regression coefficient)
urine.glm &lt;- glm(r ~ gravity + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
coef(urine.glm)
urine.glm &lt;- glm(r ~ I(gravity * 100) + ph + osmo + conduct + urea + calc, 
                 family = binomial, data = urine)
coef(urine.glm)
urine.cond &lt;- cond(urine.glm, I(gravity * 100))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
