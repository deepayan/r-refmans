<!DOCTYPE html><html><head><title>Help for package COMIX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {COMIX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acfParams'><p>The function computes (and by default plots) estimates of the autocovariance</p>
or autocorrelation function for the different parameters of the model. This
is a wrapper for coda::acf.</a></li>
<li><a href='#calibrate'><p>This function aligns multiple samples so that their location parameters</p>
are equal.</a></li>
<li><a href='#calibrateNoDist'><p>This function aligns multiple samples so that their location parameters</p>
are equal.</a></li>
<li><a href='#comix'><p>This function generates a sample from the posterior of COMIX.</p></a></li>
<li><a href='#effectiveSampleSize'><p>This function creates an object that summarizes the effective sample size</p>
for the parameters of the model.</a></li>
<li><a href='#gewekeParams'><p>This function creates an object that summarizes the Geweke convergence</p>
diagnostic.</a></li>
<li><a href='#heidelParams'><p>This function creates an object that summarizes the Heidelberg-Welch</p>
convergence diagnostic.</a></li>
<li><a href='#plotEffectiveSampleSize'><p>This function creates plots for the effective sample size</p>
for the parameters of the model.</a></li>
<li><a href='#plotGewekeParams'><p>This function creates plots for the Geweke diagnostic and results of test of</p>
stationarity for the parameters of the model.</a></li>
<li><a href='#plotHeidelParams'><p>This function creates plots for the Heidelberg-Welch diagnostic and</p>
results of test of stationarity for the parameters of the model.</a></li>
<li><a href='#plotTracePlots'><p>This function creates trace plots for different parameters of the MCMC chain.</p></a></li>
<li><a href='#relabelChain'><p>This function relabels the chain to avoid label switching issues.</p></a></li>
<li><a href='#summarizeChain'><p>This function provides post-hoc estimates of the model parameters.</p></a></li>
<li><a href='#tidyChain'><p>This function creates tidy versions of the stored chain. This object can then be used as input</p>
for the other diagnostic functions in this package.</a></li>
<li><a href='#transform_params'><p>Convert between parameterizations of the multivariate skew normal distribution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Coarsened Mixtures of Hierarchical Skew Kernels</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian fit of a Dirichlet Process Mixture with hierarchical multivariate skew normal kernels and coarsened posteriors. For more information, see Gorsky, Chan and Ma (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2001.06451">doi:10.48550/arXiv.2001.06451</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.18), dplyr, ggplot2, stringr, coda, tidyr,
rlang, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sn, R.rsp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen, RcppNumerical</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-23 15:51:17 UTC; hhh</td>
</tr>
<tr>
<td>Author:</td>
<td>S. Gorsky [aut, cre],
  C. Chan [ctb],
  L. Ma [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>S. Gorsky &lt;sgorsky@umass.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-23 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acfParams'>The function computes (and by default plots) estimates of the autocovariance
or autocorrelation function for the different parameters of the model. This
is a wrapper for coda::acf.</h2><span id='topic+acfParams'></span>

<h3>Description</h3>

<p>The function computes (and by default plots) estimates of the autocovariance
or autocorrelation function for the different parameters of the model. This
is a wrapper for coda::acf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfParams(
  res,
  params = c("w", "xi", "xi0", "psi", "G", "E", "eta"),
  only_non_trivial_clusters = TRUE,
  lag.max = NULL,
  type = c("correlation", "covariance", "partial"),
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acfParams_+3A_res">res</code></td>
<td>
<p>An object of class <code>COMIX</code> or <code>tidyChainCOMIX</code>.</p>
</td></tr>
<tr><td><code id="acfParams_+3A_params">params</code></td>
<td>
<p>A character vector naming the parameters to compute and plot 
the autocorrelation plots for.</p>
</td></tr>
<tr><td><code id="acfParams_+3A_only_non_trivial_clusters">only_non_trivial_clusters</code></td>
<td>
<p>Logical, if <code>TRUE</code> only compute and/or
plot the autocorrelation for the clusters that are estimated to be non-empty.</p>
</td></tr>
<tr><td><code id="acfParams_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate the autocorrelation. See more
details at ?acf.</p>
</td></tr>
<tr><td><code id="acfParams_+3A_type">type</code></td>
<td>
<p>Character string giving the type of autocorrelation to be 
computed. See more details at ?acf.</p>
</td></tr>
<tr><td><code id="acfParams_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default) the autocorrelation is 
plotted.</p>
</td></tr>
<tr><td><code id="acfParams_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>acf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>acfParamsCOMIX</code> object which is a named list,
with a named element for each requested parameter. Each element is 
an object of class <code>acf</code> (from the <code>coda</code> package).
#' @examples
library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
matrix(
c(
150, 300,
250, 200
),
nrow = 2,
byrow = TRUE
)
</p>
<p># Dimension of data:
p &lt;- 3
</p>
<p># Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)
</p>
<p># Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)
</p>
<p># Sample data:
set.seed(1)
Y &lt;- 
rbind(
sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
)
</p>
<p>C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))
</p>
<p>prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)
</p>
<p># Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)
effssz &lt;- effectiveSampleSize(res_relab, &quot;w&quot;)
# Or:
tidy_chain &lt;- tidyChain(res_relab, &quot;w&quot;)
acf_w &lt;- acfParams(tidy_chain, &quot;w&quot;)
</p>
<p># (see vignette for a more detailed example)
</p>

<hr>
<h2 id='calibrate'>This function aligns multiple samples so that their location parameters
are equal.</h2><span id='topic+calibrate'></span>

<h3>Description</h3>

<p>This function aligns multiple samples so that their location parameters
are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate(x, reference.group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_+3A_x">x</code></td>
<td>
<p>An object of class COMIX.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_reference.group">reference.group</code></td>
<td>
<p>An integer between 1 and the number of groups in the data
(<code>length(unique(C))</code>). Defaults to <code>NULL</code>. If <code>NULL</code>, the samples 
are aligned so that their location parameters are set to be at the estimated
group location parameter. If an integer, the samples are aligned so that their 
location parameters are the same as the location parameter of sample <code>reference.group</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of 3:
</p>

<ul>
<li> <p><code>Y_cal</code>: a <code>nrow(x$data$Y)</code> <code class="reqn">\times</code> <code>ncol(x$data$Y)</code>
matrix, a calibrated version of the original data.
</p>
</li>
<li> <p><code>calibration_distribution</code>: an <code>x$pmc$nsave</code> <code class="reqn">\times</code> 
<code>ncol(x$data$Y)</code> <code class="reqn">\times</code> <code>nrow(x$data$Y)</code> array storing the 
difference between the estimated sample-specific location parameter and the group
location parameter for each saved step of the chain.
</p>
</li>
<li> <p><code>calibration_median</code>: a <code>nrow(x$data$Y)</code> <code class="reqn">\times</code> <code>ncol(x$data$Y)</code>
matrix storing the median difference between the estimated sample-specific location parameter and the group
location parameter for each saved step of the chain. This matrix is equal to the 
difference between the uncalibrated data (<code>x$data$Y</code>) and the calibrated
data (<code>Y_cal</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)

# Generate calibrated data:
cal &lt;- calibrateNoDist(res_relab)

# Compare raw and calibrated data: (see plot in vignette)
# par(mfrow=c(1, 2))
# plot(Y, col = C, xlim = range(Y[,1]), ylim = range(Y[,2]) )

# Get posterior estimates for the model parameters:
res_summary &lt;- summarizeChain(res_relab)
# Check for instance, the cluster assignment labels:
table(res_summary$t)
# Indeed the same as 
colSums(njk)

# Or examine the skewness parameter for the non-trivial clusters:
res_summary$alpha[ , unique(res_summary$t)]
# And compare those to
cbind(alpha1, alpha2)

# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='calibrateNoDist'>This function aligns multiple samples so that their location parameters
are equal.</h2><span id='topic+calibrateNoDist'></span>

<h3>Description</h3>

<p>This function aligns multiple samples so that their location parameters
are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateNoDist(x, reference.group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrateNoDist_+3A_x">x</code></td>
<td>
<p>An object of class COMIX.</p>
</td></tr>
<tr><td><code id="calibrateNoDist_+3A_reference.group">reference.group</code></td>
<td>
<p>An integer between 1 and the number of groups in the data
(<code>length(unique(C))</code>). Defaults to <code>NULL</code>. If <code>NULL</code>, the samples 
are aligned so that their location parameters are set to be at the estimated
group location parameter. If an integer, the samples are aligned so that their 
location parameters are the same as the location parameter of sample <code>reference.group</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of 2:
</p>

<ul>
<li> <p><code>Y_cal</code>: a <code>nrow(x$data$Y)</code> <code class="reqn">\times</code> <code>ncol(x$data$Y)</code>
matrix, a calibrated version of the original data.
</p>
</li>
<li> <p><code>calibration_median</code>: a <code>nrow(x$data$Y)</code> <code class="reqn">\times</code> <code>ncol(x$data$Y)</code>
matrix storing the median difference between the estimated sample-specific location parameter and the group
location parameter for each saved step of the chain. This matrix is equal to the 
difference between the uncalibrated data (<code>x$data$Y</code>) and the calibrated
data (<code>Y_cal</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)

# Generate calibrated data:
cal &lt;- calibrateNoDist(res_relab)

# Compare raw and calibrated data: (see plot in vignette)
# par(mfrow=c(1, 2))
# plot(Y, col = C, xlim = range(Y[,1]), ylim = range(Y[,2]) )

# Get posterior estimates for the model parameters:
res_summary &lt;- summarizeChain(res_relab)
# Check for instance, the cluster assignment labels:
table(res_summary$t)
# Indeed the same as 
colSums(njk)

# Or examine the skewness parameter for the non-trivial clusters:
res_summary$alpha[ , unique(res_summary$t)]
# And compare those to
cbind(alpha1, alpha2)

# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='comix'>This function generates a sample from the posterior of COMIX.</h2><span id='topic+comix'></span>

<h3>Description</h3>

<p>This function generates a sample from the posterior of COMIX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comix(Y, C, prior = NULL, pmc = NULL, state = NULL, ncores = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comix_+3A_y">Y</code></td>
<td>
<p>Matrix of the data. Each row represents an observation.</p>
</td></tr>
<tr><td><code id="comix_+3A_c">C</code></td>
<td>
<p>Vector of the group label of each observation. Labels must be integers starting from 1.</p>
</td></tr>
<tr><td><code id="comix_+3A_prior">prior</code></td>
<td>
<p>A list giving the prior information. If unspecified, a default prior is used.
The list includes the following parameters:
</p>

<ul>
<li> <p><code>zeta</code>: Coarsening parameter. A number between 0 and 1. <code>zeta</code> = 1: sample from standard posterior;
<code>zeta</code> &lt; 1: sample from power posterior. The lower <code>zeta</code> is, the more flexible the kernels become.
</p>
</li>
<li> <p><code>K</code>: Maximal number of mixture components.
</p>
</li>
<li> <p><code>eta_prior</code> Parameters for gamma prior for concentration parameter of the stick breaking process
prior for the weights.
</p>
</li>
<li> <p><code>m0</code>: Number of degrees of freedom for the inverse Wishart prior for Sigma, the covariance matrix
of the kernels. 
</p>
</li>
<li> <p><code>Lambda</code>: Mean parameter for the inverse Wishart prior for Sigma, the covariance matrix
of the kernels. 
</p>
</li>
<li> <p><code>b0</code>: Mean parameter for the multivariate normal distribution that is the prior for the
group mean parameter xi0.
</p>
</li>
<li> <p><code>B0</code>: Covariance parameter for the multivariate normal distribution that is the prior for the
group mean parameter xi0.
</p>
</li>
<li> <p><code>e0</code>: Number of degrees of freedom for the inverse Wishart prior for <code class="reqn">E_k</code>, the 
covariance matrix of the multivariate normal from which <code class="reqn">\xi_{j,k}</code> are drawn.
</p>
</li>
<li> <p><code>E0</code>: Mean parameter for the inverse Wishart prior for <code class="reqn">E_k</code>, the 
covariance matrix of the multivariate normal from which <code class="reqn">\xi_{j,k}</code> are drawn.
</p>
</li>
<li> <p><code>merge_step</code>: Introduce step to merge mixture components with small KL divergence. Default 
is <code>merge_step = TRUE</code>.
</p>
</li>
<li> <p><code>merge_par</code>: Parameter controlling merging radius. Default is <code>merge_par = 0.1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="comix_+3A_pmc">pmc</code></td>
<td>
<p>A list giving the Population Monte Carlo (PMC) parameters:
</p>

<ul>
<li> <p><code>npart</code>: Number of PMC particles.
</p>
</li>
<li> <p><code>nburn</code>: Number of burn-in steps
</p>
</li>
<li> <p><code>nsave</code>: Number of steps in the chain after burn-in.
</p>
</li>
<li> <p><code>nskip</code>: Thinning parameter, number of steps to skip between saving steps after burn-in.
</p>
</li>
<li> <p><code>ndisplay</code>: Display status of chain after every <code>ndisplay</code> steps.
</p>
</li></ul>
</td></tr>
<tr><td><code id="comix_+3A_state">state</code></td>
<td>
<p>A list giving the initial cluster labels:
</p>

<ul>
<li> <p><code>t</code>: An integer vector, same length as the number of rows of <code>Y</code>, with cluster labels
between <code>1</code> and <code>K</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="comix_+3A_ncores">ncores</code></td>
<td>
<p>The number of CPU cores to utilize in parallel. Defaults to 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class COMIX, a list of 4:
</p>

<p><code>chain</code>, a named list:
</p>

<ul>
<li>  <p><code>t</code>: an <code>nsave</code> <code class="reqn">\times</code> <code>nrow(Y)</code> matrix with estimated cluster labels
for each saved step of the chain and each observation in the data <code>Y</code>.
</p>
</li>
<li>  <p><code>z</code>: a <code>nsave</code> <code class="reqn">\times</code> <code>nrow(Y)</code> matrix with estimated values of 
the latent <code class="reqn">z_{i,j}</code> variable for the parameterization of the
multivariate skew normal distribution used in the sampler for each saved step of 
the chain and each observation in the data <code>Y</code>.
</p>
</li>
<li>  <p><code>W</code>: an <code>length(unique(C))</code> <code class="reqn">\times</code> <code>K</code> <code class="reqn">\times</code> 
</p>
</li>
<li>  <p><code>nsave</code>: array storing the estimated sample- and cluster-specific weights for each 
saved step of the chain.
</p>
</li>
<li>  <p><code>xi</code>: an <code>length(unique(C))</code> <code class="reqn">\times</code> <code>(ncol(Y) x K)</code> 
<code class="reqn">\times</code> <code>nsave</code> array storing the estimated sample- and cluster-specific
multivariate skew normal location parameters of the kernel for each saved step of the chain.
</p>
</li>
<li>  <p><code>xi0</code>: an <code>ncol(Y)</code> <code class="reqn">\times</code> <code>K</code> <code class="reqn">\times</code> 
</p>
</li>
<li>  <p><code>nsave</code>: array storing the estimated cluster-specific 
group location parameters for each saved step of the chain.
</p>
</li>
<li>  <p><code>psi</code>: an <code>ncol(Y)</code> <code class="reqn">\times</code> <code>K</code> <code class="reqn">\times</code> <code>nsave</code>
array storing the estimated cluster-specific skew parameters of the kernels in
the parameterization of the
multivariate skew normal distribution used in the sampler
for each saved step of the chain.
</p>
</li>
<li>  <p><code>G</code>: an  <code>ncol(Y)</code> <code class="reqn">\times</code> <code>(ncol(Y) x K)</code> 
<code class="reqn">\times</code> <code>nsave</code> array storing the estimated cluster-specific
multivariate skew normal scale matrix (in row format) of the kernel
used in the sampler for each saved step of the chain.
</p>
</li>
<li>  <p><code>E</code>: an  <code>ncol(Y)</code> <code class="reqn">\times</code> <code>(ncol(Y) x K)</code> 
<code class="reqn">\times</code> <code>nsave</code> array storing the estimated covariance matrix 
(in row format) of the multivariate normal distribution from which the  
sample- and cluster-specific location parameters are drawn for each saved step 
of the chain.
</p>
</li>
<li> <p><code>eta</code>: a <code>nsave</code> <code class="reqn">\times</code> <code>1</code> matrix storing the
estimated Dirichlet Process Mixture concentration parameter for each saved step of the chain.
</p>
</li>
<li> <p><code>Sigma</code>: an  <code>ncol(Y)</code> <code class="reqn">\times</code> <code>(ncol(Y) x K)</code> 
<code class="reqn">\times</code> <code>nsave</code> array storing the estimated cluster-specific
multivariate skew normal scale matrix (in row format) of the kernel for each saved step of the chain.
</p>
</li>
<li> <p><code>alpha</code>: an <code>ncol(Y)</code> <code class="reqn">\times</code> <code>K</code> <code class="reqn">\times</code> <code>nsave</code>
array storing the estimated cluster-specific skew parameters of the
kernel's multivariate skew normal distribution
for each saved step of the chain.
</p>
</li></ul>

<ul>
<li> <p><code>data</code>, a named list that includes the matrix of the data <code>Y</code>
and <code>C</code> the vector of the group label of each observation.
</p>
</li>
<li> <p><code>prior</code> and <code>pmc</code>, the lists, as above, that were provided as inputs to 
the function.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )


# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)

# Generate calibrated data:
cal &lt;- calibrateNoDist(res_relab)

# Compare raw and calibrated data: (see plot in vignette)
# par(mfrow=c(1, 2))
# plot(Y, col = C, xlim = range(Y[,1]), ylim = range(Y[,2]) )

# Get posterior estimates for the model parameters:
res_summary &lt;- summarizeChain(res_relab)
# Check for instance, the cluster assignment labels:
table(res_summary$t)
# Indeed the same as 
colSums(njk)

# Or examine the skewness parameter for the non-trivial clusters:
res_summary$alpha[ , unique(res_summary$t)]
# And compare those to
cbind(alpha1, alpha2)

# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='effectiveSampleSize'>This function creates an object that summarizes the effective sample size
for the parameters of the model.</h2><span id='topic+effectiveSampleSize'></span>

<h3>Description</h3>

<p>This function creates an object that summarizes the effective sample size
for the parameters of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectiveSampleSize(res, params = c("w", "xi", "xi0", "psi", "G", "E", "eta"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectiveSampleSize_+3A_res">res</code></td>
<td>
<p>An object of class <code>COMIX</code> or <code>tidyChainCOMIX</code>.</p>
</td></tr>
<tr><td><code id="effectiveSampleSize_+3A_params">params</code></td>
<td>
<p>A character vector naming the parameters to compute the 
effective sample size for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>effectiveSampleSizeCOMIX</code> object which is a named list,
with a named element for each requested parameter. Each element is a data
frame that includes the effective sample size for the parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)
effssz &lt;- effectiveSampleSize(res_relab, "w")
# Or:
tidy_chain &lt;- tidyChain(res_relab, "w")
effssz &lt;- effectiveSampleSize(tidy_chain, "w")
# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='gewekeParams'>This function creates an object that summarizes the Geweke convergence 
diagnostic.</h2><span id='topic+gewekeParams'></span>

<h3>Description</h3>

<p>This function creates an object that summarizes the Geweke convergence 
diagnostic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gewekeParams(
  res,
  params = c("w", "xi", "xi0", "psi", "G", "E", "eta"),
  frac1 = 0.1,
  frac2 = 0.5,
  probs = c(0.025, 0.975)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gewekeParams_+3A_res">res</code></td>
<td>
<p>An object of class <code>COMIX</code> or <code>tidyChainCOMIX</code>.</p>
</td></tr>
<tr><td><code id="gewekeParams_+3A_params">params</code></td>
<td>
<p>A character vector naming the parameters to compute the 
Geweke diagnostic for.</p>
</td></tr>
<tr><td><code id="gewekeParams_+3A_frac1">frac1</code></td>
<td>
<p>Double, fraction to use from beginning of chain.</p>
</td></tr>
<tr><td><code id="gewekeParams_+3A_frac2">frac2</code></td>
<td>
<p>Double, fraction to use from end of chain.</p>
</td></tr>
<tr><td><code id="gewekeParams_+3A_probs">probs</code></td>
<td>
<p>A vector of 2 doubles, probabilities denoting the limits
of a confidence interval for the convergence diagnostic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>gewekeParamsCOMIX</code> object which is a named list,
with a named element for each requested parameter. Each element is a data
frame that includes the Geweke diagnostic and result of a stationarity test 
for the parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)
effssz &lt;- effectiveSampleSize(res_relab, "w")
# Or:
tidy_chain &lt;- tidyChain(res_relab, "w")
gwk &lt;- gewekeParams(tidy_chain, "w")
# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='heidelParams'>This function creates an object that summarizes the Heidelberg-Welch 
convergence diagnostic.</h2><span id='topic+heidelParams'></span>

<h3>Description</h3>

<p>This function creates an object that summarizes the Heidelberg-Welch 
convergence diagnostic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heidelParams(
  res,
  params = c("w", "xi", "xi0", "psi", "G", "E", "eta"),
  eps = 0.1,
  pvalue = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heidelParams_+3A_res">res</code></td>
<td>
<p>An object of class <code>COMIX</code> or <code>tidyChainCOMIX</code>.</p>
</td></tr>
<tr><td><code id="heidelParams_+3A_params">params</code></td>
<td>
<p>A character vector naming the parameters to compute the 
Heidelberg-Welch diagnostic for.</p>
</td></tr>
<tr><td><code id="heidelParams_+3A_eps">eps</code></td>
<td>
<p>Target value for ratio of halfwidth to sample mean.</p>
</td></tr>
<tr><td><code id="heidelParams_+3A_pvalue">pvalue</code></td>
<td>
<p>Significance level to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>heidelParamsCOMIX</code> object which is a named list,
with a named element for each requested parameter. Each element is a data
frame that includes the Heidelberg-Welch diagnostic and results of a
stationarity test for the parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)
effssz &lt;- effectiveSampleSize(res_relab, "w")
# Or:
tidy_chain &lt;- tidyChain(res_relab, "w")
hd &lt;- heidelParams(tidy_chain, "w")
# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='plotEffectiveSampleSize'>This function creates plots for the effective sample size 
for the parameters of the model.</h2><span id='topic+plotEffectiveSampleSize'></span>

<h3>Description</h3>

<p>This function creates plots for the effective sample size 
for the parameters of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEffectiveSampleSize(effssz, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEffectiveSampleSize_+3A_effssz">effssz</code></td>
<td>
<p>An object of class <code>effectiveSampleSizeCOMIX</code> as created
by the function <code>effectiveSampleSize</code>.</p>
</td></tr>
<tr><td><code id="plotEffectiveSampleSize_+3A_param">param</code></td>
<td>
<p>Character, naming the parameter to create a plot of effective
sample sizes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot containing the effective sample size plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)
effssz &lt;- effectiveSampleSize(res_relab, "w")
# Or:
tidy_chain &lt;- tidyChain(res_relab, "w")
effssz &lt;- effectiveSampleSize(tidy_chain, "w")
plotEffectiveSampleSize(effssz, "w")
# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='plotGewekeParams'>This function creates plots for the Geweke diagnostic and results of test of
stationarity for the parameters of the model.</h2><span id='topic+plotGewekeParams'></span>

<h3>Description</h3>

<p>This function creates plots for the Geweke diagnostic and results of test of
stationarity for the parameters of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGewekeParams(gwk, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGewekeParams_+3A_gwk">gwk</code></td>
<td>
<p>An object of class <code>gewekeParamsCOMIX</code> as created
by the function <code>gewekeParams</code>.</p>
</td></tr>
<tr><td><code id="plotGewekeParams_+3A_param">param</code></td>
<td>
<p>Character, naming the parameter to create a plot of the Geweke
diagnostic for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot containing the Geweke diagnostic plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)
effssz &lt;- effectiveSampleSize(res_relab, "w")
# Or:
tidy_chain &lt;- tidyChain(res_relab, "w")
gwk &lt;- gewekeParams(tidy_chain, "w")
plotGewekeParams(gwk, "w")
# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='plotHeidelParams'>This function creates plots for the Heidelberg-Welch diagnostic and 
results of test of stationarity for the parameters of the model.</h2><span id='topic+plotHeidelParams'></span>

<h3>Description</h3>

<p>This function creates plots for the Heidelberg-Welch diagnostic and 
results of test of stationarity for the parameters of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHeidelParams(hd, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHeidelParams_+3A_hd">hd</code></td>
<td>
<p>An object of class <code>heidelParamsCOMIX</code> as created
by the function <code>heidelParams</code>.</p>
</td></tr>
<tr><td><code id="plotHeidelParams_+3A_param">param</code></td>
<td>
<p>Character, naming the parameter to create a plot of the 
Heidelberg-Welch diagnostic for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot containing the Heidelberg-Welch diagnostic plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)
effssz &lt;- effectiveSampleSize(res_relab, "w")
# Or:
tidy_chain &lt;- tidyChain(res_relab, "w")
hd &lt;- heidelParams(tidy_chain, "w")
plotHeidelParams(hd, "w")
# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='plotTracePlots'>This function creates trace plots for different parameters of the MCMC chain.</h2><span id='topic+plotTracePlots'></span>

<h3>Description</h3>

<p>This function creates trace plots for different parameters of the MCMC chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTracePlots(res, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTracePlots_+3A_res">res</code></td>
<td>
<p>An object of class <code>COMIX</code> or <code>tidyChainCOMIX</code>.</p>
</td></tr>
<tr><td><code id="plotTracePlots_+3A_param">param</code></td>
<td>
<p>Character, naming the parameter to create a trace plot for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot containing the trace plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)
plotTracePlots(res_relab, "w")
# Or:
tidy_chain &lt;- tidyChain(res_relab, "w")
plotTracePlots(tidy_chain, "w")
# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='relabelChain'>This function relabels the chain to avoid label switching issues.</h2><span id='topic+relabelChain'></span>

<h3>Description</h3>

<p>This function relabels the chain to avoid label switching issues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relabelChain(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relabelChain_+3A_res">res</code></td>
<td>
<p>An object of class COMIX.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class COMIX where <code>res$chain$t</code> is replaced with the
new labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)

# Generate calibrated data:
cal &lt;- calibrateNoDist(res_relab)

# Compare raw and calibrated data: (see plot in vignette)
# par(mfrow=c(1, 2))
# plot(Y, col = C, xlim = range(Y[,1]), ylim = range(Y[,2]) )

# Get posterior estimates for the model parameters:
res_summary &lt;- summarizeChain(res_relab)
# Check for instance, the cluster assignment labels:
table(res_summary$t)
# Indeed the same as 
colSums(njk)

# Or examine the skewness parameter for the non-trivial clusters:
res_summary$alpha[ , unique(res_summary$t)]
# And compare those to
cbind(alpha1, alpha2)

# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='summarizeChain'>This function provides post-hoc estimates of the model parameters.</h2><span id='topic+summarizeChain'></span>

<h3>Description</h3>

<p>This function provides post-hoc estimates of the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeChain(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeChain_+3A_res">res</code></td>
<td>
<p>An object of class COMIX.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list:
</p>

<ul>
<li> <p><code>xi0</code>: a <code>ncol(res$data$Y)</code> <code class="reqn">\times</code> <code>res$prior$K</code> matrix storing
the posterior mean of the group location parameter.
</p>
</li>
<li> <p><code>psi</code>: a <code>ncol(res$data$Y)</code> <code class="reqn">\times</code> <code>res$prior$K</code> matrix storing
the posterior mean of the multivariate skew normal kernels skewness parameter (in the parameterization used in
the sampler).
</p>
</li>
<li> <p><code>alpha</code>: a <code>ncol(res$data$Y)</code> <code class="reqn">\times</code> <code>res$prior$K</code> matrix storing
the posterior mean of the multivariate skew normal kernels skewness parameter.
</p>
</li>
<li> <p><code>W</code>: a <code>length(unique(res$data$C))</code> <code class="reqn">\times</code> <code>res$prior$K</code> matrix storing
the posterior mean of the mixture weights for each sample and cluster.
</p>
</li>
<li> <p><code>xi</code>: an <code>length(unique(res$data$C))</code> <code class="reqn">\times</code> <code>ncol(res$data$Y)</code>
<code class="reqn">\times</code> <code>res$prior$K</code> array storing the the posterior mean of the 
multivariate skew normal kernels location parameter for each sample and cluster.
</p>
</li>
<li> <p><code>Sigma</code>: an <code>ncol(res$data$Y)</code> <code class="reqn">\times</code> <code>ncol(res$data$Y)</code>
<code class="reqn">\times</code> <code>res$prior$K</code> array storing the the posterior mean of the 
scaling matrix of the multivariate skew normal kernels for each cluster.
</p>
</li>
<li> <p><code>G</code>: an <code>ncol(res$data$Y)</code> <code class="reqn">\times</code> <code>ncol(res$data$Y)</code>
<code class="reqn">\times</code> <code>res$prior$K</code> array storing the the posterior mean of the 
scaling matrix of the multivariate skew normal kernels for each cluster (in the 
parameterization used in the sampler).
</p>
</li>
<li> <p><code>E</code>: an <code>ncol(res$data$Y)</code> <code class="reqn">\times</code> <code>ncol(res$data$Y)</code>
<code class="reqn">\times</code> <code>res$prior$K</code> array storing the the posterior mean of the 
covariance matrix of the multivariate normal distributions for each cluster form which
the sample specific location parameters are drawn.
</p>
</li>
<li> <p><code>meanvec</code>: an <code>length(unique(res$data$C))</code> <code class="reqn">\times</code> <code>ncol(res$data$Y)</code>
<code class="reqn">\times</code> <code>res$prior$K</code> array storing the the posterior mean of the 
multivariate skew normal kernels mean parameter for each sample and cluster.
</p>
</li>
<li> <p><code>meanvec0</code>: a <code>ncol(res$data$Y)</code> <code class="reqn">\times</code> <code>res$prior$K</code> matrix storing
the posterior mean of the group mean parameter.
</p>
</li>
<li> <p><code>t</code>: Vector of length <code>nrow(x$data$Y)</code>. Each element is the mode
of the posterior distribution of cluster labels.
</p>
</li>
<li> <p><code>eta</code>: scalar, the mean of the posterior distribution of the estimated
Dirichlet Process Mixture concentration parameter.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)

# Generate calibrated data:
cal &lt;- calibrateNoDist(res_relab)

# Compare raw and calibrated data: (see plot in vignette)
# par(mfrow=c(1, 2))
# plot(Y, col = C, xlim = range(Y[,1]), ylim = range(Y[,2]) )

# Get posterior estimates for the model parameters:
res_summary &lt;- summarizeChain(res_relab)
# Check for instance, the cluster assignment labels:
table(res_summary$t)
# Indeed the same as 
colSums(njk)

# Or examine the skewness parameter for the non-trivial clusters:
res_summary$alpha[ , unique(res_summary$t)]
# And compare those to
cbind(alpha1, alpha2)

# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='tidyChain'>This function creates tidy versions of the stored chain. This object can then be used as input 
for the other diagnostic functions in this package.</h2><span id='topic+tidyChain'></span>

<h3>Description</h3>

<p>This function creates tidy versions of the stored chain. This object can then be used as input 
for the other diagnostic functions in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidyChain(
  res,
  params = c("t", "w", "xi", "xi0", "psi", "G", "E", "eta", "Sigma", "alpha")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyChain_+3A_res">res</code></td>
<td>
<p>An object of class COMIX.</p>
</td></tr>
<tr><td><code id="tidyChain_+3A_params">params</code></td>
<td>
<p>A character vector naming the parameters to tidy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tidyChainCOMIX</code> object: a named list of class whose length is the length 
of <code>params</code>. Each element of the list contains a tibble with a tidy version of the samples
from the MCMC chain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Number of observations for each sample (row) and cluster (column):
njk &lt;- 
  matrix(
    c(
      150, 300,
      250, 200
    ),
    nrow = 2,
    byrow = TRUE
  )

# Dimension of data:
p &lt;- 3

# Scale and skew parameters for first cluster:
Sigma1 &lt;- matrix(0.5, nrow = p, ncol = p) + diag(0.5, nrow = p)
alpha1 &lt;- rep(0, p)
alpha1[1] &lt;- -5
# location parameter for first cluster in first sample:
xi11 &lt;- rep(0, p)
# location parameter for first cluster in second sample (aligned with first):
xi21 &lt;- rep(0, p)

# Scale and skew parameters for second cluster:
Sigma2 &lt;- matrix(-1/3, nrow = p, ncol = p) + diag(1 + 1/3, nrow = p)
alpha2 &lt;- rep(0, p)
alpha2[2] &lt;- 5
# location parameter for second cluster in first sample:
xi12 &lt;- rep(3, p)
# location parameter for second cluster in second sample (misaligned with first):
xi22 &lt;- rep(4, p)

# Sample data:
set.seed(1)
Y &lt;- 
  rbind(
    sn::rmsn(njk[1, 1], xi = xi11, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[1, 2], xi = xi12, Omega = Sigma2, alpha = alpha2),
    sn::rmsn(njk[2, 1], xi = xi21, Omega = Sigma1, alpha = alpha1),
    sn::rmsn(njk[2, 2], xi = xi22, Omega = Sigma2, alpha = alpha2)
  )

C &lt;- c(rep(1, rowSums(njk)[1]), rep(2, rowSums(njk)[2]))

prior &lt;- list(zeta = 1, K = 10)
pmc &lt;- list(naprt = 5, nburn = 200, nsave = 200) # Reasonable usage
pmc &lt;- list(naprt = 5, nburn = 2, nsave = 5) # Minimal usage for documentation
# Fit the model:
res &lt;- comix(Y, C, pmc = pmc, prior = prior)

# Relabel to resolve potential label switching issues:
res_relab &lt;- relabelChain(res)
tidy_chain &lt;- tidyChain(res_relab)
# (see vignette for a more detailed example)
</code></pre>

<hr>
<h2 id='transform_params'>Convert between parameterizations of the multivariate skew normal distribution.</h2><span id='topic+transform_params'></span>

<h3>Description</h3>

<p>Convert between parameterizations of the multivariate skew normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_params(Sigma, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_params_+3A_sigma">Sigma</code></td>
<td>
<p>A scale matrix.</p>
</td></tr>
<tr><td><code id="transform_params_+3A_alpha">alpha</code></td>
<td>
<p>A vector for the skew parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list:
</p>

<ul>
<li> <p><code>delta</code>: a reparameterized skewness vector, a transformed 
version of <code>alpha</code>.
</p>
</li>
<li> <p><code>omega</code>: a diagonal matrix of the same dimensions as <code>Sigma</code>, 
the diagonal elements are the square roots of the diagonal elements of <code>Sigma</code>.
</p>
</li>
<li> <p><code>psi</code>: another reparameterized skewness vector, utilized in the sampler.
</p>
</li>
<li> <p><code>G</code>: a reparameterized version of <code>Sigma</code>, utilized in the sampler.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(COMIX)
# Scale and skew parameters:
Sigma &lt;- matrix(0.5, nrow = 4, ncol = 4) + diag(0.5, nrow = 4)
alpha &lt;- c(0, 0, 0, 5)
transformed_parameters &lt;- transform_params(Sigma, alpha)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
