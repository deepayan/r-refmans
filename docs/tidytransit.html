<!DOCTYPE html><html lang="en"><head><title>Help for package tidytransit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidytransit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agency_info'><p>Create a text listing the first <code>max_agencies</code> agencies of the feed</p></a></li>
<li><a href='#as_tidygtfs'><p>Convert another gtfs like object to a tidygtfs object</p></a></li>
<li><a href='#cluster_stops'><p>Cluster nearby stops within a group</p></a></li>
<li><a href='#convert_types'><p>Convert columns between gtfsio types to tidytransit types according to GTFS reference</p></a></li>
<li><a href='#duplicated_primary_keys'><p>Check if primary keys are unique within tables</p></a></li>
<li><a href='#empty_strings_to_na'><p>Convert empty strings (&quot;&quot;) to NA values in all gtfs tables</p></a></li>
<li><a href='#feed_contains.'><p>Returns TRUE if the given gtfs_obj contains the table in tidytransit's &quot;calculated</p>
tables sublist&quot; (<code>gtfs_obj$.</code>)</a></li>
<li><a href='#filter_feed_by_area'><p>Filter a gtfs feed so that it only contains trips that pass a given area</p></a></li>
<li><a href='#filter_feed_by_date'><p>Filter a gtfs feed so that it only contains trips running on a given date</p></a></li>
<li><a href='#filter_feed_by_stops'><p>Filter a gtfs feed so that it only contains trips that pass the given stops</p></a></li>
<li><a href='#filter_feed_by_trips'><p>Filter a gtfs feed so that it only contains a given set of trips</p></a></li>
<li><a href='#filter_stop_times'><p>Filter a <code>stop_times</code> table for a given date and timespan.</p></a></li>
<li><a href='#filter_stops'><p>Get a set of stops for a given set of service ids and route ids</p></a></li>
<li><a href='#get_route_frequency'><p>Get Route Frequency</p></a></li>
<li><a href='#get_route_geometry'><p>Get all trip shapes for a given route and service</p></a></li>
<li><a href='#get_stop_frequency'><p>Get Stop Frequency</p></a></li>
<li><a href='#get_trip_geometry'><p>Get all trip shapes for given trip ids</p></a></li>
<li><a href='#gtfs_as_sf'><p>Convert stops and shapes to Simple Features</p></a></li>
<li><a href='#gtfs_duke'><p>Example GTFS data</p></a></li>
<li><a href='#gtfs_to_tidygtfs'><p>Convert an object created by gtfsio::import_gtfs to a tidygtfs object</p></a></li>
<li><a href='#gtfs_transform'><p>Transform coordinates of a gtfs feed</p></a></li>
<li><a href='#hhmmss_to_hms'><p>Convert &quot;HH:MM:SS&quot; time strings to hms values</p>
empty strings are converted to NA</a></li>
<li><a href='#hhmmss_to_sec_split'><p>Fallback function to convert strings like 5:02:11</p>
10x slower than <code>hhmmss_to_seconds()</code>, empty strings are converted to NA</a></li>
<li><a href='#hhmmss_to_seconds'><p>Convert &quot;HH:MM:SS&quot; time strings to seconds (numeric)</p>
empty strings are converted to NA</a></li>
<li><a href='#interpolate_stop_times'><p>Interpolate missing stop_times linearly</p></a></li>
<li><a href='#json_to_sf'><p>Convert a json (read with jsonlite) to sf object</p></a></li>
<li><a href='#na_to_empty_strings'><p>Convert NA values to empty strings (&quot;&quot;)</p></a></li>
<li><a href='#plot.tidygtfs'><p>Plot GTFS stops and trips</p></a></li>
<li><a href='#print.tidygtfs'><p>Print a GTFS object</p></a></li>
<li><a href='#raptor'><p>Calculate travel times from one stop to all reachable stops</p></a></li>
<li><a href='#read_gtfs'><p>Read and validate GTFS files</p></a></li>
<li><a href='#route_type_names'><p>Dataframe of route type id's and the names of the types (e.g. &quot;Bus&quot;)</p></a></li>
<li><a href='#set_dates_services'><p>Returns all possible date/service_id combinations as a data frame</p></a></li>
<li><a href='#set_servicepattern'><p>Calculate service pattern ids for a GTFS feed</p></a></li>
<li><a href='#sf_as_tbl'><p>Convert stops and shapes from sf objects to tibbles</p></a></li>
<li><a href='#sf_lines_to_df'><p>Adds the coordinates of an sf LINESTRING object as columns and rows</p></a></li>
<li><a href='#sf_points_to_df'><p>Adds the coordinates of an sf POINT object as columns</p></a></li>
<li><a href='#sf_to_json'><p>Convert an sf object to a json list</p></a></li>
<li><a href='#shape_as_sf_linestring'><p>return an sf linestring with lat and long from gtfs</p></a></li>
<li><a href='#shapes_as_sf'><p>Convert shapes into Simple Features Linestrings</p></a></li>
<li><a href='#stop_distances'><p>Calculate distances between a given set of stops</p></a></li>
<li><a href='#stop_group_distances'><p>Calculates distances among stop within the same group column</p></a></li>
<li><a href='#stops_as_sf'><p>Convert stops into Simple Features Points</p></a></li>
<li><a href='#summary.tidygtfs'><p>GTFS feed summary</p></a></li>
<li><a href='#tidygtfs_to_gtfs'><p>Convert a tidygtfs object to a gtfs object (for gtfsio)</p></a></li>
<li><a href='#travel_times'><p>Calculate shortest travel times from a stop to all reachable stops</p></a></li>
<li><a href='#validate_gtfs'><p>Validate GTFS feed</p></a></li>
<li><a href='#write_gtfs'><p>Write a tidygtfs object to a zip file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read, Validate, Analyze, and Map GTFS Feeds</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Read General Transit Feed Specification (GTFS) zipfiles into a list of R dataframes. Perform validation of the data structure against the specification. Analyze the headways and frequencies at routes and stops. Create maps and perform spatial analysis on the routes and stops. Please see the GTFS documentation here for more detail: <a href="https://gtfs.org/">https://gtfs.org/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtfsio (&ge; 1.2.0), dplyr (&ge; 1.1.1), data.table (&ge; 1.12.8),
rlang, sf, jsonlite, hms, digest, geodist</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.1.5), knitr, markdown, rmarkdown, ggplot2,
scales, lubridate, leaflet</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-transit/tidytransit">https://github.com/r-transit/tidytransit</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-transit/tidytransit/issues">https://github.com/r-transit/tidytransit/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-18 13:36:18 UTC; flaviopoletti</td>
</tr>
<tr>
<td>Author:</td>
<td>Flavio Poletti [aut, cre],
  Daniel Herszenhut <a href="https://orcid.org/0000-0001-8066-1105"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Mark Padgham [aut],
  Tom Buckley [aut],
  Danton Noriega-Goodwin [aut],
  Angela Li [ctb],
  Elaine McVey [ctb],
  Charles Hans Thompson [ctb],
  Michael Sumner [ctb],
  Patrick Hausmann [ctb],
  Bob Rudis [ctb],
  James Lamb [ctb],
  Alexandra Kapp [ctb],
  Kearey Smith [ctb],
  Dave Vautin [ctb],
  Kyle Walker [ctb],
  Davis Vaughan [ctb],
  Ryan Rymarczyk [ctb],
  Kirill MÃ¼ller [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Flavio Poletti &lt;flavio.poletti@hotmail.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-18 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='agency_info'>Create a text listing the first <code>max_agencies</code> agencies of the feed</h2><span id='topic+agency_info'></span>

<h3>Description</h3>

<p>Create a text listing the first <code>max_agencies</code> agencies of the feed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agency_info(gtfs_obj, max_agencies = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agency_info_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="agency_info_+3A_max_agencies">max_agencies</code></td>
<td>
<p>max number of agencies to list before using &quot;...&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>called for side effects
</p>

<hr>
<h2 id='as_tidygtfs'>Convert another gtfs like object to a tidygtfs object</h2><span id='topic+as_tidygtfs'></span>

<h3>Description</h3>

<p>Convert another gtfs like object to a tidygtfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tidygtfs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tidygtfs_+3A_x">x</code></td>
<td>
<p>gtfs object</p>
</td></tr>
<tr><td><code id="as_tidygtfs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tidygtfs object
</p>

<hr>
<h2 id='cluster_stops'>Cluster nearby stops within a group</h2><span id='topic+cluster_stops'></span>

<h3>Description</h3>

<p>Finds clusters of stops for each unique value in <code>group_col</code> (e.g. stop_name). Can
be used to find different groups of stops that share the same name but are located more
than <code>max_dist</code> apart. <code>gtfs_stops</code> is assigned a new column (named <code>cluster_colname</code>)
which contains the <code>group_col</code> value and the cluster number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_stops(
  gtfs_stops,
  max_dist = 300,
  group_col = "stop_name",
  cluster_colname = "stop_name_cluster"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_stops_+3A_gtfs_stops">gtfs_stops</code></td>
<td>
<p>Stops table of a gtfs object. It is also possible to pass a
tidygtfs object to enable piping.</p>
</td></tr>
<tr><td><code id="cluster_stops_+3A_max_dist">max_dist</code></td>
<td>
<p>Only stop groups that have a maximum distance among them above this
threshold (in meters) are clustered.</p>
</td></tr>
<tr><td><code id="cluster_stops_+3A_group_col">group_col</code></td>
<td>
<p>Clusters for are calculated for each set of stops with the same value
in this column (default: stop_name)</p>
</td></tr>
<tr><td><code id="cluster_stops_+3A_cluster_colname">cluster_colname</code></td>
<td>
<p>Name of the new column name. Can be the same as group_col to overwrite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> is used for clustering.
</p>


<h3>Value</h3>

<p>Returns a stops table with an added cluster column. If <code>gtfs_stops</code> is a tidygtfs object, a
modified tidygtfs object is return
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
nyc_path &lt;- system.file("extdata", "nyc_subway.zip", package = "tidytransit")
nyc &lt;- read_gtfs(nyc_path)
nyc &lt;- cluster_stops(nyc)

# There are 6 stops with the name "86 St" that are far apart
stops_86_St = nyc$stops %&gt;% 
  filter(stop_name == "86 St")

table(stops_86_St$stop_name_cluster)

stops_86_St %&gt;% select(stop_id, stop_name, parent_station, stop_name_cluster) %&gt;% head()

library(ggplot2)
ggplot(stops_86_St) +
  geom_point(aes(stop_lon, stop_lat, color = stop_name_cluster))

</code></pre>

<hr>
<h2 id='convert_types'>Convert columns between gtfsio types to tidytransit types according to GTFS reference</h2><span id='topic+convert_types'></span>

<h3>Description</h3>

<p>Convert columns between gtfsio types to tidytransit types according to GTFS reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_types(gtfs_list, conversion_table, conversion_function)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_types_+3A_gtfs_list">gtfs_list</code></td>
<td>
<p>gtfs object</p>
</td></tr>
<tr><td><code id="convert_types_+3A_conversion_table">conversion_table</code></td>
<td>
<p>data.frame containing a column <code>file</code> and <code>Field_Name</code>, generally
from internal <code>gtfs_reference_types</code> dataset</p>
</td></tr>
<tr><td><code id="convert_types_+3A_conversion_function">conversion_function</code></td>
<td>
<p>function to convert columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gtfs_list with converted (overwritten) columns in tables
</p>

<hr>
<h2 id='duplicated_primary_keys'>Check if primary keys are unique within tables</h2><span id='topic+duplicated_primary_keys'></span>

<h3>Description</h3>

<p>Check if primary keys are unique within tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicated_primary_keys(gtfs_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="duplicated_primary_keys_+3A_gtfs_list">gtfs_list</code></td>
<td>
<p>list of tables</p>
</td></tr>
</table>

<hr>
<h2 id='empty_strings_to_na'>Convert empty strings (&quot;&quot;) to NA values in all gtfs tables</h2><span id='topic+empty_strings_to_na'></span>

<h3>Description</h3>

<p>Convert empty strings (&quot;&quot;) to NA values in all gtfs tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_strings_to_na(gtfs_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="empty_strings_to_na_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a gtfs_obj where all empty strings in tables have been replaced with NA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+na_to_empty_strings">na_to_empty_strings()</a></code>
</p>

<hr>
<h2 id='feed_contains.'>Returns TRUE if the given gtfs_obj contains the table in tidytransit's &quot;calculated
tables sublist&quot; (<code>gtfs_obj$.</code>)</h2><span id='topic+feed_contains.'></span>

<h3>Description</h3>

<p>Returns TRUE if the given gtfs_obj contains the table in tidytransit's &quot;calculated
tables sublist&quot; (<code>gtfs_obj$.</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feed_contains.(gtfs_obj, table_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feed_contains._+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="feed_contains._+3A_table_name">table_name</code></td>
<td>
<p>name of the table to look for, as string</p>
</td></tr>
</table>

<hr>
<h2 id='filter_feed_by_area'>Filter a gtfs feed so that it only contains trips that pass a given area</h2><span id='topic+filter_feed_by_area'></span>

<h3>Description</h3>

<p>Only stop_times, stops, routes, services (in calendar and calendar_dates), shapes,
frequencies and transfers belonging to one of those trips are kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_feed_by_area(gtfs_obj, area)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_feed_by_area_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="filter_feed_by_area_+3A_area">area</code></td>
<td>
<p>all trips passing through this area are kept. Either a bounding box
(numeric vector with xmin, ymin, xmax, ymax) or a sf object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidygtfs object with filtered tables
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_feed_by_stops">filter_feed_by_stops</a></code>, <code><a href="#topic+filter_feed_by_trips">filter_feed_by_trips</a></code>, <code><a href="#topic+filter_feed_by_date">filter_feed_by_date</a></code>
</p>

<hr>
<h2 id='filter_feed_by_date'>Filter a gtfs feed so that it only contains trips running on a given date</h2><span id='topic+filter_feed_by_date'></span>

<h3>Description</h3>

<p>Only stop_times, stops, routes, services (in calendar and calendar_dates), shapes,
frequencies and transfers belonging to one of those trips are kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_feed_by_date(
  gtfs_obj,
  extract_date,
  min_departure_time,
  max_arrival_time
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_feed_by_date_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="filter_feed_by_date_+3A_extract_date">extract_date</code></td>
<td>
<p>date to extract trips from this day (Date or &quot;YYYY-MM-DD&quot; string)</p>
</td></tr>
<tr><td><code id="filter_feed_by_date_+3A_min_departure_time">min_departure_time</code></td>
<td>
<p>(optional) The earliest departure time. Can be given as &quot;HH:MM:SS&quot;,
hms object or numeric value in seconds.</p>
</td></tr>
<tr><td><code id="filter_feed_by_date_+3A_max_arrival_time">max_arrival_time</code></td>
<td>
<p>(optional) The latest arrival time. Can be given as &quot;HH:MM:SS&quot;,
hms object or numeric value in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidygtfs object with filtered tables
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_stop_times">filter_stop_times</a></code>, <code><a href="#topic+filter_feed_by_trips">filter_feed_by_trips</a></code>,
<code><a href="#topic+filter_feed_by_trips">filter_feed_by_trips</a></code>, <code><a href="#topic+filter_feed_by_date">filter_feed_by_date</a></code>
</p>

<hr>
<h2 id='filter_feed_by_stops'>Filter a gtfs feed so that it only contains trips that pass the given stops</h2><span id='topic+filter_feed_by_stops'></span>

<h3>Description</h3>

<p>Only stop_times, stops, routes, services (in calendar and calendar_dates), shapes,
frequencies and transfers belonging to one of those trips are kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_feed_by_stops(gtfs_obj, stop_ids = NULL, stop_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_feed_by_stops_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="filter_feed_by_stops_+3A_stop_ids">stop_ids</code></td>
<td>
<p>vector with stop_ids. You can either provide stop_ids or stop_names</p>
</td></tr>
<tr><td><code id="filter_feed_by_stops_+3A_stop_names">stop_names</code></td>
<td>
<p>vector with stop_names (will be converted to stop_ids)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidygtfs object with filtered tables
</p>


<h3>Note</h3>

<p>The returned gtfs_obj likely contains more than just the stops given (i.e. all stops
that belong to a trip passing the initial stop).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_feed_by_trips">filter_feed_by_trips</a></code>, <code><a href="#topic+filter_feed_by_trips">filter_feed_by_trips</a></code>, <code><a href="#topic+filter_feed_by_date">filter_feed_by_date</a></code>
</p>

<hr>
<h2 id='filter_feed_by_trips'>Filter a gtfs feed so that it only contains a given set of trips</h2><span id='topic+filter_feed_by_trips'></span>

<h3>Description</h3>

<p>Only stop_times, stops, routes, services (in calendar and calendar_dates), shapes,
frequencies and transfers belonging to one of those trips are kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_feed_by_trips(gtfs_obj, trip_ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_feed_by_trips_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="filter_feed_by_trips_+3A_trip_ids">trip_ids</code></td>
<td>
<p>vector with trip_ids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidygtfs object with filtered tables
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_feed_by_stops">filter_feed_by_stops</a></code>, <code><a href="#topic+filter_feed_by_area">filter_feed_by_area</a></code>, <code><a href="#topic+filter_feed_by_date">filter_feed_by_date</a></code>
</p>

<hr>
<h2 id='filter_stop_times'>Filter a <code>stop_times</code> table for a given date and timespan.</h2><span id='topic+filter_stop_times'></span>

<h3>Description</h3>

<p>Filter a <code>stop_times</code> table for a given date and timespan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_stop_times(gtfs_obj, extract_date, min_departure_time, max_arrival_time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_stop_times_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="filter_stop_times_+3A_extract_date">extract_date</code></td>
<td>
<p>date to extract trips from this day (Date or &quot;YYYY-MM-DD&quot; string)</p>
</td></tr>
<tr><td><code id="filter_stop_times_+3A_min_departure_time">min_departure_time</code></td>
<td>
<p>(optional) The earliest departure time. Can be given as &quot;HH:MM:SS&quot;,
hms object or numeric value in seconds.</p>
</td></tr>
<tr><td><code id="filter_stop_times_+3A_max_arrival_time">max_arrival_time</code></td>
<td>
<p>(optional) The latest arrival time. Can be given as &quot;HH:MM:SS&quot;,
hms object or numeric value in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered <code>stop_times</code> data.table for <code><a href="#topic+travel_times">travel_times()</a></code> and <code><a href="#topic+raptor">raptor()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>feed_path &lt;- system.file("extdata", "routing.zip", package = "tidytransit")
g &lt;- read_gtfs(feed_path)

# filter the sample feed
stop_times &lt;- filter_stop_times(g, "2018-10-01", "06:00:00", "08:00:00")
</code></pre>

<hr>
<h2 id='filter_stops'>Get a set of stops for a given set of service ids and route ids</h2><span id='topic+filter_stops'></span>

<h3>Description</h3>

<p>Get a set of stops for a given set of service ids and route ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_stops(gtfs_obj, service_ids, route_ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_stops_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="filter_stops_+3A_service_ids">service_ids</code></td>
<td>
<p>the service for which to get stops</p>
</td></tr>
<tr><td><code id="filter_stops_+3A_route_ids">route_ids</code></td>
<td>
<p>the route_ids for which to get stops</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stops table for a given service or route
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
local_gtfs_path &lt;- system.file("extdata", "nyc_subway.zip", package = "tidytransit")
nyc &lt;- read_gtfs(local_gtfs_path)
select_service_id &lt;- filter(nyc$calendar, monday==1) %&gt;% pull(service_id)
select_route_id &lt;- sample_n(nyc$routes, 1) %&gt;% pull(route_id)
filtered_stops_df &lt;- filter_stops(nyc, select_service_id, select_route_id)

</code></pre>

<hr>
<h2 id='get_route_frequency'>Get Route Frequency</h2><span id='topic+get_route_frequency'></span>

<h3>Description</h3>

<p>Calculate the number of departures and mean headways for routes within a given timespan
and for given service_ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_route_frequency(
  gtfs_obj,
  start_time = "06:00:00",
  end_time = "22:00:00",
  service_ids = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_route_frequency_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="get_route_frequency_+3A_start_time">start_time</code></td>
<td>
<p>analysis start time, can be given as &quot;HH:MM:SS&quot;,
hms object or numeric value in seconds.</p>
</td></tr>
<tr><td><code id="get_route_frequency_+3A_end_time">end_time</code></td>
<td>
<p>analysis period end time, can be given as &quot;HH:MM:SS&quot;,
hms object or numeric value in seconds.</p>
</td></tr>
<tr><td><code id="get_route_frequency_+3A_service_ids">service_ids</code></td>
<td>
<p>A set of service_ids from the calendar dataframe
identifying a particular service id. If not provided, the service_id
with the most departures is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe of routes with variables or headway/frequency in seconds for a route
within a given time frame
</p>


<h3>Note</h3>

<p>Some GTFS feeds contain a frequency data frame already.
Consider using this instead, as it will be more accurate than what
tidytransit calculates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtfs_duke)
routes_frequency &lt;- get_route_frequency(gtfs_duke)
x &lt;- order(routes_frequency$median_headways)
head(routes_frequency[x,])
</code></pre>

<hr>
<h2 id='get_route_geometry'>Get all trip shapes for a given route and service</h2><span id='topic+get_route_geometry'></span>

<h3>Description</h3>

<p>Get all trip shapes for a given route and service
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_route_geometry(gtfs_sf_obj, route_ids = NULL, service_ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_route_geometry_+3A_gtfs_sf_obj">gtfs_sf_obj</code></td>
<td>
<p>tidytransit gtfs object with sf data frames</p>
</td></tr>
<tr><td><code id="get_route_geometry_+3A_route_ids">route_ids</code></td>
<td>
<p>routes to extract</p>
</td></tr>
<tr><td><code id="get_route_geometry_+3A_service_ids">service_ids</code></td>
<td>
<p>service_ids to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an sf dataframe for gtfs routes with a row/linestring for each trip
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtfs_duke)
gtfs_duke_sf &lt;- gtfs_as_sf(gtfs_duke)
routes_sf &lt;- get_route_geometry(gtfs_duke_sf)
plot(routes_sf[c(1,1350),])
</code></pre>

<hr>
<h2 id='get_stop_frequency'>Get Stop Frequency</h2><span id='topic+get_stop_frequency'></span>

<h3>Description</h3>

<p>Calculate the number of departures and mean headways for all stops within a
given timespan and for given service_ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stop_frequency(
  gtfs_obj,
  start_time = "06:00:00",
  end_time = "22:00:00",
  service_ids = NULL,
  by_route = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_stop_frequency_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="get_stop_frequency_+3A_start_time">start_time</code></td>
<td>
<p>analysis start time, can be given as &quot;HH:MM:SS&quot;,
hms object or numeric value in seconds.</p>
</td></tr>
<tr><td><code id="get_stop_frequency_+3A_end_time">end_time</code></td>
<td>
<p>analysis period end time, can be given as &quot;HH:MM:SS&quot;,
hms object or numeric value in seconds.</p>
</td></tr>
<tr><td><code id="get_stop_frequency_+3A_service_ids">service_ids</code></td>
<td>
<p>A set of service_ids from the calendar dataframe
identifying a particular service id. If not provided, the service_id
with the most departures is used.</p>
</td></tr>
<tr><td><code id="get_stop_frequency_+3A_by_route">by_route</code></td>
<td>
<p>Default TRUE, if FALSE then calculate headway for any line coming
through the stop in the same direction on the same schedule.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe of stops with the number of departures and the headway
(departures divided by timespan) in seconds as columns
</p>


<h3>Note</h3>

<p>Some GTFS feeds contain a frequency data frame already.
Consider using this instead, as it will be more accurate than what
tidytransit calculates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtfs_duke)
stop_frequency &lt;- get_stop_frequency(gtfs_duke)
x &lt;- order(stop_frequency$mean_headway)
head(stop_frequency[x,])
</code></pre>

<hr>
<h2 id='get_trip_geometry'>Get all trip shapes for given trip ids</h2><span id='topic+get_trip_geometry'></span>

<h3>Description</h3>

<p>Get all trip shapes for given trip ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trip_geometry(gtfs_sf_obj, trip_ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_trip_geometry_+3A_gtfs_sf_obj">gtfs_sf_obj</code></td>
<td>
<p>tidytransit gtfs object with sf data frames</p>
</td></tr>
<tr><td><code id="get_trip_geometry_+3A_trip_ids">trip_ids</code></td>
<td>
<p>trip_ids to extract shapes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an sf dataframe for gtfs routes with a row/linestring for each trip
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtfs_duke)
gtfs_duke &lt;- gtfs_as_sf(gtfs_duke)
trips_sf &lt;- get_trip_geometry(gtfs_duke, c("t_726295_b_19493_tn_41", "t_726295_b_19493_tn_40"))
plot(trips_sf[1,"shape_id"])
</code></pre>

<hr>
<h2 id='gtfs_as_sf'>Convert stops and shapes to Simple Features</h2><span id='topic+gtfs_as_sf'></span>

<h3>Description</h3>

<p>Stops are converted to POINT sf data frames. Shapes are converted to a
LINESTRING data frame. Note that this function replaces stops and shapes
tables in <code>gtfs_obj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtfs_as_sf(gtfs_obj, skip_shapes = FALSE, crs = NULL, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtfs_as_sf_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object, created by <code><a href="#topic+read_gtfs">read_gtfs()</a></code>)</p>
</td></tr>
<tr><td><code id="gtfs_as_sf_+3A_skip_shapes">skip_shapes</code></td>
<td>
<p>if TRUE, shapes are not converted. Default FALSE.</p>
</td></tr>
<tr><td><code id="gtfs_as_sf_+3A_crs">crs</code></td>
<td>
<p>optional coordinate reference system (used by sf::st_transform) to transform
lon/lat coordinates of stops and shapes</p>
</td></tr>
<tr><td><code id="gtfs_as_sf_+3A_quiet">quiet</code></td>
<td>
<p>boolean whether to print status messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidygtfs object with stops and shapes as sf dataframes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sf_as_tbl">sf_as_tbl</a></code>, <code><a href="#topic+stops_as_sf">stops_as_sf</a></code>, <code><a href="#topic+shapes_as_sf">shapes_as_sf</a></code>
</p>

<hr>
<h2 id='gtfs_duke'>Example GTFS data</h2><span id='topic+gtfs_duke'></span>

<h3>Description</h3>

<p>Data obtained from
<a href="https://data.trilliumtransit.com/gtfs/duke-nc-us/duke-nc-us.zip">https://data.trilliumtransit.com/gtfs/duke-nc-us/duke-nc-us.zip</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtfs_duke
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tidygtfs</code> (inherits from <code>gtfs</code>) of length 25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_gtfs">read_gtfs()</a></code>
</p>

<hr>
<h2 id='gtfs_to_tidygtfs'>Convert an object created by gtfsio::import_gtfs to a tidygtfs object</h2><span id='topic+gtfs_to_tidygtfs'></span>

<h3>Description</h3>

<p>Some basic validation is done to ensure the feed works in tidytransit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtfs_to_tidygtfs(gtfs_list, files = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtfs_to_tidygtfs_+3A_gtfs_list">gtfs_list</code></td>
<td>
<p>list of tables</p>
</td></tr>
<tr><td><code id="gtfs_to_tidygtfs_+3A_files">files</code></td>
<td>
<p>subset of files to validate</p>
</td></tr>
</table>

<hr>
<h2 id='gtfs_transform'>Transform coordinates of a gtfs feed</h2><span id='topic+gtfs_transform'></span>

<h3>Description</h3>

<p>Transform coordinates of a gtfs feed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtfs_transform(gtfs_obj, crs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtfs_transform_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="gtfs_transform_+3A_crs">crs</code></td>
<td>
<p>target coordinate reference system, used by sf::st_transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidygtfs object with transformed stops and shapes sf dataframes
</p>
<p>gtfs object with transformed sf tables
</p>

<hr>
<h2 id='hhmmss_to_hms'>Convert &quot;HH:MM:SS&quot; time strings to hms values
empty strings are converted to NA</h2><span id='topic+hhmmss_to_hms'></span>

<h3>Description</h3>

<p>Convert &quot;HH:MM:SS&quot; time strings to hms values
empty strings are converted to NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hhmmss_to_hms(time_strings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hhmmss_to_hms_+3A_time_strings">time_strings</code></td>
<td>
<p>char vector (&quot;HH:MM:SS&quot;)</p>
</td></tr>
</table>

<hr>
<h2 id='hhmmss_to_sec_split'>Fallback function to convert strings like 5:02:11
10x slower than <code><a href="#topic+hhmmss_to_seconds">hhmmss_to_seconds()</a></code>, empty strings are converted to NA</h2><span id='topic+hhmmss_to_sec_split'></span>

<h3>Description</h3>

<p>Fallback function to convert strings like 5:02:11
10x slower than <code><a href="#topic+hhmmss_to_seconds">hhmmss_to_seconds()</a></code>, empty strings are converted to NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hhmmss_to_sec_split(hhmmss_str)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hhmmss_to_sec_split_+3A_hhmmss_str">hhmmss_str</code></td>
<td>
<p>string</p>
</td></tr>
</table>

<hr>
<h2 id='hhmmss_to_seconds'>Convert &quot;HH:MM:SS&quot; time strings to seconds (numeric)
empty strings are converted to NA</h2><span id='topic+hhmmss_to_seconds'></span>

<h3>Description</h3>

<p>Convert &quot;HH:MM:SS&quot; time strings to seconds (numeric)
empty strings are converted to NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hhmmss_to_seconds(hhmmss_str)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hhmmss_to_seconds_+3A_hhmmss_str">hhmmss_str</code></td>
<td>
<p>char vector (&quot;HH:MM:SS&quot;)</p>
</td></tr>
</table>

<hr>
<h2 id='interpolate_stop_times'>Interpolate missing stop_times linearly</h2><span id='topic+interpolate_stop_times'></span>

<h3>Description</h3>

<p>Interpolate missing stop_times linearly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_stop_times(x, use_shape_dist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate_stop_times_+3A_x">x</code></td>
<td>
<p>tidygtfs object or stop_times table</p>
</td></tr>
<tr><td><code id="interpolate_stop_times_+3A_use_shape_dist">use_shape_dist</code></td>
<td>
<p>If TRUE, use <code>shape_dist_traveled</code> column from the shapes table for
time interpolation (if that column is available). If FALSE or
<code>shape_dist_traveled</code> is missing, times are interpolated equally
between stops.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidygtfs or stop_times with interpolated arrival and departure times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(gtfs_duke)
print(gtfs_duke$stop_times[1:5, 1:5])

gtfs_duke_2 = interpolate_stop_times(gtfs_duke)
print(gtfs_duke_2$stop_times[1:5, 1:5])

gtfs_duke_3 = interpolate_stop_times(gtfs_duke, FALSE)
print(gtfs_duke_3$stop_times[1:5, 1:5])

## End(Not run)
</code></pre>

<hr>
<h2 id='json_to_sf'>Convert a json (read with jsonlite) to sf object</h2><span id='topic+json_to_sf'></span>

<h3>Description</h3>

<p>The json object is written to a temporary file and re-read with sf::read().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_to_sf(json_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="json_to_sf_+3A_json_list">json_list</code></td>
<td>
<p>list as read by jsonlite::read_json (in gtfsio)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sf object
</p>

<hr>
<h2 id='na_to_empty_strings'>Convert NA values to empty strings (&quot;&quot;)</h2><span id='topic+na_to_empty_strings'></span>

<h3>Description</h3>

<p>Convert NA values to empty strings (&quot;&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_to_empty_strings(gtfs_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na_to_empty_strings_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a gtfs_obj where all NA strings in tables have been replaced with &quot;&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empty_strings_to_na">empty_strings_to_na()</a></code>
</p>

<hr>
<h2 id='plot.tidygtfs'>Plot GTFS stops and trips</h2><span id='topic+plot.tidygtfs'></span>

<h3>Description</h3>

<p>Plot GTFS stops and trips
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidygtfs'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tidygtfs_+3A_x">x</code></td>
<td>
<p>a tidygtfs object as read by <code><a href="#topic+read_gtfs">read_gtfs()</a></code></p>
</td></tr>
<tr><td><code id="plot.tidygtfs_+3A_...">...</code></td>
<td>
<p>ignored for tidygtfs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
local_gtfs_path &lt;- system.file("extdata",
                              "nyc_subway.zip",
                              package = "tidytransit")
nyc &lt;- read_gtfs(local_gtfs_path)
plot(nyc)


</code></pre>

<hr>
<h2 id='print.tidygtfs'>Print a GTFS object</h2><span id='topic+print.tidygtfs'></span>

<h3>Description</h3>

<p>Prints a GTFS object suppressing the <code>class</code> attribute and hiding the
validation_result attribute, created with <code><a href="#topic+validate_gtfs">validate_gtfs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidygtfs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tidygtfs_+3A_x">x</code></td>
<td>
<p>a tidygtfs object as read by <code><a href="#topic+read_gtfs">read_gtfs()</a></code></p>
</td></tr>
<tr><td><code id="print.tidygtfs_+3A_...">...</code></td>
<td>
<p>Optional arguments ultimately passed to <code>format</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The GTFS object that was printed, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
path = system.file("extdata", 
           "nyc_subway.zip", 
           package = "tidytransit")

g = read_gtfs(path)
print(g)

## End(Not run)
</code></pre>

<hr>
<h2 id='raptor'>Calculate travel times from one stop to all reachable stops</h2><span id='topic+raptor'></span>

<h3>Description</h3>

<p><code>raptor</code> finds the minimal travel time, earliest or latest arrival time for all
stops in <code>stop_times</code> with journeys departing from <code>stop_ids</code> within
<code>time_range</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raptor(
  stop_times,
  transfers,
  stop_ids,
  arrival = FALSE,
  time_range = 3600,
  max_transfers = NULL,
  keep = "all"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raptor_+3A_stop_times">stop_times</code></td>
<td>
<p>A (prepared) stop_times table from a gtfs feed. Prepared means
that all stop time rows before the desired journey departure time
should be removed. The table should also only include departures
happening on one day. Use <code><a href="#topic+filter_stop_times">filter_stop_times()</a></code> for easier preparation.</p>
</td></tr>
<tr><td><code id="raptor_+3A_transfers">transfers</code></td>
<td>
<p>Transfers table from a gtfs feed. In general no preparation
is needed. Can be omitted if stop_times has been prepared with
<code><a href="#topic+filter_stop_times">filter_stop_times()</a></code>.</p>
</td></tr>
<tr><td><code id="raptor_+3A_stop_ids">stop_ids</code></td>
<td>
<p>Character vector with stop_ids from where journeys should start (or end).
It is recommended to only use stop_ids that are related to each other,
like different platforms in a train station or bus stops that are
reasonably close to each other.</p>
</td></tr>
<tr><td><code id="raptor_+3A_arrival">arrival</code></td>
<td>
<p>If FALSE (default), all journeys <em>start</em> from <code>stop_ids</code>. If
TRUE, all journeys <em>end</em> at <code>stop_ids</code>.</p>
</td></tr>
<tr><td><code id="raptor_+3A_time_range">time_range</code></td>
<td>
<p>Either a range in seconds or a vector containing the minimal and maximal
departure time (i.e. earliest and latest possible journey departure time)
as seconds or &quot;HH:MM:SS&quot; character. If <code>arrival</code> is TRUE, <code>time_range</code>
describes the time window when journeys should end at <code>stop_ids</code>.</p>
</td></tr>
<tr><td><code id="raptor_+3A_max_transfers">max_transfers</code></td>
<td>
<p>Maximum number of transfers allowed, no limit (NULL) as default.</p>
</td></tr>
<tr><td><code id="raptor_+3A_keep">keep</code></td>
<td>
<p>One of c(&quot;all&quot;, &quot;shortest&quot;, &quot;earliest&quot;, &quot;latest&quot;). By default, <code>all</code> journeys
between stop_ids are returned. With <code>shortest</code> only the journey with the
shortest travel time is returned. With <code>earliest</code> the journey arriving at a
stop the earliest is returned, <code>latest</code> works accordingly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a modified <a href="https://www.microsoft.com/en-us/research/publication/round-based-public-transit-routing/">Round-Based Public Transit Routing Algorithm</a>
(RAPTOR) using data.table, earliest arrival times for all stops are calculated. If two
journeys arrive at the same time, the one with the later departure time and thus shorter
travel time is kept. By default, all journeys departing within <code>time_range</code> that arrive
at a stop are returned in a table. If you want all journeys <em>arriving</em> at stop_ids within
the specified time range, set <code>arrival</code> to TRUE.
</p>
<p>Journeys are defined by a &quot;from&quot; and &quot;to&quot; stop_id, a departure, arrival and travel time.
Note that exact journeys (with each intermediate stop and route ids for example) are
<em>not</em> returned.
</p>
<p>For most cases, <code>stop_times</code> needs to be filtered, as it should only contain trips
happening on a single day, see <code><a href="#topic+filter_stop_times">filter_stop_times()</a></code>. The algorithm scans all trips
until it exceeds <code>max_transfers</code> or all trips in <code>stop_times</code> have been visited.
</p>


<h3>Value</h3>

<p>A data.table with journeys (departure, arrival and travel time) to/from all
stop_ids reachable by <code>stop_ids</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+travel_times">travel_times()</a></code> for an easier access to travel time calculations via stop_names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nyc_path &lt;- system.file("extdata", "nyc_subway.zip", package = "tidytransit")
nyc &lt;- read_gtfs(nyc_path)

# you can use initial walk times to different stops in walking distance (arbitrary example values)
stop_ids_harlem_st &lt;- c("301", "301N", "301S")
stop_ids_155_st &lt;- c("A11", "A11N", "A11S", "D12", "D12N", "D12S")
walk_times &lt;- data.frame(stop_id = c(stop_ids_harlem_st, stop_ids_155_st),
                         walk_time = c(rep(600, 3), rep(410, 6)), stringsAsFactors = FALSE)

# Use journeys departing after 7 AM with arrival time before 11 AM on 26th of June
stop_times &lt;- filter_stop_times(nyc, "2018-06-26", 7*3600, 9*3600)

# calculate all journeys departing from Harlem St or 155 St between 7:00 and 7:30
rptr &lt;- raptor(stop_times, nyc$transfers, walk_times$stop_id, time_range = 1800,
               keep = "all")

# add walk times to travel times
rptr &lt;- merge(rptr, walk_times, by.x = "from_stop_id", by.y = "stop_id")
rptr$travel_time_incl_walk &lt;- rptr$travel_time + rptr$walk_time

# get minimal travel times (with walk times) for all stop_ids
library(data.table)
shortest_travel_times &lt;- setDT(rptr)[order(travel_time_incl_walk)][, .SD[1], by = "to_stop_id"]
hist(shortest_travel_times$travel_time, breaks = seq(0,2*60)*60)

</code></pre>

<hr>
<h2 id='read_gtfs'>Read and validate GTFS files</h2><span id='topic+read_gtfs'></span>

<h3>Description</h3>

<p>Reads a GTFS feed from either a local <code>.zip</code> file or an URL and validates them against
GTFS specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gtfs(path, files = NULL, quiet = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_gtfs_+3A_path">path</code></td>
<td>
<p>The path to a GTFS <code>.zip</code> file.</p>
</td></tr>
<tr><td><code id="read_gtfs_+3A_files">files</code></td>
<td>
<p>A character vector containing the text files to be validated against the GTFS
specification without the file extension (<code>txt</code> or <code>geojson</code>). If <code>NULL</code> (the default),
all existing files are read.</p>
</td></tr>
<tr><td><code id="read_gtfs_+3A_quiet">quiet</code></td>
<td>
<p>Whether to hide log messages and progress bars (defaults to TRUE).</p>
</td></tr>
<tr><td><code id="read_gtfs_+3A_...">...</code></td>
<td>
<p>Can be used to pass on arguments to <code><a href="gtfsio.html#topic+import_gtfs">gtfsio::import_gtfs()</a></code>. The parameters
<code>files</code> and <code>quiet</code> are passed on by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidygtfs object: a list of tibbles in which each entry represents a GTFS text
file. Additional tables are stored in the <code>.</code> sublist.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+validate_gtfs">validate_gtfs()</a></code>, <code><a href="#topic+write_gtfs">write_gtfs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
local_gtfs_path &lt;- system.file("extdata", "nyc_subway.zip", package = "tidytransit")
gtfs &lt;- read_gtfs(local_gtfs_path)
summary(gtfs)

gtfs &lt;- read_gtfs(local_gtfs_path, files = c("trips", "stop_times"))
names(gtfs)

## End(Not run)
</code></pre>

<hr>
<h2 id='route_type_names'>Dataframe of route type id's and the names of the types (e.g. &quot;Bus&quot;)</h2><span id='topic+route_type_names'></span>

<h3>Description</h3>

<p>Extended GTFS Route Types: https://developers.google.com/transit/gtfs/reference/extended-route-types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_type_names
</code></pre>


<h3>Format</h3>

<p>A data frame with 136 rows and 2 variables:
</p>

<dl>
<dt>route_type</dt><dd><p>the id of route type</p>
</dd>
<dt>route_type_name</dt><dd><p>name of the gtfs route type</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://gist.github.com/derhuerst/b0243339e22c310bee2386388151e11e">https://gist.github.com/derhuerst/b0243339e22c310bee2386388151e11e</a>
</p>

<hr>
<h2 id='set_dates_services'>Returns all possible date/service_id combinations as a data frame</h2><span id='topic+set_dates_services'></span>

<h3>Description</h3>

<p>Returns all possible date/service_id combinations as a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_dates_services(gtfs_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_dates_services_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a date_service data frame
</p>

<hr>
<h2 id='set_servicepattern'>Calculate service pattern ids for a GTFS feed</h2><span id='topic+set_servicepattern'></span>

<h3>Description</h3>

<p>Each trip has a defined number of dates it runs on. This set of dates is called a
service pattern in tidytransit. Trips with the same <code>servicepattern</code> id run on the same
dates. In general, <code>service_id</code> can work this way but it is not enforced by the
GTFS standard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_servicepattern(
  gtfs_obj,
  id_prefix = "s_",
  hash_algo = "md5",
  hash_length = 7
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_servicepattern_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="set_servicepattern_+3A_id_prefix">id_prefix</code></td>
<td>
<p>all servicepattern ids will start with this string</p>
</td></tr>
<tr><td><code id="set_servicepattern_+3A_hash_algo">hash_algo</code></td>
<td>
<p>hashing algorithm used by digest</p>
</td></tr>
<tr><td><code id="set_servicepattern_+3A_hash_length">hash_length</code></td>
<td>
<p>length the hash should be cut to with <code>substr()</code>. Use <code>-1</code> if the full
hash should be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified gtfs_obj with added servicepattern list and a table linking
trips and pattern (trip_servicepatterns), added to <code>gtfs_obj$.</code> sublist.
</p>

<hr>
<h2 id='sf_as_tbl'>Convert stops and shapes from sf objects to tibbles</h2><span id='topic+sf_as_tbl'></span>

<h3>Description</h3>

<p>Coordinates are transformed to lon/lat columns (<code>stop_lon</code>/<code>stop_lat</code> or
<code>shape_pt_lon</code>/<code>shape_pt_lat</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_as_tbl(gtfs_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_as_tbl_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidygtfs object with stops and shapes converted to tibbles
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtfs_as_sf">gtfs_as_sf</a></code>
</p>

<hr>
<h2 id='sf_lines_to_df'>Adds the coordinates of an sf LINESTRING object as columns and rows</h2><span id='topic+sf_lines_to_df'></span>

<h3>Description</h3>

<p>Adds the coordinates of an sf LINESTRING object as columns and rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_lines_to_df(
  lines_sf,
  coord_colnames = c("shape_pt_lon", "shape_pt_lat"),
  remove_geometry = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_lines_to_df_+3A_lines_sf">lines_sf</code></td>
<td>
<p>sf object</p>
</td></tr>
<tr><td><code id="sf_lines_to_df_+3A_coord_colnames">coord_colnames</code></td>
<td>
<p>names of the new columns (existing columns are overwritten)</p>
</td></tr>
<tr><td><code id="sf_lines_to_df_+3A_remove_geometry">remove_geometry</code></td>
<td>
<p>remove sf geometry column?</p>
</td></tr>
</table>

<hr>
<h2 id='sf_points_to_df'>Adds the coordinates of an sf POINT object as columns</h2><span id='topic+sf_points_to_df'></span>

<h3>Description</h3>

<p>Adds the coordinates of an sf POINT object as columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_points_to_df(
  pts_sf,
  coord_colnames = c("stop_lon", "stop_lat"),
  remove_geometry = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_points_to_df_+3A_pts_sf">pts_sf</code></td>
<td>
<p>sf object</p>
</td></tr>
<tr><td><code id="sf_points_to_df_+3A_coord_colnames">coord_colnames</code></td>
<td>
<p>names of the new columns (existing columns are overwritten)</p>
</td></tr>
<tr><td><code id="sf_points_to_df_+3A_remove_geometry">remove_geometry</code></td>
<td>
<p>remove sf geometry column?</p>
</td></tr>
</table>

<hr>
<h2 id='sf_to_json'>Convert an sf object to a json list</h2><span id='topic+sf_to_json'></span>

<h3>Description</h3>

<p>The sf object is written to a temporary file and re-read with jsonlite::read_json().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_to_json(sf_obj, layer_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf_to_json_+3A_sf_obj">sf_obj</code></td>
<td>
<p>sf table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>json list
</p>

<hr>
<h2 id='shape_as_sf_linestring'>return an sf linestring with lat and long from gtfs</h2><span id='topic+shape_as_sf_linestring'></span>

<h3>Description</h3>

<p>return an sf linestring with lat and long from gtfs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape_as_sf_linestring(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape_as_sf_linestring_+3A_df">df</code></td>
<td>
<p>dataframe from the gtfs shapes split() on shape_id</p>
</td></tr>
</table>


<h3>Value</h3>

<p>st_linestring (sfr) object
</p>

<hr>
<h2 id='shapes_as_sf'>Convert shapes into Simple Features Linestrings</h2><span id='topic+shapes_as_sf'></span>

<h3>Description</h3>

<p>Convert shapes into Simple Features Linestrings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapes_as_sf(gtfs_shapes, crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shapes_as_sf_+3A_gtfs_shapes">gtfs_shapes</code></td>
<td>
<p>a gtfs$shapes dataframe</p>
</td></tr>
<tr><td><code id="shapes_as_sf_+3A_crs">crs</code></td>
<td>
<p>optional coordinate reference system (used by sf::st_transform) to transform
lon/lat coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an sf dataframe for gtfs shapes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtfs_as_sf">gtfs_as_sf</a></code>
</p>

<hr>
<h2 id='stop_distances'>Calculate distances between a given set of stops</h2><span id='topic+stop_distances'></span>

<h3>Description</h3>

<p>Calculate distances between a given set of stops
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_distances(gtfs_stops)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_distances_+3A_gtfs_stops">gtfs_stops</code></td>
<td>
<p>gtfs stops table either as data frame (with at least <code>stop_id</code>,
<code>stop_lon</code> and <code>stop_lat</code> columns) or as <code>sf</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with each row containing a pair of stop_ids (columns
<code>from_stop_id</code> and <code>to_stop_id</code>) and the <code>distance</code> between them (in meters)
</p>


<h3>Note</h3>

<p>The resulting data.frame has <code>nrow(gtfs_stops)^2</code> rows, distances calculations
among all stops for large feeds should be avoided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)

nyc_path &lt;- system.file("extdata", "nyc_subway.zip", package = "tidytransit")
nyc &lt;- read_gtfs(nyc_path)

nyc$stops %&gt;%
  filter(stop_name == "Borough Hall") %&gt;%
  stop_distances() %&gt;%
  arrange(desc(distance))

#&gt; # A tibble: 36 Ã 3
#&gt;    from_stop_id to_stop_id  distance
#&gt;    &lt;chr&gt;        &lt;chr&gt;          &lt;dbl&gt;
#&gt;  1 423          232             91.5
#&gt;  2 423N         232             91.5
#&gt;  3 423S         232             91.5
#&gt;  4 423          232N            91.5
#&gt;  5 423N         232N            91.5
#&gt;  6 423S         232N            91.5
#&gt;  7 423          232S            91.5
#&gt;  8 423N         232S            91.5
#&gt;  9 423S         232S            91.5
#&gt; 10 232          423             91.5
#&gt; # â¦ with 26 more rows

## End(Not run)
</code></pre>

<hr>
<h2 id='stop_group_distances'>Calculates distances among stop within the same group column</h2><span id='topic+stop_group_distances'></span>

<h3>Description</h3>

<p>By default calculates distances among stop_ids with the same stop_name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_group_distances(gtfs_stops, by = "stop_name")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_group_distances_+3A_gtfs_stops">gtfs_stops</code></td>
<td>
<p>gtfs stops table either as data frame (with at least <code>stop_id</code>,
<code>stop_lon</code> and <code>stop_lat</code> columns) or as <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="stop_group_distances_+3A_by">by</code></td>
<td>
<p>group column, default: &quot;stop_name&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with one row per group containing a distance matrix (distances),
number of stop ids within that group (n_stop_ids) and distance summary values
(dist_mean, dist_median and dist_max).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)

nyc_path &lt;- system.file("extdata", "nyc_subway.zip", package = "tidytransit")
nyc &lt;- read_gtfs(nyc_path)

stop_group_distances(nyc$stops)
#&gt; # A tibble: 380 Ã 6
#&gt;    stop_name   distances       n_stop_ids dist_mean dist_median dist_max
#&gt;    &lt;chr&gt;       &lt;list&gt;               &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;
#&gt;  1 86 St       &lt;dbl [18 Ã 18]&gt;         18     5395.       5395.   21811.
#&gt;  2 79 St       &lt;dbl [6 Ã 6]&gt;            6    19053.      19053.   19053.
#&gt;  3 Prospect Av &lt;dbl [6 Ã 6]&gt;            6    18804.      18804.   18804.
#&gt;  4 77 St       &lt;dbl [6 Ã 6]&gt;            6    16947.      16947.   16947.
#&gt;  5 59 St       &lt;dbl [6 Ã 6]&gt;            6    14130.      14130.   14130.
#&gt;  6 50 St       &lt;dbl [9 Ã 9]&gt;            9     7097.       7097.   14068.
#&gt;  7 36 St       &lt;dbl [6 Ã 6]&gt;            6    12496.      12496.   12496.
#&gt;  8 8 Av        &lt;dbl [6 Ã 6]&gt;            6    11682.      11682.   11682.
#&gt;  9 7 Av        &lt;dbl [9 Ã 9]&gt;            9     5479.       5479.   10753.
#&gt; 10 111 St      &lt;dbl [9 Ã 9]&gt;            9     3877.       3877.    7753.
#&gt; # â¦ with 370 more rows

## End(Not run)
</code></pre>

<hr>
<h2 id='stops_as_sf'>Convert stops into Simple Features Points</h2><span id='topic+stops_as_sf'></span>

<h3>Description</h3>

<p>Convert stops into Simple Features Points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stops_as_sf(stops, crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stops_as_sf_+3A_stops">stops</code></td>
<td>
<p>a gtfs$stops dataframe</p>
</td></tr>
<tr><td><code id="stops_as_sf_+3A_crs">crs</code></td>
<td>
<p>optional coordinate reference system (used by sf::st_transform) to transform
lon/lat coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an sf dataframe for gtfs routes with a point column
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtfs_as_sf">gtfs_as_sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtfs_duke)
some_stops &lt;- gtfs_duke$stops[sample(nrow(gtfs_duke$stops), 40),]
some_stops_sf &lt;- stops_as_sf(some_stops)
plot(some_stops_sf[,"stop_name"])
</code></pre>

<hr>
<h2 id='summary.tidygtfs'>GTFS feed summary</h2><span id='topic+summary.tidygtfs'></span>

<h3>Description</h3>

<p>GTFS feed summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidygtfs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tidygtfs_+3A_object">object</code></td>
<td>
<p>a tidygtfs object as read by <code><a href="#topic+read_gtfs">read_gtfs()</a></code></p>
</td></tr>
<tr><td><code id="summary.tidygtfs_+3A_...">...</code></td>
<td>
<p>ignored for tidygtfs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the tidygtfs object, invisibly
</p>

<hr>
<h2 id='tidygtfs_to_gtfs'>Convert a tidygtfs object to a gtfs object (for gtfsio)</h2><span id='topic+tidygtfs_to_gtfs'></span>

<h3>Description</h3>

<p>Convert a tidygtfs object to a gtfs object (for gtfsio)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidygtfs_to_gtfs(gtfs_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidygtfs_to_gtfs_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gtfs list
</p>

<hr>
<h2 id='travel_times'>Calculate shortest travel times from a stop to all reachable stops</h2><span id='topic+travel_times'></span>

<h3>Description</h3>

<p>Function to calculate the shortest travel times from a stop (given by <code>stop_name</code>)
to all other stop_names of a feed. <code>filtered_stop_times</code> needs to be created before with
<code><a href="#topic+filter_stop_times">filter_stop_times()</a></code> or <code><a href="#topic+filter_feed_by_date">filter_feed_by_date()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>travel_times(
  filtered_stop_times,
  stop_name,
  time_range = 3600,
  arrival = FALSE,
  max_transfers = NULL,
  max_departure_time = NULL,
  return_coords = FALSE,
  return_DT = FALSE,
  stop_dist_check = 300
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="travel_times_+3A_filtered_stop_times">filtered_stop_times</code></td>
<td>
<p>stop_times data.table (with transfers and stops tables as
attributes) created with <code><a href="#topic+filter_stop_times">filter_stop_times()</a></code> where the
departure or arrival time has been set.</p>
</td></tr>
<tr><td><code id="travel_times_+3A_stop_name">stop_name</code></td>
<td>
<p>Stop name for which travel times should be calculated. A vector with
multiple names can be used.</p>
</td></tr>
<tr><td><code id="travel_times_+3A_time_range">time_range</code></td>
<td>
<p>Either a range in seconds or a vector containing the minimal and maximal
departure time (i.e. earliest and latest possible journey departure time)
as seconds or &quot;HH:MM:SS&quot; character. If <code>arrival</code> is TRUE, <code>time_range</code>
describes the time window when journeys should end at <code>stop_name</code>.</p>
</td></tr>
<tr><td><code id="travel_times_+3A_arrival">arrival</code></td>
<td>
<p>If FALSE (default), all journeys <em>start</em> from <code>stop_name</code>. If
TRUE, all journeys <em>end</em> at <code>stop_name</code>.</p>
</td></tr>
<tr><td><code id="travel_times_+3A_max_transfers">max_transfers</code></td>
<td>
<p>The maximum number of transfers. No limit if <code>NULL</code></p>
</td></tr>
<tr><td><code id="travel_times_+3A_max_departure_time">max_departure_time</code></td>
<td>
<p>Deprecated. Use <code>time_range</code> to set the latest
possible departure time.</p>
</td></tr>
<tr><td><code id="travel_times_+3A_return_coords">return_coords</code></td>
<td>
<p>Returns stop coordinates (lon/lat) as columns. Default is FALSE.</p>
</td></tr>
<tr><td><code id="travel_times_+3A_return_dt">return_DT</code></td>
<td>
<p>travel_times() returns a data.table if TRUE. Default is FALSE which
returns a <code>tibble/tbl_df</code>.</p>
</td></tr>
<tr><td><code id="travel_times_+3A_stop_dist_check">stop_dist_check</code></td>
<td>
<p>stop_names are not structured identifiers like
stop_ids or parent_stations, so it's possible that
stops with the same name are far apart. travel_times()
errors if the distance among stop_ids with the same name is
above this threshold (in meters).
Use FALSE to turn check off. However, it is recommended to
either use <code><a href="#topic+raptor">raptor()</a></code> or fix the feed (see <code><a href="#topic+cluster_stops">cluster_stops()</a></code>)
in case of warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows easier access to <code><a href="#topic+raptor">raptor()</a></code> by using stop names instead of ids and
returning shortest travel times by default.
</p>
<p>Note however that stop_name might not be a suitable identifier for a feed. It is possible
that multiple stops have the same name while not being related or geographically close to
each other. <code><a href="#topic+stop_group_distances">stop_group_distances()</a></code> and <code><a href="#topic+cluster_stops">cluster_stops()</a></code> can help identify and fix
issues with stop_names.
</p>


<h3>Value</h3>

<p>A table with travel times to/from all stops reachable by <code>stop_name</code> and their
corresponding journey departure and arrival times.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# 1) Calculate travel times from two closely related stops
# The example dataset gtfs_duke has missing times (allowed in gtfs) which is
# why we run interpolate_stop_times beforehand
gtfs = interpolate_stop_times(gtfs_duke)

tts1 = gtfs %&gt;%
  filter_feed_by_date("2019-08-26") %&gt;%
  travel_times(c("Campus Dr at Arts Annex (WB)", "Campus Dr at Arts Annex (EB)"),
               time_range = c("14:00:00", "15:30:00"))

# you can use either filter_feed_by_date or filter_stop_times to prepare the feed
# the result is the same
tts2 = gtfs %&gt;%
 filter_stop_times("2019-08-26", "14:00:00") %&gt;%
 travel_times(c("Campus Dr at Arts Annex (WB)", "Campus Dr at Arts Annex (EB)"),
              time_range = 1.5*3600) # 1.5h after 14:00

all(tts1 == tts2)
# It's recommended to store the filtered feed, since it can be time consuming to
# run it for every travel time calculation, see the next example steps

# 2) separate filtering and travel time calculation for a more granular analysis
# stop_names in this feed are not restricted to an area, create clusters of stops to fix
nyc_path &lt;- system.file("extdata", "nyc_subway.zip", package = "tidytransit")
nyc &lt;- read_gtfs(nyc_path)
nyc &lt;- cluster_stops(nyc, group_col = "stop_name", cluster_colname = "stop_name")

# Use journeys departing after 7 AM with arrival time before 9 AM on 26th June
stop_times &lt;- filter_stop_times(nyc, "2018-06-26", 7*3600, 9*3600)

# Calculate travel times from "34 St - Herald Sq"
tts &lt;- travel_times(stop_times, "34 St - Herald Sq", return_coords = TRUE)

# only keep journeys under one hour for plotting
tts &lt;- tts %&gt;% filter(travel_time &lt;= 3600)

# travel time to Queensboro Plaza is 810 seconds, 13:30 minutes
tts %&gt;%
  filter(to_stop_name == "Queensboro Plaza") %&gt;%
  mutate(travel_time = hms::hms(travel_time))

# plot a simple map showing travel times to all reachable stops
# this can be expanded to isochron maps
library(ggplot2)
ggplot(tts) + geom_point(aes(x=to_stop_lon, y=to_stop_lat, color = travel_time))

</code></pre>

<hr>
<h2 id='validate_gtfs'>Validate GTFS feed</h2><span id='topic+validate_gtfs'></span>

<h3>Description</h3>

<p>Validates the GTFS object against GTFS specifications and raises warnings if
required files/fields are not found. This function is called in <code><a href="#topic+read_gtfs">read_gtfs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_gtfs(gtfs_obj, files = NULL, warnings = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_gtfs_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs object (i.e. a list of tables, not necessary a tidygtfs object)</p>
</td></tr>
<tr><td><code id="validate_gtfs_+3A_files">files</code></td>
<td>
<p>A character vector containing the text files to be validated
against the GTFS specification without the file extension (<code>txt</code> or <code>geojson</code>). If
<code>NULL</code> (the default), the provided GTFS feed is validated against all
possible GTFS text files.</p>
</td></tr>
<tr><td><code id="validate_gtfs_+3A_warnings">warnings</code></td>
<td>
<p>Whether to display warning messages (defaults to <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function just checks if required files or fields are missing. There's no
validation for internal consistency (e.g. no departure times before arrival times or
calendar covering a reasonable period).
</p>


<h3>Value</h3>

<p>A <code>validation_result</code> tibble containing the validation summary of all
possible fields from the specified files.
</p>


<h3>Details</h3>

<p>GTFS object's files and fields are validated against the GTFS specifications
as documented in <a href="https://gtfs.org/documentation/schedule/reference/">
GTFS Schedule Reference</a>:
</p>

<ul>
<li><p> GTFS feeds are considered valid if they include all required files
and fields. If a required file/field is missing the function (optionally)
raises a warning.
</p>
</li>
<li><p> Optional files/fields are listed in the reference above but are not
required, thus no warning is raised if they are missing.
</p>
</li>
<li><p> Extra files/fields are those who are not listed in the reference
above (either because they refer to a specific GTFS extension or due to
any other reason).
</p>
</li></ul>

<p>Note that some files (<code>calendar.txt</code>, <code>calendar_dates.txt</code> and
<code>feed_info.txt</code>) are conditionally required. This means that:
</p>

<ul>
<li> <p><code>calendar.txt</code> is initially set as a required file. If it's not
present, however, it becomes optional and <code>calendar_dates.txt</code>
(originally set as optional) becomes required.
</p>
</li>
<li> <p><code>feed_info.txt</code> is initially set as an optional file. If
<code>translations.txt</code> is present, however, it becomes required.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>validate_gtfs(gtfs_duke)

## Not run: 
local_gtfs_path &lt;- system.file("extdata", "nyc_subway.zip", package = "tidytransit")
gtfs &lt;- read_gtfs(local_gtfs_path)
attr(gtfs, "validation_result")

gtfs$shapes &lt;- NULL
validation_result &lt;- validate_gtfs(gtfs)

# should raise a warning
gtfs$stop_times &lt;- NULL
validation_result &lt;- validate_gtfs(gtfs)

## End(Not run)
</code></pre>

<hr>
<h2 id='write_gtfs'>Write a tidygtfs object to a zip file</h2><span id='topic+write_gtfs'></span>

<h3>Description</h3>

<p>Write a tidygtfs object to a zip file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_gtfs(gtfs_obj, zipfile, compression_level = 9, as_dir = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_gtfs_+3A_gtfs_obj">gtfs_obj</code></td>
<td>
<p>gtfs feed (tidygtfs object)</p>
</td></tr>
<tr><td><code id="write_gtfs_+3A_zipfile">zipfile</code></td>
<td>
<p>path to the zip file the feed should be written to. The file is overwritten
if it already exists.</p>
</td></tr>
<tr><td><code id="write_gtfs_+3A_compression_level">compression_level</code></td>
<td>
<p>a number between 1 and 9, defaults to 9 (best compression).</p>
</td></tr>
<tr><td><code id="write_gtfs_+3A_as_dir">as_dir</code></td>
<td>
<p>if <code>TRUE</code>, the feed is not zipped and zipfile is used as a directory path.
The directory will be overwritten if it already exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>gtfs_obj</code>
</p>


<h3>Note</h3>

<p>Auxiliary tidytransit tables (e.g. <code>dates_services</code>) are not exported. Calls
<code><a href="gtfsio.html#topic+export_gtfs">gtfsio::export_gtfs()</a></code> after preparing the data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_gtfs">read_gtfs()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
