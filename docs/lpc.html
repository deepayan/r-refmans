<!DOCTYPE html><html><head><title>Help for package lpc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lpc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EstimateLPCFDR'><p>Estimate LPC False Discovery Rates.</p></a></li>
<li><a href='#EstimateTFDR'><p>Estimate T False Discovery Rates.</p></a></li>
<li><a href='#LPC'><p>Compute LPC score for each gene</p></a></li>
<li><a href='#lpc-internal'><p>Internal lpc functions</p></a></li>
<li><a href='#lpc-package'>
<p>This package implements the Lassoed Principal Components (LPC) method.</p>
It is used to compute LPC scores for each gene in a microrray
experiment with a survival, quantitative, or two-class outcome.</a></li>
<li><a href='#PlotFDRs'><p>Plot FDRs for both T and LPC</p></a></li>
<li><a href='#PredictiveAdvantage'><p>Plot predictive advantage of LPC vs. T</p></a></li>
<li><a href='#PrintGeneList'><p>Print the list of genes with highest LPC scores</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Lassoed Principal Components for Testing Significance of
Features</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2013-12-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniela M Witten and Robert Tibshirani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniela M Witten &lt;dwitten@uw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the LPC method of Witten&amp;Tibshirani(Annals of Applied Statistics 2008) for identification of significant genes in a microarray experiment.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-04 17:04:07 UTC; hornik</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-04 17:06:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='EstimateLPCFDR'>Estimate LPC False Discovery Rates.</h2><span id='topic+EstimateLPCFDR'></span>

<h3>Description</h3>

<p>An estimated false discovery rate for each gene is computed, based on
the LPC scores. Estimated false discovery rates based on T scores (Cox,
regression coefficient, or two-sample t-statistic) are also given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateLPCFDR(x, y, type, nreps=100,soft.thresh=NULL, censoring.status=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstimateLPCFDR_+3A_x">x</code></td>
<td>
<p>The matrix of gene expression values; pxn where n is the
number of observations and p is the number of genes.</p>
</td></tr>
<tr><td><code id="EstimateLPCFDR_+3A_y">y</code></td>
<td>
<p>A vector of
length n, with an outcome for each observation. For two-class outcome, y's
elements are 1 or 2. For quantitative outcome, y's elements are
real-valued. For survival
data, y indicates the survival time. For multiclass, y is coded as 1,2,3,...</p>
</td></tr>
<tr><td><code id="EstimateLPCFDR_+3A_type">type</code></td>
<td>
<p>One of &quot;regression&quot; (for a quantitative outcome), &quot;two
class&quot;, &quot;multiclass&quot;, or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="EstimateLPCFDR_+3A_nreps">nreps</code></td>
<td>
<p>The number of training/test set splits used to estimate
LPC's false discovery rates. Default is 100.</p>
</td></tr>
<tr><td><code id="EstimateLPCFDR_+3A_soft.thresh">soft.thresh</code></td>
<td>
<p>The value of the soft threshold to be used in the
L1 regression of the scores onto the eigenarrays. This can be the
value of the soft-threshold chosen adaptively by LPC function when it
is run on the data; if not entered by the user, then that adaptive
value is computed.</p>
</td></tr>
<tr><td><code id="EstimateLPCFDR_+3A_censoring.status">censoring.status</code></td>
<td>
<p>For survival outcome only, a vector of length
n which takes on values 0 or 1
depending on whether the observation is complete or censored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of false discovery rate estimation for LPC can be found in the
paper: http://www-stat.stanford.edu/~dwitten \
</p>
<p>As explained in the paper, FDR of LPC is estimated by computing the FDR
of simpler scores (Cox for survival outcome, standardized regression
coefficients for regression outcome, and two-sample t-statistic for
two-class outcome) and then estimating the difference between the FDR of LPC
and the FDR of these simpler scores. 
</p>


<h3>Value</h3>



<table>
<tr><td><code>fdrlpc</code></td>
<td>
<p>A vector of length p (equal to the number of genes),
with the LPC false discovery rate for each gene.</p>
</td></tr>
<tr><td><code>fdrt</code></td>
<td>
<p>A vector of length p (equal to the number of genes),
with the T false discovery rate for each gene.</p>
</td></tr>
<tr><td><code>fdrdiff</code></td>
<td>
<p>The FDR of T minus the FDR of LPC. This is
approximately equal to fdrt-fdrlpc, with the caveat that the FDR of
LPC (computed via this difference) must be between 0 and 1.</p>
</td></tr>
<tr><td><code>pi0</code></td>
<td>
<p>The fraction of genes that are believed to be null.</p>
</td></tr>
<tr><td><code>soft.thresh</code></td>
<td>
<p>The value of the soft threshold used in the L1
constraint for LPC.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call made.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela M. Witten and Robert Tibshirani</p>


<h3>References</h3>

<p>Witten, D.M. and Tibshirani, R. (2008) Testing significance
of features by lassoed principal components. Annals of Applied
Statistics. http://www-stat.stanford.edu/~dwitten</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Uncomment to run....

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) # quantitative outcome
## make first 50 genes differentially-expressed
#x[1:25,y&lt;(-.5)] &lt;- x[1:25,y&lt;(-.5)]+ 1.5
#x[26:50,y&lt;0] &lt;- x[26:50,y&lt;0] - 1.5
## compute LPC and T scores for each gene
#lpc.obj &lt;- LPC(x,y, type="regression")
## Look at plot of Predictive Advantage
#pred.adv &lt;-
#PredictiveAdvantage(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh)
## Estimate FDRs for LPC and T scores
#fdr.lpc.out &lt;-
#EstimateLPCFDR(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh,nreps=50)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="regression")
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC on 6% of genes. In this example, LPC has
##    lower FDR.
#PlotFDRs(fdr.lpc.out,frac=.06)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)

# Now, repeating everything that we did before, but using a
#   **survival** outcome
# NOT RUNNING DUE TO TIME CONSTRAINTS -- UNCOMMENT TO RUN


#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) + 10 # survival times; must be positive
## censoring outcome: 0 or 1
#cens &lt;- rep(1,40) # Assume all observations are complete
## make first 50 genes differentially-expressed
#x[1:25,y&lt;9.5] &lt;- x[1:25,y&lt;9.5]+ 1.5
#x[26:50,y&lt;10] &lt;- x[26:50,y&lt;10] - 1.5
#lpc.obj &lt;- LPC(x,y, type="survival", censoring.status=cens)
## Look at plot of Predictive Advantage
#pred.adv &lt;- PredictiveAdvantage(x,y,type="survival",soft.thresh=lpc.obj$soft.thresh,
#censoring.status=cens)
## Estimate FDRs for LPC scores and T scores
#fdr.lpc.out &lt;- EstimateLPCFDR(x,y,type="survival",
#soft.thresh=lpc.obj$soft.thresh,nreps=20,censoring.status=cens)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="survival", censoring.status=cens)
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC scores on 10% of genes.
#PlotFDRs(fdr.lpc.out,frac=.1)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)

</code></pre>

<hr>
<h2 id='EstimateTFDR'>Estimate T False Discovery Rates.</h2><span id='topic+EstimateTFDR'></span>

<h3>Description</h3>

<p>An estimated false discovery rate for each gene is computed, based on
the T scores. The T scores are as follows, for two-class, survival, and
quantitative outcomes: two-sample t-statistics, Cox scores, standardized
regression coefficients. The output of this function is identical to the
outputs &quot;fdrt&quot; and &quot;pi0&quot; of the function EstimateLPCFDR. This function
should be used if only the FDR of T is desired, because computing the
FDR of LPC is time-consuming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateTFDR(x,y, type,censoring.status=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstimateTFDR_+3A_x">x</code></td>
<td>
<p>The matrix of gene expression values; pxn where n is the
number of observations and p is the number of genes.</p>
</td></tr>
<tr><td><code id="EstimateTFDR_+3A_y">y</code></td>
<td>
<p>A vector of length n, with an outcome for each observation. For two-class
outcome, y's elements are 1 or 2. For quantitative outcome, y's
elements are real-valued. For survival
data, y indicates the survival time. For a multiclass outcome, y is
coded as 1,2,3,...</p>
</td></tr>    
<tr><td><code id="EstimateTFDR_+3A_type">type</code></td>
<td>
<p>One of &quot;regression&quot; (for a quantitative outcome), &quot;two
class&quot;, &quot;survival&quot;, or &quot;multiclass&quot; (for a multiple-class outcome).</p>
</td></tr>
<tr><td><code id="EstimateTFDR_+3A_censoring.status">censoring.status</code></td>
<td>
<p>For survival outcome only, a vector of
length
n which takes on values 0 or 1
depending on whether the observation is complete or censored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>False discovery rates are estimated by permutations, as in e.g. Tusher
et al (2001) and Storey &amp; Tibshirani (2003).
</p>


<h3>Value</h3>



<table>
<tr><td><code>fdrt</code></td>
<td>
<p>A vector of length p (equal to the number of genes),
with the T false discovery rate for each gene. Note that this is
identical to the &quot;fdrt&quot; output by the function EstimateLPCFDR.</p>
</td></tr> 
<tr><td><code>pi0</code></td>
<td>
<p>The fraction of genes that are believed to be null.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call made.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela M. Witten and Robert Tibshirani</p>


<h3>References</h3>

<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for
genomewide studies. Proceedings of the National Academy of
Sciences. 100(16): 9440-9445.
</p>
<p>Tusher, V.G. and Tibshirani, R. and Chu, G. (2001) Significance analysis
of microarrays applied to the ionizing radiation response. Proceedings
of the National Academy of Sciences. 98(9): 5116-5121.
</p>
<p>Witten, D.M. and Tibshirani, R. (2008) Testing significance
of features by lassoed principal components. Annals of Applied
Statistics. http://www-stat.stanford.edu/~dwitten</p>


<h3>Examples</h3>

<pre><code class='language-R'>### not running due to timing - uncomment to run

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) # quantitative outcome
## make first 50 genes differentially-expressed
#x[1:25,y&lt;(-.5)] &lt;- x[1:25,y&lt;(-.5)]+ 1.5
#x[26:50,y&lt;0] &lt;- x[26:50,y&lt;0] - 1.5
## compute LPC and T scores for each gene
#lpc.obj &lt;- LPC(x,y, type="regression")
## Look at plot of Predictive Advantage
#pred.adv &lt;-
#PredictiveAdvantage(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh)
## Estimate FDRs for LPC and T scores
#fdr.lpc.out &lt;-
#EstimateLPCFDR(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh,nreps=50)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="regression")
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC on 6% of genes. In this example, LPC has
##    lower FDR.
#PlotFDRs(fdr.lpc.out,frac=.06)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)

# Now, repeating everything that we did before, but using a
#   **survival** outcome
# NOT RUNNING DUE TO TIMING -- UNCOMMENT TO RUN

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) + 10 # survival times; must be positive
## censoring outcome: 0 or 1
#cens &lt;- rep(1,40) # Assume all observations are complete
## make first 50 genes differentially-expressed
#x[1:25,y&lt;9.5] &lt;- x[1:25,y&lt;9.5]+ 1.5
#x[26:50,y&lt;10] &lt;- x[26:50,y&lt;10] - 1.5
#lpc.obj &lt;- LPC(x,y, type="survival", censoring.status=cens)
## Look at plot of Predictive Advantage
#pred.adv &lt;-
#PredictiveAdvantage(x,y,type="survival",soft.thresh=lpc.obj$soft.thresh,
#censoring.status=cens)
## Estimate FDRs for LPC scores and T scores
#fdr.lpc.out &lt;- EstimateLPCFDR(x,y,
#type="survival",soft.thresh=lpc.obj$soft.thresh,
#nreps=20,censoring.status=cens)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="survival", censoring.status=cens)
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC scores on 10% of genes.
#PlotFDRs(fdr.lpc.out,frac=.1)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)

</code></pre>

<hr>
<h2 id='LPC'>Compute LPC score for each gene</h2><span id='topic+LPC'></span>

<h3>Description</h3>

<p>This is the main function for the Lassoed Principal Components (lpc)
method. Given a matrix of gene expression data and a vector of outcome
measurements (one per patient) and an outcome type, this function
computes the LPC score for each gene. Simple scores
are projected onto the eigenarrays (with an L1 constraint) in
order to obtain LPC scores; these simple scores are Cox scores (for a survival outcome),
two-sample t-statistics (for a two-class outcome) or standardized
regression coefficients (for a regression/quantitative
outcome).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPC(x, y, type = "regression", soft.thresh = NULL, u =
NULL, censoring.status = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LPC_+3A_x">x</code></td>
<td>
<p>The matrix of gene expression values; pxn where n is the
number of observations and p is the number of genes.</p>
</td></tr>
<tr><td><code id="LPC_+3A_y">y</code></td>
<td>
<p>A vector of
length n, with an outcome for each observation. For two-class
outcome, y's
elements are 1 or 2. For quantitative outcome, y's elements
are
real-valued. For survival
data, y indicates the survival time, and must be
positive. For multiclass outcome, y must be coded as 1,2,3,...</p>
</td></tr>   
<tr><td><code id="LPC_+3A_type">type</code></td>
<td>
<p>One of &quot;regression&quot; (for a quantitative outcome), &quot;two
class&quot;, &quot;multiclass&quot;, or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="LPC_+3A_soft.thresh">soft.thresh</code></td>
<td>
<p>The value of the soft threshold to be used in the
L1 regression of the scores onto the eigenarrays. If NULL, then it
will be chosen adaptively.</p>
</td></tr>
<tr><td><code id="LPC_+3A_u">u</code></td>
<td>
<p>The eigenarrays of the data matrix (useful if the data matrix
is large, to avoid having to re-compute the SVD in order to run this
function multiple times). If NULL, then the eigenarrays will be
computed internally. Note that the eigenarrays have the same dimension
as the data.</p>
</td></tr>
<tr><td><code id="LPC_+3A_censoring.status">censoring.status</code></td>
<td>
<p>For survival outcome only, a vector of length
n which takes on values 0 or 1
depending on whether the observation is complete or censored.</p>
</td></tr>      
</table>


<h3>Details</h3>

<p>Lassoed Principal Components (LPC) is a method for identifying
features associated with an outcome, under the hypothesis that
significant features occur in correlated sets. In particular, the method
was designed for identifying genes in a microarray experiment that are
associated with some outcome (e.g.: cancer vs. normal, survival time,
tumor size). The method involves projecting simpler scores for each gene
(e.g.: two-sample t-statistic, Cox score, standardized regression
coefficients) onto the eigenarrays of the gene expression data matrix,
subject to an L1 constraint. The fitted values are the LPC scores, which
may result in a more accurate gene ranking than the initial simpler
scores. 
</p>


<h3>Value</h3>



<table>
<tr><td><code>lpcscores</code></td>
<td>
<p>A vector of LPC scores, of length p (one for each
gene).</p>
</td></tr>
<tr><td><code>tscores</code></td>
<td>
<p>A vector of T scores (Cox, two-sample t-stats, or
standardized regression coefficients), of length p (one for each
gene). </p>
</td></tr>
<tr><td><code>soft.thresh</code></td>
<td>
<p>The value of the soft threshold used.</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>The coefficients for the L1 regression of the scores onto
the eigenarrays.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call that was made to this function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela M. Witten and Robert Tibshirani</p>


<h3>References</h3>

<p>Witten, D.M. and Tibshirani, R. (2008) Testing significance
of features by lassoed principal components. Annals of Applied
Statistics. http://www-stat.stanford.edu/~dwitten</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
n &lt;- 40 # 40 samples
p &lt;- 1000 # 1000 genes
x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
y &lt;-  rnorm(n) # quantitative outcome
# make first 50 genes differentially-expressed
x[1:25,y&lt;(-.5)] &lt;- x[1:25,y&lt;(-.5)]+ 1.5
x[26:50,y&lt;0] &lt;- x[26:50,y&lt;0] - 1.5
# compute LPC and T scores for each gene
lpc.obj &lt;- LPC(x,y, type="regression")
# Look at plot of Predictive Advantage
pred.adv &lt;- PredictiveAdvantage(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh)
# Estimate FDRs for LPC and T scores
fdr.lpc.out &lt;-
EstimateLPCFDR(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh,nreps=5)
# should run more reps in practice! Running just 5 in this example
# so that it runs fast.
# Estimate FDRs for T scores only. This is quicker than computing FDRs
#    for LPC scores, and should be used when only T FDRs are needed. If we
#    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
#    would give same T FDRs.
fdr.t.out &lt;- EstimateTFDR(x,y, type="regression")
# print out results of main function
lpc.obj
# print out info about T FDRs
fdr.t.out
# print out info about LPC FDRs
fdr.lpc.out
# Compare FDRs for T and LPC on 6% of genes. In this example, LPC has
#    lower FDR.
PlotFDRs(fdr.lpc.out,frac=.06)
# Print out names of 20 genes with highest LPC scores, along with their
#    LPC and T scores.
PrintGeneList(lpc.obj,numGenes=20)
# Print out names of 20 genes with highest LPC scores, along with their
#    LPC and T scores and their FDRs for LPC and T.
PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)




# Now, repeating everything that we did before, but using a
#   **survival** outcome
### COMMENTED TO REDUCE RUN TIME -- UNCOMMENT TO RUN

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) + 10 # survival times; must be positive
## censoring outcome: 0 or 1
#cens &lt;- rep(1,40) # Assume all observations are complete
## make first 50 genes differentially-expressed
#x[1:25,y&lt;9.5] &lt;- x[1:25,y&lt;9.5]+ 1.5
#x[26:50,y&lt;10] &lt;- x[26:50,y&lt;10] - 1.5
#lpc.obj &lt;- LPC(x,y, type="survival", censoring.status=cens)
## Look at plot of Predictive Advantage
#pred.adv &lt;-
#PredictiveAdvantage(x,y,type="survival",soft.thresh=lpc.obj$soft.thresh,
#censoring.status=cens)
## Estimate FDRs for LPC scores and T scores
#fdr.lpc.out &lt;-
#EstimateLPCFDR(x,y, type="survival",soft.thresh=lpc.obj$soft.thresh,
#nreps=5,censoring.status=cens)
# Running just 5 reps so that things run quickly -- please run more in practice
## Estimate FDRs for T scores only. This is quicker than computing FDRs
###    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="survival", censoring.status=cens)
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC scores on 10% of genes. 
#PlotFDRs(fdr.lpc.out,frac=.1)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)


## Now, repeating everything that we did before, but using a
##   **multiclass** outcome

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  sample(1:4, n, rep=TRUE)
## make first 50 genes differentially-expressed
#x[1:50,y==1] &lt;- x[1:50,y==1] + 1.5
#x[1:25,y==2] &lt;- x[1:25,y==2] + 1
#x[1:50,y==3] &lt;- x[1:50,y==3] - 1
#lpc.obj &lt;- LPC(x,y, type="multiclass")
## Look at plot of Predictive Advantage
#pred.adv &lt;-
#PredictiveAdvantage(x,y,type="multiclass",soft.thresh=lpc.obj$soft.thresh)
## Estimate FDRs for LPC scores and T scores
#fdr.lpc.out &lt;-
#EstimateLPCFDR(x,y, type="multiclass",soft.thresh=lpc.obj$soft.thresh,
#nreps=20)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="multiclass")
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC scores on 10% of genes. 
#PlotFDRs(fdr.lpc.out,frac=.1)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)



</code></pre>

<hr>
<h2 id='lpc-internal'>Internal lpc functions</h2><span id='topic+print.lpcobj'></span><span id='topic+print.lpcfdrobj'></span><span id='topic+print.tfdrobj'></span>

<h3>Description</h3>

<p>Internal lpc functions</p>


<h3>Details</h3>

<p>These functions are not to be called by the user.</p>


<h3>Author(s)</h3>

<p>Daniela Witten and Robert Tibshirani</p>

<hr>
<h2 id='lpc-package'>
This package implements the Lassoed Principal Components (LPC) method.
It is used to compute LPC scores for each gene in a microrray
experiment with a survival, quantitative, or two-class outcome.
</h2><span id='topic+lpc-package'></span><span id='topic+lpc'></span>

<h3>Description</h3>

<p>LPC scores are computed for each gene; the method borrows strength
across genes and can result in more accurate gene scores than simpler
statistics. In this package, the LPC method is applied by regressing Cox scores
(survival outcome), two-sample t-statistics (two-class outcome), or
standardized regression coefficients (quantitative outcome) onto gene
expression eigenarrays, with an L1 constraint.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> lpc</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2013-12-15</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)
</td>
</tr>

</table>

<p>The main function is &quot;LPC&quot;, which computes LPC scores for each
gene. The matrix of gene expression data, a vector of outcome, and the
outcome type must be passed in to this function.
</p>


<h3>Author(s)</h3>

<p>Daniela M. Witten and Robert Tibshirani
</p>
<p>Maintainer: Daniela M. Witten &lt;dwitten@uw.edu&gt;
</p>


<h3>References</h3>

<p>Witten, DM and Tibshirani R (2008) Testing significance of features by
lassoed principal components. Annals of Applied Statistics.
</p>


<h3>See Also</h3>

<p>www.biostat.washington.edu/~dwitten
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Uncomment to run


#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) # quantitative outcome
## make first 50 genes differentially-expressed
#x[1:25,y&lt;(-.5)] &lt;- x[1:25,y&lt;(-.5)]+ 1.5
#x[26:50,y&lt;0] &lt;- x[26:50,y&lt;0] - 1.5
## compute LPC and T scores for each gene
#lpc.obj &lt;- LPC(x,y, type="regression")
#lpc.obj
## Look at plot of Predictive Advantage
#pred.adv &lt;- PredictiveAdvantage(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh)
## Estimate FDRs for LPC and T scores
#fdr.lpc.out &lt;- EstimateLPCFDR(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh,nreps=50)
#fdr.lpc.out
</code></pre>

<hr>
<h2 id='PlotFDRs'>Plot FDRs for both T and LPC</h2><span id='topic+PlotFDRs'></span>

<h3>Description</h3>

<p>Takes the output of a call to EstimateLPCFDR, and uses it to plot the
false discovery rates of the genes with highest LPC / T scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotFDRs(lpcfdr.out, frac=.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotFDRs_+3A_lpcfdr.out">lpcfdr.out</code></td>
<td>
<p>Output of a call to EstimateLPCFDR.</p>
</td></tr>
<tr><td><code id="PlotFDRs_+3A_frac">frac</code></td>
<td>
<p>The fraction of genes (with highest T/LPC scores) for
which the T/LPC FDRs are plotted. Default is .25 (25%).</p>
</td></tr>
</table>


<h3>Value</h3>



<p>Nothing is returned.
</p>


<h3>Author(s)</h3>

<p>Daniela M. Witten and Robert Tibshirani</p>


<h3>References</h3>

<p>Witten, D.M. and Tibshirani, R. (2008) Testing significance
of features by lassoed principal components. Annals of Applied
Statistics. http://www-stat.stanford.edu/~dwitten</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###### not running due to timing; uncomment to run ####

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) # quantitative outcome
## make first 50 genes differentially-expressed
#x[1:25,y&lt;(-.5)] &lt;- x[1:25,y&lt;(-.5)]+ 1.5
#x[26:50,y&lt;0] &lt;- x[26:50,y&lt;0] - 1.5
## compute LPC and T scores for each gene
#lpc.obj &lt;- LPC(x,y, type="regression")
## Look at plot of Predictive Advantage
#pred.adv &lt;-
#PredictiveAdvantage(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh)
## Estimate FDRs for LPC and T scores
#fdr.lpc.out &lt;-
#EstimateLPCFDR(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh,nreps=50)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="regression")
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC on 6% of genes. In this example, LPC has
##    lower FDR.
#PlotFDRs(fdr.lpc.out,frac=.06)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)




## Now, repeating everything that we did before, but using a
##   **survival** outcome
## Not run due to timing

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) + 10 # survival times; must be positive
## censoring outcome: 0 or 1
#cens &lt;- rep(1,40) # Assume all observations are complete
## make first 50 genes differentially-expressed
#x[1:25,y&lt;9.5] &lt;- x[1:25,y&lt;9.5]+ 1.5
#x[26:50,y&lt;10] &lt;- x[26:50,y&lt;10] - 1.5
##lpc.obj &lt;- LPC(x,y, type="survival", censoring.status=cens)
## Look at plot of Predictive Advantage
#pred.adv &lt;- PredictiveAdvantage(x,y,type="survival",soft.thresh=lpc.obj$soft.thresh,
#censoring.status=cens)
## Estimate FDRs for LPC scores and T scores
#fdr.lpc.out &lt;- EstimateLPCFDR(x,y, type="survival",
#soft.thresh=lpc.obj$soft.thresh,nreps=20,censoring.status=cens)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="survival", censoring.status=cens)
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC scores on 10% of genes.
#PlotFDRs(fdr.lpc.out,frac=.1)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)

</code></pre>

<hr>
<h2 id='PredictiveAdvantage'>Plot predictive advantage of LPC vs. T</h2><span id='topic+PredictiveAdvantage'></span>

<h3>Description</h3>

<p>This function plots the predictive advantage of LPC vs. T.  The
predictive advantage is the difference between the red and black
curves. If the red curve is higher than the black curve on average, then
LPC should be used instead of T on this data set. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictiveAdvantage(x,y,type,nreps=20,ngenes=100,
soft.thresh=NULL,censoring.status=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PredictiveAdvantage_+3A_x">x</code></td>
<td>
<p>The matrix of gene expression values; pxn where n is the
number of observations and p is the number of genes.</p>
</td></tr>
<tr><td><code id="PredictiveAdvantage_+3A_y">y</code></td>
<td>
<p>A vector of
length n, with an outcome for each observation. For two-class
outcome, y's
elements are 1 or 2. For quantitative outcome, y's elements
are
real-valued. For survival
data, y indicates the survival time. For multiclass outcome,
y is coded as 1,2,3,..</p>
</td></tr>
<tr><td><code id="PredictiveAdvantage_+3A_type">type</code></td>
<td>
<p>One of &quot;regression&quot; (for a quantitative outcome), &quot;two
class&quot;, &quot;multiclass&quot;, or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="PredictiveAdvantage_+3A_nreps">nreps</code></td>
<td>
<p>Number of training/test set splits used in computing
predictive advantage.</p>
</td></tr>
<tr><td><code id="PredictiveAdvantage_+3A_soft.thresh">soft.thresh</code></td>
<td>
<p>Value of soft threshold used in L1 constraint for
LPC. If NULL, then it will be computed adaptively.</p>
</td></tr>
<tr><td><code id="PredictiveAdvantage_+3A_ngenes">ngenes</code></td>
<td>
<p>Number of genes to include in predictive advantage
plot. (E.g., if ngenes=100 (default) then  $E(|T_test| |
|L_train|&gt;alpha(L_train))$ and 
$E(|T_test| | |T_train|&gt;alpha(T_train))$ will be plotted (see
&quot;Details&quot;), where $alpha(L_train)$ and $alpha(T_train)$ are the 100th
largest (in absolute value) T and LPC scores on the training set.)</p>
</td></tr>
<tr><td><code id="PredictiveAdvantage_+3A_censoring.status">censoring.status</code></td>
<td>
<p>For survival outcome only, a vector of length
n which takes on values 0 or 1
depending on whether the observation is complete or censored.</p>
</td></tr>      
</table>


<h3>Details</h3>

<p>As explained
in the paper, predictive advantage is computed by first splitting the
data into a training set and a test set (each with 50% of the
samples). Then, the following is computed: $E(|T_test| | |L_train|&gt;alpha(L_train)) -
E(|T_test| | |T_train|&gt;alpha(T_train))$, where $T_test$ are the T scores on
the test data, $T_train$ are the T scores on the training data, and
$L_train$ are the LPC scores on the training data. $alpha(L_train)$ and
$alpha(T_train)$ are the $alpha$ quantiles of the LPC and T scores on the training data. A
large value of $E(|T_test| | |L_train|&gt;alpha(L_train)) -
E(|T_test| | |T_train|&gt;alpha(T_train))$ suggests that LPC is superior to
T on this data set.
</p>


<h3>Value</h3>

<table>
<tr><td><code>lpc</code></td>
<td>
<p>A vector of numGenes elements. The ith element is of the form
$E(|T_test| | |L_train|&gt;alpha(L_train))$, where $alpha(L_train)$ is
the ith smallest (in absolute value) training set LPC score.  Note that $L_train$
are LPC scores on the training set, $T_test$ are T scores on the
test set.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>A vector of numGenes elements. The ith element is of the form
$E(|T_test| | |L_train|&gt;alpha(T_train))$, where $alpha(T_train)$ is
the ith smallest (in absolute value) training set T score, and where $T_train$ are
T scores on the training set and $T_test$ are T scores on the test set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela M. Witten and Robert Tibshirani</p>


<h3>References</h3>

<p>Witten, D.M. and Tibshirani, R. (2008) Testing significance
of features by lassoed principal components. Annals of Applied
Statistics. http://www-stat.stanford.edu/~dwitten</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run due to timing; uncomment to run

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) # quantitative outcome
## make first 50 genes differentially-expressed
#x[1:25,y&lt;(-.5)] &lt;- x[1:25,y&lt;(-.5)]+ 1.5
#x[26:50,y&lt;0] &lt;- x[26:50,y&lt;0] - 1.5
## compute LPC and T scores for each gene
#lpc.obj &lt;- LPC(x,y, type="regression")
## Look at plot of Predictive Advantage
#pred.adv &lt;-
#PredictiveAdvantage(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh)
## Estimate FDRs for LPC and T scores
#fdr.lpc.out &lt;-
#EstimateLPCFDR(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh,nreps=50)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="regression")
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC on 6% of genes. In this example, LPC has
##    lower FDR.
#PlotFDRs(fdr.lpc.out,frac=.06)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)




## Now, repeating everything that we did before, but using a
##   **survival** outcome

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) + 10 # survival times; must be positive
## censoring outcome: 0 or 1
#cens &lt;- rep(1,40) # Assume all observations are complete
## make first 50 genes differentially-expressed
#x[1:25,y&lt;9.5] &lt;- x[1:25,y&lt;9.5]+ 1.5
#x[26:50,y&lt;10] &lt;- x[26:50,y&lt;10] - 1.5
#lpc.obj &lt;- LPC(x,y, type="survival", censoring.status=cens)
## Look at plot of Predictive Advantage
#pred.adv &lt;-
#PredictiveAdvantage(x,y,type="survival",soft.thresh=lpc.obj$soft.thresh,
#censoring.status=cens)
## Estimate FDRs for LPC scores and T scores
#fdr.lpc.out &lt;- EstimateLPCFDR(x,y,type="survival",
#soft.thresh=lpc.obj$soft.thresh,nreps=20,censoring.status=cens)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="survival", censoring.status=cens)
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC scores on 10% of genes.
#PlotFDRs(fdr.lpc.out,frac=.1)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)

 
</code></pre>

<hr>
<h2 id='PrintGeneList'>Print the list of genes with highest LPC scores</h2><span id='topic+PrintGeneList'></span>

<h3>Description</h3>

<p>Takes the output of a call to LPC function, and prints out the (T and LPC)
scores and
names of the top-scoring genes. It can (optionally) also print out FDRs
for the T and LPC scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrintGeneList(lpc.obj, numGenes=100,gene.names=NULL, lpcfdr.out=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrintGeneList_+3A_lpc.obj">lpc.obj</code></td>
<td>
<p>Output of a call to LPC.</p>
</td></tr>
<tr><td><code id="PrintGeneList_+3A_numgenes">numGenes</code></td>
<td>
<p>Desired length of list of top genes.</p>
</td></tr>
<tr><td><code id="PrintGeneList_+3A_gene.names">gene.names</code></td>
<td>
<p>Vector containing gene names; should have length
equal to the number of genes in the data set.</p>
</td></tr>
<tr><td><code id="PrintGeneList_+3A_lpcfdr.out">lpcfdr.out</code></td>
<td>
<p>Optional paramater, it is the output of the function
EstimateLPCFDR. If this is passed in, then FDRs for LPC and T will
also be printed.</p>
</td></tr>
</table>


<h3>Value</h3>



<p>Nothing is returned.
</p>


<h3>Author(s)</h3>

<p>Daniela M. Witten and Robert Tibshirani</p>


<h3>References</h3>

<p>Witten, D.M. and Tibshirani, R. (2008) Testing significance
of features by lassoed principal components. Annals of Applied
Statistics. http://www-stat.stanford.edu/~dwitten</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not running due to timing

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) # quantitative outcome
## make first 50 genes differentially-expressed
#x[1:25,y&lt;(-.5)] &lt;- x[1:25,y&lt;(-.5)]+ 1.5
#x[26:50,y&lt;0] &lt;- x[26:50,y&lt;0] - 1.5
## compute LPC and T scores for each gene
#lpc.obj &lt;- LPC(x,y, type="regression")
## Look at plot of Predictive Advantage
#pred.adv &lt;- PredictiveAdvantage(x,y,type="regression",soft.thresh=lpc.obj$soft.thresh)
## Estimate FDRs for LPC and T scores
#fdr.lpc.out &lt;- EstimateLPCFDR(x,y,type="regression",
#soft.thresh=lpc.obj$soft.thresh,nreps=50)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="regression")
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC on 6% of genes. In this example, LPC has
##    lower FDR.
#PlotFDRs(fdr.lpc.out,frac=.06)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)




## Now, repeating everything that we did before, but using a
##   **survival** outcome

#set.seed(2)
#n &lt;- 40 # 40 samples
#p &lt;- 1000 # 1000 genes
#x &lt;- matrix(rnorm(n*p), nrow=p) # make 40x1000 gene expression matrix
#y &lt;-  rnorm(n) + 10 # survival times; must be positive
## censoring outcome: 0 or 1
#cens &lt;- rep(1,40) # Assume all observations are complete
## make first 50 genes differentially-expressed
#x[1:25,y&lt;9.5] &lt;- x[1:25,y&lt;9.5]+ 1.5
#x[26:50,y&lt;10] &lt;- x[26:50,y&lt;10] - 1.5
#lpc.obj &lt;- LPC(x,y, type="survival", censoring.status=cens)
## Look at plot of Predictive Advantage
#pred.adv &lt;- PredictiveAdvantage(x,y,type="survival",
#soft.thresh=lpc.obj$soft.thresh, censoring.status=cens)
## Estimate FDRs for LPC scores and T scores
#fdr.lpc.out &lt;- EstimateLPCFDR(x,y,type="survival",
#soft.thresh=lpc.obj$soft.thresh,nreps=20,censoring.status=cens)
## Estimate FDRs for T scores only. This is quicker than computing FDRs
##    for LPC scores, and should be used when only T FDRs are needed. If we
##    started with the same random seed, then EstimateTFDR and EstimateLPCFDR
##    would give same T FDRs.
#fdr.t.out &lt;- EstimateTFDR(x,y, type="survival", censoring.status=cens)
## print out results of main function
#lpc.obj
## print out info about T FDRs
#fdr.t.out
## print out info about LPC FDRs
#fdr.lpc.out
## Compare FDRs for T and LPC scores on 10% of genes.
#PlotFDRs(fdr.lpc.out,frac=.1)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores.
#PrintGeneList(lpc.obj,numGenes=20)
## Print out names of 20 genes with highest LPC scores, along with their
##    LPC and T scores and their FDRs for LPC and T.
#PrintGeneList(lpc.obj,numGenes=20,lpcfdr.out=fdr.lpc.out)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
