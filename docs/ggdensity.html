<!DOCTYPE html><html><head><title>Help for package ggdensity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggdensity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geom_hdr'><p>Highest density regions of a 2D density estimate</p></a></li>
<li><a href='#geom_hdr_fun'><p>Highest density regions of a bivariate pdf</p></a></li>
<li><a href='#geom_hdr_points'><p>Scatterplot colored by highest density regions of a 2D density estimate</p></a></li>
<li><a href='#geom_hdr_points_fun'><p>Scatterplot colored by highest density regions of a bivariate pdf</p></a></li>
<li><a href='#geom_hdr_rug'><p>Rug plots of marginal highest density region estimates</p></a></li>
<li><a href='#geom_hdr_rug_fun'><p>Rug plots of highest density region estimates of univariate pdfs</p></a></li>
<li><a href='#get_hdr'><p>Computing the highest density regions of a 2D density</p></a></li>
<li><a href='#get_hdr_1d'><p>Computing the highest density regions of a 1D density</p></a></li>
<li><a href='#ggdensity'><p>ggdensity: Stats and Geoms for Density Estimation with ggplot2</p></a></li>
<li><a href='#method_freqpoly'><p>Bivariate frequency polygon HDR estimator</p></a></li>
<li><a href='#method_freqpoly_1d'><p>Univariate frequency polygon HDR estimator</p></a></li>
<li><a href='#method_histogram'><p>Bivariate histogram HDR estimator</p></a></li>
<li><a href='#method_histogram_1d'><p>Univariate histogram HDR estimator</p></a></li>
<li><a href='#method_kde'><p>Bivariate kernel density HDR estimator</p></a></li>
<li><a href='#method_kde_1d'><p>Univariate kernel density HDR estimator</p></a></li>
<li><a href='#method_mvnorm'><p>Bivariate parametric normal HDR estimator</p></a></li>
<li><a href='#method_norm_1d'><p>Univariate parametric normal HDR estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interpretable Bivariate Density Visualization with 'ggplot2'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'ggplot2' package provides simple functions for visualizing contours
  of 2-d kernel density estimates. 'ggdensity' implements several additional density estimators 
  as well as more interpretable visualizations based on highest density regions instead of
  the traditional height of the estimated density surface. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>isoband, vctrs, tibble, MASS, stats, scales</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jamesotto852.github.io/ggdensity/">https://jamesotto852.github.io/ggdensity/</a>,
<a href="https://github.com/jamesotto852/ggdensity/">https://github.com/jamesotto852/ggdensity/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jamesotto852/ggdensity/issues/">https://github.com/jamesotto852/ggdensity/issues/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>vdiffr, testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-09 22:57:26 UTC; ubuntu</td>
</tr>
<tr>
<td>Author:</td>
<td>James Otto <a href="https://orcid.org/0000-0002-0665-2515"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  David Kahle <a href="https://orcid.org/0000-0002-9999-1558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Otto &lt;jamesotto852@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-09 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='geom_hdr'>Highest density regions of a 2D density estimate</h2><span id='topic+geom_hdr'></span><span id='topic+stat_hdr'></span><span id='topic+StatHdr'></span><span id='topic+GeomHdr'></span><span id='topic+stat_hdr_lines'></span><span id='topic+StatHdrLines'></span><span id='topic+geom_hdr_lines'></span><span id='topic+GeomHdrLines'></span>

<h3>Description</h3>

<p>Perform 2D density estimation, compute and plot the resulting highest density regions.
<code>geom_hdr()</code> draws filled regions and <code>geom_hdr_lines()</code> draws lines outlining the regions.
Note, the plotted objects have probabilities mapped to the <code>alpha</code> aesthetic by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_hdr(
  mapping = NULL,
  data = NULL,
  geom = "hdr",
  position = "identity",
  ...,
  method = "kde",
  probs = c(0.99, 0.95, 0.8, 0.5),
  n = 100,
  xlim = NULL,
  ylim = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_hdr(
  mapping = NULL,
  data = NULL,
  stat = "hdr",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_hdr_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_method">method</code></td>
<td>
<p>Density estimator to use, accepts character vector:
<code>"kde"</code>,<code>"histogram"</code>, <code>"freqpoly"</code>, or <code>"mvnorm"</code>.
Alternatively accepts functions  which return closures corresponding to density estimates,
see <code>?get_hdr</code> or <code>vignette("method", "ggdensity")</code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute highest density regions for.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_n">n</code></td>
<td>
<p>Resolution of grid defined by <code>xlim</code> and <code>ylim</code>.
Ignored if <code>method = "histogram"</code> or <code>method = "freqpoly"</code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_xlim">xlim</code>, <code id="geom_hdr_+3A_ylim">ylim</code></td>
<td>
<p>Range to compute and draw regions. If <code>NULL</code>, defaults to
range of data.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_hdr()</code> and <code>geom_hdr_lines()</code> understand the following aesthetics (required
aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill (only <code>geom_hdr</code>)
</p>
</li>
<li><p> group
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> subgroup
</p>
</li></ul>



<h3>Computed variables</h3>

 <dl>
<dt>probs</dt><dd><p>The probability associated with the highest density region, specified
by <code>probs</code> argument.</p>
</dd> </dl>



<h3>References</h3>

<p>Scott, David W. Multivariate Density Estimation (2e), Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic simulated data with bivariate normal data and various methods
df &lt;- data.frame(x = rnorm(1000), y = rnorm(1000))
p &lt;- ggplot(df, aes(x, y)) + coord_equal()

p + geom_hdr()
p + geom_hdr(method = "mvnorm")
p + geom_hdr(method = "freqpoly")
# p + geom_hdr(method = "histogram")

# Adding point layers on top to visually assess region estimates
pts &lt;- geom_point(size = .2, color = "red")

p + geom_hdr() + pts
p + geom_hdr(method = "mvnorm") + pts
p + geom_hdr(method = "freqpoly") + pts
# p + geom_hdr(method = "histogram") + pts

# Highest density region boundary lines
p + geom_hdr_lines()
p + geom_hdr_lines(method = "mvnorm")
p + geom_hdr_lines(method = "freqpoly")
# p + geom_hdr_lines(method = "histogram")

## Not run: 

# 2+ groups - mapping other aesthetics in the geom
rdata &lt;- function(n, n_groups = 3, radius = 3) {
  list_of_dfs &lt;- lapply(0:(n_groups-1), function(k) {
    mu &lt;- c(cos(2*k*pi/n_groups), sin(2*k*pi/n_groups))
    m &lt;- MASS::mvrnorm(n, radius*mu, diag(2))
    structure(data.frame(m, as.character(k)), names = c("x", "y", "c"))
  })
  do.call("rbind", list_of_dfs)
}

dfc &lt;- rdata(1000, n_groups = 5)
pf &lt;- ggplot(dfc, aes(x, y, fill = c)) + coord_equal()

pf + geom_hdr()
pf + geom_hdr(method = "mvnorm")
pf + geom_hdr(method = "mvnorm", probs = .90, alpha = .5)
pf + geom_hdr(method = "histogram")
pf + geom_hdr(method = "freqpoly")

pc &lt;- ggplot(dfc, aes(x, y, color = c)) +
 coord_equal() +
 theme_minimal() +
 theme(panel.grid.minor = element_blank())

pc + geom_hdr_lines()
pc + geom_hdr_lines(method = "mvnorm")


# Data with boundaries
ggplot(df, aes(x^2)) + geom_histogram(bins = 30)
ggplot(df, aes(x^2)) + geom_histogram(bins = 30, boundary = 0)
ggplot(df, aes(x^2, y^2)) + geom_hdr(method = "histogram")


## End(Not run)

</code></pre>

<hr>
<h2 id='geom_hdr_fun'>Highest density regions of a bivariate pdf</h2><span id='topic+geom_hdr_fun'></span><span id='topic+stat_hdr_fun'></span><span id='topic+StatHdrFun'></span><span id='topic+GeomHdrFun'></span><span id='topic+stat_hdr_lines_fun'></span><span id='topic+StatHdrLinesFun'></span><span id='topic+geom_hdr_lines_fun'></span><span id='topic+GeomHdrLinesFun'></span>

<h3>Description</h3>

<p>Compute and plot the highest density regions (HDRs) of a bivariate pdf.
<code>geom_hdr_fun()</code> draws filled regions, and <code>geom_hdr_lines_fun()</code> draws lines outlining the regions.
Note, the plotted objects have probabilities mapped to the <code>alpha</code> aesthetic by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_hdr_fun(
  mapping = NULL,
  data = NULL,
  geom = "hdr_fun",
  position = "identity",
  ...,
  fun,
  args = list(),
  probs = c(0.99, 0.95, 0.8, 0.5),
  xlim = NULL,
  ylim = NULL,
  n = 100,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_hdr_fun(
  mapping = NULL,
  data = NULL,
  stat = "hdr_fun",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_hdr_fun_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_fun">fun</code></td>
<td>
<p>A function, the joint probability density function, must be
vectorized in its first two arguments; see examples.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_args">args</code></td>
<td>
<p>Named list of additional arguments passed on to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute highest density regions for.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_xlim">xlim</code>, <code id="geom_hdr_fun_+3A_ylim">ylim</code></td>
<td>
<p>Range to compute and draw regions. If <code>NULL</code>, defaults to
range of data if present.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_n">n</code></td>
<td>
<p>Resolution of grid <code>fun</code> is evaluated on.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_fun_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_hdr_fun()</code> and <code>geom_hdr_lines_fun()</code> understand the following aesthetics (required
aesthetics are in bold):
</p>

<ul>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill (only <code>geom_hdr_fun</code>)
</p>
</li>
<li><p> group
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> subgroup
</p>
</li></ul>



<h3>Computed variables</h3>

 <dl>
<dt>probs</dt><dd><p>The probability associated with the highest density region, specified
by <code>probs</code>.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'># HDRs of the bivariate exponential
f &lt;- function(x, y) dexp(x) * dexp(y)
ggplot() + geom_hdr_fun(fun = f, xlim = c(0, 10), ylim = c(0, 10))


# HDRs of a custom parametric model

# generate example data
n &lt;- 1000
th_true &lt;- c(3, 8)

rdata &lt;- function(n, th) {
  gen_single_obs &lt;- function(th) {
    rchisq(2, df = th) # can be anything
  }
  df &lt;- replicate(n, gen_single_obs(th))
  setNames(as.data.frame(t(df)), c("x", "y"))
}
data &lt;- rdata(n, th_true)

# estimate unknown parameters via maximum likelihood
likelihood &lt;- function(th) {
  th &lt;- abs(th) # hack to enforce parameter space boundary
  log_f &lt;- function(v) {
    x &lt;- v[1]; y &lt;- v[2]
    dchisq(x, df = th[1], log = TRUE) + dchisq(y, df = th[2], log = TRUE)
  }
  sum(apply(data, 1, log_f))
}
(th_hat &lt;- optim(c(1, 1), likelihood, control = list(fnscale = -1))$par)

# plot f for the give model
f &lt;- function(x, y, th) dchisq(x, df = th[1]) * dchisq(y, df = th[2])

ggplot(data, aes(x, y)) +
  geom_hdr_fun(fun = f, args = list(th = th_hat)) +
  geom_point(size = .25, color = "red") +
  xlim(0, 30) + ylim(c(0, 30))

ggplot(data, aes(x, y)) +
  geom_hdr_lines_fun(fun = f, args = list(th = th_hat)) +
  geom_point(size = .25, color = "red") +
  xlim(0, 30) + ylim(c(0, 30))


</code></pre>

<hr>
<h2 id='geom_hdr_points'>Scatterplot colored by highest density regions of a 2D density estimate</h2><span id='topic+geom_hdr_points'></span><span id='topic+stat_hdr_points'></span><span id='topic+StatHdrPoints'></span>

<h3>Description</h3>

<p>Perform 2D density estimation, compute the resulting highest density regions (HDRs),
and plot the provided data as a scatterplot with points colored according to
their corresponding HDR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_hdr_points(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  method = "kde",
  probs = c(0.99, 0.95, 0.8, 0.5),
  n = 100,
  xlim = NULL,
  ylim = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_hdr_points(
  mapping = NULL,
  data = NULL,
  stat = "hdr_points",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_hdr_points_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_method">method</code></td>
<td>
<p>Density estimator to use, accepts character vector:
<code>"kde"</code>,<code>"histogram"</code>, <code>"freqpoly"</code>, or <code>"mvnorm"</code>.
Alternatively accepts functions  which return closures corresponding to density estimates,
see <code>?get_hdr</code> or <code>vignette("method", "ggdensity")</code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute highest density regions for.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_n">n</code></td>
<td>
<p>Number of grid points in each direction.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_xlim">xlim</code>, <code id="geom_hdr_points_+3A_ylim">ylim</code></td>
<td>
<p>Range to compute and draw regions. If <code>NULL</code>, defaults to
range of data.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_hdr_points understands the following aesthetics (required
aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> size
</p>
</li>
<li><p> subgroup
</p>
</li></ul>



<h3>Computed variables</h3>

 <dl>
<dt>probs</dt><dd><p>The probability associated with the highest density region, specified
by <code>probs</code>.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df &lt;- data.frame(x = rnorm(500), y = rnorm(500))
p &lt;- ggplot(df, aes(x, y)) +
 coord_equal()

p + geom_hdr_points()

# Setting aes(fill = after_stat(probs)), color = "black", and
# shape = 21 helps alleviate overplotting:
p + geom_hdr_points(aes(fill = after_stat(probs)), color = "black", shape = 21, size = 2)

# Also works well with geom_hdr_lines()
p +
 geom_hdr_lines(
   aes(color = after_stat(probs)), alpha = 1,
   xlim = c(-5, 5), ylim = c(-5, 5)
 ) +
 geom_hdr_points(
   aes(fill = after_stat(probs)), color = "black", shape = 21, size = 2,
   xlim = c(-5, 5), ylim = c(-5, 5)
 )

</code></pre>

<hr>
<h2 id='geom_hdr_points_fun'>Scatterplot colored by highest density regions of a bivariate pdf</h2><span id='topic+geom_hdr_points_fun'></span><span id='topic+stat_hdr_points_fun'></span><span id='topic+StatHdrPointsFun'></span>

<h3>Description</h3>

<p>Compute the highest density regions (HDRs) of a bivariate pdf and plot the provided
data as a scatterplot with points colored according to their corresponding HDR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_hdr_points_fun(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  fun,
  args = list(),
  probs = c(0.99, 0.95, 0.8, 0.5),
  xlim = NULL,
  ylim = NULL,
  n = 100,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_hdr_points_fun(
  mapping = NULL,
  data = NULL,
  stat = "hdr_points_fun",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_hdr_points_fun_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_fun">fun</code></td>
<td>
<p>A function, the joint probability density function, must be
vectorized in its first two arguments; see examples.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_args">args</code></td>
<td>
<p>Named list of additional arguments passed on to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute highest density regions for.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_xlim">xlim</code>, <code id="geom_hdr_points_fun_+3A_ylim">ylim</code></td>
<td>
<p>Range to compute and draw regions. If <code>NULL</code>, defaults to
range of data if present.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_n">n</code></td>
<td>
<p>Number of grid points in each direction.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_points_fun_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_hdr_points_fun understands the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> size
</p>
</li>
<li><p> subgroup
</p>
</li></ul>



<h3>Computed variables</h3>

 <dl>
<dt>probs</dt><dd><p>The probability associated with the highest density region, specified
by <code>probs</code>.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'># Can plot points colored according to known pdf:
set.seed(1)
df &lt;- data.frame(x = rexp(1000), y = rexp(1000))
f &lt;- function(x, y) dexp(x) * dexp(y)

ggplot(df, aes(x, y)) +
  geom_hdr_points_fun(fun = f, xlim = c(0, 10), ylim = c(0, 10))


# Also allows for hdrs of a custom parametric model

# generate example data
n &lt;- 1000
th_true &lt;- c(3, 8)

rdata &lt;- function(n, th) {
  gen_single_obs &lt;- function(th) {
    rchisq(2, df = th) # can be anything
  }
  df &lt;- replicate(n, gen_single_obs(th))
  setNames(as.data.frame(t(df)), c("x", "y"))
}
data &lt;- rdata(n, th_true)

# estimate unknown parameters via maximum likelihood
likelihood &lt;- function(th) {
  th &lt;- abs(th) # hack to enforce parameter space boundary
  log_f &lt;- function(v) {
    x &lt;- v[1]; y &lt;- v[2]
    dchisq(x, df = th[1], log = TRUE) + dchisq(y, df = th[2], log = TRUE)
  }
  sum(apply(data, 1, log_f))
}
(th_hat &lt;- optim(c(1, 1), likelihood, control = list(fnscale = -1))$par)

# plot f for the give model
f &lt;- function(x, y, th) dchisq(x, df = th[1]) * dchisq(y, df = th[2])

ggplot(data, aes(x, y)) +
  geom_hdr_points_fun(fun = f, args = list(th = th_hat))

ggplot(data, aes(x, y)) +
  geom_hdr_points_fun(aes(fill = after_stat(probs)), shape = 21, color = "black",
    fun = f, args = list(th = th_hat), na.rm = TRUE) +
  geom_hdr_lines_fun(aes(color = after_stat(probs)), alpha = 1, fun = f, args = list(th = th_hat)) +
  lims(x = c(0, 15), y = c(0, 25))

</code></pre>

<hr>
<h2 id='geom_hdr_rug'>Rug plots of marginal highest density region estimates</h2><span id='topic+geom_hdr_rug'></span><span id='topic+stat_hdr_rug'></span><span id='topic+StatHdrRug'></span><span id='topic+GeomHdrRug'></span>

<h3>Description</h3>

<p>Perform 1D density estimation, compute and plot the resulting highest density
regions in a way similar to <code><a href="ggplot2.html#topic+geom_rug">ggplot2::geom_rug()</a></code>.
Note, the plotted objects have probabilities mapped to the <code>alpha</code> aesthetic by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_hdr_rug(
  mapping = NULL,
  data = NULL,
  geom = "hdr_rug",
  position = "identity",
  ...,
  method = "kde",
  method_y = "kde",
  probs = c(0.99, 0.95, 0.8, 0.5),
  xlim = NULL,
  ylim = NULL,
  n = 512,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE
)

geom_hdr_rug(
  mapping = NULL,
  data = NULL,
  stat = "hdr_rug",
  position = "identity",
  ...,
  outside = FALSE,
  sides = "bl",
  length = unit(0.03, "npc"),
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_hdr_rug_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_method">method</code>, <code id="geom_hdr_rug_+3A_method_y">method_y</code></td>
<td>
<p>Density estimator(s) to use.
By default <code>method</code> is used for both x- and y-axis.
If specified, <code>method_y</code> will be used for y-axis.
Accepts character vector: <code>"kde"</code>,<code>"histogram"</code>, <code>"freqpoly"</code>, or <code>"norm"</code>.
Alternatively accepts functions  which return closures corresponding to density estimates,
see <code>?get_hdr_1d</code> or <code>vignette("method", "ggdensity")</code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute highest density regions for.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_xlim">xlim</code>, <code id="geom_hdr_rug_+3A_ylim">ylim</code></td>
<td>
<p>Range to compute and draw regions. If <code>NULL</code>, defaults to
range of data.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_n">n</code></td>
<td>
<p>Resolution of grid defined by <code>xlim</code> and <code>ylim</code>.
Ignored if <code>method = "histogram"</code> or <code>method = "freqpoly"</code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_outside">outside</code></td>
<td>
<p>logical that controls whether to move the rug tassels outside of the plot area. Default is off (FALSE). You will also need to use <code>coord_cartesian(clip = "off")</code>. When set to TRUE, also consider changing the sides argument to &quot;tr&quot;. See examples.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_sides">sides</code></td>
<td>
<p>A string that controls which sides of the plot the rugs appear on.
It can be set to a string containing any of <code>"trbl"</code>, for top, right,
bottom, and left.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_+3A_length">length</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> object that sets the length of the rug lines. Use scale expansion to avoid overplotting of data.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_hdr_rug understands the following aesthetics (required
aesthetics are in bold):
</p>

<ul>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> subgroup
</p>
</li></ul>



<h3>Computed variables</h3>

 <dl>
<dt>probs</dt><dd><p>The probability of the highest density region, specified
by <code>probs</code>, corresponding to each point.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df &lt;- data.frame(x = rnorm(100), y = rnorm(100))

# Plot marginal HDRs for bivariate data
ggplot(df, aes(x, y)) +
  geom_point() +
  geom_hdr_rug() +
  coord_fixed()

ggplot(df, aes(x, y)) +
  geom_hdr() +
  geom_hdr_rug() +
  coord_fixed()

# Plot HDR for univariate data
ggplot(df, aes(x)) +
  geom_density() +
  geom_hdr_rug()

ggplot(df, aes(y = y)) +
  geom_density() +
  geom_hdr_rug()

# Specify location of marginal HDRs as in ggplot2::geom_rug()
ggplot(df, aes(x, y)) +
  geom_hdr() +
  geom_hdr_rug(sides = "tr", outside = TRUE) +
  coord_fixed(clip = "off")

# Can use same methods of density estimation as geom_hdr().
# For data with constrained support, we suggest setting method = "histogram":
ggplot(df, aes(x^2)) +
 geom_histogram(bins = 30, boundary = 0) +
 geom_hdr_rug(method = "histogram")

ggplot(df, aes(x^2, y^2)) +
 geom_hdr(method = "histogram") +
 geom_hdr_rug(method = "histogram") +
 coord_fixed()

</code></pre>

<hr>
<h2 id='geom_hdr_rug_fun'>Rug plots of highest density region estimates of univariate pdfs</h2><span id='topic+geom_hdr_rug_fun'></span><span id='topic+stat_hdr_rug_fun'></span><span id='topic+StatHdrRugFun'></span><span id='topic+GeomHdrRugFun'></span>

<h3>Description</h3>

<p>Compute and plot the highest density regions (HDRs) of specified univariate pdf(s).
Note, the plotted objects have probabilities mapped to the <code>alpha</code> aesthetic by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_hdr_rug_fun(
  mapping = NULL,
  data = NULL,
  geom = "hdr_rug_fun",
  position = "identity",
  ...,
  fun_x = NULL,
  fun_y = NULL,
  args_x = list(),
  args_y = list(),
  probs = c(0.99, 0.95, 0.8, 0.5),
  xlim = NULL,
  ylim = NULL,
  n = 512,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_hdr_rug_fun(
  mapping = NULL,
  data = NULL,
  stat = "hdr_rug_fun",
  position = "identity",
  ...,
  outside = FALSE,
  sides = "bl",
  length = unit(0.03, "npc"),
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_hdr_rug_fun_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_fun_x">fun_x</code>, <code id="geom_hdr_rug_fun_+3A_fun_y">fun_y</code></td>
<td>
<p>Functions, the univariate probability density function for the x- and/or y-axis.
First argument must be vectorized.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_args_x">args_x</code>, <code id="geom_hdr_rug_fun_+3A_args_y">args_y</code></td>
<td>
<p>Named list of additional arguments passed on to <code>fun_x</code> and/or <code>fun_y</code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute highest density regions for.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_xlim">xlim</code>, <code id="geom_hdr_rug_fun_+3A_ylim">ylim</code></td>
<td>
<p>Range to compute and draw regions. If <code>NULL</code>, defaults to
range of data.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_n">n</code></td>
<td>
<p>Resolution of grid defined by <code>xlim</code> and <code>ylim</code>.
Ignored if <code>method = "histogram"</code> or <code>method = "freqpoly"</code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_outside">outside</code></td>
<td>
<p>logical that controls whether to move the rug tassels outside of the plot area. Default is off (FALSE). You will also need to use <code>coord_cartesian(clip = "off")</code>. When set to TRUE, also consider changing the sides argument to &quot;tr&quot;. See examples.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_sides">sides</code></td>
<td>
<p>A string that controls which sides of the plot the rugs appear on.
It can be set to a string containing any of <code>"trbl"</code>, for top, right,
bottom, and left.</p>
</td></tr>
<tr><td><code id="geom_hdr_rug_fun_+3A_length">length</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> object that sets the length of the rug lines. Use scale expansion to avoid overplotting of data.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_hdr_rug_fun()</code> understands the following aesthetics (required
aesthetics are in bold):
</p>

<ul>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> subgroup
</p>
</li></ul>



<h3>Computed variables</h3>

 <dl>
<dt>probs</dt><dd><p>The probability of the highest density region, specified
by <code>probs</code>, corresponding to each point.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'># Plotting data with exponential marginals
df &lt;- data.frame(x = rexp(1e3), y = rexp(1e3))

ggplot(df, aes(x, y)) +
  geom_hdr_rug_fun(fun_x = dexp, fun_y = dexp) +
  geom_point(size = .5) +
  coord_fixed()

# without data/aesthetic mappings
ggplot() +
  geom_hdr_rug_fun(fun_x = dexp, fun_y = dexp, xlim = c(0, 7), ylim = c(0, 7)) +
  coord_fixed()


# Plotting univariate normal data, estimating mean and sd
df &lt;- data.frame(x = rnorm(1e4, mean = 1, sd = 3))

# estimating parameters
mu_hat &lt;- mean(df$x)
sd_hat &lt;- sd(df$x)

ggplot(df, aes(x)) +
  geom_hdr_rug_fun(fun_x = dnorm, args_x = list(mean = mu_hat, sd = sd_hat)) +
  geom_density()

# Equivalent to `method_norm_1d()` with `geom_hdr_rug()`
ggplot(df, aes(x)) +
  geom_hdr_rug(method = method_norm_1d()) +
  geom_density()
</code></pre>

<hr>
<h2 id='get_hdr'>Computing the highest density regions of a 2D density</h2><span id='topic+get_hdr'></span>

<h3>Description</h3>

<p><code>get_hdr</code> is used to estimate a 2-dimensional density and compute
corresponding HDRs. The estimated density and HDRs are represented in a
discrete form as a grid, defined by arguments <code>rangex</code>, <code>rangey</code>, and <code>n</code>.
<code>get_hdr</code> is used internally by layer functions <code>stat_hdr()</code>,
<code>stat_hdr_points()</code>, <code>stat_hdr_fun()</code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hdr(
  data = NULL,
  method = "kde",
  probs = c(0.99, 0.95, 0.8, 0.5),
  n = 100,
  rangex = NULL,
  rangey = NULL,
  hdr_membership = TRUE,
  fun,
  args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hdr_+3A_data">data</code></td>
<td>
<p>A data frame with columns <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="get_hdr_+3A_method">method</code></td>
<td>
<p>Either a character (<code>"kde"</code>, <code>"mvnorm"</code>, <code>"histogram"</code>,
<code>"freqpoly"</code>, or <code>"fun"</code>) or <code style="white-space: pre;">&#8288;method_*()&#8288;</code> function. See the &quot;The <code>method</code>
argument&quot; section below for details.</p>
</td></tr>
<tr><td><code id="get_hdr_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute HDRs for.</p>
</td></tr>
<tr><td><code id="get_hdr_+3A_n">n</code></td>
<td>
<p>Resolution of grid representing estimated density and HDRs.</p>
</td></tr>
<tr><td><code id="get_hdr_+3A_rangex">rangex</code>, <code id="get_hdr_+3A_rangey">rangey</code></td>
<td>
<p>Range of grid representing estimated density and HDRs,
along the x- and y-axes.</p>
</td></tr>
<tr><td><code id="get_hdr_+3A_hdr_membership">hdr_membership</code></td>
<td>
<p>Should HDR membership of data points (<code>data</code>) be
computed? Defaults to <code>TRUE</code>, although it is computationally expensive for
large data sets.</p>
</td></tr>
<tr><td><code id="get_hdr_+3A_fun">fun</code></td>
<td>
<p>Optional, a joint probability density function, must be vectorized
in its first two arguments. See the &quot;The <code>fun</code> argument&quot; section below for
details.</p>
</td></tr>
<tr><td><code id="get_hdr_+3A_args">args</code></td>
<td>
<p>Optional, a list of arguments to be provided to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_hdr</code> returns a list with elements <code>df_est</code> (<code>data.frame</code>), <code>breaks</code>
(named <code>numeric</code>), and <code>data</code> (<code>data.frame</code>).
</p>

<ul>
<li> <p><code>df_est</code>: the estimated HDRs and density evaluated on the grid defined by <code>rangex</code>, <code>rangey</code>, and <code>n</code>.
The column of estimated HDRs (<code>df_est$hdr</code>) is a numeric vector with values
from <code>probs</code>. The columns <code>df_est$fhat</code> and <code>df_est$fhat_discretized</code>
correspond to the estimated density on the original scale and rescaled to sum
to 1, respectively.
</p>
</li>
<li> <p><code>breaks</code>: the heights of the estimated density (<code>df_est$fhat</code>) corresponding to the HDRs specified by <code>probs</code>.
Will always have additional element <code>Inf</code> representing the cutoff for the
100% HDR.
</p>
</li>
<li> <p><code>data</code>: the original data provided in the <code>data</code> argument.
If <code>hdr_membership</code> is set to <code>TRUE</code>, this includes a column
(<code>data$hdr_membership</code>) with the HDR corresponding to each data point.
</p>
</li></ul>



<h3>The <code>method</code> argument</h3>

<p>The density estimator used to estimate the
HDRs is specified with the <code>method</code> argument. The simplest way to specify
an estimator is to provide a character value to <code>method</code>, for example
<code>method = "kde"</code> specifies a kernel density estimator. However, this
specification is limited to the default behavior of the estimator.
</p>
<p>Instead, it is possible to provide a function call, for example: <code>method = method_kde()</code>. In many cases, these functions accept parameters governing
the density estimation procedure. Here, <code>method_kde()</code> accepts parameters
<code>h</code> and <code>adjust</code>, both related to the kernel's bandwidth. For details, see
<code>?method_kde</code>. Every method of bivariate density estimation implemented has
such corresponding <code style="white-space: pre;">&#8288;method_*()&#8288;</code> function, each with an associated help
page.
</p>
<p>Note: <code>geom_hdr()</code> and other layer functions also have <code>method</code> arguments
which behave in the same way. For more details on the use and
implementation of the <code style="white-space: pre;">&#8288;method_*()&#8288;</code> functions, see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>The <code>fun</code> argument</h3>

<p>If <code>method</code> is set to <code>"fun"</code>, <code>get_hdr()</code>
expects a bivariate probability density function to be specified with the
<code>fun</code> argument. It is required that <code>fun</code> be a function of at least two
arguments (<code>x</code> and <code>y</code>). Beyond these first two arguments, <code>fun</code> can have
arbitrarily many arguments; these can be set in <code>get_hdr()</code> as a named list
via the <code>args</code> parameter.
</p>
<p>Note: <code>get_hdr()</code> requires that <code>fun</code> be vectorized in <code>x</code> and <code>y</code>. For an
example of an appropriate choice of <code>fun</code>, see the final example below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = rnorm(1e3), y = rnorm(1e3))

# Two ways to specify `method`
get_hdr(df, method = "kde")
get_hdr(df, method = method_kde())

## Not run: 

# If parenthesis are omitted, `get_hdr()` errors
get_hdr(df, method = method_kde)

## End(Not run)

# Estimate different HDRs with `probs`
get_hdr(df, method = method_kde(), probs = c(.975, .6, .2))

# Adjust estimator parameters with arguments to `method_kde()`
get_hdr(df, method = method_kde(h = 1))

# Parametric normal estimator of density
get_hdr(df, method = "mvnorm")
get_hdr(df, method = method_mvnorm())

# Compute "population" HDRs of specified bivariate pdf with `method = "fun"`
f &lt;- function(x, y, sd_x = 1, sd_y = 1) dnorm(x, sd = sd_x) * dnorm(y, sd = sd_y)

get_hdr(
  method = "fun", fun = f,
  rangex = c(-5, 5), rangey = c(-5, 5)
 )

get_hdr(
  method = "fun", fun = f,
  rangex = c(-5, 5), rangey = c(-5, 5),
  args = list(sd_x = .5, sd_y = .5) # specify additional arguments w/ `args`
)

</code></pre>

<hr>
<h2 id='get_hdr_1d'>Computing the highest density regions of a 1D density</h2><span id='topic+get_hdr_1d'></span>

<h3>Description</h3>

<p><code>get_hdr_1d</code> is used to estimate a 1-dimensional density and compute corresponding HDRs.
The estimated density and HDRs are represented in a discrete form as a grid, defined by arguments <code>range</code> and <code>n</code>.
<code>get_hdr_1d</code> is used internally by layer functions <code>stat_hdr_rug()</code> and <code>stat_hdr_rug_fun()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hdr_1d(
  x = NULL,
  method = "kde",
  probs = c(0.99, 0.95, 0.8, 0.5),
  n = 512,
  range = NULL,
  hdr_membership = TRUE,
  fun,
  args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hdr_1d_+3A_x">x</code></td>
<td>
<p>A vector of data</p>
</td></tr>
<tr><td><code id="get_hdr_1d_+3A_method">method</code></td>
<td>
<p>Either a character (<code>"kde"</code>, <code>"norm"</code>, <code>"histogram"</code>, <code>"freqpoly"</code>, or <code>"fun"</code>) or <code style="white-space: pre;">&#8288;method_*_1d()&#8288;</code> function.
See the &quot;The <code>method</code> argument&quot; section below for details.</p>
</td></tr>
<tr><td><code id="get_hdr_1d_+3A_probs">probs</code></td>
<td>
<p>Probabilities to compute HDRs for.</p>
</td></tr>
<tr><td><code id="get_hdr_1d_+3A_n">n</code></td>
<td>
<p>Resolution of grid representing estimated density and HDRs.</p>
</td></tr>
<tr><td><code id="get_hdr_1d_+3A_range">range</code></td>
<td>
<p>Range of grid representing estimated density and HDRs.</p>
</td></tr>
<tr><td><code id="get_hdr_1d_+3A_hdr_membership">hdr_membership</code></td>
<td>
<p>Should HDR membership of data points (<code>x</code>) be computed?</p>
</td></tr>
<tr><td><code id="get_hdr_1d_+3A_fun">fun</code></td>
<td>
<p>Optional, a probability density function, must be vectorized in its first argument.
See the &quot;The <code>fun</code> argument&quot; section below for details.</p>
</td></tr>
<tr><td><code id="get_hdr_1d_+3A_args">args</code></td>
<td>
<p>Optional, a list of arguments to be provided to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_hdr_1d</code> returns a list with elements <code>df_est</code> (<code>data.frame</code>), <code>breaks</code> (named <code>numeric</code>), and <code>data</code> (<code>data.frame</code>).
</p>

<ul>
<li> <p><code>df_est</code>: the estimated HDRs and density evaluated on the grid defined by <code>range</code> and <code>n</code>.
The column of estimated HDRs (<code>df_est$hdr</code>) is a numeric vector with values from <code>probs</code>.
The columns <code>df_est$fhat</code> and <code>df_est$fhat_discretized</code> correspond to the estimated density
on the original scale and rescaled to sum to 1, respectively.
</p>
</li>
<li> <p><code>breaks</code>: the heights of the estimated density (<code>df_est$fhat</code>) corresponding to the HDRs specified by <code>probs</code>.
Will always have additional element <code>Inf</code> representing the cutoff for the 100% HDR.
</p>
</li>
<li> <p><code>data</code>: the original data provided in the <code>data</code> argument.
If <code>hdr_membership</code> is set to <code>TRUE</code>, this includes a column (<code>data$hdr_membership</code>)
with the HDR corresponding to each data point.
</p>
</li></ul>



<h3>The <code>method</code> argument</h3>

<p>The density estimator used to estimate the HDRs is specified with the <code>method</code> argument.
The simplest way to specify an estimator is to provide a character value to <code>method</code>,
for example <code>method = "kde"</code> specifies a kernel density estimator.
However, this specification is limited to the default behavior of the estimator.
</p>
<p>Instead, it is possible to provide a function call, for example: <code>method = method_kde_1d()</code>.
This is slightly different from the function calls provided in <code>get_hdr()</code>, note the <code style="white-space: pre;">&#8288;_1d&#8288;</code> suffix.
In many cases, these functions accept parameters governing the density estimation procedure.
Here, <code>method_kde_1d()</code> accepts several parameters related to the choice of kernel.
For details, see <code>?method_kde_1d</code>.
Every method of univariate density estimation implemented has such corresponding <code style="white-space: pre;">&#8288;method_*_1d()&#8288;</code> function,
each with an associated help page.
</p>
<p>Note: <code>geom_hdr_rug()</code> and other layer functions also have <code>method</code> arguments which behave in the same way.
For more details on the use and implementation of the <code style="white-space: pre;">&#8288;method_*_1d()&#8288;</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>The <code>fun</code> argument</h3>

<p>If <code>method</code> is set to <code>"fun"</code>, <code>get_hdr_1d()</code> expects a univariate probability
density function to be specified with the <code>fun</code> argument.
It is required that <code>fun</code> be a function of at least one argument (<code>x</code>).
Beyond this first argument, <code>fun</code> can have arbitrarily many arguments;
these can be set in <code>get_hdr_1d()</code> as a named list via the <code>args</code> parameter.
</p>
<p>Note: <code>get_hdr_1d()</code> requires that <code>fun</code> be vectorized in <code>x</code>.
For an example of an appropriate choice of <code>fun</code>, see the final example below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1e3)

# Two ways to specify `method`
get_hdr_1d(x, method = "kde")
get_hdr_1d(x, method = method_kde_1d())

## Not run: 

# If parenthesis are omitted, `get_hdr_1d()` errors
get_hdr_1d(df, method = method_kde_1d)

# If the `_1d` suffix is omitted, `get_hdr_1d()` errors
get_hdr_1d(x, method = method_kde())

## End(Not run)

# Adjust estimator parameters with arguments to `method_kde_1d()`
get_hdr_1d(x, method = method_kde_1d(kernel = "triangular"))

# Estimate different HDRs with `probs`
get_hdr_1d(x, method = method_kde_1d(), probs = c(.975, .6, .2))

# Compute "population" HDRs of specified univariate pdf with `method = "fun"`
f &lt;- function(x, sd = 1) dnorm(x, sd = sd)
get_hdr_1d(method = "fun", fun = f, range = c(-5, 5))
get_hdr_1d(method = "fun", fun = f, range = c(-5, 5), args = list(sd = .5))


</code></pre>

<hr>
<h2 id='ggdensity'>ggdensity: Stats and Geoms for Density Estimation with ggplot2</h2><span id='topic+ggdensity'></span><span id='topic+package-ggdensity'></span>

<h3>Description</h3>

<p>A package that allows more flexible computations for visualization of density
estimates with ggplot2.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jamesotto852.github.io/ggdensity/">https://jamesotto852.github.io/ggdensity/</a>
</p>
</li>
<li> <p><a href="https://github.com/jamesotto852/ggdensity/">https://github.com/jamesotto852/ggdensity/</a>
</p>
</li></ul>


<hr>
<h2 id='method_freqpoly'>Bivariate frequency polygon HDR estimator</h2><span id='topic+method_freqpoly'></span>

<h3>Description</h3>

<p>Function used to specify bivariate frequency polygon density estimator
for <code>get_hdr()</code> and layer functions (e.g. <code>geom_hdr()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_freqpoly(bins = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_freqpoly_+3A_bins">bins</code></td>
<td>
<p>Number of bins along each axis.
Either a vector of length 2 or a scalar value which is recycled for both dimensions.
Defaults to normal reference rule (Scott, pg 87).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the use and implementation of the <code style="white-space: pre;">&#8288;method_*()&#8288;</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>References</h3>

<p>Scott, David W. Multivariate Density Estimation (2e), Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df &lt;- data.frame(x = rnorm(1e3), y = rnorm(1e3))

ggplot(df, aes(x, y)) +
  geom_hdr(method = method_freqpoly()) +
  geom_point(size = 1)

# The resolution of the frequency polygon estimator can be set via `bins`
ggplot(df, aes(x, y)) +
  geom_hdr(method = method_freqpoly(bins = c(8, 25))) +
  geom_point(size = 1)

# Can also be used with `get_hdr()` for numerical summary of HDRs
res &lt;- get_hdr(df, method = method_freqpoly())
str(res)

</code></pre>

<hr>
<h2 id='method_freqpoly_1d'>Univariate frequency polygon HDR estimator</h2><span id='topic+method_freqpoly_1d'></span>

<h3>Description</h3>

<p>Function used to specify univariate frequency polygon density estimator
for <code>get_hdr_1d()</code> and layer functions (e.g. <code>geom_hdr_rug()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_freqpoly_1d(bins = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_freqpoly_1d_+3A_bins">bins</code></td>
<td>
<p>Number of bins. Defaults to normal reference rule (Scott, pg 59).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the use and implementation of the <code style="white-space: pre;">&#8288;method_*_1d()&#8288;</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>References</h3>

<p>Scott, David W. Multivariate Density Estimation (2e), Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = rnorm(1e3))

# Strip chart to visualize 1-d data
p &lt;- ggplot(df, aes(x)) +
  geom_jitter(aes(y = 0), width = 0, height = 2) +
  scale_y_continuous(name = NULL, breaks = NULL) +
  coord_cartesian(ylim = c(-3, 3))

p

p + geom_hdr_rug(method = method_freqpoly_1d())

# The resolution of the frequency polygon estimator can be set via `bins`
p + geom_hdr_rug(method = method_freqpoly_1d(bins = 100))

# Can also be used with `get_hdr_1d()` for numerical summary of HDRs
res &lt;- get_hdr_1d(df$x, method = method_freqpoly_1d())
str(res)

</code></pre>

<hr>
<h2 id='method_histogram'>Bivariate histogram HDR estimator</h2><span id='topic+method_histogram'></span>

<h3>Description</h3>

<p>Function used to specify bivariate histogram density estimator
for <code>get_hdr()</code> and layer functions (e.g. <code>geom_hdr()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_histogram(bins = NULL, smooth = FALSE, nudgex = "none", nudgey = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_histogram_+3A_bins">bins</code></td>
<td>
<p>Number of bins along each axis.
Either a vector of length 2 or a scalar value which is recycled for both dimensions.
Defaults to normal reference rule (Scott, pg 87).</p>
</td></tr>
<tr><td><code id="method_histogram_+3A_smooth">smooth</code></td>
<td>
<p>If <code>TRUE</code>, HDRs are smoothed by the marching squares algorithm.</p>
</td></tr>
<tr><td><code id="method_histogram_+3A_nudgex">nudgex</code>, <code id="method_histogram_+3A_nudgey">nudgey</code></td>
<td>
<p>Horizontal and vertical rules for choosing witness points when <code>smooth == TRUE</code>.
Accepts character vector: <code>"left"</code>, <code>"none"</code>, <code>"right"</code> (<code>nudgex</code>) or  <code>"down"</code>, <code>"none"</code>, <code>"up"</code> (<code>nudgey</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the use and implementation of the <code style="white-space: pre;">&#8288;method_*()&#8288;</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>References</h3>

<p>Scott, David W. Multivariate Density Estimation (2e), Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Histogram estimators can be useful when data has boundary constraints
set.seed(1)
df &lt;- data.frame(x = rexp(1e3), y = rexp(1e3))

ggplot(df, aes(x, y)) +
  geom_hdr(method = method_histogram()) +
  geom_point(size = 1)

# The resolution of the histogram estimator can be set via `bins`
ggplot(df, aes(x, y)) +
  geom_hdr(method = method_histogram(bins = c(8, 25))) +
  geom_point(size = 1)

# By setting `smooth = TRUE`, we can graphically smooth the "blocky" HDRs
ggplot(df, aes(x, y)) +
  geom_hdr(method = method_histogram(smooth = TRUE)) +
  geom_point(size = 1)

# However, we need to set `nudgex` and `nudgey` to align the HDRs correctly
ggplot(df, aes(x, y)) +
  geom_hdr(method = method_histogram(smooth = TRUE, nudgex = "left", nudgey = "down")) +
  geom_point(size = 1)

# Can also be used with `get_hdr()` for numerical summary of HDRs
res &lt;- get_hdr(df, method = method_histogram())
str(res)

## End(Not run)

</code></pre>

<hr>
<h2 id='method_histogram_1d'>Univariate histogram HDR estimator</h2><span id='topic+method_histogram_1d'></span>

<h3>Description</h3>

<p>Function used to specify univariate histogram density estimator
for <code>get_hdr_1d()</code> and layer functions (e.g. <code>geom_hdr_rug()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_histogram_1d(bins = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_histogram_1d_+3A_bins">bins</code></td>
<td>
<p>Number of bins. Defaults to normal reference rule (Scott, pg 59).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the use and implementation of the <code style="white-space: pre;">&#8288;method_*_1d()&#8288;</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>References</h3>

<p>Scott, David W. Multivariate Density Estimation (2e), Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Histogram estimators can be useful when data has boundary constraints
df &lt;- data.frame(x = rexp(1e3))

# Strip chart to visualize 1-d data
p &lt;- ggplot(df, aes(x)) +
  geom_jitter(aes(y = 0), width = 0, height = 2) +
  scale_y_continuous(name = NULL, breaks = NULL) +
  coord_cartesian(ylim = c(-3, 3))

p

p + geom_hdr_rug(method = method_histogram_1d())

# The resolution of the histogram estimator can be set via `bins`
p + geom_hdr_rug(method = method_histogram_1d(bins = 5))

# Can also be used with `get_hdr_1d()` for numerical summary of HDRs
res &lt;- get_hdr_1d(df$x, method = method_histogram_1d())
str(res)

</code></pre>

<hr>
<h2 id='method_kde'>Bivariate kernel density HDR estimator</h2><span id='topic+method_kde'></span>

<h3>Description</h3>

<p>Function used to specify bivariate kernel density estimator
for <code>get_hdr()</code> and layer functions (e.g. <code>geom_hdr()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_kde(h = NULL, adjust = c(1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_kde_+3A_h">h</code></td>
<td>
<p>Bandwidth (vector of length two). If <code>NULL</code>, estimated
using <code><a href="MASS.html#topic+bandwidth.nrd">MASS::bandwidth.nrd()</a></code>.</p>
</td></tr>
<tr><td><code id="method_kde_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicative bandwidth adjustment to be used if 'h' is
'NULL'. This makes it possible to adjust the bandwidth while still
using the a bandwidth estimator. For example, <code>adjust = 1/2</code> means
use half of the default bandwidth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the use and implementation of the <code style="white-space: pre;">&#8288;method_*()&#8288;</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df &lt;- data.frame(x = rnorm(1e3, sd = 3), y = rnorm(1e3, sd = 3))

ggplot(df, aes(x, y)) +
  geom_hdr(method = method_kde()) +
  geom_point(size = 1)

# The defaults of `method_kde()` are the same as the estimator for `ggplot2::geom_density_2d()`
ggplot(df, aes(x, y)) +
  geom_density_2d_filled() +
  geom_hdr_lines(method = method_kde(), probs = seq(.1, .9, by = .1)) +
  theme(legend.position = "none")

# The bandwidth of the estimator can be set directly with `h` or scaled with `adjust`
ggplot(df, aes(x, y)) +
  geom_hdr(method = method_kde(h = 1)) +
  geom_point(size = 1)

ggplot(df, aes(x, y)) +
  geom_hdr(method = method_kde(adjust = 1/2)) +
  geom_point(size = 1)

# Can also be used with `get_hdr()` for numerical summary of HDRs
res &lt;- get_hdr(df, method = method_kde())
str(res)

</code></pre>

<hr>
<h2 id='method_kde_1d'>Univariate kernel density HDR estimator</h2><span id='topic+method_kde_1d'></span>

<h3>Description</h3>

<p>Function used to specify univariate kernel density estimator
for <code>get_hdr_1d()</code> and layer functions (e.g. <code>geom_hdr_rug()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_kde_1d(
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  weights = NULL,
  window = kernel
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_kde_1d_+3A_bw">bw</code></td>
<td>
<p>the smoothing bandwidth to be used.  The kernels are scaled
such that this is the standard deviation of the smoothing kernel.
(Note this differs from the reference books cited below, and from S-PLUS.)
</p>
<p><code>bw</code> can also be a character string giving a rule to choose the
bandwidth.  See <code><a href="stats.html#topic+bw.nrd">bw.nrd</a></code>. <br /> The default,
<code>"nrd0"</code>, has remained the default for historical and
compatibility reasons, rather than as a general recommendation,
where e.g., <code>"SJ"</code> would rather fit, see also Venables and
Ripley (2002).
</p>
<p>The specified (or computed) value of <code>bw</code> is multiplied by
<code>adjust</code>.
</p>
</td></tr>
<tr><td><code id="method_kde_1d_+3A_adjust">adjust</code></td>
<td>
<p>the bandwidth used is actually <code>adjust*bw</code>.
This makes it easy to specify values like &lsquo;half the default&rsquo;
bandwidth.</p>
</td></tr>
<tr><td><code id="method_kde_1d_+3A_kernel">kernel</code>, <code id="method_kde_1d_+3A_window">window</code></td>
<td>
<p>a character string giving the smoothing kernel
to be used. This must partially match one of <code>"gaussian"</code>,
<code>"rectangular"</code>, <code>"triangular"</code>, <code>"epanechnikov"</code>,
<code>"biweight"</code>, <code>"cosine"</code> or <code>"optcosine"</code>, with default
<code>"gaussian"</code>, and may be abbreviated to a unique prefix (single
letter).
</p>
<p><code>"cosine"</code> is smoother than <code>"optcosine"</code>, which is the
usual &lsquo;cosine&rsquo; kernel in the literature and almost MSE-efficient.
However, <code>"cosine"</code> is the version used by S.
</p>
</td></tr>
<tr><td><code id="method_kde_1d_+3A_weights">weights</code></td>
<td>
<p>numeric vector of non-negative observation weights,
hence of same length as <code>x</code>. The default <code>NULL</code> is
equivalent to <code>weights = rep(1/nx, nx)</code> where <code>nx</code> is the
length of (the finite entries of) <code>x[]</code>.  If <code>na.rm = TRUE</code>
and there are <code>NA</code>'s in <code>x</code>, they <em>and</em> the
corresponding weights are removed before computations.  In that case,
when the original weights have summed to one, they are re-scaled to
keep doing so.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the use and implementation of the <code style="white-space: pre;">&#8288;method_*_1d()&#8288;</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = rnorm(1e3, sd = 3))

ggplot(df, aes(x)) +
  geom_hdr_rug(method = method_kde_1d()) +
  geom_density()

# Details of the KDE can be adjusted with arguments to `method_kde_1d()`
ggplot(df, aes(x)) +
  geom_hdr_rug(method = method_kde_1d(adjust = 1/5)) +
  geom_density(adjust = 1/5)

ggplot(df, aes(x)) +
  geom_hdr_rug(method = method_kde_1d(kernel = "triangular")) +
  geom_density(kernel = "triangular")

# Can also be used with `get_hdr_1d()` for numerical summary of HDRs
res &lt;- get_hdr_1d(df$x, method = method_kde_1d())
str(res)

</code></pre>

<hr>
<h2 id='method_mvnorm'>Bivariate parametric normal HDR estimator</h2><span id='topic+method_mvnorm'></span>

<h3>Description</h3>

<p>Function used to specify bivariate normal density estimator
for <code>get_hdr()</code> and layer functions (e.g. <code>geom_hdr()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_mvnorm()
</code></pre>


<h3>Details</h3>

<p>For more details on the use and implementation of the <code style="white-space: pre;">&#8288;method_*()&#8288;</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normal estimator is useful when an assumption of normality is appropriate
set.seed(1)
df &lt;- data.frame(x = rnorm(1e3), y = rnorm(1e3))

ggplot(df, aes(x, y)) +
  geom_hdr(method = method_mvnorm(), xlim = c(-4, 4), ylim = c(-4, 4)) +
  geom_point(size = 1)

# Can also be used with `get_hdr()` for numerical summary of HDRs
res &lt;- get_hdr(df, method = method_mvnorm())
str(res)

</code></pre>

<hr>
<h2 id='method_norm_1d'>Univariate parametric normal HDR estimator</h2><span id='topic+method_norm_1d'></span>

<h3>Description</h3>

<p>Function used to specify univariate normal density estimator
for <code>get_hdr_1d()</code> and layer functions (e.g. <code>geom_hdr_rug()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_norm_1d()
</code></pre>


<h3>Details</h3>

<p>For more details on the use and implementation of the <code style="white-space: pre;">&#8288;method_*_1d()&#8288;</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normal estimators are useful when an assumption of normality is appropriate
df &lt;- data.frame(x = rnorm(1e3))

ggplot(df, aes(x)) +
  geom_hdr_rug(method = method_norm_1d()) +
  geom_density()

# Can also be used with `get_hdr_1d()` for numerical summary of HDRs
res &lt;- get_hdr_1d(df$x, method = method_norm_1d())
str(res)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
