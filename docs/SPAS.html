<!DOCTYPE html><html lang="en"><head><title>Help for package SPAS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SPAS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onAttach'><p>Message to display when package is loaded</p></a></li>
<li><a href='#dummy'><p>Roxygen commands</p></a></li>
<li><a href='#logit'><p>Helper functions for this package (logit, expit)</p></a></li>
<li><a href='#SPAS.autopool'><p>Autopooling a Stratified-Petersen (SP) data set.</p>
This function applies pooling rules to pool a SPAS dataset to meeting minimum sparsity requirements
.</a></li>
<li><a href='#SPAS.extract.par.est'><p>Extract the estimates into a simpler form from a Stratified-Petersen fit</p></a></li>
<li><a href='#SPAS.fit.model'><p>Fit a Stratified-Petersen (SP) model using  TMB.</p></a></li>
<li><a href='#SPAS.likelihood.star.DM'><p>Score, likelihood, and related functions for fitting Stratified Petersen model</p></a></li>
<li><a href='#SPAS.print.model'><p>Print or Extract the results from a fit of a Stratified-Petersen (SP) model when using the TMB optimizer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stratified-Petersen Analysis System</td>
</tr>
<tr>
<td>Version:</td>
<td>2025.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-01</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB, RcppEigen</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, MASS, Matrix, msm, numDeriv, plyr, reshape2, TMB
(&ge; 1.7.15), utils</td>
</tr>
<tr>
<td>Description:</td>
<td>The Stratified-Petersen Analysis System (SPAS) is designed
    to estimate abundance in two-sample capture-recapture experiments 
    where the capture and recaptures are stratified. This is a generalization
    of the simple Lincoln-Petersen estimator.
    Strata may be defined in time or in space or both, 
    and the s strata in which marking takes place 
    may differ from the t strata in which recoveries take place.
    When s=t, SPAS reduces to the method described by 
    Darroch (1961) &lt;<a href="https://doi.org/10.2307%2F2332748">doi:10.2307/2332748</a>&gt;.
    When s&lt;t, SPAS implements the methods described in
    Plante, Rivest, and Tremblay (1988) &lt;<a href="https://doi.org/10.2307%2F2533994">doi:10.2307/2533994</a>&gt;.
    Schwarz and Taylor (1998) &lt;<a href="https://doi.org/10.1139%2Ff97-238">doi:10.1139/f97-238</a>&gt; describe
    the use of SPAS in estimating return of salmon stratified by
    time and geography. 
    A related package, BTSPAS, deals with temporal stratification where 
    a spline is used to model the distribution of the population 
    over time as it passes the second capture location.
    This is the R-version of the (now obsolete) standalone Windows 
    program of the same name.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-06 07:06:49 UTC; cschwarz</td>
</tr>
<tr>
<td>Author:</td>
<td>Carl James Schwarz [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carl James Schwarz &lt;cschwarz.stat.sfu.ca@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-06 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onAttach'>Message to display when package is loaded</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>Message to display when package is loaded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>

<hr>
<h2 id='dummy'>Roxygen commands</h2><span id='topic+dummy'></span>

<h3>Description</h3>

<p>Roxygen commands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy()
</code></pre>

<hr>
<h2 id='logit'>Helper functions for this package (logit, expit)</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>These functions are helper functions for the SPAS package and not normally accessed by the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p)
</code></pre>


<h3>Details</h3>

<p><code>logit</code> - compute the logit of a proportion
<code>expit</code> - compute a proportion from a logit
</p>

<hr>
<h2 id='SPAS.autopool'>Autopooling a Stratified-Petersen (SP) data set.
This function applies pooling rules to pool a SPAS dataset to meeting minimum sparsity requirements
.</h2><span id='topic+SPAS.autopool'></span>

<h3>Description</h3>

<p>Autopooling a Stratified-Petersen (SP) data set.
This function applies pooling rules to pool a SPAS dataset to meeting minimum sparsity requirements
.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPAS.autopool(
  rawdata,
  min.released = 100,
  min.inspected = 50,
  min.recaps = 50,
  min.rows = 1,
  min.cols = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SPAS.autopool_+3A_rawdata">rawdata</code></td>
<td>
<p>An (s+1) x (t+1) of the raw data BEFORE pooling.
The s x t upper left matrix is the number of animals released in row stratum i and recovered in
column stratum j. Row s+1 contains the total number of UNMARKED animals recovered in column stratum j.
Column t+1 contains the number of animals marked in each row stratum but not recovered in any column stratum.
The rawdata[s+1, t+1] is not used and can be set to 0 or NA.
The sum of the entries in each of the first s rows is then the number of animals marked in each row stratum.
The sum of the entries in each of the first t columns is then the number of animals captured (marked and unmarked) in each column stratum.
The row/column names of the matrix may be set to identify the entries in the output.</p>
</td></tr>
<tr><td><code id="SPAS.autopool_+3A_min.released">min.released</code></td>
<td>
<p>Minimum number of releases in a pooled row</p>
</td></tr>
<tr><td><code id="SPAS.autopool_+3A_min.inspected">min.inspected</code></td>
<td>
<p>Minimum number of inspections in a pooled column</p>
</td></tr>
<tr><td><code id="SPAS.autopool_+3A_min.recaps">min.recaps</code></td>
<td>
<p>Minimum number of recaptures before any rows can be pooled</p>
</td></tr>
<tr><td><code id="SPAS.autopool_+3A_min.rows">min.rows</code>, <code id="SPAS.autopool_+3A_min.cols">min.cols</code></td>
<td>
<p>Minimum number or rows and columns after pooling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many cases, the stratified set of releases and recapture is too sparse (many zeroes) or count
are very small. Pooling rows and columns may be needed.
</p>
<p>Data needs to be pooled both row wise and column wise if the data are sparse
to avoid singularities in the fit.
This function automates pooling rows or columns following Schwarz and Taylor (1998).
</p>

<ul>
<li><p> All rows that have 0 releases are discarded
</p>
</li>
<li><p> All columns that have 0 recaptures of tagged fish and 0 fish inspected are discarded
</p>
</li>
<li><p> Starting at the first row and working forwards in time,
and then working from the final row and working backwards in time,
.  rows are pooled until a minimum of <code>min.released</code> are released.
An alternating pooling (from the top, from the bottom, from the top, etc) is used
</p>
</li>
<li><p> Starting at the first column and working forwards in time,
.   and then working from the final column and working backwards in time,
columns are pooled until a minimum of <code>min.inspected</code> are inspected.
An alternating pooling (from the left, from the right, from the left, etc) is used.
</p>
</li>
<li><p> If the sum of the total recaptures from released fish is &lt;= <code>min.recaps</code>, then all rows are pooled
(which reduces to a Chapman estimator)
</p>
</li></ul>



<h3>Value</h3>

<p>A list with a suggest pooling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conne.data.csv &lt;- textConnection("
9  ,    21  ,     0  ,    0  ,    0  ,    0  ,   171
0  ,   101  ,    22  ,    1  ,    0  ,    0  ,   763
0  ,     0  ,   128  ,   49  ,    0  ,    0  ,   934
0  ,     0  ,     0  ,   48  ,   12  ,    0  ,   434
0  ,     0  ,     0  ,    0  ,    7  ,    0  ,    49
0  ,     0  ,     0  ,    0  ,    0  ,    0  ,     4
351,  2736  ,  3847  , 1818  ,  543  ,   191 ,     0")
conne.data &lt;- as.matrix(read.csv(conne.data.csv, header=FALSE))
close(conne.data.csv)
 
SPAS.autopool(conne.data)
</code></pre>

<hr>
<h2 id='SPAS.extract.par.est'>Extract the estimates into a simpler form from a Stratified-Petersen fit</h2><span id='topic+SPAS.extract.par.est'></span>

<h3>Description</h3>

<p>This function is normally used internally and not by users of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPAS.extract.par.est(est.red, rowDM, colDM, thetaDM, conditional = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SPAS.extract.par.est_+3A_est.red">est.red</code></td>
<td>
<p>Vector of parameter estimates</p>
</td></tr>
<tr><td><code id="SPAS.extract.par.est_+3A_rowdm">rowDM</code></td>
<td>
<p>Design matrix for covariates for row parameters (after pooling). Not currently implemented so
this is usually an identity matrix.</p>
</td></tr>
<tr><td><code id="SPAS.extract.par.est_+3A_coldm">colDM</code></td>
<td>
<p>Design matrix for covariates for column parameters (after pooling). Not currently implemented so
this is usually an identity matrix.</p>
</td></tr>
<tr><td><code id="SPAS.extract.par.est_+3A_thetadm">thetaDM</code></td>
<td>
<p>Design matrix for covariates for movement parameters (after pooling). Not currently implemented so
this is usually an identity matrix.</p>
</td></tr>
<tr><td><code id="SPAS.extract.par.est_+3A_conditional">conditional</code></td>
<td>
<p>Indicates if a conditional (Poisson model) or full likelihood (Multinomial) fit was done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with entries 
</p>

<ul>
<li><p> theta The modeled number of animals released in row stratum i and recovered in column stratum j.
</p>
</li>
<li><p> cap. The estimated probability of tagging in row stratum i.
</p>
</li>
<li><p> psi. The estimated number of animals never seen after tagging for each row stratum.
</p>
</li>
<li><p> N.   The estimated population size.
</p>
</li></ul>


<hr>
<h2 id='SPAS.fit.model'>Fit a Stratified-Petersen (SP) model using  TMB.</h2><span id='topic+SPAS.fit.model'></span>

<h3>Description</h3>

<p>This function fits a Stratified-Petersen (Plante, 1996) to data and specify which rows/columns of the data
should be pooled. The number of rows after pooling should be &lt;= number of columns after
pooling
.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPAS.fit.model(
  model.id = "Stratified Petersen Estimator",
  rawdata,
  autopool = FALSE,
  row.pool.in = NULL,
  col.pool.in = NULL,
  row.physical.pool = TRUE,
  theta.pool = FALSE,
  CJSpool = FALSE,
  optMethod = c("nlminb"),
  optMethod.control = list(maxit = 50000),
  svd.cutoff = 1e-04,
  chisq.cutoff = 0.1,
  min.released = 100,
  min.inspected = 50,
  min.recaps = 50,
  min.rows = 1,
  min.cols = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SPAS.fit.model_+3A_model.id">model.id</code></td>
<td>
<p>Character string identifying the name of the model including any pooling..</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_rawdata">rawdata</code></td>
<td>
<p>An (s+1) x (t+1) of the raw data BEFORE pooling.
The s x t upper left matrix is the number of animals released in row stratum i and recovered in
column stratum j. Row s+1 contains the total number of UNMARKED animals recovered in column stratum j.
Column t+1 contains the number of animals marked in each row stratum but not recovered in any column stratum.
The rawdata[s+1, t+1] is not used and can be set to 0 or NA.
The sum of the entries in each of the first s rows is then the number of animals marked in each row stratum.
The sum of the entries in each of the first t columns is then the number of animals captured (marked and unmarked) in each column stratum.
The row/column names of the matrix may be set to identify the entries in the output.</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_autopool">autopool</code></td>
<td>
<p>Should the automatic pooling algorithms be used.
Give more details here on these rule work.</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_row.pool.in">row.pool.in</code>, <code id="SPAS.fit.model_+3A_col.pool.in">col.pool.in</code></td>
<td>
<p>Vectors (character/numeric) of length s and t respectively. These identify the rows/columns to be pooled before the analysis is done.
The vectors consists of entries where pooling takes place if the entries are the same. For example, if s=4, then 
row.pool.in = c(1,2,3,4) implies no pooling because all entries are distinct; row.pool.in=c(&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;) implies that the 
first two rows will be pooled and the last two rows will be pooled. It is not necessary that row/columns be continuous to be pooled, but
this is seldom sensible. A careful choice of pooling labels helps to remember what as done, e.g. row.pool.in=c(&quot;123&quot;,&quot;123&quot;,&quot;123&quot;,&quot;4&quot;) indicates
that the first 3 rows are pooled and the 4th row is not pooled. Character entries ensure that the resulting matrix is sorted properly (e.g. if 
row.pool.in=c(123,123,123,4), then the same pooling is done, but the matrix rows are sorted rather strangely.</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_row.physical.pool">row.physical.pool</code></td>
<td>
<p>Should physical pooling be done (default) or should logical pooling be done. For example, if there are 3 rows in 
the data matrix and row.pool.in=c(1,1,3), then in physical pooling, the entries in rows 1 and 2 are physically added together to create
2 rows in the data matrix before fitting. Because the data has changed, you cannot compare physical pooling using AIC. In logical pooling,
the data matrix is unchanged, but now parameters p1=p2 but the movement parameters for the rest of the matrix are not forced equal.</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_theta.pool">theta.pool</code>, <code id="SPAS.fit.model_+3A_cjspool">CJSpool</code></td>
<td>
<p>NOT YET IMPLEMENTED. DO NOT CHANGE.</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_optmethod">optMethod</code></td>
<td>
<p>What optimization method is used. Defaults is the nlminb() function..</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_optmethod.control">optMethod.control</code></td>
<td>
<p>Control parameters for optimization method. See the documentation on the different optimization methods for details.</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_svd.cutoff">svd.cutoff</code></td>
<td>
<p>When finding the variance-covariance matrix, a singular value decomposition is used. This identifies the smallest 
singular value to retain.</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_chisq.cutoff">chisq.cutoff</code></td>
<td>
<p>When finding a goodness of fit statistic using (obs-exp)^2/exp, all cell whose Exp &lt; gof.cutoff are ignored
to try and remove structural zero cells.</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_min.released">min.released</code></td>
<td>
<p>Minimum number of releases in a pooled row</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_min.inspected">min.inspected</code></td>
<td>
<p>Minimum number of inspections in a pooled column</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_min.recaps">min.recaps</code></td>
<td>
<p>Minimum number of recaptures before any rows can be pooled</p>
</td></tr>
<tr><td><code id="SPAS.fit.model_+3A_min.rows">min.rows</code>, <code id="SPAS.fit.model_+3A_min.cols">min.cols</code></td>
<td>
<p>Minimum number or rows and columns after pooling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with many entries. Refer to the vignettes for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conne.data.csv &lt;- textConnection("
9  ,    21  ,     0  ,    0  ,    0  ,    0  ,   171
0  ,   101  ,    22  ,    1  ,    0  ,    0  ,   763
0  ,     0  ,   128  ,   49  ,    0  ,    0  ,   934
0  ,     0  ,     0  ,   48  ,   12  ,    0  ,   434
0  ,     0  ,     0  ,    0  ,    7  ,    0  ,    49
0  ,     0  ,     0  ,    0  ,    0  ,    0  ,     4
351,  2736  ,  3847  , 1818  ,  543  ,   191 ,     0")
conne.data &lt;- as.matrix(read.csv(conne.data.csv, header=FALSE))
close(conne.data.csv)
 
mod1 &lt;- SPAS.fit.model(conne.data, model.id="Pooling rows 1/2, 5/6; pooling columns 5/6",
                      row.pool.in=c("12","12","3","4","56","56"),
                      col.pool.in=c(1,2,3,4,56,56))
mod2 &lt;- SPAS.fit.model(conne.data, model.id="Auto pool",
                      autopool=TRUE)
</code></pre>

<hr>
<h2 id='SPAS.likelihood.star.DM'>Score, likelihood, and related functions for fitting Stratified Petersen model</h2><span id='topic+SPAS.likelihood.star.DM'></span>

<h3>Description</h3>

<p>These functions are used internally to fit the Stratified Petersen models and are not normally used.
Most of these functions are for the legacy version that does not use TMB and so likely can be eventually deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPAS.likelihood.star.DM(
  Est.Star,
  rowDM,
  colDM,
  thetaDM,
  rawdata,
  returnnegll = FALSE,
  conditional = TRUE,
  fixed.N = 0,
  mytrace = FALSE
)
</code></pre>

<hr>
<h2 id='SPAS.print.model'>Print or Extract the results from a fit of a Stratified-Petersen (SP) model when using the TMB optimizer</h2><span id='topic+SPAS.print.model'></span>

<h3>Description</h3>

<p>This function makes a report/extracts the components of the results of the model fitting
.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPAS.print.model(x, extract = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SPAS.print.model_+3A_x">x</code></td>
<td>
<p>A result from the model fitting. See <code>SPAS.fit.model</code></p>
</td></tr>
<tr><td><code id="SPAS.print.model_+3A_extract">extract</code></td>
<td>
<p>Should the function simply return the &quot;printed&quot; components in a list?.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A report to the console or extracted components. Refer to the vignettes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conne.data.csv &lt;- textConnection("
9  ,    21  ,     0  ,    0  ,    0  ,    0  ,   171
0  ,   101  ,    22  ,    1  ,    0  ,    0  ,   763
0  ,     0  ,   128  ,   49  ,    0  ,    0  ,   934
0  ,     0  ,     0  ,   48  ,   12  ,    0  ,   434
0  ,     0  ,     0  ,    0  ,    7  ,    0  ,    49
0  ,     0  ,     0  ,    0  ,    0  ,    0  ,     4
351,  2736  ,  3847  , 1818  ,  543  ,   191 ,     0")
conne.data &lt;- as.matrix(read.csv(conne.data.csv, header=FALSE))
close(conne.data.csv)
 
mod1 &lt;- SPAS.fit.model(conne.data, model.id="Pooling rows 1/2, 5/6; pooling columns 5/6",
                      row.pool.in=c("12","12","3","4","56","56"),
                      col.pool.in=c(1,2,3,4,56,56))

SPAS.print.model(mod1)

out &lt;- SPAS.print.model(mod1, extract=TRUE)
names(out)
out$spas
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
