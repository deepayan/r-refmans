<!DOCTYPE html><html><head><title>Help for package TapeS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TapeS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TapeS-package'><p>TapeS: New taper functions for most common tree species in Germany and</p>
evaluating functions.</a></li>
<li><a href='#Az'><p>estimate minimum cutting diameter</p></a></li>
<li><a href='#azp'><p>Data: Function Parameters to estimate cutting diameter</p></a></li>
<li><a href='#BaMap'><p>function for mapping the 36 tree species to several internal functions</p></a></li>
<li><a href='#bark'><p>Double Bark Thickness</p></a></li>
<li><a href='#biomass'><p>Prediction of above-ground biomass according to NFI-functions</p></a></li>
<li><a href='#calcVCOVsekVol'><p>calculate VCOV-Matrix for volume segments</p></a></li>
<li><a href='#check_monotonicity'><p>monotonicity check for taper curve</p></a></li>
<li><a href='#crownExpansion'><p>Data: Crown wood expansion models to include branch coarse wood</p></a></li>
<li><a href='#data_coercion'><p>coerce different data sources into class 'tprTrees'</p></a></li>
<li><a href='#Dbh'><p>Extract pre-defined diameter</p></a></li>
<li><a href='#dbtp'><p>Data: Function Parameters to estimate double bark thickness</p></a></li>
<li><a href='#E_HDxoR_HmDm_Ht.f'><p>Find Height of diameter under bark via uniroot</p></a></li>
<li><a href='#estHeight'><p>Estimate tree height by DBH according to BWI3</p></a></li>
<li><a href='#fnUnvd'><p>percentage of unusable coarse wood</p></a></li>
<li><a href='#FormTariff'><p>Tariff for taper form</p></a></li>
<li><a href='#HtCoef'><p>returns coefficients for Pettersen-Height model</p></a></li>
<li><a href='#lmeSKEBLUP'><p>diameter prediction E[d] for TapeR-object</p></a></li>
<li><a href='#nsur'><p>Component biomass functions</p></a></li>
<li><a href='#parSort'><p>constructor for class parSort</p></a></li>
<li><a href='#parSort-class'><p>An S4 class to represent the parameters for tree assorting.</p></a></li>
<li><a href='#petterson'><p>height estimation</p></a></li>
<li><a href='#plot.tprTrees'><p>Plot taper curve for an object of class <code>tprTrees</code></p></a></li>
<li><a href='#RiPar'><p>parameter of bark function</p></a></li>
<li><a href='#setTapeSoptions'><p>Set and get options for the TapeS-package</p></a></li>
<li><a href='#simTrees'><p>simulating objects of class <code>tprTrees</code></p></a></li>
<li><a href='#SKPar'><p>Data: Taper Curve models fit using R-Package TapeR</p></a></li>
<li><a href='#Slot_accessors'><p>slot accessor functions for class 'tprtrees'</p></a></li>
<li><a href='#tprAssortment'><p>Functions to calculate assortments for given tree</p></a></li>
<li><a href='#tprBark'><p>Functions to calculate double bark thickness for given diameter at</p>
height <code>Hx</code></a></li>
<li><a href='#tprBiomass'><p>total aboveground and component biomass</p></a></li>
<li><a href='#tprDiameter'><p>Functions to extract diameters from Taper curve</p></a></li>
<li><a href='#tprDiameterCpp'><p>Function to extract diameters from Taper curve using Rcpp</p></a></li>
<li><a href='#tprHeight'><p>Estimate height for given diameter w/ or w/o bark</p></a></li>
<li><a href='#tprSpeciesCode'><p>Get BDAT species code or transform it to a name.</p></a></li>
<li><a href='#tprTrees'><p>constructor for class tprTrees</p></a></li>
<li><a href='#tprTrees-class'><p>An S4 class to represent one or multiple trees.</p></a></li>
<li><a href='#tprVolume'><p>Functions to calculate stem volume from taper curve</p></a></li>
<li><a href='#unvd'><p>Data: Percentage of unusable wood in Beech and Oak in Germany</p></a></li>
<li><a href='#Vfm'><p>tree volume information</p></a></li>
<li><a href='#volfaodlt7'><p>Data: Volume (cbm over bark) according to FAO definition for trees with</p>
dbh less than 7cm</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tree Taper Curves and Sorting Based on 'TapeR'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.12.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Providing new german-wide 'TapeR' Models and functions for their 
  evaluation. Included are the most common tree species in Germany (Norway 
  spruce, Scots pine, European larch, Douglas fir, Silver fir as well as 
  European beech, Common/Sessile oak and Red oak). Many other species are mapped
  to them so that 36 tree species / groups can be processed. Single trees are 
  defined by species code, one or multiple diameters in arbitrary measuring 
  height and tree height. The functions then provide information on diameters 
  along the stem, bark thickness, height of diameters, volume of the total or 
  parts of the trunk and total and component above-ground biomass. It is also 
  possible to calculate assortments from the taper curves. For diameter and 
  volume estimation, uncertainty information is given.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/vochr/tapes">https://gitlab.com/vochr/tapes</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, TapeR (&ge; 0.5.2), Rcpp (&ge; 1.0.5),</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, rbenchmark, rBDAT (&ge; 0.10.0),
RODBC</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-24 13:56:02 UTC; Christian.Vonderach</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Vonderach [aut, cre],
  Edgar Kublin [aut],
  Gerald KÃ¤ndler [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Vonderach &lt;christian.vonderach@forst.bwl.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-25 13:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='TapeS-package'>TapeS: New taper functions for most common tree species in Germany and
evaluating functions.</h2><span id='topic+TapeS-package'></span>

<h3>Description</h3>

<p>Implementing new taper functions for German NFI and making available
associated function to evaluate diameter, height of diameter, bark thickness,
biomass and volume of these taper functions. Also providing wrappers to
calculate specific diameters like dbh, d005, d03 and d7 as well as specific
volume measures like Vfm, Efm, VolR, VolE, Vol_FAO, and physical stem volume.
</p>


<h3>Details</h3>

<p>The package contains datasets which hold the taper curve models and further
parameters used inside the provided functions
(see <code>data(package="TapeS")</code>).
</p>

<hr>
<h2 id='Az'>estimate minimum cutting diameter</h2><span id='topic+Az'></span>

<h3>Description</h3>

<p>estimate minimum cutting diameter based on diameter in breast
height based on the functions implemented in BDAT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Az(sp, dbh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Az_+3A_sp">sp</code></td>
<td>
<p>Bdat species code [1;36], integer</p>
</td></tr>
<tr><td><code id="Az_+3A_dbh">dbh</code></td>
<td>
<p>vector of diameter in breast height, numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the implemented BDAT function and parameters are used. Not all
BDAT-species possess their own parameters, hence most of them are matched to
one of the main tree species, especially in deciduous tree species (only
parameters for beech and oak are available).
</p>


<h3>Value</h3>

<p>vector of minimum cutting diameter [cm].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp &lt;- 1
dbh &lt;- 30
Az(sp, dbh)
</code></pre>

<hr>
<h2 id='azp'>Data: Function Parameters to estimate cutting diameter</h2><span id='topic+azp'></span>

<h3>Description</h3>

<p>Parameters for linear regression model of form
Az=exp(p1+p2*log(dbh)+p3*(log(dbh)^2)+p4*dbh).
Function returns expected cutting diameter according to species and diameter
in breast height (dbh). Parameters taken from source code of BDAT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azp
</code></pre>


<h3>Format</h3>

<p>A two-dimensional array. rows refer to species, columns to parameter
of linear model.
</p>


<h3>Details</h3>

<p>The implemented species are (column=species name):
1=Norway spruce (S-Dt)
2=Norway spruce (N-Dt)
3=Silver fir
4=Scots pine
5=European larch
6=European beech
7=Quercus petraea and robur, possibly rubra
</p>


<h3>Source</h3>

<p>BDAT-Fortran-library
</p>


<h3>References</h3>

<p>Kublin and Scharnagl, 1988.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(azp)
dim(azp)
azp[1,] # 1=Norway spruce (S-Dt)
dbh &lt;- 30
exp(azp[1,1]+azp[1,2]*log(dbh)+azp[1,3]*(log(dbh)^2)+azp[1,4]*dbh) # as implemented

</code></pre>

<hr>
<h2 id='BaMap'>function for mapping the 36 tree species to several internal functions</h2><span id='topic+BaMap'></span>

<h3>Description</h3>

<p>function for mapping the 36 tree species to several internal functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BaMap(Ba = NULL, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BaMap_+3A_ba">Ba</code></td>
<td>
<p>BDAT tree number</p>
</td></tr>
<tr><td><code id="BaMap_+3A_type">type</code></td>
<td>
<p>a number referring to the type to be mapped</p>
</td></tr>
</table>


<h3>Details</h3>

<p>c.f. BDAT source code, line 7622, data block Ban(36, 7)
type 1: Schaftform // taper form
type 2: Rinde // bark
type 3: Durchschnittliche Aufarbeitungsgrenze (nach EST) //average cutting diameter
type 4: HÃ¶he unverwertbares Derbholz // percentage non-merchantable coarse wood
type 5: durchschnittlicher Astdurchmesser in der Krone // average branch diameter inside crown
type 6: BWI-Biomasse-Funktionen // NFI-biomass functions according to Riedel &amp; KÃ¤ndler (2017)
type 7: kompartimentweise Biomassefunktionen // component biomass functions according to Vonderach et al (2018)
type 8: Zuordnung zu volfao // Mapping to volume according to FAO (FIX: mapping still temporary)
Not included: volume tables according to Grundner and Schwappach as well as
volume tables according to Krenn for small trees below 10cm dbh
</p>


<h3>Value</h3>

<p>value(s), either a scalar, vector or matrix, with respect to tree
species mapping to functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BaMap(1,1) # which taper form for Norway spruce
BaMap(15,1) # which taper form for European Beech
BaMap(15,2) # which bark equation for European Beech
BaMap(,1) # return all taper form mappings
BaMap(1,) # return all mappings for Norway spruce
BaMap() # return all mappings
BaMap(, 6) # biomass mapping
BaMap(, 7) # component biomass functions
BaMap(, 8) # mapping for Vol_FAO
</code></pre>

<hr>
<h2 id='bark'>Double Bark Thickness</h2><span id='topic+bark'></span>

<h3>Description</h3>

<p>Function returns double bark thickness according to
Altherr et al. 1974/75/76/78/79
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bark(Ba, Dm, relH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bark_+3A_ba">Ba</code></td>
<td>
<p>tree species according to BDAT, cf. <code><a href="#topic+tprSpeciesCode">tprSpeciesCode</a></code></p>
</td></tr>
<tr><td><code id="bark_+3A_dm">Dm</code></td>
<td>
<p>diameter for which double bark thickness is requested</p>
</td></tr>
<tr><td><code id="bark_+3A_relh">relH</code></td>
<td>
<p>relative height of Dm inside stem</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function re-implemented according to
Subroutine RINDE(Hhrel,Kw,Ri,Hsga,Zo), BDAT-fortran Code line 5691ff.
No Functions for (historic) Heilbronner Sortierung implemented.
</p>
<p>NB: to avoid negative double bark thickness, such values are constraint to
zero. Additionally, diameter after bark reduction might not be smaller than
zero, hence double bark thickness is reduce to <code>Dm</code>.
</p>


<h3>Value</h3>

<p>double bark thickness [cm]
</p>


<h3>References</h3>

<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1974). Statistische
Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung unentrindeten
Stammholzes. Kiefer, Buche, Hainbuche, Esche und Roterle. Freiburg i. Br.,
Forstl. Versuchs- u. Forschungsanst. Baden-WÃ¼rttenberg.
</p>
<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1975). Statistische
Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung unentrindeten
Stammholzes. EuropÃ¤ische LÃ¤rche, Japanische LÃ¤rche, Schwarzkiefer, Stieleiche,
Traubeneiche, Roteiche, Bergahorn und Linde. Freiburg i. Br., Forstl.
Versuchs- u. Forschungsanst. Baden-WÃ¼rttenberg.
</p>
<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1976). Statistische
Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung unentrindeten
Stammholzes. Weymouthskiefer, Robinie, Bergulme, Birke, Marilandica-Pappel
und Robusta-Pappel. Freiburg i. Br., Forstl. Versuchs- u. Forschungsanst.
Baden-WÃ¼rttenberg.
</p>
<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1978). Statistische
Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung unentrindeten
Stammholzes. Fichte, Tanne, Douglasie und Sitka-Fichte. Freiburg i. Br.,
Forstl. Versuchs- u. Forschungsanst. Baden-WÃ¼rttenberg.
</p>
<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1979). Statistische
Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung unentrindeten
Stammholzes. Neupotz-Pappel, Regenerata-Pappel, Kirsche, Spitzahorn, Feldahorn,
Aspe, Weide, Flatterulme, Tulpenbaum u. Elsbeere. Freiburg i. Br., Forstl.
Versuchs- u. Forschungsanst. Baden-WÃ¼rttenberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bark(1, 30, .1)
bark(11, 4, .1) # zero instead of -0.2497
</code></pre>

<hr>
<h2 id='biomass'>Prediction of above-ground biomass according to NFI-functions</h2><span id='topic+biomass'></span>

<h3>Description</h3>

<p>Prediction of total above-ground biomass for trees defined via species, dbh,
d03 and height
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biomass(spp, d13, d03, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biomass_+3A_spp">spp</code></td>
<td>
<p>vector of species code for biomass function [1;18]</p>
</td></tr>
<tr><td><code id="biomass_+3A_d13">d13</code></td>
<td>
<p>vector of diameter in breast height in centimeter</p>
</td></tr>
<tr><td><code id="biomass_+3A_d03">d03</code></td>
<td>
<p>vector of diameter in 30% of tree height in centimeter</p>
</td></tr>
<tr><td><code id="biomass_+3A_h">h</code></td>
<td>
<p>vector of height of trees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>code taken from BDAT (Koeff.f).
</p>


<h3>Value</h3>

<p>a vector of total above-ground biomass
</p>


<h3>References</h3>

<p>Riedel, T. and G. Kaendler (2017). &quot;Nationale Treibhausgasberichterstattung:
Neue Funktionen zur SchÃ¤tzung der oberirdischen Biomasse am Einzelbaum.&quot;
Forstarchiv 88(2): 31-38.
</p>

<hr>
<h2 id='calcVCOVsekVol'>calculate VCOV-Matrix for volume segments</h2><span id='topic+calcVCOVsekVol'></span>

<h3>Description</h3>

<p>calculate variance-covariance matrix for volume segments from
the estimated diameter and uncertainty information from TapeR-model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVCOVsekVol(estD, kovD, estL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVCOVsekVol_+3A_estd">estD</code></td>
<td>
<p>vector of estimated diameter, numeric</p>
</td></tr>
<tr><td><code id="calcVCOVsekVol_+3A_kovd">kovD</code></td>
<td>
<p>variance-covariance-matrix of the estimated diameter, numeric</p>
</td></tr>
<tr><td><code id="calcVCOVsekVol_+3A_estl">estL</code></td>
<td>
<p>vector of segment length, numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations according to rules for products and sums of variances
</p>


<h3>Value</h3>

<p>variance-covariance matrix of the segment volume
</p>

<hr>
<h2 id='check_monotonicity'>monotonicity check for taper curve</h2><span id='topic+check_monotonicity'></span>

<h3>Description</h3>

<p>monotonicity check for taper curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_monotonicity(obj, Rfn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_monotonicity_+3A_obj">obj</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="check_monotonicity_+3A_rfn">Rfn</code></td>
<td>
<p>Rfn setting for residuals error matrix, defaults to
<code>list(fn="sig2")</code>, see <code><a href="TapeR.html#topic+resVar">resVar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taper curves are required to decrease monotonically. To avoid the
evaluation of non-monotone taper curves, a check is done through the
constructor function and an indicator (<code>monotone</code>) is set for each tree
stored inside the <code>tprTrees</code>-class. As the data has been check on validity
before this function is applied, we can use the tpr*-functions to evaluate
the taper curve and its monotonicity.
The check is done via comparison of the expected diameters along the trunk in
1m-steps and its sorted (monotonically decreasing) version using
<code><a href="base.html#topic+identical">identical</a></code>.
</p>


<h3>Value</h3>

<p>vector of logicals, same length as <code>spp</code>.
</p>

<hr>
<h2 id='crownExpansion'>Data: Crown wood expansion models to include branch coarse wood</h2><span id='topic+crownExpansion'></span>

<h3>Description</h3>

<p>This data gives percentage of branch coarse wood (as difference between TapeS
and BDAT taper curves) with respect to BDAT crown coarse wood. With these
models one can expand the TapeS main axis crown coarse wood into total
crown coarse wood. Yet, a clear volume reference of very large trees - the
case, where expansion seems to be necessary - does not exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crownExpansion
</code></pre>


<h3>Format</h3>

<p>a list with two elemens, each a (GAM) model
</p>


<h3>Source</h3>

<p>based on comparison between BDAT and TapeS
</p>


<h3>References</h3>

<p>none, yet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crownExpansion)
str(crownExpansion, max.level=1)
</code></pre>

<hr>
<h2 id='data_coercion'>coerce different data sources into class 'tprTrees'</h2><span id='topic+data_coercion'></span><span id='topic+nfi_as_tprtrees'></span><span id='topic+seg_as_tprtrees'></span><span id='topic+bdat_as_tprtrees'></span>

<h3>Description</h3>

<p>coercion functions to make NFI, segment and 'BDAT' data
available as 'tprTrees' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nfi_as_tprtrees(nfi, mapping = NULL)

seg_as_tprtrees(seg, mapping = NULL)

bdat_as_tprtrees(bdat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_coercion_+3A_nfi">nfi</code></td>
<td>
<p>data.frame with tree measurements as provided by german NFI</p>
</td></tr>
<tr><td><code id="data_coercion_+3A_mapping">mapping</code></td>
<td>
<p>mapping of column names</p>
</td></tr>
<tr><td><code id="data_coercion_+3A_seg">seg</code></td>
<td>
<p>data.frame with measured tree segments, see details.</p>
</td></tr>
<tr><td><code id="data_coercion_+3A_bdat">bdat</code></td>
<td>
<p>data.frame holding data to process with rBDAT</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coerced data is automatically checked for validity by the class
constructor. For available species codes see <code><a href="#topic+tprSpeciesCode">tprSpeciesCode</a></code>.
</p>
<p>When coercing NFI (National forest inventory, BWI) data, one need
to provide the columns <code>BaTpr</code> (species code), <code>Bhd</code> (Dbh, [mm]),
<code>D03, [mm]</code> (diameter in 30% of tree height) and <code>Hoehe</code> (tree
height, [dm]). Optionally, one can provide <code>H1</code> (measurement height of
<code>Bhd</code>, [dm]), <code>H2</code> (measurement height of <code>D03</code>, [dm]) as well
as <code>sHt</code> (measurement error of tree height, i.e. standard deviation [dm]);
otherwise these are assumed to be 1.3m, 30% of tree height and 0 (zero),
respectively.
</p>
<p>Additionally, the NFI database stores diameter as [mm] and height as [dm]; it
is *not* necessary to transform to [cm] and [m], as the function does this.
Equally, <code>sHt</code> [dm] is transformed to <code>sHt</code> [m].
</p>
<p>Keep in mind that species codes of NFI are different from the taper models
for historical reasons (c.f. BDAT). Use the NFI table  ('x_Ba') to map
species codes beforehand (see examples).
</p>
<p>Sectional measurements provide more information about the trunk of
a tree and are usually stored in a different way. They exhibit an arbitrary
amount of diameter measurements which also might vary from tree to tree.
Hence, <code>seg_as_tprtrees</code> expects a data.frame with columns
<code>Id</code>, <code>BaTpr</code> (species code), <code>Dm</code> (diameter measured, [cm]),
<code>Hm</code> (height of <code>Dm</code>, [m]) and optionally <code>Ht</code> (height of
tree, [m]). Tree height <code>Ht</code> can be included to
<code>Dm</code>-<code>Hm</code>-pairs with <code>Dm</code> being zero
(e.g. <code>Dm</code>=0, <code>Hm</code>=25). If <code>Ht</code> is given, it gains priority.
</p>
<p>coercing object of class 'datBDAT' from R-Package &quot;rBDAT&quot; into
class 'tprTrees'
</p>


<h3>Value</h3>

<p>an object of class 'tprTrees', see <code><a href="#topic+tprTrees-class">tprTrees-class</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>nfi_as_tprtrees()</code>: coercion of German NFI data
</p>
</li>
<li> <p><code>seg_as_tprtrees()</code>: coercion of segmented data to class 'tprTrees'
</p>
</li>
<li> <p><code>bdat_as_tprtrees()</code>: coercion of bdat data
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+tprTrees-class">tprTrees-class</a></code>, <code><a href="#topic+tprTrees">tprTrees</a></code>,
<code><a href="#topic+tprSpeciesCode">tprSpeciesCode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># NFI data usually stored as integer and units: diameter=[mm] and height=[dm]
nfi &lt;- data.frame(BaTpr=1L, Bhd=300L, D03=270L, Hoehe=250L)
tpr &lt;- nfi_as_tprtrees(nfi)
tpr
tpr@sHt # defaults to 0

# one can provide measurement heights explicitly
nfi &lt;- data.frame(spp=1, Bhd=300, H1=12, D03=270, H=250)
nfi_as_tprtrees(nfi, mapping=c(spp="BaTpr", H="Hoehe"))

# measurement error in height
nfi &lt;- data.frame(BaTpr=1L, Bhd=300L, D03=270L, Hoehe=250L, sHt=15)
tpr &lt;- nfi_as_tprtrees(nfi)
tpr@sHt
## coercing sectional measurements
data(DxHx.df, package = "TapeR")
DxHx.df$BaTpr &lt;- 1 # Norway spruce
segtprtrees &lt;- seg_as_tprtrees(DxHx.df, mapping=c(Dx="Dm", Hx="Hm"))

## extract tree height from Dm-Hm measurements if not given explicitly
DxHx.df$Ht &lt;- NULL # remove height, as already included with Dm=0
segtprtrees &lt;- seg_as_tprtrees(DxHx.df, mapping=c(Dx="Dm", Hx="Hm"))
segtprtrees
if(require(rBDAT)){
  bdt &lt;- buildTree(list(spp=1, D1=30, D2=28, H2=7, H=25))
  bdat_as_tprtrees(bdt)
}


</code></pre>

<hr>
<h2 id='Dbh'>Extract pre-defined diameter</h2><span id='topic+Dbh'></span><span id='topic+Bhd'></span><span id='topic+D13'></span><span id='topic+D7'></span><span id='topic+D03'></span><span id='topic+D005'></span>

<h3>Description</h3>

<p>Function extracts pre-defined diameters, e.g. dbh (in 1.3m) or
D03 (in 30% of tree height) for a <code><a href="#topic+tprTrees">tprTrees</a></code>-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dbh(obj)

Bhd(obj)

D13(obj)

D7(obj)

D03(obj)

D005(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dbh_+3A_obj">obj</code></td>
<td>
<p>a object of class 'tprTrees'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a wrapper around <code><a href="#topic+tprDiameter">tprDiameter</a></code> to calculate specifically
defined diameters like diameter in breast height (dbh), diameter in 7m above
ground or in 5% and 30% of tree height.
</p>


<h3>Value</h3>

<p>diameter(s) in predefined heights
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Dbh()</code>: wrapper to calculate diameter in breast height
</p>
</li>
<li> <p><code>Bhd()</code>: German alias for function Dbh
</p>
</li>
<li> <p><code>D13()</code>: Height specific alias for function Dbh
</p>
</li>
<li> <p><code>D7()</code>: Function to calculate diameter over bark in 7m above ground
</p>
</li>
<li> <p><code>D03()</code>: Function to calculate diameter over bark in 30% of tree height
</p>
</li>
<li> <p><code>D005()</code>: Function to calculate diameter over bark in 5% of tree height
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- tprTrees()
Dbh(t) # diameter in breast height (i.e. 1.3m)
Bhd(t) # same, german named function name
D13(t) # same, height related function name
D005(t) # diameter in 5% of tree height
D7(t) # diameter in height of 7m
D03(t) # diameter in 30% of tree height
</code></pre>

<hr>
<h2 id='dbtp'>Data: Function Parameters to estimate double bark thickness</h2><span id='topic+dbtp'></span>

<h3>Description</h3>

<p>Parameters for linear regression models to estimate double bark thickness
according to species, diameter over bark and stem part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbtp
</code></pre>


<h3>Format</h3>

<p>A three-dimensional array, first dimension refer to species code,
second dimension to required function (stem part) and third dimension to the
required parameter.
</p>


<h3>Source</h3>

<p>BDAT-Fortran-library
</p>


<h3>References</h3>

<p>Kublin and Scharnagl, 1988.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dbtp)
dbtp[1,,]
dbtp[1,1,]

</code></pre>

<hr>
<h2 id='E_HDxoR_HmDm_Ht.f'>Find Height of diameter under bark via uniroot</h2><span id='topic+E_HDxoR_HmDm_Ht.f'></span><span id='topic+HxoR_root.f'></span>

<h3>Description</h3>

<p>Functional equivalent to <code><a href="TapeR.html#topic+E_HDx_HmDm_HT.f">E_HDx_HmDm_HT.f</a></code>,
finding the height of a given diameter *without* bark, i.e. double bark
thickness needs to be added on top of given diameter to find appropriate
height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E_HDxoR_HmDm_Ht.f(DxoR, Hm, Dm, mHt, sHt = 0, par.lme, Rfn = NULL, ...)

HxoR_root.f(Hx, DxoR, Hm, Dm, mHt, sHt, par.lme, Rfn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="E_HDxoR_HmDm_Ht.f_+3A_dxor">DxoR</code></td>
<td>
<p>Scalar. Diameter under bark for which to return height.</p>
</td></tr>
<tr><td><code id="E_HDxoR_HmDm_Ht.f_+3A_hm">Hm</code></td>
<td>
<p>Numeric vector of stem heights (m) along which diameter
measurements were taken for calibration. Can be of length 1. Must be of same
length as <code>Dm</code>.</p>
</td></tr>
<tr><td><code id="E_HDxoR_HmDm_Ht.f_+3A_dm">Dm</code></td>
<td>
<p>Numeric vector of diameter measurements (cm) taken for calibration.
Can be of length 1. Must be of same length as <code>Hm</code>.</p>
</td></tr>
<tr><td><code id="E_HDxoR_HmDm_Ht.f_+3A_mht">mHt</code></td>
<td>
<p>Scalar. Tree height (m).</p>
</td></tr>
<tr><td><code id="E_HDxoR_HmDm_Ht.f_+3A_sht">sHt</code></td>
<td>
<p>Scalar. Standard deviation of stem height. Can be 0 if height was
measured without error.</p>
</td></tr>
<tr><td><code id="E_HDxoR_HmDm_Ht.f_+3A_par.lme">par.lme</code></td>
<td>
<p>List of taper model parameters obtained by
<code><a href="TapeR.html#topic+TapeR_FIT_LME.f">TapeR_FIT_LME.f</a></code>, enhanced by the attribute 'spp', which
refers to the tree species used for double bark thickness</p>
</td></tr>
<tr><td><code id="E_HDxoR_HmDm_Ht.f_+3A_rfn">Rfn</code></td>
<td>
<p>setting for residuals error matrix, defaults to <code>"sig2"</code>, see
details.</p>
</td></tr>
<tr><td><code id="E_HDxoR_HmDm_Ht.f_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
<tr><td><code id="E_HDxoR_HmDm_Ht.f_+3A_hx">Hx</code></td>
<td>
<p>height at which taper curve is evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>finds height of given diameter via <code>uniroot</code>.
</p>


<h3>Value</h3>

<p>A scalar. Estimated height (m) given a diameter without bark.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>HxoR_root.f()</code>: function to be searched
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tprTrees()
spp &lt;- spp(tmp)
Hm &lt;- Hm(tmp)
Dm &lt;- Dm(tmp)
H &lt;- Ht(tmp)
data("SKPar")
sppSK &lt;- BaMap(spp, 1) # tree species for taper curve
## diameter in 5m height
TapeR::E_DHx_HmDm_HT.f(c(5, 10), Hm, Dm, mHt=H, sHt = 0, par.lme = SKPar[[sppSK]])$DHx
(D5m &lt;- TapeR::E_DHx_HmDm_HT.f(c(5, 10), Hm, Dm, mHt=H, sHt = 0, par.lme = SKPar[[sppSK]])$DHx)
## bark thickness of diameter in 5m height
(RiD5m &lt;- bark(c(1,1), Dm = D5m, relH = c(5, 10)/H))
## find height of diameter without bark, which should be 5m
d5mub &lt;- D5m - RiD5m
E_HDxoR_HmDm_Ht.f(DxoR = d5mub, Hm = Hm, Dm = Dm, mHt = H,
                  sHt = 0, par.lme = SKPar[[sppSK]])
</code></pre>

<hr>
<h2 id='estHeight'>Estimate tree height by DBH according to BWI3</h2><span id='topic+estHeight'></span>

<h3>Description</h3>

<p>Function calculates expected tree height given diameter in
breast height and species code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estHeight(d13, sp, qtl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estHeight_+3A_d13">d13</code></td>
<td>
<p>numeric vector of diameter in breast height [cm]</p>
</td></tr>
<tr><td><code id="estHeight_+3A_sp">sp</code></td>
<td>
<p>TapeS species code, see also <code><a href="#topic+tprSpeciesCode">tprSpeciesCode</a></code></p>
</td></tr>
<tr><td><code id="estHeight_+3A_qtl">qtl</code></td>
<td>
<p>desired quantile of height, either NULL (LS-regression) or one of
17, 50, 83 (quantile regression)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function evaluates the expected value of a Pettersen-Height Function
based on diameter in breast height and tree species code.
The Pettersen-Function (<code class="reqn">h = 1.3 + (a + \frac{b}{dbh})^{-3}</code>) was fitted
on NFI 3 (BWI 3) data, using the main stand only.
</p>
<p><code>d13</code> and <code>sp</code> should be of equal length or one of it can
be &gt; 1 if the other is of length 1. Then, the shorter object will be extended
to match the length of the longer object. See examples.
</p>
<p>The quantile option return tree height at quantiles 17, 50 or 83. If
<code>qtl</code> is NULL, the result of a nonlinear least-squares regression is
provided.
</p>


<h3>Value</h3>

<p>a vector of same length as <code>d13</code> or <code>sp</code>, with tree
height in [m].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp &lt;- 1
d13 &lt;- 30
estHeight(d13, sp)

sp &lt;- 1
d13 &lt;- seq(15, 50, 5)
estHeight(d13, sp)

sp &lt;- 1:36
d13 &lt;- 30
estHeight(d13, sp)
</code></pre>

<hr>
<h2 id='fnUnvd'>percentage of unusable coarse wood</h2><span id='topic+fnUnvd'></span>

<h3>Description</h3>

<p>function extracts the percentage of unusable coarse wood
according to species (beech, oak), diameter class and cutting diameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnUnvd(ba = NULL, dm = NULL, cd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnUnvd_+3A_ba">ba</code></td>
<td>
<p>tree species index; see details</p>
</td></tr>
<tr><td><code id="fnUnvd_+3A_dm">dm</code></td>
<td>
<p>diameter class; see details</p>
</td></tr>
<tr><td><code id="fnUnvd_+3A_cd">cd</code></td>
<td>
<p>cutting diameter; see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function extracts the percentage of unusable coarse wood according
to three parameters: (i) tree species, which is 1 for using beech models and
2 for using the oak model; (ii) the 2cm-diameter class (from 8 and 60cm) and
(iii) the cutting diameter ranging from 8 to 40cm.
</p>


<h3>References</h3>

<p>Kublin and Scharnagl (1988): Verfahrens- und Programmbeschreibung
zum BWI-Unterprogramm BDAT. FVA-BW 1988. ISSN: 0178-3165.
</p>

<hr>
<h2 id='FormTariff'>Tariff for taper form</h2><span id='topic+FormTariff'></span>

<h3>Description</h3>

<p>evaluates tariff functions to estimate taper form, i.e. quotient
of d03 by d005
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormTariff(spp, Dbh, Ht, inv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FormTariff_+3A_spp">spp</code></td>
<td>
<p>species code of <code>tprSpeciesCode</code></p>
</td></tr>
<tr><td><code id="FormTariff_+3A_dbh">Dbh</code></td>
<td>
<p>diameter of considered tree at 1.3m above ground [cm]</p>
</td></tr>
<tr><td><code id="FormTariff_+3A_ht">Ht</code></td>
<td>
<p>tree height of considered tree [m]</p>
</td></tr>
<tr><td><code id="FormTariff_+3A_inv">inv</code></td>
<td>
<p>indicator for inventory (0=TapeS taper curve models,
1=NFI1, 2=NsoG, 3=IS08, 4=NFI3, 5=BDAT)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quotient of d03 / d005 [unitless]
</p>


<h3>References</h3>

<p>c.f. rBDAT::getForm respectively BDAT source code FormTarif.f
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## dont't run
spp &lt;- 15
Dbh &lt;- 30
Ht &lt;- 27
FormTariff(spp, Dbh, Ht, 0)
FormTariff(spp=c(1:2), Dbh=c(30, 30), Ht=c(27, 24), inv=0)
if(require("rBDAT")){
  FormTariff(spp, Dbh, Ht, 0)
  rBDAT::getForm(list(spp=spp, D1=Dbh, H1=1.3, H=Ht), inv=0) # different taper curves!
  FormTariff(spp, Dbh, Ht, 1)
  rBDAT::getForm(list(spp=spp, D1=Dbh, H1=1.3, H=Ht), inv=1) # identical
  FormTariff(spp, Dbh, Ht, 2)
  rBDAT::getForm(list(spp=spp, D1=Dbh, H1=1.3, H=Ht), inv=2) # identical
  FormTariff(spp, Dbh, Ht, 3)
  rBDAT::getForm(list(spp=spp, D1=Dbh, H1=1.3, H=Ht), inv=3) # identical
  FormTariff(spp, Dbh, Ht, 4)
  rBDAT::getForm(list(spp=spp, D1=Dbh, H1=1.3, H=Ht), inv=4) # identical
}

</code></pre>

<hr>
<h2 id='HtCoef'>returns coefficients for Pettersen-Height model</h2><span id='topic+HtCoef'></span>

<h3>Description</h3>

<p>Function to provide model coefficients for Pettersen-height model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HtCoef(sp = NULL, qtl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HtCoef_+3A_sp">sp</code></td>
<td>
<p>BDAT species code, could be NULL then all coefficients are returned</p>
</td></tr>
<tr><td><code id="HtCoef_+3A_qtl">qtl</code></td>
<td>
<p>quantile, either NULL or 17, 50, 83</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with species code and coefficients
</p>

<hr>
<h2 id='lmeSKEBLUP'>diameter prediction E[d] for TapeR-object</h2><span id='topic+lmeSKEBLUP'></span>

<h3>Description</h3>

<p>Prediction diameter (no variances) for given tree and TapeR-object using
BSpline Matrix all in C++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmeSKEBLUP(xm, ym, xp, par, RV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmeSKEBLUP_+3A_xm">xm</code></td>
<td>
<p>relative height of measured diameter</p>
</td></tr>
<tr><td><code id="lmeSKEBLUP_+3A_ym">ym</code></td>
<td>
<p>measured diameter for calibration</p>
</td></tr>
<tr><td><code id="lmeSKEBLUP_+3A_xp">xp</code></td>
<td>
<p>relative height for which diameter prediction is required</p>
</td></tr>
<tr><td><code id="lmeSKEBLUP_+3A_par">par</code></td>
<td>
<p>a TapeR-object (including padded knots vector)</p>
</td></tr>
<tr><td><code id="lmeSKEBLUP_+3A_rv">RV</code></td>
<td>
<p>numeric vector holding assumed residual variance for each observation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>code implementation in C++ following the code base of TapeR. Bspline
matrix code taken from R-package splines to avoid the need of calling R from C.
</p>


<h3>Value</h3>

<p>a list holding several elements, perspectively only the estimated diameter
</p>

<hr>
<h2 id='nsur'>Component biomass functions</h2><span id='topic+nsur'></span>

<h3>Description</h3>

<p>evaluation of the component biomass functions fit by nonlinear seemingly
unrelated regression (NSUR) to estimate absolute or relative component mass
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsur(spp, dbh, ht, sth, d03, kl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsur_+3A_spp">spp</code></td>
<td>
<p>vector of species code for biomass component function of interval
[1;8]; see <code><a href="#topic+BaMap">BaMap</a></code> for mapping of species model codes</p>
</td></tr>
<tr><td><code id="nsur_+3A_dbh">dbh</code></td>
<td>
<p>vector of diameter in breast height; in centimeter</p>
</td></tr>
<tr><td><code id="nsur_+3A_ht">ht</code></td>
<td>
<p>vector of tree heights, in meter</p>
</td></tr>
<tr><td><code id="nsur_+3A_sth">sth</code></td>
<td>
<p>vector of stump heights, in meter</p>
</td></tr>
<tr><td><code id="nsur_+3A_d03">d03</code></td>
<td>
<p>vector if diameter in 30% of tree height, in centimeter</p>
</td></tr>
<tr><td><code id="nsur_+3A_kl">kl</code></td>
<td>
<p>vector of green crown base, in meter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to calculate component biomass; functions fitted using
same methodology as in Vonderach et al. (2018) with slightly updated
parameters as in Vonderach and KÃ¤ndler (2021); species mapping as in
<code>TapeS::BaMap(, type=7)</code>
</p>


<h3>Value</h3>

<p>a numeric matrix holding component biomass
</p>


<h3>References</h3>

<p>Vonderach, C., G. KÃ¤ndler and C. F. Dormann (2018).
&quot;Consistent set of additive biomass functions for eight tree species in
Germany fit by nonlinear seemingly unrelated regression.&quot;
Annals of Forest Science 75(2): 49.
doi: <a href="https://doi.org/10.1007/s13595-018-0728-4">10.1007/s13595-018-0728-4</a>
</p>
<p>Vonderach, C. and G. KÃ¤ndler (2021). Neuentwicklung von Schaftkurven- und
Biomassemodellen fÃ¼r die Bundeswaldinventur auf Basis des TapeR-Pakets -
Abschlussbericht zum Projekt BWI-TapeR. Freiburg: 150p.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nsur(spp = c(1, 6),
     dbh = c(30, 30),
     ht = c(25, 27),
     sth = c(0.25, 0.27),
     d03 = c(27, 27),
     kl = .7*c(25, 27))
</code></pre>

<hr>
<h2 id='parSort'>constructor for class parSort</h2><span id='topic+parSort'></span>

<h3>Description</h3>

<p>function to call <code>new()</code> on class <code>parSort</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parSort(
  n = 1,
  stH = 0,
  Lxh = 0,
  Hkz = 0L,
  Skz = 0L,
  Hsh = 0,
  Zsh = 0,
  Lsh = 0,
  Zab = 14,
  Lab = 0,
  Az = 0,
  LIh = 0,
  trL = 0,
  fixN = 0L,
  fixL = 0,
  fixZ = 0,
  fixA = 0,
  fixR = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parSort_+3A_n">n</code></td>
<td>
<p>the number of parameter sets to generate, defaults to 1</p>
</td></tr>
<tr><td><code id="parSort_+3A_sth">stH</code></td>
<td>
<p>stump height</p>
</td></tr>
<tr><td><code id="parSort_+3A_lxh">Lxh</code></td>
<td>
<p>length of unusable wood at stem foot, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_hkz">Hkz</code></td>
<td>
<p>height indicator, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_skz">Skz</code></td>
<td>
<p>stem indicator, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_hsh">Hsh</code></td>
<td>
<p>height of stem wood, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_zsh">Zsh</code></td>
<td>
<p>cutting diameter of stem wood, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_lsh">Lsh</code></td>
<td>
<p>length of stem wood, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_zab">Zab</code></td>
<td>
<p>cutting diameter of upper trunk, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_lab">Lab</code></td>
<td>
<p>length of upper trunk, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_az">Az</code></td>
<td>
<p>minimal cutting diameter, defaults to 7cm, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_lih">LIh</code></td>
<td>
<p>length of industrial wood, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_trl">trL</code></td>
<td>
<p>maximum transport length</p>
</td></tr>
<tr><td><code id="parSort_+3A_fixn">fixN</code></td>
<td>
<p>number of fixed length assortments, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_fixl">fixL</code></td>
<td>
<p>length of fixed length assortments, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_fixz">fixZ</code></td>
<td>
<p>cutting diameter of fixed length assortments, see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_fixa">fixA</code></td>
<td>
<p>absolute add-on for good measure of fixed length assortments,
given in cm; see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_fixr">fixR</code></td>
<td>
<p>relative add-on for good measure of fixed length assortments,
given in percentage, i.e. 1% = 1; see details</p>
</td></tr>
<tr><td><code id="parSort_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if n is not given (or one) and any of the other parameter is given
with length greater than one, n is reset to the maximum length of all
parameters; care should be taken when using n and individual parameter
setting for several trees.
</p>


<h3>Value</h3>

<p>an object of class <code>parSort</code>, i.e. a list, each element of
length <code>n</code> or maximum of length of defined parameters
</p>

<hr>
<h2 id='parSort-class'>An S4 class to represent the parameters for tree assorting.</h2><span id='topic+parSort-class'></span><span id='topic++5B+2CparSort+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CparSort-method'></span>

<h3>Description</h3>

<p>This class represents one or multiple parameter sets holding the
necessary information to specify the assortment process.
</p>
<p>using indices i and j to subset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'parSort,ANY,ANY,ANY'
x[i, j, ..., drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parSort-class_+3A_x">x</code></td>
<td>
<p>object from which to extract</p>
</td></tr>
<tr><td><code id="parSort-class_+3A_i">i</code></td>
<td>
<p>index i</p>
</td></tr>
<tr><td><code id="parSort-class_+3A_j">j</code></td>
<td>
<p>index j</p>
</td></tr>
<tr><td><code id="parSort-class_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
<tr><td><code id="parSort-class_+3A_drop">drop</code></td>
<td>
<p>drop dimensions, defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assortment process is defined by several parameters. These
follow the specification of its ancestor BDAT , but
are extended to allow for fix length assortments at the tree top
(industrial wood / pulp wood) and relaxes transport length and stump height.
</p>

<ul>
<li><p> stH: stump height, defaults to 0, i.e. 1% of tree height
</p>
</li>
<li><p> Lxh: length of unusable wood at stem foot [m], defaults to 0 (X-Holz)
</p>
</li>
<li><p> Hkz: indicator for tree top, 0 - normal, 1 - Wipfelbruch,
2 - Gipfelbruch
</p>

<ul>
<li><p> 0 =&gt; H=H (default)
</p>
</li>
<li><p> 1 =&gt; H=H+2
</p>
</li>
<li><p> 2 =&gt; DBH &lt; 30 =&gt; H=DBH; dbh &gt; 30 =&gt; H = 30 + (DBH-30) * 0.3
</p>
</li></ul>

</li>
<li><p> Skz: indicator for stem type, defaults to 0
</p>

<ul>
<li><p> 0 =&gt; conifer trees =&gt; no assortment restriction;
deciduous trees =&gt; no assortments
</p>
</li>
<li><p> 1 =&gt; monopodial deciduous trees =&gt; Hsh = 0.7*H
</p>
</li>
<li><p> 2 =&gt; branching between dbh and 7m =&gt; Hsh = 5m
</p>
</li>
<li><p> 3 =&gt; crown base &lt; 3m =&gt; Hsh=0.1
</p>
</li>
<li><p> 4 =&gt; dead or broken stem =&gt; Az = H*0.7
</p>
</li>
<li><p> 5 =&gt; dead tree =&gt; non-usable wood
</p>
</li></ul>

</li>
<li><p> Hsh: usable stem height, defaults to 0, i.e. 0.7*H
</p>
</li>
<li><p> Zsh: minimum cutting diameter under bark for stem wood [cm], defaults
to 0, using parameter <code>Az</code> if estimated length &lt; maximum length
(i.e. 20m)
</p>
</li>
<li><p> Lsh: length of stem wood, defaults to 0, i.e. length unrestricted
</p>
</li>
<li><p> Zab: minimum cutting diameter under bark for top segment [cm],
defaults to 0, i.e. 14cm under bark
</p>
</li>
<li><p> Lab: length of top segment, defaults to 0, i.e. length unrestricted
</p>
</li>
<li><p> Az: minimum cutting diameter over bark [cm], defaults to 0,
using an exponential function given DBH to estimate Az
</p>
</li>
<li><p> LIh: length of industrial wood [m], defaults to 0, i.e. length
unrestricted
</p>
</li>
<li><p> trL: maximum transport length of assortments, defaults to 0, i.e. 19m
</p>
</li>
<li><p> fixN: number of fixed length assortments at stem foot, defaults to 0
(no fixed length assortments, irrespective of other fix* parameters)
</p>
</li>
<li><p> fixZ: mininum diameter under bark for fixed length assortment at
stem foot, defaults to 0
</p>
</li>
<li><p> fixL: length of fixed length assortment at stem foot, defaults to 0
</p>
</li>
<li><p> fixA: fixed length assortement add-on in [cm], defaults to 0
</p>
</li>
<li><p> fixR: fixed length assortement add-on in [%], defaults to 0
</p>
</li></ul>



<h3>Value</h3>

<p>a part of the original object
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>x[i</code>: subsetting for class 'parSort'
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>stH</code></dt><dd><p>stump height</p>
</dd>
<dt><code>Lxh</code></dt><dd><p>length of unusable wood at stem foot, see details</p>
</dd>
<dt><code>Hkz</code></dt><dd><p>height indicator, see details</p>
</dd>
<dt><code>Skz</code></dt><dd><p>stem indicator, see details</p>
</dd>
<dt><code>Hsh</code></dt><dd><p>height of stem wood, see details</p>
</dd>
<dt><code>Zsh</code></dt><dd><p>cutting diameter of stem wood, see details</p>
</dd>
<dt><code>Lsh</code></dt><dd><p>length of stem wood, see details</p>
</dd>
<dt><code>Zab</code></dt><dd><p>cutting diameter of upper trunk, see details</p>
</dd>
<dt><code>Lab</code></dt><dd><p>length of upper trunk, see details</p>
</dd>
<dt><code>Az</code></dt><dd><p>minimal cutting diameter, defaults to 7cm, see details</p>
</dd>
<dt><code>LIh</code></dt><dd><p>length of industrial wood, see details</p>
</dd>
<dt><code>trL</code></dt><dd><p>maximum transport length</p>
</dd>
<dt><code>fixN</code></dt><dd><p>number of fixed length assortments, see details</p>
</dd>
<dt><code>fixL</code></dt><dd><p>length of fixed length assortments, see details</p>
</dd>
<dt><code>fixZ</code></dt><dd><p>cutting diameter of fixed length assortments, see details</p>
</dd>
<dt><code>fixA</code></dt><dd><p>absolute add-on for good measure of fixed length assortments,
see details</p>
</dd>
<dt><code>fixR</code></dt><dd><p>relative add-on for good measure of fixed length assortments,
see details</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>parSort()
parSort(Lxh=1)
parSort(n=2)
</code></pre>

<hr>
<h2 id='petterson'>height estimation</h2><span id='topic+petterson'></span>

<h3>Description</h3>

<p>height estimation based on diameter in breast height and species using a
Petterson-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>petterson(sp, d13)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="petterson_+3A_sp">sp</code></td>
<td>
<p>vector of species code for biomass function from interval [1;18];
see <code><a href="#topic+BaMap">BaMap</a></code> for mapping of species model codes</p>
</td></tr>
<tr><td><code id="petterson_+3A_d13">d13</code></td>
<td>
<p>vector of diameter in breast height; in centimeter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar: tree height
</p>

<hr>
<h2 id='plot.tprTrees'>Plot taper curve for an object of class <code>tprTrees</code></h2><span id='topic+plot.tprTrees'></span>

<h3>Description</h3>

<p>creating a plot of the taper curve of a tree, over or under bark
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tprTrees'
plot(
  x,
  bark = NULL,
  col.bark = NULL,
  obs = FALSE,
  assort = NULL,
  legend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tprTrees_+3A_x">x</code></td>
<td>
<p>an object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="plot.tprTrees_+3A_bark">bark</code></td>
<td>
<p>either NULL or logical; if TRUE taper curve over bark is plotted,
if FALSE taper curve under bark is plotted; if NULL, both are plotted</p>
</td></tr>
<tr><td><code id="plot.tprTrees_+3A_col.bark">col.bark</code></td>
<td>
<p>color to be used for plot of bark, if plot of taper curve
over and under bark is requested</p>
</td></tr>
<tr><td><code id="plot.tprTrees_+3A_obs">obs</code></td>
<td>
<p>should observations (measured/observed diameters) be added to
the plot?</p>
</td></tr>
<tr><td><code id="plot.tprTrees_+3A_assort">assort</code></td>
<td>
<p>assortments produced by <code>tprAssortment(, value="merge")</code></p>
</td></tr>
<tr><td><code id="plot.tprTrees_+3A_legend">legend</code></td>
<td>
<p>logical, if legend should be added</p>
</td></tr>
<tr><td><code id="plot.tprTrees_+3A_...">...</code></td>
<td>
<p>further arguments for <code>plot</code> and <code>points</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>plots the taper curve of a tree. Either over bark or under bark, or
both. Elements design can partly be chosen. If assortments are given, these
are added to the plot. Doing that, the assortment bottom and top position is
indicated by a vertical line and mid-diameter is shown as a point with
vertical dashed line. N.B. the mid-diameter shown is under bark and rounded
downwards for 0.5 cm if mid-diameter &lt; 20 and for 0.75 cm if bigger. Volume
is calculated using this diameter. Reason for that behaviour is that
assortment information with regard to diameter and volume reflects the legal
rules for roundwood assortments (german RVR).
Additionally, assortment names are indicated.
One can provide assortment names in a column of <code>assort</code> named
'assortname', which will be used if available, otherwise the 'Sort'-column
will be used. See Examples.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## plotting the taper curve of a tree
oldpar &lt;- par()
par(mfrow = c(1, 1))
tree &lt;- tprTrees(spp=1L, Dm=40, Hm=1.3, H=35)
plot(tree, type = "l", las = 1, legend = TRUE)
plot(tree, bark = TRUE, las = 1)
plot(tree, bark = FALSE, las = 1, obs=TRUE) # obs incl. bark!!!
tree &lt;- tprTrees(spp=c(1, 1), Dm = c(40, 35), Hm=c(1.3, 1.3), H = c(35, 30))
plot(tree, bark = FALSE, las = 1, legend = TRUE) # both trees are plotted
plot(tree, bark = TRUE, las = 1, legend = TRUE, obs=TRUE)

tree &lt;- tprTrees(spp=1L, Dm=c(40, 32), Hm=c(1.3, 10.5), H=35)
plot(tree, type = "l", las = 1, legend = TRUE, obs=TRUE)

## if monotonicity is not forced:
tree &lt;- tprTrees(spp=3L, Dm=8, Hm=1.3, H=10)
plot(tree, type = "l", las = 1, obs=TRUE, mono=FALSE)
plot(tree, type = "l", las = 1, obs=TRUE, mono=TRUE) # default

tree &lt;- tprTrees(spp=c(1, 8), Dm = c(40, 40), Hm=c(1.3, 1.3), H = c(35, 35))
plot(tree, bark = NULL, las = 1, col.bark = "blue", legend = TRUE)
plot(tree, bark = NULL, las = 1, col.bark = "blue", legend = TRUE, obs = TRUE)
plot(tree[1, ], main = tprSpeciesCode(spp(tree[1, ]), out = "long"))
plot(tree[2, ], main = tprSpeciesCode(spp(tree[2, ]), out = "scientific"))
par(mfrow = c(1, 2))
plot(tree, bark = TRUE, las = 1)

## now add assortments into taper curve
par(mfrow = c(1, 1))
pars &lt;- parSort(n=length(tree), Lxh=1, fixN=2, fixL=4, fixA=10)
ass &lt;- tprAssortment(tree, pars=pars)
plot(tree, assort = ass)
plot(tree, bark = FALSE, assort = ass)
plot(tree, bark = FALSE, assort = ass, legend = TRUE)
plot(tree[1, ], assort = ass[ass$tree == 1, ], main = "first tree in subset")
plot(tree[2, ], assort = ass[ass$tree == 2, ], main = "second tree in subset")

## adding own assortment labels using column 'assortname'
ass$assortname &lt;- ifelse(grepl("fix", ass$sort), paste0("Fix:", ass$length), ass$sort)
plot(tree, assort = ass)
par(oldpar)
</code></pre>

<hr>
<h2 id='RiPar'>parameter of bark function</h2><span id='topic+RiPar'></span>

<h3>Description</h3>

<p>extract parameter of bark functions according to Altherr et al.
1974 - 1979
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RiPar(ba = NULL, fn = NULL, par = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RiPar_+3A_ba">ba</code></td>
<td>
<p>tree species code; returned by <code><a href="#topic+BaMap">BaMap</a></code></p>
</td></tr>
<tr><td><code id="RiPar_+3A_fn">fn</code></td>
<td>
<p>function number; see details</p>
</td></tr>
<tr><td><code id="RiPar_+3A_par">par</code></td>
<td>
<p>parameter; see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function extracts the parameter according to tree species, function
type and parameter number. There are three parameters in each of four
functions. The first one refers to butt log (dt. Erdstamm), the second to
middle log (dt. MittelstammstÃ¼ck), the third to the top log
(dt. GipfelstammstÃ¼ck) and the fourth to the complete stem (dt. Gesamtstamm).
</p>

<hr>
<h2 id='setTapeSoptions'>Set and get options for the TapeS-package</h2><span id='topic+setTapeSoptions'></span><span id='topic+getTapeSoptions'></span>

<h3>Description</h3>

<p>Function to set and get options on how the TapeS-package works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTapeSoptions(Rfn = list(fn = "sig2"), mono = TRUE)

getTapeSoptions(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setTapeSoptions_+3A_rfn">Rfn</code></td>
<td>
<p>setting for residuals error matrix, defaults to <code>"sig2"</code>, see
details.</p>
</td></tr>
<tr><td><code id="setTapeSoptions_+3A_mono">mono</code></td>
<td>
<p>logical, defaults to true. If calibrated taper curve is
non-monotonic at stem base, an support diameter is added.</p>
</td></tr>
<tr><td><code id="setTapeSoptions_+3A_name">name</code></td>
<td>
<p>name of options to be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>So far, only two options are implemented: <code>TapeS_Rfn</code> and
<code>TapeS_mono</code>. Teh first defaults to &quot;sig2&quot; (i.e. 'sigma squared') and
the second to &quot;TRUE&quot;.
</p>
<p>The TapeR-taper curves can be evaluated in basically two ways: (i) either
as defined in the TapeR-package, i.e. the diameters and volumes are
estimated using the estimated error structure and find an optimal taper
curve given the measured diameters or (ii) by interpolating the measured
diameters, i.e. forcing the estimated taper curve through those
measurements by setting the residual error structure to zero. See Kublin et
al. (2013), p.987 bottom left. Technically, forcing the taper curve through
the measurements is achieved by setting the residual error matrix R to
zero, that is <code>Rfn = list(fn="zero")</code>. Defaults to <code>Rfn =
  list(fn="sig2")</code>. Besides, one can defined other functions about
assumptions about the errors at the measurement positions, see
<code><a href="TapeR.html#topic+resVar">resVar</a></code> for options.
</p>
<p>NB: Caution is required in applying <code>Rfn=list(fn="zero")</code>, since
forcing the taper curve through too many points might lead to singularities
or implausible results!
</p>
<p>The option 'mono=TRUE' assures that no taper curve is generated which shows
lower diameter in lower heights, possibly adding a support diameter at 1%
of tree height.
</p>


<h3>Value</h3>

<p>by defaults, sets <code>options()$TapeS_Rfn</code> to &quot;sig2&quot;
</p>


<h3>References</h3>

<p>Kublin, E., Breidenbach, J., Kaendler, G. (2013) A flexible stem
taper and volume prediction method based on mixed-effects B-spline
regression, Eur J For Res, 132:983-997.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## reset option TapeS_Rfn to "sig2", i.e. model based errors by
setTapeSoptions(Rfn = list(fn="sig2"))
## or to force the taper curve through the  measurements, set
options("TapeS_Rfn" = list(fn="zero"))
## see the actual state of options by
options()[grep("^TapeS_", names(options()))]
## or easier
getTapeSoptions()
</code></pre>

<hr>
<h2 id='simTrees'>simulating objects of class <code>tprTrees</code></h2><span id='topic+simTrees'></span>

<h3>Description</h3>

<p>Function to simulate an object of class <code>tprTrees</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTrees(par = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simTrees_+3A_par">par</code></td>
<td>
<p>list of lists, one for each species</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function simulates trees based on given distributions and petterson
height function. Dbh can be simulated using normal ('norm'), weibull or
gamma distribution. Others might be added.
</p>
<p>The <code>par</code>-list of each species needs the following named entries:
<code>spp</code> - species code, <code>n</code> - number of trees, <code>ddist</code> -
distribution of dbh, <code>dpar</code> - list of parameter of the distribution,
i.e. <code>mu</code> and <code>sd</code> for normal distribution and <code>shape</code> and
<code>scale</code> for weibull and gamma distribution. The latter both might use
<code>lag</code> to offset the estimated diameter by this amount.
</p>


<h3>Value</h3>

<p>an object of class <code>tprTrees</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+petterson">petterson</a></code> for the implemented height function and
<code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="stats.html#topic+dweibull">dweibull</a></code> and <code><a href="stats.html#topic+dgamma">dgamma</a></code> for the
diameter distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par &lt;- list(list(spp=1, n=10, ddist="norm", dpar=list(mu=30, sd=4)),
            list(spp=3, n=5, ddist="norm", dpar=list(mu=40, sd=2)))
simTrees(par)

</code></pre>

<hr>
<h2 id='SKPar'>Data: Taper Curve models fit using R-Package TapeR</h2><span id='topic+SKPar'></span>

<h3>Description</h3>

<p>Taper curve models based on a large data base of sectional measurements and
fit by <code><a href="TapeR.html#topic+TapeR_FIT_LME.f">TapeR_FIT_LME.f</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SKPar
</code></pre>


<h3>Format</h3>

<p>A list with eight elements, each a TapeR taper curve model, fit
using <code><a href="TapeR.html#topic+TapeR_FIT_LME.f">TapeR_FIT_LME.f</a></code>. Additionally, these objects
carry two attributes: <code>spp</code> and <code>name</code>, the first refering to the
species code (cf. <code><a href="#topic+tprSpeciesCode">tprSpeciesCode</a></code>) and the second
to the abbreviated german species name. These eight models refer to
the different tree species: Norway Spruce, Silver fir, Douglas fir, Scots
pine, European larch, European Beech, Oak and Northern red oak.
The spp-attributed is evaluated e.g. by the bark functions
</p>


<h3>Details</h3>

<p>These taper curve models were developed for this package based on a
collection of sectional measurements from several german forest research
stations (FVA-BW, LFE, NW-FVA, TUM) and french ONF. Details for model fitting
can be found in the corresponding report.
</p>
<p>Data used to fit the models consists of
</p>

<ul>
<li><p>Norway spruce: n=15181, n_D=156501
</p>
</li>
<li><p>European silver fir: n=7263, n_D=58988
</p>
</li>
<li><p>Douglas fir: n=12019, n_D=116349
</p>
</li>
<li><p>Scotch pine: n=11844, n_D=130379
</p>
</li>
<li><p>larch: n=2816, n_D=25490
</p>
</li>
<li><p>beech: n=16105, n_D=142691
</p>
</li>
<li><p>oak (robur/petraea): n=12341, n_D=97754
</p>
</li>
<li><p>Red oak: n=5411, n_D=43575
</p>
</li></ul>

<p>where n=number of trees and n_D=number of diameter measurements included.
</p>


<h3>Source</h3>

<p>data collection of sectionally measured trees compiled by
FVA-BW <a href="https://www.fva-bw.de">https://www.fva-bw.de</a>
</p>


<h3>References</h3>

<p>Vonderach und KÃ¤ndler (2021): Neuentwicklung von
Schaftkurvenmodellen fÃ¼r die Bundeswaldinventur auf Basis des TapeR-Pakets.
Abschlussbericht zum Projekt BWI-TapeR im Auftrag des ThÃ¼neninstituts fÃ¼r
WaldÃ¶kosysteme.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SKPar)
</code></pre>

<hr>
<h2 id='Slot_accessors'>slot accessor functions for class 'tprtrees'</h2><span id='topic+Slot_accessors'></span><span id='topic+spp'></span><span id='topic+spp+2CtprTrees-method'></span><span id='topic+spp+3C-'></span><span id='topic+spp+3C-+2CtprTrees-method'></span><span id='topic+Dm'></span><span id='topic+Dm+2CtprTrees-method'></span><span id='topic+Dm+3C-'></span><span id='topic+Dm+3C-+2CtprTrees-method'></span><span id='topic+Hm'></span><span id='topic+Hm+2CtprTrees-method'></span><span id='topic+Hm+3C-'></span><span id='topic+Hm+3C-+2CtprTrees-method'></span><span id='topic+Ht'></span><span id='topic+Ht+2CtprTrees-method'></span><span id='topic+Ht+3C-'></span><span id='topic+Ht+3C-+2CtprTrees-method'></span><span id='topic+sHt'></span><span id='topic+sHt+2CtprTrees-method'></span><span id='topic+sHt+3C-'></span><span id='topic+sHt+3C-+2CtprTrees-method'></span><span id='topic+mono'></span><span id='topic+mono+2CtprTrees-method'></span>

<h3>Description</h3>

<p>get and set slot values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp(obj)

## S4 method for signature 'tprTrees'
spp(obj)

spp(obj) &lt;- value

## S4 replacement method for signature 'tprTrees'
spp(obj) &lt;- value

Dm(obj)

## S4 method for signature 'tprTrees'
Dm(obj)

Dm(obj) &lt;- value

## S4 replacement method for signature 'tprTrees'
Dm(obj) &lt;- value

Hm(obj)

## S4 method for signature 'tprTrees'
Hm(obj)

Hm(obj) &lt;- value

## S4 replacement method for signature 'tprTrees'
Hm(obj) &lt;- value

Ht(obj)

## S4 method for signature 'tprTrees'
Ht(obj)

Ht(obj) &lt;- value

## S4 replacement method for signature 'tprTrees'
Ht(obj) &lt;- value

sHt(obj)

## S4 method for signature 'tprTrees'
sHt(obj)

sHt(obj) &lt;- value

## S4 replacement method for signature 'tprTrees'
sHt(obj) &lt;- value

mono(obj)

## S4 method for signature 'tprTrees'
mono(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slot_accessors_+3A_obj">obj</code></td>
<td>
<p>object of class 'tprtrees'</p>
</td></tr>
<tr><td><code id="Slot_accessors_+3A_value">value</code></td>
<td>
<p>depending on slot, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Getting and setting the values of the different slots of
'tprTrees'-objects. For slot <code>mono</code> no setting function has been defined,
as this slot is computed by <code><a href="#topic+check_monotonicity">check_monotonicity</a></code> and should not
be reset by users.
</p>
<p>Setting of <code>spp</code> requires mode integer. For convenience,
<code>value</code> is coerced by <code><a href="base.html#topic+as.integer">as.integer</a></code>.
</p>
<p>Setting <code>spp</code> and <code>H</code>, a vector of length equal
<code>length(spp(obj))</code> is required.
</p>
<p>For setting slots <code>Dm</code> and <code>Hm</code> <code>value</code> must be a
list of vectors of length equal <code>length(spp(obj))</code> and the length of
each vector must correspond to the length of the vectors in <code>Hm</code> and
<code>Dm</code>.
</p>


<h3>Value</h3>

<p>the accessor functions return the value of the specified slot and
the setting functions update the object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>spp()</code>: getting slot 'spp' of <code>obj</code>
</p>
</li>
<li> <p><code>spp(tprTrees)</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>spp(obj) &lt;- value</code>: setting 'spp' slot of object
</p>
</li>
<li> <p><code>spp(tprTrees) &lt;- value</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>Dm()</code>: getting slot 'Dm' of <code>obj</code>
</p>
</li>
<li> <p><code>Dm(tprTrees)</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>Dm(obj) &lt;- value</code>: setting 'Dm' slot of object
</p>
</li>
<li> <p><code>Dm(tprTrees) &lt;- value</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>Hm()</code>: getting slot 'Hm' of <code>obj</code>
</p>
</li>
<li> <p><code>Hm(tprTrees)</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>Hm(obj) &lt;- value</code>: setting 'Hm' slot of object
</p>
</li>
<li> <p><code>Hm(tprTrees) &lt;- value</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>Ht()</code>: getting slot 'Ht' of <code>obj</code>
</p>
</li>
<li> <p><code>Ht(tprTrees)</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>Ht(obj) &lt;- value</code>: setting 'Ht' slot of object
</p>
</li>
<li> <p><code>Ht(tprTrees) &lt;- value</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>sHt()</code>: getting slot 'sHt' of <code>obj</code>
</p>
</li>
<li> <p><code>sHt(tprTrees)</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>sHt(obj) &lt;- value</code>: setting 'sHt' slot of object
</p>
</li>
<li> <p><code>sHt(tprTrees) &lt;- value</code>: method for class 'tprTrees'
</p>
</li>
<li> <p><code>mono()</code>: getting slot 'monotone' of <code>obj</code>
</p>
</li>
<li> <p><code>mono(tprTrees)</code>: method for class 'tprTrees'
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+tprTrees-class">tprTrees-class</a></code>, <code><a href="#topic+tprTrees">tprTrees</a></code>
</p>

<hr>
<h2 id='tprAssortment'>Functions to calculate assortments for given tree</h2><span id='topic+tprAssortment'></span><span id='topic+tprAssortment+2CtprTrees-method'></span>

<h3>Description</h3>

<p>Function calculates assortments for given tree according to
assortment specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprAssortment(obj, pars = NULL, mono = TRUE, Rfn = NULL)

## S4 method for signature 'tprTrees'
tprAssortment(obj, pars = NULL, mono = TRUE, Rfn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprAssortment_+3A_obj">obj</code></td>
<td>
<p>an object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="tprAssortment_+3A_pars">pars</code></td>
<td>
<p>parameters to specify assortments, see <code><a href="#topic+parSort">parSort</a></code></p>
</td></tr>
<tr><td><code id="tprAssortment_+3A_mono">mono</code></td>
<td>
<p>logical, defaults to true. If calibrated taper curve is
non-monotonic at stem base, a support diameter is added.</p>
</td></tr>
<tr><td><code id="tprAssortment_+3A_rfn">Rfn</code></td>
<td>
<p>Rfn setting for residuals error matrix, defaults to
<code>list(fn="sig2")</code>, see <code><a href="TapeR.html#topic+resVar">resVar</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with columns <code>tree</code>: tree identifier,
<code>sort</code>: assortment name, <code>height</code>: beginning of assortment along
trunk, <code>length</code>: length of assortment, <code>mdm</code>: mid-diameter of
assortment, <code>zdm</code>: top-diameter of assortment and <code>vol</code>: volume.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tprAssortment(tprTrees)</code>: method for class 'tprTrees'
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## conifer wood
obj &lt;- tprTrees(spp=c(1, 8),
                Dm=list(30, 40),
                Hm=list(1.3, 1.3),
                Ht=c(30, 40))
tprAssortment(obj)
pars &lt;- parSort(stH=0.2, Lxh=c(1, 1.5), fixN=2, fixL=4)
(ass &lt;- tprAssortment(obj, pars))
plot(obj, assort = ass)

## deciduous wood
obj &lt;- tprTrees(spp=c(15),
                Dm=list(40),
                Hm=list(1.3),
                Ht=c(40))
tprAssortment(obj)
pars &lt;- parSort(n=length(obj), Lxh=c(1), Hsh=10, Az=10)
ass &lt;- tprAssortment(obj, pars)
plot(obj, assort=ass)

</code></pre>

<hr>
<h2 id='tprBark'>Functions to calculate double bark thickness for given diameter at
height <code>Hx</code></h2><span id='topic+tprBark'></span><span id='topic+tprBark+2CtprTrees-method'></span>

<h3>Description</h3>

<p>Funktion evaluates the double bark thickness models developed
by Altherr et al (1974-79).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprBark(obj, Hx, cp = TRUE, mono = TRUE, Rfn = NULL)

## S4 method for signature 'tprTrees'
tprBark(obj, Hx, cp = TRUE, mono = TRUE, Rfn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprBark_+3A_obj">obj</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="tprBark_+3A_hx">Hx</code></td>
<td>
<p>height for which double bark thickness is required</p>
</td></tr>
<tr><td><code id="tprBark_+3A_cp">cp</code></td>
<td>
<p>cartesian product, i.e. apply all <code>Hx</code> to all trees, defaults
to TRUE</p>
</td></tr>
<tr><td><code id="tprBark_+3A_mono">mono</code></td>
<td>
<p>logical, defaults to true. If calibrated taper curve is
non-monotonic at stem base, an support diameter is added.</p>
</td></tr>
<tr><td><code id="tprBark_+3A_rfn">Rfn</code></td>
<td>
<p>Rfn setting for residuals error matrix, defaults to
<code>list(fn="sig2")</code>, see <code><a href="TapeR.html#topic+resVar">resVar</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double bark thickness [cm]
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tprBark(tprTrees)</code>: method for class 'tprTrees'
</p>
</li></ul>


<h3>References</h3>

<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1974).
Statistische Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung
unentrindeten Stammholzes. Kiefer, Buche, Hainbuche, Esche und Roterle.
Freiburg i. Br., Forstl. Versuchs- u. Forschungsanst. Baden-WÃ¼rttenberg.
</p>
<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1975). Statistische
Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung unentrindeten
Stammholzes. EuropÃ¤ische LÃ¤rche, Japanische LÃ¤rche, Schwarzkiefer,
Stieleiche, Traubeneiche, Roteiche, Bergahorn und Linde. Freiburg i. Br.,
Forstl. Versuchs- u. Forschungsanst. Baden-WÃ¼rttenberg.
</p>
<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1976). Statistische
Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung unentrindeten
Stammholzes. Weymouthskiefer, Robinie, Bergulme, Birke, Marilandica-Pappel
und Robusta-Pappel. Freiburg i. Br., Forstl. Versuchs- u. Forschungsanst.
Baden-WÃ¼rttenberg.
</p>
<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1978). Statistische
Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung unentrindeten
Stammholzes. Fichte, Tanne, Douglasie und Sitka-Fichte. Freiburg i. Br.,
Forstl. Versuchs- u. Forschungsanst. Baden-WÃ¼rttenberg.
</p>
<p>Altherr, E., P. Unfried, J. Hradetzky and V. Hradetzky (1979). Statistische
Rindenbeziehungen als Hilfsmittel zur Ausformung und Aufmessung unentrindeten
Stammholzes. Neupotz-Pappel, Regenerata-Pappel, Kirsche, Spitzahorn,
Feldahorn, Aspe, Weide, Flatterulme, Tulpenbaum u. Elsbeere.
Freiburg i. Br., Forstl. Versuchs- u. Forschungsanst. Baden-WÃ¼rttenberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculating bark thickness depends on diameter estimation and hence on the
## assumed residual variance at calibration.
## can be Rfn=list(fn="sig2") (default), i.e. EBLUP estimation from taper curve
## or e.g. Rfn=list(fn="zero"), i.e. force taper curve through the given measurements
options("TapeS_Rfn") # "sig2", default in TapeS
tmp &lt;- tprTrees()
Dm(tmp); Hm(tmp) # Dbh = D(Hx=1.3) = 30cm (measured)
Dbh(tmp) # estimated via EBLUP from taper curve
tprBark(tmp, Hx = c(1.3, 5)) # bark thickness corresponds to Dbh(tmp)
(d &lt;- tprDiameter(tmp, Hx = c(1.3, 5), bark=TRUE)) ## predicted
bark(1, d[1], 1.3/30) # the same!
bark(1, d[2], 5/30) # the same!

## if using option TapeS_Rfn = list(fn="zero"), force taper curve through measurements
setTapeSoptions(Rfn = list(fn="zero"))
options()$TapeS_Rfn
tprBark(tmp, Hx = c(1.3, 5))
bark(1, 30, 1.3/30) # the same but different to above
bark(1, d[1], 1.3/30) # cf. above
bark(1, 28, 5/30) # the same but different to above
bark(1, d[2], 1.3/30) # cf. above
</code></pre>

<hr>
<h2 id='tprBiomass'>total aboveground and component biomass</h2><span id='topic+tprBiomass'></span><span id='topic+tprBiomass+2CtprTrees-method'></span>

<h3>Description</h3>

<p>calculate total above ground and optionally component biomass
for given trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprBiomass(obj, component = NULL, mono = TRUE, Rfn = NULL)

## S4 method for signature 'tprTrees'
tprBiomass(obj, component = NULL, mono = TRUE, Rfn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprBiomass_+3A_obj">obj</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="tprBiomass_+3A_component">component</code></td>
<td>
<p>component for which biomass should be returned. If NULL,
total aboveground biomass is returned, if 'all', all components are returned.
See details.</p>
</td></tr>
<tr><td><code id="tprBiomass_+3A_mono">mono</code></td>
<td>
<p>logical, defaults to true. If calibrated taper curve is
non-monotonic at stem base, a support diameter is added.</p>
</td></tr>
<tr><td><code id="tprBiomass_+3A_rfn">Rfn</code></td>
<td>
<p>Rfn setting for residuals error matrix, defaults to
<code>list(fn="sig2")</code>, see <code><a href="TapeR.html#topic+resVar">resVar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available components are agb (= total aboveground biomass),
stw (=stump wood), stb (=stump bark), sw (=solid wood with diameter above
7cm over bark), sb (=bark of component sw), fwb (=fine wood incl. bark)
and ndl (=needles), if applicable. The needles-component is set to zero for
deciduous tree species, no mass for leaves is available. One can request
'all' components to receive all components.
</p>


<h3>Value</h3>

<p>a vector in case agb or only one component is requested, otherwise
a matrix with one row per tree
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tprBiomass(tprTrees)</code>: method for class 'tprTrees'
</p>
</li></ul>


<h3>References</h3>

<p>KÃ¤ndler, G. and B. BÃ¶sch (2012). Methodenentwicklung fÃ¼r die
3. Bundeswaldinventur: Modul 3 ÃberprÃ¼fung und Neukonzeption einer
Biomassefunktion - Abschlussbericht. Im Auftrag des Bundesministeriums fÃ¼r
ErnÃ¤hrung, Landwirtschaft und Verbraucherschutz in Zusammenarbeit mit dem
Institut fÃ¼r WaldÃ¶kologie und Waldinventur des Johann Heinrich von
ThÃ¼nen-Instituts, FVA-BW: 71.
</p>
<p>Kaendler (2021): AFJZ article, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- tprTrees(spp=c(1, 15),
                Dm=list(c(30, 28), c(30, 28)),
                Hm=list(c(1, 3), c(1, 3)),
                Ht = rep(30, 2))
## OBS: component 'ndl' NOT included to aboveground biomass 'agb'
(tmp &lt;- tprBiomass(obj, component="all"))
rowSums(tmp[, -which(colnames(tmp) %in% c("agb", "ndl"))])
## equal to
tmp$agb
tprBiomass(obj, component=NULL) # aboveground biomass
component &lt;- c("agb", "sw", "sb", "ndl")
tprBiomass(obj, component=component)
component &lt;- c("sw", "sb", "ndl")
tprBiomass(obj, component=component)
</code></pre>

<hr>
<h2 id='tprDiameter'>Functions to extract diameters from Taper curve</h2><span id='topic+tprDiameter'></span><span id='topic+tprDiameter+2CtprTrees-method'></span>

<h3>Description</h3>

<p>Function evaluates TapeR taper curve models for given trees
according to species, required height and optionally substracts double bark
thickness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprDiameter(
  obj,
  Hx,
  bark = TRUE,
  interval = "none",
  cp = TRUE,
  mono = TRUE,
  Rfn = NULL
)

## S4 method for signature 'tprTrees'
tprDiameter(
  obj,
  Hx,
  bark = TRUE,
  interval = "none",
  cp = TRUE,
  mono = TRUE,
  Rfn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprDiameter_+3A_obj">obj</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="tprDiameter_+3A_hx">Hx</code></td>
<td>
<p>vector of heights for which diameter w/ or w/0 bark are required</p>
</td></tr>
<tr><td><code id="tprDiameter_+3A_bark">bark</code></td>
<td>
<p>should diameter over or under bark be returned?</p>
</td></tr>
<tr><td><code id="tprDiameter_+3A_interval">interval</code></td>
<td>
<p>indicator about whether 'confidence' or 'prediction'
intervals are required (defaults to 'none'), optionally function returns the
mean squared error of the mean and predictions ('MSE').</p>
</td></tr>
<tr><td><code id="tprDiameter_+3A_cp">cp</code></td>
<td>
<p>cartesian product, i.e. apply all <code>Hx</code> to all trees, defaults
to TRUE</p>
</td></tr>
<tr><td><code id="tprDiameter_+3A_mono">mono</code></td>
<td>
<p>logical, defaults to true. If calibrated taper curve is
non-monotonic at stem base, a support diameter is added.</p>
</td></tr>
<tr><td><code id="tprDiameter_+3A_rfn">Rfn</code></td>
<td>
<p>Rfn setting for residuals error matrix, defaults to
<code>list(fn="sig2")</code>, see <code><a href="TapeR.html#topic+resVar">resVar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function evaluates taper curves at required height <code>Hx</code>. By
default (<code>cp==TRUE</code>), the taper curve is evaluated at <code>Hx</code> for each
tree. If <code>cp==FALSE</code>, each tree is evaluated at exactly one Hx (recycled
if necessary). This feature is intended for situations where diameter in
relative heights are required. Then, the recycling of one height Hx (e.g.
1.3m) is not possible, since relative heights depend on absolute tree height,
which might be different for each tree. Hence a call like
<code>tprDiameter(obj, Hx=0.3*Ht(obj), cp=FALSE)</code> is necessary.
</p>


<h3>Value</h3>

<p>a matrix or data.frame depending on value of <code>interval</code>. If
'none' (the default), a matrix of size [length(obj@Ht), length(Hx)] is
returned, otherwise a data.frame of size [length(obj@Ht) * length(Hx), 5].
The five columns hold a tree identifier, Hx, lower confidence/prediction
interval, the estimated diameter and the upper confidence/prediction
interval. In case 'interval=MSE' the returned columns contain a tree
identifier, Hx, the estimated diameter and mean squared error (MSE) of the
mean and of the prediction. Estimates and intervals include bark or not,
depending on <code>bark</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tprDiameter(tprTrees)</code>: method for class 'tprTrees'
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+tprDiameterCpp">tprDiameterCpp</a></code> for a faster implementation if no
confidence or prediction information are required and <code><a href="#topic+tprBark">tprBark</a></code>
for the applied bark reduction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## prediction for new tree using implemented 'TapeR' taper curve model
obj &lt;- tprTrees(spp=c(1, 3),
                Hm=list(c(1.3, 5), c(1.3, 5)),
                Dm=list(c(27, 25), c(27, 25)),
                Ht=c(27, 27))
hx &lt;- c(1.3, 5, 7)
## by default, Hx applied on each tree, i.e. result is a 2x3 matrix
tprDiameter(obj, Hx = hx)

## if cp=FALSE, each tree only 'sees' one Hx, i.e. results is a vector
## (obs: length of Hx must be identical to length of obj)
tprDiameter(obj, Hx = c(1.3, 5), cp=FALSE)
tprDiameter(obj, Hx = hx, bark = FALSE)
tprDiameter(obj, Hx = hx, interval = "confidence")
tprDiameter(obj, Hx = hx, bark = FALSE, interval = "prediction")
tprDiameter(obj, Hx = hx, interval = "MSE")
tprDiameter(obj, Hx = hx, bark=FALSE, interval = "MSE")

## here same behaviour, if cp=FALSE
tprDiameter(obj, Hx = c(1.3, 5), bark = FALSE,
            interval = "prediction", cp=FALSE)
## using Cpp-implementation
## faster, but no intervals available
tprDiameterCpp(obj, Hx = hx)
tprDiameterCpp(obj, Hx = c(1.3, 5), cp=FALSE)

## prediction for objects of class 'datBDAT':
if(require(rBDAT)){
  tree &lt;- rBDAT::buildTree(list(spp=1, D1=20:30, H1=1.3, H2=50, H=20:30))
  tree &lt;- bdat_as_tprtrees(tree)
  tprDiameter(tree, Hx = 1.3)
}
</code></pre>

<hr>
<h2 id='tprDiameterCpp'>Function to extract diameters from Taper curve using Rcpp</h2><span id='topic+tprDiameterCpp'></span><span id='topic+tprDiameterCpp+2CtprTrees-method'></span>

<h3>Description</h3>

<p>This function uses Rcpp and C-code to implement the diameter
estimation of package TapeR to allow for faster estimation if no interval
information is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprDiameterCpp(obj, Hx, bark = TRUE, cp = TRUE, mono = TRUE, Rfn = NULL)

## S4 method for signature 'tprTrees'
tprDiameterCpp(obj, Hx, bark = TRUE, cp = TRUE, mono = TRUE, Rfn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprDiameterCpp_+3A_obj">obj</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="tprDiameterCpp_+3A_hx">Hx</code></td>
<td>
<p>vector of heights for which diameter are required</p>
</td></tr>
<tr><td><code id="tprDiameterCpp_+3A_bark">bark</code></td>
<td>
<p>should diameter over or under bark be returned?</p>
</td></tr>
<tr><td><code id="tprDiameterCpp_+3A_cp">cp</code></td>
<td>
<p>cartesian product, i.e. apply all <code>Hx</code> to all trees, defaults
to TRUE</p>
</td></tr>
<tr><td><code id="tprDiameterCpp_+3A_mono">mono</code></td>
<td>
<p>logical to decide whether a supporting diameter should be added
in case the taper curve is regarded as non-monotonic. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="tprDiameterCpp_+3A_rfn">Rfn</code></td>
<td>
<p>setting for residuals error matrix, defaults to <code>"sig2"</code>, see
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function evaluates taper curves at required height <code>Hx</code>. By
default (<code>cp==TRUE</code>), the taper curve is evaluated at <code>Hx</code> for each
tree. If <code>cp==FALSE</code>, each tree is evaluated at exactly one Hx (recycled
if necessary). This feature is intended for situations where diameter in
relative heights are required. Then, the recycling of one height Hx (e.g.
1.3m) is not possible, since relative heights depend on absolute tree height,
which might be different for each tree. Hence a call like
<code>tprDiameter(obj, Hx=0.3*Ht(obj), cp=FALSE)</code> is necessary.
</p>


<h3>Value</h3>

<p>a vector, in case only one diameter (i.e. Hx) is required per tree
(<code>cp=FALSE</code>) or a matrix of size
<code>length(trees)</code> x <code>length(Hx)</code> (<code>cp=TRUE</code>).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tprDiameterCpp(tprTrees)</code>: method for class 'tprTrees'
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+tprDiameter">tprDiameter</a></code> if confidence or prediction intervals
are required.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- tprTrees(spp=c(1 , 3),
                Hm=list(c(1.3, 5), c(1.3, 5)),
                Dm=list(c(27, 25), c(27, 25)),
                Ht=c(27, 27))
Hx &lt;- seq(0, 1, 0.1)
tprDiameterCpp(obj, Hx = Hx)
tprDiameterCpp(obj, Hx = Hx, bark=FALSE)
tprDiameterCpp(obj, Hx = c(1, 2), bark=FALSE, cp=FALSE)


require(rbenchmark)
benchmark(tprDiameter(obj, Hx, bark = TRUE),
          tprDiameterCpp(obj, Hx, bark = TRUE),
          replications = 10000)[,1:4]

</code></pre>

<hr>
<h2 id='tprHeight'>Estimate height for given diameter w/ or w/o bark</h2><span id='topic+tprHeight'></span><span id='topic+tprHeight+2CtprTrees-method'></span>

<h3>Description</h3>

<p>Function to extract the height of given diameter w/ or w/o bark
from taper curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprHeight(obj, Dx, bark = TRUE, cp = TRUE, mono = TRUE, Rfn = NULL)

## S4 method for signature 'tprTrees'
tprHeight(obj, Dx, bark = TRUE, cp = TRUE, mono = TRUE, Rfn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprHeight_+3A_obj">obj</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="tprHeight_+3A_dx">Dx</code></td>
<td>
<p>diameter for which height is required</p>
</td></tr>
<tr><td><code id="tprHeight_+3A_bark">bark</code></td>
<td>
<p>should given diameter be considered over or under bark?</p>
</td></tr>
<tr><td><code id="tprHeight_+3A_cp">cp</code></td>
<td>
<p>cartesian product, i.e. apply all <code>Hx</code> to all trees, defaults
to TRUE</p>
</td></tr>
<tr><td><code id="tprHeight_+3A_mono">mono</code></td>
<td>
<p>logical, defaults to true. If calibrated taper curve is
non-monotonic at stem base, a support diameter is added.</p>
</td></tr>
<tr><td><code id="tprHeight_+3A_rfn">Rfn</code></td>
<td>
<p>Rfn setting for residuals error matrix, defaults to
<code>list(fn="sig2")</code>, see <code><a href="TapeR.html#topic+resVar">resVar</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated height of given diameter
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tprHeight(tprTrees)</code>: method for class 'tprTrees'
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+tprDiameter">tprDiameter</a></code>, <code><a href="#topic+tprDiameterCpp">tprDiameterCpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- tprTrees(spp=c(1, 3, 8, 15),
                Dm=list(c(30, 28), c(30, 28), c(30, 28), c(30, 28)),
                Hm=list(c(1.3, 5), c(1.3, 5), c(1.3, 5), c(1.3, 5)),
                Ht = rep(30, 4))
tprHeight(obj, Dx = c(30, 7), bark=TRUE)
tprHeight(obj, Dx = c(30, 7), bark=FALSE)

## no cartesion product between obj and Dx, i.e. cp=FALSE
## Dx is recycled if necessary
tprHeight(obj, Dx = c(30, 7), bark=FALSE, cp=FALSE)
</code></pre>

<hr>
<h2 id='tprSpeciesCode'>Get BDAT species code or transform it to a name.</h2><span id='topic+tprSpeciesCode'></span>

<h3>Description</h3>

<p>Function to get BDAT species code, or transform it to a
german or english name, possibly an abbreviated version or even a scientific
name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprSpeciesCode(inSp = NULL, outSp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprSpeciesCode_+3A_insp">inSp</code></td>
<td>
<p>species information given, either numeric or character</p>
</td></tr>
<tr><td><code id="tprSpeciesCode_+3A_outsp">outSp</code></td>
<td>
<p>character vector of names, for which information should be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function matches inSp to outSp. Depending on inSp, being either
a numeric vector of values between 1 and 36 or a character vector of species
names. Possible names are those which could be return values. One can get all
names and the respective species code by calling the function with inSP=NULL
and outSP=NULL (the default).
</p>
<p>English species names and codes are taken from
https://www.forestry.gov.uk/pdf/PF2011_Tree_Species.pdf/$FILE/PF2011_Tree_Species.pdf
while slightly adjusting the codes to be unique compared to the german codes
(e.g. European larch is now ELA instead of EL).
</p>
<p>Any given species code outside the interval [1, 36] is given the code 1
(i.e. Norway spruce), while throwing a warning. If any inSp - name is invalid,
i.e. not in species list, this throws an error.
</p>
<p>All elements of outSp, which are not colnames of the default returned
data.frame, are silently dropped.
</p>


<h3>Value</h3>

<p>vector or data.frame, depending on length of 'outSp'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tprSpeciesCode(inSp=NULL, outSp=NULL) ## the default
tprSpeciesCode() ## the same
tprSpeciesCode(outSp = "scientific")
tprSpeciesCode(inSp = c(1, 2)) ## giving codes
tprSpeciesCode(inSp = c(1, 2, -1, 37)) ## values outside [1, 36] are given code 1
tprSpeciesCode(inSp = c(1, 2), outSp = c("scientific")) ## output a vector
tprSpeciesCode(inSp = c("Bu", "Fi")) ## asking for codes of abbreviated german names
tprSpeciesCode(inSp = c("Bu", "Fi", "Bu")) ## order is preserved
tprSpeciesCode(inSp = c("Buche", "Fichte")) ## asking for codes of german names
tprSpeciesCode(inSp = c("BE", "NS")) ## ... abbreviated english names
tprSpeciesCode(inSp = c("beech", "Norway spruce")) ## ... english names
tprSpeciesCode(inSp = c("Fagus sylvatica", "Picea abies")) ### ... scientific names
## not run
## tprSpeciesCode(inSp = c("Fagus sylvatica", "Picea")) ## error, 2nd name wrong
## end not run
</code></pre>

<hr>
<h2 id='tprTrees'>constructor for class tprTrees</h2><span id='topic+tprTrees'></span>

<h3>Description</h3>

<p>constructor for class tprTrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprTrees(
  spp = 1L,
  Dm = list(c(30, 28)),
  Hm = list(c(1.3, 5)),
  Ht = 30,
  sHt = rep(0, length(Ht)),
  inv = NULL,
  Rfn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprTrees_+3A_spp">spp</code></td>
<td>
<p>species code, see <code><a href="#topic+tprSpeciesCode">tprSpeciesCode</a></code></p>
</td></tr>
<tr><td><code id="tprTrees_+3A_dm">Dm</code></td>
<td>
<p>measurements of diameter along trunk</p>
</td></tr>
<tr><td><code id="tprTrees_+3A_hm">Hm</code></td>
<td>
<p>height of measurements along trunk</p>
</td></tr>
<tr><td><code id="tprTrees_+3A_ht">Ht</code></td>
<td>
<p>tree height</p>
</td></tr>
<tr><td><code id="tprTrees_+3A_sht">sHt</code></td>
<td>
<p>standard deviation of stem height <code>Ht</code>. Can be 0 if height
was measured without error.</p>
</td></tr>
<tr><td><code id="tprTrees_+3A_inv">inv</code></td>
<td>
<p>indicator (0-5) for inventory to assess taper form; numeric scalar
see <code><a href="#topic+FormTariff">FormTariff</a></code></p>
</td></tr>
<tr><td><code id="tprTrees_+3A_rfn">Rfn</code></td>
<td>
<p>function to populate residual variance matrix R</p>
</td></tr>
<tr><td><code id="tprTrees_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>initialize()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>constructor for a tprTrees object, includes a check on monotonicity
of the taper curve.
</p>


<h3>Value</h3>

<p>object of class <code>tprTrees</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># just define a tree
tpr &lt;- tprTrees(spp=1, Dm=30, Hm=1.3, Ht=27)
plot(tpr)
# define 2 trees with only dbh
tpr &lt;- tprTrees(spp=c(1,3), Dm=c(30, 35), Hm=c(1.3, 1.3), Ht=c(27, 30))
plot(tpr)
# define 2 trees with several measurement
tpr &lt;- tprTrees(spp=c(1,3), Dm=list(c(30, 28), c(35, 33, 31)),
                Hm=list(c(1.3, 8), c(1.3, 5, 8)), Ht=c(27, 30))
plot(tpr)
# define 2 trees with only dbh and inventory indicator (form)
tpr &lt;- tprTrees(spp=c(1,3), Dm=c(30, 35), Hm=c(1.3, 1.3), Ht=c(27, 30), inv=4)
plot(tpr)
</code></pre>

<hr>
<h2 id='tprTrees-class'>An S4 class to represent one or multiple trees.</h2><span id='topic+tprTrees-class'></span><span id='topic++5B+2CtprTrees+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CtprTrees-method'></span><span id='topic+length+2CtprTrees-method'></span><span id='topic+show+2CtprTrees-method'></span>

<h3>Description</h3>

<p>This class represents one or multiple trees by their biometric
characteristics.
</p>
<p>using indices i and j to subset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tprTrees,ANY,ANY,ANY'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'tprTrees'
length(x)

## S4 method for signature 'tprTrees'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprTrees-class_+3A_x">x</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="tprTrees-class_+3A_i">i</code></td>
<td>
<p>index i</p>
</td></tr>
<tr><td><code id="tprTrees-class_+3A_j">j</code></td>
<td>
<p>index j</p>
</td></tr>
<tr><td><code id="tprTrees-class_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
<tr><td><code id="tprTrees-class_+3A_drop">drop</code></td>
<td>
<p>drop dimensions, defaults to FALSE</p>
</td></tr>
<tr><td><code id="tprTrees-class_+3A_object">object</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>blabla
</p>


<h3>Value</h3>

<p>a part of the original object
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>x[i</code>: subsetting for class 'tprTrees'
</p>
</li>
<li> <p><code>length(tprTrees)</code>: length function for class 'tprTrees'
</p>
</li>
<li> <p><code>show(tprTrees)</code>: length function for class 'tprTrees'
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>spp</code></dt><dd><p>species code of trees</p>
</dd>
<dt><code>Dm</code></dt><dd><p>list of measured diameters</p>
</dd>
<dt><code>Hm</code></dt><dd><p>list of heights of measured diameters</p>
</dd>
<dt><code>Ht</code></dt><dd><p>total height of trees</p>
</dd>
<dt><code>sHt</code></dt><dd><p>standard deviation of total tree height, defaults to 0 for exact
height measurements without error</p>
</dd>
<dt><code>monotone</code></dt><dd><p>logical indicator about monotonicity of taper curve</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>tprTrees() # initialise object by constructor
(tmp &lt;- tprTrees(spp=c(1L,3L), Dm=list(c(30, 28), c(40, 38)),
                 Hm=list(c(1.3, 5), c(1.3, 5)), Ht=c(30, 40)))

</code></pre>

<hr>
<h2 id='tprVolume'>Functions to calculate stem volume from taper curve</h2><span id='topic+tprVolume'></span><span id='topic+tprVolume+2CtprTrees-method'></span>

<h3>Description</h3>

<p>Function calculates stem volume from taper curve for given
trees, depending definition of segment and on bark indicator. It is possible
to request confidence or prediction intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprVolume(
  obj,
  AB = NULL,
  iAB = NULL,
  bark = NULL,
  interval = "none",
  mono = TRUE,
  Rfn = NULL
)

## S4 method for signature 'tprTrees'
tprVolume(
  obj,
  AB = list(A = 0, B = 7, sl = 2),
  iAB = c("h", "dob"),
  bark = TRUE,
  interval = "none",
  mono = TRUE,
  Rfn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tprVolume_+3A_obj">obj</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="tprVolume_+3A_ab">AB</code></td>
<td>
<p>list with heights or diameters A and B of section for which volume
over or under bark should be calculated. Additionally, add in <code>sl</code> for
the segment length over which the integral should be calculated. See details.</p>
</td></tr>
<tr><td><code id="tprVolume_+3A_iab">iAB</code></td>
<td>
<p>character indicating how to interpret given A and B values. Either
&quot;H&quot; (the default), &quot;Dob&quot; (diameter over bark) or &quot;Dub&quot; (diameter under bark).
Could be of length one or two, depending on whether A and B are both height
or diameter variables or not. See examples.</p>
</td></tr>
<tr><td><code id="tprVolume_+3A_bark">bark</code></td>
<td>
<p>should volume be returned including (<code>TRUE</code>) or excluding
bark (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="tprVolume_+3A_interval">interval</code></td>
<td>
<p>character to indicate whether and which type of interval is
required; one of <code>none</code>, <code>confidence</code> or <code>prediction</code>.</p>
</td></tr>
<tr><td><code id="tprVolume_+3A_mono">mono</code></td>
<td>
<p>logical, defaults to true. If calibrated taper curve is
non-monotonic at stem base, a support diameter is added.</p>
</td></tr>
<tr><td><code id="tprVolume_+3A_rfn">Rfn</code></td>
<td>
<p>Rfn setting for residuals error matrix, defaults to
<code>list(fn="sig2")</code>, see <code><a href="TapeR.html#topic+resVar">resVar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns total solid wood w/ bark (i.e. from H=0 to
D=7cm) by default. Using <code>AB</code>, one can specify lower <code>A</code> and upper
<code>B</code> end of segments for which volume is required, w/ or w/o bark.
</p>
<p><code>iAB</code> can be a vector of length two, indicating how to interpret A and
B. Hence, one can calculate volume between a given height and a given
diameter, either over or under bark. If of length one, it is assumed that the
indicator applies to both A and B.
</p>
<p>Defining interval <code>'confidence'</code> or <code>'prediction'</code> returns
lower (lwr) and upper (upr) interval bounds on confidence level
<code class="reqn">\alpha</code> = <code>qt(0.025, ...)</code>. NB: The volume confidence bounds only
incorporate the uncertainty of diameter estimation at a pre-fixed position
(e.g. H=1.3m). If the position is given as diameter (e.g. <code>iAB="Dob"</code>),
the absolute height position is calculated using the *estimated* diameter,
hence, the uncertainty of the estimated absolute height is not (yet)
included. Neither is the uncertainty of the models for bark reduction.
</p>
<p>In contrast to the underlying R-package TapeR, which uses
<code><a href="TapeR.html#topic+E_VOL_AB_HmDm_HT.f">E_VOL_AB_HmDm_HT.f</a></code> for volume calculation, this function
calculates volume based on stem-section (default: 2m, see parameter
<code>AB</code>). Additionally, with that approach, bark reduction is easily
possible.
</p>


<h3>Value</h3>

<p>if <code>interval='none'</code> a vector else a matrix.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tprVolume(tprTrees)</code>: method for class 'tprTrees'
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="TapeR.html#topic+E_DHx_HmDm_HT.f">E_DHx_HmDm_HT.f</a></code> for the underlying diameter
calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- simTrees() # default is: simulate 10 Norway spruce with mean dbh of 40
A &lt;- 1
B &lt;- 10
tprVolume(obj) # default is: coarse wood volume w/ bark
tprVolume(obj, AB = list(A=A, B=B, sl=2), iAB = "H", bark=FALSE)
tprVolume(obj, AB = list(A=A, B=B, sl=0.01), iAB = "H", bark=FALSE)
tprVolume(obj, AB = list(A=A, B=B, sl=0.01), iAB = "H", bark=TRUE)

## compare against integrated taper curve volume via package TapeR
## TapeR integrates over the taper curve, while TapeS uses segments of length 'sl'
TapeR::E_VOL_AB_HmDm_HT.f(Hm=obj@Hm[[1]], Dm = obj@Dm[[1]], iDH = "H",
                          mHt = obj@Ht[1], sHt = 0, A = A, B = B,
                          par.lme=SKPar[[1]])$E_VOL

## returning intervals
tprVolume(obj, interval="none")
tprVolume(obj, interval="confidence")
tprVolume(obj, interval="prediction")
tprVolume(obj, interval="prediction", bark=FALSE)
tprVolume(obj, interval="prediction", AB=list(A=0.1, B=5.1, sl=0.1), iAB="H")
</code></pre>

<hr>
<h2 id='unvd'>Data: Percentage of unusable wood in Beech and Oak in Germany</h2><span id='topic+unvd'></span>

<h3>Description</h3>

<p>This data gives percentage of unusable wood according to species (beech or
oak) and 2cm-diameter classes and cutting diameter. Data was taken from
BDAT-Fortran-library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvd
</code></pre>


<h3>Format</h3>

<p>A three-dimensional array.
</p>


<h3>Source</h3>

<p>BDAT-Fortran-library
</p>


<h3>References</h3>

<p>none, yet.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(unvd)
dim(unvd)
dbh &lt;- 40 # diameter in breast height
cd &lt;- 10 # cutting diameter
unvd[1, floor(dbh/2), cd]
</code></pre>

<hr>
<h2 id='Vfm'>tree volume information</h2><span id='topic+Vfm'></span><span id='topic+Efm'></span><span id='topic+VolR'></span><span id='topic+VolE'></span><span id='topic+VolFAO'></span><span id='topic+Vfm_phys'></span><span id='topic+Efm_phys'></span>

<h3>Description</h3>

<p>Wrapper to get specific type of volume from taper curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vfm(obj)

Efm(obj, stH = 0.01)

VolR(obj)

VolE(obj)

VolFAO(obj)

Vfm_phys(obj)

Efm_phys(obj, stH = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Vfm_+3A_obj">obj</code></td>
<td>
<p>a object of class 'tprTrees'</p>
</td></tr>
<tr><td><code id="Vfm_+3A_sth">stH</code></td>
<td>
<p>assumed or known relative or absolute stump height, from which
volume calculation should starts, defaults to 0.01</p>
</td></tr>
</table>


<h3>Details</h3>

<p>wrapper functions around <code><a href="#topic+tprVolume">tprVolume</a></code>, which return
specific definitions of stem volume.
</p>
<p>Function <code>Efm</code> uses parameter <code>stH</code> to define starting
point, i.e. stump height, of volume calculation. <code>stH</code> can be defined
relative to total tree height <code>(0 &lt; stH &lt;= 1)</code> or in absolute measure
(unit=cm) in case <code>stH &gt; 1</code>
</p>
<p><code>VolE</code> calculates as the sum of volume of default assortments
(stem wood, top log, industrial wood, X-wood, non-usuable wood according to
RVR. For dbh &lt; 7cm a linear regression is applied.
</p>
<p><code>VolFAO</code> calculates tree volume starting from stump up to tree
top (in contrast to german definition, which uses D=7cm over bark), and
includes bark component. Stump height is defined as 1% of tree height.
Volume calculation is based on 2m-sections. For trees with dbh &lt; 7cm,
tabulated values are used, see Riedel et al. (2017) for details (e.g. p.35,
table 5.6).
</p>
<p><code>Vfm_phys</code> is equal to <code>Vfm</code>, except that the taper curve
is numerically integrated, by use of section length of 0.01m. This is
relevant if biomass or nutrient export is to be calculate. Numerical
integration is quite slow.
</p>
<p><code>Efm_phys</code> is equal to <code>Efm</code>, except that the taper curve
is numerically integrated, by use of section length of 0.01m. This is
relevant if biomass or nutrient export is to be calculate. Numerical
integration is quite slow.
</p>


<h3>Value</h3>

<p>vector of volume estimates
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Efm()</code>: Efm, i.e. coarse wood excl. bark from Ht=stH*Ht to Dob=7cm
</p>
</li>
<li> <p><code>VolR()</code>: VolR: Volume from H=0 to D=7cm over bark, measured as 2m sections
</p>
</li>
<li> <p><code>VolE()</code>: VolE: sum of volume of default assortments according to RVR
</p>
</li>
<li> <p><code>VolFAO()</code>: VolFAO: from stump to tree top incl. bark; if dbh &lt; 7cm using
tabulated values
</p>
</li>
<li> <p><code>Vfm_phys()</code>: Vfm_phys physical volume of tree incl. bark from A=0
</p>
</li>
<li> <p><code>Efm_phys()</code>: Efm_phys physical volume of tree excl. bark from A=0.1*Ht
</p>
</li></ul>


<h3>References</h3>

<p><a href="https://www.bundeswaldinventur.de/fileadmin/SITE_MASTER/content/Downloads/BWI_Methodenband_web.pdf">Riedel, T. and Hennig, P. and Kroiher, F. and Polley, H. and
Schwitzgebel, F. (2017): Die dritte Bundeswaldinventur (BWI 2012). Inventur-
und Auswertemethoden. 124 pages.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- tprTrees() # constructor of class 'tprTrees'
Vfm(t)
Efm(t)
Efm(t, stH=0.01) # stump height = 1\% of tree height
Efm(t, stH=10) # stump height=10cm
VolR(t)
VolE(t)
VolFAO(t)
Vfm_phys(t) # slower since much more evaluations of taper curve (every 1 cm)
Efm_phys(t, stH=0.01) # slower since much more evaluations of taper curve (every 1 cm)
</code></pre>

<hr>
<h2 id='volfaodlt7'>Data: Volume (cbm over bark) according to FAO definition for trees with
dbh less than 7cm</h2><span id='topic+volfaodlt7'></span>

<h3>Description</h3>

<p>This data keeps the volume according to FAO definition in cubic meter
including bark for trees with dbh &lt; 7cm. Data discriminates according to
species and diameter class (class mid at 25mm, 55mm and 65mm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volfaodlt7
</code></pre>


<h3>Format</h3>

<p>A two-dimensional array.
</p>


<h3>Source</h3>

<p>Riedel et al. 2017, table 5.6, p. 35
</p>


<h3>References</h3>

<p>Riedel et al 2017: Die Dritte Bundeswaldinventur BWI 2012,
Inventur und Auswertemethoden, Eberswalde November 2017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volfaodlt7)
dim(volfaodlt7)
dbhclass &lt;- 3 # classified diameter in breast height, i.e. 3=50-60mm
sp &lt;- 10 # species code
volfaodlt7[BaMap(sp, 8), 3]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
