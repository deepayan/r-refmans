<!DOCTYPE html><html><head><title>Help for package squat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {squat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#-.qts'><p>Operator <code>-</code> for <code>qts</code> Objects</p></a></li>
<li><a href='#*.qts'><p>Operator <code>*</code> for <code>qts</code> Objects</p></a></li>
<li><a href='#+.qts'><p>Operator <code>+</code> for <code>qts</code> Objects</p></a></li>
<li><a href='#append'><p>QTS Sample Concatenation</p></a></li>
<li><a href='#autoplot.prcomp_qts'><p>Plot for <code>prcomp_qts</code> objects</p></a></li>
<li><a href='#autoplot.qts'><p>Plot for <code>qts</code> objects</p></a></li>
<li><a href='#autoplot.qts_sample'><p>Plot for <code>qts_sample</code> objects</p></a></li>
<li><a href='#autoplot.qtsclust'><p>Plot for <code>qtsclust</code> objects</p></a></li>
<li><a href='#centring'><p>QTS Centering and Standardization</p></a></li>
<li><a href='#dbscan'><p>QTS Nearest-Neighbor Clustering</p></a></li>
<li><a href='#differentiate'><p>QTS Differentiation</p></a></li>
<li><a href='#dist'><p>QTS Distance Matrix Computation</p></a></li>
<li><a href='#DTW'><p>Dynamic Time Warping for Quaternion Time Series</p></a></li>
<li><a href='#exp'><p>QTS Exponential</p></a></li>
<li><a href='#hclust'><p>QTS Hierarchical Agglomerative Clustering</p></a></li>
<li><a href='#hemispherize'><p>QTS Hemispherization</p></a></li>
<li><a href='#inverse_qts'><p>Inverse Operator for <code>qts</code> Objects</p></a></li>
<li><a href='#kmeans'><p>QTS K-Means Alignment Algorithm</p></a></li>
<li><a href='#log'><p>QTS Logarithm</p></a></li>
<li><a href='#mean.qts_sample'><p>QTS Geometric Mean</p></a></li>
<li><a href='#median.qts_sample'><p>QTS Geometric Median</p></a></li>
<li><a href='#moving_average'><p>QTS Moving Average</p></a></li>
<li><a href='#normalize'><p>QTS Normalization</p></a></li>
<li><a href='#plot.prcomp_qts'><p>Plot for <code>prcomp_qts</code> objects</p></a></li>
<li><a href='#plot.qts'><p>Plot for <code>qts</code> objects</p></a></li>
<li><a href='#plot.qts_sample'><p>Plot for <code>qts_sample</code> objects</p></a></li>
<li><a href='#plot.qtsclust'><p>Plot for <code>qtsclust</code> objects</p></a></li>
<li><a href='#prcomp.qts_sample'><p>PCA for QTS Sample</p></a></li>
<li><a href='#predict.prcomp_qts'><p>Predict QTS from PCA decomposition</p></a></li>
<li><a href='#qts'><p>QTS Class</p></a></li>
<li><a href='#qts_sample'><p>QTS Sample Class</p></a></li>
<li><a href='#qts2aats'><p>QTS Transformation to Angle-Axis Time Series</p></a></li>
<li><a href='#qts2ats'><p>QTS Transformation To Angle Time Series</p></a></li>
<li><a href='#qts2avts'><p>QTS Transformation to Angular Velocity Time Series</p></a></li>
<li><a href='#qts2dts'><p>QTS Transformation To Distance Time Series</p></a></li>
<li><a href='#qts2nts'><p>QTS Transformation To Norm Time Series</p></a></li>
<li><a href='#reorient'><p>QTS Reorientation</p></a></li>
<li><a href='#resample'><p>QTS Resampling</p></a></li>
<li><a href='#rnorm_qts'><p>QTS Random Sampling</p></a></li>
<li><a href='#scale'><p>QTS Sample Centering and Standardization</p></a></li>
<li><a href='#smooth'><p>QTS Smoothing via SLERP Interpolation</p></a></li>
<li><a href='#straighten'><p>QTS Straightening</p></a></li>
<li><a href='#vespa'><p>The VESPA dataset</p></a></li>
<li><a href='#vespa64'><p>The VESPA64 dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistics for Quaternion Temporal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of statistical tools for the analysis 
    of rotation-valued time series and functional data. It relies on 
    pre-existing quaternion data structure provided by the 'Eigen' 'C++' 
    library.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen, fdacluster</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dbscan, dtw, fdacluster, funData, furrr, ggplot2,
ggrepel, MFPCA, progressr, purrr, Rcpp, rlang, roahd, scales,
tibble, tidyr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, future, gganimate, gghighlight, testthat (&ge; 3.0.0),
vdiffr, withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LMJL-Alea/squat">https://github.com/LMJL-Alea/squat</a>,
<a href="https://lmjl-alea.github.io/squat/">https://lmjl-alea.github.io/squat/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LMJL-Alea/squat/issues">https://github.com/LMJL-Alea/squat/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-10 15:21:09 UTC; stamm-a</td>
</tr>
<tr>
<td>Author:</td>
<td>Lise Bellanger [aut],
  Pierre Drouin [aut],
  Aymeric Stamm <a href="https://orcid.org/0000-0002-8725-3654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Benjamin Martineau [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aymeric Stamm &lt;aymeric.stamm@cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='-.qts'>Operator <code>-</code> for <code>qts</code> Objects</h2><span id='topic+-.qts'></span>

<h3>Description</h3>

<p>This function implements the pointwise subtraction between two quaternion
time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts'
x - rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="-.qts_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts">qts</a></code>.</p>
</td></tr>
<tr><td><code id="-.qts_+3A_rhs">rhs</code></td>
<td>
<p>Either an object of class <code><a href="#topic+qts">qts</a></code> or a numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+qts">qts</a></code> storing the subtraction of the two
inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vespa64$igp[[1]] - vespa64$igp[[2]]
</code></pre>

<hr>
<h2 id='+2A.qts'>Operator <code>*</code> for <code>qts</code> Objects</h2><span id='topic++2A.qts'></span>

<h3>Description</h3>

<p>This function implements the pointwise quaternion Hamilton multiplication
between two quaternion time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts'
x * rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.qts_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts">qts</a></code>.</p>
</td></tr>
<tr><td><code id="+2B2A.qts_+3A_rhs">rhs</code></td>
<td>
<p>Either an object of class <code><a href="#topic+qts">qts</a></code> or a numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+qts">qts</a></code> storing the multiplication of the two
inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vespa64$igp[[1]] * vespa64$igp[[2]]
</code></pre>

<hr>
<h2 id='+2B.qts'>Operator <code>+</code> for <code>qts</code> Objects</h2><span id='topic++2B.qts'></span>

<h3>Description</h3>

<p>This function implements the pointwise addition between two quaternion time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts'
x + rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.qts_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts">qts</a></code>.</p>
</td></tr>
<tr><td><code id="+2B2B.qts_+3A_rhs">rhs</code></td>
<td>
<p>Either an object of class <code><a href="#topic+qts">qts</a></code> or a numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+qts">qts</a></code> storing the addition of the two inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vespa64$igp[[1]] + vespa64$igp[[2]]
</code></pre>

<hr>
<h2 id='append'>QTS Sample Concatenation</h2><span id='topic+append'></span><span id='topic+append.default'></span><span id='topic+append.qts_sample'></span>

<h3>Description</h3>

<p>QTS Sample Concatenation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append(x, ...)

## Default S3 method:
append(x, values, after = length(x), ...)

## S3 method for class 'qts_sample'
append(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_+3A_x">x</code></td>
<td>
<p>Either a numeric vector or an object of class <code><a href="#topic+qts_sample">qts_sample</a></code>.</p>
</td></tr>
<tr><td><code id="append_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed on to next methods.</p>
</td></tr>
<tr><td><code id="append_+3A_values">values</code></td>
<td>
<p>to be included in the modified vector.</p>
</td></tr>
<tr><td><code id="append_+3A_after">after</code></td>
<td>
<p>a subscript, after which the values are to be appended.</p>
</td></tr>
<tr><td><code id="append_+3A_y">y</code></td>
<td>
<p>Either a numeric vector or an object of class <code><a href="#topic+qts_sample">qts_sample</a></code> or an
object of class <code><a href="#topic+qts">qts</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a numeric vector, the output is a numeric vector containing
the values in <code>x</code> with the elements of <code>values</code> appended after the
specified element of <code>x</code>. If <code>x</code> is of class <code><a href="#topic+qts_sample">qts_sample</a></code>, the output is
another object of class <code><a href="#topic+qts_sample">qts_sample</a></code> containing the elements in <code>x</code> and
the ones in <code>y</code> appended after the last element of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>append(vespa64$igp, vespa64$igp[1])
append(vespa64$igp, vespa64$igp[[1]])
</code></pre>

<hr>
<h2 id='autoplot.prcomp_qts'>Plot for <code>prcomp_qts</code> objects</h2><span id='topic+autoplot.prcomp_qts'></span>

<h3>Description</h3>

<p>This function creates a visualization of the results of the PCA applied on a
sample of QTS and returns the corresponding <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object which
enable further customization of the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prcomp_qts'
autoplot(object, what = "PC1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.prcomp_qts_+3A_object">object</code></td>
<td>
<p>An object of class <code>prcomp_qts</code> as produced by the
<code><a href="#topic+prcomp.qts_sample">prcomp.qts_sample()</a></code> method.</p>
</td></tr>
<tr><td><code id="autoplot.prcomp_qts_+3A_what">what</code></td>
<td>
<p>A string specifying what kind of visualization the user wants to
perform. Choices are words starting with <code>PC</code> and ending with a PC number
(in which case the mean QTS is displayed along with its perturbations due
to the required PC) or <code>scores</code> (in which case individuals are projected on
the required plane). Defaults to <code>PC1</code>.</p>
</td></tr>
<tr><td><code id="autoplot.prcomp_qts_+3A_...">...</code></td>
<td>
<p>If <code>what = "PC?"</code>, the user can specify whether to plot the QTS in
the tangent space or in the original space by providing a boolean argument
<code>original_space</code> which defaults to <code>TRUE</code>. If <code>what = "scores"</code>, the user
can specify the plane onto which the individuals will be projected by
providing a length-2 integer vector argument <code>plane</code> which defaults to
<code>1:2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- as_qts_sample(vespa64$igp[1:16])
res_pca &lt;- prcomp(df)

# Plot the data points in a PC plane
# And color points according to a categorical variable
p &lt;- ggplot2::autoplot(res_pca, what = "scores")
p + ggplot2::geom_point(ggplot2::aes(color = vespa64$V[1:16]))

</code></pre>

<hr>
<h2 id='autoplot.qts'>Plot for <code><a href="#topic+qts">qts</a></code> objects</h2><span id='topic+autoplot.qts'></span>

<h3>Description</h3>

<p>This function creates a visualization of a QTS and returns the corresponding
<a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object which enable further customization of the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts'
autoplot(object, highlighted_points = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.qts_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
<tr><td><code id="autoplot.qts_+3A_highlighted_points">highlighted_points</code></td>
<td>
<p>An integer vector specifying point indices to be
highlighted. Defaults to <code>NULL</code>, in which case no point will be highlighted
with respect to the others.</p>
</td></tr>
<tr><td><code id="autoplot.qts_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to next methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ggplot2::autoplot(vespa64$igp[[1]])

</code></pre>

<hr>
<h2 id='autoplot.qts_sample'>Plot for <code><a href="#topic+qts_sample">qts_sample</a></code> objects</h2><span id='topic+autoplot.qts_sample'></span>

<h3>Description</h3>

<p>This function creates a visualization of a sample of QTS and returns the
corresponding <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object which enable further customization of
the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts_sample'
autoplot(
  object,
  memberships = NULL,
  highlighted = NULL,
  with_animation = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.qts_sample_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+qts_sample">qts_sample</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.qts_sample_+3A_memberships">memberships</code></td>
<td>
<p>A vector coercible as factor specifying a group membership
for each QTS in the sample. Defaults to <code>NULL</code>, in which case no grouping
structure is displayed.</p>
</td></tr>
<tr><td><code id="autoplot.qts_sample_+3A_highlighted">highlighted</code></td>
<td>
<p>A boolean vector specifying whether each QTS in the sample
should be hightlighted. Defaults to <code>NULL</code>, in which case no QTS is
hightlighted w.r.t. the others.</p>
</td></tr>
<tr><td><code id="autoplot.qts_sample_+3A_with_animation">with_animation</code></td>
<td>
<p>A boolean value specifying whether to create a an
animated plot or a static <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object. Defaults to <code>FALSE</code>
which will create a static plot.</p>
</td></tr>
<tr><td><code id="autoplot.qts_sample_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ggplot2::autoplot(vespa64$igp)

</code></pre>

<hr>
<h2 id='autoplot.qtsclust'>Plot for <code>qtsclust</code> objects</h2><span id='topic+autoplot.qtsclust'></span>

<h3>Description</h3>

<p>This function creates a visualization of the clustering results obtained on a
sample of QTS and returns the corresponding <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object which
enable further customization of the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtsclust'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.qtsclust_+3A_object">object</code></td>
<td>
<p>An object of class <code>qtsclust</code> as produced by
<code><a href="#topic+kmeans.qts_sample">kmeans.qts_sample()</a></code> or <code><a href="#topic+hclust.qts_sample">hclust.qts_sample()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.qtsclust_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- kmeans(vespa64$igp[1:10], n_clusters = 2)
ggplot2::autoplot(out)

</code></pre>

<hr>
<h2 id='centring'>QTS Centering and Standardization</h2><span id='topic+centring'></span>

<h3>Description</h3>

<p>This function operates a centering of the QTS around the geometric mean of
its quaternions. This is effectively achieved by left-multiplying each
quaternion by the inverse of their geometric mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centring(x, standardize = FALSE, keep_summary_stats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centring_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts">qts</a></code>.</p>
</td></tr>
<tr><td><code id="centring_+3A_standardize">standardize</code></td>
<td>
<p>A boolean specifying whether to standardize the QTS in
addition to centering it. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="centring_+3A_keep_summary_stats">keep_summary_stats</code></td>
<td>
<p>A boolean specifying whether the mean and standard
deviation used for standardizing the data should be stored in the output
object. Defaults to <code>FALSE</code> in which case only the centered
<code><a href="#topic+qts">qts</a></code> is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>keep_summary_stats = FALSE</code>, an object of class <code><a href="#topic+qts">qts</a></code> in which
quaternions have been centered (and possibly standardized) around their
geometric mean. If <code>keep_summary_stats = TRUE</code>, a list with three
components:
</p>

<ul>
<li> <p><code>qts</code>: an object of class <code><a href="#topic+qts">qts</a></code> in which quaternions have been centered
(and possibly standardized) around their geometric mean;
</p>
</li>
<li> <p><code>mean</code>: a numeric vector with the quaternion Fréchet mean;
</p>
</li>
<li> <p><code>sd</code>: a numeric value with the quaternion Fréchet standard deviation.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>centring(vespa64$igp[[1]])
</code></pre>

<hr>
<h2 id='dbscan'>QTS Nearest-Neighbor Clustering</h2><span id='topic+dbscan'></span><span id='topic+dbscan.default'></span><span id='topic+dbscan.qts_sample'></span>

<h3>Description</h3>

<p>This function massages the input quaternion time series to apply DBSCAN
clustering on them, with the possibility of separating amplitude and phase
variability and of choosing the source of variability through which clusters
should be searched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbscan(x, ...)

## Default S3 method:
dbscan(x, eps, minPts = 5, weights = NULL, borderPoints = TRUE, ...)

## S3 method for class 'qts_sample'
dbscan(
  x,
  warping_class = c("affine", "dilation", "none", "shift", "srsf"),
  centroid_type = "mean",
  metric = c("l2", "pearson"),
  cluster_on_phase = FALSE,
  use_fence = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbscan_+3A_x">x</code></td>
<td>
<p>Either a numeric matrix of data, or an object that can be coerced to
such a matrix (such as a numeric vector or a data frame with all numeric
columns) or an object of class <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_...">...</code></td>
<td>
<p>additional arguments are passed on to the fixed-radius nearest
neighbor search algorithm. See <code><a href="dbscan.html#topic+frNN">frNN()</a></code> for details on how to
control the search strategy.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_eps">eps</code></td>
<td>
<p>size (radius) of the epsilon neighborhood. Can be omitted if
<code>x</code> is a frNN object.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_minpts">minPts</code></td>
<td>
<p>number of minimum points required in the eps neighborhood for
core points (including the point itself).</p>
</td></tr>
<tr><td><code id="dbscan_+3A_weights">weights</code></td>
<td>
<p>numeric; weights for the data points. Only needed to perform
weighted clustering.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_borderpoints">borderPoints</code></td>
<td>
<p>logical; should border points be assigned to clusters.
The default is <code>TRUE</code> for regular DBSCAN. If <code>FALSE</code> then border
points are considered noise (see DBSCAN* in Campello et al, 2013).</p>
</td></tr>
<tr><td><code id="dbscan_+3A_warping_class">warping_class</code></td>
<td>
<p>A string specifying the warping class Choices are
<code>"affine"</code>, <code>"dilation"</code>, <code>"none"</code>, <code>"shift"</code> or <code>"srsf"</code>. Defaults to
<code>"affine"</code>. The SRSF class is the only class which is boundary-preserving.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_centroid_type">centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code>, <code>"median"</code> <code>"medoid"</code>, <code>"lowess"</code> or <code>"poly"</code>.
Defaults to <code>"mean"</code>. If LOWESS appproximation is chosen, the user can
append an integer between 0 and 100 as in <code>"lowess20"</code>. This number will be
used as the smoother span. This gives the proportion of points in the plot
which influence the smooth at each value. Larger values give more
smoothness. The default value is 10%. If polynomial approximation is
chosen, the user can append an positive integer as in <code>"poly3"</code>. This
number will be used as the degree of the polynomial model. The default
value is <code>4L</code>.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_metric">metric</code></td>
<td>
<p>A character string specifying the distance measure to be used.
This must be one of <code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>,
<code>"canberra"</code>, <code>"binary"</code> or <code>"minkowski"</code> if <code>x</code> is not a QTS sample.
Otherwise, it must be one of <code>"l2"</code>, <code>"pearson"</code> or <code>"dtw"</code>.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_cluster_on_phase">cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_use_fence">use_fence</code></td>
<td>
<p>A boolean specifying whether the fence algorithm should be
used to robustify the algorithm against outliers. Defaults to <code>FALSE</code>. This
is used only when <code>warping_class != "srsf"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+kmeans">stats::kmeans</a></code> or <code><a href="stats.html#topic+hclust">stats::hclust</a></code> or
<code>dbscan_fast</code> if the input <code>x</code> is NOT of class <code><a href="#topic+qts_sample">qts_sample</a></code>. Otherwise,
an object of class <code>qtsclust</code> which is effectively a list with four
components:
</p>

<ul>
<li> <p><code>qts_aligned</code>: An object of class <code><a href="#topic+qts_sample">qts_sample</a></code> storing the sample of
aligned QTS;
</p>
</li>
<li> <p><code>qts_centers</code>: A list of objects of class <code><a href="#topic+qts">qts</a></code> representing the centers
of the clusters;
</p>
</li>
<li> <p><code>best_clustering</code>: An object of class <code><a href="fdacluster.html#topic+caps">fdacluster::caps</a></code> storing the
results of the best k-mean alignment result among all initialization that
were tried.
</p>
</li>
<li> <p><code>call_name</code>: A string storing the name of the function that was used to
produce the clustering structure;
</p>
</li>
<li> <p><code>call_args</code>: A list containing the exact arguments that were passed to
the function <code>call_name</code> that produced this output.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- dbscan(vespa64$igp[1:10])
plot(out)
</code></pre>

<hr>
<h2 id='differentiate'>QTS Differentiation</h2><span id='topic+differentiate'></span><span id='topic+differentiate.qts'></span><span id='topic+differentiate.qts_sample'></span>

<h3>Description</h3>

<p>This function computes the first derivative of quaternion time series with
respect to time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>differentiate(x)

## S3 method for class 'qts'
differentiate(x)

## S3 method for class 'qts_sample'
differentiate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="differentiate_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a> or <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> in which
quaternions measure the rotation to be applied to transform attitude at
previous time point to attitude at current time point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>differentiate(vespa64$igp[[1]])
differentiate(vespa64$igp)
</code></pre>

<hr>
<h2 id='dist'>QTS Distance Matrix Computation</h2><span id='topic+dist'></span><span id='topic+dist.default'></span><span id='topic+dist.qts_sample'></span>

<h3>Description</h3>

<p>This function massages an input sample of quaternion time series to turn it
into a pairwise distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist(x, metric, ...)

## Default S3 method:
dist(
  x,
  metric = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  diag = FALSE,
  upper = FALSE,
  p = 2,
  ...
)

## S3 method for class 'qts_sample'
dist(
  x,
  metric = c("l2", "pearson", "dtw"),
  warping_class = c("affine", "dilation", "none", "shift", "srsf"),
  cluster_on_phase = FALSE,
  labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_+3A_x">x</code></td>
<td>
<p>A numeric matrix, data frame, <a href="stats.html#topic+dist">stats::dist</a> object or object of
class <a href="#topic+qts_sample">qts_sample</a> specifying the sample on which to compute the pairwise
distance matrix.</p>
</td></tr>
<tr><td><code id="dist_+3A_metric">metric</code></td>
<td>
<p>A character string specifying the distance measure to be used.
This must be one of <code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>,
<code>"canberra"</code>, <code>"binary"</code> or <code>"minkowski"</code> if <code>x</code> is not a QTS sample.
Otherwise, it must be one of <code>"l2"</code>, <code>"pearson"</code> or <code>"dtw"</code>.</p>
</td></tr>
<tr><td><code id="dist_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="dist_+3A_diag">diag</code></td>
<td>
<p>logical value indicating whether the diagonal of the
distance matrix should be printed by <code>print.dist</code>.</p>
</td></tr>
<tr><td><code id="dist_+3A_upper">upper</code></td>
<td>
<p>logical value indicating whether the upper triangle of the
distance matrix should be printed by <code>print.dist</code>.</p>
</td></tr>
<tr><td><code id="dist_+3A_p">p</code></td>
<td>
<p>The power of the Minkowski distance.</p>
</td></tr>
<tr><td><code id="dist_+3A_warping_class">warping_class</code></td>
<td>
<p>A string specifying the warping class Choices are
<code>"affine"</code>, <code>"dilation"</code>, <code>"none"</code>, <code>"shift"</code> or <code>"srsf"</code>. Defaults to
<code>"affine"</code>. The SRSF class is the only class which is boundary-preserving.</p>
</td></tr>
<tr><td><code id="dist_+3A_cluster_on_phase">cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td></tr>
<tr><td><code id="dist_+3A_labels">labels</code></td>
<td>
<p>A character vector specifying curve labels. Defaults to <code>NULL</code>
which uses sequential numbers as labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="stats.html#topic+dist">stats::dist</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- dist(vespa64$igp[1:5])
</code></pre>

<hr>
<h2 id='DTW'>Dynamic Time Warping for Quaternion Time Series</h2><span id='topic+DTW'></span>

<h3>Description</h3>

<p>This function evaluates the Dynamic Time Warping (DTW) distance between two
quaternion time series (QTS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTW(
  qts1,
  qts2,
  resample = TRUE,
  disable_normalization = FALSE,
  distance_only = FALSE,
  step_pattern = dtw::symmetric2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DTW_+3A_qts1">qts1</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
<tr><td><code id="DTW_+3A_qts2">qts2</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
<tr><td><code id="DTW_+3A_resample">resample</code></td>
<td>
<p>A boolean specifying whether the QTS should be uniformly
resampled on their domain before computing distances. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DTW_+3A_disable_normalization">disable_normalization</code></td>
<td>
<p>A boolean specifying whether quaternion
normalization should be disabled. Defaults to <code>FALSE</code> which ensures that we
always deal with unit quaternions.</p>
</td></tr>
<tr><td><code id="DTW_+3A_distance_only">distance_only</code></td>
<td>
<p>A boolean specifying whether to only compute distance
(no backtrack, faster). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DTW_+3A_step_pattern">step_pattern</code></td>
<td>
<p>A <a href="dtw.html#topic+stepPattern">dtw::stepPattern</a> specifying the local constraints on
the warping path. Defaults to <a href="dtw.html#topic+stepPattern">dtw::symmetric2</a> which uses symmetric and
normalizable warping paths with no local slope constraints. See
<a href="dtw.html#topic+stepPattern">dtw::stepPattern</a> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no evaluation grid is provided, the function assumes that the two input
QTS are evaluated on the same grid.
</p>


<h3>Value</h3>

<p>An object of class <a href="dtw.html#topic+dtw">dtw::dtw</a> storing the dynamic time warping
results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DTW(vespa64$igp[[1]], vespa64$igp[[2]])
</code></pre>

<hr>
<h2 id='exp'>QTS Exponential</h2><span id='topic+exp'></span><span id='topic+exp.qts'></span><span id='topic+exp.qts_sample'></span>

<h3>Description</h3>

<p>This function computes the exponential of quaternion time series as the time
series of the quaternion exponentials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts'
exp(x, ...)

## S3 method for class 'qts_sample'
exp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a> or <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
<tr><td><code id="exp_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed on to next methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> in which
quaternions have been replaced by their exponential.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- log(vespa64$igp[[1]])
exp(x)
y &lt;- log(vespa64$igp)
exp(y)
</code></pre>

<hr>
<h2 id='hclust'>QTS Hierarchical Agglomerative Clustering</h2><span id='topic+hclust'></span><span id='topic+hclust.default'></span><span id='topic+hclust.qts_sample'></span>

<h3>Description</h3>

<p>This function massages the input quaternion time series to apply hierarchical
agglomerative clustering on them, with the possibility of separating
amplitude and phase variability and of choosing the source of variability
through which clusters should be searched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclust(x, metric, linkage_criterion, ...)

## Default S3 method:
hclust(
  x,
  metric = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  linkage_criterion = c("complete", "average", "single", "ward.D2"),
  ...
)

## S3 method for class 'qts_sample'
hclust(
  x,
  metric = c("l2", "pearson"),
  linkage_criterion = c("complete", "average", "single", "ward.D2"),
  n_clusters = 1L,
  warping_class = c("affine", "dilation", "none", "shift", "srsf"),
  centroid_type = "mean",
  cluster_on_phase = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hclust_+3A_x">x</code></td>
<td>
<p>Either a numeric matrix of data, or an object that can be coerced to
such a matrix (such as a numeric vector or a data frame with all numeric
columns) or an object of class <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
<tr><td><code id="hclust_+3A_metric">metric</code></td>
<td>
<p>A character string specifying the distance measure to be used.
This must be one of <code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>,
<code>"canberra"</code>, <code>"binary"</code> or <code>"minkowski"</code> if <code>x</code> is not a QTS sample.
Otherwise, it must be one of <code>"l2"</code>, <code>"pearson"</code> or <code>"dtw"</code>.</p>
</td></tr>
<tr><td><code id="hclust_+3A_linkage_criterion">linkage_criterion</code></td>
<td>
<p>A string specifying which linkage criterion should
be used to compute distances between sets of curves. Choices are
<code>"complete"</code> for complete linkage, <code>"average"</code> for average linkage and
<code>"single"</code> for single linkage. See <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> for more details.
Defaults to <code>"complete"</code>.</p>
</td></tr>
<tr><td><code id="hclust_+3A_...">...</code></td>
<td>
<p>Further graphical arguments.  E.g., <code>cex</code> controls
the size of the labels (if plotted) in the same way as <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="hclust_+3A_n_clusters">n_clusters</code></td>
<td>
<p>An integer value specifying the number of clusters.
Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="hclust_+3A_warping_class">warping_class</code></td>
<td>
<p>A string specifying the warping class Choices are
<code>"affine"</code>, <code>"dilation"</code>, <code>"none"</code>, <code>"shift"</code> or <code>"srsf"</code>. Defaults to
<code>"affine"</code>. The SRSF class is the only class which is boundary-preserving.</p>
</td></tr>
<tr><td><code id="hclust_+3A_centroid_type">centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code>, <code>"median"</code> <code>"medoid"</code>, <code>"lowess"</code> or <code>"poly"</code>.
Defaults to <code>"mean"</code>. If LOWESS appproximation is chosen, the user can
append an integer between 0 and 100 as in <code>"lowess20"</code>. This number will be
used as the smoother span. This gives the proportion of points in the plot
which influence the smooth at each value. Larger values give more
smoothness. The default value is 10%. If polynomial approximation is
chosen, the user can append an positive integer as in <code>"poly3"</code>. This
number will be used as the degree of the polynomial model. The default
value is <code>4L</code>.</p>
</td></tr>
<tr><td><code id="hclust_+3A_cluster_on_phase">cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+kmeans">stats::kmeans</a></code> or <code><a href="stats.html#topic+hclust">stats::hclust</a></code> or
<code>dbscan_fast</code> if the input <code>x</code> is NOT of class <code><a href="#topic+qts_sample">qts_sample</a></code>. Otherwise,
an object of class <code>qtsclust</code> which is effectively a list with four
components:
</p>

<ul>
<li> <p><code>qts_aligned</code>: An object of class <code><a href="#topic+qts_sample">qts_sample</a></code> storing the sample of
aligned QTS;
</p>
</li>
<li> <p><code>qts_centers</code>: A list of objects of class <code><a href="#topic+qts">qts</a></code> representing the centers
of the clusters;
</p>
</li>
<li> <p><code>best_clustering</code>: An object of class <code><a href="fdacluster.html#topic+caps">fdacluster::caps</a></code> storing the
results of the best k-mean alignment result among all initialization that
were tried.
</p>
</li>
<li> <p><code>call_name</code>: A string storing the name of the function that was used to
produce the clustering structure;
</p>
</li>
<li> <p><code>call_args</code>: A list containing the exact arguments that were passed to
the function <code>call_name</code> that produced this output.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- hclust(vespa64$igp[1:10], n_clusters = 2)
plot(out)
</code></pre>

<hr>
<h2 id='hemispherize'>QTS Hemispherization</h2><span id='topic+hemispherize'></span><span id='topic+hemispherize.qts'></span><span id='topic+hemispherize.qts_sample'></span>

<h3>Description</h3>

<p>This function ensures that there are no discontinuities in QTS due to
quaternion flips since two unit quaternions q and -q encode the same
rotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hemispherize(x)

## S3 method for class 'qts'
hemispherize(x)

## S3 method for class 'qts_sample'
hemispherize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hemispherize_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts">qts</a></code> or <code><a href="#topic+qts_sample">qts_sample</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> with no
quaternion flip discontinuities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hemispherize(vespa64$igp[[1]])
hemispherize(vespa64$igp)
</code></pre>

<hr>
<h2 id='inverse_qts'>Inverse Operator for <code>qts</code> Objects</h2><span id='topic+inverse_qts'></span>

<h3>Description</h3>

<p>This function implements the pointwise inverse of a quaternion time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_qts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverse_qts_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts">qts</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+qts">qts</a></code> storing the inverse of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inverse_qts(vespa64$igp[[1]])
</code></pre>

<hr>
<h2 id='kmeans'>QTS K-Means Alignment Algorithm</h2><span id='topic+kmeans'></span><span id='topic+kmeans.default'></span><span id='topic+kmeans.qts_sample'></span>

<h3>Description</h3>

<p>This function massages the input quaternion time series to feed them into the
k-means alignment algorithm for jointly clustering and aligning the input
QTS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeans(x, n_clusters, ...)

## Default S3 method:
kmeans(
  x,
  n_clusters = 1,
  iter_max = 10,
  nstart = 1,
  algorithm = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen"),
  trace = FALSE,
  ...
)

## S3 method for class 'qts_sample'
kmeans(
  x,
  n_clusters = 1L,
  seeds = NULL,
  seeding_strategy = c("kmeans++", "exhaustive-kmeans++", "exhaustive", "hclust"),
  warping_class = c("affine", "dilation", "none", "shift", "srsf"),
  centroid_type = "mean",
  metric = c("l2", "pearson"),
  cluster_on_phase = FALSE,
  use_fence = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeans_+3A_x">x</code></td>
<td>
<p>Either a numeric matrix of data, or an object that can be coerced to
such a matrix (such as a numeric vector or a data frame with all numeric
columns) or an object of class <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_n_clusters">n_clusters</code></td>
<td>
<p>An integer value specifying the number of clusters to be
look for.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_iter_max">iter_max</code></td>
<td>
<p>An integer value specifying the maximum number of iterations
for terminating the k-mean algorithm. Defaults to <code>10L</code>.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_nstart">nstart</code></td>
<td>
<p>if <code>centers</code> is a number, how many random sets
should be chosen?</p>
</td></tr>
<tr><td><code id="kmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>character: may be abbreviated.  Note that
<code>"Lloyd"</code> and <code>"Forgy"</code> are alternative names for one
algorithm.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_trace">trace</code></td>
<td>
<p>logical or integer number, currently only used in the
default method (<code>"Hartigan-Wong"</code>): if positive (or true),
tracing information on the progress of the algorithm is
produced.  Higher values may produce more tracing information.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_seeds">seeds</code></td>
<td>
<p>An integer value or vector specifying the indices of the initial
centroids. If an integer vector, it is interpreted as the indices of the
intial centroids and should therefore be of length <code>n_clusters</code>. If an
integer value, it is interpreted as the index of the first initial centroid
and subsequent centroids are chosen according to the k-means++ strategy. It
can be <code>NULL</code> in which case the argument <code>seeding_strategy</code> is used to
automatically provide suitable indices. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_seeding_strategy">seeding_strategy</code></td>
<td>
<p>A character string specifying the strategy for
choosing the initial centroids in case the argument <code>seeds</code> is set to
<code>NULL</code>. Choices are
<a href="https://en.wikipedia.org/wiki/K-means%2B%2B"><code>"kmeans++"</code></a>,
<code>"exhaustive-kmeans++"</code> which performs an exhaustive search over the choice
of the first centroid, <code>"exhaustive"</code> which tries on all combinations of
initial centroids or <code>"hclust"</code> which first performs hierarchical
clustering using Ward's linkage criterion to identify initial centroids.
Defaults to <code>"kmeans++"</code>, which is the fastest strategy.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_warping_class">warping_class</code></td>
<td>
<p>A string specifying the warping class Choices are
<code>"affine"</code>, <code>"dilation"</code>, <code>"none"</code>, <code>"shift"</code> or <code>"srsf"</code>. Defaults to
<code>"affine"</code>. The SRSF class is the only class which is boundary-preserving.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_centroid_type">centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code>, <code>"median"</code> <code>"medoid"</code>, <code>"lowess"</code> or <code>"poly"</code>.
Defaults to <code>"mean"</code>. If LOWESS appproximation is chosen, the user can
append an integer between 0 and 100 as in <code>"lowess20"</code>. This number will be
used as the smoother span. This gives the proportion of points in the plot
which influence the smooth at each value. Larger values give more
smoothness. The default value is 10%. If polynomial approximation is
chosen, the user can append an positive integer as in <code>"poly3"</code>. This
number will be used as the degree of the polynomial model. The default
value is <code>4L</code>.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_metric">metric</code></td>
<td>
<p>A string specifying the metric used to compare curves. Choices
are <code>"l2"</code> or <code>"pearson"</code>. Defaults to <code>"l2"</code>. Used only when
<code>warping_class != "srsf"</code>. For the boundary-preserving warping class, the
L2 distance between the SRSFs of the original curves is used.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_cluster_on_phase">cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_use_fence">use_fence</code></td>
<td>
<p>A boolean specifying whether the fence algorithm should be
used to robustify the algorithm against outliers. Defaults to <code>FALSE</code>. This
is used only when <code>warping_class != "srsf"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+kmeans">stats::kmeans</a></code> or <code><a href="stats.html#topic+hclust">stats::hclust</a></code> or
<code>dbscan_fast</code> if the input <code>x</code> is NOT of class <code><a href="#topic+qts_sample">qts_sample</a></code>. Otherwise,
an object of class <code>qtsclust</code> which is effectively a list with four
components:
</p>

<ul>
<li> <p><code>qts_aligned</code>: An object of class <code><a href="#topic+qts_sample">qts_sample</a></code> storing the sample of
aligned QTS;
</p>
</li>
<li> <p><code>qts_centers</code>: A list of objects of class <code><a href="#topic+qts">qts</a></code> representing the centers
of the clusters;
</p>
</li>
<li> <p><code>best_clustering</code>: An object of class <code><a href="fdacluster.html#topic+caps">fdacluster::caps</a></code> storing the
results of the best k-mean alignment result among all initialization that
were tried.
</p>
</li>
<li> <p><code>call_name</code>: A string storing the name of the function that was used to
produce the clustering structure;
</p>
</li>
<li> <p><code>call_args</code>: A list containing the exact arguments that were passed to
the function <code>call_name</code> that produced this output.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- kmeans(vespa64$igp[1:10], n_clusters = 2)
</code></pre>

<hr>
<h2 id='log'>QTS Logarithm</h2><span id='topic+log'></span><span id='topic+log.qts'></span><span id='topic+log.qts_sample'></span>

<h3>Description</h3>

<p>This function computes the logarithm of quaternion time series as the time
series of the quaternion logarithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts'
log(x, ...)

## S3 method for class 'qts_sample'
log(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a> or <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
<tr><td><code id="log_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed on to next methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> in which
quaternions have been replaced by their logarithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log(vespa64$igp[[1]])
log(vespa64$igp)
</code></pre>

<hr>
<h2 id='mean.qts_sample'>QTS Geometric Mean</h2><span id='topic+mean.qts_sample'></span>

<h3>Description</h3>

<p>This function computes the pointwise geometric mean of a QTS sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts_sample'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.qts_sample_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts_sample">qts_sample</a></code>.</p>
</td></tr>
<tr><td><code id="mean.qts_sample_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+qts">qts</a></code> in which quaternions are the
pointwise geometric mean of the input QTS sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean(vespa64$igp)
</code></pre>

<hr>
<h2 id='median.qts_sample'>QTS Geometric Median</h2><span id='topic+median.qts_sample'></span>

<h3>Description</h3>

<p>This function computes the pointwise geometric median of a QTS sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts_sample'
median(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median.qts_sample_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts_sample">qts_sample</a></code>.</p>
</td></tr>
<tr><td><code id="median.qts_sample_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="median.qts_sample_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+qts">qts</a></code> in which quaternions are the
pointwise geometric median of the input QTS sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>median(vespa64$igp)
</code></pre>

<hr>
<h2 id='moving_average'>QTS Moving Average</h2><span id='topic+moving_average'></span><span id='topic+moving_average.qts'></span><span id='topic+moving_average.qts_sample'></span>

<h3>Description</h3>

<p>This function performs QTS smoothing via moving average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moving_average(x, window_size = 0)

## S3 method for class 'qts'
moving_average(x, window_size = 0)

## S3 method for class 'qts_sample'
moving_average(x, window_size = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moving_average_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts">qts</a></code> or <code><a href="#topic+qts_sample">qts_sample</a></code>.</p>
</td></tr>
<tr><td><code id="moving_average_+3A_window_size">window_size</code></td>
<td>
<p>An integer value specifying the size of the sliding window
used to compute the median value. Defaults to <code>0L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> storing the
smoothed QTS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>moving_average(vespa64$igp[[1]], window_size = 5)
moving_average(vespa64$igp, window_size = 5)
</code></pre>

<hr>
<h2 id='normalize'>QTS Normalization</h2><span id='topic+normalize'></span><span id='topic+normalize.qts'></span><span id='topic+normalize.qts_sample'></span>

<h3>Description</h3>

<p>This function ensures that all quaternions in the time series are unit
quaternions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x)

## S3 method for class 'qts'
normalize(x)

## S3 method for class 'qts_sample'
normalize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a> or <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> in which
quaternions are unit quaternions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalize(vespa64$igp[[1]])
normalize(vespa64$igp)
</code></pre>

<hr>
<h2 id='plot.prcomp_qts'>Plot for <code>prcomp_qts</code> objects</h2><span id='topic+plot.prcomp_qts'></span><span id='topic+screeplot.prcomp_qts'></span>

<h3>Description</h3>

<p>This function creates a visualization of the results of the PCA applied on a
sample of QTS <strong>without</strong> returning the plot data as an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prcomp_qts'
plot(x, what = "PC1", ...)

## S3 method for class 'prcomp_qts'
screeplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.prcomp_qts_+3A_x">x</code></td>
<td>
<p>An object of class <code>prcomp_qts</code> as produced by the
<code><a href="#topic+prcomp.qts_sample">prcomp.qts_sample()</a></code> method.</p>
</td></tr>
<tr><td><code id="plot.prcomp_qts_+3A_what">what</code></td>
<td>
<p>A string specifying what kind of visualization the user wants to
perform. Choices are words starting with <code>PC</code> and ending with a PC number
(in which case the mean QTS is displayed along with its perturbations due
to the required PC) or <code>scores</code> (in which case individuals are projected on
the required plane). Defaults to <code>PC1</code>.</p>
</td></tr>
<tr><td><code id="plot.prcomp_qts_+3A_...">...</code></td>
<td>
<p>If <code>what = "PC?"</code>, the user can specify whether to plot the QTS in
the tangent space or in the original space by providing a boolean argument
<code>original_space</code> which defaults to <code>TRUE</code>. If <code>what = "scores"</code>, the user
can specify the plane onto which the individuals will be projected by
providing a length-2 integer vector argument <code>plane</code> which defaults to
<code>1:2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- as_qts_sample(vespa64$igp[1:16])
res_pca &lt;- prcomp(df)

# You can plot the effect of a PC on the mean
plot(res_pca, what = "PC1")

# You can plot the data points in a PC plane
plot(res_pca, what = "scores")
</code></pre>

<hr>
<h2 id='plot.qts'>Plot for <code><a href="#topic+qts">qts</a></code> objects</h2><span id='topic+plot.qts'></span>

<h3>Description</h3>

<p>This function creates a visualization of a QTS <strong>without</strong> returning the plot
data as an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts'
plot(x, highlighted_points = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.qts_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
<tr><td><code id="plot.qts_+3A_highlighted_points">highlighted_points</code></td>
<td>
<p>An integer vector specifying point indices to be
highlighted. Defaults to <code>NULL</code>, in which case no point will be highlighted
with respect to the others.</p>
</td></tr>
<tr><td><code id="plot.qts_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to next methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(vespa64$igp[[1]])
</code></pre>

<hr>
<h2 id='plot.qts_sample'>Plot for <code><a href="#topic+qts_sample">qts_sample</a></code> objects</h2><span id='topic+plot.qts_sample'></span>

<h3>Description</h3>

<p>This function creates a visualization of a sample of QTS <strong>without</strong>
returning the corresponding <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts_sample'
plot(x, memberships = NULL, highlighted = NULL, with_animation = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.qts_sample_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+qts_sample">qts_sample</a></code>.</p>
</td></tr>
<tr><td><code id="plot.qts_sample_+3A_memberships">memberships</code></td>
<td>
<p>A vector coercible as factor specifying a group membership
for each QTS in the sample. Defaults to <code>NULL</code>, in which case no grouping
structure is displayed.</p>
</td></tr>
<tr><td><code id="plot.qts_sample_+3A_highlighted">highlighted</code></td>
<td>
<p>A boolean vector specifying whether each QTS in the sample
should be hightlighted. Defaults to <code>NULL</code>, in which case no QTS is
hightlighted w.r.t. the others.</p>
</td></tr>
<tr><td><code id="plot.qts_sample_+3A_with_animation">with_animation</code></td>
<td>
<p>A boolean value specifying whether to create a an
animated plot or a static <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> object. Defaults to <code>FALSE</code>
which will create a static plot.</p>
</td></tr>
<tr><td><code id="plot.qts_sample_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(vespa64$igp)
</code></pre>

<hr>
<h2 id='plot.qtsclust'>Plot for <code>qtsclust</code> objects</h2><span id='topic+plot.qtsclust'></span>

<h3>Description</h3>

<p>This function creates a visualization of the clustering results obtained on a
sample of QTS <strong>without</strong> returning the plot data as an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qtsclust'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.qtsclust_+3A_x">x</code></td>
<td>
<p>An object of class <code>qtsclust</code> as produced by <code><a href="#topic+kmeans.qts_sample">kmeans.qts_sample()</a></code>
or <code><a href="#topic+hclust.qts_sample">hclust.qts_sample()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.qtsclust_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- kmeans(vespa64$igp[1:10], n_clusters = 2)
plot(out)
</code></pre>

<hr>
<h2 id='prcomp.qts_sample'>PCA for QTS Sample</h2><span id='topic+prcomp.qts_sample'></span>

<h3>Description</h3>

<p>This is the <code>S3</code> specialization of the function <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code> for QTS
samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qts_sample'
prcomp(x, M = 5, fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prcomp.qts_sample_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
<tr><td><code id="prcomp.qts_sample_+3A_m">M</code></td>
<td>
<p>An integer value specifying the number of principal component to
compute. Defaults to <code>5L</code>.</p>
</td></tr>
<tr><td><code id="prcomp.qts_sample_+3A_fit">fit</code></td>
<td>
<p>A boolean specifying whether the resulting <code>prcomp_qts</code> object
should store a reconstruction of the sample from the retained PCs. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="prcomp.qts_sample_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mean_qts</code> component of the resulting object is the QTS used for
centering. It it part of the <code>prcomp_qts</code> object because it is needed to
reconstruct the sample from the retained PCs. The <code>prcomp_qts</code> object also
contains the total variance of the sample and the percentage of variance
explained by each PC.
</p>


<h3>Value</h3>

<p>An object of class <code>prcomp_qts</code> which is a list with the following
components:
</p>

<ul>
<li> <p><code>tpca</code>: An object of class <code>MFPCAfit</code> as produced by the function
<code><a href="MFPCA.html#topic+MFPCA">MFPCA::MFPCA()</a></code>,
</p>
</li>
<li> <p><code>var_props</code>: A numeric vector storing the percentage of variance explained
by each PC,
</p>
</li>
<li> <p><code>total_variance</code>: A numeric value storing the total variance of the sample,
</p>
</li>
<li> <p><code>mean_qts</code>: An object of class <a href="#topic+qts">qts</a> containing the mean QTS (used for
centering the QTS sample before projecting it to the tangent space),
</p>
</li>
<li> <p><code>principal_qts</code>: A list of <a href="#topic+qts">qts</a>s containing the required principal
components.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>res_pca &lt;- prcomp(vespa64$igp[1:16])
</code></pre>

<hr>
<h2 id='predict.prcomp_qts'>Predict QTS from PCA decomposition</h2><span id='topic+predict.prcomp_qts'></span>

<h3>Description</h3>

<p>This function predicts the QTS of a new sample from the PCA decomposition of
a previous sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prcomp_qts'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.prcomp_qts_+3A_object">object</code></td>
<td>
<p>An object of class <code>prcomp_qts</code> as produced by the
<code><a href="#topic+prcomp.qts_sample">prcomp.qts_sample()</a></code> method.</p>
</td></tr>
<tr><td><code id="predict.prcomp_qts_+3A_newdata">newdata</code></td>
<td>
<p>An object of class <code><a href="#topic+qts">qts</a></code> or <code><a href="#topic+qts_sample">qts_sample</a></code> specifying a QTS
or a sample of QTS. The QTS should be evaluated on the same grid as the one
used to fit the PCA model. If the evaluation grids map the same domain but
with different sampling frequenciesa, the QTS will be linearly interpolated
(in the Lie algebra) to the common grid used to fit the PCA model.</p>
</td></tr>
<tr><td><code id="predict.prcomp_qts_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+qts_sample">qts_sample</a></code> containing the predicted QTS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit PCA model
pr &lt;- prcomp(vespa64$igp, M = 5)

# Predict QTS
new_qts &lt;- predict(pr)
</code></pre>

<hr>
<h2 id='qts'>QTS Class</h2><span id='topic+qts'></span><span id='topic+as_qts'></span><span id='topic+is_qts'></span><span id='topic+format.qts'></span>

<h3>Description</h3>

<p>A collection of functions that implements the QTS class. It currently
provides the <code><a href="#topic+as_qts">as_qts()</a></code> function for QTS coercion of <code><a href="tibble.html#topic+tibble">tibble::tibble</a></code>s
and the <code><a href="#topic+is_qts">is_qts()</a></code> function for checking if an object is a QTS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_qts(x)

is_qts(x)

## S3 method for class 'qts'
format(x, digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qts_+3A_x">x</code></td>
<td>
<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble</a></code> with columns <code>time</code>, <code>w</code>, <code>x</code>, <code>y</code> and <code>z</code>.</p>
</td></tr>
<tr><td><code id="qts_+3A_digits">digits</code></td>
<td>
<p>An integer value specifying the number of digits to keep for
printing. Defaults to <code>5L</code>.</p>
</td></tr>
<tr><td><code id="qts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A quaternion time series (QTS) is stored as a <code><a href="tibble.html#topic+tibble">tibble::tibble</a></code> with 5
columns:
</p>

<ul>
<li> <p><code>time</code>: A first column specifying the time points at which quaternions were
collected;
</p>
</li>
<li> <p><code>w</code>: A second column specifying the first coordinate of the collected
quaternions;
</p>
</li>
<li> <p><code>x</code>: A third column specifying the second coordinate of the collected
quaternions;
</p>
</li>
<li> <p><code>y</code>: A fourth column specifying the third coordinate of the collected
quaternions;
</p>
</li>
<li> <p><code>z</code>: A fifth column specifying the fourth coordinate of the collected
quaternions.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+qts">qts</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qts1 &lt;- vespa64$igp[[1]]
qts2 &lt;- as_qts(qts1)
is_qts(qts1)
is_qts(qts2)
</code></pre>

<hr>
<h2 id='qts_sample'>QTS Sample Class</h2><span id='topic+qts_sample'></span><span id='topic+as_qts_sample'></span><span id='topic+is_qts_sample'></span><span id='topic++5B.qts_sample'></span>

<h3>Description</h3>

<p>A collection of functions that implements the QTS sample class. It currently
provides the <code><a href="#topic+as_qts_sample">as_qts_sample()</a></code> function for QTS sample coercion of lists of
<code><a href="#topic+qts">qts</a></code> objects, the <code><a href="#topic+is_qts_sample">is_qts_sample()</a></code> function for checking if an object
is a QTS sample and the subset operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_qts_sample(x)

is_qts_sample(x)

## S3 method for class 'qts_sample'
x[i, simplify = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qts_sample_+3A_x">x</code></td>
<td>
<p>A list of <code><a href="tibble.html#topic+tibble">tibble::tibble</a></code>s, each of which with columns
<code>time</code>, <code>w</code>, <code>x</code>, <code>y</code> and <code>z</code>.</p>
</td></tr>
<tr><td><code id="qts_sample_+3A_i">i</code></td>
<td>
<p>A valid expression to subset observations from a QTS sample.</p>
</td></tr>
<tr><td><code id="qts_sample_+3A_simplify">simplify</code></td>
<td>
<p>A boolean value specifying whether the resulting subset
should be turned into a single QTS in case the subset is of size 1.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A QTS sample is a collection of quaternion time series (QTS), each of which
is stored as a <code><a href="tibble.html#topic+tibble">tibble::tibble</a></code> with 5 columns:
</p>

<ul>
<li> <p><code>time</code>: A first column specifying the time points at which quaternions were
collected;
</p>
</li>
<li> <p><code>w</code>: A second column specifying the first coordinate of the collected
quaternions;
</p>
</li>
<li> <p><code>x</code>: A third column specifying the second coordinate of the collected
quaternions;
</p>
</li>
<li> <p><code>y</code>: A fourth column specifying the third coordinate of the collected
quaternions;
</p>
</li>
<li> <p><code>z</code>: A fifth column specifying the fourth coordinate of the collected
quaternions.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+qts_sample">qts_sample</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- vespa64$igp
y &lt;- as_qts_sample(x)
is_qts_sample(x)
is_qts_sample(y)
x[1]
x[1, simplify = TRUE]
</code></pre>

<hr>
<h2 id='qts2aats'>QTS Transformation to Angle-Axis Time Series</h2><span id='topic+qts2aats'></span>

<h3>Description</h3>

<p>This function converts a quaternion time series into its angle-axis
representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qts2aats(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qts2aats_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A time series stored as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns <code>time</code>,
<code>angle</code>, <code>ux</code>, <code>uy</code> and <code>uz</code> containing the angle-axis representation of
the input quaternions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qts2aats(vespa64$igp[[1]])
</code></pre>

<hr>
<h2 id='qts2ats'>QTS Transformation To Angle Time Series</h2><span id='topic+qts2ats'></span>

<h3>Description</h3>

<p>This function computes a univariate time series representing the angle
between the first and other attitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qts2ats(x, disable_normalization = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qts2ats_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
<tr><td><code id="qts2ats_+3A_disable_normalization">disable_normalization</code></td>
<td>
<p>A boolean specifying whether quaternion
normalization should be disabled. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A time series stored as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns <code>time</code> and
<code>angle</code> in which <code>angle</code> measures the angle between the current rotation
and the first one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qts2ats(vespa64$igp[[1]])
</code></pre>

<hr>
<h2 id='qts2avts'>QTS Transformation to Angular Velocity Time Series</h2><span id='topic+qts2avts'></span>

<h3>Description</h3>

<p>This function projects a quaternion time series into the space of angular
velocities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qts2avts(x, body_frame = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qts2avts_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
<tr><td><code id="qts2avts_+3A_body_frame">body_frame</code></td>
<td>
<p>A boolean specifying whether the fixed frame with respect
to which coordinates of the angular velocity should be computed is the body
frame or the global frame. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A time series stored as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns <code>time</code>, <code>x</code>,
<code>y</code> and <code>z</code> containing the angular velocity at each time point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qts2avts(vespa64$igp[[1]])
</code></pre>

<hr>
<h2 id='qts2dts'>QTS Transformation To Distance Time Series</h2><span id='topic+qts2dts'></span>

<h3>Description</h3>

<p>This function computes a real-valued time series reporting the pointwise
geodesic distance between the two input QTS at each time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qts2dts(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qts2dts_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
<tr><td><code id="qts2dts_+3A_y">y</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently expects that the two input QTS are evaluated on the
same time grid.
</p>


<h3>Value</h3>

<p>A time series stored as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns <code>time</code> and
<code>distance</code> in which <code>distance</code> measures the angular distance between the
quaternions of both input QTS at a given time point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qts2dts(vespa64$igp[[1]], vespa64$igp[[2]])
</code></pre>

<hr>
<h2 id='qts2nts'>QTS Transformation To Norm Time Series</h2><span id='topic+qts2nts'></span>

<h3>Description</h3>

<p>This function computes a univariate time series representing the norm of the
quaternions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qts2nts(x, disable_normalization = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qts2nts_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a>.</p>
</td></tr>
<tr><td><code id="qts2nts_+3A_disable_normalization">disable_normalization</code></td>
<td>
<p>A boolean specifying whether quaternion
normalization should be disabled. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A time series stored as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns <code>time</code> and
<code>norm</code> in which <code>norm</code> measures the angular distance between the current
quaternion and the identity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qts2nts(vespa64$igp[[1]])
</code></pre>

<hr>
<h2 id='reorient'>QTS Reorientation</h2><span id='topic+reorient'></span><span id='topic+reorient.qts'></span><span id='topic+reorient.qts_sample'></span>

<h3>Description</h3>

<p>This function reorients the quaternions in a QTS for representing attitude
with respect to the orientation of the sensor at the first time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorient(x, disable_normalization = FALSE)

## S3 method for class 'qts'
reorient(x, disable_normalization = FALSE)

## S3 method for class 'qts_sample'
reorient(x, disable_normalization = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorient_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a> or <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
<tr><td><code id="reorient_+3A_disable_normalization">disable_normalization</code></td>
<td>
<p>A boolean specifying whether quaternion
normalization should be disabled. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> in which
quaternions measure attitude with respect to the orientation of the sensor
at the first time point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reorient(vespa64$igp[[1]])
reorient(vespa64$igp)
</code></pre>

<hr>
<h2 id='resample'>QTS Resampling</h2><span id='topic+resample'></span><span id='topic+resample.qts'></span><span id='topic+resample.qts_sample'></span>

<h3>Description</h3>

<p>This function performs uniform resampling using SLERP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(x, tmin = NA, tmax = NA, nout = 0L, disable_normalization = FALSE)

## S3 method for class 'qts'
resample(x, tmin = NA, tmax = NA, nout = 0L, disable_normalization = FALSE)

## S3 method for class 'qts_sample'
resample(x, tmin = NA, tmax = NA, nout = 0L, disable_normalization = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a> or <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
<tr><td><code id="resample_+3A_tmin">tmin</code></td>
<td>
<p>A numeric value specifying the lower bound of the time interval
over which uniform resampling should take place. It must satisfy <code>tmin &gt;= min(qts$time)</code>. Defaults to <code>NA</code> in which case it is set to
<code>min(qts$time)</code>.</p>
</td></tr>
<tr><td><code id="resample_+3A_tmax">tmax</code></td>
<td>
<p>A numeric value specifying the upper bound of the time interval
over which uniform resampling should take place. It must satisfy <code>tmax &lt;= max(qts$time)</code>. Defaults to <code>NA</code> in which case it is set to
<code>max(qts$time)</code>.</p>
</td></tr>
<tr><td><code id="resample_+3A_nout">nout</code></td>
<td>
<p>An integer specifying the size of the uniform grid for time
resampling. Defaults to <code>0L</code> in which case it uses the same grid size as
the input QTS.</p>
</td></tr>
<tr><td><code id="resample_+3A_disable_normalization">disable_normalization</code></td>
<td>
<p>A boolean specifying whether quaternion
normalization should be disabled. Defaults to <code>FALSE</code> in which case the
function makes sure that quaternions are normalized prior to performing
SLERP interpolation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> in which
quaternions are uniformly sampled in the range <code style="white-space: pre;">&#8288;[tmin, tmax]&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resample(vespa64$igp[[1]])
resample(vespa64$igp)
</code></pre>

<hr>
<h2 id='rnorm_qts'>QTS Random Sampling</h2><span id='topic+rnorm_qts'></span>

<h3>Description</h3>

<p>This function adds uncorrelated Gaussian noise to the logarithm QTS using an
exponential covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnorm_qts(n, mean_qts, alpha = 0.01, beta = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnorm_qts_+3A_n">n</code></td>
<td>
<p>An integer specifying how many QTS should be generated.</p>
</td></tr>
<tr><td><code id="rnorm_qts_+3A_mean_qts">mean_qts</code></td>
<td>
<p>An object of class <code><a href="#topic+qts">qts</a></code> specifying the mean QTS.</p>
</td></tr>
<tr><td><code id="rnorm_qts_+3A_alpha">alpha</code></td>
<td>
<p>A positive scalar specifying the variance of each component of
the log-QTS. Defaults to <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="rnorm_qts_+3A_beta">beta</code></td>
<td>
<p>A positive scalar specifying the exponential weight. Defaults to
<code>0.001</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="roahd.html#topic+exp_cov_function">exp_cov_function</a></code> for details about the roles of
<code>alpha</code> and <code>beta</code> in the definition of the covariance operator.
</p>


<h3>Value</h3>

<p>A list of <code>n</code> objects of class <code><a href="#topic+qts">qts</a></code> with added noise as
specified by parameters <code>alpha</code> and <code>beta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rnorm_qts(1, vespa64$igp[[1]])
</code></pre>

<hr>
<h2 id='scale'>QTS Sample Centering and Standardization</h2><span id='topic+scale'></span><span id='topic+scale.default'></span><span id='topic+scale.qts_sample'></span>

<h3>Description</h3>

<p>QTS Sample Centering and Standardization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale(x, center = TRUE, scale = TRUE, ...)

## Default S3 method:
scale(x, center = TRUE, scale = TRUE, ...)

## S3 method for class 'qts_sample'
scale(
  x,
  center = TRUE,
  scale = TRUE,
  by_row = FALSE,
  keep_summary_stats = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_+3A_x">x</code></td>
<td>
<p>An object coercible into a numeric matrix or an object of class
<code><a href="#topic+qts_sample">qts_sample</a></code> representing a sample of observed QTS.</p>
</td></tr>
<tr><td><code id="scale_+3A_center">center</code></td>
<td>
<p>A boolean specifying whether to center the sample. If set to
<code>FALSE</code>, the original sample is returned, meaning that no standardization
is performed regardless of whether argument <code>scale</code> was set to <code>TRUE</code> or
not. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_+3A_scale">scale</code></td>
<td>
<p>A boolean specifying whether to standardize the sample once it
has been centered. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on to next methods.</p>
</td></tr>
<tr><td><code id="scale_+3A_by_row">by_row</code></td>
<td>
<p>A boolean specifying whether the QTS scaling should happen for
each data point (<code>by_row = TRUE</code>) or for each time point (<code>by_row = FALSE</code>). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_+3A_keep_summary_stats">keep_summary_stats</code></td>
<td>
<p>A boolean specifying whether the mean and standard
deviation used for standardizing the data should be stored in the output
object. Defaults to <code>FALSE</code> in which case only the list of properly
rescaled QTS is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of properly rescaled QTS stored as an object of class
<code><a href="#topic+qts_sample">qts_sample</a></code> when <code>keep_summary_stats = FALSE</code>. Otherwise a list with
three components:
</p>

<ul>
<li> <p><code>rescaled_sample</code>: a list of properly rescaled QTS stored as an object of
class <code><a href="#topic+qts_sample">qts_sample</a></code>;
</p>
</li>
<li> <p><code>mean</code>: a list of numeric vectors storing the corresponding quaternion
Fréchet means;
</p>
</li>
<li> <p><code>sd</code>: a numeric vector storing the corresponding quaternion Fréchet
standard deviations.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- scale(vespa64$igp)
x[[1]]
</code></pre>

<hr>
<h2 id='smooth'>QTS Smoothing via SLERP Interpolation</h2><span id='topic+smooth'></span><span id='topic+smooth.default'></span><span id='topic+smooth.qts'></span><span id='topic+smooth.qts_sample'></span>

<h3>Description</h3>

<p>This function performs a smoothing of a QTS by SLERP interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth(x, ...)

## Default S3 method:
smooth(
  x,
  kind = c("3RS3R", "3RSS", "3RSR", "3R", "3", "S"),
  twiceit = FALSE,
  endrule = c("Tukey", "copy"),
  do.ends = FALSE,
  ...
)

## S3 method for class 'qts'
smooth(x, alpha = 0.5, ...)

## S3 method for class 'qts_sample'
smooth(x, alpha = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a> or <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
<tr><td><code id="smooth_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on to next methods.</p>
</td></tr>
<tr><td><code id="smooth_+3A_kind">kind</code></td>
<td>
<p>a character string indicating the kind of smoother required;
defaults to <code>"3RS3R"</code>.</p>
</td></tr>
<tr><td><code id="smooth_+3A_twiceit">twiceit</code></td>
<td>
<p>logical, indicating if the result should be &lsquo;twiced&rsquo;.
Twicing a smoother <code class="reqn">S(y)</code> means <code class="reqn">S(y) + S(y - S(y))</code>, i.e.,
adding smoothed residuals to the smoothed values.  This decreases
bias (increasing variance).</p>
</td></tr>
<tr><td><code id="smooth_+3A_endrule">endrule</code></td>
<td>
<p>a character string indicating the rule for smoothing at the
boundary.  Either <code>"Tukey"</code> (default) or <code>"copy"</code>.</p>
</td></tr>
<tr><td><code id="smooth_+3A_do.ends">do.ends</code></td>
<td>
<p>logical, indicating if the 3-splitting of ties should
also happen at the boundaries (ends).  This is only used for
<code>kind = "S"</code>.</p>
</td></tr>
<tr><td><code id="smooth_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> specifying the amount of smoothing.
The closer to one, the smoother the resulting QTS. Defaults to <code>0.5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> which is a
smooth version of the input QTS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smooth(vespa64$igp[[1]])
smooth(vespa64$igp)
</code></pre>

<hr>
<h2 id='straighten'>QTS Straightening</h2><span id='topic+straighten'></span><span id='topic+straighten.qts'></span><span id='topic+straighten.qts_sample'></span>

<h3>Description</h3>

<p>This function straightens QTS so that the last point equals the first point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>straighten(x)

## S3 method for class 'qts'
straighten(x)

## S3 method for class 'qts_sample'
straighten(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="straighten_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+qts">qts</a> or <a href="#topic+qts_sample">qts_sample</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as the input argument <code>x</code> storing the
straightened QTS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>straighten(vespa64$igp[[1]])
straighten(vespa64$igp)
</code></pre>

<hr>
<h2 id='vespa'>The VESPA dataset</h2><span id='topic+vespa'></span>

<h3>Description</h3>

<p>A set of QTS representing individual gait patterns (IGPs) of individuals
collected under a number of varying factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vespa
</code></pre>


<h3>Format</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with 320 rows and 7 columns:
</p>

<ul>
<li> <p><code>V</code>: a categorical variable with two levels specifying the ID of the
<code>Volunteer</code>;
</p>
</li>
<li> <p><code>E</code>: a categorical variable with two levels specifying the ID of the
<code>Experimenter</code>;
</p>
</li>
<li> <p><code>S</code>: a categorical variable with four levels specifying the type of
<code>Sensor</code>;
</p>
</li>
<li> <p><code>P</code>: a categorical variable with four levels specifying the <code>Position</code> of
the sensor;
</p>
</li>
<li> <p><code>A</code>: a categorical variable with two levels specifying the ID of the
<code>Acquisition</code> pathway;
</p>
</li>
<li> <p><code>R</code>: a categorical variable with 5 levels specifying the ID of the
<code>Repetition</code>;
</p>
</li>
<li> <p><code>igp</code>: A 101x5 <code><a href="tibble.html#topic+tibble">tibble</a></code> storing a QTS which
represents the IGP of the individual under a specific set of VESPA
conditions.
</p>
</li></ul>



<h3>Details</h3>

<p>The IGP measures the hip rotation during a typical gait cycle. Each rotation
is expressed with respect to the mean position of the sensor during the gait
cycle. Each IGP is then straightened so that it is periodic with a last point
matching the first one.
</p>

<hr>
<h2 id='vespa64'>The VESPA64 dataset</h2><span id='topic+vespa64'></span>

<h3>Description</h3>

<p>A set of QTS representing individual gait patterns (IGPs) of individuals
collected under a number of varying factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vespa64
</code></pre>


<h3>Format</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with 320 rows and 7 columns:
</p>

<ul>
<li> <p><code>V</code>: a categorical variable with two levels specifying the ID of the
<code>Volunteer</code>;
</p>
</li>
<li> <p><code>E</code>: a categorical variable with two levels specifying the ID of the
<code>Experimenter</code>;
</p>
</li>
<li> <p><code>S</code>: a categorical variable with four levels specifying the type of
<code>Sensor</code>;
</p>
</li>
<li> <p><code>P</code>: a categorical variable with four levels specifying the <code>Position</code> of
the sensor;
</p>
</li>
<li> <p><code>A</code>: a categorical variable with two levels specifying the ID of the
<code>Acquisition</code> pathway;
</p>
</li>
<li> <p><code>igp</code>: A 101x5 <code><a href="tibble.html#topic+tibble">tibble</a></code> storing a QTS which
represents the IGP of the individual under a specific set of VESPA
conditions.
</p>
</li></ul>



<h3>Details</h3>

<p>The IGP measures the hip rotation during a typical gait cycle. Each rotation
is expressed with respect to the mean position of the sensor during the gait
cycle. Each IGP is then straightened so that it is periodic with a last point
matching the first one.
</p>
<p>It is essentially a reduced version of the VESPA data set where IGPs have
been averaged over the repetition for each set of conditions.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
