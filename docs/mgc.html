<!DOCTYPE html><html lang="en"><head><title>Help for package mgc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mgc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ConnCompLabel'><p>Connected Components Labelling &ndash; Unique Patch Labelling</p></a></li>
<li><a href='#discr.mnr'><p>Discriminability Mean Normalized Rank</p></a></li>
<li><a href='#discr.rdf'><p>Reliability Density Function</p></a></li>
<li><a href='#discr.sims.cross'><p>Discriminability Cross Simulation</p></a></li>
<li><a href='#discr.sims.exp'><p>Discriminability Exponential Simulation</p></a></li>
<li><a href='#discr.sims.fat_tails'><p>Discriminability Spread Simulation</p></a></li>
<li><a href='#discr.sims.linear'><p>Discriminability Linear Simulation</p></a></li>
<li><a href='#discr.sims.radial'><p>Discriminability Radial Simulation</p></a></li>
<li><a href='#discr.stat'><p>Discriminability Statistic</p></a></li>
<li><a href='#discr.test.one_sample'><p>Discriminability One Sample Permutation Test</p></a></li>
<li><a href='#discr.test.two_sample'><p>Discriminability Two Sample Permutation Test</p></a></li>
<li><a href='#discr.validator'><p>Discriminability Utility Validator</p></a></li>
<li><a href='#DistCentering'><p>An auxiliary function that properly transforms the distance matrix X</p></a></li>
<li><a href='#DistRanks'><p>An auxiliary function that sorts the entries within each column by ascending order:</p>
For ties, the minimum ranking is used,
e.g. if there are repeating distance entries, the order is like 1,2,3,3,4,..,n-1.</a></li>
<li><a href='#gen.coefs'><p>A helper function to generate a d-dimensional linear transformation matrix.</p></a></li>
<li><a href='#gen.sample.labels'><p>A helper function for simulating sample labels</p></a></li>
<li><a href='#gen.x.unif'><p>A helper function to generate n samples of a d-dimensional uniform vector.</p></a></li>
<li><a href='#LocalCov'><p>An auxiliary function that computes all local correlations simultaneously in O(n^2).</p></a></li>
<li><a href='#mgc.dist.validator'><p>Distance Matrix Validator</p></a></li>
<li><a href='#mgc.dist.xfm'><p>MGC Distance Transform</p></a></li>
<li><a href='#mgc.distance'><p>Distance</p></a></li>
<li><a href='#mgc.ksample'><p>MGC K Sample Testing</p></a></li>
<li><a href='#mgc.localcorr'><p>MGC Local Correlations</p></a></li>
<li><a href='#mgc.localcorr.driver'><p>Driver for MGC Local Correlations</p></a></li>
<li><a href='#mgc.sims.2ball'><p>Sample from Unit 2-Ball</p></a></li>
<li><a href='#mgc.sims.2sphere'><p>Sample from Unit 2-Sphere</p></a></li>
<li><a href='#mgc.sims.cubic'><p>Cubic Simulation</p></a></li>
<li><a href='#mgc.sims.exp'><p>Exponential Simulation</p></a></li>
<li><a href='#mgc.sims.joint'><p>Joint Normal Simulation</p></a></li>
<li><a href='#mgc.sims.linear'><p>Linear Simulation</p></a></li>
<li><a href='#mgc.sims.quad'><p>Quadratic Simulation</p></a></li>
<li><a href='#mgc.sims.random_rotate'><p>Random Rotation</p></a></li>
<li><a href='#mgc.sims.rotation'><p>Sample Random Rotation</p></a></li>
<li><a href='#mgc.sims.sim_gmm'><p>GMM Simulate</p></a></li>
<li><a href='#mgc.sims.spiral'><p>Spiral Simulation</p></a></li>
<li><a href='#mgc.sims.step'><p>Step Function Simulation</p></a></li>
<li><a href='#mgc.sims.ubern'><p>Uncorrelated Bernoulli Simulation</p></a></li>
<li><a href='#mgc.sims.wshape'><p>W Shaped Simulation</p></a></li>
<li><a href='#mgc.stat'><p>MGC Test</p></a></li>
<li><a href='#mgc.stat.driver'><p>MGC Sample Statistic Internal Driver</p></a></li>
<li><a href='#mgc.test'><p>MGC Permutation Test</p></a></li>
<li><a href='#mgc.validator'><p>MGC Utility Validator</p></a></li>
<li><a href='#remove.isolates'><p>Remove Isolates</p></a></li>
<li><a href='#Smoothing'><p>An auxiliary function that finds the smoothed maximal within the significant region R:</p>
If area of R is too small, return the last local corr otherwise take the maximum within R.</a></li>
<li><a href='#Thresholding'><p>An auxiliary function that finds a region of significance in the local correlation map by thresholding.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiscale Graph Correlation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-06-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Bridgeford &lt;ericwb95@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiscale Graph Correlation (MGC) is a framework developed by Vogelstein et al. (2019) &lt;<a href="https://doi.org/10.7554%2FeLife.41690">doi:10.7554/eLife.41690</a>&gt; that extends global correlation procedures to be multiscale; consequently, MGC tests typically require far fewer samples than existing methods for a wide variety of dependence structures and dimensionalities, while maintaining computational efficiency. Moreover, MGC provides a simple and elegant multiscale characterization of the potentially complex latent geometry underlying the relationship.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MASS, abind, boot, energy, raster</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/neurodata/r-mgc">https://github.com/neurodata/r-mgc</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), ggplot2, reshape2, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-22 22:51:13 UTC; eric</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Bridgeford [aut, cre],
  Censheng Shen [aut],
  Shangsi Wang [aut],
  Joshua Vogelstein [ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-23 12:50:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='ConnCompLabel'>Connected Components Labelling &ndash; Unique Patch Labelling</h2><span id='topic+ConnCompLabel'></span>

<h3>Description</h3>

<p><code>ConnCompLabel</code> is a 1 pass implementation of connected components
labelling. Here it is applied to identify disjunt patches within a
distribution. <br /> <br /> The raster matrix can be a raster of class 'asc'
(adehabitat package), 'RasterLayer' (raster package) or
'SpatialGridDataFrame' (sp package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConnCompLabel(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConnCompLabel_+3A_mat">mat</code></td>
<td>
<p>is a binary matrix of data with 0 representing background and 1
representing environment of interest. NA values are acceptable. The matrix
can be a raster of class 'asc' (this &amp; adehabitat package), 'RasterLayer'
(raster package) or 'SpatialGridDataFrame' (sp package)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dim and class of <code>mat</code> in which unique
components (individual patches) are numbered 1:n with 0 remaining background
value.
</p>


<h3>Author(s)</h3>

<p>Jeremy VanDerWal <a href="mailto:jjvanderwal@gmail.com">jjvanderwal@gmail.com</a>
</p>


<h3>References</h3>

<p>Chang, F., C.-J. Chen, and C.-J. Lu. 2004. A linear-time
component-labeling algorithm using contour tracing technique. Comput. Vis.
Image Underst. 93:206-220.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#define a simple binary matrix
tmat = { matrix(c( 0,0,0,1,0,0,1,1,0,1,
                   0,0,1,0,1,0,0,0,0,0,
                   0,1,NA,1,0,1,0,0,0,1,
                   1,0,1,1,1,0,1,0,0,1,
                   0,1,0,1,0,1,0,0,0,1,
                   0,0,1,0,1,0,0,1,1,0,
                   1,0,0,1,0,0,1,0,0,1,
                   0,1,0,0,0,1,0,0,0,1,
                   0,0,1,1,1,0,0,0,0,1,
                   1,1,1,0,0,0,0,0,0,1),nr=10,byrow=TRUE) }

#do the connected component labelling
ccl.mat = ConnCompLabel(tmat)
ccl.mat
image(t(ccl.mat[10:1,]),col=c('grey',rainbow(length(unique(ccl.mat))-1)))


</code></pre>

<hr>
<h2 id='discr.mnr'>Discriminability Mean Normalized Rank</h2><span id='topic+discr.mnr'></span>

<h3>Description</h3>

<p>Discriminability Mean Normalized Rank
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.mnr(rdf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.mnr_+3A_rdf">rdf</code></td>
<td>
<p>the reliability densities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mnr.
</p>

<hr>
<h2 id='discr.rdf'>Reliability Density Function</h2><span id='topic+discr.rdf'></span>

<h3>Description</h3>

<p>A function for computing the reliability density function of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.rdf(X, ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.rdf_+3A_x">X</code></td>
<td>
<p><code>[n, n]</code> a distance matrix for n samples.</p>
</td></tr>
<tr><td><code id="discr.rdf_+3A_ids">ids</code></td>
<td>
<p><code>[n]</code> a vector containing the label ids for each sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>[n]</code> vector of the reliability per sample.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='discr.sims.cross'>Discriminability Cross Simulation</h2><span id='topic+discr.sims.cross'></span>

<h3>Description</h3>

<p>A function to simulate data with the same mean that spreads as class id increases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.sims.cross(
  n,
  d,
  K,
  signal.scale = 10,
  non.scale = 1,
  mean.scale = 0,
  rotate = FALSE,
  class.equal = TRUE,
  ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.sims.cross_+3A_n">n</code></td>
<td>
<p>the number of samples.</p>
</td></tr>
<tr><td><code id="discr.sims.cross_+3A_d">d</code></td>
<td>
<p>the number of dimensions.</p>
</td></tr>
<tr><td><code id="discr.sims.cross_+3A_k">K</code></td>
<td>
<p>the number of classes in the dataset.</p>
</td></tr>
<tr><td><code id="discr.sims.cross_+3A_signal.scale">signal.scale</code></td>
<td>
<p>the scaling for the signal dimension. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.cross_+3A_non.scale">non.scale</code></td>
<td>
<p>the scaling for the non-signal dimensions. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.cross_+3A_mean.scale">mean.scale</code></td>
<td>
<p>whether the magnitude of the difference in the means between the two classes.
If a mean scale is requested, <code>d</code> should be at least &gt; <code>K</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.cross_+3A_rotate">rotate</code></td>
<td>
<p>whether to apply a random rotation. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.cross_+3A_class.equal">class.equal</code></td>
<td>
<p>whether the number of samples/class should be equal, with each
class having a prior of 1/K, or inequal, in which each class obtains a prior
of k/sum(K) for k=1:K. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.cross_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
sim &lt;- discr.sims.cross(100, 3, 2)
</code></pre>

<hr>
<h2 id='discr.sims.exp'>Discriminability Exponential Simulation</h2><span id='topic+discr.sims.exp'></span>

<h3>Description</h3>

<p>A function to simulate multi-class data with an Exponential class-mean trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.sims.exp(
  n,
  d,
  K,
  signal.scale = 1,
  signal.lshift = 1,
  non.scale = 1,
  rotate = FALSE,
  class.equal = TRUE,
  ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.sims.exp_+3A_n">n</code></td>
<td>
<p>the number of samples.</p>
</td></tr>
<tr><td><code id="discr.sims.exp_+3A_d">d</code></td>
<td>
<p>the number of dimensions. The first dimension will be the signal dimension; the remainders noise.</p>
</td></tr>
<tr><td><code id="discr.sims.exp_+3A_k">K</code></td>
<td>
<p>the number of classes in the dataset.</p>
</td></tr>
<tr><td><code id="discr.sims.exp_+3A_signal.scale">signal.scale</code></td>
<td>
<p>the scaling for the signal dimension. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.exp_+3A_signal.lshift">signal.lshift</code></td>
<td>
<p>the location shift for the signal dimension between the classes. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.exp_+3A_non.scale">non.scale</code></td>
<td>
<p>the scaling for the non-signal dimensions. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.exp_+3A_rotate">rotate</code></td>
<td>
<p>whether to apply a random rotation. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.exp_+3A_class.equal">class.equal</code></td>
<td>
<p>whether the number of samples/class should be equal, with each
class having a prior of 1/K, or inequal, in which each class obtains a prior
of k/sum(K) for k=1:K. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.exp_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='discr.sims.fat_tails'>Discriminability Spread Simulation</h2><span id='topic+discr.sims.fat_tails'></span>

<h3>Description</h3>

<p>A function to simulate data with the same mean that spreads as class id increases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.sims.fat_tails(
  n,
  d,
  K,
  signal.scale = 1,
  rotate = FALSE,
  class.equal = TRUE,
  ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.sims.fat_tails_+3A_n">n</code></td>
<td>
<p>the number of samples.</p>
</td></tr>
<tr><td><code id="discr.sims.fat_tails_+3A_d">d</code></td>
<td>
<p>the number of dimensions.</p>
</td></tr>
<tr><td><code id="discr.sims.fat_tails_+3A_k">K</code></td>
<td>
<p>the number of classes in the dataset.</p>
</td></tr>
<tr><td><code id="discr.sims.fat_tails_+3A_signal.scale">signal.scale</code></td>
<td>
<p>the scaling for the signal dimension. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.fat_tails_+3A_rotate">rotate</code></td>
<td>
<p>whether to apply a random rotation. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.fat_tails_+3A_class.equal">class.equal</code></td>
<td>
<p>whether the number of samples/class should be equal, with each
class having a prior of 1/K, or inequal, in which each class obtains a prior
of k/sum(K) for k=1:K. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.fat_tails_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
sim &lt;- discr.sims.fat_tails(100, 3, 2)
</code></pre>

<hr>
<h2 id='discr.sims.linear'>Discriminability Linear Simulation</h2><span id='topic+discr.sims.linear'></span>

<h3>Description</h3>

<p>A function to simulate multi-class data with a linear class-mean trend. The signal dimension is the dimension carrying all of the
between-class difference, and the non-signal dimensions are noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.sims.linear(
  n,
  d,
  K,
  signal.scale = 1,
  signal.lshift = 1,
  non.scale = 1,
  rotate = FALSE,
  class.equal = TRUE,
  ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.sims.linear_+3A_n">n</code></td>
<td>
<p>the number of samples.</p>
</td></tr>
<tr><td><code id="discr.sims.linear_+3A_d">d</code></td>
<td>
<p>the number of dimensions. The first dimension will be the signal dimension; the remainders noise.</p>
</td></tr>
<tr><td><code id="discr.sims.linear_+3A_k">K</code></td>
<td>
<p>the number of classes in the dataset.</p>
</td></tr>
<tr><td><code id="discr.sims.linear_+3A_signal.scale">signal.scale</code></td>
<td>
<p>the scaling for the signal dimension. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.linear_+3A_signal.lshift">signal.lshift</code></td>
<td>
<p>the location shift for the signal dimension between the classes. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.linear_+3A_non.scale">non.scale</code></td>
<td>
<p>the scaling for the non-signal dimensions. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.linear_+3A_rotate">rotate</code></td>
<td>
<p>whether to apply a random rotation. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.linear_+3A_class.equal">class.equal</code></td>
<td>
<p>whether the number of samples/class should be equal, with each
class having a prior of 1/K, or inequal, in which each class obtains a prior
of k/sum(K) for k=1:K. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.linear_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='discr.sims.radial'>Discriminability Radial Simulation</h2><span id='topic+discr.sims.radial'></span>

<h3>Description</h3>

<p>A function to simulate data with the same mean with radial symmetry as class id increases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.sims.radial(
  n,
  d,
  K,
  er.scale = 0.1,
  r = 1,
  class.equal = TRUE,
  ind = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.sims.radial_+3A_n">n</code></td>
<td>
<p>the number of samples.</p>
</td></tr>
<tr><td><code id="discr.sims.radial_+3A_d">d</code></td>
<td>
<p>the number of dimensions.</p>
</td></tr>
<tr><td><code id="discr.sims.radial_+3A_k">K</code></td>
<td>
<p>the number of classes in the dataset.</p>
</td></tr>
<tr><td><code id="discr.sims.radial_+3A_er.scale">er.scale</code></td>
<td>
<p>the scaling for the error of the samples. Defaults to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.radial_+3A_r">r</code></td>
<td>
<p>the radial spacing between each class. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.radial_+3A_class.equal">class.equal</code></td>
<td>
<p>whether the number of samples/class should be equal, with each
class having a prior of 1/K, or inequal, in which each class obtains a prior
of k/sum(K) for k=1:K. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.sims.radial_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
sim &lt;- discr.sims.radial(100, 3, 2)
</code></pre>

<hr>
<h2 id='discr.stat'>Discriminability Statistic</h2><span id='topic+discr.stat'></span>

<h3>Description</h3>

<p>A function for computing the discriminability from a distance matrix and a set of associated labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.stat(
  X,
  Y,
  is.dist = FALSE,
  dist.xfm = mgc.distance,
  dist.params = list(method = "euclidean"),
  dist.return = NULL,
  remove.isolates = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.stat_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a distance matrix. Use flag <code>is.dist=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="discr.stat_+3A_y">Y</code></td>
<td>
<p><code>[n]</code> a vector containing the sample ids for our <code>n</code> samples.</p>
</td></tr>
<tr><td><code id="discr.stat_+3A_is.dist">is.dist</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="discr.stat_+3A_dist.xfm">dist.xfm</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix,
which can be either the default output, an item castable to a distance matrix, or . See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="discr.stat_+3A_dist.params">dist.params</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="discr.stat_+3A_dist.return">dist.return</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be an object castable to a <code>[n x n]</code> matrix.
You can verify whether this is the case by looking at <code>as.matrix(do.call(dist.xfm, list(X, &lt;trailing_args&gt;))</code></p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="discr.stat_+3A_remove.isolates">remove.isolates</code></td>
<td>
<p>remove isolated samples from the dataset. Isolated samples are samples with only
one instance of their class appearing in the <code>Y</code> vector. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table role = "presentation">
<tr><td><code>discr</code></td>
<td>
<p>the discriminability statistic.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>the rdfs for each sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see the help vignette:
<code>vignette("discriminability", package = "mgc")</code>
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>References</h3>

<p>Eric W. Bridgeford, et al. &quot;Optimal Decisions for Reference Pipelines and Datasets: Applications in Connectomics.&quot; Bioarxiv (2019).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- discr.sims.linear(100, 10, K=2)
X &lt;- sim$X; Y &lt;- sim$Y
discr.stat(X, Y)$discr

</code></pre>

<hr>
<h2 id='discr.test.one_sample'>Discriminability One Sample Permutation Test</h2><span id='topic+discr.test.one_sample'></span>

<h3>Description</h3>

<p>A function that performs a one-sample test for whether the discriminability differs from random chance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.test.one_sample(
  X,
  Y,
  is.dist = FALSE,
  dist.xfm = mgc.distance,
  dist.params = list(method = "euclidean"),
  dist.return = NULL,
  remove.isolates = TRUE,
  nperm = 500,
  no_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.test.one_sample_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a distance matrix. Use flag <code>is.dist=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="discr.test.one_sample_+3A_y">Y</code></td>
<td>
<p><code>[n]</code> a vector containing the sample ids for our <code>n</code> samples.</p>
</td></tr>
<tr><td><code id="discr.test.one_sample_+3A_is.dist">is.dist</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="discr.test.one_sample_+3A_dist.xfm">dist.xfm</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="discr.test.one_sample_+3A_dist.params">dist.params</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="discr.test.one_sample_+3A_dist.return">dist.return</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="discr.test.one_sample_+3A_remove.isolates">remove.isolates</code></td>
<td>
<p>remove isolated samples from the dataset. Isolated samples are samples with only
one instance of their class appearing in the <code>Y</code> vector. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.test.one_sample_+3A_nperm">nperm</code></td>
<td>
<p>the number of permutations to perform. Defaults to <code>500</code>.</p>
</td></tr>
<tr><td><code id="discr.test.one_sample_+3A_no_cores">no_cores</code></td>
<td>
<p>the number of cores to use for permutation test. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table role = "presentation">
<tr><td><code>stat</code></td>
<td>
<p>the discriminability of the data.</p>
</td></tr>
<tr><td><code>null</code></td>
<td>
<p>the discriminability scores under the null, computed via permutation.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the pvalue associated with the permutation test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a test of whether an observed discriminability is significantly different from chance, as described in Bridgeford et al. (2019).
With <code class="reqn">\hat D_X</code> the sample discriminability of <code class="reqn">X</code>:
</p>
<p style="text-align: center;"><code class="reqn">H_0: D_X = D_0</code>
</p>
<p> and:</p>
<p style="text-align: center;"><code class="reqn">H_A: D_X &gt; D_0</code>
</p>
<p> where <code class="reqn">D_0</code>
is the discriminability that would be observed by random chance.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>References</h3>

<p>Eric W. Bridgeford, et al. &quot;Optimal Decisions for Reference Pipelines and Datasets: Applications in Connectomics.&quot; Bioarxiv (2019).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(mgc)
n = 100; d=5

# simulation with a large difference between the classes
# meaning they are more discriminable
sim &lt;- discr.sims.linear(n=n, d=d, K=2, signal.lshift=10)
X &lt;- sim$X; Y &lt;- sim$Y

# p-value is small
discr.test.one_sample(X, Y)$p.value

## End(Not run)
</code></pre>

<hr>
<h2 id='discr.test.two_sample'>Discriminability Two Sample Permutation Test</h2><span id='topic+discr.test.two_sample'></span>

<h3>Description</h3>

<p>A function that takes two sets of paired data and tests of whether or not the data is more, less, or non-equally discriminable between the set of paired data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.test.two_sample(
  X1,
  X2,
  Y,
  dist.xfm = mgc.distance,
  dist.params = list(method = "euclidian"),
  dist.return = NULL,
  remove.isolates = TRUE,
  nperm = 500,
  no_cores = 1,
  alt = "greater"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.test.two_sample_+3A_x1">X1</code></td>
<td>
<p>is interpreted as a <code>[n x d]</code> data matrix with <code>n</code> samples in <code>d</code> dimensions. Should NOT be a distance matrix.</p>
</td></tr>
<tr><td><code id="discr.test.two_sample_+3A_x2">X2</code></td>
<td>
<p>is interpreted as a <code>[n x d]</code> data matrix with <code>n</code> samples in <code>d</code> dimensions. Should NOT be a distance matrix.</p>
</td></tr>
<tr><td><code id="discr.test.two_sample_+3A_y">Y</code></td>
<td>
<p><code>[n]</code> a vector containing the sample ids for our <code>n</code> samples. Should be matched such that <code>Y[i]</code> is the corresponding label for <code>X1[i,]</code> and <code>X2[i,]</code>.</p>
</td></tr>
<tr><td><code id="discr.test.two_sample_+3A_dist.xfm">dist.xfm</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="discr.test.two_sample_+3A_dist.params">dist.params</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="discr.test.two_sample_+3A_dist.return">dist.return</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="discr.test.two_sample_+3A_remove.isolates">remove.isolates</code></td>
<td>
<p>remove isolated samples from the dataset. Isolated samples are samples with only
one instance of their class appearing in the <code>Y</code> vector. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="discr.test.two_sample_+3A_nperm">nperm</code></td>
<td>
<p>the number of permutations for permutation test. Defualts to <code>500</code>.</p>
</td></tr>
<tr><td><code id="discr.test.two_sample_+3A_no_cores">no_cores</code></td>
<td>
<p>the number of cores to use for the permutations. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="discr.test.two_sample_+3A_alt">alt</code></td>
<td>
<p>the alternative hypothesis. Can be that first dataset is more discriminable (<code>alt = 'greater'</code>), less discriminable (<code>alt = 'less'</code>),
or just non-equal (<code>alt = 'neq'</code>). Defaults to <code>"greater"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table role = "presentation">
<tr><td><code>stat</code></td>
<td>
<p>the observed test statistic. the test statistic is the difference in discriminability of X1 vs X2.</p>
</td></tr>
<tr><td><code>discr</code></td>
<td>
<p>the discriminabilities for each of the two data sets, as a list.</p>
</td></tr>
<tr><td><code>null</code></td>
<td>
<p>the null distribution of the test statistic, computed via permutation.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value associated with the test.</p>
</td></tr>
<tr><td><code>alt</code></td>
<td>
<p>The alternative hypothesis for the test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function that performs a two-sample test for whether the discriminability is different for that of
one dataset vs another, as described in Bridgeford et al. (2019). With <code class="reqn">\hat D_{X_1}</code> the sample discriminability of one approach, and <code class="reqn">\hat D_{X_2}</code> the sample discriminability of another approach:
</p>
<p style="text-align: center;"><code class="reqn">H_0: D_{X_1} = D_{X_2}</code>
</p>
<p> and:</p>
<p style="text-align: center;"><code class="reqn">H_A: D_{X_1} &gt; D_{X_2}</code>
</p>
<p>.
Also implemented are tests of <code class="reqn">&lt;</code> and <code class="reqn">\neq</code>.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>References</h3>

<p>Eric W. Bridgeford, et al. &quot;Optimal Decisions for Reference Pipelines and Datasets: Applications in Connectomics.&quot; Bioarxiv (2019).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(mgc)
require(MASS)

n = 100; d=5

# generate two subjects truths; true difference btwn
# subject 1 (column 1) and subject 2 (column 2)
mus &lt;- cbind(c(0, 0), c(1, 1))
Sigma &lt;- diag(2)  # dimensions are independent

# first dataset X1 contains less noise than X2
X1 &lt;- do.call(rbind, lapply(1:dim(mus)[2],
  function(k) {mvrnorm(n=50, mus[,k], 0.5*Sigma)}))
X2 &lt;- do.call(rbind, lapply(1:dim(mus)[2],
  function(k) {mvrnorm(n=50, mus[,k], 2*Sigma)}))
Y &lt;- do.call(c, lapply(1:2, function(i) rep(i, 50)))

# X1 should be more discriminable, as less noise
discr.test.two_sample(X1, X2, Y, alt="greater")$p.value  # p-value is small

## End(Not run)
</code></pre>

<hr>
<h2 id='discr.validator'>Discriminability Utility Validator</h2><span id='topic+discr.validator'></span>

<h3>Description</h3>

<p>A script that validates that data inputs are correct, and returns a distance matrix and a ids vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr.validator(
  X,
  Y,
  is.dist = FALSE,
  dist.xfm = mgc.distance,
  dist.params = list(method = "euclidean"),
  dist.return = NULL,
  remove.isolates = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discr.validator_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a distance matrix. Use flag <code>is.dist=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="discr.validator_+3A_y">Y</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>Y is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>Y is a distance matrix. Use flag <code>is.dist=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="discr.validator_+3A_is.dist">is.dist</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="discr.validator_+3A_dist.xfm">dist.xfm</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="discr.validator_+3A_dist.params">dist.params</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="discr.validator_+3A_dist.return">dist.return</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="discr.validator_+3A_remove.isolates">remove.isolates</code></td>
<td>
<p>whether to remove isolated samples, or samples with only a single instance in the <code>Y</code> vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table role = "presentation">
<tr><td><code>DX</code></td>
<td>
<p>The X distance matrix, as a <code>[n x n]</code> matrix.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>The sample ids, with isolates removed.</p>
</td></tr>
</table>

<hr>
<h2 id='DistCentering'>An auxiliary function that properly transforms the distance matrix X</h2><span id='topic+DistCentering'></span>

<h3>Description</h3>

<p>An auxiliary function that properly transforms the distance matrix X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistCentering(X, option, optionRk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DistCentering_+3A_x">X</code></td>
<td>
<p>is a symmetric distance matrix</p>
</td></tr>
<tr><td><code id="DistCentering_+3A_option">option</code></td>
<td>
<p>is a string that specifies which global correlation to build up-on, including 'mgc','dcor','mantel', and 'rank'</p>
</td></tr>
<tr><td><code id="DistCentering_+3A_optionrk">optionRk</code></td>
<td>
<p>is a string that specifies whether ranking within column is computed or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains the following:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>is the centered distance matrices</p>
</td></tr>
<tr><td><code>RX</code></td>
<td>
<p>is the column rank matrices of X.</p>
</td></tr>
</table>

<hr>
<h2 id='DistRanks'>An auxiliary function that sorts the entries within each column by ascending order:
For ties, the minimum ranking is used,
e.g. if there are repeating distance entries, the order is like 1,2,3,3,4,..,n-1.</h2><span id='topic+DistRanks'></span>

<h3>Description</h3>

<p>An auxiliary function that sorts the entries within each column by ascending order:
For ties, the minimum ranking is used,
e.g. if there are repeating distance entries, the order is like 1,2,3,3,4,..,n-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistRanks(dis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DistRanks_+3A_dis">dis</code></td>
<td>
<p>is a symmetric distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>disRank</code> is the column rank matrices of <code>X</code>.
</p>

<hr>
<h2 id='gen.coefs'>A helper function to generate a d-dimensional linear transformation matrix.</h2><span id='topic+gen.coefs'></span>

<h3>Description</h3>

<p>A helper function to generate a d-dimensional linear transformation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.coefs(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.coefs_+3A_d">d</code></td>
<td>
<p>the number of dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>[d]</code> the coefficient vector.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='gen.sample.labels'>A helper function for simulating sample labels</h2><span id='topic+gen.sample.labels'></span>

<h3>Description</h3>

<p>A helper function for simulating sample labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.sample.labels(K, class.equal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.sample.labels_+3A_k">K</code></td>
<td>
<p>the number of classes</p>
</td></tr>
<tr><td><code id="gen.sample.labels_+3A_class.equal">class.equal</code></td>
<td>
<p>whether the number of samples/class should be equal, with each
class having a prior of 1/K, or inequal, in which each class obtains a prior
of k/sum(K) for k=1:K. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='gen.x.unif'>A helper function to generate n samples of a d-dimensional uniform vector.</h2><span id='topic+gen.x.unif'></span>

<h3>Description</h3>

<p>A helper function to generate n samples of a d-dimensional uniform vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.x.unif(n, d, a = -1, b = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.x.unif_+3A_n">n</code></td>
<td>
<p>the number of samples.</p>
</td></tr>
<tr><td><code id="gen.x.unif_+3A_d">d</code></td>
<td>
<p>the number of dimensions.</p>
</td></tr>
<tr><td><code id="gen.x.unif_+3A_a">a</code></td>
<td>
<p>the lower limit.</p>
</td></tr>
<tr><td><code id="gen.x.unif_+3A_b">b</code></td>
<td>
<p>the upper limit.</p>
</td></tr>
<tr><td><code id="gen.x.unif_+3A_x">x</code></td>
<td>
<p><code>[n, d]</code> the simulated data matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='LocalCov'>An auxiliary function that computes all local correlations simultaneously in O(n^2).</h2><span id='topic+LocalCov'></span>

<h3>Description</h3>

<p>An auxiliary function that computes all local correlations simultaneously in O(n^2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocalCov(A, B, RX, RY)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LocalCov_+3A_a">A</code></td>
<td>
<p>is a properly transformed distance matrix</p>
</td></tr>
<tr><td><code id="LocalCov_+3A_b">B</code></td>
<td>
<p>is the second distance matrix properly transformed</p>
</td></tr>
<tr><td><code id="LocalCov_+3A_rx">RX</code></td>
<td>
<p>is the column-ranking matrix of A</p>
</td></tr>
<tr><td><code id="LocalCov_+3A_ry">RY</code></td>
<td>
<p>is the column-ranking matrix of B.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>covXY is all local covariances computed iteratively.
</p>

<hr>
<h2 id='mgc.dist.validator'>Distance Matrix Validator</h2><span id='topic+mgc.dist.validator'></span>

<h3>Description</h3>

<p>A utility to validate a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.dist.validator(
  X,
  is.dist = FALSE,
  dist.xfm = mgc.distance,
  dist.params = list(method = "euclidean"),
  dist.return = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.dist.validator_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a distance matrix. Use flag <code>is.dist=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.dist.validator_+3A_is.dist">is.dist</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.dist.validator_+3A_dist.xfm">dist.xfm</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="mgc.dist.validator_+3A_dist.params">dist.params</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="mgc.dist.validator_+3A_dist.return">dist.return</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='mgc.dist.xfm'>MGC Distance Transform</h2><span id='topic+mgc.dist.xfm'></span>

<h3>Description</h3>

<p>Transform the distance matrices, with column-wise ranking if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.dist.xfm(X, Y, option = "mgc", optionRk = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.dist.xfm_+3A_x">X</code></td>
<td>
<p><code>[nxn]</code> is a distance matrix</p>
</td></tr>
<tr><td><code id="mgc.dist.xfm_+3A_y">Y</code></td>
<td>
<p><code>[nxn]</code> is a second distance matrix</p>
</td></tr>
<tr><td><code id="mgc.dist.xfm_+3A_option">option</code></td>
<td>
<p>is a string that specifies which global correlation to build up-on. Defaults to <code>mgc</code>.
</p>

<dl>
<dt><code>'mgc'</code></dt><dd><p>use the MGC global correlation.</p>
</dd>
<dt><code>'dcor'</code></dt><dd><p>use the dcor global correlation.</p>
</dd>
<dt><code>'mantel'</code></dt><dd><p>use the mantel global correlation.</p>
</dd>
<dt><code>'rank'</code></dt><dd><p>use the rank global correlation.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.dist.xfm_+3A_optionrk">optionRk</code></td>
<td>
<p>is a string that specifies whether ranking within column is computed or not. If <code>option='rank'</code>, ranking will be performed regardless of the value specified by <code>optionRk</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p><code>[nxn]</code> the centered distance matrix for X.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p><code>[nxn]</code> the centered distance matrix for Y.</p>
</td></tr>
<tr><td><code>RX</code></td>
<td>
<p><code>[nxn]</code> the column-rank matrices of X.</p>
</td></tr>
<tr><td><code>RY</code></td>
<td>
<p><code>[nxn]</code> the column-rank matrices of Y.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. Shen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)

n=200; d=2
data &lt;- mgc.sims.linear(n, d)
Dx &lt;- as.matrix(dist(data$X), nrow=n); Dy &lt;- as.matrix(dist(data$Y), nrow=n)
dt &lt;- mgc.dist.xfm(Dx, Dy)

</code></pre>

<hr>
<h2 id='mgc.distance'>Distance</h2><span id='topic+mgc.distance'></span>

<h3>Description</h3>

<p>A function that returns a distance matrix given a collection of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.distance(X, method = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.distance_+3A_x">X</code></td>
<td>
<p><code>[n x d]</code> a data matrix for <code>d</code> samples of <code>d</code> variables.</p>
</td></tr>
<tr><td><code id="mgc.distance_+3A_method">method</code></td>
<td>
<p>the method for computing distances. Defaults to <code>'euclidean'</code>. See <a href="stats.html#topic+dist">dist</a> for details. Also
includes a &quot;ohe&quot; option, which one-hot-encodes the matrix when computing distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>[n x n]</code> distance matrix indicating the pairwise distances between all samples passed in.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='mgc.ksample'>MGC K Sample Testing</h2><span id='topic+mgc.ksample'></span>

<h3>Description</h3>

<p>MGC K Sample Testing provides a wrapper for MGC Sample testing under the constraint that the Ys here are
categorical labels with K possible sample ids. This function uses a 0-1 loss for the Ys (one-hot-encoding)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.ksample(X, Y, mgc.opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.ksample_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist.X=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a distance matrix. Use flag <code>is.dist.X=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.ksample_+3A_y">Y</code></td>
<td>
<p><code>[n]</code> the labels of the samples with <code>K</code> unique labels.</p>
</td></tr>
<tr><td><code id="mgc.ksample_+3A_mgc.opts">mgc.opts</code></td>
<td>
<p>Arguments to pass to MGC, as a named list. See <code><a href="#topic+mgc.test">mgc.test</a></code> for details. Do not pass arguments for
<code>is.dist.Y</code>, <code>dist.xfm.Y</code>, <code>dist.params.Y</code>, nor <code>dist.return.Y</code>, as they will be ignored.</p>
</td></tr>
<tr><td><code id="mgc.ksample_+3A_...">...</code></td>
<td>
<p>trailing args.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table role = "presentation">
<tr><td><code>p.value</code></td>
<td>
<p>P-value of MGC</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>is the sample MGC statistic within <code>[-1,1]</code></p>
</td></tr>
<tr><td><code>pLocalCorr</code></td>
<td>
<p>P-value of the local correlations by double matrix index</p>
</td></tr>
<tr><td><code>localCorr</code></td>
<td>
<p>the local correlations</p>
</td></tr>
<tr><td><code>optimalScale</code></td>
<td>
<p>the optimal scale identified by MGC</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>References</h3>

<p>Youjin Lee, et al. &quot;Network Dependence Testing via Diffusion Maps and Distance-Based Correlations.&quot; ArXiv (2019).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(mgc)
library(MASS)

n = 100; d = 2
# simulate 100 samples, where first 50 have mean [0,0] and second 50 have mean [1,1]
Y &lt;- c(replicate(n/2, 0), replicate(n/2, 1))
X &lt;- do.call(rbind, lapply(Y, function(y) {
    return(rnorm(d) + y)
}))
# p value is small
mgc.ksample(X, Y, mgc.opts=list(nperm=100))$p.value

## End(Not run)
</code></pre>

<hr>
<h2 id='mgc.localcorr'>MGC Local Correlations</h2><span id='topic+mgc.localcorr'></span>

<h3>Description</h3>

<p>Compute all local correlation coefficients in O(n^2 log n)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.localcorr(
  X,
  Y,
  is.dist.X = FALSE,
  dist.xfm.X = mgc.distance,
  dist.params.X = list(method = "euclidean"),
  dist.return.X = NULL,
  is.dist.Y = FALSE,
  dist.xfm.Y = mgc.distance,
  dist.params.Y = list(method = "euclidean"),
  dist.return.Y = NULL,
  option = "mgc"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.localcorr_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist.X=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a distance matrix. Use flag <code>is.dist.X=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_y">Y</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>Y is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist.Y=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>Y is a distance matrix. Use flag <code>is.dist.Y=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_is.dist.x">is.dist.X</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_dist.xfm.x">dist.xfm.X</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_dist.params.x">dist.params.X</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.X</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_dist.return.x">dist.return.X</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.X</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm.X[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_is.dist.y">is.dist.Y</code></td>
<td>
<p>a boolean indicating whether your <code>Y</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_dist.xfm.y">dist.xfm.Y</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>Y</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>dist.return.Y</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_dist.params.y">dist.params.Y</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.Y</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_dist.return.y">dist.return.Y</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.Y</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm.Y(Y)</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm.Y(Y)[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.localcorr_+3A_option">option</code></td>
<td>
<p>is a string that specifies which global correlation to build up-on. Defaults to <code>'mgc'</code>.
</p>

<dl>
<dt>'mgc'</dt><dd><p>use the MGC global correlation.</p>
</dd>
<dt>'dcor'</dt><dd><p>use the dcor global correlation.</p>
</dd>
<dt>'mantel'</dt><dd><p>use the mantel global correlation.</p>
</dd>
<dt>'rank'</dt><dd><p>use the rank global correlation.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains the following:
</p>
<table role = "presentation">
<tr><td><code>corr</code></td>
<td>
<p>consists of all local correlations within [-1,1] by double matrix index</p>
</td></tr>
<tr><td><code>varX</code></td>
<td>
<p>contains all local variances for X.</p>
</td></tr>
<tr><td><code>varY</code></td>
<td>
<p>contains all local variances for X.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. Shen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)

n=200; d=2
data &lt;- mgc.sims.linear(n, d)
lcor &lt;- mgc.localcorr(data$X, data$Y)

</code></pre>

<hr>
<h2 id='mgc.localcorr.driver'>Driver for MGC Local Correlations</h2><span id='topic+mgc.localcorr.driver'></span>

<h3>Description</h3>

<p>Driver for MGC Local Correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.localcorr.driver(DX, DY, option = "mgc")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.localcorr.driver_+3A_dx">DX</code></td>
<td>
<p>the first distance matrix.</p>
</td></tr>
<tr><td><code id="mgc.localcorr.driver_+3A_dy">DY</code></td>
<td>
<p>the second distance matrix.</p>
</td></tr>
<tr><td><code id="mgc.localcorr.driver_+3A_option">option</code></td>
<td>
<p>is a string that specifies which global correlation to build up-on. Defaults to <code>'mgc'</code>.
</p>

<dl>
<dt><code>'mgc'</code></dt><dd><p>use the MGC global correlation.</p>
</dd>
<dt><code>'dcor'</code></dt><dd><p>use the dcor global correlation.</p>
</dd>
<dt><code>'mantel'</code></dt><dd><p>use the mantel global correlation.</p>
</dd>
<dt><code>'rank'</code></dt><dd><p>use the rank global correlation.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains the following:
</p>
<table role = "presentation">
<tr><td><code>corr</code></td>
<td>
<p>consists of all local correlations within [-1,1] by double matrix index</p>
</td></tr>
<tr><td><code>varX</code></td>
<td>
<p>contains all local variances for X.</p>
</td></tr>
<tr><td><code>varY</code></td>
<td>
<p>contains all local variances for X.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. Shen
</p>

<hr>
<h2 id='mgc.sims.2ball'>Sample from Unit 2-Ball</h2><span id='topic+mgc.sims.2ball'></span>

<h3>Description</h3>

<p>Sample from the 2-ball in d-dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.2ball(n, d, r = 1, cov.scale = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.2ball_+3A_n">n</code></td>
<td>
<p>the number of samples.</p>
</td></tr>
<tr><td><code id="mgc.sims.2ball_+3A_d">d</code></td>
<td>
<p>the number of dimensions.</p>
</td></tr>
<tr><td><code id="mgc.sims.2ball_+3A_r">r</code></td>
<td>
<p>the radius of the 2-ball. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.2ball_+3A_cov.scale">cov.scale</code></td>
<td>
<p>if desired, sample from 2-ball with error sigma. Defaults to <code>NaN</code>,
which has no noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the points sampled from the ball, as a <code>[n, d]</code> array.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
# sample 100 points from 3-d 2-ball with radius 2
X &lt;- mgc.sims.2ball(100, 3, 2)
</code></pre>

<hr>
<h2 id='mgc.sims.2sphere'>Sample from Unit 2-Sphere</h2><span id='topic+mgc.sims.2sphere'></span>

<h3>Description</h3>

<p>Sample from the 2-sphere in d-dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.2sphere(n, d, r, cov.scale = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.2sphere_+3A_n">n</code></td>
<td>
<p>the number of samples.</p>
</td></tr>
<tr><td><code id="mgc.sims.2sphere_+3A_d">d</code></td>
<td>
<p>the number of dimensions.</p>
</td></tr>
<tr><td><code id="mgc.sims.2sphere_+3A_r">r</code></td>
<td>
<p>the radius of the 2-ball. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.2sphere_+3A_cov.scale">cov.scale</code></td>
<td>
<p>if desired, sample from 2-ball with error sigma. Defaults to <code>0</code>,
which has no noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the points sampled from the sphere, as a <code>[n, d]</code> array.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
# sample 100 points from 3-d 2-sphere with radius 2
X &lt;- mgc.sims.2sphere(100, 3, 2)
</code></pre>

<hr>
<h2 id='mgc.sims.cubic'>Cubic Simulation</h2><span id='topic+mgc.sims.cubic'></span>

<h3>Description</h3>

<p>A function for Generating a cubic simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.cubic(
  n,
  d,
  eps = 80,
  ind = FALSE,
  a = -1,
  b = 1,
  c.coef = c(-12, 48, 128),
  s = 1/3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.cubic_+3A_n">n</code></td>
<td>
<p>the number of samples for the simulation.</p>
</td></tr>
<tr><td><code id="mgc.sims.cubic_+3A_d">d</code></td>
<td>
<p>the number of dimensions for the simulation setting.</p>
</td></tr>
<tr><td><code id="mgc.sims.cubic_+3A_eps">eps</code></td>
<td>
<p>the noise level for the simulation. Defaults to <code>80</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.cubic_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.cubic_+3A_a">a</code></td>
<td>
<p>the lower limit for the range of the data matrix. Defaults to <code>-1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.cubic_+3A_b">b</code></td>
<td>
<p>the upper limit for the range  of the data matrix. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.cubic_+3A_c.coef">c.coef</code></td>
<td>
<p>the coefficients for the cubic function, where the first value is the first order coefficient, the second value the quadratic coefficient, and the third the cubic coefficient. Defaults to <code>c(-12, 48, 128)</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.cubic_+3A_s">s</code></td>
<td>
<p>the scaling for the center of the cubic. Defaults to <code>1/3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the response array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given: <code class="reqn">w_i = \frac{1}{i}</code> is a weight-vector that scales with the dimensionality.
Simulates <code class="reqn">n</code> points from <code class="reqn">Linear(X, Y) \in  \mathbf{R}^d \times \mathbf{R}</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">X \sim {U}(a, b)^d</code>
</p>

<p style="text-align: center;"><code class="reqn">Y = c_3\left(w^TX - s\right)^3 + c_2\left(w^TX - s\right)^2 + c_1\left(w^TX - s\right) + \kappa \epsilon</code>
</p>

<p>and <code class="reqn">\kappa = 1\textrm{ if }d = 1, \textrm{ and 0 otherwise}</code> controls the noise for higher dimensions.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
result  &lt;- mgc.sims.cubic(n=100, d=10)  # simulate 100 samples in 10 dimensions
X &lt;- result$X; Y &lt;- result$Y
</code></pre>

<hr>
<h2 id='mgc.sims.exp'>Exponential Simulation</h2><span id='topic+mgc.sims.exp'></span>

<h3>Description</h3>

<p>A function for Generating an exponential simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.exp(n, d, eps = 10, ind = FALSE, a = 0, b = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.exp_+3A_n">n</code></td>
<td>
<p>the number of samples for the simulation.</p>
</td></tr>
<tr><td><code id="mgc.sims.exp_+3A_d">d</code></td>
<td>
<p>the number of dimensions for the simulation setting.</p>
</td></tr>
<tr><td><code id="mgc.sims.exp_+3A_eps">eps</code></td>
<td>
<p>the noise level for the simulation. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.exp_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.exp_+3A_a">a</code></td>
<td>
<p>the lower limit for the range of the data matrix. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.exp_+3A_b">b</code></td>
<td>
<p>the upper limit for the range  of the data matrix. Defaults to <code>3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the response array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given: <code class="reqn">w_i = \frac{1}{i}</code> is a weight-vector that scales with the dimensionality.
Simulates <code class="reqn">n</code> points from <code class="reqn">Linear(X, Y) \in  \mathbf{R}^d \times \mathbf{R}</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">X \sim {U}(a, b)^d</code>
</p>

<p style="text-align: center;"><code class="reqn">Y = e^{w^TX} + \kappa \epsilon</code>
</p>

<p>and <code class="reqn">\kappa = 1\textrm{ if }d = 1, \textrm{ and 0 otherwise}</code> controls the noise for higher dimensions.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
result  &lt;- mgc.sims.exp(n=100, d=10)  # simulate 100 samples in 10 dimensions
X &lt;- result$X; Y &lt;- result$Y
</code></pre>

<hr>
<h2 id='mgc.sims.joint'>Joint Normal Simulation</h2><span id='topic+mgc.sims.joint'></span>

<h3>Description</h3>

<p>A function for Generating a joint-normal simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.joint(n, d, eps = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.joint_+3A_n">n</code></td>
<td>
<p>the number of samples for the simulation.</p>
</td></tr>
<tr><td><code id="mgc.sims.joint_+3A_d">d</code></td>
<td>
<p>the number of dimensions for the simulation setting.</p>
</td></tr>
<tr><td><code id="mgc.sims.joint_+3A_eps">eps</code></td>
<td>
<p>the noise level for the simulation. Defaults to <code>0.5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the response array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given: <code class="reqn">\rho = \frac{1}{2}d</code>, <code class="reqn">I_d</code> is the identity matrix of size <code class="reqn">d \times d</code>, <code class="reqn">J_d</code> is the matrix of ones of size <code class="reqn">d \times d</code>.
Simulates <code class="reqn">n</code> points from <code class="reqn">Joint-Normal(X, Y) \in  \mathbf{R}^d \times \mathbf{R}^d</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">(X, Y) \sim {N}(0, \Sigma)</code>
</p>
<p>,
</p>
<p style="text-align: center;"><code class="reqn">\Sigma = \left[I_d, \rho J_d; \rho J_d , (1 + \epsilon\kappa)I_d\right]</code>
</p>

<p>and <code class="reqn">\kappa = 1\textrm{ if }d = 1, \textrm{ and 0 otherwise}</code> controls the noise for higher dimensions.
</p>
<p>For more details see the help vignette:
<code>vignette("sims", package = "mgc")</code>
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
result  &lt;- mgc.sims.joint(n=100, d=10)  # simulate 100 samples in 10 dimensions
X &lt;- result$X; Y &lt;- result$Y
</code></pre>

<hr>
<h2 id='mgc.sims.linear'>Linear Simulation</h2><span id='topic+mgc.sims.linear'></span>

<h3>Description</h3>

<p>A function for Generating a linear simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.linear(n, d, eps = 1, ind = FALSE, a = -1, b = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.linear_+3A_n">n</code></td>
<td>
<p>the number of samples for the simulation.</p>
</td></tr>
<tr><td><code id="mgc.sims.linear_+3A_d">d</code></td>
<td>
<p>the number of dimensions for the simulation setting.</p>
</td></tr>
<tr><td><code id="mgc.sims.linear_+3A_eps">eps</code></td>
<td>
<p>the noise level for the simulation. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.linear_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.linear_+3A_a">a</code></td>
<td>
<p>the lower limit for the range of the data matrix. Defaults to <code>-1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.linear_+3A_b">b</code></td>
<td>
<p>the upper limit for the range  of the data matrix. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the response array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given: <code class="reqn">w_i = \frac{1}{i}</code> is a weight-vector that scales with the dimensionality.
Simulates <code class="reqn">n</code> points from <code class="reqn">Linear(X, Y) \in  \mathbf{R}^d \times \mathbf{R}</code>, where:
</p>
<p style="text-align: center;"><code class="reqn">X \sim {U}(a, b)^d</code>
</p>

<p style="text-align: center;"><code class="reqn">Y = w^TX + \kappa \epsilon</code>
</p>

<p>and <code class="reqn">\kappa = 1\textrm{ if }d = 1, \textrm{ and 0 otherwise}</code> controls the noise for higher dimensions.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
result  &lt;- mgc.sims.linear(n=100, d=10)  # simulate 100 samples in 10 dimensions
X &lt;- result$X; Y &lt;- result$Y
</code></pre>

<hr>
<h2 id='mgc.sims.quad'>Quadratic Simulation</h2><span id='topic+mgc.sims.quad'></span>

<h3>Description</h3>

<p>A function for Generating a quadratic simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.quad(n, d, eps = 0.5, ind = FALSE, a = -1, b = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.quad_+3A_n">n</code></td>
<td>
<p>the number of samples for the simulation.</p>
</td></tr>
<tr><td><code id="mgc.sims.quad_+3A_d">d</code></td>
<td>
<p>the number of dimensions for the simulation setting.</p>
</td></tr>
<tr><td><code id="mgc.sims.quad_+3A_eps">eps</code></td>
<td>
<p>the noise level for the simulation. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.quad_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.quad_+3A_a">a</code></td>
<td>
<p>the lower limit for the data matrix. Defaults to <code>-1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.quad_+3A_b">b</code></td>
<td>
<p>the upper limit for the data matrix. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the response array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given: <code class="reqn">w_i = \frac{1}{i}</code> is a weight-vector that scales with the dimensionality.
Simulates <code>n</code> points from <code class="reqn">Quadratic(X, Y) \in \mathbf{R}^d \times \mathbf{R}</code> where:
</p>
<p style="text-align: center;"><code class="reqn">X \sim {U}(a, b)^d</code>
</p>
<p>,
</p>
<p style="text-align: center;"><code class="reqn">Y = (w^TX)^2 + \kappa\epsilon N(0, 1)</code>
</p>

<p>and <code class="reqn">\kappa = 1\textrm{ if }d = 1, \textrm{ and 0 otherwise}</code> controls the noise for higher dimensions.
</p>
<p>For more details see the help vignette:
<code>vignette("sims", package = "mgc")</code>
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
result  &lt;- mgc.sims.quad(n=100, d=10)  # simulate 100 samples in 10 dimensions
X &lt;- result$X; Y &lt;- result$Y
</code></pre>

<hr>
<h2 id='mgc.sims.random_rotate'>Random Rotation</h2><span id='topic+mgc.sims.random_rotate'></span>

<h3>Description</h3>

<p>A helper function for applying a random rotation to gaussian parameter set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.random_rotate(mus, Sigmas, Q = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.random_rotate_+3A_mus">mus</code></td>
<td>
<p>means per class.</p>
</td></tr>
<tr><td><code id="mgc.sims.random_rotate_+3A_sigmas">Sigmas</code></td>
<td>
<p>covariances per class.</p>
</td></tr>
<tr><td><code id="mgc.sims.random_rotate_+3A_q">Q</code></td>
<td>
<p>rotation to use, if any</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='mgc.sims.rotation'>Sample Random Rotation</h2><span id='topic+mgc.sims.rotation'></span>

<h3>Description</h3>

<p>A helper function for estimating a random rotation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.rotation(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.rotation_+3A_d">d</code></td>
<td>
<p>dimensions to generate a rotation matrix for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the rotation matrix
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='mgc.sims.sim_gmm'>GMM Simulate</h2><span id='topic+mgc.sims.sim_gmm'></span>

<h3>Description</h3>

<p>A helper function for simulating from Gaussian Mixture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.sim_gmm(mus, Sigmas, n, priors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.sim_gmm_+3A_mus">mus</code></td>
<td>
<p><code>[d, K]</code> the mus for each class.</p>
</td></tr>
<tr><td><code id="mgc.sims.sim_gmm_+3A_sigmas">Sigmas</code></td>
<td>
<p><code>[d,d,K]</code> the Sigmas for each class.</p>
</td></tr>
<tr><td><code id="mgc.sims.sim_gmm_+3A_n">n</code></td>
<td>
<p>the number of examples.</p>
</td></tr>
<tr><td><code id="mgc.sims.sim_gmm_+3A_priors">priors</code></td>
<td>
<p><code>K</code> the priors for each class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the simulated data.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the labels for each data point.</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p><code>[K]</code> the priors for each class.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='mgc.sims.spiral'>Spiral Simulation</h2><span id='topic+mgc.sims.spiral'></span>

<h3>Description</h3>

<p>A function for Generating a spiral simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.spiral(n, d, eps = 0.4, a = 0, b = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.spiral_+3A_n">n</code></td>
<td>
<p>the number of samples for the simulation.</p>
</td></tr>
<tr><td><code id="mgc.sims.spiral_+3A_d">d</code></td>
<td>
<p>the number of dimensions for the simulation setting.</p>
</td></tr>
<tr><td><code id="mgc.sims.spiral_+3A_eps">eps</code></td>
<td>
<p>the noise level for the simulation. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.spiral_+3A_a">a</code></td>
<td>
<p>the lower limit for the data matrix. Defaults <code>-1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.spiral_+3A_b">b</code></td>
<td>
<p>the upper limit for the data matrix. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the response array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given: <code class="reqn">U \sim U(a, b)</code> a random variable.
Simumlates <code class="reqn">n</code> points from <code class="reqn">Spiral(X, Y) \in \mathbf{R}^d \times \mathbf{R}</code> where:
<code class="reqn">X_i = U\, \textrm{cos}(\pi\, U)^d</code> if <code>i = d</code>, and <code class="reqn">U\, \textrm{sin}(\pi U)\textrm{cos}^i(\pi U)</code> otherwise
</p>
<p style="text-align: center;"><code class="reqn">Y = U\, \textrm{sin}(\pi\, U) + \epsilon p N(0, 1)</code>
</p>

<p>For more details see the help vignette:
<code>vignette("sims", package = "mgc")</code>
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
result  &lt;- mgc.sims.spiral(n=100, d=10)  # simulate 100 samples in 10 dimensions
X &lt;- result$X; Y &lt;- result$Y
</code></pre>

<hr>
<h2 id='mgc.sims.step'>Step Function Simulation</h2><span id='topic+mgc.sims.step'></span>

<h3>Description</h3>

<p>A function for Generating a step function simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.step(n, d, eps = 1, ind = FALSE, a = -1, b = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.step_+3A_n">n</code></td>
<td>
<p>the number of samples for the simulation.</p>
</td></tr>
<tr><td><code id="mgc.sims.step_+3A_d">d</code></td>
<td>
<p>the number of dimensions for the simulation setting.</p>
</td></tr>
<tr><td><code id="mgc.sims.step_+3A_eps">eps</code></td>
<td>
<p>the noise level for the simulation. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.step_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.step_+3A_a">a</code></td>
<td>
<p>the lower limit for the data matrix. Defaults to <code>-1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.step_+3A_b">b</code></td>
<td>
<p>the upper limit for the data matrix. Defaults to <code>-1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the response array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given: <code class="reqn">w_i = \frac{1}{i}</code> is a weight-vector that scales with the dimensionality.
Simulates <code class="reqn">n</code> points from <code class="reqn">Step(X, Y) \in \mathbf{R}^d\times \mathbf{R}</code> where:
</p>
<p style="text-align: center;"><code class="reqn">X \sim {U}\left(a, b\right)^d</code>
</p>
<p>,
</p>
<p style="text-align: center;"><code class="reqn">Y = \mathbf{I}\left\{w^TX &gt; 0\right\} + \kappa \epsilon N(0, 1)</code>
</p>

<p>and <code class="reqn">\kappa = 1\textrm{ if }d = 1, \textrm{ and 0 otherwise}</code> controls the noise for higher dimensions.
</p>
<p>For more details see the help vignette:
<code>vignette("sims", package = "mgc")</code>
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
result  &lt;- mgc.sims.step(n=100, d=10)  # simulate 100 samples in 10 dimensions
X &lt;- result$X; Y &lt;- result$Y
</code></pre>

<hr>
<h2 id='mgc.sims.ubern'>Uncorrelated Bernoulli Simulation</h2><span id='topic+mgc.sims.ubern'></span>

<h3>Description</h3>

<p>A function for Generating an uncorrelated bernoulli simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.ubern(n, d, eps = 0.5, p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.ubern_+3A_n">n</code></td>
<td>
<p>the number of samples for the simulation.</p>
</td></tr>
<tr><td><code id="mgc.sims.ubern_+3A_d">d</code></td>
<td>
<p>the number of dimensions for the simulation setting.</p>
</td></tr>
<tr><td><code id="mgc.sims.ubern_+3A_eps">eps</code></td>
<td>
<p>the noise level for the simulation. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.ubern_+3A_p">p</code></td>
<td>
<p>the bernoulli probability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the response array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given: <code class="reqn">w_i = \frac{1}{i}</code> is a weight-vector that scales with the dimensionality.
Simumlates <code class="reqn">n</code> points from <code class="reqn">Wshape(X, Y) \in \mathbf{R}^d \times \mathbf{R}</code> where:
</p>
<p style="text-align: center;"><code class="reqn">U \sim Bern(p)</code>
</p>

<p style="text-align: center;"><code class="reqn">X \sim Bern\left(p\right)^d + \epsilon N(0, I_d)</code>
</p>

<p style="text-align: center;"><code class="reqn">Y = (2U - 1)w^TX + \epsilon N(0, 1)</code>
</p>

<p>For more details see the help vignette:
<code>vignette("sims", package = "mgc")</code>
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
result  &lt;- mgc.sims.ubern(n=100, d=10)  # simulate 100 samples in 10 dimensions
X &lt;- result$X; Y &lt;- result$Y
</code></pre>

<hr>
<h2 id='mgc.sims.wshape'>W Shaped Simulation</h2><span id='topic+mgc.sims.wshape'></span>

<h3>Description</h3>

<p>A function for Generating a W-shaped simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.sims.wshape(n, d, eps = 0.5, ind = FALSE, a = -1, b = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.sims.wshape_+3A_n">n</code></td>
<td>
<p>the number of samples for the simulation.</p>
</td></tr>
<tr><td><code id="mgc.sims.wshape_+3A_d">d</code></td>
<td>
<p>the number of dimensions for the simulation setting.</p>
</td></tr>
<tr><td><code id="mgc.sims.wshape_+3A_eps">eps</code></td>
<td>
<p>the noise level for the simulation. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.wshape_+3A_ind">ind</code></td>
<td>
<p>whether to sample x and y independently. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.wshape_+3A_a">a</code></td>
<td>
<p>the lower limit for the data matrix. Defaults <code>-1</code>.</p>
</td></tr>
<tr><td><code id="mgc.sims.wshape_+3A_b">b</code></td>
<td>
<p>the upper limit for the data matrix. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p><code>[n, d]</code> the data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>[n]</code> the response array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given: <code class="reqn">w_i = \frac{1}{i}</code> is a weight-vector that scales with the dimensionality.
Simumlates <code class="reqn">n</code> points from <code class="reqn">W-shape(X, Y) \in \mathbf{R}^d \times \mathbf{R}</code> where:
</p>
<p style="text-align: center;"><code class="reqn">U \sim {U}(a, b)^d</code>
</p>
<p>,
</p>
<p style="text-align: center;"><code class="reqn">X \sim {U}(a, b)^d</code>
</p>
<p>,
</p>
<p style="text-align: center;"><code class="reqn">Y = \left[\left((w^TX)^2 - \frac{1}{2}\right)^2 + \frac{w^TU}{500}\right] + \kappa \epsilon N(0, 1)</code>
</p>

<p>and <code class="reqn">\kappa = 1\textrm{ if }d = 1, \textrm{ and 0 otherwise}</code> controls the noise for higher dimensions.
</p>
<p>For more details see the help vignette:
<code>vignette("sims", package = "mgc")</code>
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)
result  &lt;- mgc.sims.wshape(n=100, d=10)  # simulate 100 samples in 10 dimensions
X &lt;- result$X; Y &lt;- result$Y
</code></pre>

<hr>
<h2 id='mgc.stat'>MGC Test</h2><span id='topic+mgc.stat'></span>

<h3>Description</h3>

<p>The main function that computes the MGC measure between two datasets:
It first computes all local correlations, then use the maximal statistic
among all local correlations based on thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.stat(
  X,
  Y,
  is.dist.X = FALSE,
  dist.xfm.X = mgc.distance,
  dist.params.X = list(method = "euclidean"),
  dist.return.X = NULL,
  is.dist.Y = FALSE,
  dist.xfm.Y = mgc.distance,
  dist.params.Y = list(method = "euclidean"),
  dist.return.Y = NULL,
  option = "mgc"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.stat_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist.X=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a distance matrix. Use flag <code>is.dist.X=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.stat_+3A_y">Y</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>Y is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist.Y=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>Y is a distance matrix. Use flag <code>is.dist.Y=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.stat_+3A_is.dist.x">is.dist.X</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.stat_+3A_dist.xfm.x">dist.xfm.X</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="mgc.stat_+3A_dist.params.x">dist.params.X</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.X</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="mgc.stat_+3A_dist.return.x">dist.return.X</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.X</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm.X[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.stat_+3A_is.dist.y">is.dist.Y</code></td>
<td>
<p>a boolean indicating whether your <code>Y</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.stat_+3A_dist.xfm.y">dist.xfm.Y</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>Y</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>dist.return.Y</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="mgc.stat_+3A_dist.params.y">dist.params.Y</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.Y</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="mgc.stat_+3A_dist.return.y">dist.return.Y</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.Y</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm.Y(Y)</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm.Y(Y)[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.stat_+3A_option">option</code></td>
<td>
<p>is a string that specifies which global correlation to build up-on. Defaults to <code>'mgc'</code>.
</p>

<dl>
<dt><code>'mgc'</code></dt><dd><p>use the MGC global correlation.</p>
</dd>
<dt><code>'dcor'</code></dt><dd><p>use the dcor global correlation.</p>
</dd>
<dt><code>'mantel'</code></dt><dd><p>use the mantel global correlation.</p>
</dd>
<dt><code>'rank'</code></dt><dd><p>use the rank global correlation.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table role = "presentation">
<tr><td><code>stat</code></td>
<td>
<p>is the sample MGC statistic within <code>[-1,1]</code></p>
</td></tr>
<tr><td><code>localCorr</code></td>
<td>
<p>the local correlations</p>
</td></tr>
<tr><td><code>optimalScale</code></td>
<td>
<p>the optimal scale identified by MGC</p>
</td></tr>
<tr><td><code>option</code></td>
<td>
<p>specifies which global correlation was used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. Shen and Eric Bridgeford
</p>


<h3>References</h3>

<p>Joshua T. Vogelstein, et al. &quot;Discovering and deciphering relationships across disparate data modalities.&quot; eLife (2019).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgc)

n=200; d=2
data &lt;- mgc.sims.linear(n, d)
mgc.stat.res &lt;- mgc.stat(data$X, data$Y)

</code></pre>

<hr>
<h2 id='mgc.stat.driver'>MGC Sample Statistic Internal Driver</h2><span id='topic+mgc.stat.driver'></span>

<h3>Description</h3>

<p>MGC Sample Statistic Internal Driver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.stat.driver(DX, DY, option = "mgc")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.stat.driver_+3A_dx">DX</code></td>
<td>
<p>the first distance matrix.</p>
</td></tr>
<tr><td><code id="mgc.stat.driver_+3A_dy">DY</code></td>
<td>
<p>the second distance matrix.</p>
</td></tr>
<tr><td><code id="mgc.stat.driver_+3A_option">option</code></td>
<td>
<p>is a string that specifies which global correlation to build up-on. Defaults to <code>'mgc'</code>.
</p>

<dl>
<dt><code>'mgc'</code></dt><dd><p>use the MGC global correlation.</p>
</dd>
<dt><code>'dcor'</code></dt><dd><p>use the dcor global correlation.</p>
</dd>
<dt><code>'mantel'</code></dt><dd><p>use the mantel global correlation.</p>
</dd>
<dt><code>'rank'</code></dt><dd><p>use the rank global correlation.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='mgc.test'>MGC Permutation Test</h2><span id='topic+mgc.test'></span>

<h3>Description</h3>

<p>Test of Dependence using MGC Approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.test(
  X,
  Y,
  is.dist.X = FALSE,
  dist.xfm.X = mgc.distance,
  dist.params.X = list(method = "euclidean"),
  dist.return.X = NULL,
  is.dist.Y = FALSE,
  dist.xfm.Y = mgc.distance,
  dist.params.Y = list(method = "euclidean"),
  dist.return.Y = NULL,
  nperm = 1000,
  option = "mgc",
  no_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.test_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist.X=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a distance matrix. Use flag <code>is.dist.X=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.test_+3A_y">Y</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>Y is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist.Y=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>Y is a distance matrix. Use flag <code>is.dist.Y=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.test_+3A_is.dist.x">is.dist.X</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.test_+3A_dist.xfm.x">dist.xfm.X</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="mgc.test_+3A_dist.params.x">dist.params.X</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.X</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="mgc.test_+3A_dist.return.x">dist.return.X</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.X</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm.X[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.test_+3A_is.dist.y">is.dist.Y</code></td>
<td>
<p>a boolean indicating whether your <code>Y</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.test_+3A_dist.xfm.y">dist.xfm.Y</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>Y</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>dist.return.Y</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="mgc.test_+3A_dist.params.y">dist.params.Y</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.Y</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="mgc.test_+3A_dist.return.y">dist.return.Y</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.Y</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm.Y(Y)</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm.Y(Y)[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.test_+3A_nperm">nperm</code></td>
<td>
<p>specifies the number of replicates to use for the permutation test. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="mgc.test_+3A_option">option</code></td>
<td>
<p>is a string that specifies which global correlation to build up-on. Defaults to <code>'mgc'</code>.
</p>

<dl>
<dt><code>'mgc'</code></dt><dd><p>use the MGC global correlation.</p>
</dd>
<dt><code>'dcor'</code></dt><dd><p>use the dcor global correlation.</p>
</dd>
<dt><code>'mantel'</code></dt><dd><p>use the mantel global correlation.</p>
</dd>
<dt><code>'rank'</code></dt><dd><p>use the rank global correlation.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.test_+3A_no_cores">no_cores</code></td>
<td>
<p>the number of cores to use for the permutations. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table role = "presentation">
<tr><td><code>p.value</code></td>
<td>
<p>P-value of MGC</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>is the sample MGC statistic within <code>[-1,1]</code></p>
</td></tr>
<tr><td><code>p.localCorr</code></td>
<td>
<p>P-value of the local correlations by double matrix index.</p>
</td></tr>
<tr><td><code>localCorr</code></td>
<td>
<p>the local correlations</p>
</td></tr>
<tr><td><code>optimalScale</code></td>
<td>
<p>the optimal scale identified by MGC</p>
</td></tr>
<tr><td><code>option</code></td>
<td>
<p>specifies which global correlation was used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A test of independence using the MGC approach, described in Vogelstein et al. (2019). For <code class="reqn">X \sim F_X</code>, <code class="reqn">Y \sim F_Y</code>:
</p>
<p style="text-align: center;"><code class="reqn">H_0: F_X \neq F_Y</code>
</p>
<p> and: </p>
<p style="text-align: center;"><code class="reqn">H_A: F_X = F_Y</code>
</p>

<p>Note that one should avoid report positive discovery via minimizing individual p-values of local correlations,
unless corrected for multiple hypotheses.
</p>
<p>For details on usage see the help vignette:
<code>vignette("mgc", package = "mgc")</code>
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford and C. Shen
</p>


<h3>References</h3>

<p>Joshua T. Vogelstein, et al. &quot;Discovering and deciphering relationships across disparate data modalities.&quot; eLife (2019).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(mgc)

n = 100; d = 2
data &lt;- mgc.sims.linear(n, d)
# note: on real data, one would put nperm much higher (at least 100)
# nperm is set to 10 merely for demonstration purposes
result &lt;- mgc.test(data$X, data$Y, nperm=10)

## End(Not run)
</code></pre>

<hr>
<h2 id='mgc.validator'>MGC Utility Validator</h2><span id='topic+mgc.validator'></span>

<h3>Description</h3>

<p>A script that validates that data inputs are correct, and returns a X distance and Y distance matrix for MGC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgc.validator(
  X,
  Y,
  is.dist.X = FALSE,
  dist.xfm.X = mgc.distance,
  dist.params.X = list(method = "euclidean"),
  dist.return.X = NULL,
  is.dist.Y = FALSE,
  dist.xfm.Y = mgc.distance,
  dist.params.Y = list(method = "euclidean"),
  dist.return.Y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgc.validator_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions, if flag <code>is.dist=FALSE</code>.</p>
</dd>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a distance matrix. Use flag <code>is.dist=TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.validator_+3A_y">Y</code></td>
<td>
<p><code>[n]</code> a vector containing the sample ids for our <code>n</code> samples.</p>
</td></tr>
<tr><td><code id="mgc.validator_+3A_is.dist.x">is.dist.X</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.validator_+3A_dist.xfm.x">dist.xfm.X</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>X</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>$D</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="mgc.validator_+3A_dist.params.x">dist.params.X</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.X</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="mgc.validator_+3A_dist.return.x">dist.return.X</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.X</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm.X[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgc.validator_+3A_is.dist.y">is.dist.Y</code></td>
<td>
<p>a boolean indicating whether your <code>Y</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mgc.validator_+3A_dist.xfm.y">dist.xfm.Y</code></td>
<td>
<p>if <code>is.dist == FALSE</code>, a distance function to transform <code>Y</code>. If a distance function is passed,
it should accept an <code>[n x d]</code> matrix of <code>n</code> samples in <code>d</code> dimensions and return a <code>[n x n]</code> distance matrix
as the <code>dist.return.Y</code> return argument. See <a href="#topic+mgc.distance">mgc.distance</a> for details.</p>
</td></tr>
<tr><td><code id="mgc.validator_+3A_dist.params.y">dist.params.Y</code></td>
<td>
<p>a list of trailing arguments to pass to the distance function specified in <code>dist.xfm.Y</code>.
Defaults to <code>list(method='euclidean')</code>.</p>
</td></tr>
<tr><td><code id="mgc.validator_+3A_dist.return.y">dist.return.Y</code></td>
<td>
<p>the return argument for the specified <code>dist.xfm.Y</code> containing the distance matrix. Defaults to <code>FALSE</code>.
</p>

<dl>
<dt><code>is.null(dist.return)</code></dt><dd><p>use the return argument directly from <code>dist.xfm.Y(Y)</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
<dt><code>is.character(dist.return) | is.integer(dist.return)</code></dt><dd><p>use <code>dist.xfm.Y(Y)[[dist.return]]</code> as the distance matrix. Should be a <code>[n x n]</code> matrix.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<table role = "presentation">
<tr><td><code>D</code></td>
<td>
<p>The distance matrix, as a <code>[n x n]</code> matrix.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>the sample ids, as a <code>[n]</code> vector.</p>
</td></tr>
</table>

<hr>
<h2 id='remove.isolates'>Remove Isolates</h2><span id='topic+remove.isolates'></span>

<h3>Description</h3>

<p>A function to remove isolates from a dataset, given a data matrix or a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.isolates(X, Y, is.dist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove.isolates_+3A_x">X</code></td>
<td>
<p>is interpreted as:
</p>

<dl>
<dt>a <code>[n x n]</code> distance matrix</dt><dd><p>X is a square matrix with zeros on diagonal for <code>n</code> samples.</p>
</dd>
<dt>a <code>[n x d]</code> data matrix</dt><dd><p>X is a data matrix with <code>n</code> samples in <code>d</code> dimensions.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="remove.isolates_+3A_y">Y</code></td>
<td>
<p><code>[n]</code> a vector containing the sample ids for our <code>n</code> samples.</p>
</td></tr>
<tr><td><code id="remove.isolates_+3A_is.dist">is.dist</code></td>
<td>
<p>a boolean indicating whether your <code>X</code> input is a distance matrix or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Bridgeford
</p>

<hr>
<h2 id='Smoothing'>An auxiliary function that finds the smoothed maximal within the significant region R:
If area of R is too small, return the last local corr otherwise take the maximum within R.</h2><span id='topic+Smoothing'></span>

<h3>Description</h3>

<p>An auxiliary function that finds the smoothed maximal within the significant region R:
If area of R is too small, return the last local corr otherwise take the maximum within R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Smoothing(localCorr, m, n, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Smoothing_+3A_localcorr">localCorr</code></td>
<td>
<p>is all local correlations</p>
</td></tr>
<tr><td><code id="Smoothing_+3A_m">m</code></td>
<td>
<p>is the number of rows of localCorr</p>
</td></tr>
<tr><td><code id="Smoothing_+3A_n">n</code></td>
<td>
<p>is the number of columns of localCorr</p>
</td></tr>
<tr><td><code id="Smoothing_+3A_r">R</code></td>
<td>
<p>is a binary matrix of size m by n indicating the significant region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains the following:
</p>
<table role = "presentation">
<tr><td><code>stat</code></td>
<td>
<p>is the sample MGC statistic within <code>[-1,1]</code></p>
</td></tr>
<tr><td><code>optimalScale</code></td>
<td>
<p>the estimated optimal scale as a list.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>C. Shen
</p>

<hr>
<h2 id='Thresholding'>An auxiliary function that finds a region of significance in the local correlation map by thresholding.</h2><span id='topic+Thresholding'></span>

<h3>Description</h3>

<p>An auxiliary function that finds a region of significance in the local correlation map by thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Thresholding(localCorr, m, n, sz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Thresholding_+3A_localcorr">localCorr</code></td>
<td>
<p>is all local correlations</p>
</td></tr>
<tr><td><code id="Thresholding_+3A_m">m</code></td>
<td>
<p>is the number of rows of localCorr</p>
</td></tr>
<tr><td><code id="Thresholding_+3A_n">n</code></td>
<td>
<p>is the number of columns of localCorr</p>
</td></tr>
<tr><td><code id="Thresholding_+3A_sz">sz</code></td>
<td>
<p>is the sample size of original data (which may not equal m or n in case of repeating data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R is a binary matrix of size m and n, with 1's indicating the significant region.
</p>


<h3>Author(s)</h3>

<p>Eric Bridgeford and C. Shen
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
