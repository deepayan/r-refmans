<!DOCTYPE html><html><head><title>Help for package wactor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wactor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_wactor'><p>As wactor</p></a></li>
<li><a href='#dtm'><p>Document term frequency</p></a></li>
<li><a href='#split_test_train'><p>Split into test and train data sets</p></a></li>
<li><a href='#tfidf'><p>Term frequency inverse document frequency</p></a></li>
<li><a href='#wactor'><p>Create wactor</p></a></li>
<li><a href='#Wactr'><p>A wactor object</p></a></li>
<li><a href='#xgb_mat'><p>xgb matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Word Factor Vectors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A user-friendly factor-like interface for converting strings of
    text into numeric vectors and rectangular data structures.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>xgboost, tokenizers, text2vec, R6, utils, tibble, ggplot2,
stats, Matrix</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mkearney/wactor">https://github.com/mkearney/wactor</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mkearney/wactor/issues">https://github.com/mkearney/wactor/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-13 05:40:20 UTC; kmw</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael W. Kearney
    <a href="https://orcid.org/0000-0002-0730-4694"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Lingshu Hu <a href="https://orcid.org/0000-0003-0304-882X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael W. Kearney &lt;kearneymw@missouri.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-18 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_wactor'>As wactor</h2><span id='topic+as_wactor'></span>

<h3>Description</h3>

<p>Convert data into object of type 'wactor'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_wactor(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_wactor_+3A_.x">.x</code></td>
<td>
<p>Input text vector</p>
</td></tr>
<tr><td><code id="as_wactor_+3A_...">...</code></td>
<td>
<p>Other args passed to Wactr$new(...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type wactor
</p>

<hr>
<h2 id='dtm'>Document term frequency</h2><span id='topic+dtm'></span>

<h3>Description</h3>

<p>Converts character vector into document term matrix (dtm)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtm(object, .x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtm_+3A_object">object</code></td>
<td>
<p>Input object containing dictionary (column), e.g., wactor</p>
</td></tr>
<tr><td><code id="dtm_+3A_.x">.x</code></td>
<td>
<p>Text from which the document term matrix will be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A c-style matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create wactor
w &lt;- wactor(letters)

## use wactor to create dtm of same vector
dtm(w, letters)

## using the initial data is the default; so you don't actually have to
## respecify it
dtm(w)

## use wactor to create dtm on new vector
dtm(w, c("a", "e", "i", "o", "u"))

## apply directly to character vector
dtm(letters)

</code></pre>

<hr>
<h2 id='split_test_train'>Split into test and train data sets</h2><span id='topic+split_test_train'></span>

<h3>Description</h3>

<p>Randomly partition input into a list of <code>train</code> and <code>test</code> data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_test_train(.data, .p = 0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_test_train_+3A_.data">.data</code></td>
<td>
<p>Input data. If atomic (numeric, integer, character, etc.), the
input is first converted to a data frame with a column  name of &quot;x.&quot;</p>
</td></tr>
<tr><td><code id="split_test_train_+3A_.p">.p</code></td>
<td>
<p>Proportion of data that should be used for the <code>train</code> data set
output. The default value is 0.80, meaning the <code>train</code> output will include
roughly 80 pct. of the input cases while the <code>test</code> output will include roughly
20 oct..</p>
</td></tr>
<tr><td><code id="split_test_train_+3A_...">...</code></td>
<td>
<p>Optional. The response (outcome) variable. Uses tidy evaluation
(quotes are not necessary). This is only relevant if the identified
variable is categorical–i.e., character, factor, logical–in which case it
is used to ensure a uniform distribution for the <code>train</code> output data set.
If a value is supplied, uniformity in response level observations is
prioritized over the <code>.p</code> (train proportion) value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>train</code> and <code>test</code> tibbles (data.frames)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example data frame
d &lt;- data.frame(
  x = rnorm(100),
  y = rnorm(100),
  z = c(rep("a", 80), rep("b", 20))
)

## split using defaults
split_test_train(d)

## split 0.60/0.40
split_test_train(d, 0.60)

## split with equal response level obs
split_test_train(d, 0.80, label = z)

## apply to atomic data
split_test_train(letters)

</code></pre>

<hr>
<h2 id='tfidf'>Term frequency inverse document frequency</h2><span id='topic+tfidf'></span>

<h3>Description</h3>

<p>Converts character vector into a term frequency inverse document frequency
(TFIDF) matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfidf(object, .x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfidf_+3A_object">object</code></td>
<td>
<p>Input object containing dictionary (column), e.g., wactor</p>
</td></tr>
<tr><td><code id="tfidf_+3A_.x">.x</code></td>
<td>
<p>Text from which the tfidf matrix will be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A c-style matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create wactor
w &lt;- wactor(letters)

## use wactor to create tfidf of same vector
tfidf(w, letters)

## using the initial data is the default; so you don't actually have to
## respecify it
tfidf(w)

## use wactor to create tfidf on new vector
tfidf(w, c("a", "e", "i", "o", "u"))

## apply directly to character vector
tfidf(letters)

</code></pre>

<hr>
<h2 id='wactor'>Create wactor</h2><span id='topic+wactor'></span>

<h3>Description</h3>

<p>Create an object of type 'wactor'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wactor(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wactor_+3A_.x">.x</code></td>
<td>
<p>Input text vector</p>
</td></tr>
<tr><td><code id="wactor_+3A_...">...</code></td>
<td>
<p>Other args passed to Wactr$new(...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type wactor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create
w &lt;- wactor(c("a", "a", "a", "b", "b", "c"))

## summarize
summary(w)

## plot
plot(w)

## predict
predict(w)

## use on NEW data
dtm(w, letters[1:5])

## dtm() is the same as predict()
predict(w, letters[1:5])

## works if you specify 'newdata' too
predict(w, newdata = letters[1:5])

</code></pre>

<hr>
<h2 id='Wactr'>A wactor object</h2><span id='topic+Wactr'></span>

<h3>Description</h3>

<p>A factor-like class for word vectors
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>Wactr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Wactr$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>


<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Wactr$new(
  text = character(),
  tokenizer = NULL,
  max_words = 1000,
  doc_prop_max = 1,
  doc_prop_min = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_words</code></dt><dd><p>Maximum number of words in vocabulary</p>
</dd>
<dt><code>doc_prop_max</code></dt><dd><p>Maximum proportion of docs for terms in dinctionary</p>
</dd>
<dt><code>doc_prop_min</code></dt><dd><p>Minimum proportion of docs for terms in dictionary.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clone"></a>


<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Wactr$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='xgb_mat'>xgb matrix</h2><span id='topic+xgb_mat'></span>

<h3>Description</h3>

<p>Simple wrapper for creating a xgboost matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgb_mat(x, ..., y = NULL, split = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xgb_mat_+3A_x">x</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code id="xgb_mat_+3A_...">...</code></td>
<td>
<p>Other data to cbind</p>
</td></tr>
<tr><td><code id="xgb_mat_+3A_y">y</code></td>
<td>
<p>Label vector</p>
</td></tr>
<tr><td><code id="xgb_mat_+3A_split">split</code></td>
<td>
<p>Optional number between 0-1 indicating the desired split between
train and test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A xgb.Dmatrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xgb_mat(data.frame(x = rnorm(20), y = rnorm(20)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
