<!DOCTYPE html><html><head><title>Help for package crch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CensoredLogistic'><p>Create a Censored Logistic Distribution</p></a></li>
<li><a href='#CensoredNormal'><p>Create a Censored Normal Distribution</p></a></li>
<li><a href='#CensoredStudentsT'><p>Create a Censored Student's T Distribution</p></a></li>
<li><a href='#clogis'><p>The Censored Logistic Distribution</p></a></li>
<li><a href='#cnorm'><p>The Censored Normal Distribution</p></a></li>
<li><a href='#coef.crch'><p>Methods for CRCH Objects</p></a></li>
<li><a href='#coef.crch.boost'><p>Methods for boosted CRCH Objects</p></a></li>
<li><a href='#coef.hxlr'><p>Methods for HXLR Objects</p></a></li>
<li><a href='#crch'><p>Censored Regression with Conditional Heteroscedasticy</p></a></li>
<li><a href='#crch.boost'><p>Auxiliary functions to fit <code>crch</code> models via boosting.</p></a></li>
<li><a href='#crch.control'><p>Auxiliary Function for Controlling crch Fitting</p></a></li>
<li><a href='#crch.stabsel'><p>Auxiliary functions to perform stability selection using boosting.</p></a></li>
<li><a href='#ct'><p>The Censored Student-t Distribution</p></a></li>
<li><a href='#hxlr'><p>Heteroscedastic Extended Logistic Regression</p></a></li>
<li><a href='#hxlr.control'><p>Auxiliary Function for Controlling HXLR Fitting</p></a></li>
<li><a href='#plot.crch.boost'><p>Plot coefficient paths of boosted CRCH objects.</p></a></li>
<li><a href='#predict.crch'><p>Predicted/Fitted Values for CRCH Fits</p></a></li>
<li><a href='#predict.crch.boost'><p>Predicted/Fitted Values for boosted CRCH Fits</p></a></li>
<li><a href='#predict.hxlr'><p>Predict/Fitted Values for HXLR Fits</p></a></li>
<li><a href='#RainIbk'><p>Precipitation Observations and Forecasts for Innsbruck</p></a></li>
<li><a href='#tlogis'><p>The Truncated Logistic Distribution</p></a></li>
<li><a href='#tnorm'><p>The Truncated Normal Distribution</p></a></li>
<li><a href='#TruncatedLogistic'><p>Create a Truncated Logistic Distribution</p></a></li>
<li><a href='#TruncatedNormal'><p>Create a Truncated Normal Distribution</p></a></li>
<li><a href='#TruncatedStudentsT'><p>Create a Truncated Student's T Distribution</p></a></li>
<li><a href='#tt'><p>The Truncated Student-t Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Censored Regression with Conditional Heteroscedasticity</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-25</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Formula, ordinal, sandwich, scoringRules</td>
</tr>
<tr>
<td>Suggests:</td>
<td>distributions3 (&ge; 0.2.1), glmx, lmtest, memisc</td>
</tr>
<tr>
<td>Description:</td>
<td>Different approaches to censored or truncated regression with 
  conditional heteroscedasticity are provided. First, continuous 
  distributions can be used for the (right and/or left censored or truncated)
  response with separate linear predictors for the mean and variance. 
  Second, cumulative link models for ordinal data
  (obtained by interval-censoring continuous data) can be employed for
  heteroscedastic extended logistic regression (HXLR). In the latter type of
  models, the intercepts depend on the thresholds that define the intervals.
  Infrastructure for working with censored or truncated normal, logistic,
  and Student-t distributions, i.e., d/p/q/r functions and distributions3
  objects. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-27 12:08:39 UTC; jakob</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakob Messner <a href="https://orcid.org/0000-0002-1027-3673"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Reto Stauffer <a href="https://orcid.org/0000-0002-3798-5507"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakob Messner &lt;jakob.messner@posteo.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-27 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CensoredLogistic'>Create a Censored Logistic Distribution</h2><span id='topic+CensoredLogistic'></span><span id='topic+mean.CensoredLogistic'></span><span id='topic+variance.CensoredLogistic'></span><span id='topic+skewness.CensoredLogistic'></span><span id='topic+kurtosis.CensoredLogistic'></span><span id='topic+pdf.CensoredLogistic'></span><span id='topic+log_pdf.CensoredLogistic'></span><span id='topic+cdf.CensoredLogistic'></span><span id='topic+quantile.CensoredLogistic'></span><span id='topic+random.CensoredLogistic'></span><span id='topic+crps.CensoredLogistic'></span><span id='topic+support.CensoredLogistic'></span><span id='topic+is_discrete.CensoredLogistic'></span><span id='topic+is_continuous.CensoredLogistic'></span>

<h3>Description</h3>

<p>Class and methods for left-, right-, and interval-censored logistic
distributions using the workflow from the <span class="pkg">distributions3</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CensoredLogistic(location = 0, scale = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CensoredLogistic_+3A_location">location</code></td>
<td>
<p>numeric. The location parameter of the underlying <em>uncensored</em>
logistic distribution, typically written <code class="reqn">\mu</code> in textbooks.
Can be any real number, defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="CensoredLogistic_+3A_scale">scale</code></td>
<td>
<p>numeric. The scale parameter (standard deviation) of
the underlying <em>uncensored</em> logistic distribution,
typically written <code class="reqn">\sigma</code> in textbooks.
Can be any positive number, defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="CensoredLogistic_+3A_left">left</code></td>
<td>
<p>numeric. The left censoring point. Can be any real number,
defaults to <code>-Inf</code> (uncensored). If set to a finite value, the
distribution has a point mass at <code>left</code> whose probability corresponds
to the cumulative probability function of the <em>uncensored</em>
logistic distribution at this point.</p>
</td></tr>
<tr><td><code id="CensoredLogistic_+3A_right">right</code></td>
<td>
<p>numeric. The right censoring point. Can be any real number,
defaults to <code>Inf</code> (uncensored). If set to a finite value, the
distribution has a point mass at <code>right</code> whose probability corresponds
to 1 minus the cumulative probability function of the <em>uncensored</em>
logistic distribution at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor function <code>CensoredLogistic</code> sets up a distribution
object, representing the censored logistic probability distribution by the
corresponding parameters: the latent mean <code>location</code> = <code class="reqn">\mu</code> and
latent standard deviation <code>scale</code> = <code class="reqn">\sigma</code> (i.e., the parameters
of the underlying <em>uncensored</em> logistic variable), the <code>left</code> censoring
point (with <code>-Inf</code> corresponding to uncensored), and the
<code>right</code> censoring point (with <code>Inf</code> corresponding to uncensored). 
</p>
<p>The censored logistic distribution has probability density function (PDF) <code class="reqn">f(x)</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">\Lambda((left - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \le left</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">1 - \Lambda((right - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \ge right</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\lambda((x - \mu)/\sigma)/\sigma</code> </td><td style="text-align: left;"> if <code class="reqn">left &lt; x &lt; right</code>
</td>
</tr>

</table>

<p>where <code class="reqn">\Lambda</code> and <code class="reqn">\lambda</code> are the cumulative distribution function
and probability density function of the standard logistic distribution,
respectively.
</p>
<p>All parameters can also be vectors, so that it is possible to define a vector
of censored logistic distributions with potentially different parameters.
All parameters need to have the same length or must be scalars (i.e.,
of length 1) which are then recycled to the length of the other parameters.
</p>
<p>For the <code>CensoredLogistic</code> distribution objects there is a wide range
of standard methods available to the generics provided in the <span class="pkg">distributions3</span>
package: <code><a href="distributions3.html#topic+pdf">pdf</a></code> and <code><a href="distributions3.html#topic+log_pdf">log_pdf</a></code>
for the (log-)density (PDF), <code><a href="distributions3.html#topic+cdf">cdf</a></code> for the probability
from the cumulative distribution function (CDF), <code>quantile</code> for quantiles,
<code><a href="distributions3.html#topic+random">random</a></code> for simulating random variables,
<code><a href="scoringRules.html#topic+crps">crps</a></code> for the continuous ranked probability score
(CRPS), and <code><a href="distributions3.html#topic+support">support</a></code> for the support interval
(minimum and maximum). Internally, these methods rely on the usual d/p/q/r
functions provided for the censored logistic distributions in the <span class="pkg">crch</span>
package, see <code><a href="#topic+dclogis">dclogis</a></code>, and the <code><a href="scoringRules.html#topic+crps_clogis">crps_clogis</a></code>
function from the <span class="pkg">scoringRules</span> package.
The methods <code><a href="distributions3.html#topic+is_discrete">is_discrete</a></code> and <code><a href="distributions3.html#topic+is_continuous">is_continuous</a></code>
can be used to query whether the distributions are discrete on the entire support
(always <code>FALSE</code>) or continuous on the entire support (only <code>TRUE</code> if
there is no censoring, i.e., if both <code>left</code> and <code>right</code> are infinite).
</p>
<p>See the examples below for an illustration of the workflow for the class and methods.
</p>


<h3>Value</h3>

<p>A <code>CensoredLogistic</code> distribution object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dclogis">dclogis</a></code>, <code><a href="distributions3.html#topic+Logistic">Logistic</a></code>, <code><a href="#topic+TruncatedLogistic">TruncatedLogistic</a></code>,
<code><a href="#topic+CensoredNormal">CensoredNormal</a></code>, <code><a href="#topic+CensoredStudentsT">CensoredStudentsT</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## package and random seed
library("distributions3")
set.seed(6020)

## three censored logistic distributions:
## - uncensored standard logistic
## - left-censored at zero with latent location = 1 and scale = 1
## - interval-censored in [0, 5] with latent location = 2 and scale = 1
X &lt;- CensoredLogistic(
  location = c(   0,   1, 2),
  scale    = c(   1,   1, 1),
  left     = c(-Inf,   0, 0),
  right    = c( Inf, Inf, 5)
)
X

## compute mean of the censored distribution
mean(X)
## higher moments (variance, skewness, kurtosis) are not implemented yet

## support interval (minimum and maximum)
support(X)

## simulate random variables
random(X, 5)

## histograms of 1,000 simulated observations
x &lt;- random(X, 1000)
hist(x[1, ], main = "uncensored")
hist(x[2, ], main = "left-censored at zero")
hist(x[3, ], main = "interval-censored in [0, 5]")

## probability density function (PDF) and log-density (or log-likelihood)
x &lt;- c(0, 0, 1)
pdf(X, x)
pdf(X, x, log = TRUE)
log_pdf(X, x)

## cumulative distribution function (CDF)
cdf(X, x)

## quantiles
quantile(X, 0.5)

## cdf() and quantile() are inverses (except at censoring points)
cdf(X, quantile(X, 0.5))
quantile(X, cdf(X, 1))

## all methods above can either be applied elementwise or for
## all combinations of X and x, if length(X) = length(x),
## also the result can be assured to be a matrix via drop = FALSE
p &lt;- c(0.05, 0.5, 0.95)
quantile(X, p, elementwise = FALSE)
quantile(X, p, elementwise = TRUE)
quantile(X, p, elementwise = TRUE, drop = FALSE)

## compare theoretical and empirical mean from 1,000 simulated observations
cbind(
  "theoretical" = mean(X),
  "empirical" = rowMeans(random(X, 1000))
)

## evaluate continuous ranked probability score (CRPS) using scoringRules
library("scoringRules")
crps(X, x)
</code></pre>

<hr>
<h2 id='CensoredNormal'>Create a Censored Normal Distribution</h2><span id='topic+CensoredNormal'></span><span id='topic+mean.CensoredNormal'></span><span id='topic+variance.CensoredNormal'></span><span id='topic+skewness.CensoredNormal'></span><span id='topic+kurtosis.CensoredNormal'></span><span id='topic+pdf.CensoredNormal'></span><span id='topic+log_pdf.CensoredNormal'></span><span id='topic+cdf.CensoredNormal'></span><span id='topic+quantile.CensoredNormal'></span><span id='topic+random.CensoredNormal'></span><span id='topic+crps.CensoredNormal'></span><span id='topic+support.CensoredNormal'></span><span id='topic+is_discrete.CensoredNormal'></span><span id='topic+is_continuous.CensoredNormal'></span>

<h3>Description</h3>

<p>Class and methods for left-, right-, and interval-censored normal
distributions using the workflow from the <span class="pkg">distributions3</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CensoredNormal(mu = 0, sigma = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CensoredNormal_+3A_mu">mu</code></td>
<td>
<p>numeric. The location parameter of the underlying <em>uncensored</em>
normal distribution, typically written <code class="reqn">\mu</code> in textbooks.
Can be any real number, defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="CensoredNormal_+3A_sigma">sigma</code></td>
<td>
<p>numeric. The scale parameter (standard deviation) of
the underlying <em>uncensored</em> normal distribution,
typically written <code class="reqn">\sigma</code> in textbooks.
Can be any positive number, defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="CensoredNormal_+3A_left">left</code></td>
<td>
<p>numeric. The left censoring point. Can be any real number,
defaults to <code>-Inf</code> (uncensored). If set to a finite value, the
distribution has a point mass at <code>left</code> whose probability corresponds
to the cumulative probability function of the <em>uncensored</em>
normal distribution at this point.</p>
</td></tr>
<tr><td><code id="CensoredNormal_+3A_right">right</code></td>
<td>
<p>numeric. The right censoring point. Can be any real number,
defaults to <code>Inf</code> (uncensored). If set to a finite value, the
distribution has a point mass at <code>right</code> whose probability corresponds
to 1 minus the cumulative probability function of the <em>uncensored</em>
normal distribution at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor function <code>CensoredNormal</code> sets up a distribution
object, representing the censored normal probability distribution by the
corresponding parameters: the latent mean <code>mu</code> = <code class="reqn">\mu</code> and
latent standard deviation <code>sigma</code> = <code class="reqn">\sigma</code> (i.e., the parameters
of the underlying <em>uncensored</em> normal variable), the <code>left</code> censoring
point (with <code>-Inf</code> corresponding to uncensored), and the
<code>right</code> censoring point (with <code>Inf</code> corresponding to uncensored). 
</p>
<p>The censored normal distribution has probability density function (PDF) <code class="reqn">f(x)</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">\Phi((left - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \le left</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">1 - \Phi((right - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \ge right</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\phi((x - \mu)/\sigma)/\sigma</code> </td><td style="text-align: left;"> if <code class="reqn">left &lt; x &lt; right</code>
</td>
</tr>

</table>

<p>where <code class="reqn">\Phi</code> and <code class="reqn">\phi</code> are the cumulative distribution function
and probability density function of the standard normal distribution
respectively.
</p>
<p>All parameters can also be vectors, so that it is possible to define a vector
of censored normal distributions with potentially different parameters.
All parameters need to have the same length or must be scalars (i.e.,
of length 1) which are then recycled to the length of the other parameters.
</p>
<p>For the <code>CensoredNormal</code> distribution objects there is a wide range
of standard methods available to the generics provided in the <span class="pkg">distributions3</span>
package: <code><a href="distributions3.html#topic+pdf">pdf</a></code> and <code><a href="distributions3.html#topic+log_pdf">log_pdf</a></code>
for the (log-)density (PDF), <code><a href="distributions3.html#topic+cdf">cdf</a></code> for the probability
from the cumulative distribution function (CDF), <code>quantile</code> for quantiles,
<code><a href="distributions3.html#topic+random">random</a></code> for simulating random variables,
<code><a href="scoringRules.html#topic+crps">crps</a></code> for the continuous ranked probability score
(CRPS), and <code><a href="distributions3.html#topic+support">support</a></code> for the support interval
(minimum and maximum). Internally, these methods rely on the usual d/p/q/r
functions provided for the censored normal distributions in the <span class="pkg">crch</span>
package, see <code><a href="#topic+dcnorm">dcnorm</a></code>, and the <code><a href="scoringRules.html#topic+crps_cnorm">crps_cnorm</a></code>
function from the <span class="pkg">scoringRules</span> package.
The methods <code><a href="distributions3.html#topic+is_discrete">is_discrete</a></code> and <code><a href="distributions3.html#topic+is_continuous">is_continuous</a></code>
can be used to query whether the distributions are discrete on the entire support
(always <code>FALSE</code>) or continuous on the entire support (only <code>TRUE</code> if
there is no censoring, i.e., if both <code>left</code> and <code>right</code> are infinite).
</p>
<p>See the examples below for an illustration of the workflow for the class and methods.
</p>


<h3>Value</h3>

<p>A <code>CensoredNormal</code> distribution object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcnorm">dcnorm</a></code>, <code><a href="distributions3.html#topic+Normal">Normal</a></code>, <code><a href="#topic+TruncatedNormal">TruncatedNormal</a></code>,
<code><a href="#topic+CensoredLogistic">CensoredLogistic</a></code>, <code><a href="#topic+CensoredStudentsT">CensoredStudentsT</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## package and random seed
library("distributions3")
set.seed(6020)

## three censored normal distributions:
## - uncensored standard normal
## - left-censored at zero (Tobit) with latent mu = 1 and sigma = 1
## - interval-censored in [0, 5] with latent mu = 1 and sigma = 2
X &lt;- CensoredNormal(
  mu    = c(   0,   1, 1),
  sigma = c(   1,   1, 2),
  left  = c(-Inf,   0, 0),
  right = c( Inf, Inf, 5)
)
X

## compute mean of the censored distribution
mean(X)
## higher moments (variance, skewness, kurtosis) are not implemented yet

## support interval (minimum and maximum)
support(X)

## simulate random variables
random(X, 5)

## histograms of 1,000 simulated observations
x &lt;- random(X, 1000)
hist(x[1, ], main = "uncensored")
hist(x[2, ], main = "left-censored at zero")
hist(x[3, ], main = "interval-censored in [0, 5]")

## probability density function (PDF) and log-density (or log-likelihood)
x &lt;- c(0, 0, 1)
pdf(X, x)
pdf(X, x, log = TRUE)
log_pdf(X, x)

## cumulative distribution function (CDF)
cdf(X, x)

## quantiles
quantile(X, 0.5)

## cdf() and quantile() are inverses (except at censoring points)
cdf(X, quantile(X, 0.5))
quantile(X, cdf(X, 1))

## all methods above can either be applied elementwise or for
## all combinations of X and x, if length(X) = length(x),
## also the result can be assured to be a matrix via drop = FALSE
p &lt;- c(0.05, 0.5, 0.95)
quantile(X, p, elementwise = FALSE)
quantile(X, p, elementwise = TRUE)
quantile(X, p, elementwise = TRUE, drop = FALSE)

## compare theoretical and empirical mean from 1,000 simulated observations
cbind(
  "theoretical" = mean(X),
  "empirical" = rowMeans(random(X, 1000))
)

## evaluate continuous ranked probability score (CRPS) using scoringRules
library("scoringRules")
crps(X, x)
</code></pre>

<hr>
<h2 id='CensoredStudentsT'>Create a Censored Student's T Distribution</h2><span id='topic+CensoredStudentsT'></span><span id='topic+mean.CensoredStudentsT'></span><span id='topic+variance.CensoredStudentsT'></span><span id='topic+skewness.CensoredStudentsT'></span><span id='topic+kurtosis.CensoredStudentsT'></span><span id='topic+pdf.CensoredStudentsT'></span><span id='topic+log_pdf.CensoredStudentsT'></span><span id='topic+cdf.CensoredStudentsT'></span><span id='topic+quantile.CensoredStudentsT'></span><span id='topic+random.CensoredStudentsT'></span><span id='topic+crps.CensoredStudentsT'></span><span id='topic+support.CensoredStudentsT'></span><span id='topic+is_discrete.CensoredStudentsT'></span><span id='topic+is_continuous.CensoredStudentsT'></span>

<h3>Description</h3>

<p>Class and methods for left-, right-, and interval-censored t
distributions using the workflow from the <span class="pkg">distributions3</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CensoredStudentsT(df, location = 0, scale = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CensoredStudentsT_+3A_df">df</code></td>
<td>
<p>numeric. The degrees of freedom of the underlying <em>uncensored</em>
t distribution. Can be any positive number, with <code>df = Inf</code> corresponding
to the normal distribution.</p>
</td></tr>
<tr><td><code id="CensoredStudentsT_+3A_location">location</code></td>
<td>
<p>numeric. The location parameter of the underlying <em>uncensored</em>
t distribution, typically written <code class="reqn">\mu</code> in textbooks.
Can be any real number, defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="CensoredStudentsT_+3A_scale">scale</code></td>
<td>
<p>numeric. The scale parameter (standard deviation) of
the underlying <em>uncensored</em> t distribution,
typically written <code class="reqn">\sigma</code> in textbooks.
Can be any positive number, defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="CensoredStudentsT_+3A_left">left</code></td>
<td>
<p>numeric. The left censoring point. Can be any real number,
defaults to <code>-Inf</code> (uncensored). If set to a finite value, the
distribution has a point mass at <code>left</code> whose probability corresponds
to the cumulative probability function of the <em>uncensored</em>
t distribution at this point.</p>
</td></tr>
<tr><td><code id="CensoredStudentsT_+3A_right">right</code></td>
<td>
<p>numeric. The right censoring point. Can be any real number,
defaults to <code>Inf</code> (uncensored). If set to a finite value, the
distribution has a point mass at <code>right</code> whose probability corresponds
to 1 minus the cumulative probability function of the <em>uncensored</em>
t distribution at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor function <code>CensoredStudentsT</code> sets up a distribution
object, representing the censored t probability distribution by the
corresponding parameters: the degrees of freedom <code>df</code>, the latent mean
<code>location</code> = <code class="reqn">\mu</code> and latent scale parameter <code>scale</code> = <code class="reqn">\sigma</code>
(i.e., the parameters of the underlying <em>uncensored</em> t variable),
the <code>left</code> censoring point (with <code>-Inf</code> corresponding to uncensored),
and the <code>right</code> censoring point (with <code>Inf</code> corresponding to uncensored). 
</p>
<p>The censored t distribution has probability density function (PDF) <code class="reqn">f(x)</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">T((left - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \le left</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">1 - T((right - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \ge right</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\tau((x - \mu)/\sigma)/\sigma</code> </td><td style="text-align: left;"> if <code class="reqn">left &lt; x &lt; right</code>
</td>
</tr>

</table>

<p>where <code class="reqn">T</code> and <code class="reqn">\tau</code> are the cumulative distribution function
and probability density function of the standard t distribution with
<code>df</code> degrees of freedom, respectively.
</p>
<p>All parameters can also be vectors, so that it is possible to define a vector
of censored t distributions with potentially different parameters.
All parameters need to have the same length or must be scalars (i.e.,
of length 1) which are then recycled to the length of the other parameters.
</p>
<p>For the <code>CensoredStudentsT</code> distribution objects there is a wide range
of standard methods available to the generics provided in the <span class="pkg">distributions3</span>
package: <code><a href="distributions3.html#topic+pdf">pdf</a></code> and <code><a href="distributions3.html#topic+log_pdf">log_pdf</a></code>
for the (log-)density (PDF), <code><a href="distributions3.html#topic+cdf">cdf</a></code> for the probability
from the cumulative distribution function (CDF), <code>quantile</code> for quantiles,
<code><a href="distributions3.html#topic+random">random</a></code> for simulating random variables,
<code><a href="scoringRules.html#topic+crps">crps</a></code> for the continuous ranked probability score
(CRPS), and <code><a href="distributions3.html#topic+support">support</a></code> for the support interval
(minimum and maximum). Internally, these methods rely on the usual d/p/q/r
functions provided for the censored t distributions in the <span class="pkg">crch</span>
package, see <code><a href="#topic+dct">dct</a></code>, and the <code><a href="scoringRules.html#topic+crps_ct">crps_ct</a></code>
function from the <span class="pkg">scoringRules</span> package.
The methods <code><a href="distributions3.html#topic+is_discrete">is_discrete</a></code> and <code><a href="distributions3.html#topic+is_continuous">is_continuous</a></code>
can be used to query whether the distributions are discrete on the entire support
(always <code>FALSE</code>) or continuous on the entire support (only <code>TRUE</code> if
there is no censoring, i.e., if both <code>left</code> and <code>right</code> are infinite).
</p>
<p>See the examples below for an illustration of the workflow for the class and methods.
</p>


<h3>Value</h3>

<p>A <code>CensoredStudentsT</code> distribution object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dct">dct</a></code>, <code><a href="distributions3.html#topic+StudentsT">StudentsT</a></code>, <code><a href="#topic+TruncatedStudentsT">TruncatedStudentsT</a></code>,
<code><a href="#topic+CensoredNormal">CensoredNormal</a></code>, <code><a href="#topic+CensoredLogistic">CensoredLogistic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## package and random seed
library("distributions3")
set.seed(6020)

## three censored t distributions:
## - uncensored standard t with 5 degrees of freedom
## - left-censored at zero with 5 df, latent location = 1 and scale = 1
## - interval-censored in [0, 5] with 5 df, latent location = 2 and scale = 2
X &lt;- CensoredStudentsT(
  df       = c(   5,   5, 5),
  location = c(   0,   1, 2),
  scale    = c(   1,   1, 2),
  left     = c(-Inf,   0, 0),
  right    = c( Inf, Inf, 5)
)
X

## compute mean of the censored distribution
mean(X)
## higher moments (variance, skewness, kurtosis) are not implemented yet

## support interval (minimum and maximum)
support(X)

## simulate random variables
random(X, 5)

## histograms of 1,000 simulated observations
x &lt;- random(X, 1000)
hist(x[1, ], main = "uncensored")
hist(x[2, ], main = "left-censored at zero")
hist(x[3, ], main = "interval-censored in [0, 5]")

## probability density function (PDF) and log-density (or log-likelihood)
x &lt;- c(0, 0, 1)
pdf(X, x)
pdf(X, x, log = TRUE)
log_pdf(X, x)

## cumulative distribution function (CDF)
cdf(X, x)

## quantiles
quantile(X, 0.5)

## cdf() and quantile() are inverses (except at censoring points)
cdf(X, quantile(X, 0.5))
quantile(X, cdf(X, 1))

## all methods above can either be applied elementwise or for
## all combinations of X and x, if length(X) = length(x),
## also the result can be assured to be a matrix via drop = FALSE
p &lt;- c(0.05, 0.5, 0.95)
quantile(X, p, elementwise = FALSE)
quantile(X, p, elementwise = TRUE)
quantile(X, p, elementwise = TRUE, drop = FALSE)

## compare theoretical and empirical mean from 1,000 simulated observations
cbind(
  "theoretical" = mean(X),
  "empirical" = rowMeans(random(X, 1000))
)

## evaluate continuous ranked probability score (CRPS) using scoringRules
library("scoringRules")
crps(X, x)
</code></pre>

<hr>
<h2 id='clogis'>The Censored Logistic Distribution</h2><span id='topic+dclogis'></span><span id='topic+pclogis'></span><span id='topic+qclogis'></span><span id='topic+rclogis'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation
for the left and/or right censored logistic distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dclogis(x, location = 0, scale = 1, left = -Inf, right = Inf, log = FALSE)

pclogis(q, location = 0, scale = 1, left = -Inf, right = Inf, 
  lower.tail = TRUE, log.p = FALSE)

qclogis(p, location = 0, scale = 1, left = -Inf, right = Inf,
  lower.tail = TRUE, log.p = FALSE)

rclogis(n, location = 0, scale = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clogis_+3A_x">x</code>, <code id="clogis_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="clogis_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="clogis_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="clogis_+3A_location">location</code></td>
<td>
<p>location parameter.</p>
</td></tr>
<tr><td><code id="clogis_+3A_scale">scale</code></td>
<td>
<p>scale parameter.</p>
</td></tr>
<tr><td><code id="clogis_+3A_left">left</code></td>
<td>
<p>left censoring point.</p>
</td></tr>
<tr><td><code id="clogis_+3A_right">right</code></td>
<td>
<p>right censoring point.</p>
</td></tr>
<tr><td><code id="clogis_+3A_log">log</code>, <code id="clogis_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="clogis_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x]
otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>location</code> or <code>scale</code> are not specified they assume the default values
of <code>0</code> and <code>1</code>, respectively. <code>left</code> and <code>right</code> have the defaults <code>-Inf</code> and <code>Inf</code> respectively.
</p>
<p>The censored logistic distribution has density <code class="reqn">f(x)</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">\Lambda((left - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \le left</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">1 - \Lambda((right - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \ge right</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\lambda((x - \mu)/\sigma)/\sigma</code> </td><td style="text-align: left;"> if <code class="reqn">left &lt; x &lt; right</code>
</td>
</tr>

</table>

<p>where <code class="reqn">\Lambda</code> and <code class="reqn">\lambda</code> are the cumulative distribution function
and probability density function of the standard logistic distribution
respectively, <code class="reqn">\mu</code> is the location of the distribution, and <code class="reqn">\sigma</code> 
the scale.
</p>


<h3>Value</h3>

<p><code>dclogis</code> gives the density, <code>pclogis</code> gives the distribution
function, <code>qclogis</code> gives the quantile function, and <code>rclogis</code>
generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dlogis">dlogis</a></code></p>

<hr>
<h2 id='cnorm'>The Censored Normal Distribution</h2><span id='topic+dcnorm'></span><span id='topic+pcnorm'></span><span id='topic+qcnorm'></span><span id='topic+rcnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation
for the left and/or right censored normal distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcnorm(x, mean = 0, sd = 1, left = -Inf, right = Inf, log = FALSE)

pcnorm(q, mean = 0, sd = 1, left = -Inf, right = Inf, 
  lower.tail = TRUE, log.p = FALSE)

qcnorm(p, mean = 0, sd = 1, left = -Inf, right = Inf,
  lower.tail = TRUE, log.p = FALSE)

rcnorm(n, mean = 0, sd = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnorm_+3A_x">x</code>, <code id="cnorm_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_left">left</code></td>
<td>
<p>left censoring point.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_right">right</code></td>
<td>
<p>right censoring point.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_log">log</code>, <code id="cnorm_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="cnorm_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x]
otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mean</code> or <code>sd</code> are not specified they assume the default values
of <code>0</code> and <code>1</code>, respectively. <code>left</code> and <code>right</code> have the defaults <code>-Inf</code> and <code>Inf</code> respectively.
</p>
<p>The censored normal distribution has density <code class="reqn">f(x)</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">\Phi((left - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \le left</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">1 - \Phi((right - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \ge right</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\phi((x - \mu)/\sigma)/\sigma</code> </td><td style="text-align: left;"> if <code class="reqn">left &lt; x &lt; right</code>
</td>
</tr>

</table>

<p>where <code class="reqn">\Phi</code> and <code class="reqn">\phi</code> are the cumulative distribution function
and probability density function of the standard normal distribution
respectively, <code class="reqn">\mu</code> is the mean of the distribution, and <code class="reqn">\sigma</code> 
the standard deviation.
</p>


<h3>Value</h3>

<p><code>dcnorm</code> gives the density, <code>pcnorm</code> gives the distribution
function, <code>qcnorm</code> gives the quantile function, and <code>rcnorm</code>
generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code></p>

<hr>
<h2 id='coef.crch'>Methods for CRCH Objects</h2><span id='topic+coef.crch'></span><span id='topic+vcov.crch'></span><span id='topic+print.crch'></span><span id='topic+summary.crch'></span><span id='topic+print.summary.crch'></span><span id='topic+logLik.crch'></span><span id='topic+terms.crch'></span><span id='topic+model.frame.crch'></span><span id='topic+model.matrix.crch'></span><span id='topic+residuals.crch'></span><span id='topic+fitted.crch'></span><span id='topic+getSummary.crch'></span><span id='topic+estfun.crch'></span><span id='topic+crps.crch'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted <code>crch</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crch'
coef(object, model = c("full", "location", "scale", "df"), ...)
## S3 method for class 'crch'
vcov(object, model = c("full", "location", "scale", "df"), ...)
## S3 method for class 'crch'
terms(x, model = c("location", "scale", "full"), ...)
## S3 method for class 'crch'
fitted(object, type = c("location", "scale"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.crch_+3A_object">object</code>, <code id="coef.crch_+3A_x">x</code></td>
<td>
<p>an object of class <code>"crch"</code>.</p>
</td></tr>
<tr><td><code id="coef.crch_+3A_model">model</code></td>
<td>
<p>model for which coefficients shall be returned.</p>
</td></tr>
<tr><td><code id="coef.crch_+3A_type">type</code></td>
<td>
<p>type of fitted values.</p>
</td></tr>
<tr><td><code id="coef.crch_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the methods above, a set of standard extractor functions for 
<code>"crch"</code> objects is available, including methods to the generic
functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, 
<code><a href="stats.html#topic+logLik">logLik</a></code>, and  <code><a href="stats.html#topic+residuals">residuals</a></code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crch">crch</a></code></p>

<hr>
<h2 id='coef.crch.boost'>Methods for boosted CRCH Objects</h2><span id='topic+coef.crch.boost'></span><span id='topic+print.crch.boost'></span><span id='topic+summary.crch.boost'></span><span id='topic+print.summary.crch.boost'></span><span id='topic+logLik.crch.boost'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted <code>crch.boost</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crch.boost'
coef(object, model = c("full", "location", "scale", "df"), 
  mstop = NULL, zero.coefficients = FALSE, standardize = FALSE, ...)
## S3 method for class 'crch.boost'
print(x, digits = max(3, getOption("digits") - 3),
  mstop = NULL, zero.coefficients = FALSE, ...)
## S3 method for class 'crch.boost'
summary(object, mstop = NULL, zero.coefficients = FALSE, ...)
## S3 method for class 'crch.boost'
logLik(object, mstop = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.crch.boost_+3A_object">object</code>, <code id="coef.crch.boost_+3A_x">x</code></td>
<td>
<p>an object of class <code>"crch.boost"</code>.</p>
</td></tr>
<tr><td><code id="coef.crch.boost_+3A_model">model</code></td>
<td>
<p>model for which coefficients shall be returned.</p>
</td></tr>
<tr><td><code id="coef.crch.boost_+3A_mstop">mstop</code></td>
<td>
<p>stopping iteration for which coefficients shall be returned.
Can be either a character (<code>"max"</code>, <code>"aic"</code>, <code>"bic"</code>, <code>"cv"</code>) 
or a numeric value.</p>
</td></tr>
<tr><td><code id="coef.crch.boost_+3A_zero.coefficients">zero.coefficients</code></td>
<td>
<p>logical whether zero coefficients are returned.</p>
</td></tr>
<tr><td><code id="coef.crch.boost_+3A_standardize">standardize</code></td>
<td>
<p>logical whether coefficients shall be standardized.</p>
</td></tr>
<tr><td><code id="coef.crch.boost_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="coef.crch.boost_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the methods above, the <code>"crch"</code> methods 
<code><a href="stats.html#topic+terms">terms</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>, <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="stats.html#topic+residuals">residuals</a></code>, and <code><a href="stats.html#topic+fitted">fitted</a></code> can be used also for
<code>"crch.boost"</code> objects .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crch.boost">crch.boost</a></code>,<code><a href="#topic+coef.crch">coef.crch</a></code></p>

<hr>
<h2 id='coef.hxlr'>Methods for HXLR Objects</h2><span id='topic+coef.hxlr'></span><span id='topic+vcov.hxlr'></span><span id='topic+print.hxlr'></span><span id='topic+summary.hxlr'></span><span id='topic+print.summary.hxlr'></span><span id='topic+logLik.hxlr'></span><span id='topic+terms.hxlr'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted <code>hxlr</code> 
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hxlr'
coef(object, model = c("full", "intercept", "location", "scale"),
  type = c("CLM", "latent"), ...)
## S3 method for class 'hxlr'
vcov(object, model = c("full", "intercept", "location", "scale"), 
  type = c("CLM", "latent"), ...)
## S3 method for class 'hxlr'
terms(x, model = c("full", "location", "scale"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.hxlr_+3A_object">object</code>, <code id="coef.hxlr_+3A_x">x</code></td>
<td>
<p>an object of class <code>"hxlr"</code>.</p>
</td></tr>
<tr><td><code id="coef.hxlr_+3A_model">model</code></td>
<td>
<p>model for which coefficients shall be returned.</p>
</td></tr>
<tr><td><code id="coef.hxlr_+3A_type">type</code></td>
<td>
<p>type of coefficients. Default are CLM type coefficients.  For
type <code>"latent"</code> coefficients are converted in coefficients for location
and scale of the latent distribution (analog to <code>crch</code> models).</p>
</td></tr>
<tr><td><code id="coef.hxlr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the methods above, a set of standard extractor functions for 
<code>"hxlr"</code> objects is available, including methods to the generic
functions <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, and
<code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hxlr">hxlr</a></code></p>

<hr>
<h2 id='crch'>Censored Regression with Conditional Heteroscedasticy</h2><span id='topic+crch'></span><span id='topic+trch'></span><span id='topic+crch.fit'></span>

<h3>Description</h3>

<p>Fitting censored (tobit) or truncated regression models with conditional heteroscedasticy. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crch(formula, data, subset, na.action, weights, offset, 
  link.scale = c("log", "identity", "quadratic"),
  dist = c("gaussian", "logistic", "student"), df = NULL, 
  left = -Inf, right = Inf, truncated = FALSE, 
  type = c("ml", "crps"), control = crch.control(...), 
  model = TRUE, x = FALSE, y = FALSE, ...)

trch(formula, data, subset, na.action, weights, offset, 
  link.scale = c("log", "identity", "quadratic"),
  dist = c("gaussian", "logistic", "student"), df = NULL, 
  left = -Inf, right = Inf, truncated = TRUE, 
  type = c("ml", "crps"), control = crch.control(...), 
  model = TRUE, x = FALSE, y = FALSE, ...)

crch.fit(x, z, y, left, right, truncated = FALSE, dist = "gaussian",
  df = NULL, link.scale = "log", type = "ml", weights = NULL, offset = NULL, 
  control = crch.control()) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crch_+3A_formula">formula</code></td>
<td>
<p>a formula expression of the form <code>y ~ x | z</code> where
<code>y</code> is the response and <code>x</code> and <code>z</code> are regressor variables
for the location and the scale of the fitted distribution respectively.</p>
</td></tr>
<tr><td><code id="crch_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables occurring in the
formulas.</p>
</td></tr>
<tr><td><code id="crch_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used for fitting.</p>
</td></tr>
<tr><td><code id="crch_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="crch_+3A_weights">weights</code></td>
<td>
<p>optional case weights in fitting.</p>
</td></tr>
<tr><td><code id="crch_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with <em>a priori</em> known component to
be included in the linear predictor for the location.  For <code>crch.fit</code>, 
<code>offset</code> can also be a list of 2 offsets used for the location and scale
respectively.</p>
</td></tr>
<tr><td><code id="crch_+3A_link.scale">link.scale</code></td>
<td>
<p>character specification of the link function in
the scale model. Currently, <code>"identity"</code>, <code>"log"</code>, 
<code>"quadratic"</code> are supported. The default is <code>"log"</code>.
Alternatively, an object of class <code>"link-glm"</code> can be supplied.</p>
</td></tr>
<tr><td><code id="crch_+3A_dist">dist</code></td>
<td>
<p>assumed distribution for the dependent variable <code>y</code>.</p>
</td></tr>
<tr><td><code id="crch_+3A_df">df</code></td>
<td>
<p>optional degrees of freedom for <code>dist="student"</code>. If omitted
the degrees of freedom are estimated.</p>
</td></tr>
<tr><td><code id="crch_+3A_left">left</code></td>
<td>
<p>left limit for the censored dependent variable <code>y</code>.  If set
to <code>-Inf</code>, <code>y</code> is assumed not to be left-censored.</p>
</td></tr>
<tr><td><code id="crch_+3A_right">right</code></td>
<td>
<p>right limit for the censored dependent variable <code>y</code>.  If
set to <code>Inf</code>, <code>y</code> is assumed not to be right-censored.</p>
</td></tr>
<tr><td><code id="crch_+3A_truncated">truncated</code></td>
<td>
<p>logical. If <code>TRUE</code> truncated model is fitted
with <code>left</code> and <code>right</code> interpreted as truncation points,
If <code>FALSE</code> censored model is fitted. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="crch_+3A_type">type</code></td>
<td>
<p>loss function to be optimized. Can be either <code>"ml"</code> for
maximum likelihood (default) or <code>"crps"</code> for minimum continuous ranked
probability score (CRPS).</p>
</td></tr>
<tr><td><code id="crch_+3A_control">control</code></td>
<td>
<p>a list of control parameters passed to <code><a href="stats.html#topic+optim">optim</a></code> 
or to the internal boosting algorithm if <code>control=<a href="#topic+crch.boost">crch.boost</a>()</code>. 
Default is <code><a href="#topic+crch.control">crch.control</a>()</code>.</p>
</td></tr>
<tr><td><code id="crch_+3A_model">model</code></td>
<td>
<p>logical. If <code>TRUE</code> <em>model frame</em> is
included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="crch_+3A_x">x</code>, <code id="crch_+3A_y">y</code></td>
<td>
<p>for <code>crch</code>: logical. If <code>TRUE</code> the model matrix and
response vector used for fitting are returned as components of the returned
value.
for <code>crch.fit</code>: <code>x</code> is a design matrix with regressors for the
location and <code>y</code> is a vector of observations.</p>
</td></tr>
<tr><td><code id="crch_+3A_z">z</code></td>
<td>
<p>a design matrix with regressors for the scale.</p>
</td></tr>
<tr><td><code id="crch_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default <code>control</code> argument
if it is not supplied directly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>crch</code> fits censored (tobit) or truncated regression models with conditional
heteroscedasticy with maximum likelihood estimation. Student-t, Gaussian, and
logistic distributions can be fitted to left- and/or right censored or 
truncated responses. Different regressors can be used to model the location 
and the scale of this distribution. If <code>control=<a href="#topic+crch.boost">crch.boost</a>()</code>
optimization is performed by boosting.
</p>
<p><code>trch</code> is a wrapper function for <code>crch</code> with default 
<code>truncated = TRUE</code>.
</p>
<p><code>crch.fit</code> is the lower level function where the actual
fitting takes place.
</p>


<h3>Value</h3>

<p>An object of class <code>"crch"</code> or <code>"crch.boost"</code>, i.e., a list with the 
following elements.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>list of coefficients for location, scale, and df. Scale
and df coefficients are in log-scale.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>if <code>dist = "student"</code>: degrees of freedom of student-t
distribution. else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>list of fitted location and scale parameters.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>assumed distribution for the dependent variable <code>y</code>.</p>
</td></tr>
<tr><td><code>cens</code></td>
<td>
<p>list of censoring points.</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>output from optimization from <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>optimization method used for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>used loss function (maximum likelihood or minimum CRPS).</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>list of control parameters passed to <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>starting values of coefficients used in the optimization.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>case weights used for fitting.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>list of offsets for location and scale.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>a list with element <code>"scale"</code> containing
the link objects for the scale model.</p>
</td></tr>
<tr><td><code>truncated</code></td>
<td>
<p>logical indicating wheter a truncated model has been fitted.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical variable whether optimization has converged or not.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations in optimization.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> objects used.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>list of levels of the factors used in fitting for location and
scale respectively.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(where relevant) the contrasts used.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested, the model frame used.</p>
</td></tr>
<tr><td><code>stepsize</code>, <code>mstop</code>, <code>mstopopt</code>, <code>standardize</code></td>
<td>
<p>return values of boosting 
optimization. See <code><a href="#topic+crch.boost">crch.boost</a></code> for details.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Messner JW, Mayr GJ, Zeileis A (2016). Heteroscedastic Censored and
Truncated Regression with crch.
<em>The R Journal</em>, <b>3</b>(1), 173&ndash;181.
<a href="https://journal.R-project.org/archive/2016-1/messner-mayr-zeileis.pdf">https://journal.R-project.org/archive/2016-1/messner-mayr-zeileis.pdf</a>.
</p>
<p>Messner JW, Zeileis A, Broecker J, Mayr GJ (2014). Probabilistic Wind Power
Forecasts with an Inverse Power Curve Transformation and Censored Regression.
<em>Wind Energy</em>, <b>17</b>(11), 1753&ndash;1766. doi: <a href="https://doi.org/10.1002/we.1666">10.1002/we.1666</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.crch">predict.crch</a></code>, <code><a href="#topic+crch.control">crch.control</a></code>, <code><a href="#topic+crch.boost">crch.boost</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("RainIbk")
## mean and standard deviation of square root transformed ensemble forecasts
RainIbk$sqrtensmean &lt;- 
  apply(sqrt(RainIbk[,grep('^rainfc',names(RainIbk))]), 1, mean)
RainIbk$sqrtenssd &lt;- 
  apply(sqrt(RainIbk[,grep('^rainfc',names(RainIbk))]), 1, sd)

## fit linear regression model with Gaussian distribution 
CRCH &lt;- crch(sqrt(rain) ~ sqrtensmean, data = RainIbk, dist = "gaussian")
## same as lm?
all.equal(
  coef(lm(sqrt(rain) ~ sqrtensmean, data = RainIbk)),
  head(coef(CRCH), -1),
  tol = 1e-6)

## print
CRCH
## summary
summary(CRCH)

## left censored regression model with censoring point 0:
CRCH2 &lt;- crch(sqrt(rain) ~ sqrtensmean, data = RainIbk, 
  dist = "gaussian", left = 0)

## left censored regression model with censoring point 0 and 
## conditional heteroscedasticy:
CRCH3 &lt;- crch(sqrt(rain) ~ sqrtensmean|sqrtenssd, data = RainIbk, 
  dist = "gaussian",  left = 0)

## left censored regression model with censoring point 0 and 
## conditional heteroscedasticy with logistic distribution:
CRCH4 &lt;- crch(sqrt(rain) ~ sqrtensmean|sqrtenssd, data = RainIbk, 
  dist = "logistic", left = 0)

## compare AIC 
AIC(CRCH, CRCH2, CRCH3, CRCH4)
</code></pre>

<hr>
<h2 id='crch.boost'>Auxiliary functions to fit <code>crch</code> models via boosting.</h2><span id='topic+crch.boost'></span><span id='topic+crch.boost.fit'></span>

<h3>Description</h3>

<p>Auxiliary functions to fit <code>crch</code> models via boosting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crch.boost(maxit = 100, nu = 0.1, start = NULL, dot = "separate", 
  mstop = c("max", "aic", "bic", "cv"),  nfolds = 10, foldid = NULL, 
  maxvar = NULL)

crch.boost.fit(x, z, y, left, right, truncated = FALSE, dist = "gaussian",
  df = NULL, link.scale = "log", type = "ml", weights = NULL, offset = NULL, 
  control = crch.boost())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crch.boost_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of boosting iterations.</p>
</td></tr>
<tr><td><code id="crch.boost_+3A_nu">nu</code></td>
<td>
<p>boosting step size. Default is 0.1.</p>
</td></tr>
<tr><td><code id="crch.boost_+3A_start">start</code></td>
<td>
<p>a previously boosted but not converged <code>"crch.boost"</code> 
object to continue.</p>
</td></tr>
<tr><td><code id="crch.boost_+3A_dot">dot</code></td>
<td>
<p>character specifying how to process formula parts with a dot
(<code>.</code>) on the right-hand side. This can either be <code>"separate"</code>
so that each formula part is expanded separately or <code>"sequential"</code>
so that the parts are expanded sequentially conditional on all prior parts.
Default is <code>"separate"</code></p>
</td></tr>
<tr><td><code id="crch.boost_+3A_mstop">mstop</code></td>
<td>
<p>method to find optimum stopping iteration. Default is <code>"max"</code>
which is <code>maxit</code>. Alternatives are <code>"aic"</code> and <code>"bic"</code> for 
AIC and BIC
optimization and <code>"cv"</code> for cross validation.
<code>mstop</code> can also be a positive integer to set the number of boosting
iterations. Then <code>maxit</code> is set to <code>mstop</code> and <code>mstop="max"</code>.</p>
</td></tr>
<tr><td><code id="crch.boost_+3A_nfolds">nfolds</code></td>
<td>
<p>if <code>mstopopt = "cv"</code>, number of folds in cross validation.</p>
</td></tr>
<tr><td><code id="crch.boost_+3A_foldid">foldid</code></td>
<td>
<p>if <code>mstopopt = "cv"</code>, an optional vector of values between 1 
and <code>nfold</code> identifying the fold each observation is in. If supplied,
<code>nfolds</code> can be missing.</p>
</td></tr>
<tr><td><code id="crch.boost_+3A_maxvar">maxvar</code></td>
<td>
<p>Positive <code>numeric</code>. Maximum number of parameters to be selected
during each iteration (not including intercepts). Used for stability selection.</p>
</td></tr>
<tr><td><code id="crch.boost_+3A_x">x</code>, <code id="crch.boost_+3A_z">z</code>, <code id="crch.boost_+3A_y">y</code>, <code id="crch.boost_+3A_left">left</code>, <code id="crch.boost_+3A_right">right</code>, <code id="crch.boost_+3A_truncated">truncated</code>, <code id="crch.boost_+3A_dist">dist</code>, <code id="crch.boost_+3A_df">df</code>, <code id="crch.boost_+3A_link.scale">link.scale</code>, <code id="crch.boost_+3A_type">type</code>, <code id="crch.boost_+3A_weights">weights</code>, <code id="crch.boost_+3A_offset">offset</code>, <code id="crch.boost_+3A_control">control</code></td>
<td>
<p>see <code><a href="#topic+crch.fit">crch.fit</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>crch.boost</code> extends <code>crch</code> to fit censored (tobit) or 
truncated regression models with conditional heteroscedasticy by
boosting. If <code>crch.boost()</code> is supplied as <code>control</code> in 
<code>crch</code> then <code>crch.boost.fit</code> is used as lower level fitting
function. Note that <code><a href="#topic+crch.control">crch.control</a>()</code> with <code>method=boosting</code>
is equivalent to <code>crch.boost()</code>. Thus, boosting can more 
conveniently be called with <code>crch(..., method = "boosting")</code>.
</p>


<h3>Value</h3>

<p>For <code>crch.boost</code>: A list with components named as the arguments.
For <code>crch.boost.fit</code>: An object of class <code>"crch.boost"</code>, 
i.e., a list with the following elements.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>list of coefficients for location and scale. Scale
coefficients are in log-scale. Coefficients are of optimum stopping
stopping iteration specified by <code>mstop</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>if <code>dist = "student"</code>: degrees of freedom of student-t
distribution. else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>list of fitted location and scale parameters at
optimum stopping iteration specified by <code>mstop</code>.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>assumed distribution for the dependent variable <code>y</code>.</p>
</td></tr>
<tr><td><code>cens</code></td>
<td>
<p>list of censoring points.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>list of control parameters.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>case weights used for fitting.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>list of offsets for location and scale.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>a list with element <code>"scale"</code> containing
the link objects for the scale model.</p>
</td></tr>
<tr><td><code>truncated</code></td>
<td>
<p>logical indicating wheter a truncated model has been 
fitted.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of boosting iterations.</p>
</td></tr>
<tr><td><code>stepsize</code></td>
<td>
<p>boosting stepsize <code>nu</code>.</p>
</td></tr>
<tr><td><code>mstop</code></td>
<td>
<p>criterion used to find optimum stopping iteration.</p>
</td></tr>
<tr><td><code>mstopopt</code></td>
<td>
<p>optimum stopping iterations for different criteria.</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>list of center and scale values used to standardize 
response and regressors.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Messner JW, Mayr GJ, Zeileis A (2016). Non-Homogeneous Boosting for Predictor 
Selection in Ensemble Post-Processing. <em>Working Papers</em>, Faculty of 
Economics and Statistics, University of Innsbruck, url:http://econpapers.repec.org/paper/innwpaper/2016-04.htm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crch">crch</a></code>, <code><a href="#topic+crch.control">crch.control</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate data
suppressWarnings(RNGversion("3.5.0"))
set.seed(5)
x &lt;- matrix(rnorm(1000*20),1000,20)
y &lt;- rnorm(1000, 1 + x[,1] - 1.5 * x[,2], exp(-1 + 0.3*x[,3]))
y &lt;- pmax(0, y)
data &lt;- data.frame(cbind(y, x))

# fit model with maximum likelihood
CRCH &lt;- crch(y ~ .|., data = data, dist = "gaussian", left = 0)

# fit model with boosting
boost &lt;- crch(y ~ .|.,  data = data, dist = "gaussian", left = 0,
  control = crch.boost(mstop = "aic"))

# more conveniently, the same model can also be fit through
# boost &lt;- crch(y ~ .|.,  data = data, dist = "gaussian", left = 0,
#   method = "boosting", mstop = "aic")

# AIC comparison
AIC(CRCH, boost)

# summary
summary(boost)

# plot
plot(boost)
</code></pre>

<hr>
<h2 id='crch.control'>Auxiliary Function for Controlling crch Fitting</h2><span id='topic+crch.control'></span>

<h3>Description</h3>

<p>Auxiliary function for <code>crch</code> fitting. Specifies a list of values passed
to <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crch.control(method = "BFGS", maxit = NULL, hessian = NULL,
  trace = FALSE, start = NULL, dot = "separate",
  lower = -Inf, upper = Inf, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crch.control_+3A_method">method</code></td>
<td>
<p>optimization method passed to <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="crch.control_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations. Default is 5000 except for 
<code>method="boosting"</code> where the default is 100.</p>
</td></tr>
<tr><td><code id="crch.control_+3A_hessian">hessian</code></td>
<td>
<p>logical or NULL. If TRUE the numerical Hessian matrix from the 
<code><a href="stats.html#topic+optim">optim</a></code> output is used for estimation of the covariance matrix.
If FALSE no covariance matrix is computed.
If NULL (the default) the Hessian matrix is computed analytically for 
<code>dist="gaussian"</code>, <code>dist="logistic"</code>, and <code>dist="student"</code>
with predefined <code>df</code>. 
For <code>dist="student"</code> without prespecified <code>df</code>, no analytical 
solution is available and a numerical Hessian matrix is forced.</p>
</td></tr>
<tr><td><code id="crch.control_+3A_trace">trace</code></td>
<td>
<p>non-negative integer. If positive, tracing information on the
progress of the optimization is produced.</p>
</td></tr>
<tr><td><code id="crch.control_+3A_start">start</code></td>
<td>
<p>initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="crch.control_+3A_dot">dot</code></td>
<td>
<p>character specifying how to process formula parts with a dot
(<code>.</code>) on the right-hand side. This can either be <code>"separate"</code>
so that each formula part is expanded separately or <code>"sequential"</code>
so that the parts are expanded sequentially conditional on all prior parts.
Default is <code>"separate"</code></p>
</td></tr>
<tr><td><code id="crch.control_+3A_lower">lower</code>, <code id="crch.control_+3A_upper">upper</code></td>
<td>
<p>bounds on the variables for the <code>"L-BFGS-B"</code> method,
or bounds in which to search for method <code>"Brent"</code>.</p>
</td></tr>
<tr><td><code id="crch.control_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="stats.html#topic+optim">optim</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crch">crch</a></code>, <code><a href="stats.html#topic+optim">optim</a></code></p>

<hr>
<h2 id='crch.stabsel'>Auxiliary functions to perform stability selection using boosting.</h2><span id='topic+crch.stabsel'></span>

<h3>Description</h3>

<p>Auxilirary function which allows to do stability selection on heteroscedastic
<code><a href="#topic+crch">crch</a></code> models based on <code><a href="#topic+crch.boost">crch.boost</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crch.stabsel(formula, data, ..., nu = 0.1, q, B = 100, thr = 0.9, 
  maxit = 2000, data_percentage = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crch.stabsel_+3A_formula">formula</code></td>
<td>
<p>a formula expression of the form <code>y ~ x | z</code> where
<code>y</code> is the response and <code>x</code> and <code>z</code> are regressor variables
for the location and the scale of the fitted distribution respectively.</p>
</td></tr>
<tr><td><code id="crch.stabsel_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables occurring in the
formulas.</p>
</td></tr>
<tr><td><code id="crch.stabsel_+3A_...">...</code></td>
<td>
<p>Additional attributes to control the <code><a href="#topic+crch">crch</a></code> model.
Note that <code>control</code> is <em>not</em> allowed; <code>crch.stabsel</code>
uses <code>crch.boost</code> by default.</p>
</td></tr>
<tr><td><code id="crch.stabsel_+3A_nu">nu</code></td>
<td>
<p>Boosting step size (see <code><a href="#topic+crch.boost">crch.boost</a></code>) default is <code>0.1</code>
as for <code><a href="#topic+crch.boost">crch.boost</a></code> while lower values might yield better results
frequently and should be considered.</p>
</td></tr>
<tr><td><code id="crch.stabsel_+3A_q">q</code></td>
<td>
<p>Positive <code>numeric</code>. Maximum number of parameters to be selected
during each iteration (not including intercepts).</p>
</td></tr>
<tr><td><code id="crch.stabsel_+3A_b">B</code></td>
<td>
<p><code>numeric</code>, total number of iterations.</p>
</td></tr>
<tr><td><code id="crch.stabsel_+3A_thr">thr</code></td>
<td>
<p><code>numeric</code> threshold (<code>(0.5-1.0)</code>). Used to generate the new
formula and the computation of the per-family error rate.</p>
</td></tr>
<tr><td><code id="crch.stabsel_+3A_maxit">maxit</code></td>
<td>
<p>Positive <code>numeric</code> value. Maximum number for the boosting algorithm.
If <code>q</code> is not reached before <code>maxit</code> the algorithm will stop.</p>
</td></tr>
<tr><td><code id="crch.stabsel_+3A_data_percentage">data_percentage</code></td>
<td>
<p>Percentage of data which should be sampled in each of the
iterations. Default (and suggested) is <code>0.5</code>.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code><a href="#topic+crch.boost">crch.boost</a></code> allows to perform gradient boosting on heteroscedastic
additive models. <code>crch.stabsel</code> is a wrapper around the core <code><a href="#topic+crch.boost">crch.boost</a></code>
algorithm to perform stability selection (see references).
</p>
<p>Half of the data set (<code>data</code>) is sampled <code>B</code> times to perform boosting
(based on <code><a href="#topic+crch.boost">crch.boost</a></code>). Rather than perform the boosting iterations
until a certain stopping criterion is reached (e.g., maximum number of iterations
<code>maxit</code>) the algorithm stops as soon as <code>q</code> parameters have been selected.
The number of parameters is computed across both parameters location and scale.
Intercepts are not counted.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"stabsel.crch"</code> containing the stability
selection summary and the new formula based on the stability selection.
</p>
<table>
<tr><td><code>table</code></td>
<td>
<p>A table object containing the parameters which have been
selected and the corresponding frequency of selection.</p>
</td></tr>
<tr><td><code>formula.org</code></td>
<td>
<p>Original formula used to perform the stability selection.</p>
</td></tr>
<tr><td><code>formula.new</code></td>
<td>
<p>New formula based including the coefficients selected during
stability selection.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>A list object which contains the distribution-specification from
the <code>crch.stabsel</code> call including: <code>dist</code>, <code>cens</code>, and <code>truncated</code>.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>List with the parameters used to perform the stability selection
including <code>q</code>, <code>B</code>, <code>thr</code>, <code>p</code>, and <code>PFER</code> (per-family error rate).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Meinhausen N, Buehlmann P (2010). Stability selection.
<em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, <b>72</b>(4),
417&ndash;473. doi: <a href="https://doi.org/10.1111/j.1467-9868.2010.00740.x">10.1111/j.1467-9868.2010.00740.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crch">crch</a></code>, <code><a href="#topic+crch.boost">crch.boost</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate data
suppressWarnings(RNGversion("3.5.0"))
set.seed(5)
x &lt;- matrix(rnorm(1000*20),1000,20)
y &lt;- rnorm(1000, 1 + x[,1] - 1.5 * x[,2], exp(-1 + 0.3*x[,3]))
y &lt;- pmax(0, y)
data &lt;- data.frame(cbind(y, x))

# fit model with maximum likelihood
CRCH1 &lt;- crch(y ~ .|., data = data, dist = "gaussian", left = 0)

# Perform stability selection
stabsel &lt;- crch.stabsel(y ~ .|.,  data = data, dist = "gaussian", left = 0,
           q = 8, B = 5)

# Show stability selection summary
print(stabsel); plot(stabsel)

CRCH2 &lt;- crch(stabsel$formula.new, data = data, dist = "gaussian", left = 0 )
BOOST &lt;- crch(stabsel$formula.new, data = data, dist = "gaussian", left = 0,
              control = crch.boost() )

### AIC comparison
sapply( list(CRCH1,CRCH2,BOOST), logLik )
</code></pre>

<hr>
<h2 id='ct'>The Censored Student-t Distribution</h2><span id='topic+dct'></span><span id='topic+pct'></span><span id='topic+qct'></span><span id='topic+rct'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation
for the left and/or right censored student-t distribution with <code>df</code>
degrees of freedom.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dct(x, location = 0, scale = 1, df, left = -Inf, right = Inf, log = FALSE)

pct(q, location = 0, scale = 1, df, left = -Inf, right = Inf, 
  lower.tail = TRUE, log.p = FALSE)

qct(p, location = 0, scale = 1, df, left = -Inf, right = Inf, 
  lower.tail = TRUE, log.p = FALSE)

rct(n, location = 0, scale = 1, df, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ct_+3A_x">x</code>, <code id="ct_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ct_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ct_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="ct_+3A_location">location</code></td>
<td>
<p>location parameter.</p>
</td></tr>
<tr><td><code id="ct_+3A_scale">scale</code></td>
<td>
<p>scale parameter.</p>
</td></tr>
<tr><td><code id="ct_+3A_df">df</code></td>
<td>
<p>degrees of freedom (&gt; 0, maybe non-integer).  <code>df = Inf</code> is
allowed.</p>
</td></tr>
<tr><td><code id="ct_+3A_left">left</code></td>
<td>
<p>left censoring point.</p>
</td></tr>
<tr><td><code id="ct_+3A_right">right</code></td>
<td>
<p>right censoring point.</p>
</td></tr>
<tr><td><code id="ct_+3A_log">log</code>, <code id="ct_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ct_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x]
otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>location</code> or <code>scale</code> are not specified they assume the default values
of <code>0</code> and <code>1</code>, respectively. <code>left</code> and <code>right</code> have the defaults <code>-Inf</code> and <code>Inf</code> respectively.
</p>
<p>The censored student-t distribution has density <code class="reqn">f(x)</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">T((left - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \le left</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">1 - T((right - \mu)/\sigma)</code> </td><td style="text-align: left;"> if <code class="reqn">x \ge right</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\tau((x - \mu)/\sigma)/\sigma</code> </td><td style="text-align: left;"> if <code class="reqn">left &lt; x &lt; right</code>
</td>
</tr>

</table>

<p>where <code class="reqn">T</code> and <code class="reqn">\tau</code> are the cumulative distribution function
and probability density function of the student-t distribution with
<code>df</code> degrees of freedom respectively, <code class="reqn">\mu</code> is the location of the
distribution, and <code class="reqn">\sigma</code> the scale.
</p>


<h3>Value</h3>

<p><code>dct</code> gives the density, <code>pct</code> gives the distribution
function, <code>qct</code> gives the quantile function, and <code>rct</code>
generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dt">dt</a></code></p>

<hr>
<h2 id='hxlr'>Heteroscedastic Extended Logistic Regression</h2><span id='topic+hxlr'></span>

<h3>Description</h3>

<p>This is a wrapper function for <code><a href="ordinal.html#topic+clm">clm</a></code> (from package
<span class="pkg">ordinal</span>) to fit (heteroscedastic) extended logistic regression (HXLR)
models (Messner et al. 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hxlr(formula, data, subset, na.action, weights, thresholds, link, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hxlr_+3A_formula">formula</code></td>
<td>
<p>a formula expression of the form <code>y ~ x | z</code> where
<code>y</code> is the response and <code>x</code> and <code>z</code> are regressor variables
for the location and the scale of the latend distribution respectively.
Response can either be a continuous variable or a factor.</p>
</td></tr>
<tr><td><code id="hxlr_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables occurring in the
formulas.</p>
</td></tr>
<tr><td><code id="hxlr_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used for fitting.</p>
</td></tr>
<tr><td><code id="hxlr_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s. Default is na.omit</p>
</td></tr>
<tr><td><code id="hxlr_+3A_weights">weights</code></td>
<td>
<p>optional case weights in fitting.</p>
</td></tr>
<tr><td><code id="hxlr_+3A_thresholds">thresholds</code></td>
<td>
<p>vector of (transformed) thresholds that are used to cut the
continuous response into categories. Data frames or matrices with multiple
columns are allowed as well. Then each column is used as separate predictor
variable for the intercept model.</p>
</td></tr>
<tr><td><code id="hxlr_+3A_link">link</code></td>
<td>
<p>link function, i.e., the type of location-scale distribution
assumed for the latent distribution. Default is <code>logit</code>.</p>
</td></tr>
<tr><td><code id="hxlr_+3A_control">control</code></td>
<td>
<p>a list of control parameters passed to <code><a href="stats.html#topic+optim">optim</a></code>.
Default is <code><a href="#topic+hxlr.control">hxlr.control</a></code></p>
</td></tr>
<tr><td><code id="hxlr_+3A_...">...</code></td>
<td>
<p>arguments to be used to form the default <code>control</code> argument
if it is not supplied directly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extended logistic regression (Wilks 2009) extends binary logistic regression to
multi-category responses by including the thresholds, that are used to cut a
continuous variable into categories, in the regression equation.
Heteroscedastic extended logistic regression (Messner et al. 2013) extends this
model further and allows to add additional predictor variables that are used to
predict the scale of the latent logistic distribution.
</p>


<h3>Value</h3>

<p>An object of class <code>"hxlr"</code>, i.e., a list with the following elements.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>list of CLM coefficients for intercept, location,
and scale model.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>list of fitted location and scale parameters.</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>output from optimization from <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Optimization method used for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>list of control parameters passed to <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>starting values of coefficients used in the optimization.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>case weights used for fitting.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical variable whether optimization has converged or not.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations in optimization.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> objects used.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>list of levels of the factors used in fitting for location and
scale respectively.</p>
</td></tr>
<tr><td><code>thresholds</code></td>
<td>
<p>the thresholds supplied.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Messner JW, Mayr GJ, Zeileis A, Wilks DS (2014). Extending Extended Logistic
Regression to Effectively Utilize the Ensemble Spread. <em>Monthly Weather
Review</em>, <b>142</b>, 448&ndash;456. doi: <a href="https://doi.org/10.1175/MWR-D-13-00271.1">10.1175/MWR-D-13-00271.1</a>.
</p>
<p>Wilks DS (2009).  Extending Logistic Regression to Provide
Full-Probability-Distribution MOS Forecasts.
<em>Meteorological Applications</em>, <b>368</b>, 361&ndash;368.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.hxlr">predict.hxlr</a></code>, <code><a href="ordinal.html#topic+clm">clm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("RainIbk")
## mean and standard deviation of square root transformed ensemble forecasts
RainIbk$sqrtensmean &lt;- 
  apply(sqrt(RainIbk[,grep('^rainfc',names(RainIbk))]), 1, mean)
RainIbk$sqrtenssd &lt;- 
  apply(sqrt(RainIbk[,grep('^rainfc',names(RainIbk))]), 1, sd)

## climatological deciles
q &lt;- unique(quantile(RainIbk$rain, seq(0.1, 0.9, 0.1)))

## fit ordinary extended logistic regression with ensemble mean as 
## predictor variable
XLR &lt;- hxlr(sqrt(rain) ~ sqrtensmean, data = RainIbk, thresholds = sqrt(q))
## print
XLR
## summary
summary(XLR)


## fit ordinary extended logistic regression with ensemble mean 
## and standard deviation as predictor variables
XLRS &lt;- hxlr(sqrt(rain) ~ sqrtensmean + sqrtenssd, data = RainIbk, 
  thresholds = sqrt(q))
## fit heteroscedastic extended logistic regression with ensemble 
## standard deviation as predictor for the scale
HXLR &lt;- hxlr(sqrt(rain) ~ sqrtensmean | sqrtenssd, data = RainIbk, 
  thresholds = sqrt(q))

## compare AIC of different models
AIC(XLR, XLRS, HXLR)

## XLRS and HXLR are nested in XLR -&gt; likelihood-ratio-tests
if(require("lmtest")) {
  lrtest(XLR, XLRS)
  lrtest(XLR, HXLR)
}

## Not run: 
###################################################################
## Cross-validation and bootstrapping RPS for different models 
## (like in Messner 2013). 
N &lt;- NROW(RainIbk)
## function that returns model fits
fits &lt;- function(data, weights = rep(1, N)) {
  list(
    "XLR"    = hxlr(sqrt(rain) ~ sqrtensmean, data = data, 
      weights = weights, thresholds = sqrt(q)),
    "XLR:S"  = hxlr(sqrt(rain) ~ sqrtensmean + sqrtenssd, data = data, 
      weights = weights, thresholds = sqrt(q)),
    "XLR:SM" = hxlr(sqrt(rain) ~ sqrtensmean + I(sqrtensmean*sqrtenssd), 
      data = data, weights = weights, thresholds = sqrt(q)),
    "HXLR"   = hxlr(sqrt(rain) ~ sqrtensmean | sqrtenssd, data = data, 
      weights = weights, thresholds = sqrt(q)),
    "HXLR:S" = hxlr(sqrt(rain) ~ sqrtensmean + sqrtenssd | sqrtenssd, 
      data = data, weights = weights, thresholds = sqrt(q))
  )
}


## cross validation
id &lt;- sample(1:10, N, replace = TRUE)
obs &lt;- NULL
pred &lt;- list(NULL)
for(i in 1:10) {
  ## splitting into test and training data set
  trainIndex &lt;- which(id != i)     
  testIndex &lt;- which(id == i)			     
  ## weights that are used for fitting the models
  weights &lt;- as.numeric(table(factor(trainIndex, levels = c(1:N))))
  ## testdata
  testdata &lt;- RainIbk[testIndex,]
  ## observations    
  obs &lt;- c(obs, RainIbk$rain[testIndex])
  ## estimation
  modelfits &lt;- fits(RainIbk, weights)
  ## Prediction
  pred2 &lt;- lapply(modelfits, predict, newdata = testdata, type = "cumprob")
  pred &lt;- mapply(rbind, pred, pred2, SIMPLIFY = FALSE)
}
names(pred) &lt;- c(names(modelfits))

## function to compute RPS
rps &lt;- function(pred, obs) {
  OBS &lt;- NULL
  for(i in 1:N) 
    OBS &lt;- rbind(OBS, rep(0:1, c(obs[i] - 1, length(q) - obs[i] + 1)))
  apply((OBS-pred)^2, 1, sum)
}

## compute rps
RPS &lt;- lapply(pred, rps, obs = as.numeric(cut(obs, c(-Inf, q, Inf))))

## bootstrapping mean rps 
rpsall &lt;- NULL
for(i in 1:250) {
  index &lt;- sample(length(obs), replace = TRUE)
  rpsall &lt;- rbind(rpsall, sapply(RPS, function(x) mean(x[index])))
}
  
rpssall &lt;- 1 - rpsall/rpsall[,1]
boxplot(rpssall[,-1], ylab = "RPSS", main = "RPSS relative to XLR")
abline(h = 0, lty = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='hxlr.control'>Auxiliary Function for Controlling HXLR Fitting</h2><span id='topic+hxlr.control'></span>

<h3>Description</h3>

<p>Auxiliary function for <code>hxlr</code> fitting. Specifies a list of values passed
to <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hxlr.control(method = "BFGS", maxit = 5000, hessian = TRUE, 
  trace = FALSE, start = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hxlr.control_+3A_method">method</code></td>
<td>
<p>optimization method used in <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="hxlr.control_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="hxlr.control_+3A_hessian">hessian</code></td>
<td>
<p>logical. Should a numerically differentiated Hessian matrix be
returned?</p>
</td></tr>
<tr><td><code id="hxlr.control_+3A_trace">trace</code></td>
<td>
<p>non-negative integer. If positive, tracing information on the
progress of the optimization is produced.</p>
</td></tr>
<tr><td><code id="hxlr.control_+3A_start">start</code></td>
<td>
<p>initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="hxlr.control_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="stats.html#topic+optim">optim</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hxlr">hxlr</a></code>, <code><a href="stats.html#topic+optim">optim</a></code></p>

<hr>
<h2 id='plot.crch.boost'>Plot coefficient paths of boosted CRCH objects.</h2><span id='topic+plot.crch.boost'></span>

<h3>Description</h3>

<p>Plot paths of coefficients or log-likelihood contributions for <code>crch.boost</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crch.boost'
plot(x, loglik = FALSE, 
  standardize = TRUE, which = c("both", "location", "scale"), 
  mstop = NULL, coef.label = TRUE, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.crch.boost_+3A_x">x</code></td>
<td>
<p>an object of class <code>"crch.boost"</code>.</p>
</td></tr>
<tr><td><code id="plot.crch.boost_+3A_loglik">loglik</code></td>
<td>
<p>logical whether log-likelihood contribution shall be plotted
instead of coefficient value.</p>
</td></tr>
<tr><td><code id="plot.crch.boost_+3A_standardize">standardize</code></td>
<td>
<p>logical whether coefficients shall be standardized.
Not used if <code>loglik = TRUE</code> </p>
</td></tr>
<tr><td><code id="plot.crch.boost_+3A_which">which</code></td>
<td>
<p>which coefficients: <code>"location"</code> and <code>"scale"</code> plots
only the coefficients for the location and scale part of the model 
respectively. <code>"both"</code> plots the coefficient paths of both parts in one
graph.</p>
</td></tr>
<tr><td><code id="plot.crch.boost_+3A_mstop">mstop</code></td>
<td>
<p>Stopping iteration for which a vertical line is plotted. 
Possible choices are <code>"max"</code>, <code>"aic"</code>, <code>"bic"</code>, 
<code>"cv"</code>, <code>"all"</code>, or <code>"no"</code>. Default is the stopping iteration
used for fitting.</p>
</td></tr>
<tr><td><code id="plot.crch.boost_+3A_coef.label">coef.label</code></td>
<td>
<p>logical whether paths shall be labeled.</p>
</td></tr>
<tr><td><code id="plot.crch.boost_+3A_col">col</code></td>
<td>
<p>Color(s) for the paths. If <code>which="both"</code> a vector of 
two colors where the paths for the location are plotted in the first
color and for the scale in the second color.</p>
</td></tr>
<tr><td><code id="plot.crch.boost_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+plot.ts">plot.ts</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+crch.boost">crch.boost</a></code>,<code><a href="stats.html#topic+plot.ts">plot.ts</a></code></p>

<hr>
<h2 id='predict.crch'>Predicted/Fitted Values for CRCH Fits</h2><span id='topic+predict.crch'></span><span id='topic+prodist.crch'></span>

<h3>Description</h3>

<p>Obtains various types of predictions for <code>crch</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crch'
predict(object, newdata = NULL, type = c("location", "scale", 
  "response", "parameter", "density", "probability", "quantile", "crps"), 
  na.action = na.pass, at = 0.5, left = NULL, right = NULL, ...)

## S3 method for class 'crch'
prodist(object, newdata = NULL, na.action = na.pass,
  left = NULL, right = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.crch_+3A_object">object</code></td>
<td>
<p>an object of class <code>"crch"</code>.</p>
</td></tr>
<tr><td><code id="predict.crch_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables with
which to predict.</p>
</td></tr>
<tr><td><code id="predict.crch_+3A_type">type</code></td>
<td>
<p>type of prediction: <code>"location"</code> returns the location of 
the predicted distribution.
<code>"scale"</code> returns the scale of the predicted distribution.
<code>"response"</code> returns the expected value of the predicted distribution
(not equal to location for censored and truncated distributions).
<code>"parameter"</code> returns a data frame with predicted location and scale 
parameters.
<code>"density"</code> evaluates the predictive density at <code>at</code>.
<code>"probability"</code> evaluates the predictive CDF at <code>at</code>.
<code>"quantile"</code> returns a matrix of predicted quantiles with quantile
probabilities <code>at</code>.
<code>"crps"</code> returns the CRPS of the predictive distributions at <code>at</code>.</p>
</td></tr>
<tr><td><code id="predict.crch_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s. Default is na.pass</p>
</td></tr>
<tr><td><code id="predict.crch_+3A_at">at</code></td>
<td>
<p>a vector of values to evaluate the predictive density (<code>type =
  "density"</code>), probability (<code>type = "probability"</code>), or CRPS (<code>type =
  "crps"</code>) or a vector of quantile probabilities used for <code>type =
  "quantile"</code>.
Alternatively, with <code>at = "function"</code> a function is returned that 
takes <code>at</code> as an argument.</p>
</td></tr>
<tr><td><code id="predict.crch_+3A_left">left</code></td>
<td>
<p>left censoring or truncation point. Only used for <code>type = "quantile"</code>.
If NULL, censoring or truncation point is obtained from <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.crch_+3A_right">right</code></td>
<td>
<p>right censoring or truncation point. Only used for <code>type = "quantile"</code>.
If NULL, censoring or truncation point is obtained from <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.crch_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>predict</code> method, for type <code>"response"</code>, <code>"location"</code>, or <code>"scale"</code>,
returns a vector with either the location or the scale of the predicted distribution.
For type <code>"quantile"</code> a matrix of predicted quantiles each column
corresponding to an element of <code>at</code>.
</p>
<p>The <code>prodist</code> method returns the fitted/predict probability distribution object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crch">crch</a></code>, <code><a href="distributions3.html#topic+prodist">prodist</a></code></p>

<hr>
<h2 id='predict.crch.boost'>Predicted/Fitted Values for boosted CRCH Fits</h2><span id='topic+predict.crch.boost'></span>

<h3>Description</h3>

<p>Obtains various types of predictions for <code>crch.boost</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crch.boost'
predict(object, newdata = NULL, mstop = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.crch.boost_+3A_object">object</code></td>
<td>
<p>an object of class <code>"crch.boost"</code>.</p>
</td></tr>
<tr><td><code id="predict.crch.boost_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables with
which to predict.</p>
</td></tr>
<tr><td><code id="predict.crch.boost_+3A_mstop">mstop</code></td>
<td>
<p>stopping iteration. Can be either a character (<code>"max"</code>, 
<code>"aic"</code>, <code>"bic"</code>, <code>"cv"</code>) or a numeric value. If not <code>NULL</code>,
newdata has to be supplied.</p>
</td></tr>
<tr><td><code id="predict.crch.boost_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For type <code>"response"</code>, <code>"location"</code>, or <code>"scale"</code> a vector with
either the location or the scale of the predicted distribution.
</p>
<p>For type <code>"quantile"</code> a matrix of predicted quantiles each column
corresponding to an element of <code>at</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crch.boost">crch.boost</a></code>,<code><a href="#topic+predict.crch">predict.crch</a></code></p>

<hr>
<h2 id='predict.hxlr'>Predict/Fitted Values for HXLR Fits</h2><span id='topic+predict.hxlr'></span><span id='topic+fitted.hxlr'></span>

<h3>Description</h3>

<p>Obtains various types of predictions/fitted values for heteroscedastic
extended logistic regression (HXLR) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hxlr'
predict(object, newdata = NULL, type = c("class", "probability",
  "cumprob", "location", "scale"), thresholds = object$thresholds,
  na.action = na.pass, ...)
## S3 method for class 'hxlr'
fitted(object, type = c("class", "probability", 
  "cumprob", "location", "scale"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hxlr_+3A_object">object</code></td>
<td>
<p>an object of class <code>"hxlr"</code>.</p>
</td></tr>
<tr><td><code id="predict.hxlr_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables with
which to predict.</p>
</td></tr>
<tr><td><code id="predict.hxlr_+3A_type">type</code></td>
<td>
<p>type of prediction: <code>"probability"</code> returns a data frame
with category probabilities, <code>"cumprob"</code> returns cumulative
probabilities, <code>"location"</code> and <code>"scale"</code> return the location and
scale of the predicted latent distribution respectively, and <code>"class"</code>
returns the category with the highest probability. Default is
<code>"class"</code>.</p>
</td></tr>
<tr><td><code id="predict.hxlr_+3A_thresholds">thresholds</code></td>
<td>
<p>optional thresholds used for defining the thresholds for
types <code>"probability"</code>, <code>"cumprob"</code>, and <code>"class"</code>.  Can differ
from thresholds used for fitting. If omitted, the same thresholds as for
fitting are used.</p>
</td></tr>
<tr><td><code id="predict.hxlr_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain <code>NA</code>s. Default is na.pass</p>
</td></tr>
<tr><td><code id="predict.hxlr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For type <code>"prob"</code> a matrix with number of intervals (= number of
thresholds + 1) columns is produced. Each row corresponds to a row in newdata
and contains the predicted probabilities to fall in the corresponding interval.
</p>
<p>For type <code>"cumprob"</code> a matrix with number of thresholds columns is
produced. Each row corresponds to a row in <code>newdata</code> and contains the
predicted probabilities to fall below the corresponding threshold.
</p>
<p>For types <code>"class"</code>, <code>"location"</code>, and <code>"scale"</code> a vector is
returned respectively with either the most probable categories (<code>"class"</code>)
or the location (<code>"location"</code>) or scale (<code>scale</code>) of the latent
distribution. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hxlr">hxlr</a></code></p>

<hr>
<h2 id='RainIbk'>Precipitation Observations and Forecasts for Innsbruck</h2><span id='topic+RainIbk'></span>

<h3>Description</h3>

<p>Accumulated 5-8 days precipitation amount for Innsbruck. Data includes GEFS
reforecasts (Hamill et al. 2013) and observations from SYNOP station Innsbruck
Airport (11120) from 2000-01-01 to 2013-09-17.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("RainIbk")</code></pre>


<h3>Format</h3>

<p>A data frame with 4977 rows. The first column (<code>rain</code>) are 3 days
accumulated precipitation amount observations, Columns 2-12 (<code>rainfc</code>)
are 5-8 days accumulated precipitation amount forecasts from the individual
ensemble members.
</p>


<h3>Source</h3>

<p>Observations: http://www.ogimet.com/synops.phtml.en
</p>
<p>Reforecasts: http://www.esrl.noaa.gov/psd/forecasts/reforecast2/
</p>


<h3>References</h3>

<p>Hamill TM, Bates GT, Whitaker JS, Murray DR, Fiorino M, Galarneau Jr TJ,
Zhu Y, Lapenta W (2013). NOAA's Second-Generation Global Medium-Range
Ensemble Reforecast Data Set. <em>Bulletin of the American Meteorological
Society</em>, 94(10), 1553-1565.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Spread skill relationship ##

## load and prepare data
data(RainIbk)

## mean and standard deviation of square root transformed ensemble forecasts
RainIbk$sqrtensmean &lt;- 
  apply(sqrt(RainIbk[,grep('^rainfc',names(RainIbk))]), 1, mean)
RainIbk$sqrtenssd &lt;- 
  apply(sqrt(RainIbk[,grep('^rainfc',names(RainIbk))]),  1, sd)

## quintiles of sqrtenssd
sdcat &lt;- cut(RainIbk$sqrtenssd, c(-Inf, quantile(RainIbk$sqrtenssd, 
  seq(0.2,0.8,0.2)), Inf), labels = c(1:5))

## mean forecast errors for each quintile
m &lt;- NULL
for(i in levels(sdcat)) {
  m &lt;- c(m, mean((sqrt(RainIbk$rain)[sdcat == i] -
  RainIbk$sqrtensmean[sdcat == i])^2, na.rm = TRUE))
}

## plot
boxplot((sqrt(rain) - sqrtensmean)^2~sdcat, RainIbk, 
  xlab = "Quintile of ensemble standard deviation", 
  ylab = "mean squared error", main = "Spread skill relationship")

</code></pre>

<hr>
<h2 id='tlogis'>The Truncated Logistic Distribution</h2><span id='topic+dtlogis'></span><span id='topic+ptlogis'></span><span id='topic+qtlogis'></span><span id='topic+rtlogis'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation
for the left and/or right truncated logistic distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtlogis(x, location = 0, scale = 1, left = -Inf, right = Inf, log = FALSE)

ptlogis(q, location = 0, scale = 1, left = -Inf, right = Inf,
  lower.tail = TRUE, log.p = FALSE)

qtlogis(p, location = 0, scale = 1, left = -Inf, right = Inf, 
  lower.tail = TRUE, log.p = FALSE)

rtlogis(n, location = 0, scale = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tlogis_+3A_x">x</code>, <code id="tlogis_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="tlogis_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="tlogis_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="tlogis_+3A_location">location</code></td>
<td>
<p>location parameter.</p>
</td></tr>
<tr><td><code id="tlogis_+3A_scale">scale</code></td>
<td>
<p>scale parameter.</p>
</td></tr>
<tr><td><code id="tlogis_+3A_left">left</code></td>
<td>
<p>left truncation point.</p>
</td></tr>
<tr><td><code id="tlogis_+3A_right">right</code></td>
<td>
<p>right truncation point.</p>
</td></tr>
<tr><td><code id="tlogis_+3A_log">log</code>, <code id="tlogis_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="tlogis_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x]
otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>location</code> or <code>scale</code> are not specified they assume the default values
of <code>0</code> and <code>1</code>, respectively. <code>left</code> and <code>right</code> have the defaults <code>-Inf</code> and <code>Inf</code> respectively.
</p>
<p>The truncated logistic distribution has density 
</p>
<p style="text-align: center;"><code class="reqn">f(x) = 1/\sigma \lambda((x - \mu)/\sigma) / (\Lambda((right - \mu)/\sigma) - \Lambda((left - \mu)/\sigma))</code>
</p>

<p>for <code class="reqn">left \le x \le right</code>, and 0 otherwise.
</p>
<p><code class="reqn">\Lambda</code> and <code class="reqn">\lambda</code> are the cumulative distribution function
and probability density function of the standard logistic distribution
respectively, <code class="reqn">\mu</code> is the location of the distribution, and <code class="reqn">\sigma</code> 
the scale.
</p>


<h3>Value</h3>

<p><code>dtlogis</code> gives the density, <code>ptlogis</code> gives the distribution
function, <code>qtlogis</code> gives the quantile function, and <code>rtlogis</code>
generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dlogis">dlogis</a></code></p>

<hr>
<h2 id='tnorm'>The Truncated Normal Distribution</h2><span id='topic+dtnorm'></span><span id='topic+ptnorm'></span><span id='topic+qtnorm'></span><span id='topic+rtnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation
for the left and/or right truncated normal distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtnorm(x, mean = 0, sd = 1, left = -Inf, right = Inf, log = FALSE)

ptnorm(q, mean = 0, sd = 1, left = -Inf, right = Inf, 
  lower.tail = TRUE, log.p = FALSE)

qtnorm(p, mean = 0, sd = 1, left = -Inf, right = Inf, 
  lower.tail = TRUE, log.p = FALSE)

rtnorm(n, mean = 0, sd = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnorm_+3A_x">x</code>, <code id="tnorm_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_left">left</code></td>
<td>
<p>left censoring point.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_right">right</code></td>
<td>
<p>right censoring point.</p>
</td></tr>
<tr><td><code id="tnorm_+3A_log">log</code>, <code id="tnorm_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="tnorm_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x]
otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mean</code> or <code>sd</code> are not specified they assume the default values
of <code>0</code> and <code>1</code>, respectively. <code>left</code> and <code>right</code> have the defaults <code>-Inf</code> and <code>Inf</code> respectively.
</p>
<p>The truncated normal distribution has density
</p>
<p style="text-align: center;"><code class="reqn">f(x) = 1/\sigma \phi((x - \mu)/\sigma) / 
  (\Phi((right - \mu)/\sigma) - \Phi((left - \mu)/\sigma))</code>
</p>

<p>for <code class="reqn">left \le x \le right</code>, and 0 otherwise.
</p>
<p><code class="reqn">\Phi</code> and <code class="reqn">\phi</code> are the cumulative distribution function
and probability density function of the standard normal distribution
respectively, <code class="reqn">\mu</code> is the mean of the distribution, and <code class="reqn">\sigma</code> 
the standard deviation.
</p>


<h3>Value</h3>

<p><code>dtnorm</code> gives the density, <code>ptnorm</code> gives the distribution
function, <code>qtnorm</code> gives the quantile function, and <code>rtnorm</code>
generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code></p>

<hr>
<h2 id='TruncatedLogistic'>Create a Truncated Logistic Distribution</h2><span id='topic+TruncatedLogistic'></span><span id='topic+mean.TruncatedLogistic'></span><span id='topic+variance.TruncatedLogistic'></span><span id='topic+skewness.TruncatedLogistic'></span><span id='topic+kurtosis.TruncatedLogistic'></span><span id='topic+pdf.TruncatedLogistic'></span><span id='topic+log_pdf.TruncatedLogistic'></span><span id='topic+cdf.TruncatedLogistic'></span><span id='topic+quantile.TruncatedLogistic'></span><span id='topic+random.TruncatedLogistic'></span><span id='topic+crps.TruncatedLogistic'></span><span id='topic+support.TruncatedLogistic'></span><span id='topic+is_discrete.TruncatedLogistic'></span><span id='topic+is_continuous.TruncatedLogistic'></span>

<h3>Description</h3>

<p>Class and methods for left-, right-, and interval-truncated logistic
distributions using the workflow from the <span class="pkg">distributions3</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TruncatedLogistic(location = 0, scale = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TruncatedLogistic_+3A_location">location</code></td>
<td>
<p>numeric. The location parameter of the underlying <em>untruncated</em>
logistic distribution, typically written <code class="reqn">\mu</code> in textbooks.
Can be any real number, defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="TruncatedLogistic_+3A_scale">scale</code></td>
<td>
<p>numeric. The scale parameter (standard deviation) of
the underlying <em>untruncated</em> logistic distribution,
typically written <code class="reqn">\sigma</code> in textbooks.
Can be any positive number, defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="TruncatedLogistic_+3A_left">left</code></td>
<td>
<p>numeric. The left truncation point. Can be any real number,
defaults to <code>-Inf</code> (untruncated). If set to a finite value, the
distribution has a point mass at <code>left</code> whose probability corresponds
to the cumulative probability function of the <em>untruncated</em>
logistic distribution at this point.</p>
</td></tr>
<tr><td><code id="TruncatedLogistic_+3A_right">right</code></td>
<td>
<p>numeric. The right truncation point. Can be any real number,
defaults to <code>Inf</code> (untruncated). If set to a finite value, the
distribution has a point mass at <code>right</code> whose probability corresponds
to 1 minus the cumulative probability function of the <em>untruncated</em>
logistic distribution at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor function <code>TruncatedLogistic</code> sets up a distribution
object, representing the truncated logistic probability distribution by the
corresponding parameters: the latent mean <code>location</code> = <code class="reqn">\mu</code> and
latent standard deviation <code>scale</code> = <code class="reqn">\sigma</code> (i.e., the parameters
of the underlying <em>untruncated</em> logistic variable), the <code>left</code> truncation
point (with <code>-Inf</code> corresponding to untruncated), and the
<code>right</code> truncation point (with <code>Inf</code> corresponding to untruncated). 
</p>
<p>The truncated logistic distribution has probability density function (PDF):
</p>
<p style="text-align: center;"><code class="reqn">f(x) = 1/\sigma \lambda((x - \mu)/\sigma) / (\Lambda((right - \mu)/\sigma) - \Lambda((left - \mu)/\sigma))</code>
</p>

<p>for <code class="reqn">left \le x \le right</code>, and 0 otherwise,
where <code class="reqn">\Lambda</code> and <code class="reqn">\lambda</code> are the cumulative distribution function
and probability density function of the standard logistic distribution,
respectively.
</p>
<p>All parameters can also be vectors, so that it is possible to define a vector
of truncated logistic distributions with potentially different parameters.
All parameters need to have the same length or must be scalars (i.e.,
of length 1) which are then recycled to the length of the other parameters.
</p>
<p>For the <code>TruncatedLogistic</code> distribution objects there is a wide range
of standard methods available to the generics provided in the <span class="pkg">distributions3</span>
package: <code><a href="distributions3.html#topic+pdf">pdf</a></code> and <code><a href="distributions3.html#topic+log_pdf">log_pdf</a></code>
for the (log-)density (PDF), <code><a href="distributions3.html#topic+cdf">cdf</a></code> for the probability
from the cumulative distribution function (CDF), <code>quantile</code> for quantiles,
<code><a href="distributions3.html#topic+random">random</a></code> for simulating random variables,
<code><a href="scoringRules.html#topic+crps">crps</a></code> for the continuous ranked probability score
(CRPS), and <code><a href="distributions3.html#topic+support">support</a></code> for the support interval
(minimum and maximum). Internally, these methods rely on the usual d/p/q/r
functions provided for the truncated logistic distributions in the <span class="pkg">crch</span>
package, see <code><a href="#topic+dtlogis">dtlogis</a></code>, and the <code><a href="scoringRules.html#topic+crps_tlogis">crps_tlogis</a></code>
function from the <span class="pkg">scoringRules</span> package.
The methods <code><a href="distributions3.html#topic+is_discrete">is_discrete</a></code> and <code><a href="distributions3.html#topic+is_continuous">is_continuous</a></code>
can be used to query whether the distributions are discrete on the entire support
(always <code>FALSE</code>) or continuous on the entire support (always <code>TRUE</code>).
</p>
<p>See the examples below for an illustration of the workflow for the class and methods.
</p>


<h3>Value</h3>

<p>A <code>TruncatedLogistic</code> distribution object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtlogis">dtlogis</a></code>, <code><a href="distributions3.html#topic+Logistic">Logistic</a></code>, <code><a href="#topic+CensoredLogistic">CensoredLogistic</a></code>,
<code><a href="#topic+TruncatedNormal">TruncatedNormal</a></code>, <code><a href="#topic+TruncatedStudentsT">TruncatedStudentsT</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## package and random seed
library("distributions3")
set.seed(6020)

## three truncated logistic distributions:
## - untruncated standard logistic
## - left-truncated at zero with latent location = 1 and scale = 1
## - interval-truncated in [0, 5] with latent location = 2 and scale = 1
X &lt;- TruncatedLogistic(
  location = c(   0,   1, 2),
  scale    = c(   1,   1, 1),
  left     = c(-Inf,   0, 0),
  right    = c( Inf, Inf, 5)
)
X

## compute mean of the truncated distribution
mean(X)
## higher moments (variance, skewness, kurtosis) are not implemented yet

## support interval (minimum and maximum)
support(X)

## simulate random variables
random(X, 5)

## histograms of 1,000 simulated observations
x &lt;- random(X, 1000)
hist(x[1, ], main = "untruncated")
hist(x[2, ], main = "left-truncated at zero")
hist(x[3, ], main = "interval-truncated in [0, 5]")

## probability density function (PDF) and log-density (or log-likelihood)
x &lt;- c(0, 0, 1)
pdf(X, x)
pdf(X, x, log = TRUE)
log_pdf(X, x)

## cumulative distribution function (CDF)
cdf(X, x)

## quantiles
quantile(X, 0.5)

## cdf() and quantile() are inverses (except at truncation points)
cdf(X, quantile(X, 0.5))
quantile(X, cdf(X, 1))

## all methods above can either be applied elementwise or for
## all combinations of X and x, if length(X) = length(x),
## also the result can be assured to be a matrix via drop = FALSE
p &lt;- c(0.05, 0.5, 0.95)
quantile(X, p, elementwise = FALSE)
quantile(X, p, elementwise = TRUE)
quantile(X, p, elementwise = TRUE, drop = FALSE)

## compare theoretical and empirical mean from 1,000 simulated observations
cbind(
  "theoretical" = mean(X),
  "empirical" = rowMeans(random(X, 1000))
)

## evaluate continuous ranked probability score (CRPS) using scoringRules
library("scoringRules")
crps(X, x)
</code></pre>

<hr>
<h2 id='TruncatedNormal'>Create a Truncated Normal Distribution</h2><span id='topic+TruncatedNormal'></span><span id='topic+mean.TruncatedNormal'></span><span id='topic+variance.TruncatedNormal'></span><span id='topic+skewness.TruncatedNormal'></span><span id='topic+kurtosis.TruncatedNormal'></span><span id='topic+pdf.TruncatedNormal'></span><span id='topic+log_pdf.TruncatedNormal'></span><span id='topic+cdf.TruncatedNormal'></span><span id='topic+quantile.TruncatedNormal'></span><span id='topic+random.TruncatedNormal'></span><span id='topic+crps.TruncatedNormal'></span><span id='topic+support.TruncatedNormal'></span><span id='topic+is_discrete.TruncatedNormal'></span><span id='topic+is_continuous.TruncatedNormal'></span>

<h3>Description</h3>

<p>Class and methods for left-, right-, and interval-truncated normal
distributions using the workflow from the <span class="pkg">distributions3</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TruncatedNormal(mu = 0, sigma = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TruncatedNormal_+3A_mu">mu</code></td>
<td>
<p>numeric. The location parameter of the underlying <em>untruncated</em>
normal distribution, typically written <code class="reqn">\mu</code> in textbooks.
Can be any real number, defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="TruncatedNormal_+3A_sigma">sigma</code></td>
<td>
<p>numeric. The scale parameter (standard deviation) of
the underlying <em>untruncated</em> normal distribution,
typically written <code class="reqn">\sigma</code> in textbooks.
Can be any positive number, defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="TruncatedNormal_+3A_left">left</code></td>
<td>
<p>numeric. The left truncation point. Can be any real number,
defaults to <code>-Inf</code> (untruncated). If set to a finite value, the
distribution has a point mass at <code>left</code> whose probability corresponds
to the cumulative probability function of the <em>untruncated</em>
normal distribution at this point.</p>
</td></tr>
<tr><td><code id="TruncatedNormal_+3A_right">right</code></td>
<td>
<p>numeric. The right truncation point. Can be any real number,
defaults to <code>Inf</code> (untruncated). If set to a finite value, the
distribution has a point mass at <code>right</code> whose probability corresponds
to 1 minus the cumulative probability function of the <em>untruncated</em>
normal distribution at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor function <code>TruncatedNormal</code> sets up a distribution
object, representing the truncated normal probability distribution by the
corresponding parameters: the latent mean <code>mu</code> = <code class="reqn">\mu</code> and
latent standard deviation <code>sigma</code> = <code class="reqn">\sigma</code> (i.e., the parameters
of the underlying <em>untruncated</em> normal variable), the <code>left</code> truncation
point (with <code>-Inf</code> corresponding to untruncated), and the
<code>right</code> truncation point (with <code>Inf</code> corresponding to untruncated). 
</p>
<p>The truncated normal distribution has probability density function (PDF):
</p>
<p style="text-align: center;"><code class="reqn">f(x) = 1/\sigma \phi((x - \mu)/\sigma) / 
  (\Phi((right - \mu)/\sigma) - \Phi((left - \mu)/\sigma))</code>
</p>

<p>for <code class="reqn">left \le x \le right</code>, and 0 otherwise,
where <code class="reqn">\Phi</code> and <code class="reqn">\phi</code> are the cumulative distribution function
and probability density function of the standard normal distribution
respectively.
</p>
<p>All parameters can also be vectors, so that it is possible to define a vector
of truncated normal distributions with potentially different parameters.
All parameters need to have the same length or must be scalars (i.e.,
of length 1) which are then recycled to the length of the other parameters.
</p>
<p>For the <code>TruncatedNormal</code> distribution objects there is a wide range
of standard methods available to the generics provided in the <span class="pkg">distributions3</span>
package: <code><a href="distributions3.html#topic+pdf">pdf</a></code> and <code><a href="distributions3.html#topic+log_pdf">log_pdf</a></code>
for the (log-)density (PDF), <code><a href="distributions3.html#topic+cdf">cdf</a></code> for the probability
from the cumulative distribution function (CDF), <code>quantile</code> for quantiles,
<code><a href="distributions3.html#topic+random">random</a></code> for simulating random variables,
<code><a href="scoringRules.html#topic+crps">crps</a></code> for the continuous ranked probability score
(CRPS), and <code><a href="distributions3.html#topic+support">support</a></code> for the support interval
(minimum and maximum). Internally, these methods rely on the usual d/p/q/r
functions provided for the truncated normal distributions in the <span class="pkg">crch</span>
package, see <code><a href="#topic+dtnorm">dtnorm</a></code>, and the <code><a href="scoringRules.html#topic+crps_tnorm">crps_tnorm</a></code>
function from the <span class="pkg">scoringRules</span> package.
The methods <code><a href="distributions3.html#topic+is_discrete">is_discrete</a></code> and <code><a href="distributions3.html#topic+is_continuous">is_continuous</a></code>
can be used to query whether the distributions are discrete on the entire support
(always <code>FALSE</code>) or continuous on the entire support (always <code>TRUE</code>).
</p>
<p>See the examples below for an illustration of the workflow for the class and methods.
</p>


<h3>Value</h3>

<p>A <code>TruncatedNormal</code> distribution object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtnorm">dtnorm</a></code>, <code><a href="distributions3.html#topic+Normal">Normal</a></code>, <code><a href="#topic+CensoredNormal">CensoredNormal</a></code>,
<code><a href="#topic+TruncatedLogistic">TruncatedLogistic</a></code>, <code><a href="#topic+TruncatedStudentsT">TruncatedStudentsT</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## package and random seed
library("distributions3")
set.seed(6020)

## three truncated normal distributions:
## - untruncated standard normal
## - left-truncated at zero with latent mu = 1 and sigma = 1
## - interval-truncated in [0, 5] with latent mu = 1 and sigma = 2
X &lt;- TruncatedNormal(
  mu    = c(   0,   1, 1),
  sigma = c(   1,   1, 2),
  left  = c(-Inf,   0, 0),
  right = c( Inf, Inf, 5)
)
X

## compute mean of the truncated distribution
mean(X)
## higher moments (variance, skewness, kurtosis) are not implemented yet

## support interval (minimum and maximum)
support(X)

## simulate random variables
random(X, 5)

## histograms of 1,000 simulated observations
x &lt;- random(X, 1000)
hist(x[1, ], main = "untruncated")
hist(x[2, ], main = "left-truncated at zero")
hist(x[3, ], main = "interval-truncated in [0, 5]")

## probability density function (PDF) and log-density (or log-likelihood)
x &lt;- c(0, 0, 1)
pdf(X, x)
pdf(X, x, log = TRUE)
log_pdf(X, x)

## cumulative distribution function (CDF)
cdf(X, x)

## quantiles
quantile(X, 0.5)

## cdf() and quantile() are inverses
cdf(X, quantile(X, 0.5))
quantile(X, cdf(X, 1))

## all methods above can either be applied elementwise or for
## all combinations of X and x, if length(X) = length(x),
## also the result can be assured to be a matrix via drop = FALSE
p &lt;- c(0.05, 0.5, 0.95)
quantile(X, p, elementwise = FALSE)
quantile(X, p, elementwise = TRUE)
quantile(X, p, elementwise = TRUE, drop = FALSE)

## compare theoretical and empirical mean from 1,000 simulated observations
cbind(
  "theoretical" = mean(X),
  "empirical" = rowMeans(random(X, 1000))
)

## evaluate continuous ranked probability score (CRPS) using scoringRules
library("scoringRules")
crps(X, x)
</code></pre>

<hr>
<h2 id='TruncatedStudentsT'>Create a Truncated Student's T Distribution</h2><span id='topic+TruncatedStudentsT'></span><span id='topic+mean.TruncatedStudentsT'></span><span id='topic+variance.TruncatedStudentsT'></span><span id='topic+skewness.TruncatedStudentsT'></span><span id='topic+kurtosis.TruncatedStudentsT'></span><span id='topic+pdf.TruncatedStudentsT'></span><span id='topic+log_pdf.TruncatedStudentsT'></span><span id='topic+cdf.TruncatedStudentsT'></span><span id='topic+quantile.TruncatedStudentsT'></span><span id='topic+random.TruncatedStudentsT'></span><span id='topic+crps.TruncatedStudentsT'></span><span id='topic+support.TruncatedStudentsT'></span><span id='topic+is_discrete.TruncatedStudentsT'></span><span id='topic+is_continuous.TruncatedStudentsT'></span>

<h3>Description</h3>

<p>Class and methods for left-, right-, and interval-truncated t
distributions using the workflow from the <span class="pkg">distributions3</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TruncatedStudentsT(df, location = 0, scale = 1, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TruncatedStudentsT_+3A_df">df</code></td>
<td>
<p>numeric. The degrees of freedom of the underlying <em>untruncated</em>
t distribution. Can be any positive number, with <code>df = Inf</code> corresponding
to the normal distribution.</p>
</td></tr>
<tr><td><code id="TruncatedStudentsT_+3A_location">location</code></td>
<td>
<p>numeric. The location parameter of the underlying <em>untruncated</em>
t distribution, typically written <code class="reqn">\mu</code> in textbooks.
Can be any real number, defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="TruncatedStudentsT_+3A_scale">scale</code></td>
<td>
<p>numeric. The scale parameter (standard deviation) of
the underlying <em>untruncated</em> t distribution,
typically written <code class="reqn">\sigma</code> in textbooks.
Can be any positive number, defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="TruncatedStudentsT_+3A_left">left</code></td>
<td>
<p>numeric. The left truncation point. Can be any real number,
defaults to <code>-Inf</code> (untruncated). If set to a finite value, the
distribution has a point mass at <code>left</code> whose probability corresponds
to the cumulative probability function of the <em>untruncated</em>
t distribution at this point.</p>
</td></tr>
<tr><td><code id="TruncatedStudentsT_+3A_right">right</code></td>
<td>
<p>numeric. The right truncation point. Can be any real number,
defaults to <code>Inf</code> (untruncated). If set to a finite value, the
distribution has a point mass at <code>right</code> whose probability corresponds
to 1 minus the cumulative probability function of the <em>untruncated</em>
t distribution at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor function <code>TruncatedStudentsT</code> sets up a distribution
object, representing the truncated t probability distribution by the
corresponding parameters: the degrees of freedom <code>df</code>, the latent mean
<code>location</code> = <code class="reqn">\mu</code> and latent scale parameter <code>scale</code> = <code class="reqn">\sigma</code>
(i.e., the parameters of the underlying <em>untruncated</em> t variable),
the <code>left</code> truncation point (with <code>-Inf</code> corresponding to untruncated),
and the <code>right</code> truncation point (with <code>Inf</code> corresponding to untruncated). 
</p>
<p>The truncated t distribution has probability density function (PDF) <code class="reqn">f(x)</code>:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = 1/\sigma \tau((x - \mu)/\sigma) / 
  (T((right - \mu)/\sigma) - T((left - \mu)/\sigma))</code>
</p>

<p>for <code class="reqn">left \le x \le right</code>, and 0 otherwise,
where <code class="reqn">T</code> and <code class="reqn">\tau</code> are the cumulative distribution function
and probability density function of the standard t distribution with
<code>df</code> degrees of freedom, respectively.
</p>
<p>All parameters can also be vectors, so that it is possible to define a vector
of truncated t distributions with potentially different parameters.
All parameters need to have the same length or must be scalars (i.e.,
of length 1) which are then recycled to the length of the other parameters.
</p>
<p>For the <code>TruncatedStudentsT</code> distribution objects there is a wide range
of standard methods available to the generics provided in the <span class="pkg">distributions3</span>
package: <code><a href="distributions3.html#topic+pdf">pdf</a></code> and <code><a href="distributions3.html#topic+log_pdf">log_pdf</a></code>
for the (log-)density (PDF), <code><a href="distributions3.html#topic+cdf">cdf</a></code> for the probability
from the cumulative distribution function (CDF), <code>quantile</code> for quantiles,
<code><a href="distributions3.html#topic+random">random</a></code> for simulating random variables,
<code><a href="scoringRules.html#topic+crps">crps</a></code> for the continuous ranked probability score
(CRPS), and <code><a href="distributions3.html#topic+support">support</a></code> for the support interval
(minimum and maximum). Internally, these methods rely on the usual d/p/q/r
functions provided for the truncated t distributions in the <span class="pkg">crch</span>
package, see <code><a href="#topic+dtt">dtt</a></code>, and the <code><a href="scoringRules.html#topic+crps_tt">crps_tt</a></code>
function from the <span class="pkg">scoringRules</span> package.
The methods <code><a href="distributions3.html#topic+is_discrete">is_discrete</a></code> and <code><a href="distributions3.html#topic+is_continuous">is_continuous</a></code>
can be used to query whether the distributions are discrete on the entire support
(always <code>FALSE</code>) or continuous on the entire support (always <code>TRUE</code>).
</p>
<p>See the examples below for an illustration of the workflow for the class and methods.
</p>


<h3>Value</h3>

<p>A <code>TruncatedStudentsT</code> distribution object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtt">dtt</a></code>, <code><a href="distributions3.html#topic+StudentsT">StudentsT</a></code>, <code><a href="#topic+CensoredStudentsT">CensoredStudentsT</a></code>,
<code><a href="#topic+TruncatedNormal">TruncatedNormal</a></code>, <code><a href="#topic+TruncatedLogistic">TruncatedLogistic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## package and random seed
library("distributions3")
set.seed(6020)

## three truncated t distributions:
## - untruncated standard t with 5 degrees of freedom
## - left-truncated at zero with 5 df, latent location = 1 and scale = 1
## - interval-truncated in [0, 5] with 5 df, latent location = 2 and scale = 2
X &lt;- TruncatedStudentsT(
  df       = c(   5,   5, 5),
  location = c(   0,   1, 2),
  scale    = c(   1,   1, 2),
  left     = c(-Inf,   0, 0),
  right    = c( Inf, Inf, 5)
)
X

## compute mean of the truncated distribution
mean(X)
## higher moments (variance, skewness, kurtosis) are not implemented yet

## support interval (minimum and maximum)
support(X)

## simulate random variables
random(X, 5)

## histograms of 1,000 simulated observations
x &lt;- random(X, 1000)
hist(x[1, ], main = "untruncated")
hist(x[2, ], main = "left-truncated at zero")
hist(x[3, ], main = "interval-truncated in [0, 5]")

## probability density function (PDF) and log-density (or log-likelihood)
x &lt;- c(0, 0, 1)
pdf(X, x)
pdf(X, x, log = TRUE)
log_pdf(X, x)

## cumulative distribution function (CDF)
cdf(X, x)

## quantiles
quantile(X, 0.5)

## cdf() and quantile() are inverses (except at truncation points)
cdf(X, quantile(X, 0.5))
quantile(X, cdf(X, 1))

## all methods above can either be applied elementwise or for
## all combinations of X and x, if length(X) = length(x),
## also the result can be assured to be a matrix via drop = FALSE
p &lt;- c(0.05, 0.5, 0.95)
quantile(X, p, elementwise = FALSE)
quantile(X, p, elementwise = TRUE)
quantile(X, p, elementwise = TRUE, drop = FALSE)

## compare theoretical and empirical mean from 1,000 simulated observations
cbind(
  "theoretical" = mean(X),
  "empirical" = rowMeans(random(X, 1000))
)

## evaluate continuous ranked probability score (CRPS) using scoringRules
library("scoringRules")
crps(X, x)
</code></pre>

<hr>
<h2 id='tt'>The Truncated Student-t Distribution</h2><span id='topic+dtt'></span><span id='topic+ptt'></span><span id='topic+qtt'></span><span id='topic+rtt'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation
for the left and/or right truncated student-t distribution with <code>df</code>
degrees of freedom.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtt(x, location = 0, scale = 1, df, left = -Inf, right = Inf, log = FALSE)

ptt(q, location = 0, scale = 1, df, left = -Inf, right = Inf, 
  lower.tail = TRUE, log.p = FALSE)

qtt(p, location = 0, scale = 1, df, left = -Inf, right = Inf,
  lower.tail = TRUE, log.p = FALSE)

rtt(n, location = 0, scale = 1, df, left = -Inf, right = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tt_+3A_x">x</code>, <code id="tt_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="tt_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="tt_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="tt_+3A_location">location</code></td>
<td>
<p>location parameter.</p>
</td></tr>
<tr><td><code id="tt_+3A_scale">scale</code></td>
<td>
<p>scale parameter.</p>
</td></tr>
<tr><td><code id="tt_+3A_df">df</code></td>
<td>
<p>degrees of freedom (&gt; 0, maybe non-integer).  <code>df = Inf</code> is
allowed.</p>
</td></tr>
<tr><td><code id="tt_+3A_left">left</code></td>
<td>
<p>left censoring point.</p>
</td></tr>
<tr><td><code id="tt_+3A_right">right</code></td>
<td>
<p>right censoring point.</p>
</td></tr>
<tr><td><code id="tt_+3A_log">log</code>, <code id="tt_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="tt_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x]
otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>location</code> or <code>scale</code> are not specified they assume the default values
of <code>0</code> and <code>1</code>, respectively. <code>left</code> and <code>right</code> have the defaults <code>-Inf</code> and <code>Inf</code> respectively.
</p>
<p>The truncated student-t distribution has density 
</p>
<p style="text-align: center;"><code class="reqn">f(x) = 1/\sigma \tau((x - \mu)/\sigma) / 
  (T((right - \mu)/\sigma) - T((left - \mu)/\sigma))</code>
</p>

<p>for <code class="reqn">left \le x \le right</code>, and 0 otherwise.
</p>
<p>where <code class="reqn">T</code> and <code class="reqn">\tau</code> are the cumulative distribution function
and probability density function of the student-t distribution with
<code>df</code> degrees of freedom respectively, <code class="reqn">\mu</code> is the location of the
distribution, and <code class="reqn">\sigma</code> the scale.
</p>


<h3>Value</h3>

<p><code>dtt</code> gives the density, <code>ptt</code> gives the distribution
function, <code>qtt</code> gives the quantile function, and <code>rtt</code>
generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dt">dt</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
