<!DOCTYPE html><html><head><title>Help for package nilde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nilde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bin.packing'><p>Enumeration of all existing solutions for one-dimensional bin-packing problem</p></a></li>
<li><a href='#get.knapsack'><p>Enumeration of all existing nonnegative integer  solutions for unbounded, bounded and 0-1 knapsack and subset sum  problems</p></a></li>
<li><a href='#get.partitions'><p>Additive partitioning of natural numbers</p></a></li>
<li><a href='#get.subsetsum'><p>Enumeration of all existing 0-1 and bounded solutions of a subset sum problem</p></a></li>
<li><a href='#nilde-package'>
<p>Nonnegative Integer Solutions of Linear Diophantine Equations</p>
with Applications</a></li>
<li><a href='#nlde'><p>Enumeration of all existing nonnegative integer solutions of a linear Diophantine equation</p></a></li>
<li><a href='#print.partitions'><p>Print partitions object.</p></a></li>
<li><a href='#tsp_solver'><p>Travelling salesperson problem solver</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-7</td>
</tr>
<tr>
<td>Author:</td>
<td>Natalya Pya Arnqvist[aut, cre], 
        Vassilly Voinov [aut], 
        Rashid Makarov [aut],
        Yevgeniy Voinov [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Natalya Pya Arnqvist &lt;nat.pya@gmail.com&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonnegative Integer Solutions of Linear Diophantine Equations
with Applications</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for enumerating all existing nonnegative integer solutions of a linear Diophantine equation. The package provides routines for solving 0-1, bounded and unbounded knapsack problems; 0-1, bounded and unbounded subset sum problems; additive partitioning of natural numbers; and one-dimensional bin-packing problem.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, lpSolve, TSP</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-16 07:45:34 UTC; natalya</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-16 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bin.packing'>Enumeration of all existing solutions for one-dimensional bin-packing problem</h2><span id='topic+bin.packing'></span>

<h3>Description</h3>

<p>The algorithm used for this function is a permutational modification of First Find (FF) algorithm described in Martello and Toth (1990). However, there are significant differences. First, the algorithm suggested by Martello and Toth does not set an objective to find all possible optimal solutions while algorithm suggested here finds them all. Apparently, these changes result in a significant increase of required computing time because we need to analyse and process all possible item  permutations. Noteworthy, the time of the optimized algorithm is still polynomial. Second, Martello  and Toth used an iterative embodiment of the algorithm while a recursive function is used here in order to reduce computing time by advantageous employment of &quot;lazy evaluation&quot; feature of R program and in order to optimize the code of the script.
</p>
<p>According to its name, our algorithm is build around &quot;generation of a bin&quot;. The objective is achieved by finding the next set of items that fit into existing bin (FF choice). The combination of added items is selected from the solutions provided by <code>nilde</code> function. This method allows to optimize computing time since we process more than one item at a time when we call the function. Further optimization is achieved by canceling any recursive calls when the addition of a new bin results in the number of bins exceeding the currently found local optimum (minimal number of bins achieved so far).
</p>
<p>The algorithm segregates two types of calls from the parent function. Namely, scenarios when the current bin is complete and incomplete are treated separately. If the remaining unused capacity of the bin is zero, i.e. the bin is complete, then we check if creation of a new bin pushes the number of bins above the current optimum. If the number is still optimal, then we start a new bin and generate the list of item clusters that can fit and move on.
</p>
<p>If the remaining unused capacity if not zero (bin is incomplete), then, first, we try to complete the existing bin by adding items that can fit and, then, if it is not possible, we close existing bin (even if its unused capacity is more than zero) and start processing item clusters that would not fit the closed bin anyway. By doing so, solutions with smaller number of bins will be generated earlier. Thus, we will be able to find globally optimal number of bins a.s.a.p.
</p>
<p>Obviously, the algorithm stops recursive calls only in two cases: either we have distributed all the items or we exceeded the optimal number of bins by adding next new bin. In both cases, we proceed with processing the next possible combination of items, i.e. process the next leaf on our decision-making tree.
</p>
<p>As for robustness checks, we have tested several versions of our recursive algorithm. For example, Martello and Toth demonstrate that on sample of any complexity First Find Decreasing (FFD) algorithm leads to a significant decrease in computing time as compared to FF. Therefore, we tested FFD modification of the algorithm. However, in our case, since we are looking for all optimal solutions, implementation of FFD algorithm has yielded no results. Furthermore, we experimented with the format and list of variables transferred recursively. Specifically, a version of the algorithm that transfers only logical vector of scenarios to be processed resulted in increase of computing time.
</p>
<p>The function demonstrates the best computing time for all the sampled scenarios of item weights and bin capacity. However, there are some limitations to be addressed. For example, if the initial set includes multiple items with the same weight but different IDs, then the output of <code>GenVagonE</code> will need to be filtered from seemingly different solutions. Yet, the filtering is not computationally demanding and definitely polynomial in terms of time.
</p>
<p>Note: majority of input variables are pre-computed in advance, separately, see example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> bin.packing(input.a, input.n, bin.globals)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.packing_+3A_input.a">input.a</code></td>
<td>
<p>a vector of items weights.</p>
</td></tr>
<tr><td><code id="bin.packing_+3A_input.n">input.n</code></td>
<td>
<p>capacity of a bin.</p>
</td></tr>   
<tr><td><code id="bin.packing_+3A_bin.globals">bin.globals</code></td>
<td>
<p>an environment for global variables.</p>
</td></tr>   
</table>


<h3>Value</h3>





<table>
<tr><td><code>min.bins</code></td>
<td>
<p>minimum number of bins required.</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p>solutions of the bin-packing problem. Each number is a position of an item in the input string (Input string specifies item weights. Items are numbered 1, 2, 3, etc.)  Items included into one bin are separated by commas. Bins are separated by space character. Different solutions are enclosed by double quotes.</p>
</td></tr>
<tr><td><code>bin.ineff</code></td>
<td>
<p>bin &quot;inefficiency&quot;, i.e. unused space of each bin respectively, for every solution.</p>
</td></tr>
<tr><td><code>total.ineff</code></td>
<td>
<p>total &quot;inefficiency&quot;, i.e. unused space of every solution (sum of bin &quot;inefficiencies&quot; per solution).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rashid Makarov 
</p>


<h3>References</h3>

<p>Martello, S. and Toth, P. (1990) Knapsack Problems: Algorithms and Computer Implementations, Wiley, Chichester, 1990.
</p>
<p>Voinov, V., Makarov, R., Voinov, Y. (2019) An exact polynomial in time solution of the one-dimensional bin-packing problem. In: Christos H Skiadas (ed.) Proceedings of the ASMDA 2019, published by ISAST (Int. Society for the Advancement of Science and Technology), December 2019, pp. 787-798.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nilde-package">nilde-package</a></code>, <code><a href="#topic+get.partitions">get.partitions</a></code>, <code><a href="#topic+get.subsetsum">get.subsetsum</a></code>, <code><a href="#topic+nlde">nlde</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nilde)
input.a &lt;- c(70, 60, 50, 40, 30, 20, 10) # weights of items
input.n &lt;- 100 # capacity of a bin
bin.globals &lt;- new.env() # a new environment for global variables
bin.globals$OptVag &lt;- length(input.a) # initial min # of bins
bin.globals$TrainList &lt;- vector("list",length(input.a)) # output with solutions
g &lt;- bin.packing(input.a, input.n,bin.globals)
g$min.bins # minimum number of bins
g$solution # solutions
</code></pre>

<hr>
<h2 id='get.knapsack'>Enumeration of all existing nonnegative integer  solutions for unbounded, bounded and 0-1 knapsack and subset sum  problems</h2><span id='topic+get.knapsack'></span>

<h3>Description</h3>

<p>This function solves the unbounded, bounded and 0-1 knapsack problems.
</p>
<p>The unbounded knapsack problem can be written as follows.
</p>
<p><code>maximize   </code> <code class="reqn">c_1s_1 +c_2s_2 +...+ c_ls_l </code>
</p>
<p><code>subject to </code> <code class="reqn">a_1s_1 +a_2s_2 +...+ a_ls_l &lt;= n,</code>
</p>
<p><code class="reqn">s_i &gt;= 0, integers.</code>
</p>
<p>The bounded knapsack problem has additional constraints, <code class="reqn">0 &lt;= s_i &lt;= b_i, i=1,...,l, b_i &lt;= [n/a_i].</code> The 0-1 knapsack problem arises when 
<code class="reqn">s_i= 0</code> or <code class="reqn">1, i=1,...,l</code>.  
</p>
<p>The algorithm is based on a generating function of Hardy and Littlewood used by Voinov and Nikulin (1997). Subset sum problems are particular
cases of knapsack problems when vectors of <code>weights</code>, <code class="reqn">(a_1,...,a_l)</code>, and <code>objectives</code>, <code class="reqn">(c_1,...,c_l)</code>, are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> get.knapsack(objective,a,n,problem="uknap",bounds=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.knapsack_+3A_objective">objective</code></td>
<td>
<p>A vector of coefficients (values of each item in the knapsack) of the objective function to be maximized when solving knapsack problem.</p>
</td></tr>
<tr><td><code id="get.knapsack_+3A_a">a</code></td>
<td>
<p>An <code>l</code>-vector of weights of each item in a knapsack, with <code>l&gt;= 2</code>.</p>
</td></tr>
<tr><td><code id="get.knapsack_+3A_n">n</code></td>
<td>
<p>a maximal possible capacity of the knapsack.</p>
</td></tr> 
<tr><td><code id="get.knapsack_+3A_problem">problem</code></td>
<td>
<p>one of the following names of the problems to be solved: 
&quot;uknap&quot; (default) for an unbounded knapsack problem,
&quot;knap01&quot; for a 0-1 knapsack problem, and
&quot;bknap&quot; for a bounded knapsack problem.</p>
</td></tr>
<tr><td><code id="get.knapsack_+3A_bounds">bounds</code></td>
<td>
<p>An l-vector of positive integers, bounds of <code class="reqn">s_i</code>, i.e. <code class="reqn">0 &lt;= s_i &lt;= b_i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>p.n</code></td>
<td>
<p>total number of solutions obtained.</p>
</td></tr>
<tr><td><code>solutions</code></td>
<td>
<p>a matrix with each column representing a solution of <code>n</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vassilly Voinov, Natalya Pya Arnqvist, Yevgeniy Voinov
</p>


<h3>References</h3>

<p>Voinov, V. and Nikulin, M. (1997) On a subset sum algorithm and its probabilistic and other applications. In: Advances in combinatorial methods and applications to probability and statistics, Ed. N. Balakrishnan, Birkhäuser, Boston, 153-163.
</p>
<p>Hardy, G.H. and Littlewood, J.E. (1966) Collected Papers of G.H. Hardy, Including Joint Papers with J.E. Littlewood and Others. Clarendon Press, Oxford.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nilde-package">nilde-package</a></code>, <code><a href="#topic+get.partitions">get.partitions</a></code>, <code><a href="#topic+get.subsetsum">get.subsetsum</a></code>, <code><a href="#topic+nlde">nlde</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## some examples...
b1 &lt;- get.knapsack(objective=c(200:206),a=c(100:106),n=999,problem="uknap")
b1

b2 &lt;- get.knapsack(objective=c(41,34,21,20,8,7,7,4,3,3),a=c(41,34,21,20,8,7,7,4,3,3),
         n=50, problem="bknap", bounds=rep(2,10))
b2
colSums(b2$solutions*c(41,34,21,20,8,7,7,4,3,3))

b3 &lt;- get.knapsack(objective=c(4,3,3),a=c(3,2,2),n=4,problem="bknap",bounds=c(2,2,2))
b3
## get maximum value of the objective function...
colSums(b3$solutions*c(4,3,3)) 
## checking constraint...
colSums(b3$solutions*c(3,2,2))   

b4 &lt;- get.knapsack(objective=c(4,3,3),a=c(3,2,2),n=4,problem="knap01")
b4
## get maximum value of the objective function...
colSums(b4$solutions*c(4,3,3)) 
## checking constraint...
colSums(b4$solutions*c(3,2,2))

## Not run: 
b5 &lt;- get.knapsack(a=c(100:106),n=2999,objective=c(200:206),problem="uknap")
b5$p.n ## total number of solutions
options(max.print=5E5)
print(b5)

  
## End(Not run)
</code></pre>

<hr>
<h2 id='get.partitions'>Additive partitioning of natural numbers</h2><span id='topic+get.partitions'></span>

<h3>Description</h3>

<p>This function solves the problem of additive partitioning of positive integers. The approach for additive partitioning is based on a generating function discussed in details in Voinov and Nikulin (1995). The function enumerates all partitions of a positive integer <code>n</code> on at most (or exactly) <code>M</code> parts, <code>M &lt;= n</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> get.partitions(n, M, at.most=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.partitions_+3A_n">n</code></td>
<td>
<p>A positive integer to be partitioned.</p>
</td></tr>
<tr><td><code id="get.partitions_+3A_m">M</code></td>
<td>
<p>A positive integer, the number of parts of <code>n</code>, <code>M &lt;= n</code>.</p>
</td></tr>
<tr><td><code id="get.partitions_+3A_at.most">at.most</code></td>
<td>
<p>If <code>TRUE</code> then partitioning of <code>n</code> into at most <code>M</code> parts, if <code>FALSE</code> then partitioning on exactly <code>M</code> parts.</p>
</td></tr> 
</table>


<h3>Value</h3>

<table>
<tr><td><code>p.n</code></td>
<td>
<p>total number of partitions obtained.</p>
</td></tr>
<tr><td><code>partitions</code></td>
<td>
<p>a matrix with each column presenting partitions of <code>n</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vassilly Voinov, Natalya Pya Arnqvist, Yevgeniy Voinov
</p>


<h3>References</h3>

<p>Voinov, V. and Nikulin, M. (1995) Generating functions, problems of additive number theory, and some statistical applications. Revue Roumaine de Mathématiques Pures et Appliquées, 40(2), 107-147
</p>
<p>Voinov, V.G. and Pya, N.E. (2017) R-software for additive partitioning of positive integers. Mathematical Journal (ISSN 1682-0525) 17(1), 69-76.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nilde-package">nilde-package</a></code>, <code><a href="#topic+get.knapsack">get.knapsack</a></code>, <code><a href="#topic+get.subsetsum">get.subsetsum</a></code>, <code><a href="#topic+nlde">nlde</a></code>     
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## getting all partitions of n = 8 on at most 6 parts...
get.partitions(8,6,at.most=TRUE)

## getting all partitions of n = 8 on exactly 6 parts...
b &lt;- get.partitions(8,6,at.most=FALSE)
b
colSums(b$partitions)

</code></pre>

<hr>
<h2 id='get.subsetsum'>Enumeration of all existing 0-1 and bounded solutions of a subset sum problem</h2><span id='topic+get.subsetsum'></span>

<h3>Description</h3>

<p>By default this function solves the following 0-1 subset sum problem.
Given the set of positive integers <code>(a_1, a_2, ..., a_l)</code> and a positive integer <code>n</code>, find all non-empty subsets that sum to <code>n</code>, so that each of the integers <code>a_i</code> either appears in the subset or it does not, and the total number of summands should not exceed <code>M</code>, <code>M &lt;= n</code>.
</p>
<p>The bounded subset sum problem has restrictions on the number of times (bounds) <code>a_i</code> can turn up in the subset.
</p>
<p>The algorithm is based on a generating function of Hardy and Littlewood used by Voinov and Nikulin (1997). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> get.subsetsum(a,n,M=NULL,problem="subsetsum01",bounds=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.subsetsum_+3A_a">a</code></td>
<td>
<p>An <code>l</code>-vector of positive integers with <code>l&gt;= 2</code>.</p>
</td></tr>
<tr><td><code id="get.subsetsum_+3A_n">n</code></td>
<td>
<p>A positive integer.</p>
</td></tr>
<tr><td><code id="get.subsetsum_+3A_m">M</code></td>
<td>
<p>A positive integer, the maximum number of summands, <code>M &lt;= n</code></p>
</td></tr> 
<tr><td><code id="get.subsetsum_+3A_problem">problem</code></td>
<td>
<p>one of the two problems to be solved: &quot;subsetsum01&quot; (default) for a 0-1 subset sum problem, 
or &quot;bsubsetsum&quot; a bounded subset sum problem.</p>
</td></tr>
<tr><td><code id="get.subsetsum_+3A_bounds">bounds</code></td>
<td>
<p>An <code>l</code>-vector of positive integers, bounds for <code class="reqn">s_i</code>, i.e. <code class="reqn">0 &lt;= s_i &lt;= b_i</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>p.n</code></td>
<td>
<p>total number of solutions obtained.</p>
</td></tr>
<tr><td><code>solutions</code></td>
<td>
<p>a matrix with each column presenting a solution for <code>n</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vassilly Voinov, Natalya Pya Arnqvist, Yevgeniy Voinov
</p>


<h3>References</h3>

<p>Voinov, V. and Nikulin, M. (1997) On a subset sum algorithm and its probabilistic and other applications. In: Advances in combinatorial methods and applications to probability and statistics, Ed. N. Balakrishnan, Birkhäuser, Boston, 153-163.
</p>
<p>Hardy, G.H. and Littlewood, J.E. (1966) Collected Papers of G.H. Hardy, Including Joint Papers with J.E. Littlewood and Others. Clarendon Press, Oxford.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nilde-package">nilde-package</a></code>, <code><a href="#topic+get.partitions">get.partitions</a></code>, <code><a href="#topic+get.knapsack">get.knapsack</a></code>, <code><a href="#topic+nlde">nlde</a></code>     
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## some examples...
b1 &lt;- get.subsetsum(a=c(41,34,21,20,8,7,7,4,3,3),M=10,n=50,problem="subsetsum01")
b1
colSums(b1$solutions*c(41,34,21,20,8,7,7,4,3,3))

b2 &lt;- get.subsetsum(a=c(111:120),M=10,n=485,problem="subsetsum01") ## no solutions
b2

b3 &lt;- get.subsetsum(a=c(30,29,32,31,33),M=5,n=91,problem="subsetsum01")
b3
colSums(b3$solutions*c(30,29,32,31,33))
get.subsetsum(a=c(30,29,32,31,33),M=5,n=91,problem="bsubsetsum",bounds=c(1,1,1,1,1))

b4 &lt;- get.subsetsum(a=c(30,29,32,31,33),M=5,n=91,problem="bsubsetsum",
                 bounds=c(1,2,1,3,4))
b4
colSums(b4$solutions*c(30,29,32,31,33))
</code></pre>

<hr>
<h2 id='nilde-package'>
Nonnegative Integer Solutions of Linear Diophantine Equations
with Applications
</h2><span id='topic+nilde-package'></span><span id='topic+nilde'></span>

<h3>Description</h3>

<p><code>nilde</code> provides functions for enumerating all existing nonnegative integer solutions of a linear Diophantine equation. The package also includes functions for solving 0-1, bounded and unbounded knapsack problems; 0-1, bounded and unbounded subset sum problems; and a problem of additive partitioning of natural numbers. The algorithm is based on a generating function of Hardy and Littlewood used by Voinov and Nikulin (1997). 
</p>


<h3>Author(s)</h3>

<p>Natalya Pya Arnqvist[aut, cre], 
        Vassilly Voinov [aut], 
        Rashid Makarov [aut],
        Yevgeniy Voinov [aut]
</p>
<p>Maintainer: Natalya Pya Arnqvist &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Voinov, V. and Nikulin, M. (1995) Generating functions, problems of additive number theory, and some statistical applications. Revue Roumaine de Mathématiques Pures et Appliquées, 40(2), 107-147
</p>
<p>Voinov, V. and Nikulin, M. (1997) On a subset sum algorithm and its probabilistic and other applications. In: Advances in combinatorial methods and applications to probability and statistics, Ed. N. Balakrishnan, Birkhäuser, Boston, 153-163
</p>
<p>Voinov, V. and Pya, N. (2006) A Remark on the Non-Uniqueness of a Non-Negative Integer Solution of a System of Linear Diophantine Equations with Applications to Integer Programming, Genetics, Reliability. Central Asian Journal of Management, Economics and Social Research (ISSN 1815-3356) 5(1-2), 42-47.
</p>
<p>Voinov, V. and Pya, N. (2017) R-software for additive partitioning of positive integers. Mathematical Journal (ISSN 1682-0525), 17(1), 69-76 
</p>

<hr>
<h2 id='nlde'>Enumeration of all existing nonnegative integer solutions of a linear Diophantine equation</h2><span id='topic+nlde'></span>

<h3>Description</h3>

<p>This function enumerates nonnegative integer solutions of a linear Diophantine equation (NLDE):
</p>
<p style="text-align: center;"><code class="reqn">a_1s_1 +a_2s_2 +...+ a_ls_l =n,</code>
</p>

<p>where <code class="reqn">a_1 &lt;= a_2 &lt;= ... &lt;= a_l,</code> <code class="reqn">a_i &gt; 0,</code> <code class="reqn">n &gt; 0,</code> <code class="reqn">s_i &gt;= 0,</code> <code class="reqn">i=1,2,...,l,</code> and all variables involved are integers.
</p>
<p>The algorithm is based on a generating function of Hardy and Littlewood used by Voinov and Nikulin (1997). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nlde(a, n, M=NULL, at.most=TRUE, option=0)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlde_+3A_a">a</code></td>
<td>
<p>An <code>l</code>-vector of positive integers (coefficients of the left-hand-side of NLDE) with <code>l&gt;= 2</code>.</p>
</td></tr>
<tr><td><code id="nlde_+3A_n">n</code></td>
<td>
<p>A positive integer which is to be partitioned.</p>
</td></tr>
<tr><td><code id="nlde_+3A_m">M</code></td>
<td>
<p>A positive integer, the number of parts of <code>n</code>, <code>M &lt;= n</code>.</p>
</td></tr>
<tr><td><code id="nlde_+3A_at.most">at.most</code></td>
<td>
<p>If <code>TRUE</code> partitioning of <code>n</code> into at most <code>M</code> parts, if <code>FALSE</code> partitioning on exactly <code>M</code> parts.</p>
</td></tr> 
<tr><td><code id="nlde_+3A_option">option</code></td>
<td>
<p>When set to <code>1</code> (or any positive number) finds only 0-1 solutions of the linear Diophantine equation.
When set to <code>2</code> (or any positive number &gt; 1) finds 0-1 solutions of the linear Diophantine inequality.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>p.n</code></td>
<td>
<p>total number of partitions obtained.</p>
</td></tr>
<tr><td><code>solutions</code></td>
<td>
<p>a matrix with each column forming a partition of <code>n</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vassilly Voinov, Natalya Pya Arnqvist, Yevgeniy Voinov
</p>


<h3>References</h3>

<p>Voinov, V. and Nikulin, M. (1997) On a subset sum algorithm and its probabilistic and other applications. In: Advances in combinatorial methods and applications to probability and statistics, Ed. N. Balakrishnan, Birkhäuser, Boston, 153-163.
</p>
<p>Hardy, G.H. and Littlewood, J.E. (1966) Collected Papers of G.H. Hardy, Including Joint Papers with J.E. Littlewood and Others. Clarendon Press, Oxford.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nilde-package">nilde-package</a></code>, <code><a href="#topic+get.partitions">get.partitions</a></code>, <code><a href="#topic+get.subsetsum">get.subsetsum</a></code>, <code><a href="#topic+get.knapsack">get.knapsack</a></code>     
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## some examples...
## example 1...
nlde(a=c(3,2,5,16),n=18,at.most=TRUE)
b1 &lt;- nlde(a=c(3,2,5,16),n=18,M=6,at.most=FALSE)
b1
## checking M, the number of parts that n=18 has been partitioned into...
colSums(b1$solutions)
## checking the value of n...
colSums(b1$solutions*c(3,2,5,16))

## example 2:  solving 0-1 nlde ...
b2 &lt;- nlde(a=c(3,2,5,16),n=18,M=6,option=1)
b2
colSums(b2$solutions*c(3,2,5,16))

## example 3...
b3 &lt;- nlde(c(15,21),261)
b3 
## checking M, the number of parts that n has been partitioned into...
colSums(b3$solutions)
## checking the value of n...
colSums(b3$solutions*c(15,21))

## example 4... 
nlde(c(5,6),19) ## no solutions

## example 5: solving 0-1 inequality...
b4 &lt;- nlde(a=c(70,60,50,33,33,33,11,7,3),n=100,at.most=TRUE,option=2)


</code></pre>

<hr>
<h2 id='print.partitions'>Print partitions object.</h2><span id='topic+print.partitions'></span><span id='topic+print.nlde'></span><span id='topic+print.knapsack'></span><span id='topic+print.subsetsum'></span><span id='topic+print.tsp_solver'></span>

<h3>Description</h3>

<p> The default print method for a <code>partitions</code>, <code>nlde</code> objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partitions'
print(x, ...)
## S3 method for class 'nlde'
print(x, ...)
## S3 method for class 'knapsack'
print(x, ...)
## S3 method for class 'subsetsum'
print(x, ...)
## S3 method for class 'tsp_solver'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="print.partitions_+3A_x">x</code>, <code id="print.partitions_+3A_...">...</code></td>
<td>
<p> objects of class <code>partitions</code>, <code>nlde</code>, <code>knapsack</code>, <code>subsetsum</code> as produced by <code>get.partitions()</code>, 
<code>nlde()</code>, <code>get.knapsack()</code>, <code>get.subsetsum()</code>, <code>tsp_solver()</code> correspondingly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Prints the number of partitions/solutions obtained and all resulted partitions/solutions themselves. 
</p>


<h3>Author(s)</h3>

<p>Natalya Pya Arnqvist &lt;nat.pya@gmail.com&gt;
</p>

<hr>
<h2 id='tsp_solver'>Travelling salesperson problem solver</h2><span id='topic+tsp_solver'></span>

<h3>Description</h3>

<p> Interface to travelling salesperson problem solver. 
</p>
<p>Consider an integer linear programming (ILP) formulation of DFJ (Dantzig et al, 1954) used in this research. Let <code class="reqn">G=(V,A)</code> be a graph with a set <code class="reqn">V</code> of  <code class="reqn">n</code> vertices 
and <code class="reqn">A</code> be a set of arcs or edges. Let <code class="reqn">C=(c_{ij})</code> be a distance (or cost) matrix associated with <code class="reqn">A</code>. Elements of the distance matrix <code class="reqn">C,</code> <code class="reqn">c_{ij},</code> are positive integers, <code class="reqn">i,j \in V, i \neq j.</code> 
The TSP focuses on finding a minimum distance circuit (a tour or Hamiltonian circuit) that passes through each vertex once and only once. The DFJ formulation is
</p>
<p><code>minimize    </code> <code class="reqn">L =  \sum\limits_{j \neq i}c_{ij}\delta_{ij} ~~~~~~~~~~</code>   (1)
</p>
<p><code>subject to    </code>   <code class="reqn">\sum\limits_{j=1}^n \delta_{ij} = 1, i=1,..., n ~~~~~~~~~~</code>      (2)
</p>
<p> <code class="reqn">~~~~~~~~~~~~~~~~~~~~\sum\limits_{i=1}^n \delta_{ij} = 1, j=1,..., n ~~~~~~~~~~</code>     (3)
</p>
<p> <code class="reqn">~~~~~~~~~~~~~~~~~~~~\sum\limits_{i,j\in S}\delta_{ij} \leq |S|-1, S\subset V,  2\leq |S| \leq n-2 ~~~~~~~~~~</code>    (4)
</p>
<p> <code class="reqn">~~~~~~~~~~~~~~~~~~~~~ \delta_{ij} \in {0,1}, i,j=1,..., n, i\neq j~~~~~~~~~~~ </code>      (5)
</p>
<p>Constraints (2) and (3) are known as degree constraints indicating that every vertex should be entered and left exactly once correspondingly. Constraints (4) are 
subtour elimination constraints that prevent from forming subtours (several unconnected tours on subsets of less than <code class="reqn">n</code> vertices), with <code class="reqn">|S|</code> denoting the number of vertices in <code class="reqn">S</code>. 
</p>
<p>In the DFJ formulation there are <code class="reqn">n(n-1)</code> unknown binary variables, <code class="reqn">2n</code> degree constraints and <code class="reqn">2^n -2n-2</code> subtour elimination constraints. Since the number of subtour elimination constraints increases exponentially, 
solving this problem directly using an integer linear programming code is in general  intractable. However, relaxed versions of the integer linear programming problem where some constraints are initially removed,
and later restored via an iterative process, have been proposed and extensively used.
</p>
<p>Here it is proposed to combine heuristics (to get an initial feasible solution) and a linear Diophantine equation (nilde) relaxation to develop a new exact
algorithm that constructs all existing optimal solutions for the TSP in an efficient way.
</p>
<p>Below is a brief summary of the proposed algorithm.
</p>
<p>Step 1. (Initialization) Solve a corresponding assignment problem to obtain an initial lower bound on the value of the optimal TSP solution. Apply heuristics to obtain an initial upper bound.
</p>
<p>Step 2. (Subproblem solution) Given the initial lower bound construct all 0-1 solutions to a linear Diophantine equation introduced by Voinov and Nikulin (1997).
</p>
<p>Step 3. (Degree constraints check) Remove solutions  that do not satisfy the degree constraints.  
</p>
<p>Step 4. (Subtour elimination) Remove solutions that contain subtours by applying a new simple subtour elimination routine. 
If there is a solution(s) that contains no subtours, it forms the optimal solution(s): stop. Otherwise, increase the initial lower bound by one and go to step 2. Repeat until the upper bound is reached.
</p>
<p>The integer programming formulation of the assignment problem solved in Step 1 of the above algorithm is obtained by relaxing constraints (4), i.e. given by (1) subject to constraints (2), (3) and 
(5).  
</p>
<p>For implementing Step 2, solutions of the corresponding subset sum problem should be enumerated. A subset sum problem formulation can be expressed as
</p>
<p style="text-align: center;"><code class="reqn">  a_1s_1+a_2s_2+\ldots +a_ps_p=L, ~~~~~~~~(6)</code>
</p>
 
<p>where <code class="reqn">s_i \in \{0,1\},</code> <code class="reqn">i=1,\ldots,p, p=n(n-1)</code> is the number of unknown binary variables of the original TSP. <code class="reqn">a_i</code> are positive integers matching the costs <code class="reqn">c_{ij}</code> of the cost matrix <code class="reqn">C.</code>
</p>
<p>Voinon and Nikulin (1997)  introduced an algorithm that enumerates all nonnegative integer solutions of equation (6) by using the corresponding generating
function and the binomial theorem. 
All <code class="reqn">0-1</code> solutions to the equation in (6) can be found by means of the following generating function:
</p>
<p style="text-align: center;"><code class="reqn">
  \Psi_L(z)=\left(z^{a_1}+z^{a_2}+\ldots +z^{a_p} \right)^L= \sum\limits_{k=L\cdot \textrm{min}_i(a_i)}^{k=L\cdot \textrm{max}_i(a_i)}R_k(L,p),
  </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
   R_k(L,p)= \sum\limits_{s_p=0}^{\textrm{min}\left(1,\left[\frac{L}{a_p}\right]\right)}\sum\limits_{s_{p-1}=0}^{\textrm{min}\left(1,\left[\frac{L-a_ps_p}{a_{p-1}}\right]\right)}
   \ldots \sum\limits_{s_2=0}^{\textrm{min}\left(1,\left[\frac{L-a_ps_p-\ldots -a_3s_3}{a_2}\right]\right)} \frac{L!}{(L-s_1-\ldots -s_p)!s_1!\ldots s_p!}, 
</code>
</p>
  
<p style="text-align: center;"><code class="reqn"> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(7)
</code>
</p>

<p><code class="reqn">s_1=\frac{L-a_ps_p-\ldots -a_2s_2}{a_1}</code> is necessarily either <code class="reqn">0</code> or <code class="reqn">1</code>. Otherwise, the equation in (6) does not  have any solutions. The notation <code class="reqn">[x]</code> denotes the greatest integer part of <code class="reqn">x.</code>
The right-hand side multiplier in (7) presents the total number of compositions that satisfy the above condition.
If the value of that multiplier is set to <code class="reqn">1</code>, (7) gives the number of <code class="reqn">0-1</code> solutions for the equation (6). The solutions, if exist, are written explicitly as
</p>
<p style="text-align: center;"><code class="reqn">
\left\{a_1^{s_1},a_2^{s_2},\ldots, a_p^{s_p} \right\}, ~~~~~~~~(8)
</code>
</p>
 
<p>where <code class="reqn">\{s_2,\ldots, s_p\}</code> are sets of summation indices  in (7), with <code class="reqn">s_1</code> as specified above. The notation (8) means that in a particular partition 
(a solution of the equation (6)) there are <code class="reqn">s_1</code> terms equal to <code class="reqn">a_1,</code> <code class="reqn">s_2</code> terms of <code class="reqn">a_2</code> and so on. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> tsp_solver(data, labels=NULL,cluster=0,upper_bound=NULL,
          lower_bound=NULL,method="cheapest_insertion",no_go=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsp_solver_+3A_data">data</code></td>
<td>
<p>An <code>n x n</code> matrix of costs/distances of the TSP (with <code>0</code>'s or <code>NA</code>s on the main diagonal). Costs/distances of the unconnected edges must be supplied as NA.</p>
</td></tr>
<tr><td><code id="tsp_solver_+3A_labels">labels</code></td>
<td>
<p>An <code>n</code> vector of optional city labels. If not given, labels are taken from <code>data</code>.</p>
</td></tr>
<tr><td><code id="tsp_solver_+3A_cluster">cluster</code></td>
<td>
<p>Degree constraints can be checked in parallel using parLapply from the parallel package.
<code>cluster</code> is either <code>0</code> (default) for no parallel computing to be used; or <code>1</code> for one less than the number of cores; or user-supplied cluster on which to do checking. a cluster here can be some cores of a single machine.</p>
</td></tr>
<tr><td><code id="tsp_solver_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive integer, an upper bound of the tour length (cost function), if not supplied (default: <code>NULL</code>) heuristic solution is obtained using 
</p>
<p><code>TSP::solve_TSP(data,method)</code>.</p>
</td></tr>
<tr><td><code id="tsp_solver_+3A_lower_bound">lower_bound</code></td>
<td>
<p>A positive integer, a lower possible value of the tour lenght (cost function); 
if not supplied (default: <code>NULL</code>), obtained by solving a corresponding assignment problem
using <code>lpSolve::lp.assign(data)</code></p>
</td></tr>
<tr><td><code id="tsp_solver_+3A_method">method</code></td>
<td>
<p>Heuristic method used in <code>TSP::solve_TSP()</code> 
</p>
<p>(default: <code>cheapest_insertion</code>)</p>
</td></tr>
<tr><td><code id="tsp_solver_+3A_no_go">no_go</code></td>
<td>
<p>A suitably large value used in the distance/cost matrix to make related edges infeasible, 
if <code>NULL</code> (default) set to <code>max(data)*10^5</code>. It can be set to <code>Inf</code> for <code>TSP()</code>. However, <code>lpSolve()</code> is very sensitive to too large values and can result in high values of the <code>lower_bound</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>tour</code></td>
<td>
<p>optimal tour(s).</p>
</td></tr>
<tr><td><code>tour_length</code></td>
<td>
<p>an optimal (minimal) length of the obtained tour(s).</p>
</td></tr>
<tr><td><code>coming_solutions</code></td>
<td>
<p>a list of coming feasible tours obtained within <code>[lower_bound, upper_bound]</code>.</p>
</td></tr>
<tr><td><code>coming_tour_lengths</code></td>
<td>
<p>a vector of feasible tour length gone within <code>[lower_bound, upper_bound]</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>a number of feasible tour length gone through</p>
</td></tr>
<tr><td><code>upper_bound</code></td>
<td>
<p>an upper bound of the tour length</p>
</td></tr>
<tr><td><code>lower_bound</code></td>
<td>
<p>a lower bound value of the tour lenght</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vassilly Voinov, Natalya Pya Arnqvist
</p>


<h3>References</h3>

<p>Voinov, V. and Nikulin, M. (1997) On a subset sum algorithm and its probabilistic and other applications. In: Advances in combinatorial methods and applications to probability and statistics, Ed. N. Balakrishnan, Birkhäuser, Boston, 153-163.
</p>
<p>Dantzig, G., Fulkerson, R. and Johnson, S. (1954) Solution of a large-scale traveling-salesman problem.
Journal of the operations research society of America , 2(4):393-410.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nilde-package">nilde-package</a></code>, <code><a href="#topic+get.partitions">get.partitions</a></code>, <code><a href="#topic+get.knapsack">get.knapsack</a></code>, <code><a href="#topic+get.subsetsum">get.subsetsum</a></code>     
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## some examples...
library(nilde)
set.seed(3)
d &lt;- matrix(sample(1:100,25,replace=TRUE),5,5)
diag(d) &lt;-NA # although no need to specify as the code assumes NAs by default
g &lt;- tsp_solver(d)
g

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
