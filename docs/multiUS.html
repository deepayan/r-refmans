<!DOCTYPE html><html><head><title>Help for package multiUS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multiUS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#antiImage'><p>Anti-image matrix</p></a></li>
<li><a href='#BoxMTest'><p>Box's test for equivalence of covariance matrices</p></a></li>
<li><a href='#breakString'><p>Break a string</p></a></li>
<li><a href='#cancorPlus'><p>Canonical correlations</p></a></li>
<li><a href='#compLoad'><p>Compare factor loadings</p></a></li>
<li><a href='#corTestDf'><p>Compute correlations and test their statistical significance</p></a></li>
<li><a href='#discretize'><p>Transform continuous variable to a discrete variable</p></a></li>
<li><a href='#freqTab'><p>Create a frequency table</p></a></li>
<li><a href='#histNorm'><p>Histogram with normal curve</p></a></li>
<li><a href='#KNNimp'><p>KNN-imputation method</p></a></li>
<li><a href='#ldaPlus'><p>Linear discriminant analysis</p></a></li>
<li><a href='#makeFactorLabels'><p>Make factor labels</p></a></li>
<li><a href='#mapLda'><p>LDA mapping</p></a></li>
<li><a href='#Omega'><p>Simple version of omega coefficient - measure of measurement internal consistency based on factor analysis</p></a></li>
<li><a href='#plotCCA'><p>Plot a solution of canonical correlations</p></a></li>
<li><a href='#plotMeans'><p>Plot the means</p></a></li>
<li><a href='#predict.ldaPlus'><p>Predict the values of a categorical variable based on a linear discriminant function</p></a></li>
<li><a href='#printP'><p>Print p-value</p></a></li>
<li><a href='#renameVar'><p>Rename variables</p></a></li>
<li><a href='#seqKNNimp'><p>Sequential KNN imputation method</p></a></li>
<li><a href='#small2other'><p>Recoding the smallest categories to &quot;other&quot; value in case of too many or too small categories.</p></a></li>
<li><a href='#testCC'><p>Test of canonical correlations</p></a></li>
<li><a href='#Theta'><p>Theta coefficient - measure of measurement internal consistency based on principal component analysis</p></a></li>
<li><a href='#wardKF'><p>Calculate the value of the Ward criterion function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for the Courses Multivariate Analysis and Computer
Intensive Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utility functions for multivariate analysis (factor analysis, discriminant analysis, and others). The package is primary written for the course Multivariate analysis and for the course Computer intensive methods at the masters program of Applied Statistics at University of Ljubljana.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, gplots, graphics, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>CCA, psych</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-23 10:20:36 UTC; marss</td>
</tr>
<tr>
<td>Author:</td>
<td>Žiberna Aleš [aut],
  Cugmas Marjan [cre, aut],
  Torgo Luis [cph],
  Ki-Yeol Kim [cph],
  Gwan-Su Yi [cph],
  Liaw Andy [cph],
  Leisch Friedrich [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cugmas Marjan &lt;marjan.cugmas@fdv.uni-lj.si&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-23 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='antiImage'>Anti-image matrix</h2><span id='topic+antiImage'></span>

<h3>Description</h3>

<p>The function computes anti-image matrix (i.e., with partial correlations on the off-diagonal and with KMO-MSAs on the diagonal) and the overall KMO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antiImage(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="antiImage_+3A_x">X</code></td>
<td>
<p>A data frame with the values of numerical variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li> <p><code>AIR</code> - Anti-image matrix.
</p>
</li>
<li> <p><code>KMO</code> - Overall KMO.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>References</h3>

<p>Kaiser, H. F., &amp; Rice, J. (1974). Little Jiffy, Mark Iv. Educational &amp; Psychological Measurement, 34(1), 111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>antiImage(X = mtcars[, c(1, 3, 4, 5)])
</code></pre>

<hr>
<h2 id='BoxMTest'>Box's test for equivalence of covariance matrices</h2><span id='topic+BoxMTest'></span>

<h3>Description</h3>

<p>The function performs Box's test for testing the null hypothesis that two or more covariance matrices are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoxMTest(X, cl, alpha = 0.05, test = "any")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoxMTest_+3A_x">X</code></td>
<td>
<p>A data frame with the values of numberical variables.</p>
</td></tr>
<tr><td><code id="BoxMTest_+3A_cl">cl</code></td>
<td>
<p>An normial or ordinal variable which defines groups (a partition) (must be of type <code>factor</code>).</p>
</td></tr>
<tr><td><code id="BoxMTest_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (default <code>0.05</code>).</p>
</td></tr>
<tr><td><code id="BoxMTest_+3A_test">test</code></td>
<td>
<p>Wheter the F-test (<code>test = "F"</code>) or Chi-square (<code>test = "ChiSq"</code>) test should be forced (see Details). In the case of default value <code>any</code>, the test is chosen based on the number of units by groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the size of any group is at least 20 units (sufficiently large),
the test takes a Chi-square approximation, otherwise it takes
an F approximation.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>MBox</code> - The value of the Box's M statistic.
</p>
</li>
<li> <p><code>ChiSq</code> or <code>F</code> - The approximation statistic test.
</p>
</li>
<li> <p><code>p</code> - An observed significance level.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Andy Liaw and Aleš Žiberna (minor modifications)
</p>


<h3>References</h3>

<p>Stevens, J. (1996). Applied multivariate statistics for the social sciences . 1992. Hillsdale, NJ: Laurence Erlbaum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BoxMTest(X = mtcars[, c(1, 3, 4, 5)], cl = as.factor(mtcars[, 2]), alpha = 0.05)
</code></pre>

<hr>
<h2 id='breakString'>Break a string</h2><span id='topic+breakString'></span>

<h3>Description</h3>

<p>The function breaks a string after around the specified number of characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breakString(x, nChar = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breakString_+3A_x">x</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="breakString_+3A_nchar">nChar</code></td>
<td>
<p>The number of characters after which the new line is inserted. Default to 20.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with inserted <code>\n</code>.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>someText &lt;- "This is the function that breaks a string."
breakString(x = someText, nChar = 20)
</code></pre>

<hr>
<h2 id='cancorPlus'>Canonical correlations</h2><span id='topic+cancorPlus'></span>

<h3>Description</h3>

<p>The function computes canonical correlations (by using <code>cc</code> or <code>cancor</code> functions) and provides with the test of
canonical correlations and with the eigenvalues of the canonical roots (including with the proportion of explained variances by correlation and other related
statistics).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cancorPlus(x, y, xcenter = TRUE, ycenter = TRUE, useCCApackage = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cancorPlus_+3A_x">x</code></td>
<td>
<p>A data frame or a matrix with the values that correspond to the first set of variables (<code class="reqn">X</code>-variables).</p>
</td></tr>
<tr><td><code id="cancorPlus_+3A_y">y</code></td>
<td>
<p>A data frame or a matrix with the values that correspond to the second set of variables (<code class="reqn">Y</code>-variables).</p>
</td></tr>
<tr><td><code id="cancorPlus_+3A_xcenter">xcenter</code></td>
<td>
<p>Whether any centring have to be done on the <code class="reqn">x</code> values before the analysis. If <code>TRUE</code> (default), subtract the column means. If <code>FALSE</code>, do not adjust the columns. Otherwise, a vector of values to be subtracted from the columns.</p>
</td></tr>
<tr><td><code id="cancorPlus_+3A_ycenter">ycenter</code></td>
<td>
<p>Analogous to <code>xcenter</code>, but for the <code class="reqn">y</code> values.</p>
</td></tr>
<tr><td><code id="cancorPlus_+3A_useccapackage">useCCApackage</code></td>
<td>
<p>Whether <code>cc</code> function (from <code>CCA</code> package) or <code>cancor</code> function (from <code>stats</code> package) should be used to obtain canonical correlations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the same output as functions <code>cancor</code> or <code>cc</code> with the following additional elements:
</p>

<ul>
<li> <p><code>$sigTest</code>
</p>

<ul>
<li> <p><code>WilksL</code> - Value of the Wilk's lambda statistic (it is a generalization of the multivariate R2; values near 0 indicate high correlation while values near 1 indicate low correlation).
</p>
</li>
<li> <p><code>F</code> - Corresponding (to Wilk's lambda) F-ratio.
</p>
</li>
<li> <p><code>df1</code> - Degrees of freedom for the corresponding F-ratio.
</p>
</li>
<li> <p><code>df2</code> - Degrees of freedom for the corresponding F-ratio.
</p>
</li>
<li> <p><code>p</code> - Probability value (p-value) for the corresponding F-ratio (Ho: The current and all the later canonical correlations equal to zero).
</p>
</li></ul>

</li>
<li> <p><code>$eigModel</code>
</p>

<ul>
<li> <p><code>Eigenvalues</code> - Eigenvalues of the canonical roots.
</p>
</li>
<li> <p><code>%</code> - Proportion of explained variance of correlation.
</p>
</li>
<li> <p><code>Cum %</code> - Cumulative proportion of explained variance of correlation.
</p>
</li>
<li> <p><code>Cor</code> - Canonical correlation coefficient.
</p>
</li>
<li> <p><code>Sq. Cor</code> - Squared canonical correlation coefficient.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Adapted by Aleš Žiberna based on the source in References.
</p>


<h3>References</h3>

<p>R Data Analysis Examples: Canonical Correlation Analysis, UCLA: Statistical Consulting Group. From http://www.ats.ucla.edu/stat/r/dae/canonical.htm (accessed Decembar 27, 2013).
</p>


<h3>See Also</h3>

<p><code>testCC</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cancorPlus(x = mtcars[, c(1,2,3)], y = mtcars[, c(4,5, 6)])
</code></pre>

<hr>
<h2 id='compLoad'>Compare factor loadings</h2><span id='topic+compLoad'></span>

<h3>Description</h3>

<p>The function compares two sets of factor loadings by considering different possible orders of factors and different possible signs of factor loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compLoad(L1, L2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compLoad_+3A_l1">L1</code></td>
<td>
<p>First set of factor loadings in a matrix form (variables are organized in rows and factors are organized in columns).</p>
</td></tr>
<tr><td><code id="compLoad_+3A_l2">L2</code></td>
<td>
<p>Second set of factor loadings in a matrix form (variables are organized in rows and factors are organized in columns).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>err</code> - Sum of squared differences between the values of <code>L1</code> and <code>L2</code> (for the corresponding permuation and signs).
</p>
</li>
<li> <p><code>perm</code> - Permutation of columns of <code>L1</code> that results in the lowest <code>err</code> value.
</p>
</li>
<li> <p><code>sign</code> - Signs of factor loadings of <code>L1</code>. The first value corresponds to the first column of <code>L1</code> and the second value corresponds to the second column of <code>L1</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aleš Žiberna and Friedrich Leisch (permutations)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L1 &lt;- cbind(c(0.72, 0.81, 0.92, 0.31, 0.22, 0.15), c(0.11, 0.09, 0.17, 0.77, 0.66, 0.89))
L2 &lt;- cbind(c(-0.13, -0.08, -0.20, -0.78, -0.69, -0.88), c(0.72, 0.82, 0.90, 0.29, 0.20, 0.17))
compLoad(L1, L2)
</code></pre>

<hr>
<h2 id='corTestDf'>Compute correlations and test their statistical significance</h2><span id='topic+corTestDf'></span><span id='topic+print.corTestDf'></span><span id='topic+printCorTestDf'></span>

<h3>Description</h3>

<p>The function computes the whole correlation matrix and corresponding sample sizes and <code class="reqn">p</code>-values. Print method is also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corTestDf(X, method = "p", use = "everything", ...)

## S3 method for class 'corTestDf'
print(x, digits = c(3, 3), format = NULL, ...)

printCorTestDf(l, digits = c(3, 3), format = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corTestDf_+3A_x">X</code></td>
<td>
<p>Data matrix with selected variables.</p>
</td></tr>
<tr><td><code id="corTestDf_+3A_method">method</code></td>
<td>
<p>A type of correlation coefficient to be calculated, see function <code>cor</code>.</p>
</td></tr>
<tr><td><code id="corTestDf_+3A_use">use</code></td>
<td>
<p>In the case of missing values, which method should be used, see function <code>cor</code>.</p>
</td></tr>
<tr><td><code id="corTestDf_+3A_...">...</code></td>
<td>
<p>Other parameters to print.default (not needed).</p>
</td></tr>
<tr><td><code id="corTestDf_+3A_x">x</code></td>
<td>
<p>Output of <code>corTestDf</code> function.</p>
</td></tr>
<tr><td><code id="corTestDf_+3A_digits">digits</code></td>
<td>
<p>Vector of length two for the number of digits (the first element of a vector corresponds to the number of digits for correlation coefficients and the second element of a vector corresponds to the number of digits for <code class="reqn">p</code>-values).</p>
</td></tr>
<tr><td><code id="corTestDf_+3A_format">format</code></td>
<td>
<p>A vector of length two for the formatting of the output values.</p>
</td></tr>
<tr><td><code id="corTestDf_+3A_l">l</code></td>
<td>
<p>Output of <code>corTestDf</code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ales Ziberna
</p>


<h3>See Also</h3>

<p><code>cor.test</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corTestDf(mtcars[, 3:5])
</code></pre>

<hr>
<h2 id='discretize'>Transform continuous variable to a discrete variable</h2><span id='topic+discretize'></span>

<h3>Description</h3>

<p>The function transforms a continuous variable to a <code class="reqn">k</code>-point discrete variable (similar to a Likert-item type variable). Different styles of answering to a survey are possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize(x, type = "eq", q = 1.5, k = 5, r = range(x), num = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize_+3A_x">x</code></td>
<td>
<p>Vector with values to be transformed.</p>
</td></tr>
<tr><td><code id="discretize_+3A_type">type</code></td>
<td>
<p>Type of transformation. Possible values are: <code>eq</code> (default) (equal wide intervals), <code>yes</code> (wider intervals at higher values of <code>x</code>), <code>no</code> (wider intervals at lower values of <code>x</code>), <code>avg</code> (wider intervals near the mean of <code>x</code>).</p>
</td></tr>
<tr><td><code id="discretize_+3A_q">q</code></td>
<td>
<p>Extension factor. Tells how much is each next interval wider then the previous one. Not used when <code>type="eq"</code>.</p>
</td></tr>
<tr><td><code id="discretize_+3A_k">k</code></td>
<td>
<p>Number of classes.</p>
</td></tr>
<tr><td><code id="discretize_+3A_r">r</code></td>
<td>
<p>Minimum and maximum values to define intervals of <code>x</code>. Default are minimum and maximum values of <code>x</code>.</p>
</td></tr>
<tr><td><code id="discretize_+3A_num">num</code></td>
<td>
<p>If <code>TRUE</code> (default) numerical values are returned, otherwise intervals are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transformed values are organized into a vector.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
hist(x = discretize(x, type = "eq"), breaks = 0:5+0.5, xlab = "answer", main = "type = 'eq'")
hist(x = discretize(x, type = "yes"), breaks = 0:5+0.5, xlab = "answer", main = "type = 'yes'")
hist(x = discretize(x, type = "no"), breaks = 0:5+0.5, xlab = "answer", main = "type = 'no'")
hist(x = discretize(x, type = "avg"), breaks = 0:5+0.5, xlab = "answer", main = "type = 'avg'")
</code></pre>

<hr>
<h2 id='freqTab'>Create a frequency table</h2><span id='topic+freqTab'></span>

<h3>Description</h3>

<p>The function creates a frequency table with percentages for the selected categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqTab(x, dec = 2, cum = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqTab_+3A_x">x</code></td>
<td>
<p>Vector with the values of a categorical variable.</p>
</td></tr>
<tr><td><code id="freqTab_+3A_dec">dec</code></td>
<td>
<p>Number of decimal places for percentages.</p>
</td></tr>
<tr><td><code id="freqTab_+3A_cum">cum</code></td>
<td>
<p>whether to calculate cumulative frequencies and percentages (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="freqTab_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code>table</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A frequency table (as a dataframe).
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freqTab(mtcars[,2], dec = 1)
</code></pre>

<hr>
<h2 id='histNorm'>Histogram with normal curve</h2><span id='topic+histNorm'></span>

<h3>Description</h3>

<p>The function draws a histogram with a normal density curve. The parameters (mean and standard deviation) are estimated on the empirical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histNorm(y, breaks = "Sturges", freq = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histNorm_+3A_y">y</code></td>
<td>
<p>A vector of observations.</p>
</td></tr>
<tr><td><code id="histNorm_+3A_breaks">breaks</code></td>
<td>
<p>See help file for function <code>hist</code>.</p>
</td></tr>
<tr><td><code id="histNorm_+3A_freq">freq</code></td>
<td>
<p>Wheter frequencies (<code>freq = TRUE</code>) of density (<code>freq = FALSE</code>) should be represented on <code class="reqn">y</code>-axis.</p>
</td></tr>
<tr><td><code id="histNorm_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code>hist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li> <p><code>x</code> - breaks, see <code>graphics::hist</code>.
</p>
</li>
<li> <p><code>y</code> - frequencies or relative frequencies, see <code>graphics::hist</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>histNorm(rnorm(1000), freq = TRUE)
histNorm(rnorm(1000), freq = FALSE)
</code></pre>

<hr>
<h2 id='KNNimp'>KNN-imputation method</h2><span id='topic+KNNimp'></span>

<h3>Description</h3>

<p>Function that fills in all NA values using the k-nearest-neighbours of each case with NA values.
By default it uses the values of the neighbours and obtains an weighted (by the distance to the case) average of
their values to fill in the unknows. If <code>meth='median'</code> it uses the median/most frequent value, instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KNNimp(data, k = 10, scale = TRUE, meth = "weighAvg", distData = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KNNimp_+3A_data">data</code></td>
<td>
<p>A data frame with the data set.</p>
</td></tr>
<tr><td><code id="KNNimp_+3A_k">k</code></td>
<td>
<p>The number of nearest neighbours to use (defaults to 10).</p>
</td></tr>
<tr><td><code id="KNNimp_+3A_scale">scale</code></td>
<td>
<p>Boolean setting if the data should be scale before finding the nearest neighbours (defaults to TRUE).</p>
</td></tr>
<tr><td><code id="KNNimp_+3A_meth">meth</code></td>
<td>
<p>String indicating the method used to calculate the value to fill in each NA. Available values are <code>median</code> or <code>weighAvg</code> (the default).</p>
</td></tr>
<tr><td><code id="KNNimp_+3A_distdata">distData</code></td>
<td>
<p>Optionally you may sepecify here a data frame containing the data set that should be used to find the neighbours. This is usefull when filling in NA values on a test set, where you should use only information from the training set. This defaults to <code>NULL</code>, which means that the neighbours will be searched in data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the k-nearest neighbours to fill in the unknown (NA) values in a data set. For each case with any NA value it will search for its k most similar cases and use the values of these cases to fill in the unknowns.
If <code>meth='median'</code> the function will use either the median (in case of numeric variables) or the most frequent value (in case of factors), of the neighbours to fill in the NAs. If <code>meth='weighAvg'</code> the function will use a
weighted average of the values of the neighbours. The weights are given by <code>exp(-dist(k,x)</code> where <code>dist(k,x)</code> is the euclidean distance between the case with NAs (x) and the neighbour k.
</p>


<h3>Value</h3>

<p>A dataframe with imputed values.
</p>


<h3>Note</h3>

<p>This is a slightly modified function from package <code>DMwR</code> by Luis Torgo. The modification allows the units with missing values at almost all variables.
</p>


<h3>Author(s)</h3>

<p>Luis Torgo
</p>


<h3>References</h3>

<p>Torgo, L. (2010) Data Mining using R: learning with case studies, CRC Press (ISBN: 9781439810187).
</p>


<h3>See Also</h3>

<p><code>seqKNNimp</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars$mpg[sample(1:nrow(mtcars), size = 5, replace = FALSE)] &lt;- NA
KNNimp(data = mtcars)
</code></pre>

<hr>
<h2 id='ldaPlus'>Linear discriminant analysis</h2><span id='topic+ldaPlus'></span>

<h3>Description</h3>

<p>The function performs a linear discriminant analysis (by using the <code>MASS::lda</code> function).
Compared to the <code>MASS::lda</code> function, the <code>ldaPlus</code>
function enable to consider the prior probabilities to predict the values of a categorical variable, it
provides with predicted values and with (Jack-knife) classification table and also with statistical test of canonical correlations
between the variable that represents groups and numeric variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldaPlus(x, grouping, pred = TRUE, CV = TRUE, usePriorBetweenGroups = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldaPlus_+3A_x">x</code></td>
<td>
<p>A data frame with values of numeric variables.</p>
</td></tr>
<tr><td><code id="ldaPlus_+3A_grouping">grouping</code></td>
<td>
<p>Categorical variable that defines groups.</p>
</td></tr>
<tr><td><code id="ldaPlus_+3A_pred">pred</code></td>
<td>
<p>Whether to return the predicted values based on the model. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ldaPlus_+3A_cv">CV</code></td>
<td>
<p>Whether to do cross-validation in addition to &quot;ordinary&quot; analysis, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ldaPlus_+3A_usepriorbetweengroups">usePriorBetweenGroups</code></td>
<td>
<p>Whether to use prior probabilities also in estimating the model (compared to only in prediction); default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ldaPlus_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code>MASS::lda</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specified <code>prior</code> is not taken into account when computing eigenvalues and all statistics based on them (everything in components <code>eigModel</code> and <code>sigTest</code> of the returned value).
</p>


<h3>Value</h3>

<p>The following objects are also a part of what is returned by the <code>MASS::lda</code> function.
</p>

<ul>
<li> <p><code>prior</code> - Prior probabilities of class membership taken to estimate the model (it can be estimated based on the sample data or it can be provided by a reseacher).
</p>
</li>
<li> <p><code>counts</code> - Number of units in each category of categorical variable taken to estimate the model.
</p>
</li>
<li> <p><code>means</code> - Group means.
</p>
</li>
<li> <p><code>scaling</code> - Matrix that transforms observations to discriminant functions, normalized so that within groups covariance matrix is spherical.
</p>
</li>
<li> <p><code>lev</code> - Levels (groups) of the categorical variable.
</p>
</li>
<li> <p><code>svd</code> - Singular values, that give the ratio of the between-group and within-group standard deviations on linear discriminant variables. Their squares are the canonical F-statistics.
</p>
</li>
<li> <p><code>N</code> - Number of observations used.
</p>
</li>
<li> <p><code>call</code> - 	the (matched) function call.
</p>
</li></ul>

<p>The additional following objects are generated by the <code>multiUS::ldaPlus</code> function.
</p>

<ul>
<li> <p><code>standCoefWithin</code> - Standardized coefficients (within groups) of discriminant function.
</p>
</li>
<li> <p><code>standCoefTotal</code> - Standardized coefficients of discriminant function.
</p>
</li>
<li> <p><code>betweenGroupsWeights</code> - Proportions/priors used when estimating the model.
</p>
</li>
<li> <p><code>sigTest</code> - Test of canonical correlations between the variable that represent groups (binary variable) and numeric variables (see function <code>testCC</code> for more details) (Ho: The current and all the later canonical correlations equal to zero.).
</p>
</li>
<li> <p><code>eigModel</code> - Table with eigenvalues and canonical correlations (see function <code>testCC</code> for more details).
</p>
</li>
<li> <p><code>centroids</code> - Means of discriminant variables by levels of categorical variable (not predicted, but actual).
</p>
</li>
<li> <p><code>corr</code> - Pooled correlations within groups (correlations between values of numerical variables and values of linear discriminat function(s)).
</p>
</li>
<li> <p><code>pred</code>
</p>

<ul>
<li> <p><code>class</code> - Predicted values of categorical variable
</p>
</li>
<li> <p><code>posterior</code> - Posterior probabilities (the values of the Fisher's calcification linear discrimination function)
</p>
</li>
<li> <p><code>x</code> - Estimated values of discriminat function(s) for each unit
</p>
</li></ul>

</li>
<li> <p><code>class</code> - Classification table:
</p>

<ul>
<li> <p><code>orgTab</code> - Frequency table.
</p>
</li>
<li> <p><code>perTab</code> - Percentages.
</p>
</li>
<li> <p><code>corPer</code> - Percentage of correctly predicted values (alternatively, percentage of correctly classified units).
</p>
</li></ul>

</li>
<li> <p><code>classCV</code> - Similar to <code>class</code> but based on cross validation (Jack-knife).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>R Data Analysis Examples: Canonical Correlation Analysis, UCLA: Statistical Consulting Group. From http://www.ats.ucla.edu/stat/r/dae/canonical.htm (accessed Decembar 27, 2013).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ldaPlus(x = mtcars[,c(1, 3, 4, 5, 6)], grouping = mtcars[,10])
</code></pre>

<hr>
<h2 id='makeFactorLabels'>Make factor labels</h2><span id='topic+makeFactorLabels'></span>

<h3>Description</h3>

<p>The function transforms a numeric varibale into categorical one, based on the attribute data from a given SPSS file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFactorLabels(x, reduce = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFactorLabels_+3A_x">x</code></td>
<td>
<p>Data for the selected variable, see Details.</p>
</td></tr>
<tr><td><code id="makeFactorLabels_+3A_reduce">reduce</code></td>
<td>
<p>Wheter to reduce categories with zero frequency, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="makeFactorLabels_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code>factor</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data have to be imported by using the <code>foreign::read.spss</code> function.
The use of the function make sence when the parameter <code>use.value.lables</code> in the function <code>read.spss</code> is set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>Categorical variable (vector).
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>

<hr>
<h2 id='mapLda'>LDA mapping</h2><span id='topic+mapLda'></span>

<h3>Description</h3>

<p>The function draws two dimensional map of discriminant functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapLda(
  object,
  xlim = c(-2, 2),
  ylim = c(-2, 2),
  npoints = 101,
  prior = object$prior,
  dimen = 2,
  col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapLda_+3A_object">object</code></td>
<td>
<p>Object obtained by <code>ldaPlus</code> function or <code>MASS::lda</code> function.</p>
</td></tr>
<tr><td><code id="mapLda_+3A_xlim">xlim</code></td>
<td>
<p>Limits of the <code class="reqn">x</code>-axis.</p>
</td></tr>
<tr><td><code id="mapLda_+3A_ylim">ylim</code></td>
<td>
<p>Limits of the <code class="reqn">y</code>-axis.</p>
</td></tr>
<tr><td><code id="mapLda_+3A_npoints">npoints</code></td>
<td>
<p>Number of points on y-axis and x-axis (i.e., drawing precision).</p>
</td></tr>
<tr><td><code id="mapLda_+3A_prior">prior</code></td>
<td>
<p>Prior probabilities of class membership to estimate the model (they can be estimated based on the sample data or they can be provided by a reseacher).</p>
</td></tr>
<tr><td><code id="mapLda_+3A_dimen">dimen</code></td>
<td>
<p>Number of dimensions used for prediction. Probably only 2 (as these are used for drawing) makes sense.</p>
</td></tr>
<tr><td><code id="mapLda_+3A_col">col</code></td>
<td>
<p>Vector of mapping colors, default is <code>NULL</code> (i.e., it takes the default R colors).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects (plotting a map).
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate the LDA model:
ldaCars &lt;- ldaPlus(x = mtcars[,c(1, 3, 4, 5, 6)], grouping = mtcars[,10])
# Plot LDA map:
mapLda(ldaCars)
</code></pre>

<hr>
<h2 id='Omega'>Simple version of omega coefficient - measure of measurement internal consistency based on factor analysis</h2><span id='topic+Omega'></span>

<h3>Description</h3>

<p>The function omega coefficient, which is a measure of measurement internal consistency based on factor analysis, based on the covariance or correlation matrix. <code><a href="psych.html#topic+fa">psych::fa</a></code> is used to preform factor analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Omega(
  C,
  fm = "ml",
  nfactors = 1,
  covar = TRUE,
  usePsych = TRUE,
  returnFaRes = FALSE,
  rotation = "none",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Omega_+3A_c">C</code></td>
<td>
<p>Covariance or correlation matrix.</p>
</td></tr>
<tr><td><code id="Omega_+3A_fm">fm</code></td>
<td>
<p>Factor analysis method, maximum likelihood (<code>"ml"</code>) by default. See <code><a href="psych.html#topic+fa">psych::fa</a></code> for details. Only used if <code>usePsych</code> is <code>TRUE</code> and <code>psych</code> package is available.</p>
</td></tr>
<tr><td><code id="Omega_+3A_nfactors">nfactors</code></td>
<td>
<p>Number of factors, 1 by default, <code><a href="psych.html#topic+fa">psych::fa</a></code> for details.</p>
</td></tr>
<tr><td><code id="Omega_+3A_covar">covar</code></td>
<td>
<p>Should the input <code>C</code> be treated as covariance matrix. Defaults to <code>TRUE</code>. If set to <code>FALSE</code>, the input <code>C</code> is converted to correlation matrix using <code><a href="stats.html#topic+cov2cor">stats::cov2cor</a></code>.</p>
</td></tr>
<tr><td><code id="Omega_+3A_usepsych">usePsych</code></td>
<td>
<p>Should <code>psych</code> package or more precisely <code><a href="psych.html#topic+fa">psych::fa</a></code> be used to perform factor analysis. Defaults to <code>TRUE</code>. If <code>FALSE</code> or <code>psych</code> package is not available, <code><a href="stats.html#topic+factanal">stats::factanal</a></code> is used.</p>
</td></tr>
<tr><td><code id="Omega_+3A_returnfares">returnFaRes</code></td>
<td>
<p>Should results of factor analysis be returned in addition to the computed omega coefficient. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="Omega_+3A_rotation">rotation</code></td>
<td>
<p>Rotation to be used in factor analysis. Defaults to &quot;none&quot;, as it does not influence the Omega coefficient. Used only if <code>returnFaRes</code> is <code>TRUE</code>. Included if one wants to customize the results of factor analyisis. See <code><a href="psych.html#topic+fa">psych::fa</a></code> or <code><a href="stats.html#topic+factanal">stats::factanal</a></code>  for details (depending on which function is used, see <code>usePsych</code>).</p>
</td></tr>
<tr><td><code id="Omega_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code><a href="psych.html#topic+fa">psych::fa</a></code> or <code><a href="stats.html#topic+factanal">stats::factanal</a></code> (depending on which function is used, see <code>usePsych</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default just the value of the omega coefficient. If <code>returnFaRes</code> is <code>TRUE</code>, then a list with two elements:
</p>

<ul>
<li> <p><code>omega</code> - The value of the omega coefficient.
</p>
</li>
<li> <p><code>faRes</code> - The result of factor analysis.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ales Ziberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Omega(C=cor(mtcars[,1:6]),nfactors=1)
Omega(C=cor(mtcars[,1:6]),nfactors=1,returnFaRes=TRUE)
</code></pre>

<hr>
<h2 id='plotCCA'>Plot a solution of canonical correlations</h2><span id='topic+plotCCA'></span>

<h3>Description</h3>

<p>It plots the canonical solution that is obtained by the function <code><a href="#topic+cancorPlus">multiUS::cancorPlus</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCCA(
  ccRes,
  xTitle = "X",
  yTitle = "Y",
  inColors = TRUE,
  scaleLabelsFactor = 1/2,
  what = "reg",
  nDigits = 2,
  mar = c(1, 2, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCCA_+3A_ccres">ccRes</code></td>
<td>
<p>The output of  <code><a href="#topic+cancorPlus">multiUS::cancorPlus</a></code>.</p>
</td></tr>
<tr><td><code id="plotCCA_+3A_xtitle">xTitle</code></td>
<td>
<p>The title of the first set of variables.</p>
</td></tr>
<tr><td><code id="plotCCA_+3A_ytitle">yTitle</code></td>
<td>
<p>The title of the second set of variables.</p>
</td></tr>
<tr><td><code id="plotCCA_+3A_incolors">inColors</code></td>
<td>
<p>Whether plot should be plotted in colours (<code>TRUE</code>) (default) or in black and white (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plotCCA_+3A_scalelabelsfactor">scaleLabelsFactor</code></td>
<td>
<p>Parameter for setting the size of values (default is <code>1/2</code>). The size of plotted values is proportional to  its value to the power of <code>scaleLabelsFactor</code>.</p>
</td></tr>
<tr><td><code id="plotCCA_+3A_what">what</code></td>
<td>
<p>Whether to plot regression coefficients (<code>"reg"</code>) (default) or correlations (i.e., canonical structure loadings) (<code>"cor"</code>).</p>
</td></tr>
<tr><td><code id="plotCCA_+3A_ndigits">nDigits</code></td>
<td>
<p>Number of decimal places.</p>
</td></tr>
<tr><td><code id="plotCCA_+3A_mar">mar</code></td>
<td>
<p>Margins, default is <code>mar = c(1, 2, 1, 1)</code>, see <code><a href="graphics.html#topic+par">graphics::par</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It plots the plot.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp&lt;-cancorPlus(x = mtcars[, c(1,2,3)], y = mtcars[, c(4,5, 6)], useCCApackage = TRUE)
plotCCA(tmp, scaleLabelsFactor = 1/2, what = "cor")
</code></pre>

<hr>
<h2 id='plotMeans'>Plot the means</h2><span id='topic+plotMeans'></span>

<h3>Description</h3>

<p>The function plots the means of several numerical variables by the levels of one categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMeans(
  x,
  by,
  plotCI = TRUE,
  alpha = 0.05,
  ylab = "averages",
  xlab = "",
  plotLegend = TRUE,
  inset = 0.01,
  xleg = "topleft",
  legPar = list(),
  gap = 0,
  labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMeans_+3A_x">x</code></td>
<td>
<p>Data frame with values of numeric variables.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_by">by</code></td>
<td>
<p>Categorical variable that defines groups.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_plotci">plotCI</code></td>
<td>
<p>Whether to plot confidence intervals or not, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_alpha">alpha</code></td>
<td>
<p>A confidence level for calculating confidence intervals (default is <code>0.05</code>).</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_ylab">ylab</code></td>
<td>
<p>The title of <code class="reqn">y</code>-axis.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_xlab">xlab</code></td>
<td>
<p>The title of <code class="reqn">x</code>-axis.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_plotlegend">plotLegend</code></td>
<td>
<p>Whether to plot a legend or not, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_inset">inset</code></td>
<td>
<p>Inset distance(s) from the margins as a fraction of the plot region when legend is placed by keyword.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_xleg">xleg</code></td>
<td>
<p>Position of a legend, default is <code>topleft</code>.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_legpar">legPar</code></td>
<td>
<p>Additional parameters for a legend. They have to be provided in a list format.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_gap">gap</code></td>
<td>
<p>Space left between the center of the error bar and the lines marking the error bar in units of the height (width). Defaults to 1.0</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_labels">labels</code></td>
<td>
<p>Labels of x-axis.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_...">...</code></td>
<td>
<p>Arguments passed to functions <code>matplot</code> and <code>axis</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>means</code> - mean values by groups.
</p>
</li>
<li> <p><code>CI</code> - widths of confidence intervals by groups.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotMeans(x = mtcars[, c(1, 3, 5)], by = mtcars[,8])
</code></pre>

<hr>
<h2 id='predict.ldaPlus'>Predict the values of a categorical variable based on a linear discriminant function</h2><span id='topic+predict.ldaPlus'></span>

<h3>Description</h3>

<p>The function predicts the values of a categorical variable based on a linear discriminat function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ldaPlus'
predict(
  object,
  newdata,
  prior = object$prior,
  dimen,
  method = c("plug-in", "predictive", "debiased"),
  betweenGroupsWeights = object$betweenGroupsWeights,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ldaPlus_+3A_object">object</code></td>
<td>
<p>Object obtained by the <code>ldaPlus</code> function or by the <code>MASS::lda</code>.</p>
</td></tr>
<tr><td><code id="predict.ldaPlus_+3A_newdata">newdata</code></td>
<td>
<p>New dataset (without categorical variable).</p>
</td></tr>
<tr><td><code id="predict.ldaPlus_+3A_prior">prior</code></td>
<td>
<p>Prior probabilities of class membership to be used to predict values.</p>
</td></tr>
<tr><td><code id="predict.ldaPlus_+3A_dimen">dimen</code></td>
<td>
<p>The number of dimensions/linear discriminant functions to use. Defaults to all.</p>
</td></tr>
<tr><td><code id="predict.ldaPlus_+3A_method">method</code></td>
<td>
<p>Possible values are <code>plug-in</code>, <code>predictive</code> and <code>debiased</code>.</p>
</td></tr>
<tr><td><code id="predict.ldaPlus_+3A_betweengroupsweights">betweenGroupsWeights</code></td>
<td>
<p>The proportions/weights used when computing the grand/total mean from group means.</p>
</td></tr>
<tr><td><code id="predict.ldaPlus_+3A_...">...</code></td>
<td>
<p>other arguments passed to function <code>MASS::predict</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>class</code> - Predicted values of categorical variable.
</p>
</li>
<li> <p><code>posterior</code> - Posterior probabilities (the values of the Fisher's calsification linear discrimination function).
</p>
</li>
<li> <p><code>x</code> - Estimated values of discriminat function(s) for each unit.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>See Also</h3>

<p><code>MASS::predict</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the first 20 cars to estimate the model and the rest of cars to predict
# (for each car) wheter it has a V-shape engine or a straight engine.
ldaCars &lt;- ldaPlus(x = mtcars[1:20,c(1, 2, 4, 5, 6)], grouping = mtcars[1:20,8])
predict.ldaPlus(object = ldaCars, newdata = mtcars[20:32,c(1, 2, 4, 5, 6)])
</code></pre>

<hr>
<h2 id='printP'>Print p-value</h2><span id='topic+printP'></span>

<h3>Description</h3>

<p>The function round and prints <code class="reqn">p</code>-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printP(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printP_+3A_p">p</code></td>
<td>
<p>Value to be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string (formatted <code class="reqn">p</code>-value).
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>printP(p = 0.523)
printP(p = 0.022)
printP(p = 0.099)
</code></pre>

<hr>
<h2 id='renameVar'>Rename variables</h2><span id='topic+renameVar'></span>

<h3>Description</h3>

<p>The function for renaming one or several variables in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameVar(data, renames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renameVar_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="renameVar_+3A_renames">renames</code></td>
<td>
<p>A list with oldnames and newnames (e.g, <code>list("oldname1" = "newname1", "oldname2" = "newname2")</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with renamed columns.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>renameVar(mtcars, list("cyl" = "Cylinders", "wt" = "Weight", "am" = "Transmission"))
</code></pre>

<hr>
<h2 id='seqKNNimp'>Sequential KNN imputation method</h2><span id='topic+seqKNNimp'></span>

<h3>Description</h3>

<p>This function estimates missing values sequentially from the units that has least missing rate, using weighted mean of k nearest neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqKNNimp(data, k = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqKNNimp_+3A_data">data</code></td>
<td>
<p>A data frame with the data set.</p>
</td></tr>
<tr><td><code id="seqKNNimp_+3A_k">k</code></td>
<td>
<p>The number of nearest neighbours to use (defaults to 10).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function separates the dataset into an incomplete set with missing values and into a complete set without missing values.
The values in an incomplete set are imputed in the order of the number of missing values. A missing value is filled by the
weighted mean value of a corresponding column of the nearest neighbour units in the complete set. Once all missing values for
a given unit are imputed, the unit is moved into the complete set and used for the imputation of the rest of units in the
incomplete set. In this process, all missing values for one unit can be imputed simultaneously from the selected neighbour
units in the complete set. This reduces execution time from previously developed KNN method that selects nearest neighbours
for each imputation.
</p>


<h3>Value</h3>

<p>A dataframe with imputed values.
</p>


<h3>Note</h3>

<p>This is the function from package <code>SeqKNN</code> by Ki-Yeol Kim and Gwan-Su Yi.
</p>


<h3>Author(s)</h3>

<p>Ki-Yeol Kim and Gwan-Su Yi
</p>


<h3>References</h3>

<p>Ki-Yeol Kim, Byoung-Jin Kim, Gwan-Su Yi (2004.Oct.26) &quot;Reuse of imputed data in microarray analysis increases imputation efficiency&quot;, BMC Bioinformatics 5:160.
</p>


<h3>See Also</h3>

<p><code>KNNimp</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars$mpg[sample(1:nrow(mtcars), size = 5, replace = FALSE)] &lt;- NA
seqKNNimp(data = mtcars)
</code></pre>

<hr>
<h2 id='small2other'>Recoding the smallest categories to &quot;other&quot; value in case of too many or too small categories.</h2><span id='topic+small2other'></span>

<h3>Description</h3>

<p>The smallest categories are recoded to &quot;other&quot; or user specified string. The variables is converted to factor if not  already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>small2other(
  x,
  maxLevels = 12,
  minFreq = 0,
  otherValue = "other",
  convertNA = TRUE,
  orderLevels = FALSE,
  otherLast = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="small2other_+3A_x">x</code></td>
<td>
<p>The variable to be recoded.</p>
</td></tr>
<tr><td><code id="small2other_+3A_maxlevels">maxLevels</code></td>
<td>
<p>The maximum number of levels after recoding</p>
</td></tr>
<tr><td><code id="small2other_+3A_minfreq">minFreq</code></td>
<td>
<p>The minimal frequency after recoding.</p>
</td></tr>
<tr><td><code id="small2other_+3A_othervalue">otherValue</code></td>
<td>
<p>The name give to the new category</p>
</td></tr>
<tr><td><code id="small2other_+3A_convertna">convertNA</code></td>
<td>
<p>Should the <code>NA</code> values be converted to ordinary values. If <code>TRUE</code>, they are converted to string <code>"NA"</code>. If <code>FALSE</code>, there are left as missing and ignored in the recording.</p>
</td></tr>
<tr><td><code id="small2other_+3A_orderlevels">orderLevels</code></td>
<td>
<p>How should the categories be ordered. Possible values are:
</p>

<ul>
<li> <p><code>FALSE</code> - do not change the ordering (default)
</p>
</li>
<li> <p><code>alpha</code> - alphabetically; and
</p>
</li>
<li> <p>freq - based on frequencies (highest frequencies first).
</p>
</li></ul>
</td></tr>
<tr><td><code id="small2other_+3A_otherlast">otherLast</code></td>
<td>
<p>Only used if category with <code>otherValue</code> was created. If <code>TRUE</code>, the <code>otherValue</code> is placed as last category regardless of the <code>orderLevels</code> argument. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='testCC'>Test of canonical correlations</h2><span id='topic+testCC'></span>

<h3>Description</h3>

<p>The function perform the Wilk's test for the statistical significance of canonical correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testCC(cor, n, p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testCC_+3A_cor">cor</code></td>
<td>
<p>Vector with canonical correlations.</p>
</td></tr>
<tr><td><code id="testCC_+3A_n">n</code></td>
<td>
<p>Number of units.</p>
</td></tr>
<tr><td><code id="testCC_+3A_p">p</code></td>
<td>
<p>Number of variables in the first group of variables.</p>
</td></tr>
<tr><td><code id="testCC_+3A_q">q</code></td>
<td>
<p>Number of variables in the second group of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results are organized in a <code>list</code> format with two data tables:
</p>
<p><code>sigTest</code>
</p>

<ul>
<li> <p><code>WilksL</code> - Value of the Wilk's lambda statistic (it is a generalization of the multivariate R2; values near 0 indicate high correlation while values near 1 indicate low correlation).
</p>
</li>
<li> <p><code>F</code> - Corresponding (to Wilk's lambda) F-ratio.
</p>
</li>
<li> <p><code>df1</code> - Degrees of freedom for the corresponding F-ratio.
</p>
</li>
<li> <p><code>df2</code> - Degrees of freedom for the corresponding F-ratio.
</p>
</li>
<li> <p><code>p</code> - Probability value (p-value) for the corresponding F-ratio (Ho: The current and all the later canonical correlations equal to zero).
</p>
</li></ul>

<p><code>eigModel</code>
</p>

<ul>
<li> <p><code>Eigenvalues</code> - Eigenvalues of the canonical roots.
</p>
</li>
<li> <p><code>%</code> - Proportion of explained variance of correlation.
</p>
</li>
<li> <p><code>Cum %</code> - Cumulative proportion of explained variance of correlation.
</p>
</li>
<li> <p><code>Cor</code> - Canonical correlation coeficient.
</p>
</li>
<li> <p><code>Sq. Cor</code> - Squared canonical correlation coeficient.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>


<h3>References</h3>

<p>R Data Analysis Examples: Canonical Correlation Analysis, UCLA: Statistical Consulting Group. From http://www.ats.ucla.edu/stat/r/dae/canonical.htm (accessed Decembar 27, 2013).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testCC(cor = c(0.76, 0.51, 0.35, 0.28, 0.10), n = 51, p = 5, q = 5)
</code></pre>

<hr>
<h2 id='Theta'>Theta coefficient - measure of measurement internal consistency based on principal component analysis</h2><span id='topic+Theta'></span>

<h3>Description</h3>

<p>The function theta coefficient, which is a measure of measurement internal consistency based on principal component analysis, or more precisely first eigenvalue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Theta(C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Theta_+3A_c">C</code></td>
<td>
<p>Covariance or correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the theta coefficient.
</p>


<h3>Author(s)</h3>

<p>Ales Ziberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Theta(C=cor(mtcars[,1:6]))
</code></pre>

<hr>
<h2 id='wardKF'>Calculate the value of the Ward criterion function</h2><span id='topic+wardKF'></span><span id='topic+wardCF'></span>

<h3>Description</h3>

<p>The function calculate the value of the Ward criterion function, based on a set of numerical variables and one categorical variable (partition).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wardKF(X, clu)

wardCF(X, clu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wardKF_+3A_x">X</code></td>
<td>
<p>Data frame with values of numerical variables (usually the ones that were/are used for clustering).</p>
</td></tr>
<tr><td><code id="wardKF_+3A_clu">clu</code></td>
<td>
<p>Partition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the Ward criterion function.
</p>


<h3>Author(s)</h3>

<p>Aleš Žiberna
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
