<!DOCTYPE html><html><head><title>Help for package lgpr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lgpr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_dis_age'><p>Easily add the disease-related age variable to a data frame</p></a></li>
<li><a href='#add_factor'><p>Easily add a categorical covariate to a data frame</p></a></li>
<li><a href='#add_factor_crossing'><p>Add a crossing of two factors to a data frame</p></a></li>
<li><a href='#adjusted_c_hat'><p>Set the GP mean vector, taking TMM or other normalization</p>
into account</a></li>
<li><a href='#apply_scaling'><p>Apply variable scaling</p></a></li>
<li><a href='#as_character'><p>Character representations of different formula objects</p></a></li>
<li><a href='#create_model'><p>Create a model</p></a></li>
<li><a href='#create_model.covs_and_comps'><p>Parse the covariates and model components from given data and formula</p></a></li>
<li><a href='#create_model.formula'><p>Create a model formula</p></a></li>
<li><a href='#create_model.likelihood'><p>Parse the response variable and its likelihood model</p></a></li>
<li><a href='#create_model.options'><p>Parse the given modeling options</p></a></li>
<li><a href='#create_model.prior'><p>Parse given prior</p></a></li>
<li><a href='#create_plot_df'><p>Helper function for plots</p></a></li>
<li><a href='#create_scaling'><p>Create a standardizing transform</p></a></li>
<li><a href='#dinvgamma_stanlike'><p>Density and quantile functions of the inverse gamma distribution</p></a></li>
<li><a href='#draw_pred'><p>Draw pseudo-observations from posterior or prior predictive distribution</p></a></li>
<li><a href='#example_fit'><p>Quick way to create an example lgpfit, useful for debugging</p></a></li>
<li><a href='#fit_summary'><p>Print a fit summary.</p></a></li>
<li><a href='#GaussianPrediction-class'><p>An S4 class to represent analytically computed predictive distributions</p>
(conditional on hyperparameters) of an additive GP model</a></li>
<li><a href='#get_draws'><p>Extract parameter draws from lgpfit or stanfit</p></a></li>
<li><a href='#get_pred'><p>Extract model predictions and function posteriors</p></a></li>
<li><a href='#kernel'><p>Compute a kernel matrix (covariance matrix)</p></a></li>
<li><a href='#KernelComputer-class'><p>An S4 class to represent input for kernel matrix computations</p></a></li>
<li><a href='#lgp'><p>Main function of the 'lgpr' package</p></a></li>
<li><a href='#lgpexpr-class'><p>An S4 class to represent an lgp expression</p></a></li>
<li><a href='#lgpfit-class'><p>An S4 class to represent the output of the <code>lgp</code> function</p></a></li>
<li><a href='#lgpformula-class'><p>An S4 class to represent an lgp formula</p></a></li>
<li><a href='#lgpmodel-class'><p>An S4 class to represent an additive GP model</p></a></li>
<li><a href='#lgpr-package'><p>The 'lgpr' package.</p></a></li>
<li><a href='#lgprhs-class'><p>An S4 class to represent the right-hand side of an lgp formula</p></a></li>
<li><a href='#lgpscaling-class'><p>An S4 class to represent variable scaling</p></a></li>
<li><a href='#lgpsim-class'><p>An S4 class to represent a data set simulated using the additive GP</p>
formalism</a></li>
<li><a href='#lgpterm-class'><p>An S4 class to represent one formula term</p></a></li>
<li><a href='#model_summary'><p>Print a model summary.</p></a></li>
<li><a href='#new_x'><p>Create test input points for prediction</p></a></li>
<li><a href='#operations'><p>Operations on formula terms and expressions</p></a></li>
<li><a href='#plot_api_c'><p>Plot a generated/fit model component</p></a></li>
<li><a href='#plot_api_g'><p>Plot longitudinal data and/or model fit so that each subject/group has</p>
their own panel</a></li>
<li><a href='#plot_components'><p>Visualize all model components</p></a></li>
<li><a href='#plot_data'><p>Vizualizing longitudinal data</p></a></li>
<li><a href='#plot_draws'><p>Visualize the distribution of parameter draws</p></a></li>
<li><a href='#plot_inputwarp'><p>Visualize input warping function with several steepness parameter values</p></a></li>
<li><a href='#plot_invgamma'><p>Plot the inverse gamma-distribution pdf</p></a></li>
<li><a href='#plot_pred'><p>Visualizing model predictions or inferred covariate effects</p></a></li>
<li><a href='#plot_sim'><p>Visualize an lgpsim object (simulated data)</p></a></li>
<li><a href='#ppc'><p>Graphical posterior predictive checks</p></a></li>
<li><a href='#pred'><p>Posterior predictions and function posteriors</p></a></li>
<li><a href='#Prediction-class'><p>An S4 class to represent prior or posterior</p>
draws from an additive function distribution.</a></li>
<li><a href='#prior_pred'><p>Prior (predictive) sampling</p></a></li>
<li><a href='#prior_to_num'><p>Convert given prior to numeric format</p></a></li>
<li><a href='#priors'><p>Prior definitions</p></a></li>
<li><a href='#read_proteomics_data'><p>Function for reading the built-in proteomics data</p></a></li>
<li><a href='#relevances'><p>Assess component relevances</p></a></li>
<li><a href='#s4_generics'><p>S4 generics for lgpfit, lgpmodel, and other objects</p></a></li>
<li><a href='#sample_model'><p>Fitting a model</p></a></li>
<li><a href='#select'><p>Select relevant components</p></a></li>
<li><a href='#show'><p>Printing formula object info using the show generic</p></a></li>
<li><a href='#sim.create_f'><p>Simulate latent function components for longitudinal data analysis</p></a></li>
<li><a href='#sim.create_x'><p>Create an input data frame X for simulated data</p></a></li>
<li><a href='#sim.create_y'><p>Simulate noisy observations</p></a></li>
<li><a href='#sim.kernels'><p>Compute all kernel matrices when simulating data</p></a></li>
<li><a href='#simulate_data'><p>Generate an artificial longitudinal data set</p></a></li>
<li><a href='#split'><p>Split data into training and test sets</p></a></li>
<li><a href='#testdata_001'><p>A very small artificial test data, used mostly for unit tests</p></a></li>
<li><a href='#testdata_002'><p>Medium-size artificial test data, used mostly for tutorials</p></a></li>
<li><a href='#validate'><p>Validate S4 class objects</p></a></li>
<li><a href='#var_mask'><p>Variance masking function</p></a></li>
<li><a href='#warp_input'><p>Input warping function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Longitudinal Gaussian Process Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Interpretable nonparametric modeling of longitudinal data
    using additive Gaussian process regression. Contains functionality
    for inferring covariate effects and assessing covariate relevances.
    Models are specified using a convenient formula syntax, and can include
    shared, group-specific, non-stationary, heterogeneous and temporally
    uncertain effects. Bayesian inference for model parameters is performed
    using 'Stan'. The modeling approach and methods are described in detail in
    Timonen et al. (2021) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtab021">doi:10.1093/bioinformatics/btab021</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.2), RCurl (&ge; 1.98),
rstan (&ge; 2.26.0), rstantools (&ge; 2.3.1), bayesplot (&ge; 1.7.0),
MASS (&ge; 7.3-50), stats (&ge; 3.4), ggplot2 (&ge; 3.1.0), gridExtra
(&ge; 0.3.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.75.0-0), Rcpp (&ge; 1.0.6), RcppEigen (&ge; 0.3.3.9.1),
RcppParallel (&ge; 5.0.2), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jtimonen/lgpr">https://github.com/jtimonen/lgpr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jtimonen/lgpr/issues">https://github.com/jtimonen/lgpr/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-24 03:44:19 UTC; juho</td>
</tr>
<tr>
<td>Author:</td>
<td>Juho Timonen <a href="https://orcid.org/0000-0003-2341-6765"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Andrew Johnson [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juho Timonen &lt;juho.timonen@iki.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-24 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_dis_age'>Easily add the disease-related age variable to a data frame</h2><span id='topic+add_dis_age'></span>

<h3>Description</h3>

<p>Creates the disease-related age covariate vector based on the
disease initiation times and adds it to the data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dis_age(data, t_init, id_var = "id", time_var = "age")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dis_age_+3A_data">data</code></td>
<td>
<p>the original data frame</p>
</td></tr>
<tr><td><code id="add_dis_age_+3A_t_init">t_init</code></td>
<td>
<p>A named vector containing the observed initiation or onset
time for each individual. The names, i.e. <code>names(t_init)</code>, should
specify the individual id.</p>
</td></tr>
<tr><td><code id="add_dis_age_+3A_id_var">id_var</code></td>
<td>
<p>name of the id variable in <code>data</code></p>
</td></tr>
<tr><td><code id="add_dis_age_+3A_time_var">time_var</code></td>
<td>
<p>name of the time variable in <code>data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one column added. The new column will
be called <code>dis_age</code>. For controls, its value will be <code>NaN</code>.
</p>


<h3>See Also</h3>

<p>Other data frame handling functions: 
<code><a href="#topic+add_factor_crossing">add_factor_crossing</a>()</code>,
<code><a href="#topic+add_factor">add_factor</a>()</code>,
<code><a href="#topic+adjusted_c_hat">adjusted_c_hat</a>()</code>,
<code><a href="#topic+new_x">new_x</a>()</code>,
<code><a href="#topic+split">split</a>()</code>
</p>

<hr>
<h2 id='add_factor'>Easily add a categorical covariate to a data frame</h2><span id='topic+add_factor'></span>

<h3>Description</h3>

<p>Easily add a categorical covariate to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_factor(data, x, id_var = "id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_factor_+3A_data">data</code></td>
<td>
<p>the original data frame</p>
</td></tr>
<tr><td><code id="add_factor_+3A_x">x</code></td>
<td>
<p>A named vector containing the category for each individual.
The names should specify the individual id.</p>
</td></tr>
<tr><td><code id="add_factor_+3A_id_var">id_var</code></td>
<td>
<p>name of the id variable in <code>data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one column added. The new column will
have same name as the variable passed as input <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other data frame handling functions: 
<code><a href="#topic+add_dis_age">add_dis_age</a>()</code>,
<code><a href="#topic+add_factor_crossing">add_factor_crossing</a>()</code>,
<code><a href="#topic+adjusted_c_hat">adjusted_c_hat</a>()</code>,
<code><a href="#topic+new_x">new_x</a>()</code>,
<code><a href="#topic+split">split</a>()</code>
</p>

<hr>
<h2 id='add_factor_crossing'>Add a crossing of two factors to a data frame</h2><span id='topic+add_factor_crossing'></span>

<h3>Description</h3>

<p>Add a crossing of two factors to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_factor_crossing(data, fac1, fac2, new_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_factor_crossing_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="add_factor_crossing_+3A_fac1">fac1</code></td>
<td>
<p>name of first factor, must be found in <code>df</code></p>
</td></tr>
<tr><td><code id="add_factor_crossing_+3A_fac2">fac2</code></td>
<td>
<p>name of second factor, must be found in <code>df</code></p>
</td></tr>
<tr><td><code id="add_factor_crossing_+3A_new_name">new_name</code></td>
<td>
<p>name of the new factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>See Also</h3>

<p>Other data frame handling functions: 
<code><a href="#topic+add_dis_age">add_dis_age</a>()</code>,
<code><a href="#topic+add_factor">add_factor</a>()</code>,
<code><a href="#topic+adjusted_c_hat">adjusted_c_hat</a>()</code>,
<code><a href="#topic+new_x">new_x</a>()</code>,
<code><a href="#topic+split">split</a>()</code>
</p>

<hr>
<h2 id='adjusted_c_hat'>Set the GP mean vector, taking TMM or other normalization
into account</h2><span id='topic+adjusted_c_hat'></span>

<h3>Description</h3>

<p>Creates the <code>c_hat</code> input for <code>lgp</code>,
so that it accounts for normalization between data points in the
<code>"poisson"</code> or <code>"nb"</code> observation model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjusted_c_hat(y, norm_factors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjusted_c_hat_+3A_y">y</code></td>
<td>
<p>response variable, vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="adjusted_c_hat_+3A_norm_factors">norm_factors</code></td>
<td>
<p>normalization factors, vector of length <code>n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length <code>n</code>, which can be used as
the <code>c_hat</code> input to the <code>lgp</code> function
</p>


<h3>See Also</h3>

<p>Other data frame handling functions: 
<code><a href="#topic+add_dis_age">add_dis_age</a>()</code>,
<code><a href="#topic+add_factor_crossing">add_factor_crossing</a>()</code>,
<code><a href="#topic+add_factor">add_factor</a>()</code>,
<code><a href="#topic+new_x">new_x</a>()</code>,
<code><a href="#topic+split">split</a>()</code>
</p>

<hr>
<h2 id='apply_scaling'>Apply variable scaling</h2><span id='topic+apply_scaling'></span>

<h3>Description</h3>

<p>Apply variable scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_scaling(scaling, x, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_scaling_+3A_scaling">scaling</code></td>
<td>
<p>an object of class <a href="#topic+lgpscaling-class">lgpscaling</a></p>
</td></tr>
<tr><td><code id="apply_scaling_+3A_x">x</code></td>
<td>
<p>object to which apply the scaling (numeric)</p>
</td></tr>
<tr><td><code id="apply_scaling_+3A_inverse">inverse</code></td>
<td>
<p>whether scaling should be done in inverse direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a similar object as <code>x</code>
</p>


<h3>See Also</h3>

<p>Other variable scaling functions: 
<code><a href="#topic+create_scaling">create_scaling</a>()</code>
</p>

<hr>
<h2 id='as_character'>Character representations of different formula objects</h2><span id='topic+as_character'></span><span id='topic+as.character+2Clgpexpr-method'></span><span id='topic+as.character+2Clgpterm-method'></span><span id='topic+as.character+2Clgpformula-method'></span>

<h3>Description</h3>

<p>Character representations of different formula objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lgpexpr'
as.character(x)

## S4 method for signature 'lgpterm'
as.character(x)

## S4 method for signature 'lgpformula'
as.character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_character_+3A_x">x</code></td>
<td>
<p>an object of some S4 class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character representation of the object
</p>

<hr>
<h2 id='create_model'>Create a model</h2><span id='topic+create_model'></span>

<h3>Description</h3>

<p>See the
<a href="https://jtimonen.github.io/lgpr-usage/articles/math.html">Mathematical description of lgpr models</a>
vignette for more information about the connection between different options
and the created statistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_model(
  formula,
  data,
  likelihood = "gaussian",
  prior = NULL,
  c_hat = NULL,
  num_trials = NULL,
  options = NULL,
  prior_only = FALSE,
  verbose = FALSE,
  sample_f = !(likelihood == "gaussian")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_model_+3A_formula">formula</code></td>
<td>
<p>The model formula, where
</p>

<ul>
<li><p> it must contain exatly one tilde (<code>~</code>), with response
variable on the left-hand side and model terms on the right-hand side
</p>
</li>
<li><p> terms are be separated by a plus (<code>+</code>) sign
</p>
</li>
<li><p> all variables appearing in <code>formula</code> must be
found in <code>data</code>
</p>
</li></ul>

<p>See the &quot;Model formula syntax&quot; section below (<code><a href="#topic+lgp">lgp</a></code>) for
instructions on how to specify the model terms.</p>
</td></tr>
<tr><td><code id="create_model_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> where each column corresponds to one
variable, and each row is one observation. Continuous covariates and the
response variable must have type <code>"numeric"</code> and categorical covariates
must have type <code>"factor"</code>. Missing values should be indicated with
<code>NaN</code> or <code>NA</code>. The response variable cannot contain missing
values. Column names should not contain trailing or leading underscores.</p>
</td></tr>
<tr><td><code id="create_model_+3A_likelihood">likelihood</code></td>
<td>
<p>Determines the observation model. Must be either
<code>"gaussian"</code> (default), <code>"poisson"</code>, <code>"nb"</code> (negative
binomial), <code>"binomial"</code> or <code>"bb"</code> (beta binomial).</p>
</td></tr>
<tr><td><code id="create_model_+3A_prior">prior</code></td>
<td>
<p>A named list, defining the prior distribution of model
(hyper)parameters. See the &quot;Defining priors&quot; section below
(<code><a href="#topic+lgp">lgp</a></code>).</p>
</td></tr>
<tr><td><code id="create_model_+3A_c_hat">c_hat</code></td>
<td>
<p>The GP mean. This should only be given if <code>sample_f</code> is
<code>TRUE</code>, otherwise the GP will always have zero mean. If <code>sample_f</code>
is <code>TRUE</code>, the given <code>c_hat</code> can be a vector of length
<code>dim(data)[1]</code>, or a real number defining a constant GP mean. If not
specified and <code>sample_f</code> is <code>TRUE</code>, <code>c_hat</code> is set to
</p>

<ul>
<li> <p><code>c_hat = mean(y)</code>, if <code>likelihood</code> is <code>"gaussian"</code>,
</p>
</li>
<li> <p><code>c_hat = </code> <code>log(mean(y))</code> if <code>likelihood</code> is
<code>"poisson"</code> or <code>"nb"</code>,
</p>
</li>
<li> <p><code>c_hat = </code> <code>log(p/(1-p))</code>, where
<code>p = mean(y/num_trials)</code> if <code>likelihood</code> is <code>"binomial"</code>
or <code>"bb"</code>,
</p>
</li></ul>

<p>where <code>y</code> denotes the response variable measurements.</p>
</td></tr>
<tr><td><code id="create_model_+3A_num_trials">num_trials</code></td>
<td>
<p>This argument (number of trials) is only needed when
likelihood is <code>"binomial"</code> or <code>"bb"</code>. Must have length one or
equal to the number of data points. Setting <code>num_trials=1</code> and
<code>likelihood="binomial"</code> corresponds to Bernoulli observation model.</p>
</td></tr>
<tr><td><code id="create_model_+3A_options">options</code></td>
<td>
<p>A named list with the following possible fields:
</p>

<ul>
<li> <p><code>delta</code> Amount of added jitter to ensure positive definite
covariance matrices.
</p>
</li>
<li> <p><code>vm_params</code> Variance mask function parameters (numeric
vector of length 2).
</p>
</li></ul>

<p>If <code>options</code> is <code>NULL</code>, default options are used. The defaults
are equivalent to
<code>options = list(delta = 1e-8,  vm_params = c(0.025, 1))</code>.</p>
</td></tr>
<tr><td><code id="create_model_+3A_prior_only">prior_only</code></td>
<td>
<p>Should likelihood be ignored? See also
<code><a href="#topic+sample_param_prior">sample_param_prior</a></code> which can be used for any
<a href="#topic+lgpmodel-class">lgpmodel</a>, and whose runtime is independent of the number of
observations.</p>
</td></tr>
<tr><td><code id="create_model_+3A_verbose">verbose</code></td>
<td>
<p>Should some informative messages be printed?</p>
</td></tr>
<tr><td><code id="create_model_+3A_sample_f">sample_f</code></td>
<td>
<p>Determines if the latent function values are sampled
(must be <code>TRUE</code> if likelihood is not <code>"gaussian"</code>). If this is
<code>TRUE</code>, the response variable will be normalized to have zero mean
and unit variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+lgpmodel-class">lgpmodel</a>, containing the
Stan input created based on parsing the specified <code>formula</code>,
<code>prior</code>, and other options.
</p>


<h3>See Also</h3>

<p>Other main functions: 
<code><a href="#topic+draw_pred">draw_pred</a>()</code>,
<code><a href="#topic+get_draws">get_draws</a>()</code>,
<code><a href="#topic+lgp">lgp</a>()</code>,
<code><a href="#topic+pred">pred</a>()</code>,
<code><a href="#topic+prior_pred">prior_pred</a>()</code>,
<code><a href="#topic+sample_model">sample_model</a>()</code>
</p>

<hr>
<h2 id='create_model.covs_and_comps'>Parse the covariates and model components from given data and formula</h2><span id='topic+create_model.covs_and_comps'></span>

<h3>Description</h3>

<p>Parse the covariates and model components from given data and formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_model.covs_and_comps(data, model_formula, x_cont_scl, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_model.covs_and_comps_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> where each column corresponds to one
variable, and each row is one observation. Continuous covariates and the
response variable must have type <code>"numeric"</code> and categorical covariates
must have type <code>"factor"</code>. Missing values should be indicated with
<code>NaN</code> or <code>NA</code>. The response variable cannot contain missing
values. Column names should not contain trailing or leading underscores.</p>
</td></tr>
<tr><td><code id="create_model.covs_and_comps_+3A_model_formula">model_formula</code></td>
<td>
<p>an object of class <a href="#topic+lgpformula-class">lgpformula</a></p>
</td></tr>
<tr><td><code id="create_model.covs_and_comps_+3A_x_cont_scl">x_cont_scl</code></td>
<td>
<p>Information on how to scale the continuous covariates.
This can either be
</p>

<ul>
<li><p> an existing list of objects with class <a href="#topic+lgpscaling-class">lgpscaling</a>, or
</p>
</li>
<li> <p><code>NA</code>, in which case such list is created by computing mean
and standard deviation from <code>data</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_model.covs_and_comps_+3A_verbose">verbose</code></td>
<td>
<p>Should some informative messages be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parsed input to Stan and covariate scaling, and other info
</p>


<h3>See Also</h3>

<p>Other internal model creation functions: 
<code><a href="#topic+create_model.formula">create_model.formula</a>()</code>,
<code><a href="#topic+create_model.likelihood">create_model.likelihood</a>()</code>,
<code><a href="#topic+create_model.prior">create_model.prior</a>()</code>
</p>

<hr>
<h2 id='create_model.formula'>Create a model formula</h2><span id='topic+create_model.formula'></span>

<h3>Description</h3>

<p>Checks if formula is in advanced format and translates if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_model.formula(formula, data, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_model.formula_+3A_formula">formula</code></td>
<td>
<p>The model formula, where
</p>

<ul>
<li><p> it must contain exatly one tilde (<code>~</code>), with response
variable on the left-hand side and model terms on the right-hand side
</p>
</li>
<li><p> terms are be separated by a plus (<code>+</code>) sign
</p>
</li>
<li><p> all variables appearing in <code>formula</code> must be
found in <code>data</code>
</p>
</li></ul>

<p>See the &quot;Model formula syntax&quot; section below (<code><a href="#topic+lgp">lgp</a></code>) for
instructions on how to specify the model terms.</p>
</td></tr>
<tr><td><code id="create_model.formula_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> where each column corresponds to one
variable, and each row is one observation. Continuous covariates and the
response variable must have type <code>"numeric"</code> and categorical covariates
must have type <code>"factor"</code>. Missing values should be indicated with
<code>NaN</code> or <code>NA</code>. The response variable cannot contain missing
values. Column names should not contain trailing or leading underscores.</p>
</td></tr>
<tr><td><code id="create_model.formula_+3A_verbose">verbose</code></td>
<td>
<p>Should some informative messages be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <a href="#topic+lgpformula-class">lgpformula</a>
</p>


<h3>See Also</h3>

<p>Other internal model creation functions: 
<code><a href="#topic+create_model.covs_and_comps">create_model.covs_and_comps</a>()</code>,
<code><a href="#topic+create_model.likelihood">create_model.likelihood</a>()</code>,
<code><a href="#topic+create_model.prior">create_model.prior</a>()</code>
</p>

<hr>
<h2 id='create_model.likelihood'>Parse the response variable and its likelihood model</h2><span id='topic+create_model.likelihood'></span>

<h3>Description</h3>

<p>Parse the response variable and its likelihood model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_model.likelihood(
  data,
  likelihood,
  c_hat,
  num_trials,
  y_name,
  sample_f,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_model.likelihood_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> where each column corresponds to one
variable, and each row is one observation. Continuous covariates and the
response variable must have type <code>"numeric"</code> and categorical covariates
must have type <code>"factor"</code>. Missing values should be indicated with
<code>NaN</code> or <code>NA</code>. The response variable cannot contain missing
values. Column names should not contain trailing or leading underscores.</p>
</td></tr>
<tr><td><code id="create_model.likelihood_+3A_likelihood">likelihood</code></td>
<td>
<p>Determines the observation model. Must be either
<code>"gaussian"</code> (default), <code>"poisson"</code>, <code>"nb"</code> (negative
binomial), <code>"binomial"</code> or <code>"bb"</code> (beta binomial).</p>
</td></tr>
<tr><td><code id="create_model.likelihood_+3A_c_hat">c_hat</code></td>
<td>
<p>The GP mean. This should only be given if <code>sample_f</code> is
<code>TRUE</code>, otherwise the GP will always have zero mean. If <code>sample_f</code>
is <code>TRUE</code>, the given <code>c_hat</code> can be a vector of length
<code>dim(data)[1]</code>, or a real number defining a constant GP mean. If not
specified and <code>sample_f</code> is <code>TRUE</code>, <code>c_hat</code> is set to
</p>

<ul>
<li> <p><code>c_hat = mean(y)</code>, if <code>likelihood</code> is <code>"gaussian"</code>,
</p>
</li>
<li> <p><code>c_hat = </code> <code>log(mean(y))</code> if <code>likelihood</code> is
<code>"poisson"</code> or <code>"nb"</code>,
</p>
</li>
<li> <p><code>c_hat = </code> <code>log(p/(1-p))</code>, where
<code>p = mean(y/num_trials)</code> if <code>likelihood</code> is <code>"binomial"</code>
or <code>"bb"</code>,
</p>
</li></ul>

<p>where <code>y</code> denotes the response variable measurements.</p>
</td></tr>
<tr><td><code id="create_model.likelihood_+3A_num_trials">num_trials</code></td>
<td>
<p>This argument (number of trials) is only needed when
likelihood is <code>"binomial"</code> or <code>"bb"</code>. Must have length one or
equal to the number of data points. Setting <code>num_trials=1</code> and
<code>likelihood="binomial"</code> corresponds to Bernoulli observation model.</p>
</td></tr>
<tr><td><code id="create_model.likelihood_+3A_y_name">y_name</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="create_model.likelihood_+3A_sample_f">sample_f</code></td>
<td>
<p>Determines if the latent function values are sampled
(must be <code>TRUE</code> if likelihood is not <code>"gaussian"</code>). If this is
<code>TRUE</code>, the response variable will be normalized to have zero mean
and unit variance.</p>
</td></tr>
<tr><td><code id="create_model.likelihood_+3A_verbose">verbose</code></td>
<td>
<p>Should some informative messages be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of parsed options
</p>


<h3>See Also</h3>

<p>Other internal model creation functions: 
<code><a href="#topic+create_model.covs_and_comps">create_model.covs_and_comps</a>()</code>,
<code><a href="#topic+create_model.formula">create_model.formula</a>()</code>,
<code><a href="#topic+create_model.prior">create_model.prior</a>()</code>
</p>

<hr>
<h2 id='create_model.options'>Parse the given modeling options</h2><span id='topic+create_model.options'></span>

<h3>Description</h3>

<p>Parse the given modeling options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_model.options(options, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_model.options_+3A_options">options</code></td>
<td>
<p>A named list with the following possible fields:
</p>

<ul>
<li> <p><code>delta</code> Amount of added jitter to ensure positive definite
covariance matrices.
</p>
</li>
<li> <p><code>vm_params</code> Variance mask function parameters (numeric
vector of length 2).
</p>
</li></ul>

<p>If <code>options</code> is <code>NULL</code>, default options are used. The defaults
are equivalent to
<code>options = list(delta = 1e-8,  vm_params = c(0.025, 1))</code>.</p>
</td></tr>
<tr><td><code id="create_model.options_+3A_verbose">verbose</code></td>
<td>
<p>Should some informative messages be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of parsed options
</p>

<hr>
<h2 id='create_model.prior'>Parse given prior</h2><span id='topic+create_model.prior'></span>

<h3>Description</h3>

<p>Parse given prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_model.prior(prior, stan_input, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_model.prior_+3A_prior">prior</code></td>
<td>
<p>A named list, defining the prior distribution of model
(hyper)parameters. See the &quot;Defining priors&quot; section below
(<code><a href="#topic+lgp">lgp</a></code>).</p>
</td></tr>
<tr><td><code id="create_model.prior_+3A_stan_input">stan_input</code></td>
<td>
<p>a list of stan input fields</p>
</td></tr>
<tr><td><code id="create_model.prior_+3A_verbose">verbose</code></td>
<td>
<p>Should some informative messages be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of parsed options
</p>


<h3>See Also</h3>

<p>Other internal model creation functions: 
<code><a href="#topic+create_model.covs_and_comps">create_model.covs_and_comps</a>()</code>,
<code><a href="#topic+create_model.formula">create_model.formula</a>()</code>,
<code><a href="#topic+create_model.likelihood">create_model.likelihood</a>()</code>
</p>

<hr>
<h2 id='create_plot_df'>Helper function for plots</h2><span id='topic+create_plot_df'></span>

<h3>Description</h3>

<p>Helper function for plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_plot_df(object, x = "age", group_by = "id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_plot_df_+3A_object">object</code></td>
<td>
<p>model or fit</p>
</td></tr>
<tr><td><code id="create_plot_df_+3A_x">x</code></td>
<td>
<p>x-axis variable name</p>
</td></tr>
<tr><td><code id="create_plot_df_+3A_group_by">group_by</code></td>
<td>
<p>grouping variable name (use <code>NULL</code> for no grouping)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>

<hr>
<h2 id='create_scaling'>Create a standardizing transform</h2><span id='topic+create_scaling'></span>

<h3>Description</h3>

<p>Create a standardizing transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_scaling(x, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_scaling_+3A_x">x</code></td>
<td>
<p>variable measurements (might contain <code>NA</code> or <code>NaN</code>)</p>
</td></tr>
<tr><td><code id="create_scaling_+3A_name">name</code></td>
<td>
<p>variable name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <a href="#topic+lgpscaling-class">lgpscaling</a>
</p>


<h3>See Also</h3>

<p>Other variable scaling functions: 
<code><a href="#topic+apply_scaling">apply_scaling</a>()</code>
</p>

<hr>
<h2 id='dinvgamma_stanlike'>Density and quantile functions of the inverse gamma distribution</h2><span id='topic+dinvgamma_stanlike'></span><span id='topic+qinvgamma_stanlike'></span>

<h3>Description</h3>

<p>Using the same parametrization as Stan. More info
<a href="https://mc-stan.org/docs/2_24/functions-reference/inverse-gamma-distribution.html">here</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgamma_stanlike(x, alpha, beta, log = FALSE)

qinvgamma_stanlike(p, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dinvgamma_stanlike_+3A_x">x</code></td>
<td>
<p>point where to compute the density</p>
</td></tr>
<tr><td><code id="dinvgamma_stanlike_+3A_alpha">alpha</code></td>
<td>
<p>positive real number</p>
</td></tr>
<tr><td><code id="dinvgamma_stanlike_+3A_beta">beta</code></td>
<td>
<p>positive real number</p>
</td></tr>
<tr><td><code id="dinvgamma_stanlike_+3A_log">log</code></td>
<td>
<p>is log-scale used?</p>
</td></tr>
<tr><td><code id="dinvgamma_stanlike_+3A_p">p</code></td>
<td>
<p>quantile (must be between 0 and 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density/quantile value
</p>


<h3>See Also</h3>

<p>Other functions related to the inverse-gamma distribution: 
<code><a href="#topic+plot_invgamma">plot_invgamma</a>()</code>,
<code><a href="#topic+priors">priors</a></code>
</p>

<hr>
<h2 id='draw_pred'>Draw pseudo-observations from posterior or prior predictive distribution</h2><span id='topic+draw_pred'></span>

<h3>Description</h3>

<p>Draw pseudo-observations from predictive distribution.
If <code>pred</code> contains draws from the component posterior (prior)
distributions, then the output is draws from the posterior (prior)
predictive distribution. If <code>pred</code> is not specified, then
whether output draws are from prior or posterior predictive distribution
depends on whether <code>fit</code> is created using the <code><a href="#topic+lgp">lgp</a></code>
option <code>prior_only=TRUE</code> or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_pred(fit, pred = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_pred_+3A_fit">fit</code></td>
<td>
<p>An object of class <a href="#topic+lgpfit-class">lgpfit</a> that has been created
using the <code><a href="#topic+lgp">lgp</a></code> option <code>sample_f=TRUE</code>.</p>
</td></tr>
<tr><td><code id="draw_pred_+3A_pred">pred</code></td>
<td>
<p>An object of class <a href="#topic+Prediction-class">Prediction</a>, containing
draws of each model component. If <code>NULL</code>, this is
obtained using <code>get_pred(fit)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with shape <code class="reqn">S x P</code>, where <code class="reqn">S</code> is the number of
draws that <code>pred</code> contains and <code class="reqn">P</code> is the length of each
function draw.
Each row <code class="reqn">s = 1, \ldots, S</code> of the output is one vector drawn from the
predictive distribution, given parameter draw <code class="reqn">s</code>.
</p>


<h3>See Also</h3>

<p>Other main functions: 
<code><a href="#topic+create_model">create_model</a>()</code>,
<code><a href="#topic+get_draws">get_draws</a>()</code>,
<code><a href="#topic+lgp">lgp</a>()</code>,
<code><a href="#topic+pred">pred</a>()</code>,
<code><a href="#topic+prior_pred">prior_pred</a>()</code>,
<code><a href="#topic+sample_model">sample_model</a>()</code>
</p>

<hr>
<h2 id='example_fit'>Quick way to create an example lgpfit, useful for debugging</h2><span id='topic+example_fit'></span>

<h3>Description</h3>

<p>Quick way to create an example lgpfit, useful for debugging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_fit(
  formula = y ~ id + age + age | SEX + age | LOC,
  likelihood = "gaussian",
  chains = 1,
  iter = 30,
  num_indiv = 6,
  num_timepoints = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_fit_+3A_formula">formula</code></td>
<td>
<p>model formula</p>
</td></tr>
<tr><td><code id="example_fit_+3A_likelihood">likelihood</code></td>
<td>
<p>observation model</p>
</td></tr>
<tr><td><code id="example_fit_+3A_chains">chains</code></td>
<td>
<p>number of chains to run</p>
</td></tr>
<tr><td><code id="example_fit_+3A_iter">iter</code></td>
<td>
<p>number of iterations to run</p>
</td></tr>
<tr><td><code id="example_fit_+3A_num_indiv">num_indiv</code></td>
<td>
<p>number of individuals (data simulation)</p>
</td></tr>
<tr><td><code id="example_fit_+3A_num_timepoints">num_timepoints</code></td>
<td>
<p>number of time points (data simulation)</p>
</td></tr>
<tr><td><code id="example_fit_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+lgp">lgp</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+lgpfit-class">lgpfit</a> object created by fitting
the example model.
</p>

<hr>
<h2 id='fit_summary'>Print a fit summary.</h2><span id='topic+fit_summary'></span>

<h3>Description</h3>

<p>Print a fit summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_summary(fit, ignore_pars = c("f_latent", "eta", "teff_raw", "lp__"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_summary_+3A_fit">fit</code></td>
<td>
<p>an object of class <a href="#topic+lgpfit-class">lgpfit</a></p>
</td></tr>
<tr><td><code id="fit_summary_+3A_ignore_pars">ignore_pars</code></td>
<td>
<p>parameters and generated quantities to ignore from output</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> invisibly.
</p>

<hr>
<h2 id='GaussianPrediction-class'>An S4 class to represent analytically computed predictive distributions
(conditional on hyperparameters) of an additive GP model</h2><span id='topic+GaussianPrediction-class'></span><span id='topic+GaussianPrediction'></span><span id='topic+show+2CGaussianPrediction-method'></span><span id='topic+component_names+2CGaussianPrediction-method'></span><span id='topic+num_components+2CGaussianPrediction-method'></span><span id='topic+num_paramsets+2CGaussianPrediction-method'></span><span id='topic+num_evalpoints+2CGaussianPrediction-method'></span>

<h3>Description</h3>

<p>An S4 class to represent analytically computed predictive distributions
(conditional on hyperparameters) of an additive GP model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GaussianPrediction'
show(object)

## S4 method for signature 'GaussianPrediction'
component_names(object)

## S4 method for signature 'GaussianPrediction'
num_components(object)

## S4 method for signature 'GaussianPrediction'
num_paramsets(object)

## S4 method for signature 'GaussianPrediction'
num_evalpoints(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussianPrediction-class_+3A_object">object</code></td>
<td>
<p><a href="#topic+GaussianPrediction-class">GaussianPrediction</a> object for which to apply a
class method.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(GaussianPrediction)</code>: Print a summary about the object.
</p>
</li>
<li> <p><code>component_names(GaussianPrediction)</code>: Get names of components.
</p>
</li>
<li> <p><code>num_components(GaussianPrediction)</code>: Get number of components.
</p>
</li>
<li> <p><code>num_paramsets(GaussianPrediction)</code>: Get number of parameter combinations
(different parameter vectors) using which predictions were computed.
</p>
</li>
<li> <p><code>num_evalpoints(GaussianPrediction)</code>: Get number of points where
predictions were computed.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>f_comp_mean</code></dt><dd><p>component means</p>
</dd>
<dt><code>f_comp_std</code></dt><dd><p>component standard deviations</p>
</dd>
<dt><code>f_mean</code></dt><dd><p>signal mean (on normalized scale)</p>
</dd>
<dt><code>f_std</code></dt><dd><p>signal standard deviation (on normalized scale)</p>
</dd>
<dt><code>y_mean</code></dt><dd><p>predictive mean (on original data scale)</p>
</dd>
<dt><code>y_std</code></dt><dd><p>predictive standard deviation (on original data scale)</p>
</dd>
<dt><code>x</code></dt><dd><p>a data frame of points (covariate values) where the
function posteriors or predictive distributions have been evaluated</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+Prediction-class">Prediction</a>
</p>

<hr>
<h2 id='get_draws'>Extract parameter draws from lgpfit or stanfit</h2><span id='topic+get_draws'></span>

<h3>Description</h3>

<p>Uses <code><a href="rstan.html#topic+extract">extract</a></code>
with <code>permuted = FALSE</code> and <code>inc_warmup = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_draws(object, draws = NULL, reduce = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_draws_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+lgpfit-class">lgpfit</a> or <code>stanfit</code>.</p>
</td></tr>
<tr><td><code id="get_draws_+3A_draws">draws</code></td>
<td>
<p>Indices of the parameter draws. <code>NULL</code> corresponds to
all post-warmup draws.</p>
</td></tr>
<tr><td><code id="get_draws_+3A_reduce">reduce</code></td>
<td>
<p>Function used to reduce all parameter draws into
one set of parameters. Ignored if <code>NULL</code>, or if <code>draws</code> is not
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_draws_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>rstan::extract()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is always a 2-dimensional array of shape
<code>num_param_sets</code> x <code>num_params</code>.
</p>


<h3>See Also</h3>

<p>Other main functions: 
<code><a href="#topic+create_model">create_model</a>()</code>,
<code><a href="#topic+draw_pred">draw_pred</a>()</code>,
<code><a href="#topic+lgp">lgp</a>()</code>,
<code><a href="#topic+pred">pred</a>()</code>,
<code><a href="#topic+prior_pred">prior_pred</a>()</code>,
<code><a href="#topic+sample_model">sample_model</a>()</code>
</p>

<hr>
<h2 id='get_pred'>Extract model predictions and function posteriors</h2><span id='topic+get_pred'></span>

<h3>Description</h3>

<p><em>NOTE:</em> It is not recommended for users to call this. Use
<code><a href="#topic+pred">pred</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pred(fit, draws = NULL, reduce = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pred_+3A_fit">fit</code></td>
<td>
<p>An object of class <a href="#topic+lgpfit-class">lgpfit</a>.</p>
</td></tr>
<tr><td><code id="get_pred_+3A_draws">draws</code></td>
<td>
<p>Indices of parameter draws to use, or <code>NULL</code> to use all
draws.</p>
</td></tr>
<tr><td><code id="get_pred_+3A_reduce">reduce</code></td>
<td>
<p>Reduction for parameters draws. Can be a function that
is applied to reduce all parameter draws into one parameter set, or
<code>NULL</code> (no reduction). Has no effect if <code>draws</code> is specified.</p>
</td></tr>
<tr><td><code id="get_pred_+3A_verbose">verbose</code></td>
<td>
<p>Should more information and a possible progress bar be
printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <a href="#topic+GaussianPrediction-class">GaussianPrediction</a> or
<a href="#topic+Prediction-class">Prediction</a>
</p>

<hr>
<h2 id='kernel'>Compute a kernel matrix (covariance matrix)</h2><span id='topic+kernel'></span><span id='topic+kernel_eq'></span><span id='topic+kernel_ns'></span><span id='topic+kernel_zerosum'></span><span id='topic+kernel_bin'></span><span id='topic+kernel_cat'></span><span id='topic+kernel_varmask'></span><span id='topic+kernel_beta'></span>

<h3>Description</h3>

<p>These have <code>STAN_kernel_*</code> counterparts. These R versions
are provided for reference and are not optimized for speed. These are
used when generating simulated data, and not during model inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_eq(x1, x2, alpha = 1, ell)

kernel_ns(x1, x2, alpha = 1, ell, a)

kernel_zerosum(x1, x2, M)

kernel_bin(x1, x2, pos_class = 0)

kernel_cat(x1, x2)

kernel_varmask(x1, x2, a, vm_params)

kernel_beta(beta, idx1_expand, idx2_expand)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_+3A_x1">x1</code></td>
<td>
<p>vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="kernel_+3A_x2">x2</code></td>
<td>
<p>vector of length <code class="reqn">m</code></p>
</td></tr>
<tr><td><code id="kernel_+3A_alpha">alpha</code></td>
<td>
<p>marginal std (default = 1)</p>
</td></tr>
<tr><td><code id="kernel_+3A_ell">ell</code></td>
<td>
<p>lengthscale</p>
</td></tr>
<tr><td><code id="kernel_+3A_a">a</code></td>
<td>
<p>steepness of the warping function rise</p>
</td></tr>
<tr><td><code id="kernel_+3A_m">M</code></td>
<td>
<p>number of categories</p>
</td></tr>
<tr><td><code id="kernel_+3A_pos_class">pos_class</code></td>
<td>
<p>binary (mask) kernel function has value one if both inputs
have this value, other wise it is zero</p>
</td></tr>
<tr><td><code id="kernel_+3A_vm_params">vm_params</code></td>
<td>
<p>vector of two mask function parameters.</p>
</td></tr>
<tr><td><code id="kernel_+3A_beta">beta</code></td>
<td>
<p>a parameter vector (row vector) of length <code>N_cases</code></p>
</td></tr>
<tr><td><code id="kernel_+3A_idx1_expand">idx1_expand</code></td>
<td>
<p>integer vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="kernel_+3A_idx2_expand">idx2_expand</code></td>
<td>
<p>integer vector of length <code class="reqn">m</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code class="reqn">n</code> x <code class="reqn">m</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>kernel_eq()</code>: Uses the exponentiated quadratic kernel.
</p>
</li>
<li> <p><code>kernel_ns()</code>: Uses the non-stationary kernel (input warping + squared
exponential).
</p>
</li>
<li> <p><code>kernel_zerosum()</code>: Uses the zero-sum kernel. Here, <code>x1</code> and
<code>x2</code> must be integer vectors (integers denoting different categories).
Returns a binary matrix.
</p>
</li>
<li> <p><code>kernel_bin()</code>: Uses the binary (mask) kernel. Here, <code>x1</code> and
<code>x2</code> must be integer vectors (integers denoting different categories).
Returns a binary matrix.
</p>
</li>
<li> <p><code>kernel_cat()</code>: Uses the categorical kernel. Here, <code>x1</code> and
<code>x2</code> must be integer vectors (integers denoting different categories).
Returns a binary matrix.
</p>
</li>
<li> <p><code>kernel_varmask()</code>: Computes variance mask multiplier matrix. <code>NaN</code>'s
in <code>x1</code> and <code>x2</code> will be replaced by 0.
</p>
</li>
<li> <p><code>kernel_beta()</code>: Computes the heterogeneity multiplier matrix.
<em>NOTE:</em> <code>idx_expand</code> needs to be given so that
<code>idx_expand[j]-1</code> tells the index of the beta parameter that should be
used for the <code class="reqn">j</code>th observation. If observation <code class="reqn">j</code> doesn't
correspond to any beta parameter, then <code>idx_expand[j]</code> should be 1.
</p>
</li></ul>

<hr>
<h2 id='KernelComputer-class'>An S4 class to represent input for kernel matrix computations</h2><span id='topic+KernelComputer-class'></span><span id='topic+KernelComputer'></span><span id='topic+show+2CKernelComputer-method'></span><span id='topic+num_components+2CKernelComputer-method'></span><span id='topic+num_evalpoints+2CKernelComputer-method'></span><span id='topic+num_paramsets+2CKernelComputer-method'></span><span id='topic+component_names+2CKernelComputer-method'></span>

<h3>Description</h3>

<p>An S4 class to represent input for kernel matrix computations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KernelComputer'
show(object)

## S4 method for signature 'KernelComputer'
num_components(object)

## S4 method for signature 'KernelComputer'
num_evalpoints(object)

## S4 method for signature 'KernelComputer'
num_paramsets(object)

## S4 method for signature 'KernelComputer'
component_names(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KernelComputer-class_+3A_object">object</code></td>
<td>
<p>The object for which to call a class method.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(KernelComputer)</code>: Print a summary about the object.
</p>
</li>
<li> <p><code>num_components(KernelComputer)</code>: Get number of components.
</p>
</li>
<li> <p><code>num_evalpoints(KernelComputer)</code>: Get number of evaluation points.
</p>
</li>
<li> <p><code>num_paramsets(KernelComputer)</code>: Get number of parameter sets.
</p>
</li>
<li> <p><code>component_names(KernelComputer)</code>: Get component names.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>input</code></dt><dd><p>Common input (for example parameter values).</p>
</dd>
<dt><code>K_input</code></dt><dd><p>Input for computing kernel matrices between data points
(<code>N</code> x <code>N</code>). A list.</p>
</dd>
<dt><code>Ks_input</code></dt><dd><p>Input for computing kernel matrices between data and output
points (<code>P</code> x <code>N</code>). A list.</p>
</dd>
<dt><code>Kss_input</code></dt><dd><p>Input for computing kernel matrices between output
points (<code>P</code> x <code>P</code>). A list, empty if <code>full_covariance=FALSE</code>.</p>
</dd>
<dt><code>comp_names</code></dt><dd><p>Component names (character vector).</p>
</dd>
<dt><code>full_covariance</code></dt><dd><p>Boolean value determining if this can compute
full predictive covariance matrices (or just marginal variance at
each point).</p>
</dd>
<dt><code>no_separate_output_points</code></dt><dd><p>Boolean value determining if
<code>Ks_input</code> and <code>Kss_input</code> are the same thing. Using this
knowledge can reduce unnecessary computations of kernel matrices.</p>
</dd>
<dt><code>STREAM</code></dt><dd><p>external pointer (for calling 'Stan' functions)</p>
</dd>
</dl>

<hr>
<h2 id='lgp'>Main function of the 'lgpr' package</h2><span id='topic+lgp'></span>

<h3>Description</h3>

<p>Creates an additive Gaussian process model using
<code><a href="#topic+create_model">create_model</a></code> and fits it using <code><a href="#topic+sample_model">sample_model</a></code>.
See the
<a href="https://jtimonen.github.io/lgpr-usage/articles/math.html">Mathematical description of lgpr models</a>
vignette for more information about the connection between different options
and the created statistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgp(
  formula,
  data,
  likelihood = "gaussian",
  prior = NULL,
  c_hat = NULL,
  num_trials = NULL,
  options = NULL,
  prior_only = FALSE,
  verbose = FALSE,
  sample_f = !(likelihood == "gaussian"),
  quiet = FALSE,
  skip_postproc = sample_f,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgp_+3A_formula">formula</code></td>
<td>
<p>The model formula, where
</p>

<ul>
<li><p> it must contain exatly one tilde (<code>~</code>), with response
variable on the left-hand side and model terms on the right-hand side
</p>
</li>
<li><p> terms are be separated by a plus (<code>+</code>) sign
</p>
</li>
<li><p> all variables appearing in <code>formula</code> must be
found in <code>data</code>
</p>
</li></ul>

<p>See the &quot;Model formula syntax&quot; section below (<code><a href="#topic+lgp">lgp</a></code>) for
instructions on how to specify the model terms.</p>
</td></tr>
<tr><td><code id="lgp_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> where each column corresponds to one
variable, and each row is one observation. Continuous covariates and the
response variable must have type <code>"numeric"</code> and categorical covariates
must have type <code>"factor"</code>. Missing values should be indicated with
<code>NaN</code> or <code>NA</code>. The response variable cannot contain missing
values. Column names should not contain trailing or leading underscores.</p>
</td></tr>
<tr><td><code id="lgp_+3A_likelihood">likelihood</code></td>
<td>
<p>Determines the observation model. Must be either
<code>"gaussian"</code> (default), <code>"poisson"</code>, <code>"nb"</code> (negative
binomial), <code>"binomial"</code> or <code>"bb"</code> (beta binomial).</p>
</td></tr>
<tr><td><code id="lgp_+3A_prior">prior</code></td>
<td>
<p>A named list, defining the prior distribution of model
(hyper)parameters. See the &quot;Defining priors&quot; section below
(<code><a href="#topic+lgp">lgp</a></code>).</p>
</td></tr>
<tr><td><code id="lgp_+3A_c_hat">c_hat</code></td>
<td>
<p>The GP mean. This should only be given if <code>sample_f</code> is
<code>TRUE</code>, otherwise the GP will always have zero mean. If <code>sample_f</code>
is <code>TRUE</code>, the given <code>c_hat</code> can be a vector of length
<code>dim(data)[1]</code>, or a real number defining a constant GP mean. If not
specified and <code>sample_f</code> is <code>TRUE</code>, <code>c_hat</code> is set to
</p>

<ul>
<li> <p><code>c_hat = mean(y)</code>, if <code>likelihood</code> is <code>"gaussian"</code>,
</p>
</li>
<li> <p><code>c_hat = </code> <code>log(mean(y))</code> if <code>likelihood</code> is
<code>"poisson"</code> or <code>"nb"</code>,
</p>
</li>
<li> <p><code>c_hat = </code> <code>log(p/(1-p))</code>, where
<code>p = mean(y/num_trials)</code> if <code>likelihood</code> is <code>"binomial"</code>
or <code>"bb"</code>,
</p>
</li></ul>

<p>where <code>y</code> denotes the response variable measurements.</p>
</td></tr>
<tr><td><code id="lgp_+3A_num_trials">num_trials</code></td>
<td>
<p>This argument (number of trials) is only needed when
likelihood is <code>"binomial"</code> or <code>"bb"</code>. Must have length one or
equal to the number of data points. Setting <code>num_trials=1</code> and
<code>likelihood="binomial"</code> corresponds to Bernoulli observation model.</p>
</td></tr>
<tr><td><code id="lgp_+3A_options">options</code></td>
<td>
<p>A named list with the following possible fields:
</p>

<ul>
<li> <p><code>delta</code> Amount of added jitter to ensure positive definite
covariance matrices.
</p>
</li>
<li> <p><code>vm_params</code> Variance mask function parameters (numeric
vector of length 2).
</p>
</li></ul>

<p>If <code>options</code> is <code>NULL</code>, default options are used. The defaults
are equivalent to
<code>options = list(delta = 1e-8,  vm_params = c(0.025, 1))</code>.</p>
</td></tr>
<tr><td><code id="lgp_+3A_prior_only">prior_only</code></td>
<td>
<p>Should likelihood be ignored? See also
<code><a href="#topic+sample_param_prior">sample_param_prior</a></code> which can be used for any
<a href="#topic+lgpmodel-class">lgpmodel</a>, and whose runtime is independent of the number of
observations.</p>
</td></tr>
<tr><td><code id="lgp_+3A_verbose">verbose</code></td>
<td>
<p>Can messages be printed during model creation? Has no
effect if <code>quiet=TRUE</code>.</p>
</td></tr>
<tr><td><code id="lgp_+3A_sample_f">sample_f</code></td>
<td>
<p>Determines if the latent function values are sampled
(must be <code>TRUE</code> if likelihood is not <code>"gaussian"</code>). If this is
<code>TRUE</code>, the response variable will be normalized to have zero mean
and unit variance.</p>
</td></tr>
<tr><td><code id="lgp_+3A_quiet">quiet</code></td>
<td>
<p>Should all output messages be suppressed? You need to set
also <code>refresh=0</code> if you want to suppress also the progress update
messages from <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
<tr><td><code id="lgp_+3A_skip_postproc">skip_postproc</code></td>
<td>
<p>Should all postprocessing be skipped? If this is
<code>TRUE</code>, the returned <a href="#topic+lgpfit-class">lgpfit</a> object will likely be
much smaller (if <code>sample_f=FALSE</code>).</p>
</td></tr>
<tr><td><code id="lgp_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to
<code><a href="rstan.html#topic+sampling">sampling</a></code> or <code><a href="rstan.html#topic+optimizing">optimizing</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the S4 class <a href="#topic+lgpfit-class">lgpfit</a>.
</p>


<h3>Model formula syntax</h3>

<p>There are two ways to define the model formula:
</p>

<ol>
<li><p> Using a common <code><a href="stats.html#topic+formula">formula</a></code>-like syntax, like in
<code>y ~ age +</code> <code>age|id</code> <code> + sex</code>. Terms can consist of a
single variable, such as <code>age</code>, or an interaction of two variables,
such as <code>age|id</code>. In single-variable terms, the variable can be either
continuous (numeric) or categorical (factor), whereas in interaction terms
the variable on the left-hand side of the vertical bar (<code>|</code>) has to
be continuous and the one on the right-hand side has to be categorical.
Formulae specified using this syntax are translated to the advanced format
so that
</p>

<ul>
<li><p> single-variable terms become <code>gp(x)</code> if
variable <code>x</code> is numeric and <code>zs(x)</code> if <code>x</code> is a factor
</p>
</li>
<li><p> interaction terms <code>x|z</code> become <code>gp(x)*zs(z)</code>
</p>
</li></ul>

</li>
<li><p> Using the advanced syntax, like in <code>y ~ gp(age) +</code>
<code>gp(age)*zs(id) +</code> <code>het(id)*gp_vm(disAge)</code>.
This creates <a href="#topic+lgprhs-class">lgprhs</a> objects, which consist of
<a href="#topic+lgpterm-class">lgpterm</a>s, which consist of <a href="#topic+lgpexpr-class">lgpexpr</a>s.
This approach must be used if creating nonstationary, heterogeneous or
temporally uncertain components.
</p>
</li></ol>

<p>Either one of the approaches should be used and they should not be mixed.
</p>


<h3>Defining priors</h3>

<p>The <code>prior</code> argument must be a named list, like
<code>list(alpha=student_t(4), wrp=igam(30,10))</code>. See examples in tutorials.
Possible allowed names are
</p>

<ul>
<li> <p><code>"alpha"</code> = component magnitude parameters
</p>
</li>
<li> <p><code>"ell"</code> = component lengthscale parameters
</p>
</li>
<li> <p><code>"wrp"</code> = input warping steepness parameters
</p>
</li>
<li> <p><code>"sigma"</code> = noise magnitude (Gaussian obs. model)
</p>
</li>
<li> <p><code>"phi"</code> = inv. overdispersion (negative binomial obs. model)
</p>
</li>
<li> <p><code>"gamma"</code> = overdispersion (beta-binomial obs. model)
</p>
</li>
<li> <p><code>"beta"</code> = heterogeneity parameters
</p>
</li>
<li> <p><code>"effect_time"</code> = uncertain effect time parameters
</p>
</li>
<li> <p><code>"effect_time_info"</code> = additional options for the above
</p>
</li></ul>

<p>See <code><a href="#topic+priors">priors</a></code> for functions that can be
used to define the list elements. If a parameter of a model is not given
in this list, a default prior will be used for it.
</p>


<h3>When to not use default priors</h3>

<p>It is not recommended to use default priors blindly. Rather, priors should
be specified according to the knowledge about the problem at hand, as in any
Bayesian analysis. In <code>lgpr</code> this is especially important when
</p>

<ol>
<li><p> Using a non-Gaussian likelihood or otherwise setting
<code>sample_f = TRUE</code>. In this case the response variable is not
normalized, so the scale on which the data varies must be taken into
account when defining priors of the signal magnitude parameters
<code>alpha</code> and possible noise parameters (<code>sigma</code>, <code>phi</code>,
<code>gamma</code>). Also it should be checked if <code>c_hat</code> is set in a
sensible way.
</p>
</li>
<li><p> Using a model that contains a <code>gp_ns(x)</code> or <code>gp_vm(x)</code>
expression in its formula. In this case the corresponding covariate
<code>x</code> is not normalized, and the prior for the input warping steepness
parameter <code>wrp</code> must be set according to the expected width of the
window in which the nonstationary effect of <code>x</code> occurs. By default,
the width of this window is about 36, which has been set assuming that
the unit of <code>x</code> is months.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other main functions: 
<code><a href="#topic+create_model">create_model</a>()</code>,
<code><a href="#topic+draw_pred">draw_pred</a>()</code>,
<code><a href="#topic+get_draws">get_draws</a>()</code>,
<code><a href="#topic+pred">pred</a>()</code>,
<code><a href="#topic+prior_pred">prior_pred</a>()</code>,
<code><a href="#topic+sample_model">sample_model</a>()</code>
</p>

<hr>
<h2 id='lgpexpr-class'>An S4 class to represent an lgp expression</h2><span id='topic+lgpexpr-class'></span><span id='topic+lgpexpr'></span>

<h3>Description</h3>

<p>An S4 class to represent an lgp expression
</p>


<h3>Slots</h3>


<dl>
<dt><code>covariate</code></dt><dd><p>name of a covariate</p>
</dd>
<dt><code>fun</code></dt><dd><p>function name</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <code><a href="#topic+operations">operations</a></code> for performing arithmetics
on <a href="#topic+lgprhs-class">lgprhs</a>, <a href="#topic+lgpterm-class">lgpterm</a> and <a href="#topic+lgpexpr-class">lgpexpr</a>
objects.
</p>

<hr>
<h2 id='lgpfit-class'>An S4 class to represent the output of the <code>lgp</code> function</h2><span id='topic+lgpfit-class'></span><span id='topic+lgpfit'></span><span id='topic+show+2Clgpfit-method'></span><span id='topic+component_names+2Clgpfit-method'></span><span id='topic+num_components+2Clgpfit-method'></span><span id='topic+postproc+2Clgpfit-method'></span><span id='topic+contains_postproc+2Clgpfit-method'></span><span id='topic+clear_postproc+2Clgpfit-method'></span><span id='topic+get_model+2Clgpfit-method'></span><span id='topic+get_stanfit+2Clgpfit-method'></span><span id='topic+is_f_sampled+2Clgpfit-method'></span><span id='topic+plot+2Clgpfit+2Cmissing-method'></span>

<h3>Description</h3>

<p>An S4 class to represent the output of the <code>lgp</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lgpfit'
show(object)

## S4 method for signature 'lgpfit'
component_names(object)

## S4 method for signature 'lgpfit'
num_components(object)

## S4 method for signature 'lgpfit'
postproc(object, verbose = TRUE)

## S4 method for signature 'lgpfit'
contains_postproc(object)

## S4 method for signature 'lgpfit'
clear_postproc(object)

## S4 method for signature 'lgpfit'
get_model(object)

## S4 method for signature 'lgpfit'
get_stanfit(object)

## S4 method for signature 'lgpfit'
is_f_sampled(object)

## S4 method for signature 'lgpfit,missing'
plot(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgpfit-class_+3A_object">object</code></td>
<td>
<p>The object for which to apply a class method.</p>
</td></tr>
<tr><td><code id="lgpfit-class_+3A_verbose">verbose</code></td>
<td>
<p>Can the method print any messages?</p>
</td></tr>
<tr><td><code id="lgpfit-class_+3A_x">x</code></td>
<td>
<p>an <a href="#topic+lgpfit-class">lgpfit</a> object to visualize</p>
</td></tr>
<tr><td><code id="lgpfit-class_+3A_y">y</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(lgpfit)</code>: Print information and summary about the fit object.
</p>
</li>
<li> <p><code>component_names(lgpfit)</code>: Get names of model components.
</p>
</li>
<li> <p><code>num_components(lgpfit)</code>: Get number of model components. Returns a
positive integer.
</p>
</li>
<li> <p><code>postproc(lgpfit)</code>: Apply postprocessing. Returns an updated
<a href="#topic+lgpfit-class">lgpfit</a> object (copies data).
</p>
</li>
<li> <p><code>contains_postproc(lgpfit)</code>: Check if object contains postprocessing information.
</p>
</li>
<li> <p><code>clear_postproc(lgpfit)</code>: Returns an updated (copies data)
<a href="#topic+lgpfit-class">lgpfit</a> object without any postprocessing information.
</p>
</li>
<li> <p><code>get_model(lgpfit)</code>: Get the stored <a href="#topic+lgpmodel-class">lgpmodel</a> object.
Various properties of the returned object can be accessed as explained
in the documentation of <a href="#topic+lgpmodel-class">lgpmodel</a>.
</p>
</li>
<li> <p><code>get_stanfit(lgpfit)</code>: Get the stored <code><a href="rstan.html#topic+stanfit">stanfit</a></code> object.
Various properties of the returned object can be accessed or plotted
as explained
<a href="https://CRAN.R-project.org/package=rstan/vignettes/stanfit-objects.html">here</a>
or in the documentation of <code><a href="rstan.html#topic+stanfit">stanfit</a></code>.
</p>
</li>
<li> <p><code>is_f_sampled(lgpfit)</code>: Determine if inference was done by sampling
the latent signal <code>f</code> (and its components).
</p>
</li>
<li> <p><code>plot(x = lgpfit, y = missing)</code>: Visualize parameter draws using <code><a href="#topic+plot_draws">plot_draws</a></code>.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>stan_fit</code></dt><dd><p>An object of class <code>stanfit</code>.</p>
</dd>
<dt><code>model</code></dt><dd><p>An object of class <code>lgpmodel</code>.</p>
</dd>
<dt><code>num_draws</code></dt><dd><p>Total number of parameter draws.</p>
</dd>
<dt><code>postproc_results</code></dt><dd><p>A named list containing possible postprocessing
results.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>For extracting parameter draws, see <code><a href="#topic+get_draws">get_draws</a></code>,
or the <code>rstan</code> methods for <code>stanfit</code> objects.
</p>
<p>For more detailed plotting functions, see <code><a href="#topic+plot_draws">plot_draws</a></code>,
<code><a href="#topic+plot_beta">plot_beta</a></code>, <code><a href="#topic+plot_warp">plot_warp</a></code>,
<code><a href="#topic+plot_effect_times">plot_effect_times</a></code>
</p>

<hr>
<h2 id='lgpformula-class'>An S4 class to represent an lgp formula</h2><span id='topic+lgpformula-class'></span><span id='topic+lgpformula'></span>

<h3>Description</h3>

<p>An S4 class to represent an lgp formula
</p>


<h3>Slots</h3>


<dl>
<dt><code>terms</code></dt><dd><p>an object of class <a href="#topic+lgprhs-class">lgprhs</a></p>
</dd>
<dt><code>y_name</code></dt><dd><p>name of the response variable</p>
</dd>
<dt><code>call</code></dt><dd><p>original formula call</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <code><a href="#topic+operations">operations</a></code> for performing arithmetics
on <a href="#topic+lgprhs-class">lgprhs</a>, <a href="#topic+lgpterm-class">lgpterm</a> and <a href="#topic+lgpexpr-class">lgpexpr</a>
objects.
</p>

<hr>
<h2 id='lgpmodel-class'>An S4 class to represent an additive GP model</h2><span id='topic+lgpmodel-class'></span><span id='topic+lgpmodel'></span><span id='topic+show+2Clgpmodel-method'></span><span id='topic+parameter_info+2Clgpmodel-method'></span><span id='topic+component_info+2Clgpmodel-method'></span><span id='topic+num_components+2Clgpmodel-method'></span><span id='topic+covariate_info+2Clgpmodel-method'></span><span id='topic+component_names+2Clgpmodel-method'></span><span id='topic+is_f_sampled+2Clgpmodel-method'></span>

<h3>Description</h3>

<p>An S4 class to represent an additive GP model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lgpmodel'
show(object)

## S4 method for signature 'lgpmodel'
parameter_info(object, digits = 3)

## S4 method for signature 'lgpmodel'
component_info(object)

## S4 method for signature 'lgpmodel'
num_components(object)

## S4 method for signature 'lgpmodel'
covariate_info(object)

## S4 method for signature 'lgpmodel'
component_names(object)

## S4 method for signature 'lgpmodel'
is_f_sampled(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgpmodel-class_+3A_object">object</code></td>
<td>
<p>The object for which to apply a class method.</p>
</td></tr>
<tr><td><code id="lgpmodel-class_+3A_digits">digits</code></td>
<td>
<p>number of digits to show for floating point numbers</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(lgpmodel)</code>: Print information and summary about the object.
Returns <code>object</code> invisibly.
</p>
</li>
<li> <p><code>parameter_info(lgpmodel)</code>: Get a parameter summary (bounds and
priors). Returns a <code>data.frame</code>.
</p>
</li>
<li> <p><code>component_info(lgpmodel)</code>: Get a data frame with information about each model
component.
</p>
</li>
<li> <p><code>num_components(lgpmodel)</code>: Get number of model components. Returns a
positive integer.
</p>
</li>
<li> <p><code>covariate_info(lgpmodel)</code>: Get covariate information.
</p>
</li>
<li> <p><code>component_names(lgpmodel)</code>: Get names of model components.
</p>
</li>
<li> <p><code>is_f_sampled(lgpmodel)</code>: Determine if inference of the model requires sampling
the latent signal <code>f</code> (and its components).
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>formula</code></dt><dd><p>An object of class <a href="#topic+lgpformula-class">lgpformula</a></p>
</dd>
<dt><code>data</code></dt><dd><p>The original unmodified data.</p>
</dd>
<dt><code>stan_input</code></dt><dd><p>The data to be given as input to <code>rstan::sampling</code></p>
</dd>
<dt><code>var_names</code></dt><dd><p>List of variable names grouped by type.</p>
</dd>
<dt><code>var_scalings</code></dt><dd><p>A named list with fields
</p>

<ul>
<li> <p><code>y</code> - Response variable normalization function and its
inverse operation. Must be an <a href="#topic+lgpscaling-class">lgpscaling</a> object.
</p>
</li>
<li> <p><code>x_cont</code> - Continuous covariate normalization functions and
their inverse operations. Must be a named list with each element is an
<a href="#topic+lgpscaling-class">lgpscaling</a> object.
</p>
</li></ul>
</dd>
<dt><code>var_info</code></dt><dd><p>A named list with fields
</p>

<ul>
<li> <p><code>x_cat_levels</code> - Names of the levels of categorical covariates
before converting from factor to numeric.
</p>
</li></ul>
</dd>
<dt><code>info</code></dt><dd><p>Other info in text format.</p>
</dd>
<dt><code>sample_f</code></dt><dd><p>Whether the signal <code>f</code> is sampled or marginalized.</p>
</dd>
<dt><code>full_prior</code></dt><dd><p>Complete prior information.</p>
</dd>
</dl>

<hr>
<h2 id='lgpr-package'>The 'lgpr' package.</h2><span id='topic+lgpr-package'></span><span id='topic+lgpr'></span>

<h3>Description</h3>

<p>Interpretable nonparametric modeling of longitudinal data
using additive Gaussian process regression. Contains functionality
for inferring covariate effects and assessing covariate relevances.
Models are specified using a convenient formula syntax, and can include
shared, group-specific, non-stationary, heterogeneous and temporally
uncertain effects. Bayesian inference for model parameters is performed
using 'Stan' (<code><a href="rstan.html#topic+rstan">rstan</a></code>). The modeling approach and methods
are described in detail in
<a href="https://academic.oup.com/bioinformatics/advance-article/doi/10.1093/bioinformatics/btab021/6104850">Timonen et al. (2021)</a>.
</p>


<h3>Core functions</h3>

<p>Main functionality of the package consists of creating and fitting an
additive GP model:
</p>

<ul>
<li> <p><code><a href="#topic+lgp">lgp</a></code>: Specify and fit an additive GP model with one
command.
</p>
</li>
<li> <p><code><a href="#topic+create_model">create_model</a></code>: Define an <a href="#topic+lgpmodel-class">lgpmodel</a> object.
</p>
</li>
<li> <p><code><a href="#topic+sample_model">sample_model</a></code>: Fit a model by sampling the posterior
distribution of its parameters and create an <a href="#topic+lgpfit-class">lgpfit</a> object.
</p>
</li>
<li> <p><code><a href="#topic+pred">pred</a></code>: Computing model predictions and inferred
covariate effects after fitting a model.
</p>
</li>
<li> <p><code><a href="#topic+relevances">relevances</a></code>: Assessing covariate relevances after
fitting a model.
</p>
</li>
<li> <p><code><a href="#topic+prior_pred">prior_pred</a></code>: Prior predictive sampling to check
if your prior makes sense.
</p>
</li></ul>



<h3>Visualization</h3>


<ul>
<li> <p><code><a href="#topic+plot_pred">plot_pred</a></code>: Plot model predictions.
</p>
</li>
<li> <p><code><a href="#topic+plot_components">plot_components</a></code>: Visualize inferred model components.
</p>
</li>
<li> <p><code><a href="#topic+plot_draws">plot_draws</a></code>: Visualize parameter draws.
</p>
</li>
<li> <p><code><a href="#topic+plot_data">plot_data</a></code>: Visualize longitudinal data.
</p>
</li></ul>



<h3>Data</h3>

<p>The data that you wish to analyze with 'lgpr' should be in an <span class="rlang"><b>R</b></span>
<code>data.frame</code> where columns correspond to measured variables and rows
correspond to observations. Some functions that can help working with such
data frames are:
</p>

<ul>
<li> <p><code><a href="#topic+new_x">new_x</a></code>: Creating new test points where the posterior
distribution of any function component or sum of all components, or the
posterior predictive distribution can be computed after model fitting.
</p>
</li>
<li><p> Other functions: <code><a href="#topic+add_factor">add_factor</a></code>,
<code><a href="#topic+add_factor_crossing">add_factor_crossing</a></code>, <code><a href="#topic+add_dis_age">add_dis_age</a></code>,
<code><a href="#topic+adjusted_c_hat">adjusted_c_hat</a></code>.
</p>
</li></ul>



<h3>Vignettes and tutorials</h3>

<p>See <a href="https://jtimonen.github.io/lgpr-usage/index.html">https://jtimonen.github.io/lgpr-usage/index.html</a>. The
tutorials focus on code and use cases, whereas the
<a href="https://jtimonen.github.io/lgpr-usage/articles/math.html">Mathematical description of lgpr models</a>
vignette describes the statistical models and how they can be customized in
'lgpr'.
</p>


<h3>Citation</h3>

<p>Run <code>citation("lgpr")</code> to get citation information.
</p>


<h3>Feedback</h3>

<p>Bug reports, PRs, enhancement ideas or user experiences in general are
welcome and appreciated. Create an issue in Github or email the author.
</p>


<h3>Author(s)</h3>

<p>Juho Timonen (first.last at iki.fi)
</p>


<h3>References</h3>


<ol>
<li><p> Timonen, J. et al. (2021).
<em>lgpr: an interpretable non-parametric method for inferring covariate
effects from longitudinal data</em>. Bioinformatics,
<a href="https://academic.oup.com/bioinformatics/advance-article/doi/10.1093/bioinformatics/btab021/6104850">url</a>.
</p>
</li>
<li><p> Carpenter, B. et al. (2017).
<em>Stan: A probabilistic programming language</em>. Journal of Statistical
Software 76(1).
</p>
</li></ol>


<hr>
<h2 id='lgprhs-class'>An S4 class to represent the right-hand side of an lgp formula</h2><span id='topic+lgprhs-class'></span><span id='topic+lgprhs'></span>

<h3>Description</h3>

<p>An S4 class to represent the right-hand side of an lgp formula
</p>


<h3>Slots</h3>


<dl>
<dt><code>summands</code></dt><dd><p>a list of one or more <a href="#topic+lgpterm-class">lgpterm</a>s</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <code><a href="#topic+operations">operations</a></code> for performing arithmetics
on <a href="#topic+lgprhs-class">lgprhs</a>, <a href="#topic+lgpterm-class">lgpterm</a> and <a href="#topic+lgpexpr-class">lgpexpr</a>
objects.
</p>

<hr>
<h2 id='lgpscaling-class'>An S4 class to represent variable scaling</h2><span id='topic+lgpscaling-class'></span><span id='topic+lgpscaling'></span>

<h3>Description</h3>

<p>An S4 class to represent variable scaling
</p>


<h3>Slots</h3>


<dl>
<dt><code>loc</code></dt><dd><p>original location (mean)</p>
</dd>
<dt><code>scale</code></dt><dd><p>original scale (standard deviation)</p>
</dd>
<dt><code>var_name</code></dt><dd><p>variable name</p>
</dd>
</dl>

<hr>
<h2 id='lgpsim-class'>An S4 class to represent a data set simulated using the additive GP
formalism</h2><span id='topic+lgpsim-class'></span><span id='topic+lgpsim'></span><span id='topic+show+2Clgpsim-method'></span><span id='topic+plot+2Clgpsim+2Cmissing-method'></span>

<h3>Description</h3>

<p>An S4 class to represent a data set simulated using the additive GP
formalism
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lgpsim'
show(object)

## S4 method for signature 'lgpsim,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgpsim-class_+3A_object">object</code></td>
<td>
<p>an <a href="#topic+lgpsim-class">lgpsim</a> object</p>
</td></tr>
<tr><td><code id="lgpsim-class_+3A_x">x</code></td>
<td>
<p>an <a href="#topic+lgpsim-class">lgpsim</a> object to plot</p>
</td></tr>
<tr><td><code id="lgpsim-class_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="lgpsim-class_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="#topic+plot_sim">plot_sim</a></code></p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(lgpsim)</code>: Show summary of object.
</p>
</li>
<li> <p><code>plot(x = lgpsim, y = missing)</code>: Plot the data and generating process. For more
information see <code><a href="#topic+plot_sim">plot_sim</a></code>.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>the actual data</p>
</dd>
<dt><code>response</code></dt><dd><p>name of the response variable in the data</p>
</dd>
<dt><code>components</code></dt><dd><p>the drawn function components</p>
</dd>
<dt><code>kernel_matrices</code></dt><dd><p>the covariance matrices for each gp</p>
</dd>
<dt><code>info</code></dt><dd><p>A list with fields
</p>

<ul>
<li> <p><code>par_ell</code> the used lengthscale parameters
</p>
</li>
<li> <p><code>par_cont</code> the parameters used to generate the continuous
covariates
</p>
</li>
<li> <p><code>p_signal</code> signal proportion
</p>
</li></ul>
</dd>
<dt><code>effect_times</code></dt><dd><p>A list with fields
</p>

<ul>
<li> <p><code>true</code> possible true effect times that generate the disease
effect
</p>
</li>
<li> <p><code>observed</code> possible observed effect times
</p>
</li></ul>
</dd>
</dl>

<hr>
<h2 id='lgpterm-class'>An S4 class to represent one formula term</h2><span id='topic+lgpterm-class'></span><span id='topic+lgpterm'></span>

<h3>Description</h3>

<p>An S4 class to represent one formula term
</p>


<h3>Slots</h3>


<dl>
<dt><code>factors</code></dt><dd><p>a list of at most two <a href="#topic+lgpexpr-class">lgpexpr</a>s</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <code><a href="#topic+operations">operations</a></code> for performing arithmetics
on <a href="#topic+lgprhs-class">lgprhs</a>, <a href="#topic+lgpterm-class">lgpterm</a> and <a href="#topic+lgpexpr-class">lgpexpr</a>
objects.
</p>

<hr>
<h2 id='model_summary'>Print a model summary.</h2><span id='topic+model_summary'></span><span id='topic+param_summary'></span>

<h3>Description</h3>

<p>Print a model summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_summary(object, digits = 3)

param_summary(object, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_summary_+3A_object">object</code></td>
<td>
<p>a model or fit</p>
</td></tr>
<tr><td><code id="model_summary_+3A_digits">digits</code></td>
<td>
<p>number of digits to round floats to</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> invisibly.
</p>

<hr>
<h2 id='new_x'>Create test input points for prediction</h2><span id='topic+new_x'></span>

<h3>Description</h3>

<p>Replaces a continuous variable <code>x</code> in the data frame, and
possibly another continuous variable <code>x_ns</code> derived from it, with new
values, for each level of a grouping factor (usually id)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_x(data, x_values, group_by = "id", x = "age", x_ns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_x_+3A_data">data</code></td>
<td>
<p>A data frame. Can also be an <a href="#topic+lgpfit-class">lgpfit</a> or
<a href="#topic+lgpmodel-class">lgpmodel</a> object, in which case data is extracted from it.</p>
</td></tr>
<tr><td><code id="new_x_+3A_x_values">x_values</code></td>
<td>
<p>the values of <code>x</code> to set for each individual</p>
</td></tr>
<tr><td><code id="new_x_+3A_group_by">group_by</code></td>
<td>
<p>name of the grouping variable, must be a factor
in <code>data</code> (or use <code>group_by=NA</code> to create a dummy grouping
factor which has only one value)</p>
</td></tr>
<tr><td><code id="new_x_+3A_x">x</code></td>
<td>
<p>of the variable along which to extend,
must be a numeric in <code>data</code></p>
</td></tr>
<tr><td><code id="new_x_+3A_x_ns">x_ns</code></td>
<td>
<p>of a nonstationary variable derived from <code>x</code>,
must be a numeric in <code>data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the following columns
</p>

<ul>
<li><p> all factors in the original <code>data</code>
</p>
</li>
<li> <p><code>x</code>
</p>
</li>
<li> <p><code>x_ns</code> (unless it is NULL)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other data frame handling functions: 
<code><a href="#topic+add_dis_age">add_dis_age</a>()</code>,
<code><a href="#topic+add_factor_crossing">add_factor_crossing</a>()</code>,
<code><a href="#topic+add_factor">add_factor</a>()</code>,
<code><a href="#topic+adjusted_c_hat">adjusted_c_hat</a>()</code>,
<code><a href="#topic+split">split</a>()</code>
</p>

<hr>
<h2 id='operations'>Operations on formula terms and expressions</h2><span id='topic+operations'></span><span id='topic++2B+2Clgprhs+2Clgprhs-method'></span><span id='topic++2B+2Clgpterm+2Clgpterm-method'></span><span id='topic++2B+2Clgprhs+2Clgpterm-method'></span><span id='topic++2A+2Clgpterm+2Clgpterm-method'></span>

<h3>Description</h3>

<p>Operations on formula terms and expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lgprhs,lgprhs'
e1 + e2

## S4 method for signature 'lgpterm,lgpterm'
e1 + e2

## S4 method for signature 'lgprhs,lgpterm'
e1 + e2

## S4 method for signature 'lgpterm,lgpterm'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operations_+3A_e1">e1</code></td>
<td>
<p>The first sum, term or expression</p>
</td></tr>
<tr><td><code id="operations_+3A_e2">e2</code></td>
<td>
<p>The second sum, term or expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The behaviour and return type depend on the types of <code>e1</code> and <code>e2</code>.
You can
</p>

<ul>
<li><p> sum (<code>+</code>) two <a href="#topic+lgprhs-class">lgprhs</a>'s to yield an
<a href="#topic+lgprhs-class">lgprhs</a>
</p>
</li>
<li><p> sum (<code>+</code>) two <a href="#topic+lgpterm-class">lgpterm</a>'s to yield an
<a href="#topic+lgprhs-class">lgprhs</a>
</p>
</li>
<li><p> sum (<code>+</code>) an <a href="#topic+lgprhs-class">lgprhs</a> and an <a href="#topic+lgpterm-class">lgpterm</a>
to yield an <a href="#topic+lgprhs-class">lgprhs</a>
</p>
</li>
<li><p> multiply (<code>*</code>) two <a href="#topic+lgpterm-class">lgpterm</a>'s to yield
an <a href="#topic+lgpterm-class">lgpterm</a>
</p>
</li></ul>


<hr>
<h2 id='plot_api_c'>Plot a generated/fit model component</h2><span id='topic+plot_api_c'></span>

<h3>Description</h3>

<p>Data frames specified in arguments <code>df</code>,
and <code>df_err</code> must have a format where
</p>

<ul>
<li><p> The first column is the grouping factor (usually id).
</p>
</li>
<li><p> The second column is the x-axis variable (usually age).
</p>
</li>
<li><p> The third column is the coloring factor. If name of the third
column is <code>NA</code>, coloring is not done.
</p>
</li>
<li><p> A column named <code>y</code> must contain the y-axis variable
(not for <code>df_err</code>).
</p>
</li>
<li><p> A column named <code>lower</code> (<code>upper</code>) must contain the lower
(upper) bound of error bar (only for <code>df_err</code>).
</p>
</li>
<li><p> The posterior draw using which the fit has been computed can be
specified with a factor named <code>_draw_</code> (only for <code>df</code>).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plot_api_c(
  df,
  df_err = NULL,
  alpha = 1,
  alpha_err = 0.2,
  no_err = FALSE,
  no_line = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_api_c_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="plot_api_c_+3A_df_err">df_err</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="plot_api_c_+3A_alpha">alpha</code></td>
<td>
<p>line opacity</p>
</td></tr>
<tr><td><code id="plot_api_c_+3A_alpha_err">alpha_err</code></td>
<td>
<p>ribbon opacity</p>
</td></tr>
<tr><td><code id="plot_api_c_+3A_no_err">no_err</code></td>
<td>
<p>hide error bar even when it would normally be plotted?</p>
</td></tr>
<tr><td><code id="plot_api_c_+3A_no_line">no_line</code></td>
<td>
<p>hide line even when it would normally be plotted?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>


<h3>See Also</h3>

<p>Other internal plot API functions: 
<code><a href="#topic+plot_api_g">plot_api_g</a>()</code>
</p>

<hr>
<h2 id='plot_api_g'>Plot longitudinal data and/or model fit so that each subject/group has
their own panel</h2><span id='topic+plot_api_g'></span>

<h3>Description</h3>

<p>Data frames specified in arguments <code>df_data</code>,
<code>df_signal</code>, <code>df_fit</code>, and <code>df_fit_err</code> must have a format
where
</p>

<ul>
<li><p> the first column is the grouping factor (usually id)
</p>
</li>
<li><p> the second column is the x-axis variable (usually age)
</p>
</li>
<li><p> a column named <code>y</code> must contain the y-axis variable
(not for <code>df_fit_err</code>)
</p>
</li>
<li><p> a column named <code>lower</code> (<code>upper</code>) must contain the lower
(upper) bound of error bar (only for <code>df_fit_err</code>)
</p>
</li>
<li><p> a column named <code>draw</code> must be a factor that
specifies the posterior draw using which the fit has been computed
(only for <code>df_fit</code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plot_api_g(
  df_data,
  df_signal = NULL,
  df = NULL,
  df_err = NULL,
  teff_signal = NULL,
  teff_obs = NULL,
  i_test = NULL,
  color_signal = color_palette(2)[1],
  color = color_palette(2)[2],
  color_err = colorset("red", "light_highlight"),
  color_vlines = colorset("gray", "mid_highlight"),
  alpha = 1,
  alpha_err = 0.5,
  nrow = NULL,
  ncol = NULL,
  y_transform = function(x) x
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_api_g_+3A_df_data">df_data</code></td>
<td>
<p>A data frame containing the observations.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_df_signal">df_signal</code></td>
<td>
<p>A data frame containing the true signal. Omitted if
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_df">df</code></td>
<td>
<p>A data frame containing the model fit, or a list of data
frames. The list version can be used for example so that each list element
corresponds to the fit computed using one parameter draw. Omitted if
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_df_err">df_err</code></td>
<td>
<p>A data frame containing error bars. Omitted if <code>NULL</code>.
Must be <code>NULL</code> if <code>df_fit</code> is a list.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_teff_signal">teff_signal</code></td>
<td>
<p>A named vector containing true effect times used to
generate the signal. Omitted if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_teff_obs">teff_obs</code></td>
<td>
<p>A named vector containing observed effect times. Omitted if
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_i_test">i_test</code></td>
<td>
<p>Indices of test points.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_color_signal">color_signal</code></td>
<td>
<p>Line color for true signal.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_color">color</code></td>
<td>
<p>Line color for model fit.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_color_err">color_err</code></td>
<td>
<p>Color of the error ribbon.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_color_vlines">color_vlines</code></td>
<td>
<p>Two line colors for vertical lines
(true and obs. effect time).</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_alpha">alpha</code></td>
<td>
<p>Line opacity for model fit.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_alpha_err">alpha_err</code></td>
<td>
<p>Opacity of the error ribbon.</p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_nrow">nrow</code></td>
<td>
<p>number of rows, an argument for
<code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code></p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_ncol">ncol</code></td>
<td>
<p>number of columns, an argument for
<code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code></p>
</td></tr>
<tr><td><code id="plot_api_g_+3A_y_transform">y_transform</code></td>
<td>
<p>A function to be applied to the third column of
<code>df_data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>


<h3>See Also</h3>

<p>Other internal plot API functions: 
<code><a href="#topic+plot_api_c">plot_api_c</a>()</code>
</p>

<hr>
<h2 id='plot_components'>Visualize all model components</h2><span id='topic+plot_components'></span>

<h3>Description</h3>

<p>This calls <code><a href="#topic+plot_f">plot_f</a></code> for all model components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_components(
  fit,
  pred = NULL,
  group_by = "id",
  t_name = "age",
  MULT_STD = 2,
  verbose = TRUE,
  draws = NULL,
  reduce = function(x) base::mean(x),
  color_by = NA,
  no_err = FALSE,
  ylim = NULL,
  draw = TRUE,
  nrow = NULL,
  ncol = NULL,
  gg_add = NULL,
  x = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_components_+3A_fit">fit</code></td>
<td>
<p>An object of class <a href="#topic+lgpfit-class">lgpfit</a>.</p>
</td></tr>
<tr><td><code id="plot_components_+3A_pred">pred</code></td>
<td>
<p>An object of class <a href="#topic+GaussianPrediction-class">GaussianPrediction</a> or
<a href="#topic+Prediction-class">Prediction</a>. If <code>pred=NULL</code>, the <code><a href="#topic+pred">pred</a></code>
function is called with the given <code>reduce</code> and <code>draws</code> arguments.</p>
</td></tr>
<tr><td><code id="plot_components_+3A_group_by">group_by</code></td>
<td>
<p>name of the grouping variable (use <code>group_by=NA</code>
to avoid grouping)</p>
</td></tr>
<tr><td><code id="plot_components_+3A_t_name">t_name</code></td>
<td>
<p>name of the x-axis variable</p>
</td></tr>
<tr><td><code id="plot_components_+3A_mult_std">MULT_STD</code></td>
<td>
<p>a multiplier for standard deviation</p>
</td></tr>
<tr><td><code id="plot_components_+3A_verbose">verbose</code></td>
<td>
<p>Can this print any messages?</p>
</td></tr>
<tr><td><code id="plot_components_+3A_draws">draws</code></td>
<td>
<p>Only has effect if <code>pred=NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_components_+3A_reduce">reduce</code></td>
<td>
<p>Only has effect if <code>pred=NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_components_+3A_color_by">color_by</code></td>
<td>
<p>Names of coloring factors. Can have length 1 or equal to
the number of components. See the <code>color_by</code> argument of
<code><a href="#topic+plot_f">plot_f</a></code>.</p>
</td></tr>
<tr><td><code id="plot_components_+3A_no_err">no_err</code></td>
<td>
<p>Should the error ribbons be skipped even though they
otherwise would be shown? Can have length 1 or equal to number of
components + 1. See the <code>no_err</code> argument of <code><a href="#topic+plot_api_c">plot_api_c</a></code>.</p>
</td></tr>
<tr><td><code id="plot_components_+3A_ylim">ylim</code></td>
<td>
<p>a vector of length 2 (upper and lower y-axis limits), or NULL</p>
</td></tr>
<tr><td><code id="plot_components_+3A_draw">draw</code></td>
<td>
<p>if this is TRUE, the plot grid is drawn using
<code><a href="gridExtra.html#topic+arrangeGrob">arrangeGrob</a></code></p>
</td></tr>
<tr><td><code id="plot_components_+3A_nrow">nrow</code></td>
<td>
<p>number of grid rows</p>
</td></tr>
<tr><td><code id="plot_components_+3A_ncol">ncol</code></td>
<td>
<p>number of grid columns</p>
</td></tr>
<tr><td><code id="plot_components_+3A_gg_add">gg_add</code></td>
<td>
<p>additional ggplot obejct to add to each plot</p>
</td></tr>
<tr><td><code id="plot_components_+3A_x">x</code></td>
<td>
<p>Deprecated argument. This is now taken from the <code>pred</code>
object to ensure compatibility.</p>
</td></tr>
<tr><td><code id="plot_components_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+plot_api_c">plot_api_c</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of ggplot objects invisibly
</p>


<h3>See Also</h3>

<p>Other main plot functions: 
<code><a href="#topic+plot_draws">plot_draws</a>()</code>,
<code><a href="#topic+plot_pred">plot_pred</a>()</code>
</p>

<hr>
<h2 id='plot_data'>Vizualizing longitudinal data</h2><span id='topic+plot_data'></span>

<h3>Description</h3>

<p>Vizualizing longitudinal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_data(
  data,
  x_name = "age",
  y_name = "y",
  group_by = "id",
  facet_by = NULL,
  color_by = NULL,
  highlight = NULL,
  main = NULL,
  sub = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_data_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_x_name">x_name</code></td>
<td>
<p>Name of x-axis variable.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_y_name">y_name</code></td>
<td>
<p>Name of the y-axis variable.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_group_by">group_by</code></td>
<td>
<p>Name of grouping variable (must be a factor).</p>
</td></tr>
<tr><td><code id="plot_data_+3A_facet_by">facet_by</code></td>
<td>
<p>Name of the faceting variable (must be a factor).</p>
</td></tr>
<tr><td><code id="plot_data_+3A_color_by">color_by</code></td>
<td>
<p>Name of coloring variable (must be a factor).</p>
</td></tr>
<tr><td><code id="plot_data_+3A_highlight">highlight</code></td>
<td>
<p>Value of category of the <code>group_by</code> variable
that is highlighted. Can only be used if <code>color_by</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_data_+3A_main">main</code></td>
<td>
<p>main plot title</p>
</td></tr>
<tr><td><code id="plot_data_+3A_sub">sub</code></td>
<td>
<p>plot subtitle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>

<hr>
<h2 id='plot_draws'>Visualize the distribution of parameter draws</h2><span id='topic+plot_draws'></span><span id='topic+plot_beta'></span><span id='topic+plot_warp'></span><span id='topic+plot_effect_times'></span>

<h3>Description</h3>

<p>Visualize the distribution of parameter draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_draws(
  fit,
  type = "intervals",
  regex_pars = c("alpha", "ell", "wrp", "sigma", "phi", "gamma"),
  ...
)

plot_beta(fit, type = "dens", verbose = TRUE, ...)

plot_warp(
  fit,
  num_points = 300,
  window_size = 48,
  color = colorset("red", "dark"),
  alpha = 0.5
)

plot_effect_times(fit, type = "areas", verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_draws_+3A_fit">fit</code></td>
<td>
<p>an object of class <a href="#topic+lgpfit-class">lgpfit</a></p>
</td></tr>
<tr><td><code id="plot_draws_+3A_type">type</code></td>
<td>
<p>plot type, allowed options are &quot;intervals&quot;, &quot;dens&quot;,
&quot;areas&quot;, and &quot;trace&quot;</p>
</td></tr>
<tr><td><code id="plot_draws_+3A_regex_pars">regex_pars</code></td>
<td>
<p>regex for parameter names to plot</p>
</td></tr>
<tr><td><code id="plot_draws_+3A_...">...</code></td>
<td>
<p>additional arguments for the <code>bayesplot</code> function
<code><a href="bayesplot.html#topic+mcmc_intervals">mcmc_intervals</a></code>, <code><a href="bayesplot.html#topic+mcmc_dens">mcmc_dens</a></code>,
<code><a href="bayesplot.html#topic+mcmc_areas">mcmc_areas</a></code> or <code><a href="bayesplot.html#topic+mcmc_trace">mcmc_trace</a></code></p>
</td></tr>
<tr><td><code id="plot_draws_+3A_verbose">verbose</code></td>
<td>
<p>Can any output be printed?</p>
</td></tr>
<tr><td><code id="plot_draws_+3A_num_points">num_points</code></td>
<td>
<p>number of plot points</p>
</td></tr>
<tr><td><code id="plot_draws_+3A_window_size">window_size</code></td>
<td>
<p>width of time window</p>
</td></tr>
<tr><td><code id="plot_draws_+3A_color">color</code></td>
<td>
<p>line color</p>
</td></tr>
<tr><td><code id="plot_draws_+3A_alpha">alpha</code></td>
<td>
<p>line alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object or list of them
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot_draws()</code>: visualizes the distribution of any set of
model parameters (defaults to kernel hyperparameters and possible
observation model parameters)
</p>
</li>
<li> <p><code>plot_beta()</code>: visualizes the distribution of the
individual-specific disease effect magnitude parameter draws
</p>
</li>
<li> <p><code>plot_warp()</code>: visualizes the input warping function for
different draws of the warping steepness parameter
</p>
</li>
<li> <p><code>plot_effect_times()</code>: visualizes the input warping function for
different parameter draws
</p>
</li></ul>


<h3>See Also</h3>

<p>Other main plot functions: 
<code><a href="#topic+plot_components">plot_components</a>()</code>,
<code><a href="#topic+plot_pred">plot_pred</a>()</code>
</p>

<hr>
<h2 id='plot_inputwarp'>Visualize input warping function with several steepness parameter values</h2><span id='topic+plot_inputwarp'></span>

<h3>Description</h3>

<p>Visualize input warping function with several steepness parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_inputwarp(wrp, x, color = colorset("red", "dark"), alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_inputwarp_+3A_wrp">wrp</code></td>
<td>
<p>a vector of values of the warping steepness parameter</p>
</td></tr>
<tr><td><code id="plot_inputwarp_+3A_x">x</code></td>
<td>
<p>a vector of input values</p>
</td></tr>
<tr><td><code id="plot_inputwarp_+3A_color">color</code></td>
<td>
<p>line color</p>
</td></tr>
<tr><td><code id="plot_inputwarp_+3A_alpha">alpha</code></td>
<td>
<p>line alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>

<hr>
<h2 id='plot_invgamma'>Plot the inverse gamma-distribution pdf</h2><span id='topic+plot_invgamma'></span>

<h3>Description</h3>

<p>Plot the inverse gamma-distribution pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_invgamma(
  alpha,
  beta,
  by = 0.01,
  log = FALSE,
  IQR = 0.95,
  return_quantiles = FALSE,
  linecolor = colorset("red", "dark"),
  fillcolor = colorset("red", "mid")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_invgamma_+3A_alpha">alpha</code></td>
<td>
<p>positive real number</p>
</td></tr>
<tr><td><code id="plot_invgamma_+3A_beta">beta</code></td>
<td>
<p>positive real number</p>
</td></tr>
<tr><td><code id="plot_invgamma_+3A_by">by</code></td>
<td>
<p>grid size</p>
</td></tr>
<tr><td><code id="plot_invgamma_+3A_log">log</code></td>
<td>
<p>is log-scale used?</p>
</td></tr>
<tr><td><code id="plot_invgamma_+3A_iqr">IQR</code></td>
<td>
<p>inter-quantile range width</p>
</td></tr>
<tr><td><code id="plot_invgamma_+3A_return_quantiles">return_quantiles</code></td>
<td>
<p>should this return a list</p>
</td></tr>
<tr><td><code id="plot_invgamma_+3A_linecolor">linecolor</code></td>
<td>
<p>line color</p>
</td></tr>
<tr><td><code id="plot_invgamma_+3A_fillcolor">fillcolor</code></td>
<td>
<p>fill color</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>See Also</h3>

<p>Other functions related to the inverse-gamma distribution: 
<code><a href="#topic+dinvgamma_stanlike">dinvgamma_stanlike</a>()</code>,
<code><a href="#topic+priors">priors</a></code>
</p>

<hr>
<h2 id='plot_pred'>Visualizing model predictions or inferred covariate effects</h2><span id='topic+plot_pred'></span><span id='topic+plot_f'></span>

<h3>Description</h3>


<ul>
<li><p> Function draws at data points can be visualized using
<code>plot_pred</code>. If the <code>pred</code> argument is <code>NULL</code>, it
is computed using the <code><a href="#topic+pred">pred</a></code> function with <code>x=NULL</code>.
</p>
</li>
<li><p> The total signal <code>f</code> or any of its
additive components can be plotted using <code>plot_f</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plot_pred(
  fit,
  pred = NULL,
  group_by = "id",
  t_name = "age",
  MULT_STD = 2,
  verbose = TRUE,
  draws = NULL,
  reduce = function(x) base::mean(x),
  x = NULL,
  ...
)

plot_f(
  fit,
  pred = NULL,
  group_by = "id",
  t_name = "age",
  MULT_STD = 2,
  verbose = TRUE,
  draws = NULL,
  reduce = function(x) base::mean(x),
  comp_idx = NULL,
  color_by = NA,
  x = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pred_+3A_fit">fit</code></td>
<td>
<p>An object of class <a href="#topic+lgpfit-class">lgpfit</a>.</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_pred">pred</code></td>
<td>
<p>An object of class <a href="#topic+GaussianPrediction-class">GaussianPrediction</a> or
<a href="#topic+Prediction-class">Prediction</a>. If <code>pred=NULL</code>, the <code><a href="#topic+pred">pred</a></code>
function is called with the given <code>reduce</code> and <code>draws</code> arguments.</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_group_by">group_by</code></td>
<td>
<p>name of the grouping variable (use <code>group_by=NA</code>
to avoid grouping)</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_t_name">t_name</code></td>
<td>
<p>name of the x-axis variable</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_mult_std">MULT_STD</code></td>
<td>
<p>a multiplier for standard deviation</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_verbose">verbose</code></td>
<td>
<p>Can this print any messages?</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_draws">draws</code></td>
<td>
<p>Only has effect if <code>pred=NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_reduce">reduce</code></td>
<td>
<p>Only has effect if <code>pred=NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_x">x</code></td>
<td>
<p>Deprecated argument. This is now taken from the <code>pred</code>
object to ensure compatibility.</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+plot_api_g">plot_api_g</a></code> or
<code><a href="#topic+plot_api_c">plot_api_c</a></code></p>
</td></tr>
<tr><td><code id="plot_pred_+3A_comp_idx">comp_idx</code></td>
<td>
<p>Index of component to plot. The total sum is plotted
if this is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_pred_+3A_color_by">color_by</code></td>
<td>
<p>name of coloring factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>See Also</h3>

<p>Other main plot functions: 
<code><a href="#topic+plot_components">plot_components</a>()</code>,
<code><a href="#topic+plot_draws">plot_draws</a>()</code>
</p>

<hr>
<h2 id='plot_sim'>Visualize an lgpsim object (simulated data)</h2><span id='topic+plot_sim'></span>

<h3>Description</h3>

<p>Visualize an lgpsim object (simulated data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sim(
  simdata,
  group_by = "id",
  x_name = "age",
  h_name = "h",
  y_name = "y",
  comp_idx = NULL,
  color_by = NA,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sim_+3A_simdata">simdata</code></td>
<td>
<p>an object of class <a href="#topic+lgpsim-class">lgpsim</a></p>
</td></tr>
<tr><td><code id="plot_sim_+3A_group_by">group_by</code></td>
<td>
<p>grouping factor</p>
</td></tr>
<tr><td><code id="plot_sim_+3A_x_name">x_name</code></td>
<td>
<p>name of x-axis variable</p>
</td></tr>
<tr><td><code id="plot_sim_+3A_h_name">h_name</code></td>
<td>
<p>name of the signal in <code>simdata$components</code> (&quot;h&quot; or &quot;f&quot;)</p>
</td></tr>
<tr><td><code id="plot_sim_+3A_y_name">y_name</code></td>
<td>
<p>name of response variable</p>
</td></tr>
<tr><td><code id="plot_sim_+3A_comp_idx">comp_idx</code></td>
<td>
<p>Possible index of a component to be shown.
If this is NULL, the data and total signal are shown.</p>
</td></tr>
<tr><td><code id="plot_sim_+3A_color_by">color_by</code></td>
<td>
<p>coloring factor</p>
</td></tr>
<tr><td><code id="plot_sim_+3A_verbose">verbose</code></td>
<td>
<p>should some information be printed?</p>
</td></tr>
<tr><td><code id="plot_sim_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+plot_api_g">plot_api_g</a></code> or
<code><a href="#topic+plot_api_c">plot_api_c</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>

<hr>
<h2 id='ppc'>Graphical posterior predictive checks</h2><span id='topic+ppc'></span>

<h3>Description</h3>

<p>Graphical posterior predictive checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc(fit, data = NULL, fun = default_ppc_fun(fit), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppc_+3A_fit">fit</code></td>
<td>
<p>An object of class <a href="#topic+lgpfit-class">lgpfit</a> that can been created
with <code>sample_f=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ppc_+3A_data">data</code></td>
<td>
<p>the original data frame (deprecated argument with no
effect, now obtained from fit object)</p>
</td></tr>
<tr><td><code id="ppc_+3A_fun">fun</code></td>
<td>
<p><code>bayesplot</code> function name</p>
</td></tr>
<tr><td><code id="ppc_+3A_verbose">verbose</code></td>
<td>
<p>Can this print any messages?</p>
</td></tr>
<tr><td><code id="ppc_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the default
<code><a href="bayesplot.html#topic+pp_check">pp_check</a></code> method in
<code>bayesplot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>See Also</h3>

<p>Introduction to graphical posterior predictive checks:
<a href="https://CRAN.R-project.org/package=bayesplot/vignettes/graphical-ppcs.html">here</a>.
Prior predictive check can be done by calling
<code><a href="#topic+prior_pred">prior_pred</a></code> and then <code>bayesplot::pp_check()</code>.
</p>

<hr>
<h2 id='pred'>Posterior predictions and function posteriors</h2><span id='topic+pred'></span>

<h3>Description</h3>


<ul>
<li><p> If <code>fit</code> is for a model that marginalizes the latent
signal <code>f</code> (i.e. <code>is_f_sampled(fit)</code> is <code>FALSE</code>), this
computes the analytic conditional posterior
distributions of each model component, their sum, and the conditional
predictive distribution. All these are computed for
each (hyper)parameter draw (defined by <code>draws</code>), or other parameter
set (obtained by a reduction defined by <code>reduce</code>). Results are stored
in a <a href="#topic+GaussianPrediction-class">GaussianPrediction</a> object which is then returned.
</p>
</li>
<li><p> If <code>fit</code> is for a model that samples the latent
signal <code>f</code> (i.e. <code>is_f_sampled(fit)</code> is <code>TRUE</code>), this will
extract these function samples, compute their sum, and a version of the
sum <code>f</code> that is transformed through the inverse link function.
If <code>x</code> is not <code>NULL</code>, the function draws are extrapolated
to the points specified by <code>x</code> using kernel regression.
Results are stored in a <a href="#topic+Prediction-class">Prediction</a>
object which is then returned.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>pred(
  fit,
  x = NULL,
  reduce = function(x) base::mean(x),
  draws = NULL,
  verbose = TRUE,
  STREAM = get_stream(),
  c_hat_pred = NULL,
  force = FALSE,
  debug_kc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_+3A_fit">fit</code></td>
<td>
<p>An object of class <a href="#topic+lgpfit-class">lgpfit</a>.</p>
</td></tr>
<tr><td><code id="pred_+3A_x">x</code></td>
<td>
<p>A data frame of points where function posterior distributions
and predictions should be computed or sampled.
The function <code><a href="#topic+new_x">new_x</a></code> provides an easy way to create it.
If this is <code>NULL</code>, the data points are used.</p>
</td></tr>
<tr><td><code id="pred_+3A_reduce">reduce</code></td>
<td>
<p>Reduction for parameters draws. Can be a function that
is applied to reduce all parameter draws into one parameter set, or
<code>NULL</code> (no reduction). Has no effect if <code>draws</code> is specified.</p>
</td></tr>
<tr><td><code id="pred_+3A_draws">draws</code></td>
<td>
<p>Indices of parameter draws to use, or <code>NULL</code> to use all
draws.</p>
</td></tr>
<tr><td><code id="pred_+3A_verbose">verbose</code></td>
<td>
<p>Should more information and a possible progress bar be
printed?</p>
</td></tr>
<tr><td><code id="pred_+3A_stream">STREAM</code></td>
<td>
<p>External pointer. By default obtained with
<code>rstan::get_stream()</code>.</p>
</td></tr>
<tr><td><code id="pred_+3A_c_hat_pred">c_hat_pred</code></td>
<td>
<p>This is only used if the latent signal <code>f</code> was
sampled. This input contains the values added to the sum <code>f</code> before
passing through inverse link function. Must be a vector with length equal to
the number of prediction points. If original <code>c_hat</code> was constant,
then <code>c_hat_pred</code> can be ignored, in which case this will by default
use the same constant.</p>
</td></tr>
<tr><td><code id="pred_+3A_force">force</code></td>
<td>
<p>This is by default <code>FALSE</code> to prevent unintended
large computations that might crash R or take forever. Set it to <code>TRUE</code>
try computing no matter what.</p>
</td></tr>
<tr><td><code id="pred_+3A_debug_kc">debug_kc</code></td>
<td>
<p>If this is <code>TRUE</code>, this only returns a
<a href="#topic+KernelComputer-class">KernelComputer</a> object that is created internally. Meant for
debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+GaussianPrediction-class">GaussianPrediction</a> or
<a href="#topic+Prediction-class">Prediction</a>.
</p>


<h3>See Also</h3>

<p>Other main functions: 
<code><a href="#topic+create_model">create_model</a>()</code>,
<code><a href="#topic+draw_pred">draw_pred</a>()</code>,
<code><a href="#topic+get_draws">get_draws</a>()</code>,
<code><a href="#topic+lgp">lgp</a>()</code>,
<code><a href="#topic+prior_pred">prior_pred</a>()</code>,
<code><a href="#topic+sample_model">sample_model</a>()</code>
</p>

<hr>
<h2 id='Prediction-class'>An S4 class to represent prior or posterior
draws from an additive function distribution.</h2><span id='topic+Prediction-class'></span><span id='topic+Prediction'></span><span id='topic+show+2CPrediction-method'></span><span id='topic+component_names+2CPrediction-method'></span><span id='topic+num_components+2CPrediction-method'></span><span id='topic+num_paramsets+2CPrediction-method'></span><span id='topic+num_evalpoints+2CPrediction-method'></span>

<h3>Description</h3>

<p>An S4 class to represent prior or posterior
draws from an additive function distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Prediction'
show(object)

## S4 method for signature 'Prediction'
component_names(object)

## S4 method for signature 'Prediction'
num_components(object)

## S4 method for signature 'Prediction'
num_paramsets(object)

## S4 method for signature 'Prediction'
num_evalpoints(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prediction-class_+3A_object">object</code></td>
<td>
<p><a href="#topic+Prediction-class">Prediction</a> object for which to apply a class
method.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(Prediction)</code>: Print a summary about the object.
</p>
</li>
<li> <p><code>component_names(Prediction)</code>: Get names of components.
</p>
</li>
<li> <p><code>num_components(Prediction)</code>: Get number of components.
</p>
</li>
<li> <p><code>num_paramsets(Prediction)</code>: Get number of parameter combinations
(different parameter vectors) using which predictions were computed.
</p>
</li>
<li> <p><code>num_evalpoints(Prediction)</code>: Get number of points where
predictions were computed.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>f_comp</code></dt><dd><p>component draws</p>
</dd>
<dt><code>f</code></dt><dd><p>signal draws</p>
</dd>
<dt><code>h</code></dt><dd><p>predictions (signal draws + scaling factor <code>c_hat</code>,
transformed through inverse link function)</p>
</dd>
<dt><code>x</code></dt><dd><p>a data frame of points (covariate values) where the
functions/predictions have been evaluated/sampled</p>
</dd>
<dt><code>extrapolated</code></dt><dd><p>Boolean value telling if the function draws are
original MCMC draws or if they have been created by extrapolating
such draws.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+GaussianPrediction-class">GaussianPrediction</a>
</p>

<hr>
<h2 id='prior_pred'>Prior (predictive) sampling</h2><span id='topic+prior_pred'></span><span id='topic+sample_param_prior'></span>

<h3>Description</h3>

<p>These functions take an <a href="#topic+lgpmodel-class">lgpmodel</a> object, and
</p>

<ul>
<li> <p><code>prior_pred</code> samples from the prior predictive distribution of
the model
</p>
</li>
<li> <p><code>sample_param_prior</code> samples only its parameter prior using
<code><a href="rstan.html#topic+sampling">sampling</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>prior_pred(
  model,
  verbose = TRUE,
  quiet = FALSE,
  refresh = 0,
  STREAM = get_stream(),
  ...
)

sample_param_prior(model, verbose = TRUE, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_pred_+3A_model">model</code></td>
<td>
<p>An object of class <a href="#topic+lgpmodel-class">lgpmodel</a>.</p>
</td></tr>
<tr><td><code id="prior_pred_+3A_verbose">verbose</code></td>
<td>
<p>Should more information and a possible progress bar be
printed?</p>
</td></tr>
<tr><td><code id="prior_pred_+3A_quiet">quiet</code></td>
<td>
<p>This forces <code>verbose</code> to be <code>FALSE</code>. If you want
to suppress also the output from Stan, give the additional argument
<code>refresh=0</code>.</p>
</td></tr>
<tr><td><code id="prior_pred_+3A_refresh">refresh</code></td>
<td>
<p>Argument for <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
<tr><td><code id="prior_pred_+3A_stream">STREAM</code></td>
<td>
<p>External pointer. By default obtained with
<code>rstan::get_stream()</code>.</p>
</td></tr>
<tr><td><code id="prior_pred_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>prior_pred</code> returns a list with components
</p>

<ul>
<li> <p><code>y_draws</code>: A matrix containing the prior predictive draws
as rows. Can be passed to <code>bayesplot::pp_check()</code> for
graphical prior predictive checking.
</p>
</li>
<li> <p><code>pred_draws</code>: an object of class <a href="#topic+Prediction-class">Prediction</a>,
containing prior draws of each model component and their sum
</p>
</li>
<li> <p><code>param_draws</code>: a <code>stanfit</code> object of prior parameter
draws (obtained by calling <code>sample_param_prior</code> internally)
</p>
</li></ul>

</li>
<li> <p><code>sample_param_prior</code> returns
an object of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other main functions: 
<code><a href="#topic+create_model">create_model</a>()</code>,
<code><a href="#topic+draw_pred">draw_pred</a>()</code>,
<code><a href="#topic+get_draws">get_draws</a>()</code>,
<code><a href="#topic+lgp">lgp</a>()</code>,
<code><a href="#topic+pred">pred</a>()</code>,
<code><a href="#topic+sample_model">sample_model</a>()</code>
</p>

<hr>
<h2 id='prior_to_num'>Convert given prior to numeric format</h2><span id='topic+prior_to_num'></span>

<h3>Description</h3>

<p>Convert given prior to numeric format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_to_num(desc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_to_num_+3A_desc">desc</code></td>
<td>
<p>Prior description as a named list, containing fields
</p>

<ul>
<li> <p><code>dist</code> - Distribution name. Must be one of
'uniform', 'normal', 'student-t', 'gamma', 'inv-gamma', 'log-normal'
(case-insensitive)
</p>
</li>
<li> <p><code>square</code> - Is the prior for a square-transformed parameter.
</p>
</li></ul>

<p>Other list fields are interpreted as hyperparameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of parsed options
</p>

<hr>
<h2 id='priors'>Prior definitions</h2><span id='topic+priors'></span><span id='topic+normal+2C'></span><span id='topic+log_normal+2C'></span><span id='topic+gam+2C'></span><span id='topic+igam+2C'></span><span id='topic+uniform+2C'></span><span id='topic+student_t+2C'></span><span id='topic+bet'></span><span id='topic+uniform'></span><span id='topic+normal'></span><span id='topic+student_t'></span><span id='topic+gam'></span><span id='topic+igam'></span><span id='topic+log_normal'></span>

<h3>Description</h3>

<p>These use the same parametrizations as defined in the 'Stan'
documentation. See the docs for
<a href="https://mc-stan.org/docs/2_24/functions-reference/gamma-distribution.html">gamma</a> and
<a href="https://mc-stan.org/docs/2_24/functions-reference/inverse-gamma-distribution.html">inverse gamma</a> distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform(square = FALSE)

normal(mu, sigma, square = FALSE)

student_t(nu, square = FALSE)

gam(shape, inv_scale, square = FALSE)

igam(shape, scale, square = FALSE)

log_normal(mu, sigma, square = FALSE)

bet(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priors_+3A_square">square</code></td>
<td>
<p>is prior for a square-transformed parameter?</p>
</td></tr>
<tr><td><code id="priors_+3A_mu">mu</code></td>
<td>
<p>mean</p>
</td></tr>
<tr><td><code id="priors_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation</p>
</td></tr>
<tr><td><code id="priors_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="priors_+3A_shape">shape</code></td>
<td>
<p>shape parameter (alpha)</p>
</td></tr>
<tr><td><code id="priors_+3A_inv_scale">inv_scale</code></td>
<td>
<p>inverse scale parameter (beta)</p>
</td></tr>
<tr><td><code id="priors_+3A_scale">scale</code></td>
<td>
<p>scale parameter (beta)</p>
</td></tr>
<tr><td><code id="priors_+3A_a">a</code></td>
<td>
<p>shape parameter</p>
</td></tr>
<tr><td><code id="priors_+3A_b">b</code></td>
<td>
<p>shape parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list
</p>


<h3>See Also</h3>

<p>Other functions related to the inverse-gamma distribution: 
<code><a href="#topic+dinvgamma_stanlike">dinvgamma_stanlike</a>()</code>,
<code><a href="#topic+plot_invgamma">plot_invgamma</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Log-normal prior
log_normal(mu = 1, sigma = 1)

# Cauchy prior
student_t(nu = 1)

# Exponential prior with rate = 0.1
gam(shape = 1, inv_scale = 0.1)

# Create a similar priors as in LonGP (Cheng et al., 2019)
# Not recommended, because a lengthscale close to 0 is possible.
a &lt;- log(1) - log(0.1)
log_normal(mu = 0, sigma = a / 2) # for continuous lengthscale
student_t(nu = 4) # for interaction lengthscale
igam(shape = 0.5, scale = 0.005, square = TRUE) # for sigma
</code></pre>

<hr>
<h2 id='read_proteomics_data'>Function for reading the built-in proteomics data</h2><span id='topic+read_proteomics_data'></span>

<h3>Description</h3>

<p>Function for reading the built-in proteomics data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_proteomics_data(parentDir = NULL, protein = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_proteomics_data_+3A_parentdir">parentDir</code></td>
<td>
<p>Path to local parent directory for the data.
If this is <code>NULL</code>, data is downloaded from
<a href="https://github.com/jtimonen/lgpr-usage/tree/master/data/proteomics">https://github.com/jtimonen/lgpr-usage/tree/master/data/proteomics</a>.</p>
</td></tr>
<tr><td><code id="read_proteomics_data_+3A_protein">protein</code></td>
<td>
<p>Index or name of protein.</p>
</td></tr>
<tr><td><code id="read_proteomics_data_+3A_verbose">verbose</code></td>
<td>
<p>Can this print some output?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>

<hr>
<h2 id='relevances'>Assess component relevances</h2><span id='topic+relevances'></span>

<h3>Description</h3>

<p>Assess component relevances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relevances(fit, reduce = function(x) base::mean(x), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relevances_+3A_fit">fit</code></td>
<td>
<p>an object of class <code>lgpfit</code></p>
</td></tr>
<tr><td><code id="relevances_+3A_reduce">reduce</code></td>
<td>
<p>a function to apply to reduce the relevances given each
parameter draw into one value</p>
</td></tr>
<tr><td><code id="relevances_+3A_verbose">verbose</code></td>
<td>
<p>Can this print any messages?</p>
</td></tr>
<tr><td><code id="relevances_+3A_...">...</code></td>
<td>
<p>currently has no effect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector with length equal to <code>num_comps + 1</code>
</p>

<hr>
<h2 id='s4_generics'>S4 generics for lgpfit, lgpmodel, and other objects</h2><span id='topic+s4_generics'></span><span id='topic+parameter_info'></span><span id='topic+component_info'></span><span id='topic+covariate_info'></span><span id='topic+component_names'></span><span id='topic+get_model'></span><span id='topic+is_f_sampled'></span><span id='topic+get_stanfit'></span><span id='topic+postproc'></span><span id='topic+contains_postproc'></span><span id='topic+clear_postproc'></span><span id='topic+num_paramsets'></span><span id='topic+num_evalpoints'></span><span id='topic+num_components'></span>

<h3>Description</h3>

<p>S4 generics for lgpfit, lgpmodel, and other objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_info(object, digits)

component_info(object)

covariate_info(object)

component_names(object)

get_model(object)

is_f_sampled(object)

get_stanfit(object)

postproc(object, ...)

contains_postproc(object)

clear_postproc(object)

num_paramsets(object)

num_evalpoints(object)

num_components(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s4_generics_+3A_object">object</code></td>
<td>
<p>object for which to apply the generic</p>
</td></tr>
<tr><td><code id="s4_generics_+3A_digits">digits</code></td>
<td>
<p>number of digits to show</p>
</td></tr>
<tr><td><code id="s4_generics_+3A_...">...</code></td>
<td>
<p>additional optional arguments to pass</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>parameter_info</code> returns a data frame with
one row for each parameter and columns
for parameter name, parameter bounds, and the assigned prior
</p>
</li>
<li> <p><code>component_info</code> returns a data frame with one row for
each model component, and columns encoding information about
model components
</p>
</li>
<li> <p><code>covariate_info</code> returns a list with names
<code>continuous</code> and <code>categorical</code>, with information about
both continuous and categorical covariates
</p>
</li>
<li> <p><code>component_names</code> returns a character vector with
component names
</p>
</li>
<li> <p><code>get_model</code> for <a href="#topic+lgpfit-class">lgpfit</a> objects
returns an <a href="#topic+lgpmodel-class">lgpmodel</a>
</p>
</li>
<li> <p><code>is_f_sampled</code> returns a logical value
</p>
</li>
<li> <p><code>get_stanfit</code> returns a <code>stanfit</code> (rstan)
</p>
</li>
<li> <p><code>postproc</code> applies postprocessing and returns an
updated <a href="#topic+lgpfit-class">lgpfit</a>
</p>
</li>
<li> <p><code>clear_postproc</code> removes postprocessing information and
returns an updated <a href="#topic+lgpfit-class">lgpfit</a>
</p>
</li>
<li> <p><code>num_paramsets</code>, <code>num_evalpoints</code> and
<code>num_components</code> return an integer
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>parameter_info()</code>: Get parameter information (priors etc.).
</p>
</li>
<li> <p><code>component_info()</code>: Get component information.
</p>
</li>
<li> <p><code>covariate_info()</code>: Get covariate information.
</p>
</li>
<li> <p><code>component_names()</code>: Get component names.
</p>
</li>
<li> <p><code>get_model()</code>: Get <a href="#topic+lgpmodel-class">lgpmodel</a> object.
</p>
</li>
<li> <p><code>is_f_sampled()</code>: Determine if signal f is sampled or marginalized.
</p>
</li>
<li> <p><code>get_stanfit()</code>: Extract stanfit object.
</p>
</li>
<li> <p><code>postproc()</code>: Perform postprocessing.
</p>
</li>
<li> <p><code>contains_postproc()</code>: Determine if object contains postprocessing
information.
</p>
</li>
<li> <p><code>clear_postproc()</code>: Clear postprocessing information (to reduce
size of object).
</p>
</li>
<li> <p><code>num_paramsets()</code>: Get number of parameter sets.
</p>
</li>
<li> <p><code>num_evalpoints()</code>: Get number of points where posterior is evaluated.
</p>
</li>
<li> <p><code>num_components()</code>: Get number of model components.
</p>
</li></ul>


<h3>See Also</h3>

<p>To find out which methods have been implemented for which classes,
see <a href="#topic+lgpfit-class">lgpfit</a>, <a href="#topic+lgpmodel-class">lgpmodel</a>,
<a href="#topic+Prediction-class">Prediction</a> and <a href="#topic+GaussianPrediction-class">GaussianPrediction</a>.
</p>

<hr>
<h2 id='sample_model'>Fitting a model</h2><span id='topic+sample_model'></span><span id='topic+optimize_model'></span>

<h3>Description</h3>


<ul>
<li> <p><code>sample_model</code> takes an <a href="#topic+lgpmodel-class">lgpmodel</a>
object and fits it using <code><a href="rstan.html#topic+sampling">sampling</a></code>.
</p>
</li>
<li> <p><code>optimize_model</code> takes an <a href="#topic+lgpmodel-class">lgpmodel</a>
object and fits it using <code><a href="rstan.html#topic+optimizing">optimizing</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sample_model(
  model,
  verbose = TRUE,
  quiet = FALSE,
  skip_postproc = is_f_sampled(model),
  ...
)

optimize_model(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_model_+3A_model">model</code></td>
<td>
<p>An object of class <a href="#topic+lgpmodel-class">lgpmodel</a>.</p>
</td></tr>
<tr><td><code id="sample_model_+3A_verbose">verbose</code></td>
<td>
<p>Can messages be printed?</p>
</td></tr>
<tr><td><code id="sample_model_+3A_quiet">quiet</code></td>
<td>
<p>Should all output messages be suppressed? You need to set
also <code>refresh=0</code> if you want to suppress also the progress update
messages from <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
<tr><td><code id="sample_model_+3A_skip_postproc">skip_postproc</code></td>
<td>
<p>Should all postprocessing be skipped? If this is
<code>TRUE</code>, the returned <a href="#topic+lgpfit-class">lgpfit</a> object will likely be
much smaller (if <code>sample_f=FALSE</code>).</p>
</td></tr>
<tr><td><code id="sample_model_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to
<code><a href="rstan.html#topic+sampling">sampling</a></code> or <code><a href="rstan.html#topic+optimizing">optimizing</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>sample_model</code> returns an object of class <a href="#topic+lgpfit-class">lgpfit</a>
containing the parameter draws, the original <code>model</code> object,
and possible postprocessing results. See documentation of
<a href="#topic+lgpfit-class">lgpfit</a> for more information.
</p>
</li>
<li> <p><code>optimize_model</code> directly returns the list returned by
<code><a href="rstan.html#topic+optimizing">optimizing</a></code>. See its documentation for more information.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other main functions: 
<code><a href="#topic+create_model">create_model</a>()</code>,
<code><a href="#topic+draw_pred">draw_pred</a>()</code>,
<code><a href="#topic+get_draws">get_draws</a>()</code>,
<code><a href="#topic+lgp">lgp</a>()</code>,
<code><a href="#topic+pred">pred</a>()</code>,
<code><a href="#topic+prior_pred">prior_pred</a>()</code>
</p>

<hr>
<h2 id='select'>Select relevant components</h2><span id='topic+select'></span><span id='topic+select_freq'></span><span id='topic+select.integrate'></span><span id='topic+select_freq.integrate'></span>

<h3>Description</h3>


<ul>
<li> <p><code>select</code> performs strict selection, returning either <code>TRUE</code>
or <code>FALSE</code> for each component.
</p>
</li>
<li> <p><code>select.integrate</code> is like <code>select</code>, but instead of
a fixed threshold, computes probabilistic selection by integrating over
a threshold density.
</p>
</li>
<li> <p><code>select_freq</code> performs the selection separately using
each parameter draw and returns the frequency at which each
component was selected.
</p>
</li>
<li> <p><code>select_freq.integrate</code> is like <code>select_freq</code>, but
instead of a fixed threshold, computes probabilistic selection
frequencies by integrating over a threshold density.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>select(fit, reduce = function(x) base::mean(x), threshold = 0.95, ...)

select_freq(fit, threshold = 0.95, ...)

select.integrate(
  fit,
  reduce = function(x) base::mean(x),
  p = function(x) stats::dbeta(x, 100, 5),
  h = 0.01,
  verbose = TRUE,
  ...
)

select_freq.integrate(
  fit,
  p = function(x) stats::dbeta(x, 100, 5),
  h = 0.01,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>lgpfit</code>.</p>
</td></tr>
<tr><td><code id="select_+3A_reduce">reduce</code></td>
<td>
<p>The <code>reduce</code> argument for <code><a href="#topic+relevances">relevances</a></code>.</p>
</td></tr>
<tr><td><code id="select_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for relevance sum.
Must be a value between 0 and 1.</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+relevances">relevances</a></code>.</p>
</td></tr>
<tr><td><code id="select_+3A_p">p</code></td>
<td>
<p>A threshold density over interval [0,1].</p>
</td></tr>
<tr><td><code id="select_+3A_h">h</code></td>
<td>
<p>A discretization parameter for computing a quadrature.</p>
</td></tr>
<tr><td><code id="select_+3A_verbose">verbose</code></td>
<td>
<p>Should this show a progress bar?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See description.
</p>

<hr>
<h2 id='show'>Printing formula object info using the show generic</h2><span id='topic+show'></span><span id='topic+show+2Clgpformula-method'></span><span id='topic+show+2Clgprhs-method'></span><span id='topic+show+2Clgpterm-method'></span>

<h3>Description</h3>

<p>Printing formula object info using the show generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lgpformula'
show(object)

## S4 method for signature 'lgprhs'
show(object)

## S4 method for signature 'lgpterm'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>an object of some S4 class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object invisibly
</p>

<hr>
<h2 id='sim.create_f'>Simulate latent function components for longitudinal data analysis</h2><span id='topic+sim.create_f'></span>

<h3>Description</h3>

<p>Simulate latent function components for longitudinal data analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.create_f(
  X,
  covariates,
  relevances,
  lengthscales,
  X_affected,
  dis_fun,
  bin_kernel,
  steepness,
  vm_params,
  force_zeromean
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.create_f_+3A_x">X</code></td>
<td>
<p>input data matrix (generated by <code><a href="#topic+sim.create_x">sim.create_x</a></code>)</p>
</td></tr>
<tr><td><code id="sim.create_f_+3A_covariates">covariates</code></td>
<td>
<p>Integer vector that defines the types of covariates
(other than id and age). Different integers correspond to the
following covariate types:
</p>

<ul>
<li><p> 0 = disease-related age
</p>
</li>
<li><p> 1 = other continuous covariate
</p>
</li>
<li><p> 2 = a categorical covariate that interacts with age
</p>
</li>
<li><p> 3 = a categorical covariate that acts as a group offset
</p>
</li>
<li><p> 4 = a categorical covariate that that acts as a group offset AND
is restricted to have value 0 for controls and 1 for cases
</p>
</li></ul>
</td></tr>
<tr><td><code id="sim.create_f_+3A_relevances">relevances</code></td>
<td>
<p>Relative relevance of each component. Must have be a vector
so that <br />
<code>length(relevances) =  2 + length(covariates)</code>. <br />
First two values define the relevance of the individual-specific age and
shared age component, respectively.</p>
</td></tr>
<tr><td><code id="sim.create_f_+3A_lengthscales">lengthscales</code></td>
<td>
<p>A vector so that <br /> <code>length(lengthscales) = </code>
<code>2 + sum(covariates %in% c(0,1,2))</code>.</p>
</td></tr>
<tr><td><code id="sim.create_f_+3A_x_affected">X_affected</code></td>
<td>
<p>which individuals are affected by the disease</p>
</td></tr>
<tr><td><code id="sim.create_f_+3A_dis_fun">dis_fun</code></td>
<td>
<p>A function or a string that defines the disease effect. If
this is a function, that function is used to generate the effect.
If <code>dis_fun</code> is &quot;gp_vm&quot; or &quot;gp_ns&quot;, the disease component is drawn from
a nonstationary GP prior (&quot;vm&quot; is the variance masked version of it).</p>
</td></tr>
<tr><td><code id="sim.create_f_+3A_bin_kernel">bin_kernel</code></td>
<td>
<p>Should the binary kernel be used for categorical
covariates? If this is <code>TRUE</code>, the effect will exist only for group 1.</p>
</td></tr>
<tr><td><code id="sim.create_f_+3A_steepness">steepness</code></td>
<td>
<p>Steepness of the input warping function. This is only used
if the disease component is in the model.</p>
</td></tr>
<tr><td><code id="sim.create_f_+3A_vm_params">vm_params</code></td>
<td>
<p>Parameters of the variance mask function. This is only
needed if <code>useMaskedVarianceKernel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sim.create_f_+3A_force_zeromean">force_zeromean</code></td>
<td>
<p>Should each component (excluding the disease age
component) be forced to have a zero mean?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame FFF where one column corresponds to one additive
component
</p>

<hr>
<h2 id='sim.create_x'>Create an input data frame X for simulated data</h2><span id='topic+sim.create_x'></span>

<h3>Description</h3>

<p>Create an input data frame X for simulated data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.create_x(
  N,
  covariates,
  names,
  n_categs,
  t_data,
  t_jitter,
  t_effect_range,
  continuous_info
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.create_x_+3A_n">N</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="sim.create_x_+3A_covariates">covariates</code></td>
<td>
<p>Integer vector that defines the types of covariates
(other than id and age). If not given, only the id and age
covariates are created. Different integers correspond to the following
covariate types:
</p>

<ul>
<li><p> 0 = disease-related age
</p>
</li>
<li><p> 1 = other continuous covariate
</p>
</li>
<li><p> 2 = a categorical covariate that interacts with age
</p>
</li>
<li><p> 3 = a categorical covariate that acts as a group offset
</p>
</li>
<li><p> 4 = a categorical covariate that that acts as a group offset AND
is restricted to have value 0 for controls and 1 for cases
</p>
</li></ul>
</td></tr>
<tr><td><code id="sim.create_x_+3A_names">names</code></td>
<td>
<p>Covariate names.</p>
</td></tr>
<tr><td><code id="sim.create_x_+3A_n_categs">n_categs</code></td>
<td>
<p>An integer vector defining the number of categories
for each categorical covariate, so that <code>length(n_categs)</code> equals to
the number of 2's and 3's in the <code>covariates</code> vector.</p>
</td></tr>
<tr><td><code id="sim.create_x_+3A_t_data">t_data</code></td>
<td>
<p>Measurement times (same for each individual, unless
<code>t_jitter &gt; 0</code> in which case they are perturbed).</p>
</td></tr>
<tr><td><code id="sim.create_x_+3A_t_jitter">t_jitter</code></td>
<td>
<p>Standard deviation of the jitter added to the given
measurement times.</p>
</td></tr>
<tr><td><code id="sim.create_x_+3A_t_effect_range">t_effect_range</code></td>
<td>
<p>Time interval from which the disease effect times are
sampled uniformly. Alternatively, This can any function that returns the
(possibly randomly generated) real disease effect time for one individual.</p>
</td></tr>
<tr><td><code id="sim.create_x_+3A_continuous_info">continuous_info</code></td>
<td>
<p>Info for generating continuous covariates. Must be a
list containing fields <code>lambda</code> and <code>mu</code>, which have length 3.
The continuous covariates are generated so that <code>x &lt;- sin(a*t + b) + c</code>,
where
</p>

<ul>
<li> <p><code>t &lt;- seq(0, 2*pi, length.out = k)</code>
</p>
</li>
<li> <p><code>a &lt;- mu[1] + lambda[1]*stats::runif(1)</code>
</p>
</li>
<li> <p><code>b &lt;- mu[2] + lambda[2]*stats::runif(1)</code>
</p>
</li>
<li> <p><code>c &lt;- mu[3] + lambda[3]*stats::runif(1)</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='sim.create_y'>Simulate noisy observations</h2><span id='topic+sim.create_y'></span>

<h3>Description</h3>

<p>Simulate noisy observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.create_y(noise_type, f, snr, phi, gamma, N_trials)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.create_y_+3A_noise_type">noise_type</code></td>
<td>
<p>Either &quot;gaussian&quot;, &quot;poisson&quot;, &quot;nb&quot; (negative binomial),
&quot;binomial&quot;, or &quot;bb&quot; (beta-binomial).</p>
</td></tr>
<tr><td><code id="sim.create_y_+3A_f">f</code></td>
<td>
<p>The underlying signal.</p>
</td></tr>
<tr><td><code id="sim.create_y_+3A_snr">snr</code></td>
<td>
<p>The desired signal-to-noise ratio. This argument is valid
only when <code>noise_type</code> is <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="sim.create_y_+3A_phi">phi</code></td>
<td>
<p>The inverse overdispersion parameter for negative binomial data.
The variance is <code>g + g^2/phi</code>.</p>
</td></tr>
<tr><td><code id="sim.create_y_+3A_gamma">gamma</code></td>
<td>
<p>The dispersion parameter for beta-binomial data.</p>
</td></tr>
<tr><td><code id="sim.create_y_+3A_n_trials">N_trials</code></td>
<td>
<p>The number of trials parameter for binomial data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list <code>out</code>, where
</p>

<ul>
<li> <p><code>out$h</code> is <code>f</code> mapped through an inverse link function
(times <code>N_trials</code> if <code>noise_type</code> is binomial or beta-binomial)
</p>
</li>
<li> <p><code>out$y</code> is the noisy response variable.
</p>
</li></ul>


<hr>
<h2 id='sim.kernels'>Compute all kernel matrices when simulating data</h2><span id='topic+sim.kernels'></span>

<h3>Description</h3>

<p>Compute all kernel matrices when simulating data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.kernels(
  X,
  types,
  lengthscales,
  X_affected,
  bin_kernel,
  useMaskedVarianceKernel,
  steepness,
  vm_params
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.kernels_+3A_x">X</code></td>
<td>
<p>covariates</p>
</td></tr>
<tr><td><code id="sim.kernels_+3A_types">types</code></td>
<td>
<p>vector of covariate types, so that
</p>

<ul>
<li><p> 1 = ID
</p>
</li>
<li><p> 2 = age
</p>
</li>
<li><p> 3 = diseaseAge
</p>
</li>
<li><p> 4 = other continuous covariate
</p>
</li>
<li><p> 5 = a categorical covariate that interacts with age
</p>
</li>
<li><p> 6 = a categorical covariate that acts as an offset
</p>
</li></ul>
</td></tr>
<tr><td><code id="sim.kernels_+3A_lengthscales">lengthscales</code></td>
<td>
<p>vector of lengthscales</p>
</td></tr>
<tr><td><code id="sim.kernels_+3A_x_affected">X_affected</code></td>
<td>
<p>which individuals are affected by the disease</p>
</td></tr>
<tr><td><code id="sim.kernels_+3A_bin_kernel">bin_kernel</code></td>
<td>
<p>whether or not binary (mask) kernel should be used for
categorical covariates (if not, the zerosum kernel is used)</p>
</td></tr>
<tr><td><code id="sim.kernels_+3A_usemaskedvariancekernel">useMaskedVarianceKernel</code></td>
<td>
<p>should the masked variance kernel be used
for drawing the disease component</p>
</td></tr>
<tr><td><code id="sim.kernels_+3A_steepness">steepness</code></td>
<td>
<p>steepness of the input warping function</p>
</td></tr>
<tr><td><code id="sim.kernels_+3A_vm_params">vm_params</code></td>
<td>
<p>parameters of the variance mask function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3D array
</p>

<hr>
<h2 id='simulate_data'>Generate an artificial longitudinal data set</h2><span id='topic+simulate_data'></span>

<h3>Description</h3>

<p>Generate an artificial longitudinal data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_data(
  N,
  t_data,
  covariates = c(),
  names = NULL,
  relevances = c(1, 1, rep(1, length(covariates))),
  n_categs = rep(2, sum(covariates %in% c(2, 3))),
  t_jitter = 0,
  lengthscales = rep(12, 2 + sum(covariates %in% c(0, 1, 2))),
  f_var = 1,
  noise_type = "gaussian",
  snr = 3,
  phi = 1,
  gamma = 0.2,
  N_affected = round(N/2),
  t_effect_range = "auto",
  t_observed = "after_0",
  c_hat = 0,
  dis_fun = "gp_warp_vm",
  bin_kernel = FALSE,
  steepness = 0.5,
  vm_params = c(0.025, 1),
  continuous_info = list(mu = c(pi/8, pi, -0.5), lambda = c(pi/8, pi, 1)),
  N_trials = 1,
  force_zeromean = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_data_+3A_n">N</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_t_data">t_data</code></td>
<td>
<p>Measurement times (same for each individual, unless
<code>t_jitter &gt; 0</code> in which case they are perturbed).</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_covariates">covariates</code></td>
<td>
<p>Integer vector that defines the types of covariates
(other than id and age). If not given, only the id and age
covariates are created. Different integers correspond to the following
covariate types:
</p>

<ul>
<li><p> 0 = disease-related age
</p>
</li>
<li><p> 1 = other continuous covariate
</p>
</li>
<li><p> 2 = a categorical covariate that interacts with age
</p>
</li>
<li><p> 3 = a categorical covariate that acts as a group offset
</p>
</li>
<li><p> 4 = a categorical covariate that that acts as a group offset AND
is restricted to have value 0 for controls and 1 for cases
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_data_+3A_names">names</code></td>
<td>
<p>Covariate names.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_relevances">relevances</code></td>
<td>
<p>Relative relevance of each component. Must have be a vector
so that <br />
<code>length(relevances) =  2 + length(covariates)</code>. <br />
First two values define the relevance of the individual-specific age and
shared age component, respectively.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_n_categs">n_categs</code></td>
<td>
<p>An integer vector defining the number of categories
for each categorical covariate, so that <code>length(n_categs)</code> equals to
the number of 2's and 3's in the <code>covariates</code> vector.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_t_jitter">t_jitter</code></td>
<td>
<p>Standard deviation of the jitter added to the given
measurement times.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_lengthscales">lengthscales</code></td>
<td>
<p>A vector so that <br /> <code>length(lengthscales) = </code>
<code>2 + sum(covariates %in% c(0,1,2))</code>.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_f_var">f_var</code></td>
<td>
<p>variance of f</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_noise_type">noise_type</code></td>
<td>
<p>Either &quot;gaussian&quot;, &quot;poisson&quot;, &quot;nb&quot; (negative binomial),
&quot;binomial&quot;, or &quot;bb&quot; (beta-binomial).</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_snr">snr</code></td>
<td>
<p>The desired signal-to-noise ratio. This argument is valid
only when <code>noise_type</code> is <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_phi">phi</code></td>
<td>
<p>The inverse overdispersion parameter for negative binomial data.
The variance is <code>g + g^2/phi</code>.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_gamma">gamma</code></td>
<td>
<p>The dispersion parameter for beta-binomial data.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_n_affected">N_affected</code></td>
<td>
<p>Number of diseased individuals that are affected by the
disease. This defaults to the number of diseased individuals. This argument
can only be given if <code>covariates</code> contains a zero.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_t_effect_range">t_effect_range</code></td>
<td>
<p>Time interval from which the disease effect times are
sampled uniformly. Alternatively, This can any function that returns the
(possibly randomly generated) real disease effect time for one individual.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_t_observed">t_observed</code></td>
<td>
<p>Determines how the disease effect time is observed. This
can be any function that takes the real disease effect time as an argument
and returns the (possibly randomly generated) observed onset/initiation time.
Alternatively, this can be a string of the form <code>"after_n"</code> or
<code>"random_p"</code> or <code>"exact"</code>.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_c_hat">c_hat</code></td>
<td>
<p>a constant added to f</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_dis_fun">dis_fun</code></td>
<td>
<p>A function or a string that defines the disease effect. If
this is a function, that function is used to generate the effect.
If <code>dis_fun</code> is &quot;gp_vm&quot; or &quot;gp_ns&quot;, the disease component is drawn from
a nonstationary GP prior (&quot;vm&quot; is the variance masked version of it).</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_bin_kernel">bin_kernel</code></td>
<td>
<p>Should the binary kernel be used for categorical
covariates? If this is <code>TRUE</code>, the effect will exist only for group 1.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_steepness">steepness</code></td>
<td>
<p>Steepness of the input warping function. This is only used
if the disease component is in the model.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_vm_params">vm_params</code></td>
<td>
<p>Parameters of the variance mask function. This is only
needed if <code>useMaskedVarianceKernel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_continuous_info">continuous_info</code></td>
<td>
<p>Info for generating continuous covariates. Must be a
list containing fields <code>lambda</code> and <code>mu</code>, which have length 3.
The continuous covariates are generated so that <code>x &lt;- sin(a*t + b) + c</code>,
where
</p>

<ul>
<li> <p><code>t &lt;- seq(0, 2*pi, length.out = k)</code>
</p>
</li>
<li> <p><code>a &lt;- mu[1] + lambda[1]*stats::runif(1)</code>
</p>
</li>
<li> <p><code>b &lt;- mu[2] + lambda[2]*stats::runif(1)</code>
</p>
</li>
<li> <p><code>c &lt;- mu[3] + lambda[3]*stats::runif(1)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_data_+3A_n_trials">N_trials</code></td>
<td>
<p>The number of trials parameter for binomial data.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_force_zeromean">force_zeromean</code></td>
<td>
<p>Should each component (excluding the disease age
component) be forced to have a zero mean?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+lgpsim-class">lgpsim</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate Gaussian data
dat &lt;- simulate_data(N = 4, t_data = c(6, 12, 24, 36, 48), snr = 3)

# Generate negative binomially (NB) distributed count data
dat &lt;- simulate_data(
  N = 6, t_data = seq(2, 10, by = 2), noise_type = "nb",
  phi = 2
)
</code></pre>

<hr>
<h2 id='split'>Split data into training and test sets</h2><span id='topic+split'></span><span id='topic+split_by_factor'></span><span id='topic+split_within_factor'></span><span id='topic+split_within_factor_random'></span><span id='topic+split_random'></span><span id='topic+split_data'></span>

<h3>Description</h3>


<ul>
<li> <p><code>split_by_factor</code> splits according to given factor
</p>
</li>
<li> <p><code>split_within_factor</code> splits according to given
data point indices within the same level of a factor
</p>
</li>
<li> <p><code>split_within_factor_random</code> selects k points
from each level of a factor uniformly at random as test data
</p>
</li>
<li> <p><code>split_random</code> splits uniformly at random
</p>
</li>
<li> <p><code>split_data</code> splits according to given data rows
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>split_by_factor(data, test, var_name = "id")

split_within_factor(data, idx_test, var_name = "id")

split_within_factor_random(data, k_test = 1, var_name = "id")

split_random(data, p_test = 0.2, n_test = NULL)

split_data(data, i_test, sort_ids = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="split_+3A_test">test</code></td>
<td>
<p>the levels of the factor that will be used as test data</p>
</td></tr>
<tr><td><code id="split_+3A_var_name">var_name</code></td>
<td>
<p>name of a factor in the data</p>
</td></tr>
<tr><td><code id="split_+3A_idx_test">idx_test</code></td>
<td>
<p>indices point indices with the factor</p>
</td></tr>
<tr><td><code id="split_+3A_k_test">k_test</code></td>
<td>
<p>desired number of test data points per each level of the
factor</p>
</td></tr>
<tr><td><code id="split_+3A_p_test">p_test</code></td>
<td>
<p>desired proportion of test data</p>
</td></tr>
<tr><td><code id="split_+3A_n_test">n_test</code></td>
<td>
<p>desired number of test data points (if NULL, <code>p_test</code>
is used to compute this)</p>
</td></tr>
<tr><td><code id="split_+3A_i_test">i_test</code></td>
<td>
<p>test data row indices</p>
</td></tr>
<tr><td><code id="split_+3A_sort_ids">sort_ids</code></td>
<td>
<p>should the test indices be sorted into increasing order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with names <code>train</code>, <code>test</code>, <code>i_train</code>
and <code>i_test</code>
</p>


<h3>See Also</h3>

<p>Other data frame handling functions: 
<code><a href="#topic+add_dis_age">add_dis_age</a>()</code>,
<code><a href="#topic+add_factor_crossing">add_factor_crossing</a>()</code>,
<code><a href="#topic+add_factor">add_factor</a>()</code>,
<code><a href="#topic+adjusted_c_hat">adjusted_c_hat</a>()</code>,
<code><a href="#topic+new_x">new_x</a>()</code>
</p>

<hr>
<h2 id='testdata_001'>A very small artificial test data, used mostly for unit tests</h2><span id='topic+testdata_001'></span>

<h3>Description</h3>

<p>A very small artificial test data, used mostly for unit tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testdata_001
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 rows and 6 variables:
</p>

<dl>
<dt>id</dt><dd><p>individual id, a factor with levels: 1, 2, 3, 4</p>
</dd>
<dt>age</dt><dd><p>age</p>
</dd>
<dt>dis_age</dt><dd><p>disease-related age</p>
</dd>
<dt>blood</dt><dd><p>a continuous variable</p>
</dd>
<dt>sex</dt><dd><p>a factor with 2 levels: Male, Female</p>
</dd>
<dt>y</dt><dd><p>a continuous variable</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other built-in datasets: 
<code><a href="#topic+testdata_002">testdata_002</a></code>
</p>

<hr>
<h2 id='testdata_002'>Medium-size artificial test data, used mostly for tutorials</h2><span id='topic+testdata_002'></span>

<h3>Description</h3>

<p>Medium-size artificial test data, used mostly for tutorials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testdata_002
</code></pre>


<h3>Format</h3>

<p>A data frame with 96 rows and 6 variables:
</p>

<dl>
<dt>id</dt><dd><p>individual id, a factor with levels: 01-12</p>
</dd>
<dt>age</dt><dd><p>age</p>
</dd>
<dt>diseaseAge</dt><dd><p>disease-related age</p>
</dd>
<dt>sex</dt><dd><p>a factor with 2 levels: Male, Female</p>
</dd>
<dt>group</dt><dd><p>a factor with 2 levels: Case, Control</p>
</dd>
<dt>y</dt><dd><p>a continuous variable</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+read_proteomics_data">read_proteomics_data</a></code>
</p>
<p>Other built-in datasets: 
<code><a href="#topic+testdata_001">testdata_001</a></code>
</p>

<hr>
<h2 id='validate'>Validate S4 class objects</h2><span id='topic+validate'></span><span id='topic+validate_lgpexpr'></span><span id='topic+validate_lgpformula'></span><span id='topic+validate_lgpscaling'></span><span id='topic+validate_lgpfit'></span><span id='topic+validate_GaussianPrediction'></span><span id='topic+validate_Prediction'></span>

<h3>Description</h3>

<p>Validate S4 class objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_lgpexpr(object)

validate_lgpformula(object)

validate_lgpscaling(object)

validate_lgpfit(object)

validate_GaussianPrediction(object)

validate_Prediction(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_object">object</code></td>
<td>
<p>an object to validate</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if valid, otherwise reasons for invalidity
</p>

<hr>
<h2 id='var_mask'>Variance masking function</h2><span id='topic+var_mask'></span>

<h3>Description</h3>

<p>Variance masking function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_mask(x, stp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_mask_+3A_x">x</code></td>
<td>
<p>a vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="var_mask_+3A_stp">stp</code></td>
<td>
<p>a positive real number (steepness of mask function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length <code class="reqn">n</code>
</p>


<h3>See Also</h3>

<p>Other kernel utility functions: 
<code><a href="#topic+warp_input">warp_input</a>()</code>
</p>

<hr>
<h2 id='warp_input'>Input warping function</h2><span id='topic+warp_input'></span>

<h3>Description</h3>

<p>Input warping function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warp_input(x, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warp_input_+3A_x">x</code></td>
<td>
<p>a vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="warp_input_+3A_a">a</code></td>
<td>
<p>steepness of the warping function rise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of warped inputs <code class="reqn">w(x)</code>, length <code class="reqn">n</code>
</p>


<h3>See Also</h3>

<p>Other kernel utility functions: 
<code><a href="#topic+var_mask">var_mask</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
