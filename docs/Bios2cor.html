<!DOCTYPE html><html><head><title>Help for package Bios2cor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Bios2cor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bios2cor-package'>
<p>Correlation/covariation Analysis in Biological Sequences and Simulations</p></a></li>
<li><a href='#angle2rotamer'>
<p>Converts dihedral angles to rotamers</p></a></li>
<li><a href='#angles.plot'>
<p>plots the time evolution of the dihedral angles in top pairs</p></a></li>
<li><a href='#centered_pca'>
<p>Performs principal component analysis of a correlation/covariation matrix</p></a></li>
<li><a href='#delta_filter'>
<p>Creation of an entropy/dynamic score delta filter for each element</p></a></li>
<li><a href='#dynamic_circular'>
<p>Circular correlation</p></a></li>
<li><a href='#dynamic_entropy'>
<p>Variability score</p></a></li>
<li><a href='#dynamic_mi'>
<p>Mutual Information (MI) function applied to rotamers in molecular dynamics simulations</p></a></li>
<li><a href='#dynamic_mip'>
<p>Mutual Information Product (MIP) function applied to rotamers in molecular dynamics simulations</p></a></li>
<li><a href='#dynamic_omes'>
<p>OMES (Observed minus Expected Squared) function applied to rotamers in molecular dynamics simulations</p></a></li>
<li><a href='#dynamic_structure'>
<p>Creates the data structure for the analysis of side chain dihedral angles</p></a></li>
<li><a href='#elsc'>
<p>Explicit Likelihood of Subset Covariation (ELSC) function</p></a></li>
<li><a href='#entropy'>
<p>Entropy score</p></a></li>
<li><a href='#import.fasta'>
<p>Reads a file in FASTA format</p></a></li>
<li><a href='#import.msf'>
<p>Reads a multiple sequence alignment file in MSF format</p></a></li>
<li><a href='#mcbasc'>
<p>McBASC (McLachlan Based Substitution Correlation) function</p></a></li>
<li><a href='#mi'>
<p>Mutual Information (MI) function</p></a></li>
<li><a href='#mip'>
<p>Mutual Information product  (MIP) function</p></a></li>
<li><a href='#network.plot'>
<p>Creates network structure of top elements</p></a></li>
<li><a href='#omes'>
<p>OMES (Observed minus Expected Squared) function</p></a></li>
<li><a href='#pca_2d'>
<p>PCA projection on two dimensions</p></a></li>
<li><a href='#pca_screeplot'>
<p>Creates PCA screeplot</p></a></li>
<li><a href='#random.msa'>
<p>Random Alignment</p></a></li>
<li><a href='#scores_entropy.plot'>
<p>Scores versus entropy graph</p></a></li>
<li><a href='#scores.boxplot'>
<p>Creates boxplots of correlation/covariation scores</p></a></li>
<li><a href='#top_pairs_analysis'>
<p>Calculates the number of contacts for each element of the top pairs</p></a></li>
<li><a href='#write.entropy'>
<p>Writes and displays entropy values</p></a></li>
<li><a href='#write.pca'>
<p>Creates a file of coordinates in PCA space</p></a></li>
<li><a href='#write.pca.pdb'>
<p>PDB and PML file creation for 3D representation of PCA analysis</p></a></li>
<li><a href='#write.scores'>
<p>Creates a correlation/covariation ouput file</p></a></li>
<li><a href='#xyz2torsion'><p> Convert Cartesian Coordinates to Torsion Angles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>From Biological Sequences and Simulations to Correlation
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-10-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Bruck Taddese [aut], Antoine Garnier [aut], Madeline Deniaud [aut], Julien Pele [ctb], Lea Bellenger [ctb], Jean-Michel Becu [ctb], Marie Chabbert [aut,cre] </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marie Chabbert &lt;marie.chabbert@univ-angers.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), bio3d, circular, bigmemory, parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities for computation and analysis of correlation/covariation in multiple sequence alignments and in side chain motions during molecular dynamics simulations. Features include the computation of correlation/covariation scores using a variety of scoring functions between either sequence positions in alignments or side chain dihedral angles in molecular dynamics simulations and utilities to analyze the correlation/covariation matrix through a variety of tools including network representation and principal components analysis. In addition, several utility functions are based on the R graphical environment to provide friendly tools for help in data interpretation. Examples of sequence covariation analysis are provided in: (1) Pele J, Moreau M, Abdi H, Rodien P, Castel H, Chabbert M (2014) &lt;<a href="https://doi.org/10.1002%2Fprot.24570">doi:10.1002/prot.24570</a>&gt; and (2) Taddese B, Deniaud M, Garnier A, Tiss A, Guissouma H, Abdi H, Henrion D, Chabbert M (2018) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1006209">doi:10.1371/journal.pcbi.1006209</a>&gt;. An example of side chain correlated motion analysis is provided in: Taddese B, Garnier A, Abdi H, Henrion D, Chabbert M (2020) &lt;<a href="https://doi.org/10.1038%2Fs41598-020-72766-1">doi:10.1038/s41598-020-72766-1</a>&gt;. This work was supported by the French National Research Agency (Grant number: ANR-11-BSV2-026) and by GENCI (Grant number: 100567).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-08 09:19:21 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-08 09:25:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='bios2cor-package'>
Correlation/covariation Analysis in Biological Sequences and Simulations
</h2><span id='topic+bios2cor-package'></span><span id='topic+bios2cor'></span><span id='topic+Bios2cor'></span>

<h3>Description</h3>

<p>The <code>bios2cor</code> package is dedicated to the computation and analysis of correlation/covariation between positions in multiple sequence alignments (MSA) and between side chain dihedral angles during molecular dynamics simulations (MD). Features include the computation of correlation/covariation scores using a variety of scoring functions and their analysis through a variety of tools including network representation and principal components analysis. In addition, several utility functions are based on the R graphical environment to provide friendly tools for help in data interpretation. 
</p>
<p>For clarity purpose, version 2 of the package differentiates scoring functions working on MSA and on MD because their arguments are different. Analysis functions are common with auto detection of MSA or MD.   
</p>
<p>The main functionalities of <code>bios2cor</code> are summarized below:
</p>

<dl>
<dt>(1) CORRELATION/COVARIATION METHODS : </dt><dd>
<p>Methods that can be used to analyze sequence alignments and molecular simulations and to calculate a correlation/covariation matrix containing a score for each pair of positions (sequence alignment) or each pair of dihedral angles (molecular simulations).
</p>
<p>Methods working with sequence alignments (fasta or msf file is required):
</p>

<ul>
<li> <p><code><a href="#topic+omes">omes</a></code>: calculates the difference between the observed and expected occurrences of each possible pair of amino acids (x, y) at positions i and j of the alignment.
</p>
</li>
<li> <p><code><a href="#topic+mi">mi</a></code> and <code><a href="#topic+mip">mip</a></code>: calculate a score based on the probability of joint occurrence of events (MI)  and a corrected score by substraction of the average product (MIP), respectively. 
</p>
</li>
<li> <p><code><a href="#topic+elsc">elsc</a></code>: calculates a score based on rigorous statistics of correlation/covariation in a perturbation-based algorithm. It measures how many possible subsets of size n would have the composition found in column j.
</p>
</li>
<li> <p><code><a href="#topic+mcbasc">mcbasc</a></code>: relies on a substitution matrix giving a similarity score for each pair of amino acids.
</p>
</li></ul>

<p>Methods working with molecular simulations (pdb and dcd files are required) :
</p>

<ul>
<li> <p><code><a href="#topic+dynamic_circular">dynamic_circular</a></code>: calculates a correlation/covariation score based on a circular version of the Pearson correlation coefficient, between each pair of side chain dihedral angles in a trajectory obtained from molecular dynamics simulations.
</p>
</li>
<li> <p><code><a href="#topic+dynamic_omes">dynamic_omes</a></code>: calculates the difference between the observed and expected occurrences of each possible pair of rotamers (x, y) occuring at side chain dihedral angles i and j in a trajectory.
</p>
</li>
<li> <p><code><a href="#topic+dynamic_mi">dynamic_mi</a></code> and <code><a href="#topic+dynamic_mip">dynamic_mip</a></code>: calculate a score based on the probability of joint occurrence of rotameric states (MI) and a corrected score by substraction of the average product (MIP), respectively.
</p>
</li></ul>

<p>The methods working with molecular simulations require the following functions :
</p>

<ul>
<li> <p><code><a href="#topic+dynamic_structure">dynamic_structure</a></code>: using the result of the <code>xyz2torsion</code> function from the <code>bio3D</code> package, creates a structure that contains side chain dihedral angle informations for each selected frame of the trajectory.
</p>
</li>
<li> <p><code><a href="#topic+angle2rotamer">angle2rotamer</a></code>: using the result of the <code><a href="#topic+dynamic_structure">dynamic_structure</a></code> function, creates a structure that associates rotameric state to each side chain dihedral angle for each selected frame of the trajectory.
</p>
</li></ul>

</dd>
<dt>(2) ADDITIONNAL FUNCTIONS  : </dt><dd>
<p>Functions that can be used to analyse the results of the correlation/covariation methods :
</p>
<p>Entropy functions :
</p>

<ul>
<li> <p><code><a href="#topic+entropy">entropy</a></code>: calculates an entropy score for each position of the alignment. This score is based on sequence conservation and uses a formula derived from the Shannon's entropy.
</p>
</li>
<li> <p><code><a href="#topic+dynamic_entropy">dynamic_entropy</a></code>: calculates a &quot;dynamic entropy&quot; score for each side chain dihedral angle of a protein during molecular simulations. This score is based on the number of rotameric changes of the dihedral angle during the simulation.    
</p>
</li></ul>

<p>Filters:
</p>

<ul>
<li> <p><code><a href="#topic+delta_filter">delta_filter</a></code>: given an entropy object, returns a delta filter for each position of the alignment or each side chain dihedral angle of the protein, based on entropy/dynamic entropy value.
</p>
</li></ul>

<p>PCA :
</p>

<ul>
<li> <p><code><a href="#topic+centered_pca">centered_pca</a></code>: returns a principal component analysis of the double-centered correlation/covariation matrix passed as a parameter. A delta filter can be precised.
</p>
</li></ul>

</dd>
<dt>(3) OUTPUT FILES : </dt><dd>
<p>Functions that can be used to produce output files.
</p>
<p>Some data structures can be stored in txt/csv files :
</p>

<ul>
<li> <p><code><a href="#topic+write.scores">write.scores</a></code>: Using the result of a correlation/covariation method, creates a file containing the score of each pair of positions (sequence alignment analysis) or of side chain dihedral angles (molecular simulations) and optionaly their entropy/dynamic_entropy score.
</p>
</li>
<li> <p><code><a href="#topic+top_pairs_analysis">top_pairs_analysis</a></code>: Using the result of a correlation/covariation method and an integer N, creates two files containing (1) the top N pairs with their scores and (2) the individual elements, their contact counts and their entropy score for the top N pairs. Subsequently, these files can be  used for network visualization with the Cytoscape program accessible at <em>https://cytoscape.org</em>. 
</p>
</li>
<li> <p><code><a href="#topic+write.pca">write.pca</a></code>: Using the result of the <code><a href="#topic+centered_pca">centered_pca</a></code> function, creates a file that contains the coordinates of each element in the principal component space.
</p>
</li>
<li> <p><code><a href="#topic+write.pca.pdb">write.pca.pdb</a></code>: Using the result of the <code><a href="#topic+centered_pca">centered_pca</a></code> function, creates a pdb file with the PCA coordinates on three principal components along with a pml file for nice visualization with the Pymol molecular visualization program accessible at <em>https://pymol.org</em>.
</p>
</li></ul>

<p>Some data can be visualized in png/pdf files:
</p>

<ul>
<li> <p><code><a href="#topic+scores.boxplot">scores.boxplot</a></code>: Using the result of one or several correlation/covariation methods, creates a boxplot to visualize the distribution of the Z-scores.
</p>
</li>
<li> <p><code><a href="#topic+network.plot">network.plot</a></code>: Using the result of the <code><a href="#topic+top_pairs_analysis">top_pairs_analysis</a></code> function, creates the graph of a network representation of the data.
</p>
</li>
<li> <p><code><a href="#topic+scores_entropy.plot">scores_entropy.plot</a></code>: Using the result of a correlation/covariation method and an entropy structure, creates a graph comparing correlation/covariation scores with entropy values. Each pair of elements (i,j) is placed in the graph with (entropy[i] ; entropy[j]) as coordinates. The color code of each point is based on its correlation/covariation score (red/pink color for top values, blue/skyblue for bottom values).
</p>
</li>
<li> <p><code><a href="#topic+pca_screeplot">pca_screeplot</a></code>: Using the result of the <code><a href="#topic+centered_pca">centered_pca</a></code> function, creates the graph of the eigen values (positive values only).
</p>
</li>
<li> <p><code><a href="#topic+pca_2d">pca_2d</a></code>: Using the result of the <code><a href="#topic+centered_pca">centered_pca</a></code> function, creates a graph with the projection of the elements on two selected components.
</p>
</li>
<li> <p><code><a href="#topic+angles.plot">angles.plot</a></code>: Using pdb and dcd files and the result of a correlation/covariation method, creates graphs to monitor the time evolution of each dihedral angle in the top N pairs
</p>
</li></ul>

</dd>
</dl>



<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> BioCor</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
  Date: </td><td style="text-align: left;"> 2020-01-30</td>
</tr>
<tr>
 <td style="text-align: left;">
  License: </td><td style="text-align: left;"> GPL </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Bruck TADDESE [aut], Antoine Garnier [aut], Madeline DENIAUD [aut], Lea BELLANGER [ctb], Julien PELE[ctb], Jean-Michel BECU [ctb], Marie CHABBERT [cre].
Maintainer: Marie CHABBERT &lt;marie.chabbert@univ-angers.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;- getwd()
  file &lt;- file.path(wd,"test_seq1") 

  #Importing multiple sequence alignment
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating correlation object with OMES method
  omes &lt;- omes(align, gap_ratio = 0.2)

  #Creating entropy object
  entropy &lt;- entropy(align, gap_ratio = 0.2)

  #Creating delta filter based on entropy
  filter &lt;- delta_filter(entropy, Smin = 0.3, Smax = 0.8)
  
  #Selecting a correlation matrix
  omes &lt;-omes$score

  # Creating PCA object for selected correlation matrix and storing eigen values in csv file
  pca &lt;- centered_pca(omes, filepathroot= file, pc= NULL, dec_val= 5, filter= filter)
  
  
</code></pre>

<hr>
<h2 id='angle2rotamer'>
Converts dihedral angles to rotamers
</h2><span id='topic+angle2rotamer'></span>

<h3>Description</h3>

<p>Given an object of class 'structure' and an angle to rotamer conversion file, associates a rotamer to each dihedral angle value.
The object of class 'structure' contains dihedral angle values for each side chain dihedral angle and each frame of the trajectory.
The conversion file is a reference file that contains the rotamer to be associated with a dihedral angle value, depending on the residue type and the dihedral angle considered. This function will allow to compute correlation/covariation scores between rotameric states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  angle2rotamer(dynamic_structure, 
    conversion_file=system.file("rotamer/dynameomics_rotamers.csv", package= "Bios2cor"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle2rotamer_+3A_dynamic_structure">dynamic_structure</code></td>
<td>

<p>Dihedral angle structure, result of the <code>dynamic_structure</code> function
</p>
</td></tr>
<tr><td><code id="angle2rotamer_+3A_conversion_file">conversion_file</code></td>
<td>

<p>The file containing the rotamer to be associated with each residue dihedral angle depending of the dihedral angle value.
</p>
<p>Each line contains five fields, separated by ','. The five fields represent the amino acid name (&quot;R&quot;, &quot;N&quot;,...), the dihedral angle name(&quot;chi1&quot;, &quot;chi2&quot;,...), the associated rotamer (&quot;g+&quot;, &quot;t&quot;, &quot;g-&quot;), the start and stop angles (between -180 and 180). For example, for the <em>chi1</em> angle of the valine residue, a torsion angle between 0 and 120 is associated to rotameric state <em>g+</em>.
</p>
<p>Default is the &quot;rotamer/dynameomics_rotamers.csv&quot; conversion file provided with the Bios2cor package from the dynameomics database (<code>http://dynameomics.org</code>) .
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the torsion object and in the conversion file, dihedral angle values vary between -180 and 180.
</p>


<h3>Value</h3>

<p>A character matrix containing the rotameric state of each side chain dihedral angle for each frame in the trajectory, depending on the dihedral angle value and on a conversion file.
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER and Lea BELLENGER
</p>


<h3>References</h3>

<p>Van der Kamp MW, Schaeffer RD, Jonsson AL, Scouras AD, Simms AM, Toofanny RD, Benson NC, Anderson PC, Merkley ED, Rysavy S, Bromley D, Beck DAC, and Daggett V. Dynameomics: A comprehensive database of protein dynamics. Structure, 18: 423-435, 2010. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Reading pdb and dcd files
  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")
 
  #Reading conversion file 
  #conversion_file &lt;- system.file("rotamer/dynameomics_rotamers.csv", package= "Bios2cor")

  #Creating dynamic_structure object
  wanted_frames &lt;- seq(from = 1, to = 40, by = 2)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)
  
  #Creating rotamers object with default conversion_file
  rotamers &lt;- angle2rotamer(dynamic_structure)
  
  #Creating rotamers object with conversion_file   
  #rotamers &lt;- angle2rotamer(dynamic_structure, conversion_file)
 
</code></pre>

<hr>
<h2 id='angles.plot'>
plots the time evolution of the dihedral angles in top pairs
</h2><span id='topic+angles.plot'></span>

<h3>Description</h3>

<p>Given an object of class 'structure' and names of dihedral angles, creates plots of the dihedral angles as a function of frames in a pdf file. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  angles.plot(dynamic_structure, angles, filepathroot=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angles.plot_+3A_dynamic_structure">dynamic_structure</code></td>
<td>

<p>Dihedral angle structure, result of the <code>dynamic_structure</code> function
</p>
</td></tr>
<tr><td><code id="angles.plot_+3A_angles">angles</code></td>
<td>

<p>A vector containing the names of the dihedral angles to be visualized.Default is NULL (all the torsional angles of the dynamic_structure object are taken into account). 
</p>
</td></tr>
<tr><td><code id="angles.plot_+3A_filepathroot">filepathroot</code></td>
<td>

<p>Root of the full path name for the output file. Default is NULL. In this case, the output file is named &quot;ANGLES.pdf&quot;. When filepathroot is not NULL, a &quot;_ANGLES.pdf&quot; extention is added to the filepathroot name.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object of class 'structure' contains the side chain dihedral angles (between -180 and 180) for each residue in the protein, for each frame of the molecular simulations. This function allows visualisation of the evolution of selected angles. 
</p>


<h3>Value</h3>

<p>returns a pdf file containing the plots of the frame dependance of each element included in argument <code>angles</code>.
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER and Marie CHABBERT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #Indicating file path for output files
  wd &lt;- tempdir()
  #wd &lt;- getwd()
  file &lt;- file.path(wd,"test_dyn1") 

  #Reading pdb and dcd files
  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")
  
  #Creating dynamic_structure object for wanted frames
  wanted_frames &lt;- seq(from= 1, to= 40, by= 2)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)

  #Calculating circular correlation between dihedral angles of selected residues 
  wanted_residues &lt;- c("H","N","Q","F","Y","W")
  dihed_corr &lt;- dynamic_circular(dynamic_structure, wanted_residues)

  #Selecting a correlation matrix
  dihed_corr &lt;- dihed_corr$Zscore
  
  #Selecting angles of interest (here from the "top_pairs_analysis" function)
  top_angles &lt;- top_pairs_analysis(dihed_corr, top= 25, file)
  my_angles &lt;- unlist(top_angles$positions)
  
  #Creating plots of the time evolution of the dihedral angles 
  evol_angles &lt;- angles.plot(dynamic_structure, my_angles, file)

</code></pre>

<hr>
<h2 id='centered_pca'>
Performs principal component analysis of a correlation/covariation matrix 
</h2><span id='topic+centered_pca'></span>

<h3>Description</h3>

<p>Given a correlation/covariation matrix, performs the principal component analysis of the centered matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  centered_pca(corr_matrix, filepathroot= NULL, filter = NULL, pc= NULL, dec_val= 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centered_pca_+3A_corr_matrix">corr_matrix</code></td>
<td>

<p>A score or Zscore matrix created by a correlation/covariation function (<code><a href="#topic+omes">omes</a></code>, <code><a href="#topic+mip">mip</a></code>, <code><a href="#topic+elsc">elsc</a></code>, <code><a href="#topic+mcbasc">mcbasc</a></code>, <code><a href="#topic+dynamic_circular">dynamic_circular</a></code>, <code><a href="#topic+dynamic_omes">dynamic_omes</a></code>, <code><a href="#topic+dynamic_mip">dynamic_mip</a></code>)
</p>
</td></tr>
<tr><td><code id="centered_pca_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root of the full path name for the csv and png files where eigen values are stored or displayed. Default is NULL (Two &quot;EIGEN.csv&quot; and &quot;EIGEN.png&quot; files are created). If not NULL, the extensions &quot;_EIGEN.csv&quot; and &quot;_EIGEN.png&quot; are added to the filepathroot. 
</p>
</td></tr>
<tr><td><code id="centered_pca_+3A_filter">filter</code></td>
<td>

<p>A filter calculated by the <code><a href="#topic+delta_filter">delta_filter</a></code> function to limit the analysis to elements within a given entropy/dynamic_entropy range. DEFAULT is NULL (no filter is applied and each element has the same weight equal to the inverse of the number of elements).
</p>
</td></tr>
<tr><td><code id="centered_pca_+3A_pc">pc</code></td>
<td>

<p>A numeric value indicating the number of principal components to be saved. Default is NULL (all the principal components are saved).
</p>
</td></tr>
<tr><td><code id="centered_pca_+3A_dec_val">dec_val</code></td>
<td>

<p>A numeric value corresponding to the precision when the <em>round</em> function is used. Default is 5.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a principal component analysis of a correlation/covariation matrix after double centering. It is based on the matrix centering algorithm of the <code>mmds.R</code> function from the <code>Bios2mds</code> package. The elements have the same weight except when a delta filter is indicated. In this latter case, only the elements allowed by the delta filter are taken into account.
</p>


<h3>Value</h3>

<p>returns an object of class 'pca' which is a named list of four elements: 
</p>
<table>
<tr><td><code>eigen</code></td>
<td>

<p>a numeric vector of the eigenvalues
</p>
</td></tr>
<tr><td><code>eigen.perc</code></td>
<td>

<p>a numeric vector of the relative eigenvalues (eigenvalues divided by the sum of the absolute eigenvalues)
</p>
</td></tr>
<tr><td><code>coord</code></td>
<td>

<p>a numeric matrix representing the coordinates of each element of the correlation/covariation matrix in the PCA space
</p>
</td></tr>
<tr><td><code>source</code></td>
<td>

<p>a named list with 2 elements, the correlation/covariation matrix (<code>cor</code>) and the delta filter vector (<code>filter</code>) to limit the analysis to elements within a given entropy range.
</p>
</td></tr>
</table>
<p>returns also two files: a csv file containing eigen values and a png file displaying eigen values.
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER and Marie CHABBERT 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;- getwd()
  file &lt;- file.path(wd,"test_seq_pca") 

  #Importing multiple sequence alignment
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating correlation object with OMES method
  omes &lt;- omes(align, gap_ratio= 0.2)

  #Creating entropy object
  entropy &lt;- entropy(align, gap_ratio=0.2)

  #Creating delta filter based on entropy
  filter &lt;- delta_filter(entropy, Smin = 0.2, Smax = 0.6)
  
  #Selecting a correlation/covariation matrix
  matrix_omes &lt;-omes$score

  #Creating PCA object for selected matrix and storing eigen values in csv file
  pca &lt;- centered_pca(matrix_omes, filepathroot= file, filter = filter)

</code></pre>

<hr>
<h2 id='delta_filter'>
Creation of an entropy/dynamic score delta filter for each element
</h2><span id='topic+delta_filter'></span>

<h3>Description</h3>

<p>Given an entropy object (result of the <code><a href="#topic+entropy">entropy</a></code> or of the <code><a href="#topic+dynamic_entropy">dynamic_entropy</a></code> function), creates a vector with a delta filter of each element based on the entropy value. The vector will be used to limit the analysis to the elements in the given entropy range in the <code><a href="#topic+centered_pca">centered_pca</a></code> and <code><a href="#topic+top_pairs_analysis">top_pairs_analysis</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  delta_filter(entropy, Smin = 0, Smax = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_filter_+3A_entropy">entropy</code></td>
<td>

<p>An object created by the <code><a href="#topic+entropy">entropy</a></code> or the <code><a href="#topic+dynamic_entropy">dynamic_entropy</a></code>function
</p>
</td></tr>
<tr><td><code id="delta_filter_+3A_smin">Smin</code></td>
<td>

<p>A value indicating the minimum entropy value. (Smin = 0 by default)
</p>
</td></tr>
<tr><td><code id="delta_filter_+3A_smax">Smax</code></td>
<td>

<p>A value indicating the maximum entropy value. (Smax = 1 by default)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object returned by the <code><a href="#topic+entropy">entropy</a></code> or the <code><a href="#topic+dynamic_entropy">dynamic_entropy</a></code> function contains an entropy score for each element.
The delta weighting of each element is calculated as follow :
</p>
<p style="text-align: center;"><code class="reqn"> weighting[i] = \left\{ \begin{array}{ll}  1, &amp; Smin &lt; entropy[i] &lt; Smax \\  0, &amp; otherwise \end{array}  \right. </code>
</p>



<h3>Value</h3>

<p>A vector that contains a 0 or 1 weighting score for each element (position in sequence alignment or side chain dihedral angle in trajectory) to limit principal component and top pair analysis to elements within a given entropy range.
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Importing MSA
  align &lt;- import.msf(system.file("msa/toy_align.msf", package = "Bios2cor"))

  #Creating entropy object
  entropy &lt;- entropy(align)
  
  #Creating delta filter based on entropy
  filter &lt;- delta_filter(entropy, Smin = 0.4, Smax = 0.6)
  
</code></pre>

<hr>
<h2 id='dynamic_circular'>
Circular correlation
</h2><span id='topic+dynamic_circular'></span>

<h3>Description</h3>

<p>Calculates circular correlation/covariation scores between side chain dihedral angles during a molecular dynamics trajectory. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dynamic_circular(
    dynamic_structure,
    res_selection=
      c("C","I","L","M","V","R","H","K","D","E","N","Q","F","Y","W","T","S","P")
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamic_circular_+3A_dynamic_structure">dynamic_structure</code></td>
<td>

<p>Object of class 'structure' that is created by the <code><a href="#topic+dynamic_structure">dynamic_structure</a></code> function
</p>
</td></tr>
<tr><td><code id="dynamic_circular_+3A_res_selection">res_selection</code></td>
<td>

<p>List of amino acids that will be taken into account in the correlation/covariation matrix. By default, all the amino acids are taken into account except Gly and Ala, with no side chain dihedral angles.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code>cor.circular</code> function from the <code>circular</code> package based on a circular version of the Pearson coeefficient. 
</p>


<h3>Value</h3>

<p>returns a list of four elements which are numeric matrices containing (1) the correlation/covariation scores for each pair of rotamers (score), (2) the Z-scores for each pair of rotamers (Zscore), (3) the correlation/covariation scores for each pair of rotamers with zero values for autocorrelation (correlation within the same side chain) (score_noauto) and (4) the Z-scores calculated without autocorrelation pairs and zero values for autocorrelation pairs (Zscore_noauto). 
</p>


<h3>Author(s)</h3>

<p>Bruck TADESSE, Antoine GARNIER, and Marie CHABBERT 
</p>


<h3>References</h3>

<p>Circular Statistics, from &ldquo;Topics in circular Statistics&rdquo; (2001) S. Rao Jammalamadaka and A. SenGupta, World Scientific.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Reading pdb and dcd files
  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")

  #Creating dynamic_structure object for selected frames
  wanted_frames &lt;- seq(from = 1, to = 40, by = 2)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)

  #Computing circular correlation between dihedral angles of selected residues
  res_selection &lt;- c("H","N","Q","F","Y","W")    
  dihed_corr &lt;- dynamic_circular(dynamic_structure, res_selection)

  #Computing correlation between all dihedral angles 
  #dihed_corr &lt;- dynamic_circular(dynamic_structure)

</code></pre>

<hr>
<h2 id='dynamic_entropy'>
Variability score
</h2><span id='topic+dynamic_entropy'></span>

<h3>Description</h3>

<p>Measures a &quot;dynamic entropy&quot; or variability score of each dihedral angle based on the number of rotameric changes during the molecular dynamics trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dynamic_entropy(rotamers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamic_entropy_+3A_rotamers">rotamers</code></td>
<td>

<p>A character matrix of type 'rotamers' that is produced by the <code>angle2rotamer</code> function. 
The matrix indicates the rotameric state of each side chain dihedral angle for each frame of the trajectory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;dynamic entropy&quot; score S is computed by summing the number of rotameric changes over all frames, normalized to the number of frames. It is not a &quot;true entropy&quot; score but gives usefull information on variability of the dihedral angle during the MD simulation.
</p>


<h3>Value</h3>

<p>A numeric vector containing a &quot;dynamic entropy&quot; score for each side chain dihedral angle during the trajectory. The score is comprised between 0 (no change in the rotameric state during the trajectory) and 1 (rotameric change for every frame of the trajectory).   
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER, Lea BELLENGER and Marie CHABBERT 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Reading pdb and dcd files
  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")
 
  #Reading conversion file
  conversion_file &lt;- system.file("rotamer/dynameomics_rotamers.csv", package= "Bios2cor")

  #Creating the dynamic_structure and rotamers objects
  wanted_frames &lt;- seq(from = 1, t = 40, by = 5)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)
  rotamers &lt;- angle2rotamer(dynamic_structure, conversion_file)
 
  #creating the dynamic_entropy object
  dynamic_entropy &lt;- dynamic_entropy(rotamers)
</code></pre>

<hr>
<h2 id='dynamic_mi'>
Mutual Information (MI) function applied to rotamers in molecular dynamics simulations
</h2><span id='topic+dynamic_mi'></span>

<h3>Description</h3>

<p>Calculates a mutual information score (MI) based on the probability of joint occurrence of events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dynamic_mi(
    dynamic_structure,
    rotamers,
    res_selection=
      c("C","I","L","M","V","R","H","K","D","E","N","Q","F","Y","W","T","S","P")
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamic_mi_+3A_dynamic_structure">dynamic_structure</code></td>
<td>

<p>An object of class 'structure' that is created by the <code><a href="#topic+dynamic_structure">dynamic_structure</a></code> function
</p>
</td></tr>
<tr><td><code id="dynamic_mi_+3A_rotamers">rotamers</code></td>
<td>

<p>A character matrix of type 'rotamers' that is produced by the <code><a href="#topic+angle2rotamer">angle2rotamer</a></code> function. 
The matrix indicates the rotameric state of each side chain dihedral angle for each frame of the trajectory.
</p>
</td></tr>
<tr><td><code id="dynamic_mi_+3A_res_selection">res_selection</code></td>
<td>

<p>List of amino acids that will be taken into account in the correlation/covariation matrix. By default, all the amino acids are taken into account except Gly and Ala, with no side chain dihedral angles.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MI score at position [i,j] has been computed with the following formula :
</p>

<ul>
<li> <p><em><code class="reqn">{MI(i,j) = \sum_{x,y}^{ } p_{x,y}(i,j) ln\frac{p_{x,y}(i,j)}{p_{x}(i)p_{y}(j)}}</code></em> 
</p>
</li></ul>

<p>where <em><code class="reqn">p_{x,y}(i,j)</code></em> is the frequency of the rotamer pair (x,y) at dihedral angles i and j.
</p>


<h3>Value</h3>

<p>returns a list of four elements which are numeric matrices containing (1) the correlation/covariation scores for each pair of rotamers (score), (2) the Z-scores for each pair of rotamers (Zscore), (3) the correlation/covariation scores for each pair of rotamers with zero values for autocorrelation (correlation within the same side chain) (score_noauto) and (4) the Z-scores calculated without autocorrelation pairs and zero values for autocorrelation pairs (Zscore_noauto). 
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER and Marie CHABBERT
</p>


<h3>References</h3>

<p>Dunn SD, Wahl LM, Gloor GB. Mutual information without the influence of phylogeny or entropy dramatically improves residue contact prediction. Bioinfor;atics 2008;24:333-340.
Martin LC, Gloor GB, Dunn SD, Wahl LM. Using infor;ation theory to search for co-evolving residues in proteins. Bioinformatics 2005;21:4116-4124.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Reading pdb and dcd files
  pdb &lt;- system.file("rotamer/tiny_toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/tiny_toy_dynamics.dcd", package= "Bios2cor")

  #Creating dynamic_structure object
  wanted_frames &lt;- seq(from = 5, to = 40, by = 15)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)

  #Creating rotamers object using conversion_file
  conversion_file &lt;- system.file("rotamer/dynameomics_rotamers.csv", package= "Bios2cor")
  rotamers &lt;- angle2rotamer(dynamic_structure, conversion_file)

  #Creating correlation object for selected residues using MI method
  wanted_residues &lt;- c("H","N")
  mi_corr &lt;- dynamic_mi(dynamic_structure, rotamers, wanted_residues)
</code></pre>

<hr>
<h2 id='dynamic_mip'>
Mutual Information Product (MIP) function applied to rotamers in molecular dynamics simulations
</h2><span id='topic+dynamic_mip'></span>

<h3>Description</h3>

<p>Calculates a corrected mutual information score (MIP), by substraction of the average product from the probability of joint occurrence of events. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dynamic_mip(
    dynamic_structure,
    rotamers,
    res_selection=
      c("C","I","L","M","V","R","H","K","D","E","N","Q","F","Y","W","T","S","P")
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamic_mip_+3A_dynamic_structure">dynamic_structure</code></td>
<td>

<p>An object of class 'structure' that is created by the <code><a href="#topic+dynamic_structure">dynamic_structure</a></code> function
</p>
</td></tr>
<tr><td><code id="dynamic_mip_+3A_rotamers">rotamers</code></td>
<td>

<p>A character matrix of type 'rotamers' that is produced by the <code><a href="#topic+angle2rotamer">angle2rotamer</a></code> function. 
The matrix indicates the rotameric state of each side chain dihedral angle for each frame of the trajectory.
</p>
</td></tr>
<tr><td><code id="dynamic_mip_+3A_res_selection">res_selection</code></td>
<td>

<p>List of amino acids that will be taken into account in the correlation/covariation matrix. By default, all the amino acids are taken into account except Gly and Ala, with no side chain dihedral angles.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MIP score at position [i,j] has been computed with the following formula :
</p>
<p style="text-align: center;"><code class="reqn">{MIP(i,j)} = MI(i,j) - \frac{MI(i,\bar{j})MI(\bar{i},j)}{&lt;MI&gt;}</code>
</p>

<p>with :
</p>

<ul>
<li> <p><em><code class="reqn">{MI(i,j) = \sum_{x,y}^{ } p_{x,y}(i,j) ln\frac{p_{x,y}(i,j)}{p_{x}(i)p_{y}(j)}}</code></em> 
</p>
</li>
<li> <p><em><code class="reqn">MI(i,\bar{j}) = \frac{1}{n-1} \sum_{j \neq i}^{ } MI(i,j)</code></em> 
</p>
</li>
<li> <p><em><code class="reqn">MI(\bar{i},j) = \frac{1}{n-1} \sum_{i \neq j}^{ } MI(i,j)</code></em> 
</p>
</li>
<li> <p><em><code class="reqn">&lt;MI&gt; = \frac{2}{n(n-1)} \sum_{i,j}^{ }MI(i,j)</code></em> 
</p>
</li></ul>

<p>and where <em><code class="reqn">p_{x,y}(i,j)</code></em> is the frequency of the rotamer pair (x,y) at dihedral angles i and j.
</p>


<h3>Value</h3>

<p>returns a list of four elements which are numeric matrices containing (1) the correlation/covariation scores for each pair of rotamers (score), (2) the Z-scores for each pair of rotamers (Zscore), (3) the correlation/covariation scores for each pair of rotamers with zero values for autocorrelation (correlation within the same side chain) (score_noauto) and (4) the Z-scores calculated without autocorrelation pairs and zero values for autocorrelation pairs (Zscore_noauto). 
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER and Marie CHABBERT
</p>


<h3>References</h3>

<p>Dunn SD, Wahl LM, Gloor GB. Mutual information without the influence of phylogeny or entropy dramatically improves residue contact prediction. Bioinfor;atics 2008;24:333-340.
Martin LC, Gloor GB, Dunn SD, Wahl LM. Using infor;ation theory to search for co-evolving residues in proteins. Bioinformatics 2005;21:4116-4124.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Reading pdb and dcd files
  pdb &lt;- system.file("rotamer/tiny_toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/tiny_toy_dynamics.dcd", package= "Bios2cor")

  #Creating dynamic_structure object
  wanted_frames &lt;- seq(from = 5, to = 40, by = 15)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)

  #Creating rotamers object using conversion_file
  conversion_file &lt;- system.file("rotamer/dynameomics_rotamers.csv", package= "Bios2cor")
  rotamers &lt;- angle2rotamer(dynamic_structure, conversion_file)

  #Creating correlation object for selected residues with MIP method
  wanted_residues &lt;- c("H","N")
  mip_corr &lt;- dynamic_mip(dynamic_structure, rotamers, wanted_residues)
</code></pre>

<hr>
<h2 id='dynamic_omes'>
OMES (Observed minus Expected Squared) function applied to rotamers in molecular dynamics simulations
</h2><span id='topic+dynamic_omes'></span>

<h3>Description</h3>

<p>Calculates difference between observed and expected occurrences of each possible pair of rotamers (x, y) for i and j dihedral angles over all frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dynamic_omes(
    dynamic_structure,
    rotamers,
    res_selection= 
      c("C","I","L","M","V","R","H","K","D","E","N","Q","F","Y","W","T","S","P")
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamic_omes_+3A_dynamic_structure">dynamic_structure</code></td>
<td>

<p>An object of class 'structure' that is created by the <code><a href="#topic+dynamic_structure">dynamic_structure</a></code> function
</p>
</td></tr>
<tr><td><code id="dynamic_omes_+3A_rotamers">rotamers</code></td>
<td>

<p>A character matrix that is produced by the <a href="#topic+angle2rotamer">angle2rotamer</a> function. The matrix indicates the rotameric state of each side chain dihedral angle for each frame of the trajectory.
</p>
</td></tr>
<tr><td><code id="dynamic_omes_+3A_res_selection">res_selection</code></td>
<td>

<p>List of amino acids that will be taken into account in the correlation/covariation matrix. By default, all the amino acids are taken into account except Gly and Ala, with no side chain dihedral angles.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The OMES score for angles [i,j] has been computed with the following formula :
</p>
<p style="text-align: center;"><code class="reqn">{OMES(i,j)} = \frac{1}{N} \sum_{x,y}^{ }(N_{x,y}^{obs}(i,j)-N_{x,y}^{ex}(i,j))^2</code>
</p>

<p>with : <em><code class="reqn">N_{x,y}^{ex}(i,j) = p_{x}(i)p_{y}(j)N</code></em>
</p>
<p>where :
</p>

<ul>
<li> <p><em><code class="reqn">N_{x,y}^{obs}(i,j)</code></em> is number of times that each (x,y) rotamer pair is observed at angles i and j
</p>
</li>
<li> <p><em><code class="reqn">N_{x,y}^{ex}(i,j)</code></em> is number of times that each (x,y) rotamer pair would be expected, based on the frequency of rotamer x and y at angles i and j
</p>
</li>
<li> <p><em><code class="reqn">N</code></em> is the number of frames
</p>
</li>
<li> <p><em><code class="reqn">p_{x}(i)</code></em> is the frequency of rotamer x at angle i
</p>
</li>
<li> <p><em><code class="reqn">p_{y}(j)</code></em> is the frequency of rotamer y at angle j
</p>
</li></ul>



<h3>Value</h3>

<p>returns a list of four elements which are numeric matrices containing (1) the correlation/covariation scores for each pair of rotamers (score), (2) the Z-scores for each pair of rotamers (Zscore), (3) the correlation/covariation scores for each pair of rotamers with zero values for autocorrelation (correlation within the same side chain) (score_noauto) and (4) the Z-scores calculated without autocorrelation pairs and zero values for autocorrelation pairs (Zscore_noauto). 
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER, Lea BELLENGER, and Marie CHABBERT 
</p>


<h3>References</h3>

<p>Fodor AA and Aldrich RW. Influence of conservation on calculations of amino acid covariance in multiple sequence alignments. Proteins. 2004;56(2):211-21.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Reading pdb and dcd files
  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")

  #Creating dynamic_structure object
  wanted_frames &lt;- seq(from = 5, to = 40, by = 10)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)

  #Creating rotamers object using conversion_file
  conversion_file &lt;- system.file("rotamer/dynameomics_rotamers.csv", package= "Bios2cor")
  rotamers &lt;- angle2rotamer(dynamic_structure, conversion_file)

  #Creating correlation object for selected residues with OMES method
  wanted_residues &lt;- c("W")
  omes_corr &lt;- dynamic_omes(dynamic_structure, rotamers, wanted_residues)
</code></pre>

<hr>
<h2 id='dynamic_structure'>
Creates the data structure for the analysis of side chain dihedral angles   
</h2><span id='topic+dynamic_structure'></span>

<h3>Description</h3>

<p>Given a structure pdb file, a trajectory dcd file and frame indices, gathers information on side chain dihedral angles in a unique structure. This structure will be used in correlation/covariation methods aimed at analyzing side chain rotational motions during molecular dynamics simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dynamic_structure(pdb, trj, frames=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamic_structure_+3A_pdb">pdb</code></td>
<td>

<p>Filepath of the  pdb file
</p>
</td></tr>
<tr><td><code id="dynamic_structure_+3A_trj">trj</code></td>
<td>

<p>Filepath of trajectory file (dcd file)
</p>
</td></tr>
<tr><td><code id="dynamic_structure_+3A_frames">frames</code></td>
<td>

<p>Indicates the selected frames for the analysis, created with the <code>seq</code> function (Usage: frames &lt;-seq(from ,to , by= ). Default is NULL (all the frames of the trajectory are taken into account).  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class 'structure' with the following elements containing information on the sequence, structure, trajectory and side chain dihedral angles (values and names) of the protein during the simulation:
</p>
<table>
<tr><td><code>pdb</code></td>
<td>

<p>an object of class 'pdb' created by the <code>read.pdb</code>function from the <code>bio3d</code> package
</p>
</td></tr>
<tr><td><code>dcd</code></td>
<td>

<p>A numeric matrix of xyz coordinates with a frame per row and a Cartesian coordinate per column. Created by the <code>read.dcd</code>function from the <code>bio3d</code> package  
</p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>

<p>A numeric matrix of xyz coordinates with a frame per row and a Cartesian coordinate per column. For each frame, the protein coordinates have been fitted on the pdb structure using the <code>fit.xyz</code> from the <code>bio3d</code> package  
</p>
</td></tr>
<tr><td><code>tor</code></td>
<td>

<p>A numeric matrix of side chain dihedral angles with a frame per row and a dihedral angle per column. Contains only side chain dihedral angles. Created by the <code>xyz2tor</code> function from the <code>bio3d</code> package  
</p>
</td></tr>
<tr><td><code>tor.names</code></td>
<td>

<p>a character vector with the names of all side chain chi dihedral angles. They are written as &quot;M.chiN&quot; where M is the residue number and N the dihedral angle chi (chi1, chi2,...). Alanine and Glycine residues which do not have side chain dihedral angles are omitted. 
</p>
</td></tr>
<tr><td><code>tor.resno</code></td>
<td>

<p>a character vector with the residue number M of all side chain chi dihedral angles. 
</p>
</td></tr>
<tr><td><code>tor.angle</code></td>
<td>

<p>a character vector with the dihedral angle (chiN) of all side chain chi dihedral angles. 
</p>
</td></tr>
<tr><td><code>nb_torsions</code></td>
<td>

<p>a numeric value indicating the total number of dihedral angles 
</p>
</td></tr>
<tr><td><code>prot.seq</code></td>
<td>

<p>a character vector with the sequence of the protein 
</p>
</td></tr>
<tr><td><code>nb_residues</code></td>
<td>

<p>a numeric value indicating the number of residues in the protein
</p>
</td></tr>
<tr><td><code>nb_frames</code></td>
<td>

<p>a numeric value indicating the total number of selected frames 
</p>
</td></tr>
<tr><td><code>frames</code></td>
<td>

<p>a numeric vector indicating the selected frames 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bruck TADDESE, Antoine GARNIER and Marie CHABBERT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Reading pdb and dcd files
  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")
  
  #Creating dynamic_structure object for selected frames  
  wanted_frames &lt;- seq(from = 1, to = 40, by = 2)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)

  #Creating dynamic_structure object for all the frames  
  #dynamic_structure &lt;- dynamic_structure(pdb, trj)
</code></pre>

<hr>
<h2 id='elsc'>
Explicit Likelihood of Subset Covariation (ELSC) function
</h2><span id='topic+elsc'></span>

<h3>Description</h3>

<p>Calculates a score based on rigorous statistics of correlation/covariation in a perturbation-based algorithm. It measures how many possible subsets of size n would have the composition found in column j in the subset alignment defined by the perturbation in column i, and in the ideal subset
(i.e., in a subset with the amino acid distribution equal to the total alignment).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  elsc(align, gap_ratio = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elsc_+3A_align">align</code></td>
<td>

<p>An object of class 'align' created by the <code><a href="#topic+import.msf">import.msf</a></code> or the <code><a href="#topic+import.fasta">import.fasta</a></code> function from a sequence alignment
</p>
</td></tr>
<tr><td><code id="elsc_+3A_gap_ratio">gap_ratio</code></td>
<td>

<p>Numeric value between 0 and 1 indicating the maximal gap ratio at a given position in the MSA for this position to be taken into account. Default is 0.2, positions with more than 20 percent of gaps will not be taken into account in the analysis. When gap_ratio is 1 or close to 1, only positions with at least 1 aa are taken into account (positions with only gaps are excluded). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ELSC score at position [i,j] has been computed with the following formula :
</p>
<p style="text-align: center;"><code class="reqn">ELSC(i,j) = -ln\prod_{y}^{ } \frac{{{N_{y(j)}}\choose{n_{y(j)}}}}{{{N_{y(j)}}\choose{m_{y(j)}}}}</code>
</p>

<p>As a reminder, a binomial coefficient <code class="reqn">{N}\choose{k}</code> is computed as follow :
</p>
<p style="text-align: center;"><code class="reqn">{{N}\choose{k}} = \frac{N!}{k!(N-k)!}</code>
</p>

<p>where :
</p>

<ul>
<li> <p><code class="reqn">N_{y(j)}</code> is the number of residues y at position j in the total (unperturbed) sequence alignment
</p>
</li>
<li> <p><code class="reqn">n_{y(j)}</code> is the number of residues y at position j in the subset alignment defined by the perturbation in column i
</p>
</li>
<li> <p><code class="reqn">m_{y(j)}</code> is the number of residues y at position j in the ideal subset (i.e., in a subset with the amino acid distribution equal to the total alignment)
</p>
</li></ul>



<h3>Value</h3>

<p>A list of two elements which are numeric matrices containing the ELSC scores and Z-scores for each pair of elements. 
</p>


<h3>Author(s)</h3>

<p>Madeline DENIAUD and Marie CHABBERT
</p>


<h3>References</h3>

<p>Dekker JP, Fodor A, Aldrich RW, Yellen G. A perturbation-bqsed method for calculating explicit likelihood of evolutionary covariance in multiple sequence alignements. Bioinformatics 2004;20:1565-1572.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Importing MSA file 
  align &lt;- import.msf(system.file("msa/toy_align.msf", package = "Bios2cor"))

  #Creating correlation object with ELSC method for positions with gap ratio &lt; 0.1
  elsc &lt;- elsc(align, gap_ratio = 0.1)

  #Creating correlation object with ELSC method for positions with gap_ratio &lt; 0.2 (Default)
  #elsc &lt;- elsc(align)
</code></pre>

<hr>
<h2 id='entropy'>
Entropy score
</h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p>Measures the entropy score of each position in a sequence alignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  entropy(align, gap_ratio=0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_+3A_align">align</code></td>
<td>

<p>An object created by the <code><a href="#topic+import.msf">import.msf</a></code> or the <code><a href="#topic+import.fasta">import.fasta</a></code> function from a multiple sequence alignment file
</p>
</td></tr>
<tr><td><code id="entropy_+3A_gap_ratio">gap_ratio</code></td>
<td>

<p>Numeric value between 0 and 1 indicating the maximal gap ratio at a given position in the MSA for this position to be taken into account. 1 is excluded (positions with gaps only). Default is 0.2, positions with more than 20 percent of gaps will not be taken into account in the analysis. When gap_ratio is 1 or close to 1, only positions with at least 1 aa are taken into account (positions with only gaps are excluded). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The entropy score S at position i has been computed with a formula derived from the Shannon's entropy as follow : 
</p>
<p style="text-align: center;"><code class="reqn">{S(i)} = - \sum_{x}^{ } {p} _{x}(i) \log_{20} {p} _{x}(i)</code>
</p>

<p>where :
</p>

<ul>
<li> <p><em>i</em> is the position in the sequence
</p>
</li>
<li> <p><em>x</em> is the sequence index
</p>
</li>
<li> <p><em> <code class="reqn">{p} _{x}(i)</code>  </em> represents the frequency of residue x at position i
</p>
</li></ul>



<h3>Value</h3>

<p>A vector containing an entropy value for each position in the alignment
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER and Marie CHABBERT
</p>


<h3>References</h3>

<p>Shannon CE. A mathematical theory of communication. Bell Syst Techn J 1948;27:379-423.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Importing MSA file
  align &lt;- import.msf(system.file("msa/human_gpcr.msf", package = "Bios2cor"))

  #creating entropy object for positions with gap ratio &lt; 0.5
  entropy &lt;- entropy(align,gap_ratio=0.5)
</code></pre>

<hr>
<h2 id='import.fasta'>
Reads a file in FASTA format
</h2><span id='topic+import.fasta'></span>

<h3>Description</h3>

<p>Reads a Multiple Sequence Alignment (MSA) file in FASTA format (.fasta or .fa extension).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> import.fasta(file, aa.to.upper = TRUE, gap.to.dash = TRUE, log.file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import.fasta_+3A_file">file</code></td>
<td>

<p>a string of characters to indicate the name of the MSA file to be read.
</p>
</td></tr>
<tr><td><code id="import.fasta_+3A_aa.to.upper">aa.to.upper</code></td>
<td>

<p>a logical value indicating whether amino acids should be converted to upper case (TRUE) or not (FALSE). Default is TRUE. 
</p>
</td></tr>
<tr><td><code id="import.fasta_+3A_gap.to.dash">gap.to.dash</code></td>
<td>

<p>a logical value indicating whether the dot (.) and tilde (<code class="reqn">\sim</code>) gap symbols should be converted
to dash (-) character (TRUE) or not (FALSE). Default is TRUE.
</p>
</td></tr>
<tr><td><code id="import.fasta_+3A_log.file">log.file</code></td>
<td>

<p>a file containing errors that occurred when trying to read fasta file
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initially, FASTA (for FAST-ALL) was the input format of the FASTA program, used for protein comparison and searching in databases.
Presently, FASTA format is a standard format for biological sequences.
</p>
<p>The FASTA formatted file of a single sequence displays:
</p>

<ul>
<li><p> a single-line description beginning with a greater-than (&gt;) symbol. The following word is the identifier.
</p>
</li>
<li><p> followed by any number of lines, representing biological sequence.
</p>
</li></ul>

<p>For multiple alignments, the FASTA formatted sequences are concatenated to create a multiple
FASTA format.
</p>


<h3>Value</h3>

<p>A object of class 'align', which is a named list whose elements correspond to sequences, in the form of character vectors.
</p>


<h3>Note</h3>

<p>The <code>import.fasta</code> function was developed for the <code>bios2mds</code> R package (Julien PELE [aut], Jean-Michel BECU [aut], Marie CHABBERT [cre]).
.
</p>


<h3>Author(s)</h3>

<p>Julien PELE
</p>


<h3>References</h3>

<p>Pearson WR and Lipman DJ (1988) Improved tools for biological sequence comparison.
<em>Proc Natl Acad Sci U S A</em> <b>27</b>:2444-2448.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Importing MSA file in FASTA format
  aln &lt;- import.fasta(system.file("msa/toy2_align.fa", package = "Bios2cor"))
</code></pre>

<hr>
<h2 id='import.msf'>
Reads a multiple sequence alignment file in MSF format
</h2><span id='topic+import.msf'></span>

<h3>Description</h3>

<p>Reads a Multiple Sequence Alignment (MSA) file in MSF format (.msf extension).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.msf(file, aa.to.upper = TRUE, gap.to.dash = TRUE, log.file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import.msf_+3A_file">file</code></td>
<td>

<p>a string of characters to indicate the name of the MSA file to be read.
</p>
</td></tr>
<tr><td><code id="import.msf_+3A_aa.to.upper">aa.to.upper</code></td>
<td>

<p>a logical value indicating whether amino acids should be converted to upper case (TRUE) or not (FALSE). Default is TRUE.
</p>
</td></tr>
<tr><td><code id="import.msf_+3A_gap.to.dash">gap.to.dash</code></td>
<td>

<p>a logical value indicating whether the dot (.) and tilde (<code class="reqn">\sim</code>) gap symbols should be converted
to the dash (-) character (TRUE) or not (FALSE). Default is TRUE.
</p>
</td></tr>
<tr><td><code id="import.msf_+3A_log.file">log.file</code></td>
<td>

<p>a file containing errors that occurred when trying to read fasta file
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initially, Multiple Sequence Format (MSF) was the multiple sequence alignment format of
the Wisconsin Package (WP) or GCG (Genetic Computer Group). This package is a suite of over 130
sequence analysis programs for database searching, secondary structure prediction
or sequence alignment. Presently, numerous multiple sequence alignment editors
(Jalview and GeneDoc for example) can read and write MSF files.
</p>
<p>MSF file displays several specificities:
</p>

<ul>
<li><p> a header containing sequence identifiers and characteristics (length, check and weight).
</p>
</li>
<li><p> a separator symbolized by 2 slashes (//).
</p>
</li>
<li><p> sequences of identifiers, displayed by consecutive blocks.
</p>
</li></ul>



<h3>Value</h3>

<p>A object of class 'align', which is a named list whose elements correspond to sequences, in the form of character vectors.
</p>


<h3>Note</h3>

<p>The <code>import.msf</code> function was developed for the <code>bios2mds</code> R package (Julien PELE [aut], Jean-Michel BECU [aut], Marie CHABBERT [cre]).
</p>
<p>It checks the presence of duplicated identifiers in header. Sequences whose identifiers are missing in header are ignored.
</p>


<h3>Author(s)</h3>

<p>Julien PELE
</p>


<h3>See Also</h3>

<p><code>read.alignment</code> function from <code>seqinr</code> package.<br />
<code>read.GDoc</code> function from <code>aaMI</code> package (archived).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Importing MSA file in MSF format
  aln &lt;- import.msf(system.file("msa/toy_align.msf", package = "Bios2cor"))
</code></pre>

<hr>
<h2 id='mcbasc'>
McBASC (McLachlan Based Substitution Correlation) function
</h2><span id='topic+mcbasc'></span>

<h3>Description</h3>

<p>Calculates a score for each pair of residus in the sequenec alignment. 
It relies on a substitution matrix giving a similarity score for each pair of amino acids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mcbasc(align, gap_ratio= 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcbasc_+3A_align">align</code></td>
<td>

<p>An object of class 'align' created by the <code><a href="#topic+import.msf">import.msf</a></code> or the <code><a href="#topic+import.fasta">import.fasta</a></code> function from a sequence alignment 
</p>
</td></tr>
<tr><td><code id="mcbasc_+3A_gap_ratio">gap_ratio</code></td>
<td>

<p>Numeric value between 0 and 1 indicating the maximal gap ratio at a given position in the MSA for this position to be taken into account. Default is 0.2, positions with more than 20 percent of gaps will not be taken into account in the analysis. When gap_ratio is 1 or close to 1, only positions with at least 1 aa are taken into account (positions with only gaps are excluded). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The McBASC score at position [i,j] has been computed with a formula which was initially proposed by Valencia and coworkers(1) as follow :
</p>
<p style="text-align: center;"><code class="reqn">{McBASC(i,j)} = \frac{1}{N^2\sigma(i)\sigma(j)} \sum_{k,l}^{ } (SC_{k,l}(i)-SC(i))(SC_{k,l}(j)-SC(j))</code>
</p>

<p>where :
</p>

<ul>
<li> <p><em><code class="reqn">SC_{k,l}(i)</code></em> is the score for the amino acid pair present in sequences k and l at position i
</p>
</li>
<li> <p><em><code class="reqn">SC_{k,l}(j)</code></em> is the score for the amino acid pair present in sequences k and l at position j
</p>
</li>
<li> <p><em><code class="reqn">SC(i)</code></em> is the average of all the scores <em><code class="reqn">SC_{k,l}(i)</code></em>
</p>
</li>
<li> <p><em><code class="reqn">SC(j)</code></em> is the average of all the scores <em><code class="reqn">SC_{k,l}(j)</code></em>
</p>
</li>
<li> <p><em><code class="reqn">\sigma(i)</code></em> is the standard deviation of all the scores <em><code class="reqn">SC_{k,l}(i)</code></em>
</p>
</li>
<li> <p><em><code class="reqn">\sigma(j)</code></em> is the standard deviation of all the scores <em><code class="reqn">SC_{k,l}(j)</code></em>
</p>
</li></ul>



<h3>Value</h3>

<p>A list of two elements which are numeric matrices containing the mcbasc scores and Z-scores for each pair of elements.
</p>


<h3>Author(s)</h3>

<p>Madeline DENIAUD and Marie CHABBERT
</p>


<h3>References</h3>

<p>(1) Gobel U, Sander C, Schneider R, Valencia A. Correlated mutations and residue contacts in proteins. Proteins 1994;18:309-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Importing MSA file
  align &lt;- import.msf(system.file("msa/toy_align.msf", package = "Bios2cor"))

  #Creating correlation object with McBASC method for positions with gap_ratio &lt; 0.2 (Default)
  mcbasc &lt;- mcbasc(align, gap_ratio = 0.2)
</code></pre>

<hr>
<h2 id='mi'>
Mutual Information (MI) function
</h2><span id='topic+mi'></span>

<h3>Description</h3>

<p>Calculates a mutual information score (MI) based on the probability of joint occurrence of events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mi(align, gap_ratio= 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi_+3A_align">align</code></td>
<td>

<p>An object of class 'align' created by the <code><a href="#topic+import.msf">import.msf</a></code> or the <code><a href="#topic+import.fasta">import.fasta</a></code> function from a sequence alignment
</p>
</td></tr>
<tr><td><code id="mi_+3A_gap_ratio">gap_ratio</code></td>
<td>

<p>Numeric value between 0 and 1 indicating the maximal gap ratio at a given position in the MSA for this position to be taken into account. Default is 0.2, positions with more than 20 percent of gaps will not be taken into account in the analysis. When gap_ratio is 1 or close to 1, only positions with at least 1 aa are taken into account (positions with only gaps are excluded). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MI score at position [i,j] has been computed with the following formula :
</p>

<ul>
<li> <p><em><code class="reqn">{MI(i,j) = \sum_{x,y}^{ } p_{x,y}(i,j) ln\frac{p_{x,y}(i,j)}{p_{x}(i)p_{y}(j)}}</code></em> 
</p>
</li></ul>

<p>and where <em><code class="reqn">p_{x,y}(i,j)</code></em> is the frequency of the amino acid pair (x,y) at positions i and j.
</p>
<p>N.B. this formula has been widely applied in the field of sequence correlation/covariation but favors pairs with high entropy.
</p>


<h3>Value</h3>

<p>A list of two elements which are numeric matrices containing the MI scores and Z-scores for each pair of elements. 
</p>


<h3>Author(s)</h3>

<p>Madeline DENIAUD and Marie CHABBERT
</p>


<h3>References</h3>

<p>Dunn SD, Wahl LM, Gloor GB. Mutual information without the influence of phylogeny or entropy dramatically improves residue contact prediction. Bioinfor;atics 2008;24:333-340.
Martin LC, Gloor GB, Dunn SD, Wahl LM. Using infor;ation theory to search for co-evolving residues in proteins. Bioinformatics 2005;21:4116-4124.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Importing MSA file
  align &lt;- import.fasta(system.file("msa/toy2_align.fa", package = "Bios2cor"))

  #Creating correlation object with MI method for positions with gap ratio &lt; 0.2 (Default)
  mi &lt;- mi(align)
</code></pre>

<hr>
<h2 id='mip'>
Mutual Information product  (MIP) function
</h2><span id='topic+mip'></span>

<h3>Description</h3>

<p>Calculates a corrected mutual information score (MIP), by substraction of the average product from the probability of joint occurrence of events. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mip(align, gap_ratio = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mip_+3A_align">align</code></td>
<td>

<p>An object of class 'align' created by the <code><a href="#topic+import.msf">import.msf</a></code> or the <code><a href="#topic+import.fasta">import.fasta</a></code> function from a sequence alignment
</p>
</td></tr>
<tr><td><code id="mip_+3A_gap_ratio">gap_ratio</code></td>
<td>

<p>Numeric value between 0 and 1 indicating the maximal gap ratio at a given position in the MSA for this position to be taken into account. Default is 0.2, positions with more than 20 percent of gaps will not be taken into account in the analysis. When gap_ratio is 1 or close to 1, only positions with at least 1 aa are taken into account (positions with only gaps are excluded). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MIp score at position [i,j] has been computed with the following formula :
</p>
<p style="text-align: center;"><code class="reqn">{MIp(i,j)} = MI(i,j) - \frac{MI(i,\bar{j})MI(\bar{i},j)}{&lt;MI&gt;}</code>
</p>

<p>with :
</p>

<ul>
<li> <p><em><code class="reqn">{MI(i,j) = \sum_{x,y}^{ } p_{x,y}(i,j) ln\frac{p_{x,y}(i,j)}{p_{x}(i)p_{y}(j)}}</code></em> 
</p>
</li>
<li> <p><em><code class="reqn">MI(i,\bar{j}) = \frac{1}{n-1} \sum_{j \neq i}^{ } MI(i,j)</code></em> 
</p>
</li>
<li> <p><em><code class="reqn">MI(\bar{i},j) = \frac{1}{n-1} \sum_{i \neq j}^{ } MI(i,j)</code></em> 
</p>
</li>
<li> <p><em><code class="reqn">&lt;MI&gt; = \frac{2}{n(n-1)} \sum_{i,j}^{ }MI(i,j)</code></em> 
</p>
</li></ul>

<p>and where <em><code class="reqn">p_{x,y}(i,j)</code></em> is the frequency of the amino acid pair (x,y) at positions i and j.
</p>
<p>N.B. this formula has been widely applied in the field of sequence correlation/covariation but favors pairs with high entropy.
</p>


<h3>Value</h3>

<p>A list of two elements which are numerical matrices containing the MIP scores and Z-scores for each pair of elements. 
</p>


<h3>Author(s)</h3>

<p>Madeline DENIAUD and Marie CHABBERT
</p>


<h3>References</h3>

<p>Dunn SD, Wahl LM, Gloor GB. Mutual information without the influence of phylogeny or entropy dramatically improves residue contact prediction. Bioinfor;atics 2008;24:333-340.
Martin LC, Gloor GB, Dunn SD, Wahl LM. Using infor;ation theory to search for co-evolving residues in proteins. Bioinformatics 2005;21:4116-4124.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Importing MSA file
  align &lt;- import.fasta(system.file("msa/toy2_align.fa", package = "Bios2cor"))

  #Creating correlation object with MIP method for positions with gap ratio &lt; 0.2 (Default) 
  mip &lt;- mip(align)
</code></pre>

<hr>
<h2 id='network.plot'>
Creates network structure of top elements
</h2><span id='topic+network.plot'></span>

<h3>Description</h3>

<p>Given a top_pairs object (result of the <code><a href="#topic+top_pairs_analysis">top_pairs_analysis</a></code> function), creates a network to visualize the elements involved in the top scoring pairs and their links
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  network.plot(top_pairs, filepathroot=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.plot_+3A_top_pairs">top_pairs</code></td>
<td>

<p>An object of class 'top_pairs' created by the <code><a href="#topic+top_pairs_analysis">top_pairs_analysis</a></code> function
</p>
</td></tr>
<tr><td><code id="network.plot_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root of the full path name for the output file. Default is NULL (a &quot;NETWORK.pdf&quot; file will be created). If not NULL, the filepathroot will have the &quot;_NETWORK.pdf&quot; extension. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network representing links between elements in the top scoring pairs
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #File path for output file
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_omes") 

  #Importing MSA file
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating OMES correlation object for positions with gap ratio &lt; 0.2
  omes &lt;- omes(align, gap_ratio= 0.2)
  
  #Selecting a correlation matrix
  omes &lt;-omes$Zscore
   
  #Analyzing pairs with top scores and creating 'top_pairs' object
  top_pairs &lt;- top_pairs_analysis(omes, top = 25, file)

  #Plotting the network structure of top pairs in pdf file 
  network.plot(top_pairs, file)
</code></pre>

<hr>
<h2 id='omes'>
OMES (Observed minus Expected Squared) function
</h2><span id='topic+omes'></span>

<h3>Description</h3>

<p>Calculates the difference between the observed and expected occurrences of each possible pair of amino acids (x, y) at positions i and j of the alignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  omes(align, gap_ratio = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omes_+3A_align">align</code></td>
<td>

<p>An object of class 'align' created by the <code><a href="#topic+import.msf">import.msf</a></code> or the <code><a href="#topic+import.fasta">import.fasta</a></code> function from a sequence alignment
</p>
</td></tr>
<tr><td><code id="omes_+3A_gap_ratio">gap_ratio</code></td>
<td>

<p>Numeric value between 0 and 1 indicating the maximal gap ratio at a given position in the MSA for this position to be taken into account. Default is 0.2, positions with more than 20 percent of gaps will not be taken into account in the analysis. When gap_ratio is 1 or close to 1, only positions with at least 1 aa are taken into account (positions with only gaps are excluded). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The OMES score at position [i,j] has been computed with the following formula :
</p>
<p style="text-align: center;"><code class="reqn">{OMES(i,j)} = \frac{1}{N(i,j)} \sum_{x,y}^{ }(N_{x,y}^{obs}(i,j)-N_{x,y}^{ex}(i,j))^2</code>
</p>

<p>with : <em><code class="reqn">N_{x,y}^{ex}(i,j) = p_{x}(i)p_{y}(j)N</code></em>
</p>
<p>where :
</p>

<ul>
<li> <p><em><code class="reqn">N_{x,y}^{obs}(i,j)</code></em>is number of times that each (x,y) pair is observed at positions i and j
</p>
</li>
<li> <p><em><code class="reqn">N_{x,y}^{ex}(i,j)</code></em>is number of times that each (x,y) pair would be expected, based on the frequency of residues x and y at positions i and j
</p>
</li>
<li> <p><em><code class="reqn">N(i,j)</code></em>is the number of sequences in the alignment with non-gapped residues at positions i and j
</p>
</li>
<li> <p><em><code class="reqn">p_{x}(i)</code></em>is the frequency of amino acid x at position i
</p>
</li>
<li> <p><em><code class="reqn">p_{y}(j)</code></em>is the frequency of amino acid y at position j
</p>
</li></ul>



<h3>Value</h3>

<p>A list of two elements which are numerical matrices containing the OMES scores and Z-scores for each pair of elements. 
</p>


<h3>Author(s)</h3>

<p>Jean-Miche BECU, Madeline DENIAUD, and Marie CHABBERT
</p>


<h3>References</h3>

<p>Fodor AA and Aldrich RW. Influence of conservation on calculations of amino acid covariance in multiple
sequence alignments. Proteins. 2004;56(2):211-21.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Importing MSA file
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating correlation object with OMES method for positions with gap ratio &lt; 0.2 (Default)
  omes &lt;- omes(align, gap_ratio = 0.2)
  #omes &lt;- omes(align)
</code></pre>

<hr>
<h2 id='pca_2d'>
PCA projection on two dimensions
</h2><span id='topic+pca_2d'></span>

<h3>Description</h3>

<p>Given an object of class 'pca'  (result of the <code><a href="#topic+centered_pca">centered_pca</a></code> function), draws a graph of the projection of the elements on two dimensions (first and second components by default)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pca_2d(pca_struct, abs= 1, ord= 2, filepathroot=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_2d_+3A_pca_struct">pca_struct</code></td>
<td>

<p>An object created by the <code><a href="#topic+centered_pca">centered_pca</a></code> function
</p>
</td></tr>
<tr><td><code id="pca_2d_+3A_abs">abs</code></td>
<td>

<p>An integer which corresponds to the x axis of the projection plane. Default is 1 (first component)
</p>
</td></tr>
<tr><td><code id="pca_2d_+3A_ord">ord</code></td>
<td>

<p>An integer which corresponds to the y axis of the projection plane. Default is 2 (second component)
</p>
</td></tr>
<tr><td><code id="pca_2d_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root of the full path name for the output file. Default is NULL (a &quot;PCA_abs_ord.png&quot; file will be created). If not NULL, the filepathroot will have the &quot;_PCA_abs_ord.png&quot; extension. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2D graph of the projection of the elements on selected two principal components
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_seq2") 

  #Importing MSA file
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating OMES correlation object
  omes &lt;- omes(align, gap_ratio = 0.2)

  #Creating entropy object
  #entropy &lt;- entropy(align)

  #Selecting correlation matrix
  omes &lt;-omes$Zscore

  #Creating PCA object for selected correlation matrix and saving eigen values
  pca &lt;- centered_pca(omes, filepathroot= file, pc= NULL, dec_val= 5, filter= NULL)

  #Creating 2D plot of elements projected on selected [abs,ord] plane 
  pca_2d(pca, abs = 1, ord = 3, file)

  #Creating 2D plot of elements projected on default [1,2] plane 
  #pca_2d(pca)  
</code></pre>

<hr>
<h2 id='pca_screeplot'>
Creates PCA screeplot 
</h2><span id='topic+pca_screeplot'></span>

<h3>Description</h3>

<p>Given a PCA structure (result of the <code><a href="#topic+centered_pca">centered_pca</a></code> function), creates a screeplot of the positive eigen values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pca_screeplot(pca_struct, filepathroot=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_screeplot_+3A_pca_struct">pca_struct</code></td>
<td>

<p>An object created by the <code><a href="#topic+centered_pca">centered_pca</a></code> function
</p>
</td></tr>
<tr><td><code id="pca_screeplot_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root of the full path name for the output file. Default is NULL (a &quot;EIGEN.png&quot; file will be created). If not NULL, the filepathroot will have the &quot;_EIGEN.png&quot; extension. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A screeplot of positive eigen values 
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_seq3") 

  #Importing MSA file
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating OMES correlation object
  omes &lt;- omes(align, gap_ratio = 0.2)

  #Selecting correlation matrix
  omes &lt;-omes$Zscore

  #Creating PCA object for selected correlation matrix and saving eigen values
  pca &lt;- centered_pca(omes, filepathroot= file, pc= NULL, dec_val= 5, filter = NULL)

  #Plotting scree plot 
  pca_screeplot(pca, file)
  #pca_screeplot(pca)  
</code></pre>

<hr>
<h2 id='random.msa'>
Random Alignment
</h2><span id='topic+random.msa'></span>

<h3>Description</h3>

<p>Builds a multiple sequence alignment (MSA) of random sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.msa(nb.seq = 100, id = "SEQ", nb.pos = 100, gap = FALSE,
aa.strict = FALSE, align = NULL, align.replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.msa_+3A_nb.seq">nb.seq</code></td>
<td>

<p>a numeric value indicating the number of sequences in the random MSA. Default is 100. 
</p>
</td></tr>
<tr><td><code id="random.msa_+3A_id">id</code></td>
<td>

<p>a string of characters used to tag each sequence name. Default is &quot;SEQ&quot;. An
incremented number is attached to this tag to name each sequence.
</p>
</td></tr>
<tr><td><code id="random.msa_+3A_nb.pos">nb.pos</code></td>
<td>

<p>a numeric value indicating the length of each sequence in the random MSA. Default is 100.
</p>
</td></tr>
<tr><td><code id="random.msa_+3A_gap">gap</code></td>
<td>

<p>a logical value indicating whether the gap character should be considered as a supplementary symbol
(TRUE) or not (FALSE). Default is FALSE. 
</p>
</td></tr>
<tr><td><code id="random.msa_+3A_aa.strict">aa.strict</code></td>
<td>

<p>a logical value indicating whether only strict amino acids should be taken into account (TRUE)
or not (FALSE). Default is FALSE.
</p>
</td></tr>
<tr><td><code id="random.msa_+3A_align">align</code></td>
<td>

<p>an object of class 'align', obtained from <code><a href="#topic+import.fasta">import.fasta</a></code> or <code><a href="#topic+import.msf">import.msf</a></code> function.
If this parameter is not NULL, the composition of the output sequences is based on the composition of the input sequences. Default is NULL.
</p>
</td></tr>
<tr><td><code id="random.msa_+3A_align.replace">align.replace</code></td>
<td>

<p>a logical value indicating random drawing with replacement (TRUE) or without replacement (FALSE) of characters present in <code>align</code>. Default is FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>random.msa</code> may be used to compare a reference MSA to a random MSA. The random MSA must have the same characteristics as the reference MSA (same number of sequences of same length). 
</p>
<p>A procedure can be applied to the random MSA to assess the amount of variance due to random mutations in the reference MSA. 
</p>
<p>The <code>subset</code> function is used for random selection of the amino acids. If a truly random procedure is needed, see <code>random</code> package.
</p>


<h3>Value</h3>

<p>A named list whose objects correspond to random sequences.
</p>


<h3>Note</h3>

<p>This function has been initially developped in the <code>bios2mds</code> R package (Julien PELE [aut], Marie CHABBERT [cre]).
</p>


<h3>Author(s)</h3>

<p>Julien PELE
</p>


<h3>References</h3>

<p>For an application of random MSA see : 
</p>
<p>Pele J, Abdi H, Moreau M, Thybert D and Chabbert M (2011) Multidimensional scaling reveals the main evolutionary pathways of class A G-protein-coupled receptors. <em>PLoS ONE</em> <b>6</b>: e19094. doi:10.1371.
</p>


<h3>See Also</h3>

<p><code>permutation</code> and <code>synsequence</code> functions from <code>seqinr</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Importing MSA file
  aln &lt;- import.fasta(system.file("msa/toy2_align.fa", package = "Bios2cor"))

  #Generating a random sequence alignment with the same characterics as input file
  nb.seq &lt;- length(aln)
  nb.pos &lt;- length(aln[[1]])
  aln.random &lt;- random.msa(nb.seq = nb.seq, nb.pos = nb.pos)
</code></pre>

<hr>
<h2 id='scores_entropy.plot'>
Scores versus entropy graph
</h2><span id='topic+scores_entropy.plot'></span>

<h3>Description</h3>

<p>The aim of this graph is the visualization of the entropy values of the elements in top and bottom pairs. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  scores_entropy.plot(entropy, corr_matrix, 
    filepathroot=NULL, 
    elite=25, 
    high=275, 
    filter=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores_entropy.plot_+3A_entropy">entropy</code></td>
<td>

<p>An object created by the <code><a href="#topic+entropy">entropy</a></code> (sequence alignment) or the <code><a href="#topic+dynamic_entropy">dynamic_entropy</a></code> (trajectory) function. 
</p>
</td></tr>
<tr><td><code id="scores_entropy.plot_+3A_corr_matrix">corr_matrix</code></td>
<td>

<p>A correlation/covariation matrix created by one of the correlation/covariation functions: 
</p>
</td></tr>
<tr><td><code id="scores_entropy.plot_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root of the full path name of the graph that will be created. Default is NULL (a &quot;ei_ej.pdf&quot; file will be created). If not NULL, the filepathroot will have the &quot;_ei_ej.pdf&quot; extension. 
</p>
</td></tr>
<tr><td><code id="scores_entropy.plot_+3A_elite">elite</code></td>
<td>

<p>An integer to determine the number of pairs with the highest and lowest scores (e.g. 25: pairs ranked 1 to 25 in decreasing or increasing order) to be colored with the &quot;elite&quot; color codes. Default is 25.
</p>
</td></tr>
<tr><td><code id="scores_entropy.plot_+3A_high">high</code></td>
<td>

<p>An integer to determine the number of pairs with the next highest and lowest scores (e.g. 275: pairs ranked 26 to 275 in decreasing or increasing order) to be colored with the &quot;high&quot; color codes. Default is 275.
</p>
</td></tr>
<tr><td><code id="scores_entropy.plot_+3A_filter">filter</code></td>
<td>

<p>A vector created by the <code><a href="#topic+delta_filter">delta_filter</a></code> function, to limit the analysis to elements within a given entropy range. When filter is not NULL, only top elite and high pairs are visualized. Default is NULL. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the result of a correlation/covariation method and an entropy structure, creates a graph comparing correlation/covariation scores with entropy values. Each pair of elements (i,j) is placed in the graph with (entropy[i] ; entropy[j]) as coordinates. In the absence of filter, the color code of each point is based on its correlation/covariation score (dark and light blue for top elite and high values, red and pink for bottom elite and high values). In the presence of an entropy based filter, only top elite and high scores are visualized in dark and light blue, respectively,  
</p>


<h3>Value</h3>

<p>A graph showing the entropy values of the elements in pairs with top and bottom entropy scores 
</p>


<h3>Author(s)</h3>

<p>Julien PELE, Antoine GARNIER and Marie CHABBERT
</p>


<h3>References</h3>

<p>For an application of these graphs see : 
</p>
<p>Pele J, Abdi H, Moreau M, Thybert D and Chabbert M (2011) Multidimensional scaling reveals the main evolutionary pathways of class A G-protein-coupled receptors. <em>PLoS ONE</em> <b>6</b>: e19094. doi:10.1371.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
##Example with MSA
  #File path for output file
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_seq7") 
  
  #Importing MSA file  
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating OMES correlation object and selecting a correlation matrix
  correlation &lt;- omes(align, gap_ratio = 0.2)
  corr_matrix &lt;- correlation$Zscore 

  #Creating entropy object
  entropy &lt;- entropy(align)

  #Creating a delta filter based on entropy
  filter &lt;- delta_filter(entropy, Smin = 0.4, Smax = 0.7)
 
  #Creating the entropy graph
  scores_entropy.plot(entropy, corr_matrix, filepathroot = file, filter=filter)

##Example with MD
#  #File path for output file
#  wd &lt;- tempdir()
#  #wd &lt;-getwd() 
#  file &lt;- file.path(wd,"test_dyn7") 

#  #Reading pdb and dcd files
#  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
#  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")

#  #Creating dynamic_structure object for selected frames 
#  wanted_frames &lt;- seq(from = 1, to = 40, by = 1)
#  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)
#    
#  #Creating rotamers object using conversion_file
#  conversion_file &lt;- system.file("rotamer/dynameomics_rotamers.csv", package= "Bios2cor")
#  rotamers &lt;- angle2rotamer(dynamic_structure, conversion_file)
# 
#  #Creating the dynamic_entropy and filter objects 
#  entropy &lt;- dynamic_entropy(rotamers)
#  filter &lt;- delta_filter(entropy, Smin = 0.0, Smax = 0.1)

#  #Creating correlation object
#  #dyn_cor &lt;- dynamic_circular(dynamic_structure)
#  dyn_cor &lt;- dynamic_omes(dynamic_structure,rotamers) 

#  #selection correlation matrix
#  corr_matrix &lt;- dyn_cor$Zscore_noauto
# 
#  #Creating the entropy graph
#  scores_entropy.plot(entropy, corr_matrix, filepathroot = file, filter=filter)

</code></pre>

<hr>
<h2 id='scores.boxplot'>
Creates boxplots of correlation/covariation scores 
</h2><span id='topic+scores.boxplot'></span>

<h3>Description</h3>

<p>Given a list of correlation/covariation matrices, build boxplots for comparative purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  scores.boxplot(corr_matrix_list, name_list, filepathroot=NULL, elite=25, high=275)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores.boxplot_+3A_corr_matrix_list">corr_matrix_list</code></td>
<td>

<p>A list of correlation/covariation matrices to be compared
</p>
</td></tr>
<tr><td><code id="scores.boxplot_+3A_name_list">name_list</code></td>
<td>

<p>The names of the correlation/covariation matrices 
</p>
</td></tr>
<tr><td><code id="scores.boxplot_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root of the full path name for the output file. Default is NULL (a BOXPLOT.png file will be created). If not NULL, the &quot;_BOXPLOT.png&quot; extension is added to the filepathroot. 
</p>
</td></tr>
<tr><td><code id="scores.boxplot_+3A_elite">elite</code></td>
<td>

<p>An integer to determine the number of pairs with the highest and lowest scores (e.g. 25: pairs ranked 1 to 25 in decreasing or increasing order) to be colored with the &quot;elite&quot; color codes. Default is 25.
</p>
</td></tr>
<tr><td><code id="scores.boxplot_+3A_high">high</code></td>
<td>

<p>An integer to determine the number of pairs with the next highest and lowest scores (e.g. 275: pairs ranked 26 to 275 in decreasing or increasing order) to be colored with the &quot;high&quot; color codes. Default is 275.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation/covariation matrices contain the correlation/covariation scores for each pair of elements [i,j].
The boxplots will allow comparing these scores using color codes : the highest values are dark blue, the next highest values are light blue, the lowest values are red and the next lowest values are pink.
</p>


<h3>Value</h3>

<p>A pdf figure with boxplots to compare correlation/covariation scores
</p>


<h3>Author(s)</h3>

<p>Julien PELE and Antoine GARNIER
</p>


<h3>References</h3>

<p>For an application of these boxplots, see : 
</p>
<p>Pele J, Abdi H, Moreau M, Thybert D and Chabbert M (2011) Multidimensional scaling reveals the main evolutionary pathways of class A G-protein-coupled receptors. <em>PLoS ONE</em> <b>6</b>: e19094. doi:10.1371.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #File path for output file
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_seq") 

  #Importing MSA file
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating OMES correlation object
  omes &lt;- omes(align, gap_ratio = 0.2)

  #Creating MIP correlation object
  #mip &lt;- mip(align, gap_ratio = 0.2)

  #Selecting correlation matrices
  omes &lt;-omes$Zscore
  #mip &lt;- mip$Zscore

  #Creating a list of matrices and plotting the boxplots in a graph
  #Two matrices
  #corr_matrix_list &lt;- list(omes,mip)
  #name &lt;- c("omes","mip")
  #One matrix
  corr_matrix_list &lt;- list(omes)
  name &lt;- c("omes")
  scores.boxplot(corr_matrix_list, name, file, 25, 275)
</code></pre>

<hr>
<h2 id='top_pairs_analysis'>
Calculates the number of contacts for each element of the top pairs 
</h2><span id='topic+top_pairs_analysis'></span>

<h3>Description</h3>

<p>Given a correlation object, calculates the number of pairs (contacts) each element in the top X pairs are involved in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  top_pairs_analysis(corr_matrix, filepathroot=NULL, top=25, entropy=NULL, filter=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_pairs_analysis_+3A_corr_matrix">corr_matrix</code></td>
<td>

<p>One of the matrices created by a correlation/covariation function (<code><a href="#topic+omes">omes</a></code>, <code><a href="#topic+mip">mip</a></code>, <code><a href="#topic+elsc">elsc</a></code>, <code><a href="#topic+mcbasc">mcbasc</a></code>, <code><a href="#topic+dynamic_circular">dynamic_circular</a></code>, <code><a href="#topic+dynamic_omes">dynamic_omes</a></code>, <code><a href="#topic+dynamic_mip">dynamic_mip</a></code>).
</p>
</td></tr> 
<tr><td><code id="top_pairs_analysis_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root of the full path names of the output files for top_pairs_analysis. Default is NULL (two csv files are created : TOPn_CONTACTS.csv and TOPn_SCORES.csv, where n is the number of top pairs). If not NULL, extentions &quot;-TOPn_CONTACTS.csv&quot; and &quot;_TOPn_SCORES.csv&quot; are added to the root name.
</p>
</td></tr>
<tr><td><code id="top_pairs_analysis_+3A_top">top</code></td>
<td>

<p>A integer indicating the number of top pairs used for this analysis. Default is 25.
</p>
</td></tr> 
<tr><td><code id="top_pairs_analysis_+3A_entropy">entropy</code></td>
<td>

<p>An object created by the entropy or dynamic_entropy function. Default is NULL.
</p>
</td></tr> 
<tr><td><code id="top_pairs_analysis_+3A_filter">filter</code></td>
<td>

<p>A vector created by the <code><a href="#topic+delta_filter">delta_filter</a></code> function to limit the analysis to elements in the given entropy/dynamic_entropy range. DEfault is NULL.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function sorts element pairs by correlation/covariation scores and analyzes the top X pairs to determine the number of pairs (contacts) each element of the top X pairs is involved in. If filter is TRUE, only the scores of elements in the delta filter defined entropy range are taken into account. Results are written as .csv files.
</p>


<h3>Value</h3>

<p>returns an object of class 'top_pairs' which is a named list of four elements for subsequent network representation with the <code>network.plot</code> function:
</p>
<table>
<tr><td><code>pair_i</code></td>
<td>

<p>a vector containing the name of element i in the ordered top pairs
</p>
</td></tr>
<tr><td><code>pair_j</code></td>
<td>

<p>a vector containing the name of element j in the ordered top pairs
</p>
</td></tr>
<tr><td><code>positions</code></td>
<td>

<p>a vector containing the positions in the top n pairs
</p>
</td></tr>
<tr><td><code>contacts</code></td>
<td>

<p>a vector containing the number of contacts of the positions in the top n pairs
</p>
</td></tr>
</table>
<p>returns also two .csv files containing scores and contacts of the top n pairs for subsequent network representation with Cytoscape.
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER and Marie CHABBERT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_seq") 

  #Importing MSA file
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating entropy object
  entropy &lt;- entropy(align)

  #Creating OMES correlation object
  omes &lt;- omes(align, gap_ratio = 0.2)

  #Selecting correlation matrix
  omes &lt;-omes$Zscore
   
  #Creating top_pairs object and writing scores and contacts to csv files  
  top_pairs &lt;- top_pairs_analysis(omes, file, top = 25, entropy=entropy)
</code></pre>

<hr>
<h2 id='write.entropy'>
Writes and displays entropy values
</h2><span id='topic+write.entropy'></span>

<h3>Description</h3>

<p>Given an entropy/dynamic_entropy object, writes each element (position or dihedral angle) and its entropy/dynamic_entropy value in a csv file, and displays the histogram. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  write.entropy(entropy, filepathroot = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.entropy_+3A_entropy">entropy</code></td>
<td>

<p>An object created by the <code><a href="#topic+entropy">entropy</a></code> or the <code><a href="#topic+dynamic_entropy">dynamic_entropy</a></code> function.
</p>
</td></tr>
<tr><td><code id="write.entropy_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root of the full path name for the entropy output file. Default is NULL (a &quot;ENTROPY.csv&quot; file is created). If filepathroot is not NULL, a &quot;_ENTROPY.csv&quot; extension is added to the file path root. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+entropy">entropy</a></code> function calculates entropy score for each position of an alignment file. The <code><a href="#topic+dynamic_entropy">dynamic_entropy</a></code>function calculate a &quot;dynamic entropy&quot; score for each side chain dihedral angle of a protein during a molecular simulations. 
</p>


<h3>Value</h3>

<p>A csv file containing the elements and their scores. A png file displaying the histogram of the scores.
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_seq") 

  #Importing multiple sequence alignment
  align &lt;- import.msf(system.file("msa/human_gpcr.msf", package = "Bios2cor"))

  #Creating entropy object
  entropy &lt;- entropy(align, gap_ratio = 0.2)
  
  #Writing results to csv file
  write.entropy(entropy, file)
</code></pre>

<hr>
<h2 id='write.pca'>
Creates a file of coordinates in PCA space 
</h2><span id='topic+write.pca'></span>

<h3>Description</h3>

<p>Given an object of class 'pca' (result of the <code><a href="#topic+centered_pca">centered_pca</a></code> function), stores the coordinates of each element in the PC space in a txt file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  write.pca(corr_pca,filepathroot=NULL, pc=NULL, entropy= NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pca_+3A_corr_pca">corr_pca</code></td>
<td>

<p>An object created by the <code><a href="#topic+centered_pca">centered_pca</a></code> function from a correlation/covariation matrix
</p>
</td></tr>
<tr><td><code id="write.pca_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root for the full path name of the output file where all coordinates on all components are stored. Default is NULL (a &quot;PCA_COORD.csv&quot; file is created). If not NULL, the &quot;_PCA_COORD.csv extension is added to the root name.
</p>
</td></tr>
<tr><td><code id="write.pca_+3A_pc">pc</code></td>
<td>

<p>An integer corresponding to the number of principal components for which coordinates of the elements are saved. By default, this number corresponds to the number of components with positive eigen values.
</p>
</td></tr> 
<tr><td><code id="write.pca_+3A_entropy">entropy</code></td>
<td>

<p>An object created by the <code><a href="#topic+entropy">entropy</a></code> or the <code><a href="#topic+dynamic_entropy">dynamic_entropy</a></code> function. DEfault is NULL. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object returned by the <code><a href="#topic+centered_pca">centered_pca</a></code> function contains coordinates in the PC space for each element.
Each line of the pca file will contain the name of the current element and its coordinates.
Any line that contains Na value for X, Y or Z coordinates will be ignored.
</p>


<h3>Value</h3>

<p>returns a file containing the coordinates of each element in PC space.
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_seq4") 

  #Importing MSA file
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating OMES correlation object and selecting correlation matrix
  omes &lt;- omes(align, gap_ratio = 0.2)
  omes &lt;-omes$Zscore

  #Creating PCA object for selected matrix
  pca &lt;- centered_pca(omes, filepathroot= file, filter = NULL, pc= NULL, dec_val= 5)
   
  #Saving coordinates of elements in csv file 
  write.pca(pca, file, pc = 10, entropy = NULL)
  
</code></pre>

<hr>
<h2 id='write.pca.pdb'>
PDB and PML file creation for 3D representation of PCA analysis
</h2><span id='topic+write.pca.pdb'></span>

<h3>Description</h3>

<p>Given a PCA structure, creates .pdb and .pml files for 3D visualization with Pymol
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  write.pca.pdb(corr_pca, filepathroot=NULL, trio_comp= c(1:3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pca.pdb_+3A_corr_pca">corr_pca</code></td>
<td>

<p>An object created by the <code><a href="#topic+centered_pca">centered_pca</a></code> function from a correlation/covariation matrix
</p>
</td></tr>
<tr><td><code id="write.pca.pdb_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root for the full path name of the output PDB and PML files. Default is NULL (Two PCA_l_m_n.pdb and PCA_l_m_n.pml files are created where l, m, n are the 3 selected components). If not null, '_PCA_l_m_n.pdb' and '_PCA_l_m_n.pml' extensions are added to the root name.   
</p>
</td></tr>
<tr><td><code id="write.pca.pdb_+3A_trio_comp">trio_comp</code></td>
<td>

<p>A numeric vector of length 3 indicating the principal components to be displayed. Default is c(1, 2, 3). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates PDB and PML files to visualize the positions of the elements (sequence positions or dihedral angles) in a 3D space corresponding to three selected components of the PCA space. The PDB file can be viewed in any molecular graphics softaware. The PML file allows a nice representation with Pymol (axis, background color, size of points and for GPCRs, color code for helices).
</p>


<h3>Value</h3>

<p>Returns two files:  a PDB file which contains three PCA coordinates for each element in PDB format and a PML file for nice visualization with Pymol. 
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER and Marie CHABBERT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example for MSA
  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_seq5") 

  #Importing MSA file
  align &lt;- import.msf(system.file("msa/toy_align.msf", package = "Bios2cor"))

  #Creating OMES correlation object and selecting correlation matrix
  omes &lt;- omes(align, gap_ratio = 0.2)
  cor_omes &lt;- omes$Zscore
 
  #Creating PCA object for selected  matrix 
  pca &lt;- centered_pca(cor_omes, filepathroot = file, filter = NULL, pc = NULL, dec_val = 5)

  #Creating PDB and PML files (open PDB file with Pymol then "File &gt; Run" PML file)
  indices &lt;- c(1,2,3)
  write.pca.pdb(pca, file, indices)


 
### Example for MD
  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_dyn5") 

  #Redaing pdb and dcd files
  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")

  #Creating dynamic_structure object for selected frames
  nb_frames_wanted &lt;- 40
  wanted_frames &lt;- seq(from = 5, to= nb_frames_wanted, by = 10)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)

  #Creating rotamers object
  conversion_file &lt;- system.file("rotamer/dynameomics_rotamers.csv", package= "Bios2cor")
  rotamers &lt;- angle2rotamer(dynamic_structure, conversion_file)
  
  #Creating OMES correlation object and selecting correlation matrix
  wanted_residues &lt;- c("W","Y","F","N")
  omes &lt;- dynamic_omes(dynamic_structure, rotamers, wanted_residues)
  cor_omes &lt;- omes$Zscore_noauto

  #Creating PCA object for selected matrix 
  pca &lt;- centered_pca(cor_omes, file, filter = NULL, pc = NULL, dec_val = 5)

  #Creating PDB and PML files (open PDB file with Pymol then "File &gt; Run" PML file)
  indices &lt;- c(1,2,3)
  write.pca.pdb(pca, file, indices)

</code></pre>

<hr>
<h2 id='write.scores'>
Creates a correlation/covariation ouput file 
</h2><span id='topic+write.scores'></span>

<h3>Description</h3>

<p>Given a correlation object, writes the score, the Zscore and, optionally the entropy, for each pair of elements in a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  write.scores(correlation, entropy= NULL, filepathroot=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.scores_+3A_correlation">correlation</code></td>
<td>

<p>An object created by a correlation/covariation function (<code><a href="#topic+omes">omes</a></code>, <code><a href="#topic+mi">mi</a></code>, <code><a href="#topic+mip">mip</a></code>, <code><a href="#topic+elsc">elsc</a></code>, <code><a href="#topic+mcbasc">mcbasc</a></code>, <code><a href="#topic+dynamic_circular">dynamic_circular</a></code>, <code><a href="#topic+dynamic_omes">dynamic_omes</a></code>, <code><a href="#topic+dynamic_mi">dynamic_mi</a></code>, <code><a href="#topic+dynamic_mip">dynamic_mip</a></code>
</p>
</td></tr>
<tr><td><code id="write.scores_+3A_entropy">entropy</code></td>
<td>

<p>An object created by the <code><a href="#topic+entropy">entropy</a></code> function 
</p>
</td></tr>
<tr><td><code id="write.scores_+3A_filepathroot">filepathroot</code></td>
<td>

<p>The root of the full path name for the output file. DEfault is NULL (a &quot;CORR_SCORES.csv&quot; file is created). If not NULL, the &quot;_CORR_SCORES.csv&quot; extension is added to the root name.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elements represent positions in multiple sequence alignments and side chain dihedral angles in molecular dynamic simulations (MD). 
</p>
<p>In sequence analysis, the correlation object contains two matrices with the correlation/covariation scores and Z-scores for each pair of elements [i,j].   
If entropy = NULL, each line of the output file will contain element  i, element  j, score[i,j], and Z-score[i,j]. 
If entropy is not NULL, each line of the output file will contain element  i, element  j, score[i,j], Zscore[i,j], entropy[i], and entropy[j].  
</p>
<p>In MD analysis, the correlation object contains four matrices with (1) the correlation/covariation scores for each pair of rotamers (score), (2) the Z-scores for each pair of rotamers (Zscore), (3) the correlation/covariation scores for each pair of rotamers with zero values for autocorrelation (correlation within the same side chain) (score_noauto) and (4) the Z-scores calculated without autocorrelation pairs and zero values for autocorrelation pairs (Zscore_noauto). 
If entropy = NULL, each line of the output file will contain element  i, element  j, score[i,j], Zscore[i,j], score_noauto[i,j], and Zscore_noauto[i,j].
If entropy is not NULL, each line of the output file will contain element  i, element  j, score[i,j], Zscore[i,j], score_noauto[i,j], Zscore_noauto[i,j], entropy[i], and entropy[j].
</p>


<h3>Value</h3>

<p>A csv file containing the correlation/covariation scores and optionally the entropies.
</p>


<h3>Author(s)</h3>

<p>Antoine GARNIER and Marie CHABBERT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example for MSA 
  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_seq") 

  #Importing MSA file
  msf &lt;- system.file("msa/toy_align.msf", package = "Bios2cor")
  align &lt;- import.msf(msf)

  #Creating correlation and entropy objects
  correlation &lt;- omes(align, gap_ratio= 0.2)
  entropy &lt;- entropy(align)
  
  #Writing results to csv file
  write.scores(correlation, entropy, file)

###Example for MD
  #File path for output files
  wd &lt;- tempdir()
  #wd &lt;-getwd() 
  file &lt;- file.path(wd,"test_dyn") 

  #Reading the pdb and dcd files and the angles to rotamers conversion file
  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")
  conversion_file &lt;- system.file("rotamer/dynameomics_rotamers.csv", package= "Bios2cor")

  #Creating dynamic_structure and rotamers objects
  wanted_frames &lt;- seq(from = 5, to = 40, by = 10)
  dynamic_structure &lt;- dynamic_structure(pdb, trj, wanted_frames)
  rotamers &lt;- angle2rotamer(dynamic_structure, conversion_file)
  
  #Creating correlation and entropy objects
  wanted_residues &lt;- c("F","H","N","Y","W")
  #dyn_corr &lt;- dynamic_omes(dynamic_structure, rotamers, wanted_residues)
  dyn_corr &lt;- dynamic_circular(dynamic_structure, wanted_residues)
  dyn_entropy &lt;- dynamic_entropy(rotamers)
   
  #Writing results to csv file
  write.scores(dyn_corr, dyn_entropy, file)

</code></pre>

<hr>
<h2 id='xyz2torsion'> Convert Cartesian Coordinates to Torsion Angles </h2><span id='topic+xyz2torsion'></span>

<h3>Description</h3>

<p>Convert cartesian coordinate matrix to torsion angles with 
function <code><a href="bio3d.html#topic+torsion.pdb">torsion.pdb</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz2torsion(pdb, xyz, tbl = c("basic", "mainchain", 
     "sidechain", "all", "phi", "psi", paste("chi", 1:5, sep="")), ncore = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyz2torsion_+3A_pdb">pdb</code></td>
<td>
<p> A PDB structure object as obtained from <code><a href="bio3d.html#topic+read.pdb">read.pdb</a></code>. </p>
</td></tr>
<tr><td><code id="xyz2torsion_+3A_xyz">xyz</code></td>
<td>
<p> Cartesian coordinates as a Mx(3N) matrix. </p>
</td></tr>
<tr><td><code id="xyz2torsion_+3A_tbl">tbl</code></td>
<td>
<p> Names of torsion angles to calculate. </p>
</td></tr>
<tr><td><code id="xyz2torsion_+3A_ncore">ncore</code></td>
<td>
<p> Number of CPU cores used to do the calculation. By default (NULL), use
all detected CPU cores. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available values for the argument &lsquo;tbl&rsquo; include:
</p>

<ul>
<li><p> Basic: &quot;phi&quot;, &quot;psi&quot;, &quot;chi1&quot;.
</p>
</li>
<li><p> Mainchain: &quot;phi&quot;, &quot;psi&quot;.
</p>
</li>
<li><p> Sidechain: &quot;chi1&quot;, &quot;chi2&quot;, &quot;chi3&quot;, &quot;chi4&quot;, &quot;chi5&quot;.
</p>
</li>
<li><p> All: all of the above.
</p>
</li>
<li><p> Each individual angle.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a MxP matrix, where M is the number of frames and P the number of valid torsion angles.
</p>


<h3>Note</h3>

<p>New function from the bio3d package, available at &lt;https://github.com/Grantlab/bio3d/blob/master/new_funs/xyz2torsion.R&gt;
</p>


<h3>Author(s)</h3>

<p> Xin-Qiu Yao </p>


<h3>References</h3>

<p>Grant, B.J. et al. (2006) <em>Bioinformatics</em> <b>22</b>, 2695&ndash;2696.
</p>


<h3>See Also</h3>

 <p><code><a href="bio3d.html#topic+torsion.xyz">torsion.xyz</a></code>, <code><a href="bio3d.html#topic+torsion.pdb">torsion.pdb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pdb &lt;- system.file("rotamer/toy_coordinates.pdb", package= "Bios2cor")
  trj &lt;- system.file("rotamer/toy_dynamics.dcd", package= "Bios2cor")
  
  pdb &lt;- read.pdb(pdb)
  trj &lt;- read.dcd(trj)
 
  #Selecting only "CA" atoms
  ca.inds &lt;- atom.select(pdb, elety = "CA")

  #Getting xyz coordinates using fit.xyz form bio3d package
  xyz &lt;- fit.xyz(fixed = pdb$xyz, mobile = trj,fixed.inds=ca.inds$xyz,mobile.inds=ca.inds$xyz)
 
  frames &lt;- seq(from= 1, to= 40, by= 2)
  
  #Creating torsion object for side chains using xyz2torsion function from bio3d package
  tor &lt;- xyz2torsion(pdb, xyz[frames,], tbl = "sidechain", ncore= 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
