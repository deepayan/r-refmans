<!DOCTYPE html><html><head><title>Help for package rgnoisefilt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rgnoisefilt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#discCNN'><p>Condensed Nearest Neighbors for Regression by Discretization</p></a></li>
<li><a href='#discENN'><p>Edited Nearest Neighbors for Regression by Discretization</p></a></li>
<li><a href='#discNCL'><p>Neighborhood Cleaning Rule for Regression by Discretization</p></a></li>
<li><a href='#discTL'><p>Tomek Links for Regression by Discretization</p></a></li>
<li><a href='#plot.rfdata'><p>Plot function for class rfdata</p></a></li>
<li><a href='#print.rfdata'><p>Print function for class rfdata</p></a></li>
<li><a href='#regAENN'><p>All-k Edited Nearest Neighbors for Regression</p></a></li>
<li><a href='#regBBNR'><p>Blame Based Noise Reduction for Regression</p></a></li>
<li><a href='#regCNN'><p>Condensed Nearest Neighbors for Regression</p></a></li>
<li><a href='#regCVCF'><p>Cross-Validated Committees Filter for Regression</p></a></li>
<li><a href='#regDF'><p>Dynamic Filter for Regression</p></a></li>
<li><a href='#regEF'><p>Ensemble Filter for Regression</p></a></li>
<li><a href='#regENN'><p>Edited Nearest Neighbors for Regression</p></a></li>
<li><a href='#regFMF'><p>Fusion of Multiple Filters for Regression</p></a></li>
<li><a href='#regGE'><p>Generalized Edition for Regression</p></a></li>
<li><a href='#regHRRF'><p>Hybrid Repair-Remove Filter for Regression</p></a></li>
<li><a href='#regIPF'><p>Iterative Partitioning Filter for Regression</p></a></li>
<li><a href='#regIRF'><p>Iterative Robust Filter for Regression</p></a></li>
<li><a href='#regRND'><p>Regressand Noise Detection for Regression</p></a></li>
<li><a href='#regRNN'><p>Reduced Nearest Neighbors for Regression</p></a></li>
<li><a href='#rfCDF'><p>Covering Distance Filtering for Regression</p></a></li>
<li><a href='#rfDROP2'><p>Decremental Reduction Optimization Procedure for Regression</p></a></li>
<li><a href='#rfDROP3'><p>Decremental Reduction Optimization Procedure 3 for Regression</p></a></li>
<li><a href='#rfMIF'><p>Mutual Information-based Filter for Regression</p></a></li>
<li><a href='#summary.rfdata'><p>Summary function for class rfdata</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Elimination of Noisy Samples in Regression Datasets using Noise
Filters</td>
</tr>
<tr>
<td>Description:</td>
<td>Traditional noise filtering methods aim at removing noisy samples from a classification dataset. This package adapts classic and recent filtering techniques for use in regression problems, and it also incorporates methods specifically designed for regression data. In order to do this, it uses approaches proposed in the specialized literature, such as Martin et al. (2021) [&lt;<a href="https://doi.org/10.1109%2FACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>&gt;] and Arnaiz-Gonzalez et al. (2016) [&lt;<a href="https://doi.org/10.1016%2Fj.eswa.2015.12.046">doi:10.1016/j.eswa.2015.12.046</a>&gt;]. Thus, the goal of the implemented noise filters is to eliminate samples with noise in regression datasets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/juanmartinsantos/rgnoisefilt">https://github.com/juanmartinsantos/rgnoisefilt</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>e1071, FNN, gbm, modelr, nnet, randomForest, rpart, arules,
infotheo, entropy, ggplot2, class, kknn</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Martin [aut, cre],
  José A. Sáez [aut],
  Emilio Corchado [aut],
  Pablo Morales [ctb] (Author of the NoiseFiltersR package),
  Julian Luengo [ctb] (Author of the NoiseFiltersR package),
  Luis P.F. Garcia [ctb] (Author of the NoiseFiltersR package),
  Ana C. Lorena [ctb] (Author of the NoiseFiltersR package),
  Andre C.P.L.F. de Carvalho [ctb] (Author of the NoiseFiltersR package),
  Francisco Herrera [ctb] (Author of the NoiseFiltersR package)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Martin &lt;juanmartin@usal.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-02 08:10:02 UTC</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-02 07:47:28 UTC; JuanMiguelMartinSant</td>
</tr>
</table>
<hr>
<h2 id='discCNN'>Condensed Nearest Neighbors for Regression by Discretization</h2><span id='topic+discCNN'></span><span id='topic+discCNN.default'></span><span id='topic+discCNN.formula'></span>

<h3>Description</h3>

<p>Application of the discCNN noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
discCNN(x, y, ...)

## S3 method for class 'formula'
discCNN(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discCNN_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="discCNN_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="discCNN_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="discCNN_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="discCNN_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>discCNN</code> discretizes the numerical output variable to make it compatible with <em>Condensed Nearest Neighbors</em> (CNN), typically used in classification tasks. 
CNN performs a first classification and stores all the samples that are misclassified.
Then, those stored samples are taken as a training set. The process stops when all the unstored samples are correctly classified.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>L. Devroye, L. Gyorfi and G. Lugosi,
<strong>Condensed and edited nearest neighbor rules.</strong>
<em>In: A Probabilistic Theory of Pattern Recognition</em>, 31:303-313, 1996.
<a href="https://doi.org/10.1007/978-1-4612-0711-5_19">doi:10.1007/978-1-4612-0711-5_19</a>.
</p>
<p>A. Arnaiz-González, J. Díez-Pastor, J. Rodríguez, C. García-Osorio,
<strong>Instance selection for regression by discretization.</strong>
<em>Expert Systems with Applications</em>, 54:340-350, 2016.
<a href="https://doi.org/10.1016/j.eswa.2015.12.046">doi:10.1016/j.eswa.2015.12.046</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discENN">discENN</a></code>, <code><a href="#topic+discTL">discTL</a></code>, <code><a href="#topic+discNCL">discNCL</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- discCNN(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- discCNN(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='discENN'>Edited Nearest Neighbors for Regression by Discretization</h2><span id='topic+discENN'></span><span id='topic+discENN.default'></span><span id='topic+discENN.formula'></span>

<h3>Description</h3>

<p>Application of the discENN noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
discENN(x, y, k = 5, ...)

## S3 method for class 'formula'
discENN(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discENN_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="discENN_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="discENN_+3A_k">k</code></td>
<td>
<p>an integer with the number of nearest neighbors to be used (default: 5).</p>
</td></tr>
<tr><td><code id="discENN_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="discENN_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="discENN_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>discENN</code> discretizes the numerical output variable to make it compatible with <em>Edited Nearest Neighbors</em> (ENN), typically used in classification tasks. 
ENN removes a sample if its class label is different from that of the majority of its nearest neighbors (<code>k</code>).
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>L. Devroye, L. Gyorfi and G. Lugosi,
<strong>Condensed and edited nearest neighbor rules.</strong>
<em>In: A Probabilistic Theory of Pattern Recognition</em>, 31:303-313, 1996.
<a href="https://doi.org/10.1007/978-1-4612-0711-5_19">doi:10.1007/978-1-4612-0711-5_19</a>.
</p>
<p>A. Arnaiz-González, J. Díez-Pastor, J. Rodríguez, C. García-Osorio,
<strong>Instance selection for regression by discretization.</strong>
<em>Expert Systems with Applications</em>, 54:340-350, 2016.
<a href="https://doi.org/10.1016/j.eswa.2015.12.046">doi:10.1016/j.eswa.2015.12.046</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discCNN">discCNN</a></code>, <code><a href="#topic+discTL">discTL</a></code>, <code><a href="#topic+discNCL">discNCL</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- discENN(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- discENN(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='discNCL'>Neighborhood Cleaning Rule for Regression by Discretization</h2><span id='topic+discNCL'></span><span id='topic+discNCL.default'></span><span id='topic+discNCL.formula'></span>

<h3>Description</h3>

<p>Application of the discNCL noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
discNCL(x, y, k = 3, ...)

## S3 method for class 'formula'
discNCL(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discNCL_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="discNCL_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="discNCL_+3A_k">k</code></td>
<td>
<p>an integer with the number of nearest neighbors to be used (default: 3).</p>
</td></tr>
<tr><td><code id="discNCL_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="discNCL_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="discNCL_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>discNCL</code> discretizes the numerical output variable to make it compatible with <em>Neighborhood Cleaning Rule</em> (NCL), typically used in classification tasks.
NCL identifies and prunes majority class instances that are predominantly surrounded by minority class counterparts, often perceived as noise or overlapping points. 
By removing these instances, decision boundaries become clearer, thereby enhancing classification performance.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>J. Laurikkala,
<strong>Improving identification of difficult small classes by balancing class distribution.</strong>
<em>Artificial Intelligence in Medicine</em>, 2101:63-66, 2001.
<a href="https://doi.org/10.1007/3-540-48229-6_9">doi:10.1007/3-540-48229-6_9</a>.
</p>
<p>A. Arnaiz-González, J. Díez-Pastor, J. Rodríguez, C. García-Osorio,
<strong>Instance selection for regression by discretization.</strong>
<em>Expert Systems with Applications</em>, 54:340-350, 2016.
<a href="https://doi.org/10.1016/j.eswa.2015.12.046">doi:10.1016/j.eswa.2015.12.046</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discCNN">discCNN</a></code>, <code><a href="#topic+discTL">discTL</a></code>, <code><a href="#topic+discENN">discENN</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- discNCL(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- discNCL(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='discTL'>Tomek Links for Regression by Discretization</h2><span id='topic+discTL'></span><span id='topic+discTL.default'></span><span id='topic+discTL.formula'></span>

<h3>Description</h3>

<p>Application of the discTL noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
discTL(x, y, ...)

## S3 method for class 'formula'
discTL(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discTL_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="discTL_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="discTL_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="discTL_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="discTL_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>discTL</code> discretizes the numerical output variable to make it compatible with <em>Tomek Links</em> (TL), typically used in classification tasks. 
TL identifies pairs of instances that are close neighbors but belong to different classes. 
If an instance in such a pair is predominantly surrounded by instances from a different class, it may be flagged as noisy.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>I. Tomek,
<strong>Two modifications of CNN.</strong>
<em>IEEE Trans. Syst. Man Cybern</em>, 6:769-772, 1976.
</p>
<p>A. Arnaiz-González, J. Díez-Pastor, J. Rodríguez, C. García-Osorio,
<strong>Instance selection for regression by discretization.</strong>
<em>Expert Systems with Applications</em>, 54:340-350, 2016.
<a href="https://doi.org/10.1016/j.eswa.2015.12.046">doi:10.1016/j.eswa.2015.12.046</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discENN">discENN</a></code>, <code><a href="#topic+discCNN">discCNN</a></code>, <code><a href="#topic+discNCL">discNCL</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- discTL(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- discTL(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='plot.rfdata'>Plot function for class rfdata</h2><span id='topic+plot.rfdata'></span>

<h3>Description</h3>

<p>Graphical representation that allows for comparing data distributions before and after the noise filtering process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rfdata'
plot(x, ..., var = c(1), fun = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rfdata_+3A_x">x</code></td>
<td>
<p>an object of <code>rfdata</code> class.</p>
</td></tr>
<tr><td><code id="plot.rfdata_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="plot.rfdata_+3A_var">var</code></td>
<td>
<p>an integer vector with the indices of variables whose distributions are compared, 
considering the attributes in the order in which they appear in the original data, with the output variable in the last position (default = <code>c(1)</code>).</p>
</td></tr>
<tr><td><code id="plot.rfdata_+3A_fun">fun</code></td>
<td>
<p>a character containing the name of the descriptive statistic function to compute for each distribution of the variable, 
or a user-defined function that returns a value from a distribution of numeric values (default: <code>"mean"</code>). 
Some options for fun include &quot;mean&quot;, &quot;median&quot; or &quot;sd&quot; (standard deviation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a plot for each of the variables specified by the <code>var</code> parameter,
allowing the comparison of their value distributions before filtering, using the descriptive statistic specified by <code>fun</code>,
with the distributions of the data from samples identified as clean and noisy by the filtering method.
</p>


<h3>Value</h3>

<p>An object of class <code>ggplot</code> that graphically represents the data distributions before and after the noise filtering.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# apply the regression noise filter
set.seed(9)
output &lt;- regAENN(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# comparison chart of data distributions before and after the filtering process
plot(x = output, var = c(1:4), fun = "mean")

</code></pre>

<hr>
<h2 id='print.rfdata'>Print function for class rfdata</h2><span id='topic+print.rfdata'></span>

<h3>Description</h3>

<p>This methods displays the basic information about the noise
filtering process contained in an object of class <code>rfdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rfdata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rfdata_+3A_x">x</code></td>
<td>
<p>an object of class <code>rfdata</code>.</p>
</td></tr>
<tr><td><code id="print.rfdata_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function presents the basic information of the regression noise filter and the resulting
noisy dataset contained in the object <code>x</code> of class <code>rfdata</code>.
The information offered is as follows:
</p>

<ul>
<li><p> the name of the regression noise filter.
</p>
</li>
<li><p> the parameters associated with the noise filter.
</p>
</li>
<li><p> the number of noisy and clean samples in the dataset.
</p>
</li></ul>



<h3>Value</h3>

<p>This function does not return any value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.rfdata">summary.rfdata</a></code>, <code><a href="#topic+regAENN">regAENN</a></code>, <code><a href="#topic+regENN">regENN</a></code>, <code><a href="#topic+regGE">regGE</a></code>, <code><a href="#topic+regEF">regEF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# apply the regression noise filter
set.seed(9)
output &lt;- regAENN(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# print the results
print(output)

</code></pre>

<hr>
<h2 id='regAENN'>All-k Edited Nearest Neighbors for Regression</h2><span id='topic+regAENN'></span><span id='topic+regAENN.default'></span><span id='topic+regAENN.formula'></span>

<h3>Description</h3>

<p>Application of the regAENN noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regAENN(x, y, t = 0.2, k = 5, ...)

## S3 method for class 'formula'
regAENN(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regAENN_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regAENN_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regAENN_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regAENN_+3A_k">k</code></td>
<td>
<p>an integer with the number of nearest neighbors to be used (default: 5).</p>
</td></tr>
<tr><td><code id="regAENN_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regAENN_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regAENN_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>regAENN</code> applies <code><a href="#topic+regENN">regENN</a></code> from 1 to <code>k</code> throughout the dataset and removes those noisy samples considered by any <code><a href="#topic+regENN">regENN</a></code>.
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>I. Tomek, <strong>An experiment with the edited nearest-neighbor rule</strong>,
<em>IEEE Transactions on Systems, Man, and Cybernetics</em>, 6:448–452, 1976.
<a href="https://doi.org/10.1109/TSMC.1976.4309523">doi:10.1109/TSMC.1976.4309523</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regENN">regENN</a></code>, <code><a href="#topic+regCNN">regCNN</a></code>, <code><a href="#topic+regGE">regGE</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regAENN(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regAENN(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regBBNR'>Blame Based Noise Reduction for Regression</h2><span id='topic+regBBNR'></span><span id='topic+regBBNR.default'></span><span id='topic+regBBNR.formula'></span>

<h3>Description</h3>

<p>Application of the regBBNR noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regBBNR(x, y, t = 0.2, k = 5, ...)

## S3 method for class 'formula'
regBBNR(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regBBNR_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regBBNR_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regBBNR_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regBBNR_+3A_k">k</code></td>
<td>
<p>an integer with the number of nearest neighbors to be used (default: 5).</p>
</td></tr>
<tr><td><code id="regBBNR_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regBBNR_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regBBNR_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In classification problems, <em>Blame Based Noise Reduction</em> (BBNR) removes a sample if it participates in the misclassification of another sample and
if its removal does not produce the misclassification on another correctly classified sample.
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>S. Delany and P. Cunningham,
<strong>An analysis of case-base editing in a spam filtering system</strong>,
<em>in European Conference on Case-Based Reasoning</em>, 128-141, 2004.
<a href="https://doi.org/10.1007/978-3-540-28631-8_11">doi:10.1007/978-3-540-28631-8_11</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regCNN">regCNN</a></code>, <code><a href="#topic+regRNN">regRNN</a></code>, <code><a href="#topic+regENN">regENN</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regBBNR(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regBBNR(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regCNN'>Condensed Nearest Neighbors for Regression</h2><span id='topic+regCNN'></span><span id='topic+regCNN.default'></span><span id='topic+regCNN.formula'></span>

<h3>Description</h3>

<p>Application of the regCNN noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regCNN(x, y, t = 0.2, ...)

## S3 method for class 'formula'
regCNN(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regCNN_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regCNN_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regCNN_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regCNN_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regCNN_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regCNN_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Condensed Nearest Neighbors</em> (CNN) seeks to obtain a data subset that improves the quality of the original dataset.
In classification problems, CNN performs a first classification and stores all the samples that are misclassified.
Then, those stored samples are taken as a training set. The process stops when all the unstored samples are correctly classified.
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>L. Devroye, L. Gyorfi and G. Lugosi,
<strong>Condensed and edited nearest neighbor rules.</strong>
<em>In: A Probabilistic Theory of Pattern Recognition</em>, 31:303-313, 1996.
<a href="https://doi.org/10.1007/978-1-4612-0711-5_19">doi:10.1007/978-1-4612-0711-5_19</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regRNN">regRNN</a></code>, <code><a href="#topic+regENN">regENN</a></code>, <code><a href="#topic+regBBNR">regBBNR</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regCNN(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regCNN(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regCVCF'>Cross-Validated Committees Filter for Regression</h2><span id='topic+regCVCF'></span><span id='topic+regCVCF.default'></span><span id='topic+regCVCF.formula'></span>

<h3>Description</h3>

<p>Application of the regCVCF noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regCVCF(x, y, t = 0.2, nfolds = 10, vote = FALSE, ...)

## S3 method for class 'formula'
regCVCF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regCVCF_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regCVCF_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regCVCF_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regCVCF_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds in which the dataset is split (default: 10).</p>
</td></tr>
<tr><td><code id="regCVCF_+3A_vote">vote</code></td>
<td>
<p>a logical indicating if the consensus voting (<code>TRUE</code>) or majority voting (<code>FALSE</code>) is used (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="regCVCF_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regCVCF_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regCVCF_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In classification problems, <em>Cross-Validated Committees Filter</em> (CVCF) divides the dataset into <code>nfolds</code> cross-validation folds and builds
a decision tree with C4.5 on each one. Using each classifier, a prediction of the whole dataset is obtained.
Finally, a sample is considered as noisy using a voting scheme (indicated by the argument <code>vote</code>): if equal to <code>TRUE</code>,
a consensus voting is used (in which a sample is removed if it is misclassified by all the models); if equal to <code>FALSE</code>,
a majority voting is used (in which a sample is removed if it is misclassified by more than a half of the models).
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>S. Verbaeten and A. Van,
<strong>Ensemble methods for noise elimination in classification problems</strong>,
<em>in: International Workshop on Multiple Classifier Systems</em>, 317-325, 2003.
<a href="https://doi.org/10.1007/3-540-44938-8_32">doi:10.1007/3-540-44938-8_32</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regIPF">regIPF</a></code>, <code><a href="#topic+regIRF">regIRF</a></code>, <code><a href="#topic+regEF">regEF</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regCVCF(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regCVCF(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regDF'>Dynamic Filter for Regression</h2><span id='topic+regDF'></span><span id='topic+regDF.default'></span><span id='topic+regDF.formula'></span>

<h3>Description</h3>

<p>Application of the regDF noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regDF(x, y, t = 0.2, nfolds = 10, m = 3, vote = FALSE, ...)

## S3 method for class 'formula'
regDF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regDF_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regDF_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regDF_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regDF_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds in which the dataset is split (default: 10).</p>
</td></tr>
<tr><td><code id="regDF_+3A_m">m</code></td>
<td>
<p>an integer in [1,9] with the number of algorithms in the ensemble (default: 3).</p>
</td></tr>
<tr><td><code id="regDF_+3A_vote">vote</code></td>
<td>
<p>a logical indicating if the consensus voting (<code>TRUE</code>) or majority voting (<code>FALSE</code>) is used (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="regDF_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regDF_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regDF_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In classification, <em>Dynamic Filter</em> (DF) divides the dataset into <code>nfolds</code> cross-validation folds and obtains the prediction of
9 classifiers: SVM; k-NN with <code>k</code> = 3, 5 and 9; CART; C4.5; MLPN;
<em>Random Forest</em> and <em>Naive Bayes</em>. Then, it selects one ensemble of size <code>m</code> with best predictions.
Finally, a sample is considered as noisy using a voting scheme (indicated by the argument <code>vote</code>): if equal to <code>TRUE</code>,
a consensus voting is used (in which a sample is removed if it is misclassified by all the models); if equal to <code>FALSE</code>,
a majority voting is used (in which a sample is removed if it is misclassified by more than a half of the models).
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>L. Garcia, A. Lorena and A. Carvalho,
<strong>A study on class noise detection and elimination</strong>,
<em>Brazilian Symposium on Neural Networks</em>, 13-18, 2012.
<a href="https://doi.org/10.1109/SBRN.2012.49">doi:10.1109/SBRN.2012.49</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regEF">regEF</a></code>, <code><a href="#topic+regGE">regGE</a></code>, <code><a href="#topic+regHRRF">regHRRF</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regDF(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regDF(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regEF'>Ensemble Filter for Regression</h2><span id='topic+regEF'></span><span id='topic+regEF.default'></span><span id='topic+regEF.formula'></span>

<h3>Description</h3>

<p>Application of the regEF noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regEF(x, y, t = 0.2, nfolds = 10, vote = TRUE, ...)

## S3 method for class 'formula'
regEF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regEF_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regEF_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regEF_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regEF_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds in which the dataset is split (default: 10).</p>
</td></tr>
<tr><td><code id="regEF_+3A_vote">vote</code></td>
<td>
<p>a logical indicating if the consensus voting (<code>TRUE</code>) or majority voting (<code>FALSE</code>) is used (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="regEF_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regEF_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regEF_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In classification, <em>Ensemble Filter</em> (EF) divides the dataset into <code>nfolds</code> cross-validation folds.
Then, a prediction is obtained for each one of the classifiers &ndash;C4.5, NN and LDA.
Finally, a sample is considered as noisy using a voting scheme (indicated by the argument <code>vote</code>): if equal to <code>TRUE</code>,
a consensus voting is used (in which a sample is removed if it is misclassified by all the models); if equal to <code>FALSE</code>,
a majority voting is used (in which a sample is removed if it is misclassified by more than a half of the models).
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>C. Brodley and M. Friedl,
<strong>Identifying mislabeled training data</strong>,
<em>Journal of Artificial Intelligence Research</em>, 11:131-167, 1999.
<a href="https://doi.org/10.1613/jair.606">doi:10.1613/jair.606</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regDF">regDF</a></code>, <code><a href="#topic+regCVCF">regCVCF</a></code>, <code><a href="#topic+regIPF">regIPF</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regEF(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regEF(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regENN'>Edited Nearest Neighbors for Regression</h2><span id='topic+regENN'></span><span id='topic+regENN.default'></span><span id='topic+regENN.formula'></span>

<h3>Description</h3>

<p>Application of the regENN noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regENN(x, y, t = 0.2, k = 5, ...)

## S3 method for class 'formula'
regENN(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regENN_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regENN_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regENN_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regENN_+3A_k">k</code></td>
<td>
<p>an integer with the number of nearest neighbors to be used (default: 5).</p>
</td></tr>
<tr><td><code id="regENN_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regENN_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regENN_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In classification, <em>Edited Nearest Neighbors</em> (ENN) removes a sample if its class label is different from that of the majority of its nearest neighbors (<code>k</code>).
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>L. Devroye, L. Gyorfi and G. Lugosi,
<strong>Condensed and edited nearest neighbor rules.</strong>
<em>In: A Probabilistic Theory of Pattern Recognition</em>, 31:303-313, 1996.
<a href="https://doi.org/10.1007/978-1-4612-0711-5_19">doi:10.1007/978-1-4612-0711-5_19</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regAENN">regAENN</a></code>, <code><a href="#topic+regGE">regGE</a></code>, <code><a href="#topic+regCNN">regCNN</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regENN(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regENN(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regFMF'>Fusion of Multiple Filters for Regression</h2><span id='topic+regFMF'></span><span id='topic+regFMF.default'></span><span id='topic+regFMF.formula'></span>

<h3>Description</h3>

<p>Application of the regFMF noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regFMF(x, y, t = 0.2, vote = FALSE, ...)

## S3 method for class 'formula'
regFMF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regFMF_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regFMF_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regFMF_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regFMF_+3A_vote">vote</code></td>
<td>
<p>a logical indicating if the consensus voting (<code>TRUE</code>) or majority voting (<code>FALSE</code>) is used (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="regFMF_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regFMF_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regFMF_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Fusion of Multiple Filters for Regression</em> (regFMF) is an adaptation of <em>Ensembles of label Noise Filters</em> (ENF) found in the field of classification,
which creates an ensemble with the AENN, DF and HARF filtering techniques.
Then, each filter generates one vote per sample. A sample is considered as noisy using a voting scheme (indicated by the argument <code>vote</code>):
if equal to <code>TRUE</code>, a consensus voting is used (in which a sample is removed if it is misclassified by all the models);
if equal to <code>FALSE</code>, a majority voting is used (in which a sample is removed if it is misclassified by more than a half of the models).
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>L. Garcia, A. Lorena, S. Matwin and A. de Carvalho,
<strong>Ensembles of label noise filters: a ranking approach</strong>,
<em>Data Mining Knowledge Discovery</em>, 30:1192–1216, 2016.
<a href="https://doi.org/10.1007/s10618-016-0475-9">doi:10.1007/s10618-016-0475-9</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regDF">regDF</a></code>, <code><a href="#topic+regHRRF">regHRRF</a></code>, <code><a href="#topic+regAENN">regAENN</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regFMF(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regFMF(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regGE'>Generalized Edition for Regression</h2><span id='topic+regGE'></span><span id='topic+regGE.default'></span><span id='topic+regGE.formula'></span>

<h3>Description</h3>

<p>Application of the regGE noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regGE(x, y, t = 0.2, k = 5, ...)

## S3 method for class 'formula'
regGE(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regGE_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regGE_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regGE_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regGE_+3A_k">k</code></td>
<td>
<p>an integer with the number of nearest neighbors to be used (default: 5).</p>
</td></tr>
<tr><td><code id="regGE_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regGE_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regGE_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In classification, <em>Generalized Edition</em> (GE) is a generalization of ENN, which can relabel a sample if at least half of its nearest neighbors (<code>k</code>)
have the same class label; otherwise it is removed. The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>J. Koplowitz and T. A. Brown,
<strong>On the relation of performance to editing in nearest neighbor rules</strong>,
<em>Pattern Recognition</em>, 13:251-255, 1981.
<a href="https://doi.org/10.1016/0031-3203%2881%2990102-3">doi:10.1016/0031-3203(81)90102-3</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regENN">regENN</a></code>, <code><a href="#topic+regAENN">regAENN</a></code>, <code><a href="#topic+regRNN">regRNN</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regGE(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regGE(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regHRRF'>Hybrid Repair-Remove Filter for Regression</h2><span id='topic+regHRRF'></span><span id='topic+regHRRF.default'></span><span id='topic+regHRRF.formula'></span>

<h3>Description</h3>

<p>Application of the regHRRF noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regHRRF(x, y, t = 0.2, vote = FALSE, ...)

## S3 method for class 'formula'
regHRRF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regHRRF_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regHRRF_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regHRRF_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regHRRF_+3A_vote">vote</code></td>
<td>
<p>a logical indicating if the consensus voting (<code>TRUE</code>) or majority voting (<code>FALSE</code>) is used (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="regHRRF_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regHRRF_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regHRRF_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>regHRRF</code> is an adaptation of <em>Hybrid Repair-Remove Filter</em> (HRRF) found in the field of classification, which builds a classifier set using
SVM, MLPNN, CART and k-NN (<code>k</code>= 1, 3 and 5) on the dataset. HRRF removes noisy samples depending on chosen <em>voting</em> scheme
(indicated by the argument <code>vote</code>): if equal to <code>TRUE</code>, a consensus voting is used (in which a sample is removed if it is misclassified by all the models);
if equal to <code>FALSE</code>, a majority voting is used (in which a sample is removed if it is misclassified by more than a half of the models).
The process is repeated while the prediction accuracy (over the original dataset) of the ensemble increases.
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>A. Miranda, L. Garcia, A. Carvalho and A. Lorena,
<strong>Use of classification algorithms in noise detection and elimination</strong>
<em>in Hybrid Artificial Intelligence Systems</em>, 417-424, 2009.
<a href="https://doi.org/10.1007/978-3-642-02319-4_50">doi:10.1007/978-3-642-02319-4_50</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regIPF">regIPF</a></code>, <code><a href="#topic+regEF">regEF</a></code>, <code><a href="#topic+regFMF">regFMF</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock) # data regresion

# usage of the default method
set.seed(9)
out.def &lt;- regHRRF(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regHRRF(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regIPF'>Iterative Partitioning Filter for Regression</h2><span id='topic+regIPF'></span><span id='topic+regIPF.default'></span><span id='topic+regIPF.formula'></span>

<h3>Description</h3>

<p>Application of the regIPF noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regIPF(x, y, t = 0.4, nfolds = 10, vote = FALSE, p = 0.01, s = 3, i = 0.5, ...)

## S3 method for class 'formula'
regIPF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regIPF_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regIPF_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regIPF_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regIPF_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds in which the dataset is split (default: 10).</p>
</td></tr>
<tr><td><code id="regIPF_+3A_vote">vote</code></td>
<td>
<p>a logical indicating if the consensus voting (<code>TRUE</code>) or majority voting (<code>FALSE</code>) is used (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="regIPF_+3A_p">p</code></td>
<td>
<p>a double in [0,1] with the minimum proportion of original samples that must be labeled as noisy (default: 0.4).</p>
</td></tr>
<tr><td><code id="regIPF_+3A_s">s</code></td>
<td>
<p>an integer with the number of iterations without improvement for the stopping criterion (default: 3).</p>
</td></tr>
<tr><td><code id="regIPF_+3A_i">i</code></td>
<td>
<p>a double in [0,1] with the proportion of good samples which must be retained per iteration (default: 0.5).</p>
</td></tr>
<tr><td><code id="regIPF_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regIPF_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regIPF_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In classification, <em>Iterative Partitioning Filter</em> (IPF) builds a classifier with C4.5 on each fold (<code>nfolds</code>) to evaluate the whole dataset.
The noisy samples are removed depending on the chosen voting scheme (indicated by the argument <code>vote</code>): if equal to <code>TRUE</code>,
a consensus voting is used (in which a sample is removed if it is misclassified by all the models); if equal to <code>FALSE</code>,
a majority voting is used (in which a sample is removed if it is misclassified by more than a half of the models).
In addition, IPF integrates an iterative process that stops depending on the arguments <code>p</code>, <code>s</code> and <code>i</code>.
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>T. M. Khoshgoftaar and P. Rebours,
<strong>Improving software quality prediction by noise filtering techniques</strong>,
<em>Journal of Computer Science and Technology</em>, 22:387-396, 2007.
<a href="https://doi.org/10.1007/s11390-007-9054-2">doi:10.1007/s11390-007-9054-2</a>
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regIRF">regIRF</a></code>, <code><a href="#topic+regCVCF">regCVCF</a></code>, <code><a href="#topic+regFMF">regFMF</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regIPF(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regIPF(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regIRF'>Iterative Robust Filter for Regression</h2><span id='topic+regIRF'></span><span id='topic+regIRF.default'></span><span id='topic+regIRF.formula'></span>

<h3>Description</h3>

<p>Application of the regIRF noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regIRF(x, y, t = 0.2, ...)

## S3 method for class 'formula'
regIRF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regIRF_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regIRF_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regIRF_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regIRF_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regIRF_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regIRF_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In classification, <em>Iterative Robust Filter</em> (IRF) builds models with C4.5 from the dataset and
removes misclassified samples until there are no more wrong classifications. The implementation of this noise filter to be used
in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>S. Verbaeten,
<strong>Identifying mislabeled training examples in ILP classification problems</strong>,
<em>Proc. Twelfth Belgian-Dutch Conference on Machine Learning</em>, 71-78, 2002.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regIPF">regIPF</a></code>, <code><a href="#topic+regCVCF">regCVCF</a></code>, <code><a href="#topic+regFMF">regFMF</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regIRF(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regIRF(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regRND'>Regressand Noise Detection for Regression</h2><span id='topic+regRND'></span><span id='topic+regRND.default'></span><span id='topic+regRND.formula'></span>

<h3>Description</h3>

<p>Application of the regRND noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regRND(x, y, t = 0.2, nfolds = 5, vote = FALSE, ...)

## S3 method for class 'formula'
regRND(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regRND_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regRND_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regRND_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regRND_+3A_nfolds">nfolds</code></td>
<td>
<p>an integer with the number of folds in which the dataset is split (default: 10).</p>
</td></tr>
<tr><td><code id="regRND_+3A_vote">vote</code></td>
<td>
<p>a logical indicating if the consensus voting (<code>TRUE</code>) or majority voting (<code>FALSE</code>) is used (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="regRND_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regRND_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regRND_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Regressand Noise Detection</em> (RND) is an adaptation of <em>Class Noise Detection and Classification</em> (CNDC) found in the field of classification.
In a first step, CNDC builds an ensemble with SVM, <em>Random Forest</em>, <em>Naive Bayes</em>, k-NN and <em>Neural Network</em>.
Then, a sample is marked as noisy using a voting scheme (indicated by the argument <code>vote</code>): if equal to <code>TRUE</code>,
a consensus voting is used (in which a sample is marked as noisy if it is misclassified by all the models); if equal to <code>FALSE</code>,
a majority voting is used (in which a sample is marked as noisy if it is misclassified by more than a half of the models).
Then, the decision to remove a sample is made by a distance filtering.
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>Z. Nematzadeh, R. Ibrahim and A. Selamat,
<strong>Improving class noise detection and classification performance: A new two-filter CNDC model</strong>,
<em>Applied Soft Computer</em>, 94:106428, 2020.
<a href="https://doi.org/10.1016/j.asoc.2020.106428">doi:10.1016/j.asoc.2020.106428</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regENN">regENN</a></code>, <code><a href="#topic+regAENN">regAENN</a></code>, <code><a href="#topic+regGE">regGE</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regRND(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regRND(formula = perm ~ ., data = rock[,])

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='regRNN'>Reduced Nearest Neighbors for Regression</h2><span id='topic+regRNN'></span><span id='topic+regRNN.default'></span><span id='topic+regRNN.formula'></span>

<h3>Description</h3>

<p>Application of the regRNN noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
regRNN(x, y, t = 0.2, ...)

## S3 method for class 'formula'
regRNN(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regRNN_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="regRNN_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="regRNN_+3A_t">t</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by regression noise filter (default: 0.2).</p>
</td></tr>
<tr><td><code id="regRNN_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="regRNN_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="regRNN_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In classification, <em>Reduced Nearest Neighbors</em> (RNN) is an enhancement of CNN that includes one more step,
which removes samples in the dataset that do not affect the performance of the <em>k</em>-NN classifier.
The implementation of this noise filter to be used in regression problems follows the proposal of Martín <em>et al.</em> (2021),
which is based on the use of a noise threshold (<code>t</code>) to determine the similarity between the output variable of the samples.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>G. Gates,
<strong>The reduced nearest neighbor rule (Corresp.)</strong>,
<em>IEEE Transactions on Information Theory</em>, 18:431-433, 1972.
<a href="https://doi.org/10.1109/TIT.1972.1054809">doi:10.1109/TIT.1972.1054809</a>.
</p>
<p>J. Martín, J. A. Sáez and E. Corchado,
<strong>On the regressand noise problem: Model robustness and synergy with regression-adapted noise filters.</strong>
<em>IEEE Access</em>, 9:145800-145816, 2021.
<a href="https://doi.org/10.1109/ACCESS.2021.3123151">doi:10.1109/ACCESS.2021.3123151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regCNN">regCNN</a></code>, <code><a href="#topic+regBBNR">regBBNR</a></code>, <code><a href="#topic+regENN">regENN</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- regRNN(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- regRNN(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='rfCDF'>Covering Distance Filtering for Regression</h2><span id='topic+rfCDF'></span><span id='topic+rfCDF.default'></span><span id='topic+rfCDF.formula'></span>

<h3>Description</h3>

<p>Application of the rfCDF noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rfCDF(x, y, subsets = 5, VCdim = 0.1 * nrow(x), prob = 0.05, ...)

## S3 method for class 'formula'
rfCDF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfCDF_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="rfCDF_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="rfCDF_+3A_subsets">subsets</code></td>
<td>
<p>an integer with the number of subsets to be used (default: 5).</p>
</td></tr>
<tr><td><code id="rfCDF_+3A_vcdim">VCdim</code></td>
<td>
<p>an integer specifying the VC-dimension (default: 0.1*<code>nrow(x)</code>).</p>
</td></tr>
<tr><td><code id="rfCDF_+3A_prob">prob</code></td>
<td>
<p>a double with the probability used in the filtering process (default: 0.05).</p>
</td></tr>
<tr><td><code id="rfCDF_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="rfCDF_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="rfCDF_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CDF</code> divides the dataset into two subsets, <em>Din</em> and <em>Dout</em>, which represent samples within and outside the covering interval, respectively. 
Samples in <em>Din</em> are considered to have low noise and are retained in the final clean set of samples. 
Then, the noise of each sample is estimated using the <em>Covering Distance</em> function. 
Samples in <em>Dout</em> can be removed one by one based on their absolute noise, with samples exhibiting larger noise removed first. 
Each time a new sample is removed, an objective function can be estimated. 
Finally, the removing operation is stopped at the maximum value of the objective function.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>G. Jiang, W. Wang, Y. Qian, J. Liang,
<strong>A Unified Sample Selection Framework for Output Noise Filtering: An Error-Bound Perspective.</strong>
<em>Journal of Machine Learning Research</em>, 22:1–65, 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regEF">regEF</a></code>, <code><a href="#topic+regIPF">regIPF</a></code>, <code><a href="#topic+regGE">regGE</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- rfCDF(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- rfCDF(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='rfDROP2'>Decremental Reduction Optimization Procedure for Regression</h2><span id='topic+rfDROP2'></span><span id='topic+rfDROP2.default'></span><span id='topic+rfDROP2.formula'></span>

<h3>Description</h3>

<p>Application of the rfDROP2 noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rfDROP2(x, y, k = 5, ...)

## S3 method for class 'formula'
rfDROP2(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfDROP2_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="rfDROP2_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="rfDROP2_+3A_k">k</code></td>
<td>
<p>an integer with the number of nearest neighbors to be used (default: 5).</p>
</td></tr>
<tr><td><code id="rfDROP2_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="rfDROP2_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="rfDROP2_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rfDROP2</code> tests the prediction of an edited dataset <code>S</code> over the original dataset <code>T</code>. 
The noise filter removes an instance <code>p</code> only if its exclusion does not increase the prediction error of its associates.
This is measured by comparing the accumulation of errors with and without <code>p</code> in the dataset.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>A. Arnaiz-González, J. Díez-Pastor, J. Rodríguez, C. García-Osorio,
<strong>Instance selection for regression: Adapting DROP.</strong>,
<em>Neurocomputing</em>, 201:66-81, 2016.
<a href="https://doi.org/10.1016/j.neucom.2016.04.003">doi:10.1016/j.neucom.2016.04.003</a>.
</p>
<p>D. Randall, T. Martinez,
<strong>Instance pruning techniques.</strong>
<em>Machine Learning: Proceedings of the Fourteenth International Conference</em>, 404–411, 1997.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfDROP3">rfDROP3</a></code>, <code><a href="#topic+regRNN">regRNN</a></code>, <code><a href="#topic+regCNN">regCNN</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- rfDROP2(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- rfDROP2(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='rfDROP3'>Decremental Reduction Optimization Procedure 3 for Regression</h2><span id='topic+rfDROP3'></span><span id='topic+rfDROP3.default'></span><span id='topic+rfDROP3.formula'></span>

<h3>Description</h3>

<p>Application of the rfDROP3 noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rfDROP3(x, y, k = 5, ...)

## S3 method for class 'formula'
rfDROP3(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfDROP3_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="rfDROP3_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="rfDROP3_+3A_k">k</code></td>
<td>
<p>an integer with the number of nearest neighbors to be used (default: 5).</p>
</td></tr>
<tr><td><code id="rfDROP3_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="rfDROP3_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="rfDROP3_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rfDROP3</code> works on the basis of <code><a href="#topic+rfDROP2">rfDROP2</a></code>, which removes an instance <code>p</code> only if its exclusion does not increase the prediction error of its associates.
This is measured by comparing the accumulation of errors with and without <code>p</code> in the dataset. 
<code>rfDROP3</code> integrates a initial noise filtering with <code><a href="#topic+regENN">regENN</a></code>, and then sorts instances based on distance to the nearest enemy.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>A. Arnaiz-González, J. Díez-Pastor, J. Rodríguez, C. García-Osorio,
<strong>Instance selection for regression: Adapting DROP.</strong>,
<em>Neurocomputing</em>, 201:66-81, 2016.
<a href="https://doi.org/10.1016/j.neucom.2016.04.003">doi:10.1016/j.neucom.2016.04.003</a>.
</p>
<p>D. Randall, T. Martinez,
<strong>Instance pruning techniques.</strong>
<em>Machine Learning: Proceedings of the Fourteenth International Conference</em>, 404–411, 1997.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfDROP2">rfDROP2</a></code>, <code><a href="#topic+regENN">regENN</a></code>, <code><a href="#topic+regRNN">regRNN</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- rfDROP3(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- rfDROP3(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='rfMIF'>Mutual Information-based Filter for Regression</h2><span id='topic+rfMIF'></span><span id='topic+rfMIF.default'></span><span id='topic+rfMIF.formula'></span>

<h3>Description</h3>

<p>Application of the rfMIF noise filtering method in a regression dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rfMIF(x, y, k = 5, alpha = 0.05, ...)

## S3 method for class 'formula'
rfMIF(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfMIF_+3A_x">x</code></td>
<td>
<p>a data frame of input attributes.</p>
</td></tr>
<tr><td><code id="rfMIF_+3A_y">y</code></td>
<td>
<p>a double vector with the output regressand of each sample.</p>
</td></tr>
<tr><td><code id="rfMIF_+3A_k">k</code></td>
<td>
<p>an integer with the number of nearest neighbors to be used (default: 5).</p>
</td></tr>
<tr><td><code id="rfMIF_+3A_alpha">alpha</code></td>
<td>
<p>a double in [0,1] with the <em>threshold</em> used by rfMIF (default: 0.05).</p>
</td></tr>
<tr><td><code id="rfMIF_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="rfMIF_+3A_formula">formula</code></td>
<td>
<p>a formula with the output regressand and, at least, one input attribute.</p>
</td></tr>
<tr><td><code id="rfMIF_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rfMIF</code> filter harnesses mutual information to enhance the prototypes within the training set. 
First, it identifies the <em>k</em>-nearest neighbors for each data point. 
Subsequently, mutual information values are calculated and standardized between 0 and 1. 
<code>rfMIF</code> then compares the mutual information of each data point to its <em>k</em>-nearest neighbors. 
If the discrepancy surpasses a threshold (<code>alpha</code>), the sample is considered noisy.
</p>


<h3>Value</h3>

<p>The result of applying the regression filter is a reduced dataset containing the clean samples (without errors or noise), since it removes noisy samples (those with errors).
This function returns an object of class <code>rfdata</code>, which contains information related to the noise filtering process in the form of a list with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>Note that objects of the class <code>rfdata</code> support <a href="#topic+print.rfdata">print.rfdata</a>, <a href="#topic+summary.rfdata">summary.rfdata</a> and <a href="#topic+plot.rfdata">plot.rfdata</a> methods.
</p>


<h3>References</h3>

<p>A. Guillen, L. Herrera, G. Rubio, H. Pomares, A. Lendasse, I. Rojas, 
<strong>New method for instance or prototype selection using mutual information in time series prediction.</strong>,
<em>Neurocomputing</em>, 73:2030-2038, 2010.
<a href="https://doi.org/10.1016/j.neucom.2009.11.031">doi:10.1016/j.neucom.2009.11.031</a>.
</p>
<p>M. Stojanović, M. Božić, M. Stanković, Z. Stajić,
<strong>A methodology for training set instance selection using mutual information in time series prediction.</strong>
<em>Neurocomputing</em>, 141:236-245, 2014.
<a href="https://doi.org/10.1016/j.neucom.2014.03.006">doi:10.1016/j.neucom.2014.03.006</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regENN">regENN</a></code>, <code><a href="#topic+regAENN">regAENN</a></code>, <code><a href="#topic+regCNN">regCNN</a></code>, <code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+summary.rfdata">summary.rfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# usage of the default method
set.seed(9)
out.def &lt;- rfMIF(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# show results
summary(out.def, showid = TRUE)

# usage of the method for class formula
set.seed(9)
out.frm &lt;- rfMIF(formula = perm ~ ., data = rock)

# check the match of noisy indices
all(out.def$idnoise == out.frm$idnoise)

</code></pre>

<hr>
<h2 id='summary.rfdata'>Summary function for class rfdata</h2><span id='topic+summary.rfdata'></span>

<h3>Description</h3>

<p>This methods displays a summary containing information about the noise
filtering process contained in an <code>object</code> of class <code>rfdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rfdata'
summary(object, ..., showid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rfdata_+3A_object">object</code></td>
<td>
<p>an object of class <code>rfdata</code>.</p>
</td></tr>
<tr><td><code id="summary.rfdata_+3A_...">...</code></td>
<td>
<p>other options to pass to the function.</p>
</td></tr>
<tr><td><code id="summary.rfdata_+3A_showid">showid</code></td>
<td>
<p>a logical indicating if the indices of noisy samples must be displayed (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function presents a summary containing information of the regression noise filter and the resulting
dataset contained in the <code>object</code> of class <code>rfdata</code>.
The information offered is as follows:
</p>

<ul>
<li><p> the function call.
</p>
</li>
<li><p> the name of the regression noise filter.
</p>
</li>
<li><p> the parameters associated with the noise filter.
</p>
</li>
<li><p> the number of noisy and clean samples in the dataset.
</p>
</li>
<li><p> the indices of the noisy and clean samples (if <code>showid = TRUE</code>).
</p>
</li></ul>



<h3>Value</h3>

<p>A list including information related to the noise filtering process contained in the object <code>object</code> of class rfdata with the following elements:
</p>
<table>
<tr><td><code>xclean</code></td>
<td>
<p>a data frame with the input attributes of clean samples (without errors).</p>
</td></tr>
<tr><td><code>yclean</code></td>
<td>
<p>a double vector with the output regressand of clean samples (without errors).</p>
</td></tr>
<tr><td><code>numclean</code></td>
<td>
<p>an integer with the amount of clean samples.</p>
</td></tr>
<tr><td><code>idclean</code></td>
<td>
<p>an integer vector with the indices of clean samples.</p>
</td></tr>
<tr><td><code>xnoise</code></td>
<td>
<p>a data frame with the input attributes of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>ynoise</code></td>
<td>
<p>a double vector with the output regressand of noisy samples (with errors).</p>
</td></tr>
<tr><td><code>numnoise</code></td>
<td>
<p>an integer with the amount of noisy samples.</p>
</td></tr>
<tr><td><code>idnoise</code></td>
<td>
<p>an integer vector with the indices of noisy samples.</p>
</td></tr>
<tr><td><code>filter</code></td>
<td>
<p>the full name of the noise filter used.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list of the argument values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
</table>
<p>This list also includes the <code>showid</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.rfdata">print.rfdata</a></code>, <code><a href="#topic+regEF">regEF</a></code>, <code><a href="#topic+regDF">regDF</a></code>, <code><a href="#topic+regHRRF">regHRRF</a></code>, <code><a href="#topic+regIRF">regIRF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the dataset
data(rock)

# apply the regression noise filter
set.seed(9)
output &lt;- regAENN(x = rock[,-ncol(rock)], y = rock[,ncol(rock)])

# print the results
summary(output)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
