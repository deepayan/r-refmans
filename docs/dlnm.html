<!DOCTYPE html><html lang="en"><head><title>Help for package dlnm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dlnm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dlnm-package'>
<p>Distributed Lag Non-linear Models (DLNM)</p></a></li>
<li><a href='#cbPen'><p> Generate Penalty Matrices for a DLNM</p></a></li>
<li><a href='#chicagoNMMAPS'><p> Daily Mortality Weather and Pollution Data for Chicago</p></a></li>
<li><a href='#coef.crosspred'><p> Model Coefficients and their (Co)Variance Matrix of a DLNM</p></a></li>
<li><a href='#cr'><p> Generate a Basis Matrix for Penalized Cubic Regression Splines</p></a></li>
<li><a href='#crossbasis'><p> Generate a Cross-Basis Matrix for a DLNM</p></a></li>
<li><a href='#crosspred'><p> Generate Predictions for a DLNM</p></a></li>
<li><a href='#crossreduce'><p> Reduce the Fit of a DLNM to One-Dimensional Summaries</p></a></li>
<li><a href='#dlnm-internal'><p> Internal Functions for Package dlnm</p></a></li>
<li><a href='#drug'><p> A Trial on the Effect of Time-Varying Doses of a Drug</p></a></li>
<li><a href='#equalknots'><p> Define Knots at Equally-Spaced Values</p></a></li>
<li><a href='#exphist'><p> Define Exposure Histories from an Exposure Profile</p></a></li>
<li><a href='#integer'><p> Generate a Basis Matrix of Indicator Variables for Integer Values</p></a></li>
<li><a href='#lin'><p> Generate a Basis Matrix with a Variable as Linear</p></a></li>
<li><a href='#logknots'><p> Define Knots for Lag Space at Equally-Spaced Log-Values</p></a></li>
<li><a href='#nested'><p> Nested Case-Control Study with a Time-Varying Exposure and a Cancer Outcome</p></a></li>
<li><a href='#onebasis'><p> Generate a Basis Matrix for Different Functions</p></a></li>
<li><a href='#plot.crosspred'><p> Plot Predictions for a DLNM</p></a></li>
<li><a href='#plot.crossreduce'><p> Plot Predictions for a Reduced DLNM</p></a></li>
<li><a href='#poly'><p> Generate a Basis Matrix of Polynomials</p></a></li>
<li><a href='#ps'><p> Generate a Basis Matrix for P-Splines</p></a></li>
<li><a href='#smooth.construct.cb.smooth.spec'><p> Cross-Basis Spline Smooths for a DLNM</p></a></li>
<li><a href='#strata'><p> Generate a Basis Matrix of Indicator Variables</p></a></li>
<li><a href='#thr'><p> Generate a Basis Matrix of Linear Threshold Transformations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Distributed Lag Non-Linear Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of functions for distributed lag linear and non-linear models.</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Gasparrini [aut, cre],
  Ben Armstrong [aut],
  Fabian Scheipl [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio Gasparrini &lt;antonio.gasparrini@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, utils, splines, nlme, mgcv,
tsModel</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival, lme4, gee, geepack, mixmeta</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gasparrini/dlnm">https://github.com/gasparrini/dlnm</a>,
<a href="http://www.ag-myresearch.com/package-dlnm">http://www.ag-myresearch.com/package-dlnm</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-07 10:17:29 UTC; anton</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-07 10:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='dlnm-package'>
Distributed Lag Non-linear Models (DLNM)
</h2><span id='topic+dlnm-package'></span><span id='topic+dlnm'></span>

<h3>Description</h3>

<p>The package <span class="pkg">dlnm</span> contains functions to specify and interpret distributed lag linear (DLMs) and non-linear (DLNMs) models. These functions are used to build basis and cross-basis matrices and then to predict and plot the results of a fitted model.
</p>


<h3>Modelling framework</h3>

<p>Distributed lag non-linear models (DLNMs) represent a modelling framework to describe simultaneously non-linear and delayed dependencies, termed as <em>exposure-lag-response associations</em>. These include models for linear exposure-responses (DLMs) as special cases. The methodology of DLMs and DLNMs was originally developed for time series data, and has been recently extended to other study designs and data structures, compatible with cohort, case-control or longitudinal analyses, amongst others. A thorough methodological overview is given in the references and the package vignettes detailed below.
</p>
<p>The modelling framework is based on the definition of a <em>cross-basis</em>, a bi-dimensional space of functions specifying the dependency along the space of the predictor and along lags. The cross-basis functions are built combining the basis functions for the two dimensions, produced by applying existing or user-defined functions such as splines, polynomials, linear threshold or indicators.
</p>
<p>The application of DLMs and DLNMs requires the availability of predictor values measured at equally-spaced time points. In the original development in time series analysis, these are represented by the ordered series of observations. More generally, the data can be stored in a matrix of <em>exposure histories</em>, where each row represents the lagged values of the predictor for each observation.
</p>
<p>The cross-basis matrix of transformed variables is included in the model formula of a regression model to estimate the associated parameters. The estimation can be carried out with the default regression functions, such as <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code> (package <span class="pkg">mgcv</span>), <code><a href="survival.html#topic+clogit">clogit</a></code> and <code><a href="survival.html#topic+coxph">coxph</a></code> (package <span class="pkg">survival</span>), <code><a href="nlme.html#topic+lme">lme</a></code> (package <span class="pkg">nlme</span>), <code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="lme4.html#topic+glmer">glmer</a></code> (package <span class="pkg">lme4</span>). Estimates are then extracted to obtain predictions and graphical representations which facilitate the interpretation of the results.
</p>


<h3>Functions and data included in the package</h3>

<p>In the standard usage, <code><a href="#topic+crossbasis">crossbasis</a></code> creates two set of basis functions from a time series vector or a matrix of exposure histories to define the relationship in the two dimensions of predictor and lags. This step is performed through a call to the function <code><a href="#topic+onebasis">onebasis</a></code>, which in turn internally calls existing or user-defined functions and produces a basis matrix of class <code>"crossbasis"</code> with specific attributes. Standard choices for the functions in the two dimension are <code><a href="splines.html#topic+ns">ns</a></code> or <code><a href="splines.html#topic+bs">bs</a></code> from package <span class="pkg">splines</span>, or the internal functions <code><a href="#topic+poly">poly</a></code>, <code><a href="#topic+strata">strata</a></code>, <code><a href="#topic+thr">thr</a></code>, <code><a href="#topic+integer">integer</a></code> and <code><a href="#topic+lin">lin</a></code> in <span class="pkg">dlnm</span>. Other existing of user-defined functions can be also chosen. The functions <code><a href="#topic+equalknots">equalknots</a></code> and <code><a href="#topic+logknots">logknots</a></code> can be used for knot placement. The two basis matrices are then combined in a matrix object of class <code>"crossbasis"</code>, containing the transformed variables to be included in the model formula.
</p>
<p>In a more recent development, a penalized version of DLMs and DLNMs can be performed using two alternative approaches. In the <em>external</em> method, the functions <code><a href="#topic+ps">ps</a></code> or <code><a href="#topic+cr">cr</a></code> are called in <code><a href="#topic+crossbasis">crossbasis</a></code> to derive the spline transformations, and the function <code><a href="#topic+cbPen">cbPen</a></code> is used to form the list of bi-dimensional penalty matrices. In the <em>internal</em> method, the cross-basis parameterization and matrix penalization are obtained directly using <code><a href="#topic+smooth.construct.cb.smooth.spec">smooth.construct.cb.smooth.spec</a></code>, a specific smooth constructor of class <code>"cb"</code>. This is used within the function <code><a href="mgcv.html#topic+s">s</a></code> in the model formula. In both cases, the model is fitted using the regression function <code><a href="mgcv.html#topic+gam">gam</a></code> in <span class="pkg">mgcv</span>.
</p>
<p>After the model fitting, <code><a href="#topic+crosspred">crosspred</a></code> generates predictions for a set of suitable values of the original predictor and lag period, and stores them in a <code>"crosspred"</code> object. The function <code><a href="#topic+exphist">exphist</a></code> can be used to generate exposure histories for predictions. The fit of a DLM or DLNM can be reduced and re-expressed as the chosen function of one of the two dimensions through the function <code><a href="#topic+crossreduce">crossreduce</a></code>. It returns a <code>"crossreduce"</code> object storing the new parameters and predictions.
</p>
<p>Method functions are available for objects <code>"onebasis"</code>, <code>"crossbasis"</code>, <code>"crosspred"</code> and <code>"crossreduce"</code>. Specific <code><a href="#topic+summary.crossbasis">summary</a></code> methods summarize the content of each object. The plotting functions <code><a href="#topic+plot.crosspred">plot</a></code>, <code><a href="#topic+lines.crosspred">lines</a></code> and <code><a href="#topic+points.crosspred">points</a></code>, offer a set of choices to plot the results, while <code><a href="#topic+coef.crosspred">coef</a></code> and <code><a href="#topic+vcov.crosspred">vcov</a></code> return the coefficients and associated (co)variance matrix for a (optionally reduced) model.
</p>
<p>The data set <code><a href="#topic+chicagoNMMAPS">chicagoNMMAPS</a></code> is provided to perform examples of use of <span class="pkg">dlnm</span> in time series analysis. It includes time series data of daily mortality counts, weather and pollution variables for Chicago in the period 1987-2000. The data sets <code><a href="#topic+nested">nested</a></code> and <code><a href="#topic+drug">drug</a></code> include simulated data to illustrate the extension of <span class="pkg">dlnm</span> to other study designs, specifically nested case-controls and randomized controlled trials. The former contains information on 300 risk sets each with one cancer case and one matched control, and an occupational exposure collected in 5-year periods. The latter contains information on 200 subjects who are randomly allocated a different dose of a drug for two out of four weeks, with their outcome measured after 28 days.
</p>


<h3>Additional information</h3>

<p>Additonal details on the package <span class="pkg">dlnm</span> are available in the vignettes included in the installation. These documents offer a detailed description of the capabilities of the package, and some examples of application to real data, with an extensive illustration of the use of the functions.
</p>
<p>The vignette <strong>dlnmOverview</strong> offers a general illustration of the DLM/DLNM methodology and the functions included in the package. The vignette <strong>dlnmTS</strong> illustrates specific examples on the use of the functions for time series analysis. The vignette <strong>dlnmExtended</strong> provides some examples on the extension of the methodology and package in other study designs and on the use of user-written functions. The vignette <strong>dlnmPenalized</strong> describes the definition of DLMs and DLNMs through penalized splines.
</p>
<p>A vignette is available by typing:
</p>
<p><code>vignette("dlnmOverview")</code>
</p>
<p>A list of changes included in the current and previous versions can be found by typing:
</p>
<p><code>news(package="dlnm")</code>
</p>
<p>The <span class="pkg">dlnm</span> package is available on the Comprehensive R Archive Network (CRAN), with info at the related web page (<a href="https://CRAN.R-project.org/package=dlnm">CRAN.R-project.org/package=dlnm</a>). A development website is available on GitHub (<a href="https://github.com/gasparrini/dlnm">github.com/gasparrini/dlnm</a>). General information on the development and applications of the DLM/DLNM modelling framework, together with an updated version of the <span class="rlang"><b>R</b></span> scripts for running the examples in published papers, can be found on GitHub (<a href="https://github.com/gasparrini">github.com/gasparrini</a>) or at the personal web page of the package maintainer (<a href="http://www.ag-myresearch.com">www.ag-myresearch.com</a>).
</p>
<p>Please use <code>citation("dlnm")</code> to cite this package.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini and Ben Armstrong, with contributions from Fabian Scheipl
</p>
<p>Maintainer: Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;
</p>


<h3>References</h3>

<p>Gasparrini A. Distributed lag linear and non-linear models in R: the package dlnm. <em>Journal of Statistical Software</em>. 2011;<b>43</b>(8):1-20. [freely available <a href="http://www.ag-myresearch.com/2011_gasparrini_jss.html">here</a>].
</p>
<p>Gasparrini A, Scheipl F, Armstrong B, Kenward MG. A penalized framework for distributed lag non-linear models. <em>Biometrics</em>. 2017;<b>73</b>(3):938-948. [freely available <a href="http://www.ag-myresearch.com/2017_gasparrini_biomet.html">here</a>]
</p>
<p>Gasparrini A. Modelling lagged associations in environmental time series data: a simulation study. <em>Epidemiology</em>. 2016;<b>27</b>(6):835-842. [freely available <a href="http://www.ag-myresearch.com/2016_gasparrini_epidem.html">here</a>]
</p>
<p>Gasparrini A. Modeling exposure-lag-response associations with distributed lag non-linear models. <em>Statistics in Medicine</em>. 2014;<b>33</b>(5):881-899. [freely available <a href="http://www.ag-myresearch.com/2014_gasparrini_statmed.html">here</a>]
</p>
<p>Gasparrini A, Armstrong, B, Kenward MG. Distributed lag non-linear models. <em>Statistics in Medicine</em>. 2010;<b>29</b>(21):2224-2234. [freely available <a href="http://www.ag-myresearch.com/2010_gasparrini_statmed.html">here</a>]
</p>
<p>Gasparrini A, Armstrong B, Kenward MG. Reducing and meta-analyzing estimates from distributed lag non-linear models.<em>BMC Medical Research Methodology</em>. 2013;<b>13</b>(1):1. [freely available <a href="http://www.ag-myresearch.com/2013_gasparrini_bmcmrm.html">here</a>].
</p>
<p>Armstrong B. Models for the relationship between ambient temperature and daily mortality. <em>Epidemiology</em>. 2006;<b>17</b>(6):624-31. [available <a href="https://pubmed.ncbi.nlm.nih.gov/17028505/">here</a>]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onebasis">onebasis</a></code> to generate simple basis matrices. <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices. <code><a href="#topic+smooth.construct.cb.smooth.spec">cb smooth constructor</a></code> for a penalized version. <code><a href="#topic+crosspred">crosspred</a></code> to obtain predictions after model fitting. <code><a href="#topic+crossreduce">crossreduce</a></code> to reduce the fit to one dimension. The methods <code><a href="#topic+plot.crosspred">plot.crosspred</a></code> and <code><a href="#topic+plot.crossreduce">plot.crossreduce</a></code> to plot several type of graphs.
</p>
<p>Type <code>'vignette(dlnmOverview)'</code> for a detailed description.
</p>

<hr>
<h2 id='cbPen'> Generate Penalty Matrices for a DLNM </h2><span id='topic+cbPen'></span>

<h3>Description</h3>

<p>This function generates penalty matrices for the two dimensions of predictor and lags, given the functions selected to model the relationship in each space. It can also be used for generating the single penalty matrix for the predictor space of a uni-dimensional basis not accouning for lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbPen(cb, sp=-1, addSlag=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbPen_+3A_cb">cb</code></td>
<td>
<p> an object of class <code>"crossbasis"</code> or <code>"onebasis"</code>.</p>
</td></tr>
<tr><td><code id="cbPen_+3A_sp">sp</code></td>
<td>
<p> supplied smoothing parameters. See Details below.</p>
</td></tr>
<tr><td><code id="cbPen_+3A_addslag">addSlag</code></td>
<td>
<p> matrix or vector (or list of matrices and/or vectors) defining additional penalties on the lag structure. See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to perform penalized regression models using the <em>external</em> method. This involves generating the transformation using <code><a href="#topic+crossbasis">crossbasis</a></code> or <code><a href="#topic+onebasis">onebasis</a></code> with functions for penalized splines (either <code><a href="#topic+ps">ps</a></code> or <code><a href="#topic+cr">cr</a></code>). The function <code>cbPen</code> is then called to generate a list of the related penalty matrices. The model is performed by penalizing so-called parametric terms in the <code><a href="mgcv.html#topic+gam">gam</a></code> function of <span class="pkg">mgcv</span>, by including the basis or cross-basis matrix in the regression formula and the list of penalty matrices in its <code>paraPen</code> argument.
</p>
<p>When <code>cb</code> is a cross-basis object, the penalty matrices for the two spaces of predictor and lags are rescaled and expanded accordingly to its tensor product-type structure. A penalty matrix is not defined when using a function different than <code><a href="#topic+ps">ps</a></code> or <code><a href="#topic+cr">cr</a></code>, thus keeping one of the two dimensions unpenalized. 
</p>
<p>Additional penalties on the lag dimension can be added through the argument <code>addSlag</code>, either as a single matrix or a list of matrices. If provided as a vector, this is taken as the diagonal of the penalty matrix and expanded accordingly. These objects must have appropriate dimensions in accordance with the basis matrix for the lag space. 
</p>
<p>All the penalty matrices are also appropriately rescaled to improve the estimation process.
</p>
<p>The vector <code>sp</code> must have the same length as the number of penalties, including additional penalties on the lags, and it is replicated accordingly if of length 1. Positive or zero elements are taken as fixed smoothing parameters. Negative elements signal that these parameters need to be estimated.
</p>


<h3>Value</h3>

<p>A list including penalty matrices plus two vectors <code>rank</code> and <code>sp</code> defining their rank and the smoothing parameters. This list is consistent with the argument <code>paraPen</code> in the regression function <code><a href="mgcv.html#topic+gam">gam</a></code> function of <span class="pkg">mgcv</span>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Gasparrini A, Scheipl F, Armstrong B, Kenward MG. A penalized framework for distributed lag non-linear models. <em>Biometrics</em>. 2017;<b>73</b>(3):938-948. [freely available <a href="http://www.ag-myresearch.com/2017_gasparrini_biomet.html">here</a>]
</p>
<p>Wood S. N. Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press, 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ps">ps</a></code> and <code><a href="#topic+cr">cr</a></code> for penalized spline functions. The <code><a href="#topic+smooth.construct.cb.smooth.spec">cb smooth constructor</a></code> for cross-basis penalized spline smooths.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information, in particular the vignette <strong>dlnmPenalized</strong>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to be added soon
</code></pre>

<hr>
<h2 id='chicagoNMMAPS'> Daily Mortality Weather and Pollution Data for Chicago </h2><span id='topic+chicagoNMMAPS'></span>

<h3>Description</h3>

<p>The data set contains daily mortality (all causes, CVD, respiratory), weather (temperature, dew point temperature, relative humidity) and pollution data (PM10 and ozone) for Chicago in the period 1987-2000 from the National Morbidity, Mortality and Air Pollution Study (NMMAPS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chicagoNMMAPS)</code></pre>


<h3>Format</h3>

<p>A data frame with 5114 observations on the following 14 variables.
</p>

<ul>
<li><p><code>date</code>: Date in the period 1987-2000.
</p>
</li>
<li><p><code>time</code>: The sequence of observations
</p>
</li>
<li><p><code>year</code>: Year
</p>
</li>
<li><p><code>month</code>: Month (numeric)
</p>
</li>
<li><p><code>doy</code>: Day of the year
</p>
</li>
<li><p><code>dow</code>: Day of the week (factor)
</p>
</li>
<li><p><code>death</code>: Counts of all cause mortality excluding accident
</p>
</li>
<li><p><code>cvd</code>: Cardiovascular Deaths 
</p>
</li>
<li><p><code>resp</code>: Respiratory Deaths
</p>
</li>
<li><p><code>temp</code>: Mean temperature (in Celsius degrees)
</p>
</li>
<li><p><code>dptp</code>: Dew point temperature
</p>
</li>
<li><p><code>rhum</code>: Mean relative humidity
</p>
</li>
<li><p><code>pm10</code>: PM10
</p>
</li>
<li><p><code>o3</code>: Ozone
</p>
</li></ul>



<h3>Details</h3>

<p>These data represents a subsample of the variables included in the NMMAPS dataset for Chicago.
</p>
<p>The variable <code>temp</code> is derived from the original <code>tmpd</code> after a transformation from Fahrenheit to Celsius. The variables <code>pm10</code> and <code>o3</code> are an approximated reconstruction of the original series, adding the de-trended values and the median of the long term trend. This is the reason they include negative values.
</p>


<h3>Source</h3>

<p>The complete dataset used to be available at the Internet-based Health and Air Pollution Surveillance System (iHAPSS) website, or through the packages <span class="pkg">NMMAPSdata</span> or <span class="pkg">NMMAPSlite</span>. Currently, the data are not available any more and the two packages have been archived.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested">nested</a></code> for an example of analysing exposure-lag-response associations in a nested case-control study. <code><a href="#topic+drug">drug</a></code> for an example of analysing exposure-lag-response associations in a randomized controlled trial.
</p>
<p>The application of DLNMs to this data with more detailed examples are given in vignette <strong>dlnmExtended</strong>.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>

<hr>
<h2 id='coef.crosspred'> Model Coefficients and their (Co)Variance Matrix of a DLNM </h2><span id='topic+coef.crosspred'></span><span id='topic+coef.crossreduce'></span><span id='topic+vcov.crosspred'></span><span id='topic+vcov.crossreduce'></span>

<h3>Description</h3>

<p>These method functions extract the estimated model coefficients and their (co)variance matrix from a DLNM from objects of class <code>"crosspred"</code> and <code>"crossreduce"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'crosspred'
coef(object, ...)

## S3 method for class 'crosspred'
vcov(object, ...)

## S3 method for class 'crossreduce'
coef(object, ...)

## S3 method for class 'crossreduce'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.crosspred_+3A_object">object</code></td>
<td>
<p> an object of class <code>"crosspred"</code> or <code>"crossreduce"</code>.</p>
</td></tr>
<tr><td><code id="coef.crosspred_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>

<hr>
<h2 id='cr'> Generate a Basis Matrix for Penalized Cubic Regression Splines </h2><span id='topic+cr'></span>

<h3>Description</h3>

<p>Generate the basis matrix for cubic regression splines with penalties on the second derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cr(x, df=10, knots=NULL, intercept=FALSE, fx= FALSE, S=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cr_+3A_x">x</code></td>
<td>
<p> the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="cr_+3A_df">df</code></td>
<td>
<p> degrees of freedom, basically the dimension of the basis matrix. If supplied in the absence of <code>knots</code>, it automatically selects <code>df+1-intercept</code> knots at equally-spaced quantiles of <code>x</code>. The minimum allowed is <code>df=3</code>.</p>
</td></tr>
<tr><td><code id="cr_+3A_knots">knots</code></td>
<td>
<p> breakpoints that define the spline. These are generally automatically selected, and not defined by the user. See Details below.</p>
</td></tr>
<tr><td><code id="cr_+3A_intercept">intercept</code></td>
<td>
<p> logical. If <code>TRUE</code>, an intercept is included in the basis matrix. See Details below.</p>
</td></tr>
<tr><td><code id="cr_+3A_fx">fx</code></td>
<td>
<p> logical. If <code>TRUE</code>, it removes the penalization. See Details below.</p>
</td></tr>
<tr><td><code id="cr_+3A_s">S</code></td>
<td>
<p> penalty matrix, usually internally defined if <code>NULL</code> (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has a usage similar to <code><a href="splines.html#topic+bs">bs</a></code> and <code><a href="splines.html#topic+ns">ns</a></code> in the <span class="pkg">splines</span> package. It produces spline transformations, however using a parameterization that represents the splines fit in terms of values at the knots. A penalty matrix is also defined. The same results are returned by the related <code><a href="mgcv.html#topic+smooth.construct.cr.smooth.spec">smooth constructor</a></code> in the package <span class="pkg">mgcv</span>, which is in fact called internally.
</p>
<p>The argument <code>knots</code> defines a vector of knots within the range of the predictor <code>x</code>, by default at equally-spaced quantiles. The penalization is defined on the second derivative of the function through a penalty matrix <code>S</code>.
</p>
<p>Similarly to <code><a href="splines.html#topic+bs">bs</a></code> and <code><a href="splines.html#topic+ns">ns</a></code>, setting <code>intercept=FALSE</code> (default) determines the exclusion of the first transformed variables, and the corresponding first row and column in <code>S</code>, thus avoiding identifiability issues during the model fitting. Note how the procedure of imposing identifiability constraints is different from that adopted by <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code> in the package <span class="pkg">mgcv</span>, where a more complex reparameterization is produced. 
</p>


<h3>Value</h3>

<p>A matrix object of class <code>"cr"</code>. It contains the attributes <code>df</code>, <code>knots</code>, <code>intercept</code>, <code>fx</code>, and <code>S</code>, with values that can be different than the arguments provided due to internal reset.
</p>


<h3>Note</h3>

<p>The function is primarily added here to specify penalized DLMs and DLNMs using the so-called <em>external</em> method, <em>i.e.</em> by including the penalty matrix in the argument <code>paraPen</code> of the <code><a href="mgcv.html#topic+gam">gam</a></code> regression function in <span class="pkg">mgcv</span>  (see <code><a href="#topic+cbPen">cbPen</a></code>). However, this approach can be also used to fit standard uni-dimensional penalized cubic spline models as an alternative to the use of specific <code><a href="mgcv.html#topic+smooth.construct.cr.smooth.spec">smooth constructor</a></code>, as it takes advantage of the use of prediction and plotting functions in <span class="pkg">dlnm</span>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;, with internall calls to functions included in the package <span class="pkg">mgcv</span> by Simon N. Wood.</p>


<h3>References</h3>

<p>Gasparrini A, Scheipl F, Armstrong B, Kenward MG. A penalized framework for distributed lag non-linear models. <em>Biometrics</em>. 2017;<b>73</b>(3):938-948. [freely available <a href="http://www.ag-myresearch.com/2017_gasparrini_biomet.html">here</a>]
</p>
<p>Wood S. N. Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press, 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ps">ps</a></code> for P-splines. <code><a href="splines.html#topic+bs">bs</a></code> and <code><a href="splines.html#topic+ns">ns</a></code> for B-splines and natural cubic splines, respectively. <code><a href="#topic+cbPen">cbPen</a></code> for defining tensor-type bi-dimensional penalties in DLNMs. The related <code><a href="mgcv.html#topic+smooth.construct.cr.smooth.spec">smooth constructor</a></code> for cubic regression spline smooths in <span class="pkg">mgcv</span>. The <code><a href="#topic+smooth.construct.cb.smooth.spec">cb smooth constructor</a></code> for cross-basis penalized spline smooths.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to be added soon
</code></pre>

<hr>
<h2 id='crossbasis'> Generate a Cross-Basis Matrix for a DLNM </h2><span id='topic+crossbasis'></span><span id='topic+summary.crossbasis'></span>

<h3>Description</h3>

<p>The function generates the basis matrices for the two dimensions of predictor and lags, given the functions selected to model the relationship in each space. Then, these one-dimensions basis matrices are combined in order to create the related cross-basis matrix, which can be included in a model formula to fit distributed lag linear (DLMs) and non-linear models (DLNMs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossbasis(x, lag, argvar=list(), arglag=list(), group=NULL, ...)

## S3 method for class 'crossbasis'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossbasis_+3A_x">x</code></td>
<td>
<p> either a numeric vector representing a complete series of ordered observations (for time series data), or a matrix of exposure histories over the same lag period for each observation. See Details below.</p>
</td></tr>
<tr><td><code id="crossbasis_+3A_lag">lag</code></td>
<td>
<p> either an integer scalar or vector of length 2, defining the the maximum lag or the lag range, respectively.</p>
</td></tr>
<tr><td><code id="crossbasis_+3A_argvar">argvar</code>, <code id="crossbasis_+3A_arglag">arglag</code></td>
<td>
<p> lists of arguments to be passed to the function <code><a href="#topic+onebasis">onebasis</a></code> for generating the two basis matrices for predictor and lags, respectively. See Details below.</p>
</td></tr>
<tr><td><code id="crossbasis_+3A_group">group</code></td>
<td>
<p> a factor or a list of factors defining groups of observations. Only for time series data.</p>
</td></tr>
<tr><td><code id="crossbasis_+3A_object">object</code></td>
<td>
<p> a object of class <code>"crossbasis"</code>.</p>
</td></tr>
<tr><td><code id="crossbasis_+3A_...">...</code></td>
<td>
<p> additional arguments. See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> defines the type of data. If a <code class="reqn">n</code>-dimensional vector, the data are interpreted as a time series of equally-spaced and complete observations. If a <code class="reqn">n \times (L-\ell_0+1)</code> matrix, the data are interpreted as a set of complete exposure histories at equally-spaced lags over the same lag period from <code class="reqn">\ell_0</code> to <code class="reqn">L</code> for each observation. The latter is general and can be used for applying DLMs and DLNMs beyond time series data. Lags are usually positive integers: if not provided, by default the minimum lag <code class="reqn">L0</code> is set to 0, and the maximum lag <code class="reqn">L</code> is set to 0 if <code>x</code> is a vector or to <code>ncol(x)-1</code> otherwise. Negative lags are rarely needed but allowed.
</p>
<p>The lists in <code>argvar</code> and <code>arglag</code> are passed to <code><a href="#topic+onebasis">onebasis</a></code>, which calls existing or user-defined functions to build the related basis matrices. The two lists should contain the argument <code>fun</code> defining the chosen function, and a set of additional arguments of the function. The <code>argvar</code> list is applied to <code>x</code>, in order to generate the matrix for the space of the predictor. The <code>arglag</code> list is applied to a new vector given by the sequence obtained by <code>lag</code>, in order to generate the matrix for the space of lags. By default, the basis functions for lags are defined with an intercept (if not otherwise stated). Some arguments can be automatically re-set by <code><a href="#topic+onebasis">onebasis</a></code>. Then, the two set of basis matrices are combined in order to create the related cross-basis matrix.
</p>
<p>Common choices for <code>fun</code> are represented by <code><a href="splines.html#topic+ns">ns</a></code> and <code><a href="splines.html#topic+bs">bs</a></code> from package <span class="pkg">splines</span> or by the internal functions of the package <span class="pkg">dlnm</span>, namely <code><a href="#topic+poly">poly</a></code>, <code><a href="#topic+strata">strata</a></code>, <code><a href="#topic+thr">thr</a></code>, <code><a href="#topic+integer">integer</a></code> and <code><a href="#topic+lin">lin</a></code>. In particular, DLMs can be considered a special case of DLNMs with a linear function in <code>argvar</code>. Functions <code><a href="#topic+ps">ps</a></code> and <code><a href="#topic+cr">cr</a></code> are used to specify penalized models with an external method (see <code><a href="#topic+cbPen">cbPen</a></code>). See <code>help(onebasis)</code> and the help pages of these functions for information on the additional arguments to be specified. Also, other existing or user-defined functions can be applied.
</p>
<p>The argument <code>group</code>, only used for time series data, defines groups of observations representing independent series. Each series must be consecutive, complete and ordered.
</p>


<h3>Value</h3>

<p>A matrix object of class <code>"crossbasis"</code> which can be included in a model formula in order to fit a DLM or DLNM. It contains the attributes <code>df</code> (vector of length 2 with the df for each dimension), <code>range</code> (range of the original vector of observations), <code>lag</code> (lag range), <code>argvar</code> and <code>arglag</code> (lists of arguments defining the basis functions in each space, which can be modified if compared to lists used in the call). The method <code>summary.crossbasis</code> returns a summary of the cross-basis matrix and the related attributes, and can be used to check the options for the basis functions chosen for the two dimensions.
</p>


<h3>Warnings</h3>

<p>In previous versions of the package the function adopted a different usage. In particular, the <code>argvar</code> list should not include a <code>cen</code> argument any more (see Note in this help page or <code><a href="#topic+onebasis">onebasis</a></code>). Users are strongly suggested to comply with the current usage, as backward compatibility may be discontinued in future versions of the package.
</p>
<p>Meaningless combinations of arguments in <code>argvar</code> and <code>arglag</code> passed to <code><a href="#topic+onebasis">onebasis</a></code> could lead to collinear variables, with identifiability problems in the model and the exclusion of some of them.
</p>
<p>It is strongly recommended to avoid the inclusion of an intercept in the basis for <code>x</code> (<code>intercept</code> in <code>argvar</code> should be <code>FALSE</code>, as default), otherwise a rank-deficient cross-basis matrix will be specified, causing some of the cross-variables to be excluded in the regression model. Conversely, an intercept is included by default in the basis for the space of lags.
</p>


<h3>Note</h3>

<p>Missing values in <code>x</code> are allowed, but this causes the observation (for non-time series data with <code>x</code> as a matrix) or the following observations corresponding to the lag period (for time series data with <code>x</code> as a vector series) to be set to <code>NA</code>. Although correct, this could generate computational problems in the presence of a high number of missing observations.
</p>
<p>The name of the crossbasis object will be used by <code><a href="#topic+crosspred">crosspred</a></code> in order to extract the related estimated parameters. If more than one variable is transformed through cross-basis functions in the same model, different names must be specified.
</p>
<p>Before version 2.2.0 of <span class="pkg">dlnm</span>, the <code>argvar</code> list could include a <code>cen</code> argument to be passed internally to <code><a href="#topic+onebasis">onebasis</a></code> for centering the basis. This step is now moved to the prediction stage, with a <code>cen</code> argument in <code><a href="#topic+crosspred">crosspred</a></code> or <code><a href="#topic+crossreduce">crossreduce</a></code> (see the related help pages). For backward compatibility, the use of <code>cen</code> in <code>crossbasis</code> is still allowed (with a warning), but may be discontinued in future versions.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Gasparrini A. Distributed lag linear and non-linear models in R: the package dlnm. <em>Journal of Statistical Software</em>. 2011;<b>43</b>(8):1-20. [freely available <a href="http://www.ag-myresearch.com/2011_gasparrini_jss.html">here</a>].
</p>
<p>Gasparrini A, Scheipl F, Armstrong B, Kenward MG. A penalized framework for distributed lag non-linear models. <em>Biometrics</em>. 2017;<b>73</b>(3):938-948. [freely available <a href="http://www.ag-myresearch.com/2017_gasparrini_biomet.html">here</a>]
</p>
<p>Gasparrini A. Modeling exposure-lag-response associations with distributed lag non-linear models. <em>Statistics in Medicine</em>. 2014;<b>33</b>(5):881-899. [freely available <a href="http://www.ag-myresearch.com/2014_gasparrini_statmed.html">here</a>]
</p>
<p>Gasparrini A., Armstrong, B.,Kenward M. G. Distributed lag non-linear models. <em>Statistics in Medicine</em>. 2010;<b>29</b>(21):2224-2234. [freely available <a href="http://www.ag-myresearch.com/2010_gasparrini_statmed.html">here</a>]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onebasis">onebasis</a></code> to generate one-dimensional basis matrices. The <code><a href="#topic+smooth.construct.cb.smooth.spec">cb smooth constructor</a></code> for cross-basis penalized spline smooths. <code><a href="#topic+crosspred">crosspred</a></code> to obtain predictions after model fitting. The method function <code><a href="#topic+plot.crosspred">plot</a></code> to plot several type of graphs.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### example of application in time series analysis - see vignette("dlnmTS")

# create the crossbasis objects and summarize their contents
cb1.pm &lt;- crossbasis(chicagoNMMAPS$pm10, lag=15, argvar=list(fun="lin"),
  arglag=list(fun="poly",degree=4))
cb1.temp &lt;- crossbasis(chicagoNMMAPS$temp, lag=3, argvar=list(df=5),
  arglag=list(fun="strata",breaks=1))
summary(cb1.pm)
summary(cb1.temp)

# run the model and get the predictions for pm10
library(splines)
model1 &lt;- glm(death ~ cb1.pm + cb1.temp + ns(time, 7*14) + dow,
  family=quasipoisson(), chicagoNMMAPS)
pred1.pm &lt;- crosspred(cb1.pm, model1, at=0:20, bylag=0.2, cumul=TRUE)

# plot the lag-response curves for specific and incremental cumulative effects
plot(pred1.pm, "slices", var=10, col=3, ylab="RR", ci.arg=list(density=15,lwd=2),
  main="Lag-response curve for a 10-unit increase in PM10")
plot(pred1.pm, "slices", var=10, col=2, cumul=TRUE, ylab="Cumulative RR",
  main="Lag-response curve of incremental cumulative effects")

### example of application beyond time series - see vignette("dlnmExtended")

# generate the matrix of exposure histories from the 5-year periods
Qnest &lt;- t(apply(nested, 1, function(sub) exphist(rep(c(0,0,0,sub[5:14]), 
  each=5), sub["age"], lag=c(3,40))))

# define the cross-basis
cbnest &lt;- crossbasis(Qnest, lag=c(3,40), argvar=list("bs",degree=2,df=3),
  arglag=list(fun="ns",knots=c(10,30),intercept=FALSE))
summary(cbnest)

# run the model and predict
library(survival)
mnest &lt;- clogit(case~cbnest+strata(riskset), nested)
pnest &lt;- crosspred(cbnest,mnest, cen=0, at=0:20*5)

# bi-dimensional exposure-lag-response association
plot(pnest, zlab="OR", xlab="Exposure", ylab="Lag (years)")
# lag-response curve for dose 60
plot(pnest, var=50, ylab="OR for exposure 50", xlab="Lag (years)", xlim=c(0,40))
# exposure-response curve for lag 10
plot(pnest, lag=5, ylab="OR at lag 5", xlab="Exposure", ylim=c(0.95,1.15))

### example of extended predictions - see vignette("dlnmExtended")

# compute exposure profiles and exposure history
expnested &lt;- rep(c(10,0,13), c(5,5,10))
hist &lt;- exphist(expnested, time=length(expnested), lag=c(3,40))

# predict association with a specific exposure history
pnesthist &lt;- crosspred(cbnest, mnest, cen=0, at=hist)
with(pnesthist, c(allRRfit,allRRlow,allRRhigh))

### example of user-defined functions - see vignette("dlnmExtended")

# define a log function
mylog &lt;- function(x) log(x+1)

# define the cross-basis
cbnest2 &lt;- crossbasis(Qnest, lag=c(3,40), argvar=list("mylog"),
  arglag=list(fun="ns",knots=c(10,30),intercept=FALSE))
summary(cbnest2)

# run the model and predict
mnest2 &lt;- clogit(case~cbnest2+strata(riskset), nested)
pnest2 &lt;- crosspred(cbnest2, mnest2, cen=0, at=0:20*5)

# plot and compare with previous fit
plot(pnest2, zlab="OR", xlab="Exposure", ylab="Lag (years)")
plot(pnest2, var=50, ylab="OR for exposure 50", xlab="Lag (years)", xlim=c(0,40))
lines(pnest, var=50, lty=2)
plot(pnest2, lag=5, ylab="OR at lag 5", xlab="Exposure", ylim=c(0.95,1.15))
lines(pnest, lag=5, lty=2)

### example of penalized models - see vignette("dlnmPenalized")

# to be added soon

</code></pre>

<hr>
<h2 id='crosspred'> Generate Predictions for a DLNM </h2><span id='topic+crosspred'></span><span id='topic+summary.crosspred'></span>

<h3>Description</h3>

<p>The function generates predictions from distributed lag linear (DLMs) and non-linear models (DLNMs). These are interpreted as estimated associations defined on a grid of values of the original predictor and lags, computed versus a reference predictor value. This function can be used more generally to generate predictions and facilitate interpretation for uni-dimensional unlagged models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosspred(basis, model=NULL, coef=NULL, vcov=NULL, model.link=NULL, at=NULL,
  from=NULL, to=NULL, by=NULL, lag, bylag=1, cen=NULL, ci.level=0.95,
  cumul=FALSE)

## S3 method for class 'crosspred'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crosspred_+3A_basis">basis</code></td>
<td>
<p> usually an object of class <code>"crossbasis"</code> or <code>"onebasis"</code>. Alternatively a character string for penalized models. See Details below.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_model">model</code></td>
<td>
<p> a model object for which the prediction is desired. See Details below.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_coef">coef</code>, <code id="crosspred_+3A_vcov">vcov</code>, <code id="crosspred_+3A_model.link">model.link</code></td>
<td>
<p> user-provided coefficients, (co)variance matrix and model link for the prediction. See Details below.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_at">at</code></td>
<td>
<p> either a numeric vector representing the values of a constant exposure throughout the lag period defined by <code>lag</code>, or a matrix of exposure histories over the same lag period used for estimation.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_from">from</code>, <code id="crosspred_+3A_to">to</code></td>
<td>
<p> range of predictor values used for prediction.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_lag">lag</code></td>
<td>
<p> either an integer scalar or vector of length 2, defining the lag range used for prediction. Defalut to values used for estimation.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_by">by</code>, <code id="crosspred_+3A_bylag">bylag</code></td>
<td>
<p> increment of the sequences of predictor and lag values used for prediction.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_cen">cen</code></td>
<td>
<p> logical or a numeric scalar. It specifies the centering value, then used as a reference for predictions. See Details below.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_ci.level">ci.level</code></td>
<td>
<p> confidence level for the computation of confidence intervals.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_cumul">cumul</code></td>
<td>
<p> logical. If <code>TRUE</code>, incremental cumulative associations along (integer) lags are also predicted. See Details.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_object">object</code></td>
<td>
<p> an object of class <code>"crosspred"</code>.</p>
</td></tr>
<tr><td><code id="crosspred_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to <code>summary</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model</code> is the model object including <code>basis</code> in its formula. <code>basis</code> is usually an object representing the cross-basis or basis matrix included in <code>model</code>, preserving its attributes and class. Alternatively, for penalized models fitted with <code><a href="mgcv.html#topic+gam">gam</a></code>, <code>basis</code> can be a character string identifying the first argument of <code><a href="mgcv.html#topic+s">s</a></code> in the model formula (see the <code><a href="#topic+smooth.construct.cb.smooth.spec">cb smooth constructor</a></code>). Examples are provided below in the related section.
</p>
<p>The function computes predictions for specific combinations of predictor and lag values, and the net overall predictions accounting for the whole lag period. By default, predictor values are set internally as approximately 50 equally-spaced points within the range, or alternatively directly defined through <code>at</code> or <code>from</code>/<code>to</code>/<code>by</code>. Lag values are are set by default at all the integer values within the lag period, or determined by <code>lag</code> and <code>bylag</code>.
</p>
<p>The values in <code>at</code> can be provided as a vector, and in this case they are replicated for each lag. As an alternative usage, <code>at</code> can be provided as a matrix of complete exposure histories over the same lag period used for estimation, in order to compute the association with a specific exposure pattern (see also <code><a href="#topic+exphist">exphist</a></code>).
</p>
<p>Predictions are computed versus a reference value, with default values dependent on the function used in <code>basis</code>, or manually set through <code>cen</code>. Briefly, sensible default values are automatically defined for <code><a href="#topic+strata">strata</a></code>, <code><a href="#topic+thr">thr</a></code> and <code><a href="#topic+integer">integer</a></code> (corresponding to the reference region), and for <code><a href="#topic+lin">lin</a></code> (corresponding to 0). For other choices, such as <code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="splines.html#topic+bs">bs</a></code>, <code><a href="#topic+poly">poly</a></code> or other existing or user-defined functions, the centering value is set by default to the mid-range. The inclusion of the intercept in <code>basis</code> term nullifies the centering.
</p>
<p>Exponentiated predictions are included if <code>model.link</code> is equal to <code>"log"</code> or <code>"logit"</code>. Confidence intervals computed using a normal approximation and a confidence level of <code>ci.level</code>. <code>model.link</code> is automatically selected from <code>model</code> for some classes when set to <code>NULL</code> (default), but needs to be provided for different classes. Matrices with incremental cumulative predicted associations along integer lags at each exposure values used for prediction are included if <code>cumul=TRUE</code>.
</p>
<p>The function automatically works with model objects from regression function <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code> (package <span class="pkg">mgcv</span>), <code><a href="survival.html#topic+coxph">coxph</a></code> and <code><a href="survival.html#topic+clogit">clogit</a></code> (package <span class="pkg">survival</span>), <code><a href="nlme.html#topic+lme">lme</a></code> and <code><a href="nlme.html#topic+nlme">nlme</a></code> (package <span class="pkg">nlme</span>), <code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="lme4.html#topic+glmer">glmer</a></code> and <code><a href="lme4.html#topic+nlmer">nlmer</a></code> (package <span class="pkg">lme4</span>), <code><a href="gee.html#topic+gee">gee</a></code> (package <span class="pkg">gee</span>), <code><a href="geepack.html#topic+geeglm">geeglm</a></code> (package <span class="pkg">geepack</span>). The function also works with any regression function for which <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+vcov">vcov</a></code> methods are available. Otherwise, the user needs to input the coefficients and associated (co)variance matrix related to the parameters of the crossbasis as arguments <code>coef</code> and <code>vcov</code>, and information on the link function in <code>model.link</code>. In this case, dimensions and order must match the variables included in <code>basis</code>. 
</p>
<p>The function can be used to compute predictions for models with simple uni-dimensional basis functions not including lag, derived either with <code><a href="#topic+onebasis">onebasis</a></code> or with smooth penalized functions in <code><a href="mgcv.html#topic+gam">gam</a></code>. In this case, only unlagged predicted associations are returned.
</p>


<h3>Value</h3>

<p>A list object of class <code>"crosspred"</code> with the following (optional) components:
</p>
<table role = "presentation">
<tr><td><code>predvar</code></td>
<td>
<p> vector or matrix of values used for prediction, depending on the format of the argument <code>at</code> (see Details above).</p>
</td></tr>
<tr><td><code>cen</code></td>
<td>
<p> (optional) numeric scalar defining the centering value.</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p> integer vector defining the lag range used for prediction.</p>
</td></tr>
<tr><td><code>bylag</code></td>
<td>
<p> increment of the sequence of lag values.</p>
</td></tr>
<tr><td><code>coefficients</code>, <code>vcov</code></td>
<td>
<p> coefficients and their variance-covariance matrix.</p>
</td></tr>
<tr><td><code>matfit</code>, <code>matse</code></td>
<td>
<p> matrices of predictions and standard errors at the chosen combinations of predictor and lag values.</p>
</td></tr>
<tr><td><code>matlow</code>, <code>mathigh</code></td>
<td>
<p> matrices of confidence intervals for <code>matfit</code>.</p>
</td></tr>
<tr><td><code>allfit</code>, <code>allse</code></td>
<td>
<p> vectors of the overall cumulative predicted association and standard errors.</p>
</td></tr>
<tr><td><code>alllow</code>, <code>allhigh</code></td>
<td>
<p> vectors of confidence intervals for <code>allfit</code>.</p>
</td></tr>
<tr><td><code>cumfit</code>, <code>cumse</code></td>
<td>
<p> matrices of incremental cumulative predicted associations along lags and related standard errors at the chosen combinations of predictor and (integer) lag values. Computed if <code>cumul=TRUE</code>.</p>
</td></tr>
<tr><td><code>cumlow</code>, <code>cumhigh</code></td>
<td>
<p> matrices of confidence intervals for <code>cumfit</code>. Computed if <code>cumul=TRUE</code>.</p>
</td></tr>
<tr><td><code>matRRfit</code></td>
<td>
<p> matrix of exponentiated specific associations from <code>matfit</code>.</p>
</td></tr>
<tr><td><code>matRRlow</code>, <code>matRRhigh</code></td>
<td>
<p> matrices of confidence intervals for <code>matRRfit</code>.</p>
</td></tr>
<tr><td><code>allRRfit</code></td>
<td>
<p> vector of exponentiated overall cumulative associations from <code>allfit</code>.</p>
</td></tr>
<tr><td><code>allRRlow</code>, <code>allRRhigh</code></td>
<td>
<p> vectors of confidence intervals for <code>allRRfit</code>.</p>
</td></tr>
<tr><td><code>cumRRfit</code></td>
<td>
<p> matrix of exponentiated incremental cumulative associations from <code>cumfit</code>. Computed if <code>cumul=TRUE</code>.</p>
</td></tr>
<tr><td><code>cumRRlow</code>, <code>cumRRhigh</code></td>
<td>
<p> matrix of confidence intervals for . Computed if <code>cumul=TRUE</code>.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p> confidence level used for the computation of confidence intervals for <code>cumRRfit</code>.</p>
</td></tr>
<tr><td><code>model.class</code></td>
<td>
<p> class of the model command used for estimation.</p>
</td></tr>
<tr><td><code>model.link</code></td>
<td>
<p> a specification for the model link function.</p>
</td></tr>
</table>
<p>The function <code><a href="#topic+summary.crosspred">summary.crosspred</a></code> returns a summary of the list.
</p>


<h3>Warnings</h3>

<p>In case of collinear variables in the <code>basis</code> object, some of them are discarded and the related parameters not included in <code>model</code>. Then, <code>crosspred</code> will return an error. Check that the specification of the variables is meaningful through <code><a href="#topic+summary.crossbasis">summary.crossbasis</a></code> or <code><a href="#topic+summary.onebasis">summary.onebasis</a></code>.
</p>
<p>The name of the object <code>basis</code>  will be used to extract the related estimated parameters from <code>model</code>. If more than one variable is transformed by cross-basis functions in the same model, different names must be specified.
</p>


<h3>Note</h3>

<p>All the predictions are generated using a reference value, which if not directly specific by <code>cen</code> is given default values corresponding to (approximately) the mid-range point for continuous functions. Before version 2.2.0 of <span class="pkg">dlnm</span>, centering was produced in <code><a href="#topic+onebasis">onebasis</a></code> or <code><a href="#topic+crossbasis">crossbasis</a></code> (see the related help pages), and for backward compatibility this information is kept (with a warning) and used in <code>crosspred</code> unless <code>cen</code> is directly defined as an argument.
</p>
<p>Exponentiated predictions are included if <code>model.link</code> (selected by the user or specified automatically by <code>model</code>) is equal to <code>"log"</code> or <code>"logit"</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Gasparrini A. Distributed lag linear and non-linear models in R: the package dlnm. <em>Journal of Statistical Software</em>. 2011;<b>43</b>(8):1-20. [freely available <a href="http://www.ag-myresearch.com/2011_gasparrini_jss.html">here</a>].
</p>
<p>Gasparrini A, Scheipl F, Armstrong B, Kenward MG. A penalized framework for distributed lag non-linear models. <em>Biometrics</em>. 2017;<b>73</b>(3):938-948. [freely available <a href="http://www.ag-myresearch.com/2017_gasparrini_biomet.html">here</a>]
</p>
<p>Gasparrini A. Modeling exposure-lag-response associations with distributed lag non-linear models. <em>Statistics in Medicine</em>. 2014;<b>33</b>(5):881-899. [freely available <a href="http://www.ag-myresearch.com/2014_gasparrini_statmed.html">here</a>]
</p>
<p>Gasparrini A., Armstrong, B.,Kenward M. G. Distributed lag non-linear models. <em>Statistics in Medicine</em>. 2010;<b>29</b>(21):2224-2234. [freely available <a href="http://www.ag-myresearch.com/2010_gasparrini_statmed.html">here</a>]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onebasis">onebasis</a></code> to generate one-dimensional basis matrices. <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices. <code><a href="#topic+crossreduce">crossreduce</a></code> to reduce the fit to one dimension. 
The method function <code><a href="#topic+plot.crosspred">plot</a></code> to plot several type of graphs.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### example of application in time series analysis - see vignette("dlnmTS")

# seasonal analysis: select summer months only
chicagoNMMAPSseas &lt;- subset(chicagoNMMAPS, month&gt;5 &amp; month&lt;10)

# create the crossbasis objects, including info on groups
cb2.o3 &lt;- crossbasis(chicagoNMMAPSseas$o3, lag=5,
  argvar=list(fun="thr",thr=40.3), arglag=list(fun="integer"),
  group=chicagoNMMAPSseas$year)
cb2.temp &lt;- crossbasis(chicagoNMMAPSseas$temp, lag=10,
  argvar=list(fun="thr",thr=c(15,25)), arglag=list(fun="strata",breaks=c(2,6)),
  group=chicagoNMMAPSseas$year)
summary(cb2.o3)
summary(cb2.temp)

# run the model
library(splines)
model2 &lt;- glm(death ~  cb2.o3 + cb2.temp + ns(doy, 4) + ns(time,3) + dow,
  family=quasipoisson(), chicagoNMMAPSseas)
  
# get the predictions for o3 at specific exposure values
pred2.o3 &lt;- crosspred(cb2.o3, model2, at=c(0:65,40.3,50.3))

# get figures for the overall cumulative association, with ci
pred2.o3$allRRfit["50.3"]
cbind(pred2.o3$allRRlow, pred2.o3$allRRhigh)["50.3",]

# plot the estimated lag-response curve (with 80%CI)
plot(pred2.o3, "slices", var=50.3, ci="bars", type="p", col=2, pch=19,
  ci.level=0.80, main="Lag-response a 10-unit increase above threshold (80CI)")
# plot the estimated overall cumulative exposure-response curve
plot(pred2.o3,"overall",xlab="Ozone", ci="l", col=3, ylim=c(0.9,1.3), lwd=2,
  ci.arg=list(col=1,lty=3), main="Overall cumulative association for 5 lags")
  
# plot the estimated exposure-lag-response surface
plot(pred2.o3, xlab="Ozone", main="3D: default perspective")
plot(pred2.o3, xlab="Ozone", main="3D: different perspective", theta=250, phi=40)

### example of application beyond time series - see vignette("dlnmExtended")

# generate the matrix of exposure histories from the weekly data
Qdrug &lt;- as.matrix(drug[,rep(7:4, each=7)])
colnames(Qdrug) &lt;- paste("lag", 0:27, sep="")

# define the cross-basis
cbdrug &lt;- crossbasis(Qdrug, lag=27, argvar=list("lin"),
  arglag=list(fun="ns",knots=c(9,18)))

# run the model, predict, and show estimates for specific values
mdrug &lt;- lm(out~cbdrug+sex, drug)
pdrug &lt;- crosspred(cbdrug, mdrug, at=0:20*5)
with(pdrug,cbind(allfit,alllow,allhigh)["50",])
pdrug$matfit["20","lag3"]

# bi-dimensional exposure-lag-response association
plot(pdrug, zlab="Effect", xlab="Dose", ylab="Lag (days)")
plot(pdrug, var=60, ylab="Effect at dose 60", xlab="Lag (days)", ylim=c(-1,5))
plot(pdrug, lag=10, ylab="Effect at lag 10", xlab="Dose", ylim=c(-1,5))

### example of extended predictions - see vignette("dlnmExtended")

# dose 20 for 10 days
histdrug &lt;- exphist(rep(20,10), time=10, lag=27)
pdrug4 &lt;- crosspred(cbdrug, mdrug, at=histdrug)
with(pdrug4,c(allfit,alllow,allhigh))

# define exposure profile with weekly exposures to 10, 50, 0 and 20
expdrug &lt;- rep(c(10,50,0,20),c(2,1,1,2)*7)

# define the exposure histories for all the time points
dynhist &lt;- exphist(expdrug, lag=27)

# predict the effects
pdyndrug &lt;- crosspred(cbdrug, mdrug, at=dynhist)

# plot of the evolution of the effects along time given the doses
plot(pdyndrug,"overall", ylab="Effect", xlab="Time (days)", ylim=c(-5,27), 
  xlim=c(1,50))

### example of user-defined functions - see vignette("dlnmExtended")

# define the decay function
fdecay &lt;- function(x, scale=5, ...) {
  basis &lt;- exp(-x/scale)
  attributes(basis)$scale &lt;- scale
  return(basis)
}

# define the cross-basis
cbdrug2 &lt;- crossbasis(Qdrug, lag=27, argvar=list("lin"),
  arglag=list(fun="fdecay",scale=6))
summary(cbdrug2)

# run the model and predict
mdrug2 &lt;- lm(out~cbdrug2+sex, drug)
pdrug2 &lt;- crosspred(cbdrug2, mdrug2, at=0:20*5)

# plot and compare with previous fit
plot(pdrug2, zlab="Effect", xlab="Dose", ylab="Lag (days)")
plot(pdrug2, var=60, ylab="Effect at dose 60", xlab="Lag (days)", ylim=c(-1,5))
lines(pdrug, var=60, lty=2)
plot(pdrug2, lag=10, ylab="Effect at lag 10", xlab="Dose", ylim=c(-1,5))
lines(pdrug, lag=10, lty=2)

### example of general use for regression models - see vignette("dlnmExtended")

# replicate example illustrated in help(ns)
library(splines)
oneheight &lt;- onebasis(women$height, "ns", df=5)
mwomen &lt;- lm(weight ~ oneheight, data=women)
pwomen &lt;- crosspred(oneheight, mwomen, cen=65, at=58:72)
with(pwomen, cbind(allfit, alllow, allhigh)["70",])
plot(pwomen, ci="l", ylab="Weight (lb) difference", xlab="Height (in)", col=4)

# replicate example illustrated in help(gam)
library(mgcv)
dat &lt;- gamSim(1,n=200,dist="poisson",scale=.1)
b2 &lt;- gam(y ~ s(x0,bs="cr") + s(x1,bs="cr") + s(x2,bs="cr") + s(x3,bs="cr"),
  family=poisson, data=dat, method="REML")
plot(b2, select=3)
pgam &lt;- crosspred("x2", b2, cen=0, at=0:100/100)
with(pgam, cbind(allRRfit, allRRlow, allRRhigh)["0.7",])
plot(pgam, ylim=c(0,3), ylab="RR", xlab="x2", col=2)

### example of penalized models - see vignette("dlnmPenalized")

# to be added soon

</code></pre>

<hr>
<h2 id='crossreduce'> Reduce the Fit of a DLNM to One-Dimensional Summaries </h2><span id='topic+crossreduce'></span><span id='topic+summary.crossreduce'></span>

<h3>Description</h3>

<p>The function reduces the fit of bi-dimensional distributed lag linear (DLMs) or non-linear (DLNMs) models to summaries defined in the the dimension of predictor or lags only, and re-expresses it in terms of modified parameters of the one-dimensional basis functions chosen for that space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossreduce(basis, model=NULL, type="overall", value=NULL, coef=NULL, vcov=NULL,
  model.link=NULL, at=NULL, from=NULL, to=NULL, by=NULL, lag, bylag=1, cen=NULL,
  ci.level=0.95)
  
## S3 method for class 'crossreduce'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossreduce_+3A_basis">basis</code></td>
<td>
<p> an object of class <code>"crossbasis"</code>.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_model">model</code></td>
<td>
<p> a model object for which the reduction and prediction are desired. See Details below.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_coef">coef</code>, <code id="crossreduce_+3A_vcov">vcov</code>, <code id="crossreduce_+3A_model.link">model.link</code></td>
<td>
<p> user-provided coefficients, (co)variance matrix and model link for the reduction and then prediction. See Details below.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_type">type</code></td>
<td>
<p> type of reduction. Possible options are <code>"overall"</code> (default) for reduction to the overall cumulative exposure-response association, <code>"lag"</code> for reduction to a lag-specific exposure-response association, or <code>"var"</code> for reduction to a predictor-specific lag-response association. See Details below.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_value">value</code></td>
<td>
<p> the single value of predictor or lag at which predictor-specific or lag-specific associations must be defined, respectively. See Details below.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_at">at</code></td>
<td>
<p> vector of values used for prediction in the dimension of predictor.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_from">from</code>, <code id="crossreduce_+3A_to">to</code></td>
<td>
<p> range of predictor values used for prediction.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_lag">lag</code></td>
<td>
<p> either an integer scalar or vector of length 2, defining the lag range used for prediction. Defalut to values used for estimation.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_by">by</code>, <code id="crossreduce_+3A_bylag">bylag</code></td>
<td>
<p> increment of the sequences of predictor and lag values used for prediction.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_cen">cen</code></td>
<td>
<p> logical or a numeric scalar. It specifies the centering value, then used as a reference for predictions. See Details below.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_ci.level">ci.level</code></td>
<td>
<p> confidence level for the computation of confidence intervals.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_object">object</code></td>
<td>
<p>  an object of class <code>"crossreduce"</code>.</p>
</td></tr>
<tr><td><code id="crossreduce_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to <code>summary</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dimension to which the fit is reduced is chosen by <code>type</code>, computing summaries for overall cumulative or lag-specific associations defining an exposure-response relationship in the predictor space, or predictor-specific associations defining a lag-response relationship in the lag space. The function re-expresses the original fit of the model, defined by the parameters of the bi-dimensional cross-basis functions, in summaries defined by the one-dimensional basis for the related space and a (usually smaller) set of modified parameters.
</p>
<p>Similarly to <code><a href="#topic+crosspred">crosspred</a></code>, the object <code>basis</code> must be the same containing the cross-basis matrix included in <code>model</code>, with its attributes and class. The function computes predictions for specific values of predictor (for <code>type</code> equal to <code>"overall"</code> and <code>"lag"</code>) or lag (for for <code>type</code> equal to <code>"var"</code>). Values are set to default or chosen thorugh <code>at</code>/<code>from</code>/<code>to</code>/<code>by</code> and <code>lag</code>/<code>bylag</code>, respectively.
</p>
<p>Predictions are computed versus a reference value, with default values dependent on the function used in <code>basis</code>, or manually set through <code>cen</code>. Briefly, sensible default values are automatically defined for <code><a href="#topic+strata">strata</a></code>, <code><a href="#topic+thr">thr</a></code> and <code><a href="#topic+integer">integer</a></code> (corresponding to the reference region), and for <code><a href="#topic+lin">lin</a></code> (corresponding to 0). For other choices, such as <code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="splines.html#topic+bs">bs</a></code>, <code><a href="#topic+poly">poly</a></code> or other existing or user-defined functions, the centering value is set by default to the mid-range. The inclusion of the intercept in <code>basis</code> term nullifies the centering.
</p>
<p>Exponentiated predictions are included if <code>model.link</code> is equal to <code>"log"</code> or <code>"logit"</code>. Confidence intervals computed using a normal approximation and a confidence level of <code>ci.level</code>. <code>model.link</code> is automatically selected from <code>model</code> for some classes when set to <code>NULL</code> (default), but needs to be provided for different classes.
</p>
<p>The function automatically works with model objects from regression function <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code> (package <span class="pkg">mgcv</span>), <code><a href="survival.html#topic+coxph">coxph</a></code> and <code><a href="survival.html#topic+clogit">clogit</a></code> (package <span class="pkg">survival</span>), <code><a href="nlme.html#topic+lme">lme</a></code> and <code><a href="nlme.html#topic+nlme">nlme</a></code> (package <span class="pkg">nlme</span>), <code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="lme4.html#topic+glmer">glmer</a></code> and <code><a href="lme4.html#topic+nlmer">nlmer</a></code> (package <span class="pkg">lme4</span>), <code><a href="gee.html#topic+gee">gee</a></code> (package <span class="pkg">gee</span>), <code><a href="geepack.html#topic+geeglm">geeglm</a></code> (package <span class="pkg">geepack</span>). The function also works with any regression function for which <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+vcov">vcov</a></code> methods are available and return appropriately named objects. Otherwise, the user needs to input the coefficients and associated (co)variance matrix related to the parameters of the crossbasis as arguments <code>coef</code> and <code>vcov</code>. In this case, their dimensions and order must match the variables included in <code>basis</code>.
</p>


<h3>Value</h3>

<p>A list object of class <code>"crossreduce"</code> with the following (optional) components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code>, <code>vcov</code></td>
<td>
<p> reduced parameters of the original fitted model for the chosen dimension.</p>
</td></tr>
<tr><td><code>basis</code></td>
<td>
<p> basis matrix computed at <code>predvar</code> or for the sequence of lags defined by <code>lag</code>, depending on the chosen dimension.</p>
</td></tr>
<tr><td><code>type</code>, <code>value</code></td>
<td>
<p> type of reduction and (optional) value, as arguments above.</p>
</td></tr>
<tr><td><code>cen</code></td>
<td>
<p> (optional) numeric scalar defining the centering value.</p>
</td></tr>
<tr><td><code>predvar</code></td>
<td>
<p> vector of observations used for prediction, if the reduction is in the dimension of predictor.</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p> integer vector defining the lag range.</p>
</td></tr>
<tr><td><code>bylag</code></td>
<td>
<p> increment of the sequence of lag values.</p>
</td></tr>
<tr><td><code>fit</code>, <code>se</code></td>
<td>
<p> vectors of the predicted association and related standard errors.</p>
</td></tr>
<tr><td><code>low</code>, <code>high</code></td>
<td>
<p> vectors of confidence intervals for <code>fit</code>.</p>
</td></tr>
<tr><td><code>RRfit</code></td>
<td>
<p> vector of exponentiated predicted associations from <code>fit</code>.</p>
</td></tr>
<tr><td><code>RRlow</code>, <code>RRhigh</code></td>
<td>
<p> vectors of confidence intervals for <code>RRfit</code>.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p> confidence level used for the computation of confidence intervals.</p>
</td></tr>
<tr><td><code>model.class</code></td>
<td>
<p> class of the model command used for estimation.</p>
</td></tr>
<tr><td><code>model.link</code></td>
<td>
<p> a specification for the model link function.</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>In case of collinear variables in the <code>basis</code> object, some of them are discarded and the related parameters not included in <code>model</code>. Then, <code>crossreduce</code> will return an error. Check that the specification of the variables is meaningful through <code><a href="#topic+summary.crossbasis">summary</a></code>.
</p>
<p>The name of the object <code>basis</code>  will be used to extract the related estimated parameters from <code>model</code>. If more than one variable is transformed by cross-basis functions in the same model, different names must be specified.
</p>


<h3>Note</h3>

<p>All the predictions are generated using a reference value, which if not directly specific by <code>cen</code> is given default values corresponding to (approximately) the mid-range point for continuous functions. Before version 2.2.0 of <span class="pkg">dlnm</span>, centering was produced in <code><a href="#topic+crossbasis">crossbasis</a></code> (see the related help page), and for backward compatibility this information is kept (with a warning) and used in <code>crossreduce</code> unless <code>cen</code> is directly defined as an argument.
</p>
<p>Exponentiated predictions are included if <code>model.link</code> (selected by the user or specified automatically by <code>model</code>) is equal to <code>"log"</code> or <code>"logit"</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Gasparrini A., Armstrong, B., Kenward M. G. Reducing and meta-analyzing estimates from distributed lag non-linear models.<em>BMC Medical Research Methodology</em>. 2013;<b>13</b>(1):1. [freely available <a href="http://www.ag-myresearch.com/2013_gasparrini_bmcmrm.html">here</a>].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices. <code><a href="#topic+crosspred">crosspred</a></code> to obtain predictions after model fitting. The method function <code><a href="#topic+plot.crossreduce">plot</a></code> to plot the association.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the crossbasis object
lagnk &lt;- 3
lagknots &lt;- exp(((1+log(30))/(lagnk+1) * seq(lagnk))-1)
cb4 &lt;- crossbasis(chicagoNMMAPS$temp, lag=30, argvar=list(fun="thr",
  thr=c(10,25)), arglag=list(knots=lagknots))

# # run the model and get the predictions
library(splines)
model4 &lt;- glm(death ~  cb4 + ns(time, 7*14) + dow, family=quasipoisson(),
  chicagoNMMAPS)
pred4 &lt;- crosspred(cb4, model4, by=1)

# reduce to overall cumulative association
redall &lt;- crossreduce(cb4, model4)
summary(redall)
# reduce to exposure-response association for lag 5
redlag &lt;- crossreduce(cb4, model4, type="lag", value=5)
# reduce to lag-response association for value 33
redvar &lt;- crossreduce(cb4, model4, type="var", value=33)

# compare number of parameters
length(coef(pred4))
length(coef(redall))
length(coef(redlag))
length(coef(redvar))

# test
plot(pred4, "overall", xlab="Temperature", ylab="RR",
  ylim=c(0.8,1.6), main="Overall cumulative association")
lines(redall, ci="lines",col=4,lty=2)
legend("top",c("Original","Reduced"),col=c(2,4),lty=1:2,ins=0.1)

# reconstruct the fit in terms of uni-dimensional function
b4 &lt;- onebasis(0:30,knots=attributes(cb4)$arglag$knots,int=TRUE)
pred4b &lt;- crosspred(b4,coef=coef(redvar),vcov=vcov(redvar),model.link="log",by=1)

# test
plot(pred4, "slices", var=33, ylab="RR", ylim=c(0.9,1.2),
  main="Lag-response association at 33C")
lines(redvar, ci="lines", col=4, lty=2)
points(pred4b, pch=19, cex=0.6)
legend("top",c("Original","Reduced","Reconstructed"),col=c(2,4,1),lty=c(1:2,NA),
  pch=c(NA,NA,19),pt.cex=0.6,ins=0.1)
</code></pre>

<hr>
<h2 id='dlnm-internal'> Internal Functions for Package dlnm </h2><span id='topic+fci'></span><span id='topic+findrank'></span><span id='topic+getcoef'></span><span id='topic+getlink'></span><span id='topic+getvcov'></span><span id='topic+mkaddSlag'></span><span id='topic+mkat'></span><span id='topic+mkcen'></span><span id='topic+mklag'></span><span id='topic+mkXpred'></span><span id='topic+seqlag'></span>

<h3>Description</h3>

<p>These functions are called internally by other functions and are not meant to be directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fci(ci, x, high, low, ci.arg, plot.arg, noeff=NULL)

findrank(X)

getcoef(model, class)

getlink(model, class, model.link=NULL)

getvcov(model, class)

mkaddSlag(addSlag, d)

mkat(at, from, to, by, range, lag, bylag)

mkcen(cen, type, basis, range)

mklag(lag)

mkXpred(type, basis, at, predvar, predlag, cen)

seqlag(lag, by=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlnm-internal_+3A_ci">ci</code></td>
<td>
<p> type of confidence intervals representation.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_x">x</code></td>
<td>
<p> the coordinates of the x axis.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_high">high</code>, <code id="dlnm-internal_+3A_low">low</code></td>
<td>
<p> the coordinates of the y axis for the interval.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_ci.arg">ci.arg</code></td>
<td>
<p> list of arguments to draw the confidence intervals.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_plot.arg">plot.arg</code></td>
<td>
<p> list of arguments of the main plot.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_noeff">noeff</code></td>
<td>
<p> reference value of the null effect.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_x">X</code></td>
<td>
<p> a matrix.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_model">model</code></td>
<td>
<p> a regression model object.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_class">class</code></td>
<td>
<p> a regression model class.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_addslag">addSlag</code></td>
<td>
<p> matrix or vector (or list of matrices and/or vectors) defining additional penalties on the lag structure.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_d">d</code></td>
<td>
<p> numeric vector of length 2 providing the cross-basis dimensions.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_at">at</code></td>
<td>
<p> either a numeric vector representing the values of a constant exposure throughout the lag period defined by <code>lag</code>, or a matrix of exposure histories over the same lag period used for estimation.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_from">from</code>, <code id="dlnm-internal_+3A_to">to</code></td>
<td>
<p> range of predictor values used for prediction.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_by">by</code>, <code id="dlnm-internal_+3A_bylag">bylag</code></td>
<td>
<p> increment of the sequences of predictor and lag values used for prediction.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_range">range</code></td>
<td>
<p> range of values used for prediction.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_lag">lag</code></td>
<td>
<p> either an integer scalar or vector of length 2, defining the the maximum lag or the lag range, respectively.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_cen">cen</code></td>
<td>
<p> logical or a numeric scalar. It specifies the centering value, then used as a reference for predictions.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_type">type</code>, <code id="dlnm-internal_+3A_basis">basis</code></td>
<td>
<p> type of model and related basis object from which predictions are needed. See <code><a href="#topic+crosspred">crosspred</a></code>.</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_predvar">predvar</code></td>
<td>
<p> vector or matrix of predictor values used for prediction</p>
</td></tr>
<tr><td><code id="dlnm-internal_+3A_predlag">predlag</code></td>
<td>
<p> vector or matrix of lag values used for prediction</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fci</code> provides different options for representing confidence intervals, and it is called internally in plotting functions.
</p>
<p>The function <code>findrank</code> returns the rank of a matrix.
</p>
<p>The functions <code>getcoef</code>, <code>getlink</code>, and <code>getvcov</code> extract coefficients, the model link, and (co)variance matrix, respectively, depending on the class of the model, and returns a message error if the process fails. They are used internally in <code><a href="#topic+crosspred">crosspred</a></code> and <code><a href="#topic+crossreduce">crossreduce</a></code>.
</p>
<p>The function <code>mkaddSlag</code> returns a list of rescaled penalty matrices defining additional penalties on the lag structure. It is used intenally in functions for performing penalized models.
</p>
<p>The function <code>mkat</code> is used internally in <code><a href="#topic+crosspred">crosspred</a></code> to define the values used for predictions.
</p>
<p>The function <code>mkcen</code> is used internally in <code><a href="#topic+crosspred">crosspred</a></code> to define the centering value for computing predictions.
</p>
<p>The functions <code>mklag</code> is used internally in several other functions to check/define the vector of length 2 representing the lag interval.
</p>
<p>The function <code>mkXpred</code> is used internally in <code><a href="#topic+crosspred">crosspred</a></code> to define the basis or cross-basis matrix for computing predictions.
</p>
<p>The function <code>seqlag</code> is used internally in several other functions to create the vector with the sequence of lags given the range provided.
</p>


<h3>Note</h3>

<p>These and other undocumented internal functions are not exported in the namespace of the package <span class="pkg">dlnm</span>. The user can visualize them through the use of the triple colon operator '<code>:::</code>' or through the function <code><a href="utils.html#topic+getAnywhere">getAnywhere</a></code> (see the examples below).  
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### display internal functions
dlnm:::getcoef
getAnywhere(getcoef)

### display other undocumented functions
dlnm:::fci
getAnywhere(fci)
</code></pre>

<hr>
<h2 id='drug'> A Trial on the Effect of Time-Varying Doses of a Drug </h2><span id='topic+drug'></span>

<h3>Description</h3>

<p>The data set contains simulated data from an hypothetical randomized controlled trial on the effect of time-varying doses of a drug. The study include records for 200 randomized subjects, each receiving doses of a drug randomly allocated in two out of four weeks, with daily doses varying each week. The daily doses are reported on 7-day intervals corresponding to each week.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(drug)</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 7 variables.
</p>

<ul>
<li><p><code>id</code>: subject ID.
</p>
</li>
<li><p><code>out</code>: the outcome level measured at day 28.
</p>
</li>
<li><p><code>sex</code>: the sex of the subject.
</p>
</li>
<li><p><code>day1.7</code>: daily dose for the first week.
</p>
</li>
<li><p><code>day8.14</code>: daily dose for the second week.
</p>
</li>
<li><p><code>day15.21</code>: daily dose for the third week.
</p>
</li>
<li><p><code>day22.28</code>: daily dose for the fourth week.
</p>
</li></ul>



<h3>Details</h3>

<p>The exposure history for each subject (series of daily doses from day 28 to 1) can be recovered by expanding the values given in <code>day1.7</code>-<code>day22.28</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>Source</h3>

<p>This data set only contains simulated data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested">nested</a></code> for an example of nested case-control study data. <code><a href="#topic+chicagoNMMAPS">chicagoNMMAPS</a></code> for an example of time series data.
</p>
<p>The application of DLNMs to these data with detailed examples are provided in the vignette <strong>dlnmExtended</strong>.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>

<hr>
<h2 id='equalknots'> Define Knots at Equally-Spaced Values </h2><span id='topic+equalknots'></span>

<h3>Description</h3>

<p>This function defines the position of knot or cut-off values at equally-spaced values for spline or strata functions, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equalknots(x, nk=NULL, fun="ns", df=1, degree=3, intercept=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equalknots_+3A_x">x</code></td>
<td>
<p> a vector variable.</p>
</td></tr>
<tr><td><code id="equalknots_+3A_nk">nk</code></td>
<td>
<p> number of knots or cut-offs.</p>
</td></tr>
<tr><td><code id="equalknots_+3A_fun">fun</code></td>
<td>
<p> character scalar with the name of the function for which the knots or cut-offs must be created. See Details below.</p>
</td></tr>
<tr><td><code id="equalknots_+3A_df">df</code></td>
<td>
<p> degree of freedom.</p>
</td></tr>
<tr><td><code id="equalknots_+3A_degree">degree</code></td>
<td>
<p> degree of the piecewise polynomial. Only for <code>fun="bs"</code>.</p>
</td></tr>
<tr><td><code id="equalknots_+3A_intercept">intercept</code></td>
<td>
<p> logical. If an intercept is included in the basis function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of knots is set with the argument <code>nk</code>, or otherwise determined by the choice of function and number of degrees of freedom through the arguments <code>fun</code> and <code>df</code>. Specifically, the number of knots is set to <code>df-1-intercept</code> for <code>"ns"</code>, <code>df-degree-intercept</code> for <code>"bs"</code>, or <code>df-intercept</code> for <code>"strata"</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of knot or cut-off values.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+logknots">logknots</a></code> for placing the knots at equally-spaced log values. <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### setting 3 knots for range 0-20
equalknots(20, 3)

### setting knots and cut-offs for different functions
equalknots(20, fun="ns", df=4)
equalknots(20, fun="bs", df=4, degree=2)
equalknots(20, fun="strata", df=4)

### with and without without intercept
equalknots(20, fun="ns", df=4)
equalknots(20, fun="ns", df=4, intercept=TRUE)
</code></pre>

<hr>
<h2 id='exphist'> Define Exposure Histories from an Exposure Profile </h2><span id='topic+exphist'></span>

<h3>Description</h3>

<p>This function builds a matrix of exposure histories given an exposure profile, the time points at which each exposure history is evaluated, and a lag period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exphist(exp, times, lag, fill=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exphist_+3A_exp">exp</code></td>
<td>
<p> an exposure profile defined at equally-spaced time units, from time 1 on.</p>
</td></tr>
<tr><td><code id="exphist_+3A_times">times</code></td>
<td>
<p> either a numeric scalar or vector of  integer numbers specifying the time points at which each exposure history is evaluated. By default, all the time points of <code>exp</code>. See Details.</p>
</td></tr>
<tr><td><code id="exphist_+3A_lag">lag</code></td>
<td>
<p> either an integer scalar or vector of length 2, defining the the maximum lag or the lag range, respectively. By default, the lag period from 0 to <code>length(exp)-1</code>.</p>
</td></tr>
<tr><td><code id="exphist_+3A_fill">fill</code></td>
<td>
<p> value used to fill the exposure history. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to define matrices of exposure histories (backward in time) given an exposure profile (forward in time). Among other uses, this can be applied to define specific exposure histories for obtaining predictions in <code><a href="#topic+crosspred">crosspred</a></code>.
</p>
<p>The exposure profile in <code>exp</code> is assumed to represent a series of exposure events defined forward in time, starting from time 1 and on. An exposure history is then evaluated backward in time for each point defined by <code>times</code> (rounded to integers) on the lag period defined by <code>lag</code>.
</p>
<p>Negative numbers in <code>exp</code> represent time points before the start of the exposure profile, with 0 as the time immediately before, -1 as two times before, and so on. If the values in <code>times</code> are higher than the length of <code>exp</code>, or negative, or if the lag period extends backward before the beginning of the exposure profile, the exposure history is padded with values defined by <code>fill</code>.
</p>


<h3>Value</h3>

<p>A numeric matrix of exposure histories, with named rows corresponding to the values in <code>times</code> and named columns corresponding to the lag period in <code>lag</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Gasparrini A. Modeling exposure-lag-response associations with distributed lag non-linear models. <em>Statistics in Medicine</em>. 2014;<b>33</b>(5):881-899. [freely available <a href="http://www.ag-myresearch.com/2014_gasparrini_statmed.html">here</a>]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crosspred">crosspred</a></code> to obtain predictions after model fitting.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### an exposure history evaluated at a single time
(exp &lt;- sample(1:10))
exphist(exp, 5, 3)
exphist(exp, 5, 12)
exphist(exp, 15, 3)

### use of argument lag
exphist(exp, 10, c(3,7))

### exposure histories evaluated at multiple times
exphist(exp, 3:5, 12)
exphist(exp, lag=12)

### fill with NA's
exphist(exp, lag=12, fill=NA)

### see the vignette dlnmExtended for further examples
</code></pre>

<hr>
<h2 id='integer'> Generate a Basis Matrix of Indicator Variables for Integer Values </h2><span id='topic+integer'></span>

<h3>Description</h3>

<p>The function generates a basis matrix including indicator variables defining intervals for integer values. It is meant to be used internally by <code><a href="#topic+onebasis">onebasis</a></code> and <code><a href="#topic+crossbasis">crossbasis</a></code> and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integer(x, values, intercept=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="integer_+3A_x">x</code></td>
<td>
<p> the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="integer_+3A_values">values</code></td>
<td>
<p> the values for which the indicator variables should be computed. Used internally, usually to be left as missing.</p>
</td></tr>
<tr><td><code id="integer_+3A_intercept">intercept</code></td>
<td>
<p> logical. If <code>TRUE</code>, an intercept is included in the basis matrix. See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns indicator variables for intervals defined by the integer values within the range of <code>x</code>. It is expressly created to specify an unconstrained function in the space of lags for distributed lag linear (DLMs) or non-linear (DLNMs) models, and probably of no use beyond that.
</p>
<p>The argument <code>intercept</code> determines the presence of an intercept. If <code>FALSE</code>, the interval corresponding to the first value in <code>values</code> is excluded, and the parameterization is indentical to dummy variables with the first group as a reference.
</p>


<h3>Value</h3>

<p>A matrix object of class <code>"integer"</code>. It contains the attributes <code>values</code> and <code>intercept</code>.</p>


<h3>Note</h3>

<p>This function is mainly used internally thorugh <code><a href="#topic+onebasis">onebasis</a></code> to create basis matrices. It is not exported in the namespace to avoid conflicts with the function with the same name in the package <span class="pkg">base</span>, and can be accessed through the triple colon operator '<code>:::</code>' (see Examples below).
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+onebasis">onebasis</a></code> to generate basis matrices and <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### simple use (accessing non-exported function through ':::')
dlnm:::integer(1:5)
dlnm:::integer(1:5, intercept=TRUE)
</code></pre>

<hr>
<h2 id='lin'> Generate a Basis Matrix with a Variable as Linear </h2><span id='topic+lin'></span>

<h3>Description</h3>

<p>The function generates a basis matrix including a linear un-transformed variable. It is meant to be used internally by <code><a href="#topic+onebasis">onebasis</a></code> and <code><a href="#topic+crossbasis">crossbasis</a></code> and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin(x, intercept=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lin_+3A_x">x</code></td>
<td>
<p> the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="lin_+3A_intercept">intercept</code></td>
<td>
<p> logical. If <code>TRUE</code>, an intercept is included in the basis matrix, namely a vector of 1's.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a basis matrix with the un-transformed variable, optionally with an intercept if <code>intercept=TRUE</code>.
</p>


<h3>Value</h3>

<p>A matrix object of class <code>"lin"</code>. It contains the attribute <code>intercept</code>.
</p>


<h3>Note</h3>

<p>This function is mainly used internally thorugh <code><a href="#topic+onebasis">onebasis</a></code> to create basis matrices. It is not exported in the namespace, and can be accessed through the triple colon operator '<code>:::</code>' (see Examples below). 
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+onebasis">onebasis</a></code> to generate basis matrices and <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### simple use (accessing non-exported function through ':::')
dlnm:::lin(1:5)
dlnm:::lin(1:5, intercept=TRUE)

### use as an internal function in onebasis (note the centering)
b &lt;- onebasis(chicagoNMMAPS$pm10, "lin")
summary(b)
model &lt;- glm(death ~ b, family=quasipoisson(), chicagoNMMAPS)
pred &lt;- crosspred(b, model, at=0:60)
plot(pred, xlab="PM10", ylab="RR", main="RR for PM10")
</code></pre>

<hr>
<h2 id='logknots'> Define Knots for Lag Space at Equally-Spaced Log-Values </h2><span id='topic+logknots'></span>

<h3>Description</h3>

<p>This function defines the position of knot or cut-off values at equally-spaced log-values for spline or strata functions, respectively. It is expressely created for lag-response functions to set the knots or cut-offs placements accordingly with the default of versions of <span class="pkg">dlnm</span> earlier than 2.0.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logknots(x, nk=NULL, fun="ns", df=1, degree=3, intercept=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logknots_+3A_x">x</code></td>
<td>
<p> an integer scalar or vector of length 2, defining the the maximum lag or the lag range, respectively, or a vector variable.</p>
</td></tr>
<tr><td><code id="logknots_+3A_nk">nk</code></td>
<td>
<p> number of knots or cut-offs.</p>
</td></tr>
<tr><td><code id="logknots_+3A_fun">fun</code></td>
<td>
<p> character scalar with the name of the function for which the knots or cut-offs must be created. See Details below.</p>
</td></tr>
<tr><td><code id="logknots_+3A_df">df</code></td>
<td>
<p> degree of freedom.</p>
</td></tr>
<tr><td><code id="logknots_+3A_degree">degree</code></td>
<td>
<p> degree of the piecewise polynomial. Only for <code>fun="bs"</code>.</p>
</td></tr>
<tr><td><code id="logknots_+3A_intercept">intercept</code></td>
<td>
<p> logical. If an intercept is included in the basis function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions has been included for consistency with versions of <span class="pkg">dlnm</span> earlier than 2.0.0, where the default knots or cut-off placements in the lag space for functions <code>ns</code>, <code>bs</code> and <code>strata</code> used to be at equally-spaced values in the log scale. Since version 2.0.0 on, the default is equally-spaced quantiles, similarly to functions defined for the space of predictor. This function can be used to replicate the results obtained with old versions.
</p>
<p>The argument <code>x</code> is usually assumed to represent the maximum lag (if a scalar) or the lag range (if a vector of length 2). Otherwise is interpreted as a vector variable for which the range is computed internally.
</p>
<p>The number of knots is set with the argument <code>nk</code>, or otherwise determined by the choice of function and number of degrees of freedom through the arguments <code>fun</code> and <code>df</code>. Specifically, the number of knots is set to <code>df-1-intercept</code> for <code>"ns"</code>, <code>df-degree-intercept</code> for <code>"bs"</code>, or <code>df-intercept</code> for <code>"strata"</code>.
</p>
<p>An intercept is included by default (<code>intercept=TRUE</code>), consistently with the default for the lag space.
</p>


<h3>Value</h3>

<p>A numeric vector of knot or cut-off values, to be used in the <code>arglag</code> list argument of <code><a href="#topic+crossbasis">crossbasis</a></code> for reproducing the default of versions of <span class="pkg">dlnm</span> earlier than 2.0.0.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+equalknots">equalknots</a></code> for placing the knots at equally-spaced values. <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### setting 3 knots for lag 0-20
logknots(20, 3)
logknots(c(0,20), 3)

### setting knots and cut-offs for different functions
logknots(20, fun="ns", df=4)
logknots(20, fun="bs", df=4, degree=2)
logknots(20, fun="strata", df=4)

### with and without without intercept
logknots(20, fun="ns", df=4)
logknots(20, fun="ns", df=4, intercept=FALSE)

### replicating an old example in time series analysis
lagknots &lt;- logknots(30, 3)
cb &lt;- crossbasis(chicagoNMMAPS$temp, lag=30, argvar=list(fun="bs",df=5,
  degree=2), arglag=list(knots=lagknots))
summary(cb)
library(splines)
model &lt;- glm(death ~  cb + ns(time, 7*14) + dow, 
  family=quasipoisson(), chicagoNMMAPS)
pred &lt;- crosspred(cb, model, cen=21, by=1)
plot(pred, xlab="Temperature", col="red", zlab="RR", shade=0.6,
  main="3D graph of temperature effect")
</code></pre>

<hr>
<h2 id='nested'> Nested Case-Control Study with a Time-Varying Exposure and a Cancer Outcome </h2><span id='topic+nested'></span>

<h3>Description</h3>

<p>The data set contains simulated data from an hypothetical nested case-control study on the association between a time-varying occupational exposure and a cancer outcome. The study includes 300 risk sets, each with a case and a control matched by age year. The data on the exposure is collected on 5-year age intervals between 15 and 65 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nested)</code></pre>


<h3>Format</h3>

<p>A data frame with 600 observations on the following 14 variables.
</p>

<ul>
<li><p><code>id</code>: subject ID.
</p>
</li>
<li><p><code>case</code>: indicator for case (1) or control (0).
</p>
</li>
<li><p><code>age</code>: age of each subject.
</p>
</li>
<li><p><code>riskset</code>: risk set id.
</p>
</li>
<li><p><code>exp15</code>: yearly exposure in the age period 15-19 year.
</p>
</li>
<li><p><code>exp20</code>: yearly exposure in the age period 20-24 year.
</p>
</li>
<li><p><code>...</code>
</p>
</li>
<li><p><code>exp60</code>: yearly exposure in the age period 60-64 year.
</p>
</li></ul>



<h3>Details</h3>

<p>The exposure history for each subject (series of yearly exposures) can be recovered by expanding the values given in <code>exp15</code>-<code>exp60</code>, and then selecting the values backward from the age of the subject for a given lag period.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>Source</h3>

<p>These nested case-control data were extracted from a simulated cohort with 300 cases of cancer and a time-varying exposure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drug">drug</a></code> for an example of randomized controlled trial data. <code><a href="#topic+chicagoNMMAPS">chicagoNMMAPS</a></code> for an example of time series data.
</p>
<p>The application of DLNMs to these data with detailed examples are provided in the vignette <strong>dlnmExtended</strong>.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>

<hr>
<h2 id='onebasis'> Generate a Basis Matrix for Different Functions </h2><span id='topic+onebasis'></span><span id='topic+summary.onebasis'></span><span id='topic+mkbasis'></span><span id='topic+mklagbasis'></span>

<h3>Description</h3>

<p>The function generates the basis matrix for a predictor vector. The function operates as a wrapper to existing or user-defined functions. Amongst other options, main choices include splines, polynomials, strata and linear threshold functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onebasis(x, fun="ns", ...)

## S3 method for class 'onebasis'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="onebasis_+3A_x">x</code></td>
<td>
<p> the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="onebasis_+3A_fun">fun</code></td>
<td>
<p> character scalar with the name of the function to be called. See Details below.</p>
</td></tr>
<tr><td><code id="onebasis_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to the function specified by <code>fun</code> or to <code>summary</code>.</p>
</td></tr>
<tr><td><code id="onebasis_+3A_object">object</code></td>
<td>
<p> a object of class <code>"onebasis"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>onebasis</code> is a wrapper to existing functions which are called internally to produce different types of basis matrices in a pre-defined format. Its main use in the package <span class="pkg">dlnm</span> is to be called by <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices for modelling bi-dimensional exposure-lag-response associations in distributed lag linear (DLMs) and non-linear (DLNMs) models. However, it can be used also for simplifying the modelling and plotting of uni-dimensional exposure-response relationships.
</p>
<p>The function to be called is chosen through the argument <code>fun</code>. Standard choices are:
</p>

<ul>
<li> <p><b><code>"ns"</code></b> and <b><code>"bs"</code></b>: natural cubic B-splines or B-splines of various degree. Performed through a call to functions <code><a href="splines.html#topic+ns">ns</a></code> or <code><a href="splines.html#topic+bs">bs</a></code> from package <span class="pkg">splines</span>. Arguments passed through <code>...</code> may include <code>df</code>, <code>knots</code>, <code>intercept</code>, and <code>Boundary.knots</code>.
</p>
</li>
<li> <p><b><code>"ps"</code></b> and <b><code>"cr"</code></b>: penalized splines with different parameterizations and penalties. Performed through a call to functions <code><a href="#topic+ps">ps</a></code> or <code><a href="#topic+cr">cr</a></code>. Arguments passed through <code>...</code> may include <code>df</code>, <code>knots</code>, <code>degree</code>, <code>intercept</code>, <code>fx</code>, <code>S</code>, and <code>diff</code>.
</p>
</li>
<li> <p><b><code>"poly"</code></b>: polynomials functions. Performed through a call to the internal function <code><a href="#topic+poly">poly</a></code> (be aware that this is different from <code><a href="stats.html#topic+poly">poly</a></code> in the package <span class="pkg">stats</span>). Arguments passed through <code>...</code> may include <code>degree</code>, <code>scale</code> and <code>intercept</code>.
</p>
</li>
<li> <p><b><code>"strata"</code></b>: indicator variables defining strata. Performed through a call to the function <code><a href="#topic+strata">strata</a></code>. Arguments passed through <code>...</code> may include <code>df</code>, <code>breaks</code>, <code>ref</code> and <code>intercept</code>.
</p>
</li>
<li> <p><b><code>"thr"</code></b>: high, low or double linear threshold functions. Performed through a call to the function <code><a href="#topic+thr">thr</a></code>. Arguments passed through <code>...</code> may include <code>thr.value</code>, <code>side</code> and <code>intercept</code>.
</p>
</li>
<li> <p><b><code>"integer"</code></b>: indicator variables for each integer value. Performed through a call to the internal function <code><a href="#topic+integer">integer</a></code> (be aware that this is different from the function <code><a href="base.html#topic+integer">integer</a></code> in the package <span class="pkg">base</span>). Arguments passed through <code>...</code> may include <code>intercept</code>.
</p>
</li>
<li> <p><b><code>"lin"</code></b>: linear functions. Performed through a call to the internal function <code><a href="#topic+lin">lin</a></code>. Arguments passed through <code>...</code> may include <code>intercept</code>.
</p>
</li></ul>

<p>The help pages of the called functions provides additional information. In particular, the option <code>"lin"</code> and <code>"integer"</code> are usually applied for defining constrained and unconstrained DLMs.
</p>
<p>In addition, any other existing or user-defined function can be potentially called through <code>onebasis</code>. The function should have a first argument <code>x</code> defining the vector to be transformed. It also should return a vector or matrix of transformed variables, with attributes including the arguments of the function itself which define the transformations univocally.
</p>


<h3>Value</h3>

<p>A matrix object of class <code>"onebasis"</code> which can be included in a model formula in order to estimate the association. It contains the attributes <code>fun</code>, <code>range</code> (range of the original vector of observations) and additional attributes specific to the chosen function. The method <code>summary.onebasis</code> returns a summary of the basis matrix and the related attributes.
</p>


<h3>Warnings</h3>

<p>Meaningless combinations of arguments could lead to collinear variables, with identifiability problems in the model. The function <code>onebasis</code> does not perform many checks on the arguments provided. The user is expected to provide valid arguments.
</p>


<h3>Note</h3>

<p>This function offers a wide range of options about modelling the shape of the exposure-response relationships, also simplifying or extending the use of existing functions. The function <code><a href="#topic+crosspred">crosspred</a></code> can be called on objects of class <code>"onebasis"</code> in order to obtain predictions and plotting of such uni-dimensional associations. If more than one variable is transformed through <code>onebasis</code> in the same model, different names must be specified. 
</p>
<p>Before version 2.2.0 of <span class="pkg">dlnm</span>, <code>onebasis</code> could include a <code>cen</code> argument for centering the basis. This step is now moved to the prediction stage, with a <code>cen</code> argument in <code><a href="#topic+crosspred">crosspred</a></code> or <code><a href="#topic+crossreduce">crossreduce</a></code> (see the related help pages). For backward compatibility, the use of <code>cen</code> in <code>onebasis</code> is still allowed (with a warning), but may be discontinued in the future.
</p>
<p>This function has replaced the two old functions <code>mkbasis</code> and <code>mklagbasis</code> since version 1.5.0.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Gasparrini A. Distributed lag linear and non-linear models in R: the package dlnm. <em>Journal of Statistical Software</em>. 2011;<b>43</b>(8):1-20. [freely available <a href="http://www.ag-myresearch.com/2011_gasparrini_jss.html">here</a>].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices. <code><a href="#topic+crosspred">crosspred</a></code> to obtain predictions after model fitting. The method function <code><a href="#topic+plot.crosspred">plot</a></code> to plot several type of graphs.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### a polynomial transformation of a simple vector
onebasis(1:5, "poly", degree=3)

### a low linear threshold parameterization, with and without intercept
onebasis(1:5, "thr", thr=3, side="l")
onebasis(1:5, "thr", thr=3, side="l", intercept=TRUE)

### relationship between PM10 and mortality estimated by a step function
b &lt;- onebasis(chicagoNMMAPS$pm10, "strata", breaks=c(20,40))
summary(b)
model &lt;- glm(death ~ b, family=quasipoisson(), chicagoNMMAPS)
pred &lt;- crosspred(b, model, at=0:60)
plot(pred, xlab="PM10", ylab="RR", main="RR for PM10")

### changing the reference in prediction (alternative to argument ref in strata)
pred &lt;- crosspred(b, model, cen=30, at=0:60)
plot(pred, xlab="PM10", ylab="RR", main="RR for PM10, alternative reference")

### relationship between temperature and mortality: double threshold
b &lt;- onebasis(chicagoNMMAPS$temp, "thr", thr=c(10,25))
summary(b)
model &lt;- glm(death ~ b, family=quasipoisson(), chicagoNMMAPS)
pred &lt;- crosspred(b, model, by=1)
plot(pred, xlab="Temperature (C)", ylab="RR", main="RR for temperature")

### extending the example for the 'ns' function in package splines
b &lt;- onebasis(women$height, df=5)
summary(b)
model &lt;- lm(weight ~ b, data=women)
pred &lt;- crosspred(b, model, cen=65)
plot(pred, xlab="Height (in)", ylab="Weight (lb) difference",
  main="Association between weight and height")
  
### use with a user-defined function with proper attributes
mylog &lt;- function(x, scale=min(x, na.rm=TRUE)) {
  basis &lt;- log(x-scale+1)
  attributes(basis)$scale &lt;- scale
  return(basis)
}
mylog(-2:5)
onebasis(-2:5,"mylog")
</code></pre>

<hr>
<h2 id='plot.crosspred'> Plot Predictions for a DLNM </h2><span id='topic+plot.crosspred'></span><span id='topic+lines.crosspred'></span><span id='topic+points.crosspred'></span><span id='topic+crossplot'></span>

<h3>Description</h3>

<p>High and low-level method functions for graphs (3d, contour, slices and overall) of predictions from distributed lag linear (DLMs) and non-linear (DLNMs) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crosspred'
plot(x, ptype, var=NULL, lag=NULL, ci="area", ci.arg,
  ci.level=x$ci.level, cumul=FALSE, exp=NULL, ...)

## S3 method for class 'crosspred'
lines(x, ptype, var=NULL, lag=NULL, ci="n", ci.arg,
  ci.level=x$ci.level, cumul=FALSE, exp=NULL, ...)

## S3 method for class 'crosspred'
points(x, ptype, var=NULL, lag=NULL, ci="n", ci.arg,
  ci.level=x$ci.level, cumul=FALSE, exp=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.crosspred_+3A_x">x</code></td>
<td>
<p> an object of class <code>"crosspred"</code>.</p>
</td></tr>
<tr><td><code id="plot.crosspred_+3A_ptype">ptype</code></td>
<td>
<p> type of plot. Default to <code>"3d"</code> for lagged relationship, otherwise <code>"overall"</code>. Other options are <code>"slices"</code> and <code>"contour"</code>. See Details below.</p>
</td></tr>
<tr><td><code id="plot.crosspred_+3A_var">var</code>, <code id="plot.crosspred_+3A_lag">lag</code></td>
<td>
<p> vectors (for <code>plot</code>) or numeric scalars (for <code>lines</code>-<code>points</code>) of predictor or lag values, respectively, at which specific associations must be plotted. Used only if <code>ptype="slices"</code>.</p>
</td></tr>
<tr><td><code id="plot.crosspred_+3A_ci">ci</code></td>
<td>
<p> type of confidence intervals representation: one of <code>"area"</code>, <code>"bars"</code>, <code>"lines"</code> or <code>"n"</code>. Default to <code>"area"</code> in high level functions, <code>"n"</code> for low-level functions.</p>
</td></tr>
<tr><td><code id="plot.crosspred_+3A_ci.arg">ci.arg</code></td>
<td>
<p> list of arguments to be passed to low-level plotting functions to draw the confidence intervals. See Details.</p>
</td></tr>
<tr><td><code id="plot.crosspred_+3A_ci.level">ci.level</code></td>
<td>
<p> confidence level for the computation of confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.crosspred_+3A_cumul">cumul</code></td>
<td>
<p> logical. If <code>TRUE</code>, incremental cumulative associations along lags are plotted. Used only if <code>type="slices"</code>. See Details.</p>
</td></tr>
<tr><td><code id="plot.crosspred_+3A_exp">exp</code></td>
<td>
<p> logical. It forces the choice about the exponentiation. See Details.</p>
</td></tr>
<tr><td><code id="plot.crosspred_+3A_...">...</code></td>
<td>
<p> optional graphical arguments. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different plots can be obtained by choosing the following values for the argument <code>ptype</code>:
</p>
<p><b><code>"3d"</code></b>: a 3-D plot of predicted associations on the grid of predictor-lag values. Additional graphical arguments can be included, such as <code>theta</code>-<code>phi</code> (perspective), <code>border</code>-<code>shade</code> (surface), <code>xlab</code>-<code>ylab</code>-<code>zlab</code> (axis labelling) or <code>col</code>. See <code><a href="graphics.html#topic+persp">persp</a></code> for additional information.
</p>
<p><b><code>"contour"</code></b>: a contour/level plot of predicted associations on the grid of predictor-lag values.  Additional graphical arguments can be included, such as <code>plot.title</code>-<code>plot.axes</code>-<code>key.title</code> for titles and axis and key labelling. Arguments <code>x</code>-<code>y</code>-<code>z</code> and <code>col</code>-<code>level</code> are automatically set and cannot be specified by the user. See <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> for additional information.
</p>
<p><b><code>"overall"</code></b>: a plot of the overall cumulative exposure-response associations over the whole lag period. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code> and <code><a href="graphics.html#topic+points">points</a></code> for information on additional graphical arguments.
</p>
<p><b><code>"slices"</code></b>: a (optionally multi-panel) plot of exposure-response association(s) for specific lag value(s), and/or lag-response association(s) for specific predictor value(s). Predictor and lag values are chosen by <code>var</code> and <code>lag</code>, respectively. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code> and <code><a href="graphics.html#topic+points">points</a></code> for information on additional graphical arguments.
</p>
<p>The method function <code>plot</code> calls the high-level functions listed above for each <code>ptype</code>, while <code>lines</code>-<code>points</code> add lines or points for <code>ptype</code> equal to <code>"overall"</code> or <code>"slices"</code>. These methods allow a great flexibility in the choice of graphical parameters, specified through arguments of the original plotting functions. Some arguments, if not specified, are set to different default values than the original functions.
</p>
<p>Confidence intervals are plotted for <code>ptype</code> equal to <code>"overall"</code> or <code>"slices"</code>. Their type is determined  by <code>ci</code>, with options <code>"area"</code> (default for <code>plot</code>), <code>"bars"</code>, <code>"lines"</code> or <code>"n"</code> (no confidence intervals, default for <code>points</code> and <code>lines</code>). Their appearance may be modified through <code>ci.arg</code>, a list of arguments passed to to low-level plotting functions: <code><a href="graphics.html#topic+polygon">polygon</a></code> for <code>"area"</code>, <code><a href="graphics.html#topic+segments">segments</a></code> for <code>"bars"</code> and <code><a href="graphics.html#topic+lines">lines</a></code> for <code>"lines"</code>. See the original functions for a complete list of the arguments. This option offers flexibility in the choice of confidence intervals display. As above, some unspecified arguments are set to different default values.
</p>
<p>For <code>ptype="slices"</code>, up to 4 plots for each dimension of predictor and lags are allowed in <code>plot</code>, while for <code>lines</code>-<code>points</code> a single plot in one of the two dimension must be chosen. Incremental cumulative associations along lags are reported if <code>cumul=TRUE</code>: in this case, the same option must have been set to obtain the prediction saved in the <code>crosspred</code> object (see <code><a href="#topic+crosspred">crosspred</a></code>). 
</p>
<p>For a detailed illustration of the use of the functions, see:
</p>
<p><code>vignette("dlnmOverview")</code>
</p>


<h3>Warnings</h3>

<p>The values in <code>var</code> and <code>lag</code> must match those specified in the object <code>crosspred</code> (see <code><a href="#topic+crosspred">crosspred</a></code>).
</p>


<h3>Note</h3>

<p>All the predictions are plotted using a reference value corresponding to the centering point for continuous functions or different values for the other functions (see the related help pages). This is determined by the argument <code>cen</code> in <code><a href="#topic+crosspred">crosspred</a></code>. Exponentiated predictions are returned by default if <code>x$model.link</code> is equal to <code>"log"</code> or <code>"logit"</code>.
</p>
<p>These methods for class <code>"crosspred"</code> have replaced the old function <code>crossplot</code> since version 1.3.0.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Gasparrini A. Distributed lag linear and non-linear models in R: the package dlnm. <em>Journal of Statistical Software</em>. 2011;<b>43</b>(8):1-20. [freely available <a href="http://www.ag-myresearch.com/2011_gasparrini_jss.html">here</a>].
</p>
<p>Gasparrini A, Scheipl F, Armstrong B, Kenward MG. A penalized framework for distributed lag non-linear models. <em>Biometrics</em>. 2017;<b>73</b>(3):938-948. [freely available <a href="http://www.ag-myresearch.com/2017_gasparrini_biomet.html">here</a>]
</p>
<p>Gasparrini A. Modeling exposure-lag-response associations with distributed lag non-linear models. <em>Statistics in Medicine</em>. 2014;<b>33</b>(5):881-899. [freely available <a href="http://www.ag-myresearch.com/2014_gasparrini_statmed.html">here</a>]
</p>
<p>Gasparrini A., Armstrong, B.,Kenward M. G. Distributed lag non-linear models. <em>Statistics in Medicine</em>. 2010;<b>29</b>(21):2224-2234. [freely available <a href="http://www.ag-myresearch.com/2010_gasparrini_statmed.html">here</a>]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices. <code><a href="#topic+crosspred">crosspred</a></code> to obtain predictions after model fitting.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### example of application in time series analysis - see vignette("dlnmTS")

# create the crossbasis object for pm10
cb3.pm &lt;- crossbasis(chicagoNMMAPS$pm10, lag=1, argvar=list(fun="lin"),
  arglag=list(fun="strata"))
  
# create the crossbasis object for temperature
varknots &lt;- equalknots(chicagoNMMAPS$temp,fun="bs",df=5,degree=2)
lagknots &lt;- logknots(30, 3)
cb3.temp &lt;- crossbasis(chicagoNMMAPS$temp, lag=30, argvar=list(fun="bs",
  knots=varknots), arglag=list(knots=lagknots))
  
# summarize
summary(cb3.pm)
summary(cb3.temp)

# run the model and get the predictions for temperature
library(splines)
model3 &lt;- glm(death ~  cb3.pm + cb3.temp + ns(time, 7*14) + dow,
  family=quasipoisson(), chicagoNMMAPS)
pred3.temp &lt;- crosspred(cb3.temp, model3, cen=21, by=1)

# 3-D and contour plots
plot(pred3.temp, xlab="Temperature", zlab="RR", theta=200, phi=40, lphi=30,
  main="3D graph of temperature effect")
plot(pred3.temp, "contour", xlab="Temperature", key.title=title("RR"),
  plot.title=title("Contour plot",xlab="Temperature",ylab="Lag"))

# lag-response curves specific to different temperature values
plot(pred3.temp, "slices", var=-20, ci="n", col=1, ylim=c(0.95,1.25), lwd=1.5,
  main="Lag-response curves for different temperatures, ref. 21C")
for(i in 1:3) lines(pred3.temp, "slices", var=c(0,27,33)[i], col=i+1, lwd=1.5)
legend("topright",paste("Temperature =",c(-20,0,27,33)), col=1:4, lwd=1.5)

# in one plot
plot(pred3.temp, "slices", var=c(-20,0,27,33), lag=c(0,5,15,28), col=4,
  ci.arg=list(density=40,col=grey(0.7)))

### example of application beyond time series - see vignette("dlnmExtended")

# generate the matrix of exposure histories from the 5-year periods
Qnest &lt;- t(apply(nested, 1, function(sub) exphist(rep(c(0,0,0,sub[5:14]), 
  each=5), sub["age"], lag=c(3,40))))

# define the cross-basis
cbnest &lt;- crossbasis(Qnest, lag=c(3,40), argvar=list("bs",degree=2,df=3),
  arglag=list(fun="ns",knots=c(10,30),intercept=FALSE))
summary(cbnest)

# run the model and predict
library(survival)
mnest &lt;- clogit(case~cbnest+strata(riskset), nested)
pnest &lt;- crosspred(cbnest,mnest, at=0:20*5, cen=0)

# bi-dimensional exposure-lag-response association
plot(pnest, zlab="OR", xlab="Exposure", ylab="Lag (years)")
# lag-response curve for dose 60
plot(pnest, var=50, ylab="OR for exposure 50", xlab="Lag (years)", xlim=c(0,40))
# exposure-response curve for lag 10
plot(pnest, lag=5, ylab="OR at lag 5", xlab="Exposure", ylim=c(0.95,1.15))

### example of extended predictions - see vignette("dlnmExtended")

# compute exposure profiles and exposure history
expnested &lt;- rep(c(10,0,13), c(5,5,10))
hist &lt;- exphist(expnested, time=length(expnested), lag=c(3,40))

# predict association with a specific exposure history
pnesthist &lt;- crosspred(cbnest, mnest, cen=0, at=hist)
with(pnesthist, c(allRRfit,allRRlow,allRRhigh))

### example of user-defined functions - see vignette("dlnmExtended")

# define a log function
mylog &lt;- function(x) log(x+1)

# define the cross-basis
cbnest2 &lt;- crossbasis(Qnest, lag=c(3,40), argvar=list("mylog"),
  arglag=list(fun="ns",knots=c(10,30),intercept=FALSE))
summary(cbnest2)

# run the model and predict
mnest2 &lt;- clogit(case~cbnest2+strata(riskset), nested)
pnest2 &lt;- crosspred(cbnest2, mnest2, cen=0, at=0:20*5)

# plot and compare with previous fit
plot(pnest2, zlab="OR", xlab="Exposure", ylab="Lag (years)")
plot(pnest2, var=50, ylab="OR for exposure 50", xlab="Lag (years)", xlim=c(0,40))
lines(pnest, var=50, lty=2)
plot(pnest2, lag=5, ylab="OR at lag 5", xlab="Exposure", ylim=c(0.95,1.15))
lines(pnest, lag=5, lty=2)

### example of general use for regression models - see vignette("dlnmExtended")

# replicate example illustrated in help(ns)
library(splines)
oneheight &lt;- onebasis(women$height, "ns", df=5)
mwomen &lt;- lm(weight ~ oneheight, data=women)
pwomen &lt;- crosspred(oneheight, mwomen, cen=65, at=58:72)
with(pwomen, cbind(allfit, alllow, allhigh)["70",])
plot(pwomen, ci="l", ylab="Weight (lb) difference", xlab="Height (in)", col=4)

# replicate example illustrated in help(gam)
library(mgcv)
dat &lt;- gamSim(1,n=200,dist="poisson",scale=.1)
b2 &lt;- gam(y ~ s(x0,bs="cr") + s(x1,bs="cr") + s(x2,bs="cr") + s(x3,bs="cr"),
  family=poisson, data=dat, method="REML")
plot(b2, select=3)
pgam &lt;- crosspred("x2", b2, cen=0, at=0:100/100)
with(pgam, cbind(allRRfit, allRRlow, allRRhigh)["0.7",])
plot(pgam, ylim=c(0,3), ylab="RR", xlab="x2", col=2)

### example of penalized models - see vignette("dlnmPenalized")

# to be added soon

</code></pre>

<hr>
<h2 id='plot.crossreduce'> Plot Predictions for a Reduced DLNM </h2><span id='topic+plot.crossreduce'></span><span id='topic+lines.crossreduce'></span><span id='topic+points.crossreduce'></span>

<h3>Description</h3>

<p>High and low-level method functions for graphs of predictions from reduced distributed lag linear (DLMs) and non-linear (DLNMs) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crossreduce'
plot(x, ci="area", ci.arg, ci.level=x$ci.level, exp=NULL, ...)

## S3 method for class 'crossreduce'
lines(x, ci="n", ci.arg, ci.level=x$ci.level, exp=NULL, ...)

## S3 method for class 'crossreduce'
points(x, ci="n", ci.arg, ci.level=x$ci.level, exp=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.crossreduce_+3A_x">x</code></td>
<td>
<p> an object of class <code>"crossreduce"</code>.</p>
</td></tr>
<tr><td><code id="plot.crossreduce_+3A_ci">ci</code></td>
<td>
<p> type of confidence intervals representation: one of <code>"area"</code>, <code>"bars"</code>, <code>"lines"</code> or <code>"n"</code>. Default to <code>"area"</code> in high level functions, <code>"n"</code> for low-level functions.</p>
</td></tr>
<tr><td><code id="plot.crossreduce_+3A_ci.arg">ci.arg</code></td>
<td>
<p> list of arguments to be passed to low-level plotting functions to draw the confidence intervals. See Details.</p>
</td></tr>
<tr><td><code id="plot.crossreduce_+3A_ci.level">ci.level</code></td>
<td>
<p> confidence level for the computation of confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.crossreduce_+3A_exp">exp</code></td>
<td>
<p> logical. It forces the choice about the exponentiation. See Details.</p>
</td></tr>
<tr><td><code id="plot.crossreduce_+3A_...">...</code></td>
<td>
<p> optional graphical arguments. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Differently than for plotting functions for <code>crosspred</code> objects (see the method function <code><a href="#topic+plot.crosspred">plot</a></code> for objects of class <code>"crosspred"</code>), the type of the plot is automatically chosen by the dimension and value at which the model has been reduced. Namely, the lag-specific association at the chosen lag value, the predictor-specific association at the chosen predictor value, or the overall cumulative association.
</p>
<p>These methods allow a great flexibility in the choice of graphical parameters, specified through arguments of the original plotting functions. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code> and <code><a href="graphics.html#topic+points">points</a></code> for information on additional graphical arguments. Some arguments, if not specified, are set to different default values than the original functions.
</p>
<p>Confidence intervals are plotted for <code>ptype</code> equal to <code>"overall"</code> or <code>"slices"</code>. Their type is determined  by <code>ci</code>, with options <code>"area"</code> (default for <code>plot</code>), <code>"bars"</code>, <code>"lines"</code> or <code>"n"</code> (no confidence intervals, default for <code>points</code> and <code>lines</code>). Their appearance may be modified through <code>ci.arg</code>, a list of arguments passed to to low-level plotting functions: <code><a href="graphics.html#topic+polygon">polygon</a></code> for <code>"area"</code>, <code><a href="graphics.html#topic+segments">segments</a></code> for <code>"bars"</code> and <code><a href="graphics.html#topic+lines">lines</a></code> for <code>"lines"</code>. See the original functions for a complete list of the arguments. This option offers flexibility in the choice of confidence intervals display. As above, some unspecified arguments are set to different default values.
</p>
<p>For a detailed illustration of the use of the functions, see:
</p>
<p><code>vignette("dlnmOverview")</code>
</p>


<h3>Note</h3>

<p>All the predictions are plotted using a reference value corresponding to the centering point for continuous functions or different values for the other functions (see the related help pages). This is determined by the argument <code>cen</code> in <code><a href="#topic+crossreduce">crossreduce</a></code>. Exponentiated predictions are returned by default if <code>x$model.link</code> is equal to <code>"log"</code> or <code>"logit"</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Gasparrini A., Armstrong, B., Kenward M. G. Reducing and meta-analyzing estimates from distributed lag non-linear models.<em>BMC Medical Research Methodology</em>. 2013;<b>13</b>(1):1. [freely available <a href="http://www.ag-myresearch.com/2013_gasparrini_bmcmrm.html">here</a>].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onebasis">onebasis</a></code> to generate simple basis matrices. <code><a href="#topic+crosspred">crosspred</a></code> to obtain predictions after model fitting. <code><a href="#topic+crossreduce">crossreduce</a></code> to reduce the fit ot one dimension.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the crossbasis object
lagnk &lt;- 3
lagknots &lt;- exp(((1+log(30))/(lagnk+1) * seq(lagnk))-1)
cb4 &lt;- crossbasis(chicagoNMMAPS$temp, lag=30, argvar=list(fun="thr",
  thr=c(10,25)), arglag=list(knots=lagknots))

# # run the model and get the predictions
library(splines)
model4 &lt;- glm(death ~  cb4 + ns(time, 7*14) + dow, family=quasipoisson(),
  chicagoNMMAPS)
pred4 &lt;- crosspred(cb4, model4, by=1)

# reduce to overall cumulative association
redall &lt;- crossreduce(cb4, model4)
summary(redall)
# reduce to exposure-response association for lag 5
redlag &lt;- crossreduce(cb4, model4, type="lag", value=5)
# reduce to lag-response association for value 33
redvar &lt;- crossreduce(cb4, model4, type="var", value=33)

# compare number of parameters
length(coef(pred4))
length(coef(redall))
length(coef(redlag))
length(coef(redvar))

# test
plot(pred4, "overall", xlab="Temperature", ylab="RR",
  ylim=c(0.8,1.6), main="Overall cumulative association")
lines(redall, ci="lines",col=4,lty=2)
legend("top",c("Original","Reduced"),col=c(2,4),lty=1:2,ins=0.1)

# reconstruct the fit in terms of uni-dimensional function
b4 &lt;- onebasis(0:30,knots=attributes(cb4)$arglag$knots,intercept=TRUE)
pred4b &lt;- crosspred(b4,coef=coef(redvar),vcov=vcov(redvar),model.link="log",by=1)

# test
plot(pred4, "slices", var=33, ylab="RR", ylim=c(0.9,1.2),
  main="Lag-response association at 33C")
lines(redvar, ci="lines", col=4, lty=2)
points(pred4b, pch=19, cex=0.6)
legend("top",c("Original","Reduced","Reconstructed"),col=c(2,4,1),lty=c(1:2,NA),
  pch=c(NA,NA,19),pt.cex=0.6,ins=0.1)
</code></pre>

<hr>
<h2 id='poly'> Generate a Basis Matrix of Polynomials </h2><span id='topic+poly'></span>

<h3>Description</h3>

<p>The function generates a basis matrix of polynomial transformations. It is meant to be used internally by <code><a href="#topic+onebasis">onebasis</a></code> and <code><a href="#topic+crossbasis">crossbasis</a></code> and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly(x, degree=1, scale, intercept=FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poly_+3A_x">x</code></td>
<td>
<p> the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="poly_+3A_degree">degree</code></td>
<td>
<p> numerical scalar defining the degree of the polynomial.</p>
</td></tr>
<tr><td><code id="poly_+3A_scale">scale</code></td>
<td>
<p> scaling factor. Default to the maximum of the absolute value of <code>x</code>.</p>
</td></tr>
<tr><td><code id="poly_+3A_intercept">intercept</code></td>
<td>
<p> logical. If <code>TRUE</code>, an intercept is included in the basis matrix. See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predictor vector is scaled by default through the argument <code>scale</code> to avoid numerical problem with powers of very high/low values.
</p>
<p>If <code>intercept=TRUE</code>, an intercept is included in the model, namely an additional variable with a constant value of 1.
</p>


<h3>Value</h3>

<p>A matrix object of class <code>"poly"</code>. It contains the attributes <code>degree</code>, <code>scale</code> and <code>intercept</code>, with values which can be different than the arguments provided due to internal reset.</p>


<h3>Note</h3>

<p>This function is mainly used internally thorugh <code><a href="#topic+onebasis">onebasis</a></code> and <code><a href="#topic+crossbasis">crossbasis</a></code> to create basis and cross-basis matrices, respectively. It is not exported in the namespace to avoid conflicts with the function with the same name in the package <span class="pkg">stats</span>, and can be accessed through the triple colon operator '<code>:::</code>' (see Examples below).
</p>
<p>In particular, the function <code><a href="stats.html#topic+poly">poly</a></code> from the package <span class="pkg">stats</span> cannot be used directly, as it does not store as attributes all the parameters need to univocally define the transformation.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+onebasis">onebasis</a></code> to generate basis matrices and <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### simple use (accessing non-exported function through ':::')
dlnm:::poly(1:5, degree=3)
dlnm:::poly(1:5, degree=3, intercept=TRUE)

### use as an internal function in onebasis
b &lt;- onebasis(chicagoNMMAPS$pm10, "poly", degree=3)
summary(b)
model &lt;- glm(death ~ b, family=quasipoisson(), chicagoNMMAPS)
pred &lt;- crosspred(b, model, at=0:60)
plot(pred, xlab="PM10", ylab="RR", main="RR for PM10")
</code></pre>

<hr>
<h2 id='ps'> Generate a Basis Matrix for P-Splines </h2><span id='topic+ps'></span>

<h3>Description</h3>

<p>Generate the basis matrix for P-splines, namely a B-spline basis with difference penalties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps(x, df=10, knots=NULL, degree=3, intercept=FALSE, fx= FALSE, S=NULL, diff=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ps_+3A_x">x</code></td>
<td>
<p> the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="ps_+3A_df">df</code></td>
<td>
<p> degrees of freedom, basically the dimension of the basis matrix. If supplied in the absence of <code>knots</code>, it automatically selects <code>df+degree+2-intercept</code> equally-spaced knots (within and beyond the range of <code>x</code>). The minimum <code>df</code> allowed is <code>degree+1-intercept</code>.</p>
</td></tr>
<tr><td><code id="ps_+3A_knots">knots</code></td>
<td>
<p> breakpoints that define the spline. These are generally automatically selected, and not defined by the user. See Details below.</p>
</td></tr>
<tr><td><code id="ps_+3A_degree">degree</code></td>
<td>
<p> degree of the piecewise polynomial. Default is 3 for cubic splines.</p>
</td></tr>
<tr><td><code id="ps_+3A_intercept">intercept</code></td>
<td>
<p> logical. If <code>TRUE</code>, an intercept is included in the basis matrix. See Details below.</p>
</td></tr>
<tr><td><code id="ps_+3A_fx">fx</code></td>
<td>
<p> logical. If <code>TRUE</code>, it removes the penalization. See Details below.</p>
</td></tr>
<tr><td><code id="ps_+3A_s">S</code></td>
<td>
<p> penalty matrix, usually internally defined if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="ps_+3A_diff">diff</code></td>
<td>
<p> order difference of the penalty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has a usage similar to <code><a href="splines.html#topic+bs">bs</a></code> and <code><a href="splines.html#topic+ns">ns</a></code> in the <span class="pkg">splines</span> package. It produces B-spline transformations through a call to <code><a href="splines.html#topic+splineDesign">splineDesign</a></code>, plus a difference matrix to define penalties. The same results are returned by the related <code><a href="mgcv.html#topic+smooth.construct.ps.smooth.spec">smooth constructor</a></code> in the package <span class="pkg">mgcv</span>.
</p>
<p>The argument <code>knots</code> defines a vector of knots or (if of length 2) the lower and upper limits between which the splines can be evaluated. However, knots should be usually left automatically selected, and in particular these P-splines only have sense with equally-spaced knots, due to the nature of the penalization. It is important to highlight that, differently from <code><a href="splines.html#topic+bs">bs</a></code> where <em>internal</em> and <em>boundary</em> knots are defined, this function adopts a standard B-spline parameterization, including by default <code>2*(degree+1)</code> knots beyond the range of the variable.
</p>
<p>The penalization is defined on the difference of adjacent coefficients during fitting procedure through a penalty matrix <code>S</code>. The argument <code>diff</code> selects the order difference (with the default 2 determining a second order difference, and 0 producing a ridge penalty), while setting <code>fx=TRUE</code> removes the penalization. 
</p>
<p>Similarly to <code><a href="splines.html#topic+bs">bs</a></code> and <code><a href="splines.html#topic+ns">ns</a></code>, setting <code>intercept=FALSE</code> (default) determines the exclusion of the first transformed variables, and the corresponding first row and column in <code>S</code>, thus avoiding identifiability issues during the model fitting. Note how the procedure of imposing identifiability constraints is different from that adopted by <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code> in the package <span class="pkg">mgcv</span>, where a more complex reparameterization is produced. 
</p>


<h3>Value</h3>

<p>A matrix object of class <code>"ps"</code>. It contains the attributes <code>df</code>, <code>knots</code>, <code>degree</code>, <code>intercept</code>, <code>fx</code>, <code>S</code>, and <code>diff</code>, with values that can be different than the arguments provided due to internal reset.
</p>


<h3>Note</h3>

<p>The function is primarily added here to specify penalized DLMs and DLNMs using the so-called <em>external</em> method, <em>i.e.</em> by including the penalty matrix in the argument <code>paraPen</code> of the <code><a href="mgcv.html#topic+gam">gam</a></code> regression function in <span class="pkg">mgcv</span>  (see <code><a href="#topic+cbPen">cbPen</a></code>). However, this approach can be also used to fit standard uni-dimensional P-spline models as an alternative to the use of specific <code><a href="mgcv.html#topic+smooth.construct.ps.smooth.spec">smooth constructor</a></code>, as it takes advantage of the use of prediction and plotting functions in <span class="pkg">dlnm</span>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;, adapting code available from functions included in the package <span class="pkg">mgcv</span> by Simon N. Wood.</p>


<h3>References</h3>

<p>Gasparrini A, Scheipl F, Armstrong B, Kenward MG. A penalized framework for distributed lag non-linear models. <em>Biometrics</em>. 2017;<b>73</b>(3):938-948. [freely available <a href="http://www.ag-myresearch.com/2017_gasparrini_biomet.html">here</a>]
</p>
<p>Eilers P. H. C. and Marx B. D. Flexible smoothing with B-splines and penalties. <em>Statistical Science</em>. 1996;<b>11</b>(2):89-121.
</p>
<p>Wood S. N. Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press, 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cr">cr</a></code> for penalized cubic regression splines. <code><a href="splines.html#topic+bs">bs</a></code> and <code><a href="splines.html#topic+ns">ns</a></code> for B-splines and natural cubic splines, respectively. <code><a href="#topic+cbPen">cbPen</a></code> for defining tensor-type bi-dimensional penalties in DLNMs. The related <code><a href="mgcv.html#topic+smooth.construct.ps.smooth.spec">smooth constructor</a></code> for P-spline smooths in <span class="pkg">mgcv</span>. The <code><a href="#topic+smooth.construct.cb.smooth.spec">cb smooth constructor</a></code> for cross-basis penalized spline smooths.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to be added soon
</code></pre>

<hr>
<h2 id='smooth.construct.cb.smooth.spec'> Cross-Basis Spline Smooths for a DLNM </h2><span id='topic+smooth.construct.cb.smooth.spec'></span><span id='topic+Predict.matrix.cb.smooth'></span>

<h3>Description</h3>

<p>These are method functions for a smooth class defining bi-dimensional cross-basis splines for penalized distributed lag linear (DLMs) and non-linear (DLNMs) models. The functions are not supposed to be called directly, and the class is usually specified via terms like <code>s(X,L,bs="cb",...)</code> in the formula of the <code><a href="mgcv.html#topic+gam">gam</a></code> function of the package <span class="pkg">mgcv</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cb.smooth.spec'
smooth.construct(object, data, knots)

## S3 method for class 'cb.smooth'
Predict.matrix(object, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.construct.cb.smooth.spec_+3A_object">object</code></td>
<td>
<p> for <code>smooth.construct</code>, an object of class <code>"cb.smooth.spec"</code> usually generated by a call <code>s(X,L,bs="cb",...)</code>. For <code>Predict.matrix</code>, an object of class <code>cb.smooth</code> generated by <code>smooth.construct</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.cb.smooth.spec_+3A_data">data</code></td>
<td>
<p> a list containing just the data (including any by variable) required by this term, with names corresponding to <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.cb.smooth.spec_+3A_knots">knots</code></td>
<td>
<p> a list containing any knots supplied for basis setup &mdash; in same order and with same names as data. It is usually <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These method functions embed tools available in the packages <span class="pkg">dlnm</span> and <span class="pkg">mgcv</span> to perform penalized DLMs and DLNMs. This represent the <em>internal</em> approach to perform such models (see Notes below). Specifically, the models are fitted by including a term <code>s(X,L,bs="cb",...)</code>, defining a basis <code>"cb"</code> for bi-dimensional cross-basis splines, in the formula of the <code><a href="mgcv.html#topic+gam">gam</a></code> function. The constructor function for this class turns this smooth terms into a smooth specification object, which includes the cross-basis matrix (see <code><a href="#topic+crossbasis">crossbasis</a></code>) and the penalty matrices for the two spaces of predictor and lags used in model fitting. Then, <code><a href="#topic+crosspred">crosspred</a></code> uses the predict matrix function for the <code>"cb"</code> basis to obtain predictions, and a graphical representation can be obtained by standard <code><a href="#topic+plot.crosspred">plotting functions</a></code>, similary to unpenalized models.
</p>
<p>The first two arguments <code>X</code> and <code>L</code> in <code><a href="mgcv.html#topic+s">s</a></code> represent a matrix of exposure histories and a matrix of lags. The former, also used in <code><a href="#topic+crossbasis">crossbasis</a></code>, needs to be defined directly even with time series data by lagging the exposure series. The matrix <code>L</code> must have the same dimensions of <code>X</code>, with identical rows representing the sequence of lags. The other arguments of <code><a href="mgcv.html#topic+s">s</a></code> have the same meaning: in particular, <code>k</code> (default to 10), <code>fx</code> (default to <code>FALSE</code>) and <code>sp</code> (default to <code>NULL</code>) can be provided for each marginal basis as vectors of length 2, and similarly <code>m</code> can be provided as a list (see also <code><a href="mgcv.html#topic+te">te</a></code>). No <code>by</code> argument is allowed.
</p>
<p>Extra information can be included in the argument <code>xt</code> of <code><a href="mgcv.html#topic+s">s</a></code>, which accepts a single object or a list of objects. First, an object <code>bs</code> (a vector of length 1 or 2) can be used to specify the smoother for each marginal dimension, with current options restricted to <code>"ps"</code> (<code><a href="mgcv.html#topic+smooth.construct.ps.smooth.spec">P-splines</a></code>, used by default) and/or <code>"cr"</code> (<code><a href="mgcv.html#topic+smooth.construct.cr.smooth.spec">cubic regression splines</a></code>). Second, list objects <code>argvar</code> and <code>arglag</code> can be used to build the marginal bases for predictor and lags by calling other functions (see the same arguments in <code><a href="#topic+crossbasis">crossbasis</a></code>). In particular, these can be used for a more flexible specification of penalized functions (using <code><a href="#topic+ps">ps</a></code> or <code><a href="#topic+cr">cr</a></code>) or for using unpenalized functions for one marginal basis, thus limiting the penalization to one of the two dimensions. Third, the object <code>addSlag</code> can contain a matrix or vector (or list of matrices and/or vectors) defining additional penalties on the lag structure (see <code><a href="#topic+cbPen">cbPen</a></code>).
</p>


<h3>Value</h3>

<p>The smooth constructor function returns an object of classes <code>"cb.smooth"</code> and <code>"tensor.smooth"</code>. Specifically, a list with a similar structure of that returned by the smooth constructor for <code><a href="mgcv.html#topic+smooth.construct.tensor.smooth.spec">tensor product smooths</a></code> (see also <code><a href="mgcv.html#topic+te">te</a></code>).
</p>
<p>The <code>Predict.matrix</code> function return a cross-basis matrix evaluated at specific values used for prediction.
</p>


<h3>Note</h3>

<p>Identifiability constraints are applied to marginal basis for predictor (see <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code>), while the marginal basis for the lag dimension is left untransformed. This involves a re-parameterization with the absorption of constraints into the basis that causes its dimension to decrease by 1. Note that this procedure is similar to that in <code><a href="#topic+crossbasis">crossbasis</a></code>, while it is different than in standard tensor product smooths (see <code><a href="mgcv.html#topic+te">te</a></code>), where identifiability constraints are not applied to the marginal bases.
</p>
<p>Using the default specification with <code>k=10</code> in the smooth terms defined by <code><a href="mgcv.html#topic+s">s</a></code>, the dimension of the cross-basis matrix will be <code class="reqn">(10-1) \times 10 = 90</code> (accounting for identifiability constraints). This is consistent with the rationale that this choice is not important as far as the upper limit for the degrees of freedom in each marginal basis is large enough to represent the underlying relationship (see <code><a href="mgcv.html#topic+choose.k">choose.k</a></code>). Smaller values of <code>k</code> can be used for speeding up the computation, as long as the underlying relationship can be assumed to be smooth enough.
</p>
<p>These method functions provide an <em>internal</em> method for performing penalized DLMs and DLNMs, with the cross-basis spline smoother defined directly in the model formula of <code><a href="mgcv.html#topic+gam">gam</a></code> through a smooth term specified by <code><a href="mgcv.html#topic+s">s</a></code>. The alternative <em>external</em> method relies on the standard use of <code><a href="#topic+crossbasis">crossbasis</a></code> and on the penalization of so-called parametric terms through the argument <code>paraPen</code> of <code><a href="mgcv.html#topic+gam">gam</a></code> (see <code><a href="#topic+cbPen">cbPen</a></code> for details). The two methods are expected to returns almost identical results in most cases. However, while the internal method takes advantage of the full machinery of <span class="pkg">mgcv</span> and plausibly more stable procedures, the external method allows more flexibility and the optional use of user-defined smoothers.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Fabian Scheipl &lt;<a href="mailto:fabian.scheipl@stat.uni-muenchen.de">fabian.scheipl@stat.uni-muenchen.de</a>&gt;</p>


<h3>References</h3>

<p>Gasparrini A, Scheipl F, Armstrong B, Kenward MG. A penalized framework for distributed lag non-linear models. <em>Biometrics</em>. 2017;<b>73</b>(3):938-948. [freely available <a href="http://www.ag-myresearch.com/2017_gasparrini_biomet.html">here</a>]
</p>
<p>Wood S. N. Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press, 2006.
</p>


<h3>See Also</h3>

<p>Smooth constructors for <code><a href="mgcv.html#topic+smooth.construct.ps.smooth.spec">P-splines</a></code> and <code><a href="mgcv.html#topic+smooth.construct.cr.smooth.spec">cubic regression splines</a></code> in <span class="pkg">mgcv</span>. <code><a href="#topic+ps">ps</a></code> and <code><a href="#topic+cr">cr</a></code> for the same functions available in <span class="pkg">dlnm</span>. <code><a href="#topic+cbPen">cbPen</a></code> for defining tensor-type bi-dimensional penalties in DLNMs.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to be added soon
</code></pre>

<hr>
<h2 id='strata'> Generate a Basis Matrix of Indicator Variables </h2><span id='topic+strata'></span>

<h3>Description</h3>

<p>The function generates a basis matrix including indicator variables defining intervals (strata), through dummy parameterization. It is meant to be used internally by <code><a href="#topic+onebasis">onebasis</a></code> and <code><a href="#topic+crossbasis">crossbasis</a></code> and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata(x, df=1, breaks=NULL, ref=1, intercept=FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strata_+3A_x">x</code></td>
<td>
<p> the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="strata_+3A_df">df</code></td>
<td>
<p> dimension of the basis, equal to the number of strata. They depend on <code>breaks</code> if provided.</p>
</td></tr>
<tr><td><code id="strata_+3A_breaks">breaks</code></td>
<td>
<p> internal cut-off points defining the strata as right-open intervals. If provided, they determine <code>df</code>.</p>
</td></tr>
<tr><td><code id="strata_+3A_ref">ref</code></td>
<td>
<p> interval used as reference category. Default to the first stratum. See Details below.</p>
</td></tr>
<tr><td><code id="strata_+3A_intercept">intercept</code></td>
<td>
<p> logical. If <code>TRUE</code>, an intercept is included in the basis matrix. See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The strata are defined by right-open intervals specified through <code>breaks</code>. If these are not provided, a number of intervals defined by <code>df</code> is placed at equally-spaced quantiles. This step is performed through an internal call to <code><a href="base.html#topic+cut">cut</a></code>.
</p>
<p>The argument <code>ref</code> indentifies the reference category, specified by excluding the related stratum in the dummy parameterization of the basis. This defines control-treatment contrasts, where each interval is compared with the baseline (see <code><a href="stats.html#topic+contrast">contrast</a></code>). If set to 0 (when <code>intercept=TRUE</code>), it provides a different parameterization, where each interval has its own baseline.
</p>
<p>If <code>intercept=TRUE</code>, an intercept is included in the model. The default (when <code>ref</code> is different from 0) produces an additional variable with a constant value of 1, representing the baseline.
</p>


<h3>Value</h3>

<p>A matrix object of class <code>"strata"</code>. It contains the attributes <code>df</code>, <code>breaks</code>, <code>ref</code> and <code>intercept</code>, with values which can be different than the arguments provided due to internal reset.</p>


<h3>Note</h3>

<p>This function is mainly used internally thorugh <code><a href="#topic+onebasis">onebasis</a></code> and <code><a href="#topic+crossbasis">crossbasis</a></code> to create basis and cross-basis matrices, respectively. It is not exported in the namespace to avoid conflicts with the function with the same name in the package <span class="pkg">survival</span>, and can be accessed through the triple colon operator '<code>:::</code>' (see Examples below). 
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+onebasis">onebasis</a></code> to generate basis matrices and <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### simple use (accessing non-exported function through ':::')
dlnm:::strata(1:5, breaks=3)
dlnm:::strata(1:5, df=3)
dlnm:::strata(1:5, df=3, intercept=TRUE)
dlnm:::strata(1:5, df=3, ref=2, intercept=TRUE)

### use as an internal function in onebasis
b &lt;- onebasis(chicagoNMMAPS$pm10, "strata", breaks=c(20,40))
summary(b)
model &lt;- glm(death ~ b, family=quasipoisson(), chicagoNMMAPS)
pred &lt;- crosspred(b, model, at=0:60)
plot(pred, xlab="PM10", ylab="RR", main="RR for PM10")
</code></pre>

<hr>
<h2 id='thr'> Generate a Basis Matrix of Linear Threshold Transformations </h2><span id='topic+thr'></span>

<h3>Description</h3>

<p>The function generates a basis matrix including transformed variables through high, low or double linear threshold parameterization. It is meant to be used internally by <code><a href="#topic+onebasis">onebasis</a></code> and <code><a href="#topic+crossbasis">crossbasis</a></code> and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thr(x, thr.value=NULL, side=NULL, intercept=FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thr_+3A_x">x</code></td>
<td>
<p> the predictor variable. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="thr_+3A_thr.value">thr.value</code></td>
<td>
<p> numeric scalar or vector defining the threshold value(s).</p>
</td></tr>
<tr><td><code id="thr_+3A_side">side</code></td>
<td>
<p> type of threshold parameterization: <code>"l"</code> for low, <code>"h"</code> for high, <code>"d"</code> for double. See Details below.</p>
</td></tr>
<tr><td><code id="thr_+3A_intercept">intercept</code></td>
<td>
<p> logical. If <code>TRUE</code>, an intercept is included in the basis matrix. See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A linear threshold function defines a linear relationship beyond a specific threshold. A high linear threshold defines a linear increase above the threshold, while a low linear threshold defines a linear increase below. A double linear threshold includes both of them.
</p>
<p>The argument <code>thr.value</code> is placed at the median if not provided. If <code>side</code> is not provided, the default is <code>side="h"</code> when <code>thr.value</code> is a scalar, <code>side="d"</code> otherwise. Only the minimum (for <code>side="h"</code> and <code>side="l"</code>) and minimum and maximum values (for <code>side="d"</code>) of <code>thr.value</code> are considered.
</p>
<p>If <code>intercept=TRUE</code>, an intercept is included in the model, namely an additional variable with a constant value of 1.
</p>


<h3>Value</h3>

<p>A matrix object of class <code>"thr"</code>. It contains the attributes <code>thr.value</code>, <code>side</code> and <code>intercept</code>, with values which can be different than the arguments provided due to internal reset.</p>


<h3>Note</h3>

<p>This function is mainly used internally thorugh <code><a href="#topic+onebasis">onebasis</a></code> and <code><a href="#topic+crossbasis">crossbasis</a></code> to create basis and cross-basis matrices, respectively. It is not exported in the namespace, and can be accessed through the triple colon operator '<code>:::</code>' (see Examples below).
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+onebasis">onebasis</a></code> to generate basis matrices and <code><a href="#topic+crossbasis">crossbasis</a></code> to generate cross-basis matrices.
</p>
<p>See <code><a href="#topic+dlnm-package">dlnm-package</a></code> for an introduction to the package and for links to package vignettes providing more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### simple use (accessing non-exported function through ':::')
dlnm:::thr(1:5, thr=3)
dlnm:::thr(1:5, side="d")
dlnm:::thr(1:5, side="d", intercept=TRUE)

### use as an internal function in onebasis
b &lt;- onebasis(chicagoNMMAPS$pm10, "thr", thr.value=20)
summary(b)
model &lt;- glm(death ~ b, family=quasipoisson(), chicagoNMMAPS)
pred &lt;- crosspred(b, model, at=0:60)
plot(pred, xlab="PM10", ylab="RR", main="RR for PM10")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
