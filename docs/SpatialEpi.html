<!DOCTYPE html><html lang="en"><head><title>Help for package SpatialEpi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialEpi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayes_cluster'><p>Bayesian Cluster Detection Method</p></a></li>
<li><a href='#besag_newell'><p>Besag-Newell Cluster Detection Method</p></a></li>
<li><a href='#circle'><p>Compute cartesian coordinates of a cluster center and radius</p></a></li>
<li><a href='#create_geo_objects'><p>Create geographical objects to be used in Bayesian Cluster Detection Method</p></a></li>
<li><a href='#eBayes'><p>Empirical Bayes Estimates of Relative Risk</p></a></li>
<li><a href='#EBpostdens'><p>Produce plots of empirical Bayes posterior densities when the data Y are Poisson with expected number E and relative risk theta, with the latter having a gamma distribution with known values alpha and beta, which are estimated using empirical Bayes.</p></a></li>
<li><a href='#EBpostthresh'><p>Produce the probabilities of exceeding a threshold given a posterior gamma distribution.</p></a></li>
<li><a href='#estimate_lambda'><p>Estimate lambda values</p></a></li>
<li><a href='#expected'><p>Compute Expected Numbers of Disease</p></a></li>
<li><a href='#GammaPriorCh'><p>Compute Parameters to Calibrate a Gamma Distribution</p></a></li>
<li><a href='#grid2latlong'><p>Convert Coordinates from Grid to Latitude/Longitude</p></a></li>
<li><a href='#kulldorff'><p>Kulldorff Cluster Detection Method</p></a></li>
<li><a href='#latlong2grid'><p>Convert Coordinates from Latitude/Longitude to Grid</p></a></li>
<li><a href='#leglabs'><p>Make legend labels</p></a></li>
<li><a href='#LogNormalPriorCh'><p>Compute Parameters to Calibrate a Log-normal Distribution</p></a></li>
<li><a href='#mapvariable'><p>Plot Levels of a Variable in a Colour-Coded Map</p></a></li>
<li><a href='#NYleukemia'><p>Upstate New York Leukemia Data</p></a></li>
<li><a href='#NYleukemia_sf'><p>Upstate New York Leukemia</p></a></li>
<li><a href='#pennLC'><p>Pennsylvania Lung Cancer</p></a></li>
<li><a href='#pennLC_sf'><p>Pennsylvania Lung Cancer</p></a></li>
<li><a href='#plotmap'><p>Plot Levels of a Variable in a Colour-Coded Map</p></a></li>
<li><a href='#polygon2spatial_polygon'><p>Convert a Polygon to a Spatial Polygons Object</p></a></li>
<li><a href='#process_MCMC_sample'><p>Process MCMC Sample</p></a></li>
<li><a href='#scotland'><p>Lip Cancer in Scotland</p></a></li>
<li><a href='#scotland_sf'><p>Lip Cancer in Scotland</p></a></li>
<li><a href='#zones'><p>Create set of all single zones and output geographical information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods and Data for Spatial Epidemiology</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Albert Y. Kim &lt;albert.ys.kim@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods and data for cluster detection and disease mapping.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), sp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rudeboybert/SpatialEpi">https://github.com/rudeboybert/SpatialEpi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rudeboybert/SpatialEpi/issues">https://github.com/rudeboybert/SpatialEpi/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, MASS, spdep</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, markdown, knitr, testthat (&ge; 3.0.0), ggplot2,
dplyr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-22 00:30:28 UTC; rudeboybert</td>
</tr>
<tr>
<td>Author:</td>
<td>Cici Chen [ctb],
  Albert Y. Kim <a href="https://orcid.org/0000-0001-7824-306X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Michelle Ross [ctb],
  Jon Wakefield [aut],
  Mikael Moise <a href="https://orcid.org/0000-0002-3608-1178"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-22 00:50:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayes_cluster'>Bayesian Cluster Detection Method</h2><span id='topic+bayes_cluster'></span>

<h3>Description</h3>

<p>Implementation of the Bayesian Cluster detection model of Wakefield and Kim (2013) for a study region with <code>n</code> areas. The prior and posterior probabilities of each of the <code>n.zones</code> single zones being a cluster/anti-cluster are estimated using Markov chain Monte Carlo. Furthermore, the posterior probability of k clusters/anti-clusters is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_cluster(
  y,
  E,
  population,
  sp.obj,
  centroids,
  max.prop,
  shape,
  rate,
  J,
  pi0,
  n.sim.lambda,
  n.sim.prior,
  n.sim.post,
  burnin.prop = 0.1,
  theta.init = vector(mode = "numeric", length = 0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayes_cluster_+3A_y">y</code></td>
<td>
<p>vector of length <code>n</code> of the observed number of disease in each area</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_e">E</code></td>
<td>
<p>vector of length <code>n</code> of the expected number of disease in each area</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_population">population</code></td>
<td>
<p>vector of length <code>n</code> of the population in each area</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_sp.obj">sp.obj</code></td>
<td>
<p>an object of class SpatialPolygons</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_centroids">centroids</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n x 2&#8288;</code> table of the (x,y)-coordinates of the area centroids.  The coordinate system must be grid-based</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_max.prop">max.prop</code></td>
<td>
<p>maximum proportion of the study region's population each single zone can contain</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_shape">shape</code></td>
<td>
<p>vector of length 2 of narrow/wide shape parameter for gamma prior on relative risk</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_rate">rate</code></td>
<td>
<p>vector of length 2 of narrow/wide rate parameter for gamma prior on relative risk</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_j">J</code></td>
<td>
<p>maximum number of clusters/anti-clusters</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_pi0">pi0</code></td>
<td>
<p>prior probability of no clusters/anti-clusters</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_n.sim.lambda">n.sim.lambda</code></td>
<td>
<p>number of importance sampling iterations to estimate lambda</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_n.sim.prior">n.sim.prior</code></td>
<td>
<p>number of MCMC iterations to estimate prior probabilities associated with each single zone</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_n.sim.post">n.sim.post</code></td>
<td>
<p>number of MCMC iterations to estimate posterior probabilities associated with each single zone</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_burnin.prop">burnin.prop</code></td>
<td>
<p>proportion of MCMC samples to use as burn-in</p>
</td></tr>
<tr><td><code id="bayes_cluster_+3A_theta.init">theta.init</code></td>
<td>
<p>Initial configuration used for MCMC sampling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing
return(list(
prior.map=prior.map,
post.map=post.map,
pk.y=pk.y))
</p>
<table role = "presentation">
<tr><td><code>prior.map</code></td>
<td>
<p>A list containing, for each area: 1) <code>high.area</code> the prior probability of cluster membership, 2) <code>low.area</code> anti-cluster membership, and 3) <code>RR.est.area</code> smoothed prior estimates of relative risk</p>
</td></tr>
<tr><td><code>post.map</code></td>
<td>
<p>A list containing, for each area: 1) <code>high.area</code> the posterior probability of cluster membership, 2) <code>low.area</code> anti-cluster membership, and 3) <code>RR.est.area</code> smoothed posterior estimates of the relative risk</p>
</td></tr>
<tr><td><code>pk.y</code></td>
<td>
<p>posterior probability of k clusters/anti-clusters given y for k=0,...,J</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Albert Y. Kim
</p>


<h3>References</h3>

<p>Wakefield J. and Kim A.Y. (2013) A Bayesian model for cluster detection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note for the NYleukemia example, 4 census tracts were completely surrounded 
## by another unique census tract; when applying the Bayesian cluster detection 
## model in [bayes_cluster()], we merge them with the surrounding 
## census tracts yielding `n=277` areas.

## Load data and convert coordinate system from latitude/longitude to grid
data(NYleukemia)
sp.obj &lt;- NYleukemia$spatial.polygon
population &lt;- NYleukemia$data$population
cases &lt;- NYleukemia$data$cases
centroids &lt;- latlong2grid(NYleukemia$geo[, 2:3])

## Identify the 4 census tract to be merged into their surrounding census tracts 
remove &lt;- NYleukemia$surrounded
add &lt;- NYleukemia$surrounding

## Merge population and case counts and geographical objects accordingly
population[add] &lt;- population[add] + population[remove]
population &lt;- population[-remove]
cases[add] &lt;- cases[add] + cases[remove]
cases &lt;- cases[-remove]
sp.obj &lt;-
  SpatialPolygons(sp.obj@polygons[-remove], proj4string=CRS("+proj=longlat +ellps=WGS84"))
centroids &lt;- centroids[-remove, ]

## Set parameters
y &lt;- cases
E &lt;- expected(population, cases, 1)
max.prop &lt;- 0.15
shape &lt;- c(2976.3, 2.31)
rate &lt;- c(2977.3, 1.31)
J &lt;- 7
pi0 &lt;- 0.95
n.sim.lambda &lt;- 10^4
n.sim.prior &lt;- 10^5
n.sim.post &lt;- 10^5

## (Uncomment first) Compute output
#output &lt;- bayes_cluster(y, E, population, sp.obj, centroids, max.prop, 
#  shape, rate, J, pi0, n.sim.lambda, n.sim.prior, n.sim.post)
#plotmap(output$prior.map$high.area, sp.obj)
#plotmap(output$post.map$high.area, sp.obj)
#plotmap(output$post.map$RR.est.area, sp.obj, log=TRUE)
#barplot(output$pk.y, names.arg=0:J, xlab="k", ylab="P(k|y)")    
</code></pre>

<hr>
<h2 id='besag_newell'>Besag-Newell Cluster Detection Method</h2><span id='topic+besag_newell'></span>

<h3>Description</h3>

<p>Besag-Newell cluster detection method.  There are differences with the original paper and our implementation:
</p>

<ul>
<li><p>we base our analysis on <code class="reqn">k</code> cases, rather than <code class="reqn">k</code> <em>other</em> cases as prescribed in the paper.
</p>
</li>
<li><p> we do not subtract 1 from the <em>accumulated numbers of other cases</em> and <em>accumulated numbers of others at risk</em>, as was prescribed in the paper to discount selection bias
</p>
</li>
<li><p> M is the total number of areas included, not the number of additional areas included.  i.e. <code class="reqn">M</code> starts at 1, not 0.
</p>
</li>
<li><p> p-values are not based on the original value of <code class="reqn">k</code>, rather the actual number of cases observed until we view <code class="reqn">k</code> or more cases.  Ex:  if <code class="reqn">k = 10</code>, but as we consider neighbors we encounter 1, 2, 9 then 12 cases, we base our <code class="reqn">p</code>-values on <code class="reqn">k=12</code>
</p>
</li>
<li><p> we do not provide a Monte-Carlo simulated <code class="reqn">R</code>:  the number of tests that attain significance at a fixed level <code class="reqn">\alpha</code>
</p>
</li></ul>

<p>The first two and last differences are because we view the testing on an area-by-area level, rather than a case-by-case level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besag_newell(geo, population, cases, expected.cases = NULL, k, alpha.level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="besag_newell_+3A_geo">geo</code></td>
<td>
<p>an <code style="white-space: pre;">&#8288;n x 2&#8288;</code> table of the (x,y)-coordinates of the area centroids</p>
</td></tr>
<tr><td><code id="besag_newell_+3A_population">population</code></td>
<td>
<p>aggregated population counts for all <code>n</code> areas</p>
</td></tr>
<tr><td><code id="besag_newell_+3A_cases">cases</code></td>
<td>
<p>aggregated case counts for all <code>n</code> areas</p>
</td></tr>
<tr><td><code id="besag_newell_+3A_expected.cases">expected.cases</code></td>
<td>
<p>expected numbers of disease for all <code>n</code> areas</p>
</td></tr>
<tr><td><code id="besag_newell_+3A_k">k</code></td>
<td>
<p>number of cases to consider</p>
</td></tr>
<tr><td><code id="besag_newell_+3A_alpha.level">alpha.level</code></td>
<td>
<p>alpha-level threshold used to declare significance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>population</code> and <code>cases</code> tables, the rows are bunched by areas first, and then for each area, the counts for each strata are listed.  It is important that the tables are balanced:  the strata information are in the same order for each area, and counts for each area/strata combination appear exactly once (even if zero).
</p>


<h3>Value</h3>

<p>List containing
</p>
<table role = "presentation">
<tr><td><code>clusters</code></td>
<td>
<p>information on all clusters that are <code class="reqn">\alpha</code>-level significant, in decreasing order of the <code class="reqn">p</code>-value</p>
</td></tr>
<tr><td><code>p.values</code></td>
<td>
<p>for each of the <code class="reqn">n</code> areas, <code class="reqn">p</code>-values of each cluster of size at least <code class="reqn">k</code></p>
</td></tr>
<tr><td><code>m.values</code></td>
<td>
<p>for each of the <code class="reqn">n</code> areas, the number of areas need to observe at least <code class="reqn">k</code> cases</p>
</td></tr>
<tr><td><code>observed.k.values</code></td>
<td>
<p>based on <code>m.values</code>, the actual number of cases used to compute the <code class="reqn">p</code>-values</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>clusters</code> list elements are themselves lists reporting:<br /><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>location.IDs.included</code> </td><td style="text-align: left;"> ID's of areas in cluster, in order of distance</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>population</code> </td><td style="text-align: left;"> population of cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>number.of.cases</code> </td><td style="text-align: left;"> number of cases in cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>expected.cases</code> </td><td style="text-align: left;"> expected number of cases in cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>SMR</code> </td><td style="text-align: left;"> estimated SMR of cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p.value</code> </td><td style="text-align: left;"> <code class="reqn">p</code>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Albert Y. Kim
</p>


<h3>References</h3>

<p>Besag J. and Newell J. (1991) The Detection of Clusters in Rare Diseases <em>Journal of the Royal Statistical Society. Series A (Statistics in Society)</em>, <strong>154</strong>, 143&ndash;155
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load Pennsylvania Lung Cancer Data
data(pennLC)
data &lt;- pennLC$data

## Process geographical information and convert to grid
geo &lt;- pennLC$geo[,2:3]
geo &lt;- latlong2grid(geo)

## Get aggregated counts of population and cases for each county
population &lt;- tapply(data$population,data$county,sum)
cases &lt;- tapply(data$cases,data$county,sum)

## Based on the 16 strata levels, computed expected numbers of disease
n.strata &lt;- 16
expected.cases &lt;- expected(data$population, data$cases, n.strata)

## Set Parameters
k &lt;- 1250
alpha.level &lt;- 0.05

# not controlling for stratas
results &lt;- besag_newell(geo, population, cases, expected.cases=NULL, k, 
                       alpha.level)

# controlling for stratas
results &lt;- besag_newell(geo, population, cases, expected.cases, k, alpha.level)

</code></pre>

<hr>
<h2 id='circle'>Compute cartesian coordinates of a cluster center and radius</h2><span id='topic+circle'></span>

<h3>Description</h3>

<p>This function is used for plotting purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle(geo, cluster.center, cluster.end)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circle_+3A_geo">geo</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;n x 2&#8288;</code> table of the x-coordinate and y-coordinates of the centroids of each area</p>
</td></tr>
<tr><td><code id="circle_+3A_cluster.center">cluster.center</code></td>
<td>
<p>The area index (an integer between <code>1</code> and <code>n</code>) indicating the center of the circle</p>
</td></tr>
<tr><td><code id="circle_+3A_cluster.end">cluster.end</code></td>
<td>
<p>The area index (an integer between <code>1</code> and <code>n</code>) indicating the area at the end of the circle</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cluster.radius</code></td>
<td>
<p>A data frame that you can plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Albert Y. Kim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pennLC)
geo &lt;- pennLC$geo[,2:3]
plot(geo,type='n')
text(geo,labels=1:nrow(geo))
lines( circle(geo, 23, 46), col = "red" )
</code></pre>

<hr>
<h2 id='create_geo_objects'>Create geographical objects to be used in Bayesian Cluster Detection Method</h2><span id='topic+create_geo_objects'></span>

<h3>Description</h3>

<p>This internal function creates the geographical objects needed to run the Bayesian cluster detection method in <code><a href="#topic+bayes_cluster">bayes_cluster()</a></code>.  Specifically it creates all single zones based data objects, where single zones are the <em>zones</em> defined by Kulldorff (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_geo_objects(max.prop, population, centroids, sp.obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_geo_objects_+3A_max.prop">max.prop</code></td>
<td>
<p>maximum proportion of study region's population each single zone can contain</p>
</td></tr>
<tr><td><code id="create_geo_objects_+3A_population">population</code></td>
<td>
<p>vector of length <code>n</code> of the population of each area</p>
</td></tr>
<tr><td><code id="create_geo_objects_+3A_centroids">centroids</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n x 2&#8288;</code> table of the (x,y)-coordinates of the area centroids.  The coordinate system must be grid-based</p>
</td></tr>
<tr><td><code id="create_geo_objects_+3A_sp.obj">sp.obj</code></td>
<td>
<p>object of class SpatialPolygons (See <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>) representing the study region</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>overlap</code></td>
<td>
<p>list with two elements: <code style="white-space: pre;">&#8288;1. presence&#8288;</code> which lists for each area all the single zones it is present in and <code style="white-space: pre;">&#8288;2. cluster.list&#8288;</code> for each single zone its component areas</p>
</td></tr>
<tr><td><code>cluster.coords</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n.zones x 2&#8288;</code> matrix of the center and radial area of each single zone</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Albert Y. Kim
</p>


<h3>References</h3>

<p>Wakefield J. and Kim A.Y. (2013) A Bayesian model for cluster detection.<em>Biostatistics</em>, <strong>14</strong>, 752&ndash;765.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pennLC)
max.prop &lt;- 0.15
population &lt;- tapply(pennLC$data$population, pennLC$data$county, sum)
centroids &lt;- latlong2grid(pennLC$geo[, 2:3])
sp.obj &lt;- pennLC$spatial.polygon
output &lt;- create_geo_objects(max.prop, population, centroids, sp.obj)
## number of single zones
nrow(output$cluster.coords)
</code></pre>

<hr>
<h2 id='eBayes'>Empirical Bayes Estimates of Relative Risk</h2><span id='topic+eBayes'></span>

<h3>Description</h3>

<p>The computes empirical Bayes estimates of relative risk of study region with <code>n</code> areas, given observed and expected numbers of counts of disease and covariate information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eBayes(Y, E, Xmat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eBayes_+3A_y">Y</code></td>
<td>
<p>a length <code>n</code> vector of observed cases</p>
</td></tr>
<tr><td><code id="eBayes_+3A_e">E</code></td>
<td>
<p>a length <code>n</code> vector of expected number of cases</p>
</td></tr>
<tr><td><code id="eBayes_+3A_xmat">Xmat</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n x p&#8288;</code> dimension matrix of covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 5 elements:
</p>
<table role = "presentation">
<tr><td><code>RR</code></td>
<td>
<p>the ecological relative risk posterior mean estimates</p>
</td></tr>
<tr><td><code>RRmed</code></td>
<td>
<p>the ecological relative risk posterior median estimates</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the MLE's of the regression coefficients</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the MLE of negative binomial dispersion parameter</p>
</td></tr>
<tr><td><code>SMR</code></td>
<td>
<p>the standardized mortality/morbidity ratio Y/E</p>
</td></tr>
</table>


<h3>References</h3>

<p>Clayton D. and Kaldor J. (1987) Empirical Bayes estimates of age-standardized relative risks for use in disease mapping.  <em>Biometrics</em>, <strong>43</strong>, 671&ndash;681
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scotland)
data &lt;- scotland$data
x &lt;- data$AFF
Xmat &lt;- cbind(x,x^2)
results &lt;- eBayes(data$cases,data$expected,Xmat)
scotland.map &lt;- scotland$spatial.polygon
mapvariable(results$RR, scotland.map)
</code></pre>

<hr>
<h2 id='EBpostdens'>Produce plots of empirical Bayes posterior densities when the data Y are Poisson with expected number E and relative risk theta, with the latter having a gamma distribution with known values alpha and beta, which are estimated using empirical Bayes.</h2><span id='topic+EBpostdens'></span>

<h3>Description</h3>

<p>This function produces plots of empirical Bayes posterior densities which are gamma distributions with parameters (alpha+Y, (alpha+E*mu)/mu) where mu = exp(x beta). The SMRs are drawn on for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBpostdens(
  Y,
  E,
  alpha,
  beta,
  Xrow = NULL,
  lower = NULL,
  upper = NULL,
  main = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EBpostdens_+3A_y">Y</code></td>
<td>
<p>observed disease counts</p>
</td></tr>
<tr><td><code id="EBpostdens_+3A_e">E</code></td>
<td>
<p>expected disease counts</p>
</td></tr>
<tr><td><code id="EBpostdens_+3A_alpha">alpha</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="EBpostdens_+3A_beta">beta</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="EBpostdens_+3A_xrow">Xrow</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="EBpostdens_+3A_lower">lower</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="EBpostdens_+3A_upper">upper</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="EBpostdens_+3A_main">main</code></td>
<td>
<p>x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot containing the gamma posterior distribution
</p>


<h3>Author(s)</h3>

<p>Jon Wakefield
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scotland)
Y &lt;- scotland$data$cases
E &lt;- scotland$data$expected
ebresults &lt;- eBayes(Y,E)
EBpostdens(Y[1], E[1], ebresults$alpha, ebresults$beta, lower=0, upper=15,
          main="Area 1")
</code></pre>

<hr>
<h2 id='EBpostthresh'>Produce the probabilities of exceeding a threshold given a posterior gamma distribution.</h2><span id='topic+EBpostthresh'></span>

<h3>Description</h3>

<p>This function produces the posterior probabilities of exceeding a threshold given a gamma distributions with parameters (alpha+Y, (alpha+E*mu)/mu) where mu = exp(x beta). This model arises from Y being Poisson with mean theta times E where theta is the relative risk and E are the expected numbers. The prior on theta is gamma with parameters alpha and beta. The parameters alpha and beta may be estimated using empirical Bayes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBpostthresh(Y, E, alpha, beta, Xrow = NULL, rrthresh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EBpostthresh_+3A_y">Y</code></td>
<td>
<p>observed disease counts</p>
</td></tr>
<tr><td><code id="EBpostthresh_+3A_e">E</code></td>
<td>
<p>expected disease counts</p>
</td></tr>
<tr><td><code id="EBpostthresh_+3A_alpha">alpha</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="EBpostthresh_+3A_beta">beta</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="EBpostthresh_+3A_xrow">Xrow</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="EBpostthresh_+3A_rrthresh">rrthresh</code></td>
<td>
<p>x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Posterior probabilities of exceedence are returned.
</p>


<h3>Author(s)</h3>

<p>Jon Wakefield
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eBayes">eBayes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scotland)
Y &lt;- scotland$data$cases
E &lt;- scotland$data$expected
ebresults &lt;- eBayes(Y,E)
#Find probabilities of exceedence of 3
thresh3 &lt;- EBpostthresh(Y, E, alpha=ebresults$alpha, beta=ebresults$beta, rrthresh=3)
mapvariable(thresh3, scotland$spatial.polygon)
</code></pre>

<hr>
<h2 id='estimate_lambda'>Estimate lambda values</h2><span id='topic+estimate_lambda'></span>

<h3>Description</h3>

<p>Internal function to estimate values of lambda needed for <code>MCMC_simulation</code> and prior probability of k clusters/anti-clusters for k=0,...,J
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_lambda(n.sim, J, prior.z, overlap, pi0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_lambda_+3A_n.sim">n.sim</code></td>
<td>
<p>number of importance sampling iterations</p>
</td></tr>
<tr><td><code id="estimate_lambda_+3A_j">J</code></td>
<td>
<p>maximum number of clusters/anti-clusters to consider</p>
</td></tr>
<tr><td><code id="estimate_lambda_+3A_prior.z">prior.z</code></td>
<td>
<p>prior probability of each single zone</p>
</td></tr>
<tr><td><code id="estimate_lambda_+3A_overlap">overlap</code></td>
<td>
<p>output of <code><a href="#topic+create_geo_objects">create_geo_objects()</a></code>: list with two elements: <code>presence</code> which lists for each area all the single zones it is present in and <code>cluster_list</code> for each single zone its component areas</p>
</td></tr>
<tr><td><code id="estimate_lambda_+3A_pi0">pi0</code></td>
<td>
<p>prior probability of no clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates of lambda and prior.j
</p>


<h3>References</h3>

<p>Wakefield J. and Kim A.Y. (2013) A Bayesian model for cluster detection. <em>Biostatistics</em>, <strong>14</strong>, 752&ndash;765.
</p>

<hr>
<h2 id='expected'>Compute Expected Numbers of Disease</h2><span id='topic+expected'></span>

<h3>Description</h3>

<p>Compute the internally indirect standardized expected numbers of disease.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected(population, cases, n.strata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expected_+3A_population">population</code></td>
<td>
<p>a vector of population counts for each strata in each area</p>
</td></tr>
<tr><td><code id="expected_+3A_cases">cases</code></td>
<td>
<p>a vector of the corresponding number of cases</p>
</td></tr>
<tr><td><code id="expected_+3A_n.strata">n.strata</code></td>
<td>
<p>number of strata considered</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>population</code> and <code>cases</code> vectors must be <em>balanced</em>: all counts are sorted by area first, and then within each area the counts for all strata are listed (even if 0 count) in the same order.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>expected.cases</code></td>
<td>
<p>a vector of the expected numbers of disease for each area</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Albert Y. Kim
</p>


<h3>References</h3>

<p>Elliot, P. et al. (2000) <em>Spatial Epidemiology:  Methods and Applications</em>.  Oxford Medical Publications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pennLC)
population &lt;- pennLC$data$population
cases &lt;- pennLC$data$cases
## In each county in Pennsylvania, there are 2 races, gender and 4 age bands 
## considered = 16 strata levels
pennLC$data[1:16,]
expected(population, cases, 16)


</code></pre>

<hr>
<h2 id='GammaPriorCh'>Compute Parameters to Calibrate a Gamma Distribution</h2><span id='topic+GammaPriorCh'></span>

<h3>Description</h3>

<p>Compute parameters to calibrate the prior distribution of a relative risk that has a gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GammaPriorCh(theta, prob, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GammaPriorCh_+3A_theta">theta</code></td>
<td>
<p>upper quantile</p>
</td></tr>
<tr><td><code id="GammaPriorCh_+3A_prob">prob</code></td>
<td>
<p>upper quantile</p>
</td></tr>
<tr><td><code id="GammaPriorCh_+3A_d">d</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing
</p>
<table role = "presentation">
<tr><td><code>a</code></td>
<td>
<p>shape parameter</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>rate parameter</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jon Wakefield
</p>


<h3>See Also</h3>

<p>LogNormalPriorCh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param &lt;- GammaPriorCh(5, 0.975,1)
curve(dgamma(x,shape=param$a,rate=param$b),from=0,to=6,n=1000,ylab="density")

</code></pre>

<hr>
<h2 id='grid2latlong'>Convert Coordinates from Grid to Latitude/Longitude</h2><span id='topic+grid2latlong'></span>

<h3>Description</h3>

<p>Convert geographic coordinates from Universal Transverse Mercator system to Latitude/Longitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2latlong(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid2latlong_+3A_input">input</code></td>
<td>
<p>A data frame with columns named <code>x</code> and <code>y</code> of the UTM coordinates to convert or  an <code style="white-space: pre;">&#8288;n x 2&#8288;</code> matrix of grid coordinates or an object of class SpatialPolygons (See <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Longitude/latitudes are not a grid-based coordinate system:  latitudes are equidistant but the distance between longitudes varies.
</p>


<h3>Value</h3>

<p>Either a data frame with the corresponding longitude and latitude, or a SpatialPolygons object with the coordinates changed.
</p>


<h3>Note</h3>

<p>Rough conversion of US lat/long to km (used by GeoBUGS):  (see
also forum.swarthmore.edu/dr.math/problems/longandlat.html).
Radius of earth: r = 3963.34 (equatorial) or 3949.99 (polar) mi =
6378.2 or 6356.7 km, which implies: km per mile  = 1.609299 or
1.609295 a change of 1 degree of latitude corresponds to the same
number of km, regardless of longitude.  arclength=r<em>theta, so the
multiplier for coord y should probably be just the radius of
earth. On the other hand, a change of 1 degree in longitude
corresponds to a different distance, depending on latitude.  (at N
pole, the change is essentially 0.  at the equator, use equatorial
radius.  Perhaps for U.S., might use an &quot;average&quot; latitude, 30 deg
is roughly Houston, 49deg is most of N bdry of continental 48
states.  0.5(30+49)=39.5 deg.  so use r approx 6378.2</em>sin(51.5)
</p>


<h3>Author(s)</h3>

<p>Lance A. Waller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coord &lt;- data.frame(rbind(
# Montreal, QC
c(-6414.30, 5052.849),
# Vancouver, BC
c(-122.6042, 45.6605)
))

grid2latlong(coord)

</code></pre>

<hr>
<h2 id='kulldorff'>Kulldorff Cluster Detection Method</h2><span id='topic+kulldorff'></span>

<h3>Description</h3>

<p>Kulldorff spatial cluster detection method for a study region with <code>n</code> areas.  The method constructs <em>zones</em> by consecutively aggregating nearest-neighboring areas until a proportion of the total study population is included.  Given the observed number of cases, the likelihood of each zone is computed using either binomial or poisson likelihoods. The procedure reports the zone that is the <em>most likely cluster</em> and generates significance measures via Monte Carlo sampling.  Further, <em>secondary clusters</em>, whose Monte Carlo p-values are below the <code class="reqn">\alpha</code>-threshold, are reported as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kulldorff(
  geo,
  cases,
  population,
  expected.cases = NULL,
  pop.upper.bound,
  n.simulations,
  alpha.level,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kulldorff_+3A_geo">geo</code></td>
<td>
<p>an <code style="white-space: pre;">&#8288;n x 2&#8288;</code> table of the (x,y)-coordinates of the area centroids</p>
</td></tr>
<tr><td><code id="kulldorff_+3A_cases">cases</code></td>
<td>
<p>aggregated case counts for all <code>n</code> areas</p>
</td></tr>
<tr><td><code id="kulldorff_+3A_population">population</code></td>
<td>
<p>aggregated population counts for all <code>n</code> areas</p>
</td></tr>
<tr><td><code id="kulldorff_+3A_expected.cases">expected.cases</code></td>
<td>
<p>expected numbers of disease for all <code>n</code> areas</p>
</td></tr>
<tr><td><code id="kulldorff_+3A_pop.upper.bound">pop.upper.bound</code></td>
<td>
<p>the upper bound on the proportion of the total population each zone can include</p>
</td></tr>
<tr><td><code id="kulldorff_+3A_n.simulations">n.simulations</code></td>
<td>
<p>number of Monte Carlo samples used for significance measures</p>
</td></tr>
<tr><td><code id="kulldorff_+3A_alpha.level">alpha.level</code></td>
<td>
<p>alpha-level threshold used to declare significance</p>
</td></tr>
<tr><td><code id="kulldorff_+3A_plot">plot</code></td>
<td>
<p>flag for whether to plot histogram of Monte Carlo samples of the log-likelihood of the most likely cluster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>expected.cases</code> is specified to be <code>NULL</code>, then the binomial likelihood is used.  Otherwise, a Poisson model is assumed.  Typical values of <code>n.simulations</code> are <code>99</code>, <code>999</code>, <code>9999</code>
</p>


<h3>Value</h3>

<p>List containing:
</p>
<table role = "presentation">
<tr><td><code>most.likely.cluster</code></td>
<td>
<p>information on the most likely cluster</p>
</td></tr>
<tr><td><code>secondary.clusters</code></td>
<td>
<p>information on secondary clusters, if none <code>NULL</code> is returned</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of likelihood</p>
</td></tr>
<tr><td><code>log.lkhd</code></td>
<td>
<p>log-likelihood of each zone considered</p>
</td></tr>
<tr><td><code>simulated.log.lkhd</code></td>
<td>
<p><code>n.simulations</code> Monte Carlo samples of the log-likelihood of the most likely cluster</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>most.likely.cluster</code> and <code>secondary.clusters</code> list elements are themselves lists reporting:<br /><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>location.IDs.included</code> </td><td style="text-align: left;"> ID's of areas in cluster, in order of distance</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>population</code> </td><td style="text-align: left;"> population of cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>number.of.cases</code> </td><td style="text-align: left;"> number of cases in cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>expected.cases</code> </td><td style="text-align: left;"> expected number of cases in cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>SMR</code> </td><td style="text-align: left;"> estimated SMR of cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>log.likelihood.ratio</code> </td><td style="text-align: left;"> log-likelihood of cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>monte.carlo.rank</code> </td><td style="text-align: left;"> rank of lkhd of cluster within Monte Carlo simulated values</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>p.value</code> </td><td style="text-align: left;"> Monte Carlo <code class="reqn">p</code>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Albert Y. Kim
</p>


<h3>References</h3>

<p>SatScan:  Software for the spatial, temporal, and space-time scan statistics <a href="https://www.satscan.org/">https://www.satscan.org/</a> Kulldorff, M. (1997) A spatial scan statistic. <em>Communications in Statistics: Theory and Methods</em>, <strong>26</strong>, 1481&ndash;1496.
Kulldorff M. and Nagarwalla N. (1995) Spatial disease clusters: Detection and Inference.
<em>Statistics in Medicine</em>, <strong>14</strong>, 799&ndash;810.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load Pennsylvania Lung Cancer Data
data(pennLC)
data &lt;- pennLC$data

## Process geographical information and convert to grid
geo &lt;- pennLC$geo[,2:3]
geo &lt;- latlong2grid(geo)

## Get aggregated counts of population and cases for each county
population &lt;- tapply(data$population,data$county,sum)
cases &lt;- tapply(data$cases,data$county,sum)

## Based on the 16 strata levels, computed expected numbers of disease
n.strata &lt;- 16
expected.cases &lt;- expected(data$population, data$cases, n.strata)

## Set Parameters
pop.upper.bound &lt;- 0.5
n.simulations &lt;- 999
alpha.level &lt;- 0.05
plot &lt;- TRUE

## Kulldorff using Binomial likelihoods
binomial &lt;- kulldorff(geo, cases, population, NULL, pop.upper.bound, n.simulations, 
                     alpha.level, plot)
cluster &lt;- binomial$most.likely.cluster$location.IDs.included

## plot
plot(pennLC$spatial.polygon,axes=TRUE)
plot(pennLC$spatial.polygon[cluster],add=TRUE,col="red")
title("Most Likely Cluster")

## Kulldorff using Poisson likelihoods
poisson &lt;- kulldorff(geo, cases, population, expected.cases, pop.upper.bound, 
                    n.simulations, alpha.level, plot)
cluster &lt;- poisson$most.likely.cluster$location.IDs.included

## plot
plot(pennLC$spatial.polygon,axes=TRUE)
plot(pennLC$spatial.polygon[cluster],add=TRUE,col="red")
title("Most Likely Cluster Controlling for Strata")
</code></pre>

<hr>
<h2 id='latlong2grid'>Convert Coordinates from Latitude/Longitude to Grid</h2><span id='topic+latlong2grid'></span>

<h3>Description</h3>

<p>Convert geographic latitude/longitude coordinates to kilometer-based grid coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong2grid(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latlong2grid_+3A_input">input</code></td>
<td>
<p>either an <code style="white-space: pre;">&#8288;n x 2&#8288;</code> matrix of longitude and latitude coordinates in decimal format or an object of class SpatialPolygons</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Longitude/latitudes are not a grid-based coordinate system:  latitudes are equidistant but the distance between longitudes varies.
</p>


<h3>Value</h3>

<p>Either a data frame with the corresponding (x,y) kilometer-based grid coordinates, or a SpatialPolygons object with the coordinates changed.
</p>


<h3>Note</h3>

<p>Rough conversion of US lat/long to km (used by GeoBUGS):  (see
also forum.swarthmore.edu/dr.math/problems/longandlat.html).
Radius of earth: r = 3963.34 (equatorial) or 3949.99 (polar) mi =
6378.2 or 6356.7 km, which implies: km per mile  = 1.609299 or
1.609295 a change of 1 degree of latitude corresponds to the same
number of km, regardless of longitude.  arclength=r*theta, so the
multiplier for coord y should probably be just the radius of
earth. On the other hand, a change of 1 degree in longitude
corresponds to a different distance, depending on latitude.  (at N
pole, the change is essentially 0.  at the equator, use equatorial
radius.
</p>


<h3>Author(s)</h3>

<p>Lance A. Waller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Convert coordinates
coord &lt;- data.frame(rbind(
 # Montreal, QC:  Latitude: 45deg 28' 0" N (deg min sec), Longitude: 73deg 45' 0" W
 c(-73.7500, 45.4667),
 # Vancouver, BC:  Latitude: 45deg 39' 38" N (deg min sec), Longitude: 122deg 36' 15" W
 c(-122.6042, 45.6605)
))
latlong2grid(coord)
## Convert SpatialPolygon
data(pennLC)
new &lt;- latlong2grid(pennLC$spatial.polygon)
par(mfrow=c(1,2))
plot(pennLC$spatial.polygon,axes=TRUE)
title("Lat/Long")
plot(new,axes=TRUE)
title("Grid (in km)")
</code></pre>

<hr>
<h2 id='leglabs'>Make legend labels</h2><span id='topic+leglabs'></span>

<h3>Description</h3>

<p>leglabs makes character strings from the same break points. This function was copied from the soon-to-be
deprecated <code>maptools</code> package with permission from author Roger Bivand
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leglabs(vec, under = "under", over = "over", between = "-", reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leglabs_+3A_vec">vec</code></td>
<td>
<p>vector of break values</p>
</td></tr>
<tr><td><code id="leglabs_+3A_under">under</code></td>
<td>
<p>character value for under</p>
</td></tr>
<tr><td><code id="leglabs_+3A_over">over</code></td>
<td>
<p>character value for over</p>
</td></tr>
<tr><td><code id="leglabs_+3A_between">between</code></td>
<td>
<p>character value for between</p>
</td></tr>
<tr><td><code id="leglabs_+3A_reverse">reverse</code></td>
<td>
<p>flag to reverse order of values, you will also need to reorder colours, see example</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand, Nick Bearman, Nicholas Lewin-Koh
</p>

<hr>
<h2 id='LogNormalPriorCh'>Compute Parameters to Calibrate a Log-normal Distribution</h2><span id='topic+LogNormalPriorCh'></span>

<h3>Description</h3>

<div class="sourceCode"><pre>Compute parameters to calibrate the prior distribution of a relative risk that has a log-normal distribution.
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>LogNormalPriorCh(theta1, theta2, prob1, prob2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LogNormalPriorCh_+3A_theta1">theta1</code></td>
<td>
<p>lower quantile</p>
</td></tr>
<tr><td><code id="LogNormalPriorCh_+3A_theta2">theta2</code></td>
<td>
<p>upper quantile</p>
</td></tr>
<tr><td><code id="LogNormalPriorCh_+3A_prob1">prob1</code></td>
<td>
<p>lower probability</p>
</td></tr>
<tr><td><code id="LogNormalPriorCh_+3A_prob2">prob2</code></td>
<td>
<p>upper probability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table role = "presentation">
<tr><td><code>mu</code></td>
<td>
<p>mean of log-normal distribution</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>variance of log-normal distribution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jon Wakefield
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calibrate the log-normal distribution s.t. the 95% confidence interval is [0.2, 5]
param &lt;- LogNormalPriorCh(0.2, 5, 0.025, 0.975)
curve(dlnorm(x,param$mu,param$sigma), from=0, to=6, ylab="density")
</code></pre>

<hr>
<h2 id='mapvariable'>Plot Levels of a Variable in a Colour-Coded Map</h2><span id='topic+mapvariable'></span>

<h3>Description</h3>

<p>Plot levels of a variable in a colour-coded map along with a legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapvariable(
  y,
  spatial.polygon,
  ncut = 1000,
  nlevels = 10,
  lower = NULL,
  upper = NULL,
  main = NULL,
  xlab = NULL,
  ylab = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapvariable_+3A_y">y</code></td>
<td>
<p>variable to plot</p>
</td></tr>
<tr><td><code id="mapvariable_+3A_spatial.polygon">spatial.polygon</code></td>
<td>
<p>an object of class SpatialPolygons (See <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>)</p>
</td></tr>
<tr><td><code id="mapvariable_+3A_ncut">ncut</code></td>
<td>
<p>number of cuts in colour levels to plot</p>
</td></tr>
<tr><td><code id="mapvariable_+3A_nlevels">nlevels</code></td>
<td>
<p>number of levels to include in legend</p>
</td></tr>
<tr><td><code id="mapvariable_+3A_lower">lower</code></td>
<td>
<p>lower bound of levels</p>
</td></tr>
<tr><td><code id="mapvariable_+3A_upper">upper</code></td>
<td>
<p>upper bound of levels</p>
</td></tr>
<tr><td><code id="mapvariable_+3A_main">main</code></td>
<td>
<p>an overall title for the plot</p>
</td></tr>
<tr><td><code id="mapvariable_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis</p>
</td></tr>
<tr><td><code id="mapvariable_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A map colour-coded to indicate the different levels of <code>y</code>
</p>


<h3>Author(s)</h3>

<p>Jon Wakefield, Nicky Best, Sebastien Haneuse, and Albert Y. Kim
</p>


<h3>References</h3>

<p>Bivand, R. S., Pebesma E. J., and Gomez-Rubio V. (2008) <em>Applied Spatial Data Analysis with R</em>.  Springer Series in Statistics.
E. J. Pebesma and R. S. Bivand. (2005) Classes and methods for spatial data in R. <em>R News</em>, <strong>5</strong>, 9&ndash;13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scotland)
map &lt;- scotland$spatial.polygon
y &lt;- scotland$data$cases
E &lt;- scotland$data$expected
SMR &lt;- y/E
mapvariable(SMR,map,main="Scotland",xlab="Eastings (km)",ylab="Northings (km)")
</code></pre>

<hr>
<h2 id='NYleukemia'>Upstate New York Leukemia Data</h2><span id='topic+NYleukemia'></span>

<h3>Description</h3>

<p>Census tract level (<code>n=281</code>) leukemia data for the 8 counties in upstate New York from 1978-1982, paired with population data from the 1980 census.
Note that 4 census tracts were completely surrounded by another unique census tract;
when applying the Bayesian cluster detection model in <code><a href="#topic+bayes_cluster">bayes_cluster()</a></code>,
we merge them with the surrounding census tracts yielding <code>n=277</code> areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NYleukemia
</code></pre>


<h3>Format</h3>

<p>List with 5 items:
</p>

<dl>
<dt>geo</dt><dd><p>table of the FIPS code, longitude, and latitude of the geographic centroid of each census tract</p>
</dd>
<dt>data</dt><dd><p>table of the FIPS code, number of cases, and population of each census tract</p>
</dd>
<dt>spatial.polygon</dt><dd><p>bject of class SpatialPolygons</p>
</dd>
<dt>surrounded</dt><dd><p>row IDs of the 4 census tracts that are completely surrounded by the</p>
</dd>
<dt>surrounding</dt><dd><p>census tracts</p>
</dd>
</dl>



<h3>References</h3>

<p>Turnbull, B. W. et al (1990) Monitoring for clusters of disease: application to leukemia incidence in upstate New York <em>American Journal of Epidemiology</em>, <strong>132</strong>, 136&ndash;143
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data and convert coordinate system from latitude/longitude to grid
data(NYleukemia)
map &lt;- NYleukemia$spatial.polygon
population &lt;- NYleukemia$data$population
cases &lt;- NYleukemia$data$cases
centroids &lt;- latlong2grid(NYleukemia$geo[, 2:3])

## Identify the 4 census tract to be merged into their surrounding census tracts.  
remove &lt;- NYleukemia$surrounded
add &lt;- NYleukemia$surrounding

## Merge population and case counts
population[add] &lt;- population[add] + population[remove]
population &lt;- population[-remove]
cases[add] &lt;- cases[add] + cases[remove]
cases &lt;- cases[-remove]

## Modify geographical objects accordingly
map &lt;- SpatialPolygons(map@polygons[-remove], proj4string=CRS("+proj=longlat +ellps=WGS84"))
centroids &lt;- centroids[-remove, ]

## Plot incidence in latitude/longitude
plotmap(cases/population, map, log=TRUE, nclr=5)
points(grid2latlong(centroids), pch=4)



</code></pre>

<hr>
<h2 id='NYleukemia_sf'>Upstate New York Leukemia</h2><span id='topic+NYleukemia_sf'></span>

<h3>Description</h3>

<p>Census tract level (<code>n=281</code>) leukemia data for the 8 counties in upstate New York from 1978-1982, paired with population data from the 1980 census.
Note that 4 census tracts were completely surrounded by another unique census tract;
when applying the Bayesian cluster detection model in <code><a href="#topic+bayes_cluster">bayes_cluster()</a></code>,
we merge them with the surrounding census tracts yielding <code>n=277</code> areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NYleukemia_sf
</code></pre>


<h3>Format</h3>

<p>An sf 'POLYGON' data frame with 281 rows  and 4 variables:
</p>

<dl>
<dt>geometry</dt><dd><p>Geometric representation of 8 counties in upstate New York </p>
</dd>
<dt>cases</dt><dd><p>Number of cases per county</p>
</dd>
<dt>population</dt><dd><p>Population of each census tract</p>
</dd>
<dt>censustract.FIPS</dt><dd><p>11-digit Federal Information Processing System identification number for each county</p>
</dd>
</dl>



<h3>Source</h3>

<p>Turnbull, B. W. et al (1990) Monitoring for clusters of disease: application to leukemia incidence in upstate New York <em>American Journal of Epidemiology</em>, <strong>132</strong>, 136&ndash;143
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Static map of NY Leukemia rate per county
library(ggplot2)
## Not run: 
ggplot(NYleukemia_sf) + 
  geom_sf(aes(fill= cases/population)) + 
  scale_fill_gradient(low = "white", high = "red")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='pennLC'>Pennsylvania Lung Cancer</h2><span id='topic+pennLC'></span>

<h3>Description</h3>

<p>County-level (n=67) population/case data for lung cancer in Pennsylvania in 2002, stratified on race (white vs non-white), gender and age (Under 40, 40-59, 60-69 and 70+).  Additionally, county-specific smoking rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pennLC
</code></pre>


<h3>Format</h3>

<p>List of 3 items
</p>

<dl>
<dt>geo</dt><dd><p>a table of county IDs, longitude/latitude of the geographic centroid of each county</p>
</dd>
<dt>data</dt><dd><p>a table of county IDs, number of cases, population and strata information</p>
</dd>
<dt>smoking</dt><dd><p>a table of county IDs and proportion of smokers</p>
</dd>
<dt>spatial.polygon</dt><dd><p>an object of class SpatialPolygons</p>
</dd>
</dl>



<h3>Source</h3>

<p>Population data was obtained from the 2000 decennial census, lung cancer and smoking data were obtained from the Pennsylvania Department of Health website:  <a href="https://www.health.pa.gov/Pages/default.aspx">https://www.health.pa.gov/Pages/default.aspx</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pennLC)
pennLC$geo
pennLC$data
pennLC$smoking
# Map smoking rates in Pennsylvania
mapvariable(pennLC$smoking[,2], pennLC$spatial.polygon)




</code></pre>

<hr>
<h2 id='pennLC_sf'>Pennsylvania Lung Cancer</h2><span id='topic+pennLC_sf'></span>

<h3>Description</h3>

<p>County-level (n=67) population/case data for lung cancer in
Pennsylvania in 2002, stratified on race (white vs non-white),
gender and age (Under 40, 40-59, 60-69 and 70+). Additionally,
county-specific smoking rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pennLC_sf
</code></pre>


<h3>Format</h3>

<p>An sf <code>POLYGON</code> data frame with 1072 rows = 67 counties x 2 race
x 2 gender x 4 age bands
</p>

<dl>
<dt>county</dt><dd><p>Pennsylvania county</p>
</dd>
<dt>cases</dt><dd><p>Number of cases per county split by strata</p>
</dd>
<dt>population</dt><dd><p>Population per county split by strata</p>
</dd>
<dt>race</dt><dd><p>Race (w = white and o = non-white)</p>
</dd>
<dt>gender</dt><dd><p>Gender (f = female and m = male)</p>
</dd>
<dt>age</dt><dd><p>Age (4 bands)</p>
</dd>
<dt>smoking</dt><dd><p>Overall county smoking rate (not broken down by strata)</p>
</dd>
<dt>geometry</dt><dd><p>Geometric representation of counties in Pennsylvania</p>
</dd>
</dl>



<h3>Source</h3>

<p>Population data was obtained from the 2000 decennial census, lung cancer and smoking data were obtained from the Pennsylvania Department of Health website:<a href="https://www.health.pa.gov/Pages/default.aspx">https://www.health.pa.gov/Pages/default.aspx</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(dplyr)
# Sum cases &amp; population for each county
lung_cancer_rate &lt;- pennLC_sf %&gt;% 
  group_by(county) %&gt;% 
  summarize(cases = sum(cases), population = sum(population)) %&gt;% 
  mutate(rate = cases/population)

# Static map of Pennsylvania lung cancer rates for each county
## Not run: 
ggplot() +
  geom_sf(data = lung_cancer_rate, aes(fill = rate))
  
## End(Not run)
</code></pre>

<hr>
<h2 id='plotmap'>Plot Levels of a Variable in a Colour-Coded Map</h2><span id='topic+plotmap'></span>

<h3>Description</h3>

<p>Plot levels of a variable in a colour-coded map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmap(
  values,
  map,
  log = FALSE,
  nclr = 7,
  include.legend = TRUE,
  lwd = 0.5,
  round = 3,
  brks = NULL,
  legend = NULL,
  location = "topright",
  rev = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotmap_+3A_values">values</code></td>
<td>
<p>variable to plot</p>
</td></tr>
<tr><td><code id="plotmap_+3A_map">map</code></td>
<td>
<p>an object of class SpatialPolygons (See <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>)</p>
</td></tr>
<tr><td><code id="plotmap_+3A_log">log</code></td>
<td>
<p>boolean of whether to plot values on log scale</p>
</td></tr>
<tr><td><code id="plotmap_+3A_nclr">nclr</code></td>
<td>
<p>number of colour-levels to use</p>
</td></tr>
<tr><td><code id="plotmap_+3A_include.legend">include.legend</code></td>
<td>
<p>boolean of whether to include legend</p>
</td></tr>
<tr><td><code id="plotmap_+3A_lwd">lwd</code></td>
<td>
<p>line width of borders of areas</p>
</td></tr>
<tr><td><code id="plotmap_+3A_round">round</code></td>
<td>
<p>number of digits to round to in legend</p>
</td></tr>
<tr><td><code id="plotmap_+3A_brks">brks</code></td>
<td>
<p>if desired, pre-specified breaks for legend</p>
</td></tr>
<tr><td><code id="plotmap_+3A_legend">legend</code></td>
<td>
<p>if desired, a pre-specified legend</p>
</td></tr>
<tr><td><code id="plotmap_+3A_location">location</code></td>
<td>
<p>location of legend</p>
</td></tr>
<tr><td><code id="plotmap_+3A_rev">rev</code></td>
<td>
<p>boolean of whether to reverse colour scheme (darker colours for smaller values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A map colour-coded to indicate the different levels of <code>values</code>.
</p>


<h3>Author(s)</h3>

<p>Albert Y. Kim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(scotland)
map &lt;- scotland$spatial.polygon
y &lt;- scotland$data$cases
E &lt;- scotland$data$expected
SMR &lt;- y/E
## Plot SMR
plotmap(SMR, map, nclr=9, location="topleft")
</code></pre>

<hr>
<h2 id='polygon2spatial_polygon'>Convert a Polygon to a Spatial Polygons Object</h2><span id='topic+polygon2spatial_polygon'></span>

<h3>Description</h3>

<p>Converts a polygon (a matrix of coordinates with NA values to separate subpolygons) into a Spatial Polygons object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon2spatial_polygon(
  poly,
  coordinate.system,
  area.names = NULL,
  nrepeats = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polygon2spatial_polygon_+3A_poly">poly</code></td>
<td>
<p>a 2-column matrix of coordinates, where each complete subpolygon is separated by NA's</p>
</td></tr>
<tr><td><code id="polygon2spatial_polygon_+3A_coordinate.system">coordinate.system</code></td>
<td>
<p>the coordinate system to use</p>
</td></tr>
<tr><td><code id="polygon2spatial_polygon_+3A_area.names">area.names</code></td>
<td>
<p>names of all areas</p>
</td></tr>
<tr><td><code id="polygon2spatial_polygon_+3A_nrepeats">nrepeats</code></td>
<td>
<p>number of sub polygons for each area</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just as when plotting with the <code><a href="graphics.html#topic+polygon">graphics::polygon()</a></code> function, it is assumed that each subpolygon is to be closed by joining the last point to the first point.  In the matrix <code>poly</code>, NA values separate complete subpolygons.
In the case with an area consists of more than one separate closed polygon, <code>nrepeats</code> specifies the number of closed polygons associated with each area.
</p>


<h3>Value</h3>

<p>An object of class SpatialPolygons (See <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a> from the <span class="pkg">sp</span> package).
</p>


<h3>Author(s)</h3>

<p>Albert Y. Kim
</p>


<h3>References</h3>

<p>Bivand, R. S., Pebesma E. J., and Gomez-Rubio V. (2008) <em>Applied Spatial Data Analysis with R</em>.  Springer Series in Statistics. E. J. Pebesma and R. S. Bivand. (2005) Classes and methods for spatial data in R. <em>R News</em>, <strong>5</strong>, 9&ndash;13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(scotland)

polygon &lt;- scotland$polygon$polygon
coord.system &lt;- "+proj=eqc +lat_ts=0 +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 "
coord.system &lt;- paste(coord.system, "+ellps=WGS84 +datum=WGS84 +units=m +no_defs", sep = "")
names &lt;- scotland$data$county.names
nrepeats &lt;- scotland$polygon$nrepeats

spatial.polygon &lt;- polygon2spatial_polygon(polygon,coord.system,names,nrepeats)

par(mfrow=c(1,2))
# plot using polygon function
plot(polygon,type='n',xlab="Eastings (km)",ylab="Northings (km)",main="Polygon File")
polygon(polygon)

# plot as spatial polygon object
plot(spatial.polygon,axes=TRUE)
title(xlab="Eastings (km)",ylab="Northings (km)",main="Spatial Polygon")

# Note that area 23 (argyll-bute) consists of 8 separate polygons
nrepeats[23]
plot(spatial.polygon[23],add=TRUE,col="red")
</code></pre>

<hr>
<h2 id='process_MCMC_sample'>Process MCMC Sample</h2><span id='topic+process_MCMC_sample'></span>

<h3>Description</h3>

<p>Take the output of sampled configurations from <code>MCMC_simulation</code> and produce area-by-area summaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_MCMC_sample(sample, param, RR.area, cluster.list, cutoffs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_MCMC_sample_+3A_sample">sample</code></td>
<td>
<p>list objects of sampled configurations</p>
</td></tr>
<tr><td><code id="process_MCMC_sample_+3A_param">param</code></td>
<td>
<p>mean relative risk associted with each of the <code>n.zones</code> single zones considering the wide prior</p>
</td></tr>
<tr><td><code id="process_MCMC_sample_+3A_rr.area">RR.area</code></td>
<td>
<p>mean relative risk associated with each of the <code>n</code> areas considering the narrow prior</p>
</td></tr>
<tr><td><code id="process_MCMC_sample_+3A_cluster.list">cluster.list</code></td>
<td>
<p>list of length <code>n.zones</code> listing, for each single zone, its component areas</p>
</td></tr>
<tr><td><code id="process_MCMC_sample_+3A_cutoffs">cutoffs</code></td>
<td>
<p>cutoffs used to declare highs (clusters) and lows (anti-clusters)</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>high.area</code></td>
<td>
<p>Probability of cluster membership for each area</p>
</td></tr>
<tr><td><code>low.area</code></td>
<td>
<p>Probability of anti-cluster membership for each area</p>
</td></tr>
<tr><td><code>RR.est.area</code></td>
<td>
<p>Smoothed relative risk estimates for each area</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wakefield J. and Kim A.Y. (2013) A Bayesian model for cluster detection. <em>Biostatistics</em>, <strong>14</strong>, 752&ndash;765.
</p>

<hr>
<h2 id='scotland'>Lip Cancer in Scotland</h2><span id='topic+scotland'></span>

<h3>Description</h3>

<p>County-level (n=56) data for lip cancer among males in Scotland between 1975-1980
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scotland
</code></pre>


<h3>Format</h3>

<p>List containing:
</p>

<dl>
<dt>geo</dt><dd><p>a table of county IDs, x-coordinates (eastings) and y-coordinates (northings) of the geographic centroid of each county.</p>
</dd>
<dt>data</dt><dd><p>a table of county IDs, number of cases, population and strata information</p>
</dd>
<dt>spatial.polygon</dt><dd><p>a Spatial Polygons class (See <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>) map of Scotland</p>
</dd>
<dt>polygon</dt><dd><p>a polygon map of Scotland (See <code><a href="#topic+polygon2spatial_polygon">polygon2spatial_polygon()</a></code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Kemp I., Boyle P., Smans M. and Muir C. (1985) Atlas of cancer in Scotland, 1975-1980, incidence and epidemiologic perspective <em>International Agency for Research on Cancer</em> <strong>72</strong>.
</p>


<h3>References</h3>

<p>Clayton D. and Kaldor J. (1987) Empirical Bayes estimates of age-standardized relative risks for use in disease mapping.  <em>Biometrics</em>, <strong>43</strong>, 671&ndash;681.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(scotland)
data &lt;- scotland$data
scotland.map &lt;- scotland$spatial.polygon
SMR &lt;- data$cases/data$expected
mapvariable(SMR,scotland.map)





</code></pre>

<hr>
<h2 id='scotland_sf'>Lip Cancer in Scotland</h2><span id='topic+scotland_sf'></span>

<h3>Description</h3>

<p>County-level (n=56) data for lip cancer among males in Scotland between 1975-1980
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scotland_sf
</code></pre>


<h3>Format</h3>

<p>A data frame with 56 rows representing counties and 5 variables:
</p>

<dl>
<dt>geometry</dt><dd><p>Geometric representation of counties in Scotland</p>
</dd>
<dt>cases</dt><dd><p>Number of Lip Cancer cases per county</p>
</dd>
<dt>county.names</dt><dd><p>Scotland County name</p>
</dd>
<dt>AFF</dt><dd><p>Proportion of the population who work in agricultural fishing and farming</p>
</dd>
<dt>expected</dt><dd><p>Expected number of lip cancer cases</p>
</dd>
</dl>



<h3>Source</h3>

<p>Kemp I., Boyle P., Smans M. and Muir C. (1985) Atlas of cancer in Scotland, 1975-1980, incidence and epidemiologic perspective <em>International Agency for Research on Cancer</em> <strong>72</strong>.
</p>


<h3>References</h3>

<p>Clayton D. and Kaldor J. (1987) Empirical Bayes estimates of age-standardized relative risks for use in disease mapping.  <em>Biometrics</em>, <strong>43</strong>, 671&ndash;681.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
## Not run: 
ggplot() +
geom_sf(data = scotland_sf, aes(fill= cases))

## End(Not run)
</code></pre>

<hr>
<h2 id='zones'>Create set of all single zones and output geographical information</h2><span id='topic+zones'></span>

<h3>Description</h3>

<p>Based on the population counts and centroid coordinates of each of <code>n</code> areas, output the set of <code>n.zones</code> single zones as defined by Kulldorff and other geographical information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zones(geo, population, pop.upper.bound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zones_+3A_geo">geo</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n x 2&#8288;</code> table of the (x,y)-coordinates of the area centroids</p>
</td></tr>
<tr><td><code id="zones_+3A_population">population</code></td>
<td>
<p>a vector of population counts of each area</p>
</td></tr>
<tr><td><code id="zones_+3A_pop.upper.bound">pop.upper.bound</code></td>
<td>
<p>maximum proportion of study region each zone can contain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table role = "presentation">
<tr><td><code>nearest.neighbors</code></td>
<td>
<p>list of <code>n</code> elements, where each element is a vector of the nearest neighbors in order of distance up until <code>pop.upper.bound</code> of the total population is attained</p>
</td></tr>
<tr><td><code>cluster.coords</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n.zones x 2&#8288;</code> table of the center and the radial area for each zone</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n x n&#8288;</code> inter-point distance matrix of the centroids</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Albert Y. Kim
</p>


<h3>References</h3>

<p>Kulldorff, M. (1997) A spatial scan statistic. <em>Communications in Statistics: Theory and Methods</em>, <strong>26</strong>, 1481&ndash;1496.
Kulldorff M. and Nagarwalla N. (1995) Spatial disease clusters: Detection and Inference.
<em>Statistics in Medicine</em>, <strong>14</strong>, 799&ndash;810.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pennLC)
geo &lt;- pennLC$geo[,2:3]
geo &lt;- latlong2grid(geo)
population &lt;- tapply(pennLC$data$population, pennLC$data$county, sum)
pop.upper.bound &lt;- 0.5
geo.info &lt;- zones(geo, population, pop.upper.bound)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
