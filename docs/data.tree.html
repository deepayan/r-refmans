<!DOCTYPE html><html><head><title>Help for package data.tree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {data.tree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acme'><p>Sample Data: A Simple Company with Departments</p></a></li>
<li><a href='#Aggregate'><p>Aggregate child values of a <code>Node</code>, recursively.</p></a></li>
<li><a href='#AreNamesUnique'><p>Test whether all node names are unique.</p></a></li>
<li><a href='#as.data.frame.Node'><p>Convert a <code>data.tree</code> structure to a <code>data.frame</code></p></a></li>
<li><a href='#as.dendrogram.Node'><p>Convert a <code>Node</code> to a <code>dendrogram</code></p></a></li>
<li><a href='#as.igraph.Node'><p>Convert a <code>data.tree</code> structure to an igraph network</p></a></li>
<li><a href='#as.list.Node'><p>Convert a <code>data.tree</code> structure to a list-of-list structure</p></a></li>
<li><a href='#as.Node'><p>Convert an object to a <code>data.tree</code> data structure</p></a></li>
<li><a href='#as.Node.BinaryTree'><p>Convert a a <code>SplitNode</code> from the party package to a <code>data.tree</code> structure.</p></a></li>
<li><a href='#as.Node.data.frame'><p>Convert a <code>data.frame</code> to a <code>data.tree</code> structure</p></a></li>
<li><a href='#as.Node.dendrogram'><p>Convert a <code>dendrogram</code> to a data.tree <code>Node</code></p></a></li>
<li><a href='#as.Node.list'><p>Convert a nested <code>list</code> structure to a <code>data.tree</code> structure</p></a></li>
<li><a href='#as.Node.party'><p>Convert a a <code>party</code> from the partykit package to a <code>data.tree</code> structure.</p></a></li>
<li><a href='#as.Node.phylo'><p>Convert a <code>phylo</code> object from the ape package to a <code>Node</code></p></a></li>
<li><a href='#as.Node.rpart'><p>Convert an <code>rpart</code> object to a <code>data.tree</code> structure</p></a></li>
<li><a href='#as.phylo.Node'><p>Convert a <code>Node</code> to a phylo object from the ape package.</p></a></li>
<li><a href='#averageBranchingFactor'><p>Calculate the average number of branches each non-leaf has</p></a></li>
<li><a href='#CheckNameReservedWord'><p>Checks whether <code>name</code> is a reserved word, as defined in <code>NODE_RESERVED_NAMES_CONST</code>.</p></a></li>
<li><a href='#Climb'><p>Climb a tree from parent to children, by provided criteria.</p></a></li>
<li><a href='#Clone'><p>Clone a tree (creates a deep copy)</p></a></li>
<li><a href='#CreateRandomTree'><p>Create a tree for demo and testing</p></a></li>
<li><a href='#CreateRegularTree'><p>Create a tree for demo and testing</p></a></li>
<li><a href='#Cumulate'><p>Cumulate values among siblings</p></a></li>
<li><a href='#data.tree'><p>data.tree: Hierarchical Data Structures</p></a></li>
<li><a href='#DefaultPlotHeight'><p>Calculates the height of a <code>Node</code> given the height of the root.</p></a></li>
<li><a href='#Distance'><p>Find the distance between two nodes of the same tree</p></a></li>
<li><a href='#Do'><p>Executes a function on a set of nodes</p></a></li>
<li><a href='#FindNode'><p>Find a node by name in the (sub-)tree</p></a></li>
<li><a href='#FormatFixedDecimal'><p>Format a Number as a Decimal</p></a></li>
<li><a href='#FormatPercent'><p>Format a Number as a Percentage</p></a></li>
<li><a href='#Get'><p>Traverse a Tree and Collect Values</p></a></li>
<li><a href='#GetAttribute'><p>Get an attribute from a Node.</p></a></li>
<li><a href='#GetPhyloNr'><p>Determine the number a <code>Node</code> has after conversion to a phylo object</p></a></li>
<li><a href='#isLeaf'><p>Check if a <code>Node</code> is a leaf</p></a></li>
<li><a href='#isNotLeaf'><p>Check if a <code>Node</code> is not a leaf</p></a></li>
<li><a href='#isNotRoot'><p>Check if a <code>Node</code> is not a root</p></a></li>
<li><a href='#isRoot'><p>Check if a <code>Node</code> is the root</p></a></li>
<li><a href='#mushroom'><p>Sample Data: Data Used by the ID3 Vignette</p></a></li>
<li><a href='#Navigate'><p>Navigate to another node by relative path.</p></a></li>
<li><a href='#Node'><p>Create a <code>data.tree</code> Structure With <code>Nodes</code></p></a></li>
<li><a href='#NODE_RESERVED_NAMES_CONST'><p>Names that are reserved by the Node class.</p></a></li>
<li><a href='#plot.Node'><p>Plot a graph, or get a graphviz dot representation of the tree</p></a></li>
<li><a href='#print.Node'><p>Print a <code>Node</code> in a human-readable fashion.</p></a></li>
<li><a href='#Prune'><p>Prunes a tree.</p></a></li>
<li><a href='#Revert'><p>Reverts the sort order of a <code>Node</code>'s children.</p></a></li>
<li><a href='#s3_register'><p>Register a method for a suggested dependency</p></a></li>
<li><a href='#Set'><p>Traverse a Tree and Assign Values</p></a></li>
<li><a href='#SetFormat'><p>Set a formatter function on a specific node</p></a></li>
<li><a href='#Sort'><p>Sort children of a <code>Node</code> or an entire <code>data.tree</code> structure</p></a></li>
<li><a href='#ToNewick'><p>Write a <code>data.tree</code> structure to Newick notation</p></a></li>
<li><a href='#Traverse'><p>Traverse a tree or a sub-tree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>General Purpose Hierarchical Data Structure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-11</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, stringi, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Formula, graphics, testthat, knitr, rmarkdown, ape, yaml,
networkD3, jsonlite, treemap, party, partykit, doParallel,
foreach, htmlwidgets, DiagrammeR (&ge; 1.0.0), mockery, rpart</td>
</tr>
<tr>
<td>Enhances:</td>
<td>igraph</td>
</tr>
<tr>
<td>Description:</td>
<td>Create tree structures from hierarchical data, and traverse the
    tree in various orders. Aggregate, cumulate, print, plot, convert to and from
    data.frame and more. Useful for decision trees, machine learning, finance,
    conversion from and to JSON, and many other applications.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gluc/data.tree">https://github.com/gluc/data.tree</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gluc/data.tree/issues">https://github.com/gluc/data.tree/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-12 14:00:42 UTC; ChristophGlur</td>
</tr>
<tr>
<td>Author:</td>
<td>Russ Hyde [ctb] (improve dependencies),
  Chris Hammill [ctb] (improve getting),
  Facundo Munoz [ctb] (improve list conversion),
  Markus Wamser [ctb] (fixed some typos),
  Pierre Formont [ctb] (additional features),
  Kent Russel [ctb] (documentation),
  Noam Ross [ctb] (fixes),
  Duncan Garmonsway [ctb] (fixes),
  Christoph Glur [aut, cre] (R interface)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christoph Glur &lt;christoph.glur@powerpartners.pro&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-12 20:23:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='acme'>Sample Data: A Simple Company with Departments</h2><span id='topic+acme'></span>

<h3>Description</h3>

<p>acme's tree representation is accessed through its root, acme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(acme)
</code></pre>


<h3>Format</h3>

<p>A data.tree root Node
</p>


<h3>Details</h3>


<ul>
<li><p> cost, only available for leaf nodes. Cost of the project.
</p>
</li>
<li><p> p probability that a project will be undertaken.
</p>
</li></ul>


<hr>
<h2 id='Aggregate'>Aggregate child values of a <code>Node</code>, recursively.</h2><span id='topic+Aggregate'></span>

<h3>Description</h3>

<p>The <code>Aggregate</code> method lets you fetch an attribute from a <code>Node</code>'s children, and then aggregate them
using <code>aggFun</code>. For example, you can aggregate cost by summing costs of child <code>Nodes</code>. This is especially useful in the
context of tree traversal, when using post-order traversal mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aggregate(node, attribute, aggFun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Aggregate_+3A_node">node</code></td>
<td>
<p>the <code>Node</code> on which to aggregate</p>
</td></tr>
<tr><td><code id="Aggregate_+3A_attribute">attribute</code></td>
<td>
<p>determines what is collected. The <code>attribute</code> can be
</p>

<ul>
<li><p> a.) the name of a <b>field</b> or a <b>property/active</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("p")</code> or <code>acme$Get("position")</code>
</p>
</li>
<li><p> b.) the name of a <b>method</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("levelZeroBased")</code>, where e.g. <code>acme$levelZeroBased &lt;- function() acme$level - 1</code>
</p>
</li>
<li><p> c.) a <b>function</b>, whose first argument must be a <code>Node</code> e.g. <code>acme$Get(function(node) node$cost * node$p)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="Aggregate_+3A_aggfun">aggFun</code></td>
<td>
<p>the aggregation function to be applied to the children's <code>attributes</code></p>
</td></tr>
<tr><td><code id="Aggregate_+3A_...">...</code></td>
<td>
<p>any arguments to be passed on to attribute (in case it's a function)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As with <code><a href="#topic+Get">Get</a></code>, the attribute can be a field, a method or a function. If the attribute on a child
is <code>NULL</code>, <code>Aggregate</code> is called recursively on its children.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)

#Aggregate on a field
Aggregate(acme, "cost", sum)

#This is the same as:
HomeRolledAggregate &lt;- function(node) {
  sum(sapply(node$children, function(child) {
    if (!is.null(child$cost)) child$cost
    else HomeRolledAggregate(child)
  }))
}
HomeRolledAggregate(acme)

#Aggregate using Get
print(acme, "cost", minCost = acme$Get(Aggregate, "cost", min))

#use Aggregate with a function:
Aggregate(acme, function(x) x$cost * x$p, sum)

#cache values along the way
acme$Do(function(x) x$cost &lt;- Aggregate(x, "cost", sum), traversal = "post-order")
acme$IT$cost

</code></pre>

<hr>
<h2 id='AreNamesUnique'>Test whether all node names are unique.</h2><span id='topic+AreNamesUnique'></span>

<h3>Description</h3>

<p>This can be useful for some conversions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AreNamesUnique(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AreNamesUnique_+3A_node">node</code></td>
<td>
<p>The root <code>Node</code> of the <code>data.tree</code> structure to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all <code>Node$name == TRUE</code> for all nodes in the tree
</p>


<h3>See Also</h3>

<p>as.igraph.Node
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
AreNamesUnique(acme)
acme$name &lt;- "IT"
AreNamesUnique(acme)

</code></pre>

<hr>
<h2 id='as.data.frame.Node'>Convert a <code>data.tree</code> structure to a <code>data.frame</code></h2><span id='topic+as.data.frame.Node'></span><span id='topic+ToDataFrameTree'></span><span id='topic+ToDataFrameTable'></span><span id='topic+ToDataFrameNetwork'></span><span id='topic+ToDataFrameTypeCol'></span>

<h3>Description</h3>

<p>If a node field contains data of length &gt; 1, then that is converted into a string in the
data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Node'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  ...,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),
  pruneFun = NULL,
  filterFun = NULL,
  format = FALSE,
  inheritFromAncestors = FALSE
)

ToDataFrameTree(x, ..., pruneFun = NULL)

ToDataFrameTable(x, ..., pruneFun = NULL)

ToDataFrameNetwork(
  x,
  ...,
  direction = c("climb", "descend"),
  pruneFun = NULL,
  format = FALSE,
  inheritFromAncestors = FALSE
)

ToDataFrameTypeCol(x, ..., type = "level", prefix = type, pruneFun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.Node_+3A_x">x</code></td>
<td>
<p>The root <code>Node</code> of the tree or sub-tree to be convert to a data.frame</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row names for the data frame.
Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_optional">optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and converting column names
(to syntactic names: see make.names) is optional.</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_...">...</code></td>
<td>
<p>the attributes to be added as columns of the data.frame. See <code><a href="#topic+Get">Get</a></code> for details.
If a specific Node does not contain the attribute, <code>NA</code> is added to the data.frame.</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_traversal">traversal</code></td>
<td>
<p>any of 'pre-order' (the default), 'post-order', 'in-order', 'level', or 'ancestor'. See <code><a href="#topic+Traverse">Traverse</a></code> for details.</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_prunefun">pruneFun</code></td>
<td>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_filterfun">filterFun</code></td>
<td>
<p>a function taking a <code>Node</code> as an argument. See <code><a href="#topic+Traverse">Traverse</a></code> for details.</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_format">format</code></td>
<td>
<p>if <code>FALSE</code> (the default), then no formatting will be applied. If <code>TRUE</code>, then the first formatter (if any) along the ancestor
path is used for formatting.</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_inheritfromancestors">inheritFromAncestors</code></td>
<td>
<p>if FALSE, and if the attribute is a field or a method, then only a <code>Node</code> itself is
searched for the field/method. If TRUE, and if the <code>Node</code> does not contain the attribute, then ancestors are also searched.</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_direction">direction</code></td>
<td>
<p>when converting to a network, should the edges point from root to children (&quot;climb&quot;) or from child to parent (&quot;descend&quot;)?</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_type">type</code></td>
<td>
<p>when converting type columns, the <code>type</code> is the discriminator, i.e. an attribute (e.g. field name) of each node</p>
</td></tr>
<tr><td><code id="as.data.frame.Node_+3A_prefix">prefix</code></td>
<td>
<p>when converting type columns, the prefix used for the column names. Can be NULL to omit prefixes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ToDataFrameTree: a <code>data.frame</code>, where each row represents a <code>Node</code> in the tree or sub-tree
spanned by <code>x</code>, possibly pruned according to <code>pruneFun</code>.
</p>
<p>ToDataFrameTable: a <code>data.frame</code>, where each row represents a leaf <code>Node</code> in the tree or sub-tree
spanned by <code>x</code>, possibly pruned according to <code>pruneFun</code>.
</p>
<p>ToDataFrameNetwork: a <code>data.frame</code>, where each row represents a <code>Node</code> in the tree or sub-tree
spanned by <code>x</code>, possibly pruned according to <code>pruneFun</code>. The first column is called 'from', while the
second is called 'to', describing the parent to child edge (for direction &quot;climb&quot;) or the child to parent edge (for direction &quot;descend&quot;).
If <code><a href="#topic+AreNamesUnique">AreNamesUnique</a></code> is TRUE, then the Network is
based on the <code>Node$name</code>, otherwise on the <code>Node$pathString</code>
</p>
<p>ToDataFrameTypeCol: a <code>data.frame</code> in table format (i.e. where each row represents a leaf in the tree or sub-tree
spanned by <code>x</code>), possibly pruned according to <code>pruneFun</code>. In addition to <code>...</code>, each distinct
<code>type</code> is output to a column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
acme$attributesAll
as.data.frame(acme, row.names = NULL, optional = FALSE, "cost", "p")

ToDataFrameTree(acme, "cost", "p")
ToDataFrameNetwork(acme, "cost", "p", direction = "climb")
ToDataFrameTable(acme, "cost", "p")
ToDataFrameTypeCol(acme)

#use the pruneFun:
acme$Do(function(x) x$totalCost &lt;- Aggregate(x, "cost", sum), traversal = "post-order")
ToDataFrameTree(acme, "totalCost", pruneFun = function(x) x$totalCost &gt; 300000)

#inherit
acme$Set(floor = c(1, 2, 3), filterFun = function(x) x$level == 2)
as.data.frame(acme, row.names = NULL, optional = FALSE, "floor", inheritFromAncestors = FALSE)
as.data.frame(acme, row.names = NULL, optional = FALSE, "floor", inheritFromAncestors = TRUE)

#using a function as an attribute:
acme$Accounting$Head &lt;- "Mrs. Numright"
acme$Research$Head &lt;- "Mr. Stein"
acme$IT$Head &lt;- "Mr. Squarehead"
ToDataFrameTable(acme, department = function(x) x$parent$name, "name", "Head", "cost")

#complex TypeCol
acme$IT$Outsource$AddChild("India")
acme$IT$Outsource$AddChild("Poland")
acme$Set(type = c('company', 'department', 'project', 'project', 'department',
                  'project', 'project', 'department', 'program', 'project',
                  'project', 'project', 'project'
                  )
        )
print(acme, 'type')
ToDataFrameTypeCol(acme, type = 'type')

</code></pre>

<hr>
<h2 id='as.dendrogram.Node'>Convert a <code>Node</code> to a <code>dendrogram</code></h2><span id='topic+as.dendrogram.Node'></span>

<h3>Description</h3>

<p>Convert a <code>data.tree</code> structure to a <code><a href="stats.html#topic+dendrogram">dendrogram</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Node'
as.dendrogram(
  object,
  heightAttribute = DefaultPlotHeight,
  edgetext = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.dendrogram.Node_+3A_object">object</code></td>
<td>
<p>The Node to convert</p>
</td></tr>
<tr><td><code id="as.dendrogram.Node_+3A_heightattribute">heightAttribute</code></td>
<td>
<p>The attribute (field name or function) storing the height</p>
</td></tr>
<tr><td><code id="as.dendrogram.Node_+3A_edgetext">edgetext</code></td>
<td>
<p>If TRUE, then the for non-leaf nodes the node name is stored as the dendrogram's edge text.</p>
</td></tr>
<tr><td><code id="as.dendrogram.Node_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class dendrogram
</p>


<h3>See Also</h3>

<p>Other Conversions from Node: 
<code><a href="#topic+ToNewick">ToNewick</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
acmed &lt;- as.dendrogram(acme)
plot(acmed, center = TRUE)

#you can take an attribute for the height:
acme$Do( function(x) x$myPlotHeight &lt;- (10 - x$level))
acmed &lt;- as.dendrogram(acme, heightAttribute = "myPlotHeight")
plot(acmed, center = TRUE)

#or directly a function
acmed &lt;- as.dendrogram(acme, heightAttribute = function(x) 10 - x$level)
plot(acmed)

</code></pre>

<hr>
<h2 id='as.igraph.Node'>Convert a <code>data.tree</code> structure to an igraph network</h2><span id='topic+as.igraph.Node'></span>

<h3>Description</h3>

<p>This requires the igraph package to be installed.
Also, this requires the names of the <code>Nodes</code> to be unique within
the <code>data.tree</code> structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.igraph.Node(
  x,
  vertexAttributes = character(),
  edgeAttributes = character(),
  directed = FALSE,
  direction = c("climb", "descend"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.igraph.Node_+3A_x">x</code></td>
<td>
<p>The root <code>Node</code> to convert</p>
</td></tr>
<tr><td><code id="as.igraph.Node_+3A_vertexattributes">vertexAttributes</code></td>
<td>
<p>A vector of strings, representing the attributes 
in the <code>data.tree</code> structure to add as attributes to the vertices of the igraph</p>
</td></tr>
<tr><td><code id="as.igraph.Node_+3A_edgeattributes">edgeAttributes</code></td>
<td>
<p>A vector of strings, representing the attributes
in the <code>data.tree</code> structure to add as edge attributes of the igraph</p>
</td></tr>
<tr><td><code id="as.igraph.Node_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether or not to create a directed graph.</p>
</td></tr>
<tr><td><code id="as.igraph.Node_+3A_direction">direction</code></td>
<td>
<p>when converting to a network, should the edges point from root to children (&quot;climb&quot;) or from child to parent (&quot;descend&quot;)?</p>
</td></tr>
<tr><td><code id="as.igraph.Node_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>igraph</code> object
</p>


<h3>See Also</h3>

<p>AreNamesUnique
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
library(igraph)
ig &lt;- as.igraph(acme, "p", c("level", "isLeaf"))
plot(ig)

</code></pre>

<hr>
<h2 id='as.list.Node'>Convert a <code>data.tree</code> structure to a list-of-list structure</h2><span id='topic+as.list.Node'></span><span id='topic+ToListSimple'></span><span id='topic+ToListExplicit'></span>

<h3>Description</h3>

<p>Convert a <code>data.tree</code> structure to a list-of-list structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Node'
as.list(
  x,
  mode = c("simple", "explicit"),
  unname = FALSE,
  nameName = ifelse(unname, "name", ""),
  childrenName = "children",
  rootName = "",
  keepOnly = NULL,
  pruneFun = NULL,
  ...
)

ToListSimple(x, nameName = "name", pruneFun = NULL, ...)

ToListExplicit(
  x,
  unname = FALSE,
  nameName = ifelse(unname, "name", ""),
  childrenName = "children",
  pruneFun = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.Node_+3A_x">x</code></td>
<td>
<p>The Node to convert</p>
</td></tr>
<tr><td><code id="as.list.Node_+3A_mode">mode</code></td>
<td>
<p>How the list is structured. &quot;simple&quot; (the default) will add children directly as nested lists.
&quot;explicit&quot; puts children in a separate nested list called <code>childrenName</code></p>
</td></tr>
<tr><td><code id="as.list.Node_+3A_unname">unname</code></td>
<td>
<p>If TRUE, and if <code>mode</code> is &quot;explicit&quot;, then the nested children list will not have named arguments. This
can be useful e.g. in the context of conversion to JSON, if you prefer the children to be
an array rather than named objects.</p>
</td></tr>
<tr><td><code id="as.list.Node_+3A_namename">nameName</code></td>
<td>
<p>The name that should be given to the name element</p>
</td></tr>
<tr><td><code id="as.list.Node_+3A_childrenname">childrenName</code></td>
<td>
<p>The name that should be given to the children nested list</p>
</td></tr>
<tr><td><code id="as.list.Node_+3A_rootname">rootName</code></td>
<td>
<p>The name of the node. If provided, this overrides <code>Node$name</code></p>
</td></tr>
<tr><td><code id="as.list.Node_+3A_keeponly">keepOnly</code></td>
<td>
<p>A character vector of attributes to include in the result. If <code>NULL</code> (the default), all attributes are kept.</p>
</td></tr>
<tr><td><code id="as.list.Node_+3A_prunefun">pruneFun</code></td>
<td>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</td></tr>
<tr><td><code id="as.list.Node_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>as.list.Node</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)

str(ToListSimple(acme))
str(ToListSimple(acme, keepOnly = "cost"))

str(ToListExplicit(acme))
str(ToListExplicit(acme, unname = TRUE))
str(ToListExplicit(acme, unname = TRUE, nameName = "id", childrenName = "descendants"))

</code></pre>

<hr>
<h2 id='as.Node'>Convert an object to a <code>data.tree</code> data structure</h2><span id='topic+as.Node'></span>

<h3>Description</h3>

<p>Convert an object to a <code>data.tree</code> data structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Node(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Node_+3A_x">x</code></td>
<td>
<p>The object to be converted</p>
</td></tr>
<tr><td><code id="as.Node_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other as.Node: 
<code><a href="#topic+as.Node.data.frame">as.Node.data.frame</a>()</code>,
<code><a href="#topic+as.Node.dendrogram">as.Node.dendrogram</a>()</code>,
<code><a href="#topic+as.Node.list">as.Node.list</a>()</code>,
<code><a href="#topic+as.Node.phylo">as.Node.phylo</a>()</code>,
<code><a href="#topic+as.Node.rpart">as.Node.rpart</a>()</code>
</p>

<hr>
<h2 id='as.Node.BinaryTree'>Convert a a <code>SplitNode</code> from the party package to a <code>data.tree</code> structure.</h2><span id='topic+as.Node.BinaryTree'></span>

<h3>Description</h3>

<p>Convert a a <code>SplitNode</code> from the party package to a <code>data.tree</code> structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryTree'
as.Node(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Node.BinaryTree_+3A_x">x</code></td>
<td>
<p>The BinaryTree</p>
</td></tr>
<tr><td><code id="as.Node.BinaryTree_+3A_...">...</code></td>
<td>
<p>additional arguments (unused)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(party)
airq &lt;- subset(airquality, !is.na(Ozone))
airct &lt;- ctree(Ozone ~ ., data = airq, 
               controls = ctree_control(maxsurrogate = 3))
               
tree &lt;- as.Node(airct)
tree

print(tree, 
      "label", 
      criterion = function(x) round(x$criterion$maxcriterion, 3),
      statistic = function(x) round(max(x$criterion$statistic), 3)
      )

FindNode(tree, 6)$path


</code></pre>

<hr>
<h2 id='as.Node.data.frame'>Convert a <code>data.frame</code> to a <code>data.tree</code> structure</h2><span id='topic+as.Node.data.frame'></span><span id='topic+FromDataFrameTable'></span><span id='topic+FromDataFrameNetwork'></span>

<h3>Description</h3>

<p>Convert a <code>data.frame</code> to a <code>data.tree</code> structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
as.Node(
  x,
  ...,
  mode = c("table", "network"),
  pathName = "pathString",
  pathDelimiter = "/",
  colLevels = NULL,
  na.rm = TRUE
)

FromDataFrameTable(
  table,
  pathName = "pathString",
  pathDelimiter = "/",
  colLevels = NULL,
  na.rm = TRUE,
  check = c("check", "no-warn", "no-check")
)

FromDataFrameNetwork(network, check = c("check", "no-warn", "no-check"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Node.data.frame_+3A_x">x</code></td>
<td>
<p>The data.frame in the required format.</p>
</td></tr>
<tr><td><code id="as.Node.data.frame_+3A_...">...</code></td>
<td>
<p>Any other argument implementations of this might need</p>
</td></tr>
<tr><td><code id="as.Node.data.frame_+3A_mode">mode</code></td>
<td>
<p>Either &quot;table&quot; (if x is a data.frame in tree or table format) or &quot;network&quot;</p>
</td></tr>
<tr><td><code id="as.Node.data.frame_+3A_pathname">pathName</code></td>
<td>
<p>The name of the column in x containing the path of the row</p>
</td></tr>
<tr><td><code id="as.Node.data.frame_+3A_pathdelimiter">pathDelimiter</code></td>
<td>
<p>The delimiter used to separate nodes in <code>pathName</code></p>
</td></tr>
<tr><td><code id="as.Node.data.frame_+3A_collevels">colLevels</code></td>
<td>
<p>Nested list of column names, determining on what node levels the attributes are written to.</p>
</td></tr>
<tr><td><code id="as.Node.data.frame_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, then NA's are treated as NULL and values will not be set on nodes</p>
</td></tr>
<tr><td><code id="as.Node.data.frame_+3A_table">table</code></td>
<td>
<p>a <code>data.frame</code> in table or tree format, i.e. having a row for each leaf (and optionally
for additional nodes). There should be a column called <code>pathName</code>, separated by <code>pathDelimiter</code>,
describing the path of each row.</p>
</td></tr>
<tr><td><code id="as.Node.data.frame_+3A_check">check</code></td>
<td>
<p>Either
</p>

<ul>
<li><p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li><p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li><p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li></ul>
</td></tr>
<tr><td><code id="as.Node.data.frame_+3A_network">network</code></td>
<td>
<p>A <code>data.frame</code> in network format, i.e.
it must adhere to the following requirements:
</p>

<ul>
<li><p>It must contain as many rows as there are nodes (excluding the root, there is no row for the root)
</p>
</li>
<li><p>Its first and second columns contain the network relationships. This can be either climbing (from parent to children) or descending (from child to parent)
</p>
</li>
<li><p>Its subsequent columns contain the attributes to be set on the nodes
</p>
</li>
<li><p>It must contain a single root
</p>
</li>
<li><p>There are no cycles in the network
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The root <code>Node</code> of the <code>data.tree</code> structure
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.data.frame.Node">as.data.frame.Node</a></code>
</p>
<p>Other as.Node: 
<code><a href="#topic+as.Node.dendrogram">as.Node.dendrogram</a>()</code>,
<code><a href="#topic+as.Node.list">as.Node.list</a>()</code>,
<code><a href="#topic+as.Node.phylo">as.Node.phylo</a>()</code>,
<code><a href="#topic+as.Node.rpart">as.Node.rpart</a>()</code>,
<code><a href="#topic+as.Node">as.Node</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)

#Tree
x &lt;- ToDataFrameTree(acme, "pathString", "p", "cost")
x
xN &lt;- as.Node(x)
print(xN, "p", "cost")

#Table
x &lt;- ToDataFrameTable(acme, "pathString", "p", "cost")
x
xN &lt;- FromDataFrameTable(x)
print(xN, "p", "cost")

#More complex Table structure, using colLevels
acme$Set(floor = c(1, 2, 3),  filterFun = function(x) x$level == 2)
x &lt;- ToDataFrameTable(acme, "pathString", "floor", "p", "cost")
x
xN &lt;- FromDataFrameTable(x, colLevels = list(NULL, "floor", c("p", "cost")), na.rm = TRUE)
print(xN, "floor", "p", "cost")

#Network
x &lt;- ToDataFrameNetwork(acme, "p", "cost", direction = "climb")
x
xN &lt;- FromDataFrameNetwork(x)
print(xN, "p", "cost")

</code></pre>

<hr>
<h2 id='as.Node.dendrogram'>Convert a <code><a href="stats.html#topic+dendrogram">dendrogram</a></code> to a data.tree <code>Node</code></h2><span id='topic+as.Node.dendrogram'></span>

<h3>Description</h3>

<p>Convert a <code><a href="stats.html#topic+dendrogram">dendrogram</a></code> to a data.tree <code>Node</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dendrogram'
as.Node(
  x,
  name = "Root",
  heightName = "plotHeight",
  check = c("check", "no-warn", "no-check"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Node.dendrogram_+3A_x">x</code></td>
<td>
<p>The dendrogram</p>
</td></tr>
<tr><td><code id="as.Node.dendrogram_+3A_name">name</code></td>
<td>
<p>The name of the root Node</p>
</td></tr>
<tr><td><code id="as.Node.dendrogram_+3A_heightname">heightName</code></td>
<td>
<p>The name under which the dendrogram's height is stored</p>
</td></tr>
<tr><td><code id="as.Node.dendrogram_+3A_check">check</code></td>
<td>
<p>Either
</p>

<ul>
<li><p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li><p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li><p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li></ul>
</td></tr>
<tr><td><code id="as.Node.dendrogram_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The root <code>Node</code> of a <code>data.tree</code>
</p>


<h3>See Also</h3>

<p>Other as.Node: 
<code><a href="#topic+as.Node.data.frame">as.Node.data.frame</a>()</code>,
<code><a href="#topic+as.Node.list">as.Node.list</a>()</code>,
<code><a href="#topic+as.Node.phylo">as.Node.phylo</a>()</code>,
<code><a href="#topic+as.Node.rpart">as.Node.rpart</a>()</code>,
<code><a href="#topic+as.Node">as.Node</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests), "ave")
dend1 &lt;- as.dendrogram(hc)
tree1 &lt;- as.Node(dend1)
tree1$attributesAll
tree1$totalCount
tree1$leafCount
tree1$height
  
</code></pre>

<hr>
<h2 id='as.Node.list'>Convert a nested <code>list</code> structure to a <code>data.tree</code> structure</h2><span id='topic+as.Node.list'></span><span id='topic+FromListExplicit'></span><span id='topic+FromListSimple'></span>

<h3>Description</h3>

<p>Convert a nested <code>list</code> structure to a <code>data.tree</code> structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
as.Node(
  x,
  mode = c("simple", "explicit"),
  nameName = "name",
  childrenName = "children",
  nodeName = NULL,
  interpretNullAsList = FALSE,
  check = c("check", "no-warn", "no-check"),
  ...
)

FromListExplicit(
  explicitList,
  nameName = "name",
  childrenName = "children",
  nodeName = NULL,
  check = c("check", "no-warn", "no-check")
)

FromListSimple(
  simpleList,
  nameName = "name",
  nodeName = NULL,
  interpretNullAsList = FALSE,
  check = c("check", "no-warn", "no-check")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Node.list_+3A_x">x</code></td>
<td>
<p>The <code>list</code> to be converted.</p>
</td></tr>
<tr><td><code id="as.Node.list_+3A_mode">mode</code></td>
<td>
<p>How the list is structured. &quot;simple&quot; (the default) will interpret any list to be a child. &quot;explicit&quot; 
assumes that children are in a nested list called <code>childrenName</code></p>
</td></tr>
<tr><td><code id="as.Node.list_+3A_namename">nameName</code></td>
<td>
<p>The name of the element in the list that should be used as the name, can be NULL if mode = explicit and
the children lists are named, or if an automatic name (running number) should be assigned</p>
</td></tr>
<tr><td><code id="as.Node.list_+3A_childrenname">childrenName</code></td>
<td>
<p>The name of the element that contains the child list (applies to mode 'explicit' only).</p>
</td></tr>
<tr><td><code id="as.Node.list_+3A_nodename">nodeName</code></td>
<td>
<p>A name suggestion for x, if the name cannot be deferred otherwise. This is for example the case for
the root with mode explicit and named lists.</p>
</td></tr>
<tr><td><code id="as.Node.list_+3A_interpretnullaslist">interpretNullAsList</code></td>
<td>
<p>If <code>TRUE</code>, then <code>NULL</code>-valued lists are interpreted as child nodes. Else, they are interpreted as attributes.
This has only an effect if <code>mode</code> is &quot;simple&quot;.</p>
</td></tr>
<tr><td><code id="as.Node.list_+3A_check">check</code></td>
<td>
<p>Either
</p>

<ul>
<li><p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li><p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li><p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li></ul>
</td></tr>
<tr><td><code id="as.Node.list_+3A_...">...</code></td>
<td>
<p>Any other argument to be passed to generic sub implementations</p>
</td></tr>
<tr><td><code id="as.Node.list_+3A_explicitlist">explicitList</code></td>
<td>
<p>A <code>list</code> in which children are in a separate nested list called <code>childrenName</code>.</p>
</td></tr>
<tr><td><code id="as.Node.list_+3A_simplelist">simpleList</code></td>
<td>
<p>A <code>list</code> in which children are stored as nested list alongside other attributes. Any list is
interpreted as a child <code>Node</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other as.Node: 
<code><a href="#topic+as.Node.data.frame">as.Node.data.frame</a>()</code>,
<code><a href="#topic+as.Node.dendrogram">as.Node.dendrogram</a>()</code>,
<code><a href="#topic+as.Node.phylo">as.Node.phylo</a>()</code>,
<code><a href="#topic+as.Node.rpart">as.Node.rpart</a>()</code>,
<code><a href="#topic+as.Node">as.Node</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kingJosephs &lt;- list(name = "Joseph I",
                    spouse = "Mary",
                    born = "1818-02-23",
                    died = "1839-08-29",
                    children = list(
                                    list(name = "Joseph II",
                                         spouse = "Kathryn",
                                         born = "1839-03-28",
                                         died = "1865-12-19"),
                                    list(name = "Helen",
                                         born = "1840-17-08",
                                         died = "1845-01-01")
                                    )
                   )
FromListExplicit(kingJosephs)

kingJosephs &lt;- list(head = "Joseph I",
                    spouse = "Mary",
                    born = "1818-02-23",
                    died = "1839-08-29",
                    list(head = "Joseph II",
                         spouse = "Kathryn",
                         born = "1839-03-28",
                         died = "1865-12-19"),
                    list(head = "Helen",
                         born = "1840-17-08",
                         died = "1845-01-01")       
                   )
FromListSimple(kingJosephs, nameName = "head")

kingJosephs &lt;- list(spouse = "Mary",
                    born = "1818-02-23",
                    died = "1839-08-29",
                    `Joseph II` = list(spouse = "Kathryn",
                                       born = "1839-03-28",
                                       died = "1865-12-19"),
                    Helen = list(born = "1840-17-08",
                                 died = "1845-01-01")
                                 
                   )
FromListSimple(kingJosephs, nodeName = "Joseph I")
  
</code></pre>

<hr>
<h2 id='as.Node.party'>Convert a a <code>party</code> from the partykit package to a <code>data.tree</code> structure.</h2><span id='topic+as.Node.party'></span>

<h3>Description</h3>

<p>Convert a a <code>party</code> from the partykit package to a <code>data.tree</code> structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'party'
as.Node(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Node.party_+3A_x">x</code></td>
<td>
<p>The party object</p>
</td></tr>
<tr><td><code id="as.Node.party_+3A_...">...</code></td>
<td>
<p>other arguments (unused)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(partykit)
data("WeatherPlay", package = "partykit")
### splits ###
# split in overcast, humidity, and windy
sp_o &lt;- partysplit(1L, index = 1:3)
sp_h &lt;- partysplit(3L, breaks = 75)
sp_w &lt;- partysplit(4L, index = 1:2)

## query labels
character_split(sp_o)

### nodes ###
## set up partynode structure
pn &lt;- partynode(1L, split = sp_o, kids = list(
  partynode(2L, split = sp_h, kids = list(
      partynode(3L, info = "yes"),
      partynode(4L, info = "no"))),
  partynode(5L, info = "yes"),
  partynode(6L, split = sp_w, kids = list(
      partynode(7L, info = "yes"),
      partynode(8L, info = "no")))))
pn
### tree ###
## party: associate recursive partynode structure with data
py &lt;- party(pn, WeatherPlay)
tree &lt;- as.Node(py)

print(tree, 
      "splitname",
      count = function(node) nrow(node$data), 
      "splitLevel")

SetNodeStyle(tree, 
             label = function(node) paste0(node$name, ": ", node$splitname), 
             tooltip = function(node) paste0(nrow(node$data), " observations"),
             fontname = "helvetica")
SetEdgeStyle(tree, 
             arrowhead = "none", 
             label = function(node) node$splitLevel,
             fontname = "helvetica",
             penwidth = function(node) 12 * nrow(node$data)/nrow(node$root$data),
             color = function(node) {
               paste0("grey", 
                      100 - as.integer( 100 * nrow(node$data)/nrow(node$root$data))
                      )
             }
             )
Do(tree$leaves, 
   function(node) {
     SetNodeStyle(node, 
                  shape = "box", 
                  color = ifelse(node$splitname == "yes", "darkolivegreen4", "lightsalmon4"),
                  fillcolor = ifelse(node$splitname == "yes", "darkolivegreen1", "lightsalmon"),
                  style = "filled,rounded",
                  penwidth = 2
                  )
   }
   )

plot(tree)


</code></pre>

<hr>
<h2 id='as.Node.phylo'>Convert a <code>phylo</code> object from the ape package to a <code>Node</code></h2><span id='topic+as.Node.phylo'></span>

<h3>Description</h3>

<p>Convert a <code>phylo</code> object from the ape package to a <code>Node</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylo'
as.Node(
  x,
  heightName = "plotHeight",
  replaceUnderscores = TRUE,
  namesNotUnique = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Node.phylo_+3A_x">x</code></td>
<td>
<p>The phylo object to be converted</p>
</td></tr>
<tr><td><code id="as.Node.phylo_+3A_heightname">heightName</code></td>
<td>
<p>If the phylo contains edge lengths, then they will be converted
to a height and stored in a field named according to this parameter (the default is &quot;height&quot;)</p>
</td></tr>
<tr><td><code id="as.Node.phylo_+3A_replaceunderscores">replaceUnderscores</code></td>
<td>
<p>if TRUE (the default), then underscores in names are replaced with spaces</p>
</td></tr>
<tr><td><code id="as.Node.phylo_+3A_namesnotunique">namesNotUnique</code></td>
<td>
<p>if TRUE, then the <code>name</code> of the <code>Node</code>s will be prefixed with a unique id.
This is useful if the children of a parent have non-unique names.</p>
</td></tr>
<tr><td><code id="as.Node.phylo_+3A_...">...</code></td>
<td>
<p>any other parameter to be passed to sub-implementations</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ape phylo conversions: 
<code><a href="#topic+GetPhyloNr">GetPhyloNr</a>()</code>,
<code><a href="#topic+as.phylo.Node">as.phylo.Node</a>()</code>
</p>
<p>Other as.Node: 
<code><a href="#topic+as.Node.data.frame">as.Node.data.frame</a>()</code>,
<code><a href="#topic+as.Node.dendrogram">as.Node.dendrogram</a>()</code>,
<code><a href="#topic+as.Node.list">as.Node.list</a>()</code>,
<code><a href="#topic+as.Node.rpart">as.Node.rpart</a>()</code>,
<code><a href="#topic+as.Node">as.Node</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#which bird familes have the max height?
library(ape)
data(bird.families)
bf &lt;- as.Node(bird.families)
height &lt;- bf$height
t &lt;- Traverse(bf, filterFun = function(x) x$level == 25)
Get(t, "name")

</code></pre>

<hr>
<h2 id='as.Node.rpart'>Convert an <code><a href="rpart.html#topic+rpart">rpart</a></code> object to a <code>data.tree</code> structure</h2><span id='topic+as.Node.rpart'></span>

<h3>Description</h3>

<p>Convert an <code><a href="rpart.html#topic+rpart">rpart</a></code> object to a <code>data.tree</code> structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rpart'
as.Node(x, digits = getOption("digits") - 3, use.n = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Node.rpart_+3A_x">x</code></td>
<td>
<p>the <code>rpart</code> object to be converted</p>
</td></tr>
<tr><td><code id="as.Node.rpart_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be used for numeric values in labels</p>
</td></tr>
<tr><td><code id="as.Node.rpart_+3A_use.n">use.n</code></td>
<td>
<p>logical. Add cases to labels, see <code><a href="rpart.html#topic+text.rpart">text.rpart</a></code> for further
information</p>
</td></tr>
<tr><td><code id="as.Node.rpart_+3A_...">...</code></td>
<td>
<p>any other argument to be passed to generic sub implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.tree</code> object. The tree contains a field <code>rpart.id</code> which
references back to the original node id in the row names of the <code>rpart</code> object.
</p>


<h3>See Also</h3>

<p>Other as.Node: 
<code><a href="#topic+as.Node.data.frame">as.Node.data.frame</a>()</code>,
<code><a href="#topic+as.Node.dendrogram">as.Node.dendrogram</a>()</code>,
<code><a href="#topic+as.Node.list">as.Node.list</a>()</code>,
<code><a href="#topic+as.Node.phylo">as.Node.phylo</a>()</code>,
<code><a href="#topic+as.Node">as.Node</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(rpart)) {
   fit &lt;- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)
   as.Node(fit)
}
</code></pre>

<hr>
<h2 id='as.phylo.Node'>Convert a <code>Node</code> to a phylo object from the ape package.</h2><span id='topic+as.phylo.Node'></span>

<h3>Description</h3>

<p>This method requires the ape package to be installed and loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.phylo.Node(x, heightAttribute = DefaultPlotHeight, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.phylo.Node_+3A_x">x</code></td>
<td>
<p>The root <code>Node</code> of the tree or sub-tree to be converted</p>
</td></tr>
<tr><td><code id="as.phylo.Node_+3A_heightattribute">heightAttribute</code></td>
<td>
<p>The attribute (field name or function) storing the height</p>
</td></tr>
<tr><td><code id="as.phylo.Node_+3A_...">...</code></td>
<td>
<p>any other argument</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ape phylo conversions: 
<code><a href="#topic+GetPhyloNr">GetPhyloNr</a>()</code>,
<code><a href="#topic+as.Node.phylo">as.Node.phylo</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
data(acme)
acmephylo &lt;- as.phylo(acme)
#plot(acmephylo)


</code></pre>

<hr>
<h2 id='averageBranchingFactor'>Calculate the average number of branches each non-leaf has</h2><span id='topic+averageBranchingFactor'></span>

<h3>Description</h3>

<p>Calculate the average number of branches each non-leaf has
</p>


<h3>Usage</h3>

<pre><code class='language-R'>averageBranchingFactor(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="averageBranchingFactor_+3A_node">node</code></td>
<td>
<p>The node to calculate the average branching factor for</p>
</td></tr>
</table>

<hr>
<h2 id='CheckNameReservedWord'>Checks whether <code>name</code> is a reserved word, as defined in <code>NODE_RESERVED_NAMES_CONST</code>.</h2><span id='topic+CheckNameReservedWord'></span>

<h3>Description</h3>

<p>Checks whether <code>name</code> is a reserved word, as defined in <code>NODE_RESERVED_NAMES_CONST</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckNameReservedWord(name, check = c("check", "no-warn", "no-check"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckNameReservedWord_+3A_name">name</code></td>
<td>
<p>the name to check</p>
</td></tr>
<tr><td><code id="CheckNameReservedWord_+3A_check">check</code></td>
<td>
<p>Either
</p>

<ul>
<li><p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li><p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li><p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='Climb'>Climb a tree from parent to children, by provided criteria.</h2><span id='topic+Climb'></span>

<h3>Description</h3>

<p>This method lets you climb the tree, from crutch to crutch. On each <code>Node</code>, the
<code>Climb</code> finds the first child having attribute value equal to the the provided argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>#node$Climb(...)
Climb(node, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Climb_+3A_node">node</code></td>
<td>
<p>The root <code><a href="#topic+Node">Node</a></code> of the tree or subtree to climb</p>
</td></tr>
<tr><td><code id="Climb_+3A_...">...</code></td>
<td>
<p>an attribute-value pairlist to be searched. For brevity, you can also provide a character vector to search for names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>Node</code> having path <code>...</code>, or <code>NULL</code> if such a path does not exist
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>
<p><code><a href="#topic+Navigate">Navigate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)

#the following are all equivalent
Climb(acme, 'IT', 'Outsource')
Climb(acme, name = 'IT', name = 'Outsource')
Climb(acme, 'IT')$Climb('Outsource')
Navigate(acme, path = "IT/Outsource")

Climb(acme, name = 'IT')

Climb(acme, position = c(2, 1))
#or, equivalent:
Climb(acme, position = 2, position = 1)
Climb(acme, name = "IT", cost = 250000)

tree &lt;- CreateRegularTree(5, 2)
tree$Climb(c("1", "1"), position = c(2, 2))$path

</code></pre>

<hr>
<h2 id='Clone'>Clone a tree (creates a deep copy)</h2><span id='topic+Clone'></span>

<h3>Description</h3>

<p>The method also clones object attributes (such as the formatters), if desired.
If the method is called on a non-root, then the parent relationship is not cloned,
and the resulting <code><a href="#topic+Node">Node</a></code> will be a root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Clone(node, pruneFun = NULL, attributes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Clone_+3A_node">node</code></td>
<td>
<p>the root node of the tree or sub-tree to clone</p>
</td></tr>
<tr><td><code id="Clone_+3A_prunefun">pruneFun</code></td>
<td>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</td></tr>
<tr><td><code id="Clone_+3A_attributes">attributes</code></td>
<td>
<p>if FALSE, then R class attributes (e.g. formatters and grViz styles)
are not cloned. This makes the method faster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the clone of the tree or sub-tree
</p>


<h3>See Also</h3>

<p>SetFormat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
acmeClone &lt;- Clone(acme)
acmeClone$name &lt;- "New Acme"
# acmeClone does not point to the same reference object anymore:
acme$name

#cloning a subtree
data(acme)
itClone &lt;- Clone(acme$IT)
itClone$isRoot


</code></pre>

<hr>
<h2 id='CreateRandomTree'>Create a tree for demo and testing</h2><span id='topic+CreateRandomTree'></span>

<h3>Description</h3>

<p>Create a tree for demo and testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateRandomTree(nodes = 100, root = Node$new("1"), id = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateRandomTree_+3A_nodes">nodes</code></td>
<td>
<p>The number of nodes to create</p>
</td></tr>
<tr><td><code id="CreateRandomTree_+3A_root">root</code></td>
<td>
<p>the previous node (for recursion, typically use default value)</p>
</td></tr>
<tr><td><code id="CreateRandomTree_+3A_id">id</code></td>
<td>
<p>The id (for recursion)</p>
</td></tr>
</table>

<hr>
<h2 id='CreateRegularTree'>Create a tree for demo and testing</h2><span id='topic+CreateRegularTree'></span>

<h3>Description</h3>

<p>Create a tree for demo and testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateRegularTree(height = 5, branchingFactor = 3, parent = Node$new("1"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateRegularTree_+3A_height">height</code></td>
<td>
<p>the number of levels</p>
</td></tr>
<tr><td><code id="CreateRegularTree_+3A_branchingfactor">branchingFactor</code></td>
<td>
<p>the number of children per node</p>
</td></tr>
<tr><td><code id="CreateRegularTree_+3A_parent">parent</code></td>
<td>
<p>the parent node (for recursion)</p>
</td></tr>
</table>

<hr>
<h2 id='Cumulate'>Cumulate values among siblings</h2><span id='topic+Cumulate'></span>

<h3>Description</h3>

<p>For example, you can sum up values of siblings before
this <code>Node</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cumulate(node, attribute, aggFun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cumulate_+3A_node">node</code></td>
<td>
<p>The node on which we want to cumulate</p>
</td></tr>
<tr><td><code id="Cumulate_+3A_attribute">attribute</code></td>
<td>
<p>determines what is collected. The <code>attribute</code> can be
</p>

<ul>
<li><p> a.) the name of a <b>field</b> or a <b>property/active</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("p")</code> or <code>acme$Get("position")</code>
</p>
</li>
<li><p> b.) the name of a <b>method</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("levelZeroBased")</code>, where e.g. <code>acme$levelZeroBased &lt;- function() acme$level - 1</code>
</p>
</li>
<li><p> c.) a <b>function</b>, whose first argument must be a <code>Node</code> e.g. <code>acme$Get(function(node) node$cost * node$p)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="Cumulate_+3A_aggfun">aggFun</code></td>
<td>
<p>the aggregation function to be applied to the children's <code>attributes</code></p>
</td></tr>
<tr><td><code id="Cumulate_+3A_...">...</code></td>
<td>
<p>any arguments to be passed on to attribute (in case it's a function)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
acme$Do(function(x) x$cost &lt;- Aggregate(x, "cost", sum), traversal = "post-order")
acme$Do(function(x) x$cumCost &lt;- Cumulate(x, "cost", sum))
print(acme, "cost", "cumCost")

</code></pre>

<hr>
<h2 id='data.tree'>data.tree: Hierarchical Data Structures</h2><span id='topic+data.tree'></span><span id='topic+data.tree-package'></span>

<h3>Description</h3>

<p><code>data.tree</code> is to hierarchical data what <code>data.frame</code> is to tabular data: An extensible, general purpose structure to store, manipulate, 
and display hierarchical data.
</p>


<h3>Introduction</h3>

<p>Hierarchical data is ubiquitous in statistics and programming (XML, search trees, family trees, classification, file system, etc.). However, no general-use <b>tree data structure</b> is available in R. 
Where tabular data has <code>data.frame</code>, hierarchical data is often modeled in lists of lists or similar makeshifts. These
structures are often difficult to manage.
This is where the <code>data.tree</code> package steps in. It lets you build trees of hierarchical
data for various uses: to print, to rapid prototype search algorithms, to test out new classification algorithms, and much more.
</p>


<h3>Tree Traversal</h3>

<p><code>data.tree</code> allows to <code><a href="#topic+Traverse">Traverse</a></code> trees in various orders (pre-order, post-order, level, etc.), and it lets you run operations on <code><a href="#topic+Node">Node</a>s</code> via
<code><a href="#topic+Do">Do</a></code>. 
Similarly, you can collect and store data while traversing a tree using the <code><a href="#topic+Get">Get</a></code> and the <code><a href="#topic+Set">Set</a></code> methods.
</p>


<h3>Methods</h3>

<p>The package also contains utility functions to <code><a href="#topic+Sort">Sort</a></code>, to <code><a href="#topic+Prune">Prune</a></code>, to <code><a href="#topic+Aggregate">Aggregate</a></code> and <code><a href="#topic+Cumulate">Cumulate</a></code> 
and to <code><a href="base.html#topic+print">print</a></code> in custom formats.
</p>


<h3>Construction and Conversion</h3>

<p>The package also contains many conversions from and to data.tree structures. Check out the see also section of <code><a href="#topic+as.Node">as.Node</a></code>.
</p>
<p>You can construct a tree from a <code>data.frame</code> using <code><a href="#topic+as.Node.data.frame">as.Node.data.frame</a></code>, and convert it back using <code><a href="#topic+as.data.frame.Node">as.data.frame.Node</a></code>.
Similar options exist for list of lists. 
For more specialized conversions, see <code><a href="#topic+as.dendrogram.Node">as.dendrogram.Node</a></code>, <code><a href="#topic+as.Node.dendrogram">as.Node.dendrogram</a></code>, 
<code><a href="#topic+as.phylo.Node">as.phylo.Node</a></code> and <code><a href="#topic+as.Node.phylo">as.Node.phylo</a></code>
</p>
<p>Finally, easy conversion options from and to list, dataframe, JSON, YAML, igraph, ape, rpart, party and more exist:
</p>

<ul>
<li><p>list: both directions
</p>
</li>
<li><p>dataframe: both directions
</p>
</li>
<li><p>JSON, YAML: both directions, via lists
</p>
</li>
<li><p>igraph: from igraph to data.tree
</p>
</li>
<li><p>ape: both directions
</p>
</li>
<li><p>rpart: from rpart to data.tree
</p>
</li>
<li><p>party: from party to data.tree
</p>
</li></ul>



<h3>Node and Reference Semantics</h3>

<p>The entry point to the package is <code><a href="#topic+Node">Node</a></code>. Each tree is composed of a number of <code>Node</code>s, referencing each other.
</p>
<p>One of most important things to note about <code>data.tree</code> is that it exhibits <b>reference semantics</b>. In a nutshell, this means that you can modify 
your tree along the way, without having to reassign it to a variable after each modification. By and large, this is a rather exceptional behavior
in R, where value-semantics is king most of the time.
</p>


<h3>Applications</h3>

<p><code>data.tree</code> is not optimised for computational speed, but for implementation speed. Namely, its memory
footprint is relatively large compared to traditional R data structures. However, it can easily handle trees with
several thousand nodes, and once a tree is constructed, operations on it are relatively fast.
data.tree is always useful when
</p>

<ul>
<li><p>you want to develop and test a new algorithm
</p>
</li>
<li><p>you want to import and convert tree structures (it imports and exports to list-of-list, data.frame, yaml, json, igraph, dendrogram, phylo and more)
</p>
</li>
<li><p>you want to play around with data, display it and get an understanding
</p>
</li>
<li><p>you want to test another package, to compare it with your own results
</p>
</li>
<li><p>you need to do homework
</p>
</li></ul>

<p>For a quick overview of the features, read the <code><a href="#topic+data.tree">data.tree</a></code> vignette by running <code>vignette("data.tree")</code>. For stylized
applications, see <code>vignette("applications", package='data.tree')</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Christoph Glur <a href="mailto:christoph.glur@powerpartners.pro">christoph.glur@powerpartners.pro</a> (R interface)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Russ Hyde (improve dependencies) [contributor]
</p>
</li>
<li><p> Chris Hammill (improve getting) [contributor]
</p>
</li>
<li><p> Facundo Munoz (improve list conversion) [contributor]
</p>
</li>
<li><p> Markus Wamser (fixed some typos) [contributor]
</p>
</li>
<li><p> Pierre Formont (additional features) [contributor]
</p>
</li>
<li><p> Kent Russel (documentation) [contributor]
</p>
</li>
<li><p> Noam Ross (fixes) [contributor]
</p>
</li>
<li><p> Duncan Garmonsway (fixes) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>
<p>For more details, see the <code>data.tree</code> vignette by running: <code>vignette("data.tree")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
print(acme)
acme$attributesAll
acme$count
acme$totalCount
acme$isRoot
acme$height
print(acme, "p", "cost")

outsource &lt;- acme$IT$Outsource
class(outsource)
print(outsource)
outsource$attributes
outsource$isLeaf
outsource$level
outsource$path
outsource$p
outsource$parent$name
outsource$root$name
outsource$expCost &lt;- outsource$p * outsource$cost
print(acme, "expCost")

acme$Get("p")
acme$Do(function(x) x$expCost &lt;- x$p * x$cost)
acme$Get("expCost", filterFun = isLeaf)

ToDataFrameTable(acme, "name", "p", "cost", "level", "pathString")
ToDataFrameTree(acme, "name", "p", "cost", "level")
ToDataFrameNetwork(acme, "p", "cost")


</code></pre>

<hr>
<h2 id='DefaultPlotHeight'>Calculates the height of a <code>Node</code> given the height of the root.</h2><span id='topic+DefaultPlotHeight'></span>

<h3>Description</h3>

<p>This function puts leafs at the bottom (not hanging), and makes edges equally long.
Useful for easy plotting with third-party packages, e.g. if you have no specific height
attribute, e.g. with <code><a href="#topic+as.dendrogram.Node">as.dendrogram.Node</a></code>, <code><a href="#topic+ToNewick">ToNewick</a></code>,
and <code><a href="#topic+as.phylo.Node">as.phylo.Node</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DefaultPlotHeight(node, rootHeight = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DefaultPlotHeight_+3A_node">node</code></td>
<td>
<p>The node</p>
</td></tr>
<tr><td><code id="DefaultPlotHeight_+3A_rootheight">rootHeight</code></td>
<td>
<p>The height of the root</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
dacme &lt;- as.dendrogram(acme, heightAttribute = function(x) DefaultPlotHeight(x, 200))
plot(dacme, center = TRUE)

</code></pre>

<hr>
<h2 id='Distance'>Find the distance between two nodes of the same tree</h2><span id='topic+Distance'></span>

<h3>Description</h3>

<p>The distance is measured as the number of edges that
need to be traversed to reach node2 when starting 
from node1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Distance(node1, node2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Distance_+3A_node1">node1</code></td>
<td>
<p>the first node in the tree</p>
</td></tr>
<tr><td><code id="Distance_+3A_node2">node2</code></td>
<td>
<p>the second node in the same tree</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
Distance(FindNode(acme, "Outsource"), FindNode(acme, "Research"))

</code></pre>

<hr>
<h2 id='Do'>Executes a function on a set of nodes</h2><span id='topic+Do'></span>

<h3>Description</h3>

<p>Executes a function on a set of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'># OO-style:
# node$Do(fun, 
#         ..., 
#         traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"), 
#         pruneFun = NULL, 
#         filterFun = NULL)
         
# traditional:
Do(nodes, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Do_+3A_nodes">nodes</code></td>
<td>
<p>The nodes on which to perform the Get (typically obtained via <code><a href="#topic+Traverse">Traverse</a></code>)</p>
</td></tr>
<tr><td><code id="Do_+3A_fun">fun</code></td>
<td>
<p>the function to execute. The function is expected to be either a Method, or to take a 
Node as its first argument</p>
</td></tr>
<tr><td><code id="Do_+3A_...">...</code></td>
<td>
<p>any additional parameters to be passed on to fun</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>
<p><code><a href="#topic+Get">Get</a></code>
</p>
<p><code><a href="#topic+Set">Set</a></code>
</p>
<p><code><a href="#topic+Traverse">Traverse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
traversal &lt;- Traverse(acme)
Do(traversal, function(node) node$expectedCost &lt;- node$p * node$cost)
print(acme, "expectedCost")

</code></pre>

<hr>
<h2 id='FindNode'>Find a node by name in the (sub-)tree</h2><span id='topic+FindNode'></span>

<h3>Description</h3>

<p>Scans the entire sub-tree spanned by <code>node</code> and returns the first <code><a href="#topic+Node">Node</a></code>
having the <code>name</code> specified. This is mainly useful for trees whose name is unique.
If <code><a href="#topic+AreNamesUnique">AreNamesUnique</a></code> is <code>FALSE</code>, i.e. if there is more than one <code>Node</code>
called <code>name</code> in the tree, then it is undefined which one will be returned.
Also note that this method is not particularly fast. See examples for a faster way to
index large trees, if you need to do multiple searches. See <code><a href="#topic+Traverse">Traverse</a></code> if
you need to find multiple <code>Nodes</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindNode(node, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindNode_+3A_node">node</code></td>
<td>
<p>The root <code>Node</code> of the tree or sub-tree to search</p>
</td></tr>
<tr><td><code id="FindNode_+3A_name">name</code></td>
<td>
<p>The name of the <code>Node</code> to be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first <code>Node</code> whose name matches, or <code>NULL</code> if no such <code>Node</code> is
found.
</p>


<h3>See Also</h3>

<p>AreNamesUnique, Traverse
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
FindNode(acme, "Outsource")

#re-usable hashed index for multiple searches:
if(!AreNamesUnique(acme)) stop("Hashed index works for unique names only!")
trav &lt;- Traverse(acme, "level")
names(trav) &lt;- Get(trav, "name")
nameIndex &lt;- as.environment(trav)
#you could also use hash from package hash instead!
#nameIndex &lt;- hash(trav)
nameIndex$Outsource
nameIndex$IT


</code></pre>

<hr>
<h2 id='FormatFixedDecimal'>Format a Number as a Decimal</h2><span id='topic+FormatFixedDecimal'></span>

<h3>Description</h3>

<p>Simple function that can be used as a format function when converting trees to a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormatFixedDecimal(x, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FormatFixedDecimal_+3A_x">x</code></td>
<td>
<p>a numeric scalar or vector</p>
</td></tr>
<tr><td><code id="FormatFixedDecimal_+3A_digits">digits</code></td>
<td>
<p>the number of digits to print after the decimal point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string corresponding to x, suitable for printing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
print(acme, prob = acme$Get("p", format = function(x) FormatFixedDecimal(x, 4)))

</code></pre>

<hr>
<h2 id='FormatPercent'>Format a Number as a Percentage</h2><span id='topic+FormatPercent'></span>

<h3>Description</h3>

<p>This utility method can be used as a format function when converting trees to a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormatPercent(x, digits = 2, format = "f", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FormatPercent_+3A_x">x</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="FormatPercent_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print</p>
</td></tr>
<tr><td><code id="FormatPercent_+3A_format">format</code></td>
<td>
<p>The format to use</p>
</td></tr>
<tr><td><code id="FormatPercent_+3A_...">...</code></td>
<td>
<p>Any other argument passed to formatC</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string corresponding to x, suitable for printing
</p>


<h3>See Also</h3>

<p>formatC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
print(acme, prob = acme$Get("p", format = FormatPercent))

</code></pre>

<hr>
<h2 id='Get'>Traverse a Tree and Collect Values</h2><span id='topic+Get'></span>

<h3>Description</h3>

<p>The <code>Get</code> method is one of the most important ones of the <code>data.tree</code> package. It lets you traverse a tree
and collect values along the way. Alternatively, you can call a method or a function on each <code><a href="#topic+Node">Node</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># OO-style:
#node$Get(attribute, 
#        ..., 
#        traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"), 
#        pruneFun = NULL, 
#        filterFun = NULL, 
#        format = FALSE, 
#        inheritFromAncestors = FALSE)
         
# traditional:
Get(nodes, 
    attribute, 
    ..., 
    format = FALSE, 
    inheritFromAncestors = FALSE, 
    simplify = c(TRUE, FALSE, "array", "regular"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get_+3A_nodes">nodes</code></td>
<td>
<p>The nodes on which to perform the Get (typically obtained via <code><a href="#topic+Traverse">Traverse</a></code>)</p>
</td></tr>
<tr><td><code id="Get_+3A_attribute">attribute</code></td>
<td>
<p>determines what is collected. The <code>attribute</code> can be
</p>

<ul>
<li><p> a.) the name of a <b>field</b> or a <b>property/active</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("p")</code> or <code>acme$Get("position")</code>
</p>
</li>
<li><p> b.) the name of a <b>method</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("levelZeroBased")</code>, where e.g. <code>acme$levelZeroBased &lt;- function() acme$level - 1</code>
</p>
</li>
<li><p> c.) a <b>function</b>, whose first argument must be a <code>Node</code> e.g. <code>acme$Get(function(node) node$cost * node$p)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="Get_+3A_...">...</code></td>
<td>
<p>in case the <code>attribute</code> is a function or a method, the ellipsis is passed to it as additional arguments.</p>
</td></tr>
<tr><td><code id="Get_+3A_format">format</code></td>
<td>
<p>if <code>FALSE</code> (the default), no formatting is being used. If <code>TRUE</code>, then the first formatter (if any) found along the ancestor path is being used for formatting 
(see <code><a href="#topic+SetFormat">SetFormat</a></code>). If <code>format</code> is a function, then the collected value is passed to that function, and the result is returned.</p>
</td></tr>
<tr><td><code id="Get_+3A_inheritfromancestors">inheritFromAncestors</code></td>
<td>
<p>if <code>TRUE</code>, then the path above a <code>Node</code> is searched to get the <code>attribute</code> in case it is NULL.</p>
</td></tr>
<tr><td><code id="Get_+3A_simplify">simplify</code></td>
<td>
<p>same as <code><a href="base.html#topic+sapply">sapply</a></code>, i.e. TRUE, FALSE or &quot;array&quot;. Additionally, you can specify &quot;regular&quot; if
each returned value is of length &gt; 1, and equally named. See below for an example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the <code>atrributes</code> collected during traversal, in traversal order. <code>NULL</code> is converted
to NA, such that <code>length(Node$Get) == Node$totalCount</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>
<p><code><a href="#topic+Set">Set</a></code>
</p>
<p><code><a href="#topic+Do">Do</a></code>
</p>
<p><code><a href="#topic+Traverse">Traverse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
acme$Get("level")
acme$Get("totalCount")
 

acme$Get(function(node) node$cost * node$p,
         filterFun = isLeaf)

#This is equivalent:
nodes &lt;- Traverse(acme, filterFun = isLeaf)
Get(nodes, function(node) node$cost * node$p)

   
#simplify = "regular" will preserve names
acme$Get(function(x) c(position = x$position, level = x$level), simplify = "regular")
 
</code></pre>

<hr>
<h2 id='GetAttribute'>Get an attribute from a Node.</h2><span id='topic+GetAttribute'></span>

<h3>Description</h3>

<p>Get an attribute from a Node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetAttribute(
  node,
  attribute,
  ...,
  format = FALSE,
  inheritFromAncestors = FALSE,
  nullAsNa = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetAttribute_+3A_node">node</code></td>
<td>
<p>The <code><a href="#topic+Node">Node</a></code> from which the <code>attribute</code> should be fetched.</p>
</td></tr>
<tr><td><code id="GetAttribute_+3A_attribute">attribute</code></td>
<td>
<p>determines what is collected. The <code>attribute</code> can be
</p>

<ul>
<li><p> a.) the name of a <b>field</b> or a <b>property/active</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("p")</code> or <code>acme$Get("position")</code>
</p>
</li>
<li><p> b.) the name of a <b>method</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("levelZeroBased")</code>, where e.g. <code>acme$levelZeroBased &lt;- function() acme$level - 1</code>
</p>
</li>
<li><p> c.) a <b>function</b>, whose first argument must be a <code>Node</code> e.g. <code>acme$Get(function(node) node$cost * node$p)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="GetAttribute_+3A_...">...</code></td>
<td>
<p>in case the <code>attribute</code> is a function or a method, the ellipsis is passed to it as additional arguments.</p>
</td></tr>
<tr><td><code id="GetAttribute_+3A_format">format</code></td>
<td>
<p>if <code>FALSE</code> (the default), no formatting is being used. If <code>TRUE</code>, then the first formatter (if any) found along the ancestor path is being used for formatting 
(see <code><a href="#topic+SetFormat">SetFormat</a></code>). If <code>format</code> is a function, then the collected value is passed to that function, and the result is returned.</p>
</td></tr>
<tr><td><code id="GetAttribute_+3A_inheritfromancestors">inheritFromAncestors</code></td>
<td>
<p>if <code>TRUE</code>, then the path above a <code>Node</code> is searched to get the <code>attribute</code> in case it is NULL.</p>
</td></tr>
<tr><td><code id="GetAttribute_+3A_nullasna">nullAsNa</code></td>
<td>
<p>If TRUE (the default), then NULL is returned as NA. Otherwise it is returned as NULL.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
GetAttribute(acme$IT$Outsource, "cost")

</code></pre>

<hr>
<h2 id='GetPhyloNr'>Determine the number a <code>Node</code> has after conversion to a phylo object</h2><span id='topic+GetPhyloNr'></span>

<h3>Description</h3>

<p>Use this function when plotting a Node as a phylo, e.g. to set custom
labels to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetPhyloNr(x, type = c("node", "edge"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetPhyloNr_+3A_x">x</code></td>
<td>
<p>The Node</p>
</td></tr>
<tr><td><code id="GetPhyloNr_+3A_type">type</code></td>
<td>
<p>Either &quot;node&quot; (the default) or &quot;edge&quot; (to get the number of the edge from <code>x</code> to its parent)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer representing the node
</p>


<h3>See Also</h3>

<p>Other ape phylo conversions: 
<code><a href="#topic+as.Node.phylo">as.Node.phylo</a>()</code>,
<code><a href="#topic+as.phylo.Node">as.phylo.Node</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
library(data.tree)
data(acme)
ap &lt;- as.phylo(acme)
#plot(ap)
#nodelabels("IT Dep.", GetPhyloNr(Climb(acme, "IT")))
#edgelabels("Good!", GetPhyloNr(Climb(acme, "IT", "Switch to R"), "edge"))


</code></pre>

<hr>
<h2 id='isLeaf'>Check if a <code>Node</code> is a leaf</h2><span id='topic+isLeaf'></span>

<h3>Description</h3>

<p>Check if a <code>Node</code> is a leaf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isLeaf(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isLeaf_+3A_node">node</code></td>
<td>
<p>The Node to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the Node is a leaf, FALSE otherwise
</p>

<hr>
<h2 id='isNotLeaf'>Check if a <code>Node</code> is not a leaf</h2><span id='topic+isNotLeaf'></span>

<h3>Description</h3>

<p>Check if a <code>Node</code> is not a leaf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNotLeaf(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNotLeaf_+3A_node">node</code></td>
<td>
<p>The Node to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FALSE if the Node is a leaf, TRUE otherwise
</p>

<hr>
<h2 id='isNotRoot'>Check if a <code>Node</code> is not a root</h2><span id='topic+isNotRoot'></span>

<h3>Description</h3>

<p>Check if a <code>Node</code> is not a root
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNotRoot(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNotRoot_+3A_node">node</code></td>
<td>
<p>The Node to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FALSE if the Node is the root, TRUE otherwise
</p>

<hr>
<h2 id='isRoot'>Check if a <code>Node</code> is the root</h2><span id='topic+isRoot'></span>

<h3>Description</h3>

<p>Check if a <code>Node</code> is the root
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isRoot(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isRoot_+3A_node">node</code></td>
<td>
<p>The Node to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the Node is the root, FALSE otherwise
</p>

<hr>
<h2 id='mushroom'>Sample Data: Data Used by the ID3 Vignette</h2><span id='topic+mushroom'></span>

<h3>Description</h3>

<p>mushroom contains attributes of mushrooms. We can use this data to predict a
mushroom's toxicity based on its attributes.
The attributes available in the data set are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mushroom)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Details</h3>


<ul>
<li><p> color the color of a mushroom
</p>
</li>
<li><p> size whether a mushroom is small or large
</p>
</li>
<li><p> points whether a mushroom has points
</p>
</li>
<li><p> edibility whether a mushroom is edible or toxic
</p>
</li></ul>


<hr>
<h2 id='Navigate'>Navigate to another node by relative path.</h2><span id='topic+Navigate'></span>

<h3>Description</h3>

<p>Navigate to another node by relative path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Navigate(node, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Navigate_+3A_node">node</code></td>
<td>
<p>The starting <code><a href="#topic+Node">Node</a></code> to navigate</p>
</td></tr>
<tr><td><code id="Navigate_+3A_path">path</code></td>
<td>
<p>A string or a character vector describing the path to navigate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>path</code> is always relative to the <code>node</code>. Navigation
to the parent is defined by <code>..</code>, whereas navigation to a child
is defined via the child's name.
If path is provided as a string, then the navigation steps are separated
by '/'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Climb">Climb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
Navigate(acme$Research, "../IT/Outsource")
Navigate(acme$Research, c("..", "IT", "Outsource"))

</code></pre>

<hr>
<h2 id='Node'>Create a <code>data.tree</code> Structure With <code>Nodes</code></h2><span id='topic+Node'></span>

<h3>Description</h3>

<p><code>Node</code> is at the very heart of the <code>data.tree</code> package. All trees are constructed
by tying together <code>Node</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># n1 &lt;- Node$new("Node 1")
</code></pre>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object
</p>


<h3>Details</h3>

<p>Assemble <code>Node</code> objects into a <code>data.tree</code>
structure and use the traversal methods to set, get, and perform operations on it. Typically, you construct larger tree 
structures by converting from <code>data.frame</code>, <code>list</code>, or other formats.
</p>
<p>Most methods (e.g. <code>node$Sort()</code>) also have a functional form (e.g. <code>Sort(node)</code>)
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>name</code></dt><dd><p>Gets or sets the name of a <code>Node</code>. For example <code>Node$name &lt;- "Acme"</code>.</p>
</dd>
<dt><code>printFormatters</code></dt><dd><p>gets or sets the formatters used to print a <code>Node</code>.
Set this as a list to a root node.
The different formatters are h (horizontal), v (vertical), l (L), j (junction), and s (separator). 
For example, you can set the formatters to <code>list(h = "\u2500" , v = "\u2502", l = "\u2514",  j = "\u251C", s = " ")</code>
to get a similar behavior as in <code>fs::dir_tree()</code>.
The defaults are: <code>list(h = "--" , v = "\u00A6", l = "\u00B0", j = "\u00A6", s = " ")</code></p>
</dd>
<dt><code>parent</code></dt><dd><p>Gets or sets the parent <code>Node</code> of a <code>Node</code>. Only set this if you know what you are doing, as you might mess up the tree structure!</p>
</dd>
<dt><code>children</code></dt><dd><p>Gets or sets the children <code>list</code> of a <code>Node</code>. Only set this if you know what you are doing, as you might mess up the tree structure!</p>
</dd>
<dt><code>isLeaf</code></dt><dd><p>Returns <code>TRUE</code> if the <code>Node</code> is a leaf, <code>FALSE</code> otherwise</p>
</dd>
<dt><code>isRoot</code></dt><dd><p>Returns <code>TRUE</code> if the <code>Node</code> is the root, <code>FALSE</code> otherwise</p>
</dd>
<dt><code>count</code></dt><dd><p>Returns the number of children of a <code>Node</code></p>
</dd>
<dt><code>totalCount</code></dt><dd><p>Returns the total number of <code>Node</code>s in the tree</p>
</dd>
<dt><code>path</code></dt><dd><p>Returns a vector of mode <code>character</code> containing the names of the <code>Node</code>s in the path from the root to this <code>Node</code></p>
</dd>
<dt><code>pathString</code></dt><dd><p>Returns a string representing the path to this <code>Node</code>, separated by backslash</p>
</dd>
<dt><code>position</code></dt><dd><p>The position of a <code>Node</code> within its siblings</p>
</dd>
<dt><code>fields</code></dt><dd><p>Will be deprecated, use <code>attributes</code> instead</p>
</dd>
<dt><code>fieldsAll</code></dt><dd><p>Will be deprecated, use <code>attributesAll</code> instead</p>
</dd>
<dt><code>attributes</code></dt><dd><p>The attributes defined on this specific node</p>
</dd>
<dt><code>attributesAll</code></dt><dd><p>The distinct union of attributes defined on all the nodes in the tree spanned by this <code>Node</code></p>
</dd>
<dt><code>levelName</code></dt><dd><p>Returns the name of the <code>Node</code>, preceded by level times '*'. Useful for printing and not typically called by package users.</p>
</dd>
<dt><code>leaves</code></dt><dd><p>Returns a list containing all the leaf <code>Node</code>s</p>
</dd>
<dt><code>leafCount</code></dt><dd><p>Returns the number of leaves are below a <code>Node</code></p>
</dd>
<dt><code>level</code></dt><dd><p>Returns an integer representing the level of a <code>Node</code>. For example, the root has level 1.</p>
</dd>
<dt><code>height</code></dt><dd><p>Returns max(level) of any of the <code>Nodes</code> of the tree</p>
</dd>
<dt><code>isBinary</code></dt><dd><p>Returns <code>TRUE</code> if all <code>Node</code>s in the tree (except the leaves) have <code>count = 2</code></p>
</dd>
<dt><code>root</code></dt><dd><p>Returns the root of a <code>Node</code> in a tree.</p>
</dd>
<dt><code>siblings</code></dt><dd><p>Returns a <code>list</code> containing all the siblings of this <code>Node</code></p>
</dd>
<dt><code>averageBranchingFactor</code></dt><dd><p>Returns the average number of crotches below this <code>Node</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Node-new"><code>Node$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-AddChild"><code>Node$AddChild()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-AddChildNode"><code>Node$AddChildNode()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-AddSibling"><code>Node$AddSibling()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-AddSiblingNode"><code>Node$AddSiblingNode()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-RemoveChild"><code>Node$RemoveChild()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-RemoveAttribute"><code>Node$RemoveAttribute()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Sort"><code>Node$Sort()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Revert"><code>Node$Revert()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Prune"><code>Node$Prune()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Climb"><code>Node$Climb()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Navigate"><code>Node$Navigate()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Get"><code>Node$Get()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Do"><code>Node$Do()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Set"><code>Node$Set()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-clone"><code>Node$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Node-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Node</code> object. This is often used to create the root of a tree when creating a tree programmatically.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$new(name, check = c("check", "no-warn", "no-check"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name of the node to be created</p>
</dd>
<dt><code>check</code></dt><dd><p>Either
</p>

<ul>
<li><p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li><p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li><p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li></ul>
</dd>
<dt><code>...</code></dt><dd><p>A name-value mapping of node attributes</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'Node' object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>node &lt;- Node$new("mynode", x = 2, y = "value of y")
node$y

</pre>
</div>


<hr>
<a id="method-Node-AddChild"></a>



<h4>Method <code>AddChild()</code></h4>

<p>Creates a <code>Node</code> and adds it as the last sibling as a child to the <code>Node</code> on which this is called.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$AddChild(name, check = c("check", "no-warn", "no-check"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name of the node to be created</p>
</dd>
<dt><code>check</code></dt><dd><p>Either
</p>

<ul>
<li><p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li><p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li><p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li></ul>
</dd>
<dt><code>...</code></dt><dd><p>A name-value mapping of node attributes</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The new <code>Node</code> (invisibly)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>root &lt;- Node$new("myroot", myname = "I'm the root")
root$AddChild("child1", myname = "I'm the favorite child")
child2 &lt;- root$AddChild("child2", myname = "I'm just another child")
child3 &lt;- child2$AddChild("child3", myname = "Grandson of a root!")
print(root, "myname")

</pre>
</div>


<hr>
<a id="method-Node-AddChildNode"></a>



<h4>Method <code>AddChildNode()</code></h4>

<p>Adds a <code>Node</code> as a child to this node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$AddChildNode(child)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>child</code></dt><dd><p>The child <code>"Node"</code> to add.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the child node added (this lets you chain calls)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>root &lt;- Node$new("myroot")
child &lt;- Node$new("mychild")
root$AddChildNode(child)

</pre>
</div>


<hr>
<a id="method-Node-AddSibling"></a>



<h4>Method <code>AddSibling()</code></h4>

<p>Creates a new <code>Node</code> called <code>name</code> and adds it after this <code>Node</code> as a sibling.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$AddSibling(name, check = c("check", "no-warn", "no-check"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name of the node to be created</p>
</dd>
<dt><code>check</code></dt><dd><p>Either
</p>

<ul>
<li><p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li><p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li><p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li></ul>
</dd>
<dt><code>...</code></dt><dd><p>A name-value mapping of node attributes</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the sibling node (this lets you chain calls)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>#' root &lt;- Node$new("myroot")
child &lt;- root$AddChild("child1")
sibling &lt;- child$AddSibling("sibling1")

</pre>
</div>


<hr>
<a id="method-Node-AddSiblingNode"></a>



<h4>Method <code>AddSiblingNode()</code></h4>

<p>Adds a <code>Node</code> after this <code>Node</code>, as a sibling.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$AddSiblingNode(sibling)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sibling</code></dt><dd><p>The <code>"Node"</code> to add as a sibling.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the added sibling node (this lets you chain calls, as in the examples)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>root &lt;- Node$new("myroot")
child &lt;- Node$new("mychild")
sibling &lt;- Node$new("sibling")
root$AddChildNode(child)$AddSiblingNode(sibling)

</pre>
</div>


<hr>
<a id="method-Node-RemoveChild"></a>



<h4>Method <code>RemoveChild()</code></h4>

<p>Remove the child <code>Node</code> called <code>name</code> from a <code>Node</code> and returns it.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$RemoveChild(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name of the node to be created</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the subtree spanned by the removed child.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>node &lt;- Node$new("myroot")$AddChild("mychild")$root
node$RemoveChild("mychild")

</pre>
</div>


<hr>
<a id="method-Node-RemoveAttribute"></a>



<h4>Method <code>RemoveAttribute()</code></h4>

<p>Removes attribute called <code>name</code> from this <code>Node</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$RemoveAttribute(name, stopIfNotAvailable = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name of the node to be created</p>
</dd>
<dt><code>stopIfNotAvailable</code></dt><dd><p>Gives an error if <code>stopIfNotAvailable</code> and the attribute does not exist.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>node &lt;- Node$new("mynode")
node$RemoveAttribute("age", stopIfNotAvailable = FALSE)
node$age &lt;- 27
node$RemoveAttribute("age")
node

</pre>
</div>


<hr>
<a id="method-Node-Sort"></a>



<h4>Method <code>Sort()</code></h4>

<p>Sort children of a <code>Node</code> or an entire <code>data.tree</code> structure
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Sort(attribute, ..., decreasing = FALSE, recursive = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attribute</code></dt><dd><p>determines what is collected. The <code>attribute</code> can be
</p>

<ul>
<li><p> a.) the name of a <b>field</b> or a <b>property/active</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("p")</code> or <code>acme$Get("position")</code>
</p>
</li>
<li><p> b.) the name of a <b>method</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("levelZeroBased")</code>, where e.g. <code>acme$levelZeroBased &lt;- function() acme$level - 1</code>
</p>
</li>
<li><p> c.) a <b>function</b>, whose first argument must be a <code>Node</code> e.g. <code>acme$Get(function(node) node$cost * node$p)</code>
</p>
</li></ul>
</dd>
<dt><code>...</code></dt><dd><p>any parameters to be passed on the the attribute (in case it's a method or a 
function)</p>
</dd>
<dt><code>decreasing</code></dt><dd><p>sort order</p>
</dd>
<dt><code>recursive</code></dt><dd><p>if <code>TRUE</code>, the method will be called recursively on the <code>Node</code>'s children. This allows sorting an entire tree.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>You can sort with respect to any argument of the tree. But note that sorting has
side-effects, meaning that you modify the underlying, original data.tree object structure.
</p>
<p>See also <code><a href="#topic+Sort">Sort</a></code> for the equivalent function.
</p>



<h5>Returns</h5>

<p>Returns the node on which Sort is called, invisibly. This can be useful to chain Node methods.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Do(function(x) x$totalCost &lt;- Aggregate(x, "cost", sum), traversal = "post-order")
Sort(acme, "totalCost", decreasing = FALSE)
print(acme, "totalCost")

</pre>
</div>


<hr>
<a id="method-Node-Revert"></a>



<h4>Method <code>Revert()</code></h4>

<p>Reverts the sort order of a <code>Node</code>'s children.
</p>
<p>See also <code><a href="#topic+Revert">Revert</a></code> for the equivalent function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Revert(recursive = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recursive</code></dt><dd><p>if <code>TRUE</code>, the method will be called recursively on the <code>Node</code>'s children. This allows sorting an entire tree.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>returns the Node invisibly (for chaining)
</p>


<hr>
<a id="method-Node-Prune"></a>



<h4>Method <code>Prune()</code></h4>

<p>Prunes a tree. 
</p>
<p>Pruning refers to removing entire subtrees. This function has side-effects, it modifies your data.tree structure!
</p>
<p>See also <code><a href="#topic+Prune">Prune</a></code> for the equivalent function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Prune(pruneFun)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pruneFun</code></dt><dd><p>allows providing a a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the number of nodes removed
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Do(function(x) x$cost &lt;- Aggregate(x, "cost", sum))
Prune(acme, function(x) x$cost &gt; 700000)
print(acme, "cost")

</pre>
</div>


<hr>
<a id="method-Node-Climb"></a>



<h4>Method <code>Climb()</code></h4>

<p>Climb a tree from parent to children, by provided criteria.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Climb(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>an attribute-value pairlist to be searched. For brevity, you can also provide a character vector to search for names.</p>
</dd>
<dt><code>node</code></dt><dd><p>The root <code><a href="#topic+Node">Node</a></code> of the tree or subtree to climb</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method lets you climb the tree, from crutch to crutch. On each <code>Node</code>, the
<code>Climb</code> finds the first child having attribute value equal to the the provided argument.
</p>
<p>See also <code><a href="#topic+Climb">Climb</a></code> and <code><a href="#topic+Navigate">Navigate</a></code>
</p>
<p>Climb(node, ...)
</p>



<h5>Returns</h5>

<p>the <code>Node</code> having path <code>...</code>, or <code>NULL</code> if such a path does not exist
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)

#the following are all equivalent
Climb(acme, 'IT', 'Outsource')
Climb(acme, name = 'IT', name = 'Outsource')
Climb(acme, 'IT')$Climb('Outsource')
Navigate(acme, path = "IT/Outsource")

Climb(acme, name = 'IT')

Climb(acme, position = c(2, 1))
#or, equivalent:
Climb(acme, position = 2, position = 1)
Climb(acme, name = "IT", cost = 250000)

tree &lt;- CreateRegularTree(5, 2)
tree$Climb(c("1", "1"), position = c(2, 2))$path


</pre>
</div>


<hr>
<a id="method-Node-Navigate"></a>



<h4>Method <code>Navigate()</code></h4>

<p>Navigate to another node by relative path.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Navigate(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>A string or a character vector describing the path to navigate</p>
</dd>
<dt><code>node</code></dt><dd><p>The starting <code><a href="#topic+Node">Node</a></code> to navigate</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The <code>path</code> is always relative to the <code>Node</code>. Navigation
to the parent is defined by <code>..</code>, whereas navigation to a child
is defined via the child's name.
If path is provided as a string, then the navigation steps are separated
by '/'.
</p>
<p>See also <code><a href="#topic+Navigate">Navigate</a></code> and <code><a href="#topic+Climb">Climb</a></code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
Navigate(acme$Research, "../IT/Outsource")
Navigate(acme$Research, c("..", "IT", "Outsource"))

</pre>
</div>


<hr>
<a id="method-Node-Get"></a>



<h4>Method <code>Get()</code></h4>

<p>Traverse a Tree and Collect Values
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Get(
  attribute,
  ...,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),
  pruneFun = NULL,
  filterFun = NULL,
  format = FALSE,
  inheritFromAncestors = FALSE,
  simplify = c(TRUE, FALSE, "array", "regular")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attribute</code></dt><dd><p>determines what is collected. The <code>attribute</code> can be
</p>

<ul>
<li><p> a.) the name of a <b>field</b> or a <b>property/active</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("p")</code> or <code>acme$Get("position")</code>
</p>
</li>
<li><p> b.) the name of a <b>method</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("levelZeroBased")</code>, where e.g. <code>acme$levelZeroBased &lt;- function() acme$level - 1</code>
</p>
</li>
<li><p> c.) a <b>function</b>, whose first argument must be a <code>Node</code> e.g. <code>acme$Get(function(node) node$cost * node$p)</code>
</p>
</li></ul>
</dd>
<dt><code>...</code></dt><dd><p>in case the <code>attribute</code> is a function or a method, the ellipsis is passed to it as additional arguments.</p>
</dd>
<dt><code>traversal</code></dt><dd><p>defines the traversal order to be used. This can be
</p>

<dl>
<dt>pre-order</dt><dd><p>Go to first child, then to its first child, etc.</p>
</dd>
<dt>post-order</dt><dd><p>Go to the first branch's leaf, then to its siblings, and work your way back to the root</p>
</dd>
<dt>in-order</dt><dd><p>Go to the first branch's leaf, then to its parent, and only then to the leaf's sibling</p>
</dd>
<dt>level</dt><dd><p>Collect root, then level 2, then level 3, etc.</p>
</dd>
<dt>ancestor</dt><dd><p>Take a node, then the node's parent, then that node's parent in turn, etc. This ignores the <code>pruneFun</code> </p>
</dd>
<dt>function</dt><dd><p>You can also provide a function, whose sole parameter is a <code><a href="#topic+Node">Node</a></code> object. The function is expected to return the node's next node, a list of the node's next nodes, or NULL.</p>
</dd>
</dl>

<p>Read the data.tree vignette for a detailed explanation of these traversal orders.</p>
</dd>
<dt><code>pruneFun</code></dt><dd><p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</dd>
<dt><code>filterFun</code></dt><dd><p>allows providing a a filter, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>.
Note that if filter returns <code>FALSE</code>, then the node will be excluded from the result (but not the entire subtree).</p>
</dd>
<dt><code>format</code></dt><dd><p>if <code>FALSE</code> (the default), no formatting is being used. If <code>TRUE</code>, then the first formatter (if any) found along the ancestor path is being used for formatting 
(see <code><a href="#topic+SetFormat">SetFormat</a></code>). If <code>format</code> is a function, then the collected value is passed to that function, and the result is returned.</p>
</dd>
<dt><code>inheritFromAncestors</code></dt><dd><p>if <code>TRUE</code>, then the path above a <code>Node</code> is searched to get the <code>attribute</code> in case it is NULL.</p>
</dd>
<dt><code>simplify</code></dt><dd><p>same as <code><a href="base.html#topic+sapply">sapply</a></code>, i.e. TRUE, FALSE or &quot;array&quot;. Additionally, you can specify &quot;regular&quot; if
each returned value is of length &gt; 1, and equally named. See below for an example.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The <code>Get</code> method is one of the most important ones of the <code>data.tree</code> package. It lets you traverse a tree
and collect values along the way. Alternatively, you can call a method or a function on each <code><a href="#topic+Node">Node</a></code>.
</p>
<p>See also <code><a href="#topic+Get">Get</a></code>, <code><a href="#topic+Node">Node</a></code>, <code><a href="#topic+Set">Set</a></code>, <code><a href="#topic+Do">Do</a></code>, <code><a href="#topic+Traverse">Traverse</a></code>
</p>



<h5>Returns</h5>

<p>a vector containing the <code>atrributes</code> collected during traversal, in traversal order. <code>NULL</code> is converted
to NA, such that <code>length(Node$Get) == Node$totalCount</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Get("level")
acme$Get("totalCount")
 

acme$Get(function(node) node$cost * node$p,
         filterFun = isLeaf)

#This is equivalent:
nodes &lt;- Traverse(acme, filterFun = isLeaf)
Get(nodes, function(node) node$cost * node$p)

   
#simplify = "regular" will preserve names
acme$Get(function(x) c(position = x$position, level = x$level), simplify = "regular")
 
</pre>
</div>


<hr>
<a id="method-Node-Do"></a>



<h4>Method <code>Do()</code></h4>

<p>Executes a function on a set of nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Do(
  fun,
  ...,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),
  pruneFun = NULL,
  filterFun = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fun</code></dt><dd><p>the function to execute. The function is expected to be either a Method, or to take a 
Node as its first argument</p>
</dd>
<dt><code>...</code></dt><dd><p>A name-value mapping of node attributes</p>
</dd>
<dt><code>traversal</code></dt><dd><p>defines the traversal order to be used. This can be
</p>

<dl>
<dt>pre-order</dt><dd><p>Go to first child, then to its first child, etc.</p>
</dd>
<dt>post-order</dt><dd><p>Go to the first branch's leaf, then to its siblings, and work your way back to the root</p>
</dd>
<dt>in-order</dt><dd><p>Go to the first branch's leaf, then to its parent, and only then to the leaf's sibling</p>
</dd>
<dt>level</dt><dd><p>Collect root, then level 2, then level 3, etc.</p>
</dd>
<dt>ancestor</dt><dd><p>Take a node, then the node's parent, then that node's parent in turn, etc. This ignores the <code>pruneFun</code> </p>
</dd>
<dt>function</dt><dd><p>You can also provide a function, whose sole parameter is a <code><a href="#topic+Node">Node</a></code> object. The function is expected to return the node's next node, a list of the node's next nodes, or NULL.</p>
</dd>
</dl>

<p>Read the data.tree vignette for a detailed explanation of these traversal orders.</p>
</dd>
<dt><code>pruneFun</code></dt><dd><p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</dd>
<dt><code>filterFun</code></dt><dd><p>allows providing a a filter, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>.
Note that if filter returns <code>FALSE</code>, then the node will be excluded from the result (but not the entire subtree).</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>See also <code><a href="#topic+Node">Node</a></code>, <code><a href="#topic+Get">Get</a></code>, <code><a href="#topic+Set">Set</a></code>, <code><a href="#topic+Traverse">Traverse</a></code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Do(function(node) node$expectedCost &lt;- node$p * node$cost)
print(acme, "expectedCost")

</pre>
</div>


<hr>
<a id="method-Node-Set"></a>



<h4>Method <code>Set()</code></h4>

<p>Traverse a Tree and Assign Values
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Set(
  ...,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),
  pruneFun = NULL,
  filterFun = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>each argument can be a vector of values to be assigned. Recycled.</p>
</dd>
<dt><code>traversal</code></dt><dd><p>defines the traversal order to be used. This can be
</p>

<dl>
<dt>pre-order</dt><dd><p>Go to first child, then to its first child, etc.</p>
</dd>
<dt>post-order</dt><dd><p>Go to the first branch's leaf, then to its siblings, and work your way back to the root</p>
</dd>
<dt>in-order</dt><dd><p>Go to the first branch's leaf, then to its parent, and only then to the leaf's sibling</p>
</dd>
<dt>level</dt><dd><p>Collect root, then level 2, then level 3, etc.</p>
</dd>
<dt>ancestor</dt><dd><p>Take a node, then the node's parent, then that node's parent in turn, etc. This ignores the <code>pruneFun</code> </p>
</dd>
<dt>function</dt><dd><p>You can also provide a function, whose sole parameter is a <code><a href="#topic+Node">Node</a></code> object. The function is expected to return the node's next node, a list of the node's next nodes, or NULL.</p>
</dd>
</dl>

<p>Read the data.tree vignette for a detailed explanation of these traversal orders.</p>
</dd>
<dt><code>pruneFun</code></dt><dd><p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</dd>
<dt><code>filterFun</code></dt><dd><p>allows providing a a filter, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>.
Note that if filter returns <code>FALSE</code>, then the node will be excluded from the result (but not the entire subtree).</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The method takes one or more vectors as an argument. It traverses the tree, whereby the values are picked
from the vector. Also available as OO-style method on <code><a href="#topic+Node">Node</a></code>.
</p>
<p>See also <code><a href="#topic+Node">Node</a></code>, <code><a href="#topic+Get">Get</a></code>, <code><a href="#topic+Do">Do</a></code>, <code><a href="#topic+Traverse">Traverse</a></code>
</p>



<h5>Returns</h5>

<p>invisibly returns the nodes (useful for chaining)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Set(departmentId = 1:acme$totalCount, openingHours = NULL, traversal = "post-order")
acme$Set(head = c("Jack Brown", 
                  "Mona Moneyhead", 
                  "Dr. Frank N. Stein", 
                  "Eric Nerdahl"
                  ),
         filterFun = function(x) !x$isLeaf
        )
print(acme, "departmentId", "head")
 
</pre>
</div>


<hr>
<a id="method-Node-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>For more details see the <code><a href="#topic+data.tree">data.tree</a></code> documentations, or the <code>data.tree</code> vignette: <code>vignette("data.tree")</code>
</p>
<p><code><a href="#topic+Node">Node</a></code>
</p>
<p><code><a href="#topic+Sort">Sort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.tree)
acme &lt;- Node$new("Acme Inc.")
accounting &lt;- acme$AddChild("Accounting")$
              AddSibling("Research")$
              AddChild("New Labs")$
              parent$
              AddSibling("IT")$
              AddChild("Outsource")
print(acme)



## ------------------------------------------------
## Method `Node$new`
## ------------------------------------------------

node &lt;- Node$new("mynode", x = 2, y = "value of y")
node$y


## ------------------------------------------------
## Method `Node$AddChild`
## ------------------------------------------------

root &lt;- Node$new("myroot", myname = "I'm the root")
root$AddChild("child1", myname = "I'm the favorite child")
child2 &lt;- root$AddChild("child2", myname = "I'm just another child")
child3 &lt;- child2$AddChild("child3", myname = "Grandson of a root!")
print(root, "myname")


## ------------------------------------------------
## Method `Node$AddChildNode`
## ------------------------------------------------

root &lt;- Node$new("myroot")
child &lt;- Node$new("mychild")
root$AddChildNode(child)


## ------------------------------------------------
## Method `Node$AddSibling`
## ------------------------------------------------

#' root &lt;- Node$new("myroot")
child &lt;- root$AddChild("child1")
sibling &lt;- child$AddSibling("sibling1")


## ------------------------------------------------
## Method `Node$AddSiblingNode`
## ------------------------------------------------

root &lt;- Node$new("myroot")
child &lt;- Node$new("mychild")
sibling &lt;- Node$new("sibling")
root$AddChildNode(child)$AddSiblingNode(sibling)


## ------------------------------------------------
## Method `Node$RemoveChild`
## ------------------------------------------------

node &lt;- Node$new("myroot")$AddChild("mychild")$root
node$RemoveChild("mychild")


## ------------------------------------------------
## Method `Node$RemoveAttribute`
## ------------------------------------------------

node &lt;- Node$new("mynode")
node$RemoveAttribute("age", stopIfNotAvailable = FALSE)
node$age &lt;- 27
node$RemoveAttribute("age")
node


## ------------------------------------------------
## Method `Node$Sort`
## ------------------------------------------------

data(acme)
acme$Do(function(x) x$totalCost &lt;- Aggregate(x, "cost", sum), traversal = "post-order")
Sort(acme, "totalCost", decreasing = FALSE)
print(acme, "totalCost")


## ------------------------------------------------
## Method `Node$Prune`
## ------------------------------------------------

data(acme)
acme$Do(function(x) x$cost &lt;- Aggregate(x, "cost", sum))
Prune(acme, function(x) x$cost &gt; 700000)
print(acme, "cost")


## ------------------------------------------------
## Method `Node$Climb`
## ------------------------------------------------

data(acme)

#the following are all equivalent
Climb(acme, 'IT', 'Outsource')
Climb(acme, name = 'IT', name = 'Outsource')
Climb(acme, 'IT')$Climb('Outsource')
Navigate(acme, path = "IT/Outsource")

Climb(acme, name = 'IT')

Climb(acme, position = c(2, 1))
#or, equivalent:
Climb(acme, position = 2, position = 1)
Climb(acme, name = "IT", cost = 250000)

tree &lt;- CreateRegularTree(5, 2)
tree$Climb(c("1", "1"), position = c(2, 2))$path



## ------------------------------------------------
## Method `Node$Navigate`
## ------------------------------------------------

data(acme)
Navigate(acme$Research, "../IT/Outsource")
Navigate(acme$Research, c("..", "IT", "Outsource"))


## ------------------------------------------------
## Method `Node$Get`
## ------------------------------------------------

data(acme)
acme$Get("level")
acme$Get("totalCount")
 

acme$Get(function(node) node$cost * node$p,
         filterFun = isLeaf)

#This is equivalent:
nodes &lt;- Traverse(acme, filterFun = isLeaf)
Get(nodes, function(node) node$cost * node$p)

   
#simplify = "regular" will preserve names
acme$Get(function(x) c(position = x$position, level = x$level), simplify = "regular")
 

## ------------------------------------------------
## Method `Node$Do`
## ------------------------------------------------

data(acme)
acme$Do(function(node) node$expectedCost &lt;- node$p * node$cost)
print(acme, "expectedCost")


## ------------------------------------------------
## Method `Node$Set`
## ------------------------------------------------

data(acme)
acme$Set(departmentId = 1:acme$totalCount, openingHours = NULL, traversal = "post-order")
acme$Set(head = c("Jack Brown", 
                  "Mona Moneyhead", 
                  "Dr. Frank N. Stein", 
                  "Eric Nerdahl"
                  ),
         filterFun = function(x) !x$isLeaf
        )
print(acme, "departmentId", "head")
 
</code></pre>

<hr>
<h2 id='NODE_RESERVED_NAMES_CONST'>Names that are reserved by the Node class.</h2><span id='topic+NODE_RESERVED_NAMES_CONST'></span>

<h3>Description</h3>

<p>These are reserved by the Node class, you cannot use these as 
attribute names.
Note also that all attributes starting with a . are reserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NODE_RESERVED_NAMES_CONST
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 43.
</p>

<hr>
<h2 id='plot.Node'>Plot a graph, or get a graphviz dot representation of the tree</h2><span id='topic+plot.Node'></span><span id='topic+ToDiagrammeRGraph'></span><span id='topic+SetNodeStyle'></span><span id='topic+SetEdgeStyle'></span><span id='topic+SetGraphStyle'></span><span id='topic+GetDefaultTooltip'></span>

<h3>Description</h3>

<p>Use these methods to style your graph, and to plot it. The functionality is built around the
DiagrammeR package, so for anything that goes beyond simple plotting, it is recommended to read its 
documentation at https://rich-iannone.github.io/DiagrammeR/docs.html. Note that DiagrammeR is only suggested
by data.tree, so 'plot' only works if you have installed it on your system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Node'
plot(
  x,
  ...,
  direction = c("climb", "descend"),
  pruneFun = NULL,
  output = "graph"
)

ToDiagrammeRGraph(root, direction = c("climb", "descend"), pruneFun = NULL)

SetNodeStyle(node, inherit = TRUE, keepExisting = FALSE, ...)

SetEdgeStyle(node, inherit = TRUE, keepExisting = FALSE, ...)

SetGraphStyle(root, keepExisting = FALSE, ...)

GetDefaultTooltip(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Node_+3A_x">x</code></td>
<td>
<p>The root node of the data.tree structure to plot</p>
</td></tr>
<tr><td><code id="plot.Node_+3A_...">...</code></td>
<td>
<p>For the SetStyle methods, this can be any stlyeName / value pair. See 
https://graphviz.org/Documentation.php for details. For the plot.Node generic method, this is not used.</p>
</td></tr>
<tr><td><code id="plot.Node_+3A_direction">direction</code></td>
<td>
<p>when converting to a network, should the edges point from root to children (&quot;climb&quot;) or from child to parent (&quot;descend&quot;)?</p>
</td></tr>
<tr><td><code id="plot.Node_+3A_prunefun">pruneFun</code></td>
<td>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</td></tr>
<tr><td><code id="plot.Node_+3A_output">output</code></td>
<td>
<p>A string specifying the output type; <code>graph</code> (the default)
renders the graph using the <code><a href="DiagrammeR.html#topic+grViz">grViz()</a></code> function and <code>visNetwork</code> renders the
graph using the <code><a href="DiagrammeR.html#topic+visnetwork">visnetwork()</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.Node_+3A_root">root</code></td>
<td>
<p>The root <code><a href="#topic+Node">Node</a></code> of the data.tree structure to visualize.</p>
</td></tr>
<tr><td><code id="plot.Node_+3A_node">node</code></td>
<td>
<p>The <code><a href="#topic+Node">Node</a></code> of the data.tree structure on which you would like to set style attributes.</p>
</td></tr>
<tr><td><code id="plot.Node_+3A_inherit">inherit</code></td>
<td>
<p>If TRUE, then children will inherit this node's style. 
Otherwise they inherit from this node's parent. Note that the inherit 
always applies to the node, i.e. all style attributes of a node and not 
to a single style attribute.</p>
</td></tr>
<tr><td><code id="plot.Node_+3A_keepexisting">keepExisting</code></td>
<td>
<p>If TRUE, then style attributes are added to possibly
existing style attributes on the node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>SetNodeStyle</code> and <code>SetEdgeStyle</code> to define the style of your plot. Use <code>plot</code> to display a 
graphical representation of your tree.
</p>
<p>The most common styles that can be set on the nodes are:
</p>

<ul>
<li><p><code>color</code>
</p>
</li>
<li><p><code>fillcolor</code>
</p>
</li>
<li><p><code>fixedsize</code> true or false
</p>
</li>
<li><p><code>fontcolor</code>
</p>
</li>
<li><p><code>fontname</code>
</p>
</li>
<li><p><code>fontsize</code>
</p>
</li>
<li><p><code>height</code>
</p>
</li>
<li><p><code>penwidth</code>
</p>
</li>
<li><p><code>shape</code> box, ellipse, polygon, circle, box, etc.
</p>
</li>
<li><p><code>style</code>
</p>
</li>
<li><p><code>tooltip</code>
</p>
</li>
<li><p><code>width</code>
</p>
</li></ul>

<p>The most common styles that can be set on the edges are:
</p>

<ul>
<li><p><code>arrowhead</code> e.g. normal, dot, vee
</p>
</li>
<li><p><code>arrowsize</code>
</p>
</li>
<li><p><code>arrowtail</code>
</p>
</li>
<li><p><code>color</code>
</p>
</li>
<li><p><code>dir</code> forward, back, both, none
</p>
</li>
<li><p><code>fontcolor</code>
</p>
</li>
<li><p><code>fontname</code>
</p>
</li>
<li><p><code>fontsize</code>
</p>
</li>
<li><p><code>headport</code>
</p>
</li>
<li><p><code>label</code>
</p>
</li>
<li><p><code>minlen</code>
</p>
</li>
<li><p><code>penwidth</code>
</p>
</li>
<li><p><code>tailport</code>
</p>
</li>
<li><p><code>tooltip</code>
</p>
</li></ul>

<p>A good source to understand the attributes is https://graphviz.org/Documentation.php. Another good source
is the DiagrammeR package documentation, or more specifically: https://rich-iannone.github.io/DiagrammeR/docs.html
</p>
<p>In addition to the standard GraphViz functionality, the <code>data.tree</code> plotting infrastructure takes advantage
of the fact that data.tree structure are always hierarchic. Thus, style attributes are inherited from parents
to children on an individual basis. For example, you can set the fontcolor to red on a parent, and then all children
will also have red font, except if you specifically disallow inheritance. Labels and tooltips are never inherited.
</p>
<p>Another feature concerns functions: Instead of setting a fixed value (e.g. <code>SetNodeStyle(acme, label = "Acme. Inc"</code>), 
you can set a function (e.g. <code>SetNodeStyle(acme, label = function(x) x$name)</code>). The function must take a <code><a href="#topic+Node">Node</a></code>
as its single argument. Together with inheritance, this becomes a very powerful tool.
</p>
<p>The <code>GetDefaultTooltip</code> method is a utility method that can be used to print all attributes of a <code><a href="#topic+Node">Node</a></code>.
</p>
<p>There are some more examples in the 'applications' vignette, see <code>vignette('applications', package = "data.tree")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
SetGraphStyle(acme, rankdir = "TB")
SetEdgeStyle(acme, arrowhead = "vee", color = "blue", penwidth = 2)
#per default, Node style attributes will be inherited:
SetNodeStyle(acme, style = "filled,rounded", shape = "box", fillcolor = "GreenYellow", 
             fontname = "helvetica", tooltip = GetDefaultTooltip)
SetNodeStyle(acme$IT, fillcolor = "LightBlue", penwidth = "5px")
#inheritance can be avoided:
SetNodeStyle(acme$Accounting, inherit = FALSE, fillcolor = "Thistle", 
             fontcolor = "Firebrick", tooltip = "This is the accounting department")
SetEdgeStyle(acme$Research$`New Labs`, 
             color = "red", 
             label = "Focus!", 
             penwidth = 3, 
             fontcolor = "red")
#use Do to set style on specific nodes:
Do(acme$leaves, function(node) SetNodeStyle(node, shape = "egg"))
plot(acme)

#print p as label, where available:
SetNodeStyle(acme, label = function(node) node$p)
plot(acme)

</code></pre>

<hr>
<h2 id='print.Node'>Print a <code>Node</code> in a human-readable fashion.</h2><span id='topic+print.Node'></span>

<h3>Description</h3>

<p>Print a <code>Node</code> in a human-readable fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Node'
print(
  x,
  ...,
  pruneMethod = c("simple", "dist", NULL),
  limit = 100,
  pruneFun = NULL,
  row.names = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Node_+3A_x">x</code></td>
<td>
<p>The Node</p>
</td></tr>
<tr><td><code id="print.Node_+3A_...">...</code></td>
<td>
<p>Node attributes to be printed. Can be either a character (i.e. the name of a Node field),
a Node method, or a function taking a Node as a single argument. See <code>Get</code> for details on
the meaning of <code>attribute</code>.</p>
</td></tr>
<tr><td><code id="print.Node_+3A_prunemethod">pruneMethod</code></td>
<td>
<p>The method can be used to prune for printing in a simple way. If NULL, the entire tree is displayed. If
&quot;simple&quot;, then only the first <code>limit</code> nodes are displayed. If &quot;dist&quot;, then Nodes are removed
everywhere in the tree, according to their level. If pruneFun is provided, then pruneMethod is ignored.</p>
</td></tr>
<tr><td><code id="print.Node_+3A_limit">limit</code></td>
<td>
<p>The maximum number of nodes to print. Can be <code>NULL</code> if the
entire tree should be printed.</p>
</td></tr>
<tr><td><code id="print.Node_+3A_prunefun">pruneFun</code></td>
<td>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</td></tr>
<tr><td><code id="print.Node_+3A_row.names">row.names</code></td>
<td>
<p>If <code>TRUE</code> (default), then the row names are printed out. Else, they are not.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
print(acme, "cost", "p")
print(acme, "cost", probability = "p")
print(acme, expectedCost = function(x) x$cost * x$p)
do.call(print, c(acme, acme$attributesAll))

tree &lt;- CreateRegularTree(4, 5)
# print entire tree:
print(tree, pruneMethod = NULL)
# print first 20 nodes:
print(tree, pruneMethod = "simple", limit = 20)
# print 20 nodes, removing leafs first:
print(tree, pruneMethod = "dist", limit = 20)
# provide your own pruning function:
print(tree, pruneFun = function(node) node$position != 2)


</code></pre>

<hr>
<h2 id='Prune'>Prunes a tree.</h2><span id='topic+Prune'></span>

<h3>Description</h3>

<p>Pruning refers to removing entire subtrees. This function has side-effects, it modifies your data.tree structure!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Prune(node, pruneFun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prune_+3A_node">node</code></td>
<td>
<p>The root of the sub-tree to be pruned</p>
</td></tr>
<tr><td><code id="Prune_+3A_prunefun">pruneFun</code></td>
<td>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of nodes removed
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
acme$Do(function(x) x$cost &lt;- Aggregate(x, "cost", sum))
Prune(acme, function(x) x$cost &gt; 700000)
print(acme, "cost")

</code></pre>

<hr>
<h2 id='Revert'>Reverts the sort order of a <code>Node</code>'s children.</h2><span id='topic+Revert'></span>

<h3>Description</h3>

<p>Reverts the sort order of a <code>Node</code>'s children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Revert(node, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Revert_+3A_node">node</code></td>
<td>
<p>the Node whose childrens' sort order is to be reverted</p>
</td></tr>
<tr><td><code id="Revert_+3A_recursive">recursive</code></td>
<td>
<p>If <code>TRUE</code>, then revert is called recursively on
all children.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the Node invisibly (for chaining)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>
<p><code><a href="#topic+Sort">Sort</a></code>
</p>

<hr>
<h2 id='s3_register'>Register a method for a suggested dependency</h2><span id='topic+s3_register'></span>

<h3>Description</h3>

<p>Code copied into data.tree from 'vctrs' (authors Wickham H, Henry L,
Vaughan D; https://github.com/r-lib/vctrs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s3_register(generic, class, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s3_register_+3A_generic">generic</code></td>
<td>
<p>Name of the generic in the form 'pkg::generic'.</p>
</td></tr>
<tr><td><code id="s3_register_+3A_class">class</code></td>
<td>
<p>Name of the class</p>
</td></tr>
<tr><td><code id="s3_register_+3A_method">method</code></td>
<td>
<p>Optionally, the implementation of the method. By default,
this will be found by looking for a function called 'generic.class'
in the package environment.
</p>
<p>Note that providing 'method' can be dangerous if you use
devtools. When the namespace of the method is reloaded by
'devtools::load_all()', the function will keep inheriting from
the old namespace. This might cause crashes because of dangling
'.Call()' pointers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For R 3.5.0 and later, 's3_register()' is useful when demonstrating
class creation in a vignette, since method lookup no longer always involves
the lexical scope. For R 3.6.0 and later, you can achieve a similar effect
by using &quot;delayed method registration&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A typical use case is to dynamically register tibble/pillar methods
# for your class. That way you avoid creating a hard depedency on packages
# that are not essential, while still providing finer control over
# printing when they are used.

.onLoad &lt;- function(...) {
  s3_register("pillar::pillar_shaft", "vctrs_vctr")
  s3_register("tibble::type_sum", "vctrs_vctr")
}
</code></pre>

<hr>
<h2 id='Set'>Traverse a Tree and Assign Values</h2><span id='topic+Set'></span>

<h3>Description</h3>

<p>The method takes one or more vectors as an argument. It traverses the tree, whereby the values are picked
from the vector. Also available as OO-style method on <code><a href="#topic+Node">Node</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>#OO-style:
# node$Set(..., 
#          traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),  
#          pruneFun = NULL, 
#          filterFun = NULL)
#traditional:
Set(nodes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Set_+3A_nodes">nodes</code></td>
<td>
<p>The nodes on which to perform the Get (typically obtained via <code><a href="#topic+Traverse">Traverse</a></code>)</p>
</td></tr>
<tr><td><code id="Set_+3A_...">...</code></td>
<td>
<p>each argument can be a vector of values to be assigned. Recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns the nodes (useful for chaining)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>
<p><code><a href="#topic+Get">Get</a></code>
</p>
<p><code><a href="#topic+Do">Do</a></code>
</p>
<p><code><a href="#topic+Traverse">Traverse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
acme$Set(departmentId = 1:acme$totalCount, openingHours = NULL, traversal = "post-order")
acme$Set(head = c("Jack Brown", 
                  "Mona Moneyhead", 
                  "Dr. Frank N. Stein", 
                  "Eric Nerdahl"
                  ),
         filterFun = function(x) !x$isLeaf
        )
print(acme, "departmentId", "head")
 
</code></pre>

<hr>
<h2 id='SetFormat'>Set a formatter function on a specific node</h2><span id='topic+SetFormat'></span>

<h3>Description</h3>

<p>Formatter functions set on a Node act as a default formatter when printing and using
the <code><a href="#topic+Get">Get</a></code> method. The formatter is inherited, meaning that whenever
<code>Get</code> fetches an attribute from a <code>Node</code>, it checks on the <code>Node</code> or
on any of its ancestors whether a formatter is set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SetFormat(node, name, formatFun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetFormat_+3A_node">node</code></td>
<td>
<p>The node on which to set the formatter</p>
</td></tr>
<tr><td><code id="SetFormat_+3A_name">name</code></td>
<td>
<p>The attribute name for which to set the formatter</p>
</td></tr>
<tr><td><code id="SetFormat_+3A_formatfun">formatFun</code></td>
<td>
<p>The formatter, i.e. a function taking a value as an input, and formatting
returning the formatted value</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Get
</p>
<p>print.Node
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
acme$Set(id = 1:(acme$totalCount))
SetFormat(acme, "id", function(x) FormatPercent(x, digits = 0))
SetFormat(Climb(acme, "IT"), "id", FormatFixedDecimal)
print(acme, "id")
# Calling Get with an explicit formatter will overwrite the default set on the Node:
print(acme, id = acme$Get("id", format = function(x) paste0("id:", x)))

# Or, to avoid formatters, even though you set them on a Node:
print(acme, id = acme$Get("id", format = identity))


</code></pre>

<hr>
<h2 id='Sort'>Sort children of a <code>Node</code> or an entire <code>data.tree</code> structure</h2><span id='topic+Sort'></span>

<h3>Description</h3>

<p>You can sort with respect to any argument of the tree. But note that sorting has
side-effects, meaning that you modify the underlying, original data.tree object structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sort(node, attribute, ..., decreasing = FALSE, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sort_+3A_node">node</code></td>
<td>
<p>The node whose children are to be sorted</p>
</td></tr>
<tr><td><code id="Sort_+3A_attribute">attribute</code></td>
<td>
<p>determines what is collected. The <code>attribute</code> can be
</p>

<ul>
<li><p> a.) the name of a <b>field</b> or a <b>property/active</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("p")</code> or <code>acme$Get("position")</code>
</p>
</li>
<li><p> b.) the name of a <b>method</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("levelZeroBased")</code>, where e.g. <code>acme$levelZeroBased &lt;- function() acme$level - 1</code>
</p>
</li>
<li><p> c.) a <b>function</b>, whose first argument must be a <code>Node</code> e.g. <code>acme$Get(function(node) node$cost * node$p)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="Sort_+3A_...">...</code></td>
<td>
<p>any parameters to be passed on the the attribute (in case it's a method or a 
function)</p>
</td></tr>
<tr><td><code id="Sort_+3A_decreasing">decreasing</code></td>
<td>
<p>sort order</p>
</td></tr>
<tr><td><code id="Sort_+3A_recursive">recursive</code></td>
<td>
<p>if <code>TRUE</code>, Sort will be called recursively on the <code>Node</code>'s children. 
This allows sorting an entire tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the node on which Sort is called, invisibly. This can be useful to chain Node methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>
<p><code><a href="#topic+Revert">Revert</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
acme$Do(function(x) x$totalCost &lt;- Aggregate(x, "cost", sum), traversal = "post-order")
Sort(acme, "totalCost", decreasing = FALSE)
print(acme, "totalCost")

</code></pre>

<hr>
<h2 id='ToNewick'>Write a <code>data.tree</code> structure to Newick notation</h2><span id='topic+ToNewick'></span>

<h3>Description</h3>

<p>To read from Newick, you can use the <code>ape</code> package, and convert the resulting <code>phylo</code>
object to a <code>data.tree</code> structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ToNewick(node, heightAttribute = DefaultPlotHeight, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ToNewick_+3A_node">node</code></td>
<td>
<p>The root <code>Node</code> of a tree or sub-tree to be converted</p>
</td></tr>
<tr><td><code id="ToNewick_+3A_heightattribute">heightAttribute</code></td>
<td>
<p>The attribute (field name, method, or function) storing or calculating the height for each <code>Node</code></p>
</td></tr>
<tr><td><code id="ToNewick_+3A_...">...</code></td>
<td>
<p>parameters that will be passed on the the heightAttributeName, in case it is a function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Conversions from Node: 
<code><a href="#topic+as.dendrogram.Node">as.dendrogram.Node</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acme)
ToNewick(acme)
ToNewick(acme, heightAttribute = NULL)
ToNewick(acme, heightAttribute = function(x) DefaultPlotHeight(x, 200))
ToNewick(acme, rootHeight = 200)

</code></pre>

<hr>
<h2 id='Traverse'>Traverse a tree or a sub-tree</h2><span id='topic+Traverse'></span>

<h3>Description</h3>

<p>Traverse takes the root of a tree or a sub-tree, and &quot;walks&quot; the tree in a specific order. It returns a list of
<code><a href="#topic+Node">Node</a></code> objects, filtered and pruned by <code>filterFun</code> and <code>pruneFun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Traverse(
  node,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),
  pruneFun = NULL,
  filterFun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Traverse_+3A_node">node</code></td>
<td>
<p>the root of a tree or a sub-tree that should be traversed</p>
</td></tr>
<tr><td><code id="Traverse_+3A_traversal">traversal</code></td>
<td>
<p>any of 'pre-order' (the default), 'post-order', 'in-order', 'level', 'ancestor', or a custom function (see details)</p>
</td></tr>
<tr><td><code id="Traverse_+3A_prunefun">pruneFun</code></td>
<td>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</td></tr>
<tr><td><code id="Traverse_+3A_filterfun">filterFun</code></td>
<td>
<p>allows providing a a filter, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>.
Note that if filter returns <code>FALSE</code>, then the node will be excluded from the result (but not the entire subtree).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The traversal order is as follows. (Note that these descriptions are not precise and complete. They are meant
for quick reference only. See the data.tree vignette for a more detailed description). 
</p>

<dl>
<dt>pre-order</dt><dd><p>Go to first child, then to its first child, etc.</p>
</dd>
<dt>post-order</dt><dd><p>Go to the first branch's leaf, then to its siblings, and work your way back to the root</p>
</dd>
<dt>in-order</dt><dd><p>Go to the first branch's leaf, then to its parent, and only then to the leaf's sibling</p>
</dd>
<dt>level</dt><dd><p>Collect root, then level 2, then level 3, etc.</p>
</dd>
<dt>ancestor</dt><dd><p>Take a node, then the node's parent, then that node's parent in turn, etc. This ignores the <code>pruneFun</code> </p>
</dd>
<dt>function</dt><dd><p>You can also provide a function, whose sole parameter is a <code><a href="#topic+Node">Node</a></code> object. The
function is expected to return the node's next node, a list of the node's next nodes, or NULL.</p>
</dd>
</dl>



<h3>Value</h3>

<p>a list of <code>Node</code>s
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Node">Node</a></code>
</p>
<p><code><a href="#topic+Get">Get</a></code>
</p>
<p><code><a href="#topic+Set">Set</a></code>
</p>
<p><code><a href="#topic+Do">Do</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
