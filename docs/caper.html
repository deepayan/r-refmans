<!DOCTYPE html><html><head><title>Help for package caper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {caper}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#caper-package'>
<p>Comparative analysis of phylogenetics and evolution in R (caper)</p></a></li>
<li><a href='#anova.caic'>
<p>Anova and model checking methods for independent contrast models.</p></a></li>
<li><a href='#anova.pgls'>
<p>Anova and AIC tables for 'pgls' models.</p></a></li>
<li><a href='#BritishBirds'>
<p>Conservation status of British birds (Thomas 2008)</p></a></li>
<li><a href='#brunch'><p>Comparative analysis using the brunch algorithm.</p></a></li>
<li><a href='#caic-class'>
<p>The 'caic' S3 object class and methods</p></a></li>
<li><a href='#caic.diagnostics'><p>Diagnostic tools for independent contrasts models</p></a></li>
<li><a href='#caper-benchmarks'><p>Datasets used for benchmarking caper</p></a></li>
<li><a href='#clade.matrix'><p>Create a clade matrix from a phylogeny</p></a></li>
<li><a href='#clade.members'><p>Identify tips descended from a node</p></a></li>
<li><a href='#comparative.data'>
<p>Comparative dataset creation</p></a></li>
<li><a href='#crunch'><p>Comparative analysis using the crunch algorithm.</p></a></li>
<li><a href='#fusco.test'><p>Imbalance statistics using Fusco and Cronk's method.</p></a></li>
<li><a href='#fuscoData'><p>Example dataset for Fusco imbalance calculations</p></a></li>
<li><a href='#growTree'><p> Tree simulation with traits.</p></a></li>
<li><a href='#IsaacEtAl'><p>Example dataset for the caper package</p></a></li>
<li><a href='#macrocaic'><p>Comparative analysis using independent contrasts on species richness data.</p></a></li>
<li><a href='#pd.calc'><p>Calculate and bootstrap phylogenetic diversity measurements.</p></a></li>
<li><a href='#perissodactyla'><p>Example dataset for the CAIC package</p></a></li>
<li><a href='#pgls'><p>Phylogenetic generalized linear models</p></a></li>
<li><a href='#pgls-methods'>
<p>Generic model methods for 'pgls' models.</p></a></li>
<li><a href='#pgls.profile'>
<p>Likelihood profiles and confidence intervals for 'pgls' models.</p></a></li>
<li><a href='#phylo.d'><p>Calculates the phylogenetic D statistic</p></a></li>
<li><a href='#phylo.d.subset'><p>Calculates the phylogenetic D statistic across clades within a phylogeny</p></a></li>
<li><a href='#plot.pgls'>
<p>Diagnostic plots for 'pgls' models.</p></a></li>
<li><a href='#shorebird'><p>Example dataset for the caper package</p></a></li>
<li><a href='#summary.caic'><p>Summarize a crunch, brunch or macrocaic analysis</p></a></li>
<li><a href='#syrphidae'><p>The syrphidae dataset of Katzourakis et al. 2001</p></a></li>
<li><a href='#VCV.array'><p>Create a 2D or 3D variance-covariance matrix from a phylogeny</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Comparative Analyses of Phylogenetics and Evolution in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Orme &lt;d.orme@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, utils, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), ape (&ge; 3.0-6) , MASS, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xtable, rmarkdown, knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for performing phylogenetic comparative analyses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-26 13:28:35 UTC; dorme</td>
</tr>
<tr>
<td>Author:</td>
<td>David Orme <a href="https://orcid.org/0000-0002-7005-1394"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Rob Freckleton [aut],
  Gavin Thomas [aut],
  Thomas Petzoldt [aut],
  Susanne Fritz [aut],
  Nick Isaac [aut],
  Will Pearse [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-26 14:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='caper-package'>
Comparative analysis of phylogenetics and evolution in R (caper)
</h2><span id='topic+caper-package'></span><span id='topic+caper'></span>

<h3>Description</h3>

<p>The <span class="pkg">caper</span> package provides a set of functions to conduct 
comparative analyses using both independent contrasts and phylogenetic 
generalised least squares methods. It also provides functions to combine 
phylogeny objects with data frames into simple comparative datasets and some 
utility functions for manipulating phylogenies.
</p>
<p>In addition to linear models correcting for phylogeny, the package also 
provides functions to test tree imbalance, calculate various measures of 
phylogenetic diversity and simulate phylogenies and traits.
</p>


<h3>Author(s)</h3>

<p>David Orme
Maintainer: David Orme &lt;d.orme@imperial.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+ape-package">ape</a></code>
</p>

<hr>
<h2 id='anova.caic'>
Anova and model checking methods for independent contrast models.
</h2><span id='topic+anova.caic'></span><span id='topic+anova.caiclist'></span><span id='topic+logLik.caic'></span><span id='topic+plot.caic'></span><span id='topic+predict.caic'></span><span id='topic+residuals.caic'></span><span id='topic+coef.caic'></span>

<h3>Description</h3>

<p>These functions provide ANOVA tables and model comparison using ANOVA and AIC, along with standard model diagnostic plots and accessor functions for phylogenetic independent contrast objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caic'
anova(object, ...)
## S3 method for class 'caiclist'
anova(object, ..., scale=0, test='F')
## S3 method for class 'caic'
logLik(object, ...)
## S3 method for class 'caic'
predict(object, ...)
## S3 method for class 'caic'
residuals(object, ...)
## S3 method for class 'caic'
coef(object, ...)
## S3 method for class 'caic'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.caic_+3A_object">object</code></td>
<td>
<p>An object of class 'caic'.</p>
</td></tr>
<tr><td><code id="anova.caic_+3A_scale">scale</code></td>
<td>
<p>A character string specifying the test statistic to be used. Can be one of &quot;F&quot;, &quot;Chisq&quot; or &quot;Cp&quot;, with partial matching allowed, or NULL for no test.</p>
</td></tr>
<tr><td><code id="anova.caic_+3A_test">test</code></td>
<td>
<p>numeric. An estimate of the noise variance sigma^2. If zero this will be estimated from the largest model considered.</p>
</td></tr>
<tr><td><code id="anova.caic_+3A_x">x</code></td>
<td>
<p>An object of class 'caic'.</p>
</td></tr>
<tr><td><code id="anova.caic_+3A_...">...</code></td>
<td>
<p>Further argument to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'anova' method provides access to single anova tables for a model and to comparison of lists of models. The 'logLik' method provides access to the log likelihood of the 'caic' model and hence to AIC comparison of models.
</p>
<p>The 'plot' method uses the standard set of model diagnostic plots for linear models. It is also wise to check the evolutionary assumptions of independent contrast models using the 'caic' specific diagnostic plots. The 'predict' and 'residuals' functions provide access to these parts of the 'caic' object.
</p>


<h3>Author(s)</h3>

<p>David Orme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crunch">crunch</a></code>, <code><a href="#topic+brunch">brunch</a></code>,<code><a href="#topic+macrocaic">macrocaic</a></code>,<code><a href="#topic+caic.diagnostics">caic.diagnostics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird.data$lgEgg.Mass &lt;- log(shorebird.data$Egg.Mass)
shorebird.data$lgM.Mass &lt;- log(shorebird.data$M.Mass)
shorebird.data$lgF.Mass &lt;- log(shorebird.data$F.Mass)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species)

cMod1 &lt;- crunch(lgEgg.Mass ~ lgM.Mass * lgF.Mass, data=shorebird)
cMod2 &lt;- crunch(lgEgg.Mass ~ lgM.Mass + lgF.Mass, data=shorebird)
cMod3 &lt;- crunch(lgEgg.Mass ~ lgM.Mass , data=shorebird)

anova(cMod1, cMod2, cMod3)
AIC(cMod1, cMod2, cMod3)

plot(cMod3)
</code></pre>

<hr>
<h2 id='anova.pgls'>
Anova and AIC tables for 'pgls' models.
</h2><span id='topic+anova.pgls'></span><span id='topic+anova.pglslist'></span><span id='topic+logLik.pgls'></span>

<h3>Description</h3>

<p>The 'anova' function creates ANOVA tables for a 'pgls' models using sequential sums of squares. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pgls'
anova(object, ...)
## S3 method for class 'pglslist'
anova(object, ..., scale = 0, test = "F")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.pgls_+3A_object">object</code></td>
<td>
<p>A 'pgls' model object.</p>
</td></tr>
<tr><td><code id="anova.pgls_+3A_...">...</code></td>
<td>
<p>Additional 'pgls' models.</p>
</td></tr>
<tr><td><code id="anova.pgls_+3A_scale">scale</code></td>
<td>
<p>A character string specifying the test statistic to be used. Can be one of &quot;F&quot;, &quot;Chisq&quot; or &quot;Cp&quot;, with partial matching allowed, or NULL for no test.</p>
</td></tr>
<tr><td><code id="anova.pgls_+3A_test">test</code></td>
<td>
<p>numeric. An estimate of the noise variance sigma^2. If zero this will be estimated from the largest model considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequential sums of squares are calculated by refitting the model in the order of the terms of the formula and so can take a little time to calculate. Branch length transformations are held at the values of the initial object. The 'logLik.pgls' provides a simple accessor function that allows the use of AIC model comparisons. Note that the generic AIC methods do no checking to ensure that sensible models are being compared.
</p>


<h3>Value</h3>

<p>A table of class 'anova' and 'data.frame' that employs the generic plot methods for 'anova' tables.</p>


<h3>Note</h3>

<p>The functions build heavily on the generic methods 'anova.lm' and 'anova.lmlist'.
</p>


<h3>Author(s)</h3>

<p>Rob Freckleton, David Orme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pgls">pgls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species, vcv=TRUE, vcv.dim=3)

mod1 &lt;- pgls(log(Egg.Mass) ~ log(M.Mass) * log(F.Mass), shorebird) 
anova(mod1)

mod2 &lt;- pgls(log(Egg.Mass) ~ log(M.Mass) + log(F.Mass), shorebird)  
mod3 &lt;- pgls(log(Egg.Mass) ~ log(M.Mass) , shorebird)
mod4 &lt;- pgls(log(Egg.Mass) ~ 1, shorebird)

anova(mod1, mod2, mod3, mod4)
AIC(mod1, mod2, mod3, mod4)
</code></pre>

<hr>
<h2 id='BritishBirds'>
Conservation status of British birds (Thomas 2008)
</h2><span id='topic+BritishBirds'></span><span id='topic+BritishBirds.tree'></span><span id='topic+BritishBirds.data'></span>

<h3>Description</h3>

<p>The dataset contains a molecular phylogeny of 249 species of British birds and a data frame containing information on the conservation status of 181 of those species. The dataset is taken from Thomas (2008)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BritishBirds)</code></pre>


<h3>Details</h3>

<p>The data frame contains 26 variables:
</p>
<p>binomial    
common_name 
Red_list    
Amber_list  
Green_list  
Red_amber_list
IUCN
Red_HD
Amber_HD 
Red_amber_HD  
Red_list_BDp
amb_BDp 
Red_amb_BDp 
Red_list_BDr
Red_list_WDp
amb_BDr     
amb_WDMp    
amb_spec    
amb_BR      
amb_BL      
amb_WL      
amb_BI      
amb_WI      
Red_amb_BDr 
pop_size    
range_size  
</p>


<h3>References</h3>

<p>Thomas, G. H. (2008). Phylogenetic distributions of british birds of conservation concern. Proceedings of the Royal Society B-Biological Sciences, 275(1647):2077-2083.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BritishBirds)
BritishBirds &lt;- comparative.data(BritishBirds.tree, BritishBirds.data, binomial)
</code></pre>

<hr>
<h2 id='brunch'>Comparative analysis using the brunch algorithm.</h2><span id='topic+brunch'></span>

<h3>Description</h3>

<p>Calculate a linear model using the brunch algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brunch(formula, data, phy, names.col, stand.contr = TRUE, robust = Inf, 
       ref.var=NULL, node.depth=NULL, equal.branch.length=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brunch_+3A_formula">formula</code></td>
<td>
<p>A model formula.</p>
</td></tr>
<tr><td><code id="brunch_+3A_data">data</code></td>
<td>
<p>An 'comparative.data' object. Alternatively, a data frame.</p>
</td></tr>
<tr><td><code id="brunch_+3A_phy">phy</code></td>
<td>
<p>An object of class 'phylo', required when data is not a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="brunch_+3A_names.col">names.col</code></td>
<td>
<p>A name specifying the column in 'data' that matches rows to tips in 'phy', required when data is not a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="brunch_+3A_stand.contr">stand.contr</code></td>
<td>
<p>A logical flag indicating whether or not to standardize contrasts</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="brunch_+3A_robust">robust</code></td>
<td>
<p>A threshold value of studentized residuals to exclude from the model.</p>
</td></tr>
<tr><td><code id="brunch_+3A_ref.var">ref.var</code></td>
<td>
<p>A reference variable present in the model that is used to specify the direction of calculation of contrasts. If null, this is assumed to be the first explanatory variable.</p>
</td></tr>
<tr><td><code id="brunch_+3A_node.depth">node.depth</code></td>
<td>
<p>A positive integer greater than 1 used to restrict the model to contrasts with a node depth less than or equal to the specified depth. Tips have a depth of 1.</p>
</td></tr>
<tr><td><code id="brunch_+3A_equal.branch.length">equal.branch.length</code></td>
<td>
<p>If set to 'TRUE' then all branch lengths are set to 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the 'brunch' algorithm for modelling the relationship between variables that are phylogenetically non-independent. This method was described and previously implemented in the Mac Classic computer programs CAIC, written by Purvis and Rambaut (1995) and updated by Nick Isaac and Paul-Michael Agapow. 
</p>
<p>The 'brunch' algorithm calculates contrasts for models that include binary categorical variables. Contrasts are identified and calculated for all variables in the model for a set of nodes where each side can be unequivocally attributed to one or other of the categories. Unlike 'crunch', nested contrasts are not calculated and each row of data at the tips is used only once. This follows Burt (1989): contrasts whose paths do not meet or cross at any point will be phylogenetically independent.
</p>
<p>Factors with more than two levels are supported but *must* be ordered to allow sensible contrasts to be drawn. In addition, there is no single best compromise set of contrasts with non-binary factors and implementations may differ in the set chosen.
</p>
<p>The user provides a comparative dataset. The formula specifies the model to be fitted and contrasts are calculated in those variables. The specified reference variable is used to ensure that contrasts for multivariate models are calculated in a consistent direction at each node. The function <code>brunch</code> acts as a data preparation wrapper for the function <code>contrCalc</code>, which is not intended to be directly called by users. Missing data can be present in the explanatory variables: the algorithm makes use of the complete data available at each node as was the case with CAIC.
</p>
<p>Polytomies - more detail here The Mac Classic program CAIC used 1 for both 'Brunch' and 'Crunch' analyses and this the default.
</p>


<h3>Value</h3>

<p>A object of class 'caic'.
</p>


<h3>Author(s)</h3>

<p>David Orme</p>


<h3>References</h3>

<p>Purvis, A. and Rambaut, A. (1995) Comparative analysis by independent contrasts (CAIC): an Apple Macintosh application for analysing comparative data.  Computer Appl. Biosciences 11, 247-251.
</p>
<p>Burt, A. (1989). Comparative methods using phylogenetically independent contrasts. Oxford Surveys in Evolutionary Biology, 6:33-53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caic-class">caic-class</a></code> for 'caic' object structure and methods.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(perissodactyla)
perisso &lt;- comparative.data(perissodactyla.tree, perissodactyla.data, Binomial)
brunchMod &lt;- brunch(log.female.wt ~ Territoriality, data=perisso)
summary(brunchMod)

# plot the contrasts
brunchTab &lt;- caic.table(brunchMod)
plot(log.female.wt ~ Territoriality, brunchTab)

# for the actual model diagnostics
par(mfrow=c(3,1))
caic.diagnostics(brunchMod)

</code></pre>

<hr>
<h2 id='caic-class'>
The 'caic' S3 object class and methods
</h2><span id='topic+caic-class'></span>

<h3>Description</h3>

<p>The functions 'crunch', 'brunch', 'macrocaic' and 'piclm' all return an object
containing an independent contrast model. The structure of the object and the
available methods are described here.
</p>


<h3>Format</h3>

<p>A 'caic' object is a list containing the following:
</p>

<dl>
<dt>contrast.data</dt><dd><p> A list of the following:
</p>

<dl>
<dt>contr</dt><dd><p>A list containing matrices of the contrasts in the response
variable (contr<code style="white-space: pre;">&#8288;$&#8288;</code>response) and explanatory variables
(contr<code style="white-space: pre;">&#8288;$&#8288;</code>explanatory).</p>
</dd>
<dt>nodalVals</dt><dd><p>A list containing matrices of the nodal values in the
response variable (contr<code style="white-space: pre;">&#8288;$&#8288;</code>response) and explanatory variables
(contr<code style="white-space: pre;">&#8288;$&#8288;</code>explanatory).</p>
</dd>
<dt>contrVar</dt><dd><p>A numeric vector of the expected variance for each
contrast.</p>
</dd>
<dt>nChild</dt><dd><p>A vector showing the number of nodes descending from each
internal node</p>
</dd>
<dt>nodeDepth</dt><dd><p>A vector showing the maximum number of nodes between
each internal node and the tips of the phylogeny (including both the
node in question and the tip and hence always &gt;=2) </p>
</dd>
<dt>validNodes</dt><dd><p>A logical vector showing which internal nodes on the
tree have valid contrasts, given the available data and any user
constraints.</p>
</dd></dl>
</dd>
<dt>data</dt><dd><p>A 'comparative.data' object containing the phylogeny used to
calculate contrasts and the original data.</p>
</dd>
<dt>lm</dt><dd><p>An 'lm' object containing a regression model through the origin
for the calculated contrast</p>
</dd>
</dl>

<p>In addition, the object may have the following attributes:
</p>

<dl>
<dt>contr.method</dt><dd><p>One of 'crunch', 'brunch' or 'piclm'.</p>
</dd>
<dt>macro</dt><dd><p>Either 'RRD' or 'PDI' if the response contrasts are calculated as species richness contrasts using <code><a href="#topic+macrocaic">macrocaic</a></code></p>
</dd>
<dt>stand.cont</dt><dd><p>A logical value showing whether the contrasts in the object have been standardized.</p>
</dd>
</dl>


<hr>
<h2 id='caic.diagnostics'>Diagnostic tools for independent contrasts models</h2><span id='topic+caic.label'></span><span id='topic+caic.diagnostics'></span><span id='topic+caic.robust'></span><span id='topic+caic.table'></span><span id='topic+print.caic.diagnostics'></span>

<h3>Description</h3>

<p>These functions are a set of diagnostic tools to assess whether a particular contrast model is adequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caic.table(caicObj, validNodes=TRUE, nodalValues=FALSE, ultrametric.tol=0.0001,
           CAIC.codes=FALSE, style="CAIC")
caic.diagnostics(caicObj, which.terms=NULL, which.tests=c("NV","SD","AGE"),
           plot=TRUE, outlier=3, ultrametric.tol=0.0001, plot.signif=plot, 
           alpha=0.05, cex.id=0.7,  ...)
## S3 method for class 'caic.diagnostics'
print(x, ...)
caic.robust(caicObj, robust=3)
caic.label(phy, charset=NULL, action="insert", style="CAIC", tips=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caic.diagnostics_+3A_caicobj">caicObj</code></td>
<td>
<p>An object of class 'caic'</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_validnodes">validNodes</code></td>
<td>
<p>A logical indicating whether to return only the nodes at which valid contrasts have been drawn or all nodes in the phylogeny.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_nodalvalues">nodalValues</code></td>
<td>
<p>A logical indicating whether to include the estimated nodal values in the contrasts table.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_ultrametric.tol">ultrametric.tol</code></td>
<td>
<p>A value in branch length units indicating how large a departure from ultrametric path lengths is permitted before calculating node ages is blocked.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_caic.codes">CAIC.codes</code></td>
<td>
<p>Should CAIC style node labels be added to the contrast table?</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_style">style</code></td>
<td>
<p>Either 'CAIC', which is the default, or 'RLE' for run-length encoded codes.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_which.terms">which.terms</code></td>
<td>
<p>A character vector of the terms in the linear model for which diagnostic checks should be made. The default is to use all terms.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_which.tests">which.tests</code></td>
<td>
<p>A character vector of the tests to conduct. Any of 'NV', 'SD' and 'Age' may be selected and the default is to use all three.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_plot">plot</code></td>
<td>
<p>A logical indicating whether or not to create plots of the diagnostic tests.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_outlier">outlier</code></td>
<td>
<p>A value indicating the size of absolute studentized residuals above which a contrast will be highlighted in diagnostic plots</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_robust">robust</code></td>
<td>
<p>A value indicating the size of absolute studentized residuals above which a contrast will be removed from the contrast model.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_plot.signif">plot.signif</code></td>
<td>
<p>By default, significant relationships are indicated on the plots by showing the model line.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_alpha">alpha</code></td>
<td>
<p>This value sets the significance at which model predictions are added to the diagnostic plots.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_cex.id">cex.id</code></td>
<td>
<p>Adjust the size of labels added to outlier points.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_x">x</code></td>
<td>
<p>An object of class 'caic diagnostics' to be printed out</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_...">...</code></td>
<td>
<p>Generic arguments to <code>print.caic.diagnostics</code> or plot arguments for <code>print.caic.diagnostics</code>.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_phy">phy</code></td>
<td>
<p>A 'phylo' object.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_charset">charset</code></td>
<td>
<p>A vector of characters to be used to construct CAIC codes.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_action">action</code></td>
<td>
<p>One of 'replace', 'append' or 'insert'.</p>
</td></tr>
<tr><td><code id="caic.diagnostics_+3A_tips">tips</code></td>
<td>
<p>A logical indicating whether to modify the tip labels of the phylogeny in addition to the internal node labels.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The most general function (<code>caic.table</code>) extracts a data frame from a 'caic' object that contains the contrasts, expected variance ('contrVar'), node depth, number of descendant lineages and studentized residuals. It can also optionally include the nodal values estimated at internal nodes and CAIC style node labels. This data frame is very similar to the output files generated by CAIC and MacroCAIC. By default, only the valid nodes contributing contrasts to the model are shown but other internal nodes can also be included ('validNodes=FALSE').
</p>
<p>The <code>caic.diagnostics</code> function carries out a set of regression tests on the absolute values of contrasts in a model. These include regression against estimates of the nodal values ('NV), standard deviation at each node ('SD') and, where the underlying phylogeny is ultrametric, the log age at each node ('AGE'). Significant regressions indicate problems with the distribution of the contrast values. The user can select which of these plots are to be generated and also which terms in the contrasts model will be plotted. The function can also plot these relationships and show the slope of problematic tests (slope significance &lt; alpha).  
</p>
<p>Plots from the <code>caic.diagnostics</code> function will plot outliers in red and label these points.  Outliers are identified as points with absolute studentized residuals greater than the cutoff specified in 'outlier'. The function <code>caic.robust</code> is a simple method to obtain a refitted 'caic' object model from which these outlying contrasts have been excluded.
</p>
<p>The <code>caic.label</code> function provides a method to label nodes (and optionally tips) with CAIC phylogeny codes. These are simple alphabetic sequences that indicate the branching structure of the tree from the root and are unique for each node.  With deeply nested trees, these codes can be very long and so the option 'RLE' is provided to reduce the length of codes for plotting onto trees: for example, the code AABAAAC would be converted to 2AB3AC. If <code>action</code> is 'replace', then the phylogeny tip and node labels are replaced with the CAIC codes. If <code>action</code> is 'append', then the codes are appended onto the end of existing labels, with the internal node numbers used if no node labels exist. Finally, if <code>action</code> is 'insert', then a named character vector called 'edge.caic.code' is inserted into the 'phylo' object list.
</p>


<h3>Value</h3>


<dl>
<dt><code>caic.table</code></dt><dd><p>A data frame of contrasts and other nodal values.</p>
</dd>
<dt><code>caic.diagnostics</code></dt><dd><p>An array of slope coefficients for each test (rows) and for each term (depth).</p>
</dd> 
<dt><code>caic.robust</code></dt><dd><p>A 'caic' object with a model omitting outliers.</p>
</dd>
<dt><code>caic.labels</code></dt><dd><p>A 'phylo' object with modified labels.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> David Orme </p>


<h3>See Also</h3>

<p><code><a href="#topic+crunch">crunch</a></code>, <code><a href="#topic+brunch">brunch</a></code>, <code><a href="#topic+macrocaic">macrocaic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species)
crunchMod &lt;- crunch(log(Egg.Mass) ~  log(M.Mass) + log(F.Mass), data=shorebird)
caic.diagnostics(crunchMod)
</code></pre>

<hr>
<h2 id='caper-benchmarks'>Datasets used for benchmarking caper</h2><span id='topic+caper-benchmarks'></span><span id='topic+benchBayesTraitsOutputs'></span><span id='topic+benchBrunchOutputs'></span><span id='topic+benchCrunchOutputs'></span><span id='topic+benchFuscoOutputs'></span><span id='topic+benchMacroCAICOutputs'></span><span id='topic+benchMesaOutputs'></span><span id='topic+benchTestInputs'></span><span id='topic+BayesTraitsMods'></span><span id='topic+benchData'></span><span id='topic+benchTreeDicho'></span><span id='topic+benchTreePoly'></span><span id='topic+CAIC.BrDi1057'></span><span id='topic+CAIC.BrDi1157'></span><span id='topic+CAIC.BrDi813'></span><span id='topic+CAIC.BrDi913'></span><span id='topic+CAIC.BrPl1057'></span><span id='topic+CAIC.BrPl1157'></span><span id='topic+CAIC.BrPl813'></span><span id='topic+CAIC.BrPl913'></span><span id='topic+CAIC.CrDi213'></span><span id='topic+CAIC.CrDi657'></span><span id='topic+CAIC.CrPl213'></span><span id='topic+CAIC.CrPl413'></span><span id='topic+CAIC.CrPl657'></span><span id='topic+FuscoDiSpp'></span><span id='topic+FuscoDiTax'></span><span id='topic+FuscoPolySpp'></span><span id='topic+FuscoPolyTax'></span><span id='topic+MacroCAIC.DiSpp23'></span><span id='topic+MacroCAIC.DiSpp67'></span><span id='topic+MacroCAIC.DiTax23'></span><span id='topic+MacroCAIC.DiTax67'></span><span id='topic+MacroCAIC.PolySpp23'></span><span id='topic+MacroCAIC.PolySpp67'></span><span id='topic+MacroCAIC.PolyTax23'></span><span id='topic+MacroCAIC.PolyTax67'></span><span id='topic+MeSA.I'></span><span id='topic+testData'></span><span id='topic+testTree'></span><span id='topic+nul'></span><span id='topic+fix'></span><span id='topic+kld'></span><span id='topic+Kld'></span><span id='topic+kLd'></span><span id='topic+klD'></span><span id='topic+KLd'></span><span id='topic+kLD'></span><span id='topic+KlD'></span><span id='topic+KLD'></span>

<h3>Description</h3>

<p>These data files and model objects contain input datasets for benchmarking the caper package against other implementations and the results returned by those other implementations. For more details, see the benchmark vignette for caper.
</p>


<h3>See Also</h3>

<p>vignette()</p>

<hr>
<h2 id='clade.matrix'>Create a clade matrix from a phylogeny</h2><span id='topic+clade.matrix'></span>

<h3>Description</h3>

<p>Takes a phylogeny in the 'ape' package format and converts it into a binary matrix showing which tips (matrix columns) subtend from each node in the phylogeny (matrix rows). This is a useful format for quickly calculating branch length information for subsets of the phylogeny.</p>


<h3>Usage</h3>

<pre><code class='language-R'>clade.matrix(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clade.matrix_+3A_phy">phy</code></td>
<td>
<p>A object of class 'phylo'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clade matrix shows the tips from a phylogeny that subtend from each internal and external node. Each tip is represented as column showing the nodes of which it is a member and hence each row shows the tips that are members of a given node. Dropping columns gives a quick and easy way to find out which edges are retained in a particular subset of the tree and this structure is used for quickly calculating branch lengths calculations or clade statistics.
</p>


<h3>Value</h3>

<p>A list of class 'clade.matrix' containing the following components:
</p>
<table>
<tr><td><code>clade.matrix</code></td>
<td>
<p>A binary m x n matrix, where m is the total number of nodes in the phylogeny and n is the number of tips. An element is 1 if tip $n_i$ subtends from a node $m_j$.</p>
</td></tr>
<tr><td><code>edge.length</code></td>
<td>
<p>A numeric vector of length m showing the edge length leading to each node in the phylogeny and named with the node number.</p>
</td></tr>
<tr><td><code>tip.label</code></td>
<td>
<p>A character vector of length n giving the labels assigned to the tips of the phylogeny.</p>
</td></tr>
<tr><td><code>edge</code></td>
<td>
<p>The edge matrix from the original phylogeny.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Orme</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(perissodactyla)
clade.matrix(perissodactyla.tree)
</code></pre>

<hr>
<h2 id='clade.members'>Identify tips descended from a node</h2><span id='topic+clade.members'></span><span id='topic+clade.members.list'></span>

<h3>Description</h3>

<p>Obtains a vector of the tips subtending from either one node or all nodes in a phylogeny.</p>


<h3>Usage</h3>

<pre><code class='language-R'>clade.members(x, phy, tip.labels = FALSE, include.nodes=FALSE)
clade.members.list(phy, tips = FALSE, tip.labels = FALSE, include.nodes=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clade.members_+3A_x">x</code></td>
<td>
<p>A integer identifying the node for which a list of tips is required.</p>
</td></tr>
<tr><td><code id="clade.members_+3A_phy">phy</code></td>
<td>
<p>An object of class 'phylo'. </p>
</td></tr>
<tr><td><code id="clade.members_+3A_tips">tips</code></td>
<td>
<p> A logical indicating whether to include external node membership in the list.</p>
</td></tr>
<tr><td><code id="clade.members_+3A_tip.labels">tip.labels</code></td>
<td>
<p>A logical flag indicating whether to return the node numbers of the tips or their tip labels.</p>
</td></tr>
<tr><td><code id="clade.members_+3A_include.nodes">include.nodes</code></td>
<td>
<p>A logical flag indicating whether to return the node number of descendent internal nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>clade.members.list</code> runs <code>clade.members</code> over each node in the phylogeny, possibly including the external nodes as indicated by the tips argument, and returns a list of vectors showing the members of the clade defined by each node.
</p>


<h3>Value</h3>

<p>A numeric vector of external node (i.e. tip) numbers or a character vector of tip labels for a single internal node or, for <code>clade.members.list</code>, a list of such vector for all nodes in the phylogeny. If <code>include.nodes</code> is <code>TRUE</code> then <code>clade.members</code> returns a list of length two containing a vector of the descendent tips and a vector of the descendent internal nodes -  <code>clade.members.list</code> then contains a list of such lists.
</p>


<h3>Author(s)</h3>

<p>David Orme, Lynsey McInnes</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(perissodactyla)
# use comparative.data to add node labels
perisso &lt;- comparative.data(perissodactyla.tree, perissodactyla.data, Binomial, na.omit=FALSE)
plot(perisso$phy, show.node.label=TRUE)
clade.members(22, perisso$phy, tip.labels=TRUE)
clade.members.list(perisso$phy, tip.labels=FALSE)

</code></pre>

<hr>
<h2 id='comparative.data'>
Comparative dataset creation
</h2><span id='topic+comparative.data'></span><span id='topic+print.comparative.data'></span><span id='topic+na.omit.comparative.data'></span><span id='topic+subset.comparative.data'></span><span id='topic+reorder.comparative.data'></span><span id='topic++5B.comparative.data'></span><span id='topic+as.comparative.data'></span><span id='topic+caicStyleArgs'></span>

<h3>Description</h3>

<p>A simple tool to combine phylogenies with datasets and ensure consistent structure and ordering for use in functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparative.data(phy, data, names.col, vcv=FALSE, vcv.dim=2, na.omit=TRUE, 
	             force.root=FALSE, warn.dropped=FALSE, scope=NULL)
## S3 method for class 'comparative.data'
print(x, ...)
## S3 method for class 'comparative.data'
na.omit(object, scope=NULL, ...)
## S3 method for class 'comparative.data'
subset(x, subset, select, ...)
## S3 method for class 'comparative.data'
reorder(x, order, ...)
## S3 method for class 'comparative.data'
x[i, j]
as.comparative.data(x, ...)
caicStyleArgs(phy, data, names.col, warn.dropped=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparative.data_+3A_data">data</code></td>
<td>
<p>A data frame containing variables that can be attributed to the taxa at the tips of a phylogeny.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_phy">phy</code></td>
<td>
<p>A phylogeny (class 'phylo') to be matched to the data above.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_names.col">names.col</code></td>
<td>
<p>The name of a column in the provided data frame that will be used to match data rows to phylogeny tips.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_vcv">vcv</code></td>
<td>
<p>A logical value indicating whether to include a variance covariance array representing the phylogeny within the comparative dataset.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_vcv.dim">vcv.dim</code></td>
<td>
<p>Either 2 (a standard VCV matrix) or 3 (an array retaining the individual branches contributing to the standard values). The array form is of use for optimising some branch length transformations.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_na.omit">na.omit</code></td>
<td>
<p>A logical value indicating whether to reduce the comparative dataset to those tips for which all selected variables are complete. Note that some functions cannot handle missing data and will return an error.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_force.root">force.root</code></td>
<td>
<p>Many functions consider a basal polytomy to indicate an unrooted tree. Using force.root=TRUE will set an arbitrary root edge below this polytomy.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_warn.dropped">warn.dropped</code></td>
<td>
<p>A logical value indicating whether to warn the user when data or tips are dropped in creating the comparative data object.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_scope">scope</code></td>
<td>
<p>A model formula, used to indicate which variables to consider when omitting row containing NA values.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_x">x</code></td>
<td>
<p>An object of class 'comparative.data'.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_object">object</code></td>
<td>
<p>An object of class 'comparative.data'.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_subset">subset</code></td>
<td>
<p>A logical expression indicating rows of data to keep: missing values are taken as false.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_select">select</code></td>
<td>
<p>An expression, indicating columns to select from the data frame.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_order">order</code></td>
<td>
<p>One of 'cladewise' or 'pruningwise'. See <code><a href="ape.html#topic+reorder.phylo">reorder.phylo</a></code>.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_i">i</code>, <code id="comparative.data_+3A_j">j</code></td>
<td>
<p>Indices specifying tips or data columns to extract. See details.</p>
</td></tr>
<tr><td><code id="comparative.data_+3A_...">...</code></td>
<td>
<p>Further arguments to functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function matches rows in a data frame to tips on a phylogeny and ensures correct ordering of the data with respect to the tips. It also can add a variance covariance representation of the phylogeny. Mismatched rows and tips are removed and the taxon labels of these are stored in the 'dropped'  slot of the 'comparative.data' object. The 'print' method displays a brief summary of the dataset contents and the names of the original 'phylo' and 'data.frame' objects. If any rows or tips were dropped, 'print' will also show a venn diagram of the data shared and dropped from each source. Node labels are preserved but must be unique - unlabelled nodes will be assigned numeric codes.
</p>
<p>The 'na.omit' and 'subset' methods provide simple ways to clean up and extract parts of the comparative dataset. In particular, 'subset' acts exclusively with the data component of the object and, like subset on a data frame, expects the subset argument to produce a logical vector of data rows to include. The 'reorder' method is use to restructure all the components with the 'comparative.data' object into either pruningwise or cladewise order. This uses code from the 'ape' library: see <code><a href="ape.html#topic+reorder.phylo">reorder.phylo</a></code>.
</p>
<p>The '[' method allows subsets to be taken of the data. There are no replace methods ('[&lt;-'). If only one index is specified (e.g. x[2]), then this is interpreted as extracting data columns from the object. Otherwise (e.g. x[2,], x[1,1]), the first index will specify tips to extract and the second index will specify columns. Indices for tips are permitted to be numeric, logical or character vectors or empty (missing) or NULL. Numeric values are coerced to integer as by as.integer (and hence truncated towards zero). Character vectors will be matched to the names of the object (or for matrices/arrays, the dimnames): see 'Character indices' below for further details.
</p>
<p>The function 'caicStyleArgs' handles turning 'phy', 'data' and 'names.col' arguments into a 'comparative.data' object when they are provided separately to a function. This argument structure was used in older versions of many functions.
</p>
<p>All of these functions are in part a substitute for the considerably more sophisticated handling of such data in the package 'phylobase', which will be integrated into later releases.
</p>


<h3>Value</h3>

<p>A list of class 'comparative.data':
</p>
<table>
<tr><td><code>phy</code></td>
<td>
<p>An object of class 'phylo'</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A data frame of matched data</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>The original object name of the data</p>
</td></tr>
<tr><td><code>phy.name</code></td>
<td>
<p>The original object name of the phylogeny</p>
</td></tr>
<tr><td><code>dropped</code></td>
<td>
<p>A list of taxon names dropped from the dataset:
</p>

<dl>
<dt>unmatched.rows</dt><dd><p>Data rows that do not match to tips</p>
</dd>
<dt>tips</dt><dd><p>Tips that do not match to data rows</p>
</dd></dl>
</td></tr>
</table>
<p>And optionally:
</p>
<table>
<tr><td><code>vcv</code></td>
<td>
<p>A variance covariance matrix of the phylogeny</p>
</td></tr>
<tr><td><code>vcv.dim</code></td>
<td>
<p>The dimension of the VCV - 2 for a standard VCV matrix and 3 for an expanded array retaining individual branch lengths</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Orme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crunch">crunch</a></code>,<code><a href="#topic+pgls">pgls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, 'Species')
print(shorebird)

subset(shorebird, subset=Mat.syst == 'MO')

sandpipers &lt;- grep('Calidris', shorebird$phy$tip.label)
shorebird[-sandpipers, ]

sandpipers &lt;- grep('Calidris', shorebird$phy$tip.label, value=TRUE)
shorebird[sandpipers, ]

shorebird[]
shorebird[,]
shorebird[2:3]
shorebird[, 2:3]
shorebird[1:15, ]
shorebird[1:15, 2:3]
</code></pre>

<hr>
<h2 id='crunch'>Comparative analysis using the crunch algorithm.</h2><span id='topic+crunch'></span><span id='topic+contrCalc'></span>

<h3>Description</h3>

<p>Calculate a linear model using the crunch algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crunch(formula, data, phy, names.col, stand.contr = TRUE, robust=Inf,
	   ref.var=NULL, node.depth=NULL, polytomy.brlen=0, equal.branch.length=FALSE, 
	   factor.action="abort")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crunch_+3A_formula">formula</code></td>
<td>
<p>A model formula.</p>
</td></tr>
<tr><td><code id="crunch_+3A_data">data</code></td>
<td>
<p>An 'comparative.data' object. Alternatively, a data frame.</p>
</td></tr>
<tr><td><code id="crunch_+3A_phy">phy</code></td>
<td>
<p>An object of class 'phylo', required when data is not a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="crunch_+3A_names.col">names.col</code></td>
<td>
<p>A name specifying the column in 'data' that matches rows to tips in 'phy', required when data is not a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="crunch_+3A_stand.contr">stand.contr</code></td>
<td>
<p>A logical flag indicating whether or not to standardize contrasts</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="crunch_+3A_robust">robust</code></td>
<td>
<p>A threshold value of studentized residuals to exclude from the model.</p>
</td></tr>
<tr><td><code id="crunch_+3A_ref.var">ref.var</code></td>
<td>
<p>A reference variable present in the model that is used to specify the direction of calculation of contrasts. If null, this is assumed to be the first explanatory variable.</p>
</td></tr>
<tr><td><code id="crunch_+3A_node.depth">node.depth</code></td>
<td>
<p>A positive integer greater than 1 used to restrict the model to contrasts with a node depth less than or equal to the specified depth. Tips have a depth of 1.</p>
</td></tr>
<tr><td><code id="crunch_+3A_polytomy.brlen">polytomy.brlen</code></td>
<td>
<p>The internal branch length used for calculating contrasts at a polytomy, following Pagel's (1992) method. </p>
</td></tr>
<tr><td><code id="crunch_+3A_equal.branch.length">equal.branch.length</code></td>
<td>
<p>If set to 'TRUE' then all branch lengths are set to 2.</p>
</td></tr>
<tr><td><code id="crunch_+3A_factor.action">factor.action</code></td>
<td>
<p>One of &quot;abort&quot;, &quot;warn&quot; or &quot;allow&quot;, describing whether to stop if the formula contains a factor (&quot;abort&quot;), or continue after converting the factor to a numeric variable, either with (&quot;warn&quot;) or without (&quot;allow&quot;) a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the 'crunch' algorithm for modelling the relationship between variables that are phylogenetically non-independent. The method was first described by Felsenstein (1985) and subsequently extended to permit the use of phylogenies with polytomies by Pagel (1992). This method was previously implemented in the Mac Classic computer programs CAIC, written by Andy Purvis, Andy Rambaut (Purvis and Rambaut, 1995) and updated by Nick Isaac and Paul-Michael Agapow.
</p>
<p>The user provides a comparative dataset. The formula specifies the model to be fitted and contrasts are calculated in those variables. The specified reference variable is used to ensure that contrasts for multivariate models are calculated in a consistent direction at each node. The function <code>crunch()</code> acts as a data preparation wrapper for the function <code>contrCalc()</code>, which is not intended to be directly called by users. Missing data can be present in the explanatory variables: the algorithm makes use of the complete data available at each node as was the case with CAIC.
</p>
<p>The resulting table of contrasts is then used to fit the specified model - note that the intercept is automatically dropped from the model if present, following REF HERE. 
</p>
<p>Contrasts at polytomies are calculated following Pagel (1992). The descendants from the node are split into two groups based on whether they are above or below the group mean in the reference variable. If there is no variation in the reference variable, then a 1:(N-1) split is used. Weighted means in the variables are then calculated for each subgroup and a contrast is calculated between these values using an arbitrary internal branch length.
</p>


<h3>Value</h3>

<p>A object of class 'caic'.
</p>


<h3>Warning</h3>

<p>At a polytomy, subtracting the internal branch length from the real branch lengths can lead to negative branch lengths. CAIC used a hard-coded internal branch length of 1 for calculating crunch contrasts at polytomies. From version 2.6.9, CAIC issued a warning if this lead to negative branch lengths but allowed contrast calculation to continue. In contrast, the implementation in <code>crunch()</code> uses a default internal branch length (<code>polytomy.brlen</code>) of 0 and also treats a negative branch length in a polytomy calculation as an error. In either case, contrast calculation on negative branch lengths is not a desirable outcome. Duplication of CAIC results therefore requires <code>polytomy.brlen</code> to be set to 1 and an analyis <em>cannot</em> be duplicated precisely if the phylogeny contains polytomies with descending branches shorter than 1. The method used by <code>pic.lm</code> to handle polytomies avoids such problems.
</p>


<h3>Author(s)</h3>

<p>David Orme</p>


<h3>References</h3>

<p>Felsenstein, J.  (1985).  Phylogenies and the comparative method.  Am. Nat.  125, 1-15
</p>
<p>Pagel, M. D. (1992). A method for the analysis of comparative data.  J. theor. Biol. 156, 431-442.
</p>
<p>Purvis, A. and Rambaut, A. (1995) Comparative analysis by independent contrasts (CAIC): an Apple Macintosh application for analysing comparative data.  Computer Appl. Biosciences 11, 247-251.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caic-class">caic-class</a></code> for 'caic' object structure and methods.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species)
crunchMod &lt;- crunch(Egg.Mass ~ F.Mass + M.Mass, data=shorebird)
summary(crunchMod)
# plot the contrasts
crunchTab &lt;- caic.table(crunchMod)
plot(Egg.Mass ~ F.Mass, crunchTab)
# for the actual model diagnostics
par(mfrow=c(3,2))
caic.diagnostics(crunchMod)
</code></pre>

<hr>
<h2 id='fusco.test'>Imbalance statistics using Fusco and Cronk's method.</h2><span id='topic+fusco.test'></span><span id='topic+summary.fusco'></span><span id='topic+print.fusco'></span><span id='topic+plot.fusco'></span>

<h3>Description</h3>

<p>Fusco and Cronk (1995) described a method for testing the imbalance of phylogenetic trees based on looking at the distribution of I. I is calculated using the number of tips descending from each side of a bifurcating node using the formula I = (B-m)/(M-m) and is bounded between 0 (a perfectly balanced node) and 1 (maximum imbalance). B is the larger number of tips descending from each branch, M is the maximum size of this larger group (i.e. a 1 : (S-1) split, where S is the total number of descendent tips), and m is the minimum size of the larger group (ceiling of S/2). The method can cope with small proportions of polytomies in the phylogeny and these are not used in calculating balance statistics. It can also incorporate information about species richness at the tips of the phylogeny and can therefore be used to distinguish between an unbalanced topology and the unbalanced distribution of diversity at the tips of a phylogeny. 
</p>
<p>Purvis et al. (2002) demonstrated that I is not independent of the node size S, resulting in a bias to the expected median of 0.5. They proposed a modification (I') that corrects this to give a statistic with an expected median of 0.5 regardless of node size. The defaults in this function perform testing of imbalance using I', but it is also possible to use the original measure proposed by Fusco and Cronk (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fusco.test(phy, data , names.col, rich, tipsAsSpecies=FALSE, 
	       randomise.Iprime=TRUE,  reps=1000, conf.int=0.95)
## S3 method for class 'fusco'
print(x, ...)
## S3 method for class 'fusco'
summary(object, ...)
## S3 method for class 'fusco'
plot(x, correction=TRUE, nBins=10, right=FALSE, I.prime=TRUE, plot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fusco.test_+3A_phy">phy</code></td>
<td>
<p>An object of class 'comparative.data' or of class 'phylo'.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_data">data</code></td>
<td>
<p>A data frame containing species richness values. Not required if phy is a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_names.col">names.col</code></td>
<td>
<p>A variable in <code>data</code> identifying tip labels. Not required if phy is a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_rich">rich</code></td>
<td>
<p>A variable  identifying species richness.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_tipsasspecies">tipsAsSpecies</code></td>
<td>
<p>A logical value. If TRUE, a species richness column need not be specified and the tips will be treated as species.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_randomise.iprime">randomise.Iprime</code></td>
<td>
<p>Use a randomization test on calculated I' to generate confidence intervals.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_reps">reps</code></td>
<td>
<p>Number of replicates to use in simulation or randomization.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_conf.int">conf.int</code></td>
<td>
<p>Width of confidence intervals required.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_x">x</code>, <code id="fusco.test_+3A_object">object</code></td>
<td>
<p>An object of class 'fusco'.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_correction">correction</code></td>
<td>
<p>Apply the correction described in Appendix A of Fusco and Cronk (1995) to the histogram of nodal imbalance.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_nbins">nBins</code></td>
<td>
<p>The number of bins to be used in the histogram of nodal imbalance.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_right">right</code></td>
<td>
<p>Use right or left open intervals in plotting the distribution and calculating the correction</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_i.prime">I.prime</code></td>
<td>
<p>Plot distribution of I' or I.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_plot">plot</code></td>
<td>
<p>If changed to FALSE, then the plot method does not plot the frequency histogram. Because the method invisibly returns a table of histogram bins along with the observed and corrected frequencies, this isn't as dim an option as it sounds.</p>
</td></tr>
<tr><td><code id="fusco.test_+3A_...">...</code></td>
<td>
<p>Further arguments to generic methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I is calculated only at bifurcating nodes giving rise to more than 3 tips (or more than 3 species at the tips): nodes with three or fewer descendants have no variation in I and are not informative in assessing imbalance. The expected distribution of the nodal imbalance values between 0 and 1 is theoretically uniform under a Markov null model. However, the range of possible I values at a node is constrained by the number of descendent species. For example, for a node with 8 species, only the values 0, 0.33, 0.66, 1 are possible, corresponding to 4:4, 5:3, 6:2 and 7:1 splits (Fusco and Cronk, 1995). As node size increases, this departure from a uniform distribution decreases. The plot method incorporates a correction, described by Fusco and Cronk (1995), that uses the distribution of all possible splits at each node to characterize and correct for the departure from uniformity.
</p>
<p>The randomization option generates confidence intervals around the mean I'.
</p>


<h3>Value</h3>

<p>The function <code>fusco.test</code> produces an object of class 'fusco' containing:
</p>
<table>
<tr><td><code>observed</code></td>
<td>
<p>A data frame of informative nodes showing nodal imbalance statistics. If the phylogeny has labelled nodes, then the node names are also returned in this data frame.</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>The median value of I.</p>
</td></tr>
<tr><td><code>qd</code></td>
<td>
<p>The quartile deviation of I.</p>
</td></tr>
<tr><td><code>tipsAsSpecies</code></td>
<td>
<p>A logical indicating whether the tips of the trees were treated as species or higher taxa.</p>
</td></tr>
<tr><td><code>nInformative</code></td>
<td>
<p>The number of informative nodes.</p>
</td></tr>
<tr><td><code>nSpecies</code></td>
<td>
<p>The number of species distributed across the tips.</p>
</td></tr>
<tr><td><code>nTips</code></td>
<td>
<p>The number of tips.</p>
</td></tr>
<tr><td><code>reps</code></td>
<td>
<p>The number of replicates used in randomization.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>The confidence levels used in randomization.</p>
</td></tr>
</table>
<p>If <code>randomise.Iprime</code> is TRUE, or the user calls <code>fusco.randomize</code> on a 'fusco' object, then the following are also present.
</p>
<table>
<tr><td><code>randomised</code></td>
<td>
<p>A data frame of mean I' from the randomized observed values.</p>
</td></tr>
<tr><td><code>rand.mean</code></td>
<td>
<p>A vector of length 2 giving confidence intervals in mean I'.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Orme, Andy Purvis</p>


<h3>References</h3>

<p>Fusco, G. &amp; Cronk, Q.C.B. (1995) A New Method for Evaluating the Shape of Large Phylogenies. J. theor. Biol. 175, 235-243
</p>
<p>Purvis A.,  Katzourakis A. &amp; Agapow, P-M (2002) Evaluating Phylogenetic Tree Shape: Two Modifications to Fusco &amp; Cronk's Method. J. theor. Biol. 214, 93-103.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(syrphidae)
syrphidae &lt;- comparative.data(phy=syrphidaeTree, dat=syrphidaeRich, names.col=genus)
summary(fusco.test(syrphidae, rich=nSpp))
summary(fusco.test(syrphidae, tipsAsSpecies=TRUE))
plot(fusco.test(syrphidae, rich=nSpp))
</code></pre>

<hr>
<h2 id='fuscoData'>Example dataset for Fusco imbalance calculations</h2><span id='topic+fuscoBirdData'></span><span id='topic+fuscoBirdTree'></span>

<h3>Description</h3>

<p>This dataset contains the phylogeny of bird families and species richness originally included with the FUSCO imbalance calculation programs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fuscoData)
</code></pre>


<h3>Format</h3>

<p>The dataset provides a phylogeny (<code>fuscoBirdTree</code>) and a data frame (<code>fuscoBirdData</code>). The phylogeny is a 137 tip tree containing one polytomy and the dataframe provides tip labels and species richness for each bird family. This dataset was provided with the original DOS implementation of the test and the families were unlabelled in this original file.
</p>


<h3>See Also</h3>

<p>fusco.test</p>

<hr>
<h2 id='growTree'> Tree simulation with traits.  </h2><span id='topic+growTree'></span><span id='topic+as.comparative.data.growTree'></span>

<h3>Description</h3>

<p>This function provides a very general environment in which to simulate trees. The basic philosophy is that the user provides a series of expressions that define speciation rates, extinction rates and trait evolution. These expressions can make use of information about the internal state of the tree, allowing for very flexible definitions of rules for tree growth.</p>


<h3>Usage</h3>

<pre><code class='language-R'>growTree(b = 1, d = 0, halt = 20, grain = 0.1, linObj = NULL, ct.start = NULL,
         ct.change = NULL, ct.var = NULL, dt.rates = NULL, inheritance = NULL, 
         trace.events = FALSE, trace.cladesize = FALSE, output.lineages = FALSE,
         neg.rates = "abort", inf.rates = "abort", stall.time = 10, 
         extend.proportion=0)
## S3 method for class 'growTree'
as.comparative.data(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growTree_+3A_b">b</code></td>
<td>
<p>A speciation rate. This can be a numeric constant, as in the default, which specifies a single speciation rate for the simulation. Alternatively, this can be an expression, or a list of expressions which define speciation rate in terms of the properties of the tree. See details for discussion of those properties.</p>
</td></tr>
<tr><td><code id="growTree_+3A_d">d</code></td>
<td>
<p>An extinction rate, described as above.</p>
</td></tr>
<tr><td><code id="growTree_+3A_halt">halt</code></td>
<td>
<p>A rule use to halt the simulation. The default is the number of tips in the simulation, specified as a single integer, but this can also be an expression or list of expressions on the properties of the tree. The simulation is halted when any of these expressions becomes true.</p>
</td></tr>
<tr><td><code id="growTree_+3A_grain">grain</code></td>
<td>
<p>Where rates depend on time or trait values, it becomes necessary to allow time to pass discretely in order to re-evaluate waiting times under the changing values. This sets the amount of time that is allowed to pass before re-evaluation. If rates do not depend on such changing parameters, it is sensible to set this to infinity - this will ensure that the flow of the simulation is not slowed by checking.</p>
</td></tr>
<tr><td><code id="growTree_+3A_linobj">linObj</code></td>
<td>
<p>This can be used to supply an existing simulation object, which will then continue to grow under the provided rules. This allows the user to simulate trees with different sets of rules operating in different epochs. The function <code>linToApe</code> will convert such an object to a 'phylo' object, retaining additional trait data as extra components of the 'phylo' object list. </p>
</td></tr>
<tr><td><code id="growTree_+3A_ct.start">ct.start</code></td>
<td>
<p>A numeric vector specifying the starting values for continuous traits. If unnamed these will be sequentially named as 'ct1', 'ct2' etc. The names of traits may be used in expressions governing tree growth rules.</p>
</td></tr>
<tr><td><code id="growTree_+3A_ct.change">ct.change</code></td>
<td>
<p>A numeric vector describing the mean change per unit time in continuous trait values, used to simulate a directional bias in character evolution. If ct.change is NULL, then this is assumed to be zero for each species.</p>
</td></tr>
<tr><td><code id="growTree_+3A_ct.var">ct.var</code></td>
<td>
<p>Either a vector of variances for each trait or a square matrix describing the variances and covariances amongst the continuous traits. If this is NULL, then uncorrelated traits with a variance of 1 are assumed.</p>
</td></tr>
<tr><td><code id="growTree_+3A_dt.rates">dt.rates</code></td>
<td>
<p>A list of matrices describing the rate of transition between discrete character traits. Each matrix defines a trait and, as with ct.start, the list names are used to identify the traits in the simulation and default to 'dt1', 'dt2', etc. The dimnames of the matrix are used to identify the states of the trait and default to 'st1', 'st2', etc. The matrix need not be symmetrical: the rates are defined from the states in the columns to the states in the rows, hence the diagonal should probably be zero. Each trait is assumed to start the simulation in the first state in the matrix.</p>
</td></tr>
<tr><td><code id="growTree_+3A_inheritance">inheritance</code></td>
<td>
<p>A list of rules that are applied after a speciation and can be used to modify trait values for the descendent lineages. The names of the list specify which traits are to be modified and, for each trait specified, should return a vector of length two which replaces the existing values. </p>
</td></tr>
<tr><td><code id="growTree_+3A_trace.events">trace.events</code></td>
<td>
<p>A logical flag, indicating whether or not report speciation, extinction and discrete character evolution events.</p>
</td></tr>
<tr><td><code id="growTree_+3A_trace.cladesize">trace.cladesize</code></td>
<td>
<p>A positive integer giving an increment size for the simulation to report clade size if required.</p>
</td></tr>
<tr><td><code id="growTree_+3A_output.lineages">output.lineages</code></td>
<td>
<p>A logical flag indicating whether to return the internal lineages object.</p>
</td></tr>
<tr><td><code id="growTree_+3A_neg.rates">neg.rates</code></td>
<td>
<p>One of 'abort', 'warn' or 'quiet', defining the behaviour when a rate calculation produces a negative number. With 'warn'  and 'quiet', negative rates are set to zero and the simulation continues.</p>
</td></tr>
<tr><td><code id="growTree_+3A_inf.rates">inf.rates</code></td>
<td>
<p>One of 'abort', 'warn' or 'quiet', as for<code>neg.rates</code>. With 'warn' or 'quiet', infinite rates are left in place, resulting in events happening instantly. This may, in some cases, be desirable!</p>
</td></tr>
<tr><td><code id="growTree_+3A_stall.time">stall.time</code></td>
<td>
<p>If the all rates within the simulation are zero then only this length of time is allowed to pass before the simulation exits with a 'stalled' status. If <code>grain</code> is infinite, then the simulation stalls immediately when all rates are zero.</p>
</td></tr>
<tr><td><code id="growTree_+3A_extend.proportion">extend.proportion</code></td>
<td>
<p>This option allows the simulation to continue running for a given proportion of the time to the next speciation. This makes sense when growing a clade to a given number of extant taxa; with the default setting of zero, the resulting tree ends at a bifurcation with zero branch lengths and this option allows the tree to grow (and taxa to go extinct and traits to evolve).</p>
</td></tr>
<tr><td><code id="growTree_+3A_x">x</code></td>
<td>
<p>A lineage table output from growTree</p>
</td></tr>
<tr><td><code id="growTree_+3A_...">...</code></td>
<td>
<p>Further arguments to as.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main idea behind this function (which is still in development) is to provide a flexible framework for simulating tree growth and trait evolution. The user provides expressions for the main arguments (<code>b</code>, <code>d</code> and <code>halt</code>) which act as rules defining speciation and extinction and the ending of the simulation. These can be simple constants, but can also make use of the properties of the environment of the evolving tree. This includes both lineage specific properties (as described in the <code>lineages</code> section of the returned value) or properties of the clade as a whole (as described in the <code>clade</code> section of the returned value). For example, a extinction rate might increase with lineage age (<code>d=0.01*lin.age</code>) or a speciation rate might decrease according to a density dependent process (<code>b=1 - (nExtantTip/500)</code>). Halt expressions will typically use clade properties (<code>halt=clade.age &gt;= 5</code> or <code>nTips &gt;= 50</code>) but could use lineage properties, for example stopping when a trait value hits a certain value (<code>halt=any(ct1 &gt;= 10)</code>). It is not permitted to use '==' in a halt function of clade.age because it will allow the simulation to run away if the actual value steps over the test value.
</p>
<p>Discrete traits are defined using a matrices of rates for transitions between states for each trait. At present, these are fixed for the duration of a simulation epoch and cannot be set as expressions of tree variables.
</p>
<p>Continuous trait evolution currently employs a simple Brownian model, given a starting value and variance per unit time. The traits can have defined co-variance (the simulation uses mvrnorm at present) and can also have a defined mean change, allowing for a directional walk in the trait values. At present, it is not possible for the trait variance to vary according to the internal state of the tree; continuous characters retain the same variance and covariance for the whole of the simulation epoch.
</p>
<p>Whilst none of the <code>halt</code> rules are TRUE, then the function evaluates the birth, death and discrete trait rates and converts these to waiting times using random variates from a exponential distribution with the calculated rates. These competing waiting times are compared both to each other and the <code>grain</code> of the simulation, the shortest waiting time is found and the relevant event is then triggered. The winning event is identified in the character vector <code>winnerName</code> in order to allow inheritance rules to differentiate events.
</p>


<h3>Value</h3>

<p>Depending on the value of <code>output.phylo</code>, either an object of class 'phylo' or an object of class 'growTree' with the following structure:
</p>
<table>
<tr><td><code>lineages</code></td>
<td>
<p>A data frame with a row for each lineage in the tree. Each row identifies the <code>parent.id</code> and <code>id</code> of the row along with the total age of the lineage (<code>lin.age</code>) and the times at which the lineage was born (<code>birth.time</code>). If the species went extinct (or speciated) then the <code>death.time</code> is recorded and <code>extinct</code> is set to TRUE. Speciating lineages have  <code>tip</code> set to FALSE. Each row also records the <code>caic.code</code> of the lineage - this is used as a sorting code for conversion to a 'phylo' object and is a kludge. If traits are defined in the simulation then the values or states are recorded in this table. These are the current values for extant tips and the values at extinction for extinct tips and internal nodes.</p>
</td></tr>
<tr><td><code>clade</code></td>
<td>
<p>A list containing:<code>clade.age</code>, the total age of the simulation; <code>nLin</code>, the total number of lineages; <code>nTip</code>, the total number of tips, differentated into <code>nExtantTip</code> and <code>nExtinctTip</code>.</p>
</td></tr>
<tr><td><code>rules</code></td>
<td>
<p>A list reporting the birth (<code>b</code>), death (<code>d</code>) and stopping (<code>halt</code>) rules and any inheritance rules.</p>
</td></tr>
<tr><td><code>ct.set</code></td>
<td>
<p>If continuous characters were simulated, a list of the <code>ct.start</code>, <code>ct.change</code> and <code>ct.var</code> details provided.</p>
</td></tr>
<tr><td><code>dt.rates</code></td>
<td>
<p>If discrete characters were simulated, a list containing the <code>dt.rates</code> details provided.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Orme, drawing heavily on discussions with Paul-Michael Agapow.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see the package vignette for a much fuller discussion of examples.

# A basic 200 tip tree, output as a 'comparative.data' object
    tree &lt;- growTree(halt=200, grain=Inf)
    plot(tree$phy)

# A basic tree of age 4 time units, output as a 'comparative.data' object
    tree &lt;- growTree(halt=expression(clade.age &gt;= 4), grain=Inf)
    plot(tree$phy)

</code></pre>

<hr>
<h2 id='IsaacEtAl'>Example dataset for the caper package</h2><span id='topic+IsaacEtAl'></span><span id='topic+chiroptera.tree'></span><span id='topic+carnivora.tree'></span><span id='topic+primates.tree'></span><span id='topic+marsupialia.tree'></span><span id='topic+chiroptera.data'></span><span id='topic+carnivora.data'></span><span id='topic+primates.data'></span><span id='topic+marsupialia.data'></span>

<h3>Description</h3>

<p>This data set contains four species-level comparative datasets used in Isaac et al (2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(IsaacEtAl)
</code></pre>


<h3>Format</h3>

<p>The datafile contains species level phylogenies and accompanying data frames of nine variables for each of four mammalian orders (Primates, Carnivora, Chiroptera and Marsupialia). The data were published in supplementary material for Isaac et al. (2005) as CAIC format files and text data files and have been converted for use in 'caper'. The data files are incomplete, with some variables having little or no data for some orders.
</p>
<p>The variables (all saved as natural log values) are:
</p>

<dl>
<dt>species.rich</dt><dd><p>Species richness at the tips - all are set to 1 for use in <code>macrocaic</code></p>
</dd>
<dt>body.mass</dt><dd><p>The average body mass in grams</p>
</dd>
<dt>age.sexual.maturity</dt><dd><p>Age at sexual maturity in months</p>
</dd>
<dt>gestation</dt><dd><p>Gestation length in days</p>
</dd>
<dt>interbirth.interval</dt><dd><p>Interbirth interval in months</p>
</dd>
<dt>litter.size</dt><dd><p>The average number of offspring in a litter</p>
</dd>
<dt>population.density</dt><dd><p>Population density</p>
</dd>
<dt>group.size</dt><dd><p>Number of individuals in a typical group</p>
</dd>
<dt>mass.dimorphism</dt><dd><p>Male mass /female mass</p>
</dd>
<dt>length.dimorphism</dt><dd><p>Male length / female length</p>
</dd>
</dl>



<h3>References</h3>

<p>Isaac, N., Jones, K., Gittleman, J., and Purvis, A. (2005). Correlates of species richness in mammals: Body size, life history, and ecology. American Naturalist, 165(5):600-607.</p>


<h3>See Also</h3>

<p> caic, pgls </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IsaacEtAl)
chiroptera  &lt;- comparative.data(chiroptera.tree, chiroptera.data, 'binomial', na.omit=FALSE)
carnivora   &lt;- comparative.data(carnivora.tree, carnivora.data, 'binomial', na.omit=FALSE)
primates    &lt;- comparative.data(primates.tree, primates.data, 'binomial', na.omit=FALSE)
marsupialia &lt;- comparative.data(marsupialia.tree, marsupialia.data, 'binomial', na.omit=FALSE)
	
</code></pre>

<hr>
<h2 id='macrocaic'>Comparative analysis using independent contrasts on species richness data.</h2><span id='topic+macrocaic'></span>

<h3>Description</h3>

<p>Macroevolutionary hypotheses about correlates of species richness require testing in a phylogenetic framework in order to avoid phylogenetic autocorrelation. Independent contrasts as described by Felsenstein (1985) are appropriate for explanatory variables in such models but not for species richness as the response variable. This function implements two methods for calculating species richness constrasts described by Agapow and Isaac (2002) and originally implemented in the program MacroCAIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>macrocaic(formula, data, phy, names.col, macroMethod = "RRD", 
          stand.contr = TRUE, robust=Inf, ref.var = NULL, node.depth = NULL, 
          macroMinSize = 3, equal.branch.length = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="macrocaic_+3A_formula">formula</code></td>
<td>
<p>A formula describing a linear model predicting species richness.</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables to be used in the model.</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_phy">phy</code></td>
<td>
<p>An object of class 'phylo'.</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_names.col">names.col</code></td>
<td>
<p>A name identifying a column in <code>data</code> that contains the tip labels from <code>phy</code>.</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_macromethod">macroMethod</code></td>
<td>
<p>One of either &quot;RRD&quot; or &quot;PDI&quot; (see Details).</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_stand.contr">stand.contr</code></td>
<td>
<p>A logical flag indicating whether to standardize the contrasts.</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_robust">robust</code></td>
<td>
<p>A threshold value of studentized residuals to exclude from the model.</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_ref.var">ref.var</code></td>
<td>
<p>Identifies a predictor variable used for determining the direction of contrasts.</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_node.depth">node.depth</code></td>
<td>
<p>A positive integer greater than 1 used to restrict the model to contrasts with a node depth less than or equal to the specified depth. Tips have a depth of 1.</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_macrominsize">macroMinSize</code></td>
<td>
<p>A positive integer giving the minimum species richness at a node for contrasts to be included in the model.</p>
</td></tr>
<tr><td><code id="macrocaic_+3A_equal.branch.length">equal.branch.length</code></td>
<td>
<p>If set to 'TRUE' then all branch lengths are set to 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'macrocaic' function fits a regression to the formula provided using 'crunch' contrasts for continuous explanatory variables and species richness contrasts for the response. The species richness contrasts are either the relative rate difference (RRD) or proportion dominance index (PDI):
</p>
<p style="text-align: center;"><code class="reqn">RRD = \ln\left(\frac{N_1}{N_2}\right)</code>
</p>

<p>RRD = ln(N_1/N_2)
</p>
<p style="text-align: center;"><code class="reqn">PDI = \left(\frac{N_1}{N_1+N_2}\right)-0.5</code>
</p>

<p>PDI = (N_1/(N_1 + N_2))-0.5
</p>
<p>The values <code class="reqn">N_1</code> and <code class="reqn">N_2</code> are the species richness of the two daughter nodes and <code class="reqn">N_1</code> is the species richness of the clade with the larger value of the reference variable. Species richness contrasts are not calculated at polytomies. Nodal values for species richness are calculated as the sum of the richness of the daughter nodes.
</p>


<h3>Value</h3>

<p>A object of class 'caic'.
</p>


<h3>Author(s)</h3>

<p>David Orme</p>


<h3>References</h3>

<p>Felsenstein, J.  (1985).  Phylogenies and the comparative method.  Am. Nat.  125, 1-15
Agapow, P.-M. and Isaac, N. J. B. (2002) MacroCAIC: correlates of species richness. Diversity &amp; Distributions, 8, 41-43
Isaac, N., Agapow, P., Harvey, P., and Purvis, A. (2003). Phylogenetically nested com- parisons for testing correlates of species richness: A simulation study of continuous variables. Evolution, 57(1):18-26.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caic-class">caic-class</a></code> for 'caic' object structure and methods.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IsaacEtAl)
primates &lt;- comparative.data(primates.tree, primates.data, binomial, na.omit=FALSE)
primatesBodySize &lt;- macrocaic(species.rich ~ body.mass, data=primates)
summary(primatesBodySize)

</code></pre>

<hr>
<h2 id='pd.calc'>Calculate and bootstrap phylogenetic diversity measurements.</h2><span id='topic+pd.calc'></span><span id='topic+pd.bootstrap'></span><span id='topic+ed.calc'></span>

<h3>Description</h3>

<p>These functions calculate various phylogenetic diversity measures for either a given set of nodes on a tree or for a randomly chosen set of nodes of a given size. The ed.calc function calculates a related species-level measurement of evolutionary distinctness.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pd.calc(cm, tip.subset = NULL, method = "TBL", root.edge=FALSE)
pd.bootstrap(cm, ntips, reps = 1000, method = "TBL", tip.weights = NULL)
ed.calc(cm, polytomy.cf=c("isaac","mooers","none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pd.calc_+3A_cm">cm</code></td>
<td>
<p>A object of class 'clade matrix'. Alternatively an object of class 'phylo', which will be converted to a clade.matrix.</p>
</td></tr>
<tr><td><code id="pd.calc_+3A_tip.subset">tip.subset</code></td>
<td>
<p>An optional vector identifying the subset of tips to use for PD calculations. If no tip.subset is provided the method is applied to the complete phylogeny [Hmm.. this might be undesirable]. Can either be a character vector, in which case the elements are matched against tip labels, or a vector of positive integers in the range 1 to the number of tips, in which case the tips with those numbers are used.</p>
</td></tr>
<tr><td><code id="pd.calc_+3A_method">method</code></td>
<td>
<p> One of 'TBL', 'MST', 'UEH', 'SBL', defaulting to 'TBL'. See details.</p>
</td></tr>
<tr><td><code id="pd.calc_+3A_root.edge">root.edge</code></td>
<td>
<p>Logical indicating whether to include the root edge length in calculations, defaulting to FALSE.</p>
</td></tr>
<tr><td><code id="pd.calc_+3A_ntips">ntips</code></td>
<td>
<p>A single integer giving the number of tips to be selected.</p>
</td></tr>
<tr><td><code id="pd.calc_+3A_reps">reps</code></td>
<td>
<p>The number of replicate values to calculate.</p>
</td></tr>
<tr><td><code id="pd.calc_+3A_tip.weights">tip.weights</code></td>
<td>
<p>A numeric vector containing weights for all the tips in the phylogeny. Each element must be named in order to match weights to the tips.</p>
</td></tr>
<tr><td><code id="pd.calc_+3A_polytomy.cf">polytomy.cf</code></td>
<td>
<p>Which correction factor to use for calculating ED at polytomies. One of 'isaac', 'mooers' or 'none'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are five implemented PD measures:
</p>

<dl>
<dt>Total Branch Length (TBL)</dt><dd><p>The sum of all the edge lengths in the subtree given by the tip subset. This measure can be partitioned into the two next measures.</p>
</dd>
<dt>Shared Branch Length (SBL)</dt><dd><p>The sum of all edges in the subtree that are shared by more than one tip.</p>
</dd>
<dt>Unique Evolutionary History (UEH)</dt><dd><p>The sum of the edge lengths that give rise to only one tip in the subtree.</p>
</dd>
<dt>Length of tip branch lengths (TIPS)</dt><dd><p>Length of tip branch lengths (TIPS)</p>
</dd></dl>
<p>Unlike UEH, this measure does not use the unique paths to each tips on the <strong>subtree</strong> and instead gives the sum of the unique branches leading to the tips on the <strong>complete tree</strong>.
</p>
<dl>
<dt>Minimum Spanning Tree (MST)</dt><dd><p>The sum of the lengths of the edges for the smallest tree that links the subset tips, excluding any edges below the node of the most recent common ancestor.</p>
</dd></dl>

<p>These options are illustrated in the caper package vignette. The pd.calc function returns the PD value for a given set of tips, whereas the pd.bootstrap function returns a vector of PD values for randomly selected sets of tips of a given size.
</p>
<p>The ed.calc function returns the evolutionary distinctness (ED) metric (Isaac et al, 2007) for the tips of a given phylogeny. The idea behind the ED measure is that the evolutionary history of each branch is shared equally between all tips descending from that branch. Each branch therefore has a per-tip values of the branch length divided by the number of descendants and the ED value for a tip is the sum of those per-tip contributions over the path to the root of the phylogeny. Polytomies inflate apparent ED since the branches of a properly resolved polytomy must be shorter than the branch lengths on the unresolved polytomy. The function provides two correction factors for this: 'isaac' uses a correction factor calibrated from simulations and 'mooers' uses empirical predictions from a pure birth model.
</p>


<h3>Value</h3>

<p>Both pd.calc and pd.bootstrap return a vector containing either a single value for the phylogenetic diversity of a given set of tips or a vector of length 'nrep' containing the pd values for a random set of tips of a given size. The method used is stored in the 'pd.method' attribute of the vector.
</p>
<p>The ed.calc function returns a list containing:
</p>

<dl>
<dt>branch</dt><dd><p>A data frame of the ED contributions arising from each branch.</p>
</dd>
<dt>spp</dt><dd><p>A data frame of the summed ED contributions for each species.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Orme, Gavin Thomas, Nick Isaac</p>


<h3>References</h3>

<p>Faith, DP, 
Isaac, N. J. B., Turvey, S. T., Collen, B., Waterman, C., and Baillie, J. E. M. (2007). Mammals on the edge: Conservation priorities based on threat and phylogeny. Plos One, 2(3):e296</p>


<h3>Examples</h3>

<pre><code class='language-R'>treeString &lt;- paste('((((A:1,B:1):1.5,C:2.5):0.5,(D:0.6,E:0.6):2.4):0.5,',
                    '((F:1.9,G:1.9):0.8,(H:1.6,I:1.6):1.1):0.8):0.2;' ,sep='')
tre &lt;- read.tree(text=treeString)
clmat &lt;- clade.matrix(tre)
tips &lt;- c("A","C","D","E","G","H")
pd.calc(clmat, tip.subset=tips)
pd.calc(clmat, tip.subset=c(1,3,4,5,7,8))
pd.calc(clmat, tip.subset=tips, root.edge=TRUE)

pd.bootstrap(clmat, ntips=6, reps=1000, method='TBL')

data(IsaacEtAl)
primatesCM &lt;- clade.matrix(primates.tree)
primatesED &lt;- ed.calc(primatesCM)
</code></pre>

<hr>
<h2 id='perissodactyla'>Example dataset for the CAIC package</h2><span id='topic+perissodactyla'></span><span id='topic+perissodactyla.data'></span><span id='topic+perissodactyla.tree'></span>

<h3>Description</h3>

<p>This is a comparative dataset on Perissodactyla taken from the examples include with the original CAIC program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shorebird)
</code></pre>


<h3>Format</h3>

<p>The datafile contains a phylogeny (<code>perissodactyla.tree</code>) of 18 perissodactyl species as a 'phylo' object from the <code>ape</code> library. The tip names are the binomial names of the species. The file also contains a data frame (<code>perissodactyla.data</code>) of variables 5 variables for 13 of those species: 
</p>

<dl>
<dt>Binomial</dt><dd><p>The species binomial name.</p>
</dd>
<dt>log.female.wt</dt><dd><p>Log female weight</p>
</dd>
<dt>log.gestation.length</dt><dd><p>Log gestation length</p>
</dd>
<dt>log.neonatal.wt</dt><dd><p>Log neonatal weight</p>
</dd>
<dt>Territoriality</dt><dd><p>A factor indicating whether or not the species displays territorial behaviour.</p>
</dd>
</dl>

<p>The dataset is incomplete - it does not include data for each species in the phylogeny and contains missing values. See the examples for the behaviour of the 'comparative.data' function in handling missing data. 
</p>


<h3>References</h3>

<p>Purvis, A. and Rambaut, A. (1995). Comparative Analysis by Independent Contrasts (CAIC) User's Guide.</p>


<h3>See Also</h3>

<p> caic, pgls </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(perissodactyla)
# default behaviour is to omit incomplete data rows
(perisso &lt;- comparative.data(perissodactyla.tree, perissodactyla.data, Binomial))
# but this can be turned off
(perisso &lt;- comparative.data(perissodactyla.tree, perissodactyla.data, Binomial, na.omit=FALSE))
na.omit(perisso)
</code></pre>

<hr>
<h2 id='pgls'>Phylogenetic generalized linear models</h2><span id='topic+pgls'></span><span id='topic+pgls.likelihood'></span><span id='topic+pgls.blenTransform'></span>

<h3>Description</h3>

<p>Fits a linear model, taking into account phylogenetic non-independence between data points. The strength and type of the phylogenetic signal in the data matrix can also be accounted for by adjusting branch length transformations (lambda, delta and kappa). These transformations can also be optimised to find the maximum likelihood transformation given the data and the model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgls(formula, data, lambda = 1.0, kappa = 1.0,  delta= 1.0, param.CI = 0.95, 
	 control = list(fnscale=-1), bounds = NULL)
pgls.likelihood(optimPar, fixedPar, y, x, V, optim.output=TRUE, names.optim=NULL)
pgls.blenTransform(V, fixedPar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgls_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="pgls_+3A_data">data</code></td>
<td>
<p>A 'comparative.data' object containing the covariance matrix and data to be used in the model.</p>
</td></tr>
<tr><td><code id="pgls_+3A_lambda">lambda</code></td>
<td>
<p>A value for the lambda transformation.</p>
</td></tr>
<tr><td><code id="pgls_+3A_kappa">kappa</code></td>
<td>
<p>A value for the kappa transformation.</p>
</td></tr>
<tr><td><code id="pgls_+3A_delta">delta</code></td>
<td>
<p>A value for the delta transformation.</p>
</td></tr>
<tr><td><code id="pgls_+3A_param.ci">param.CI</code></td>
<td>
<p>A p value used to calculate confidence intervals.</p>
</td></tr>
<tr><td><code id="pgls_+3A_control">control</code></td>
<td>
<p>A list of control parameters for the optim function.</p>
</td></tr>
<tr><td><code id="pgls_+3A_bounds">bounds</code></td>
<td>
<p>A list of bounds to use for branch length transformations (see Details).</p>
</td></tr>
<tr><td><code id="pgls_+3A_optimpar">optimPar</code></td>
<td>
<p>A named vector of branch length parameters to be optimised to find the maximum likelihood value.</p>
</td></tr>
<tr><td><code id="pgls_+3A_fixedpar">fixedPar</code></td>
<td>
<p>A named vector of fixed values for branch length parameters.</p>
</td></tr>
<tr><td><code id="pgls_+3A_y">y</code></td>
<td>
<p>A column matrix of the model response.</p>
</td></tr>
<tr><td><code id="pgls_+3A_x">x</code></td>
<td>
<p>The design matrix of the model.</p>
</td></tr>
<tr><td><code id="pgls_+3A_v">V</code></td>
<td>
<p>A phylogenetic covariance matrix.</p>
</td></tr>
<tr><td><code id="pgls_+3A_optim.output">optim.output</code></td>
<td>
<p>A logical value. If true then 'pgls.likelihood' returns only the likelihood value for use in the 'optim' function.</p>
</td></tr>
<tr><td><code id="pgls_+3A_names.optim">names.optim</code></td>
<td>
<p>The name of a single parameter being optimised. This is only required for estimating parameter confidence intervals, where the function 'uniroot' strips names from vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a linear model controlling for the non-independence between cases resulting from phylogenetic structure in the data. The stucture of the phylogenetic signal can be controlled by altering the parameters lambda, delta and kappa (see the 'caper' vignette for details). The implementation of the method is currently as described in Freckleton et al (2002). 
</p>
<p>The branch length transformations can be optimised between bounds using maximum likelihood by setting the value for a transformation to 'ML'. The default bounds are: lambda = c(1e-6,1), kappa = c(1e-6,3) and delta=c(1e-6,3). These defaults may be overridden by passing a named list with new elements to the bounds argument - only the bounds to be changed need to be provided (e.g. bounds=list(lambda=c(0,3))).
</p>
<p>The 'pgls.likelihood' and 'pgls.blenTransform' methods are not primarily intended to be called by users. The 'pgls.likelihood' function provides a general method to calculate the likelihood of a model, given the covariance matrix, response, design matrix and branch length parameters. 
</p>


<h3>Value</h3>

<p>The 'pgls' function returns an object of class <code>pgls</code> containing the following:
</p>
<p>&quot;na.action&quot; &quot;param.CI&quot;
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The original call to the 'pgls' function</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A summary of the fitted model containing:</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The model formula supplied.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The comparative data object provided.</p>
</td></tr>
<tr><td><code>dname</code></td>
<td>
<p>The name of the comparative data object.</p>
</td></tr>
<tr><td><code>logLikY</code></td>
<td>
<p>The log likelihood of the response variable given the model.</p>
</td></tr>
<tr><td><code>RMS</code></td>
<td>
<p>The residual mean square variance in the model.</p>
</td></tr> 
<tr><td><code>RSSQ</code></td>
<td>
<p>The residual sum of squares from the model.</p>
</td></tr> 
<tr><td><code>NMS</code></td>
<td>
<p>The null mean square variance for the model.</p>
</td></tr> 
<tr><td><code>NSSQ</code></td>
<td>
<p>The null sum of squares for the response.</p>
</td></tr> 
<tr><td><code>aic</code></td>
<td>
<p>The AIC score of the model</p>
</td></tr> 
<tr><td><code>aicc</code></td>
<td>
<p>The AICc score of the model, correcting for the number of cases and parameters estimated</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of rows of data used in fitting the model</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The number of parameter estimates</p>
</td></tr> 
<tr><td><code>sterr</code></td>
<td>
<p>The standard errors of the parameter estimates</p>
</td></tr> 
<tr><td><code>Vt</code></td>
<td>
<p>The phylogenetic covariance matrix used in the model, with branch length transformations applied.</p>
</td></tr> 
<tr><td><code>fitted</code></td>
<td>
<p>The predicted values</p>
</td></tr> 
<tr><td><code>residuals</code></td>
<td>
<p>The non-phylogenetic residuals</p>
</td></tr>
<tr><td><code>phyres</code></td>
<td>
<p>The phylogenetic residuals</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The design matrix of the model </p>
</td></tr>
<tr><td><code>varNames</code></td>
<td>
<p>The variables include in the model.</p>
</td></tr> 
<tr><td><code>y</code></td>
<td>
<p>The response of the model.</p>
</td></tr>
<tr><td><code>namey</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A named numeric vector of length three giving the branch length transformations used in the model.</p>
</td></tr>
<tr><td><code>mlVals</code></td>
<td>
<p>A named logical vector of length three indicating which branch length values in 'param' are maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p>The bounds on branch length parameter estimates used in the model.</p>
</td></tr>
<tr><td><code>param.CI</code></td>
<td>
<p>A named list of length three giving confidence intervals and the p values at the parameter bounds for optimised branch length transformations. Fixed parameters will have a NULL entry in this list.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>A named vector identifying any rows of missing data excluded from the model.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The model is fitted using a data frame reduced to complete row cases to eliminate missing values. In order to ensure that the models fitted using different subsets of the data are comparable, the whole data frame <code>data</code> is reduced to complete cases. In the future, a scope argument may be provided to control this but at present the data frame should be reduced to only those variables used in the maximal model in order to avoid prevent redundant variables causing rows to be dropped unnecessarily.
</p>


<h3>Author(s)</h3>

<p>Rob Freckleton; David Orme</p>


<h3>References</h3>

<p>R. P. Freckleton, P. H. Harvey, and M. Pagel. Phylogenetic analysis and comparative data: A test and 
review of evidence. American Naturalist, 160:712-726, 2002.</p>


<h3>See Also</h3>

<p><code><a href="#topic+pgls.profile">pgls.profile</a></code>, <code><a href="#topic+anova.pgls">anova.pgls</a></code>, <code><a href="#topic+summary.pgls">summary.pgls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species, vcv=TRUE, vcv.dim=3)
mod1 &lt;- pgls(log(Egg.Mass) ~ log(M.Mass) * log(F.Mass), shorebird, lambda='ML')
mod2 &lt;- pgls(log(Egg.Mass) ~ log(M.Mass), data=shorebird, lambda='ML', delta='ML')
</code></pre>

<hr>
<h2 id='pgls-methods'>
Generic model methods for 'pgls' models.
</h2><span id='topic+coef.pgls'></span><span id='topic+residuals.pgls'></span><span id='topic+fitted.pgls'></span><span id='topic+predict.pgls'></span><span id='topic+print.pgls'></span><span id='topic+summary.pgls'></span><span id='topic+print.summary.pgls'></span><span id='topic+nobs.pgls'></span>

<h3>Description</h3>

<p>These are simple summary methods, accessor functions and summary and print methods for 'pgls' models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pgls'
coef(object, ...)
## S3 method for class 'pgls'
residuals(object, phylo = FALSE, ...)
## S3 method for class 'pgls'
fitted(object, ...)
## S3 method for class 'pgls'
predict(object, newdata, ...)
## S3 method for class 'pgls'
summary(object, ...)
## S3 method for class 'pgls'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'summary.pgls'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'pgls'
nobs(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgls-methods_+3A_object">object</code></td>
<td>
<p>An object of class 'pgls'.</p>
</td></tr>
<tr><td><code id="pgls-methods_+3A_x">x</code></td>
<td>
<p>An object of class 'pgls'.</p>
</td></tr>
<tr><td><code id="pgls-methods_+3A_phylo">phylo</code></td>
<td>
<p>Return phylogenetically corrected residuals or ordinary residuals (see details).</p>
</td></tr>
<tr><td><code id="pgls-methods_+3A_newdata">newdata</code></td>
<td>
<p>Alternative data for predicting from 'pgls' models.</p>
</td></tr>
<tr><td><code id="pgls-methods_+3A_digits">digits</code></td>
<td>
<p>Number of digits to show in summary methods.</p>
</td></tr>
<tr><td><code id="pgls-methods_+3A_...">...</code></td>
<td>
<p>Further arguments to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Phylogenetically corrected residuals from 'pgls' models [TODO].
</p>
<p>Note that the r^2 values reported by <code>summary.pgls</code> have a specific interpretation. <code>pgls</code> fits the intercept-only model for the data using _exactly_ the same covariance matrix (phylogeny plugged through any branch length transformations) as the fitted model to get a null model. The r-squared and adjusted r-squared that are reported therefore hold the covariance matrix constant, so show percentage of variance explained between a null model and the actual model given that precise model of trait change.
</p>
<p>The actual ML null model for the data (optimising the BL transformation independently) might be different from this - but then the r squared values confound change in explanatory power from changing the model parameters and from changing the trait model.
</p>


<h3>Value</h3>

<p>The 'summary' method returns an object of class 'summary.pgls' containing:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The original function call creating the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>A vector of the degrees of freedom used to estimate parameters and the residual degrees of freedom.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The square root of the estimated variance of the random error.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The phylogenetically corrected residuals.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A table of model coefficient, standard errors and t values.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A vector of branch length parameters used in the model.</p>
</td></tr>
<tr><td><code>mlVals</code></td>
<td>
<p>A vector showing which branch length parameters have been optimised.</p>
</td></tr>
<tr><td><code>param.CI</code></td>
<td>
<p>A list of length three containing confidence intervals and p values on parameter bounds for each parameter.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>A vector of the F value, numerator and denominator degrees of freedom for the model.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>The r^2 for the model.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>The adjusted r^2 for the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob Freckleton, David Orme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pgls">pgls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species, vcv=TRUE, vcv.dim=3)
mod1 &lt;- pgls(log(Egg.Mass) ~ log(M.Mass) * log(F.Mass), shorebird) 
print(mod1)

mod1.sum &lt;- summary(mod1)
print(mod1.sum)
</code></pre>

<hr>
<h2 id='pgls.profile'>
Likelihood profiles and confidence intervals for 'pgls' models.
</h2><span id='topic+pgls.profile'></span><span id='topic+plot.pgls.profile'></span><span id='topic+pgls.confint'></span>

<h3>Description</h3>

<p>These functions create likelihood profiles for branch length transformations in phylogenetic generalised least squares models and fit confidence intervals to estimated branch length parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgls.profile(pgls, which = c("lambda", "kappa", "delta"), N = 50, param.CI = NULL)
pgls.confint(pgls, which=c('lambda','kappa','delta'), param.CI=0.95)
## S3 method for class 'pgls.profile'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgls.profile_+3A_pgls">pgls</code></td>
<td>
<p>A <code>pgls</code> object.</p>
</td></tr>
<tr><td><code id="pgls.profile_+3A_which">which</code></td>
<td>
<p>A choice of which branch length transformation ('lambda', 'kappa' or 'delta') to use.</p>
</td></tr>
<tr><td><code id="pgls.profile_+3A_n">N</code></td>
<td>
<p>The number of points used to profile the likelihood</p>
</td></tr>
<tr><td><code id="pgls.profile_+3A_param.ci">param.CI</code></td>
<td>
<p>A p value used to add confidence intervals to a likelihood profile for a parameter.</p>
</td></tr>
<tr><td><code id="pgls.profile_+3A_x">x</code></td>
<td>
<p>A 'pgls.profile' object to plot.</p>
</td></tr>
<tr><td><code id="pgls.profile_+3A_...">...</code></td>
<td>
<p>Further arguments to plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'pgls.profile' function calculates the likelihood of a 'pgls' model under different values of branch length transformations. A single parameter is chosen from 'lambda', 'kappa' or 'delta' to be profiled and the model likelihood is calculated at 'N' equally spaced  points between the parameter bounds used in the model. If the model contains a maximum likelihood estimate of the parameter (or if param.CI is not null) then the resulting 'pgls.profile' object will contain estimated confidence intervals. 
</p>
<p>Only one parameter is profiled at a time and the other branch length parameters will be held at the fixed or ML estimates used to fit the model. The 'pgls.confint' function is used by either 'pgls' or 'pgls.profile' to find confidence intervals around a maximum likelihood estimate of a given branch length. The model must contain an ML estimate of the parameter for confidence intervals to be calculated.
</p>
<p>The plot method simply draws an annotated profile plot, showing the location of the ML estimate and confidence intervals if present.
</p>


<h3>Value</h3>

<p>The 'pgls.profile' function returns a list containing:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Parameter values at which the likelihood has been calculated.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The likelihood value at each value.</p>
</td></tr>
<tr><td><code>which</code></td>
<td>
<p>The parameter being profiled.</p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>The value of the other fixed parameters.</p>
</td></tr>
<tr><td><code>dname</code></td>
<td>
<p>The name of the 'comparative.data' object used to fit the model.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula of the model being profiled</p>
</td></tr>
</table>
<p>If the model contains an ML estimate of the parameter being profiled, then the 'pgls.profile' object will also contain the output of 'pgls.confint':
</p>
<table>
<tr><td><code>opt</code></td>
<td>
<p>The maximum likelihood value of the parameter.</p>
</td></tr>
<tr><td><code>bounds.val</code></td>
<td>
<p>The values of the bounds on the parameter.</p>
</td></tr>
<tr><td><code>bounds.p</code></td>
<td>
<p>The p value of the likelihood at the bounds, given the ML value.</p>
</td></tr>
<tr><td><code>ci.val</code></td>
<td>
<p>The values of the parameter at the confidence intervals.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>The confidence interval value used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Orme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pgls">pgls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species, vcv=TRUE, vcv.dim=3)
mod &lt;- pgls(log(Egg.Mass) ~ log(M.Mass), shorebird, lambda='ML')
mod.l &lt;- pgls.profile(mod, 'lambda')
plot(mod.l)
pgls.confint(mod, 'lambda')

</code></pre>

<hr>
<h2 id='phylo.d'>Calculates the phylogenetic D statistic</h2><span id='topic+phylo.d'></span><span id='topic+print.phylo.d'></span><span id='topic+summary.phylo.d'></span><span id='topic+plot.phylo.d'></span>

<h3>Description</h3>

<p>Calculates the D value, a measure of phylogenetic signal in a binary trait, and tests the estimated D value for significant departure from both random association and the clumping expected under a Brownian evolution threshold model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo.d(data, phy, names.col, binvar, permut = 1000, rnd.bias=NULL)
## S3 method for class 'phylo.d'
print(x, ...)
## S3 method for class 'phylo.d'
summary(object, ...)
## S3 method for class 'phylo.d'
plot(x, bw=0.02, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo.d_+3A_data">data</code></td>
<td>
<p>A 'comparative.data' or 'data.frame' object.</p>
</td></tr>
<tr><td><code id="phylo.d_+3A_phy">phy</code></td>
<td>
<p>An object of class 'phylo', required when data is not a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="phylo.d_+3A_names.col">names.col</code></td>
<td>
<p>A name specifying the column in 'data' that matches rows to tips in 'phy', required when data is not a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="phylo.d_+3A_binvar">binvar</code></td>
<td>
<p>The name of the variable in <code>data</code> holding the binary variable of interest.</p>
</td></tr>
<tr><td><code id="phylo.d_+3A_permut">permut</code></td>
<td>
<p>Number of permutations to be used in the randomisation test.</p>
</td></tr>
<tr><td><code id="phylo.d_+3A_rnd.bias">rnd.bias</code></td>
<td>
<p>An optional name of a variable in <code>data</code> holding probability weights to bias the generation of the random distribution. See 'destails'</p>
</td></tr>
<tr><td><code id="phylo.d_+3A_x">x</code></td>
<td>
<p>An object of class 'phylo.d'</p>
</td></tr>
<tr><td><code id="phylo.d_+3A_object">object</code></td>
<td>
<p>An object of class 'phylo.d'</p>
</td></tr>
<tr><td><code id="phylo.d_+3A_bw">bw</code></td>
<td>
<p>The bandwidth to be used for the density plots</p>
</td></tr>
<tr><td><code id="phylo.d_+3A_...">...</code></td>
<td>
<p>Further arguments to print and summary methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sum of changes in estimated nodal values of a binary trait along edges in a phylogeny (D) provides a measure of the phylogenetic signal in that trait (Fritz and Purvis, 2010). If a trait is highly conserved, with only a basal division between two clades expressing either trait value, then the only change will be along the two daughters at the root. This will give a summed value of 1: the two differences between the root nodal value of 0.5 and the ancestors of the 1 and 0 clades. In contrast, if the trait is labile, more differences will be observed and the sum will be higher.
</p>
<p>This function calculates the observed D for a binary trait on a tree and compares this to the value of D found using an equal number of simulations under each of two models:
</p>

<dl>
<dt>Phylogenetic randomness</dt><dd><p>Trait values are randomly shuffled relative to the tips of the phylogeny and D is calculated.</p>
</dd>
<dt>Brownian threshold model</dt><dd><p>A continuous trait is evolved along the phylogeny under a Brownian process and then converted to a binary trait using a threshold that reproduces the relative prevalence of the observed trait.</p>
</dd>
</dl>

<p>The value of D depends on phylogeny size - more sister clades yield higher sums - and so the means of the  two sets of simulated data are used as calibrations to scale both observed and simulated values of D to set points of 0 (as phylogenetically conserved as expected under a Brownian threshold model) and 1 (random). The value of D can be both smaller than 0 (highly conserved) and greater than 1 (overdispersed) and the distributions of scaled D from the simulations are used to assess the significance of the observed scaled D. The <code>plot</code> method generates density plots of the distributions of the two simulations relative to the observed D value.
</p>
<p><code>rnd.bias</code> is passed to <code><a href="base.html#topic+sample">sample</a></code> as the <code>prob</code> argument to weight the random shuffles of the observed trait. The weights are not checked for validity.</p>


<h3>Value</h3>

<p>Returns an object of class 'phylo.d', which is a list of the following:
</p>
<table>
<tr><td><code>DEstimate</code></td>
<td>
<p>The estimated D value</p>
</td></tr>
<tr><td><code>Pval1</code></td>
<td>
<p>A p value, giving the result of testing whether D is significantly different from one</p>
</td></tr>
<tr><td><code>Pval0</code></td>
<td>
<p>A p value, giving the result of testing whether D is significantly different from zero</p>
</td></tr>
<tr><td><code>Parameters</code></td>
<td>
<p>A list of the Observed, MeanRandom and MeanBrownian sums of sister-clade differences</p>
</td></tr>
<tr><td><code>Permutations</code></td>
<td>
<p>A list with elements random and brownian, containing the sums of sister-clade differences from random permutations and simulations of Brownian evolution under a threshold model</p>
</td></tr>
<tr><td><code>NodalVals</code></td>
<td>
<p>A list with the elements observed, random and brownian, containing the nodal values estimated for the observed trait and permutations. The values are as matrices with rows labelled by the node names in the comparative data object.</p>
</td></tr>
<tr><td><code>binvar</code></td>
<td>
<p>The binary variable used</p>
</td></tr>
<tr><td><code>phyName</code></td>
<td>
<p>The name of the phylogeny object used</p>
</td></tr>
<tr><td><code>dsName</code></td>
<td>
<p>The name of the dataframe used</p>
</td></tr>
<tr><td><code>nPermut</code></td>
<td>
<p>The number of permutations used</p>
</td></tr>
<tr><td><code>rnd.bias</code></td>
<td>
<p>If a bias was introduced to the calculation of the random distribution, the bias used, else <code>NULL</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Susanne Fritz &lt;Susanne.Fritz@senckenberg.de&gt; and David Orme</p>


<h3>References</h3>

<p>Fritz, S. A. and Purvis, A. (2010). Selectivity in mammalian extinction risk and threat types: a new measure of phylogenetic signal strength in binary traits. Conservation Biology, 24(4):1042-1051.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BritishBirds)
BritishBirds &lt;- comparative.data(BritishBirds.tree, BritishBirds.data, binomial)
redPhyloD &lt;- phylo.d(BritishBirds, binvar=Red_list)
print(redPhyloD)
plot(redPhyloD)
</code></pre>

<hr>
<h2 id='phylo.d.subset'>Calculates the phylogenetic D statistic across clades within a phylogeny</h2><span id='topic+phylo.d.subset'></span><span id='topic+print.phylo.d.subset'></span><span id='topic+summary.phylo.d.subset'></span>

<h3>Description</h3>

<p>Calculates the D value, a measure of phylogenetic signal in a binary trait, and tests the estimated D value for significant departure from both random association and the clumping expected under a Brownian evolution threshold model. Does this across clades within a phylogeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo.d.subset(data, phy, names.col, binvar, permut = 1000, rnd.bias=NULL, 
	           min.tips=1, max.tips=length(data$phy$tip.label), min.nodes=1, 
			   max.nodes=data$phy$Nnode, verbose=FALSE)
## S3 method for class 'phylo.d.subset'
print(x, ...)
## S3 method for class 'phylo.d.subset'
summary(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo.d.subset_+3A_data">data</code></td>
<td>
<p>A 'comparative.data' or 'data.frame' object.</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_phy">phy</code></td>
<td>
<p>An object of class 'phylo', required when data is not a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_names.col">names.col</code></td>
<td>
<p>A name specifying the column in 'data' that matches rows to tips in 'phy', required when data is not a 'comparative.data' object.</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_binvar">binvar</code></td>
<td>
<p>The name of the variable in <code>data</code> holding the binary variable of interest.</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_permut">permut</code></td>
<td>
<p>Number of permutations to be used in the randomisation test.</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_rnd.bias">rnd.bias</code></td>
<td>
<p>An optional name of a variable in <code>data</code> holding probability weights to bias the generation of the random distribution. See 'destails'</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_verbose">verbose</code></td>
<td>
<p>Logical; do you want to know how many clades are being assessed, and see when each is being assessed?</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_min.tips">min.tips</code></td>
<td>
<p>The minimum number of tips a clade should have for it to have a D value calculated. Defaults to 1 (i.e. no limit).</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_max.tips">max.tips</code></td>
<td>
<p>The maximum number of species a clade should have for it to have a D value calculated. Defaults to the number of species in the whole phylogeny (i.e. no limit).</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_min.nodes">min.nodes</code></td>
<td>
<p>The minimum number of nodes a clade should have for it to have a D value calculated. Defaults to 1 (i.e. no limit).</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_max.nodes">max.nodes</code></td>
<td>
<p>The maximum number of nodes a clade should have for it to have a D value calculated. Defaults to the number of nodes in the whole phylogeny (i.e. no limit).</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_x">x</code></td>
<td>
<p>An object of class 'phylo.d.subset'</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_object">object</code></td>
<td>
<p>An object of class 'phylo.d.subset'</p>
</td></tr>
<tr><td><code id="phylo.d.subset_+3A_...">...</code></td>
<td>
<p>Further arguments to print and summary methods</p>
</td></tr></table>


<h3>Details</h3>

<p>A wrapper function for <code><a href="#topic+phylo.d">phylo.d</a></code>, calculating D values for clades within a given dataset. These clades can be filtered according to the number of species and nodes using the arguments above. See <code><a href="#topic+phylo.d">phylo.d</a></code> for more details on the method itself.
</p>
<p>Any clades for which there is no variation in the binary variable have <code>NA</code> values for all of the below slots.</p>


<h3>Value</h3>

<p>Returns an object of class 'phylo.d.subset', which is a list of the following:
</p>
<table>
<tr><td><code>raw</code></td>
<td>
<p>A list of the raw output from <code><a href="#topic+phylo.d">phylo.d</a></code> for each clade</p>
</td></tr>
<tr><td><code>DEstimate</code></td>
<td>
<p>A vector of the estimated D values</p>
</td></tr>
<tr><td><code>Pval1</code></td>
<td>
<p>A vector of p values, giving the result of testing whether D is significantly different from one, for each clade</p>
</td></tr>
<tr><td><code>Pval0</code></td>
<td>
<p>A vector of p values, giving the result of testing whether D is significantly different from zero, for each clade</p>
</td></tr>
<tr><td><code>phy.depth</code></td>
<td>
<p>A numeric vector giving the age of the clade for which each value was calculated</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Susanne Fritz (SFritz@bio.ku.dk), Will Pearse and  David Orme</p>


<h3>References</h3>

<p>Fritz, S. A. and Purvis, A. (2010). Selectivity in mammalian extinction risk and threat types: a new measure of phylogenetic signal strength in binary traits. Conservation Biology, 24(4):1042-1051.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BritishBirds)
BritishBirds &lt;- comparative.data(BritishBirds.tree, BritishBirds.data, binomial)
# Look at big clades only
## Not run: 
bigClades &lt;- phylo.d.subset(BritishBirds, binvar=Red_list, verbose=TRUE, min.tips=10, min.nodes=5)
print(bigClades)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.pgls'>
Diagnostic plots for 'pgls' models.
</h2><span id='topic+plot.pgls'></span>

<h3>Description</h3>

<p>The function generates four diagnostics plots for 'pgls' models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pgls'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pgls_+3A_x">x</code></td>
<td>
<p>An object of class 'pgls'.</p>
</td></tr>
<tr><td><code id="plot.pgls_+3A_...">...</code></td>
<td>
<p>Additional arguments to plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two plots show the fit of the phylogenetic residuals from the model to a normal distribution: a density plot of the residuals and a normal Q-Q plot. The second two plots scatterplots show pattern in the distribution of the fitted values against the observed and residual values.
</p>


<h3>Author(s)</h3>

<p>Rob Freckleton, David Orme
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pgls">pgls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species, vcv=TRUE, vcv.dim=3)
mod1 &lt;- pgls(log(Egg.Mass) ~ log(M.Mass) * log(F.Mass), shorebird)
par(mfrow=c(2,2))
plot(mod1)
</code></pre>

<hr>
<h2 id='shorebird'>Example dataset for the caper package</h2><span id='topic+shorebird'></span><span id='topic+shorebird.data'></span><span id='topic+shorebird.tree'></span>

<h3>Description</h3>

<p>This is a comparative dataset on the evolution of shorebird egg size taken from Lislevand and Thomas (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shorebird)
</code></pre>


<h3>Format</h3>

<p>The datafile contains a phylogeny (<code>shorebird.tree</code>) of 71 shorebird species as a 'phylo' object from the <code>ape</code> library. The tip names are the binomial names of the species. The file also contains a data frame (<code>shorebird.data</code>) of 71 complete cases for those species. The data frame contains six variables: 
</p>

<dl>
<dt>Species</dt><dd><p>The species binomial name.</p>
</dd>
<dt>M.Mass</dt><dd><p>The adult male mass body mass in grams.</p>
</dd>
<dt>F.Mass</dt><dd><p>The adult female mass body mass in grams.</p>
</dd>
<dt>Egg.Mass</dt><dd><p>The fresh egg mass in grams.</p>
</dd>
<dt>Cl.size</dt><dd><p>The mean clutch size</p>
</dd>
<dt>Mat.syst</dt><dd><p>The mating system, as a three level factor: monogamous (MO), polygynous (PO) or polyandrous (PA).</p>
</dd>
</dl>



<h3>References</h3>

<p>Lislevand, T and Thomas, G. H. (2006) Limited male incubation ability and the evolution of egg size in shorebirds. Biology Letters 2, 206 - 208</p>


<h3>See Also</h3>

<p>crunch, pgls</p>

<hr>
<h2 id='summary.caic'>Summarize a crunch, brunch or macrocaic analysis</h2><span id='topic+summary.caic'></span><span id='topic+print.caic'></span>

<h3>Description</h3>

<p>The summary method simply returns the linear model summary from the 'caic' object. The print method prints some basic information about the analysis followed by the model summary.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caic'
summary(object, ...)
## S3 method for class 'caic'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.caic_+3A_object">object</code></td>
<td>
<p>An object of class 'caic'.</p>
</td></tr>
<tr><td><code id="summary.caic_+3A_x">x</code></td>
<td>
<p>An object of class 'caic'.</p>
</td></tr>
<tr><td><code id="summary.caic_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to 'summary.lm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary method returns an object of class 'summary.lm'.
</p>


<h3>Author(s)</h3>

<p>David Orme</p>


<h3>See Also</h3>

<p><code><a href="#topic+crunch">crunch</a></code>,<code><a href="#topic+brunch">brunch</a></code>, <code>link{macrocaic}</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shorebird)
shorebird &lt;- comparative.data(shorebird.tree, shorebird.data, Species)
crunchMod &lt;- crunch(Egg.Mass ~ F.Mass + M.Mass, data=shorebird)
print(crunchMod)
summary(crunchMod)
</code></pre>

<hr>
<h2 id='syrphidae'>The syrphidae dataset of Katzourakis et al. 2001 </h2><span id='topic+syrphidae'></span><span id='topic+syrphidaeTree'></span><span id='topic+syrphidaeRich'></span>

<h3>Description</h3>

<p>A genus level phylogeny of the Syrphidae (sawflies) along with data on the species richness of each genus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(syrphidae)
</code></pre>


<h3>Format</h3>

<p>A 'phylo' object (<code>syrphidaeTree</code>) containing a phylogeny of 204 genera of sawflies and a data frame  (<code>syrphidaeRich</code>) of the species richness of each genus. 
</p>


<h3>References</h3>

<p>Katzourakis, A., Purvis, A., Azmeh, S., Rotheray, G., and Gilbert, F. (2001). Macroevolution of hoverflies (Diptera : Syrphidae): the effect of using higher-level taxa in studies of biodiversity, and correlates of species richness. Journal of Evolutionary Biology, 14:219-227.
</p>


<h3>See Also</h3>

<p>fusco.test</p>

<hr>
<h2 id='VCV.array'>Create a 2D or 3D variance-covariance matrix from a phylogeny</h2><span id='topic+VCV.array'></span>

<h3>Description</h3>

<p>The function turns a phylogeny into a variance-covariance matrix, as in the function <code>vcv.phylo</code> in the 'ape' package but can also return a 3D array retaining the individual branch lengths contributing to the shared branch lengths. This is useful for handling some branch length transformations, such as kappa, and has a lower overhead than repeatedly calling <code>vcv.phylo</code> on a phylogeny after transforming the vector of edge lengths.</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCV.array(phy, dim=2, compact=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VCV.array_+3A_phy">phy</code></td>
<td>
<p>An object of class 'phylo'.</p>
</td></tr>
<tr><td><code id="VCV.array_+3A_dim">dim</code></td>
<td>
<p>Either 2, for a standard VCV matrix, or 3, for an array of branch lengths.</p>
</td></tr>
<tr><td><code id="VCV.array_+3A_compact">compact</code></td>
<td>
<p>A logical vector indicating the form to use for a 3D array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The compact form of the 3D array uses a shortened third dimension, which is only long enough to hold the maximum number of shared branches between root and tip for each pair of tips. Zeros are used to pad out this depth vector for tip pairs with shorter paths. The non-compact form returns 3D array showing, for each pair of tips and each node in the tree, either 0 if the node is not shared or the appropriate edge length if the node is shared. Note that, for maximally unbalanced trees, the size of the two forms will be identical.
</p>
<p>The algorithm for the noncompact form is faster than for the compact form but it has very high memory overheads on big trees. The 2 dimensional algorithm is at least twice as fast as <code>vcv.phylo</code> on trees up to 2500 tips.
</p>
<p>The <code>apply</code> function can be easily used to collapse the array down to a standard VCV matrix, as in the example. 
</p>


<h3>Value</h3>

<p>When dim = 2, a variance covariance matrix of class 'VCV.array' of dimension nTips by nTips with dimnames set from the tip labels of the phylogeny.
</p>
<p>When dim = 3, a 3 dimensional array of class 'VCV.array' with dimensions of the number of taxa in the phylogeny for the rows and columns and either the maximum number of branches on the root to tip path or the number of internal nodes as the depth, depending on the setting of <code>compact</code>. The rows and columns are named using the tip labels from the phylogeny and the depth only named with node numbers if <code>compact</code> is TRUE. 
</p>


<h3>Author(s)</h3>

<p>David Orme</p>


<h3>See Also</h3>

 <p><code><a href="ape.html#topic+vcv.phylo">vcv.phylo</a></code>,  <code><a href="#topic+pgls">pgls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- rcoal(8)
tree.VCV &lt;- vcv.phylo(tree)
tree.VCVA &lt;- VCV.array(tree)

# reconstruct a simple VCV array
tree.VCVA.reduced &lt;- apply(tree.VCVA, c(1,2), sum, na.rm=TRUE)

# minimal differences between the two
all((tree.VCVA.reduced - tree.VCV) &lt; 1e-10)

# a kappa transformation of 0.5
apply(tree.VCVA ^ 0.5, c(1,2), sum, na.rm=TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
