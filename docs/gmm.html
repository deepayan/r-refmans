<!DOCTYPE html><html lang="en"><head><title>Help for package gmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ATEgel'><p>ATE with Generalized Empirical Likelihood estimation</p></a></li>
<li><a href='#bread'><p>Bread for sandwiches</p></a></li>
<li><a href='#bwWilhelm'><p>Wilhelm (2015) bandwidth selection</p></a></li>
<li><a href='#charStable'><p>The characteristic function of a stable distribution</p></a></li>
<li><a href='#coef'><p>Coefficients of GEL or GMM</p></a></li>
<li><a href='#confint'><p>Confidence intervals for GMM or GEL</p></a></li>
<li><a href='#estfun'><p>Extracts the empirical moment function</p></a></li>
<li><a href='#Finance'><p>Returns on selected stocks</p></a></li>
<li><a href='#FinRes'><p>Method to finalize the result of the momentEstim method</p></a></li>
<li><a href='#fitted'><p>Fitted values of GEL and GMM</p></a></li>
<li><a href='#formula'><p>Formula method for gel and gmm objects</p></a></li>
<li><a href='#gel'><p>Generalized Empirical Likelihood estimation</p></a></li>
<li><a href='#getDat'><p>Extracting data from a formula</p></a></li>
<li><a href='#getImpProb'><p>Implied Probabilities</p></a></li>
<li><a href='#getLamb'><p>Solving for the Lagrange multipliers of Generalized Empirical Likelihood (GEL)</p></a></li>
<li><a href='#getModel'><p>Method for setting the properties of a model</p></a></li>
<li><a href='#gmm'><p>Generalized method of moment estimation</p></a></li>
<li><a href='#Growth'><p>Growth Data</p></a></li>
<li><a href='#KTest'><p>Compute the K statistics of Kleibergen</p></a></li>
<li><a href='#marginal'><p>Marginal effects Summary</p></a></li>
<li><a href='#momentEstim'><p>Method for estimating models based on moment conditions</p></a></li>
<li><a href='#nsw'><p>Lalonde subsample of the National Supported Work Demonstration Data</p>
(NSW)</a></li>
<li><a href='#plot'><p>Plot Diagnostics for gel and gmm objects</p></a></li>
<li><a href='#print'><p>Printing a gmm or gel object</p></a></li>
<li><a href='#residuals'><p>Residuals of GEL or GMM</p></a></li>
<li><a href='#smoothG'><p>Kernel smoothing of a matrix of time series</p></a></li>
<li><a href='#specTest'><p>Compute tests of specification</p></a></li>
<li><a href='#summary'><p>Method for object of class gmm or gel</p></a></li>
<li><a href='#sysGmm'><p>Generalized method of moment estimation for system of equations</p></a></li>
<li><a href='#tsls'><p>Two stage least squares estimation</p></a></li>
<li><a href='#vcov'><p>Variance-covariance matrix of GMM or GEL</p></a></li>
<li><a href='#wage'><p>Labor Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Method of Moments and Generalized Empirical
Likelihood</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre Chausse &lt;pchausse@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre Chausse &lt;pchausse@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>It is a complete suite to estimate models based on moment conditions. It includes the two step Generalized method of moments (Hansen 1982; &lt;<a href="https://doi.org/10.2307%2F1912775">doi:10.2307/1912775</a>&gt;), the iterated GMM and continuous updated estimator (Hansen, Eaton and Yaron 1996; &lt;<a href="https://doi.org/10.2307%2F1392442">doi:10.2307/1392442</a>&gt;) and several methods that belong to the Generalized Empirical Likelihood family of estimators (Smith 1997; &lt;<a href="https://doi.org/10.1111%2Fj.0013-0133.1997.174.x">doi:10.1111/j.0013-0133.1997.174.x</a>&gt;, Kitamura 1997; &lt;<a href="https://doi.org/10.1214%2Faos%2F1069362388">doi:10.1214/aos/1069362388</a>&gt;, Newey and Smith 2004; &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2004.00482.x">doi:10.1111/j.1468-0262.2004.00482.x</a>&gt;, and Anatolyev 2005 &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2005.00601.x">doi:10.1111/j.1468-0262.2005.00601.x</a>&gt;).	</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), sandwich</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mvtnorm, car, stabledist, MASS, timeDate, timeSeries</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, grDevices, graphics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>gmm</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>212</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2023-06-06 14:44:35</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-06 15:50:02 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-06 15:04:25 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='ATEgel'>ATE with Generalized Empirical Likelihood estimation</h2><span id='topic+ATEgel'></span><span id='topic+checkConv'></span>

<h3>Description</h3>

<p>Function to estimate the average treatment effect with the sample being
balanced by GEL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATEgel(g, balm, w=NULL, y=NULL, treat=NULL, tet0=NULL,momType=c("bal","balSample","ATT"),
                   popMom = NULL, family=c("linear","logit", "probit"),
                   type = c("EL", "ET", "CUE", "ETEL", "HD", "ETHD", "RCUE"),
                   tol_lam = 1e-9, tol_obj = 1e-9, tol_mom = 1e-9, maxiterlam = 100,
                   optfct = c("optim", "nlminb"), 
                   optlam = c("nlminb", "optim", "iter", "Wu"), data=NULL,
                   Lambdacontrol = list(),
                   model = TRUE, X = FALSE, Y = FALSE, ...)
checkConv(obj, tolConv=1e-4, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ATEgel_+3A_g">g</code></td>
<td>
<p>A formula as <code>y~z</code>, where codey is the response and
<code>z</code> the treatment indicator. If there is more than one
treatment, more indicators can be added or <code>z</code> can be set as a
factor. It can also be of the form
<code>g(theta, y, z)</code> for non-linear models. It is however, not
implemented yet.</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>"ategel"</code> produced y <code>ATEgel</code></p>
</td></tr>
<tr><td><code id="ATEgel_+3A_balm">balm</code></td>
<td>
<p>A formula for the moments to be balanced between the treated
and control groups (see details)</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_y">y</code></td>
<td>
<p>The response variable when <code>g</code> is a function. Not
implemented yet</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_treat">treat</code></td>
<td>
<p>The treatment indicator when <code>g</code> is a function. Not
implemented yet</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_w">w</code></td>
<td>
<p>A formula to add covariates to the main regression. When
<code>NULL</code>, the default value, the main regression only include
treatment indicators.</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_tet0">tet0</code></td>
<td>
<p>A <code class="reqn">3 \times 1</code> vector of starting values. If not
provided, they are obtained using an OLS regression</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_momtype">momType</code></td>
<td>
<p>How the moments of the covariates should be balanced. By
default, it is simply balanced without restriction. Alternatively,
moments can be set equal to the sample moments of the whole sample, or
to the sample  moments of the treated group. The later will produce
the average treatment effect of the treated (ATT)</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_popmom">popMom</code></td>
<td>
<p>A vector of population moments to use for balancing. It
can be used of those moments are available from a census, for
example. When available, it greatly improves efficiency.</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_family">family</code></td>
<td>
<p>By default, the outcome is linearly related to the
treatment indicators. If the outcome is binary, it is possible to use
the estimating equations of either the logit or probit model.</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_type">type</code></td>
<td>
<p>&quot;EL&quot; for empirical likelihood, &quot;ET&quot; for exponential tilting,
&quot;CUE&quot; for continuous updated estimator, &quot;ETEL&quot; for exponentially
tilted empirical likelihood of Schennach(2007), &quot;HD&quot; for Hellinger
Distance of Kitamura-Otsu-Evdokimov (2013), and &quot;ETHD&quot; for the
exponentially tilted Hellinger distance of Antoine-Dovonon
(2015). &quot;RCUE&quot; is a restricted version of &quot;CUE&quot; in which the
probabilities are bounded below by zero. In that case, an analytical
Kuhn-Tucker method is used to find the solution.</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_tol_lam">tol_lam</code></td>
<td>
<p>Tolerance for <code class="reqn">\lambda</code> between two iterations. The
algorithm stops when <code class="reqn">\|\lambda_i -\lambda_{i-1}\|</code> reaches
<code>tol_lamb</code> (see <code><a href="#topic+getLamb">getLamb</a></code>) </p>
</td></tr>
<tr><td><code id="ATEgel_+3A_maxiterlam">maxiterlam</code></td>
<td>
<p>The algorithm to compute <code class="reqn">\lambda</code> stops if there
is no convergence after &quot;maxiterlam&quot; iterations (see
<code><a href="#topic+getLamb">getLamb</a></code>).</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_tol_obj">tol_obj</code></td>
<td>
<p>Tolerance for the gradiant of the objective function to
compute <code class="reqn">\lambda</code> (see <code><a href="#topic+getLamb">getLamb</a></code>).</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_optfct">optfct</code></td>
<td>
<p>Algorithm used for the parameter estimates</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_tol_mom">tol_mom</code></td>
<td>
<p>It is the tolerance for the moment condition
<code class="reqn">\sum_{t=1}^n p_t g(\theta(x_t)=0</code>, where
<code class="reqn">p_t=\frac{1}{n}D\rho(&lt;g_t,\lambda&gt;)</code> is the implied probability. It
adds a penalty if the solution diverges from its goal.</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_optlam">optlam</code></td>
<td>
<p>Algorithm used to solve for the lagrange multiplier in
<code><a href="#topic+getLamb">getLamb</a></code>. The algorithm Wu is only for
<code>type="EL"</code>. The value of <code>optlam</code> is ignored for &quot;CUE&quot;
because in that case, the analytical solution exists.</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_data">data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optional). </p>
</td></tr>
<tr><td><code id="ATEgel_+3A_lambdacontrol">Lambdacontrol</code></td>
<td>
<p>Controls for the optimization of the vector of
Lagrange multipliers used by either <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+constrOptim">constrOptim</a></code></p>
</td></tr>
<tr><td><code id="ATEgel_+3A_model">model</code>, <code id="ATEgel_+3A_x">X</code>, <code id="ATEgel_+3A_y">Y</code></td>
<td>
<p>logicals.  If <code>TRUE</code> the corresponding
components of the fit (the model frame, the model matrix, the response)
are returned if g is a formula.</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, a summary of the convergence is printed</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_tolconv">tolConv</code></td>
<td>
<p>The tolerance for comparing moments between groups</p>
</td></tr>
<tr><td><code id="ATEgel_+3A_...">...</code></td>
<td>
<p>More options to give to <code><a href="stats.html#topic+optim">optim</a></code> or
<code><a href="stats.html#topic+nlminb">nlminb</a></code>. In <code>checkConv</code>, they are options passed to
<code><a href="#topic+getImpProb">getImpProb</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We want to estimate the model <code class="reqn">Y_t = \theta_1 + \theta_2 treat +
  \epsilon_t</code>, where <code class="reqn">\theta_2</code> is the treatment effect.  GEL is
used to balance the sample based on the argument <code>x</code> above.
</p>
<p>For example, if we want the sample mean of <code>x1</code> and <code>x2</code> to be
balanced between the treated and control, we set <code>x</code> to
<code>~x1+x2</code>. If we want the sample mean of <code>x1</code>, <code>x2</code>,
<code>x1*x2</code>, <code>x1^2</code> and <code>x2^2</code>, we set <code>x</code> to
<code>~x1*x2 + I(x1^2) + I(x2^2)</code>.
</p>


<h3>Value</h3>

<p>'gel' returns an object of 'class' '&quot;ategel&quot;'  
</p>
<p>The functions 'summary' is used to obtain and print a summary of the results. 
</p>
<p>The object of class &quot;ategel&quot; is a list containing the same elements
contained in objects of class <code><a href="#topic+gel">gel</a></code>.
</p>


<h3>References</h3>

<p>Lee, Seojeong (2016), Asymptotic refinements of misspecified-robust
bootstrap for GEL estimators, <em>Journal of Econometrics</em>,
<b>192</b>, 86&ndash;104.
</p>
<p>Schennach, Susanne, M. (2007), Point Estimation with Exponentially Tilted Empirical Likelihood.
<em>Econometrica</em>, <b>35</b>, 634-672.
</p>
<p>Wu, C. (2005), Algorithms and R codes for the pseudo empirical
likelihood method in survey sampling.
<em>Survey Methodology</em>, <b>31</b>(2), page 239.
</p>
<p>Chausse, P. (2010), Computing Generalized Method of Moments and Generalized Empirical Likelihood with R.
<em>Journal of Statistical Software</em>, <b>34</b>(11), 1&ndash;35.
URL <a href="https://doi.org/10.18637/jss.v034.i11">doi:10.18637/jss.v034.i11</a>.
</p>
<p>Chausse, P. and Giurcanu, M. and Luta, G. (2021) Estimating the Average Causal Effect
using Generalized Empirical Likelihood Methods, Work in progress. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nsw)
# Scale income
nsw$re78 &lt;- nsw$re78/1000
nsw$re75 &lt;- nsw$re75/1000
res &lt;- ATEgel(re78~treat, ~age+ed+black+hisp+married+nodeg+re75,
data=nsw,type="ET")
summary(res)
chk &lt;- checkConv(res)

res2 &lt;- ATEgel(re78~treat, ~age+ed+black+hisp+married+nodeg+re75,
data=nsw,type="ET", momType="balSample")
summary(res2)
chk2 &lt;- checkConv(res2)

</code></pre>

<hr>
<h2 id='bread'>Bread for sandwiches</h2><span id='topic+bread.gmm'></span><span id='topic+bread.gel'></span><span id='topic+bread.tsls'></span>

<h3>Description</h3>

<p>Computes the bread of the sandwich covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmm'
bread(x, ...)
## S3 method for class 'gel'
bread(x, ...)
## S3 method for class 'tsls'
bread(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bread_+3A_x">x</code></td>
<td>
<p>A fitted model of class <code>gmm</code> or <code>gel</code>.</p>
</td></tr>
<tr><td><code id="bread_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>bread</code> is applied to another class object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the weighting matrix is not the optimal one, the covariance matrix of the estimated coefficients is:
<code class="reqn">(G'WG)^{-1} G'W V W G(G'WG)^{-1}</code>, 
where <code class="reqn">G=d\bar{g}/d\theta</code>, <code class="reqn">W</code> is the matrix of weights, and <code class="reqn">V</code> is the covariance matrix of the moment function. Therefore, the bread is <code class="reqn">(G'WG)^{-1}</code>, which is the second derivative of the objective function. 
</p>
<p>The method if not yet available for <code>gel</code> objects.
</p>


<h3>Value</h3>

<p>A <code class="reqn">k \times k</code> matrix (see details). 
</p>


<h3>References</h3>

<p>Zeileis A (2006), Object-oriented Computation of Sandwich Estimators.
<em>Journal of Statistical Software</em>, <b>16</b>(9), 1&ndash;16.
URL <a href="https://doi.org/10.18637/jss.v016.i09">doi:10.18637/jss.v016.i09</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See \code{\link{gmm}} for more details on this example.
# With the identity matrix 
# bread is the inverse of (G'G)

n &lt;- 1000
x &lt;- rnorm(n, mean = 4, sd = 2)
g &lt;- function(tet, x)
        {
        m1 &lt;- (tet[1] - x)
        m2 &lt;- (tet[2]^2 - (x - tet[1])^2)
        m3 &lt;- x^3 - tet[1]*(tet[1]^2 + 3*tet[2]^2)
        f &lt;- cbind(m1, m2, m3)
        return(f)
        }
Dg &lt;- function(tet, x)
        {
        jacobian &lt;- matrix(c( 1, 2*(-tet[1]+mean(x)), -3*tet[1]^2-3*tet[2]^2,0, 2*tet[2],
				-6*tet[1]*tet[2]), nrow=3,ncol=2)
        return(jacobian)
        }

res &lt;- gmm(g, x, c(0, 0), grad = Dg,weightsMatrix=diag(3))
G &lt;- Dg(res$coef, x)
bread(res)
solve(crossprod(G))
</code></pre>

<hr>
<h2 id='bwWilhelm'>Wilhelm (2015) bandwidth selection</h2><span id='topic+bwWilhelm'></span>

<h3>Description</h3>

<p>It computes the optimal bandwidth for the HAC estimation of the
covariance matrix of the moment conditions. The bandwidth was shown by
Wilhelm (2005) to be the one that minimizes the MSE of the GMM estimator. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwWilhelm(x, order.by = NULL, kernel = c("Quadratic Spectral",
  "Bartlett", "Parzen", "Tukey-Hanning"), approx = c("AR(1)", "ARMA(1,1)"),
  weights = NULL, prewhite = 1, ar.method = "ols", data = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bwWilhelm_+3A_x">x</code></td>
<td>
<p>An object of class <code>gmm</code>.</p>
</td></tr>
<tr><td><code id="bwWilhelm_+3A_order.by">order.by</code></td>
<td>
<p>Either a vector 'z' or a formula with a single
explanatory variable like '~ z'. The observations in the model are ordered by the size of 'z'. If set to 'NULL' (the default)
the observations are assumed to be ordered (e.g., a time
series).</p>
</td></tr>
<tr><td><code id="bwWilhelm_+3A_kernel">kernel</code></td>
<td>
<p>type of kernel used to compute the covariance matrix of the vector of sample moment conditions (see <code>kernHAC</code> for more details)</p>
</td></tr>
<tr><td><code id="bwWilhelm_+3A_approx">approx</code></td>
<td>
<p>A character specifying the approximation method if the bandwidth has to be chosen by <code>bwAndrews</code>.</p>
</td></tr>
<tr><td><code id="bwWilhelm_+3A_weights">weights</code></td>
<td>
<p>numeric. A vector of weights used for weighting the
estimated coefficients of the approximation model (as specified by 'approx'). By default all weights are 1 except that for the
intercept term (if there is more than one variable)</p>
</td></tr>
<tr><td><code id="bwWilhelm_+3A_prewhite">prewhite</code></td>
<td>
<p>logical or integer. Should the estimating functions be prewhitened? If <code>TRUE</code> or greater than 0 a VAR model of order <code>as.integer(prewhite)</code> is fitted via <code>ar</code> with method <code>"ols"</code> and <code>demean = FALSE</code>.</p>
</td></tr>
<tr><td><code id="bwWilhelm_+3A_ar.method">ar.method</code></td>
<td>
<p>character. The <code>method</code> argument passed to <code><a href="stats.html#topic+ar">ar</a></code> for prewhitening.</p>
</td></tr>
<tr><td><code id="bwWilhelm_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the 'order.by' model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function 'bwWilhelm'  returns the optimal bandwidth.
</p>


<h3>Note</h3>

<p>The function was written by Daniel Wilhelm and is based on bwAndrews.
</p>


<h3>References</h3>

<p>Wilhelm, D. (2015), Optimal Bandwidth Selection for Robust Generalized
Method of Moments Estimation.
<em>Econometric Theory</em>, <b>31</b>, 1054&ndash;1077
</p>
<p>Zeileis A (2006), Object-oriented Computation of Sandwich Estimators.
<em>Journal of Statistical Software</em>, <b>16</b>(9), 1&ndash;16.
URL <a href="https://doi.org/10.18637/jss.v016.i09">doi:10.18637/jss.v016.i09</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Finance)
f1 &lt;- Finance[1:300, "rm"] 
f2 &lt;- Finance[1:300, "hml"] 
f3 &lt;- Finance[1:300, "smb"] 
y &lt;- Finance[1:300,"WMK"]

## Silly example just to make it over-identified
###############################################
res &lt;- gmm(y ~ f1, ~ f1 + f2 + f3)
summary(res)


## Set the bandwidth using the second step estimate
################################################
bw &lt;- bwWilhelm(res)
res2 &lt;- update(res, bw=bw)
summary(res2)

## Set the bandwidth using the first-step estimate as for bwAndrews
###################################################################
res3 &lt;- gmm(y ~ f1, ~ f1 + f2 + f3, bw=bwWilhelm)
summary(res3)




</code></pre>

<hr>
<h2 id='charStable'>The characteristic function of a stable distribution</h2><span id='topic+charStable'></span>

<h3>Description</h3>

<p>It computes the theoretical characteristic function of a stable distribution for two different parametrizations. It is used in the vignette to illustrate the estimation of the parameters using GMM.</p>


<h3>Usage</h3>

<pre><code class='language-R'>charStable(theta, tau, pm = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="charStable_+3A_theta">theta</code></td>
<td>
<p>Vector of parameters of the stable distribution. See details.</p>
</td></tr>
<tr><td><code id="charStable_+3A_tau">tau</code></td>
<td>
<p>A vector of numbers at which the function is evaluated.</p>
</td></tr>
<tr><td><code id="charStable_+3A_pm">pm</code></td>
<td>
<p>The type of parametization. It takes the values 0 or 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the vector <code class="reqn">\Psi(\theta,\tau,pm)</code> defined as <code class="reqn">E(e^{ix\tau}</code>, where <code class="reqn">\tau</code> is a vector of real numbers, <code class="reqn">i</code> is the imaginary number, <code class="reqn">x</code> is a stable random variable with parameters <code class="reqn">\theta</code> = <code class="reqn">(\alpha,\beta,\gamma,\delta)</code> and <code>pm</code> is the type of parametrization. The vector of parameters are the characteristic exponent, the skewness, the scale and the location parameters, respectively. The restrictions on the parameters are: <code class="reqn">\alpha \in (0,2]</code>, <code class="reqn">\beta\in [-1,1]</code> and <code class="reqn">\gamma&gt;0</code>. For mode details see Nolan(2009).
</p>


<h3>Value</h3>

<p>It returns a vector of complex numbers with the dimension equals to <code>length(tau)</code>.
</p>


<h3>References</h3>

<p>Nolan J. P. (2020), Univariate Stable Distributions - Models for Heavy Tailed Data.
<em>Springer Series in Operations Research and Financial Engineering</em>.
URL <a href="https://edspace.american.edu/jpnolan/stable/">https://edspace.american.edu/jpnolan/stable/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMM is like GLS for linear models without endogeneity problems

pm &lt;- 0
theta &lt;- c(1.5,.5,1,0) 
tau &lt;- seq(-3, 3, length.out = 20)
char_fct &lt;- charStable(theta, tau, pm)

</code></pre>

<hr>
<h2 id='coef'>Coefficients of GEL or GMM</h2><span id='topic+coef.gel'></span><span id='topic+coef.gmm'></span>

<h3>Description</h3>

<p>It extracts the coefficients from <code>gel</code> or <code>gmm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmm'
coef(object, ...)
## S3 method for class 'gel'
coef(object, lambda = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>An object of class <code>gel</code> or <code>gmm</code> returned by the function <code><a href="#topic+gel">gel</a></code> or <code><a href="#topic+gmm">gmm</a></code></p>
</td></tr>
<tr><td><code id="coef_+3A_lambda">lambda</code></td>
<td>
<p>If set to TRUE, the lagrange multipliers are extracted instead of the vector of coefficients</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>coef</code> is applied to an other class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################
n = 500
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n=n,list(order=c(2,0,1),ar=phi,ma=thet,sd=sd)),ncol=1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]

H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H
t0 &lt;- c(0,.5,.5)

res &lt;- gel(g, x, t0)

coef(res)
coef(res, lambda = TRUE)
###################
res &lt;- gmm(g, x)
coef(res)

</code></pre>

<hr>
<h2 id='confint'>Confidence intervals for GMM or GEL</h2><span id='topic+confint.gel'></span><span id='topic+confint.ategel'></span><span id='topic+confint.gmm'></span><span id='topic+print.confint'></span>

<h3>Description</h3>

<p>It produces confidence intervals for the coefficients from <code>gel</code> or <code>gmm</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gel'
confint(object, parm, level = 0.95, lambda = FALSE,
                        type = c("Wald", "invLR", "invLM", "invJ"),
                        fact = 3, corr = NULL, ...)
## S3 method for class 'gmm'
confint(object, parm, level = 0.95, ...)
## S3 method for class 'ategel'
confint(object, parm, level = 0.95, lambda = FALSE,
                            type = c("Wald", "invLR", "invLM", "invJ"), fact = 3,
                            corr = NULL, robToMiss=TRUE, ...)
## S3 method for class 'confint'
print(x, digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint_+3A_object">object</code></td>
<td>
<p>An object of class <code>gel</code> or <code>gmm</code> returned by the function <code><a href="#topic+gel">gel</a></code> or <code><a href="#topic+gmm">gmm</a></code></p>
</td></tr>
<tr><td><code id="confint_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector
of names.  If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint_+3A_level">level</code></td>
<td>
<p>The confidence level</p>
</td></tr>
<tr><td><code id="confint_+3A_lambda">lambda</code></td>
<td>
<p>If set to TRUE, the confidence intervals for the Lagrange
multipliers are produced.</p>
</td></tr>
<tr><td><code id="confint_+3A_type">type</code></td>
<td>
<p>'Wald' is the usual symetric confidence interval. The thee
others are based on the inversion of the LR, LM, and J tests.</p>
</td></tr>
<tr><td><code id="confint_+3A_fact">fact</code></td>
<td>
<p>This parameter control the span of search for the inversion
of the test. By default we search within plus or minus 3 times the
standard error of the coefficient estimate.</p>
</td></tr>
<tr><td><code id="confint_+3A_corr">corr</code></td>
<td>
<p>This numeric scalar is meant to apply a correction to the
critical value, such as a Bartlett correction. This value depends on
the model (See Owen; 2001)</p>
</td></tr>
<tr><td><code id="confint_+3A_x">x</code></td>
<td>
<p>An object of class <code>confint</code> produced by <code>confint.gel</code> and <code>confint.gmm</code></p>
</td></tr>
<tr><td><code id="confint_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed</p>
</td></tr>
<tr><td><code id="confint_+3A_robtomiss">robToMiss</code></td>
<td>
<p>If <code>TRUE</code>, the confidence interval is based on the
standard errors that are robust to  misspecification</p>
</td></tr>
<tr><td><code id="confint_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>confint</code> is applied to another classe object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a matrix with the first column being the lower bound and the second the upper bound.</p>


<h3>References</h3>

<p>Hansen, L.P. (1982),
Large Sample Properties of Generalized Method of Moments Estimators.
<em>Econometrica</em>, <b>50</b>,
1029-1054,
Hansen, L.P. and Heaton, J. and Yaron, A.(1996),
Finit-Sample Properties of Some Alternative GMM Estimators.
<em>Journal of Business and Economic Statistics</em>, <b>14</b>
262-280.
Owen, A.B. (2001),
Empirical Likelihood.
<em>Monographs on Statistics and Applied Probability 92, Chapman and
Hall/CRC</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################
n = 500
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n, list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]

H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H
t0 &lt;- c(0,.5,.5)

resGel &lt;- gel(g, x, t0)

confint(resGel)
confint(resGel, level = 0.90)
confint(resGel, lambda = TRUE)

########################

resGmm &lt;- gmm(g, x)

confint(resGmm)
confint(resGmm, level = 0.90)

## Confidence interval with inversion of the LR, LM or J test.
##############################################################

set.seed(112233)
x &lt;- rt(40, 3)
y &lt;- x+rt(40,3)
# Simple interval on the mean
res &lt;- gel(x~1, ~1, method="Brent", lower=-4, upper=4)
confint(res, type = "invLR")
confint(res)
# Using a Bartlett correction
k &lt;- mean((x-mean(x))^4)/sd(x)^4
s &lt;- mean((x-mean(x))^3)/sd(x)^3
a &lt;- k/2-s^2/3
corr &lt;- 1+a/40
confint(res, type = "invLR", corr=corr)

# Interval on the slope
res &lt;- gel(y~x, ~x)
confint(res, "x", type="invLR")
confint(res, "x")
</code></pre>

<hr>
<h2 id='estfun'>Extracts the empirical moment function</h2><span id='topic+estfun.gmmFct'></span><span id='topic+estfun.gmm'></span><span id='topic+estfun.gel'></span><span id='topic+estfun.tsls'></span><span id='topic+model.matrix.tsls'></span>

<h3>Description</h3>

<p>It extracts the matrix of empirical moments so that it can be used by the <code>kernHAC</code> function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmmFct'
estfun(x, y = NULL, theta = NULL, ...)
## S3 method for class 'gmm'
estfun(x, ...)
## S3 method for class 'gel'
estfun(x, ...)
## S3 method for class 'tsls'
estfun(x, ...)
## S3 method for class 'tsls'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estfun_+3A_x">x</code></td>
<td>
<p>A function of the form <code class="reqn">g(\theta,y)</code> or a <code class="reqn">n \times q</code> matrix with typical element <code class="reqn">g_i(\theta,y_t)</code> for <code class="reqn">i=1,...q</code> and <code class="reqn">t=1,...,n</code> or an object of class <code>gmm</code>. See <code><a href="#topic+gmm">gmm</a></code> for more details. For <code><a href="#topic+tsls">tsls</a></code>, it is an object of class <code>tsls</code>.</p>
</td></tr>
<tr><td><code id="estfun_+3A_object">object</code></td>
<td>
<p>An object of class <code>tsls</code>.</p>
</td></tr>
<tr><td><code id="estfun_+3A_y">y</code></td>
<td>
<p>The matrix or vector of data from which the function <code class="reqn">g(\theta,y)</code> is computed if <code>g</code> is a function.</p>
</td></tr>
<tr><td><code id="estfun_+3A_theta">theta</code></td>
<td>
<p>Vector of parameters if <code>g</code> is a function.</p>
</td></tr>
<tr><td><code id="estfun_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>estfun</code> is applied to another class object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>estfun.gmmFct</code>, it returns a <code class="reqn">n \times q</code> matrix with typical element <code class="reqn">g_i(\theta,y_t)</code> for <code class="reqn">i=1,...q</code> and <code class="reqn">t=1,...,n</code>. It is only used by <code>gmm</code> to obtain the estimates.
</p>
<p>For <code>estfun.gmm</code>, it returns the matrix of first order conditions of <code class="reqn">\min_\theta \bar{g}'W\bar{g}/2</code>, which is a <code class="reqn">n \times k</code> matrix with the <code class="reqn">t^{th}</code> row being <code class="reqn">g(\theta, y_t)W G</code>, where <code class="reqn">G</code> is <code class="reqn">d\bar{g}/d\theta</code>. It allows to compute the sandwich covariance matrix using <code>kernHAC</code> or <code>vcovHAC</code> when <code class="reqn">W</code> is not the optimal matrix.
</p>
<p>The method if not yet available for <code>gel</code> objects.
</p>
<p>For tsls, model.matrix and estfun are used by <code>vcov()</code> to compute different covariance matrices using the <code>sandwich</code> package. See <code><a href="#topic+vcov.tsls">vcov.tsls</a></code>. <code>model.matrix</code> returns the fitted values frin the first stage regression and <code>esfun</code> the residuals.
</p>


<h3>Value</h3>

<p>A <code class="reqn">n \times q</code> matrix (see details). 
</p>


<h3>References</h3>

<p>Zeileis A (2006), Object-oriented Computation of Sandwich Estimators.
<em>Journal of Statistical Software</em>, <b>16</b>(9), 1&ndash;16.
URL <a href="https://doi.org/10.18637/jss.v016.i09">doi:10.18637/jss.v016.i09</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n = 500
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n=n,list(order=c(2,0,1),ar=phi,ma=thet,sd=sd)),ncol=1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]
H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H
res &lt;- gmm(g, x,weightsMatrix = diag(5))

gt &lt;- res$gt
G &lt;- res$G

foc &lt;- gt
foc2 &lt;- estfun(res)

foc[1:5,]
foc2[1:5,]

</code></pre>

<hr>
<h2 id='Finance'>Returns on selected stocks</h2><span id='topic+Finance'></span>

<h3>Description</h3>

<p>Daily returns on selected stocks, the Market portfolio and factors of Fama and French from 1993-01-05 to 2009-01-30 for CAPM and APT analysis 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Finance)</code></pre>


<h3>Format</h3>

<p>A data frame containing 24 time series. Dates are reported as rownames(). In the following description, company symboles are used.
</p>

<dl>
<dt>WMK</dt><dd><p>Returns of WEIS MARKETS INC</p>
</dd> 
<dt>UIS</dt><dd><p>Returns of UNISYS CP NEW</p>
</dd> 
<dt>ORB</dt><dd><p>Returns of ORBITAL SCIENCES CP</p>
</dd> 
<dt>MAT</dt><dd><p>Returns of Mattel, Inc.</p>
</dd> 
<dt>ABAX</dt><dd><p>Returns of ABAXIS, Inc.</p>
</dd> 
<dt>T</dt><dd><p>Returns of AT&amp;T INC.</p>
</dd> 
<dt>EMR</dt><dd><p>Returns of EMERSON ELEC CO</p>
</dd> 
<dt>JCS</dt><dd><p>Returns of Communications Systems Inc.</p>
</dd> 
<dt>VOXX</dt><dd><p>Returns of Audiovox Corp.</p>
</dd>
<dt>ZOOM</dt><dd><p>Returns of ZOOM Technologies Inc.</p>
</dd> 
<dt>TDW</dt><dd><p>Returns of TIDEWATER INC</p>
</dd> 
<dt>ROG</dt><dd><p>Returns of Rogers Corporation</p>
</dd> 
<dt>GGG</dt><dd><p>Returns of Graco Inc.</p>
</dd> 
<dt>PC</dt><dd><p>Returns of Panasonic Corporation</p>
</dd> 
<dt>GCO</dt><dd><p>Returns of Genesco Inc.</p>
</dd> 
<dt>EBF</dt><dd><p>Returns of ENNIS, INC</p>
</dd> 
<dt>F</dt><dd><p>Returns of FORD MOTOR CO</p>
</dd> 
<dt>FNM</dt><dd><p>Returns of FANNIE MAE</p>
</dd> 
<dt>NHP</dt><dd><p>Returns of NATIONWIDE HLTH PROP</p>
</dd> 
<dt>AA</dt><dd><p>Returns of ALCOA INC</p>
</dd> 
<dt>rf</dt><dd><p>Risk-free rate of Fama-French</p>
</dd>
<dt>rm</dt><dd><p>Return of the market portfolio of Fama-French</p>
</dd>
<dt>hml</dt><dd><p>Factor High-Minus-Low of Fama-French</p>
</dd>
<dt>smb</dt><dd><p>Factor Small-Minus-Big of Fama-French</p>
</dd>
</dl>



<h3>Source</h3>

<p>Yahoo Finance and <a href="https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/">https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/</a></p>

<hr>
<h2 id='FinRes'>Method to finalize the result of the momentEstim method</h2><span id='topic+FinRes.baseGmm.res'></span>

<h3>Description</h3>

<p>It computes the final results that will be needed to create the object of class <code>gmm</code>.). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baseGmm.res'
FinRes(z, object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FinRes_+3A_z">z</code></td>
<td>
<p>An object of class determined by the method <code>momentEstim</code>.</p>
</td></tr>
<tr><td><code id="FinRes_+3A_object">object</code></td>
<td>
<p>An object produced my <code>getModel</code></p>
</td></tr>
<tr><td><code id="FinRes_+3A_...">...</code></td>
<td>
<p>Other argument to be passed to other <code>FinRes</code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class <code>gmm</code>. See <code><a href="#topic+gmm">gmm</a></code> for more details. 
</p>


<h3>References</h3>

<p>Hansen, L.P. (1982),
Large Sample Properties of Generalized Method of Moments Estimators.
<em>Econometrica</em>, <b>50</b>,
1029-1054,
</p>
<p>Hansen, L.P. and Heaton, J. and Yaron, A.(1996),
Finit-Sample Properties of Some Alternative GMM Estimators.
<em>Journal of Business and Economic Statistics</em>, <b>14</b>
262-280.
</p>

<hr>
<h2 id='fitted'>Fitted values of GEL and GMM</h2><span id='topic+fitted.gel'></span><span id='topic+fitted.gmm'></span>

<h3>Description</h3>

<p>Method to extract the fitted values of the model estimated by <code><a href="#topic+gel">gel</a></code> or <code><a href="#topic+gmm">gmm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gel'
fitted(object, ...)
## S3 method for class 'gmm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted_+3A_object">object</code></td>
<td>
<p>An object of class <code>gel</code> or <code>gel</code> returned by the function <code><a href="#topic+gel">gel</a></code> or  <code><a href="#topic+gmm">gmm</a></code></p>
</td></tr>
<tr><td><code id="fitted_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>fitted</code> is applied to an other class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a matrix of the estimated mean <code class="reqn">\hat{y}</code> in <code>g=y~x</code> as it is done by <code>fitted.lm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GEL can deal with endogeneity problems

n = 200
phi&lt;-c(.2,.7)
thet &lt;- 0.2
sd &lt;- .2
set.seed(123)
x &lt;- matrix(arima.sim(n = n, list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)

y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]
H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H

res &lt;- gel(g, x, c(0,.3,.6))
plot(y, main = "Fitted ARMA with GEL")
lines(fitted(res), col = 2)

# GMM is like GLS for linear models without endogeneity problems

set.seed(345)
n = 200
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n, list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)
y &lt;- 10 + 5*rnorm(n) + x

res &lt;- gmm(y ~ x, x)
plot(x, y, main = "Fitted model with GMM")
lines(x, fitted(res), col = 2)
legend("topright", c("Y","Yhat"), col = 1:2, lty = c(1,1))
</code></pre>

<hr>
<h2 id='formula'>Formula method for gel and gmm objects</h2><span id='topic+formula.gel'></span><span id='topic+formula.gmm'></span>

<h3>Description</h3>

<p>Method to extract the formula from <code>gel</code> or <code>gmm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gel'
formula(x, ...)
## S3 method for class 'gmm'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula_+3A_x">x</code></td>
<td>
<p>An object of class <code>gel</code> or <code>gmm</code> returned by the function <code><a href="#topic+gel">gel</a></code> or <code><a href="#topic+gmm">gmm</a></code></p>
</td></tr>
<tr><td><code id="formula_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## GEL ##
n = 200
phi&lt;-c(.2,.7)
thet &lt;- 0.2
sd &lt;- .2
set.seed(123)
x &lt;- matrix(arima.sim(n = n, list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)

y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]
H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H

res &lt;- gel(g, x, c(0,.3,.6))
formula(res)

# GMM is like GLS for linear models without endogeneity problems

set.seed(345)
n = 200
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n, list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)
y &lt;- 10 + 5*rnorm(n) + x

res &lt;- gmm(y ~ x, x)
formula(res)


</code></pre>

<hr>
<h2 id='gel'>Generalized Empirical Likelihood estimation</h2><span id='topic+gel'></span><span id='topic+evalGel'></span>

<h3>Description</h3>

<p>Function to estimate a vector of parameters based on moment conditions using the GEL method as presented by Newey-Smith(2004) and Anatolyev(2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gel(g, x, tet0 = NULL, gradv = NULL, smooth = FALSE,
    type = c("EL","ET","CUE","ETEL","HD","ETHD","RCUE"), 
    kernel = c("Truncated", "Bartlett"), bw = bwAndrews, 
    approx = c("AR(1)", "ARMA(1,1)"), prewhite = 1, ar.method = "ols", 
    tol_weights = 1e-7, tol_lam = 1e-9, tol_obj = 1e-9, tol_mom = 1e-9, 
    maxiterlam = 100, constraint = FALSE, optfct = c("optim", "optimize", 
    "nlminb"), optlam = c("nlminb", "optim", "iter", "Wu"), data,
    Lambdacontrol = list(), model = TRUE, X = FALSE, Y = FALSE,
    TypeGel = "baseGel", alpha = NULL, eqConst = NULL,
    eqConstFullVcov = FALSE, onlyCoefficients=FALSE, ...)
evalGel(g, x, tet0, gradv = NULL, smooth = FALSE,
        type = c("EL", "ET", "CUE", "ETEL", "HD", "ETHD","RCUE"),
        kernel = c("Truncated", "Bartlett"), bw = bwAndrews,
        approx = c("AR(1)", "ARMA(1,1)"), prewhite = 1,
        ar.method = "ols", tol_weights = 1e-7, tol_lam = 1e-9, tol_obj = 1e-9, 
        tol_mom = 1e-9, maxiterlam = 100, optlam = c("nlminb", "optim",
        "iter", "Wu"), data, Lambdacontrol = list(),
        model = TRUE, X = FALSE, Y = FALSE, alpha = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gel_+3A_g">g</code></td>
<td>
<p>A function of the form <code class="reqn">g(\theta,x)</code> and which returns a <code class="reqn">n \times q</code> matrix with typical element <code class="reqn">g_i(\theta,x_t)</code> for <code class="reqn">i=1,...q</code> and <code class="reqn">t=1,...,n</code>. This matrix is then used to build the q sample moment conditions. It can also be a formula if the model is linear (see details below).  </p>
</td></tr>
<tr><td><code id="gel_+3A_tet0">tet0</code></td>
<td>
<p>A <code class="reqn">k \times 1</code> vector of starting values. If the
dimension of <code class="reqn">\theta</code> is one, see the argument &quot;optfct&quot;. In the
linear case, if tet0=NULL, the 2-step gmm estimator is used as starting
value. However, it has to be provided when eqConst is not NULL</p>
</td></tr>
<tr><td><code id="gel_+3A_x">x</code></td>
<td>
<p>The matrix or vector of data from which the function <code class="reqn">g(\theta,x)</code> is computed. If &quot;g&quot; is a formula, it is an <code class="reqn">n \times Nh</code> matrix of instruments (see details below).</p>
</td></tr>
<tr><td><code id="gel_+3A_gradv">gradv</code></td>
<td>
<p>A function of the form <code class="reqn">G(\theta,x)</code> which returns a <code class="reqn">q\times k</code> matrix of derivatives of <code class="reqn">\bar{g}(\theta)</code> with respect to <code class="reqn">\theta</code>. By default, the numerical algorithm <code>numericDeriv</code> is used. It is of course strongly suggested to provide this function when it is possible. This gradiant is used compute the asymptotic covariance matrix of <code class="reqn">\hat{\theta}</code>. If &quot;g&quot; is a formula, the gradiant is not required (see the details below).</p>
</td></tr>
<tr><td><code id="gel_+3A_smooth">smooth</code></td>
<td>
<p>If set to TRUE, the moment function is smoothed as proposed by Kitamura(1997)</p>
</td></tr>
<tr><td><code id="gel_+3A_type">type</code></td>
<td>
<p>&quot;EL&quot; for empirical likelihood, &quot;ET&quot; for exponential tilting,
&quot;CUE&quot; for continuous updated estimator, &quot;ETEL&quot; for exponentially
tilted empirical likelihood of Schennach(2007), &quot;HD&quot; for Hellinger
Distance of Kitamura-Otsu-Evdokimov (2013), and &quot;ETHD&quot; for the
exponentially tilted Hellinger distance of Antoine-Dovonon
(2015). &quot;RCUE&quot; is a restricted version of &quot;CUE&quot; in which the
probabilities are bounded below by zero. In that case, an analytical
Kuhn-Tucker method is used to find the solution.</p>
</td></tr>
<tr><td><code id="gel_+3A_kernel">kernel</code></td>
<td>
<p>type of kernel used to compute the covariance matrix of the vector of sample moment conditions (see <code>kernHAC</code> for more details) and to smooth the moment conditions if &quot;smooth&quot; is set to TRUE. Only two types of kernel are available. The truncated implies a Bartlett kernel for the HAC matrix and the Bartlett implies a Parzen kernel (see Smith 2004).</p>
</td></tr>
<tr><td><code id="gel_+3A_bw">bw</code></td>
<td>
<p>The method to compute the bandwidth parameter. By default it is <code>bwAndrews</code> which is proposed by Andrews (1991). The alternative is <code>bwNeweyWest</code> of Newey-West(1994).</p>
</td></tr>
<tr><td><code id="gel_+3A_prewhite">prewhite</code></td>
<td>
<p>logical or integer. Should the estimating functions be prewhitened? If <code>TRUE</code> or greater than 0 a VAR model of order <code>as.integer(prewhite)</code> is fitted via <code>ar</code> with method <code>"ols"</code> and <code>demean = FALSE</code>.</p>
</td></tr>
<tr><td><code id="gel_+3A_ar.method">ar.method</code></td>
<td>
<p>character. The <code>method</code> argument passed to <code><a href="stats.html#topic+ar">ar</a></code> for prewhitening.</p>
</td></tr>
<tr><td><code id="gel_+3A_approx">approx</code></td>
<td>
<p>a character specifying the approximation method if the bandwidth has to be chosen by <code>bwAndrews</code>.</p>
</td></tr>
<tr><td><code id="gel_+3A_tol_weights">tol_weights</code></td>
<td>
<p>numeric. Weights that exceed <code>tol</code> are used for computing the covariance matrix, all other weights are treated as 0.</p>
</td></tr>
<tr><td><code id="gel_+3A_tol_lam">tol_lam</code></td>
<td>
<p>Tolerance for <code class="reqn">\lambda</code> between two iterations. The algorithm stops when <code class="reqn">\|\lambda_i -\lambda_{i-1}\|</code> reaches <code>tol_lamb</code> (see <code><a href="#topic+getLamb">getLamb</a></code>) </p>
</td></tr>
<tr><td><code id="gel_+3A_maxiterlam">maxiterlam</code></td>
<td>
<p>The algorithm to compute <code class="reqn">\lambda</code> stops if there is no convergence after &quot;maxiterlam&quot; iterations (see <code><a href="#topic+getLamb">getLamb</a></code>).</p>
</td></tr>
<tr><td><code id="gel_+3A_tol_obj">tol_obj</code></td>
<td>
<p>Tolerance for the gradiant of the objective function to compute <code class="reqn">\lambda</code> (see <code><a href="#topic+getLamb">getLamb</a></code>).</p>
</td></tr>
<tr><td><code id="gel_+3A_optfct">optfct</code></td>
<td>
<p>Only when the dimension of <code class="reqn">\theta</code> is 1, you can choose between the algorithm <code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+optimize">optimize</a></code>. In that case, the former is unreliable. If <code><a href="stats.html#topic+optimize">optimize</a></code> is chosen, &quot;t0&quot; must be <code class="reqn">1\times 2</code> which represents the interval in which the algorithm seeks the solution.It is also possible to choose the <code><a href="stats.html#topic+nlminb">nlminb</a></code> algorithm. In that case, borns for the coefficients can be set by the options <code>upper=</code> and <code>lower=</code>.</p>
</td></tr>
<tr><td><code id="gel_+3A_constraint">constraint</code></td>
<td>
<p>If set to TRUE, the constraint optimization algorithm is used. See <code><a href="stats.html#topic+constrOptim">constrOptim</a></code> to learn how it works. In particular, if you choose to use it, you need to provide &quot;ui&quot; and &quot;ci&quot; in order to impose the constraint <code class="reqn">ui \theta - ci \geq 0</code>.</p>
</td></tr>
<tr><td><code id="gel_+3A_tol_mom">tol_mom</code></td>
<td>
<p>It is the tolerance for the moment condition <code class="reqn">\sum_{t=1}^n p_t g(\theta(x_t)=0</code>, where <code class="reqn">p_t=\frac{1}{n}D\rho(&lt;g_t,\lambda&gt;)</code> is the implied probability. It adds a penalty if the solution diverges from its goal.</p>
</td></tr>
<tr><td><code id="gel_+3A_optlam">optlam</code></td>
<td>
<p>Algorithm used to solve for the lagrange multiplier in
<code><a href="#topic+getLamb">getLamb</a></code>. The algorithm Wu is only for
<code>type="EL"</code>. The value of <code>optlam</code> is ignored for &quot;CUE&quot;
because in that case, the analytical solution exists.</p>
</td></tr>
<tr><td><code id="gel_+3A_data">data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optional). </p>
</td></tr>
<tr><td><code id="gel_+3A_lambdacontrol">Lambdacontrol</code></td>
<td>
<p>Controls for the optimization of the vector of Lagrange multipliers used by either <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+constrOptim">constrOptim</a></code></p>
</td></tr>
<tr><td><code id="gel_+3A_model">model</code>, <code id="gel_+3A_x">X</code>, <code id="gel_+3A_y">Y</code></td>
<td>
<p>logicals.  If <code>TRUE</code> the corresponding components of the fit (the model frame, the model matrix, the response) are returned if g is a formula.</p>
</td></tr>
<tr><td><code id="gel_+3A_typegel">TypeGel</code></td>
<td>
<p>The name of the class object created by the method <code>getModel</code>. It allows developers to extand the package and create other GEL methods.</p>
</td></tr>
<tr><td><code id="gel_+3A_alpha">alpha</code></td>
<td>
<p>Regularization coefficient for discrete CGEL estimation (experimental). By setting alpha to any value, the model is estimated by CGEL of type specified    by the option <code>type</code>. See Chausse (2011)</p>
</td></tr>
<tr><td><code id="gel_+3A_eqconst">eqConst</code></td>
<td>
<p>Either a named vector (if &quot;g&quot; is a function), a simple vector for the nonlinear case indicating which of the <code class="reqn">\theta_0</code> is restricted, or a qx2 vector defining equality constraints of the form <code class="reqn">\theta_i=c_i</code>. See <code><a href="#topic+gmm">gmm</a></code> for an example.</p>
</td></tr>
<tr><td><code id="gel_+3A_eqconstfullvcov">eqConstFullVcov</code></td>
<td>
<p>If FALSE, the constrained coefficients are assumed to be fixed and only the covariance of the unconstrained coefficients is computed. If TRUE, the covariance matrix of the full set of coefficients is computed.</p>
</td></tr>
<tr><td><code id="gel_+3A_onlycoefficients">onlyCoefficients</code></td>
<td>
<p>If <code>TRUE</code>, only the vector of coefficients
and Lagrange multipliers are returned</p>
</td></tr>
<tr><td><code id="gel_+3A_...">...</code></td>
<td>
<p>More options to give to <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+optimize">optimize</a></code> or <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If we want to estimate a model like <code class="reqn">Y_t = \theta_1 + X_{2t}\theta_2 + ... + X_{k}\theta_k + \epsilon_t</code> using the moment conditions <code class="reqn">Cov(\epsilon_tH_t)=0</code>, where <code class="reqn">H_t</code> is a vector of <code class="reqn">Nh</code> instruments, than we can define &quot;g&quot; like we do for <code><a href="stats.html#topic+lm">lm</a></code>. We would have <code>g = y~x2+x3+...+xk</code> and the argument &quot;x&quot; above would become the matrix H of instruments. As for <code><a href="stats.html#topic+lm">lm</a></code>, <code class="reqn">Y_t</code> can be a <code class="reqn">Ny \times 1</code> vector which would imply that <code class="reqn">k=Nh \times Ny</code>. The intercept is included by default so you do not have to add a column of ones to the matrix <code class="reqn">H</code>. You do not need to provide the gradiant in that case since in that case it is embedded in <code><a href="#topic+gel">gel</a></code>. The intercept can be removed by adding -1 to the formula. In that case, the column of ones need to be added manually to H.
</p>
<p>If &quot;smooth&quot; is set to TRUE, the sample moment conditions <code class="reqn">\sum_{t=1}^n g(\theta,x_t)</code> is replaced by:
<code class="reqn">\sum_{t=1}^n g^k(\theta,x_t)</code>,
where
<code class="reqn">g^k(\theta,x_t)=\sum_{i=-r}^r k(i) g(\theta,x_{t+i})</code>,
where <code class="reqn">r</code> is a truncated parameter that depends on the bandwidth and <code class="reqn">k(i)</code> are normalized weights so that they sum to 1.
</p>
<p>The method solves 
<code class="reqn">\hat{\theta} = \arg\min \left[\arg\max_\lambda \frac{1}{n}\sum_{t=1}^n \rho(&lt;g(\theta,x_t),\lambda&gt;) - \rho(0) \right]</code>
</p>
<p><code><a href="#topic+evalGel">evalGel</a></code> generates the object of class &quot;gel&quot; for a fixed vector of
parameters. There is no estimation for <code class="reqn">\theta</code>, but the optimal
vector of Lagrange multipliers <code class="reqn">\lambda</code> is computed. The objective
function is then the profiled likelihood for a given <code class="reqn">\theta</code>. It
can be used to construct a confidence interval by inverting  the
likelihood ratio test. 
</p>


<h3>Value</h3>

<p>'gel' returns an object of 'class' '&quot;gel&quot;' 
</p>
<p>The functions 'summary' is used to obtain and print a summary of the results. 
</p>
<p>The object of class &quot;gel&quot; is a list containing at least the following:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p><code class="reqn">k\times 1</code> vector of parameters</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values if &quot;g&quot; is a formula.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values if &quot;g&quot; is a formula.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p><code class="reqn">q \times 1</code> vector of Lagrange multipliers.</p>
</td></tr>
<tr><td><code>vcov_par</code></td>
<td>
<p>the covariance matrix of &quot;coefficients&quot;</p>
</td></tr>
<tr><td><code>vcov_lambda</code></td>
<td>
<p>the covariance matrix of &quot;lambda&quot;</p>
</td></tr>
<tr><td><code>pt</code></td>
<td>
<p>The implied probabilities</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>the value of the objective function</p>
</td></tr>
<tr><td><code>conv_lambda</code></td>
<td>
<p>Convergence code for &quot;lambda&quot; (see <code><a href="#topic+getLamb">getLamb</a></code>)</p>
</td></tr>
<tr><td><code>conv_mes</code></td>
<td>
<p>Convergence message for &quot;lambda&quot; (see <code><a href="#topic+getLamb">getLamb</a></code>)</p>
</td></tr>
<tr><td><code>conv_par</code></td>
<td>
<p>Convergence code for &quot;coefficients&quot; (see <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+optimize">optimize</a></code> or <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>)</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used when g is a formula.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response used (if &quot;g&quot; is a formula).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used if &quot;g&quot; is a formula or the data if &quot;g&quot; is a function.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame used if &quot;g&quot; is a formula.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Anatolyev, S. (2005), GMM, GEL, Serial Correlation, and Asymptotic Bias. <em>Econometrica</em>, <b>73</b>, 983-1002.
</p>
<p>Andrews DWK (1991), Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>, 817&ndash;858.
</p>
<p>Kitamura, Yuichi (1997), Empirical Likelihood Methods With Weakly Dependent Processes.
<em>The Annals of Statistics</em>, <b>25</b>, 2084-2102.
</p>
<p>Kitamura, Y. and Otsu, T. and Evdokimov, K. (2013), Robustness,
Infinitesimal Neighborhoods and Moment Restrictions.
<em>Econometrica</em>, <b>81</b>, 1185-1201.
</p>
<p>Newey, W.K. and Smith, R.J. (2004), Higher Order Properties of GMM and 
Generalized Empirical Likelihood Estimators. <em>Econometrica</em>, <b>72</b>, 219-255.
</p>
<p>Smith, R.J. (2004), GEL Criteria for Moment Condition Models. <em>Working paper, CEMMAP</em>.
</p>
<p>Newey WK &amp; West KD (1987), A Simple, Positive Semi-Definite,
Heteroskedasticity and Autocorrelation Consistent Covariance
Matrix. <em>Econometrica</em>, <b>55</b>, 703&ndash;708.
</p>
<p>Newey WK &amp; West KD (1994), Automatic Lag Selection in Covariance
Matrix Estimation. <em>Review of Economic Studies</em>, <b>61</b>, 631-653.
</p>
<p>Schennach, Susanne, M. (2007), Point Estimation with Exponentially Tilted Empirical Likelihood.
<em>Econometrica</em>, <b>35</b>, 634-672.
</p>
<p>Wu, C. (2005), Algorithms and R codes for the pseudo empirical
likelihood method in survey sampling.
<em>Survey Methodology</em>, <b>31</b>(2), page 239.
</p>
<p>Zeileis A (2006), Object-oriented Computation of Sandwich Estimators.
<em>Journal of Statistical Software</em>, <b>16</b>(9), 1&ndash;16.
URL <a href="https://doi.org/10.18637/jss.v016.i09">doi:10.18637/jss.v016.i09</a>.
</p>
<p>Chausse (2010), Computing Generalized Method of Moments and Generalized Empirical Likelihood with R.
<em>Journal of Statistical Software</em>, <b>34</b>(11), 1&ndash;35.
URL <a href="https://doi.org/10.18637/jss.v034.i11">doi:10.18637/jss.v034.i11</a>.
</p>
<p>Chausse (2011), Generalized Empirical likelihood for a continumm of moment conditions.
<em>Working Paper</em>, 
<em>Department of Economics</em>,
<em>University of Waterloo</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First, an exemple with the fonction g()

g &lt;- function(tet, x)
	{
	n &lt;- nrow(x)
	u &lt;- (x[7:n] - tet[1] - tet[2]*x[6:(n-1)] - tet[3]*x[5:(n-2)])
	f &lt;- cbind(u, u*x[4:(n-3)], u*x[3:(n-4)], u*x[2:(n-5)], u*x[1:(n-6)])
	return(f)
	}

Dg &lt;- function(tet,x)
	{
	n &lt;- nrow(x)
	xx &lt;- cbind(rep(1, (n-6)), x[6:(n-1)], x[5:(n-2)])
        H  &lt;- cbind(rep(1, (n-6)), x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
	f &lt;- -crossprod(H, xx)/(n-6)
	return(f)
	}
n = 200
phi&lt;-c(.2, .7)
thet &lt;- 0.2
sd &lt;- .2
set.seed(123)
x &lt;- matrix(arima.sim(n = n, list(order = c(2, 0, 1), ar = phi, ma = thet, sd = sd)), ncol = 1)

res &lt;- gel(g, x, c(0, .3, .6), grad = Dg)
summary(res)

# The same model but with g as a formula....  much simpler in that case

y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]

H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H

res &lt;- gel(g, x, c(0, .3, .6))
summary(res)

# Using evalGel to create the object without estimation

res &lt;- evalGel(g, x, res$coefficients)

</code></pre>

<hr>
<h2 id='getDat'>Extracting data from a formula</h2><span id='topic+getDat'></span>

<h3>Description</h3>

<p>It extract the data from a formula y~z with instrument h and put everything in a matrix. It helps redefine the function <code class="reqn">g(\theta,x)</code> that is required by <code><a href="#topic+gmm">gmm</a></code> and <code><a href="#topic+gel">gel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDat(formula, h, data, error=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDat_+3A_formula">formula</code></td>
<td>
<p>A formula that defines the linear model to be estimated (see details).</p>
</td></tr>
<tr><td><code id="getDat_+3A_h">h</code></td>
<td>
<p>A <code class="reqn">n\times nh</code> matrix of intruments(see details).</p>
</td></tr>
<tr><td><code id="getDat_+3A_data">data</code></td>
<td>
<p>A data.frame or a matrix with colnames (Optionnal).</p>
</td></tr>
<tr><td><code id="getDat_+3A_error">error</code></td>
<td>
<p>If FALSE, the data is generated without giving any error message</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model to be estimated is based on the moment conditions
<code class="reqn">&lt;h,(y-z\theta)&gt;=0</code>. It adds a column of ones to z and h by
default. They are removed if -1 is added to the formula.
The error argument has been added for <code><a href="#topic+sysGmm">sysGmm</a></code> with common
coefficients because the check is only valid for
equation by equation identification. 
</p>


<h3>Value</h3>

<p>x: A <code class="reqn">n \times l</code> matrix, where <code class="reqn">l = ncol(y)+ncol(z)+ncol(h)+2</code> if &quot;intercept&quot; is TRUE and <code class="reqn">ncol(y)+ncol(z)+xcol(h)</code> if &quot;intercept&quot; is FALSE. 
</p>
<p>nh: dimension of h
</p>
<p>k: dimension of z
</p>
<p>ny: dimension of y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 500
phi&lt;-c(.2, .7)
thet &lt;- 0.2
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n, list(order = c(2, 0, 1), ar = phi, ma = thet, sd = sd)), ncol = 1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]
H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])

x &lt;- getDat(y ~ ym1 + ym2, H)

</code></pre>

<hr>
<h2 id='getImpProb'>Implied Probabilities</h2><span id='topic+getImpProb'></span><span id='topic+getImpProb.gel'></span>

<h3>Description</h3>

<p> It computes the implied
probabilities from objects of class <code>gel</code> with additional options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'gel'
getImpProb(object, posProb=TRUE, normalize=TRUE,
                         checkConv=FALSE,...)
</code></pre>


<h3>Arguments</h3>

 <table role = "presentation">
<tr><td><code id="getImpProb_+3A_object">object</code></td>
<td>
<p>Object of class
<code>gel</code>.</p>
</td></tr>  <tr><td><code id="getImpProb_+3A_posprob">posProb</code></td>
<td>
<p>Should the implied probabilities be
transformed into positive probabilities?</p>
</td></tr>  <tr><td><code id="getImpProb_+3A_normalize">normalize</code></td>
<td>
<p>Should we
normalize the probabilities so that they sum to one?</p>
</td></tr>
<tr><td><code id="getImpProb_+3A_checkconv">checkConv</code></td>
<td>
<p>Should we add the attribute convergence to check the
sum of the probabilities and the weighted sum of the moment conditions?</p>
</td></tr>
<tr><td><code id="getImpProb_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector af implied probabilities.
</p>


<h3>References</h3>

<p>Newey, W.K. and Smith, R.J. (2004), Higher Order Properties of GMM and
Generalized Empirical Likelihood Estimators. <em>Econometrica</em>,
<b>72</b>, 219-255. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################
n = 500
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n=n,list(order=c(2,0,1),ar=phi,ma=thet,sd=sd)),ncol=1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]

H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H
t0 &lt;- c(0,.5,.5)

res &lt;- gel(g, x, t0)
pt &lt;- getImpProb(res)
</code></pre>

<hr>
<h2 id='getLamb'>Solving for the Lagrange multipliers of Generalized Empirical Likelihood (GEL) </h2><span id='topic+getLamb'></span>

<h3>Description</h3>

<p>It computes the vector of Lagrange multipliers, which maximizes the GEL objective function, using an iterative Newton method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLamb(gt, l0, type = c("EL","ET","CUE", "ETEL", "HD","ETHD","RCUE"),
        tol_lam = 1e-7, maxiterlam = 100, 
	tol_obj = 1e-7, k = 1, method = c("nlminb", "optim", "iter", "Wu"),
        control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLamb_+3A_gt">gt</code></td>
<td>
<p>A <code class="reqn">n \times q</code> matrix with typical element <code class="reqn">g_i(\theta,x_t)</code></p>
</td></tr>
<tr><td><code id="getLamb_+3A_l0">l0</code></td>
<td>
<p>Vector of starting values for lambda</p>
</td></tr>
<tr><td><code id="getLamb_+3A_type">type</code></td>
<td>
<p>&quot;EL&quot; for empirical likelihood, &quot;ET&quot; for exponential tilting,
&quot;CUE&quot; for continuous updated estimator, and &quot;HD&quot; for Hellinger
Distance. See details for &quot;ETEL&quot; and &quot;ETHD&quot;. &quot;RCUE&quot; is a restricted
version of &quot;CUE&quot; in which the probabilities are bounded below by
zero. In that case, an analytical Kuhn-Tucker method is used to find
the solution.</p>
</td></tr>
<tr><td><code id="getLamb_+3A_tol_lam">tol_lam</code></td>
<td>
<p>Tolerance for <code class="reqn">\lambda</code> between two iterations. The
algorithm stops when <code class="reqn">\|\lambda_i -\lambda_{i-1}\|</code> reaches
<code>tol_lam</code> </p>
</td></tr>
<tr><td><code id="getLamb_+3A_maxiterlam">maxiterlam</code></td>
<td>
<p>The algorithm stops if there is no convergence after
&quot;maxiterlam&quot; iterations.</p>
</td></tr>
<tr><td><code id="getLamb_+3A_tol_obj">tol_obj</code></td>
<td>
<p>Tolerance for the gradiant of the objective function. The
algorithm returns a non-convergence message if <code class="reqn">\max(|gradiant|)</code>
does not reach <code>tol_obj</code>. It helps the <code>gel</code> algorithm to
select the right space to look for <code class="reqn">\theta</code></p>
</td></tr>
<tr><td><code id="getLamb_+3A_k">k</code></td>
<td>
<p>It represents the ratio k1/k2, where
<code class="reqn">k1=\int_{-\infty}^{\infty} k(s)ds</code> and
<code class="reqn">k2=\int_{-\infty}^{\infty} k(s)^2 ds</code>. See Smith(2004).</p>
</td></tr>
<tr><td><code id="getLamb_+3A_method">method</code></td>
<td>
<p>The iterative procedure uses a Newton method for solving
the FOC. It i however recommended to use <code>optim</code> or
<code>nlminb</code>. If type is set to &quot;EL&quot; and method to &quot;optim&quot;,
<code><a href="stats.html#topic+constrOptim">constrOptim</a></code> is called to prevent <code class="reqn">log(1-gt'\lambda)</code>
from producing NA. The gradient and hessian is provided to
<code>nlminb</code> which speed up the convergence. The latter is therefore
the default value. &quot;Wu&quot; is for &quot;EL&quot; only. It uses the algorithm of Wu
(2005). The value of <code>method</code> is ignored for &quot;CUE&quot; because in
that case, the analytical solution exists.</p>
</td></tr>
<tr><td><code id="getLamb_+3A_control">control</code></td>
<td>
<p>Controls to send to <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+constrOptim">constrOptim</a></code></p>
</td></tr> </table>


<h3>Details</h3>

<p> It solves
the problem <code class="reqn">\max_{\lambda} \frac{1}{n}\sum_{t=1}^n
\rho(gt'\lambda)</code>. For the type &quot;ETEL&quot;, it is only used by
<code><a href="#topic+gel">gel</a></code>. In that case <code class="reqn">\lambda</code> is obtained by maximizing
<code class="reqn">\frac{1}{n}\sum_{t=1}^n \rho(gt'\lambda)</code>, using
<code class="reqn">\rho(v)=-\exp{v}</code> (so ET) and <code class="reqn">\theta</code> by minimizing the same
equation but with <code class="reqn">\rho(v)-\log{(1-v)}</code>. To avoid NA's,
<code><a href="stats.html#topic+constrOptim">constrOptim</a></code> is used with the restriction <code class="reqn">\lambda'g_t
&lt; 1</code>. The type &quot;ETHD&quot; is experimental and proposed by Antoine-Dovonon
(2015). The paper is not yet available.  </p>


<h3>Value</h3>

<p>lambda: A <code class="reqn">q\times 1</code> vector of Lagrange multipliers which solve the system of equations given above.
<code>conv</code>: Details on the type of convergence.
</p>


<h3>References</h3>

<p>Newey, W.K. and Smith, R.J. (2004), Higher Order Properties of GMM and 
Generalized Empirical Likelihood Estimators. <em>Econometrica</em>, <b>72</b>, 219-255.
</p>
<p>Smith, R.J. (2004), GEL Criteria for Moment Condition Models. <em>Working paper, CEMMAP</em>.
</p>
<p>Wu, C. (2005), Algorithms and R codes for the pseudo empirical
likelihood method in survey sampling.
<em>Survey Methodology</em>, <b>31</b>(2), page 239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- function(tet,x)
	{
	n &lt;- nrow(x)
	u &lt;- (x[7:n] - tet[1] - tet[2]*x[6:(n-1)] - tet[3]*x[5:(n-2)])
	f &lt;- cbind(u, u*x[4:(n-3)], u*x[3:(n-4)], u*x[2:(n-5)], u*x[1:(n-6)])
	return(f)
	}
n = 500
phi&lt;-c(.2, .7)
thet &lt;- 0.2
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n, list(order = c(2, 0, 1), ar = phi, ma = thet, sd = sd)), ncol = 1)
gt &lt;- g(c(0,phi),x)
getLamb(gt, type = "EL",method="optim")
</code></pre>

<hr>
<h2 id='getModel'>Method for setting the properties of a model</h2><span id='topic+getModel.baseGmm'></span><span id='topic+getModel.sysGmm'></span><span id='topic+getModel.baseGel'></span><span id='topic+getModel.constGmm'></span><span id='topic+getModel.tsls'></span><span id='topic+getModel.constGel'></span><span id='topic+getModel.ateGel'></span>

<h3>Description</h3>

<p>It collects what is needed by the method <code>momentEstim</code> (see details). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baseGmm'
getModel(object, ...)
## S3 method for class 'sysGmm'
getModel(object, ...)
## S3 method for class 'baseGel'
getModel(object, ...)
## S3 method for class 'constGel'
getModel(object, ...)
## S3 method for class 'constGel'
getModel(object, ...)
## S3 method for class 'tsls'
getModel(object, ...)
## S3 method for class 'ateGel'
getModel(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getModel_+3A_object">object</code></td>
<td>
<p>An object of class <code>baseGmm</code> </p>
</td></tr>
<tr><td><code id="getModel_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>getModel</code> is applied to another class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of the right class which determines how the method <code>momentEstim</code> will treat it. For example, if <code>g</code> is a formula and <code>type</code> is set to &quot;cue&quot;, it creates an object of class <code>baseGmm.cue.formula</code>. It this case, <code>momentEstim</code>, applied to this object, computes the continuously updated GMM of a linear model. It allows more flexibility this way. For example, it could be easy to add a GMM method which is robust in presence of weak identification simply by creating a new class of model and the associated <code>momentEstime</code> method.
</p>

<hr>
<h2 id='gmm'>Generalized method of moment estimation</h2><span id='topic+gmm'></span><span id='topic+gmmWithConst'></span><span id='topic+evalGmm'></span>

<h3>Description</h3>

<p>Function to estimate a vector of parameters based on moment conditions using the GMM method of Hansen(82). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm(g,x,t0=NULL,gradv=NULL, type=c("twoStep","cue","iterative"), 
    wmatrix = c("optimal","ident"), vcov=c("HAC","MDS","iid","TrueFixed"), 
    kernel=c("Quadratic Spectral","Truncated", "Bartlett", "Parzen", "Tukey-Hanning"),
    crit=10e-7,bw = bwAndrews, prewhite = 1, ar.method = "ols", approx="AR(1)",
    tol = 1e-7, itermax=100,optfct=c("optim","optimize","nlminb", "constrOptim"),
    model=TRUE, X=FALSE, Y=FALSE, TypeGmm = "baseGmm", centeredVcov = TRUE, 
    weightsMatrix = NULL, traceIter = FALSE, data, eqConst = NULL, 
    eqConstFullVcov = FALSE, mustar = NULL, onlyCoefficients=FALSE, ...)
evalGmm(g, x, t0, tetw=NULL, gradv=NULL, wmatrix = c("optimal","ident"),
    vcov=c("HAC","iid","TrueFixed"), kernel=c("Quadratic Spectral","Truncated", 
    "Bartlett", "Parzen", "Tukey-Hanning"),crit=10e-7,bw = bwAndrews,
    prewhite = FALSE, ar.method = "ols", approx="AR(1)",tol = 1e-7,
    model=TRUE, X=FALSE, Y=FALSE,  centeredVcov = TRUE, weightsMatrix = NULL,
    data, mustar = NULL)
gmmWithConst(obj, which, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmm_+3A_g">g</code></td>
<td>
<p>A function of the form <code class="reqn">g(\theta,x)</code> and which returns a <code class="reqn">n \times q</code> matrix with typical element <code class="reqn">g_i(\theta,x_t)</code> for <code class="reqn">i=1,...q</code> and <code class="reqn">t=1,...,n</code>. This matrix is then used to build the q sample moment conditions. It can also be a formula if the model is linear (see details below).</p>
</td></tr>
<tr><td><code id="gmm_+3A_x">x</code></td>
<td>
<p>The matrix or vector of data from which the function <code class="reqn">g(\theta,x)</code> is computed. If &quot;g&quot; is a formula, it is an <code class="reqn">n \times Nh</code> matrix of instruments or a formula (see details below).</p>
</td></tr>
<tr><td><code id="gmm_+3A_t0">t0</code></td>
<td>
<p>A <code class="reqn">k \times 1</code> vector of starting values. It is required
only when &quot;g&quot; is a function because only then a numerical algorithm is
used to minimize the objective function. If the dimension of
<code class="reqn">\theta</code> is one, see the argument &quot;optfct&quot;.</p>
</td></tr>
<tr><td><code id="gmm_+3A_tetw">tetw</code></td>
<td>
<p>A <code class="reqn">k \times 1</code> vector to compute the weighting matrix.</p>
</td></tr>
<tr><td><code id="gmm_+3A_gradv">gradv</code></td>
<td>
<p>A function of the form <code class="reqn">G(\theta,x)</code> which returns a <code class="reqn">q\times k</code> matrix of derivatives of <code class="reqn">\bar{g}(\theta)</code> with respect to <code class="reqn">\theta</code>. By default, the numerical algorithm <code>numericDeriv</code> is used. It is of course strongly suggested to provide this function when it is possible. This gradient is used to compute the asymptotic covariance matrix of <code class="reqn">\hat{\theta}</code> and to obtain the analytical gradient of the objective function if the method is set to &quot;CG&quot; or &quot;BFGS&quot; in <code><a href="stats.html#topic+optim">optim</a></code> and if &quot;type&quot; is not set to &quot;cue&quot;. If &quot;g&quot; is a formula, the gradiant is not required (see the details below).</p>
</td></tr>
<tr><td><code id="gmm_+3A_type">type</code></td>
<td>
<p>The GMM method: &quot;twostep&quot; is the two step GMM proposed by Hansen(1982) and the &quot;cue&quot; and &quot;iterative&quot; are respectively the continuous updated and the iterative GMM proposed by Hansen, Eaton et Yaron (1996)</p>
</td></tr>
<tr><td><code id="gmm_+3A_wmatrix">wmatrix</code></td>
<td>
<p>Which weighting matrix should be used in the objective function. By default, it is the inverse of the covariance matrix of <code class="reqn">g(\theta,x)</code>. The other choice is the identity matrix which is usually used to obtain a first step estimate of <code class="reqn">\theta</code> </p>
</td></tr>
<tr><td><code id="gmm_+3A_vcov">vcov</code></td>
<td>
<p>Assumption on the properties of the random vector x. By default, x is a weakly dependant process. The &quot;iid&quot; option will avoid using the HAC matrix which will accelerate the estimation if one is ready to make that assumption. The option &quot;TrueFixed&quot; is used only when the matrix of weights is provided and it is the optimal one.</p>
</td></tr>
<tr><td><code id="gmm_+3A_kernel">kernel</code></td>
<td>
<p>type of kernel used to compute the covariance matrix of the vector of sample moment conditions (see <code>kernHAC</code> for more details)</p>
</td></tr>
<tr><td><code id="gmm_+3A_crit">crit</code></td>
<td>
<p>The stopping rule for the iterative GMM. It can be reduce to increase the precision.</p>
</td></tr>
<tr><td><code id="gmm_+3A_bw">bw</code></td>
<td>
<p>The method to compute the bandwidth parameter in the HAC
weighting matrix. The default is <code>link{bwAndrews}</code> (as proposed in Andrews
(1991)), which minimizes the MSE of the weighting matrix. Alternatives
are <code>link{bwWilhelm}</code> (as proposed in Wilhelm
(2015)), which minimizes the mean-square error (MSE) of the resulting
GMM estimator, and <code>link{bwNeweyWest}</code> (as proposed in Newey-West(1994)).</p>
</td></tr>
<tr><td><code id="gmm_+3A_prewhite">prewhite</code></td>
<td>
<p>logical or integer. Should the estimating functions be prewhitened? If <code>TRUE</code> or greater than 0 a VAR model of order <code>as.integer(prewhite)</code> is fitted via <code>ar</code> with method <code>"ols"</code> and <code>demean = FALSE</code>.</p>
</td></tr>
<tr><td><code id="gmm_+3A_ar.method">ar.method</code></td>
<td>
<p>character. The <code>method</code> argument passed to <code><a href="stats.html#topic+ar">ar</a></code> for prewhitening.</p>
</td></tr>
<tr><td><code id="gmm_+3A_approx">approx</code></td>
<td>
<p>A character specifying the approximation method if the bandwidth has to be chosen by <code>bwAndrews</code>.</p>
</td></tr>
<tr><td><code id="gmm_+3A_tol">tol</code></td>
<td>
<p>Weights that exceed <code>tol</code> are used for computing the covariance matrix, all other weights are treated as 0.</p>
</td></tr>
<tr><td><code id="gmm_+3A_itermax">itermax</code></td>
<td>
<p>The maximum number of iterations for the iterative GMM. It is unlikely that the algorithm does not converge but we keep it as a safety.</p>
</td></tr>
<tr><td><code id="gmm_+3A_optfct">optfct</code></td>
<td>
<p>Only when the dimension of <code class="reqn">\theta</code> is 1, you can choose between the algorithm <code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+optimize">optimize</a></code>. In that case, the former is unreliable. If <code><a href="stats.html#topic+optimize">optimize</a></code> is chosen, &quot;t0&quot; must be <code class="reqn">1\times 2</code> which represents the interval in which the algorithm seeks the solution. It is also possible to choose the <code><a href="stats.html#topic+nlminb">nlminb</a></code> algorithm. In that case, boundaries for the coefficients can be set by the options <code>upper=</code> and <code>lower=</code>. The <code><a href="stats.html#topic+constrOptim">constrOptim</a></code> is only available for nonlinear models for now. The standard errors may have to be corrected if the estimtes reach the boundary set by ui and ci.</p>
</td></tr>
<tr><td><code id="gmm_+3A_model">model</code>, <code id="gmm_+3A_x">X</code>, <code id="gmm_+3A_y">Y</code></td>
<td>
<p>logical.  If <code>TRUE</code> the corresponding components of the fit (the model frame, the model matrix, the response) are returned if g is a formula.</p>
</td></tr>
<tr><td><code id="gmm_+3A_typegmm">TypeGmm</code></td>
<td>
<p>The name of the class object created by the method <code>getModel</code>. It allows developers to extend the package and create other GMM methods.</p>
</td></tr>
<tr><td><code id="gmm_+3A_centeredvcov">centeredVcov</code></td>
<td>
<p>Should the moment function be centered when computing its covariance matrix. Doing so may improve inference.</p>
</td></tr>
<tr><td><code id="gmm_+3A_weightsmatrix">weightsMatrix</code></td>
<td>
<p>It allows users to provide <code>gmm</code> with a fixed weighting matrix. This matrix must be <code class="reqn">q \times q</code>, symmetric and strictly positive definite. When provided, the <code>type</code> option becomes irrelevant. </p>
</td></tr>
<tr><td><code id="gmm_+3A_traceiter">traceIter</code></td>
<td>
<p>Tracing information for GMM of type &quot;iter&quot;</p>
</td></tr>
<tr><td><code id="gmm_+3A_data">data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optional). </p>
</td></tr>
<tr><td><code id="gmm_+3A_eqconst">eqConst</code></td>
<td>
<p>Either a named vector (if &quot;g&quot; is a function), a simple vector for the nonlinear case indicating which of the <code class="reqn">\theta_0</code> is restricted, or a qx2 vector defining equality constraints of the form <code class="reqn">\theta_i=c_i</code>. See below for an example.</p>
</td></tr>
<tr><td><code id="gmm_+3A_which">which</code>, <code id="gmm_+3A_value">value</code></td>
<td>
<p>The equality constraint is of the form which=value. &quot;which&quot; can be a vector of type characters with the names of the coefficients being constrained, or a vector of type numeric with the position of the coefficient in the whole vector.</p>
</td></tr>
<tr><td><code id="gmm_+3A_obj">obj</code></td>
<td>
<p>Object of class &quot;gmm&quot;</p>
</td></tr>
<tr><td><code id="gmm_+3A_eqconstfullvcov">eqConstFullVcov</code></td>
<td>
<p>If FALSE, the constrained coefficients are assumed to be fixed and only the covariance of the unconstrained coefficients is computed. If TRUE, the covariance matrix of the full set of coefficients is computed.</p>
</td></tr>
<tr><td><code id="gmm_+3A_mustar">mustar</code></td>
<td>
<p>If not null, it must be a vector with the number of
elements being equal to the number of moment conditions. In that case,
the vector is subtracted from the sample moment vector before
minimizing the objective function. It is useful to do a bootstrap
procedure.
</p>
</td></tr>
<tr><td><code id="gmm_+3A_onlycoefficients">onlyCoefficients</code></td>
<td>
<p>If set to <code>TRUE</code>, the function only returns
the coefficient estimates. It may be of interest when the standard
errors are not needed</p>
</td></tr>
<tr><td><code id="gmm_+3A_...">...</code></td>
<td>
<p>More options to give to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If we want to estimate a model like <code class="reqn">Y_t = \theta_1 + X_{2t} \theta_2 + \cdots + X_{k}\theta_k + \epsilon_t</code> using the moment conditions <code class="reqn">Cov(\epsilon_tH_t)=0</code>, where <code class="reqn">H_t</code> is a vector of <code class="reqn">Nh</code> instruments, than we can define &quot;g&quot; like we do for <code><a href="stats.html#topic+lm">lm</a></code>. We would have <code class="reqn">g = y ~\tilde{}~ x2+x3+ \cdots +xk</code> and the argument &quot;x&quot; above would become the matrix H of instruments. As for <code><a href="stats.html#topic+lm">lm</a></code>, <code class="reqn">Y_t</code> can be a <code class="reqn">Ny \times 1</code> vector which would imply that <code class="reqn">k=Nh \times Ny</code>. The intercept is included by default so you do not have to add a column of ones to the matrix <code class="reqn">H</code>. You do not need to provide the gradiant in that case since in that case it is embedded in <code><a href="#topic+gmm">gmm</a></code>. The intercept can be removed by adding -1 to the formula. In that case, the column of ones need to be added manually to H. It is also possible to express &quot;x&quot; as a formula. For example, if the instruments are <code class="reqn">\{1,z_1,z_2,z_3\}</code>, we can set &quot;x&quot; to <code class="reqn">\tilde{} z1+z2+z3</code>. By default, a column of ones is added. To remove it, set &quot;x&quot; to <code class="reqn">\tilde{}z1+z2+z3-1</code>. 
</p>
<p>The following explains the last example bellow. Thanks to Dieter Rozenich, a student from the Vienna University of Economics and Business Administration. He suggested that it would help to understand the implementation of the Jacobian.  
</p>
<p>For the two parameters of a normal distribution <code class="reqn">(\mu,\sigma)</code> we have the following three moment conditions:
</p>
<p style="text-align: center;"><code class="reqn">
m_{1} = \mu - x_{i}
</code>
</p>

<p style="text-align: center;"><code class="reqn"> 
m_{2} = \sigma^2 - (x_{i}-\mu)^2
</code>
</p>

<p style="text-align: center;"><code class="reqn"> 
m_{3} = x_{i}^{3} - \mu (\mu^2+3\sigma^{2}) 
</code>
</p>

<p><code class="reqn">m_{1},m_{2}</code> can be directly obtained by the definition of <code class="reqn">(\mu,\sigma)</code>. The third moment condition comes from the third derivative of the moment generating function (MGF)
</p>
<p style="text-align: center;"><code class="reqn">
    M_{X}(t) = exp\Big(\mu t + \frac{\sigma^{2}t^{2}}{2}\Big)
</code>
</p>

<p>evaluated at <code class="reqn">(t=0)</code>.
</p>
<p>Note that we have more equations (3) than unknown parameters (2).
</p>
<p>The Jacobian of these two conditions is (it should be an array but I can't make it work):
</p>
<p style="text-align: center;"><code class="reqn"> 1~~~~~~~~~~ 0 </code>
</p>

<p style="text-align: center;"><code class="reqn"> -2\mu+2x ~~~~~ 2\sigma </code>
</p>

<p style="text-align: center;"><code class="reqn">-3\mu^{2}-3\sigma^{2} ~~~~ -6\mu\sigma</code>
</p>

<p><code>gmmWithConst()</code> re-estimates an unrestricted model by adding an
equality constraint.
<code>evalGmm()</code> creates an object of class '&quot;gmm&quot;' for a given
parameter vector. If no vector &quot;tetw&quot; is provided and the weighting
matrix needs to be computed, &quot;t0&quot; is used.,  
</p>


<h3>Value</h3>

<p>'gmm' returns an object of 'class' '&quot;gmm&quot;' 
</p>
<p>The functions 'summary' is used to obtain and print a summary of the results.  It also compute the J-test of overidentying restriction
</p>
<p>The object of class &quot;gmm&quot; is a list containing at least:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p><code class="reqn">k\times 1</code> vector of coefficients</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values if &quot;g&quot; is a formula.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values if &quot;g&quot; is a formula.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the covariance matrix of the coefficients</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>the value of the objective function <code class="reqn">\| var(\bar{g})^{-1/2}\bar{g}\|^2</code></p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used when g is a formula.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response used (if &quot;g&quot; is a formula).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used if &quot;g&quot; is a formula or the data if &quot;g&quot; is a function.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame used if &quot;g&quot; is a formula.</p>
</td></tr>
<tr><td><code>algoInfo</code></td>
<td>
<p>Information produced by either <code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlminb">nlminb</a></code> related to the convergence if &quot;g&quot; is a function. It is printed by the <code>summary.gmm</code> method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zeileis A (2006), Object-oriented Computation of Sandwich Estimators.
<em>Journal of Statistical Software</em>, <b>16</b>(9), 1&ndash;16.
URL <a href="https://doi.org/10.18637/jss.v016.i09">doi:10.18637/jss.v016.i09</a>.
</p>
<p>Pierre Chausse (2010), Computing Generalized Method of Moments and Generalized Empirical Likelihood with R.
<em>Journal of Statistical Software</em>, <b>34</b>(11), 1&ndash;35.
URL <a href="https://doi.org/10.18637/jss.v034.i11">doi:10.18637/jss.v034.i11</a>.
</p>
<p>Andrews DWK (1991),
Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>,
817&ndash;858.
</p>
<p>Newey WK &amp; West KD (1987), A Simple, Positive Semi-Definite,
Heteroskedasticity and Autocorrelation Consistent Covariance
Matrix. <em>Econometrica</em>, <b>55</b>, 703&ndash;708.
</p>
<p>Newey WK &amp; West KD (1994), Automatic Lag Selection in Covariance
Matrix Estimation. <em>Review of Economic Studies</em>, <b>61</b>, 631-653.
</p>
<p>Hansen, L.P. (1982),
Large Sample Properties of Generalized Method of Moments Estimators.
<em>Econometrica</em>, <b>50</b>,
1029-1054,
</p>
<p>Hansen, L.P. and Heaton, J. and Yaron, A.(1996),
Finite-Sample Properties of Some Alternative GMM Estimators.
<em>Journal of Business and Economic Statistics</em>, <b>14</b>
262-280.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## CAPM test with GMM
data(Finance)
r &lt;- Finance[1:300, 1:10]
rm &lt;- Finance[1:300, "rm"]
rf &lt;- Finance[1:300, "rf"]

z &lt;- as.matrix(r-rf)
t &lt;- nrow(z)
zm &lt;- rm-rf
h &lt;- matrix(zm, t, 1)
res &lt;- gmm(z ~ zm, x = h)
summary(res)

## linear tests can be performed using linearHypothesis from the car package
## The CAPM can be tested as follows:

library(car)
linearHypothesis(res,cbind(diag(10),matrix(0,10,10)),rep(0,10))

# The CAPM of Black
g &lt;- function(theta, x) {
	e &lt;- x[,2:11] - theta[1] - (x[,1] - theta[1]) %*% matrix(theta[2:11], 1, 10)
	gmat &lt;- cbind(e, e*c(x[,1]))
	return(gmat) }

x &lt;- as.matrix(cbind(rm, r))
res_black &lt;- gmm(g, x = x, t0 = rep(0, 11))

summary(res_black)$coefficients


## APT test with Fama-French factors and GMM

f1 &lt;- zm
f2 &lt;- Finance[1:300, "hml"] 
f3 &lt;- Finance[1:300, "smb"] 
h &lt;- cbind(f1, f2, f3)
res2 &lt;- gmm(z ~ f1 + f2 + f3, x = h)
coef(res2)
summary(res2)$coefficients

## Same result with x defined as a formula:

res2 &lt;- gmm(z ~ f1 + f2 + f3, ~ f1 + f2 + f3)
coef(res2)

## The following example has been provided by Dieter Rozenich (see details).
# It generates normal random numbers and uses the GMM to estimate 
# mean and sd.
#-------------------------------------------------------------------------------
# Random numbers of a normal distribution
# First we generate normally distributed random numbers and compute the two parameters:
n &lt;- 1000
x &lt;- rnorm(n, mean = 4, sd = 2)
# Implementing the 3 moment conditions
g &lt;- function(tet, x)
        {
        m1 &lt;- (tet[1] - x)
        m2 &lt;- (tet[2]^2 - (x - tet[1])^2)
        m3 &lt;- x^3 - tet[1]*(tet[1]^2 + 3*tet[2]^2)
        f &lt;- cbind(m1, m2, m3)
        return(f)
        }
# Implementing the jacobian
Dg &lt;- function(tet, x)
        {
        jacobian &lt;- matrix(c( 1, 2*(-tet[1]+mean(x)), -3*tet[1]^2-3*tet[2]^2,0, 2*tet[2],
			   -6*tet[1]*tet[2]), nrow=3,ncol=2)
        return(jacobian)
        }
# Now we want to estimate the two parameters using the GMM.
gmm(g, x, c(0, 0), grad = Dg)

# Two-stage-least-squares (2SLS), or IV with iid errors.
# The model is:
# Y(t) = b[0] + b[1]C(t) + b[2]Y(t-1) + e(t)
# e(t) is an MA(1)
# The instruments are Z(t)={1 C(t) y(t-2) y(t-3) y(t-4)}

getdat &lt;- function(n) {
e &lt;- arima.sim(n,model=list(ma=.9))
C &lt;- runif(n,0,5)
Y &lt;- rep(0,n)
Y[1] = 1 + 2*C[1] + e[1]
for (i in 2:n){
Y[i] = 1 + 2*C[i] + 0.9*Y[i-1] + e[i]
}
Yt &lt;- Y[5:n]
X &lt;- cbind(1,C[5:n],Y[4:(n-1)])
Z &lt;- cbind(1,C[5:n],Y[3:(n-2)],Y[2:(n-3)],Y[1:(n-4)]) 
return(list(Y=Yt,X=X,Z=Z))
}

d &lt;- getdat(5000)
res4 &lt;- gmm(d$Y~d$X-1,~d$Z-1,vcov="iid")
res4

### Examples with equality constraint 
######################################

# Random numbers of a normal distribution

## Not run:
# The following works but produces warning message because the dimension of coef is 1
# Brent should be used

# without named vector
# Method Brent is used because the problem is now one-dimensional
gmm(g, x, c(4, 0), grad = Dg, eqConst=1, method="Brent", lower=-10,upper=10)
# with named vector
gmm(g, x, c(mu=4, sig=2), grad = Dg, eqConst="sig", method="Brent", lower=-10,upper=10)

## End(Not run)

gmm(g, x, c(4, 0), grad = Dg, eqConst=1,method="Brent",lower=0,upper=6)
gmm(g, x, c(mu=4, sig=2), grad = Dg, eqConst="sig",method="Brent",lower=0,upper=6)

# Example with formula
# first coef = 0 and second coef = 1
# Only available for one dimensional yt

z &lt;- z[,1]
res2 &lt;- gmm(z ~ f1 + f2 + f3, ~ f1 + f2 + f3, eqConst = matrix(c(1,2,0,1),2,2))
res2

# CUE with starting t0 requires eqConst to be a vector

res3 &lt;- gmm(z ~ f1 + f2 + f3, ~ f1 + f2 + f3, t0=c(0,1,.5,.5), type="cue", eqConst = c(1,2))
res3

### Examples with equality constraints, where the constrained coefficients is used to compute
### the covariance matrix.
### Useful when some coefficients have been estimated before, they are just identified in GMM 
### and don't need to be re-estimated.
### To use with caution because the covariance won't be valid if the coefficients do not solve
### the GMM FOC.
######################################

res4 &lt;- gmm(z ~ f1 + f2 + f3, ~ f1 + f2 + f3, t0=c(0,1,.5,.5), eqConst = c(1,2), 
  	    eqConstFullVcov=TRUE)
summary(res4)


### Examples with equality constraint using gmmWithConst
###########################################################

res2 &lt;- gmm(z ~ f1 + f2 + f3, ~ f1 + f2 + f3)
gmmWithConst(res2,c("f2","f3"),c(.5,.5))
gmmWithConst(res2,c(2,3),c(.5,.5))

## Creating an object without estimation for a fixed parameter vector
###################################################################

res2_2 &lt;- evalGmm(z ~ f1 + f2 + f3, ~ f1 + f2 + f3,
                  t0=res2$coefficients, tetw=res2$coefficients)
summary(res2_2)

</code></pre>

<hr>
<h2 id='Growth'>Growth Data</h2><span id='topic+Growth'></span>

<h3>Description</h3>

<p>Panel of Macroeconomic data for 125 countries from 1960 to 1985
constructed by Summers and Heston (1991))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Growth)</code></pre>


<h3>Format</h3>

<p>A data frame containing 9 vectors. 
</p>

<dl>
<dt>Country_ID</dt><dd><p>Country identification number</p>
</dd>
<dt>COM</dt><dd><p>1 if the country is in a communist regime, 0 otherwise</p>
</dd> 
<dt>OPEC</dt><dd><p>1 if the country is part of the OPEC, 0 otherwise</p>
</dd> 
<dt>Year</dt><dd><p>Year</p>
</dd> 
<dt>GDP</dt><dd><p>Per capita GDP (in thousands) in 1985 U.S. dollars.</p>
</dd> 
<dt>LagGDP</dt><dd><p>GDP of the previous period</p>
</dd>
<dt>SavRate</dt><dd><p>Saving rate measured as the ratio of real investment to
real GDP</p>
</dd>
<dt>LagSavRate</dt><dd><p>SavRate of the previous period</p>
</dd>
<dt>Country</dt><dd><p>Country names</p>
</dd>
<dt>Pop</dt><dd><p>Population in thousands</p>
</dd>
<dt>LagPop</dt><dd><p>Population of the previous period</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://fhayashi.fc2web.com/datasets.htm">http://fhayashi.fc2web.com/datasets.htm</a></p>

<hr>
<h2 id='KTest'>Compute the K statistics of Kleibergen</h2><span id='topic+KTest'></span><span id='topic+print.gmmTests'></span>

<h3>Description</h3>

<p>The test is proposed by Kleibergen (2005). It is robust to weak identification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KTest(obj, theta0 = NULL, alphaK = 0.04, alphaJ = 0.01)
## S3 method for class 'gmmTests'
print(x, digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KTest_+3A_obj">obj</code></td>
<td>
<p>Object of class &quot;gmm&quot; returned by <code><a href="#topic+gmm">gmm</a></code></p>
</td></tr>
<tr><td><code id="KTest_+3A_theta0">theta0</code></td>
<td>
<p>The null hypothesis being tested. See details.</p>
</td></tr>
<tr><td><code id="KTest_+3A_alphak">alphaK</code>, <code id="KTest_+3A_alphaj">alphaJ</code></td>
<td>
<p>The size of the J and K tests when combining the two. The overall size is alphaK+alphaJ.</p>
</td></tr>
<tr><td><code id="KTest_+3A_x">x</code></td>
<td>
<p>An object of class <code>gmmTests</code> returned by <code>KTest</code></p>
</td></tr>
<tr><td><code id="KTest_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed</p>
</td></tr>
<tr><td><code id="KTest_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>print</code> is applied to another class object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces the J-test and K-statistics which are robust to weak identification. The test is either <code class="reqn">H0:\theta=theta_0</code>, in which case theta0 must be provided, or <code class="reqn">\beta=\beta_0</code>, where <code class="reqn">\theta=(\alpha', \beta')'</code>, and <code class="reqn">\alpha</code> is assumed to be identified. In the latter case, theta0 is NULL and obj is a restricted estimation in which <code class="reqn">\beta</code> is fixed to <code class="reqn">\beta_0</code>. See <code><a href="#topic+gmm">gmm</a></code> and the option &quot;eqConst&quot; for more details.  
</p>


<h3>Value</h3>

<p>Tests and p-values
</p>


<h3>References</h3>

<p>Keibergen, F. (2005),
Testing Parameters in GMM without assuming that they are identified.
<em>Econometrica</em>, <b>73</b>,
1103-1123,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(mvtnorm)
sig &lt;- matrix(c(1,.5,.5,1),2,2)
n &lt;- 400
e &lt;- rmvnorm(n,sigma=sig)
x4 &lt;- rnorm(n)
w &lt;- exp(-x4^2) + e[,1]
y &lt;- 0.1*w + e[,2]
h &lt;- cbind(x4, x4^2, x4^3, x4^6)
g3 &lt;- y~w
res &lt;- gmm(g3,h)

# Testing the whole vector:

KTest(res,theta0=c(0,.1))

# Testing a subset of the vector (See \code{\link{gmm}})

res2 &lt;- gmm(g3, h, eqConst=matrix(c(2,.1),1,2))
res2
KTest(res2)

</code></pre>

<hr>
<h2 id='marginal'>Marginal effects Summary</h2><span id='topic+marginal'></span><span id='topic+marginal.ategel'></span>

<h3>Description</h3>

<p>It produces the summary table of marginal effects for GLM estimation with
GEL. Only implemented for ATEgel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ategel'
marginal(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marginal_+3A_object">object</code></td>
<td>
<p>An object of class <code>ategel</code> returned by the function
<code><a href="#topic+ATEgel">ATEgel</a></code></p>
</td></tr>
<tr><td><code id="marginal_+3A_...">...</code></td>
<td>
<p>Other arguments for other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a matrix with the marginal effects, the standard errors based on the Delta
method when the link is nonlinear, the t-ratios, and the pvalues.</p>


<h3>References</h3>

<p>Owen, A.B. (2001),
Empirical Likelihood.
<em>Monographs on Statistics and Applied Probability 92, Chapman and
Hall/CRC</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## We create some artificial data with unbalanced groups and binary outcome
genDat &lt;- function(n)
    {
        eta=c(-1, .5, -.25, -.1)
        Z &lt;- matrix(rnorm(n*4),ncol=4)
        b &lt;- c(27.4, 13.7, 13.7, 13.7)
        bZ &lt;- c(Z%*%b)
        Y1 &lt;- as.numeric(rnorm(n, mean=210+bZ)&gt;220)
        Y0 &lt;- as.numeric(rnorm(n, mean=200-.5*bZ)&gt;220)
        etaZ &lt;- c(Z%*%eta)
        pZ &lt;- exp(etaZ)/(1+exp(etaZ))
        T &lt;- rbinom(n, 1, pZ)
        Y &lt;- T*Y1+(1-T)*Y0
        X1 &lt;- exp(Z[,1]/2)
        X2 &lt;- Z[,2]/(1+exp(Z[,1]))
        X3 &lt;- (Z[,1]*Z[,3]/25+0.6)^3
        X4 &lt;- (Z[,2]+Z[,4]+20)^2
        data.frame(Y=Y, cbind(X1,X2,X3,X4), T=T)
    }

dat &lt;- genDat(200)
res &lt;- ATEgel(Y~T, ~X1+X2+X3+X4, data=dat, type="ET", family="logit")
summary(res)

marginal(res)

</code></pre>

<hr>
<h2 id='momentEstim'>Method for estimating models based on moment conditions</h2><span id='topic+momentEstim.baseGmm.twoStep'></span><span id='topic+momentEstim.baseGmm.twoStep.formula'></span><span id='topic+momentEstim.sysGmm.twoStep.formula'></span><span id='topic+momentEstim.tsls.twoStep.formula'></span><span id='topic+momentEstim.baseGmm.iterative.formula'></span><span id='topic+momentEstim.baseGmm.iterative'></span><span id='topic+momentEstim.baseGmm.cue.formula'></span><span id='topic+momentEstim.baseGmm.cue'></span><span id='topic+momentEstim.baseGmm.eval'></span><span id='topic+momentEstim.baseGel.mod'></span><span id='topic+momentEstim.baseGel.modFormula'></span><span id='topic+momentEstim.baseGel.eval'></span>

<h3>Description</h3>

<p>It estimates a model which is caracterized by the method <code>getModel</code> (see details). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baseGmm.twoStep'
momentEstim(object, ...)
## S3 method for class 'baseGmm.twoStep.formula'
momentEstim(object, ...)
## S3 method for class 'sysGmm.twoStep.formula'
momentEstim(object, ...)
## S3 method for class 'tsls.twoStep.formula'
momentEstim(object, ...)
## S3 method for class 'baseGmm.iterative.formula'
momentEstim(object, ...)
## S3 method for class 'baseGmm.iterative'
momentEstim(object, ...)
## S3 method for class 'baseGmm.cue.formula'
momentEstim(object, ...)
## S3 method for class 'baseGmm.cue'
momentEstim(object, ...)
## S3 method for class 'baseGmm.eval'
momentEstim(object, ...)
## S3 method for class 'baseGel.mod'
momentEstim(object, ...)
## S3 method for class 'baseGel.modFormula'
momentEstim(object, ...)
## S3 method for class 'baseGel.eval'
momentEstim(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentEstim_+3A_object">object</code></td>
<td>
<p>An object created by the method <code>getModel</code></p>
</td></tr>
<tr><td><code id="momentEstim_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>momentEstim</code> is applied to an other class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an object of class determined by the argument &quot;TypeGMM&quot; of <code><a href="#topic+gmm">gmm</a></code>. By default, it is of class <code>baseGmm.res</code>. It estimates the model and organize the results that will be finalized by the method <code>FinRes</code>. More methods can be created in order to use other GMM methods not yet included in the package. 
</p>


<h3>References</h3>

<p>Hansen, L.P. (1982),
Large Sample Properties of Generalized Method of Moments Estimators.
<em>Econometrica</em>, <b>50</b>,
1029-1054,
</p>
<p>Hansen, L.P. and Heaton, J. and Yaron, A.(1996),
Finit-Sample Properties of Some Alternative GMM Estimators.
<em>Journal of Business and Economic Statistics</em>, <b>14</b>
262-280.
</p>

<hr>
<h2 id='nsw'>Lalonde subsample of the National Supported Work Demonstration Data
(NSW)</h2><span id='topic+nsw'></span>

<h3>Description</h3>

<p>This data was collected to evaluate the National Supported Work
(NSW) Demonstration project in Lalonde (1986).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nsw)</code></pre>


<h3>Format</h3>

<p>A data frame containing 9 variables. 
</p>

<dl>
<dt>treat</dt><dd><p>Treatment assignment</p>
</dd> 
<dt>age</dt><dd><p>Age</p>
</dd> 
<dt>ed</dt><dd><p>Years of Education</p>
</dd> 
<dt>black</dt><dd><p>1 if Black, 0 otherwise</p>
</dd> 
<dt>hisp</dt><dd><p>1 if Hispanic 0 otherwise</p>
</dd> 
<dt>married</dt><dd><p>1 if married 0 otherwise</p>
</dd> 
<dt>nodeg</dt><dd><p>1 if no college degree 0 otherwise</p>
</dd> 
<dt>re75</dt><dd><p>1975 earnings</p>
</dd> 
<dt>re78</dt><dd><p>1978 earnings</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset was obtained from the ATE package (see reference).
</p>


<h3>Source</h3>

<p>&quot;NSW Data Files&quot; from Rajeev Dehejia's website. URL:
<a href="http://users.nber.org/~rdehejia/data/.nswdata2.html">http://users.nber.org/~rdehejia/data/.nswdata2.html</a>
</p>
<p>&quot;National Supported Work Evaluation Study, 1975-1979: Public Use Files.&quot;
from the Interuniversity Consortium for Political and Social
Research. URL: <a href="http://www.icpsr.umich.edu/icpsrweb/ICPSR/studies/7865">http://www.icpsr.umich.edu/icpsrweb/ICPSR/studies/7865</a>
</p>


<h3>References</h3>

<p>Lalonde, R. (1986). &quot;Evaluating the Econometric Evaluations of Training Programs,&quot; American Economic Review, 76(4), 604-620.
</p>
<p>Dehejia R. and Wahba S. (1999).  &quot;Causal Effects in Non-Experimental Studies: Re-Evaluating the Evaluation of Training Programs,&quot; JASA 94 (448), 1053-1062.
</p>
<p>Asad Haris and Gary Chan (2015). ATE: Inference for Average Treatment
Effects using Covariate Balancing. R package version 0.2.0.
<a href="https://CRAN.R-project.org/package=ATE">https://CRAN.R-project.org/package=ATE</a>
</p>

<hr>
<h2 id='plot'>Plot Diagnostics for gel and gmm objects</h2><span id='topic+plot.gel'></span><span id='topic+plot.gmm'></span>

<h3>Description</h3>

<p>It is a plot method for <code>gel</code> or <code>gmm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gel'
plot(x, which = c(1L:4),
	    main = list("Residuals vs Fitted values", "Normal Q-Q",
	    "Response variable and fitted values","Implied probabilities"),
	    panel = if(add.smooth) panel.smooth else points,
	    ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(), ...,
	    add.smooth = getOption("add.smooth"))

## S3 method for class 'gmm'
plot(x, which = c(1L:3),
	    main = list("Residuals vs Fitted values", "Normal Q-Q",
	    "Response variable and fitted values"),
	    panel = if(add.smooth) panel.smooth else points,
	    ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(), ...,
	    add.smooth = getOption("add.smooth"))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p><code>gel</code> or <code>gmm</code> object, typically result of <code><a href="#topic+gel">gel</a></code> or <code><a href="#topic+gmm">gmm</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_which">which</code></td>
<td>
<p>if a subset of the plots is required, specify a subset of
the numbers <code>1:4</code> for <code>gel</code> or <code>1:3</code> for <code>gmm</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>Vector of titles for each plot.
</p>
</td></tr>
<tr><td><code id="plot_+3A_panel">panel</code></td>
<td>
<p>panel function.  The useful alternative to
<code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+panel.smooth">panel.smooth</a></code> can be chosen
by <code>add.smooth = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, see <code><a href="graphics.html#topic+par">par</a>(ask=.)</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting
functions.</p>
</td></tr>
<tr><td><code id="plot_+3A_add.smooth">add.smooth</code></td>
<td>
<p>logical indicating if a smoother should be added to
most plots; see also <code>panel</code> above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a beta version of a plot method for <code>gel</code> objects. It is a modified version of <code>plot.lm</code>. For now, it is available only for linear models expressed as a formula. Any suggestions are welcome regarding plots or options to include. 
The first two plots are the same as the ones provided by <code>plot.lm</code>, the third is the dependant variable <code class="reqn">y</code> with its mean <code class="reqn">\hat{y}</code> (the fitted values) and the last plots the implied probabilities with the empirical density <code class="reqn">1/T</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GEL #
n = 500
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n,list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]

H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H
t0 &lt;- c(0,.5,.5)

res &lt;- gel(g, x, t0)

plot(res, which = 3)
plot(res, which = 4)

# GMM #

res &lt;- gmm(g, x)
plot(res, which = 3)
</code></pre>

<hr>
<h2 id='print'>Printing a gmm or gel object</h2><span id='topic+print.gmm'></span><span id='topic+print.sysGmm'></span><span id='topic+print.gel'></span>

<h3>Description</h3>

<p>It is a printing method for <code>gmm</code> or <code>gel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmm'
print(x, digits = 5, ...)
## S3 method for class 'gel'
print(x, digits = 5, ...)
## S3 method for class 'sysGmm'
print(x, digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>An object of class <code>gmm</code> or <code>gel</code> returned by the function <code><a href="#topic+gmm">gmm</a></code> or <code><a href="#topic+gel">gel</a></code></p>
</td></tr>
<tr><td><code id="print_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Other arguments when print is applied to an other class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It prints some results from the estimation like the coefficients and the value of the objective function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMM #

n = 500
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n, list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]

H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H

res &lt;- gmm(g, x)
print(res)

# GEL #

t0 &lt;- c(0,.5,.5)
res &lt;- gel(g,x,t0)
print(res)
</code></pre>

<hr>
<h2 id='residuals'>Residuals of GEL or GMM</h2><span id='topic+residuals.gel'></span><span id='topic+residuals.gmm'></span>

<h3>Description</h3>

<p>Method to extract the residuals of the model estimated by <code>gmm</code> or <code>gel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gel'
residuals(object, ...)
## S3 method for class 'gmm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>An object of class <code>gmm</code> or <code>gel</code> returned by the function <code><a href="#topic+gmm">gmm</a></code> or <code><a href="#topic+gel">gel</a></code></p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>residuals</code> is applied to an other classe object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the  matrix of residuals <code class="reqn">(y-\hat{y})</code> in <code>g=y~x</code> as it is done by  <code>residuals.lm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GEL can deal with endogeneity problems

n = 200
phi&lt;-c(.2,.7)
thet &lt;- 0.2
sd &lt;- .2
set.seed(123)
x &lt;- matrix(arima.sim(n = n, list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)

y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]
H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H

res &lt;- gel(g, x, c(0,.3,.6))
e &lt;- residuals(res)
plot(e, type = 'l', main = "Residuals from an ARMA fit using GEL")

# GMM is like GLS for linear models without endogeneity problems

set.seed(345)
n = 200
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n, list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)
y &lt;- 10 + 5*rnorm(n) + x

res &lt;- gmm(y ~ x, x)
plot(x, residuals(res), main = "Residuals of an estimated model with GMM")


</code></pre>

<hr>
<h2 id='smoothG'>Kernel smoothing of a matrix of time series</h2><span id='topic+smoothG'></span>

<h3>Description</h3>

<p>It applies the required kernel smoothing to the moment function in order for the GEL estimator to be valid. It is used by the <code>gel</code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothG(x, bw = bwAndrews, prewhite = 1, ar.method = "ols", weights = weightsAndrews,
	kernel = c("Bartlett", "Parzen", "Truncated", "Tukey-Hanning"), 
	approx = c("AR(1)", "ARMA(1,1)"), tol = 1e-7) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoothG_+3A_x">x</code></td>
<td>
<p>a <code class="reqn">n\times q</code> matrix of time series, where n is the sample size.</p>
</td></tr>
<tr><td><code id="smoothG_+3A_bw">bw</code></td>
<td>
<p>The method to compute the bandwidth parameter. By default, it uses the bandwidth proposed by Andrews(1991). As an alternative, we can choose bw=bwNeweyWest (without &quot;&quot;) which is proposed by Newey-West(1996).</p>
</td></tr>
<tr><td><code id="smoothG_+3A_prewhite">prewhite</code></td>
<td>
<p>logical or integer. Should the estimating functions
be prewhitened? If <code>TRUE</code> or greater than 0 a VAR model of
order <code>as.integer(prewhite)</code> is fitted via <code>ar</code> with
method <code>"ols"</code> and <code>demean = FALSE</code>.</p>
</td></tr>
<tr><td><code id="smoothG_+3A_ar.method">ar.method</code></td>
<td>
<p>character. The <code>method</code> argument passed to
<code><a href="stats.html#topic+ar">ar</a></code> for prewhitening.</p>
</td></tr>
<tr><td><code id="smoothG_+3A_weights">weights</code></td>
<td>
<p>The smoothing weights can be computed by <code>weightsAndrews</code> of it can be provided manually. If provided, it has to be a <code class="reqn">r\times 1</code>vector (see details). </p>
</td></tr>
<tr><td><code id="smoothG_+3A_approx">approx</code></td>
<td>
<p>a character specifying the approximation method if the
bandwidth has to be chosen by <code>bwAndrews</code>.</p>
</td></tr>
<tr><td><code id="smoothG_+3A_tol">tol</code></td>
<td>
<p>numeric. Weights that exceed <code>tol</code> are used for computing
the covariance matrix, all other weights are treated as 0.</p>
</td></tr>
<tr><td><code id="smoothG_+3A_kernel">kernel</code></td>
<td>
<p>The choice of kernel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sample moment conditions <code class="reqn">\sum_{t=1}^n g(\theta,x_t)</code> is replaced by:
<code class="reqn">\sum_{t=1}^n g^k(\theta,x_t)</code>, where <code class="reqn">g^k(\theta,x_t)=\sum_{i=-r}^r k(i) g(\theta,x_{t+i})</code>,
where <code class="reqn">r</code> is a truncated parameter that depends on the bandwidth and <code class="reqn">k(i)</code> are normalized weights so that they sum to 1.
</p>
<p>If the vector of weights is provided, it gives only one side weights. For exemple, if you provide the vector (1,.5,.25), <code class="reqn">k(i)</code> will become <code class="reqn">(.25,.5,1,.5,.25)/(.25+.5+1+.5+.25) =  (.1,.2,.4,.2,.1)</code>
</p>


<h3>Value</h3>

<p>smoothx: A <code class="reqn">q \times q</code> matrix containing an estimator of the asymptotic variance of <code class="reqn">\sqrt{n} \bar{x}</code>, where <code class="reqn">\bar{x}</code> is <code class="reqn">q\times 1</code>vector with typical element <code class="reqn">\bar{x}_i = \frac{1}{n}\sum_{j=1}^nx_{ji}</code>. This function is called by <code><a href="#topic+gel">gel</a></code> but can also be used by itself.
</p>
<p><code>kern_weights</code>: Vector of weights used for the smoothing.
</p>


<h3>References</h3>

<p>Anatolyev, S. (2005), GMM, GEL, Serial Correlation, and Asymptotic Bias. <em>Econometrica</em>, <b>73</b>, 983-1002.
</p>
<p>Andrews DWK (1991),
Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>,
817&ndash;858.
</p>
<p>Kitamura, Yuichi (1997), Empirical Likelihood Methods With Weakly Dependent Processes.
<em>The Annals of Statistics</em>, <b>25</b>, 2084-2102.
</p>
<p>Zeileis A (2006), Object-oriented Computation of Sandwich Estimators.
<em>Journal of Statistical Software</em>, <b>16</b>(9), 1&ndash;16.
URL <a href="https://doi.org/10.18637/jss.v016.i09">doi:10.18637/jss.v016.i09</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- function(tet, x)
	{
	n &lt;- nrow(x)
	u &lt;- (x[7:n] - tet[1] - tet[2]*x[6:(n-1)] - tet[3]*x[5:(n-2)])
	f &lt;- cbind(u, u*x[4:(n-3)], u*x[3:(n-4)], u*x[2:(n-5)], u*x[1:(n-6)])
	return(f)
	}
n = 500
phi&lt;-c(.2, .7)
thet &lt;- 0.2
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n, list(order = c(2, 0, 1), ar = phi, ma = thet, sd = sd)), ncol = 1)
gt &lt;- g(c(0, phi), x) 
sgt &lt;- smoothG(gt)$smoothx
plot(gt[,1])
lines(sgt[,1])
</code></pre>

<hr>
<h2 id='specTest'>Compute tests of specification</h2><span id='topic+specTest'></span><span id='topic+specTest.gel'></span><span id='topic+specTest.gmm'></span><span id='topic+print.specTest'></span>

<h3>Description</h3>

<p>Generic function for testing the specification of estimated models. It computes the J-test from <code>gmm</code> objects and J-test, LR-test and LM-test from 
<code>gel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmm'
specTest(x, ...)
## S3 method for class 'gel'
specTest(x, ...)
## S3 method for class 'specTest'
print(x, digits = 5, ...)
specTest(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specTest_+3A_x">x</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="specTest_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed.</p>
</td></tr>
<tr><td><code id="specTest_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tests and p-values
</p>


<h3>References</h3>

<p>Hansen, L.P. (1982),
Large Sample Properties of Generalized Method of Moments Estimators.
<em>Econometrica</em>, <b>50</b>,
1029-1054,
</p>
<p>Smith, R. J. (2004),
GEL Criteria for Moment Condition Models.
<em>CeMMAP working papers, Institute for Fiscal Studies</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################
n = 500
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n=n,list(order=c(2,0,1),ar=phi,ma=thet,sd=sd)),ncol=1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]

H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H
t0 &lt;- c(0,.5,.5)

res &lt;- gel(g, x, t0)
specTest(res)

###################
res &lt;- gmm(g, x)
specTest(res)

</code></pre>

<hr>
<h2 id='summary'>Method for object of class gmm or gel</h2><span id='topic+summary.gmm'></span><span id='topic+summary.sysGmm'></span><span id='topic+summary.gel'></span><span id='topic+summary.ategel'></span><span id='topic+summary.tsls'></span><span id='topic+print.summary.gmm'></span><span id='topic+print.summary.sysGmm'></span><span id='topic+print.summary.gel'></span><span id='topic+print.summary.tsls'></span>

<h3>Description</h3>

<p>It presents the results from the <code>gmm</code> or <code>gel</code> estimation in the same fashion as <code>summary</code> does for the <code>lm</code> class objects for example. It also compute the tests for overidentifying restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmm'
summary(object, ...)
## S3 method for class 'sysGmm'
summary(object, ...)
## S3 method for class 'gel'
summary(object, ...)
## S3 method for class 'ategel'
summary(object, robToMiss = TRUE, ...)
## S3 method for class 'tsls'
summary(object, vcov = NULL, ...)
## S3 method for class 'summary.gmm'
print(x, digits = 5, ...)
## S3 method for class 'summary.sysGmm'
print(x, digits = 5, ...)
## S3 method for class 'summary.gel'
print(x, digits = 5, ...)
## S3 method for class 'summary.tsls'
print(x, digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>An object of class <code>gmm</code> or <code>gel</code> returned by the function <code><a href="#topic+gmm">gmm</a></code> or <code><a href="#topic+gel">gel</a></code></p>
</td></tr>
<tr><td><code id="summary_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.gmm</code> or <code>summary.gel</code> returned by the function <code><a href="#topic+summary.gmm">summary.gmm</a></code> <code><a href="#topic+summary.gel">summary.gel</a></code></p>
</td></tr>
<tr><td><code id="summary_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed</p>
</td></tr>
<tr><td><code id="summary_+3A_vcov">vcov</code></td>
<td>
<p>An alternative covariance matrix computed with
<code>vcov.tsls</code></p>
</td></tr>
<tr><td><code id="summary_+3A_robtomiss">robToMiss</code></td>
<td>
<p>If <code>TRUE</code>, it computes the robust to
misspecification covariance matrix</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Other arguments when summary is applied to another class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list with the parameter estimates and their standard deviations, t-stat and p-values. It also returns the J-test and p-value for the null hypothesis that <code class="reqn">E(g(\theta,X)=0</code> 
</p>


<h3>References</h3>

<p>Hansen, L.P. (1982),
Large Sample Properties of Generalized Method of Moments Estimators.
<em>Econometrica</em>, <b>50</b>,
1029-1054,
</p>
<p>Hansen, L.P. and Heaton, J. and Yaron, A.(1996),
Finit-Sample Properties of Some Alternative GMM Estimators.
<em>Journal of Business and Economic Statistics</em>, <b>14</b>
262-280.
</p>
<p>Anatolyev, S. (2005), 
GMM, GEL, Serial Correlation, and Asymptotic Bias. 
<em>Econometrica</em>, <b>73</b>, 
983-1002.
</p>
<p>Kitamura, Yuichi (1997), 
Empirical Likelihood Methods With Weakly Dependent Processes.
<em>The Annals of Statistics</em>, <b>25</b>,
2084-2102.
</p>
<p>Newey, W.K. and Smith, R.J. (2004), 
Higher Order Properties of GMM and Generalized Empirical Likelihood Estimators. 
<em>Econometrica</em>, <b>72</b>, 
219-255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMM #
set.seed(444)
n = 500
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n, list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]
ym3 &lt;- x[4:(n-3)]
ym4 &lt;- x[3:(n-4)]
ym5 &lt;- x[2:(n-5)]
ym6 &lt;- x[1:(n-6)]

g &lt;- y ~ ym1 + ym2
x &lt;- ~ym3+ym4+ym5+ym6

res &lt;- gmm(g, x)

summary(res)

# GEL #

t0 &lt;- res$coef
res &lt;- gel(g, x, t0)
summary(res)


# tsls #

res &lt;- tsls(y ~ ym1 + ym2,~ym3+ym4+ym5+ym6)
summary(res)

</code></pre>

<hr>
<h2 id='sysGmm'>Generalized method of moment estimation for system of equations</h2><span id='topic+sysGmm'></span><span id='topic+five'></span><span id='topic+sur'></span><span id='topic+randEffect'></span><span id='topic+threeSLS'></span>

<h3>Description</h3>

<p>Functions to estimate a system of equations based on GMM. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sysGmm(g, h, wmatrix = c("optimal","ident"),
vcov=c("MDS", "HAC", "CondHom", "TrueFixed"),
       kernel=c("Quadratic Spectral","Truncated", "Bartlett", "Parzen", "Tukey-Hanning"),
       crit=10e-7,bw = bwAndrews, prewhite = FALSE, ar.method = "ols", approx="AR(1)",
       tol = 1e-7, model=TRUE, X=FALSE, Y=FALSE, centeredVcov = TRUE,
       weightsMatrix = NULL, data, crossEquConst = NULL, commonCoef = FALSE)
five(g, h, commonCoef = FALSE, data = NULL)
threeSLS(g, h, commonCoef = FALSE, data = NULL)
sur(g, commonCoef = FALSE, data = NULL)
randEffect(g, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sysGmm_+3A_g">g</code></td>
<td>
<p>A possibly named list of formulas</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_h">h</code></td>
<td>
<p>A formula if the same instruments are used in each equation or
a list of formulas.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_wmatrix">wmatrix</code></td>
<td>
<p>Which weighting matrix should be used in the objective function. By default, it is the inverse of the covariance matrix of <code class="reqn">g(\theta,x)</code>. The other choice is the identity matrix.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_vcov">vcov</code></td>
<td>
<p>Assumption on the properties of the moment vector. By
default, it is a martingale difference sequence. &quot;HAC&quot; is for weakly
dependent processes and &quot;CondHom&quot; implies conditional
homoscedasticity. The option &quot;TrueFixed&quot; is used only when the matrix of weights is provided and it is the optimal one.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_kernel">kernel</code></td>
<td>
<p>type of kernel used to compute the covariance matrix of the vector of sample moment conditions (see <code>kernHAC</code> for more details)</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_crit">crit</code></td>
<td>
<p>The stopping rule for the iterative GMM. It can be reduce to increase the precision.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_bw">bw</code></td>
<td>
<p>The method to compute the bandwidth parameter. By default it is <code>bwAndrews</code> which is proposed by Andrews (1991). The alternative is <code>bwNeweyWest</code> of Newey-West(1994).</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_prewhite">prewhite</code></td>
<td>
<p>logical or integer. Should the estimating functions be prewhitened? If <code>TRUE</code> or greater than 0 a VAR model of order <code>as.integer(prewhite)</code> is fitted via <code>ar</code> with method <code>"ols"</code> and <code>demean = FALSE</code>.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_ar.method">ar.method</code></td>
<td>
<p>character. The <code>method</code> argument passed to <code><a href="stats.html#topic+ar">ar</a></code> for prewhitening.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_approx">approx</code></td>
<td>
<p>A character specifying the approximation method if the bandwidth has to be chosen by <code>bwAndrews</code>.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_tol">tol</code></td>
<td>
<p>Weights that exceed <code>tol</code> are used for computing the covariance matrix, all other weights are treated as 0.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_model">model</code>, <code id="sysGmm_+3A_x">X</code>, <code id="sysGmm_+3A_y">Y</code></td>
<td>
<p>logical.  If <code>TRUE</code> the corresponding components of the fit (the model frame, the model matrix, the response) are returned if g is a formula.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_centeredvcov">centeredVcov</code></td>
<td>
<p>Should the moment function be centered when computing its covariance matrix. Doing so may improve inference.</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_weightsmatrix">weightsMatrix</code></td>
<td>
<p>It allows users to provide <code>gmm</code> with a fixed weighting matrix. This matrix must be <code class="reqn">q \times q</code>, symmetric and strictly positive definite. When provided, the <code>type</code> option becomes irrelevant. </p>
</td></tr>
<tr><td><code id="sysGmm_+3A_data">data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optional). </p>
</td></tr>
<tr><td><code id="sysGmm_+3A_commoncoef">commonCoef</code></td>
<td>
<p>If true, coefficients accross equations are the same</p>
</td></tr>
<tr><td><code id="sysGmm_+3A_crossequconst">crossEquConst</code></td>
<td>
<p>Only used if the number of regressors are the same
in each equation. It is a vector which indicates which coefficient are
constant across equations. The order is 1 for Intercept and 2 to k as
it is formulated in the formulas <code>g</code>. Setting it to <code>1:k</code> is
equivalent to setting commonCoef to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This set of functions implement the estimation of system of equations as presented in Hayashi (2000)
</p>


<h3>Value</h3>

<p>'sysGmm' returns an object of 'class' '&quot;sysGmm&quot;' 
</p>
<p>The functions 'summary' is used to obtain and print a summary of the results.  It also compute the J-test of overidentying restriction
</p>
<p>The object of class &quot;sysGmm&quot; is a list containing at least:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>list of vectors of coefficients for each equation</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>list of the residuals for each equation.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>list of the fitted values for each equation.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the covariance matrix of the stacked coefficients</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>the value of the objective function <code class="reqn">\| var(\bar{g})^{-1/2}\bar{g}\|^2</code></p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The list of <code><a href="stats.html#topic+terms">terms</a></code> objects for each equation</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>If requested, a list of response variables.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, a list of the model matrices.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), a list of the model frames.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zeileis A (2006), Object-oriented Computation of Sandwich Estimators.
<em>Journal of Statistical Software</em>, <b>16</b>(9), 1&ndash;16.
URL <a href="https://doi.org/10.18637/jss.v016.i09">doi:10.18637/jss.v016.i09</a>.
</p>
<p>Andrews DWK (1991),
Heteroskedasticity and Autocorrelation Consistent Covariance Matrix Estimation.
<em>Econometrica</em>, <b>59</b>,
817&ndash;858.
</p>
<p>Newey WK &amp; West KD (1987), A Simple, Positive Semi-Definite,
Heteroskedasticity and Autocorrelation Consistent Covariance
Matrix. <em>Econometrica</em>, <b>55</b>, 703&ndash;708.
</p>
<p>Newey WK &amp; West KD (1994), Automatic Lag Selection in Covariance
Matrix Estimation. <em>Review of Economic Studies</em>, <b>61</b>, 631-653.
</p>
<p>Hayashi, F. (2000), Econometrics.
<em>Princeton University Press</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(wage)

eq1 &lt;- LW~S+IQ+EXPR
eq2 &lt;- LW80~S80+IQ+EXPR80
g2 &lt;- list(Wage69=eq1, WAGE80=eq2)
h2 &lt;- list(~S+EXPR+MED+KWW, ~S80+EXPR80+MED+KWW)

res &lt;- sysGmm(g2, h2, data=wage, commonCoef=TRUE)
summary(res)

res2 &lt;- sysGmm(g2, h2, data=wage)
summary(res2)

five(g2, h2, data=wage)

threeSLS(g2, h2[[1]], data=wage)

sur(g2, data=wage)

randEffect(g2, data=wage)

## Cross-Equation restrictions
## All but the intercept are assumed to be the same

res &lt;- sysGmm(g2, h2, data=wage, crossEquConst = 2:4)
summary(res)

</code></pre>

<hr>
<h2 id='tsls'>Two stage least squares estimation</h2><span id='topic+tsls'></span>

<h3>Description</h3>

<p>Function to estimate a linear model by the two stage least squares method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsls(g,x,data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsls_+3A_g">g</code></td>
<td>
<p>A formula describing the linear regression model (see details below).</p>
</td></tr>
<tr><td><code id="tsls_+3A_x">x</code></td>
<td>
<p>The matrix of instruments (see details below).</p>
</td></tr>
<tr><td><code id="tsls_+3A_data">data</code></td>
<td>
<p>A data.frame or a matrix with column names (Optionnal). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function just calls <code><a href="#topic+gmm">gmm</a></code> with the option vcov=&quot;iid&quot;. It just simplifies the the implementation of 2SLS. The users don't have to worry about all the options offered in <code><a href="#topic+gmm">gmm</a></code>. The model is 
</p>
<p style="text-align: center;"><code class="reqn">
Y_i = X_i\beta + u_i
</code>
</p>

<p>In the first step, <code><a href="stats.html#topic+lm">lm</a></code>  is used to regress <code class="reqn">X_i</code> on the set of instruments <code class="reqn">Z_i</code>. The second step also uses <code><a href="stats.html#topic+lm">lm</a></code> to regress <code class="reqn">Y_i</code> on the fitted values of the first step. 
</p>


<h3>Value</h3>

<p>'tsls' returns an object of 'class' '&quot;tsls&quot;' which inherits from  class '&quot;gmm&quot;'.
</p>
<p>The functions 'summary' is used to obtain and print a summary of the results.  It also compute the J-test of overidentying restriction
</p>
<p>The object of class &quot;gmm&quot; is a list containing at least:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p><code class="reqn">k\times 1</code> vector of coefficients</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values if &quot;g&quot; is a formula.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values if &quot;g&quot; is a formula.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the covariance matrix of the coefficients</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>the value of the objective function <code class="reqn">\| var(\bar{g})^{-1/2}\bar{g}\|^2</code></p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used when g is a formula.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response used (if &quot;g&quot; is a formula).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used if &quot;g&quot; is a formula or the data if &quot;g&quot; is a function.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame used if &quot;g&quot; is a formula.</p>
</td></tr>
<tr><td><code>algoInfo</code></td>
<td>
<p>Information produced by either <code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlminb">nlminb</a></code> related to the convergence if &quot;g&quot; is a function. It is printed by the <code>summary.gmm</code> method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hansen, L.P. (1982),
Large Sample Properties of Generalized Method of Moments Estimators.
<em>Econometrica</em>, <b>50</b>,
1029-1054,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 1000
e &lt;- arima.sim(n,model=list(ma=.9))
C &lt;- runif(n,0,5)
Y &lt;- rep(0,n)
Y[1] = 1 + 2*C[1] + e[1]
for (i in 2:n){
Y[i] = 1 + 2*C[i] + 0.9*Y[i-1] + e[i]
}
Yt &lt;- Y[5:n]
X &lt;- cbind(C[5:n],Y[4:(n-1)])
Z &lt;- cbind(C[5:n],Y[3:(n-2)],Y[2:(n-3)],Y[1:(n-4)]) 

res &lt;- tsls(Yt~X,~Z)
res

</code></pre>

<hr>
<h2 id='vcov'>Variance-covariance matrix of GMM or GEL</h2><span id='topic+vcov.gmm'></span><span id='topic+vcov.gel'></span><span id='topic+vcov.tsls'></span><span id='topic+vcov.ategel'></span>

<h3>Description</h3>

<p>It extracts the matrix of variances and covariances from <code>gmm</code> or <code>gel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmm'
vcov(object, ...)
## S3 method for class 'gel'
vcov(object, lambda = FALSE, ...)
## S3 method for class 'tsls'
vcov(object, type=c("Classical","HC0","HC1","HAC"),
                    hacProp = list(), ...)
## S3 method for class 'ategel'
vcov(object, lambda = FALSE, robToMiss = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov_+3A_object">object</code></td>
<td>
<p>An object of class <code>gmm</code> or <code>gmm</code> returned by the function <code><a href="#topic+gmm">gmm</a></code> or <code><a href="#topic+gel">gel</a></code></p>
</td></tr>
<tr><td><code id="vcov_+3A_lambda">lambda</code></td>
<td>
<p>If set to TRUE, the covariance matrix of the Lagrange multipliers is produced.</p>
</td></tr>
<tr><td><code id="vcov_+3A_type">type</code></td>
<td>
<p>Type of covariance matrix for the meat</p>
</td></tr>
<tr><td><code id="vcov_+3A_hacprop">hacProp</code></td>
<td>
<p>A list of arguments to pass to <code>kernHAC</code></p>
</td></tr>
<tr><td><code id="vcov_+3A_robtomiss">robToMiss</code></td>
<td>
<p>If <code>TRUE</code>, it computes the robust to
misspecification covariance matrix</p>
</td></tr>
<tr><td><code id="vcov_+3A_...">...</code></td>
<td>
<p>Other arguments when <code>vcov</code> is applied to another class object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For tsls(), if vcov is set to a different value thand &quot;Classical&quot;, a sandwich covariance matrix is computed.
</p>


<h3>Value</h3>

<p>A matrix of variances and covariances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMM #
n = 500
phi&lt;-c(.2,.7)
thet &lt;- 0
sd &lt;- .2
x &lt;- matrix(arima.sim(n = n,list(order = c(2,0,1), ar = phi, ma = thet, sd = sd)), ncol = 1)
y &lt;- x[7:n]
ym1 &lt;- x[6:(n-1)]
ym2 &lt;- x[5:(n-2)]

H &lt;- cbind(x[4:(n-3)], x[3:(n-4)], x[2:(n-5)], x[1:(n-6)])
g &lt;- y ~ ym1 + ym2
x &lt;- H

res &lt;- gmm(g, x)
vcov(res)

## GEL ##

t0 &lt;- c(0,.5,.5)
res &lt;- gel(g, x, t0)
vcov(res)
vcov(res, lambda = TRUE)

</code></pre>

<hr>
<h2 id='wage'>Labor Data</h2><span id='topic+wage'></span>

<h3>Description</h3>

<p>Data used to measure return to education by Griliches (1976)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wage)</code></pre>


<h3>Format</h3>

<p>A data frame containing 20 cross-sectional vectors. 
</p>

<dl>
<dt>AGE, AGE80</dt><dd><p>Age in 1969 and 1980 respetively</p>
</dd>
<dt>EXPR, EXPR80</dt><dd><p>Working experience in 1969 and 1980 respetively</p>
</dd> 
<dt>IQ</dt><dd><p>IQ measure of the individual</p>
</dd> 
<dt>KWW</dt><dd><p>A test score</p>
</dd> 
<dt>LW, LW80</dt><dd><p>Log wage in 1969 and 1980 respectively</p>
</dd> 
<dt>MED</dt><dd><p>Mother education</p>
</dd>
<dt>MRT, MRT80</dt><dd></dd>
<dt>RNS, RNS80</dt><dd></dd>
<dt>S, S80</dt><dd><p>Schooling in 1969 and 1980 respetively</p>
</dd>
<dt>SMSA, SMSA80</dt><dd></dd> 
<dt>TENURE, TENURE80</dt><dd><p>Tenure in 1969 and 1980 respetively</p>
</dd> 
<dt>YEAR</dt><dd></dd> 
</dl>



<h3>Source</h3>

<p><a href="http://fhayashi.fc2web.com/datasets.htm">http://fhayashi.fc2web.com/datasets.htm</a></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
