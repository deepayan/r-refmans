<!DOCTYPE html><html><head><title>Help for package BGData</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BGData}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BGData-package'><p>A Suite of Packages for Analysis of Big Genomic Data</p></a></li>
<li><a href='#as.BGData'><p>Convert Other Objects to BGData Objects</p></a></li>
<li><a href='#BGData'><p>Creates a New BGData Instance</p></a></li>
<li><a href='#BGData-class'><p>Container for Phenotype and Genotype Data</p></a></li>
<li><a href='#chunkedApply'><p>Applies a Function on Each Row or Column of a File-Backed Matrix</p></a></li>
<li><a href='#chunkedMap'><p>Applies a Function on Each Chunk of a File-Backed Matrix</p></a></li>
<li><a href='#file-backed-matrices'><p>File-Backed Matrices</p></a></li>
<li><a href='#findRelated'><p>Find related individuals in a relationship matrix</p></a></li>
<li><a href='#FWD'><p>Performs Forward Regressions</p></a></li>
<li><a href='#geno'><p>Getting/Setting Genotypes, Sample Information, and Variant Information</p></a></li>
<li><a href='#geno-class'><p>An Abstract S4 Class Union of Matrix-Like Types</p></a></li>
<li><a href='#getG'><p>Computes a Genomic Relationship Matrix</p></a></li>
<li><a href='#getG_symDMatrix'><p>Computes a Very Large Genomic Relationship Matrix</p></a></li>
<li><a href='#GWAS'><p>Performs Single Marker Regressions Using BGData Objects</p></a></li>
<li><a href='#load.BGData'><p>Loads BGData (and Other) Objects from .RData Files</p></a></li>
<li><a href='#multi-level-parallelism'><p>Multi-Level Parallelism</p></a></li>
<li><a href='#orderedMerge'><p>Merge Two Data Frames Keeping the Order of the First</p></a></li>
<li><a href='#preprocess'><p>Center, scale, and impute data</p></a></li>
<li><a href='#readRAW'><p>Creates a BGData Object From a .raw File or a .ped-Like File</p></a></li>
<li><a href='#segments'><p>Find non-overlapping segments based on a summary statistic</p></a></li>
<li><a href='#summarize'><p>Generates Various Summary Statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.4.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Title:</td>
<td>A Suite of Packages for Analysis of Big Genomic Data</td>
</tr>
<tr>
<td>Description:</td>
<td>An umbrella package providing a phenotype/genotype data structure
    and scalable and efficient computational methods for large genomic datasets
    in combination with several other packages: 'BEDMatrix', 'LinkedMatrix',
    and 'symDMatrix'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/QuantGen/BGData">https://github.com/QuantGen/BGData</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/QuantGen/BGData/issues">https://github.com/QuantGen/BGData/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), BEDMatrix (&ge; 1.4.0), LinkedMatrix (&ge; 1.3.0),
symDMatrix (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, crochet (&ge; 2.1.0), bigmemory,
synchronicity, ff, bit</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.table (&ge; 1.9.6), lme4, SKAT, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-22 09:40:31 UTC; agrueneberg</td>
</tr>
<tr>
<td>Author:</td>
<td>Gustavo de los Campos [aut],
  Alexander Grueneberg [aut, cre],
  Paulino Perez [ctb],
  Ana Vazquez [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Grueneberg &lt;cran@agrueneberg.info&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 10:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='BGData-package'>A Suite of Packages for Analysis of Big Genomic Data</h2><span id='topic+BGData-package'></span>

<h3>Description</h3>

<p>Modern genomic datasets are big (large <em>n</em>), high-dimensional (large
<em>p</em>), and multi-layered. The challenges that need to be addressed are
memory requirements and computational demands. Our goal is to develop
software that will enable researchers to carry out analyses with big
genomic data within the R environment.
</p>


<h3>Details</h3>

<p>We have identified several approaches to tackle those challenges within R:
</p>

<ul>
<li><p> File-backed matrices: The data is stored in on the hard drive and
users can read in smaller chunks when they are needed.
</p>
</li>
<li><p> Linked arrays: For very large datasets a single file-backed array
may not be enough or convenient. A linked array is an array whose
content is distributed over multiple file-backed nodes.
</p>
</li>
<li><p> Multiple dispatch: Methods are presented to users so that they
can treat these arrays pretty much as if they were RAM arrays.
</p>
</li>
<li><p> Multi-level parallelism: Exploit multi-core and multi-node
computing.
</p>
</li>
<li><p> Inputs: Users can create these arrays from standard formats
(e.g., PLINK .bed).
</p>
</li></ul>

<p>The <code>BGData</code> package is an umbrella package that comprises several
packages: <code>BEDMatrix</code>, <code>LinkedMatrix</code>, and <code>symDMatrix</code>. It
features scalable and efficient computational methods for large genomic
datasets such as genome-wide association studies (GWAS) or genomic
relationship matrices (G matrix). It also contains a container class called
<code>BGData</code> that holds genotypes, sample information, and variant
information.
</p>


<h3>Example dataset</h3>

<p>The <code>extdata</code> folder contains example files that were generated from
the 250k SNP and phenotype data in
<a href="https://www.nature.com/articles/nature08800">Atwell et al. (2010)</a>.
Only the first 300 SNPs of chromosome 1, 2, and 3 were included to keep the
size of the example dataset small.
<a href="https://www.cog-genomics.org/plink2">PLINK</a> was used to convert the
data to <a href="https://www.cog-genomics.org/plink2/input#bed">.bed</a> and
<a href="https://www.cog-genomics.org/plink2/input#raw">.raw</a> files.
<code>FT10</code> has been chosen as a phenotype and is provided as an
<a href="https://www.cog-genomics.org/plink2/input#pheno">alternate phenotype
file</a>. The file is intentionally shuffled to demonstrate that the
additional phenotypes are put in the same order as the rest of the
phenotypes.
</p>


<h3>See Also</h3>

<p><code><a href="BEDMatrix.html#topic+BEDMatrix-package">BEDMatrix-package</a></code>,
<code><a href="LinkedMatrix.html#topic+LinkedMatrix-package">LinkedMatrix-package</a></code>, and
<code><a href="symDMatrix.html#topic+symDMatrix-package">symDMatrix-package</a></code> for an introduction to the
respective packages.
</p>
<p><code><a href="#topic+file-backed-matrices">file-backed-matrices</a></code> for more information on file-backed
matrices. <code><a href="#topic+multi-level-parallelism">multi-level-parallelism</a></code> for more information on
multi-level parallelism.
</p>

<hr>
<h2 id='as.BGData'>Convert Other Objects to BGData Objects</h2><span id='topic+as.BGData'></span><span id='topic+as.BGData.BEDMatrix'></span><span id='topic+as.BGData.ColumnLinkedMatrix'></span><span id='topic+as.BGData.RowLinkedMatrix'></span>

<h3>Description</h3>

<p>Converts other objects to <code>BGData</code> objects by loading supplementary
phenotypes and map files referenced by the object to be used for the sample
information and variant information, respectively.
</p>
<p>Currently supported are <code>BEDMatrix</code> objects, plain or nested in
<code>ColumnLinkedMatrix</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.BGData(x, alternatePhenotypeFile = NULL, ...)

## S3 method for class 'BEDMatrix'
as.BGData(x, alternatePhenotypeFile = NULL, ...)

## S3 method for class 'ColumnLinkedMatrix'
as.BGData(x, alternatePhenotypeFile = NULL,
  ...)

## S3 method for class 'RowLinkedMatrix'
as.BGData(x, alternatePhenotypeFile = NULL,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.BGData_+3A_x">x</code></td>
<td>

<p>An object. Currently supported are <code>BEDMatrix</code> objects, plain or
nested in <code>ColumnLinkedMatrix</code> objects.
</p>
</td></tr>
<tr><td><code id="as.BGData_+3A_alternatephenotypefile">alternatePhenotypeFile</code></td>
<td>

<p>Path to an
<a href="https://www.cog-genomics.org/plink2/input#pheno">alternate
phenotype file</a>.
</p>
</td></tr>
<tr><td><code id="as.BGData_+3A_...">...</code></td>
<td>

<p>Additional arguments to the <code>read.table</code> or <code>fread</code> call (if
data.table package is installed) call to parse the alternate pheno
file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The .ped and .raw formats only allows for a single phenotype. If more
phenotypes are required it is possible to store them in an
<a href="https://www.cog-genomics.org/plink2/input#pheno">alternate phenotype
file</a>. The path to such a file can be provided with
<code>alternatePhenotypeFile</code> and will be merged with the existing sample
information. The first and second columns of that file must contain family
and within-family IDs, respectively.
</p>
<p>For <code>BEDMatrix</code> objects: If a .fam file (which corresponds to the
first six columns of a .ped or .raw file) of the same name and in the same
directory as the .bed file exists, the sample information will be populated
with the data stored in that file. Otherwise a stub that only contains an
<code>IID</code> column populated with the rownames of <code>geno(x)</code> will be
generated. The same will happen for a .bim file for the variant
information.
</p>
<p>For <code>ColumnLinkedMatrix</code> objects: See the case for <code>BEDMatrix</code>
objects, but only the .fam file of the first node of the
<code>LinkedMatrix</code> will be read and used for the sample information, and
the .bim files of all nodes will be combined and used for the variant
information.
</p>


<h3>Value</h3>

<p>A <code>BGData</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readRAW">readRAW()</a></code> to convert text files to <code>BGData</code>
objects. <code><a href="#topic+BGData-class">BGData-class</a></code>,
<code><a href="BEDMatrix.html#topic+BEDMatrix-class">BEDMatrix-class</a></code>,
<code><a href="LinkedMatrix.html#topic+ColumnLinkedMatrix-class">ColumnLinkedMatrix-class</a></code> for more information
on the above mentioned classes. <code><a href="utils.html#topic+read.table">read.table</a></code> and
<code><a href="data.table.html#topic+fread">fread</a></code> to learn more about extra arguments that
can be passed via <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Path to example data
path &lt;- system.file("extdata", package = "BGData")

# Convert a single BEDMatrix object to a BGData object
chr1 &lt;- BEDMatrix::BEDMatrix(paste0(path, "/chr1.bed"))
bg1 &lt;- as.BGData(chr1)

# Convert multiple BEDMatrix objects in a ColumnLinkedMatrix to a BGData object
chr2 &lt;- BEDMatrix::BEDMatrix(paste0(path, "/chr2.bed"))
chr3 &lt;- BEDMatrix::BEDMatrix(paste0(path, "/chr3.bed"))
clm &lt;- ColumnLinkedMatrix(chr1, chr2, chr3)
bg2 &lt;- as.BGData(clm)

# Load additional (alternate) phenotypes
bg3 &lt;- as.BGData(clm, alternatePhenotypeFile = paste0(path, "/pheno.txt"))
</code></pre>

<hr>
<h2 id='BGData'>Creates a New BGData Instance</h2><span id='topic+BGData'></span>

<h3>Description</h3>

<p>This function constructs a new <code>BGData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BGData(geno, pheno = NULL, map = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BGData_+3A_geno">geno</code></td>
<td>

<p>A <code>geno</code> object that contains genotypes.
</p>
</td></tr>
<tr><td><code id="BGData_+3A_pheno">pheno</code></td>
<td>

<p>A <code>data.frame</code> that contains sample information (including
phenotypes). A stub that only contains a <code>sample_id</code> column
populated with either the rownames of <code>geno</code> or a sequence
starting with <code>sample_</code> will be generated if <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="BGData_+3A_map">map</code></td>
<td>

<p>A <code>data.frame</code> that contains variant information. A stub that only
contains a <code>variant_id</code> column populated with either the colnames
of <code>geno</code> or a sequence starting with <code>variant_</code> will be
generated if <code>NULL</code>
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+BGData-class">BGData-class</a></code> and <code><a href="#topic+geno-class">geno-class</a></code> for more
information on the above mentioned classes.
</p>

<hr>
<h2 id='BGData-class'>Container for Phenotype and Genotype Data</h2><span id='topic+BGData-class'></span><span id='topic+geno+2CBGData-method'></span><span id='topic+geno+3C-+2CBGData-method'></span><span id='topic+pheno+2CBGData-method'></span><span id='topic+pheno+3C-+2CBGData-method'></span><span id='topic+map+2CBGData-method'></span><span id='topic+map+3C-+2CBGData-method'></span>

<h3>Description</h3>

<p>The BGData class is a container for genotypes, sample information, and
variant information. The class is inspired by the <code>.bed/.fam/.bim</code>
(binary) and <code>.ped/.fam/.map</code> (text) phenotype/genotype file formats
of <a href="https://www.cog-genomics.org/plink2">PLINK</a>. It is used by several
functions of this package such as <code>GWAS</code> for performing a Genome Wide
Association Study or <code>getG</code> for calculating a genomic relationship
matrix.
</p>


<h3>Details</h3>

<p>There are several ways to create an instance of this class:
</p>

<ul>
<li><p> from arbitrary phenotype/genotype data using the <code>BGData</code>
constructor function.
</p>
</li>
<li><p> from a .bed file using <code>as.BGData</code> and <code>BEDMatrix</code>.
</p>
</li>
<li><p> from a previously saved <code>BGData</code> object using
<code>load.BGData</code>.
</p>
</li>
<li><p> from multiple files (even a mixture of different file types)
using <code>LinkedMatrix</code>.
</p>
</li>
<li><p> from a .raw file (or a .ped-like file) using
<code>readRAW</code>, <code>readRAW_matrix</code>, or
<code>readRAW_big.matrix</code>.
</p>
</li></ul>

<p>A .ped file can be recoded to a .raw file in
<a href="https://www.cog-genomics.org/plink2">PLINK</a> using <code>plink --file
    myfile --recodeA</code>, or converted to a .bed file using <code>plink --file
    myfile --make-bed</code>. Conversely, a .bed file can be transformed back to a
.ped file using <code>plink --bfile myfile --recode</code> or to a .raw file
using <code>plink --bfile myfile --recodeA</code> without losing information.
</p>


<h3>Accessors</h3>

<p>In the following code snippets, <code>x</code> is a BGData object.
</p>

<dl>
<dt><code>geno(x)</code>, <code>geno(x) &lt;- value</code>:</dt><dd>
<p>Get or set genotypes.
</p>
</dd>
<dt><code>pheno(x)</code>, <code>pheno(x) &lt;- value</code>:</dt><dd>
<p>Get or set sample information.
</p>
</dd>
<dt><code>map(x)</code>, <code>map(x) &lt;- value</code>:</dt><dd>
<p>Get or set variant information.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+BGData">BGData</a></code>, <code><a href="#topic+as.BGData">as.BGData</a></code>, <code><a href="#topic+load.BGData">load.BGData</a></code>,
<code><a href="#topic+readRAW">readRAW</a></code> to create <code>BGData</code> objects.
</p>
<p><code><a href="LinkedMatrix.html#topic+LinkedMatrix-class">LinkedMatrix-class</a></code> and
<code><a href="BEDMatrix.html#topic+BEDMatrix-class">BEDMatrix-class</a></code> for more information on the above
mentioned classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(data = rnorm(100), nrow = 10, ncol = 10)
Y &lt;- data.frame(y = runif(10))
MAP &lt;- data.frame(means = colMeans(X), freqNA = colMeans(is.na(X)))
DATA &lt;- BGData(geno = X, pheno = Y, map = MAP)

dim(geno(DATA))
head(pheno(DATA))
head(map(DATA))
</code></pre>

<hr>
<h2 id='chunkedApply'>Applies a Function on Each Row or Column of a File-Backed Matrix</h2><span id='topic+chunkedApply'></span>

<h3>Description</h3>

<p>Similar to <code>apply</code>, but designed for file-backed matrices. The
function brings chunks of an object into physical memory by taking subsets,
and applies a function on either the rows or the columns of the chunks
using an optimized version of <code>apply</code>. If <code>nCores</code> is greater
than 1, the function will be applied in parallel using <code>mclapply</code>. In
that case the subsets of the object are taken on the slaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunkedApply(X, MARGIN, FUN, i = seq_len(nrow(X)),
  j = seq_len(ncol(X)), chunkSize = 5000L,
  nCores = getOption("mc.cores", 2L), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunkedApply_+3A_x">X</code></td>
<td>

<p>A file-backed matrix, typically the genotypes of a <code>BGData</code>
object.
</p>
</td></tr>
<tr><td><code id="chunkedApply_+3A_margin">MARGIN</code></td>
<td>

<p>The subscripts which the function will be applied over. 1 indicates
rows, 2 indicates columns.
</p>
</td></tr>
<tr><td><code id="chunkedApply_+3A_fun">FUN</code></td>
<td>

<p>The function to be applied.
</p>
</td></tr>
<tr><td><code id="chunkedApply_+3A_i">i</code></td>
<td>

<p>Indicates which rows of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all rows are used.
</p>
</td></tr>
<tr><td><code id="chunkedApply_+3A_j">j</code></td>
<td>

<p>Indicates which columns of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all columns are used.
</p>
</td></tr>
<tr><td><code id="chunkedApply_+3A_chunksize">chunkSize</code></td>
<td>

<p>The number of rows or columns of <code>X</code> that are brought into
physical memory for processing per core. If <code>NULL</code>, all elements
in <code>i</code> or <code>j</code> are used. Defaults to 5000.
</p>
</td></tr>
<tr><td><code id="chunkedApply_+3A_ncores">nCores</code></td>
<td>

<p>The number of cores (passed to <code>mclapply</code>). Defaults to the number
of cores as detected by <code>detectCores</code>.
</p>
</td></tr>
<tr><td><code id="chunkedApply_+3A_verbose">verbose</code></td>
<td>

<p>Whether progress updates will be posted. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="chunkedApply_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the <code>apply</code> like function.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+file-backed-matrices">file-backed-matrices</a></code> for more information on file-backed
matrices. <code><a href="#topic+multi-level-parallelism">multi-level-parallelism</a></code> for more information on
multi-level parallelism. <code><a href="#topic+BGData-class">BGData-class</a></code> for more information on
the <code>BGData</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Restrict number of cores to 1 on Windows
if (.Platform$OS.type == "windows") {
    options(mc.cores = 1)
}

# Load example data
bg &lt;- BGData:::loadExample()

# Compute standard deviation of columns
chunkedApply(X = geno(bg), MARGIN = 2, FUN = sd)
</code></pre>

<hr>
<h2 id='chunkedMap'>Applies a Function on Each Chunk of a File-Backed Matrix</h2><span id='topic+chunkedMap'></span>

<h3>Description</h3>

<p>Similar to <code>lapply</code>, but designed for file-backed matrices. The
function brings chunks of an object into physical memory by taking subsets,
and applies a function on them. If <code>nCores</code> is greater than 1, the
function will be applied in parallel using <code>mclapply</code>. In that case
the subsets of the object are taken on the slaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunkedMap(X, FUN, i = seq_len(nrow(X)), j = seq_len(ncol(X)),
  chunkBy = 2L, chunkSize = 5000L, nCores = getOption("mc.cores",
  2L), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunkedMap_+3A_x">X</code></td>
<td>

<p>A file-backed matrix, typically the genotypes of a <code>BGData</code>
object.
</p>
</td></tr>
<tr><td><code id="chunkedMap_+3A_fun">FUN</code></td>
<td>

<p>The function to be applied on each chunk.
</p>
</td></tr>
<tr><td><code id="chunkedMap_+3A_i">i</code></td>
<td>

<p>Indicates which rows of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all rows are used.
</p>
</td></tr>
<tr><td><code id="chunkedMap_+3A_j">j</code></td>
<td>

<p>Indicates which columns of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all columns are used.
</p>
</td></tr>
<tr><td><code id="chunkedMap_+3A_chunkby">chunkBy</code></td>
<td>

<p>Whether to extract chunks by rows (1) or by columns (2). Defaults to
columns (2).
</p>
</td></tr>
<tr><td><code id="chunkedMap_+3A_chunksize">chunkSize</code></td>
<td>

<p>The number of rows or columns of <code>X</code> that are brought into
physical memory for processing per core. If <code>NULL</code>, all elements
in <code>i</code> or <code>j</code> are used. Defaults to 5000.
</p>
</td></tr>
<tr><td><code id="chunkedMap_+3A_ncores">nCores</code></td>
<td>

<p>The number of cores (passed to <code>mclapply</code>). Defaults to the number
of cores as detected by <code>detectCores</code>.
</p>
</td></tr>
<tr><td><code id="chunkedMap_+3A_verbose">verbose</code></td>
<td>

<p>Whether progress updates will be posted. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="chunkedMap_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the
<code>apply</code> like function.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+file-backed-matrices">file-backed-matrices</a></code> for more information on file-backed
matrices. <code><a href="#topic+multi-level-parallelism">multi-level-parallelism</a></code> for more information on
multi-level parallelism. <code><a href="#topic+BGData-class">BGData-class</a></code> for more information on
the <code>BGData</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Restrict number of cores to 1 on Windows
if (.Platform$OS.type == "windows") {
    options(mc.cores = 1)
}

# Load example data
bg &lt;- BGData:::loadExample()

# Compute column sums of each chunk
chunkedMap(X = geno(bg), FUN = colSums)
</code></pre>

<hr>
<h2 id='file-backed-matrices'>File-Backed Matrices</h2><span id='topic+file-backed-matrices'></span>

<h3>Description</h3>

<p>Functions with the <code>chunkSize</code> parameter work best with file-backed
matrices such as <code>BEDMatrix</code> objects. To avoid loading the whole,
potentially very large matrix into memory, these functions will load chunks
of the file-backed matrix into memory and perform the operations on one
chunk at a time. The size of the chunks is determined by the
<code>chunkSize</code> parameter. Care must be taken to not set <code>chunkSize</code>
too high to avoid memory shortage, particularly when combined with parallel
computing.
</p>


<h3>See Also</h3>

<p><code><a href="BEDMatrix.html#topic+BEDMatrix-class">BEDMatrix-class</a></code> as an example of a file-backed
matrix.
</p>

<hr>
<h2 id='findRelated'>Find related individuals in a relationship matrix</h2><span id='topic+findRelated'></span><span id='topic+findRelated.matrix'></span><span id='topic+findRelated.symDMatrix'></span>

<h3>Description</h3>

<p>Find related individuals in a relationship matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findRelated(x, ...)

## S3 method for class 'matrix'
findRelated(x, cutoff = 0.03, ...)

## S3 method for class 'symDMatrix'
findRelated(x, cutoff = 0.03, verbose = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findRelated_+3A_x">x</code></td>
<td>

<p>A matrix-like object with dimnames.
</p>
</td></tr>
<tr><td><code id="findRelated_+3A_...">...</code></td>
<td>

<p>Additional arguments for methods.
</p>
</td></tr>
<tr><td><code id="findRelated_+3A_cutoff">cutoff</code></td>
<td>

<p>The cutoff between 0 and 1 for related individuals to be included in
the output. Defaults to 0.03.
</p>
</td></tr>
<tr><td><code id="findRelated_+3A_verbose">verbose</code></td>
<td>

<p>Whether progress updates will be posted. Defaults to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of names or indices of related individuals.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>matrix</code>: Find related individuals in matrices
</p>
</li>
<li> <p><code>symDMatrix</code>: Find related individuals in symDMatrix objects
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load example data
bg &lt;- BGData:::loadExample()

G &lt;- getG(geno(bg))
findRelated(G)
</code></pre>

<hr>
<h2 id='FWD'>Performs Forward Regressions</h2><span id='topic+FWD'></span>

<h3>Description</h3>

<p>Performs forward regression of <code>y</code> on the columns of <code>X</code>.
Predictors are added, one at a time, each time adding the one that produces
the largest reduction in the residual sum of squares (RSS). The function
returns estimates and summaries for the entire forward search. This
function performs a similar search than that of <code>step(,
        direction='forward')</code>, however, <code>FWD()</code> is optimized for
computational speed for linear models with very large sample size. To
achieve fast computations, the software first computes the sufficient
statistics X'X and X'y. At each step, the function first finds the
predictor that produces the largest reduction in the sum of squares (this
can be derived from X'X, X'y and the current solution of effects), and then
updates the estimates of effects for the resulting model using Gauss Seidel
iterations performed on the linear system (X'X)b=X'y, iterating only over
the elements of b that are active in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FWD(y, X, df = 20, tol = 1e-7, maxIter = 1000, centerImpute = TRUE,
    verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FWD_+3A_y">y</code></td>
<td>

<p>The response vector (numeric nx1).
</p>
</td></tr>
<tr><td><code id="FWD_+3A_x">X</code></td>
<td>

<p>An (nxp) numeric matrix. Columns are the features (aka predictors)
considered in the forward search. The rows of <code>X</code> must be matched
to the entries of <code>y</code>.
</p>
</td></tr>
<tr><td><code id="FWD_+3A_df">df</code></td>
<td>

<p>Defines the maximum number of predictors to be included in the model.
For complete forward search, set <code>df = ncol(X)</code>.
</p>
</td></tr>
<tr><td><code id="FWD_+3A_tol">tol</code></td>
<td>

<p>A tolerance parameter to control when to stop the Gauss Seidel
algorithm.
</p>
</td></tr>
<tr><td><code id="FWD_+3A_maxiter">maxIter</code></td>
<td>

<p>The maximum number of iterations for the Gauss Seidel algorithm (only
used when the algorithm is not stopped by the tolerance parameter).
</p>
</td></tr>
<tr><td><code id="FWD_+3A_centerimpute">centerImpute</code></td>
<td>

<p>Whether to center the columns of <code>X</code> and impute the missing values
with the column means.
</p>
</td></tr>
<tr><td><code id="FWD_+3A_verbose">verbose</code></td>
<td>

<p>Use <code>verbose = TRUE</code> to print summaries of the forward search.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two entries:
</p>

<ul>
<li> <p><code>B</code>: (pxdf+1) includes the estimated effects for each
predictor (rows) at each step of the forward search (df, in columns).
</p>
</li>
<li> <p><code>path</code>: A data frame providing the order in which variables
were added to the model (<code>variable</code>) and statistics for each step
of the forward search (<code>RSS</code>, <code>LogLik</code>, <code>VARE</code> (the
residual variance), <code>DF</code>, <code>AIC</code>, and <code>BIC</code>).
</p>
</li></ul>


<hr>
<h2 id='geno'>Getting/Setting Genotypes, Sample Information, and Variant Information</h2><span id='topic+geno'></span><span id='topic+geno+3C-'></span><span id='topic+pheno'></span><span id='topic+pheno+3C-'></span><span id='topic+map'></span><span id='topic+map+3C-'></span>

<h3>Description</h3>

<p>A set of generic functions for getting/setting the genotypes, sample
information, and variant information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno(x)
geno(x) &lt;- value

pheno(x)
pheno(x) &lt;- value

map(x)
map(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno_+3A_x">x</code></td>
<td>

<p>The object from/on which to get/set genotypes, sample information, and
variant information. Typically a <code>BGData</code> object.
</p>
</td></tr>
<tr><td><code id="geno_+3A_value">value</code></td>
<td>

<p>Typically a <code>geno</code> object for the <code>geno</code> setter.
</p>
<p>Typically a <code>data.frame</code> object for the <code>pheno</code> setter.
</p>
<p>Typically a <code>data.frame</code> object for the <code>map</code> setter.
</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+BGData-class">BGData-class</a></code>
</p>
</li>
<li> <p><code><a href="#topic+geno-class">geno-class</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load example data
bg &lt;- BGData:::loadExample()

# Access genotypes
geno(bg)

# Access sample information
pheno(bg)

# Access variant information
map(bg)
</code></pre>

<hr>
<h2 id='geno-class'>An Abstract S4 Class Union of Matrix-Like Types</h2><span id='topic+geno-class'></span>

<h3>Description</h3>

<p><code>geno</code> is a class union of several matrix-like types, many of
them suitable for very large datasets.
</p>
<p>Currently supported are <code>LinkedMatrix</code>, <code>BEDMatrix</code>,
<code>big.matrix</code>,<code>ff_matrix</code>, and <code>matrix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="LinkedMatrix.html#topic+LinkedMatrix-class">LinkedMatrix-class</a></code>,
<code><a href="BEDMatrix.html#topic+BEDMatrix-class">BEDMatrix-class</a></code>,
<code><a href="bigmemory.html#topic+big.matrix-class">big.matrix-class</a></code>, <code><a href="ff.html#topic+ff">ff</a></code>, and
<code><a href="base.html#topic+matrix">matrix</a></code> for more information on each matrix-like type.
</p>
<p><code><a href="#topic+BGData-class">BGData-class</a></code> for more information on the <code>BGData</code> class,
in particular its <code>geno</code> accessor that accepts <code>geno</code> objects.
</p>

<hr>
<h2 id='getG'>Computes a Genomic Relationship Matrix</h2><span id='topic+getG'></span>

<h3>Description</h3>

<p>Computes a positive semi-definite symmetric genomic relation matrix G=XX'
offering options for centering and scaling the columns of <code>X</code>
beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getG(X, center = TRUE, scale = TRUE, impute = TRUE, scaleG = TRUE,
  minVar = 1e-05, i = seq_len(nrow(X)), j = seq_len(ncol(X)), i2 = NULL,
  chunkSize = 5000L, nCores = getOption("mc.cores", 2L), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getG_+3A_x">X</code></td>
<td>

<p>A matrix-like object, typically the genotypes of a <code>BGData</code>
object.
</p>
</td></tr>
<tr><td><code id="getG_+3A_center">center</code></td>
<td>

<p>Either a logical value or a numeric vector of length equal to the
number of columns of <code>X</code>. Numeric vector required if <code>i2</code> is
used. If <code>FALSE</code>, no centering is done. Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getG_+3A_scale">scale</code></td>
<td>

<p>Either a logical value or a numeric vector of length equal to the
number of columns of <code>X</code>. Numeric vector required if <code>i2</code> is
used. If <code>FALSE</code>, no scaling is done. Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getG_+3A_impute">impute</code></td>
<td>

<p>Indicates whether missing values should be imputed. Defaults to
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getG_+3A_scaleg">scaleG</code></td>
<td>

<p>Whether XX' should be scaled. Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getG_+3A_minvar">minVar</code></td>
<td>

<p>Columns with variance lower than this value will not be used in the
computation (only if <code>scale</code> is not <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="getG_+3A_i">i</code></td>
<td>

<p>Indicates which rows of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all rows are used.
</p>
</td></tr>
<tr><td><code id="getG_+3A_j">j</code></td>
<td>

<p>Indicates which columns of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all columns are used.
</p>
</td></tr>
<tr><td><code id="getG_+3A_i2">i2</code></td>
<td>

<p>Indicates which rows should be used to compute a block of the genomic
relationship matrix. Will compute XY' where X is determined by <code>i</code>
and <code>j</code> and Y by <code>i2</code> and <code>j</code>. Can be integer, boolean,
or character. If <code>NULL</code>, the whole genomic relationship matrix XX'
is computed. Defaults to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="getG_+3A_chunksize">chunkSize</code></td>
<td>

<p>The number of columns of <code>X</code> that are brought into physical memory
for processing per core. If <code>NULL</code>, all columns of <code>X</code> are
used. Defaults to 5000.
</p>
</td></tr>
<tr><td><code id="getG_+3A_ncores">nCores</code></td>
<td>

<p>The number of cores (passed to <code>mclapply</code>). Defaults to the number
of cores as detected by <code>detectCores</code>.
</p>
</td></tr>
<tr><td><code id="getG_+3A_verbose">verbose</code></td>
<td>

<p>Whether progress updates will be posted. Defaults to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>center = FALSE</code>, <code>scale = FALSE</code> and <code>scaleG = FALSE</code>,
<code>getG</code> produces the same outcome than <code>tcrossprod</code>.
</p>


<h3>Value</h3>

<p>A positive semi-definite symmetric numeric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+file-backed-matrices">file-backed-matrices</a></code> for more information on file-backed
matrices. <code><a href="#topic+multi-level-parallelism">multi-level-parallelism</a></code> for more information on
multi-level parallelism. <code><a href="#topic+BGData-class">BGData-class</a></code> for more information on
the <code>BGData</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Restrict number of cores to 1 on Windows
if (.Platform$OS.type == "windows") {
    options(mc.cores = 1)
}

# Load example data
bg &lt;- BGData:::loadExample()

# Compute a scaled genomic relationship matrix from centered and scaled
# genotypes
g1 &lt;- getG(X = geno(bg))

# Disable scaling of G
g2 &lt;- getG(X = geno(bg), scaleG = FALSE)

# Disable centering of genotypes
g3 &lt;- getG(X = geno(bg), center = FALSE)

# Disable scaling of genotypes
g4 &lt;- getG(X = geno(bg), scale = FALSE)

# Provide own scales
scales &lt;- chunkedApply(X = geno(bg), MARGIN = 2, FUN = sd)
g4 &lt;- getG(X = geno(bg), scale = scales)

# Provide own centers
centers &lt;- chunkedApply(X = geno(bg), MARGIN = 2, FUN = mean)
g5 &lt;- getG(X = geno(bg), center = centers)

# Only use the first 50 individuals (useful to account for population structure)
g6 &lt;- getG(X = geno(bg), i = 1:50)

# Only use the first 100 markers (useful to ignore some markers)
g7 &lt;- getG(X = geno(bg), j = 1:100)

# Compute unscaled G matrix by combining blocks of $XX_{i2}'$ where $X_{i2}$ is
# a horizontal partition of X. This is useful for distributed computing as each
# block can be computed in parallel. Centers and scales need to be precomputed.
block1 &lt;- getG(X = geno(bg), i2 = 1:100, center = centers, scale = scales)
block2 &lt;- getG(X = geno(bg), i2 = 101:199, center = centers, scale = scales)
g8 &lt;- cbind(block1, block2)

# Compute unscaled G matrix by combining blocks of $X_{i}X_{i2}'$ where both
# $X_{i}$ and $X_{i2}$ are horizontal partitions of X. Similarly to the example
# above, this is useful for distributed computing, in particular to compute
# very large G matrices. Centers and scales need to be precomputed. This
# approach is similar to the one taken by the symDMatrix package, but the
# symDMatrix package adds memory-mapped blocks, only stores the upper side of
# the triangular matrix, and provides a type that allows for indexing as if the
# full G matrix is in memory.
block11 &lt;- getG(X = geno(bg), i = 1:100, i2 = 1:100, center = centers, scale = scales)
block12 &lt;- getG(X = geno(bg), i = 1:100, i2 = 101:199, center = centers, scale = scales)
block21 &lt;- getG(X = geno(bg), i = 101:199, i2 = 1:100, center = centers, scale = scales)
block22 &lt;- getG(X = geno(bg), i = 101:199, i2 = 101:199, center = centers, scale = scales)
g9 &lt;- rbind(
    cbind(block11, block12),
    cbind(block21, block22)
)
</code></pre>

<hr>
<h2 id='getG_symDMatrix'>Computes a Very Large Genomic Relationship Matrix</h2><span id='topic+getG_symDMatrix'></span>

<h3>Description</h3>

<p>Computes a positive semi-definite symmetric genomic relation matrix G=XX'
offering options for centering and scaling the columns of <code>X</code>
beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getG_symDMatrix(X, center = TRUE, scale = TRUE, impute = TRUE, scaleG = TRUE,
  minVar = 1e-05, blockSize = 5000L,
  folderOut = paste0("symDMatrix_", randomString()), vmode = "double",
  i = seq_len(nrow(X)), j = seq_len(ncol(X)), chunkSize = 5000L,
  nCores = getOption("mc.cores", 2L), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getG_symDMatrix_+3A_x">X</code></td>
<td>

<p>A matrix-like object, typically the genotypes of a <code>BGData</code>
object.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_center">center</code></td>
<td>

<p>Either a logical value or a numeric vector of length equal to the
number of columns of <code>X</code>. If <code>FALSE</code>, no centering is done.
Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_scale">scale</code></td>
<td>

<p>Either a logical value or a numeric vector of length equal to the
number of columns of <code>X</code>. If <code>FALSE</code>, no scaling is done.
Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_impute">impute</code></td>
<td>

<p>Indicates whether missing values should be imputed. Defaults to
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_scaleg">scaleG</code></td>
<td>

<p>TRUE/FALSE whether xx' must be scaled.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_minvar">minVar</code></td>
<td>

<p>Columns with variance lower than this value will not be used in the
computation (only if <code>scale</code> is not <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_blocksize">blockSize</code></td>
<td>

<p>The number of rows and columns of each block. If <code>NULL</code>, a single
block of the same length as <code>i</code> will be created. Defaults to 5000.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_folderout">folderOut</code></td>
<td>

<p>The path to the folder where to save the <code>symDMatrix</code> object.
Defaults to a random string prefixed with &quot;symDMatrix_&quot;.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_vmode">vmode</code></td>
<td>

<p>vmode of <code>ff</code> objects.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_i">i</code></td>
<td>

<p>Indicates which rows of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all rows are used.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_j">j</code></td>
<td>

<p>Indicates which columns of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all columns are used.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_chunksize">chunkSize</code></td>
<td>

<p>The number of columns of <code>X</code> that are brought into physical memory
for processing per core. If <code>NULL</code>, all columns of <code>X</code> are
used. Defaults to 5000.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_ncores">nCores</code></td>
<td>

<p>The number of cores (passed to <code>mclapply</code>). Defaults to the number
of cores as detected by <code>detectCores</code>.
</p>
</td></tr>
<tr><td><code id="getG_symDMatrix_+3A_verbose">verbose</code></td>
<td>

<p>Whether progress updates will be posted. Defaults to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Even very large genomic relationship matrices are supported by partitioning
<code>X</code> into blocks and calling <code>getG</code> on these blocks. This function
performs the block computations sequentially, which may be slow. In an HPC
environment, performance can be improved by manually distributing these
operations to different nodes.
</p>


<h3>Value</h3>

<p>A <code>symDMatrix</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multi-level-parallelism">multi-level-parallelism</a></code> for more information on multi-level
parallelism. <code><a href="symDMatrix.html#topic+symDMatrix-class">symDMatrix-class</a></code> and
<code><a href="#topic+BGData-class">BGData-class</a></code> for more information on the <code>BGData</code> class.
<code><a href="#topic+getG">getG</a></code> to learn more about the underlying method.
</p>

<hr>
<h2 id='GWAS'>Performs Single Marker Regressions Using BGData Objects</h2><span id='topic+GWAS'></span>

<h3>Description</h3>

<p>Implements single marker regressions. The regression model includes all the
covariates specified in the right-hand-side of the <code>formula</code> plus one
column of the genotypes at a time. The data from the association tests is
obtained from a <code>BGData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GWAS(formula, data, method = "lsfit", i = seq_len(nrow(geno(data))),
  j = seq_len(ncol(geno(data))), chunkSize = 5000L,
  nCores = getOption("mc.cores", 2L), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GWAS_+3A_formula">formula</code></td>
<td>

<p>The formula for the GWAS model without the variant, e.g. <code>y ~ 1</code>
or <code>y ~ factor(sex) + age</code>. The variables included in the formula
must be column names in the sample information of the <code>BGData</code>
object.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_data">data</code></td>
<td>

<p>A <code>BGData</code> object.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_method">method</code></td>
<td>

<p>The regression method to be used. Currently, the following methods are
implemented: <code>rayOLS</code> (see below), <code>lsfit</code>, <code>lm</code>,
<code>lm.fit</code>, <code>glm</code>, <code>lmer</code>, and <code>SKAT</code>. Defaults to
<code>lsfit</code>.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_i">i</code></td>
<td>

<p>Indicates which rows of the genotypes should be used. Can be integer,
boolean, or character. By default, all rows are used.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_j">j</code></td>
<td>

<p>Indicates which columns of the genotypes should be used. Can be
integer, boolean, or character. By default, all columns are used.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_chunksize">chunkSize</code></td>
<td>

<p>The number of columns of the genotypes that are brought into physical
memory for processing per core. If <code>NULL</code>, all elements in
<code>j</code> are used. Defaults to 5000.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_ncores">nCores</code></td>
<td>

<p>The number of cores (passed to <code>mclapply</code>). Defaults to the number
of cores as detected by <code>detectCores</code>.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_verbose">verbose</code></td>
<td>

<p>Whether progress updates will be posted. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_...">...</code></td>
<td>

<p>Additional arguments for chunkedApply and regression method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rayOLS</code> method is a regression through the origin that can only
be used with a <code>y ~ 1</code> formula, i.e. it only allows for one
quantitative response variable <code>y</code> and one variant at a time as an
explanatory variable (the variant is not included in the formula, hence
<code>1</code> is used as a dummy). If covariates are needed, consider
preadjustment of <code>y</code>. Among the provided methods, it is by far the
fastest.
</p>
<p>Some regression methods may require the data to not contain columns with
variance 0 or too many missing values. We suggest running <code>summarize</code>
to detect variants that do not clear the desired minor-allele frequency and
rate of missing genotype calls, and filtering these variants out using the
<code>j</code> parameter of the <code>GWAS</code> function (see example below).
</p>


<h3>Value</h3>

<p>The same matrix that would be returned by <code>coef(summary(model))</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+file-backed-matrices">file-backed-matrices</a></code> for more information on file-backed
matrices. <code><a href="#topic+multi-level-parallelism">multi-level-parallelism</a></code> for more information on
multi-level parallelism. <code><a href="#topic+BGData-class">BGData-class</a></code> for more information on
the <code>BGData</code> class. <code><a href="stats.html#topic+lsfit">lsfit</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+lm.fit">lm.fit</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>, and
<code><a href="SKAT.html#topic+SKAT">SKAT</a></code> for more information on regression methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Restrict number of cores to 1 on Windows
if (.Platform$OS.type == "windows") {
    options(mc.cores = 1)
}

# Load example data
bg &lt;- BGData:::loadExample()

# Detect variants that do not pass MAF and missingness thresholds
summaries &lt;- summarize(geno(bg))
maf &lt;- ifelse(summaries$allele_freq &gt; 0.5, 1 - summaries$allele_freq,
    summaries$allele_freq)
exclusions &lt;- maf &lt; 0.01 | summaries$freq_na &gt; 0.05

# Perform a single marker regression
res1 &lt;- GWAS(formula = FT10 ~ 1, data = bg, j = !exclusions)

# Draw a Manhattan plot
plot(-log10(res1[, 4]))

# Use lm instead of lsfit (the default)
res2 &lt;- GWAS(formula = FT10 ~ 1, data = bg, method = "lm", j = !exclusions)

# Use glm instead of lsfit (the default)
y &lt;- pheno(bg)$FT10
pheno(bg)$FT10.01 &lt;- y &gt; quantile(y, 0.8, na.rm = TRUE)
res3 &lt;- GWAS(formula = FT10.01 ~ 1, data = bg, method = "glm", j = !exclusions)

# Perform a single marker regression on the first 50 markers (useful for
# distributed computing)
res4 &lt;- GWAS(formula = FT10 ~ 1, data = bg, j = 1:50)
</code></pre>

<hr>
<h2 id='load.BGData'>Loads BGData (and Other) Objects from .RData Files</h2><span id='topic+load.BGData'></span>

<h3>Description</h3>

<p>This function is similar to <code>load</code>, but also initializes the different
types of objects that can be used as genotypes in a <code>BGData</code> object.
</p>
<p>Currently supported are <code>ff_matrix</code>, <code>big.matrix</code>, and
<code>BEDMatrix</code> objects. If the object is of type <code>LinkedMatrix</code>, all
nodes will be initialized with their appropriate method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.BGData(file, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.BGData_+3A_file">file</code></td>
<td>

<p>The name of the .RData file to be loaded.
</p>
</td></tr>
<tr><td><code id="load.BGData_+3A_envir">envir</code></td>
<td>

<p>The environment where to load the data.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+BGData-class">BGData-class</a></code>, <code><a href="ff.html#topic+ff">ff</a></code>,
<code><a href="bigmemory.html#topic+big.matrix-class">big.matrix-class</a></code>,
<code><a href="BEDMatrix.html#topic+BEDMatrix-class">BEDMatrix-class</a></code>, and
<code><a href="LinkedMatrix.html#topic+LinkedMatrix-class">LinkedMatrix-class</a></code> for more information on the
above mentioned classes.
</p>

<hr>
<h2 id='multi-level-parallelism'>Multi-Level Parallelism</h2><span id='topic+multi-level-parallelism'></span>

<h3>Description</h3>

<p>Functions with the <code>nCores</code>, <code>i</code>, and <code>j</code> parameters provide
capabilities for both parallel and distributed computing.
</p>
<p>For parallel computing, <code>nCores</code> determines the number of cores the
code is run on. Memory usage can be an issue for higher values of
<code>nCores</code> as R is not particularly memory-efficient. As a rule of
thumb, at least around <code>(nCores * object_size(chunk)) +
    object_size(result)</code> MB of total memory will be needed for operations
on file-backed matrices, not including potential copies of your data that
might be created (for example <code>lsfit</code> runs <code>cbind(1, X)</code>).
<code>i</code> and <code>j</code> can be used to include or exclude certain rows or
columns. Internally, the <code>mclapply</code> function is used and therefore
parallel computing will not work on Windows machines.
</p>
<p>For distributed computing, <code>i</code> and <code>j</code> determine the subset of
the input matrix that the code runs on. In an HPC environment, this can be
used not just to include or exclude certain rows or columns, but also to
partition the task among many nodes rather than cores. Scheduler-specific
code and code to aggregate the results need to be written by the user. It
is recommended to set <code>nCores</code> to <code>1</code> as nodes are often cheaper
than cores.
</p>


<h3>See Also</h3>

<p><code><a href="parallel.html#topic+mclapply">mclapply</a></code> to learn more about the function used to
implement parallel computing. <code><a href="parallel.html#topic+detectCores">detectCores</a></code> to detect
the number of available cores.
</p>

<hr>
<h2 id='orderedMerge'>Merge Two Data Frames Keeping the Order of the First</h2><span id='topic+orderedMerge'></span>

<h3>Description</h3>

<p>This is a simplified version of <code>merge</code> useful for merging additional
data into a <code>BGData</code> object while keeping the order of the data in the
<code>BGData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderedMerge(x, y, by = c(1L, 2L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderedMerge_+3A_x">x</code></td>
<td>

<p>Data frame
</p>
</td></tr>
<tr><td><code id="orderedMerge_+3A_y">y</code></td>
<td>

<p>Data frame
</p>
</td></tr>
<tr><td><code id="orderedMerge_+3A_by">by</code></td>
<td>

<p>Specifications of the columns used for merging. Defaults to the first
two columns of the data frame, which traditionally has the family ID
and the individual ID.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Merged data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BGData-class">BGData-class</a></code> for more information on the <code>BGData</code> class.
</p>

<hr>
<h2 id='preprocess'>Center, scale, and impute data</h2><span id='topic+preprocess'></span>

<h3>Description</h3>

<p>A faster version of <code><a href="base.html#topic+scale">scale</a></code> with a similar interface that
also allows for imputation. The main difference is that this version scales
by the standard deviation regardless of whether centering is enabled or
not. If centering is enabled, missing values are imputed by 0, otherwise by
the mean of the column that contains the value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess(X, center = FALSE, scale = FALSE, impute = FALSE,
  nCores = getOption("mc.cores", 2L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_+3A_x">X</code></td>
<td>

<p>A numeric matrix.
</p>
</td></tr>
<tr><td><code id="preprocess_+3A_center">center</code></td>
<td>

<p>Either a logical value or numeric vector of length equal to the number
of columns of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="preprocess_+3A_scale">scale</code></td>
<td>

<p>Either a logical value or numeric vector of length equal to the number
of columns of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="preprocess_+3A_impute">impute</code></td>
<td>

<p>Indicates whether missing values should be imputed.
</p>
</td></tr>
<tr><td><code id="preprocess_+3A_ncores">nCores</code></td>
<td>

<p>The number of cores (passed to <code>mclapply</code>). Defaults to the number
of cores as detected by <code>detectCores</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The centered, scaled, and imputed matrix.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>, which this function tries to improve upon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data
bg &lt;- BGData:::loadExample()

# Center and scale genotypes
W &lt;- preprocess(as.matrix(geno(bg)), center = TRUE, scale = TRUE)
</code></pre>

<hr>
<h2 id='readRAW'>Creates a BGData Object From a .raw File or a .ped-Like File</h2><span id='topic+readRAW'></span><span id='topic+readRAW_matrix'></span><span id='topic+readRAW_big.matrix'></span>

<h3>Description</h3>

<p>Creates a <code>BGData</code> object from a .raw file (generated with
<code>--recodeA</code> in <a href="https://www.cog-genomics.org/plink2">PLINK</a>).
Other text-based file formats are supported as well by tweaking some of the
parameters as long as the records of individuals are in rows, and
phenotypes, covariates and markers are in columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readRAW(fileIn, header = TRUE, dataType = integer(), n = NULL,
  p = NULL, sep = "", na.strings = "NA", nColSkip = 6L,
  idCol = c(1L, 2L), nNodes = NULL, linked.by = "rows",
  folderOut = paste0("BGData_", sub("\\.[[:alnum:]]+$", "",
  basename(fileIn))), outputType = "byte", dimorder = if (linked.by ==
  "rows") 2L:1L else 1L:2L, verbose = FALSE)

readRAW_matrix(fileIn, header = TRUE, dataType = integer(), n = NULL,
  p = NULL, sep = "", na.strings = "NA", nColSkip = 6L,
  idCol = c(1L, 2L), verbose = FALSE)

readRAW_big.matrix(fileIn, header = TRUE, dataType = integer(),
  n = NULL, p = NULL, sep = "", na.strings = "NA", nColSkip = 6L,
  idCol = c(1L, 2L), folderOut = paste0("BGData_",
  sub("\\.[[:alnum:]]+$", "", basename(fileIn))), outputType = "char",
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readRAW_+3A_filein">fileIn</code></td>
<td>

<p>The path to the plaintext file.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_header">header</code></td>
<td>

<p>Whether <code>fileIn</code> contains a header. Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_datatype">dataType</code></td>
<td>

<p>The coding type of genotypes in <code>fileIn</code>. Use <code>integer()</code> or
<code>double()</code> for numeric coding. Alpha-numeric coding is currently
not supported for <code>readRAW</code> and <code>readRAW_big.matrix</code>: use the
<code>--recodeA</code> option of PLINK to convert the .ped file into a .raw
file. Defaults to <code>integer()</code>.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_n">n</code></td>
<td>

<p>The number of individuals. Auto-detect if <code>NULL</code>. Defaults to
<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_p">p</code></td>
<td>

<p>The number of markers. Auto-detect if <code>NULL</code>. Defaults to
<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_sep">sep</code></td>
<td>

<p>The field separator character. Values on each line of the file are
separated by this character. If <code>sep = ""</code> (the default for
<code>readRAW</code> the separator is &quot;white space&quot;, that is one or more
spaces, tabs, newlines or carriage returns.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_na.strings">na.strings</code></td>
<td>

<p>The character string used in the plaintext file to denote missing
value. Defaults to <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_ncolskip">nColSkip</code></td>
<td>

<p>The number of columns to be skipped to reach the genotype information
in the file. Defaults to <code>6</code>.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_idcol">idCol</code></td>
<td>

<p>The index of the ID column. If more than one index is given, both
columns will be concatenated with &quot;_&quot;. Defaults to <code>c(1, 2)</code>, i.e.
a concatenation of the first two columns.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_nnodes">nNodes</code></td>
<td>

<p>The number of nodes to create. Auto-detect if <code>NULL</code>. Defaults to
<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_linked.by">linked.by</code></td>
<td>

<p>If <code>columns</code> a column-linked matrix (<code>ColumnLinkedMatrix</code>) is
created, if <code>rows</code> a row-linked matrix (<code>RowLinkedMatrix</code>).
Defaults to <code>rows</code>.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_folderout">folderOut</code></td>
<td>

<p>The path to the folder where to save the binary files. Defaults to the
name of the input file (<code>fileIn</code>) without extension prefixed with
&quot;BGData_&quot;.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_outputtype">outputType</code></td>
<td>

<p>The <code>vmode</code> for <code>ff</code> and <code>type</code> for <code>big.matrix</code>
objects. Default to <code>byte</code> for <code>ff</code> and <code>char</code> for
<code>big.matrix</code> objects.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_dimorder">dimorder</code></td>
<td>

<p>The physical layout of the underlying <code>ff</code> object of each node.
</p>
</td></tr>
<tr><td><code id="readRAW_+3A_verbose">verbose</code></td>
<td>

<p>Whether progress updates will be posted. Defaults to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data included in the first couple of columns (up to <code>nColSkip</code>) is
used to populate the sample information of a <code>BGData</code> object, and the
remaining columns are used to fill the genotypes. If the first row contains
a header (<code>header = TRUE</code>), data in this row is used to determine the
column names for sample information and genotypes.
</p>
<p>The genotypes can take several forms, depending on the function that is
called (<code>readRAW</code>, <code>readRAW_matrix</code>, or
<code>readRAW_big.matrix</code>). The following sections illustrate each function
in detail.
</p>


<h3>readRAW</h3>

<p>Genotypes are stored in a <code>LinkedMatrix</code> object where each node is an
<code>ff</code> instance. Multiple <code>ff</code> files are used because the array
size in <code>ff</code> is limited to the largest integer which can be
represented on the system (<code>.Machine$integer.max</code>) and for genetic
data this limitation is often exceeded. The <code>LinkedMatrix</code> package
makes it possible to link several <code>ff</code> files together by columns or by
rows and treat them similarly to a single matrix. By default a
<code>ColumnLinkedMatrix</code> is used for the genotypes, but the user can
modify this using the <code>linked.by</code> argument. The number of nodes to
generate is either specified by the user using the <code>nNodes</code> argument
or determined internally so that each <code>ff</code> object has a number of
cells that is smaller than <code>.Machine$integer.max / 1.2</code>. A folder (see
<code>folderOut</code>) that contains the binary flat files (named
<code>geno_*.bin</code>) and an external representation of the <code>BGData</code>
object in <code>BGData.RData</code> is created.
</p>


<h3>readRAW_matrix</h3>

<p>Genotypes are stored in a regular <code>matrix</code> object. Therefore, this
function will only work if the .raw file is small enough to fit into
memory.
</p>


<h3>readRAW_big.matrix</h3>

<p>Genotypes are stored in a filebacked <code>big.matrix</code> object. A folder
(see <code>folderOut</code>) that contains the binary flat file (named
<code>BGData.bin</code>), a descriptor file (named <code>BGData.desc</code>), and an
external representation of the <code>BGData</code> object in <code>BGData.RData</code>
are created.
</p>


<h3>Reloading a BGData object</h3>

<p>To reload a <code>BGData</code> object, it is recommended to use the
<code>load.BGData</code> function instead of the <code>load</code> function as
<code>load</code> does not initialize <code>ff</code> objects or attach
<code>big.matrix</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.BGData">load.BGData()</a></code> to load a previously saved
<code>BGData</code> object, <code><a href="#topic+as.BGData">as.BGData()</a></code> to create
<code>BGData</code> objects from non-text files (e.g. .bed files).
<code><a href="#topic+BGData-class">BGData-class</a></code>,
<code><a href="LinkedMatrix.html#topic+ColumnLinkedMatrix-class">ColumnLinkedMatrix-class</a></code>,
<code><a href="LinkedMatrix.html#topic+RowLinkedMatrix-class">RowLinkedMatrix-class</a></code>,
<code><a href="bigmemory.html#topic+big.matrix-class">big.matrix-class</a></code>, and <code><a href="ff.html#topic+ff">ff</a></code> for
more information on the above mentioned classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Path to example data
path &lt;- system.file("extdata", package = "BGData")

# Convert RAW files of chromosome 1 to a BGData object
bg &lt;- readRAW(fileIn = paste0(path, "/chr1.raw"))

unlink("BGData_chr1", recursive = TRUE)
</code></pre>

<hr>
<h2 id='segments'>Find non-overlapping segments based on a summary statistic</h2><span id='topic+segments'></span>

<h3>Description</h3>

<p>Given a summary statistic and a threshold, this function computes the
number of non-overlapping segments, each defined as a discovery (i.e.,
<code>statistic[i] &lt;= threshold)</code> +/- a gap, in the same units as <code>bp</code>
(often base-pair position).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segments(statistic, chr, bp, threshold, gap, trim = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segments_+3A_statistic">statistic</code></td>
<td>

<p>A statistic (e.g., BFDR or p-values).
</p>
</td></tr>
<tr><td><code id="segments_+3A_chr">chr</code></td>
<td>

<p>A vector containing the chromosome for each value of <code>statistic</code>.
</p>
</td></tr>
<tr><td><code id="segments_+3A_bp">bp</code></td>
<td>

<p>A vector containing the base-pair positions for each value of
<code>statistic</code>.
</p>
</td></tr>
<tr><td><code id="segments_+3A_threshold">threshold</code></td>
<td>

<p>The threshold to determine 'significance' (e.g., <code>1e-5</code> for
p-values).
</p>
</td></tr>
<tr><td><code id="segments_+3A_gap">gap</code></td>
<td>

<p>1/2 of the length of the desired segments.
</p>
</td></tr>
<tr><td><code id="segments_+3A_trim">trim</code></td>
<td>

<p>Whether to collapse segments that were artifically inflated by
<code>gap</code>. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="segments_+3A_verbose">verbose</code></td>
<td>

<p>Whether progress updates will be posted. Defaults to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following information:
</p>
<table>
<tr><td><code>chr</code></td>
<td>

<p>Chromosome
</p>
</td></tr>
<tr><td><code>start</code></td>
<td>

<p>Index where segment starts within <code>statistic</code>.
</p>
</td></tr>
<tr><td><code>end</code></td>
<td>

<p>Index where segment ends within <code>statistic</code>.
</p>
</td></tr>
<tr><td><code>length</code></td>
<td>

<p>Length of segment.
</p>
</td></tr>
<tr><td><code>bpStart</code></td>
<td>

<p>Base-pair position where segment starts.
</p>
</td></tr>
<tr><td><code>bpEnd</code></td>
<td>

<p>Base-pair position where segment ends.
</p>
</td></tr>
<tr><td><code>bpLength</code></td>
<td>

<p>Length of segment in base-pair positions.
</p>
</td></tr>
<tr><td><code>minValue</code></td>
<td>

<p>Smallest value of <code>statistic</code> within segment.
</p>
</td></tr>
<tr><td><code>minValuePos</code></td>
<td>

<p>Position of variant with the smallest value of <code>statistic</code> within
segment.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(BGData)

# Load example data
bg &lt;- BGData:::loadExample()

# Perform GWAS
pValues &lt;- GWAS(
    formula = FT10 ~ 1,
    data = bg,
    method = "rayOLS"
)

# Determine segments within +/- 1MB from a significant variant
segments &lt;- segments(
    statistic = pValues[, 4],
    chr = map(bg)$chromosome,
    bp = map(bg)$base_pair_position,
    threshold = 1e-5,
    gap = 1e6,
    trim = FALSE,
    verbose = FALSE
)
</code></pre>

<hr>
<h2 id='summarize'>Generates Various Summary Statistics</h2><span id='topic+summarize'></span>

<h3>Description</h3>

<p>Computes the frequency of missing values, the (minor) allele frequency, and
standard deviation of each column of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize(X, i = seq_len(nrow(X)), j = seq_len(ncol(X)),
  chunkSize = 5000L, nCores = getOption("mc.cores", 2L),
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_+3A_x">X</code></td>
<td>

<p>A matrix-like object, typically the genotypes of a <code>BGData</code>
object.
</p>
</td></tr>
<tr><td><code id="summarize_+3A_i">i</code></td>
<td>

<p>Indicates which rows of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all rows are used.
</p>
</td></tr>
<tr><td><code id="summarize_+3A_j">j</code></td>
<td>

<p>Indicates which columns of <code>X</code> should be used. Can be integer,
boolean, or character. By default, all columns are used.
</p>
</td></tr>
<tr><td><code id="summarize_+3A_chunksize">chunkSize</code></td>
<td>

<p>The number of columns of <code>X</code> that are brought into physical memory
for processing per core. If <code>NULL</code>, all elements in <code>j</code> are
used. Defaults to 5000.
</p>
</td></tr>
<tr><td><code id="summarize_+3A_ncores">nCores</code></td>
<td>

<p>The number of cores (passed to <code>mclapply</code>). Defaults to the
number of cores as detected by <code>detectCores</code>.
</p>
</td></tr>
<tr><td><code id="summarize_+3A_verbose">verbose</code></td>
<td>

<p>Whether progress updates will be posted. Defaults to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with three columns: <code>freq_na</code> for frequencies of
missing values, <code>allele_freq</code> for allele frequencies of the counted
allele, and <code>sd</code> for standard deviations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+file-backed-matrices">file-backed-matrices</a></code> for more information on file-backed
matrices. <code><a href="#topic+multi-level-parallelism">multi-level-parallelism</a></code> for more information on
multi-level parallelism. <code><a href="#topic+BGData-class">BGData-class</a></code> for more information on
the <code>BGData</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Restrict number of cores to 1 on Windows
if (.Platform$OS.type == "windows") {
    options(mc.cores = 1)
}

# Load example data
bg &lt;- BGData:::loadExample()

# Summarize the whole dataset
sum1 &lt;- summarize(X = geno(bg))

# Summarize the first 50 individuals
sum2 &lt;- summarize(X = geno(bg), i = 1:50)

# Summarize the first 1000 markers (useful for distributed computing)
sum3 &lt;- summarize(X = geno(bg), j = 1:100)

# Summarize the first 50 individuals on the first 1000 markers
sum4 &lt;- summarize(X = geno(bg), i = 1:50, j = 1:100)

# Summarize by names
sum5 &lt;- summarize(X = geno(bg), j = c("snp81233_C", "snp81234_C", "snp81235_T"))

# Convert to minor allele frequencies (useful if the counted alleles are not
# the minor alleles)
maf &lt;- ifelse(sum1$allele_freq &gt; 0.5, 1 - sum1$allele_freq, sum1$allele_freq)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
