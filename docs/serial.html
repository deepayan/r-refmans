<!DOCTYPE html><html><head><title>Help for package serial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {serial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#close.serialConnection'><p>Function to close an serial interface.</p></a></li>
<li><a href='#flush.serialConnection'><p>Flushes the connection.</p></a></li>
<li><a href='#isOpen'><p>Generic function for isOpen</p></a></li>
<li><a href='#isOpen.default'><p>Default function from base-package</p></a></li>
<li><a href='#isOpen.serialConnection'><p>Tests whether the connection is open or not</p></a></li>
<li><a href='#listPorts'><p>Lists the serial interfaces.</p></a></li>
<li><a href='#nBytesInQueue'><p>Reads out the number of characters / bytes pending in the input and output buffer</p></a></li>
<li><a href='#open.serialConnection'><p>Function to initialize an serial interface.</p></a></li>
<li><a href='#print.serialConnection'><p>Print method for serialConnection</p></a></li>
<li><a href='#read.serialConnection'><p>Reads from the serial interface.</p></a></li>
<li><a href='#serial'><p>A serial communication interface for R.</p></a></li>
<li><a href='#serialConnection'><p>Sets up the interface parameters.</p></a></li>
<li><a href='#summary.serialConnection'><p>Serial Connection Summary</p></a></li>
<li><a href='#write.serialConnection'><p>Wirtes data to serial interface.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Serial Interface Package</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Seilmayer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Seilmayer &lt;m.seilmayer@hzdr.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables reading and writing binary and ASCII data to 
             RS232/RS422/RS485 or any other virtual serial interface of the
             computer.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-14 11:43:21 UTC; ms5760</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-14 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='close.serialConnection'>Function to close an serial interface.</h2><span id='topic+close.serialConnection'></span>

<h3>Description</h3>

<p>This function closes the corresponding connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serialConnection'
close(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close.serialConnection_+3A_con">con</code></td>
<td>
<p>serial connection</p>
</td></tr>
<tr><td><code id="close.serialConnection_+3A_...">...</code></td>
<td>
<p>is ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+serialConnection">serialConnection</a></code>
</p>

<hr>
<h2 id='flush.serialConnection'>Flushes the connection.</h2><span id='topic+flush.serialConnection'></span>

<h3>Description</h3>

<p>Some times (and depending on buffering mode) the connection buffer needs 
to be flushed manually. This command empties the buffer by sending all 
remaining bytes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serialConnection'
flush(con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flush.serialConnection_+3A_con">con</code></td>
<td>
<p>serial connection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serial">serial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # See the top package documentation
</code></pre>

<hr>
<h2 id='isOpen'>Generic function for isOpen</h2><span id='topic+isOpen'></span>

<h3>Description</h3>

<p>Generic function for isOpen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isOpen(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isOpen_+3A_con">con</code></td>
<td>
<p>connection Object</p>
</td></tr>
<tr><td><code id="isOpen_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='isOpen.default'>Default function from base-package</h2><span id='topic+isOpen.default'></span>

<h3>Description</h3>

<p>Default function from base-package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
isOpen(con, rw = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isOpen.default_+3A_con">con</code></td>
<td>
<p>connection object</p>
</td></tr>
<tr><td><code id="isOpen.default_+3A_rw">rw</code></td>
<td>
<p>defines the mode of operation</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+isOpen">isOpen</a></code>
</p>

<hr>
<h2 id='isOpen.serialConnection'>Tests whether the connection is open or not</h2><span id='topic+isOpen.serialConnection'></span>

<h3>Description</h3>

<p>Tests whether the connection is open or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serialConnection'
isOpen(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isOpen.serialConnection_+3A_con">con</code></td>
<td>
<p>connection of the class <code>serialConnection</code></p>
</td></tr>
<tr><td><code id="isOpen.serialConnection_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns <code>{F, T}</code> for 'not open' and 'is open'
</p>

<hr>
<h2 id='listPorts'>Lists the serial interfaces.</h2><span id='topic+listPorts'></span>

<h3>Description</h3>

<p>This function lists all installed serial interfaces in a computer.
Thereby Windows, Linux and MacOs behave different. Please ensure
that you have the appropriate permissions to do a search in the registry or
in the corresponding linux folders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listPorts()
</code></pre>


<h3>Value</h3>

<p>A character vector with the list of comports is returned.
</p>


<h3>Windows</h3>

<p>In a Windows environment, this function tries to read out the registry keys
located in:
</p>
<p><code>"HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM"</code>
</p>
<p>This should be consistent with all installed hardware ports plus all virtual
ports.
</p>


<h3>Linux and MacOS</h3>

<p>Here the situation is different, compared to Windows. All possible serial 
devices are located in <code>"/dev/tty[...]"</code> as a file connection. Still, all
virtual and closed dev's can be found here. This is confusing, because one will 
find more devices in this folder than physically (virtual) present.
In addition to that, Ubuntu linux systems do list the plug and play devices 
of interest in &quot;<code>/sys/devices/pnp0/...</code>&quot; again. That is the reason why, 
the function returns a subset of <code>"/dev/tty[...]"</code>, which is also present in the 
<code>"../pnp0/.."</code> folder.
</p>
<p>On MacOs the installed interfaces are marked by &quot;<code>tty.&lt;name&gt;</code>&quot; or &quot;<code>cu.&lt;name&gt;</code>&quot;, with a unique 
name after the dot, which makes it easier to search for installed devices.
Here a <code>tty</code> device is a modem which waits for a DCD (Data Carrier Detect)
signal to receive data. The device is blocked as long such a signal is 
not detected. The corresponding <code>cu</code> device manages the out going communication
for historical reasons. However a <code>cu</code> port is not blocked and should be used
in favour on MacOS.
</p>
<p>Subsequently, the user must know which interface is present and which isn't. AND the user
must have at least reading permissions in the corresponding folders. So in the end,
this function is a best guess of what is installed.
</p>

<hr>
<h2 id='nBytesInQueue'>Reads out the number of characters / bytes pending in the input and output buffer</h2><span id='topic+nBytesInQueue'></span>

<h3>Description</h3>

<p>Reads out the number of characters / bytes pending in the input and output buffer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nBytesInQueue(con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nBytesInQueue_+3A_con">con</code></td>
<td>
<p>serial connection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector with number of bytes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serial">serial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # See the top package documentation
</code></pre>

<hr>
<h2 id='open.serialConnection'>Function to initialize an serial interface.</h2><span id='topic+open.serialConnection'></span>

<h3>Description</h3>

<p>This function initializes the serial interface and opens it for later usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serialConnection'
open(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="open.serialConnection_+3A_con">con</code></td>
<td>
<p>serial connection</p>
</td></tr>
<tr><td><code id="open.serialConnection_+3A_...">...</code></td>
<td>
<p>is ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+serialConnection">serialConnection</a></code>
</p>

<hr>
<h2 id='print.serialConnection'>Print method for serialConnection</h2><span id='topic+print.serialConnection'></span>

<h3>Description</h3>

<p>Outputs major information of the serial connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serialConnection'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.serialConnection_+3A_x">x</code></td>
<td>
<p><code>serialConnection</code> Object</p>
</td></tr>
<tr><td><code id="print.serialConnection_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing to return
</p>

<hr>
<h2 id='read.serialConnection'>Reads from the serial interface.</h2><span id='topic+read.serialConnection'></span>

<h3>Description</h3>

<p>This function reads from the serial interface as long as the buffer is not
empty. The read takes place per line in normal operation mode. Here end-of-line
characters (\n;\r) are clipped according to the settings (<code>translation</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.serialConnection(con,n = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.serialConnection_+3A_con">con</code></td>
<td>
<p>serial connection</p>
</td></tr>
<tr><td><code id="read.serialConnection_+3A_n">n</code></td>
<td>
<p>number of bytes to read. Only in binary mode. 
<code>n=0</code> (default) reads the whole buffer at once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In binary (hex-) mode the read takes place per byte. The result is a raw 
vector of hexadecimal numbers. To get numeric values <code>as.numeric</code> 
function must be invoked.
Mind: Values form 0x01 &ndash; 0x31 might be displayed as escaped characters like
&quot;\001&quot; if they are interpreted as string.
If the end-of-file character specified by <code>eof</code> is received the reading 
stops. A <code>close(con)</code> &ndash; <code>open(con)</code> sequence must be invoked to 
reopen the connection.
If <code>n&gt;0</code> &lt;n&gt; bytes will be read. In case of less than <code>n</code> bytes 
available the function returns the buffer without waiting for all <code>n</code> 
characters.
If the result is empty (zero length) then the empty string &rdquo; is returned in ASCII
mode or <code>NA</code> in binary mode.
</p>


<h3>Value</h3>

<p>In normal mode the result is a string. In binary mode raw values will 
be returned
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serial">serial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # See the top package documentation
</code></pre>

<hr>
<h2 id='serial'>A serial communication interface for R.</h2><span id='topic+serial'></span>

<h3>Description</h3>

<p>This R package provides the functionality of serial communication ports
&quot;COM&quot; or &quot;tty&quot; to use the RS232/RS422/RS485 capabilities of the corresponding 
hardware. Also virtual COM-ports via USB do work, as long as they are mapped
to COM[n] (win) or tty[n] (Linux) in the operating system.
</p>

<dl>
<dt><code>open(con)</code></dt><dd><p>opens a serial connection</p>
</dd>
<dt><code>close(con)</code></dt><dd><p>closes the serial connection</p>
</dd>
<dt><code>flush(con)</code></dt><dd><p>flushes the serial connection</p>
</dd>
<dt><code>nBytesInQueue(con)</code></dt><dd><p>get the length of pending input an output queue</p>
</dd>
<dt><code>read.serialConnection(con)</code></dt><dd><p>read from the interface as long as 
the buffer is not empty</p>
</dd>
<dt><code>write.serialConnection(con,dat)</code></dt><dd><p>writes a data (character or binary) to the serial interface</p>
</dd>
<dt><code>isOpen(con)</code></dt><dd><p>test a connection, whether it is open or not</p>
</dd>
<dt><code>listPorts()</code></dt><dd><p>list all available ports on the system</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># for this example I used the 'null-modem' emulator 'com0com' for Windows
# which is available on 'http://com0com.sourceforge.net/'
# Here the pair of com-ports is 'CNCA0' &lt;-&gt; 'CNCB0'

# Test the functionality:
# ======================
#
# first: install the virtual null-modem connection like
#        com0com (win) or tty0tty (linux)
#        Hint: Some unix insist on port names like 'ttyS[n]'.
# 
# second: setup a terminal program (like HTerm or gtkterm) and listen to 
#         com-port 'CNCB0' (or what ever you have installed)
#         or (for unix only) 'cat /dev/tnt1' will output tnt1 to console

## Not run: 

# Now configure one of the com-ports with appropriate connection properties
con &lt;- serialConnection(name = "testcon",port = "CNCA0"
                       ,mode = "115200,n,8,1"
                       ,newline = 1
                       ,translation = "crlf"
                       )

# let's open the serial interface

open(con)

# write some stuff
write.serialConnection(con,"Hello World!")

# read, in case something came in
read.serialConnection(con)

# show summary
summary(con)

# close the connection
close(con)



# Reading and writing binary (hexadecimal) data
# remember: Everything is a string, so you might need data conversation

con &lt;- serialConnection(name = "testcon",port = "CNCA0"
                       ,mode = "115200,n,8,1"
                       ,translation = "binary" # switches to binary data
                       )

# let's open the serial interface

open(con)

# write some stuff
write.serialConnection(con, rawToChar(as.raw(15)) ) # 0x0F
write.serialConnection(con, c(15,20) ) # 0x0F, 0x14
write.serialConnection(con, c(0x6F,0x6C) )

# read, in case something came in
# the output is always a character vector
a &lt;- read.serialConnection(con)

# convert the character vector to hexadecimal (raw) values
print(a)

# close the connection
close(con)


## End(Not run)
</code></pre>

<hr>
<h2 id='serialConnection'>Sets up the interface parameters.</h2><span id='topic+serialConnection'></span>

<h3>Description</h3>

<p>This is the constructor of the serial interface connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialConnection(
  name = "",
  port = "com1",
  mode = "115200,n,8,1",
  buffering = "none",
  newline = 0,
  eof = "",
  translation = "auto",
  handshake = "none",
  buffersize = 4096
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serialConnection_+3A_name">name</code></td>
<td>
<p>optional name for the connection</p>
</td></tr>
<tr><td><code id="serialConnection_+3A_port">port</code></td>
<td>
<p>comport name; also virtual com's are 
supported; maybe USB schould work too</p>
</td></tr>
<tr><td><code id="serialConnection_+3A_mode">mode</code></td>
<td>
<p>communication mode '<code>&lt;BAUD&gt;, &lt;PARITY&gt;, &lt;DATABITS&gt;, &lt;STOPBITS&gt;</code>'
</p>

<dl>
<dt><code>BAUD</code></dt><dd><p>sets the baud rate (bits per second)</p>
</dd>
<dt><code>PARITY</code></dt><dd><p><em>n, o, e, m, s</em> corresponds to 'none', 'odd', 'even', 'mark' and 'space'</p>
</dd>
<dt><code>DATABITS</code></dt><dd><p>integer number of data bits. The value can range from 5 to 8</p>
</dd>
<dt><code>STOPBITS</code></dt><dd><p>integer number of stop bits. This can be '1' or '2'</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="serialConnection_+3A_buffering">buffering</code></td>
<td>
<p>'<code>none</code>', best for RS232 serial interface. Connection buffer
is flushed (send) when ever a write operation takes place.
'<code>line</code>', buffer is send after newline character 
(\n or 0x0A) is recognized. '<code>full</code>' write operations will
be bufferd until a <code>flush(con)</code> is invoked.</p>
</td></tr>
<tr><td><code id="serialConnection_+3A_newline">newline</code></td>
<td>
<p><code>&lt;BOOL&gt;</code>, whether a transmission ends with a newline or not.
</p>

<dl>
<dt><code>TRUE</code> or 1</dt><dd><p>send newline-char according to <code>&lt;translation&gt;</code> befor transmitting</p>
</dd>
<dt><code>FALSE</code> or 0</dt><dd><p>no newline</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="serialConnection_+3A_eof">eof</code></td>
<td>
<p><code>&lt;CHAR&gt;</code>, termination char of the datastream (end-of-file). It
only makes sense if <code>&lt;translation&gt;</code> is 'binary' and the stream is
a file. Must be in the range of 0x01 &ndash; 0x7f. When the conection is closed
<code>eof</code> is send as the last and final character.</p>
</td></tr>
<tr><td><code id="serialConnection_+3A_translation">translation</code></td>
<td>
<p>Determines the end-of-line (eol) character and mode of 
operation. This could be 'lf', 'cr', 'crlf', 'binary',
'auto' (default). A transmission is complete if eol 
symbol is received in non binary mode.</p>
</td></tr>
<tr><td><code id="serialConnection_+3A_handshake">handshake</code></td>
<td>
<p>determines the type of handshaking the communication
</p>

<dl>
<dt>'<code>none</code>'</dt><dd><p>no handshake is done</p>
</dd>
<dt>'<code>rtscts</code>'</dt><dd><p>hardware handshake is enabled</p>
</dd>
<dt>'<code>xonxoff</code>'</dt><dd><p>software handshake via extra characters is enabled</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="serialConnection_+3A_buffersize">buffersize</code></td>
<td>
<p>defines the system buffersize. The default value is 4096 
bytes (4kB).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linux and Windows behave a little bit different, when utilizing serial com 
ports. Still, by providing the name (like 'COM1', 'ttyS1' or 'cu.&lt;name&gt;')
and the appropriate settings, the serial interface can be used. Even 
virtual com ports, like the FTDI usb uart chips will work, as long they 
map to a standard serial interface in the system.
</p>
<p>Since the <code>serial</code> package relies on R's built in Tcl/Tk engine the 
configuration of the serial port takes place in the Tcl framework. This 
becomes important when different buffer sizes are set. For Windows the Tcl 
&quot;-sysbuffer&quot; parameter is invoked, whereas on unix-like systems &quot;-buffersize&quot; 
does the job.
</p>


<h3>Value</h3>

<p>An object of the class '<code>serialConnection</code>' is returned
</p>


<h3>Binary Data</h3>

<p>Handling binary data is possible by setting <code>transaltion = 'binary'</code>. Pay 
attention that input and output vectors are characters with a number range of
0...0xFF which might require certain conversations e. g. <code>charToRaw()</code> or
<code>rawToChar()</code> functions. If <code>eof</code>-character is defined, this symbol
terminates the input data stream. Every byte in the buffer after that
symbol is deleted/ignored. The next transmission is valid again up to that symbol.
If the connection is closed <code>eof</code> is send to terminate the output data
stream. Remind, the <code>newline</code> option works here too. It adds a line feed
or <code>0x0A</code> - byte to the end of each output respectively.
</p>


<h3>ASCII Data</h3>

<p>In non binary mode, ASCII-communication is assumed. This means, that each
string, which is send or received, carries valid 8bit ASCII characters 
(0x01 &ndash; 0xFF). Some of these characters appear as escaped sequences, if they
are not printable.
A string is terminated by the end-of-line character (e. g. \n). The 
transmission ends and so becomes valid if the symbol is detected according to
the <code>translation</code> setting. Sending terminated strings invokes the
substitution of the end-of-line character according to the <code>translation</code>
setting.
</p>

<hr>
<h2 id='summary.serialConnection'>Serial Connection Summary</h2><span id='topic+summary.serialConnection'></span>

<h3>Description</h3>

<p>Displays summarized informations and status of the serial connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serialConnection'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.serialConnection_+3A_object">object</code></td>
<td>
<p>object of type <code>serialConnection</code></p>
</td></tr>
<tr><td><code id="summary.serialConnection_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Table of connection properties
</p>

<hr>
<h2 id='write.serialConnection'>Wirtes data to serial interface.</h2><span id='topic+write.serialConnection'></span>

<h3>Description</h3>

<p>Writes to a serial connection in ascii or binary mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.serialConnection(con,dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.serialConnection_+3A_con">con</code></td>
<td>
<p>serial Connection</p>
</td></tr>
<tr><td><code id="write.serialConnection_+3A_dat">dat</code></td>
<td>
<p>data string to write on the serial interface. This must be a string
<code>'...'</code> in case of ascii communication. In case of binary 
communication also numeric vectors are allowed. See examle section
in <code><a href="#topic+serial">serial</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In normal operation mode (non-binary ascii mode) <code>write.serialConnection</code> 
respects the translation and adds the end-of-line characters (\n;\r) according 
to the settings. Any input is converted to character, i.e. <code>c(1,2,3)</code> becomes
<code>'123'</code> and so on.
</p>
<p>In binary mode <em>no</em> end-of-line characters are added. The input argument
must be of type <code>raw</code> or <code>string</code>. If <code>dat</code> is numeric 
(vector) it is converted to <code>raw</code>.
</p>


<h3>Value</h3>

<p>The status of success 'DONE' or 'Nothing to do' is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serial">serial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # See the top package documentation
 
 ## Not run: write.serialConnection(con, 'Hello World!')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
