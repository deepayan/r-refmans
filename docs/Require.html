<!DOCTYPE html><html><head><title>Help for package Require</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Require}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.downloadFileMasterMainAuth'><p>GITHUB_PAT-aware and <code>main</code>-<code>master</code>-aware download from GitHub</p></a></li>
<li><a href='#archiveVersionsAvailable'><p>Available and archived versions</p></a></li>
<li><a href='#availablePackagesOverride'><p>Create a custom &quot;available.packages&quot; object</p></a></li>
<li><a href='#availableVersionOK'><p>Needs <code>VersionOnRepos</code>, <code>versionSpec</code> and <code>inequality</code> columns</p></a></li>
<li><a href='#checkPath'><p>Check directory path</p></a></li>
<li><a href='#chooseCRANmirror2'><p>Pass through function for <code>chooseCRANmirror</code></p></a></li>
<li><a href='#clearRequirePackageCache'><p>Clear Require Cache elements</p></a></li>
<li><a href='#DESCRIPTIONFileVersionV'><p>GitHub package tools</p></a></li>
<li><a href='#detachAll'><p>Detach and unload all packages</p></a></li>
<li><a href='#extractPkgName'><p>Extract info from package character strings</p></a></li>
<li><a href='#getCRANrepos'><p>A helper function to get or set CRAN repos</p></a></li>
<li><a href='#getOptionRPackageCache'><p>Get the option for <code>Require.RPackageCache</code></p></a></li>
<li><a href='#invertList'><p>Invert a 2-level list</p></a></li>
<li><a href='#linkOrCopy'><p>Create link to file, falling back to making a copy if linking fails.</p></a></li>
<li><a href='#messageDF'><p>Use message to print a clean square data structure</p></a></li>
<li><a href='#modifyList2'><p><code>modifyList</code> for multiple lists</p></a></li>
<li><a href='#normPath'><p>Normalize filepath</p></a></li>
<li><a href='#paddedFloatToChar'><p>Convert numeric to character with padding</p></a></li>
<li><a href='#parseGitHub'><p>Parse a github package specification</p></a></li>
<li><a href='#pkgDep'><p>Determine package dependencies</p></a></li>
<li><a href='#pkgDepIfDepRemoved'><p>Package dependencies when one or more packages removed</p></a></li>
<li><a href='#pkgSnapshot'><p>Take a snapshot of all the packages and version numbers</p></a></li>
<li><a href='#R_TESTSomit'><p>This environment variable &quot;R_TESTS&quot; is set during testing, and it points to a file</p>
called <code>Startup.Rs</code> that is placed in the <code>.libPaths()</code>.
If the <code>.libPaths()</code> is changed during the testing,
then that file will not be found, and install.packages will
fail to install a package with an error of source file not found.
See: <a href="https://github.com/HenrikBengtsson/startup/issues/19">https://github.com/HenrikBengtsson/startup/issues/19</a>.</a></li>
<li><a href='#Require-package'><p>Require: Installing and Loading R Packages for Reproducible Workflows</p></a></li>
<li><a href='#RequireCacheDir'><p>Path to (package) cache directory</p></a></li>
<li><a href='#RequireOptions'><p><code>Require</code> options</p></a></li>
<li><a href='#rversions'><p>R versions</p></a></li>
<li><a href='#setdiffNamed'><p>Like <code>setdiff</code>, but takes into account names</p></a></li>
<li><a href='#setLibPaths'><p>Set <code>.libPaths</code></p></a></li>
<li><a href='#setLinuxBinaryRepo'><p>Setup for binary Linux repositories</p></a></li>
<li><a href='#setup'><p>Setup a project library, cache, options</p></a></li>
<li><a href='#sourcePkgs'><p>A list of R packages that should likely be installed from Source, not Binary</p></a></li>
<li><a href='#tempdir2'><p>Make a temporary (sub-)directory</p></a></li>
<li><a href='#tempfile2'><p>Make a temporary subfile in a temporary (sub-)directory</p></a></li>
<li><a href='#trimVersionNumber'><p>Trim version number off a compound package name</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Installing and Loading R Packages for Reproducible Workflows</td>
</tr>
<tr>
<td>Description:</td>
<td>A single key function, 'Require' that makes rerun-tolerant
    versions of 'install.packages' and 'require' for CRAN packages, packages
    no longer on CRAN (i.e., archived), specific versions of packages, 
    and GitHub packages. This approach is developed to create reproducible 
    workflows that are flexible and fast enough to use while in development stages,
    while able to build snapshots once a stable package collection is found. 
    As with other functions in a reproducible workflow, this package 
    emphasizes functions that return the same result whether it is 
    the first or subsequent times running the function, with subsequent times being
    sufficiently fast that they can be run every time without undue waiting burden on 
    the user or developer.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://Require.predictiveecology.org">https://Require.predictiveecology.org</a>,
<a href="https://github.com/PredictiveEcology/Require">https://github.com/PredictiveEcology/Require</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-22</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.10.4), methods, tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, parallel, remotes, testit</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-CA</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PredictiveEcology/Require/issues">https://github.com/PredictiveEcology/Require/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-22 18:46:22 UTC; emcintir</td>
</tr>
<tr>
<td>Author:</td>
<td>Eliot J B McIntire
    <a href="https://orcid.org/0000-0002-6914-8316"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Alex M Chubaty <a href="https://orcid.org/0000-0001-7146-8135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Her Majesty the Queen in Right of Canada, as represented by the
    Minister of Natural Resources Canada [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eliot J B McIntire &lt;eliot.mcintire@canada.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-22 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.downloadFileMasterMainAuth'>GITHUB_PAT-aware and <code>main</code>-<code>master</code>-aware download from GitHub</h2><span id='topic+.downloadFileMasterMainAuth'></span>

<h3>Description</h3>

<p>Equivalent to <code>utils::download.file</code>, but taking the <code>GITHUB_PAT</code> environment
variable and using it to access the Github url.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.downloadFileMasterMainAuth(
  url,
  destfile,
  need = "HEAD",
  verbose = getOption("Require.verbose"),
  verboseLevel = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".downloadFileMasterMainAuth_+3A_url">url</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string (or longer vector
for the <code>"libcurl"</code> method) naming the URL of a resource to be
downloaded.</p>
</td></tr>
<tr><td><code id=".downloadFileMasterMainAuth_+3A_destfile">destfile</code></td>
<td>
<p>a character string (or vector, see the <code>url</code>
argument) with the file path where the downloaded file is to be
saved.  Tilde-expansion is performed.</p>
</td></tr>
<tr><td><code id=".downloadFileMasterMainAuth_+3A_need">need</code></td>
<td>
<p>If specified, user can suggest which <code>master</code> or <code>main</code> or <code>HEAD</code> to
try first. If unspecified, <code>HEAD</code> is used.</p>
</td></tr>
<tr><td><code id=".downloadFileMasterMainAuth_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
<tr><td><code id=".downloadFileMasterMainAuth_+3A_verboselevel">verboseLevel</code></td>
<td>
<p>A numeric indicating what verbose threshold (level) above
which this message will show.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is called for its side effect, namely, the same as <code>utils::download.file</code>, but
using a <code>GITHUB_PAT</code>, it if is in the environment, and trying both <code>master</code> and
<code>main</code> if the actual <code>url</code> specifies either <code>master</code> or <code>main</code> and it does not exist.
</p>

<hr>
<h2 id='archiveVersionsAvailable'>Available and archived versions</h2><span id='topic+archiveVersionsAvailable'></span><span id='topic+available.packagesCached'></span>

<h3>Description</h3>

<p>These are wrappers around available.packages and also get the archived versions
available on CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archiveVersionsAvailable(package, repos)

available.packagesCached(
  repos,
  purge,
  verbose = getOption("Require.verbose"),
  returnDataTable = TRUE,
  type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archiveVersionsAvailable_+3A_package">package</code></td>
<td>
<p>A single package name (without version or github specifications)</p>
</td></tr>
<tr><td><code id="archiveVersionsAvailable_+3A_repos">repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td></tr>
<tr><td><code id="archiveVersionsAvailable_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="archiveVersionsAvailable_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
<tr><td><code id="archiveVersionsAvailable_+3A_returndatatable">returnDataTable</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then the return
is a data.table.
Otherwise, it is a <code>matrix</code>, as per <code>available.packages</code></p>
</td></tr>
<tr><td><code id="archiveVersionsAvailable_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>archiveVersionsAvailable</code> searches CRAN Archives for available versions.
It has been borrowed from a sub-set of the code in a non-exported function:
<code>remotes:::download_version_url</code>
</p>

<hr>
<h2 id='availablePackagesOverride'>Create a custom &quot;available.packages&quot; object</h2><span id='topic+availablePackagesOverride'></span>

<h3>Description</h3>

<p>This is the mechanism by which <code>install.packages</code> determines which packages
should be installed from where. With this override, we can indicate arbitrary
<code>repos</code>, <code>Package</code>, <code>File</code> for each individual package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availablePackagesOverride(toInstall, repos, purge, type = getOption("pkgType"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availablePackagesOverride_+3A_toinstall">toInstall</code></td>
<td>
<p>A <code>pkgDT</code> object</p>
</td></tr>
<tr><td><code id="availablePackagesOverride_+3A_repos">repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td></tr>
<tr><td><code id="availablePackagesOverride_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="availablePackagesOverride_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
</table>

<hr>
<h2 id='availableVersionOK'>Needs <code>VersionOnRepos</code>, <code>versionSpec</code> and <code>inequality</code> columns</h2><span id='topic+availableVersionOK'></span>

<h3>Description</h3>

<p>Needs <code>VersionOnRepos</code>, <code>versionSpec</code> and <code>inequality</code> columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableVersionOK(pkgDT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availableVersionOK_+3A_pkgdt">pkgDT</code></td>
<td>
<p>A <code>pkgDT</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='checkPath'>Check directory path</h2><span id='topic+checkPath'></span><span id='topic+checkPath+2Ccharacter+2Clogical-method'></span><span id='topic+checkPath+2Ccharacter+2Cmissing-method'></span><span id='topic+checkPath+2CNULL+2CANY-method'></span><span id='topic+checkPath+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>Checks the specified path to a directory for formatting consistencies,
such as trailing slashes, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPath(path, create)

## S4 method for signature 'character,logical'
checkPath(path, create)

## S4 method for signature 'character,missing'
checkPath(path)

## S4 method for signature ''NULL',ANY'
checkPath(path)

## S4 method for signature 'missing,ANY'
checkPath()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPath_+3A_path">path</code></td>
<td>
<p>A character string corresponding to a directory path.</p>
</td></tr>
<tr><td><code id="checkPath_+3A_create">create</code></td>
<td>
<p>A logical indicating whether the path should
be created if it does not exist. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string denoting the cleaned up filepath.
</p>


<h3>Note</h3>

<p>This will not work for paths to files.
To check for existence of files, use <code>file.exists()</code>.
To normalize a path to a file, use <code>normPath()</code> or <code>normalizePath()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+file.exists">file.exists()</a></code>, <code><a href="base.html#topic+dir.create">dir.create()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normalize file paths
paths &lt;- list("./aaa/zzz",
              "./aaa/zzz/",
              ".//aaa//zzz",
              ".//aaa//zzz/",
              ".\\\\aaa\\\\zzz",
              ".\\\\aaa\\\\zzz\\\\",
              file.path(".", "aaa", "zzz"))

checked &lt;- normPath(paths)
length(unique(checked)) ## 1; all of the above are equivalent

## check to see if a path exists
tmpdir &lt;- file.path(tempdir(), "example_checkPath")

dir.exists(tmpdir) ## FALSE
tryCatch(checkPath(tmpdir, create = FALSE), error = function(e) FALSE) ## FALSE

checkPath(tmpdir, create = TRUE)
dir.exists(tmpdir) ## TRUE

unlink(tmpdir, recursive = TRUE) # clean up
</code></pre>

<hr>
<h2 id='chooseCRANmirror2'>Pass through function for <code>chooseCRANmirror</code></h2><span id='topic+chooseCRANmirror2'></span>

<h3>Description</h3>

<p>This is here to allow mocking during unit testing related to <code>chooseCRANmirror</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseCRANmirror2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseCRANmirror2_+3A_...">...</code></td>
<td>
<p>Passed to <code>chooseCRANmirror</code></p>
</td></tr>
</table>

<hr>
<h2 id='clearRequirePackageCache'>Clear Require Cache elements</h2><span id='topic+clearRequirePackageCache'></span>

<h3>Description</h3>

<p>Clear Require Cache elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clearRequirePackageCache(
  packages,
  ask = interactive(),
  Rversion = rversion(),
  clearCranCache = FALSE,
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clearRequirePackageCache_+3A_packages">packages</code></td>
<td>
<p>Either missing or a character vector of package names
(currently cannot specify version number) to remove from the local Require
Cache.</p>
</td></tr>
<tr><td><code id="clearRequirePackageCache_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then it will ask user to confirm</p>
</td></tr>
<tr><td><code id="clearRequirePackageCache_+3A_rversion">Rversion</code></td>
<td>
<p>An R version (major dot minor, e.g., &quot;4.2&quot;). Defaults to
current R version.</p>
</td></tr>
<tr><td><code id="clearRequirePackageCache_+3A_clearcrancache">clearCranCache</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then this will also clear the
local <code>crancache</code> cache, which is only relevant if
<code>options(Require.useCranCache = TRUE)</code>, i.e., if <code>Require</code> is using the
<code>crancache</code> cache also</p>
</td></tr>
<tr><td><code id="clearRequirePackageCache_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
</table>

<hr>
<h2 id='DESCRIPTIONFileVersionV'>GitHub package tools</h2><span id='topic+DESCRIPTIONFileVersionV'></span><span id='topic+DESCRIPTIONFileOtherV'></span><span id='topic+getGitHubDESCRIPTION'></span>

<h3>Description</h3>

<p>A series of helpers to access and deal with GitHub packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DESCRIPTIONFileVersionV(file, purge = getOption("Require.purge", FALSE))

DESCRIPTIONFileOtherV(file, other = "RemoteSha")

getGitHubDESCRIPTION(
  pkg,
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_file">file</code></td>
<td>
<p>A file path to a <code>DESCRIPTION</code> file</p>
</td></tr>
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_other">other</code></td>
<td>
<p>Any other keyword in a <code>DESCRIPTION</code> file that precedes a &quot;:&quot;.
The rest of the line will be retrieved.</p>
</td></tr>
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_pkg">pkg</code></td>
<td>
<p>A character string with a GitHub package specification (c.f. remotes)</p>
</td></tr>
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getGitHubDESCRIPTION</code> retrieves the DESCRIPTION file from GitHub.com
</p>

<hr>
<h2 id='detachAll'>Detach and unload all packages</h2><span id='topic+detachAll'></span>

<h3>Description</h3>

<p>This uses <code>pkgDepTopoSort</code> internally so that the package
dependency tree is determined, and then packages are unloaded
in the reverse order. Some packages don't unload successfully for
a variety of reasons. Several known packages that have this problem
are identified internally and <em>not</em> unloaded. Currently, these are
<code>glue</code>, <code>rlang</code>, <code>ps</code>, <code>ellipsis</code>, and, <code>processx</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detachAll(
  pkgs,
  dontTry = NULL,
  doSort = TRUE,
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detachAll_+3A_pkgs">pkgs</code></td>
<td>
<p>A character vector of packages to detach. Will be topologically sorted
unless <code>doSort</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="detachAll_+3A_donttry">dontTry</code></td>
<td>
<p>A character vector of packages to not try. This can be used
by a user if they find a package fails in attempts to unload it, e.g., &quot;ps&quot;</p>
</td></tr>
<tr><td><code id="detachAll_+3A_dosort">doSort</code></td>
<td>
<p>If <code>TRUE</code> (the default), then the <code>pkgs</code> will be
topologically sorted. If <code>FALSE</code>, then it won't. Useful if the
<code>pkgs</code> are already sorted.</p>
</td></tr>
<tr><td><code id="detachAll_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric named vector, with names of the packages that were attempted.
<code>2</code> means the package was successfully unloaded, <code>1</code> it was
tried, but failed, <code>3</code> it was in the search path and was detached
and unloaded.
</p>

<hr>
<h2 id='extractPkgName'>Extract info from package character strings</h2><span id='topic+extractPkgName'></span><span id='topic+extractVersionNumber'></span><span id='topic+extractInequality'></span><span id='topic+extractPkgGitHub'></span>

<h3>Description</h3>

<p>Cleans a character vector of non-package name related information (e.g., version)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractPkgName(pkgs, filenames)

extractVersionNumber(pkgs, filenames)

extractInequality(pkgs)

extractPkgGitHub(pkgs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractPkgName_+3A_pkgs">pkgs</code></td>
<td>
<p>A character string vector of packages with or without GitHub path or versions</p>
</td></tr>
<tr><td><code id="extractPkgName_+3A_filenames">filenames</code></td>
<td>
<p>Can be supplied instead of <code>pkgs</code> if it is a filename e.g., a
.tar.gz or .zip that was downloaded from CRAN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Just the package names without extraneous info.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimVersionNumber">trimVersionNumber()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extractPkgName("Require (&gt;=0.0.1)")
extractVersionNumber(c(
  "Require (&lt;=0.0.1)",
  "PredictiveEcology/Require@development (&lt;=0.0.4)"
))
extractInequality("Require (&lt;=0.0.1)")
extractPkgGitHub("PredictiveEcology/Require")
</code></pre>

<hr>
<h2 id='getCRANrepos'>A helper function to get or set CRAN repos</h2><span id='topic+getCRANrepos'></span>

<h3>Description</h3>

<p>This will get the current option in <code>getOption('repos')</code>, and if that is not
set to a url, then it will prompt the user to select a mirror, unless
<code>ind</code> is set, in which case, it will use that mirror (in
<code>chooseCRANmirror()</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCRANrepos(repos = NULL, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCRANrepos_+3A_repos">repos</code></td>
<td>
<p>A CRAN-like repository</p>
</td></tr>
<tr><td><code id="getCRANrepos_+3A_ind">ind</code></td>
<td>
<p>an integer of which mirror to use in <code>chooseCRANmirror()</code></p>
</td></tr>
</table>

<hr>
<h2 id='getOptionRPackageCache'>Get the option for <code>Require.RPackageCache</code></h2><span id='topic+getOptionRPackageCache'></span>

<h3>Description</h3>

<p>First checks if an environment variable <code>Require.RPackageCache</code>
is set and defines a path.
If not set, checks whether the <code>options("Require.RPackageCache")</code> is set.
If a character string, then it returns that.
If <code>TRUE</code>, then use <code>RequirePkgCacheDir()</code>. If <code>FALSE</code>
then returns <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOptionRPackageCache()
</code></pre>

<hr>
<h2 id='invertList'>Invert a 2-level list</h2><span id='topic+invertList'></span>

<h3>Description</h3>

<p>This is a simple version of <code>purrr::transpose</code>, only for lists with 2 levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertList(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invertList_+3A_l">l</code></td>
<td>
<p>A list with 2 levels. If some levels are absent, they will be <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 levels deep, inverted from <code>l</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a 2-deep, 2 levels in first, 3 levels in second
a &lt;- list(a = list(d = 1, e = 2:3, f = 4:6), b = list(d = 5, e = 55))
invertList(a) # creates 2-deep, now 3 levels outer --&gt; 2 levels inner
</code></pre>

<hr>
<h2 id='linkOrCopy'>Create link to file, falling back to making a copy if linking fails.</h2><span id='topic+linkOrCopy'></span><span id='topic+fileRenameOrMove'></span>

<h3>Description</h3>

<p>First try to create a hardlink to the file. If that fails, try a symbolic
link (symlink) before falling back to copying the file. &quot;File&quot; here can mean
a file or a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkOrCopy(from, to, allowSymlink = FALSE)

fileRenameOrMove(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkOrCopy_+3A_from">from</code>, <code id="linkOrCopy_+3A_to">to</code></td>
<td>
<p>character vectors, containing file names or paths.</p>
</td></tr>
<tr><td><code id="linkOrCopy_+3A_allowsymlink">allowSymlink</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the default, then it will try
<code>file.link</code> first, then <code>file.copy</code>, omitting the <code>file.symlink</code> step</p>
</td></tr>
</table>

<hr>
<h2 id='messageDF'>Use message to print a clean square data structure</h2><span id='topic+messageDF'></span><span id='topic+messageVerbose'></span><span id='topic+messageVerboseCounter'></span>

<h3>Description</h3>

<p>Sends to <code>message</code>, but in a structured way so that a data.frame-like can
be cleanly sent to messaging.
</p>
<p>This will only show a message if the value of <code>verbose</code> is greater than the
<code>verboseLevel</code>. This is mostly useful for developers of code who want to give
users of their code easy access to how verbose their code will be. A developer
of a function will place this <code>messageVerbose</code> internally, setting the <code>verboseLevel</code>
according to how advanced they may want the message to be. <code>1</code> is a reasonable
default for standard use, <code>0</code> would be for &quot;a very important message for all users&quot;,
<code>2</code> or above would be increasing levels of details for e.g., advanced use.
If a user sets to <code>-1</code> with this numeric approach, they can avoid all messaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messageDF(df, round, verbose = getOption("Require.verbose"), verboseLevel = 1)

messageVerbose(..., verbose = getOption("Require.verbose"), verboseLevel = 1)

messageVerboseCounter(
  pre = "",
  post = "",
  verbose = getOption("Require.verbose"),
  verboseLevel = 1,
  counter = 1,
  total = 1,
  minCounter = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messageDF_+3A_df">df</code></td>
<td>
<p>A data.frame, data.table, matrix</p>
</td></tr>
<tr><td><code id="messageDF_+3A_round">round</code></td>
<td>
<p>An optional numeric to pass to <code>round</code></p>
</td></tr>
<tr><td><code id="messageDF_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
<tr><td><code id="messageDF_+3A_verboselevel">verboseLevel</code></td>
<td>
<p>A numeric indicating what verbose threshold (level) above
which this message will show.</p>
</td></tr>
<tr><td><code id="messageDF_+3A_...">...</code></td>
<td>
<p>Passed to <code>install.packages</code>. Good candidates are e.g., <code>type</code> or
<code>dependencies</code>. This can be used with <code>install_githubArgs</code> or
<code>install.packageArgs</code> which give individual options for those 2 internal
function calls.</p>
</td></tr>
<tr><td><code id="messageDF_+3A_pre">pre</code></td>
<td>
<p>A single text string to paste before the counter</p>
</td></tr>
<tr><td><code id="messageDF_+3A_post">post</code></td>
<td>
<p>A single text string to paste after the counter</p>
</td></tr>
<tr><td><code id="messageDF_+3A_counter">counter</code></td>
<td>
<p>An integer indicating which iteration is being done</p>
</td></tr>
<tr><td><code id="messageDF_+3A_total">total</code></td>
<td>
<p>An integer indicating the total number to be done.</p>
</td></tr>
<tr><td><code id="messageDF_+3A_mincounter">minCounter</code></td>
<td>
<p>An integer indicating the minimum (i.e,. starting value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for side effects, namely messaging that can be turned on or off with different
numeric values of <code>verboseLevel</code>. A user sets the <code>verboseLevel</code> for a particular
message.
</p>

<hr>
<h2 id='modifyList2'><code>modifyList</code> for multiple lists</h2><span id='topic+modifyList2'></span><span id='topic+modifyList3'></span>

<h3>Description</h3>

<p>This calls <code><a href="utils.html#topic+modifyList">utils::modifyList</a></code> iteratively using
<code><a href="base.html#topic+funprog">base::Reduce</a></code>, so it can handle &gt;2 lists.
The subsequent list elements that share a name will override
previous list elements with that same name.
It also will handle the case where any list is a <code>NULL</code>. Note:
default <code>keep.null = TRUE</code>, which is different than <code>modifyList</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifyList2(..., keep.null = FALSE)

modifyList3(..., keep.null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modifyList2_+3A_...">...</code></td>
<td>
<p>One or more named lists.</p>
</td></tr>
<tr><td><code id="modifyList2_+3A_keep.null">keep.null</code></td>
<td>
<p> If <code>TRUE</code>, <code>NULL</code> elements in <code>val</code>
become <code>NULL</code> elements in <code>x</code>.  Otherwise, the
corresponding element, if present, is deleted from <code>x</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>More or less a convenience around
<code>Reduce(modifyList, list(...))</code>, with some checks, and the addition of
<code>keep.null = TRUE</code> by default.
</p>


<h3>Note</h3>

<p><code>modifyList3</code> retains the original behaviour of <code>modifyList2</code> (prior to
Oct 2022); however, it cannot retain <code>NULL</code> values in lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modifyList2(list(a = 1), list(a = 2, b = 2))
modifyList2(list(a = 1), NULL, list(a = 2, b = 2))
modifyList2(
  list(a = 1), list(x = NULL), list(a = 2, b = 2),
  list(a = 3, c = list(1:10))
)
</code></pre>

<hr>
<h2 id='normPath'>Normalize filepath</h2><span id='topic+normPath'></span><span id='topic+normPath+2Ccharacter-method'></span><span id='topic+normPath+2Clist-method'></span><span id='topic+normPath+2CNULL-method'></span><span id='topic+normPath+2Cmissing-method'></span><span id='topic+normPath+2Clogical-method'></span>

<h3>Description</h3>

<p>Checks the specified filepath for formatting consistencies:
</p>

<ol>
<li><p> use slash instead of backslash;
</p>
</li>
<li><p> do tilde etc. expansion;
</p>
</li>
<li><p> remove trailing slash.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>normPath(path)

## S4 method for signature 'character'
normPath(path)

## S4 method for signature 'list'
normPath(path)

## S4 method for signature ''NULL''
normPath(path)

## S4 method for signature 'missing'
normPath()

## S4 method for signature 'logical'
normPath(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normPath_+3A_path">path</code></td>
<td>
<p>A character vector of filepaths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of cleaned up filepaths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normalize file paths
paths &lt;- list("./aaa/zzz",
              "./aaa/zzz/",
              ".//aaa//zzz",
              ".//aaa//zzz/",
              ".\\\\aaa\\\\zzz",
              ".\\\\aaa\\\\zzz\\\\",
              file.path(".", "aaa", "zzz"))

checked &lt;- normPath(paths)
length(unique(checked)) ## 1; all of the above are equivalent

## check to see if a path exists
tmpdir &lt;- file.path(tempdir(), "example_checkPath")

dir.exists(tmpdir) ## FALSE
tryCatch(checkPath(tmpdir, create = FALSE), error = function(e) FALSE) ## FALSE

checkPath(tmpdir, create = TRUE)
dir.exists(tmpdir) ## TRUE

unlink(tmpdir, recursive = TRUE) # clean up
</code></pre>

<hr>
<h2 id='paddedFloatToChar'>Convert numeric to character with padding</h2><span id='topic+paddedFloatToChar'></span>

<h3>Description</h3>

<p>This will pad floating point numbers, right or left. For integers, either class
integer or functionally integer (e.g., 1.0), it will not pad right of the decimal.
For more specific control or to get exact padding right and left of decimal,
try the <code>stringi</code> package. It will also not do any rounding. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paddedFloatToChar(x, padL = ceiling(log10(x + 1)), padR = 3, pad = "0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paddedFloatToChar_+3A_x">x</code></td>
<td>
<p>numeric. Number to be converted to character with padding</p>
</td></tr>
<tr><td><code id="paddedFloatToChar_+3A_padl">padL</code></td>
<td>
<p>numeric. Desired number of digits on left side of decimal.
If not enough, <code>pad</code> will be used to pad.</p>
</td></tr>
<tr><td><code id="paddedFloatToChar_+3A_padr">padR</code></td>
<td>
<p>numeric. Desired number of digits on right side of decimal.
If not enough, <code>pad</code> will be used to pad.</p>
</td></tr>
<tr><td><code id="paddedFloatToChar_+3A_pad">pad</code></td>
<td>
<p>character to use as padding (<code>nchar(pad) == 1</code> must be <code>TRUE</code>).
Currently, can be only <code>"0"</code> or <code>" "</code> (i.e., space).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string representing the filename.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>paddedFloatToChar(1.25)
paddedFloatToChar(1.25, padL = 3, padR = 5)
paddedFloatToChar(1.25, padL = 3, padR = 1) # no rounding, so keeps 2 right of decimal
</code></pre>

<hr>
<h2 id='parseGitHub'>Parse a github package specification</h2><span id='topic+parseGitHub'></span>

<h3>Description</h3>

<p>This converts a specification like <code>PredictiveEcology/Require@development</code>
into separate columns, &quot;Account&quot;, &quot;Repo&quot;, &quot;Branch&quot;, &quot;GitSubFolder&quot; (if there is one)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseGitHub(pkgDT, verbose = getOption("Require.verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseGitHub_+3A_pkgdt">pkgDT</code></td>
<td>
<p>A pkgDT data.table.</p>
</td></tr>
<tr><td><code id="parseGitHub_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parseGitHub</code> turns the single character string representation into 3 or 4:
<code>Account</code>, <code>Repo</code>, <code>Branch</code>, <code>SubFolder</code>.
</p>


<h3>Value</h3>

<p><code>parseGitHub</code> returns a <code>data.table</code> with added columns.
</p>

<hr>
<h2 id='pkgDep'>Determine package dependencies</h2><span id='topic+pkgDep'></span><span id='topic+pkgDep2'></span><span id='topic+pkgDepTopoSort'></span>

<h3>Description</h3>

<p>This will first look in local filesystem (in <code>.libPaths()</code>) and will use a
local package to find its dependencies. If the package does not exist
locally, including whether it is the correct version, then it will look in
(currently) <code>CRAN</code> and its archives (if the current <code>CRAN</code> version is not the
desired version to check). It will also look on <code>GitHub</code> if the package
description is of the form of a GitHub package with format
<code>account/repo@branch</code> or <code>account/repo@commit</code>. For this, it will attempt to
get package dependencies from the GitHub &lsquo;<span class="file">DESCRIPTION</span>&rsquo; file. This is
intended to replace <code>tools::package_dependencies</code> or <code>pkgDep</code> in the
<span class="pkg">miniCRAN</span> package, but with modifications to allow multiple sources to
be searched in the same function call.
</p>
<p><code>pkgDep2</code> is a convenience wrapper of <code>pkgDep</code> that &quot;goes one level in&quot;,
i.e., the first order dependencies, and runs the <code>pkgDep</code> on those.
</p>
<p>This is a wrapper around <code>tools::dependsOnPkgs</code>,
but with the added option of <code>sorted</code>, which
will sort them such that the packages at the top will have
the least number of dependencies that are in <code>pkgs</code>.
This is essentially a topological sort, but it is done
heuristically. This can be used to e.g., <code>detach</code> or
<code>unloadNamespace</code> packages in order so that they each
of their dependencies are detached or unloaded first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgDep(
  packages,
  libPath = .libPaths(),
  which = c("Depends", "Imports", "LinkingTo"),
  recursive = FALSE,
  depends,
  imports,
  suggests,
  linkingTo,
  repos = getOption("repos"),
  keepVersionNumber = TRUE,
  includeBase = FALSE,
  sort = TRUE,
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose"),
  includeSelf = TRUE,
  type = getOption("pkgType")
)

pkgDep2(
  packages,
  recursive = TRUE,
  which = c("Depends", "Imports", "LinkingTo"),
  depends,
  imports,
  suggests,
  linkingTo,
  repos = getOption("repos"),
  sorted = TRUE,
  purge = getOption("Require.purge", FALSE),
  includeSelf = TRUE,
  verbose = getOption("Require.verbose")
)

pkgDepTopoSort(
  pkgs,
  deps,
  reverse = FALSE,
  topoSort = TRUE,
  libPath = .libPaths(),
  useAllInSearch = FALSE,
  returnFull = TRUE,
  recursive = TRUE,
  purge = getOption("Require.purge", FALSE),
  which = c("Depends", "Imports", "LinkingTo"),
  type = getOption("pkgType"),
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkgDep_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to install via
<code>install.packages</code>, then load (i.e., with <code>library</code>). If it is one package,
it can be unquoted (as in <code>require</code>). In the case of a GitHub package, it
will be assumed that the name of the repository is the name of the package.
If this is not the case, then pass a named character vector here, where the
names are the package names that could be different than the GitHub
repository name.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_libpath">libPath</code></td>
<td>
<p>A path to search for installed packages. Defaults to
<code>.libPaths()</code></p>
</td></tr>
<tr><td><code id="pkgDep_+3A_which">which</code></td>
<td>
<p>a character vector listing the types of dependencies, a subset
of <code>c("Depends", "Imports", "LinkingTo", "Suggests", "Enhances")</code>.
Character string <code>"all"</code> is shorthand for that vector, character string
<code>"most"</code> for the same vector without <code>"Enhances"</code>.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_recursive">recursive</code></td>
<td>
<p>Logical. Should dependencies of dependencies be searched,
recursively. NOTE: Dependencies of suggests will not be recursive. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_depends">depends</code></td>
<td>
<p>Logical. Include packages listed in &quot;Depends&quot;. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_imports">imports</code></td>
<td>
<p>Logical. Include packages listed in &quot;Imports&quot;. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_suggests">suggests</code></td>
<td>
<p>Logical. Include packages listed in &quot;Suggests&quot;. Default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_linkingto">linkingTo</code></td>
<td>
<p>Logical. Include packages listed in &quot;LinkingTo&quot;. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_repos">repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_keepversionnumber">keepVersionNumber</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the package dependencies
returned will include version number. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="pkgDep_+3A_includebase">includeBase</code></td>
<td>
<p>Logical. Should R base packages be included, specifically,
those in <code>tail(.libPath(), 1)</code></p>
</td></tr>
<tr><td><code id="pkgDep_+3A_sort">sort</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then the packages will be sorted
alphabetically. If <code>FALSE</code>, the packages will not have a discernible order
as they will be a concatenation of the possibly recursive package
dependencies.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_includeself">includeSelf</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then the dependencies
will include the package itself in the returned list elements, otherwise,
only the &quot;dependencies&quot;</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
<tr><td><code id="pkgDep_+3A_sorted">sorted</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, the packages will be sorted in
the returned list from most number of dependencies to least.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_pkgs">pkgs</code></td>
<td>
<p>A vector of package names to evaluate their
reverse depends (i.e., the packages that <em>use</em> each
of these packages)</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_deps">deps</code></td>
<td>
<p>An optional named list of (reverse) dependencies.
If not supplied, then <code>tools::dependsOnPkgs(..., recursive = TRUE)</code>
will be used</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_reverse">reverse</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then this will use <code>tools::pkgDependsOn</code>
to determine which packages depend on the <code>pkgs</code></p>
</td></tr>
<tr><td><code id="pkgDep_+3A_toposort">topoSort</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then
the returned list of packages will be in order with the
least number of dependencies listed in <code>pkgs</code> at
the top of the list.</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_useallinsearch">useAllInSearch</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then all non-core
R packages in <code>search()</code> will be appended to <code>pkgs</code>
to allow those to also be identified</p>
</td></tr>
<tr><td><code id="pkgDep_+3A_returnfull">returnFull</code></td>
<td>
<p>Logical. Primarily useful when <code>reverse = TRUE</code>.
If <code>TRUE</code>, then then all installed packages will be searched.
If <code>FALSE</code>, the default, only packages that are currently in
the <code>search()</code> path and passed in <code>pkgs</code> will be included
in the possible reverse dependencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A possibly ordered, named (with packages as names) list where list elements
are either full reverse depends.
</p>


<h3>Note</h3>

<p><code>tools::package_dependencies</code> and <code>pkgDep</code> will differ under the
following circumstances: </p>
 <ol>
<li><p> GitHub packages are not detected
using <code>tools::package_dependencies</code>; </p>
</li>
<li> <p><code>tools::package_dependencies</code>
does not detect the dependencies of base packages among themselves, <em>e.g.</em>,
<code>methods</code> depends on <code>stats</code> and <code>graphics</code>. </p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()

  pkgDep("tidyverse", recursive = TRUE)

  # GitHub, local, and CRAN packages
  pkgDep(c("PredictiveEcology/reproducible", "Require", "plyr"))

  Require:::.cleanup(opts)
}

## End(Not run)
## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()

  pkgDep2("reproducible")
  # much bigger one
  pkgDep2("tidyverse")

  Require:::.cleanup(opts)
}

## End(Not run)
## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()

  pkgDepTopoSort(c("Require", "data.table"), reverse = TRUE)

  Require:::.cleanup(opts)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='pkgDepIfDepRemoved'>Package dependencies when one or more packages removed</h2><span id='topic+pkgDepIfDepRemoved'></span>

<h3>Description</h3>

<p>This is primarily for package developers. It allows the testing of what the
recursive dependencies would be if a package was removed from the immediate
dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgDepIfDepRemoved(
  pkg = character(),
  depsRemoved = character(),
  verbose = getOption()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkgDepIfDepRemoved_+3A_pkg">pkg</code></td>
<td>
<p>A package name to be testing the dependencies</p>
</td></tr>
<tr><td><code id="pkgDepIfDepRemoved_+3A_depsremoved">depsRemoved</code></td>
<td>
<p>A vector of package names who are to be &quot;removed&quot; from the
<code>pkg</code> immediate dependencies</p>
</td></tr>
<tr><td><code id="pkgDepIfDepRemoved_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 named lists <code>Direct</code>, <code>Recursive</code> and <code>IfRemoved</code>.
<code>Direct</code> will show the top level direct dependencies, either <code>Remaining</code> or
<code>Removed</code>. <code>Recursive</code> will show the full recursive dependencies, either
<code>Remaining</code> or <code>Removed</code>. <code>IfRemoved</code> returns all package dependencies that
are removed for each top level dependency. If a top level dependency is not
listed in this final list, then it means that it is also a recursive
dependency elsewhere, so its removal has no effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()

  pkgDepIfDepRemoved("reproducible", "data.table")

  Require:::.cleanup(opts)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='pkgSnapshot'>Take a snapshot of all the packages and version numbers</h2><span id='topic+pkgSnapshot'></span><span id='topic+pkgSnapshot2'></span>

<h3>Description</h3>

<p>This can be used later by <code>Require</code> to install or re-install the correct versions. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgSnapshot(
  packageVersionFile = getOption("Require.packageVersionFile"),
  libPaths = .libPaths(),
  standAlone = FALSE,
  purge = getOption("Require.purge", FALSE),
  exact = TRUE,
  includeBase = FALSE,
  verbose = getOption("Require.verbose")
)

pkgSnapshot2(
  packageVersionFile = getOption("Require.packageVersionFile"),
  libPaths,
  standAlone = FALSE,
  purge = getOption("Require.purge", FALSE),
  exact = TRUE,
  includeBase = FALSE,
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkgSnapshot_+3A_packageversionfile">packageVersionFile</code></td>
<td>
<p>A filename to save the packages and their currently
installed version numbers. Defaults to <code>"packageVersions.txt"</code>.
If this is specified to be <code>NULL</code>, the function will return the exact
<code>Require</code> call needed to install all the packages at their current
versions. This can be useful to add to a script to allow for reproducibility of
a script.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_libpaths">libPaths</code></td>
<td>
<p>The path to the local library where packages are installed.
Defaults to the <code>.libPaths()[1]</code>.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_exact">exact</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then for GitHub packages, it
will install the exact SHA, rather than the head of the <code>account/repo@branch</code>. For
CRAN packages, it will install the exact version. If <code>FALSE</code>, then GitHub
packages will identify their branch if that had been specified upon installation,
not a SHA. If the package had been installed with reference to a SHA, then it
will return the SHA as it does not know what branch it came from.
Similarly, CRAN packages will report their version and specify with a <code>&gt;=</code>,
allowing a subsequent user
to install with a minimum version number, as opposed to an exact version number.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_includebase">includeBase</code></td>
<td>
<p>Logical. Should R base packages be included, specifically,
those in <code>tail(.libPath(), 1)</code></p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A file is written with the package names and versions of all packages within <code>libPaths</code>.
This can later be passed to <code>Require</code>.
</p>
<p><code>pkgSnapshot2</code> returns a vector of package names and versions, with no file output. See
examples.
</p>


<h3>Value</h3>

<p>Will both write a file, and (invisibly) return a vector of packages with the
version numbers. This vector can be used directly in <code>Require</code>, though it should likely
be used with <code>require = FALSE</code> to prevent attaching all the packages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()
  # install one archived version so that below does something interesting

  libForThisEx &lt;- tempdir2("Example")
  Require("crayon (==1.5.1)", libPaths = libForThisEx, require = FALSE)
  # Normal use -- using the libForThisEx for example;
  #    normally libPaths would be omitted to get all
  #    packages in user or project library
  tf &lt;- tempfile()

  # writes to getOption("Require.packageVersionFile")
  # within project; also returns a vector
  # of packages with version
  pkgs &lt;- pkgSnapshot(
    packageVersionFile = tf,
    libPaths = libForThisEx
  )

  # Now move this file to another computer e.g. by committing in git,
  #   emailing, googledrive
  #   on next computer/project
  Require(packageVersionFile = tf, libPaths = libForThisEx)

  # Using pkgSnapshot2 to get the vector of packages and versions

  tf &lt;- tempfile()
  pkgs &lt;- pkgSnapshot2(
    packageVersionFile = tf,
    libPaths = libForThisEx
  )
  Require(pkgs, require = FALSE) # will install packages from previous line
  # (likely want require = FALSE
  #  and not load them all)

  Require:::.cleanup(opts)
  unlink(getOption("Require.packageVersionFile"))
}

## End(Not run)

</code></pre>

<hr>
<h2 id='R_TESTSomit'>This environment variable &quot;R_TESTS&quot; is set during testing, and it points to a file
called <code>Startup.Rs</code> that is placed in the <code>.libPaths()</code>.
If the <code>.libPaths()</code> is changed during the testing,
then that file will not be found, and install.packages will
fail to install a package with an error of source file not found.
See: <a href="https://github.com/HenrikBengtsson/startup/issues/19">https://github.com/HenrikBengtsson/startup/issues/19</a>.</h2><span id='topic+R_TESTSomit'></span>

<h3>Description</h3>

<p>The environment variable is set here:
<code style="white-space: pre;">&#8288;https://github.com/wch/r-source/blob/8b6429feb661b02e2b2b6df1757b31cf1250a33e/src/library/tools/R/testing.R#L472-Lundefined&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_TESTSomit()
</code></pre>

<hr>
<h2 id='Require-package'>Require: Installing and Loading R Packages for Reproducible Workflows</h2><span id='topic+Require'></span><span id='topic+Require-package'></span><span id='topic+Install'></span>

<h3>Description</h3>

<p>A single key function, 'Require' that makes rerun-tolerant versions of 'install.packages' and 'require' for CRAN packages, packages no longer on CRAN (i.e., archived), specific versions of packages, and GitHub packages. This approach is developed to create reproducible workflows that are flexible and fast enough to use while in development stages, while able to build snapshots once a stable package collection is found. As with other functions in a reproducible workflow, this package emphasizes functions that return the same result whether it is the first or subsequent times running the function, with subsequent times being sufficiently fast that they can be run every time without undue waiting burden on the user or developer.
</p>
<p>This is an &quot;all in one&quot; function that will run <code>install.packages</code> for CRAN
and GitHub <a href="https://github.com/">https://github.com/</a> packages and will install specific versions
of each package if versions are specified either via an (in)equality (e.g.,
<code>"glue (&gt;=1.6.2)"</code> or <code>"glue (==1.6.2)"</code> for an exact version) or with a
<code>packageVersionFile</code>. If <code>require = TRUE</code>, the default, the function will
then run <code>require</code> on all named packages that satisfy their version
requirements. If packages are already installed (<code>packages</code> supplied), and
their optional version numbers are satisfied, then the &quot;install&quot; component
will be skipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Require(
  packages,
  packageVersionFile,
  libPaths,
  install_githubArgs = list(),
  install.packagesArgs = list(INSTALL_opts = "--no-multiarch"),
  standAlone = getOption("Require.standAlone", FALSE),
  install = getOption("Require.install", TRUE),
  require = getOption("Require.require", TRUE),
  repos = getOption("repos"),
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose", FALSE),
  type = getOption("pkgType"),
  upgrade = FALSE,
  ...
)

Install(
  packages,
  packageVersionFile,
  libPaths,
  install_githubArgs = list(),
  install.packagesArgs = list(INSTALL_opts = "--no-multiarch"),
  standAlone = getOption("Require.standAlone", FALSE),
  install = TRUE,
  repos = getOption("repos"),
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose", FALSE),
  type = getOption("pkgType"),
  upgrade = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Require-package_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to install via
<code>install.packages</code>, then load (i.e., with <code>library</code>). If it is one package,
it can be unquoted (as in <code>require</code>). In the case of a GitHub package, it
will be assumed that the name of the repository is the name of the package.
If this is not the case, then pass a named character vector here, where the
names are the package names that could be different than the GitHub
repository name.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_packageversionfile">packageVersionFile</code></td>
<td>
<p>Character string of a file name or logical. If
<code>TRUE</code>, then this function will load the default file,
<code>getOption("Require.packageVersionFile")</code>. If this argument is provided,
then this will override all any packages passed to <code>packages</code>.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_libpaths">libPaths</code></td>
<td>
<p>The library path (or libraries) where all packages should be
installed, and looked for to load (i.e., call <code>library</code>). This can be used
to create isolated, stand alone package installations, if used with
<code>standAlone = TRUE</code>. Currently, the path supplied here will be prepended to
<code>.libPaths()</code> (temporarily during this call) to <code>Require</code> if
<code>standAlone = FALSE</code> or will set (temporarily) <code>.libPaths()</code> to
<code style="white-space: pre;">&#8288;c(libPaths, tail(libPaths(), 1)&#8288;</code> to keep base packages.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_install_githubargs">install_githubArgs</code></td>
<td>
<p>Deprecated. Values passed here are merged with
<code>install.packagesArgs</code>, with the <code>install.packagesArgs</code> taking precedence
if conflicting.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_install.packagesargs">install.packagesArgs</code></td>
<td>
<p>List of optional named arguments, passed to
<code>install.packages</code>. Default is only <code>--no-multi-arch</code>, meaning that only
the current architecture will be built and installed (e.g., 64 bit, not 32 bit,
in many cases).</p>
</td></tr>
<tr><td><code id="Require-package_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_install">install</code></td>
<td>
<p>Logical or &quot;force&quot;. If <code>FALSE</code>, this will not try to install
anything. If <code>"force"</code>, then it will force installation of requested
packages, mimicking a call to e.g., <code>install.packages</code>. If <code>TRUE</code>, the
default, then this function will try to install any missing packages or
dependencies.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_require">require</code></td>
<td>
<p>Logical or character string. If <code>TRUE</code>, the default, then the
function will attempt to call <code>require</code> on all requested <code>packages</code>,
possibly after they are installed. If a character string, then it will only
call <code>require</code> on those specific packages (i.e., it will install the ones
listed in <code>packages</code>, but load the packages listed in <code>require</code>)</p>
</td></tr>
<tr><td><code id="Require-package_+3A_repos">repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
<tr><td><code id="Require-package_+3A_upgrade">upgrade</code></td>
<td>
<p>When <code>FALSE</code>, the default, will only upgrade a package when the
version on in the local library is not adequate for the version requirements
of the <code>packages</code>. Note: for convenience, <code>update</code>
can be used for this argument.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_...">...</code></td>
<td>
<p>Passed to <code>install.packages</code>. Good candidates are e.g., <code>type</code> or
<code>dependencies</code>. This can be used with <code>install_githubArgs</code> or
<code>install.packageArgs</code> which give individual options for those 2 internal
function calls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Install</code> is the same as <code>Require(..., require = FALSE)</code>, for convenience.
</p>


<h3>Value</h3>

<p><code>Require</code> is intended to replace <code>base::require</code>, thus it returns a
logical, named vector indicating whether the named packages have been loaded.
Because <code>Require</code> also has the ability to install packages, a return value of
<code>FALSE</code> does not mean that it did not install correctly; rather, it means it
did not attach with <code>require</code>, which could be because it did not install
correctly, or also because e.g., <code>require = FALSE</code>.
</p>
<p><code>standAlone</code> will either put the <code>Require</code>d packages and their dependencies
<em>all</em> within the <code>libPaths</code> (if <code>TRUE</code>) or if <code>FALSE</code> will only install
packages and their dependencies that are otherwise not installed in
<code>.libPaths()[1]</code>, i.e., the current active R package directory. Any packages
or dependencies that are not yet installed will be installed in <code>libPaths</code>.
</p>


<h3>GitHub Package</h3>

<p>Follows <code>remotes::install_github</code> standard. As with
<code>remotes::install_github</code>, it is not possible to specify a past version of
a GitHub package unless that version is a tag or the user passes the SHA
that had that package version. Similarly, if a developer does a local
install e.g., via <code>pkgload::install</code>, of an active project, this package
will not be able know of the GitHub state, and thus <code>pkgSnapshot</code> will not
be able to recover this state as there is no SHA associated with a local
installation. Use <code>Require</code> (or <code>remotes::install_github</code>) to create a
record of the GitHub state.
</p>


<h3>Package Snapshots</h3>

<p>To build a snapshot of the desired packages and
their versions, first run <code>Require</code> with all packages, then <code>pkgSnapshot</code>.
If a <code>libPaths</code> is used, it must be used in both functions.
</p>


<h3>Mutual Dependencies</h3>

<p>This function works best if all required
packages are called within one <code>Require</code> call, as all dependencies can be
identified together, and all package versions will be addressed (if there
are no conflicts), allowing a call to <code>pkgSnapshot()</code> to take a snapshot or
&quot;record&quot; of the current collection of packages and versions.
</p>


<h3>Local Cache of Packages</h3>

<p>When installing new packages, <code>Require</code>
will put all source and binary files in an R-version specific subfolder of
<code>getOption("Require.RPackageCache")</code> whose default is <code>RPackageCache()</code>,
meaning <em>cache packages locally in a project-independent location</em>, and
will reuse them if needed. To turn off this feature, set
<code>options("Require.RPackageCache" = FALSE)</code>.
</p>


<h3>Note</h3>

<p>For advanced use and diagnosis, the user can set <code>verbose = TRUE</code> or
<code>1</code> or <code>2</code> (or via <code>options("Require.verbose")</code>). This will attach an
attribute <code>attr(obj, "Require")</code> to the output of this function.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eliot J B McIntire <a href="mailto:eliot.mcintire@canada.ca">eliot.mcintire@canada.ca</a> (<a href="https://orcid.org/0000-0002-6914-8316">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Alex M Chubaty <a href="mailto:achubaty@for-cast.ca">achubaty@for-cast.ca</a> (<a href="https://orcid.org/0000-0001-7146-8135">ORCID</a>) [contributor]
</p>
</li>
<li><p> Her Majesty the Queen in Right of Canada, as represented by the Minister of Natural Resources Canada [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://Require.predictiveecology.org">https://Require.predictiveecology.org</a>
</p>
</li>
<li> <p><a href="https://github.com/PredictiveEcology/Require">https://github.com/PredictiveEcology/Require</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/PredictiveEcology/Require/issues">https://github.com/PredictiveEcology/Require/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simple usage, like conditional install.packages then library
opts &lt;- Require:::.setupExample()

library(Require)
getCRANrepos(ind = 1)
Require("stats") # analogous to require(stats), but it checks for
#   pkg dependencies, and installs them, if missing

if (Require:::.runLongExamples()) {
  # Install in a new local library (libPaths)
  tempPkgFolder &lt;- file.path(tempdir(), "Packages")
  # use standAlone, means it will put it in libPaths, even if it already exists
  #   in another local library (e.g., personal library)
  Install("crayon", libPaths = tempPkgFolder, standAlone = TRUE)

  # make a package version snapshot of installed packages
  tf &lt;- tempfile()
  (pkgSnapshot(tf, standAlone = TRUE))

  # Change the libPaths to emulate a new computer or project
  tempPkgFolder &lt;- file.path(tempdir(), "Packages2")
  # Reinstall and reload the exact version from previous
  Require(packageVersionFile = tf, libPaths = tempPkgFolder, standAlone = TRUE)

  # Mutual dependencies, only installs once -- e.g., curl
  tempPkgFolder &lt;- file.path(tempdir(), "Packages")
  Install(c("remotes", "testit"), libPaths = tempPkgFolder, standAlone = TRUE)

  # Mutual dependencies, only installs once -- e.g., curl
  tempPkgFolder &lt;- file.path(tempdir(), "Packages")
  Install(c("covr", "httr"), libPaths = tempPkgFolder, standAlone = TRUE)

  #####################################################################################
  # Isolated projects -- Use a project folder and pass to libPaths or set .libPaths() #
  #####################################################################################
  # GitHub packages
  ProjectPackageFolder &lt;- file.path(tempdir(), "ProjectA")
  Require("PredictiveEcology/fpCompare@development",
    libPaths = ProjectPackageFolder, standAlone = FALSE
  )

  Install("PredictiveEcology/fpCompare@development",
    libPaths = ProjectPackageFolder,
    standAlone = TRUE
  ) # the latest version on GitHub

  ############################################################################
  # Mixing and matching GitHub, CRAN, with and without version numbering
  ############################################################################
  pkgs &lt;- c(
    "remotes (&lt;=2.4.1)", # old version
    "digest (&gt;= 0.6.28)", # recent version
    "PredictiveEcology/fpCompare@a0260b8476b06628bba0ae73af3430cce9620ca0" # exact version
  )
  Require::Require(pkgs, libPaths = ProjectPackageFolder)
  Require:::.cleanup(opts)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='RequireCacheDir'>Path to (package) cache directory</h2><span id='topic+RequireCacheDir'></span><span id='topic+RequirePkgCacheDir'></span>

<h3>Description</h3>

<p>Sets (if <code>create = TRUE</code>) or gets the cache
directory associated with the <code>Require</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RequireCacheDir(create)

RequirePkgCacheDir(create)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RequireCacheDir_+3A_create">create</code></td>
<td>
<p>A logical indicating whether the path should
be created if it does not exist. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To set a different directory than the default, set the system variable:
<code>R_USER_CACHE_DIR = "somePath"</code> and/or <code>R_REQUIRE_PKG_CACHE = "somePath"</code>
e.g., in <code>.Renviron</code> file or <code>Sys.setenv()</code>. See Note below.
</p>


<h3>Value</h3>

<p>If <code>!is.null(getOptionRPackageCache())</code>, i.e., a cache path exists,
the cache directory will be created,
with a README placed in the folder. Otherwise, this function will just
return the path of what the cache directory would be.
</p>


<h3>Note</h3>

<p>Currently, there are 2 different Cache directories used by Require:
<code>RequireCacheDir</code> and <code>RequirePkgCacheDir</code>. The <code>RequirePkgCacheDir</code>
is intended to be a sub-directory of the <code>RequireCacheDir</code>. If you set
<code>Sys.setenv("R_USER_CACHE_DIR" = "somedir")</code>, then both the package cache
and cache dirs will be set, with the package cache a sub-directory. You can, however,
set them independently, if you set <code>"R_USER_CACHE_DIR"</code> and <code>"R_REQUIRE_PKG_CACHE"</code>
environment variable. The package cache can also be set with
<code>options("Require.RPackageCache" = "somedir")</code>.
</p>

<hr>
<h2 id='RequireOptions'><code>Require</code> options</h2><span id='topic+RequireOptions'></span><span id='topic+getRequireOptions'></span>

<h3>Description</h3>

<p>These provide top-level, powerful settings for a comprehensive reproducible
workflow. See Details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RequireOptions()

getRequireOptions()
</code></pre>


<h3>Details</h3>


<dl>
<dt><code>RequireOptions()</code></dt><dd><p>prints the default values of package
options set at startup, which may have been changed (e.g., by the user)
during the current session.</p>
</dd>
<dt><code>getRequireOptions()</code></dt><dd><p>prints the current
values of package options.</p>
</dd> </dl>

<p>Below are options that can be set with <code>options("Require.xxx" = newValue)</code>,
where <code>xxx</code> is one of the values below, and <code>newValue</code> is a new value to give
the option. Sometimes these options can be placed in the user's <code>.Rprofile</code>
file so they persist between sessions.
</p>
<p>The following options are likely of interest to most users: </p>

<dl>
<dt><code>install</code></dt><dd><p> Default: <code>TRUE</code>. This is the default argument to <code>Require</code>,
but does not affect <code>Install</code>. If this is <code>FALSE</code>, then no installations
will be attempted, and missing packages will result in an error. </p>
</dd>
<dt><code>RPackageCache</code></dt><dd><p> Default: <code>getOptionRPackageCache()</code>, which must be
either a path or a logical. To turn off package caching, set this to <code>FALSE</code>.
This can be set using an environment variable e.g.
<code>Sys.setenv(R_REQUIRE_PKG_CACHE = "somePath")</code>, or
<code>Sys.setenv(R_REQUIRE_PKG_CACHE = "TRUE")</code>; if that is not set, then an
either a path or logical option (<code>options(Require.RPackageCache = "somePath")</code> or <code>options(Require.RPackageCache = TRUE)</code>). If <code>TRUE</code>, the
default folder location <code>RequirePkgCacheDir()</code> will be used. If this is
<code>TRUE</code> or a path is provided, then binary and source packages will be cached
here. Subsequent downloads of same package will use local copy. Default is to
have packages not be cached locally so each install of the same version will
be from the original source, e.g., CRAN, GitHub. </p>
</dd>
<dt><code>otherPkgs</code></dt><dd><p> Default: A character vector of packages that are
generally more successful if installed from Source on Unix-alikes. Since
there are repositories that offer binary packages builds for Linux (e.g.,
RStudio Package Manager), the vector of package names indicated here will
default to a standard CRAN repository, forcing a source install. See also
<code>spatialPkgs</code> option, which does the same for spatial packages. </p>
</dd>
<dt><code>purge</code></dt><dd><p> Default: <code>FALSE</code>. If set to (almost) all internal caches used
by <code>Require</code> will be deleted and rebuilt. This should not generally be
necessary as it will automatically be deleted after (by default) 1 hour (set
via <code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code> environment variable in
seconds) </p>
</dd>
<dt><code>spatialPkgs</code></dt><dd><p> Default: A character vector of packages that are
generally more successful if installed from Source on Unix-alikes. Since
there are repositories that offer binary packages builds for Linux (e.g.,
RStudio Package Manager), the vector of package names indicated here will
default to a standard CRAN repository, forcing a source install. See also
<code>otherPkgs</code> option, which does the same for non-spatial packages. </p>
</dd>
<dt><code>useCranCache</code></dt><dd><p> Default: <code>FALSE</code>. A user can optionally use the
locally cached packages that are available due to a user's use of the
<code>crancache</code> package.
</p>
</dd>
<dt><code>verbose</code></dt><dd><p> Default: <code>1</code>. See ?Require.
</p>
</dd>
</dl>


<hr>
<h2 id='rversions'>R versions</h2><span id='topic+rversions'></span>

<h3>Description</h3>

<p>Reference table of R versions and their release dates (2018 and later).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rversions
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 21 rows and 2 columns.
</p>


<h3>Details</h3>

<p>Update this as needed using <code>rversions::r_versions()</code>:
</p>
<p><code style="white-space: pre;">&#8288;
# install.packages("rversions")
v = rversions::r_versions()
keep = which(as.Date(v$date, format = "
             as.Date("2018-01-01", format = "
dput(v[keep, c("version", "date")])
&#8288;</code>
</p>

<hr>
<h2 id='setdiffNamed'>Like <code>setdiff</code>, but takes into account names</h2><span id='topic+setdiffNamed'></span>

<h3>Description</h3>

<p>This will identify the elements in <code>l1</code> that are not in <code>l2</code>. If
<code>missingFill</code> is provided, then elements that are in <code>l2</code>, but not in <code>l1</code>
will be returned, assigning <code>missingFill</code> to their values. This might be
<code>NULL</code> or <code>""</code>, i.e., some sort of empty value. This function will work on
named lists, named vectors and likely on other named classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setdiffNamed(l1, l2, missingFill)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setdiffNamed_+3A_l1">l1</code></td>
<td>
<p>A named list or named vector</p>
</td></tr>
<tr><td><code id="setdiffNamed_+3A_l2">l2</code></td>
<td>
<p>A named list or named vector (must be same class as <code>l1</code>)</p>
</td></tr>
<tr><td><code id="setdiffNamed_+3A_missingfill">missingFill</code></td>
<td>
<p>A value, such as <code>NULL</code> or <code>""</code> or <code>"missing"</code> that will
be given to the elements returned, that are in <code>l2</code>, but not in <code>l1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 3 types of differences that might occur with named
elements: 1. a new named element, 2. an removed named element, and 3. a
modified named element. This function captures all of these. In the case of
unnamed elements, e.g., <code>setdiff</code>, the first two are not seen as differences,
if the values are not different.
</p>


<h3>Value</h3>

<p>A vector or list of the elements in <code>l1</code> that are not in <code>l2</code>, and
optionally the elements of <code>l2</code> that are not in <code>l1</code>, with values set to
<code>missingFill</code>
</p>

<hr>
<h2 id='setLibPaths'>Set <code>.libPaths</code></h2><span id='topic+setLibPaths'></span>

<h3>Description</h3>

<p>This will set the <code>.libPaths()</code> by either adding a new path to it if
<code>standAlone = FALSE</code>, or will concatenate <code>c(libPath, tail(.libPaths(), 1))</code>
if <code>standAlone = TRUE</code>. Currently, the default is to make this new
<code>.libPaths()</code> &quot;sticky&quot;, meaning it becomes associated with the current
directory even through a restart of R. It does this by adding and/updating
the &lsquo;<span class="file">.Rprofile</span>&rsquo; file in the current directory. If this current directory
is a project, then the project will have the new <code>.libPaths()</code> associated
with it, even through an R restart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLibPaths(
  libPaths,
  standAlone = TRUE,
  updateRprofile = getOption("Require.updateRprofile", FALSE),
  exact = FALSE,
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setLibPaths_+3A_libpaths">libPaths</code></td>
<td>
<p>A new path to append to, or replace all existing user
components of <code>.libPath()</code></p>
</td></tr>
<tr><td><code id="setLibPaths_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
<tr><td><code id="setLibPaths_+3A_updaterprofile">updateRprofile</code></td>
<td>
<p>Logical or Character string. If <code>TRUE</code>, then this
function will put several lines of code in the current directory's
<code>.Rprofile</code> file setting up the package libraries for this and future
sessions. If a character string, then this should be the path to an
<code>.Rprofile</code> file. To reset back to normal, run <code>setLibPaths()</code> without a
<code>libPath</code>. Default: <code>getOption("Require.updateRprofile", FALSE)</code>, meaning
<code>FALSE</code>, but it can be set with an option or within a single call.</p>
</td></tr>
<tr><td><code id="setLibPaths_+3A_exact">exact</code></td>
<td>
<p>Logical. This function will automatically append the R version
number to the <code>libPaths</code> to maintain separate R package libraries for each
R version on the system. There are some cases where this behaviour is not
desirable. Set <code>exact</code> to <code>TRUE</code> to override this automatic appending and
use the exact, unaltered <code>libPaths</code>. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="setLibPaths_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This details of this code were modified from
<a href="https://github.com/milesmcbain">https://github.com/milesmcbain</a>. A different, likely non-approved by CRAN
approach that also works is here:
<a href="https://stackoverflow.com/a/36873741/3890027">https://stackoverflow.com/a/36873741/3890027</a>.
</p>


<h3>Value</h3>

<p>The main point of this function is to set <code>.libPaths()</code>, which will
be changed as a side effect of this function. As when setting <code>options</code>,
this will return the previous state of <code>.libPaths()</code> allowing the user to
reset easily.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()
  origDir &lt;- setwd(tempdir())
  td &lt;- tempdir()
  setLibPaths(td) # set a new R package library locally
  setLibPaths() # reset it to original
  setwd(origDir)
  # Using standAlone = FALSE means that newly installed packages
  #   will be installed
  #   in the new package library, but loading packages can come
  #   from any of the ones listed in .libPaths()

  # will have 2 or more paths
  otherLib &lt;- file.path(td, "newProjectLib")
  setLibPaths(otherLib, standAlone = FALSE)
  # Can restart R, and changes will stay

  # remove the custom .libPaths()
  setLibPaths() # reset to previous; remove from .Rprofile
  # because libPath arg is empty

  Require:::.cleanup(opts)
  unlink(otherLib, recursive = TRUE)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='setLinuxBinaryRepo'>Setup for binary Linux repositories</h2><span id='topic+setLinuxBinaryRepo'></span>

<h3>Description</h3>

<p>Enable use of binary package builds for Linux from the RStudio Package
Manager repo. This will set the <code>repos</code> option, affecting the current R
session. It will put this <code>binaryLinux</code> in the first position. If the
<code>getOption("repos")</code> is <code>NULL</code>, it will put <code>backupCRAN</code> in second position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLinuxBinaryRepo(
  binaryLinux = "https://packagemanager.posit.co/",
  backupCRAN = srcPackageURLOnCRAN
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setLinuxBinaryRepo_+3A_binarylinux">binaryLinux</code></td>
<td>
<p>A CRAN repository serving binary Linux packages.</p>
</td></tr>
<tr><td><code id="setLinuxBinaryRepo_+3A_backupcran">backupCRAN</code></td>
<td>
<p>If there is no CRAN repository set</p>
</td></tr>
</table>

<hr>
<h2 id='setup'>Setup a project library, cache, options</h2><span id='topic+setup'></span><span id='topic+setupOff'></span>

<h3>Description</h3>

<p><code>setup</code> and <code>setupOff</code> are currently deprecated.
These may be re-created in a future version.
In its place, a user can simply put <code>.libPaths(libs, include.site = FALSE)</code>
in their <code>.Rprofile</code> file, where <code>libs</code> is the directory where the packages
should be installed and should be a folder with the R version number, e.g.,
derived by using <code>checkLibPaths(libs)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup(
  newLibPaths,
  RPackageFolders,
  RPackageCache = getOptionRPackageCache(),
  standAlone = getOption("Require.standAlone", TRUE),
  verbose = getOption("Require.verbose")
)

setupOff(removePackages = FALSE, verbose = getOption("Require.verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_+3A_newlibpaths">newLibPaths</code></td>
<td>
<p>Same as <code>RPackageFolders</code>. This is for more consistent
naming with <code>Require(..., libPaths = ...)</code>.</p>
</td></tr>
<tr><td><code id="setup_+3A_rpackagefolders">RPackageFolders</code></td>
<td>
<p>One or more folders where R packages are
installed to and loaded from. In the case of more than one
folder provided, installation will only happen in the first one.</p>
</td></tr>
<tr><td><code id="setup_+3A_rpackagecache">RPackageCache</code></td>
<td>
<p>See <code>?RequireOptions</code>.</p>
</td></tr>
<tr><td><code id="setup_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
<tr><td><code id="setup_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
<tr><td><code id="setup_+3A_removepackages">removePackages</code></td>
<td>
<p>Deprecated. Please remove packages manually from
the .libPaths()</p>
</td></tr>
</table>

<hr>
<h2 id='sourcePkgs'>A list of R packages that should likely be installed from Source, not Binary</h2><span id='topic+sourcePkgs'></span>

<h3>Description</h3>

<p>The list of R packages that <code>Require</code> installs from source on Linux, even if
the <code>getOptions("repos")</code> is a binary repository. This list can be updated by
the user by modifying the options <code>Require.spatialPkgs</code> or
<code>Require.otherPkgs</code>. Default &quot;force source only packages&quot; are visible with
<code>RequireOptions()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sourcePkgs(additional = NULL, spatialPkgs = NULL, otherPkgs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sourcePkgs_+3A_additional">additional</code></td>
<td>
<p>Any other packages to be added to the other 2 argument vectors</p>
</td></tr>
<tr><td><code id="sourcePkgs_+3A_spatialpkgs">spatialPkgs</code></td>
<td>
<p>A character vector of package names that focus on spatial analyses.</p>
</td></tr>
<tr><td><code id="sourcePkgs_+3A_otherpkgs">otherPkgs</code></td>
<td>
<p>A character vector of package names that often
require system specific compilation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted concatenation of the 3 input parameters.
</p>

<hr>
<h2 id='tempdir2'>Make a temporary (sub-)directory</h2><span id='topic+tempdir2'></span>

<h3>Description</h3>

<p>Create a temporary subdirectory in <code>.RequireTempPath()</code>, or a
temporary file in that temporary subdirectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempdir2(
  sub = "",
  tempdir = getOption("Require.tempPath", .RequireTempPath()),
  create = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tempdir2_+3A_sub">sub</code></td>
<td>
<p>Character string, length 1. Can be a result of
<code>file.path("smth", "smth2")</code> for nested temporary sub
directories.</p>
</td></tr>
<tr><td><code id="tempdir2_+3A_tempdir">tempdir</code></td>
<td>
<p>Optional character string where the
temporary dir should be placed. Defaults to <code>.RequireTempPath()</code></p>
</td></tr>
<tr><td><code id="tempdir2_+3A_create">create</code></td>
<td>
<p>Logical. Should the directory be created. Default <code>TRUE</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tempfile2">tempfile2()</a></code>
</p>

<hr>
<h2 id='tempfile2'>Make a temporary subfile in a temporary (sub-)directory</h2><span id='topic+tempfile2'></span>

<h3>Description</h3>

<p>Make a temporary subfile in a temporary (sub-)directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempfile2(
  sub = "",
  tempdir = getOption("Require.tempPath", .RequireTempPath()),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tempfile2_+3A_sub">sub</code></td>
<td>
<p>Character string, length 1. Can be a result of
<code>file.path("smth", "smth2")</code> for nested temporary sub
directories.</p>
</td></tr>
<tr><td><code id="tempfile2_+3A_tempdir">tempdir</code></td>
<td>
<p>Optional character string where the
temporary dir should be placed. Defaults to <code>.RequireTempPath()</code></p>
</td></tr>
<tr><td><code id="tempfile2_+3A_...">...</code></td>
<td>
<p>passed to <code>tempfile</code>, e.g., <code>fileext</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tempdir2">tempdir2()</a></code>
</p>

<hr>
<h2 id='trimVersionNumber'>Trim version number off a compound package name</h2><span id='topic+trimVersionNumber'></span>

<h3>Description</h3>

<p>The resulting string(s) will have only name (including github.com repository if it exists).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimVersionNumber(pkgs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimVersionNumber_+3A_pkgs">pkgs</code></td>
<td>
<p>A character string vector of packages with or without GitHub path or versions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+extractPkgName">extractPkgName()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trimVersionNumber("PredictiveEcology/Require (&lt;=0.0.1)")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
