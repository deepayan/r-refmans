<!DOCTYPE html><html lang="en-CA"><head><title>Help for package Require</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Require}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Require-package'><p>Require: Installing and Loading R Packages for Reproducible Workflows</p></a></li>
<li><a href='#.downloadFileMasterMainAuth'><p>GITHUB_PAT-aware and <code>main</code>-<code>master</code>-aware download from GitHub</p></a></li>
<li><a href='#.installed.pkgs'><p>Partial alternative (faster) to <code>installed.packages</code></p></a></li>
<li><a href='#availablePackagesOverride'><p>Create a custom &quot;available.packages&quot; object</p></a></li>
<li><a href='#availableVersionOK'><p>Needs <code>VersionOnRepos</code>, <code>versionSpec</code> and <code>inequality</code> columns</p></a></li>
<li><a href='#cacheClearPackages'><p>Clear Require Cache elements</p></a></li>
<li><a href='#cacheDefaultDir'><p>The default cache directory for Require Cache</p></a></li>
<li><a href='#cacheDir'><p>Path to (package) cache directory</p></a></li>
<li><a href='#cacheGetOptionCachePkgDir'><p>Get the option for <code>Require.cachePkgDir</code></p></a></li>
<li><a href='#cachePurge'><p>Purge everything in the Require cache</p></a></li>
<li><a href='#checkLibPaths'><p>Creates the directories, and adds version number</p></a></li>
<li><a href='#checkPath'><p>Check directory path</p></a></li>
<li><a href='#chooseCRANmirror2'><p>Pass through function for <code>chooseCRANmirror</code></p></a></li>
<li><a href='#compareVersion2'><p>Compare package versions</p></a></li>
<li><a href='#dealWithMissingLibPaths'><p>Only checks for deprecated libPath argument (singular)</p></a></li>
<li><a href='#DESCRIPTIONFileVersionV'><p>GitHub package tools</p></a></li>
<li><a href='#detachAll'><p>Detach and unload all packages</p></a></li>
<li><a href='#dlArchiveVersionsAvailable'><p>Available and archived versions</p></a></li>
<li><a href='#doLibPaths'><p>Deals with missing libPaths arg, and takes first</p></a></li>
<li><a href='#envPkgCreate'><p>1st level &ndash;&gt; create the .pkgEnv object in Require</p></a></li>
<li><a href='#envPkgDepDepsCreate'><p>3rd level  for deps #############################################</p></a></li>
<li><a href='#envPkgDepDESCFileCreate'><p>3rd level for DESCRIPTIONFile</p></a></li>
<li><a href='#extractPkgName'><p>Extract info from package character strings</p></a></li>
<li><a href='#getCRANrepos'><p>A helper function to get or set CRAN repos</p></a></li>
<li><a href='#getDeps'><p>The <code>packages</code> argument may have up to 4 pieces of information for GitHub</p>
packages: name, repository, branch, version. For CRAN-alikes, it will only
be 2 pieces: name, version. There can also be an inequality or equality, if
there is a version.</a></li>
<li><a href='#invertList'><p>Invert a 2-level list</p></a></li>
<li><a href='#joinToAvailablePackages'><p>Join a data.table with a <code>Package</code> column to <code>available.packages</code></p></a></li>
<li><a href='#linkOrCopy'><p>Create link to file, falling back to making a copy if linking fails.</p></a></li>
<li><a href='#masterMainToHead'><p>This converts master or main to HEAD for a git repo</p></a></li>
<li><a href='#messageDF'><p>Use message to print a clean square data structure</p></a></li>
<li><a href='#modifyList2'><p><code>modifyList</code> for multiple lists</p></a></li>
<li><a href='#normPath'><p>Normalize filepath</p></a></li>
<li><a href='#paddedFloatToChar'><p>Convert numeric to character with padding</p></a></li>
<li><a href='#pakEnv'><p>2nd level</p></a></li>
<li><a href='#parseGitHub'><p>Parse a github package specification</p></a></li>
<li><a href='#pkgDepEnv'><p>2nd level</p></a></li>
<li><a href='#pkgDepIfDepRemoved'><p>Package dependencies when one or more packages removed</p></a></li>
<li><a href='#pkgDepTopoSort'><p>Reverse package depends</p></a></li>
<li><a href='#pkgSnapshot'><p>Take a snapshot of all the packages and version numbers</p></a></li>
<li><a href='#R_TESTSomit'><p>This environment variable &quot;R_TESTS&quot; is set during testing, and it points to a file</p>
called <code>Startup.Rs</code> that is placed in the <code>.libPaths()</code>.
If the <code>.libPaths()</code> is changed during the testing,
then that file will not be found, and install.packages will
fail to install a package with an error of source file not found.
See: <a href="https://github.com/HenrikBengtsson/startup/issues/19">https://github.com/HenrikBengtsson/startup/issues/19</a>.</a></li>
<li><a href='#RequireOptions'><p><code>Require</code> options</p></a></li>
<li><a href='#rmBase'><p>Recursive function to remove <code>.basePkgs</code></p></a></li>
<li><a href='#rversions'><p>R versions</p></a></li>
<li><a href='#setdiffNamed'><p>Like <code>setdiff</code>, but takes into account names</p></a></li>
<li><a href='#setLibPaths'><p>Set <code>.libPaths</code></p></a></li>
<li><a href='#setLinuxBinaryRepo'><p>Setup for binary Linux repositories</p></a></li>
<li><a href='#setup'><p>Setup a project library, cache, options</p></a></li>
<li><a href='#sourcePkgs'><p>A list of R packages that should likely be installed from Source, not Binary</p></a></li>
<li><a href='#splitKeepOrderAndDTIntegrity'><p><code>split</code> for a data.table that keeps integrity of a column of lists of data.table objects</p></a></li>
<li><a href='#sysInstallAndDownload'><p>download.files or install.packages in a separate process</p></a></li>
<li><a href='#tempdir2'><p>Make a temporary (sub-)directory</p></a></li>
<li><a href='#tempfile2'><p>Make a temporary subfile in a temporary (sub-)directory</p></a></li>
<li><a href='#trimVersionNumber'><p>Trim version number off a compound package name</p></a></li>
<li><a href='#updatePackages'><p>Update installed packages with latest available versions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Installing and Loading R Packages for Reproducible Workflows</td>
</tr>
<tr>
<td>Description:</td>
<td>A single key function, 'Require' that makes rerun-tolerant
    versions of 'install.packages' and 'require' for CRAN packages, packages
    no longer on CRAN (i.e., archived), specific versions of packages, 
    and GitHub packages. This approach is developed to create reproducible 
    workflows that are flexible and fast enough to use while in development stages,
    while able to build snapshots once a stable package collection is found. 
    As with other functions in a reproducible workflow, this package 
    emphasizes functions that return the same result whether it is 
    the first or subsequent times running the function, with subsequent times being
    sufficiently fast that they can be run every time without undue waiting burden on 
    the user or developer.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://Require.predictiveecology.org">https://Require.predictiveecology.org</a>,
<a href="https://github.com/PredictiveEcology/Require">https://github.com/PredictiveEcology/Require</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-06</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.10.4), methods, sys, tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, curl, diffobj, fpCompare, gitcreds, httr, pak,
parallel, rematch2, rmarkdown, knitr, rlang, roxygen2,
rprojroot, testthat (&ge; 3.0.0), tibble, waldo, withr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-CA</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PredictiveEcology/Require/issues">https://github.com/PredictiveEcology/Require/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'CRAN.R' 'Require-helpers.R' 'Require-package.R' 'messages.R'
'Require2.R' 'RequireOptions.R' 'envs.R' 'extract.R'
'helpers.R' 'pak.R' 'pkgDep.R' 'pkgDep3.R' 'pkgSnapshot.R'
'setLibPaths.R' 'setup.R' 'zzz.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-17 15:33:45 UTC; emcintir</td>
</tr>
<tr>
<td>Author:</td>
<td>Eliot J B McIntire
    <a href="https://orcid.org/0000-0002-6914-8316"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Alex M Chubaty <a href="https://orcid.org/0000-0001-7146-8135"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Her Majesty the Queen in Right of Canada, as represented by the
    Minister of Natural Resources Canada [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eliot J B McIntire &lt;eliot.mcintire@canada.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-17 22:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='Require-package'>Require: Installing and Loading R Packages for Reproducible Workflows</h2><span id='topic+Require-package'></span><span id='topic+Require'></span><span id='topic+Install'></span>

<h3>Description</h3>

<p>A single key function, 'Require' that makes rerun-tolerant versions of 'install.packages' and 'require' for CRAN packages, packages no longer on CRAN (i.e., archived), specific versions of packages, and GitHub packages. This approach is developed to create reproducible workflows that are flexible and fast enough to use while in development stages, while able to build snapshots once a stable package collection is found. As with other functions in a reproducible workflow, this package emphasizes functions that return the same result whether it is the first or subsequent times running the function, with subsequent times being sufficiently fast that they can be run every time without undue waiting burden on the user or developer.
</p>
<p>This is an &quot;all in one&quot; function that will run <code>install.packages</code> for CRAN
and GitHub <a href="https://github.com/">https://github.com/</a> packages and will install specific versions
of each package if versions are specified either via an (in)equality (e.g.,
<code>"glue (&gt;=1.6.2)"</code> or <code>"glue (==1.6.2)"</code> for an exact version) or with a
<code>packageVersionFile</code>. If <code>require = TRUE</code>, the default, the function will
then run <code>require</code> on all named packages that satisfy their version
requirements. If packages are already installed (<code>packages</code> supplied), and
their optional version numbers are satisfied, then the &quot;install&quot; component
will be skipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Require(
  packages,
  packageVersionFile,
  libPaths,
  install_githubArgs = list(),
  install.packagesArgs = list(INSTALL_opts = "--no-multiarch"),
  standAlone = getOption("Require.standAlone", FALSE),
  install = getOption("Require.install", TRUE),
  require = getOption("Require.require", TRUE),
  repos = getOption("repos"),
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose", FALSE),
  type = getOption("pkgType"),
  upgrade = FALSE,
  returnDetails = FALSE,
  ...
)

Install(
  packages,
  packageVersionFile,
  libPaths,
  install_githubArgs = list(),
  install.packagesArgs = list(INSTALL_opts = "--no-multiarch"),
  standAlone = getOption("Require.standAlone", FALSE),
  install = TRUE,
  repos = getOption("repos"),
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose", FALSE),
  type = getOption("pkgType"),
  upgrade = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Require-package_+3A_packages">packages</code></td>
<td>
<p>Either a character vector of packages to install via
<code>install.packages</code>, then load (i.e., with <code>library</code>), or, for convenience,
a vector or list (using <code>c</code> or <code>list</code>) of unquoted package names to install
and/or load (as in <code>require</code>, but vectorized). Passing vectors of names may
not work in all cases, so user should confirm before relying on this behaviour
in operational code.
In the case of a GitHub package, it
will be assumed that the name of the repository is the name of the package.
If this is not the case, then pass a <em>named</em> character vector here, where the
names are the package names that could be different than the GitHub
repository name.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_packageversionfile">packageVersionFile</code></td>
<td>
<p>Character string of a file name or logical. If
<code>TRUE</code>, then this function will load the default file,
<code>getOption("Require.packageVersionFile")</code>. If this argument is provided,
then this will override any packages passed to <code>packages</code>. By default,
<code>Require</code> will attempt to resolve dependency violations (i.e., if this
<code>packageVersionFile</code> specifies a version of a package that violates
the dependency specification of another package). If a user wishes to attempt
to install the <code>packageVersionFile</code> without assessing the dependencies,
set <code>dependencies = FALSE</code>.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_libpaths">libPaths</code></td>
<td>
<p>The library path (or libraries) where all packages should be
installed, and looked for to load (i.e., call <code>library</code>). This can be used
to create isolated, stand alone package installations, if used with
<code>standAlone = TRUE</code>. Currently, the path supplied here will be prepended to
<code>.libPaths()</code> (temporarily during this call) to <code>Require</code> if
<code>standAlone = FALSE</code> or will set (temporarily) <code>.libPaths()</code> to
<code style="white-space: pre;">&#8288;c(libPaths, tail(libPaths(), 1)&#8288;</code> to keep base packages.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_install_githubargs">install_githubArgs</code></td>
<td>
<p>Deprecated. Values passed here are merged with
<code>install.packagesArgs</code>, with the <code>install.packagesArgs</code> taking precedence
if conflicting.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_install.packagesargs">install.packagesArgs</code></td>
<td>
<p>List of optional named arguments, passed to
<code>install.packages</code>. Default is only <code>--no-multi-arch</code>, meaning that only
the current architecture will be built and installed (e.g., 64 bit, not 32 bit,
in many cases).</p>
</td></tr>
<tr><td><code id="Require-package_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_install">install</code></td>
<td>
<p>Logical or &quot;force&quot;. If <code>FALSE</code>, this will not try to install
anything. If <code>"force"</code>, then it will force installation of requested
packages, mimicking a call to e.g., <code>install.packages</code>. If <code>TRUE</code>, the
default, then this function will try to install any missing packages or
dependencies.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_require">require</code></td>
<td>
<p>Logical or character string. If <code>TRUE</code>, the default, then the
function will attempt to call <code>require</code> on all requested <code>packages</code>,
possibly after they are installed. If a character string, then it will only
call <code>require</code> on those specific packages (i.e., it will install the ones
listed in <code>packages</code>, but load the packages listed in <code>require</code>)</p>
</td></tr>
<tr><td><code id="Require-package_+3A_repos">repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
<tr><td><code id="Require-package_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
<tr><td><code id="Require-package_+3A_upgrade">upgrade</code></td>
<td>
<p>When <code>FALSE</code>, the default, will only upgrade a package when the
version on in the local library is not adequate for the version requirements
of the <code>packages</code>. Note: for convenience, <code>update</code>
can be used for this argument.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_returndetails">returnDetails</code></td>
<td>
<p>Logical. If <code>TRUE</code> the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td></tr>
<tr><td><code id="Require-package_+3A_...">...</code></td>
<td>
<p>Passed to <code>install.packages</code>. Good candidates are e.g., <code>type</code> or
<code>dependencies</code>. This can be used with <code>install_githubArgs</code> or
<code>install.packageArgs</code> which give individual options for those 2 internal
function calls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Install</code> is the same as <code>Require(..., require = FALSE)</code>, for convenience.
</p>


<h3>Value</h3>

<p><code>Require</code> is intended to replace <code>base::require</code>, thus it returns a
logical, named vector indicating whether the named packages have been loaded.
Because <code>Require</code> also has the ability to install packages, a return value of
<code>FALSE</code> does not mean that it did not install correctly; rather, it means it
did not attach with <code>require</code>, which could be because it did not install
correctly, or also because e.g., <code>require = FALSE</code>.
</p>
<p><code>standAlone</code> will either put the <code>Require</code>d packages and their dependencies
<em>all</em> within the <code>libPaths</code> (if <code>TRUE</code>) or if <code>FALSE</code> will only install
packages and their dependencies that are otherwise not installed in
<code>.libPaths()[1]</code>, i.e., the current active R package directory. Any packages
or dependencies that are not yet installed will be installed in <code>libPaths</code>.
</p>


<h3>GitHub Package</h3>

<p>Follows <code>remotes::install_github</code> standard. As with
<code>remotes::install_github</code>, it is not possible to specify a past version of
a GitHub package unless that version is a tag or the user passes the SHA
that had that package version. Similarly, if a developer does a local
install e.g., via <code>pkgload::install</code>, of an active project, this package
will not be able know of the GitHub state, and thus <code>pkgSnapshot</code> will not
be able to recover this state as there is no SHA associated with a local
installation. Use <code>Require</code> (or <code>remotes::install_github</code>) to create a
record of the GitHub state.
</p>


<h3>Package Snapshots</h3>

<p>To build a snapshot of the desired packages and
their versions, first run <code>Require</code> with all packages, then <code>pkgSnapshot</code>.
If a <code>libPaths</code> is used, it must be used in both functions.
</p>


<h3>Mutual Dependencies</h3>

<p>This function works best if all required
packages are called within one <code>Require</code> call, as all dependencies can be
identified together, and all package versions will be addressed (if there
are no conflicts), allowing a call to <code>pkgSnapshot()</code> to take a snapshot or
&quot;record&quot; of the current collection of packages and versions.
</p>


<h3>Local Cache of Packages</h3>

<p>When installing new packages, <code>Require</code>
will put all source and binary files in an R-version specific subfolder of
<code>getOption("Require.cachePkgDir")</code> whose default is <code>RPackageCache()</code>,
meaning <em>cache packages locally in a project-independent location</em>, and
will reuse them if needed. To turn off this feature, set
<code>options("Require.cachePkgDir" = FALSE)</code>.
</p>


<h3>Note</h3>

<p>For advanced use and diagnosis, the user can set <code>verbose = TRUE</code> or
<code>1</code> or <code>2</code> (or via <code>options("Require.verbose")</code>). This will attach an
attribute <code>attr(obj, "Require")</code> to the output of this function.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eliot J B McIntire <a href="mailto:eliot.mcintire@canada.ca">eliot.mcintire@canada.ca</a> (<a href="https://orcid.org/0000-0002-6914-8316">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Alex M Chubaty <a href="mailto:achubaty@for-cast.ca">achubaty@for-cast.ca</a> (<a href="https://orcid.org/0000-0001-7146-8135">ORCID</a>) [contributor]
</p>
</li>
<li><p> Her Majesty the Queen in Right of Canada, as represented by the Minister of Natural Resources Canada [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://Require.predictiveecology.org">https://Require.predictiveecology.org</a>
</p>
</li>
<li> <p><a href="https://github.com/PredictiveEcology/Require">https://github.com/PredictiveEcology/Require</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/PredictiveEcology/Require/issues">https://github.com/PredictiveEcology/Require/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
opts &lt;- Require:::.setupExample()

library(Require)
getCRANrepos(ind = 1)
Require("utils") # analogous to require(stats), but it checks for
#   pkg dependencies, and installs them, if missing

# unquoted version
Require(c(tools, utils))

if (Require:::.runLongExamples()) {
  # Install in a new local library (libPaths)
  tempPkgFolder &lt;- file.path(tempdir(), "Require/Packages")
  # use standAlone, means it will put it in libPaths, even if it already exists
  #   in another local library (e.g., personal library)
  Install("crayon", libPaths = tempPkgFolder, standAlone = TRUE)

  # Mutual dependencies, only installs once -- e.g., cli
  tempPkgFolder &lt;- file.path(tempdir(), "Require/Packages")
  Install(c("cli", "R6"), libPaths = tempPkgFolder, standAlone = TRUE)

  # Mutual dependencies, only installs once -- e.g., rlang
  tempPkgFolder &lt;- file.path(tempdir(), "Require/Packages")
  Install(c("rlang", "ellipsis"), libPaths = tempPkgFolder, standAlone = TRUE)

  #####################################################################################
  # Isolated projects -- Use a project folder and pass to libPaths or set .libPaths() #
  #####################################################################################
  # GitHub packages
  if (requireNamespace("gitcreds", quietly = TRUE)) {
    #if (is(try(gitcreds::gitcreds_get(), silent = TRUE), "gitcreds")) {
      ProjectPackageFolder &lt;- file.path(tempdir(), "Require/ProjectA")
      if (requireNamespace("curl")) {
        Require("PredictiveEcology/fpCompare@development",
          libPaths = ProjectPackageFolder,
        )
      }

      # No install because it is there already
      Install("PredictiveEcology/fpCompare@development",
        libPaths = ProjectPackageFolder,
      ) # the latest version on GitHub

      ############################################################################
      # Mixing and matching GitHub, CRAN, with and without version numbering
      ############################################################################
      pkgs &lt;- c(
        "remotes (&lt;=2.4.1)", # old version
        "digest (&gt;= 0.6.28)", # recent version
        "PredictiveEcology/fpCompare@a0260b8476b06628bba0ae73af3430cce9620ca0" # exact version
      )
      Require::Require(pkgs, libPaths = ProjectPackageFolder)
    #}
  }
  Require:::.cleanup(opts)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='.downloadFileMasterMainAuth'>GITHUB_PAT-aware and <code>main</code>-<code>master</code>-aware download from GitHub</h2><span id='topic+.downloadFileMasterMainAuth'></span>

<h3>Description</h3>

<p>Equivalent to <code>utils::download.file</code>, but taking the <code>GITHUB_PAT</code> environment
variable and using it to access the Github url.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.downloadFileMasterMainAuth(
  url,
  destfile,
  need = "HEAD",
  verbose = getOption("Require.verbose"),
  verboseLevel = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".downloadFileMasterMainAuth_+3A_url">url</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string (or longer vector
for the <code>"libcurl"</code> method) naming the URL of a resource to be
downloaded.</p>
</td></tr>
<tr><td><code id=".downloadFileMasterMainAuth_+3A_destfile">destfile</code></td>
<td>
<p>a character string (or vector, see the <code>url</code>
argument) with the file path where the downloaded file is to be
saved.  Tilde-expansion is performed.</p>
</td></tr>
<tr><td><code id=".downloadFileMasterMainAuth_+3A_need">need</code></td>
<td>
<p>If specified, user can suggest which <code>master</code> or <code>main</code> or <code>HEAD</code> to
try first. If unspecified, <code>HEAD</code> is used.</p>
</td></tr>
<tr><td><code id=".downloadFileMasterMainAuth_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
<tr><td><code id=".downloadFileMasterMainAuth_+3A_verboselevel">verboseLevel</code></td>
<td>
<p>A numeric indicating what verbose threshold (level) above
which this message will show.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is called for its side effect, namely, the same as <code>utils::download.file</code>, but
using a <code>GITHUB_PAT</code>, it if is in the environment, and trying both <code>master</code> and
<code>main</code> if the actual <code>url</code> specifies either <code>master</code> or <code>main</code> and it does not exist.
</p>

<hr>
<h2 id='.installed.pkgs'>Partial alternative (faster) to <code>installed.packages</code></h2><span id='topic+.installed.pkgs'></span>

<h3>Description</h3>

<p>This reads the DESCRIPTION files only, so can only access fields that are
available in the DESCRIPTION file. This is different than <code>installed.packages</code>
which has many other fields, like &quot;Built&quot;, &quot;NeedsCompilation&quot; etc. If those
fields are needed, then this function will return an empty column in the returned
character matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.installed.pkgs(
  lib.loc = .libPaths(),
  which = c("Depends", "Imports", "LinkingTo"),
  other = NULL,
  purge = getOption("Require.purge", FALSE),
  packages = NULL,
  collapse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".installed.pkgs_+3A_lib.loc">lib.loc</code></td>
<td>

<p>character vector describing the location of <span class="rlang"><b>R</b></span> library trees to
search through, or <code>NULL</code> for all known trees
(see <code><a href="base.html#topic+.libPaths">.libPaths</a></code>).
</p>
</td></tr>
<tr><td><code id=".installed.pkgs_+3A_which">which</code></td>
<td>
<p>a character vector listing the types of dependencies, a subset
of <code>c("Depends", "Imports", "LinkingTo", "Suggests", "Enhances")</code>.
Character string <code>"all"</code> is shorthand for that vector, character string
<code>"most"</code> for the same vector without <code>"Enhances"</code>.</p>
</td></tr>
<tr><td><code id=".installed.pkgs_+3A_other">other</code></td>
<td>
<p>Can supply other fields; the only benefit here is that a user
can specify <code>"github"</code> (lower case) and it will automatically add
c(&quot;GithubRepo&quot;, &quot;GithubUsername&quot;, &quot;GithubRef&quot;, &quot;GithubSHA1&quot;,
&quot;GithubSubFolder&quot;) fields</p>
</td></tr>
<tr><td><code id=".installed.pkgs_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id=".installed.pkgs_+3A_packages">packages</code></td>
<td>
<p>Character vector. If <code>NULL</code> (default), then all installed packages
are searched for. If a character vector is supplied, then it will only return
information about those packages (and is thus faster to execute).</p>
</td></tr>
<tr><td><code id=".installed.pkgs_+3A_collapse">collapse</code></td>
<td>
<p>Logical. If <code>TRUE</code> then the dependency fields will be collapsed;
if <code>FALSE</code> (default) then the <code>which</code> fields will be kept separate.</p>
</td></tr>
</table>

<hr>
<h2 id='availablePackagesOverride'>Create a custom &quot;available.packages&quot; object</h2><span id='topic+availablePackagesOverride'></span>

<h3>Description</h3>

<p>This is the mechanism by which <code>install.packages</code> determines which packages
should be installed from where. With this override, we can indicate arbitrary
<code>repos</code>, <code>Package</code>, <code>File</code> for each individual package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availablePackagesOverride(
  toInstall,
  repos,
  purge,
  type = getOption("pkgType"),
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="availablePackagesOverride_+3A_toinstall">toInstall</code></td>
<td>
<p>A <code>pkgDT</code> object</p>
</td></tr>
<tr><td><code id="availablePackagesOverride_+3A_repos">repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td></tr>
<tr><td><code id="availablePackagesOverride_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="availablePackagesOverride_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
<tr><td><code id="availablePackagesOverride_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>

<hr>
<h2 id='availableVersionOK'>Needs <code>VersionOnRepos</code>, <code>versionSpec</code> and <code>inequality</code> columns</h2><span id='topic+availableVersionOK'></span>

<h3>Description</h3>

<p>Needs <code>VersionOnRepos</code>, <code>versionSpec</code> and <code>inequality</code> columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableVersionOK(pkgDT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="availableVersionOK_+3A_pkgdt">pkgDT</code></td>
<td>
<p>A <code>pkgDT</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='cacheClearPackages'>Clear Require Cache elements</h2><span id='topic+cacheClearPackages'></span><span id='topic+clearRequirePackageCache'></span>

<h3>Description</h3>

<p>Clear Require Cache elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cacheClearPackages(
  packages,
  ask = interactive(),
  Rversion = versionMajorMinor(),
  clearCranCache = FALSE,
  verbose = getOption("Require.verbose")
)

clearRequirePackageCache(
  packages,
  ask = interactive(),
  Rversion = versionMajorMinor(),
  clearCranCache = FALSE,
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cacheClearPackages_+3A_packages">packages</code></td>
<td>
<p>Either missing or a character vector of package names
(currently cannot specify version number) to remove from the local Require
Cache.</p>
</td></tr>
<tr><td><code id="cacheClearPackages_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then it will ask user to confirm</p>
</td></tr>
<tr><td><code id="cacheClearPackages_+3A_rversion">Rversion</code></td>
<td>
<p>An R version (major dot minor, e.g., &quot;4.2&quot;). Defaults to
current R version.</p>
</td></tr>
<tr><td><code id="cacheClearPackages_+3A_clearcrancache">clearCranCache</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then this will also clear the
local <code>crancache</code> cache, which is only relevant if
<code>options(Require.useCranCache = TRUE)</code>, i.e., if <code>Require</code> is using the
<code>crancache</code> cache also</p>
</td></tr>
<tr><td><code id="cacheClearPackages_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>

<hr>
<h2 id='cacheDefaultDir'>The default cache directory for Require Cache</h2><span id='topic+cacheDefaultDir'></span>

<h3>Description</h3>

<p>A wrapper around <code>tools::R_user_dir("Require", which = "cache")</code> that
creates the directory, if it does not exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cacheDefaultDir()
</code></pre>


<h3>Value</h3>

<p>The default cache directory
</p>

<hr>
<h2 id='cacheDir'>Path to (package) cache directory</h2><span id='topic+cacheDir'></span><span id='topic+cachePkgDir'></span>

<h3>Description</h3>

<p>Sets (if <code>create = TRUE</code>) or gets the cache
directory associated with the <code>Require</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cacheDir(create, verbose = getOption("Require.verbose"))

cachePkgDir(create)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cacheDir_+3A_create">create</code></td>
<td>
<p>A logical indicating whether the path should
be created if it does not exist. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cacheDir_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To set a different directory than the default, set the system variable:
<code>R_USER_CACHE_DIR = "somePath"</code> and/or <code>R_REQUIRE_PKG_CACHE = "somePath"</code>
e.g., in <code>.Renviron</code> file or <code>Sys.setenv()</code>. See Note below.
</p>


<h3>Value</h3>

<p>If <code>!is.null(cacheGetOptionCachePkgDir())</code>, i.e., a cache path exists,
the cache directory will be created,
with a README placed in the folder. Otherwise, this function will just
return the path of what the cache directory would be.
</p>


<h3>Note</h3>

<p>Currently, there are 2 different Cache directories used by Require:
<code>cacheDir</code> and <code>cachePkgDir</code>. The <code>cachePkgDir</code>
is intended to be a sub-directory of the <code>cacheDir</code>. If you set
<code>Sys.setenv("R_USER_CACHE_DIR" = "somedir")</code>, then both the package cache
and cache dirs will be set, with the package cache a sub-directory. You can, however,
set them independently, if you set <code>"R_USER_CACHE_DIR"</code> and <code>"R_REQUIRE_PKG_CACHE"</code>
environment variable. The package cache can also be set with
<code>options("Require.cachePkgDir" = "somedir")</code>.
</p>

<hr>
<h2 id='cacheGetOptionCachePkgDir'>Get the option for <code>Require.cachePkgDir</code></h2><span id='topic+cacheGetOptionCachePkgDir'></span>

<h3>Description</h3>

<p>First checks if an environment variable <code>Require.cachePkgDir</code>
is set and defines a path.
If not set, checks whether the <code>options("Require.cachePkgDir")</code> is set.
If a character string, then it returns that.
If <code>TRUE</code>, then use <code>cachePkgDir()</code>. If <code>FALSE</code>
then returns <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cacheGetOptionCachePkgDir()
</code></pre>

<hr>
<h2 id='cachePurge'>Purge everything in the Require cache</h2><span id='topic+cachePurge'></span><span id='topic+purgeCache'></span>

<h3>Description</h3>

<p>Require uses caches for local Package saving, local caches of <code>available.packages</code>,
local caches of GitHub (e.g., <code>"DESCRIPTION"</code>) files, and some function calls
that are cached. This function clears all of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cachePurge(packages = FALSE, repos = getOption("repos"))

purgeCache(packages = FALSE, repos = getOption("repos"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cachePurge_+3A_packages">packages</code></td>
<td>
<p>Either a character vector of packages to install via
<code>install.packages</code>, then load (i.e., with <code>library</code>), or, for convenience,
a vector or list (using <code>c</code> or <code>list</code>) of unquoted package names to install
and/or load (as in <code>require</code>, but vectorized). Passing vectors of names may
not work in all cases, so user should confirm before relying on this behaviour
in operational code.
In the case of a GitHub package, it
will be assumed that the name of the repository is the name of the package.
If this is not the case, then pass a <em>named</em> character vector here, where the
names are the package names that could be different than the GitHub
repository name.</p>
</td></tr>
<tr><td><code id="cachePurge_+3A_repos">repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Run for its side effect, namely, all cached objects are removed.
</p>

<hr>
<h2 id='checkLibPaths'>Creates the directories, and adds version number</h2><span id='topic+checkLibPaths'></span>

<h3>Description</h3>

<p>Creates the directories, and adds version number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkLibPaths(libPaths, ifMissing, exact = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkLibPaths_+3A_libpaths">libPaths</code></td>
<td>
<p>The library path (or libraries) where all packages should be
installed, and looked for to load (i.e., call <code>library</code>). This can be used
to create isolated, stand alone package installations, if used with
<code>standAlone = TRUE</code>. Currently, the path supplied here will be prepended to
<code>.libPaths()</code> (temporarily during this call) to <code>Require</code> if
<code>standAlone = FALSE</code> or will set (temporarily) <code>.libPaths()</code> to
<code style="white-space: pre;">&#8288;c(libPaths, tail(libPaths(), 1)&#8288;</code> to keep base packages.</p>
</td></tr>
<tr><td><code id="checkLibPaths_+3A_ifmissing">ifMissing</code></td>
<td>
<p>An alternative path if <code>libPaths</code> argument is missing.</p>
</td></tr>
<tr><td><code id="checkLibPaths_+3A_exact">exact</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the default, then <code>checkLibPaths</code> will
append the R version number on the <code>libPaths</code> supplied. If <code>TRUE</code>, <code>checkLibPaths</code>
will return exactly the <code>libPaths</code> supplied.</p>
</td></tr>
<tr><td><code id="checkLibPaths_+3A_...">...</code></td>
<td>
<p>Not used, but allows other functions to pass through arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='checkPath'>Check directory path</h2><span id='topic+checkPath'></span><span id='topic+checkPath+2Ccharacter+2Clogical-method'></span><span id='topic+checkPath+2Ccharacter+2Cmissing-method'></span><span id='topic+checkPath+2CNULL+2CANY-method'></span><span id='topic+checkPath+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>Checks the specified path to a directory for formatting consistencies,
such as trailing slashes, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPath(path, create)

## S4 method for signature 'character,logical'
checkPath(path, create)

## S4 method for signature 'character,missing'
checkPath(path)

## S4 method for signature 'NULL,ANY'
checkPath(path)

## S4 method for signature 'missing,ANY'
checkPath()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkPath_+3A_path">path</code></td>
<td>
<p>A character string corresponding to a directory path.</p>
</td></tr>
<tr><td><code id="checkPath_+3A_create">create</code></td>
<td>
<p>A logical indicating whether the path should
be created if it does not exist. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string denoting the cleaned up filepath.
</p>


<h3>Note</h3>

<p>This will not work for paths to files.
To check for existence of files, use <code>file.exists()</code>.
To normalize a path to a file, use <code>normPath()</code> or <code>normalizePath()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+file.exists">file.exists()</a></code>, <code><a href="base.html#topic+dir.create">dir.create()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normalize file paths
paths &lt;- list("./aaa/zzz",
              "./aaa/zzz/",
              ".//aaa//zzz",
              ".//aaa//zzz/",
              ".\\\\aaa\\\\zzz",
              ".\\\\aaa\\\\zzz\\\\",
              file.path(".", "aaa", "zzz"))

checked &lt;- normPath(paths)
length(unique(checked)) ## 1; all of the above are equivalent

## check to see if a path exists
tmpdir &lt;- file.path(tempdir(), "example_checkPath")

dir.exists(tmpdir) ## FALSE
tryCatch(checkPath(tmpdir, create = FALSE), error = function(e) FALSE) ## FALSE

checkPath(tmpdir, create = TRUE)
dir.exists(tmpdir) ## TRUE

unlink(tmpdir, recursive = TRUE) # clean up
</code></pre>

<hr>
<h2 id='chooseCRANmirror2'>Pass through function for <code>chooseCRANmirror</code></h2><span id='topic+chooseCRANmirror2'></span>

<h3>Description</h3>

<p>This is here to allow mocking during unit testing related to <code>chooseCRANmirror</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseCRANmirror2(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chooseCRANmirror2_+3A_...">...</code></td>
<td>
<p>Passed to <code>chooseCRANmirror</code></p>
</td></tr>
</table>

<hr>
<h2 id='compareVersion2'>Compare package versions</h2><span id='topic+compareVersion2'></span>

<h3>Description</h3>

<p>Alternative to <code>utils::compareVersion</code> that is vectorized on <code>version</code>,
<code>versionSpec</code> and/or <code>inequality</code>. This will also return an NA element
in the returned vector if one of the arguments has NA for that element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareVersion2(version, versionSpec, inequality)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareVersion2_+3A_version">version</code></td>
<td>
<p>One or more package versions. Can be <code>character</code> or <code>numeric_version</code>.</p>
</td></tr>
<tr><td><code id="compareVersion2_+3A_versionspec">versionSpec</code></td>
<td>
<p>One or more versions to compare to.
Can be <code>character</code> or <code>numeric_version</code>.</p>
</td></tr>
<tr><td><code id="compareVersion2_+3A_inequality">inequality</code></td>
<td>
<p>The inequality to use, i.e., <code>&gt;=</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector of the length of the longest of the 3 arguments.
</p>

<hr>
<h2 id='dealWithMissingLibPaths'>Only checks for deprecated libPath argument (singular)</h2><span id='topic+dealWithMissingLibPaths'></span>

<h3>Description</h3>

<p>Only checks for deprecated libPath argument (singular)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dealWithMissingLibPaths(
  libPaths,
  standAlone = getOption("Require.standAlone", FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dealWithMissingLibPaths_+3A_libpaths">libPaths</code></td>
<td>
<p>The library path (or libraries) where all packages should be
installed, and looked for to load (i.e., call <code>library</code>). This can be used
to create isolated, stand alone package installations, if used with
<code>standAlone = TRUE</code>. Currently, the path supplied here will be prepended to
<code>.libPaths()</code> (temporarily during this call) to <code>Require</code> if
<code>standAlone = FALSE</code> or will set (temporarily) <code>.libPaths()</code> to
<code style="white-space: pre;">&#8288;c(libPaths, tail(libPaths(), 1)&#8288;</code> to keep base packages.</p>
</td></tr>
<tr><td><code id="dealWithMissingLibPaths_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
<tr><td><code id="dealWithMissingLibPaths_+3A_...">...</code></td>
<td>
<p>Checks for the incorrect argument <code>libPath</code> (no s)</p>
</td></tr>
</table>

<hr>
<h2 id='DESCRIPTIONFileVersionV'>GitHub package tools</h2><span id='topic+DESCRIPTIONFileVersionV'></span><span id='topic+DESCRIPTIONFileOtherV'></span><span id='topic+dlGitHubDESCRIPTION'></span>

<h3>Description</h3>

<p>A series of helpers to access and deal with GitHub packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DESCRIPTIONFileVersionV(file, purge = getOption("Require.purge", FALSE))

DESCRIPTIONFileOtherV(file, other = "RemoteSha")

dlGitHubDESCRIPTION(
  pkg,
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_file">file</code></td>
<td>
<p>A file path to a <code>DESCRIPTION</code> file</p>
</td></tr>
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_other">other</code></td>
<td>
<p>Any other keyword in a <code>DESCRIPTION</code> file that precedes a &quot;:&quot;.
The rest of the line will be retrieved.</p>
</td></tr>
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_pkg">pkg</code></td>
<td>
<p>A character string with a GitHub package specification (c.f. remotes)</p>
</td></tr>
<tr><td><code id="DESCRIPTIONFileVersionV_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dlGitHubDESCRIPTION</code> retrieves the DESCRIPTION file from GitHub.com
</p>

<hr>
<h2 id='detachAll'>Detach and unload all packages</h2><span id='topic+detachAll'></span>

<h3>Description</h3>

<p>This uses <code>pkgDepTopoSort</code> internally so that the package
dependency tree is determined, and then packages are unloaded
in the reverse order. Some packages don't unload successfully for
a variety of reasons. Several known packages that have this problem
are identified internally and <em>not</em> unloaded. Currently, these are
<code>glue</code>, <code>rlang</code>, <code>ps</code>, <code>ellipsis</code>, and, <code>processx</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detachAll(
  pkgs,
  dontTry = NULL,
  doSort = TRUE,
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detachAll_+3A_pkgs">pkgs</code></td>
<td>
<p>A character vector of packages to detach. Will be topologically sorted
unless <code>doSort</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="detachAll_+3A_donttry">dontTry</code></td>
<td>
<p>A character vector of packages to not try. This can be used
by a user if they find a package fails in attempts to unload it, e.g., &quot;ps&quot;</p>
</td></tr>
<tr><td><code id="detachAll_+3A_dosort">doSort</code></td>
<td>
<p>If <code>TRUE</code> (the default), then the <code>pkgs</code> will be
topologically sorted. If <code>FALSE</code>, then it won't. Useful if the
<code>pkgs</code> are already sorted.</p>
</td></tr>
<tr><td><code id="detachAll_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric named vector, with names of the packages that were attempted.
<code>2</code> means the package was successfully unloaded, <code>1</code> it was
tried, but failed, <code>3</code> it was not loaded, so was not unloaded.
</p>

<hr>
<h2 id='dlArchiveVersionsAvailable'>Available and archived versions</h2><span id='topic+dlArchiveVersionsAvailable'></span><span id='topic+available.packagesCached'></span>

<h3>Description</h3>

<p>These are wrappers around available.packages and also get the archived versions
available on CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlArchiveVersionsAvailable(
  package,
  repos = getOption("repos"),
  verbose = getOption("Require.verbose")
)

available.packagesCached(
  repos,
  purge,
  verbose = getOption("Require.verbose"),
  returnDataTable = TRUE,
  type
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlArchiveVersionsAvailable_+3A_package">package</code></td>
<td>
<p>A single package name (without version or github specifications)</p>
</td></tr>
<tr><td><code id="dlArchiveVersionsAvailable_+3A_repos">repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td></tr>
<tr><td><code id="dlArchiveVersionsAvailable_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
<tr><td><code id="dlArchiveVersionsAvailable_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="dlArchiveVersionsAvailable_+3A_returndatatable">returnDataTable</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then the return
is a data.table.
Otherwise, it is a <code>matrix</code>, as per <code>available.packages</code></p>
</td></tr>
<tr><td><code id="dlArchiveVersionsAvailable_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dlArchiveVersionsAvailable</code> searches CRAN Archives for available versions.
It has been borrowed from a sub-set of the code in a non-exported function:
<code>remotes:::download_version_url</code>
</p>

<hr>
<h2 id='doLibPaths'>Deals with missing libPaths arg, and takes first</h2><span id='topic+doLibPaths'></span>

<h3>Description</h3>

<p>Deals with missing libPaths arg, and takes first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doLibPaths(libPaths, standAlone = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doLibPaths_+3A_libpaths">libPaths</code></td>
<td>
<p>The library path (or libraries) where all packages should be
installed, and looked for to load (i.e., call <code>library</code>). This can be used
to create isolated, stand alone package installations, if used with
<code>standAlone = TRUE</code>. Currently, the path supplied here will be prepended to
<code>.libPaths()</code> (temporarily during this call) to <code>Require</code> if
<code>standAlone = FALSE</code> or will set (temporarily) <code>.libPaths()</code> to
<code style="white-space: pre;">&#8288;c(libPaths, tail(libPaths(), 1)&#8288;</code> to keep base packages.</p>
</td></tr>
<tr><td><code id="doLibPaths_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
</table>

<hr>
<h2 id='envPkgCreate'>1st level &ndash;&gt; create the .pkgEnv object in Require</h2><span id='topic+envPkgCreate'></span>

<h3>Description</h3>

<p>1st level &ndash;&gt; create the .pkgEnv object in Require
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envPkgCreate(parentEnv = asNamespace("Require"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="envPkgCreate_+3A_parentenv">parentEnv</code></td>
<td>
<p>The parent environment in which to make the new environment.
Defaults to <code>asNamespace("Require")</code></p>
</td></tr>
</table>

<hr>
<h2 id='envPkgDepDepsCreate'>3rd level  for deps #############################################</h2><span id='topic+envPkgDepDepsCreate'></span>

<h3>Description</h3>

<p>3rd level  for deps #############################################
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envPkgDepDepsCreate()
</code></pre>

<hr>
<h2 id='envPkgDepDESCFileCreate'>3rd level for DESCRIPTIONFile</h2><span id='topic+envPkgDepDESCFileCreate'></span>

<h3>Description</h3>

<p>3rd level for DESCRIPTIONFile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envPkgDepDESCFileCreate()
</code></pre>

<hr>
<h2 id='extractPkgName'>Extract info from package character strings</h2><span id='topic+extractPkgName'></span><span id='topic+extractVersionNumber'></span><span id='topic+extractInequality'></span><span id='topic+extractPkgGitHub'></span>

<h3>Description</h3>

<p>Cleans a character vector of non-package name related information (e.g., version)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractPkgName(pkgs, filenames)

extractVersionNumber(pkgs, filenames)

extractInequality(pkgs)

extractPkgGitHub(pkgs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractPkgName_+3A_pkgs">pkgs</code></td>
<td>
<p>A character string vector of packages with or without GitHub path or versions</p>
</td></tr>
<tr><td><code id="extractPkgName_+3A_filenames">filenames</code></td>
<td>
<p>Can be supplied instead of <code>pkgs</code> if it is a filename e.g., a
.tar.gz or .zip that was downloaded from CRAN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Just the package names without extraneous info.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimVersionNumber">trimVersionNumber()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extractPkgName("Require (&gt;=0.0.1)")
extractVersionNumber(c(
  "Require (&lt;=0.0.1)",
  "PredictiveEcology/Require@development (&lt;=0.0.4)"
))
extractInequality("Require (&lt;=0.0.1)")
extractPkgGitHub("PredictiveEcology/Require")
</code></pre>

<hr>
<h2 id='getCRANrepos'>A helper function to get or set CRAN repos</h2><span id='topic+getCRANrepos'></span>

<h3>Description</h3>

<p>This will get the current option in <code>getOption('repos')</code>, and if that is not
set to a url, then it will prompt the user to select a mirror, unless
<code>ind</code> is set, in which case, it will use that mirror (in
<code>chooseCRANmirror()</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCRANrepos(repos = NULL, ind)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCRANrepos_+3A_repos">repos</code></td>
<td>
<p>A CRAN-like repository</p>
</td></tr>
<tr><td><code id="getCRANrepos_+3A_ind">ind</code></td>
<td>
<p>an integer of which mirror to use in <code>chooseCRANmirror()</code></p>
</td></tr>
</table>

<hr>
<h2 id='getDeps'>The <code>packages</code> argument may have up to 4 pieces of information for GitHub
packages: name, repository, branch, version. For CRAN-alikes, it will only
be 2 pieces: name, version. There can also be an inequality or equality, if
there is a version.</h2><span id='topic+getDeps'></span>

<h3>Description</h3>

<p>The <code>packages</code> argument may have up to 4 pieces of information for GitHub
packages: name, repository, branch, version. For CRAN-alikes, it will only
be 2 pieces: name, version. There can also be an inequality or equality, if
there is a version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDeps(pkgDT, which, recursive, type = type, repos, libPaths, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDeps_+3A_pkgdt">pkgDT</code></td>
<td>
<p>A <code>pkgDT</code> object e.g., from <code>toPkgDT</code></p>
</td></tr>
<tr><td><code id="getDeps_+3A_which">which</code></td>
<td>
<p>a character vector listing the types of dependencies, a subset
of <code>c("Depends", "Imports", "LinkingTo", "Suggests", "Enhances")</code>.
Character string <code>"all"</code> is shorthand for that vector, character string
<code>"most"</code> for the same vector without <code>"Enhances"</code>.</p>
</td></tr>
<tr><td><code id="getDeps_+3A_recursive">recursive</code></td>
<td>
<p>Logical. Should dependencies of dependencies be searched,
recursively. NOTE: Dependencies of suggests will not be recursive. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getDeps_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
<tr><td><code id="getDeps_+3A_repos">repos</code></td>
<td>
<p>is used for <code>ap</code>.</p>
</td></tr>
<tr><td><code id="getDeps_+3A_libpaths">libPaths</code></td>
<td>
<p>A path to search for installed packages. Defaults to
<code>.libPaths()</code></p>
</td></tr>
<tr><td><code id="getDeps_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If version is not supplied, it will take the local, installed version, if it
exists. Otherwise, it is assumed that the HEAD is desired.
The function will find it in the <code>ap</code> or on <code>github.com</code>. For github packages,
this is obviously a slow step, which can be accelerated if user supplies a sha
or a version e.g., getDeps(&quot;PredictiveEcology/LandR@development (==1.0.2)&quot;)
</p>


<h3>Value</h3>

<p>A (named) vector of SaveNames, which is a concatenation of the 2 or 4 elements
above, plus the <code>which</code> and the <code>recursive</code>.
</p>

<hr>
<h2 id='invertList'>Invert a 2-level list</h2><span id='topic+invertList'></span>

<h3>Description</h3>

<p>This is a simple version of <code>purrr::transpose</code>, only for lists with 2 levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertList(l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invertList_+3A_l">l</code></td>
<td>
<p>A list with 2 levels. If some levels are absent, they will be <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 levels deep, inverted from <code>l</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a 2-deep, 2 levels in first, 3 levels in second
a &lt;- list(a = list(d = 1, e = 2:3, f = 4:6), b = list(d = 5, e = 55))
invertList(a) # creates 2-deep, now 3 levels outer --&gt; 2 levels inner
</code></pre>

<hr>
<h2 id='joinToAvailablePackages'>Join a data.table with a <code>Package</code> column to <code>available.packages</code></h2><span id='topic+joinToAvailablePackages'></span>

<h3>Description</h3>

<p>Will join <code>available.packages()</code> with <code>pkgDT</code>, if <code>pkgDT</code> does not already have
a column named <code>Depends</code>, which would be an indicator that this had already
happened.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinToAvailablePackages(pkgDT, repos, type, which, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joinToAvailablePackages_+3A_pkgdt">pkgDT</code></td>
<td>
<p>A <code>pkgDT</code> object e.g., from <code>toPkgDT</code></p>
</td></tr>
<tr><td><code id="joinToAvailablePackages_+3A_repos">repos</code></td>
<td>
<p>is used for <code>ap</code>.</p>
</td></tr>
<tr><td><code id="joinToAvailablePackages_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
<tr><td><code id="joinToAvailablePackages_+3A_which">which</code></td>
<td>
<p>a character vector listing the types of dependencies, a subset
of <code>c("Depends", "Imports", "LinkingTo", "Suggests", "Enhances")</code>.
Character string <code>"all"</code> is shorthand for that vector, character string
<code>"most"</code> for the same vector without <code>"Enhances"</code>.</p>
</td></tr>
<tr><td><code id="joinToAvailablePackages_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned <code>data.table</code> will have most of the columns from
<code>available.packages</code> appended to the <code>pkgDT</code>, including <code>Depends</code>, <code>Imports</code>,
<code>Suggests</code>. It will change the column name that is normally
returned from <code>available.packages</code> as <code>Version</code> to <code>VersionOnRepos</code>.
</p>

<hr>
<h2 id='linkOrCopy'>Create link to file, falling back to making a copy if linking fails.</h2><span id='topic+linkOrCopy'></span><span id='topic+fileRenameOrMove'></span>

<h3>Description</h3>

<p>First try to create a hardlink to the file. If that fails, try a symbolic
link (symlink) before falling back to copying the file. &quot;File&quot; here can mean
a file or a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkOrCopy(from, to, allowSymlink = FALSE)

fileRenameOrMove(from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linkOrCopy_+3A_from">from</code>, <code id="linkOrCopy_+3A_to">to</code></td>
<td>
<p>character vectors, containing file names or paths.</p>
</td></tr>
<tr><td><code id="linkOrCopy_+3A_allowsymlink">allowSymlink</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the default, then it will try
<code>file.link</code> first, then <code>file.copy</code>, omitting the <code>file.symlink</code> step</p>
</td></tr>
</table>

<hr>
<h2 id='masterMainToHead'>This converts master or main to HEAD for a git repo</h2><span id='topic+masterMainToHead'></span>

<h3>Description</h3>

<p>This will also convert a git repo with nothing after the @ to @HEAD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>masterMainToHead(gitRepo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="masterMainToHead_+3A_gitrepo">gitRepo</code></td>
<td>
<p>A git repository of the form account/repo with optional @branch
or @sha or @tag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The git repository with @HEAD if it had @master, @main or no @.
</p>

<hr>
<h2 id='messageDF'>Use message to print a clean square data structure</h2><span id='topic+messageDF'></span><span id='topic+messageVerbose'></span><span id='topic+messageVerboseCounter'></span>

<h3>Description</h3>

<p>Sends to <code>message</code>, but in a structured way so that a data.frame-like can
be cleanly sent to messaging.
</p>
<p>This will only show a message if the value of <code>verbose</code> is greater than the
<code>verboseLevel</code>. This is mostly useful for developers of code who want to give
users of their code easy access to how verbose their code will be. A developer
of a function will place this <code>messageVerbose</code> internally, setting the <code>verboseLevel</code>
according to how advanced they may want the message to be. <code>1</code> is a reasonable
default for standard use, <code>0</code> would be for &quot;a very important message for all users&quot;,
<code>2</code> or above would be increasing levels of details for e.g., advanced use.
If a user sets to <code>-1</code> with this numeric approach, they can avoid all messaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messageDF(df, round, verbose = getOption("Require.verbose"), verboseLevel = 1)

messageVerbose(..., verbose = getOption("Require.verbose"), verboseLevel = 1)

messageVerboseCounter(
  pre = "",
  post = "",
  verbose = getOption("Require.verbose"),
  verboseLevel = 1,
  counter = 1,
  total = 1,
  minCounter = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="messageDF_+3A_df">df</code></td>
<td>
<p>A data.frame, data.table, matrix</p>
</td></tr>
<tr><td><code id="messageDF_+3A_round">round</code></td>
<td>
<p>An optional numeric to pass to <code>round</code></p>
</td></tr>
<tr><td><code id="messageDF_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
<tr><td><code id="messageDF_+3A_verboselevel">verboseLevel</code></td>
<td>
<p>A numeric indicating what verbose threshold (level) above
which this message will show.</p>
</td></tr>
<tr><td><code id="messageDF_+3A_...">...</code></td>
<td>
<p>Passed to <code>install.packages</code>. Good candidates are e.g., <code>type</code> or
<code>dependencies</code>. This can be used with <code>install_githubArgs</code> or
<code>install.packageArgs</code> which give individual options for those 2 internal
function calls.</p>
</td></tr>
<tr><td><code id="messageDF_+3A_pre">pre</code></td>
<td>
<p>A single text string to paste before the counter</p>
</td></tr>
<tr><td><code id="messageDF_+3A_post">post</code></td>
<td>
<p>A single text string to paste after the counter</p>
</td></tr>
<tr><td><code id="messageDF_+3A_counter">counter</code></td>
<td>
<p>An integer indicating which iteration is being done</p>
</td></tr>
<tr><td><code id="messageDF_+3A_total">total</code></td>
<td>
<p>An integer indicating the total number to be done.</p>
</td></tr>
<tr><td><code id="messageDF_+3A_mincounter">minCounter</code></td>
<td>
<p>An integer indicating the minimum (i.e,. starting value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for side effects, namely messaging that can be turned on or off with different
numeric values of <code>verboseLevel</code>. A user sets the <code>verboseLevel</code> for a particular
message.
</p>

<hr>
<h2 id='modifyList2'><code>modifyList</code> for multiple lists</h2><span id='topic+modifyList2'></span><span id='topic+modifyList3'></span>

<h3>Description</h3>

<p>This calls <code><a href="utils.html#topic+modifyList">utils::modifyList</a></code> iteratively using
<code><a href="base.html#topic+funprog">base::Reduce</a></code>, so it can handle &gt;2 lists.
The subsequent list elements that share a name will override
previous list elements with that same name.
It also will handle the case where any list is a <code>NULL</code>. Note:
default <code>keep.null = TRUE</code>, which is different than <code>modifyList</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifyList2(..., keep.null = FALSE)

modifyList3(..., keep.null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifyList2_+3A_...">...</code></td>
<td>
<p>One or more named lists.</p>
</td></tr>
<tr><td><code id="modifyList2_+3A_keep.null">keep.null</code></td>
<td>
<p> If <code>TRUE</code>, <code>NULL</code> elements in <code>val</code>
become <code>NULL</code> elements in <code>x</code>.  Otherwise, the
corresponding element, if present, is deleted from <code>x</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>More or less a convenience around
<code>Reduce(modifyList, list(...))</code>, with some checks, and the addition of
<code>keep.null = TRUE</code> by default.
</p>


<h3>Note</h3>

<p><code>modifyList3</code> retains the original behaviour of <code>modifyList2</code> (prior to
Oct 2022); however, it cannot retain <code>NULL</code> values in lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modifyList2(list(a = 1), list(a = 2, b = 2))
modifyList2(list(a = 1), NULL, list(a = 2, b = 2))
modifyList2(
  list(a = 1), list(x = NULL), list(a = 2, b = 2),
  list(a = 3, c = list(1:10))
)
</code></pre>

<hr>
<h2 id='normPath'>Normalize filepath</h2><span id='topic+normPath'></span><span id='topic+normPath+2Ccharacter-method'></span><span id='topic+normPath+2Clist-method'></span><span id='topic+normPath+2CNULL-method'></span><span id='topic+normPath+2Cmissing-method'></span><span id='topic+normPath+2Clogical-method'></span>

<h3>Description</h3>

<p>Checks the specified filepath for formatting consistencies:
</p>

<ol>
<li><p> use slash instead of backslash;
</p>
</li>
<li><p> do tilde etc. expansion;
</p>
</li>
<li><p> remove trailing slash.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>normPath(path)

## S4 method for signature 'character'
normPath(path)

## S4 method for signature 'list'
normPath(path)

## S4 method for signature 'NULL'
normPath(path)

## S4 method for signature 'missing'
normPath()

## S4 method for signature 'logical'
normPath(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normPath_+3A_path">path</code></td>
<td>
<p>A character vector of filepaths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of cleaned up filepaths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normalize file paths
paths &lt;- list("./aaa/zzz",
              "./aaa/zzz/",
              ".//aaa//zzz",
              ".//aaa//zzz/",
              ".\\\\aaa\\\\zzz",
              ".\\\\aaa\\\\zzz\\\\",
              file.path(".", "aaa", "zzz"))

checked &lt;- normPath(paths)
length(unique(checked)) ## 1; all of the above are equivalent

## check to see if a path exists
tmpdir &lt;- file.path(tempdir(), "example_checkPath")

dir.exists(tmpdir) ## FALSE
tryCatch(checkPath(tmpdir, create = FALSE), error = function(e) FALSE) ## FALSE

checkPath(tmpdir, create = TRUE)
dir.exists(tmpdir) ## TRUE

unlink(tmpdir, recursive = TRUE) # clean up
</code></pre>

<hr>
<h2 id='paddedFloatToChar'>Convert numeric to character with padding</h2><span id='topic+paddedFloatToChar'></span>

<h3>Description</h3>

<p>This will pad floating point numbers, right or left. For integers, either class
integer or functionally integer (e.g., 1.0), it will not pad right of the decimal.
For more specific control or to get exact padding right and left of decimal,
try the <code>stringi</code> package. It will also not do any rounding. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paddedFloatToChar(x, padL = ceiling(log10(x + 1)), padR = 3, pad = "0")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paddedFloatToChar_+3A_x">x</code></td>
<td>
<p>numeric. Number to be converted to character with padding</p>
</td></tr>
<tr><td><code id="paddedFloatToChar_+3A_padl">padL</code></td>
<td>
<p>numeric. Desired number of digits on left side of decimal.
If not enough, <code>pad</code> will be used to pad.</p>
</td></tr>
<tr><td><code id="paddedFloatToChar_+3A_padr">padR</code></td>
<td>
<p>numeric. Desired number of digits on right side of decimal.
If not enough, <code>pad</code> will be used to pad.</p>
</td></tr>
<tr><td><code id="paddedFloatToChar_+3A_pad">pad</code></td>
<td>
<p>character to use as padding (<code>nchar(pad) == 1</code> must be <code>TRUE</code>).
Currently, can be only <code>"0"</code> or <code>" "</code> (i.e., space).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string representing the filename.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>paddedFloatToChar(1.25)
paddedFloatToChar(1.25, padL = 3, padR = 5)
paddedFloatToChar(1.25, padL = 3, padR = 1) # no rounding, so keeps 2 right of decimal
</code></pre>

<hr>
<h2 id='pakEnv'>2nd level</h2><span id='topic+pakEnv'></span>

<h3>Description</h3>

<p>2nd level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pakEnv()
</code></pre>

<hr>
<h2 id='parseGitHub'>Parse a github package specification</h2><span id='topic+parseGitHub'></span>

<h3>Description</h3>

<p>This converts a specification like <code>PredictiveEcology/Require@development</code>
into separate columns, &quot;Account&quot;, &quot;Repo&quot;, &quot;Branch&quot;, &quot;GitSubFolder&quot; (if there is one)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseGitHub(pkgDT, verbose = getOption("Require.verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseGitHub_+3A_pkgdt">pkgDT</code></td>
<td>
<p>A pkgDT data.table.</p>
</td></tr>
<tr><td><code id="parseGitHub_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parseGitHub</code> turns the single character string representation into 3 or 4:
<code>Account</code>, <code>Repo</code>, <code>Branch</code>, <code>SubFolder</code>.
</p>


<h3>Value</h3>

<p><code>parseGitHub</code> returns a <code>data.table</code> with added columns.
</p>

<hr>
<h2 id='pkgDepEnv'>2nd level</h2><span id='topic+pkgDepEnv'></span>

<h3>Description</h3>

<p>2nd level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgDepEnv()
</code></pre>

<hr>
<h2 id='pkgDepIfDepRemoved'>Package dependencies when one or more packages removed</h2><span id='topic+pkgDepIfDepRemoved'></span>

<h3>Description</h3>

<p>This is primarily for package developers. It allows the testing of what the
recursive dependencies would be if a package was removed from the immediate
dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgDepIfDepRemoved(
  pkg = character(),
  depsRemoved = character(),
  verbose = getOption()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkgDepIfDepRemoved_+3A_pkg">pkg</code></td>
<td>
<p>A package name to be testing the dependencies</p>
</td></tr>
<tr><td><code id="pkgDepIfDepRemoved_+3A_depsremoved">depsRemoved</code></td>
<td>
<p>A vector of package names who are to be &quot;removed&quot; from the
<code>pkg</code> immediate dependencies</p>
</td></tr>
<tr><td><code id="pkgDepIfDepRemoved_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 named lists <code>Direct</code>, <code>Recursive</code> and <code>IfRemoved</code>.
<code>Direct</code> will show the top level direct dependencies, either <code>Remaining</code> or
<code>Removed</code>. <code>Recursive</code> will show the full recursive dependencies, either
<code>Remaining</code> or <code>Removed</code>. <code>IfRemoved</code> returns all package dependencies that
are removed for each top level dependency. If a top level dependency is not
listed in this final list, then it means that it is also a recursive
dependency elsewhere, so its removal has no effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()

  pkgDepIfDepRemoved("reproducible", "data.table")

  Require:::.cleanup(opts)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='pkgDepTopoSort'>Reverse package depends</h2><span id='topic+pkgDepTopoSort'></span><span id='topic+pkgDep2'></span><span id='topic+pkgDep'></span>

<h3>Description</h3>

<p>This is a wrapper around <code>tools::dependsOnPkgs</code>,
but with the added option of <code>topoSort</code>, which
will sort them such that the packages at the top will have
the least number of dependencies that are in <code>pkgs</code>.
This is essentially a topological sort, but it is done
heuristically. This can be used to e.g., <code>detach</code> or
<code>unloadNamespace</code> packages in order so that they each
of their dependencies are detached or unloaded first.
</p>
<p><code>pkgDep2</code> is a convenience wrapper of <code>pkgDep</code> that &quot;goes one level in&quot;,
i.e., the first order dependencies, and runs the <code>pkgDep</code> on those.
</p>
<p>This will first look in local filesystem (in <code>.libPaths()</code>) and will use a
local package to find its dependencies. If the package does not exist
locally, including whether it is the correct version, then it will look in
(currently) <code>CRAN</code> and its archives (if the current <code>CRAN</code> version is not the
desired version to check). It will also look on <code>GitHub</code> if the package
description is of the form of a GitHub package with format
<code>account/repo@branch</code> or <code>account/repo@commit</code>. For this, it will attempt to
get package dependencies from the GitHub &lsquo;<span class="file">DESCRIPTION</span>&rsquo; file. This is
intended to replace <code>tools::package_dependencies</code> or <code>pkgDep</code> in the
<span class="pkg">miniCRAN</span> package, but with modifications to allow multiple sources to
be searched in the same function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgDepTopoSort(
  pkgs,
  deps,
  reverse = FALSE,
  topoSort = TRUE,
  libPaths,
  useAllInSearch = FALSE,
  returnFull = TRUE,
  recursive = TRUE,
  purge = getOption("Require.purge", FALSE),
  which = c("Depends", "Imports", "LinkingTo"),
  type = getOption("pkgType"),
  verbose = getOption("Require.verbose"),
  ...
)

pkgDep2(...)

pkgDep(
  packages,
  libPaths,
  which = c("Depends", "Imports", "LinkingTo"),
  recursive = TRUE,
  depends,
  imports,
  suggests,
  linkingTo,
  repos = getOption("repos"),
  keepVersionNumber = TRUE,
  includeBase = FALSE,
  includeSelf = TRUE,
  sort = TRUE,
  simplify = TRUE,
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose"),
  type = getOption("pkgType"),
  Additional_repositories = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkgDepTopoSort_+3A_pkgs">pkgs</code></td>
<td>
<p>A vector of package names to evaluate their
reverse depends (i.e., the packages that <em>use</em> each
of these packages)</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_deps">deps</code></td>
<td>
<p>An optional named list of (reverse) dependencies.
If not supplied, then <code>tools::dependsOnPkgs(..., recursive = TRUE)</code>
will be used</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_reverse">reverse</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then this will use <code>tools::pkgDependsOn</code>
to determine which packages depend on the <code>pkgs</code></p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_toposort">topoSort</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then
the returned list of packages will be in order with the
least number of dependencies listed in <code>pkgs</code> at
the top of the list.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_libpaths">libPaths</code></td>
<td>
<p>A path to search for installed packages. Defaults to
<code>.libPaths()</code></p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_useallinsearch">useAllInSearch</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then all non-core
R packages in <code>search()</code> will be appended to <code>pkgs</code>
to allow those to also be identified</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_returnfull">returnFull</code></td>
<td>
<p>Logical. Primarily useful when <code>reverse = TRUE</code>.
If <code>TRUE</code>, then then all installed packages will be searched.
If <code>FALSE</code>, the default, only packages that are currently in
the <code>search()</code> path and passed in <code>pkgs</code> will be included
in the possible reverse dependencies.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_recursive">recursive</code></td>
<td>
<p>Logical. Should dependencies of dependencies be searched,
recursively. NOTE: Dependencies of suggests will not be recursive. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_which">which</code></td>
<td>
<p>a character vector listing the types of dependencies, a subset
of <code>c("Depends", "Imports", "LinkingTo", "Suggests", "Enhances")</code>.
Character string <code>"all"</code> is shorthand for that vector, character string
<code>"most"</code> for the same vector without <code>"Enhances"</code>.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_type">type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_...">...</code></td>
<td>
<p>Currently only <code>dependencies</code> as an alternative to <code>which</code>. If specified,
then <code>which</code> will be ignored.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_packages">packages</code></td>
<td>
<p>Either a character vector of packages to install via
<code>install.packages</code>, then load (i.e., with <code>library</code>), or, for convenience,
a vector or list (using <code>c</code> or <code>list</code>) of unquoted package names to install
and/or load (as in <code>require</code>, but vectorized). Passing vectors of names may
not work in all cases, so user should confirm before relying on this behaviour
in operational code.
In the case of a GitHub package, it
will be assumed that the name of the repository is the name of the package.
If this is not the case, then pass a <em>named</em> character vector here, where the
names are the package names that could be different than the GitHub
repository name.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_depends">depends</code></td>
<td>
<p>Logical. Include packages listed in &quot;Depends&quot;. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_imports">imports</code></td>
<td>
<p>Logical. Include packages listed in &quot;Imports&quot;. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_suggests">suggests</code></td>
<td>
<p>Logical. Include packages listed in &quot;Suggests&quot;. Default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_linkingto">linkingTo</code></td>
<td>
<p>Logical. Include packages listed in &quot;LinkingTo&quot;. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_repos">repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_keepversionnumber">keepVersionNumber</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the package dependencies
returned will include version number. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_includebase">includeBase</code></td>
<td>
<p>Logical. Should R base packages be included, specifically,
those in <code>tail(.libPaths(), 1)</code></p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_includeself">includeSelf</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then the dependencies
will include the package itself in the returned list elements, otherwise,
only the &quot;dependencies&quot;</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_sort">sort</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then the packages will be sorted
alphabetically. If <code>FALSE</code>, the packages will not have a discernible order
as they will be a concatenation of the possibly recursive package
dependencies.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_simplify">simplify</code></td>
<td>
<p>Logical or numeric. If <code>TRUE</code> (or &gt; 0), the default,
the return object is &quot;just&quot; a character vector of package names
(with version requirements). If <code>FALSE</code> (or <code>0</code>),
then a <code>data.table</code> will be returned with 4 columns,
<code>Package</code>, <code>packageFullName</code>, <code>parentPackage</code> (the package name for which the
given line entry is a dependency; will be &quot;user&quot; if it was user supplied)
and <code>deps</code>, which is a list of <code>data.table</code>s
of all dependencies. If a negative number, then it will return a similar <code>data.table</code>
as with <code>FALSE</code>, however, duplications in the recursive package dependencies
are left intact.</p>
</td></tr>
<tr><td><code id="pkgDepTopoSort_+3A_additional_repositories">Additional_repositories</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then <code>pkgDep</code> will return
a list of <code>data.table</code> objects (instead of character vectors)
with a column <code>packageFullName</code> and possibly a second column <code>Additional_repositories</code>,
which may have been specified in a <code>DESCRIPTION</code> file. NOTE: THIS ALTERS
THE OUTPUT CLASS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A possibly ordered, named (with packages as names) list where list elements
are either full reverse depends.
</p>


<h3>Note</h3>

<p><code>tools::package_dependencies</code> and <code>pkgDep</code> will differ under the
following circumstances: </p>
 <ol>
<li><p> GitHub packages are not detected
using <code>tools::package_dependencies</code>; </p>
</li>
<li> <p><code>tools::package_dependencies</code>
does not detect the dependencies of base packages among themselves, <em>e.g.</em>,
<code>methods</code> depends on <code>stats</code> and <code>graphics</code>. </p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()

  pkgDepTopoSort(c("Require", "data.table"), reverse = TRUE)

  Require:::.cleanup(opts)
}

## End(Not run)

## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()

  pkgDep2("reproducible")
  # much bigger one
  pkgDep2("tidyverse")

  Require:::.cleanup(opts)
}

## End(Not run)
## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()

  pkgDep("tidyverse", recursive = TRUE)

  # GitHub, local, and CRAN packages
  pkgDep(c("PredictiveEcology/reproducible", "Require", "plyr"))

  Require:::.cleanup(opts)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='pkgSnapshot'>Take a snapshot of all the packages and version numbers</h2><span id='topic+pkgSnapshot'></span><span id='topic+pkgSnapshot2'></span>

<h3>Description</h3>

<p>This can be used later by <code>Require</code> to install or re-install the correct versions. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgSnapshot(
  packageVersionFile = getOption("Require.packageVersionFile"),
  libPaths = .libPaths(),
  standAlone = FALSE,
  purge = getOption("Require.purge", FALSE),
  exact = TRUE,
  includeBase = FALSE,
  verbose = getOption("Require.verbose")
)

pkgSnapshot2(
  packageVersionFile = getOption("Require.packageVersionFile"),
  libPaths,
  standAlone = FALSE,
  purge = getOption("Require.purge", FALSE),
  exact = TRUE,
  includeBase = FALSE,
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkgSnapshot_+3A_packageversionfile">packageVersionFile</code></td>
<td>
<p>A filename to save the packages and their currently
installed version numbers. Defaults to <code>"packageVersions.txt"</code>.
If this is specified to be <code>NULL</code>, the function will return the exact
<code>Require</code> call needed to install all the packages at their current
versions. This can be useful to add to a script to allow for reproducibility of
a script.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_libpaths">libPaths</code></td>
<td>
<p>The path to the local library where packages are installed.
Defaults to the <code>.libPaths()[1]</code>.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_purge">purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour &ndash; see <code><a href="utils.html#topic+available.packages">utils::available.packages</a></code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_exact">exact</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then for GitHub packages, it
will install the exact SHA, rather than the head of the <code>account/repo@branch</code>. For
CRAN packages, it will install the exact version. If <code>FALSE</code>, then GitHub
packages will identify their branch if that had been specified upon installation,
not a SHA. If the package had been installed with reference to a SHA, then it
will return the SHA as it does not know what branch it came from.
Similarly, CRAN packages will report their version and specify with a <code>&gt;=</code>,
allowing a subsequent user
to install with a minimum version number, as opposed to an exact version number.</p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_includebase">includeBase</code></td>
<td>
<p>Logical. Should R base packages be included, specifically,
those in <code>tail(.libPaths(), 1)</code></p>
</td></tr>
<tr><td><code id="pkgSnapshot_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A file is written with the package names and versions of all packages within <code>libPaths</code>.
This can later be passed to <code>Require</code>.
</p>
<p><code>pkgSnapshot2</code> returns a vector of package names and versions, with no file output. See
examples.
</p>


<h3>Value</h3>

<p>Will both write a file, and (invisibly) return a vector of packages with the
version numbers. This vector can be used directly in <code>Require</code>, though it should likely
be used with <code>require = FALSE</code> to prevent attaching all the packages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()

  # install one archived version so that below does something interesting
  libForThisEx &lt;- tempdir2("Example")
  Require("crayon (==1.5.1)", libPaths = libForThisEx, require = FALSE)
  # Normal use -- using the libForThisEx for example;
  #    normally libPaths would be omitted to get all
  #    packages in user or project library
  tf &lt;- tempfile()

  # writes to getOption("Require.packageVersionFile")
  # within project; also returns a vector
  # of packages with version
  pkgs &lt;- pkgSnapshot(
    packageVersionFile = tf,
    libPaths = libForThisEx, standAlone = TRUE # only this library
  )

  # Now move this file to another computer e.g. by committing in git,
  #   emailing, googledrive
  #   on next computer/project
  Require(packageVersionFile = tf, libPaths = libForThisEx)

  # Using pkgSnapshot2 to get the vector of packages and versions
  pkgs &lt;- pkgSnapshot2(
    libPaths = libForThisEx, standAlone = TRUE
  )
  Install(pkgs) # will install packages from previous line

  Require:::.cleanup(opts)
  unlink(getOption("Require.packageVersionFile"))
}

## End(Not run)

</code></pre>

<hr>
<h2 id='R_TESTSomit'>This environment variable &quot;R_TESTS&quot; is set during testing, and it points to a file
called <code>Startup.Rs</code> that is placed in the <code>.libPaths()</code>.
If the <code>.libPaths()</code> is changed during the testing,
then that file will not be found, and install.packages will
fail to install a package with an error of source file not found.
See: <a href="https://github.com/HenrikBengtsson/startup/issues/19">https://github.com/HenrikBengtsson/startup/issues/19</a>.</h2><span id='topic+R_TESTSomit'></span>

<h3>Description</h3>

<p>The environment variable is set here:
<code style="white-space: pre;">&#8288;https://github.com/wch/r-source/blob/8b6429feb661b02e2b2b6df1757b31cf1250a33e/src/library/tools/R/testing.R#L472-Lundefined&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_TESTSomit()
</code></pre>

<hr>
<h2 id='RequireOptions'><code>Require</code> options</h2><span id='topic+RequireOptions'></span><span id='topic+getRequireOptions'></span>

<h3>Description</h3>

<p>These provide top-level, powerful settings for a comprehensive reproducible
workflow. See Details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RequireOptions()

getRequireOptions()
</code></pre>


<h3>Details</h3>


<dl>
<dt><code>RequireOptions()</code></dt><dd><p>prints the default values of package
options set at startup, which may have been changed (e.g., by the user)
during the current session.</p>
</dd>
<dt><code>getRequireOptions()</code></dt><dd><p>prints the current
values of package options.</p>
</dd> </dl>

<p>Below are options that can be set with <code>options("Require.xxx" = newValue)</code>,
where <code>xxx</code> is one of the values below, and <code>newValue</code> is a new value to give
the option. Sometimes these options can be placed in the user's <code>.Rprofile</code>
file so they persist between sessions.
</p>
<p>The following options are likely of interest to most users: </p>

<dl>
<dt><code>install</code></dt><dd><p> Default: <code>TRUE</code>. This is the default argument to <code>Require</code>,
but does not affect <code>Install</code>. If this is <code>FALSE</code>, then no installations
will be attempted, and missing packages will result in an error. </p>
</dd>
<dt><code>RPackageCache</code></dt><dd><p> Default: <code>cacheGetOptionCachePkgDir()</code>, which must be
either a path or a logical. To turn off package caching, set this to <code>FALSE</code>.
This can be set using an environment variable e.g.
<code>Sys.setenv(R_REQUIRE_PKG_CACHE = "somePath")</code>, or
<code>Sys.setenv(R_REQUIRE_PKG_CACHE = "TRUE")</code>; if that is not set, then an
either a path or logical option (<code>options(Require.cachePkgDir = "somePath")</code> or <code>options(Require.cachePkgDir = TRUE)</code>). If <code>TRUE</code>, the
default folder location <code>cachePkgDir()</code> will be used. If this is
<code>TRUE</code> or a path is provided, then binary and source packages will be cached
here. Subsequent downloads of same package will use local copy. Default is to
have packages not be cached locally so each install of the same version will
be from the original source, e.g., CRAN, GitHub. </p>
</dd>
<dt><code>otherPkgs</code></dt><dd><p> Default: A character vector of packages that are
generally more successful if installed from Source on Unix-alikes. Since
there are repositories that offer binary packages builds for Linux (e.g.,
RStudio Package Manager), the vector of package names indicated here will
default to a standard CRAN repository, forcing a source install. See also
<code>spatialPkgs</code> option, which does the same for spatial packages. </p>
</dd>
<dt><code>purge</code></dt><dd><p> Default: <code>FALSE</code>. If set to (almost) all internal caches used
by <code>Require</code> will be deleted and rebuilt. This should not generally be
necessary as it will automatically be deleted after (by default) 1 hour (set
via <code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code> environment variable in
seconds) </p>
</dd>
<dt><code>spatialPkgs</code></dt><dd><p> Default: A character vector of packages that are
generally more successful if installed from Source on Unix-alikes. Since
there are repositories that offer binary packages builds for Linux (e.g.,
RStudio Package Manager), the vector of package names indicated here will
default to a standard CRAN repository, forcing a source install. See also
<code>otherPkgs</code> option, which does the same for non-spatial packages. </p>
</dd>
<dt><code>useCranCache</code></dt><dd><p> Default: <code>FALSE</code>. A user can optionally use the
locally cached packages that are available due to a user's use of the
<code>crancache</code> package.
</p>
</dd>
<dt><code>verbose</code></dt><dd><p> Default: <code>1</code>. See ?Require.
</p>
</dd>
</dl>


<hr>
<h2 id='rmBase'>Recursive function to remove <code>.basePkgs</code></h2><span id='topic+rmBase'></span>

<h3>Description</h3>

<p>Recursive function to remove <code>.basePkgs</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmBase(includeBase = formals(pkgDep)[["includeBase"]], deps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmBase_+3A_includebase">includeBase</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the default, then base packages will
be removed.</p>
</td></tr>
<tr><td><code id="rmBase_+3A_deps">deps</code></td>
<td>
<p>Either a list of dependencies, a data.table of dependencies with
a column <code>Package</code> or a vector of dependencies.</p>
</td></tr>
</table>

<hr>
<h2 id='rversions'>R versions</h2><span id='topic+rversions'></span>

<h3>Description</h3>

<p>Reference table of R versions and their release dates (2018 and later).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rversions
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 21 rows and 2 columns.
</p>


<h3>Details</h3>

<p>Update this as needed using <code>rversions::r_versions()</code>:
</p>
<p><code style="white-space: pre;">&#8288;
# install.packages("rversions")
v = rversions::r_versions()
keep = which(as.Date(v$date, format = "
             as.Date("2018-01-01", format = "
dput(v[keep, c("version", "date")])
&#8288;</code>
</p>

<hr>
<h2 id='setdiffNamed'>Like <code>setdiff</code>, but takes into account names</h2><span id='topic+setdiffNamed'></span>

<h3>Description</h3>

<p>This will identify the elements in <code>l1</code> that are not in <code>l2</code>. If
<code>missingFill</code> is provided, then elements that are in <code>l2</code>, but not in <code>l1</code>
will be returned, assigning <code>missingFill</code> to their values. This might be
<code>NULL</code> or <code>""</code>, i.e., some sort of empty value. This function will work on
named lists, named vectors and likely on other named classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setdiffNamed(l1, l2, missingFill)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setdiffNamed_+3A_l1">l1</code></td>
<td>
<p>A named list or named vector</p>
</td></tr>
<tr><td><code id="setdiffNamed_+3A_l2">l2</code></td>
<td>
<p>A named list or named vector (must be same class as <code>l1</code>)</p>
</td></tr>
<tr><td><code id="setdiffNamed_+3A_missingfill">missingFill</code></td>
<td>
<p>A value, such as <code>NULL</code> or <code>""</code> or <code>"missing"</code> that will
be given to the elements returned, that are in <code>l2</code>, but not in <code>l1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 3 types of differences that might occur with named
elements: 1. a new named element, 2. an removed named element, and 3. a
modified named element. This function captures all of these. In the case of
unnamed elements, e.g., <code>setdiff</code>, the first two are not seen as differences,
if the values are not different.
</p>


<h3>Value</h3>

<p>A vector or list of the elements in <code>l1</code> that are not in <code>l2</code>, and
optionally the elements of <code>l2</code> that are not in <code>l1</code>, with values set to
<code>missingFill</code>
</p>

<hr>
<h2 id='setLibPaths'>Set <code>.libPaths</code></h2><span id='topic+setLibPaths'></span>

<h3>Description</h3>

<p>This will set the <code>.libPaths()</code> by either adding a new path to it if
<code>standAlone = FALSE</code>, or will concatenate <code>c(libPath, tail(.libPaths(), 1))</code>
if <code>standAlone = TRUE</code>. Currently, the default is to make this new
<code>.libPaths()</code> &quot;sticky&quot;, meaning it becomes associated with the current
directory even through a restart of R. It does this by adding and/updating
the &lsquo;<span class="file">.Rprofile</span>&rsquo; file in the current directory. If this current directory
is a project, then the project will have the new <code>.libPaths()</code> associated
with it, even through an R restart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLibPaths(
  libPaths,
  standAlone = TRUE,
  updateRprofile = getOption("Require.updateRprofile", FALSE),
  exact = FALSE,
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setLibPaths_+3A_libpaths">libPaths</code></td>
<td>
<p>A new path to append to, or replace all existing user
components of <code>.libPath()</code></p>
</td></tr>
<tr><td><code id="setLibPaths_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
<tr><td><code id="setLibPaths_+3A_updaterprofile">updateRprofile</code></td>
<td>
<p>Logical or Character string. If <code>TRUE</code>, then this
function will put several lines of code in the current directory's
<code>.Rprofile</code> file setting up the package libraries for this and future
sessions. If a character string, then this should be the path to an
<code>.Rprofile</code> file. To reset back to normal, run <code>setLibPaths()</code> without a
<code>libPath</code>. Default: <code>getOption("Require.updateRprofile", FALSE)</code>, meaning
<code>FALSE</code>, but it can be set with an option or within a single call.</p>
</td></tr>
<tr><td><code id="setLibPaths_+3A_exact">exact</code></td>
<td>
<p>Logical. This function will automatically append the R version
number to the <code>libPaths</code> to maintain separate R package libraries for each
R version on the system. There are some cases where this behaviour is not
desirable. Set <code>exact</code> to <code>TRUE</code> to override this automatic appending and
use the exact, unaltered <code>libPaths</code>. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="setLibPaths_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This details of this code were modified from
<a href="https://github.com/milesmcbain">https://github.com/milesmcbain</a>. A different, likely non-approved by CRAN
approach that also works is here:
<a href="https://stackoverflow.com/a/36873741/3890027">https://stackoverflow.com/a/36873741/3890027</a>.
</p>


<h3>Value</h3>

<p>The main point of this function is to set <code>.libPaths()</code>, which will
be changed as a side effect of this function. As when setting <code>options</code>,
this will return the previous state of <code>.libPaths()</code> allowing the user to
reset easily.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (Require:::.runLongExamples()) {
  opts &lt;- Require:::.setupExample()
  origDir &lt;- setwd(tempdir())
  td &lt;- tempdir()
  setLibPaths(td) # set a new R package library locally
  setLibPaths() # reset it to original
  setwd(origDir)
  # Using standAlone = FALSE means that newly installed packages
  #   will be installed
  #   in the new package library, but loading packages can come
  #   from any of the ones listed in .libPaths()

  # will have 2 or more paths
  otherLib &lt;- file.path(td, "newProjectLib")
  setLibPaths(otherLib, standAlone = FALSE)
  # Can restart R, and changes will stay

  # remove the custom .libPaths()
  setLibPaths() # reset to previous; remove from .Rprofile
  # because libPath arg is empty

  Require:::.cleanup(opts)
  unlink(otherLib, recursive = TRUE)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='setLinuxBinaryRepo'>Setup for binary Linux repositories</h2><span id='topic+setLinuxBinaryRepo'></span>

<h3>Description</h3>

<p>Enable use of binary package builds for Linux from the RStudio Package
Manager repo. This will set the <code>repos</code> option, affecting the current R
session. It will put this <code>binaryLinux</code> in the first position. If the
<code>getOption("repos")</code> is <code>NULL</code>, it will put <code>backupCRAN</code> in second position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLinuxBinaryRepo(
  binaryLinux = urlForArchivedPkgs,
  backupCRAN = srcPackageURLOnCRAN
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setLinuxBinaryRepo_+3A_binarylinux">binaryLinux</code></td>
<td>
<p>A CRAN repository serving binary Linux packages.</p>
</td></tr>
<tr><td><code id="setLinuxBinaryRepo_+3A_backupcran">backupCRAN</code></td>
<td>
<p>If there is no CRAN repository set</p>
</td></tr>
</table>

<hr>
<h2 id='setup'>Setup a project library, cache, options</h2><span id='topic+setup'></span><span id='topic+setupOff'></span>

<h3>Description</h3>

<p><code>setup</code> and <code>setupOff</code> are currently deprecated.
These may be re-created in a future version.
In its place, a user can simply put <code>.libPaths(libs, include.site = FALSE)</code>
in their <code>.Rprofile</code> file, where <code>libs</code> is the directory where the packages
should be installed and should be a folder with the R version number, e.g.,
derived by using <code>checkLibPaths(libs)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup(
  newLibPaths,
  RPackageFolders,
  RPackageCache = cacheGetOptionCachePkgDir(),
  standAlone = getOption("Require.standAlone", TRUE),
  verbose = getOption("Require.verbose")
)

setupOff(removePackages = FALSE, verbose = getOption("Require.verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_+3A_newlibpaths">newLibPaths</code></td>
<td>
<p>Same as <code>RPackageFolders</code>. This is for more consistent
naming with <code>Require(..., libPaths = ...)</code>.</p>
</td></tr>
<tr><td><code id="setup_+3A_rpackagefolders">RPackageFolders</code></td>
<td>
<p>One or more folders where R packages are
installed to and loaded from. In the case of more than one
folder provided, installation will only happen in the first one.</p>
</td></tr>
<tr><td><code id="setup_+3A_rpackagecache">RPackageCache</code></td>
<td>
<p>See <code>?RequireOptions</code>.</p>
</td></tr>
<tr><td><code id="setup_+3A_standalone">standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td></tr>
<tr><td><code id="setup_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
<tr><td><code id="setup_+3A_removepackages">removePackages</code></td>
<td>
<p>Deprecated. Please remove packages manually from
the .libPaths()</p>
</td></tr>
</table>

<hr>
<h2 id='sourcePkgs'>A list of R packages that should likely be installed from Source, not Binary</h2><span id='topic+sourcePkgs'></span>

<h3>Description</h3>

<p>The list of R packages that <code>Require</code> installs from source on Linux, even if
the <code>getOptions("repos")</code> is a binary repository. This list can be updated by
the user by modifying the options <code>Require.spatialPkgs</code> or
<code>Require.otherPkgs</code>. Default &quot;force source only packages&quot; are visible with
<code>RequireOptions()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sourcePkgs(additional = NULL, spatialPkgs = NULL, otherPkgs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sourcePkgs_+3A_additional">additional</code></td>
<td>
<p>Any other packages to be added to the other 2 argument vectors</p>
</td></tr>
<tr><td><code id="sourcePkgs_+3A_spatialpkgs">spatialPkgs</code></td>
<td>
<p>A character vector of package names that focus on spatial analyses.</p>
</td></tr>
<tr><td><code id="sourcePkgs_+3A_otherpkgs">otherPkgs</code></td>
<td>
<p>A character vector of package names that often
require system specific compilation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted concatenation of the 3 input parameters.
</p>

<hr>
<h2 id='splitKeepOrderAndDTIntegrity'><code>split</code> for a data.table that keeps integrity of a column of lists of data.table objects</h2><span id='topic+splitKeepOrderAndDTIntegrity'></span>

<h3>Description</h3>

<p><code>data.table::split</code> does 2 bad things:
</p>

<ol>
<li><p> reorders if using <code>f</code>
</p>
</li>
<li><p> destroys the integrity of a column that is a list of data.tables, when using <code>by</code>
So, to keep order, need <code>by</code>, but to keep integrity, need <code>f</code>. This function
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>splitKeepOrderAndDTIntegrity(pkgDT, splitOn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitKeepOrderAndDTIntegrity_+3A_pkgdt">pkgDT</code></td>
<td>
<p>A <code>pkgDT</code> object e.g., from <code>toPkgDT</code></p>
</td></tr>
<tr><td><code id="splitKeepOrderAndDTIntegrity_+3A_spliton">splitOn</code></td>
<td>
<p>Character vector passed to <code>data.table::split(..., f = splitOn)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>data.table</code> objects of <code>length(unique(splitOn))</code>.
</p>

<hr>
<h2 id='sysInstallAndDownload'>download.files or install.packages in a separate process</h2><span id='topic+sysInstallAndDownload'></span>

<h3>Description</h3>

<p>This uses <code>sys</code> package so that messaging can be controlled. This also provides
the option to parallelize by spawning multiple <code>background</code> process to allow
parallel e.g., downloads. Noting that if <code>libcurl</code> is installed (and detected
using <code>capabilities("libcurl")</code>), then no explicit parallelism will be allowed,
instead <code>method = "libcurl"</code> will be passed enabling parallel downloads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sysInstallAndDownload(
  args,
  splitOn = "pkgs",
  doLine = "outfiles &lt;- do.call(download.packages, args)",
  returnOutfile = FALSE,
  doLineVectorized = TRUE,
  tmpdir,
  libPaths,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sysInstallAndDownload_+3A_args">args</code></td>
<td>
<p>A list with all arguments for a do.call to either <code style="white-space: pre;">&#8288;download.file, &#8288;</code>install.packages<code style="white-space: pre;">&#8288;or a custom other function e.g.,&#8288;</code>downloadAndBuildToLocalFile'.</p>
</td></tr>
<tr><td><code id="sysInstallAndDownload_+3A_spliton">splitOn</code></td>
<td>
<p>A character vector of the names in <code>args</code> to parallelize over.
Defaults to <code>pkgs</code>. All other named elements in <code>args</code> will be assumed to
be length 1 and used for every parallel process.</p>
</td></tr>
<tr><td><code id="sysInstallAndDownload_+3A_doline">doLine</code></td>
<td>
<p>A character string with the <code>"outfiles &lt;- do.call(..., args)"</code> line.</p>
</td></tr>
<tr><td><code id="sysInstallAndDownload_+3A_returnoutfile">returnOutfile</code></td>
<td>
<p>A logical. If <code>TRUE</code>, then the names of the <code>outfiles</code> will
be returned.</p>
</td></tr>
<tr><td><code id="sysInstallAndDownload_+3A_dolinevectorized">doLineVectorized</code></td>
<td>
<p>A logical. If <code>TRUE</code>, and parallism is being used, this
indicates that the <code>doLine</code> is a function that allows for multiple elements
in <code style="white-space: pre;">&#8288;args[[splitOn[[1]]]&#8288;</code>. If <code>FALSE</code>, the function will make multiple
sequential calls within each parallel process to the <code>doLine</code> call.</p>
</td></tr>
<tr><td><code id="sysInstallAndDownload_+3A_tmpdir">tmpdir</code></td>
<td>
<p>A single path where all downloads will be put</p>
</td></tr>
<tr><td><code id="sysInstallAndDownload_+3A_libpaths">libPaths</code></td>
<td>
<p>The library path (or libraries) where all packages should be
installed, and looked for to load (i.e., call <code>library</code>). This can be used
to create isolated, stand alone package installations, if used with
<code>standAlone = TRUE</code>. Currently, the path supplied here will be prepended to
<code>.libPaths()</code> (temporarily during this call) to <code>Require</code> if
<code>standAlone = FALSE</code> or will set (temporarily) <code>.libPaths()</code> to
<code style="white-space: pre;">&#8288;c(libPaths, tail(libPaths(), 1)&#8288;</code> to keep base packages.</p>
</td></tr>
<tr><td><code id="sysInstallAndDownload_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mostly for side effects, namely installed packages or downloaded packages or
files. However, in the case of <code>returnOutfile = TRUE</code>, then a list of
filenames will be returned with any outputs from the <code>doLine</code>.
</p>

<hr>
<h2 id='tempdir2'>Make a temporary (sub-)directory</h2><span id='topic+tempdir2'></span>

<h3>Description</h3>

<p>Create a temporary subdirectory in <code>.RequireTempPath()</code>, or a
temporary file in that temporary subdirectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempdir2(
  sub = "",
  tempdir = getOption("Require.tempPath", .RequireTempPath()),
  create = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tempdir2_+3A_sub">sub</code></td>
<td>
<p>Character string, length 1. Can be a result of
<code>file.path("smth", "smth2")</code> for nested temporary sub
directories.</p>
</td></tr>
<tr><td><code id="tempdir2_+3A_tempdir">tempdir</code></td>
<td>
<p>Optional character string where the
temporary dir should be placed. Defaults to <code>.RequireTempPath()</code></p>
</td></tr>
<tr><td><code id="tempdir2_+3A_create">create</code></td>
<td>
<p>Logical. Should the directory be created. Default <code>TRUE</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tempfile2">tempfile2()</a></code>
</p>

<hr>
<h2 id='tempfile2'>Make a temporary subfile in a temporary (sub-)directory</h2><span id='topic+tempfile2'></span>

<h3>Description</h3>

<p>Make a temporary subfile in a temporary (sub-)directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempfile2(
  sub = "",
  tempdir = getOption("Require.tempPath", .RequireTempPath()),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tempfile2_+3A_sub">sub</code></td>
<td>
<p>Character string, length 1. Can be a result of
<code>file.path("smth", "smth2")</code> for nested temporary sub
directories.</p>
</td></tr>
<tr><td><code id="tempfile2_+3A_tempdir">tempdir</code></td>
<td>
<p>Optional character string where the
temporary dir should be placed. Defaults to <code>.RequireTempPath()</code></p>
</td></tr>
<tr><td><code id="tempfile2_+3A_...">...</code></td>
<td>
<p>passed to <code>tempfile</code>, e.g., <code>fileext</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tempdir2">tempdir2()</a></code>
</p>

<hr>
<h2 id='trimVersionNumber'>Trim version number off a compound package name</h2><span id='topic+trimVersionNumber'></span>

<h3>Description</h3>

<p>The resulting string(s) will have only name (including github.com repository if it exists).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimVersionNumber(pkgs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimVersionNumber_+3A_pkgs">pkgs</code></td>
<td>
<p>A character string vector of packages with or without GitHub path or versions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+extractPkgName">extractPkgName()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trimVersionNumber("PredictiveEcology/Require (&lt;=0.0.1)")
</code></pre>

<hr>
<h2 id='updatePackages'>Update installed packages with latest available versions</h2><span id='topic+updatePackages'></span>

<h3>Description</h3>

<p>Similar to <code>update.packages</code>, but works for archived, non-archived,
and Github packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updatePackages(
  libPaths = .libPaths()[1],
  purge = FALSE,
  verbose = getOption("Require.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updatePackages_+3A_libpaths">libPaths</code></td>
<td>
<p>The library to update; defaults to <code>.libPaths()[1]</code></p>
</td></tr>
<tr><td><code id="updatePackages_+3A_purge">purge</code></td>
<td>
<p>Logical. Should the assessment of <code>installed.packages</code> purge the cached
version. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="updatePackages_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Run for its side effect, namely, updating installed packages to their latest
possible state, whether they are on CRAN currently, archived, or on GitHub.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
