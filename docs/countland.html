<!DOCTYPE html><html lang="en"><head><title>Help for package countland</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {countland}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Center'><p>Recapitulate Seurat centering scaled and transformed data</p></a></li>
<li><a href='#Cluster'><p>Perform spectral clustering on dot products.</p></a></li>
<li><a href='#CountIndex'><p>Internal function for calculating count index.</p></a></li>
<li><a href='#countland'><p>Initialize a countland object from a dgCMatrix</p></a></li>
<li><a href='#countland-class'><p>An S4 class to represent a countland object</p></a></li>
<li><a href='#Dot'><p>Calculate pairwise dot products of counts between all cells.</p></a></li>
<li><a href='#Embed'><p>Perform spectral embedding on dot products.</p></a></li>
<li><a href='#IMA'><p>run integer matrix approximation</p></a></li>
<li><a href='#IMA_Compute_Init_Scaled'><p>rescale if max val is above upper bound</p></a></li>
<li><a href='#IMA_init'><p>function to initialize U, V, and Lambda</p></a></li>
<li><a href='#IMA_params'><p>Parameter class for IMA</p></a></li>
<li><a href='#IMA_Update_Factor'><p>Update factor matrix - see SUSTain code</p></a></li>
<li><a href='#listCols'><p>Split dgCMatrix into column vectors.</p></a></li>
<li><a href='#Log'><p>Recapitulate Seurat log transformation</p></a></li>
<li><a href='#Normalize'><p>Recapitulate Seurat normalization</p></a></li>
<li><a href='#PlotEigengap'><p>Plots eigenvalues to investigate the optimal number of clusters</p></a></li>
<li><a href='#PlotEmbedding'><p>Plot cells using spectral embedding of dot products.</p></a></li>
<li><a href='#PlotGeneCounts'><p>Generate a strip plot for counts across selected genes</p></a></li>
<li><a href='#PlotIMA'><p>Plot cells using integer matrix approximation</p></a></li>
<li><a href='#PlotIMAElbow'><p>Plot the difference between the observed and reconstructed count matrix using integer matrix approximation and a series of total features.</p></a></li>
<li><a href='#PlotMarker'><p>Plot cell using spectral embedding and display counts in a given gene.</p></a></li>
<li><a href='#PlotSharedCounts'><p>Plot cells using matrix of counts summed by clusters of genes.</p></a></li>
<li><a href='#PrintGeneNumber'><p>Restore count matrix to original state</p></a></li>
<li><a href='#RankMarkerGenes'><p>Rank the top marker genes for each cluster from spectral clustering.</p></a></li>
<li><a href='#RemoveEmpty'><p>Internal function to remove empty columns and rows</p></a></li>
<li><a href='#RescaleVariance'><p>Recapitulate Seurat scaling to unit variance</p></a></li>
<li><a href='#RestoreCounts'><p>Restore count matrix to original state</p></a></li>
<li><a href='#RunIMA'><p>Perform integer matrix approximation on count matrix.</p></a></li>
<li><a href='#ScikitManifoldSpectralEmbedding'><p>Recapitulate scikit.manifold.spectral_embedding from python.</p></a></li>
<li><a href='#ScoreCells'><p>Calculate several scores for counts across cells</p></a></li>
<li><a href='#ScoreGenes'><p>Calculate several scores for count-based gene expression.</p></a></li>
<li><a href='#SharedCounts'><p>Combine groups of genes with similar counts by clustering and summing.</p></a></li>
<li><a href='#Subsample'><p>Subsample cells to a standard number of counts by randomly sampling observations without replacement.</p></a></li>
<li><a href='#SubsampleCol'><p>Internal function for subsampling a column from a sparse matrix.</p></a></li>
<li><a href='#SubsetCells'><p>Subsets cells using a vector of cell indices</p></a></li>
<li><a href='#SubsetGenes'><p>Subsets genes using a vector of gene indices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Analysis of Biological Count Data, Especially from Single-Cell
RNA-Seq</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions for applying a 
    restricted linear algebra to the analysis of 
    count-based data. See the accompanying preprint
    manuscript: "Normalizing need not be the norm:
    count-based math for analyzing single-cell data"
    Church et al (2022) &lt;<a href="https://doi.org/10.1101%2F2022.06.01.494334">doi:10.1101/2022.06.01.494334</a>&gt;
    This tool is specifically designed to analyze 
    count matrices from single cell RNA sequencing 
    assays. The tools implement several count-based
    approaches for standard steps in single-cell 
    RNA-seq analysis, including scoring genes and cells, 
    comparing cells and clustering, calculating differential 
    gene expression, and several methods for rank 
    reduction. There are many opportunities for further
    optimization that may prove useful in the analysis of
    other data. We provide the source code freely
    available at <a href="https://github.com/shchurch/countland">https://github.com/shchurch/countland</a>
    and encourage users and developers to fork the code for 
    their own purposes. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shchurch/countland">https://github.com/shchurch/countland</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shchurch/countland/issues">https://github.com/shchurch/countland/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, rlang, Matrix, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tidyverse, viridis, gridExtra, igraph, RSpectra, matrixTests,
rdist, stats, Seurat, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 17:48:49 UTC; samuelchurch</td>
</tr>
<tr>
<td>Author:</td>
<td>Church Samuel H. <a href="https://orcid.org/0000-0002-8451-103X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Church Samuel H. &lt;samuelhchurch@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-01 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Center'>Recapitulate Seurat centering scaled and transformed data</h2><span id='topic+Center'></span>

<h3>Description</h3>

<p>Recapitulate Seurat centering scaled and transformed data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Center(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Center_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slots <code>centered_counts</code>
</p>

<hr>
<h2 id='Cluster'>Perform spectral clustering on dot products.</h2><span id='topic+Cluster'></span>

<h3>Description</h3>

<p>Perform spectral clustering on dot products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cluster(C, n_clusters, n_components = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cluster_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="Cluster_+3A_n_clusters">n_clusters</code></td>
<td>
<p>number of clusters, integer</p>
</td></tr>
<tr><td><code id="Cluster_+3A_n_components">n_components</code></td>
<td>
<p>number of components from spectral embedding to use (default NULL, will be set to n_clusters), integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slot <code>cluster_labels</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- Dot(C)
C &lt;- Embed(C,n_components=5)
C &lt;- Cluster(C,n_clusters=3)
</code></pre>

<hr>
<h2 id='CountIndex'>Internal function for calculating count index.</h2><span id='topic+CountIndex'></span>

<h3>Description</h3>

<p>Internal function for calculating count index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountIndex(lm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CountIndex_+3A_lm">lm</code></td>
<td>
<p>column vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>count index = largest n where n cells have &gt;= n counts
</p>

<hr>
<h2 id='countland'>Initialize a countland object from a dgCMatrix</h2><span id='topic+countland'></span>

<h3>Description</h3>

<p>Initialize a countland object from a dgCMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countland(m, remove_empty = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countland_+3A_m">m</code></td>
<td>
<p>A matrix of counts (dense or sparse)</p>
</td></tr>
<tr><td><code id="countland_+3A_remove_empty">remove_empty</code></td>
<td>
<p>filter out cells and genes with no observed counts (default=TRUE)</p>
</td></tr>
<tr><td><code id="countland_+3A_verbose">verbose</code></td>
<td>
<p>show stderr message statements (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
</code></pre>

<hr>
<h2 id='countland-class'>An S4 class to represent a countland object</h2><span id='topic+countland-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a countland object
</p>


<h3>Slots</h3>


<dl>
<dt><code>counts</code></dt><dd><p>A dgCMatrix with rows as cells, columns as genes.</p>
</dd>
<dt><code>names_genes</code></dt><dd><p>A character vector of column names.</p>
</dd>
<dt><code>names_cells</code></dt><dd><p>A character vector of row names.</p>
</dd>
<dt><code>raw_counts</code></dt><dd><p>The count dgCMatrix as originally loaded.</p>
</dd>
<dt><code>raw_names_genes</code></dt><dd><p>The gene name character vector as originally loaded.</p>
</dd>
<dt><code>raw_names_cells</code></dt><dd><p>The cell name character vector as originally loaded.</p>
</dd>
<dt><code>subsample</code></dt><dd><p>A dgCMatrix with row sums equal.</p>
</dd>
<dt><code>cell_scores</code></dt><dd><p>A data.frame of cell count measures.</p>
</dd>
<dt><code>gene_scores</code></dt><dd><p>A data.frame of gene expression measures.</p>
</dd>
<dt><code>dots</code></dt><dd><p>A similarity dgCMatrix of dot products.</p>
</dd>
<dt><code>eigenvals</code></dt><dd><p>An vector of eigenvalues from spectral embedding</p>
</dd>
<dt><code>embedding</code></dt><dd><p>An array of two columns (spectral embeddings).</p>
</dd>
<dt><code>cluster_labels</code></dt><dd><p>A numeric vector of cluster assignments of length n cells.</p>
</dd>
<dt><code>marker_full</code></dt><dd><p>A list of data.frames with genes ranked for each cluster.</p>
</dd>
<dt><code>marker_genes</code></dt><dd><p>A data.frame of top ten marker genes per cluster.</p>
</dd>
<dt><code>matrixU</code></dt><dd><p>A dgCMatrix of dimensions cells x features.</p>
</dd>
<dt><code>matrixV</code></dt><dd><p>A dgCMatrix of dimensions genes x features.</p>
</dd>
<dt><code>matrixLambda</code></dt><dd><p>A diagonal dgCMatrix of scaling factors.</p>
</dd>
<dt><code>sharedcounts</code></dt><dd><p>A similarity dgCMatrix of shared counts between genes.</p>
</dd>
<dt><code>sum_sharedcounts</code></dt><dd><p>A dgCMatrix with counts summed within gene clusters.</p>
</dd>
<dt><code>sum_sharedcounts_all</code></dt><dd><p>A dgCMatrix with counts summed and including all genes not present in any cluster.</p>
</dd>
<dt><code>norm_factor</code></dt><dd><p>A numeric vector of cell normalization factors.</p>
</dd>
<dt><code>norm_counts</code></dt><dd><p>A dgCMatrix of normalized counts.</p>
</dd>
<dt><code>log_counts</code></dt><dd><p>A dgCMatrix of log transformed counts.</p>
</dd>
<dt><code>scaled_counts</code></dt><dd><p>A dgCMatrix of counts scaled by gene unit variance.</p>
</dd>
<dt><code>centered_counts</code></dt><dd><p>A dgCMatrix of counts centered at zero.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A T/F object for suppressing messages</p>
</dd>
</dl>

<hr>
<h2 id='Dot'>Calculate pairwise dot products of counts between all cells.</h2><span id='topic+Dot'></span>

<h3>Description</h3>

<p>Calculate pairwise dot products of counts between all cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dot(C, subsample = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dot_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="Dot_+3A_subsample">subsample</code></td>
<td>
<p>if TRUE, use subsampled counts, otherwise use counts (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slot <code>dots</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- Dot(C)
</code></pre>

<hr>
<h2 id='Embed'>Perform spectral embedding on dot products.</h2><span id='topic+Embed'></span>

<h3>Description</h3>

<p>Perform spectral embedding on dot products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Embed(C, n_components = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Embed_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="Embed_+3A_n_components">n_components</code></td>
<td>
<p>number of components, integer (default=10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slot <code>embedding</code>, <code>eigenvals</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- Dot(C)
C &lt;- Embed(C,n_components=5)
</code></pre>

<hr>
<h2 id='IMA'>run integer matrix approximation</h2><span id='topic+IMA'></span>

<h3>Description</h3>

<p>run integer matrix approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMA(X, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IMA_+3A_x">X</code></td>
<td>
<p>observed data matrix</p>
</td></tr>
<tr><td><code id="IMA_+3A_params">params</code></td>
<td>
<p>parameter object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>U, V, and Lambda matrix factors
</p>

<hr>
<h2 id='IMA_Compute_Init_Scaled'>rescale if max val is above upper bound</h2><span id='topic+IMA_Compute_Init_Scaled'></span>

<h3>Description</h3>

<p>rescale if max val is above upper bound
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMA_Compute_Init_Scaled(h, l_bound, u_bound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IMA_Compute_Init_Scaled_+3A_h">h</code></td>
<td>
<p>matrix to be rescaled</p>
</td></tr>
<tr><td><code id="IMA_Compute_Init_Scaled_+3A_l_bound">l_bound</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="IMA_Compute_Init_Scaled_+3A_u_bound">u_bound</code></td>
<td>
<p>upper bound</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rescaled matrix
</p>

<hr>
<h2 id='IMA_init'>function to initialize U, V, and Lambda</h2><span id='topic+IMA_init'></span>

<h3>Description</h3>

<p>function to initialize U, V, and Lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMA_init(X, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IMA_init_+3A_x">X</code></td>
<td>
<p>observed data matrix</p>
</td></tr>
<tr><td><code id="IMA_init_+3A_params">params</code></td>
<td>
<p>parameter object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>initialized U, V, and Lambda matrices
</p>

<hr>
<h2 id='IMA_params'>Parameter class for IMA</h2><span id='topic+IMA_params'></span>

<h3>Description</h3>

<p>Parameter class for IMA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMA_params(
  rank,
  u_bounds,
  l_bounds = c(0, 0),
  maxiter = 1e+06,
  stop_crit = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IMA_params_+3A_rank">rank</code></td>
<td>
<p>target number of features in final matrices</p>
</td></tr>
<tr><td><code id="IMA_params_+3A_u_bounds">u_bounds</code></td>
<td>
<p>upper bounds on integers</p>
</td></tr>
<tr><td><code id="IMA_params_+3A_l_bounds">l_bounds</code></td>
<td>
<p>lower bounds on integers (default = c(0,0))</p>
</td></tr>
<tr><td><code id="IMA_params_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations (default = 1000000)</p>
</td></tr>
<tr><td><code id="IMA_params_+3A_stop_crit">stop_crit</code></td>
<td>
<p>criterion of difference at which to stop (default = 0.0001)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parameter object
</p>

<hr>
<h2 id='IMA_Update_Factor'>Update factor matrix - see SUSTain code</h2><span id='topic+IMA_Update_Factor'></span>

<h3>Description</h3>

<p>Update factor matrix - see SUSTain code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMA_Update_Factor(M, coeff, mkrp, mode, lambda_, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IMA_Update_Factor_+3A_m">M</code></td>
<td>
<p>matrix to be updated (either U or V)</p>
</td></tr>
<tr><td><code id="IMA_Update_Factor_+3A_coeff">coeff</code></td>
<td>
<p>matrix used in updating algorithm</p>
</td></tr>
<tr><td><code id="IMA_Update_Factor_+3A_mkrp">mkrp</code></td>
<td>
<p>matrix used in updating algorithm</p>
</td></tr>
<tr><td><code id="IMA_Update_Factor_+3A_mode">mode</code></td>
<td>
<p>whether update U or V</p>
</td></tr>
<tr><td><code id="IMA_Update_Factor_+3A_lambda_">lambda_</code></td>
<td>
<p>scaling matrix</p>
</td></tr>
<tr><td><code id="IMA_Update_Factor_+3A_params">params</code></td>
<td>
<p>parameter object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated matrix and scaling factors
</p>

<hr>
<h2 id='listCols'>Split dgCMatrix into column vectors.</h2><span id='topic+listCols'></span>

<h3>Description</h3>

<p>Split dgCMatrix into column vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listCols(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="listCols_+3A_m">m</code></td>
<td>
<p>dgCMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of column vectors, numeric
</p>

<hr>
<h2 id='Log'>Recapitulate Seurat log transformation</h2><span id='topic+Log'></span>

<h3>Description</h3>

<p>Recapitulate Seurat log transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Log(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Log_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slots <code>log_counts</code>
</p>

<hr>
<h2 id='Normalize'>Recapitulate Seurat normalization</h2><span id='topic+Normalize'></span>

<h3>Description</h3>

<p>Recapitulate Seurat normalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normalize(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Normalize_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slots <code>norm_factor</code>, <code>norm_counts</code>
</p>

<hr>
<h2 id='PlotEigengap'>Plots eigenvalues to investigate the optimal number of clusters</h2><span id='topic+PlotEigengap'></span>

<h3>Description</h3>

<p>Plots eigenvalues to investigate the optimal number of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotEigengap(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotEigengap_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates plot of eigenvalues by number of components
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- Dot(C)
C &lt;- Embed(C,n_components=5)
PlotEigengap(C)
</code></pre>

<hr>
<h2 id='PlotEmbedding'>Plot cells using spectral embedding of dot products.</h2><span id='topic+PlotEmbedding'></span>

<h3>Description</h3>

<p>Plot cells using spectral embedding of dot products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotEmbedding(C, colors = color_palette)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotEmbedding_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="PlotEmbedding_+3A_colors">colors</code></td>
<td>
<p>color palette for ggplot2, default=palette of 11 colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates plot of cells in two spectral embedding dimensions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- Dot(C)
C &lt;- Embed(C,n_components=5)
C &lt;- Cluster(C,n_clusters=3)
PlotEmbedding(C)
</code></pre>

<hr>
<h2 id='PlotGeneCounts'>Generate a strip plot for counts across selected genes</h2><span id='topic+PlotGeneCounts'></span>

<h3>Description</h3>

<p>Generate a strip plot for counts across selected genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGeneCounts(C, gene_indices, colors = color_palette)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotGeneCounts_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="PlotGeneCounts_+3A_gene_indices">gene_indices</code></td>
<td>
<p>vector of gene index values</p>
</td></tr>
<tr><td><code id="PlotGeneCounts_+3A_colors">colors</code></td>
<td>
<p>color palette for ggplot2, default=palette of 11 colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates plot of gene count distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
PlotGeneCounts(C,gene_indices=1:10)
</code></pre>

<hr>
<h2 id='PlotIMA'>Plot cells using integer matrix approximation</h2><span id='topic+PlotIMA'></span>

<h3>Description</h3>

<p>Plot cells using integer matrix approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotIMA(C, x = 1, y = 2, colors = color_palette, subsample = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotIMA_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="PlotIMA_+3A_x">x</code></td>
<td>
<p>feature on x-axis, integer (default=1)</p>
</td></tr>
<tr><td><code id="PlotIMA_+3A_y">y</code></td>
<td>
<p>feature on y-axis, integer (default=2)</p>
</td></tr>
<tr><td><code id="PlotIMA_+3A_colors">colors</code></td>
<td>
<p>color palette for ggplot2, default=palette of 11 colors</p>
</td></tr>
<tr><td><code id="PlotIMA_+3A_subsample">subsample</code></td>
<td>
<p>if TRUE, use subsampled counts (default), otherwise use counts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates plot of cells using integer matrix approximation
</p>

<hr>
<h2 id='PlotIMAElbow'>Plot the difference between the observed and reconstructed count matrix using integer matrix approximation and a series of total features.</h2><span id='topic+PlotIMAElbow'></span>

<h3>Description</h3>

<p>Plot the difference between the observed and reconstructed count matrix using integer matrix approximation and a series of total features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotIMAElbow(C, max_features, u_bounds, subsample = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotIMAElbow_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="PlotIMAElbow_+3A_max_features">max_features</code></td>
<td>
<p>maximum number of features to assess, integer</p>
</td></tr>
<tr><td><code id="PlotIMAElbow_+3A_u_bounds">u_bounds</code></td>
<td>
<p>upper bounds for U and V matrices, vector of length 2</p>
</td></tr>
<tr><td><code id="PlotIMAElbow_+3A_subsample">subsample</code></td>
<td>
<p>if TRUE, use subsampled counts (default), otherwise use counts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates elbow plot for the difference between observed and reconstructed matrices as number of features increases
</p>

<hr>
<h2 id='PlotMarker'>Plot cell using spectral embedding and display counts in a given gene.</h2><span id='topic+PlotMarker'></span>

<h3>Description</h3>

<p>Plot cell using spectral embedding and display counts in a given gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotMarker(C, gene_index, colors = color_palette)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotMarker_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="PlotMarker_+3A_gene_index">gene_index</code></td>
<td>
<p>index value for gene to visualize</p>
</td></tr>
<tr><td><code id="PlotMarker_+3A_colors">colors</code></td>
<td>
<p>color palette for ggplot2, default=palette of 11 colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates plot of cells with spectral embedding, colored by marker gene counts
</p>

<hr>
<h2 id='PlotSharedCounts'>Plot cells using matrix of counts summed by clusters of genes.</h2><span id='topic+PlotSharedCounts'></span>

<h3>Description</h3>

<p>Plot cells using matrix of counts summed by clusters of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSharedCounts(C, x = 1, y = 2, colors = color_palette)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotSharedCounts_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="PlotSharedCounts_+3A_x">x</code></td>
<td>
<p>gene cluster to plot on x-axis, integer (default=1)</p>
</td></tr>
<tr><td><code id="PlotSharedCounts_+3A_y">y</code></td>
<td>
<p>gene cluster to plot on y-axis, integer (default=2)</p>
</td></tr>
<tr><td><code id="PlotSharedCounts_+3A_colors">colors</code></td>
<td>
<p>color palette for ggplot2, default=palette of 11 colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates plot of cells using shared counts
</p>

<hr>
<h2 id='PrintGeneNumber'>Restore count matrix to original state</h2><span id='topic+PrintGeneNumber'></span>

<h3>Description</h3>

<p>Restore count matrix to original state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrintGeneNumber(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PrintGeneNumber_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object
</p>

<hr>
<h2 id='RankMarkerGenes'>Rank the top marker genes for each cluster from spectral clustering.</h2><span id='topic+RankMarkerGenes'></span>

<h3>Description</h3>

<p>Rank the top marker genes for each cluster from spectral clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RankMarkerGenes(C, method = "prop-zero", subsample = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RankMarkerGenes_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="RankMarkerGenes_+3A_method">method</code></td>
<td>
<p><code>prop-zero</code> to rank by proportion of cells that are non-zero (default), or <code>rank-sums</code> to rank using Wilcoxon rank-sums test</p>
</td></tr>
<tr><td><code id="RankMarkerGenes_+3A_subsample">subsample</code></td>
<td>
<p>if TRUE, use subsampled counts, otherwise use counts (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slots <code>marker_genes</code> and <code>marker_full</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- Dot(C)
C &lt;- Embed(C,n_components=5)
C &lt;- Cluster(C,n_clusters=3)
C &lt;- RankMarkerGenes(C,method='prop-zero',subsample=FALSE)
</code></pre>

<hr>
<h2 id='RemoveEmpty'>Internal function to remove empty columns and rows</h2><span id='topic+RemoveEmpty'></span>

<h3>Description</h3>

<p>Internal function to remove empty columns and rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RemoveEmpty(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RemoveEmpty_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object, count matrix updated
</p>

<hr>
<h2 id='RescaleVariance'>Recapitulate Seurat scaling to unit variance</h2><span id='topic+RescaleVariance'></span>

<h3>Description</h3>

<p>Recapitulate Seurat scaling to unit variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RescaleVariance(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RescaleVariance_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slots <code>scaled_counts</code>
</p>

<hr>
<h2 id='RestoreCounts'>Restore count matrix to original state</h2><span id='topic+RestoreCounts'></span>

<h3>Description</h3>

<p>Restore count matrix to original state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RestoreCounts(C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RestoreCounts_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- SubsetGenes(C,gene_indices=1:200)
C &lt;- SubsetCells(C,cell_indices=1:50)
C &lt;- RestoreCounts(C)
</code></pre>

<hr>
<h2 id='RunIMA'>Perform integer matrix approximation on count matrix.</h2><span id='topic+RunIMA'></span>

<h3>Description</h3>

<p>Perform integer matrix approximation on count matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunIMA(
  C,
  features,
  u_bounds,
  l_bounds = c(0, 0),
  maxiter = 1e+06,
  stop_crit = 1e-04,
  subsample = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RunIMA_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="RunIMA_+3A_features">features</code></td>
<td>
<p>target number of features, integer</p>
</td></tr>
<tr><td><code id="RunIMA_+3A_u_bounds">u_bounds</code></td>
<td>
<p>upper bounds for U and V matrices, vector of length 2</p>
</td></tr>
<tr><td><code id="RunIMA_+3A_l_bounds">l_bounds</code></td>
<td>
<p>lower bounds for U and V matrices, vector of length 2 (default=c(0,0))</p>
</td></tr>
<tr><td><code id="RunIMA_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations, integer (default=1000000)</p>
</td></tr>
<tr><td><code id="RunIMA_+3A_stop_crit">stop_crit</code></td>
<td>
<p>criterion for stopping based on difference between iterations, numeric (default=0.0001)</p>
</td></tr>
<tr><td><code id="RunIMA_+3A_subsample">subsample</code></td>
<td>
<p>if TRUE, use subsampled counts (default), otherwise use counts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slots <code>matrixU</code>, <code>matrixV</code>, <code>matrixLambda</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- RunIMA(C,features=10,u_bounds=c(10,10),subsample=FALSE)
</code></pre>

<hr>
<h2 id='ScikitManifoldSpectralEmbedding'>Recapitulate scikit.manifold.spectral_embedding from python.</h2><span id='topic+ScikitManifoldSpectralEmbedding'></span>

<h3>Description</h3>

<p>Recapitulate scikit.manifold.spectral_embedding from python.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScikitManifoldSpectralEmbedding(A, n_components)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScikitManifoldSpectralEmbedding_+3A_a">A</code></td>
<td>
<p>similarity matrix, dgCMatrix</p>
</td></tr>
<tr><td><code id="ScikitManifoldSpectralEmbedding_+3A_n_components">n_components</code></td>
<td>
<p>number of eigenvectors to retain, integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of eigenvectors
</p>

<hr>
<h2 id='ScoreCells'>Calculate several scores for counts across cells</h2><span id='topic+ScoreCells'></span>

<h3>Description</h3>

<p>Calculate several scores for counts across cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScoreCells(C, gene_string = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScoreCells_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="ScoreCells_+3A_gene_string">gene_string</code></td>
<td>
<p>string with regular expression expression matching gene names of interest (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slot cell_scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- ScoreCells(C,gene_string="*149932$")
</code></pre>

<hr>
<h2 id='ScoreGenes'>Calculate several scores for count-based gene expression.</h2><span id='topic+ScoreGenes'></span>

<h3>Description</h3>

<p>Calculate several scores for count-based gene expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScoreGenes(C, subsample = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScoreGenes_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="ScoreGenes_+3A_subsample">subsample</code></td>
<td>
<p>if TRUE, use subsampled counts, otherwise use counts (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slot gene_scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- ScoreGenes(C)
</code></pre>

<hr>
<h2 id='SharedCounts'>Combine groups of genes with similar counts by clustering and summing.</h2><span id='topic+SharedCounts'></span>

<h3>Description</h3>

<p>Combine groups of genes with similar counts by clustering and summing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SharedCounts(C, n_clusters, n_cells = 100, subsample = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SharedCounts_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="SharedCounts_+3A_n_clusters">n_clusters</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="SharedCounts_+3A_n_cells">n_cells</code></td>
<td>
<p>number of cells to sample for gene clustering</p>
</td></tr>
<tr><td><code id="SharedCounts_+3A_subsample">subsample</code></td>
<td>
<p>if TRUE, use subsampled counts (default), otherwise use counts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slots <code>shared_counts</code>, <code>sum_sharedcounts</code>, <code>sum_sharedcounts_all</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- SharedCounts(C,n_clusters=10,subsample=FALSE)
</code></pre>

<hr>
<h2 id='Subsample'>Subsample cells to a standard number of counts by randomly sampling observations without replacement.</h2><span id='topic+Subsample'></span>

<h3>Description</h3>

<p>Subsample cells to a standard number of counts by randomly sampling observations without replacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Subsample(C, gene_counts = NA, cell_counts = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Subsample_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="Subsample_+3A_gene_counts">gene_counts</code></td>
<td>
<p>maximum total counts for genes</p>
</td></tr>
<tr><td><code id="Subsample_+3A_cell_counts">cell_counts</code></td>
<td>
<p>sequencing depth for all cells, or &quot;min&quot; to use the minimum cell total</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object with slot <code>subsample</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- Subsample(C,gene_counts=250,cell_counts=100)
</code></pre>

<hr>
<h2 id='SubsampleCol'>Internal function for subsampling a column from a sparse matrix.</h2><span id='topic+SubsampleCol'></span>

<h3>Description</h3>

<p>Internal function for subsampling a column from a sparse matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubsampleCol(lm, li, j, n_counts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SubsampleCol_+3A_lm">lm</code></td>
<td>
<p>column vector</p>
</td></tr>
<tr><td><code id="SubsampleCol_+3A_li">li</code></td>
<td>
<p>row positions</p>
</td></tr>
<tr><td><code id="SubsampleCol_+3A_j">j</code></td>
<td>
<p>column index</p>
</td></tr>
<tr><td><code id="SubsampleCol_+3A_n_counts">n_counts</code></td>
<td>
<p>count to sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subsampled column as dgTMatrix components
</p>

<hr>
<h2 id='SubsetCells'>Subsets cells using a vector of cell indices</h2><span id='topic+SubsetCells'></span>

<h3>Description</h3>

<p>Subsets cells using a vector of cell indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubsetCells(C, cell_indices, remove_empty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SubsetCells_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="SubsetCells_+3A_cell_indices">cell_indices</code></td>
<td>
<p>vector of cell index values</p>
</td></tr>
<tr><td><code id="SubsetCells_+3A_remove_empty">remove_empty</code></td>
<td>
<p>filter out cells and genes with no observed counts (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object, count matrix updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- SubsetCells(C,cell_indices=1:50)
</code></pre>

<hr>
<h2 id='SubsetGenes'>Subsets genes using a vector of gene indices</h2><span id='topic+SubsetGenes'></span>

<h3>Description</h3>

<p>Subsets genes using a vector of gene indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubsetGenes(C, gene_indices, remove_empty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SubsetGenes_+3A_c">C</code></td>
<td>
<p>countland object</p>
</td></tr>
<tr><td><code id="SubsetGenes_+3A_gene_indices">gene_indices</code></td>
<td>
<p>vector of gene index values</p>
</td></tr>
<tr><td><code id="SubsetGenes_+3A_remove_empty">remove_empty</code></td>
<td>
<p>filter out cells and genes with no observed counts (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countland object, count matrix updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_path &lt;- system.file("testdata", package = "countland", mustWork = TRUE)
gold.data &lt;- Seurat::Read10X(data.dir = gold_path)
C &lt;- countland(gold.data)
C &lt;- SubsetGenes(C,gene_indices=1:200)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
