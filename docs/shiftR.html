<!DOCTYPE html><html><head><title>Help for package shiftR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shiftR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cramerV'>
<p>Calculate Cramer's V (phi) Coefficient</p></a></li>
<li><a href='#enrichmentAnalysis'>
<p>Fast Enrichment Testing via Circular Permutations on Non-Binary Outcomes</p></a></li>
<li><a href='#getOffsets'>
<p>Generate Random or Uniformly Spaced Permutation Offsets</p></a></li>
<li><a href='#matchDatasets'>
<p>Match Two Data Sets by Location</p></a></li>
<li><a href='#shiftR-package'>
<p>Fast Enrichment Analysis via Circular Permutations</p></a></li>
<li><a href='#shiftrPermBinary'>
<p>Fast Enrichment Testing on Binary Outcomes via Circular Permutations</p></a></li>
<li><a href='#shiftrPrepare'>
<p>Prepare Data for Fast Circular Permutation Analysis</p></a></li>
<li><a href='#simulate'>
<p>Generate Artificial Data for Tests and Illustrations</p></a></li>
<li><a href='#singlePermutation'>
<p>Count Feature Overlap Under a Permutation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Enrichment Analysis via Circular Permutations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-03-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast enrichment analysis for locally correlated statistics
        via circular permutations.
        The analysis can be performed at multiple significance thresholds
        for both primary and auxiliary data sets with
        efficient correction for multiple testing.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/andreyshabalin/shiftR/issues">https://github.com/andreyshabalin/shiftR/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/andreyshabalin/shiftR">https://github.com/andreyshabalin/shiftR</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, pander</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-21 20:08:34 UTC; Andrey</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrey A Shabalin <a href="https://orcid.org/0000-0003-0309-6821"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Edwin J C G van den Oord [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrey A Shabalin &lt;andrey.shabalin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-22 09:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cramerV'>
Calculate Cramer's V (phi) Coefficient
</h2><span id='topic+cramerV'></span>

<h3>Description</h3>

<p>This functions calculates Cramer's V coefficient
for overlap of two binary data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cramerV(sum12, sum1, sum2, len)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cramerV_+3A_len">len</code></td>
<td>

<p>Total number of elements in each data set.
</p>
</td></tr>
<tr><td><code id="cramerV_+3A_sum1">sum1</code></td>
<td>

<p>Number of active features in data set 1.
</p>
</td></tr>
<tr><td><code id="cramerV_+3A_sum2">sum2</code></td>
<td>

<p>Number of active features in data set 1.
</p>
</td></tr>
<tr><td><code id="cramerV_+3A_sum12">sum12</code></td>
<td>

<p>Number of simultaneously active features in the data sets.
</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>Returns the Cramer's V coefficient.
</p>


<h3>Note</h3>

<p>The parameters can be single values or vectors.
</p>


<h3>Author(s)</h3>

<p>Andrey A Shabalin <a href="mailto:andrey.shabalin@gmail.com">andrey.shabalin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Zero score for perfect independence
cramerV(100,10000,10000,1000000)

# Positive score for increased overlap
cramerV(150,10000,10000,1000000)

# Negative score for decreased overlap
cramerV( 50,10000,10000,1000000)

# We can input a vector for sum12
cramerV(99:101,10000,10000,1000000)
</code></pre>

<hr>
<h2 id='enrichmentAnalysis'>
Fast Enrichment Testing via Circular Permutations on Non-Binary Outcomes
</h2><span id='topic+enrichmentAnalysis'></span>

<h3>Description</h3>

<p>This function performs enrichment analysis on
two sets of matching test statistics.
The circular permutation scheme accounts for 
possible local correlation of test statistcs.
The testing is performed using the quantile thresholds
provided for each data set.
</p>
<p>For every permutation the enrichment is measure with
Cramer's V coefficient. The maximum/minimum coefficient
across all considered thresholds is recorded.
It is then compared with the maximum/minimum coefficient
observed without permuting the data.
</p>
<p>For matching data sets calculated at different genomic locations
please use <code><a href="#topic+matchDatasets">matchDatasets</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enrichmentAnalysis(
    pvstats1,
    pvstats2,
    percentiles1 = NULL,
    percentiles2 = NULL,
    npermute,
    margin = 0.05,
    threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enrichmentAnalysis_+3A_pvstats1">pvstats1</code></td>
<td>

<p>The vector of statistics for primary data set. <br />
The statistics must be p-value like, i.e. smaller is better.
</p>
</td></tr>
<tr><td><code id="enrichmentAnalysis_+3A_pvstats2">pvstats2</code></td>
<td>

<p>The vector of statistics for auxiliary data set. <br />
The statistics must be p-value like, i.e. smaller is better.
</p>
</td></tr>
<tr><td><code id="enrichmentAnalysis_+3A_percentiles1">percentiles1</code></td>
<td>

<p>These quantile thresholds are used to cut off top results 
in the primary data set
for matching with the top results in the auxiliary. <br />
Can be omitted if the vector <code>pvstats1</code> is binary.
</p>
</td></tr>
<tr><td><code id="enrichmentAnalysis_+3A_percentiles2">percentiles2</code></td>
<td>

<p>Same as <code>percentiles1</code>, but for the other data set.
</p>
</td></tr>
<tr><td><code id="enrichmentAnalysis_+3A_npermute">npermute</code></td>
<td>

<p>Number of permutations to perform.
</p>
</td></tr>
<tr><td><code id="enrichmentAnalysis_+3A_margin">margin</code></td>
<td>

<p>The minimum offset in the circular permutation to consider. <br />
Can be a fraction of total number of values or
an integer count of values. <br />
Passed in the call of <code><a href="#topic+getOffsetsRandom">getOffsetsRandom</a></code> for
generation of offsets.
</p>
</td></tr>
<tr><td><code id="enrichmentAnalysis_+3A_threads">threads</code></td>
<td>

<p>The number of CPU cores to use for calculations. <br />
Set to <code>TRUE</code> to use all cores. <br />
Multithreading is turned off by default.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with:
</p>
<table>
<tr><td><code>overallPV</code></td>
<td>

<p>The p-values for the overall test across all thresholds. <br />
The p-values are for enrichment, depletion, and two-sided test for both.
</p>
</td></tr>
<tr><td><code>byThresholdPV</code></td>
<td>

<p>The p-values for tests for each individual threshold. <br />
The p-values provided for enrichment, depletion, and two-sided test.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrey A Shabalin <a href="mailto:andrey.shabalin@gmail.com">andrey.shabalin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Data size
n = 1e5

### Generate vectors of test statistics with local correlation
window = 1000
pvstats1 = diff(cumsum(runif(n+window)), lag = window)
pvstats2 = diff(cumsum(runif(n+window)), lag = window)

# Add a bit of dependence
pvstats1 = pvstats1 + 0.5 * pvstats2

# test top 0.1, 1, 3, 5, and 10 percent

percentiles1 = c(0.001, 0.01, 0.03, 0.05, 0.1)
percentiles2 = c(0.001, 0.01, 0.03, 0.05, 0.1)

# The offset margin

margin = 0.05

# Set the number of permutations
# to the maximum

npermute = 1e3


enr = enrichmentAnalysis(
        pvstats1,
        pvstats2,
        percentiles1,
        percentiles2,
        npermute,
        margin ,
        threads = 2)

# View the results
enr
</code></pre>

<hr>
<h2 id='getOffsets'>
Generate Random or Uniformly Spaced Permutation Offsets
</h2><span id='topic+getOffsetsAll'></span><span id='topic+getOffsetsRandom'></span><span id='topic+getOffsetsUniform'></span><span id='topic+getNOffsetsMax'></span>

<h3>Description</h3>

<p>This functions generate offsets for permutation analysis 
with <code><a href="#topic+shiftrPermBinary">shiftrPermBinary</a></code>. 
Random, uniformly spaced, and complete sets are available via 
<code>getOffsetsRandom</code>, <code>getOffsetsUniform</code>, and 
<code>getOffsetsAll</code> functions respectively.
</p>
<p>The function <code>getNOffestsMax</code> calculates 
the maximum number of permutations (given the margin).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOffsetsRandom(n, npermute, margin = 0.05)
getOffsetsUniform(n, npermute, margin = 0.05)
getOffsetsAll(n, margin)

getNOffsetsMax(n, margin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOffsets_+3A_n">n</code></td>
<td>

<p>Number of features in the permuted sets.
</p>
</td></tr>
<tr><td><code id="getOffsets_+3A_npermute">npermute</code></td>
<td>

<p>The number of offsets to be generated (number of permutations).
</p>
</td></tr>
<tr><td><code id="getOffsets_+3A_margin">margin</code></td>
<td>

<p>Offsets by less than <code>margin*n</code> or 
more than <code>(1-margin)*n</code> are not generated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a set of permutation offsets for use in 
<code><a href="#topic+shiftrPermBinary">shiftrPermBinary</a></code> function. <br />
The set of offsets is 
</p>

<ol>
<li><p> random for <code>getOffsetsRandom</code>, 
</p>
</li>
<li><p> uniformly spaced for <code>getOffsetsUniform</code>, or 
</p>
</li>
<li><p> all possible for <code>getOffsetsAll</code>.
</p>
</li></ol>

<p>The function <code>getNOffestsMax</code> returns the 
maximum number of permutations (given the margin).
</p>


<h3>Author(s)</h3>

<p>Andrey A Shabalin <a href="mailto:andrey.shabalin@gmail.com">andrey.shabalin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Number of features, permutations, and margin
n = 100
npermute = 20
margin = 0.1

### Maximum number of permutations 
# Should be 81 (from 10 to 90)
getNOffsetsMax(n, margin)

### Random offsets
getOffsetsRandom(n, npermute, margin)

### Uniformly spaced offsets
getOffsetsUniform(n, npermute, margin)

### All possible offsets
getOffsetsAll(n, margin)
</code></pre>

<hr>
<h2 id='matchDatasets'>
Match Two Data Sets by Location
</h2><span id='topic+matchDatasets'></span>

<h3>Description</h3>

<p>The goal of this function is to match records in the data sets
for subsequent enrichment analysis.
</p>
<p>For each record in the primary data set (<code>data1</code>)
it finds the record in the auxiliary data set (<code>data1</code>)
which overlap with it or lie within the flanking distance (<code>flank</code>).
If multiple such auxiliary record are found, 
we select the one with the center closest to
the center of the primary record.
If no such record is available, no matching is made for the primary record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchDatasets(data1, data2, flank = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchDatasets_+3A_data1">data1</code></td>
<td>

<p>A data frame with the primary data set, must have at least 4 columns:
</p>

<ol>
<li><p> Chromosome name.
</p>
</li>
<li><p> Start position.
</p>
</li>
<li><p> End position.
</p>
</li>
<li><p> P-value or test statistic.
</p>
</li>
<li><p> Optional additional columns.
</p>
</li></ol>

</td></tr>
<tr><td><code id="matchDatasets_+3A_data2">data2</code></td>
<td>

<p>A data frame with the auxiliary data set. <br />
Must satisfy the same format criteria as the primary data set.
</p>
</td></tr>
<tr><td><code id="matchDatasets_+3A_flank">flank</code></td>
<td>

<p>Allowed distance between matched records. <br />
Set to zero to require overlap.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with matched data sets.
</p>
<table>
<tr><td><code>data1</code></td>
<td>

<p>The primary data sets without unmatched records.
</p>
</td></tr>
<tr><td><code>data2</code></td>
<td>

<p>The auxiliary data set records matching those in 
<code>data1</code> above. <br />
Note that some auxiliary records can get duplicated
if they are the best match for
multiple records in the primary data.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a technical reason, the chromosome positions are assumed to be
no greater than <code>1e9</code>.
</p>


<h3>Author(s)</h3>

<p>Andrey A Shabalin <a href="mailto:andrey.shabalin@gmail.com">andrey.shabalin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data1 = read.csv(text =
"chr,start,end,stat
chr1,100,200,1
chr1,150,250,2
chr1,200,300,3
chr1,300,400,4
chr1,997,997,5
chr1,998,998,6
chr1,999,999,7")

data2 = read.csv(text =
"chr,start,end,stat
chr1,130,130,1
chr1,140,140,2
chr1,165,165,3
chr1,200,200,4
chr1,240,240,5
chr1,340,340,6
chr1,350,350,7
chr1,360,360,8
chr1,900,900,9")

# Match data sets exactly.
matchDatasets(data1, data2, 0)

# Match data sets with a flank.
# The last records are now matched.
matchDatasets(data1, data2, 100)
</code></pre>

<hr>
<h2 id='shiftR-package'>
Fast Enrichment Analysis via Circular Permutations
</h2><span id='topic+shiftR-package'></span>

<h3>Description</h3>

<p>Fast enrichment analysis for locally correlated statistics
via circular permutations.
The analysis can be performed at multiple significance thresholds
for both primary and auxiliary data sets with 
with efficient correction for multiple testing.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
        Package: </td><td style="text-align: left;"> shiftR </td>
</tr>
<tr>
 <td style="text-align: left;">
        Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
        License: </td><td style="text-align: left;"> LGPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;"> 
        Depends: </td><td style="text-align: left;"> methods </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andrey A Shabalin <a href="mailto:andrey.shabalin@gmail.com">andrey.shabalin@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See the main function <code><a href="#topic+shiftrPermBinary">shiftrPermBinary</a></code> for more info.
</p>
<p>Run <code>browseVignettes("shiftR")</code> for the vignette.
</p>

<hr>
<h2 id='shiftrPermBinary'>
Fast Enrichment Testing on Binary Outcomes via Circular Permutations
</h2><span id='topic+shiftrPermBinary'></span>

<h3>Description</h3>

<p>This function performs very fast feature enrichment 
permutation testing between two binary data sets.
Circular permutations are used instead of simple permutations to 
preserve local dependence of test statistics.
The input data sets can be preprocessed with 
<code><a href="#topic+shiftrPrepareLeft">shiftrPrepareLeft</a></code> and <code><a href="#topic+shiftrPrepareRight">shiftrPrepareRight</a></code> 
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiftrPermBinary(
    left,
    right,
    offsets,
    alsoDoFisher = TRUE,
    returnPermOverlaps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shiftrPermBinary_+3A_left">left</code></td>
<td>

<p>The first vector of binary (0/1) outcomes. <br />
For repeated use it can be preprocessed with 
<code><a href="#topic+shiftrPrepareLeft">shiftrPrepareLeft</a></code> function.
</p>
</td></tr>
<tr><td><code id="shiftrPermBinary_+3A_right">right</code></td>
<td>

<p>The second vector of binary (0/1) outcomes. <br />
For repeated use it can be preprocessed with 
<code><a href="#topic+shiftrPrepareRight">shiftrPrepareRight</a></code> function.
</p>
</td></tr>
<tr><td><code id="shiftrPermBinary_+3A_offsets">offsets</code></td>
<td>

<p>Vector of offsets, can be generated by <code>getOffsetsRandom</code>,
<code>getOffsetsUniform</code>, or <code>getOffsetsAll</code>.
</p>
</td></tr>
<tr><td><code id="shiftrPermBinary_+3A_alsodofisher">alsoDoFisher</code></td>
<td>

<p>If <code>TRUE</code>, also perform Fisher exact test 
(via <code><a href="stats.html#topic+fisher.test">fisher.test</a></code>).
</p>
</td></tr>
<tr><td><code id="shiftrPermBinary_+3A_returnpermoverlaps">returnPermOverlaps</code></td>
<td>

<p>If <code>TRUE</code> return overlap counts under all tested permutations. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with:
</p>
<table>
<tr><td><code>nfeatures</code></td>
<td>

<p>Number of features in input data sets.
</p>
</td></tr>
<tr><td><code>lfeatures</code></td>
<td>

<p>Number of active features in the left data set.
</p>
</td></tr>
<tr><td><code>rfeatures</code></td>
<td>

<p>Number of active features in the right data set.
</p>
</td></tr>
<tr><td><code>overlap</code></td>
<td>

<p>Number of features simultaneously active in both data sets.
</p>
</td></tr>
<tr><td><code>overlapUnderNull</code></td>
<td>

<p>Expected value of <code>overlap</code> if input data sets were independent.
</p>
</td></tr>
<tr><td><code>enrichment</code></td>
<td>

<p>Enrichment ratio, equal to <code>overlap / overlapUnderNull</code>
</p>
</td></tr>
<tr><td><code>permPVenrich</code></td>
<td>

<p>Permutation p-value for enrichment (one-sided).
</p>
</td></tr>
<tr><td><code>permPVdeplete</code></td>
<td>

<p>Permutation p-value for depletion (one-sided).
</p>
</td></tr>
<tr><td><code>permPV</code></td>
<td>

<p>Permutation p-value for depletion (two-sided).
</p>
</td></tr>
<tr><td><code>permZ</code></td>
<td>

<p>Permutation z-statistic, 
calculated by fitting normal distribution to the <code>overlap</code> 
values under permutations. <br />
Positive values indicate enrichment.
</p>
</td></tr>
<tr><td><code>fisherTest</code></td>
<td>

<p>Fisher exact test, as output by <code><a href="stats.html#topic+fisher.test">fisher.test</a></code>
</p>
</td></tr>
<tr><td><code>fisherMat</code></td>
<td>

<p>Input 2x2 matrix for Fisher exact test.
</p>
</td></tr>
<tr><td><code>overlapsPerm</code></td>
<td>

<p>Vector of length <code>npermute</code> with <code>overlap</code>
values under permutations.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrey A Shabalin <a href="mailto:andrey.shabalin@gmail.com">andrey.shabalin@gmail.com</a>
</p>


<h3>See Also</h3>

<p>This function essentially involves <code>npermute</code> calls of
<code><a href="#topic+singlePermutation">singlePermutation</a></code> function
and calculation of summary statistics and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Number of features
nf = 1e6
npermute = 10000

### Generate data sets
# The vector of a few common active feature to create dependence
common = sample(c(0L,1L), size = nf, replace = TRUE, prob = c(0.999,0.001))

# Left and right data sets with the common active features
lset = sample(c(0L,1L), size = nf, replace = TRUE, prob = c(0.8,0.2)) | common
rset = sample(c(0L,1L), size = nf, replace = TRUE, prob = c(0.8,0.2)) | common

offsets = getOffsetsUniform(n = nf, npermute = npermute)

show(head(offsets))
show(tail(offsets))

z = shiftrPermBinary(lset, rset, offsets)

show(z)
</code></pre>

<hr>
<h2 id='shiftrPrepare'>
Prepare Data for Fast Circular Permutation Analysis
</h2><span id='topic+shiftrPrepareLeft'></span><span id='topic+shiftrPrepareRight'></span>

<h3>Description</h3>

<p>The concept of circular permutations
is symmetric with respect to the input data sets.
The algorithm for circular permutation calculation is, however,
not symmetric with respect to two datasets and 
thus the required data preprocessing is also different.
For simplicity, we call the data sets 'left' and 'right'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiftrPrepareLeft(set)
shiftrPrepareRight(set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shiftrPrepare_+3A_set">set</code></td>
<td>

<p>A 0/1 vector defining selected (genomic) features. 
The 'left' and 'right' sets must have equal length. 
The enrichment of their overlap can be assessed w
ith <code><a href="#topic+shiftrPermBinary">shiftrPermBinary</a></code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns objects of class <code>fcpLeft</code> and <code>fcpRight</code> respectively.
The returned objects are used in <code><a href="#topic+singlePermutation">singlePermutation</a></code> and 
<code><a href="#topic+shiftrPermBinary">shiftrPermBinary</a></code> functions.
</p>


<h3>Author(s)</h3>

<p>Andrey A Shabalin <a href="mailto:andrey.shabalin@gmail.com">andrey.shabalin@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See code<a href="#topic+shiftrPermBinary">shiftrPermBinary</a> function and the respective example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Number of features
nf = 1e6

### Generate left and right sets
lset = sample(c(0L,1L), size = nf, replace = TRUE)
rset = sample(c(0L,1L), size = nf, replace = TRUE)

# Prepare binary sets:
lbin = shiftrPrepareLeft(lset)
rbin = shiftrPrepareRight(rset)

### Check object sizes
# Notice asymetry in binary object sizes

object.size(lset)
object.size(rset)
object.size(lbin)
object.size(rbin)
</code></pre>

<hr>
<h2 id='simulate'>
Generate Artificial Data for Tests and Illustrations
</h2><span id='topic+simulateNumeric'></span><span id='topic+simulateBinary'></span><span id='topic+simulatePValues'></span>

<h3>Description</h3>

<p>These functions generate two artificial data sets
with local dependence of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateNumeric(n, corWithin, corAcross = 0)
simulateBinary(n, corWithin, corAcross = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_n">n</code></td>
<td>

<p>Total number of elements in each data set.
</p>
</td></tr>
<tr><td><code id="simulate_+3A_corwithin">corWithin</code></td>
<td>

<p>Correlation of adjacent observations within each data set.
</p>
</td></tr>
<tr><td><code id="simulate_+3A_coracross">corAcross</code></td>
<td>

<p>Correlation of observations across data sets.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the Cramer's V coefficient.
</p>


<h3>Note</h3>

<p>The <code>simulateNumeric</code> function generates two data sets with elements
having standard normal distribution. 
</p>
<p>The <code>simulateBinary</code> function generates data sets with 0/1 values
by thresholding the numeric data sets from <code>simulateNumeric</code>.
</p>
<p>The <code>simulatePValues</code> function generates data sets of p-values
by applying <code><a href="stats.html#topic+Normal">pnorm</a></code> to the data sets 
from <code>simulateNumeric</code>.
</p>


<h3>Author(s)</h3>

<p>Andrey A Shabalin <a href="mailto:andrey.shabalin@gmail.com">andrey.shabalin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100000
sim = simulateNumeric(n, 0.5, 0.3)

# Means should be close to 0 (zero)
mean(sim$data1)
mean(sim$data2)

# Variances should be close to 1
var(sim$data1)
var(sim$data2)

# Correlation of adjacent observations
# should be close to 0.5
cor(sim$data1[-1], sim$data1[-n])
cor(sim$data2[-1], sim$data2[-n])

# Correlation between data sets 
# should be close to 0.3
cor(sim$data1, sim$data2)
</code></pre>

<hr>
<h2 id='singlePermutation'>
Count Feature Overlap Under a Permutation
</h2><span id='topic+singlePermutation'></span>

<h3>Description</h3>

<p>This function performs fast feature overlap 
count under a circular permutation.
The input data sets must be preprocessed with 
<code><a href="#topic+shiftrPrepareLeft">shiftrPrepareLeft</a></code> and <code><a href="#topic+shiftrPrepareRight">shiftrPrepareRight</a></code> 
functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>singlePermutation(left, right, offset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singlePermutation_+3A_left">left</code></td>
<td>

<p>Feature set prepared with <code><a href="#topic+shiftrPrepareLeft">shiftrPrepareLeft</a></code> function.
</p>
</td></tr>
<tr><td><code id="singlePermutation_+3A_right">right</code></td>
<td>

<p>Feature set prepared with <code><a href="#topic+shiftrPrepareRight">shiftrPrepareRight</a></code> function.
</p>
</td></tr>
<tr><td><code id="singlePermutation_+3A_offset">offset</code></td>
<td>

<p>Offset of one feature set relative to another. 
See the example below for clarity. <br />
Zero indicate no offset, i.e. simply count feature overlap.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns count of feature overlap under a circular permutation.
</p>


<h3>Author(s)</h3>

<p>Andrey A Shabalin <a href="mailto:andrey.shabalin@gmail.com">andrey.shabalin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Number of features
nf = 1e6

### Generate left and right sets
lset = sample(c(0L,1L), size = nf, replace = TRUE)
rset = sample(c(0L,1L), size = nf, replace = TRUE) | lset

# Prepare binary sets:
lbin = shiftrPrepareLeft(lset)
rbin = shiftrPrepareRight(rset)

### count feature overlap
# R calculations
overlapS = sum(lset &amp; rset)
# Binary calculations
overlapF = singlePermutation(lbin, rbin, 0)

message("Feature overlap: ",
        overlapS, " / ", overlapF,
        " (slow/fast count)")
stopifnot( overlapS == overlapF )


### Count overlap with offset
offset = 2017
# R calculations
overlapOS = sum(lset[ c((offset+1):nf, 1:offset)] &amp; rset)
# Binary calculations
overlapOF = singlePermutation(lbin, rbin, offset)

message("Feature overlap at offset: ",
        overlapOS, " / ", overlapOF,
        " (slow/fast count)")
stopifnot( overlapOS == overlapOF )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
