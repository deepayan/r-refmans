<!DOCTYPE html><html><head><title>Help for package chouca</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {chouca}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.camodel_initmat'><p>Convert a matrix to a CA model landscape</p></a></li>
<li><a href='#ca_library'><p>Library of stochastic cellular automata</p></a></li>
<li><a href='#camodel'><p>Definition of a stochastic cellular automaton</p></a></li>
<li><a href='#chouca'><p>chouca: a package for stochastic cellular automata</p></a></li>
<li><a href='#generate_initmat'><p>Generate an initial matrix for a <code>chouca</code> model</p></a></li>
<li><a href='#landscape_plotter'><p>Plot simulation landscapes</p></a></li>
<li><a href='#run_camodel'><p>Run a cellular automata</p></a></li>
<li><a href='#run_meanfield'><p>Mean field model</p></a></li>
<li><a href='#trace_plotter'><p>Plot simulation covers</p></a></li>
<li><a href='#update.ca_model'><p>Update a cellular automaton</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Stochastic Cellular Automaton Engine</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.99</td>
</tr>
<tr>
<td>Description:</td>
<td>An engine for stochastic cellular automata. It provides a high-level
  interface to declare a model, which can then be simulated by various backends
  (Genin et al. (2023) &lt;<a href="https://doi.org/10.1101%2F2023.11.08.566206">doi:10.1101/2023.11.08.566206</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, plyr, digest, stats, graphics, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 3.0.0), deSolve, igraph, knitr, rmarkdown,
ggplot2, spatialwarnings</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexgenin/chouca">https://github.com/alexgenin/chouca</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexgenin/chouca/issues">https://github.com/alexgenin/chouca/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 20:04:19 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexandre Genin <a href="https://orcid.org/0000-0002-3333-1338"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Guillaume Dupont [aut],
  Daniel Valencia [aut],
  Mauro Zucconi [aut],
  M. Isidora Ávila-Thieme [aut],
  Sergio A. Navarrete [aut],
  Evie A. Wieters [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexandre Genin &lt;a.a.h.genin@uu.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.camodel_initmat'>Convert a matrix to a CA model landscape</h2><span id='topic+as.camodel_initmat'></span>

<h3>Description</h3>

<p>Convert a matrix to a CA model landscape for later use with
<a href="#topic+run_camodel">run_camodel</a> or <a href="#topic+run_meanfield">run_meanfield</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.camodel_initmat(m, levels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.camodel_initmat_+3A_m">m</code></td>
<td>
<p>The input matrix (numeric, character or factor)</p>
</td></tr>
<tr><td><code id="as.camodel_initmat_+3A_levels">levels</code></td>
<td>
<p>The levels to use in the resulting landscape. If <code>NULL</code>, the unique
values of the input matrix are used as levels. Set this manually if you want the
resulting landscape to have extra levels that are not present in the original matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix containing values as factors, with levels
corresponding to the <code>levels</code> argument. This matrix has the
<code><a href="base.html#topic+class">class</a></code> <code>camodel_initmat</code> so that it can be displayed with the
<code>image</code> generic function and works well with CA-related functions 
(such as <code><a href="#topic+run_camodel">run_camodel</a></code>).
</p>


<h3>See Also</h3>

<p>generate_initmat, run_camodel, run_meanfield
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple conversion of a matrix with regular patterns
x &lt;- seq(0, 2 * pi, l = 256)
z &lt;- outer(x, x, function(x, y) as.numeric(sin(10*x) + cos(10*y) &gt; 0.8))
mat &lt;- as.camodel_initmat(z)
summary(mat)
image(mat)

# This is a character matrix. We need to convert it to use it as input to
# run_camodel()
size &lt;- 64
m &lt;- matrix(ifelse(runif(size^2) &lt; .5, "TREE", "EMPTY"), nrow = size, ncol = size)
m &lt;- as.camodel_initmat(m)
summary(m) # this is a landscape object
image(m)

# Start a simulation using this matrix
mod &lt;- ca_library("forestgap")
out &lt;- run_camodel(mod, m, seq(0, 256))
plot(out)


# Run a glider in the game of life
mod &lt;- ca_library("gameoflife")
init &lt;- matrix(c(0, 0, 1, 0, 0, 0, 0,
                 0, 0, 0, 1, 0, 0, 0,
                 0, 1, 1, 1, 0, 0, 0,
                 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0, 0, 0, 0),
                nrow = 6, ncol = 7, byrow = TRUE)
init[] &lt;- ifelse(init == 1, "LIVE", "DEAD")
# image() does not work on init here without conversion by as.camodel_initmat
init &lt;- as.camodel_initmat(init)
image(init)

# Run the model and display simulation output as it is running
ctrl &lt;- list(custom_output_fun = landscape_plotter(mod, fps_cap = 5),
             custom_output_every = 1)
out &lt;- run_camodel(mod, init, times = seq(0, 32), control = ctrl)


</code></pre>

<hr>
<h2 id='ca_library'>Library of stochastic cellular automata</h2><span id='topic+ca_library'></span>

<h3>Description</h3>

<p>Get one of the SCA models included in <code>chouca</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ca_library(model, parms = NULL, neighbors = NULL, wrap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ca_library_+3A_model">model</code></td>
<td>
<p>The model to return, as a string. See Details for the full list of models
included with <code>chouca</code>.</p>
</td></tr>
<tr><td><code id="ca_library_+3A_parms">parms</code></td>
<td>
<p>The model parameters to use, as a named list. If unset, the model default
parameters will be used.</p>
</td></tr>
<tr><td><code id="ca_library_+3A_neighbors">neighbors</code></td>
<td>
<p>The number of neighbors to use in the cellular automaton (4 for 4-way
or von-Neumann neghborhood, or 8 for a Moore neighborhood). If unset, the model
default neighborhood will be used.</p>
</td></tr>
<tr><td><code id="ca_library_+3A_wrap">wrap</code></td>
<td>
<p>Whether the 2D grid should wrap around at the edges. Default it to wrap
around the edges of the landscape.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives access to different stochastic cellular automata models. You
can provide a named list of parameters, or set the number of neighbor or wrapping
options, but default are chosen if left unspecified. This function provides
the following models (the string represents the name of the model, as passed
using the 'model' argument):
</p>

<ol>
<li> <p><code>"forestgap"</code> Kubo's forest gap model (1996), which describes how
gaps form in a forest and expand through disturbances.
</p>
</li>
<li> <p><code>"musselbed"</code> A model of mussel beds, in which disturbance by waves
occurs at the edge of mussel patches (Guichard et al. 2003)
</p>
</li>
<li> <p><code>"aridvege"</code> A model of arid vegetation, in which facilitation between
neighboring plants occur, along with grazing. The original model is to be
found in Kéfi et al. (2007), with extensions in Schneider et al. (2016)
</p>
</li>
<li> <p><code>"aridvege-danet"</code> An extension of the previous model to two species
with assymetric facilitation (Danet et al. 2021)
</p>
</li>
<li> <p><code>"coralreef"</code> A model of coral reef with local feedbacks of corals and
macroalgae (Génin, in prep)
</p>
</li>
<li> <p><code>"gameoflife"</code> The famous Game of Life by Conway, a deterministic
model.
</p>
</li>
<li> <p><code>"rockpaperscissor"</code> A rock-paper-scissor model with three states, in
which a cell changes state depending on its neighbors according the game rules
(e.g. &quot;rock beats scissors&quot;). This deterministic model produces nice spirals.
</p>
</li></ol>



<h3>Value</h3>

<p>This function returns a <code><a href="base.html#topic+list">list</a></code> object with class <code>ca_model</code>, with 
the following named components. Please note that most are for internal use and may 
change with package updates. 
</p>

<dl>
<dt><code>transitions</code></dt><dd><p>the list of transitions of the model, as returned 
by <code><a href="#topic+transition">transition</a></code> </p>
</dd>
<dt><code>nstates</code></dt><dd><p>the number of states of the model</p>
</dd>
<dt><code>parms</code></dt><dd><p>the parameter values used for the model</p>
</dd>
<dt><code>beta_0</code>,<code>beta_q</code>, <code>beta_pp</code>, <code>beta_pq</code>, <code>beta_qq</code></dt><dd> 
<p>internal tables used to represent probabilities of transitions when running
simulations, these tables are for internal use and probably not interesting for 
end users, but more information is provided in the package source code</p>
</dd>
<dt><code>wrap</code></dt><dd><p>Whether the model uses a toric space that wraps around the edge</p>
</dd>
<dt><code>neighbors</code></dt><dd><p>The type of neighborhood (4 or 8)</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>The <code>epsilon</code> values used in the model definition, below 
which transition probabilities are assumed to be zero</p>
</dd>
<dt><code>xpoints</code></dt><dd><p>(for internal use only) The number of values used to 
represent the proportion of neighbors of a cell in each state</p>
</dd>
<dt><code>max_error</code>, <code>max_rel_error</code></dt><dd><p>vector of numeric values containing 
the maximum error and maximum relative error on each transition probability</p>
</dd>
<dt><code>fixed_neighborhood</code></dt><dd><p>flag equal to <code>TRUE</code> when cells have
a fixed number of neighbors</p>
</dd>
</dl>



<h3>References</h3>

<p>Danet, Alain, Florian Dirk Schneider, Fabien Anthelme, and Sonia Kéfi. 2021.
&quot;Indirect Facilitation Drives Species Composition and Stability in Drylands.&quot;
Theoretical Ecology 14 (2): 189–203. <a href="https://doi.org/10.1007/s12080-020-00489-0">doi:10.1007/s12080-020-00489-0</a>.
</p>
<p>Genin, A., S. A. Navarrete, A. Garcia-Mayor, and E. A. Wieters. in
press (2023). Emergent spatial patterns can indicate upcoming regime
shifts in a realistic model of coral community. The American Naturalist.
</p>
<p>Guichard, F., Halpin, P.M., Allison, G.W., Lubchenco, J. &amp; Menge, B.A. (2003). Mussel
disturbance dynamics: signatures of oceanographic forcing from local interactions.
The American Naturalist, 161, 889–904. <a href="https://doi.org/10.1086/375300">doi:10.1086/375300</a>
</p>
<p>Kefi, Sonia, Max Rietkerk, Concepción L. Alados, Yolanda Pueyo, Vasilios P.
Papanastasis, Ahmed ElAich, and Peter C. de Ruiter. 2007. &quot;Spatial Vegetation
Patterns and Imminent Desertification in Mediterranean Arid Ecosystems.&quot;
Nature 449 (7159): 213–17. <a href="https://doi.org/10.1038/nature06111">doi:10.1038/nature06111</a>.
</p>
<p>Kubo, Takuya, Yoh Iwasa, and Naoki Furumoto. 1996. &quot;Forest Spatial Dynamics with Gap
Expansion: Total Gap Area and Gap Size Distribution.&quot; Journal of Theoretical Biology
180 (3): 229–46.
</p>
<p>Schneider, Florian D., and Sonia Kefi. 2016. &quot;Spatially Heterogeneous Pressure Raises
Risk of Catastrophic Shifts.&quot; Theoretical Ecology 9 (2): 207-17.
<a href="https://doi.org/10.1007/s12080-015-0289-1">doi:10.1007/s12080-015-0289-1</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Import a model, create an initial landscape and run it for ten iterations
forestgap_model &lt;- ca_library("forestgap")
im &lt;- generate_initmat(forestgap_model, c(0.5, 0.5), nrow = 64, ncol = 100)
run_camodel(forestgap_model, im, times = seq(0,100))

</code></pre>

<hr>
<h2 id='camodel'>Definition of a stochastic cellular automaton</h2><span id='topic+camodel'></span><span id='topic+transition'></span>

<h3>Description</h3>

<p>High-level definition of a stochastic cellular automaton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>camodel(
  ...,
  neighbors,
  wrap,
  parms = list(),
  all_states = NULL,
  check_model = "quick",
  verbose = FALSE,
  epsilon = sqrt(.Machine[["double.eps"]]),
  fixed_neighborhood = FALSE
)

transition(from, to, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="camodel_+3A_...">...</code></td>
<td>
<p>A number of transition descriptions, as built by the
<code><a href="#topic+transition">transition</a></code> function (see Details and Examples)</p>
</td></tr>
<tr><td><code id="camodel_+3A_neighbors">neighbors</code></td>
<td>
<p>The number of neighbors to use in the cellular automaton (4 for 4-way
or von-Neumann neigborhood, or 8 for an 8-way or Moore neighborhood)</p>
</td></tr>
<tr><td><code id="camodel_+3A_wrap">wrap</code></td>
<td>
<p>If <code>TRUE</code>, then the 2D grid on which the model is run wraps around
at the edges (the top/leftmost cells will be considered neighbors of the
bottom/rightmost cells)</p>
</td></tr>
<tr><td><code id="camodel_+3A_parms">parms</code></td>
<td>
<p>A named list of parameters, which should be all numeric, single values</p>
</td></tr>
<tr><td><code id="camodel_+3A_all_states">all_states</code></td>
<td>
<p>The complete set of states of the model (a character vector). If
unspecified, it will be guessed from the transition rules, but it is a good idea
to pass it here to make sure the model definition is correct.</p>
</td></tr>
<tr><td><code id="camodel_+3A_check_model">check_model</code></td>
<td>
<p>A check of the model definition is done to make sure there
are no issues with it (e.g. probabilities outside the [0,1] interval, or an
unsupported model definition). A quick check that should catch most problems is
performed if check_model is &quot;quick&quot;, an extensive check that tests all possible
neighborhood configurations is done with &quot;full&quot;, and no check is performed with
&quot;none&quot;.</p>
</td></tr>
<tr><td><code id="camodel_+3A_verbose">verbose</code></td>
<td>
<p>Whether information should be printed when parsing the model
definition.</p>
</td></tr>
<tr><td><code id="camodel_+3A_epsilon">epsilon</code></td>
<td>
<p>A small value under which the internal model coefficients values are
considered to be equal to zero. The default value should work well here, except
if you run models that have extremely small transition probabilities (&lt;1e-8).</p>
</td></tr>
<tr><td><code id="camodel_+3A_fixed_neighborhood">fixed_neighborhood</code></td>
<td>
<p>When not using wrapping around the edges 
(<code>wrap = FALSE</code>), the number of neighbors per cell is variable, which can 
slow down the simulation. Set this option to <code>TRUE</code> to consider that the number
of neighbors is always four or eight, regardless of the position of the cell in the
landscape, at the cost of approximate dynamics at the edges of the landscape.</p>
</td></tr>
<tr><td><code id="camodel_+3A_from">from</code></td>
<td>
<p>The state from which the transition is defined</p>
</td></tr>
<tr><td><code id="camodel_+3A_to">to</code></td>
<td>
<p>The state to which the transition is defined</p>
</td></tr>
<tr><td><code id="camodel_+3A_prob">prob</code></td>
<td>
<p>a one-sided formula describing the probability of transition between the two
states (see Details section for more information).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This help page describes in detail technical points related to the definition of 
models in <code>chouca</code>. If this is your first time working with <code>chouca</code>, 
you may like the longer introduction in the vignette, accessible using 
<code>vignette("chouca-package")</code>.
</p>
<p><code>camodel</code> allows defining a stochastic cellular automaton model by its set of
transition rules. These are defined by a set of calls to the <code>transition()</code>
function. Each of these calls defines the two states of the transition, and the
probability as a one-sided formula involving constants and the special vectors 
p and q.
</p>
<p><code>transition()</code> calls takes three arguments: the state from which the transition
is defined, the state to which the transition goes, and a transition probability,
defined as a one-sided formula. This formula can include numerical constants,
parameters defined in the named list <code>parms</code>, and any combination of
<code>p['a']</code> and <code>q['b']</code>, which respectively represent the proportion 
of cells in a landscape in state 'a', and the proportion of neighbors of a given cell
in state 'b' ('a', and 'b' being, of course, any of the possible states defined in the
model). Such formula could typically look like <code>~ 0.2 + 0.3 * p["a"] + q["b"]</code>. 
See below for examples of model definitions. 
</p>
<p>It is important to remember when using this function that <code>chouca</code> only
supports models where the probabilities depend on constant parameters, the global
proportion of each state in the landscape, and the local proportion of cells around
a given cell. In other words, all transition probabilities should have the following 
functional form: 
</p>
<p style="text-align: center;"><code class="reqn">a_0 + \sum_{k=1}^S g_k(q_k) + s(q, q) + s(p, q) + s(q, q)</code>
</p>

<p>where <code class="reqn">a_0</code> is a constant, <code class="reqn">g_k</code> are univariate functions of <code class="reqn">q_k</code>, 
the proportions of neighbors of a cell in state k, and <code class="reqn">q</code> is the vector 
containing all the <code class="reqn">q_k</code> for k between <code class="reqn">1</code> and <code class="reqn">S</code>, the total number of
states in the model. Similarly, <code class="reqn">p</code> is the length-<code class="reqn">S</code> vector containing the
proportion of cells in each state in the whole grid. <code class="reqn">s</code> above is the sum, defined 
for two vectors <code class="reqn">x = (x_1, ..., x_S)</code> and <code class="reqn">y = (y_1, ..., y_S)</code> as 
</p>
<p style="text-align: center;"><code class="reqn"> 
  a_1 x_1^{\alpha_1} y_1^{\beta_1} + 
  a_2 x_1^{\alpha_2} y_2^{\beta_2} + 
  a_3 x_1^{\alpha_3} y_3^{\beta_3} + 
  a_4 x_2^{\alpha_3} y_1^{\beta_3} + 
  a_4 x_2^{\alpha_3} y_2^{\beta_3} + 
  \dots + 
  a_K x_S^{\alpha_K} y_S^{\beta_K}
</code>
</p>

<p>where the <code class="reqn">a_k</code>, <code class="reqn">\alpha_k</code> and <code class="reqn">\beta_k</code> are constants for all <code class="reqn">k</code>, 
and <code class="reqn">K</code> is the total number of terms (equal to <code class="reqn">S^2</code>). Note that 
<code class="reqn">\alpha_K</code> and <code class="reqn">\beta_K</code> are capped to 5. This can be overriden using
<code>options(chouca.degmax = n)</code>, but we do not recommend changing it as higher 
values typically make the package slow and/or leads to numerical instabilities.
The functions <code class="reqn">g_k</code> above can be any univariate functions of <code class="reqn">q_k</code>, so
<code>chouca</code> effectively supports any type of transition rule involving the 
neighborhood of a cell, including some 'threshold' rules that involve a single state 
(and only one). For example, a rule such as &quot;more than
5 neighbors in a given state make a cell switch from state A to B&quot; is OK, but
combining states may not be supported, such as &quot;more than 5
neighbors in state A *and* 2 in state B means a cell switches from A to B&quot;. When in
doubt, just write your model, and <code>chouca</code> will tell you if it cannot run it
accurately by running model checks.
</p>
<p>Model checks are controlled by the argument <code>check_model</code>. When set to &quot;quick&quot; 
or &quot;full&quot;, a check is performed to make sure the functional form above is able to
accurately represent probabilities of transitions in the model, with &quot;full&quot; enabling
more extensive testing, and &quot;none&quot; removing it entirely. Coefficients in the formula 
above are rounded down to zero when below <code>epsilon</code>. This may be an issue if 
your transition probabilities are close to zero: consider reducing <code>epsilon</code> to 
a smaller value in this case, or adjusting your model parameters. 
</p>
<p>When space does not wrap around (<code>wrap = FALSE</code>), cells in the corners
or in the edges will have a lower number of neighbors. The proportions
of cells in a given state <code class="reqn">k</code>, <code class="reqn">q_k</code>, will thus be computed with a reduced
number of cells. For example, a cell in a corner will have only 2 neighbors
when using a 4x4 neighborhood, so <code class="reqn">q_k</code> is computed using only two cells, and 
can be only equal to 0, 0.5 or 1. 
</p>
<p>To run a model once it is defined, the function <code><a href="#topic+run_camodel">run_camodel</a></code> can be
used, or <code><a href="#topic+run_meanfield">run_meanfield</a></code> for a mean-field approximation. An initial
landscape for a simulation can be created using <code><a href="#topic+generate_initmat">generate_initmat</a></code>.
</p>
<p>You can update a model definition with new parameters (all of them or a subset)
using the <code><a href="#topic+update.ca_model">update</a></code> method. The model graph with the 
different states and transitions can be displayed using the <code>plot</code> method 
(this requires the package igraph).
</p>


<h3>Value</h3>

<p>This function returns a <code><a href="base.html#topic+list">list</a></code> object with class <code>ca_model</code>, with 
the following named components. Please note that most are for internal use and may 
change with package updates. 
</p>

<dl>
<dt><code>transitions</code></dt><dd><p>the list of transitions of the model, as returned 
by <code><a href="#topic+transition">transition</a></code> </p>
</dd>
<dt><code>nstates</code></dt><dd><p>the number of states of the model</p>
</dd>
<dt><code>parms</code></dt><dd><p>the parameter values used for the model</p>
</dd>
<dt><code>beta_0</code>,<code>beta_q</code>, <code>beta_pp</code>, <code>beta_pq</code>, <code>beta_qq</code></dt><dd> 
<p>internal tables used to represent probabilities of transitions when running
simulations, these tables are for internal use and probably not interesting for 
end users, but more information is provided in the package source code</p>
</dd>
<dt><code>wrap</code></dt><dd><p>Whether the model uses a toric space that wraps around the edge</p>
</dd>
<dt><code>neighbors</code></dt><dd><p>The type of neighborhood (4 or 8)</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>The <code>epsilon</code> values used in the model definition, below 
which transition probabilities are assumed to be zero</p>
</dd>
<dt><code>xpoints</code></dt><dd><p>(for internal use only) The number of values used to 
represent the proportion of neighbors of a cell in each state</p>
</dd>
<dt><code>max_error</code>, <code>max_rel_error</code></dt><dd><p>vector of numeric values containing 
the maximum error and maximum relative error on each transition probability</p>
</dd>
<dt><code>fixed_neighborhood</code></dt><dd><p>flag equal to <code>TRUE</code> when cells have
a fixed number of neighbors</p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>transition()</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p>run_camodel, run_meanfield, generate_initmat, run_meanfield,
update.ca_model, ca_library
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Redefine Kubo's 1996 forest gap model
kubo &lt;- camodel(
  transition(from = "TREE",
             to   = "EMPTY",
             prob = ~ d + delta * q["EMPTY"] ),
  transition(from = "EMPTY",
             to   = "TREE",
             prob = ~ alpha),
  parms = list(d = 0.125,
               delta = 0.5,
               alpha = 0.2),
  all_states = c("EMPTY", "TREE"),
  neighbors = 4,
  wrap = TRUE
)

# Display it as a graph
plot(kubo)

# A fun plant model
mod &lt;- camodel(
  transition("plant", "empty", ~ death * ( 1 - (2*q["plant"]-1)^2) ),
  transition("empty", "plant", ~ q["plant"]^2 ),
  all_states = c("empty", "plant"),
  wrap = TRUE,
  neighbors = 4,
  parms = list(death = 0.2496)
)


# Conway's Game of Life
mod &lt;- camodel(
  transition("LIVE", "DEAD", ~ q["LIVE"] &lt; (2/8) | q["LIVE"] &gt; (3/8)),
  transition("DEAD", "LIVE", ~ q["LIVE"] == (3/8)),
  wrap = TRUE,
  neighbors = 8,
  all_states = c("DEAD", "LIVE")
)

# A spiral-generating rock-paper-scissor model
mod &lt;- camodel(
  transition(from = "r", to = "p", ~ q["p"] &gt; 0.25 ),
  transition(from = "p", to = "c", ~ q["c"] &gt; 0.25 ),
  transition(from = "c", to = "r", ~ q["r"] &gt; 0.25 ),
  parms = list(prob = 1),
  wrap = TRUE,
  neighbors = 8
)

# Display the model as a graph
plot(mod)

# Running the above model (see also the help files for the relevant functions)
init &lt;- generate_initmat(mod, c(r = 1/3, p = 1/3, c = 1/3), nrow = 128)
out &lt;- run_camodel(mod, init, times = seq(0, 128))
plot(out)

# Update a model definition using update()
mod &lt;- camodel(
  transition("plant", "empty", ~ m),
  transition("empty", "plant", ~ r * q["plant"] * ( 1 - q["plant"] ) ),
  all_states = c("empty", "plant"),
  wrap = TRUE,
  neighbors = 4,
  parms = list(m = 0.35, r = 0.4)
)

mod_updated &lt;- update(mod, parms = list(m = 0.05, r = 1))
init &lt;- generate_initmat(mod_updated, c(plant = 0.8, empty = 0.2), nrow = 128)
out &lt;- run_camodel(mod_updated, init, times = seq(0, 128))
plot(out)
image(out)

# You can also specify only part of the parameters, the others will be
# kept to their original values
mod_updated &lt;- update(mod, parms = list(m = 0.035))

</code></pre>

<hr>
<h2 id='chouca'>chouca: a package for stochastic cellular automata</h2><span id='topic+chouca'></span>

<h3>Description</h3>

<p><code>chouca</code> is a package that can be used to implement and run stochastic
cellular automata (SCA). SCA are model that describe dynamics over a grid of cells.
Each cell can be in one of a set of states, and at each time step, can switch to
another one with a given transition probabilities. These transitions probabilities
typically depend on the neighborhood of a focal cell.
</p>
<p>The <code>chouca</code> package is able to simulate SCA models efficiently, including
by emitting and compiling the required C++ code at runtime. It does not support all
cellular automata, but typically only those where transition probabilities only depend
on (1) constant parameters, (2) the proportion of cells in a given state in the
landscape, and (3) the proportion of neighboring cells in a given state. More
information on the types of supported model can be found in our publication, but in
any case <code>chouca</code> is able to identify and warn you if your model is unsupported.
</p>
<p>The package workflow has typically four steps (1) define the
model, (2) create an initial landscape (grid of cells), (3) run the model, and
(4) display/extract the results. We describe each step below, and give examples at the
end of this document. A more complete description of the workflow and the package 
is available in the vignette <code>vignette("chouca-package", package = "chouca")</code>.
</p>
<p>(1) Model definition
</p>
<p>Models can be defined using the <code><a href="#topic+camodel">camodel</a></code> function. A typical call
would be something looking like this, for a simple model of plants growing over
space:
</p>
<pre>
   mod &lt;- camodel(
     transition(from = "bare", to = "plant", ~ r1 * p["plant"] + r2 * q["plant"]),
     transition(from = "plant", to = "bare", ~ m),
     parms = list(r1 = 0.1, r2 = 0.1, m = 0.05),
     wrap = TRUE,
     neighbors = 8
   )
   </pre>
<p>This model defines two transitions (between the &quot;bare&quot; and the
&quot;plant&quot; state and vice versa). These transitions are defined using the
transition() function, which arguments define where the transition
goes from, to, and an expression on how to compute its probability. In this model,
the probability that the first transition occurs depends on the proportion of
&quot;plant&quot; cells in the landscape, <code>p["plant"]</code>, and the proportion of neighbors
in the &quot;plant&quot; state, <code>q["plant"]</code>. The model has three parameters,
<code>r1</code>, <code>r2</code> and <code>m</code> whose value is passed through the named list 
<code>parms</code>. The <code>neighbors</code> argument defines the type of neighborhood 
(here 8-way, or Moore neighborhood), and we specify that the model should run over 
a toric space that wraps around the edges of the grid (<code>wrap = TRUE</code>).
</p>
<p>More information about the creation of models is available at <code><a href="#topic+camodel">camodel</a></code>.
</p>
<p>(2) Creation of the initial landscape
</p>
<p>An initial grid of cell (or landscape) can be created using
<code><a href="#topic+generate_initmat">generate_initmat</a></code>, which will fill a grid with the states provided
by a model object created using <code><a href="#topic+camodel">camodel</a></code> above, and respecting the
specified proportions:
</p>
<p><code>
   init_grid &lt;- generate_initmat(mod, c(bare = 0.4, plant = 0.6),
                                 nrow = 128, ncol = 90)
   </code>
</p>
<p>Here, we create a 128x90 rectangular grid that contains 40
distributed randomly through space.
</p>
<p>If you already have a specific grid of cells (as an R <a href="base.html#topic+matrix">matrix</a>)
you would like to use, we recommend to process it first through
<code><a href="#topic+as.camodel_initmat">as.camodel_initmat</a></code> so it will play nicely with the rest of the package
functions.
</p>
<p>(3) Running the model
</p>
<p>You can feed the model and the initial landscape to <code><a href="#topic+run_camodel">run_camodel</a></code>,
which will run the model and output the results at the time step specified by
the <code>times</code> argument:
</p>
<p><code>
     out &lt;- run_camodel(mod, init_grid, times = seq(0, 1024))
   </code>
</p>
<p><code><a href="#topic+run_camodel">run_camodel</a></code> has many options to control how the simulation is run
and the model outputs are saved, and are documented in the function help page.
</p>
<p>(4) Extracting results
</p>
<p>The results of the simulation run can be extracted from the resulting object
using the '[[' operators, typically using <code>out[["output"]][["covers"]]</code>
or <code>out[["output"]][["snapshots"]]</code> to extract the global proportions of
cells in each state and the landscapes, respectively. These data can then be used
for further analyses. Standard methods can be used to display the results (e.g.
<code>plot()</code> or <code>image()</code>).
</p>
<p>Each step of this workflow can be adjusted as necessary, either to display the results
as the simulation is run (see e.g. <code><a href="#topic+landscape_plotter">landscape_plotter</a></code>), or use different
simulation backends (see options in <code><a href="#topic+run_camodel">run_camodel</a></code>). You can also run the
equivalent mean-field model of the SCA using <code><a href="#topic+run_meanfield">run_meanfield</a></code>, which
assumes that local and global proportion of states are equal.
</p>
<p><code>chouca</code> comes with a set of pre-implemented models, which you can access using
<code><a href="#topic+ca_library">ca_library</a></code>.
</p>
<p>If you use and like <code>chouca</code>, we would appreciate you to cite our corresponding
publication:
</p>
<p>Genin A, Dupont G, Valencia D, Zucconi M, Avila-Thieme M, Navarrete
S, Wieters E (2023). &quot;Easy, fast and reproducible Stochastic Cellular
Automata with 'chouca'.&quot; <a href="https://doi.org/10.1101/2023.11.08.566206">doi:10.1101/2023.11.08.566206</a>
</p>


<h3>See Also</h3>

<p>camodel, generate_initmat, run_camodel, run_meanfield, ca_library
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The above example in full
mod &lt;- camodel(
  transition(from = "bare", to = "plant", ~ r1 * p["plant"] + r2 * q["plant"]),
  transition(from = "plant", to = "bare", ~ m),
  parms = list(r1 = 0.1, r2 = 0.1, m = 0.05),
  wrap = TRUE,
  neighbors = 8
)

# Display the structure of the model
plot(mod)

init_grid &lt;- generate_initmat(mod, c(bare = 0.4, plant = 0.6),
                              nrow = 128, ncol = 90)
out &lt;- run_camodel(mod, init_grid, times = seq(0, 128))

# Display results
plot(out)
image(out)

# Run the meanfield model (uses deSolve internally)
if ( requireNamespace("deSolve", quietly = TRUE) ) {
  out &lt;- run_meanfield(mod, init_grid, times = seq(0, 1024))
  plot(out)
}

</code></pre>

<hr>
<h2 id='generate_initmat'>Generate an initial matrix for a <code>chouca</code> model</h2><span id='topic+generate_initmat'></span>

<h3>Description</h3>

<p>Helper function to create a spatially-random initial landscape (matrix)
with specified covers for a cellular automaton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_initmat(mod, pvec, nrow, ncol = nrow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_initmat_+3A_mod">mod</code></td>
<td>
<p>A stochastic cellular automaton model created by <code><a href="#topic+camodel">camodel</a></code></p>
</td></tr>
<tr><td><code id="generate_initmat_+3A_pvec">pvec</code></td>
<td>
<p>A numeric vector of covers for each state in the initial configuration,
possibly with named elements.</p>
</td></tr>
<tr><td><code id="generate_initmat_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows of the output matrix</p>
</td></tr>
<tr><td><code id="generate_initmat_+3A_ncol">ncol</code></td>
<td>
<p>The number of columns of the output matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a helper to build a starting configuration (matrix) for a
stochastic cellular automaton based on the definition of the model and the
specified starting covers (in <code>pvec</code>). It will produce a landscape with
expected global cover of each state equal to the covers in <code>pvec</code>, and a
completely random spatial structure.
</p>
<p>The length of the <code>pvec</code> vector must match the number of possible cell states
in the model. If present, the names of <code>pvec</code> must match the states
defined in the model. In this case, they will be used to determine which state
gets which starting cover instead of the order of the values.
</p>
<p>The <code>pvec</code> will be normalized to sum to one, and the function will produce a
warning if this produces a meaningful change in covers.
</p>
<p>If you already have a matrix you want to use as a starting configuration, we
recommend you to use <code><a href="#topic+as.camodel_initmat">as.camodel_initmat</a></code> to convert it to an
object that <code><a href="#topic+run_camodel">run_camodel</a></code> can use.
</p>


<h3>Value</h3>

<p>This function returns a matrix containing values as factors, with levels
corresponding to the model states (defined in the <code>mod</code> argument) and
dimensions set by <code>nrow</code> and <code>ncol</code>. This matrix has the
<code><a href="base.html#topic+class">class</a></code> <code>camodel_initmat</code> so that it can be displayed with the
<code>image</code> generic function.
</p>


<h3>See Also</h3>

<p>as.camodel_initmat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run the Game of Life starting from a random grid
game_of_life &lt;- ca_library("gameoflife")
grid &lt;- generate_initmat(game_of_life, c(LIVE = .1, DEAD = .9), nrow = 64)
out &lt;- run_camodel(game_of_life, grid, times = seq(0, 128))
image(out) # final configuration

# Logistic growth of plants
mod &lt;- camodel(
  transition(from = "empty", to = "plant", ~ r * p["plant"]),
  transition(from = "plant", to = "empty", ~ m),
  parms = list(r = 1, m = .03),
  wrap = TRUE,
  neighbors = 8
)
grid &lt;- generate_initmat(mod, c(empty = .99, plant = .01), nrow = 128)
image(grid) # initial state
out &lt;- run_camodel(mod, grid, times = seq(0, 30))
image(out) # final state
plot(out) #

</code></pre>

<hr>
<h2 id='landscape_plotter'>Plot simulation landscapes</h2><span id='topic+landscape_plotter'></span>

<h3>Description</h3>

<p>This function creates an internal function to plot the model
landscape during the simulation of a stochastic cellular automaton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscape_plotter(
  mod,
  col = NULL,
  fps_cap = 24,
  burn_in = 0,
  transpose = TRUE,
  new_window = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landscape_plotter_+3A_mod">mod</code></td>
<td>
<p>The model being used (created by <code>link{camodel}</code>)</p>
</td></tr>
<tr><td><code id="landscape_plotter_+3A_col">col</code></td>
<td>
<p>a set of colors (character vector) of length equal to the number of
states in the model.</p>
</td></tr>
<tr><td><code id="landscape_plotter_+3A_fps_cap">fps_cap</code></td>
<td>
<p>The maximum number of frame displayed per seconds. Simulation
will be slowed down if necessary so that plot updates will not be
more frequent than this value</p>
</td></tr>
<tr><td><code id="landscape_plotter_+3A_burn_in">burn_in</code></td>
<td>
<p>Do not display anything before this time step has been
reached</p>
</td></tr>
<tr><td><code id="landscape_plotter_+3A_transpose">transpose</code></td>
<td>
<p>Set to <code>TRUE</code> to transpose the landscape matrix
before displaying it <code><a href="graphics.html#topic+image">image</a></code></p>
</td></tr>
<tr><td><code id="landscape_plotter_+3A_new_window">new_window</code></td>
<td>
<p>Controls whether the plots are displayed in a new window,
or in the default device (typically the plot panel in Rstudio)</p>
</td></tr>
<tr><td><code id="landscape_plotter_+3A_...">...</code></td>
<td>
<p>other arguments are passed to <code><a href="graphics.html#topic+image">image</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates another function that is suitable for use with
<code><a href="#topic+run_camodel">run_camodel</a></code>. It allows plotting the landscape as it is being
simulated, using the base function <code><a href="graphics.html#topic+image">image</a></code>. You can set
colors using the argument <code>col</code>, or tranpose the landscape before
plotting using <code>transpose</code>. The resulting function must by passed to
<code><a href="#topic+run_camodel">run_camodel</a></code> as the control argument <code>custom_output_fun</code>.
Typically, this function is not used by itself, but is being used when
specifying simulation options before calling <code><a href="#topic+run_camodel">run_camodel</a></code>,
see examples below.
</p>
<p><code><a href="graphics.html#topic+image">image</a></code> is used internally, and tends to be quite slow at
displaying results, but if it is still too fast for your taste, you can cap the
refresh rate at a value given by the argument <code>fps_cap</code>.
</p>
<p>It is important to note that this function will probably massively slow
down a simulation, so this is most useful for exploratory analyses.
</p>


<h3>Value</h3>

<p>This function returns another function, which will be called internally 
when simulating the model using <code><a href="#topic+run_camodel">run_camodel</a></code>, and has probably 
not much use outside of this context. The return function will display the 
simulation and returns NULL.
</p>


<h3>See Also</h3>

<p>trace_plotter, run_camodel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Display the psychedelic spirals of the rock-paper-scissor model as the model is
# being run
mod &lt;- ca_library("rock-paper-scissor")
colors &lt;- c("#fb8500", "#023047", "#8ecae6")
ctrl &lt;- list(custom_output_every = 1,
             custom_output_fun = landscape_plotter(mod, col = colors))
init &lt;- generate_initmat(mod, rep(1, 3)/3, nrow = 100, ncol = 178)
run_camodel(mod, init, times = seq(0, 128), control = ctrl)

# Arid vegetation model
mod &lt;- ca_library("aridvege")
init &lt;- generate_initmat(mod, rep(1, 3)/3, nrow = 100, ncol = 178)
colors &lt;- c("gray80", "white", "darkgreen")
ctrl &lt;- list(custom_output_every = 1,
             custom_output_fun = landscape_plotter(mod, col = colors, xaxt = "n",
                                                   yaxt = "n"))
run_camodel(mod, init, times = seq(0, 128), control = ctrl)

# Game of life, set plot margins to zero so that the landscape takes all
# of the plot window
mod &lt;- ca_library("gameoflife")
init &lt;- generate_initmat(mod, c(0.5, 0.5), nrow = 100, ncol = 178)
colors &lt;- c("white", "black")
ctrl &lt;- list(custom_output_every = 1,
             custom_output_fun = landscape_plotter(mod, col = colors,
                                                   mar = c(0, 0, 0, 0)))
run_camodel(mod, init, times = seq(0, 128), control = ctrl)



</code></pre>

<hr>
<h2 id='run_camodel'>Run a cellular automata</h2><span id='topic+run_camodel'></span>

<h3>Description</h3>

<p>Run a pre-defined stochastic cellular automaton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_camodel(mod, initmat, times, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_camodel_+3A_mod">mod</code></td>
<td>
<p>A stochastic cellular automaton model defined using <code><a href="#topic+camodel">camodel</a></code></p>
</td></tr>
<tr><td><code id="run_camodel_+3A_initmat">initmat</code></td>
<td>
<p>An initial matrix to use for the simulation, possibly created using
<code><a href="#topic+generate_initmat">generate_initmat</a></code></p>
</td></tr>
<tr><td><code id="run_camodel_+3A_times">times</code></td>
<td>
<p>A numeric vector describing the time sequence for which output is
wanted. Time will always start at zero but output will only be saved at the time
steps specified in this vector.</p>
</td></tr>
<tr><td><code id="run_camodel_+3A_control">control</code></td>
<td>
<p>a named list with settings to alter the way the simulation is run (see
full list of settings in 'Details' section)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>run_camodel()</code> is the workhorse function to run cellular automata. It runs the
simulation and outputs the results at the time steps specified by the <code>times</code>
argument, starting from the initial landscape <code>initmat</code> (a matrix typically
created by <code><a href="#topic+generate_initmat">generate_initmat</a></code>).
</p>
<p>Note that the simulation is run for all time steps, but output is only
provided for the time steps specified in <code>times</code>.
</p>
<p>The <code>control</code> list must have named elements, and allows altering the
way the simulation is run, including the live display of covers or
landscapes (see <code><a href="#topic+trace_plotter">trace_plotter</a></code> or
<code><a href="#topic+landscape_plotter">landscape_plotter</a></code>).
</p>
<p>Possible options are the following:
</p>

<ol>
<li> <p><code>save_covers_every</code> By default, global covers are saved for each time step
specified in <code>times</code>. Setting this argument to values higher than one will
skip some time steps (thinning). For example, setting it to 2 will make
<code>run_camodel</code> save covers only every two values specified in <code>times</code>.
Set to 0 to skip saving covers. This value must be an integer.
</p>
</li>
<li> <p><code>save_snapshots_every</code> In the same way as covers, landscape snapshots
can be saved every set number of values in <code>times</code>. By default, only the
initial and final landscape are saved. Set to one to save the landscape for each
value specified in <code>times</code>. Higher values will skip elements in <code>times</code>
by the set number. Set to zero to turn off the saving of snapshots. This
value must be an integer.
</p>
</li>
<li> <p><code>console_output_every</code> Set the number of iterations between which
progress report is printed on the console. Set to zero to turn off progress
report. The default option is to print progress five times during the simulation.
</p>
</li>
<li> <p><code>custom_output_fun</code> A custom function can be passed using this
argument to compute something on the landscape as the simulation is being run.
This function can return anything, but needs to take two arguments, the first
one being the current time in the simulation (single numeric value), and the
other one the current landscape (a matrix). This can be used to plot the
simulation results as it is being run, see <code><a href="#topic+landscape_plotter">landscape_plotter</a></code> and
<code><a href="#topic+trace_plotter">trace_plotter</a></code> for such use case.
</p>
</li>
<li> <p><code>custom_output_every</code> If <code>custom_output_fun</code> is specified, then
it will be called for every time step specified in the <code>times</code> vector.
Increase this value to skip some time points, in a similar way to covers
and snapshots above.
</p>
</li>
<li> <p><code>substeps</code> Stochastic CA can run into issues where the probabilities
of transitions are above one. A possible solution to this is to run the model
in 'substeps', i.e. an iteration is divided in several substeps, and
the substeps are run subsequently with probabilities divided by this amount. For
example, a model run with 4 substeps means that each iteration will be divided
in 4 'sub-iterations', and probabilities of transitions are divided by 4 for
each of those sub-iterations.
</p>
</li>
<li> <p><code>engine</code> The engine used to run the simulations. Accepted values
are 'cpp' to use the C++ engine, or 'compiled', to emit and compile the model
code on the fly. Default is to use the C++ engine. Note that the 'compiled'
engine uses its own random number generator, and for this reason may produce
simulations that are different from the C++ engine (it does respect the R seed
however). You will need a compiler to use the 'compiled' engine, which
may require you to install
<a href="https://cran.r-project.org/bin/windows/Rtools/">Rtools</a> on Windows
systems.
</p>
</li>
<li> <p><code>precompute_probas</code> (Compiled engine only) Set to <code>TRUE</code> to
precompute probabilities of transitions for all possible combinations of
neighborhood. When working with a model with a low number of states
(typically 3 or 4), this can increase simulation speed dramatically.
By default, a heuristic is used to decide whether to enable
precomputation or not.
</p>
</li>
<li> <p><code>verbose_compilation</code> (Compiled engine only) Set to <code>TRUE</code> to print
Rcpp messages when compiling the model. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>force_compilation</code> (Compiled engine only) <code>chouca</code> has a
cache system to avoid recompiling similar models. Set this
argument to <code>TRUE</code> to force compilation every time the model is run.
</p>
</li>
<li> <p><code>write_source</code> (Compiled engine only) A file name to which
the C++ code used to run the model will be written (mostly for
debugging purposes).
</p>
</li>
<li> <p><code>cores</code> (Compiled engine only) The number of threads to use
to run the model. This provides a moderate speedup in most cases, and
is sometimes counter-productive on small landscapes. If you plan on
running multiple simulations, you are probably better off parallelizing
at a higher level. See also the 'Performance' section in the vignette, 
accessible using the command <code>vignette("chouca-package")</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A <code>ca_model_result</code> objects, which is a list with the following
components:
</p>

<ol>
<li> <p><code>model</code> The original model used for the model run (see 
return value of <code><a href="#topic+camodel">camodel</a></code> for more details about these objects).
</p>
</li>
<li> <p><code>initmat</code> The initial landscape (matrix) used for the model run, 
such as what is returned by <code><a href="#topic+generate_initmat">generate_initmat</a></code>. 
</p>
</li>
<li> <p><code>times</code> The time points vector at which output is saved
</p>
</li>
<li> <p><code>control</code> The control list used for the model run, containing the options
used for the run
</p>
</li>
<li> <p><code>output</code> A named list containing the simulation outputs. The 'covers'
component contains a matrix with the first column containing the time step, and the
other columns the proportions of cells in a given state. The 'snapshots' component
contains the landscapes recorded as matrices(<code>camodel_initmat</code> objects), with 
a 't' attribute indicating the corresponding time step of the model run. The 
'custom' component contains the results from calling a custom function provided 
as 'custom_output_fun' in the control list (see examples below).
</p>
</li></ol>



<h3>See Also</h3>

<p>camodel, generate_initmat, trace_plotter, landscape_plotter, run_meanfield
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run a model with default parameters
mod &lt;- ca_library("musselbed")
im  &lt;- generate_initmat(mod, c(0.4, 0.6, 0), nrow = 100, ncol = 50)
out &lt;- run_camodel(mod, im, times = seq(0, 100))
plot(out)

# Disable console output 
opts &lt;- list(console_output_every = 0) 
out &lt;- run_camodel(mod, im, times = seq(0, 100), control = opts)

# 



# Run the same model with the 'compiled' engine, and save snapshots. This
# requires a compiler on your computer (typically available by installing
# 'Rtools' on Windows)
ctrl &lt;- list(engine = "compiled", save_covers_every = 1, save_snapshots_every = 100)
run &lt;- run_camodel(mod, im, times = seq(0, 100), control = ctrl)
plot(run)

# 
oldpar &lt;- par(mfrow = c(1, 2))
image(run, snapshot_time = 0)
image(run, snapshot_time = 100)
par(oldpar)

# Disable console output
ctrl &lt;- list(console_output_every = 0)
run &lt;- run_camodel(mod, im, times = seq(0, 100), control = ctrl)
plot(run)

# Very verbose console output (display compilation information, etc.)
ctrl &lt;- list(console_output_every = 1,
             verbose_compilation = TRUE,
             engine = "compiled",
             force_compilation = TRUE)
run &lt;- run_camodel(mod, im, times = seq(0, 100), control = ctrl)

# Turn on or off the memoisation of transition probabilities (mind the speed
# difference)
ctrl &lt;- list(engine = "compiled", precompute_probas = FALSE)
run &lt;- run_camodel(mod, im, times = seq(0, 256), control = ctrl)
ctrl2 &lt;- list(engine = "compiled", precompute_probas = TRUE)
run2 &lt;- run_camodel(mod, im, times = seq(0, 256), control = ctrl2)

# Use a custom function to compute statistics while the simulation is running
fun &lt;- function(t, mat) {
  # Disturbed cell to mussel cell ratio
  ratio &lt;- mean(mat == "DISTURB") / mean(mat == "MUSSEL")
  data.frame(t = t, ratio = ratio)
}
ctrl &lt;- list(custom_output_fun = fun, custom_output_every = 1)

run &lt;- run_camodel(mod, im, times = seq(0, 256), control = ctrl)
stats &lt;- do.call(rbind, run[["output"]][["custom"]])
plot(stats[ ,1], stats[ ,2], ylab = "DISTURB/MUSSEL ratio", xlab = "time", type = "l")


</code></pre>

<hr>
<h2 id='run_meanfield'>Mean field model</h2><span id='topic+run_meanfield'></span>

<h3>Description</h3>

<p>Run the mean field model corresponding to a cellular automaton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_meanfield(mod, init, times, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_meanfield_+3A_mod">mod</code></td>
<td>
<p>The cellular automaton model (produced by <code><a href="#topic+camodel">camodel</a></code></p>
</td></tr>
<tr><td><code id="run_meanfield_+3A_init">init</code></td>
<td>
<p>The initial landscape, or a vector of covers summing to one, whose length 
is equal to the number of states in the model.</p>
</td></tr>
<tr><td><code id="run_meanfield_+3A_times">times</code></td>
<td>
<p>The points in time for which output is wanted</p>
</td></tr>
<tr><td><code id="run_meanfield_+3A_...">...</code></td>
<td>
<p>other arguments are passed to <code><a href="deSolve.html#topic+ode">ode</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean field approximation to a cellular automaton simply describes the dynamics 
of the global covers using differential equations, assumming that both global 
and local covers are equal (in <code>chouca</code> model specifications, this assumes 
p = q). 
</p>
<p>For example, if we consider a model with two states 'a' and 'b' and transitions 
from and to each other, then the following system of equation is used to describe 
the variations of the proportions of cells in each state: 
</p>
<p style="text-align: center;"><code class="reqn">\frac{da}{dt} = p_b P(b \to a) - p_a P(a \to b)</code>
</p>

<p style="text-align: center;"><code class="reqn">\frac{db}{dt} = p_a P(a \to b) - p_b P(b \to a)</code>
</p>

<p>Running mean-field approximations is useful to understand general dynamics in the 
absence of neighborhood interactions between cells, or simply to obtain an 
fast but approximate simulation of the model. 
</p>
<p>Note that this function uses directly the expressions of the probabilities, so any 
cellular automaton is supported, regardless of whether or not it can be simulated 
exactly by <code><a href="#topic+run_camodel">run_camodel</a></code>.
</p>


<h3>Value</h3>

<p>This function returns the results of the <code><a href="deSolve.html#topic+ode">ode</a></code> 
function, which is a matrix with class 'deSolve'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if ( requireNamespace("deSolve") ) { 
  # Get the mean-field approximation to the arid vegetation model 
  arid &lt;- ca_library("aridvege") 
  mod &lt;- ca_library("aridvege")
  init &lt;- generate_initmat(mod, rep(1, 3)/3, nrow = 100, ncol = 100)
  times &lt;- seq(0, 128)
  out &lt;- run_meanfield(mod, init, times)
  # This uses the default plot method in deSolve
  plot(out)
  
  # A different model and way to specifiy initial conditions.
  coralmod &lt;- ca_library("coralreef")
  init &lt;- c(ALGAE = 0.2, CORAL = 0.5, BARE = 0.3)
  times &lt;- 10^seq(0, 4, length.out = 64)
  out &lt;- run_meanfield(coralmod, init, times, method = "lsoda")
  plot(out, ylim = c(0, 1))
}

</code></pre>

<hr>
<h2 id='trace_plotter'>Plot simulation covers</h2><span id='topic+trace_plotter'></span>

<h3>Description</h3>

<p>This function creates an internal function to plot the model
landscape during the simulation of a stochastic cellular automaton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_plotter(
  mod,
  initmat,
  fun = NULL,
  col = NULL,
  max_samples = 256,
  fps_cap = 24,
  burn_in = 0,
  new_window = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace_plotter_+3A_mod">mod</code></td>
<td>
<p>The model being used (created by <code>link{camodel}</code>)</p>
</td></tr>
<tr><td><code id="trace_plotter_+3A_initmat">initmat</code></td>
<td>
<p>The initial landscape given to <code><a href="#topic+run_camodel">run_camodel</a></code></p>
</td></tr>
<tr><td><code id="trace_plotter_+3A_fun">fun</code></td>
<td>
<p>The function used to summarise the landscape into summary metrics. By
default, gloal covers of each state are computed. It must return a vector of
numeric values.</p>
</td></tr>
<tr><td><code id="trace_plotter_+3A_col">col</code></td>
<td>
<p>a set of colors (character vector) of length equal to the number of
values returned by fun.</p>
</td></tr>
<tr><td><code id="trace_plotter_+3A_max_samples">max_samples</code></td>
<td>
<p>The maximum number of samples to display in the plot</p>
</td></tr>
<tr><td><code id="trace_plotter_+3A_fps_cap">fps_cap</code></td>
<td>
<p>The maximum number of frame displayed per seconds. Simulation
will be slowed down if necessary so that plot updates will not be
more frequent than this value</p>
</td></tr>
<tr><td><code id="trace_plotter_+3A_burn_in">burn_in</code></td>
<td>
<p>Do not display anything before this time step has been
reached</p>
</td></tr>
<tr><td><code id="trace_plotter_+3A_new_window">new_window</code></td>
<td>
<p>Controls whether the plots are displayed in a new window,
or in the default device (typically the plot panel in Rstudio)</p>
</td></tr>
<tr><td><code id="trace_plotter_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>, which is used to
display the trends.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates another function that is suitable for use with
<code><a href="#topic+run_camodel">run_camodel</a></code>. It can plot any quantity computed on the
landscape as it is being simulated, using the base function
<code><a href="graphics.html#topic+matplot">matplot</a></code>. The resulting function must by passed to
<code><a href="#topic+run_camodel">run_camodel</a></code> as the control argument <code>custom_output_fun</code>.
Typically, this function is not used by itself, but is being used when
specifying simulation options before calling <code><a href="#topic+run_camodel">run_camodel</a></code>,
see examples below.
</p>
<p>By default, the global covers of each state in the landscape will be displayed, but
you can pass any function as argument <code>fun</code> to compute something else, as long
as <code>fun</code> returns a numeric vector of length at least 1.
</p>
<p><code><a href="graphics.html#topic+matplot">matplot</a></code> is used internally, and tends to be quite slow at
displaying results, but if it is still too fast for your taste, you can cap the
refresh rate at a value given by the argument <code>fps_cap</code>.
</p>
<p>It is important to note that this function will probably massively slow down a
simulation, so it is mostly here for exploratory analyses, or just to
have a good look of what is happening in a model.
</p>


<h3>Value</h3>

<p>This function returns another function, which will be called internally 
when simulating the model using <code><a href="#topic+run_camodel">run_camodel</a></code>, and has probably 
not much use outside of this context. The return function will display the 
simulation and returns NULL.
</p>


<h3>See Also</h3>

<p>landscape_plotter, run_camodel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 

# Display covers of the rock/paper/scissor model as it is running
mod &lt;- ca_library("rock-paper-scissor")
init &lt;- generate_initmat(mod, rep(1, 3)/3, nrow = 100, ncol = 178)
ctrl &lt;- list(custom_output_every = 1,
             custom_output_fun = trace_plotter(mod, init))
run_camodel(mod, init, times = seq(0, 256), control = ctrl)

# Adjust colors of the previous example and increase speed
colors &lt;- c("#fb8500", "#023047", "#8ecae6")
ctrl &lt;- list(custom_output_every = 1,
             custom_output_fun = trace_plotter(mod, init, fps_cap = 60, col = colors))
run_camodel(mod, init, times = seq(0, 600), control = ctrl)

# Display the vegetated to degraded cover ratio for the arid
# vegetation model. 
mod &lt;- ca_library("aridvege")
init &lt;- generate_initmat(mod, rep(1, 3)/3, nrow = 100, ncol = 178)
ratio &lt;- function(mat) {
  mean(mat == "VEGE") / mean(mat == "DEGR")
}
ctrl &lt;- list(custom_output_every = 1,
             custom_output_fun = trace_plotter(mod, init,
                                               fun = ratio))
run_camodel(mod, init, times = seq(0, 512), control = ctrl)

# Display ratios of cell pairs in the rock-paper-scissor model
mod &lt;- ca_library("rock-paper-scissor")
init &lt;- generate_initmat(mod, rep(1, 3)/3, nrow = 100, ncol = 178)
ratio &lt;- function(mat) {
  c(mean(mat == "r") / mean(mat == "p"), 
    mean(mat == "p") / mean(mat == "c"), 
    mean(mat == "c") / mean(mat == "r"))
}
ctrl &lt;- list(custom_output_every = 1,
             custom_output_fun = trace_plotter(mod, init,
                                               fun = ratio))
run_camodel(mod, init, times = seq(0, 512), control = ctrl)

 

</code></pre>

<hr>
<h2 id='update.ca_model'>Update a cellular automaton</h2><span id='topic+update.ca_model'></span>

<h3>Description</h3>

<p>Update the definition of a stochastic cellular automaton
(SCA), using new parameters, type of wrapping, or any other parameters
entering in the definition of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ca_model'
update(
  object,
  parms = NULL,
  neighbors = NULL,
  wrap = NULL,
  fixed_neighborhood = NULL,
  check_model = "quick",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.ca_model_+3A_object">object</code></td>
<td>
<p>The SCA object (returned by <code><a href="#topic+camodel">camodel</a></code>)</p>
</td></tr>
<tr><td><code id="update.ca_model_+3A_parms">parms</code></td>
<td>
<p>a named list of parameters, which should be all numeric,
single values. If this list contains only a subset of model parameters, the
old parameter values will be reused for those not provided.</p>
</td></tr>
<tr><td><code id="update.ca_model_+3A_neighbors">neighbors</code></td>
<td>
<p>The number of neighbors to use in the cellular automaton
('4' for 4-way or von-Neumann neghborhood, or '8' for an 8-way or Moore
neighborhood)</p>
</td></tr>
<tr><td><code id="update.ca_model_+3A_wrap">wrap</code></td>
<td>
<p>If <code>TRUE</code>, then the 2D grid on which the model is run wraps
around at the edges (the top/leftmost cells will be considered neighbors
of the bottom/rightmost cells)</p>
</td></tr>
<tr><td><code id="update.ca_model_+3A_fixed_neighborhood">fixed_neighborhood</code></td>
<td>
<p>When not using wrapping around the edges (<code>wrap = TRUE</code>,
the number of neighbors per cell is variable, which can slow down the simulation.
Set this option to <code>TRUE</code> to consider that the number of neighbors is always
four or eight, regardless of the position of the cell in the landscape, at the cost
of approximate dynamics on the edge of the landscape.</p>
</td></tr>
<tr><td><code id="update.ca_model_+3A_check_model">check_model</code></td>
<td>
<p>A check of the model definition is done to make sure there
are no issues with it (e.g. probabilities outside the [1,0] interval, or an
unsupported model definition). A quick check that should catch most problems is
performed if check_model is &quot;quick&quot;, an extensive check that tests all
neighborhood configurations is done with &quot;full&quot;, and no check is performed with
&quot;none&quot;.</p>
</td></tr>
<tr><td><code id="update.ca_model_+3A_verbose">verbose</code></td>
<td>
<p>whether information should be printed when parsing the model
definition.</p>
</td></tr>
<tr><td><code id="update.ca_model_+3A_...">...</code></td>
<td>
<p>extra arguments are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function updates some aspects of a pre-defined stochastic celullar
automaton, such as parameter values, the type of neighborhood, whether
to wrap around the edge of space, etc. It is handy when running multiple
simulations, and only a few aspects of the model needs to be changed, such as
parameter values. Note that this function cannot add or remove states to a model.
</p>
<p>Note that the <code>parms</code> list may only specify a subset of the model parameters
to update. In this case, old parameter values not specified in the call to
<code>update</code> will be re-used.
</p>


<h3>Value</h3>

<p>This function returns a list with class <code>ca_model</code> with the changes applied to 
the original model (see <code><a href="#topic+camodel">camodel</a></code> for details about this type of
object).
</p>


<h3>See Also</h3>

<p>camodel, run_camodel...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Update the parameters of a model
mussels &lt;- ca_library("musselbed")
mussels[["parms"]] # old parameters
mussels_new &lt;- update(mussels, parms = list(d = 0.2, delta = 0.1, r = 0.8))
mussels_new[["parms"]] # updated parameters

# Update the type of neighborhood, wrapping around the edges, and
# the parameters
mussels_new &lt;- update(mussels,
                      parms = list(d = 0.2, delta = 0.1, r = 0.8),
                      wrap = TRUE,
                      neighbors = 8)
mussels_new



# Run the model for different values of d, the death rate of mussels
ds &lt;- seq(0, 0.25, length.out = 12)
initmat &lt;- generate_initmat(mussels, c(0.5, 0.5, 0), nrow = 64, ncol = 64)
results &lt;- lapply(ds, function(this_dvalue) {
  musselmod &lt;- update(mussels, parms = list(d = this_dvalue))
  run &lt;- run_camodel(musselmod, initmat, times = seq(0, 128))
  data.frame(d = this_dvalue,
             as.data.frame(tail(run[["output"]][["covers"]], 1)))
})

results &lt;- do.call(rbind, results)
plot(results[ ,"d"], results[ ,"MUSSEL"], type = "b",
     xlab = "d", ylab = "Mussel cover")



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
