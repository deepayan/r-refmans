<!DOCTYPE html><html lang="en-US"><head><title>Help for package SpatialfdaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialfdaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create.FEM.basis'>
<p>Create a FEM Basis with Triangular Finite Element Basis Functions</p></a></li>
<li><a href='#eval.FEM.basis'>
<p>Values of a Finite Element Functional Data Object</p></a></li>
<li><a href='#eval.FEM.fd'><p>Evaluate a functional data object with an FEM basis.</p></a></li>
<li><a href='#FEMdensity'>
<p>Evaluate the function value and gradient for a penalized likelihood estimate</p>
of spatial density.</a></li>
<li><a href='#insideIndex'>
<p>Index of the triangle containing a point.</p></a></li>
<li><a href='#makenodes'>
<p>Compute the matrix <code>nodes</code> containing all the nodes in the mesh.</p></a></li>
<li><a href='#mass.FEM'>
<p>Compute the mass matrix for a finite element basis.</p></a></li>
<li><a href='#MeuseData'>
<p>Objects Defining Meuse River Mesh</p></a></li>
<li><a href='#plotFEM.fd'>
<p>Plots an FEM functional data object.</p></a></li>
<li><a href='#plotFEM.mesh'>
<p>Plot a finite element mesh.</p></a></li>
<li><a href='#randomFEMpts'>
<p>Generate Random Locations in a Mesh with a Specified Density</p></a></li>
<li><a href='#smooth.FEM.basis'>
<p>Construct a functional data object by smoothing spatial data distributed over</p>
a region with a complicated boundary using a roughness penalty.</a></li>
<li><a href='#smooth.FEM.density'><p>Compute a smooth FEM density surface of a triangulated region.</p></a></li>
<li><a href='#squareMesh'>
<p>Generate a Triangulation of a Square.</p></a></li>
<li><a href='#squareMesh_RL'>
<p>Generate a Triangulation of a Square.</p></a></li>
<li><a href='#stiff.FEM'>
<p>Compute the stiffness matrix for a finite element basis.</p></a></li>
<li><a href='#tricoefCal'>
<p>Compute the coefficient matrix required to test of a point</p>
is inside a triangle.</a></li>
<li><a href='#triDensity'>
<p>Compute the probabilities that a random location will be within one of the triangles of an</p>
FEM mesh.</a></li>
<li><a href='#triquad'>
<p>Set up Gaussian quadrature points and weights for a triangular domain.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-10</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Functional Data Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>James Ramsay [aut, cre],
  Spencer Graves [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Ramsay &lt;james.ramsay@mcgill.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), fda, splines, graphics, rgl, geometry</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Finite element modeling (FEM) uses meshes of triangles to define surfaces.  
  A surface within a triangle may be either linear or quadratic. 
  In the order one case each node in the mesh is associated with a basis 
  function and the basis is called the order one finite element basis.
  In the order two case each edge mid-point is also associated with a basis
  function.  Functions are provided for smoothing, density function estimation
  point evaluation and plotting results.  Two papers illustrating the 
  finite element data analysis are Sangalli, L.M., Ramsay, J.O., 
  Ramsay, T.O. (2013)<a href="http://www.mox.polimi.it/~sangalli">http://www.mox.polimi.it/~sangalli</a> and
  Bernardi, M.S, Carey, M., Ramsay, J. O., Sangalli, L. 
  (2018)<a href="http://www.mox.polimi.it/~sangalli">http://www.mox.polimi.it/~sangalli</a>. Modelling 
  spatial anisotropy via regression with partial differential 
  regularization Journal of Multivariate Analysis, 167, 15-30.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.functionaldata.org">http://www.functionaldata.org</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-10 18:22:01 UTC; jimramsay</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-11 09:12:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='create.FEM.basis'>
Create a FEM Basis with Triangular Finite Element Basis Functions
</h2><span id='topic+create.FEM.basis'></span>

<h3>Description</h3>

<p>Functional data objects are constructed by specifying a set of basis
functions and a set of coefficients defining a linear combination of
these basis functions.
</p>
<p>The FEM basis is used for functions defined over spatial regions with
complicated boundaries.  There is an outer boundary outside of which
no spatial location is found and there may be, in addition, one or more
interior boundaries defining holes inside of which no data are found as well.
For example, the outer boundary may define a geographical region, and an inner
boundary can define a lake within which no data of interest are found.
</p>
<p>The interior of the region not within the holes is subdivided into a set of
triangles by a mesh generation procedure. See function
<code>create.mesh.object</code> for a description of this process.
</p>
<p>FEM basis functions are centered on points called nodes that are on a boundary
or within the interior region not within holes at points called nodes.  Some
or all of these nodes are also vertices of the triangles.  FEM basis functions
are the two-dimensional analogues of B-spline basis functions defined over
one dimension.  Like splines, each FEM basis function is zero everywhere
except in the immediate neighborhood defined by the triangles that share a
node, and the nodes play the role of knots for splines.
</p>
<p>Like splines, FEM functions are piecewise bivariate polynomials, with a loss
of smoothness across edges of triangles.  Linear FEM functions are
once-differentiable within triangles, and quadratic functions are
twice-differentiable.  But both types of function are only continuous across
edges.  The second example below will highlight these features.
</p>
<p>Function <code>create.FEM.basis</code> supports only linear or quadratic functions.
All nodes for linear basis functions correspond to triangle vertices, and
consequently there are three nodes per triangle.  For quadratic  basis
functions, vertices are nodes, but mid-points of edges are also nodes, so that
there are six nodes per triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.FEM.basis(pts, edg=NULL, tri, order=1, nquad=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.FEM.basis_+3A_pts">pts</code></td>
<td>

<p>The <code>nbasis</code> by 2 matrix of vertices of triangles containing
the X- and Y-coordinates of the vertices.
</p>
</td></tr>
<tr><td><code id="create.FEM.basis_+3A_edg">edg</code></td>
<td>

<p>The number of edges by 2 matrix defining the segments of the
boundary of the region which are also edges of the triangles
adjacent to the boundary.
The values in matrix <code>edg</code> are the indices of the vertices
in matrix <code>pts</code> of the starting and ending points of the edges.
</p>
</td></tr>
<tr><td><code id="create.FEM.basis_+3A_tri">tri</code></td>
<td>

<p>The no. of triangles by 3 matrix specifying triangles and
their properties.  The indices in <code>pts</code> of the vertices of each
triangle are in counter-clockwise order.
</p>
</td></tr>
<tr><td><code id="create.FEM.basis_+3A_order">order</code></td>
<td>

<p>The order of the finite element basis functions.  This may be either one
or two.  Order one functions are piecewise linear, and order two functions
are piecewise quadratic.
</p>
</td></tr>
<tr><td><code id="create.FEM.basis_+3A_nquad">nquad</code></td>
<td>

<p>An integer determining the number of quadrature points and weights used to
estimate the value of an integral if a function over a triangle  using
Gaussian quadrature. The number of quadrature points and weights is equal
to the square of <code>nquad</code>.  The <code>nquad</code> &lt;- 4 usually provides
sufficient accuracy for statistical purposes, but the default value of zero
implies that no such integration will be needed.  Data smoothing does not
require integration, but data density estimation does.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mesh generation step is critical, and if done carelessly or naively, can
easily cause the smoothing process to fail, usually due to a singular set
of coefficient equations.  Careful attention to generating a mesh is required
in order to obtain a mesh that is both well-conditioned and has sufficient
density to permit a faithful rendition of the smoothing surface required by
the data.
</p>
<p>Well-conditioned meshes do not have triangles with small angles, and the
two mesh-generations functions can allow the user to specify the minimal
angle in the mesh.
</p>
<p>On the other hand, the finer the mesh, the greater the number of basis
functions, so that, as in all smoothing procedures, one wants to avoid
meshes so fine that the possibly noisy observations are interpolated rather
than smoothed.
</p>
<p>Triangles with no data in them are in general to be avoided.  In fact, it is
common but not necessary that the mesh be constructed so that data observation
points are at the vertices of the triangles in the mesh.  This special case
also leads to very fast computation of the smoothing surface.  In some cases,
it may make sense to interpolate data to prespecified mesh points before
undertaking smoothing.
</p>
<p>Piecewise linear basis functions are generally preferable unless estimates
of the second partial derivatives of the surface are required because
quadratic elements require twice as many basis functions.  First order
partial derivatives of surfaces are piecewise constant over each  triangle.
Even though the estimated surface is piecewise linear, its total
curvature is still controlled by the size of the smoothing parameter
specified in function <code>smooth.FEM.basis</code>.  The larger the smoothing
parameter, the more flat the surface will become.
</p>


<h3>Value</h3>

<p>A <code>basisfd</code> object of the type <code>FEM</code>.  See the help file for
<code>basisfd</code> for further details about this class.
</p>
<p>The <code>params</code> slot or member for an FEM basis contains a good deal of
information that is used in other functions, such as <code>smooth.FEM.basis</code>.
Consequently, <code>basisfd$params</code> is itself a list with named members, their
contents are:
</p>
<table role = "presentation">
<tr><td><code>mesh</code></td>
<td>

<p>an object of class <code>MESH</code> specifying the structure of the triangular
mesh.  See the help file for this class for further details
</p>
</td></tr>
<tr><td><code>order</code></td>
<td>

<p>either 1 for linear elements or 2 for quadratic elements
</p>
</td></tr>
<tr><td><code>nodeList</code></td>
<td>

<p>a <code>list</code> object with named members.  The list contains information
that is required for other functions that may be repeatedly called, such as
<code>smooth.FEM.basis</code>.  The names and their contents are:
</p>

<ol>
<li><p>nodesa K by 2 matrix of coordinates for the K nodes in the mesh.
</p>
</li>
<li><p>nodesindexthe index of each node
</p>
</li>
<li><p>Jthe Jacobian for the transformation of each triangle to the
standard right triangle
</p>
</li>
<li><p>metrica three-dimensional array with the length of the leading
dimension equal to the number of triangles, and the next two dimensions of
length 2.  The 2 by 2 matrices are the transformation matrices for mapping
each triangle into the standard triangle
</p>
</li>
<li><p>quadmatNULL if argument <code>nquad</code> is zero, or otherwise, a list
with a member for each triangle containing the quadrature points and weights
for approximating the integral of a function over that triangle.  See the
help file for function <code>triquad</code> for further details.
</p>
</li>
<li><p>Cart2BaryA three-dimensional array with the leading dimension equal
to the number of triangles, and the remaining dimensions of length 3.
Each order 3 matrix maps the cartesian coordinate vector

<code>c(1, p(1), p(2))</code> into the corresponding  barycentric coordinates for
a triangle, where <code>p</code> contains the Cartesian coordinates of a point.</p>
</li></ol>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotFEM.mesh">plotFEM.mesh</a></code>,
<code><a href="#topic+smooth.FEM.basis">smooth.FEM.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  ----------------------------------------------------------------------
#  Example 1:  Set up the simplest possible mesh by hand so as to see
#  the essential elements of a finite element basis
#  Specify the three vertices, in counter-clockwise order, for a single
#  right triangle
#  ----------------------------------------------------------------------
pts &lt;- matrix(c(0, 0, 1, 0, 0, 1),3,2,byrow=TRUE)
#  These points also specify the boundary edges by a 3 by 2 matrix
#  with each row containing the index of the starting point and of the
#  corresponding ending point
edg &lt;- matrix(c(1, 2, 2, 3, 3, 1), 3, 2, byrow=TRUE)
#  The triangles are defined by a 1 by 3 matrix specifying the indices
# of the vertices in counter-clockwise order
tri &lt;- matrix(c(1, 2, 3), 1, 3)
#  FEM basis objects can be either linear (order 1) or quadratice (order 2)
#  both are illustrated here:
#  Set up a FEM basis object of order 1 (piecewise linear) basis functions
order &lt;- 1
FEMbasis1 &lt;- create.FEM.basis(pts, edg, tri, order)
#  display the number of basis functions
print(paste("Number of basis functions =",FEMbasis1$nbasis))
#  plot the basis, the boundary being plotted in red
plotFEM.mesh(pts,tri)
#  Set up an FEM basis object of order 2 (piecewise quadratic) basis functions
order &lt;- 2
FEMbasis2 &lt;- create.FEM.basis(pts, edg, tri, order)
#  display the number of basis functions
print(paste("Number of basis functions =",FEMbasis2$nbasis))
#  plot the basis, the boundary being plotted in red
plotFEM.mesh(pts,tri)
#  ----------------------------------------------------------------------
#  Example 2:  Set up an FEM object with a hexagonal boundary, and a single
#  interior point
#  ----------------------------------------------------------------------
angle &lt;- seq(0,2*pi,len=7)
x     &lt;- cos(angle); y &lt;- sin(angle)
pts   &lt;- rbind(cbind(x[1:6], y[1:6]), c(0, 0))
edg   &lt;- cbind((1:6),c((2:6), 1))
tri   &lt;- matrix(c(7*rep(1,6), 1:6, 2:6, 1),6,3)
hexFEMbasis &lt;- create.FEM.basis(pts, edg, tri)
#  display the number of basis functions
print(paste("Number of basis functions =",hexFEMbasis$nbasis))
#  plot the basis, the boundary being plotted in red
plotFEM.mesh(pts,tri)
</code></pre>

<hr>
<h2 id='eval.FEM.basis'>
Values of a Finite Element Functional Data Object
</h2><span id='topic+eval.FEM.basis'></span>

<h3>Description</h3>

<p>Evaluate a finite element (FEM) functional data object at specified locations,
or evaluate a pair of partial derivatives of the functional object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.FEM.basis(obspts, FEMbasis, nderivs=rep(0,2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.FEM.basis_+3A_obspts">obspts</code></td>
<td>

<p>a two-column matrix of x- and Y-coordinate values at which the functional data
object is to be evaluated.  
</p>
</td></tr>
<tr><td><code id="eval.FEM.basis_+3A_fembasis">FEMbasis</code></td>
<td>

<p>an FEM functional basis object to be evaluated.
</p>
</td></tr>
<tr><td><code id="eval.FEM.basis_+3A_nderivs">nderivs</code></td>
<td>

<p>a vector length 2 containing a pair of orders of derivatives.  If the FEM
basis is piecewise linear  (of order 1), the only admissible pairs are
(0,0), (0,1) and (1,0).
If the FEM basis is piecewise quadratic (of order 2), the pairs (1,1),
(0,2) and (2,0) are also admissible.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two common uses of this function are (1) to evaluate the surface at one or
more significant points, and (2) evaluate the surface over a bounding
rectangle so that the surface can be plotted as either a contour plot are
as a persp type plot.  Points that are outside of polygon defining the
surface are given the value NA, and are therefore not plotted.
</p>


<h3>Value</h3>

<p>an array of 2 or 3 dimensions containing the surface
values.  The first two dimension correspond to the arguments <code>obspts</code> and,      
if present, the third dimension corresponds to the surface
in the situation where the coefficient matrix has multiple columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.FEM.fd">eval.FEM.fd</a></code>,
<code><a href="#topic+smooth.FEM.basis">smooth.FEM.basis</a></code>
</p>

<hr>
<h2 id='eval.FEM.fd'>Evaluate a functional data object with an FEM basis.</h2><span id='topic+eval.FEM.fd'></span>

<h3>Description</h3>

<p>A set of points is supplied, and the height of the surface is evaluated at these points.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.FEM.fd(pts, fdobj, nderivs=rep(0,2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.FEM.fd_+3A_pts">pts</code></td>
<td>
<p>A two column matrix of pts within a triangular mesh.</p>
</td></tr>
<tr><td><code id="eval.FEM.fd_+3A_fdobj">fdobj</code></td>
<td>
<p>A functional data object with an FEM basis.</p>
</td></tr></table>
<p>&ldquo;1   
</p>
<table role = "presentation">
<tr><td><code id="eval.FEM.fd_+3A_nderivs">nderivs</code></td>
<td>
<p>A vector of length 2 containing derivative orders with respect 
to the X and Y coordinates of the triangular mesh.  The derivative orders are
restricted to 0, 1 or 2, and 2 can only be used for a quadratic basis system.
The default is both orders being 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with number of rows equal to the number of rows of <code>pts</code>
containing the values of of one or more surfaces at these points.
</p>


<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.FEM.basis">eval.FEM.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  ----------------------------------------------------------------------------
#  Example 1:  smoothing data over a circular region
#  ----------------------------------------------------------------------------
#  Set up a FEM object with a approximatedly circular boundary with 12 sides,
#  and two rings of 12 points plus a point at the centre.
angle = seq(0,11*pi/6,len=12)
#  define the 24 point locations
rad = 2
ctr = c(0,0)
pts  = matrix(0,25,2);
pts[ 1:12,1] = rad*cos(angle)   + ctr[1]
pts[ 1:12,2] = rad*sin(angle)   + ctr[2]
pts[13:24,1] = rad*cos(angle)/2 + ctr[1]
pts[13:24,2] = rad*sin(angle)/2 + ctr[2]
#  define the edge indices
edg &lt;- matrix(0,12,2)
for (i in 1:11) {
  edg[i,1] &lt;- i
  edg[i,2] &lt;- i+1
}
edg[12,] &lt;- c(12,1)
#  use delaunay triangulation to define the triangles
tri = delaunayn(pts)
plotFEM.mesh(pts, tri, shift = 0.02)
title("A 25-point curcular mesh")
#  Create an order 1 basis
hexFEMbasis &lt;- create.FEM.basis(pts, edg, tri, 1)
#  locations of data
obspts &lt;- pts
npts &lt;- dim(obspts)[1]
points(obspts[,1], obspts[,2], col=2, cex=2, lwd=2)
hexfd = fd(matrix(1-c(obspts[,1]^2+obspts[,2]^2),npts,1),hexFEMbasis)
#  heights of a hemisphere at these locations
hexhgts &lt;- round(eval.FEM.fd(obspts,hexfd),2)
</code></pre>

<hr>
<h2 id='FEMdensity'>
Evaluate the function value and gradient for a penalized likelihood estimate
of spatial density.
</h2><span id='topic+FEMdensity'></span>

<h3>Description</h3>

<p>A spatial density defined over a region with complicated a boundary that is
defined by a triangulation is estimated.  The basis functions are linear
finite elements (FEM) defined at each vertex.
The data are the spatial coordinates of a sample of a defined spatial event.
The density surface is the logarithm of the density, and the smoothness of
the log surface is controlled by a smoothing parameter <code>lambda</code>
multiplying the stiffness matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEMdensity(cvec, obspts, FEMbasis, K1=NULL, lambda=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FEMdensity_+3A_cvec">cvec</code></td>
<td>
<p>A matrix each column of which contains the coefficients
for an FEM basis function expansion of a surface.
The number of coefficients equals the number of vertices in the
triangulation, also called the nodes of the FEM expansion.</p>
</td></tr>
<tr><td><code id="FEMdensity_+3A_obspts">obspts</code></td>
<td>
<p>A two-column matrix containing the locations at which the
logarithm of the density is to be evaluated.</p>
</td></tr>
<tr><td><code id="FEMdensity_+3A_fembasis">FEMbasis</code></td>
<td>
<p>This argument provides the FEM basis (class <code>basisfd</code>),
and may be in the form of an FEM basis object, an FEM function object
(class <code>fd</code>), or an FEM functional parameter object
(class <code>fdPar</code>.</p>
</td></tr>
<tr><td><code id="FEMdensity_+3A_k1">K1</code></td>
<td>
<p>The stiffness matrix associated with the triangulation.
It is computed using function .</p>
</td></tr>
<tr><td><code id="FEMdensity_+3A_lambda">lambda</code></td>
<td>
<p>A non-negative real number controlling the smoothness
of the surface by a roughness penalty consisting of <code>lambda</code>
multiplying the stiffness matrix <code>K1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A probability density surface of a two-dimensional region bounded by line
segments is defined by a set of linear or planar triangular surfaces.
Each triangular segment is associated with three vertices, and with
with three basis functions, each associated with a local linear surface
that has height one at one of the vertices and height zero along
the two opposing edges.  The basis function expansion is actually of
the logarithm of the density surface, and has one set of two partial
derivatives everywhere except along edges and at vertices of the
triangles.  The surface is continuous over edges and vertices.  The
density surface is computed by dividing the exponential of the log
surface by the integral of the density over the region, which
is returned along with the coefficients of the expansion within
a list object.
Multiple density surfaces may be estimated, in which case each
column of argument <code>cvec</code> is associated with a surface.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>F</code></td>
<td>
<p>The penalized log likelihood value associated with the coefficient
vector(s).</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>The gradient vector(s) associated with the coefficient
vector(s).</p>
</td></tr>
<tr><td><code>norm</code></td>
<td>
<p>The L2 norm(s) of the gradient vector(s).</p>
</td></tr>
<tr><td><code>Pvec</code></td>
<td>
<p>A matrix, each column of which contains density function values
at the nodes or vertices.</p>
</td></tr>
<tr><td><code>Pden</code></td>
<td>
<p>A vector of values of the normalizing constants defined for
each surface defined by integrating the exponential of a log surface
over the triangular region.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jim Ramsay</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code><a href="fda.html#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+smooth.FEM.density">smooth.FEM.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  ---------  density on right triangle  --------------
#  Define the locations of the vertices of the right triangle
pts  &lt;- matrix(c(0,0, 1,0, 0,1), 3, 2, byrow=TRUE)
npts &lt;- dim(pts)[1]
#  Specify the single triangle defined by these vertices.
#  The vertices are listed in counter-clockwise order
tri  &lt;- matrix(c(1,2,3),1,3)
ntri &lt;- dim(tri)[1]
#  Set up the FEM basis object for this region
edg &lt;- NULL
RtTriBasis &lt;- create.FEM.basis(pts, edg, tri, 1)
#  List object containing details of nodes.
nodeList &lt;- makenodes(pts,tri,1)
#  number of random points required
Nsample &lt;- 100
#  generate random points ... define the function
obspts &lt;- randomFEMpts(Nsample, pts, tri)
#  Define a starting value for the coefficient vector of length 3
cvec0 &lt;- matrix(rnorm(npts),npts,1)
#  Evaluate the function and gradient vector
result &lt;- FEMdensity(cvec0, obspts, RtTriBasis)
print(paste("Function value =",result$F))
print("gradient:")
print(result$grad)
#  ---------- density on a unit square,  4 triangles, 5 nodes  ----------
#  Generate a unit square with a node in its center defining four
#  triangles and five nodes.
result &lt;- squareMesh(1)
pts &lt;- result$p
edg &lt;- result$e
tri &lt;- result$t
#  plot the mesh
plotFEM.mesh(pts, tri)
npts &lt;- dim(pts)[1]
ntri &lt;- dim(tri)[1]
#  Define the true log density function
SinCosIntensFn &lt;- function(x,y) {
  return(sin(2*pi*x)*cos(2*pi*y))
}
#  Compute a sine*cosine intensity surface.
intDensityVec &lt;- triDensity(pts, tri, SinCosIntensFn)
#  Set up and plot an FEM basis object
SquareBasis1 &lt;- create.FEM.basis(pts, edg, tri)
N &lt;- 100
obspts &lt;- randomFEMpts(N, pts, tri, intDensityVec)
#  plot the random points
points(obspts[,1],obspts[,2])
#  Estimate the smooth density surface with light smoothing
order    &lt;- 1
nodeList &lt;- makenodes(pts,tri,order)
K1       &lt;- stiff.FEM(SquareBasis1)
lambda   &lt;- 1e-4
#  define a random coefficient vector
cvec     &lt;- rnorm(npts,1)
#  display function value and gradient
result &lt;- FEMdensity(cvec, obspts, SquareBasis1, K1, lambda)
print(paste("Function value =",round(result$F,3)))
print("gradient:")
print(round(result$grad,3))
</code></pre>

<hr>
<h2 id='insideIndex'>
Index of the triangle containing a point.
</h2><span id='topic+insideIndex'></span>

<h3>Description</h3>

<p>Evaluate the index of the triangle containing the point
<code>(X,Y)</code> if such a triangle exists, and <code>NaN</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insideIndex(obspts, pts, tri, tricoef)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insideIndex_+3A_obspts">obspts</code></td>
<td>
<p>A two-column matrix of observation location points.
</p>
</td></tr>
<tr><td><code id="insideIndex_+3A_pts">pts</code></td>
<td>

<p>A two-column matrix of the locations of the vertices of the mesh.
</p>
</td></tr>
<tr><td><code id="insideIndex_+3A_tri">tri</code></td>
<td>

<p>A three-column matrix of the indices in <code>pts</code> of the triangle vertices.
</p>
</td></tr>
<tr><td><code id="insideIndex_+3A_tricoef">tricoef</code></td>
<td>
<p>Four-column matrix of coefficients for computing barycentric coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each triangle is checked to see if the point is contained within it or on its boundary.  
This is verified if all three of the barycentric coordinates are non-negative.
</p>


<h3>Value</h3>

<p>A vector of integers indicating which triangle in <code>tri</code> contains a point.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FEMdensity">FEMdensity</a></code>,
<code><a href="#topic+eval.FEM.basis">eval.FEM.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  ---------- density on a unit square,  4 triangles, 5 vertices  ----------
#  Generate a unit square with a node in its center defining four
#  triangles and five nodes.
result &lt;- squareMesh(1)
pts  &lt;- result$p
edg  &lt;- result$e
tri  &lt;- result$t
npts &lt;- dim(pts)[1]
ntri &lt;- dim(tri)[1]
#  define function for sine*cosine function
SinCosIntensFn &lt;- function(x,y) {
  return(sin(2*pi*x)*cos(2*pi*y))
}
#  Compute a sine*cosine intensity surface.
intDensityVec &lt;- triDensity(pts, tri, SinCosIntensFn)
#  Set up and plot an FEM basis object
SquareBasis1 &lt;- create.FEM.basis(pts, edg, tri)
oldpar &lt;- par(cex.lab=2)
plotFEM.mesh(pts, tri)
#  generate random points
N = 1000
obspts &lt;- randomFEMpts(N, pts, tri, intDensityVec)
#  plot the random points
points(obspts[,1],obspts[,2])
#  find the triangle number containing each point
triIndex &lt;- insideIndex(obspts, pts, tri)
par(oldpar)
</code></pre>

<hr>
<h2 id='makenodes'>
Compute the matrix <code>nodes</code> containing all the nodes in the mesh.
</h2><span id='topic+makenodes'></span>

<h3>Description</h3>

<p>Each basis function is associated with a node.  If the order of the finite
elements is 1, the nodes are the vertices of the triangles.  If the order
is 2, the nodes are also at the midpoints of the edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  makenodes(pts, tri, order=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makenodes_+3A_pts">pts</code></td>
<td>

<p>A two-column matrix of the locations of the vertices of the mesh.
</p>
</td></tr>
<tr><td><code id="makenodes_+3A_tri">tri</code></td>
<td>

<p>A three-column matrix of the indices in <code>pts</code> of the triangle vertices.
</p>
</td></tr>
<tr><td><code id="makenodes_+3A_order">order</code></td>
<td>

<p>The order of the finite element, which is either 1 or 2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a matrix nodes containing coordinates for all of the nodes to be used,
a matrix nodeindex defining which nodes correspond to each element.
If norder is 1, nodes corresponds to vertices and nodeindex is
identical to triangles.
If norder is 2, the midpoint of each edge is computed and added to
points to obtain matrix nodes.
The row index of that midpoint is then added to the rows of triangles
containing that edge to define nodeindex.
</p>


<h3>Value</h3>

<p>A list object containing these members:
</p>

<ul>
<li><p>order
The order of the finite elements, which is either 1 or 2.

</p>
</li>
<li><p>nodes
A numnodes*2 matrix whose i'th row contains
the coordinates of the i'th nodal variable.
Nodes for the second order element consist of vertices and
midpoints of edges, that is, 6 per triangle.
Points are listed first followed by midpoints.
Nodes for the first order element consist of only vertices.

</p>
</li>
<li><p>nodeindex
If norder == 1, nodeindex is triangles.
If norder == 2, an nele*6 matrix whose i'th row
contains the row numbers (in nodes) of the
nodal variables defining the i'th finite
element.  If the i'th row of FMESH is [V1 V2 V3]
then the i'th row of nodeindex is
[V1 V(12) V2 V(23) V3 V(31)], where Vi is the
row number of the i'th point and V(ij) is the
row number of the midpoint of the edge defined
by the i'th and j'th points.
If norder == 1, nodeindex is triangles

</p>
</li>
<li><p>jvec
Jacobian, which is the area of triangle.

</p>
</li>
<li><p>metric
Metric matrix.

</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mass.FEM">mass.FEM</a></code>,
<code><a href="#topic+stiff.FEM">stiff.FEM</a></code>
</p>

<hr>
<h2 id='mass.FEM'>
Compute the mass matrix for a finite element basis.
</h2><span id='topic+mass.FEM'></span>

<h3>Description</h3>

<p>mass.FEM produces the mass matrix containing integrals of products of
the nodal functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mass.FEM(FEMbasis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mass.FEM_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A List object produced by function <code>create.FEM.basis</code>.
It contains:
</p>

<ul>
<li><p>orderThe order of the element (1 or 2).
</p>
</li>
<li><p>nodesCoordinates of node points.
</p>
</li>
<li><p>nodeindexIndices of node points for each element.
</p>
</li>
<li><p>jvecJacobian of the affine transformation of each
element to the master element.
</p>
</li></ul>

</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code>k0</code>: the <code>nnod</code> by <code>nnod</code> matrix of sums
of products of nodal basis functions.
For each element i, the integral of the product
of the j'th and k'th shape functions over the i'th element is
computed.  Then that value is the 
<code>(nodeindex[i,j],nodeindex[i,k])</code> entry of the i'th elemental 
mass matrix.
</p>


<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stiff.FEM">stiff.FEM</a></code>
</p>

<hr>
<h2 id='MeuseData'>
Objects Defining Meuse River Mesh
</h2><span id='topic+MeuseData'></span>

<h3>Description</h3>

<p>The data are the points, edges and triangles required to mesh a bank of the 
Meuse river in Belgium that is of concern for heavy metal polution. The data
to be analyzed are locations and size of zinc assays.  A covariate is distances
of locations from the river.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeuseData
</code></pre>


<h3>Format</h3>

<p>A named list.</p>


<h3>Details</h3>

<p>A named list with four members. The number of points is 155, the number of edges 
is 52, and the number of triangles is 257.
</p>

<dl>
<dt>covdata:</dt><dd><p>A 155 by 2 matrix.  The first column contains the 
distance from the river of each location, and the second the amount of 
zinc detected.</p>
</dd>  
<dt>pts:</dt><dd><p>A 155 by 2 matrix containing the locations of the deposits.</p>
</dd>
<dt>edg:</dt><dd><p>A 52 by 2 matrix containing the indices of the points that
are the beginning and end of each of the 52 boundary segments.</p>
</dd>
<dt>tri:</dt><dd><p>A 257 by 3 matrix containing the indices of the vertices of each
triangle in counter-clockwise order.</p>
</dd>
</dl>


<hr>
<h2 id='plotFEM.fd'>
Plots an FEM functional data object.
</h2><span id='topic+plotFEM.fd'></span>

<h3>Description</h3>

<p>Plots a FEM object fdobj over a rectangular grid defined by
vectors Xgrid and Ygrid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotFEM.fd(fdobj, Xgrid=NULL, Ygrid=NULL, nderivs=rep(0,2), 
                      xlab="X", ylab="Y", zlab="Z", main="",
                      ticktype="detailed", r=10, phi=15, theta=30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotFEM.fd_+3A_fdobj">fdobj</code></td>
<td>

<p>A surface defined by a finite element FEM basis.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_xgrid">Xgrid</code></td>
<td>

<p>A vector of X coordinate values.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_ygrid">Ygrid</code></td>
<td>

<p>A vector of Y coordinate values.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_nderivs">nderivs</code></td>
<td>
<p>A vector of length 2 indicating order of partial derivatives.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_xlab">xlab</code></td>
<td>
<p>A character vector for labelling the X-axis
when using function <code>persp</code>.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_ylab">ylab</code></td>
<td>
<p>A character vector for labelling the Y-axis
when using function <code>persp</code>.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_zlab">zlab</code></td>
<td>
<p>A character vector for labelling the Z-axis
when using function <code>persp</code>.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_main">main</code></td>
<td>
<p>A character vector for the title
when using function <code>persp</code>.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_ticktype">ticktype</code></td>
<td>
<p>A character vector for defining the tick marks
when using function <code>persp</code>.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_r">r</code></td>
<td>
<p>A positive number for the distance of the eyepoint from the center
of the plot when using function <code>persp</code>.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_phi">phi</code></td>
<td>
<p>A number specifying the collatitude
when using function <code>persp</code>.
</p>
</td></tr>
<tr><td><code id="plotFEM.fd_+3A_theta">theta</code></td>
<td>
<p>A number specifying the azimuthal direction
when using function <code>persp</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotFEM.mesh">plotFEM.mesh</a></code>,
<code><a href="#topic+eval.FEM.fd">eval.FEM.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Set up and plot a square with side length one with 32 interior triangles,
#  and then create an order one functional basis object of type FEM.
m &lt;- 4
petList &lt;- squareMesh(m)
pts &lt;- petList$p
edg &lt;- petList$e
tri &lt;- petList$t
pts &lt;- pts/m
plotFEM.mesh(pts, tri)
norder &lt;- 1
FEMbasis &lt;- create.FEM.basis(pts, edg, tri, norder)
#  set up surface values on the nodes of this mesh
data     &lt;- sin(2*pi*pts[,1])*cos(2*pi*pts[,2])
#  smooth the data
FEMList  &lt;- smooth.FEM.basis(pts, data, FEMbasis)
sincosfd &lt;- FEMList$fd
#  set up a 21 by 21 grid of plotting points
Npts &lt;- 21
Xpts &lt;- seq(0,1,len=Npts)
Ypts &lt;- Xpts
#  plot the surface
oldpar &lt;- par(no.readonly = TRUE)
plotFEM.fd(sincosfd, Xpts, Ypts)
#  plot the X partial derivative of the surface
plotFEM.fd(sincosfd, Xpts, Ypts, c(1,0))
#  plot the Y partial derivative of the surface
plotFEM.fd(sincosfd, Xpts, Ypts, c(0,1))
par(oldpar)
</code></pre>

<hr>
<h2 id='plotFEM.mesh'>
Plot a finite element mesh.
</h2><span id='topic+plotFEM.mesh'></span>

<h3>Description</h3>

<p>A finite element mesh is a set of triangles defining a two-dimensional region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotFEM.mesh(pts, tri, xlabel="x", ylabel="y", xlim=plim1, ylim=plim2, 
               shift=0.05, nonum=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotFEM.mesh_+3A_pts">pts</code></td>
<td>
<p>A two-column matrix of the locations of the vertices of the mesh.</p>
</td></tr>
<tr><td><code id="plotFEM.mesh_+3A_tri">tri</code></td>
<td>

<p>A three-column matrix of the indices in <code>pts</code> of the triangle vertices.
</p>
</td></tr>
<tr><td><code id="plotFEM.mesh_+3A_xlabel">xlabel</code></td>
<td>
<p>A character string for the label of the abscissa or horizontal axis.</p>
</td></tr>
<tr><td><code id="plotFEM.mesh_+3A_ylabel">ylabel</code></td>
<td>
<p>A character string for the label of the ordinate or vertical axis.</p>
</td></tr>
<tr><td><code id="plotFEM.mesh_+3A_xlim">xlim</code></td>
<td>
<p>A vector of length 2 containing the left and right plotting limits, 
respectively.</p>
</td></tr>
<tr><td><code id="plotFEM.mesh_+3A_ylim">ylim</code></td>
<td>
<p>A vector of length 2 containing the bottom and plot plotting limits, 
respectively.</p>
</td></tr>
<tr><td><code id="plotFEM.mesh_+3A_shift">shift</code></td>
<td>
<p>A lateral character shift for text plotting.</p>
</td></tr>
<tr><td><code id="plotFEM.mesh_+3A_nonum">nonum</code></td>
<td>
<p>A logical constant.  If FALSE, numbers for nodes and triangles will
not be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The nodes and mesh lines are plotted.  The number of each node and triangle 
is plotted, with node numbers in black and triangle number in blue.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotFEM.fd">plotFEM.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Set up and plot a square with side length one with 32 interior triangles,
#  and then create an order one functional basis object of type FEM.
m &lt;- 4
petList &lt;- squareMesh(m)
pts &lt;- petList$p
edg &lt;- petList$e
tri &lt;- petList$t
pts &lt;- pts/m
plotFEM.mesh(pts, tri)
</code></pre>

<hr>
<h2 id='randomFEMpts'>
Generate Random Locations in a Mesh with a Specified Density 
</h2><span id='topic+randomFEMpts'></span>

<h3>Description</h3>

<p>The probability that a random location is assigned to a triangle
is defined by an input vector of probabilities, one per triangle.
But if DensityVec = 1, any location within the mesh is accepted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  randomFEMpts(Nsample, pts, tri, logDensityVec=rep(0,ntri))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomFEMpts_+3A_nsample">Nsample</code></td>
<td>
<p>The number of random locations to be generated.</p>
</td></tr>
<tr><td><code id="randomFEMpts_+3A_pts">pts</code></td>
<td>
<p>A two-column matrix of locations of nodes.</p>
</td></tr>
<tr><td><code id="randomFEMpts_+3A_tri">tri</code></td>
<td>
<p>A three-column matrix of integers specifying the
vertices of triangles in anti-clockwise order.</p>
</td></tr>
<tr><td><code id="randomFEMpts_+3A_logdensityvec">logDensityVec</code></td>
<td>
<p>A one-column matrix of log probability density values, 
one for each triangle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within triangles, the locations are uniformly distributed.
If DensityVec = 1, they are uniformly distributed over the whole mesh.
</p>


<h3>Value</h3>

<p>A two-column matrix with <code>N</code> rows specifying the locations
of the random points.
</p>


<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code>link{plotFEM.mesh}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  ---------  density on right triangle  --------------
#  Define the locations of the vertices of the right triangle
pts  &lt;- matrix(c(0,0, 1,0, 0,1), 3, 2, byrow=TRUE)
npts &lt;- dim(pts)[1]
#  Specify the single triangle defined by these vertices.
#  The vertices are listed in counter-clockwise order
tri  &lt;- matrix(c(1,2,3),1,3)
ntri &lt;- dim(tri)[1]
#  Set up the FEM basis object for this region
edg &lt;- NULL
RtTriBasis &lt;- create.FEM.basis(pts, edg, tri, 1)
#  List object containing details of nodes.
nodeList &lt;- makenodes(pts,tri,1)
#  number of random points required
Nsample &lt;- 100
#  generate random points ... define the function
obspts &lt;- randomFEMpts(Nsample, pts, tri)
#  plot the random points
plotFEM.mesh(pts, tri)
points(obspts[,1],obspts[,2])
#  -----------------  density on a circle  ---------------
angle = seq(0,11*pi/6,len=12)
#  define the 24 point locations
rad = 2
ctr = c(0,0)
pts  = matrix(0,25,2);
pts[ 1:12,1] = rad*cos(angle)   + ctr[1]
pts[ 1:12,2] = rad*sin(angle)   + ctr[2]
pts[13:24,1] = rad*cos(angle)/2 + ctr[1]
pts[13:24,2] = rad*sin(angle)/2 + ctr[2]
#  define the edge indices
edg &lt;- matrix(0,12,2)
for (i in 1:11) {
  edg[i,1] &lt;- i
  edg[i,2] &lt;- i+1
}
edg[12,] &lt;- c(12,1)
#  use delaunay triangulation to define the triangles
tri = delaunayn(pts)
#  plot the triangulation of the circle
plotFEM.mesh(pts, tri, xlim=c(-2,2), ylim=c(-2,2))
#  Define the true log density function
SinCosIntensFn &lt;- function(x,y) {
  return(sin(pi*x/2)*cos(pi*y/2))
}
#  locate observation points with sin*cos log density
intDensityVec &lt;- triDensity(pts, tri, SinCosIntensFn)
#  number of random points required
Nsample &lt;- 100
#  generate random points ... define the function
obspts &lt;- randomFEMpts(Nsample, pts, tri, intDensityVec)
points(obspts[,1], obspts[,2], pch="o")
</code></pre>

<hr>
<h2 id='smooth.FEM.basis'>
Construct a functional data object by smoothing spatial data distributed over
a region with a complicated boundary using a roughness penalty.
</h2><span id='topic+smooth.FEM.basis'></span>

<h3>Description</h3>

<p>Discrete observations of a surface are fit with a smooth  surface defined by
an expansion in a set of FEM type basis functions.  The fitting criterion is
weighted least squares, and smoothness can be defined in terms of a roughness
penalty.
</p>
<p>Data smoothing requires at a bare minimum three elements: (1) a set of
observed noisy values, (b) a set of argument values associated with these
data, and (c) a basis function system used to define the surfaces.
</p>
<p>Optionally, a set covariates may be also used to take account of
various non-smooth contributions to the data.  Smoothing without
covariates is often called nonparametric regression, and with
covariates is termed semiparametric regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  smooth.FEM.basis(FEMloc, FEMdata, FEMbasis, lambda=1e-12, wtvec=NULL,
                  covariates=NULL, Laplace=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.FEM.basis_+3A_femloc">FEMloc</code></td>
<td>

<p>A matrix with two columns containing the coordinates of the points
where the data are observed.
</p>
</td></tr>
<tr><td><code id="smooth.FEM.basis_+3A_femdata">FEMdata</code></td>
<td>
<p>If a single surface, column vector containing the values to be 
smoothed.  Otherwise, a matrix of observation values that is number of pts by    
number of surfaces.</p>
</td></tr>
<tr><td><code id="smooth.FEM.basis_+3A_fembasis">FEMbasis</code></td>
<td>

<p>Either (1) a functional basis object of the <code>FEM</code> type if the first
argument contains the X-coordinates, or, if the first argument is a matrix
with three columns, an <code>N</code> by <code>q</code> matrix of covariate values,
where <code>N</code> is the number of observations and <code>q</code> is the number of
covariates.
</p>
</td></tr>
<tr><td><code id="smooth.FEM.basis_+3A_lambda">lambda</code></td>
<td>

<p>Either (1) a nonnegative smoothing parameter value that controls the amount
of penalty on the curvature of the fitted surface, or (2) a vector of
weights for the observations.  The default value for <code>lambda</code> is
1e-12, a value too small to noticeably affect the curvature of the fitted
surface, but large enough to ensure nonsingularity in the equations
defining the coefficients of the basis function expansion.
</p>
</td></tr>
<tr><td><code id="smooth.FEM.basis_+3A_wtvec">wtvec</code></td>
<td>

<p>a vector of length <code>N</code> that is the length of <code>Xvec</code>
containing weights for the values to be smoothed, However, it may also
be a symmetric matrix of order <code>n</code>.   <code>wt</code> defaults to all weights
equal to 1.
</p>
</td></tr>
<tr><td><code id="smooth.FEM.basis_+3A_covariates">covariates</code></td>
<td>

<p>An <code>N</code> by <code>q</code> matrix of covariate values, one for each covariate
and each observed value.  By default this argument is NULL and no covariates
are used to define the surface.
</p>
</td></tr>
<tr><td><code id="smooth.FEM.basis_+3A_laplace">Laplace</code></td>
<td>
<p>If TRUE, the Laplacian surface is computed, otherwise not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The surface fitted to the data by <code>smooth.FEM.basis</code> is an expansion
in terms of finite element basis functions defined by a triangular mesh of
points defining the region over which the smooth is defined.  The mesh also
determines the location and shape of the basis functions.  The mesh therefore
plays a role that is like that of knots for B-spline basis functions, but
is perhaps even more critical to the success of the smoothing process.
</p>
<p>Designing and refining the mesh is therefore a preliminary step in finite
element smoothing, and requires considerable care and effort.  Consult the
help pages for <code>MESH</code> and <code>create.FEM.basis</code> for more details.
</p>
<p>A roughness penalty is a quantitative measure of the roughness of a
surface that is designed to fit the data.  For this function, this penalty
consists of the product of two parts.  The first is an approximate integral
over the argument range of the square of a derivative of the surface.  A
typical choice of derivative order is 2, whose square is often called
the local curvature of the function.  Since a rough function has high
curvature over most of the function's range, the integrated square of
of the second derivative quantifies the total curvature of the function,
and hence its roughness.  The second factor is a positive constant called
the bandwidth of smoothing parameter, and given the variable name
<code>lambda</code> here.
</p>
<p>The roughness penalty is added to the weighted error sum of squares
and the composite is minimized, usually in conjunction with a
high dimensional basis expansion such as a spline function defined by
placing a knot at every observation point.  Consequently, the
smoothing parameter controls the relative emphasis placed on fitting
the data versus smoothness; when large, the fitted surface is more smooth,
but the data fit worse, and when small, the fitted surface is more rough,
but the data fit much better. Typically smoothing parameter <code>lambda</code>
is manipulated on a logarithmic scale by, for example, defining it
as a power of 10.
</p>
<p>A good compromise <code>lambda</code> value can be difficult to
define, and minimizing the generalized cross-validation or &quot;gcv&quot;
criterion that is output by <code>smooth.FEM.basis</code> is a popular strategy
for making this choice, although by no means foolproof.  One may also
explore <code>lambda</code> values for a few log units up and down from this
minimizing value to see what the smoothing function and its derivatives
look like.  The function <code>plotfit.fd</code> was designed for this purpose.
</p>
<p>The size of common logarithm of the minimizing value of <code>lambda</code>
can vary widely, and spline functions depends critically on the typical
spacing between knots.  While there is typically a &quot;natural&quot; measurement
scale for the argument, such as time in milliseconds, seconds, and so
forth, it is better from a computational perspective to choose an
argument scaling that gives knot spacings not too different from one.
</p>


<h3>Value</h3>

<p>an object of class <code>fdSmooth</code>, which is a named list of length 8
with the following components:
</p>
<table role = "presentation">
<tr><td><code>fd</code></td>
<td>

<p>an FEM functional data object containing a smooth of the data
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>a degrees of freedom measure of the smooth
</p>
</td></tr>
<tr><td><code>gcv</code></td>
<td>

<p>the value of the generalized cross-validation or GCV criterion.  If
there are multiple surfaces, this is a vector of values, one per
surface.  If the smooth is multivariate, the result is a matrix of gcv
values, with columns corresponding to variables.
</p>
<p style="text-align: center;"><code class="reqn">gcv = n*SSE/((n-df)^2)</code>
</p>

</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>the regression coefficients associated with covariate variables.
These are vector, matrix or array objects depending on whether
there is a single surface, multiple surfaces or multiple surfaces and
variables, respectively.
</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>

<p>the error sums of squares.  SSE is a vector or a matrix of the same
size as GCV.
</p>
</td></tr>
<tr><td><code>penmat</code></td>
<td>

<p>the penalty matrix
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>,
<code><a href="fda.html#topic+lambda2df">lambda2df</a></code>,
<code><a href="fda.html#topic+lambda2gcv">lambda2gcv</a></code>,
<code><a href="fda.html#topic+df2lambda">df2lambda</a></code>,
<code><a href="#topic+plotFEM.fd">plotFEM.fd</a></code>,
<code><a href="#topic+plotFEM.mesh">plotFEM.mesh</a></code>,
<code><a href="#topic+smooth.FEM.basis">smooth.FEM.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  ----------------------------------------------------------------------------
#  Example 1:  smoothing data over a circular region
#  ----------------------------------------------------------------------------
#  Set up a FEM object with a approximatedly circular boundary with 12 sides,
#  and two rings of 12 points plus a point at the centre.
angle = seq(0,11*pi/6,len=12)
#  define the 24 point locations
rad = 2
ctr = c(0,0)
pts  = matrix(0,25,2)
pts[ 1:12,1] = rad*cos(angle)   + ctr[1]
pts[ 1:12,2] = rad*sin(angle)   + ctr[2]
pts[13:24,1] = rad*cos(angle)/2 + ctr[1]
pts[13:24,2] = rad*sin(angle)/2 + ctr[2]
npts = nrow(pts)
#  define the edge indices
edg &lt;- matrix(0,12,2)
for (i in 1:11) {
  edg[i,1] &lt;- i
  edg[i,2] &lt;- i+1
}
edg[12,] &lt;- c(12,1)
#  use delaunay triangulation to define the triangles
#  These geometry and RTriangle packages give different but legitimate answers
tri_GM &lt;- geometry::delaunayn(pts)
plotFEM.mesh(pts, tri_GM, nonum=FALSE, shift = 0.1)
FEMbasis_GM &lt;- create.FEM.basis(pts, edg, tri_GM, 1)
ntri &lt;- nrow(tri_GM)
#  plot the two meshes
plotFEM.mesh(pts, tri_GM, nonum=FALSE, shift = 0.1)
title("A 25-point circular mesh from geometry")
#  set up the FEM basis objects
FEMbasis_GM &lt;- create.FEM.basis(pts, edg, tri_GM, 1)
#  locations of locations and data  (kept same for both triangulations)
nobs &lt;- 201
FEMloc &lt;- randomFEMpts(nobs, pts, tri_GM)
#  heights of a hemisphere at these locations (kept same for both triangulations)
sig &lt;- 0.2
FEMdata &lt;- sqrt(4 - FEMloc[,1]^2 - FEMloc[,2]^2) + 
  matrix(rnorm(nobs),nobs,1)*sig
#  Smooth the data 
FEMList_GM &lt;- smooth.FEM.basis(FEMloc, FEMdata, FEMbasis_GM, lambda=1)
FEMfd_GM &lt;- FEMList_GM$fd
round(FEMList_GM$SSE,3)
round(FEMList_GM$df,3)
Xgrid = seq(-2,2,len=21)
Ygrid = seq(-2,2,len=21)
#  plot the result
plotFEM.fd(FEMfd_GM, Xgrid, Ygrid, 
          main="A hemisphere over a 25-point circle")
</code></pre>

<hr>
<h2 id='smooth.FEM.density'>Compute a smooth FEM density surface of a triangulated region.</h2><span id='topic+smooth.FEM.density'></span>

<h3>Description</h3>

<p>A spatial density defined over a region with complicated a boundary that is
defined by a triangulation is estimated.  The basis functions are linear
finite elements (FEM) defined at each vertex.
The data are the spatial coordinates of a sample of a defined spatial event.
The density surface is the logarithm of the density, and the smoothness of
the log surface is controlled by a smoothing parameter <code>lambda</code>
multiplying the stiffness matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.FEM.density(obspts, cvec, FEMbasis, K1=NULL, lambda=0,
                 conv=1e-4, iterlim=50, dbglev=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.FEM.density_+3A_obspts">obspts</code></td>
<td>
<p>A two-column matrix with each row corresponding to a location within
a two-dimensional region bounded by line segments and containing a triangular
mesh.</p>
</td></tr>
<tr><td><code id="smooth.FEM.density_+3A_cvec">cvec</code></td>
<td>
<p>A matrix each column of which contains the coefficients
for an FEM basis function expansion of a surface.
The number of coefficients equals the number of vertices in the
triangulation, also called the nodes of the FEM expansion.</p>
</td></tr>
<tr><td><code id="smooth.FEM.density_+3A_fembasis">FEMbasis</code></td>
<td>
<p>This argument provides the FEM basis (class <code>basisfd</code>),
and may be in the form of an FEM basis object, an FEM function object
(class <code>fd</code>), or an FEM functional parameter object
(class <code>fdPar</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.density_+3A_k1">K1</code></td>
<td>
<p>The stiffness matrix associated with the triangulation.
It is computed using function <code>stiff.FEM</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.density_+3A_lambda">lambda</code></td>
<td>
<p>A non-negative real number controlling the smoothness
of the surface by a roughness penalty consisting of <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.density_+3A_conv">conv</code></td>
<td>
<p>The convergence criterion using the function value.</p>
</td></tr>
<tr><td><code id="smooth.FEM.density_+3A_iterlim">iterlim</code></td>
<td>
<p>The maximum number of permitted iterations.</p>
</td></tr>
<tr><td><code id="smooth.FEM.density_+3A_dbglev">dbglev</code></td>
<td>
<p>print debugging output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The penalized log likelihood of a density surface is minimized with  respect to
the coefficient vector. with the initial value in <code>cvec</code>.
The spatial event locations are in the two-column matrix <code>pts</code>.
The FEM basis object is extracted from <code>IntensityfdPar</code>, which may
also be an FEM functional data object or an FEM basis object.
The roughness penalty, if required, is the stiff matrix <code>K1</code>
multiplied by the roughness parameter <code>lambda.</code></p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cvec:</code></td>
<td>
<p>The final coefficient vector or matrix.</p>
</td></tr>
<tr><td><code>Intensityfd:</code></td>
<td>
<p>An FEM functional data object for the log density.</p>
</td></tr>
<tr><td><code>Flist:</code></td>
<td>
<p>A list object with <code>F</code> the final penalized log likelihood
value, <code>grad</code> the final gradient and <code>norm</code> the final norm of the
gradient.</p>
</td></tr>
<tr><td><code>iterhist:</code></td>
<td>
<p>A matrix with three columns displaying the iteration number,
the function value and the norm of the gradient vector for the initial
iteration and each subsequent iteration.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code>link{FEMdensity}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  ---------  Density on right triangle  --------------

#  Define the locations of the vertices of the right triangle
pts &lt;- matrix(c(0,0, 1,0, 0,1), 3, 2, byrow=TRUE)
npts &lt;- dim(pts)[1]
#  Specify the single triangle defined by these vertices.
#  The vertices are listed in counter-clockwise order
tri  &lt;- matrix(c(1,2,3),1,3)
ntri &lt;- dim(tri)[1]
#  Set up the FEM basis object for this region
RtTriBasis &lt;- create.FEM.basis(pts, NULL, tri, 1)
plotFEM.mesh(pts, tri, RtTriBasis)
#  List object containing details of nodes.
nodeList &lt;- makenodes(pts,tri,1)
K1 &lt;- stiff.FEM(RtTriBasis)
#  Define the true log density, which is flat with height 0
ZeroFn &lt;- function(x,y) {
  xdim &lt;- dim(x)
  ZeroIntens &lt;- matrix(0,xdim[1],xdim[1])
  return(ZeroIntens)
}
#  Compute of probabilities for each triangle of having a
#  location withinx it.
intDensityVec &lt;- triDensity(pts, tri, ZeroFn)
#  number of random points required
N &lt;- 100
#  generate random points ... define the function
obspts &lt;- randomFEMpts(N, pts, tri, intDensityVec)
#  plot the random points
points(obspts[,1],obspts[,2])
#  Define a starting value for the coefficient vector of length 3
cvec &lt;- matrix(0,npts,1)
#  Estimate the smooth density surface with no smoothing
densityList &lt;- smooth.FEM.density(obspts, cvec, RtTriBasis, dbglev=2, iterlim=10)
#  The estimate of the coefficient vector
cvec &lt;- densityList$cvec
#  Define the log density FEM functional data object
lnlamfd  &lt;- fd(cvec,  RtTriBasis)
#  Plot the log density surface 
Xgrid &lt;- seq(0,1,len=51)
Ygrid &lt;- Xgrid
plotFEM.fd(lnlamfd, Xgrid, Ygrid)
#  Plot the log density surface
plotFEM.fd(lnlamfd, Xgrid, Ygrid)
#  Plot the log density surface using function contour
logdensitymat &lt;- matrix(0,51,51)
for (i in 1:51) {
  for (j in 1:51) {
    logdensitymat[i,j] &lt;- eval.FEM.fd(matrix(c(Xgrid[i],Ygrid[j]),1,2),lnlamfd)
  }
}
contour(Xgrid, Ygrid, logdensitymat)
#  Plot the density surface using function contour
densitymat &lt;- matrix(0,51,51)
for (i in 1:51) {
  for (j in 1:51) {
    densitymat[i,j] &lt;- exp(eval.FEM.fd(matrix(c(Xgrid[i],Ygrid[j]),1,2),lnlamfd))
  }
}
contour(Xgrid, Ygrid, densitymat)

#  ---------- density on a unit square,  4 triangles, 5 vertices  ----------

#  Generate a unit square with a node in its center defining four
#  triangles and five nodes.
result &lt;- squareMesh(1)
pts    &lt;- result$p
edg    &lt;- result$e
tri    &lt;- result$t
npts   &lt;- dim(pts)[1]
ntri   &lt;- dim(tri)[1]
#  Compute a sine*cosine intensity surface.
SinCosIntensFn &lt;- function(x,y) {
  return(sin(2*pi*x)*cos(2*pi*y))
}
logDensityVec &lt;- triDensity(pts, tri, SinCosIntensFn)
#  Set up and plot an FEM basis object
par(cex.lab=2)
SquareBasis1 &lt;- create.FEM.basis(pts, edg, tri)
plotFEM.mesh(pts, tri)
#  generate random points
N = 100
obspts &lt;- randomFEMpts(N, pts, tri, logDensityVec)
#  plot the random points
points(obspts[,1],obspts[,2])
#  Estimate the smooth density surface with light smoothing
order &lt;- 1
nodeList &lt;- makenodes(pts,tri,order)
K1 &lt;- stiff.FEM(SquareBasis1)
lambda &lt;- 1e-4
#  define a random coefficient vector
cvec  &lt;- matrix(0,npts,1)
#  Estimate the smooth density surface with no smoothing
densityList &lt;- smooth.FEM.density(obspts, cvec, SquareBasis1, dbglev=2, iterlim=10)
#  The estimate of the coefficient vector
cvec &lt;- densityList$cvec
#  Define the log density FEM functional data object
lnlamfd  &lt;- fd(cvec,  SquareBasis1)
#  Plot the log density surface 
Xgrid &lt;- seq(0,1,len=51)
Ygrid &lt;- Xgrid
plotFEM.fd(lnlamfd, Xgrid, Ygrid)
#  Plot the log density surface
plotFEM.fd(lnlamfd, Xgrid, Ygrid)
#  Plot the log density surface using function contour
logdensitymat &lt;- matrix(0,51,51)
for (i in 1:51) {
  for (j in 1:51) {
    logdensitymat[i,j] &lt;- eval.FEM.fd(matrix(c(Xgrid[i],Ygrid[j]),1,2),lnlamfd)
  }
}
contour(Xgrid, Ygrid, logdensitymat)
#  Plot the density surface using function contour
densitymat &lt;- matrix(0,51,51)
for (i in 1:51) {
  for (j in 1:51) {
    densitymat[i,j] &lt;- exp(eval.FEM.fd(matrix(c(Xgrid[i],Ygrid[j]),1,2),lnlamfd))
  }
}
contour(Xgrid, Ygrid, densitymat)
</code></pre>

<hr>
<h2 id='squareMesh'>
Generate a Triangulation of a Square.
</h2><span id='topic+squareMesh'></span>

<h3>Description</h3>

<p>The square is subdivided into <code>m</code> internal squares.  
Within each internal square nodes are set at the corners and the middle.  
Each square is thus subdivided into four triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  squareMesh(m=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="squareMesh_+3A_m">m</code></td>
<td>
<p>The number of squares within the outer square.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outer square has sides of length <code>m</code>.  If another length $x &gt; 0$ of the side
is required, this can easily be achieved by the command <code>p = p*x/m</code>.
</p>


<h3>Value</h3>

<p>A named list containing locations of nodes and which nodes define
the edge segments and the triangles.  The members are:
</p>

<ul>
<li><p>p: A two-column matrix specifying the nodes of the mesh. 
</p>
</li>
<li><p>e: A two-column matrix of integers specifying which nodes define 
each edge segment. 
</p>
</li>
<li><p>t: A three-column matrix of integers specifying which nodes
define each triangle in anti-clockwise order.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code>link{plotFEM.mesh}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 3
#  A square of size 3 with 9 internal squares, 
#  25 nodes, 12 edge segments and 36 triangles.
result = squareMesh(m)
pts    = result$pts
edg    = result$edg
tri    = result$tri
#  plot the mesh
plotFEM.mesh(pts,tri)
</code></pre>

<hr>
<h2 id='squareMesh_RL'>
Generate a Triangulation of a Square.
</h2><span id='topic+squareMesh_RL'></span>

<h3>Description</h3>

<p>The square is subdivided into <code>m</code> internal squares.  Within each internal square,
nodes are set at the corners.  Each square is subdivided into two triangles by a 
line either going from lower left to upper right if <code>orientation="L"</code>, of by
a line from lower right to upper left is <code>orientation="R"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  squareMesh_RL(m=1,orientation="L")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="squareMesh_RL_+3A_m">m</code></td>
<td>
<p>The number of squares within the outer square.</p>
</td></tr>
<tr><td><code id="squareMesh_RL_+3A_orientation">orientation</code></td>
<td>
<p>The position of the lower corner of the diagonal line
subdividing each square.  This must be either <code>"L"</code> or <code>"R"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outer square has sides of length <code>m</code>.  If another length $x &gt; 0$ of the side
is required, this can easily be achieved by the command <code>p = p*x/m</code>.
</p>


<h3>Value</h3>

<p>A named list containing locations of nodes and which nodes define
the edge segments and the triangles.  The members are:
</p>

<ul>
<li><p>p: A two-column matrix specifying the nodes of the mesh. 
</p>
</li>
<li><p>e: A two-column matrix of integers specifying which nodes define 
each edge segment. 
</p>
</li>
<li><p>t: A three-column matrix of integers specifying which nodes
define each triangle in anti-clockwise order.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code>link{plotFEM.mesh}</code>
</p>

<hr>
<h2 id='stiff.FEM'>
Compute the stiffness matrix for a finite element basis.
</h2><span id='topic+stiff.FEM'></span>

<h3>Description</h3>

<p>stiff.FEM produces the stiffness matrix containing integrals of products of
second partial derivatives of the nodal functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stiff.FEM(FEMbasis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stiff.FEM_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A List object produced by function <code>create.FEM.basis</code>.
It contains:
</p>

<ul>
<li><p>orderThe order of the element (1 or 2).
</p>
</li>
<li><p>nodesCoordinates of node points.
</p>
</li>
<li><p>nodeindexIndices of node points for each element.
</p>
</li>
<li><p>jvecjacobian of the affine transformation of each
element to the master element.
</p>
</li></ul>

</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code>K0</code>: the <code>NNOD</code> by <code>NNOD</code> matrix of sums
of products of nodal basis functions.
For each element i, the integral of the product
of the j'th and k'th second partial derivatives of the
shape functions over the i'th element is computed.  Then that value 
is the <code>(nodeindex[i,j],nodeindex[i,k])</code>th entry of the i'th 
elemental stiff matrix.
</p>


<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mass.FEM">mass.FEM</a></code>
</p>

<hr>
<h2 id='tricoefCal'>
Compute the coefficient matrix required to test of a point
is inside a triangle.
</h2><span id='topic+tricoefCal'></span>

<h3>Description</h3>

<p>Compute the coefficient matrix <code>tricoef</code> required to test
if a point is inside a triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tricoefCal(pts, tri)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tricoefCal_+3A_pts">pts</code></td>
<td>

<p>A two-column matrix of the locations of the vertices of the mesh.
</p>
</td></tr>
<tr><td><code id="tricoefCal_+3A_tri">tri</code></td>
<td>

<p>A three-column matrix of the indices in <code>pts</code> of the triangle vertices.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code>tricoef</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+insideIndex">insideIndex</a></code>
</p>

<hr>
<h2 id='triDensity'>
Compute the probabilities that a random location will be within one of the triangles of an
FEM mesh.
</h2><span id='topic+triDensity'></span>

<h3>Description</h3>

<p>Given a function defining a log-density surface for an FEM density, compute the
probabilities that a random location will be within each of the triangles of an
FEM mesh.  This involves numerical quadrature over each rectangle, and
<code>nquad</code> is the order of approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triDensity(pts, tri, logIntensFn, nquad=5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triDensity_+3A_pts">pts</code></td>
<td>
<p>A two-column matrix with each row corresponding to a location within
a two-dimensional region bounded by line segments and containing a triangular
mesh.</p>
</td></tr>
<tr><td><code id="triDensity_+3A_tri">tri</code></td>
<td>
<p>A three-column matrix indexing for each triangle its vertices.</p>
</td></tr>
<tr><td><code id="triDensity_+3A_logintensfn">logIntensFn</code></td>
<td>
<p>A function of <code>x</code> and <code>y</code> giving the surface height
for an unnormalized log density function.  It must return a square matrix
of order equal to <code>nquad</code>.  This implies that any multiplications
must be pointwise.</p>
</td></tr>
<tr><td><code id="triDensity_+3A_nquad">nquad</code></td>
<td>
<p>The order of the quadrature over a triangle.  The default order
of five is good for most applications.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length equal to the number of triangles in a mesh containing the
probabilities that a random observation will fall within the triangles.</p>


<h3>Author(s)</h3>

<p>Jim Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
Journal of the Royal Statistical Society, Series B, 75, 681-703.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.FEM.density">smooth.FEM.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  ---------  right triangle mesh  with zero log density --------------
#  Define the locations of the vertices of the right triangle
pts  &lt;- matrix(c(0,0, 1,0, 0,1), 3, 2, byrow=TRUE)
npts &lt;- dim(pts)[1]
#  Specify the single triangle defined by these vertices.
#  The vertices are listed in counter-clockwise order
tri  &lt;- matrix(c(1,2,3),1,3)
ntri &lt;- dim(tri)[1]
#  Set up the FEM basis object for this region
edg &lt;- NULL
RtTriBasis &lt;- create.FEM.basis(pts, edg, tri, 1)
#  set up function to provide log intensity zero
ZeroFn &lt;- function(x,y) {
  xdim &lt;- dim(x)
  ZeroIntens &lt;- matrix(0,xdim[1],xdim[1])
  return(ZeroIntens)
}
#  Define the true log density, which is flat with height 0
intDensityVec &lt;- triDensity(pts, tri, ZeroFn)
#  ---------  square mesh with sin*cos log density  --------------
nsquare &lt;- 3
result &lt;- squareMesh(nsquare)
pts &lt;- result$p
tri &lt;- result$t
pts &lt;- pts/nsquare
#  Set up and plot an FEM basis object
edge &lt;- NULL
SquareBasis3 &lt;- create.FEM.basis(pts, edg, tri)
plotFEM.mesh(pts, tri)
#  set up function to provide log intensity sine*cosine
SinCosIntensFn &lt;- function(x,y) {
  scale &lt;- 1
  SinCosIntens &lt;- scale*sin(2*pi*x)*cos(2*pi*y)
  return(SinCosIntens)
}
#  Computation of probabilities for each triangle of having a
#  location within it.
intDensityVec &lt;- triDensity(pts, tri, SinCosIntensFn)
#  Display triangle numbers with probabilities
print(cbind(matrix(1:ntri,ntri,1), round(intDensityVec,3)))
</code></pre>

<hr>
<h2 id='triquad'>
Set up Gaussian quadrature points and weights for a triangular domain.
</h2><span id='topic+triquad'></span>

<h3>Description</h3>

<p>The integral of a function over a triangle is approximated by a weighted sum
of the values of the function at a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  triquad(nquad, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triquad_+3A_nquad">nquad</code></td>
<td>
<p>The number of quadrature points and weights is $N^2$.</p>
</td></tr>
<tr><td><code id="triquad_+3A_v">v</code></td>
<td>
<p>A matrix with three rows and two columns containing the locations
of the vertices of the triangle.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gaussian quadrature approximates an integral of a function $f$ over a
triangle by a weighted sum of $N^2$ values of $f$ at specified points
within the triangle.  The larger <code>N</code>, the more accurate the
approximation, but course the longer it takes to compute.  For many
purposes, including  most uses of finite element methods, the accuracy
does not have to be great, and <code>N=5</code> may well suffice
</p>


<h3>Value</h3>

<p>A list object containing these named fields:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>The X-coordinates of the quadrature points.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>The Y-coordinates of the quadrature points.</p>
</td></tr>
<tr><td><code>Wx</code></td>
<td>
<p>The weights for the X-coordinates of the quadrature points.</p>
</td></tr>
<tr><td><code>Wy</code></td>
<td>
<p>The weights for the Y-coordinates of the quadrature points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. O. Ramsay
</p>


<h3>References</h3>

<p>Sangalli, Laura M., Ramsay, James O., Ramsay, Timothy O. (2013),
Spatial spline regression models,
<em>Journal of the Royal Statistical Society, Series B</em>, 75, 681-703.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
