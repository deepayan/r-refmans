<!DOCTYPE html><html><head><title>Help for package packcircles</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {packcircles}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bacteria'><p>Abundance of bacteria</p></a></li>
<li><a href='#circleGraphLayout'><p>Find an arrangement of circles satisfying a graph of adjacencies</p></a></li>
<li><a href='#circleLayout'><p>Arranges circles by iterative pair-wise repulsion within a bounding rectangle</p></a></li>
<li><a href='#circleLayoutVertices'><p>Generate a set of circle vertices suitable for plotting</p></a></li>
<li><a href='#circlePlotData'><p>Generate a set of circle vertices suitable for plotting</p></a></li>
<li><a href='#circleProgressiveLayout'><p>Progressive layout algorithm</p></a></li>
<li><a href='#circleRemoveOverlaps'><p>Filters a set of circles to remove all overlaps</p></a></li>
<li><a href='#circleRepelLayout'><p>Arranges circles by iterative pair-wise repulsion within a bounding rectangle</p></a></li>
<li><a href='#circleVertices'><p>Generate vertex coordinates for a circle</p></a></li>
<li><a href='#packcircles-package'><p>packcircles: Simple algorithms for circle packing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.6</td>
</tr>
<tr>
<td>Title:</td>
<td>Circle Packing</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms to find arrangements of non-overlapping circles.</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-05</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mbedward/packcircles">https://github.com/mbedward/packcircles</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mbedward/packcircles/issues">https://github.com/mbedward/packcircles/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggiraph (&ge; 0.8.4), ggplot2, knitr, rmarkdown, lpSolve</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-08 01:27:44 UTC; mbedward</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Bedward [aut, cre],
  David Eppstein [aut] (Author of Python code for graph-based circle
    packing ported to C++ for this package),
  Peter Menzel [aut] (Author of C code for progressive circle packing
    ported to C++ for this package)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Bedward &lt;michael.bedward@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-08 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bacteria'>Abundance of bacteria</h2><span id='topic+bacteria'></span>

<h3>Description</h3>

<p>Names and abundances of bacterial taxa as measured in a study of biofilms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bacteria
</code></pre>


<h3>Format</h3>

<p>## 'bacteria'
A data frame with 167 rows and 3 columns:
</p>

<dl>
<dt>value</dt><dd><p>measured abundance</p>
</dd>
<dt>colour</dt><dd><p>preferred colour for display</p>
</dd>
<dt>label</dt><dd><p>taxon name</p>
</dd>
</dl>


<hr>
<h2 id='circleGraphLayout'>Find an arrangement of circles satisfying a graph of adjacencies</h2><span id='topic+circleGraphLayout'></span>

<h3>Description</h3>

<p>Attempts to derive an arrangement of circles satisfying prior conditions for 
size and adjacency. Unlike the <code><a href="#topic+circleRepelLayout">circleRepelLayout</a></code> function, this
is a deterministic algorithm. Circles are classified as either internal or 
external. Viewing the pattern of adjacencies as a triangulated mesh, external
circles are those on the boundary. In the version of the algorithm 
implemented here, the radii of external circles are provided as inputs, while
the radii of internal circles are derived as part of the output arrangement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleGraphLayout(internal, external)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleGraphLayout_+3A_internal">internal</code></td>
<td>
<p>A list of vectors of circle ID values where, in each vector,
the first element is the ID of an internal circle and the remaining
elements are the IDs of that circle's neighbours arranged as a cycle. The
cycle may be clockwise or anti-clockwise but the same ordering must be used
for all vectors.</p>
</td></tr>
<tr><td><code id="circleGraphLayout_+3A_external">external</code></td>
<td>
<p>A data.frame or matrix of external circle radii, with circle
IDs in the first column and radii in the second column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>internal</code> argument specifies circle adjacencies (ie. tangencies). 
The format is an concise representation of graph edges, and consists of a 
list of vectors: one per internal circle. In each vector the first element is
the ID value of the internal circle and the remaining values are IDs of 
neighbouring circles, which may be either internal or external.
</p>
<p>The <code>external</code> argument is a data.frame which specifies the radii of 
external circles. Internal circle radii should not be specified as they are 
derived as part of the fitting algorithm. The function will issue an error if
any internal circle IDs are present in the <code>external</code> data.
</p>


<h3>Value</h3>

<p>A data.frame with columns for circle ID, centre X and Y ordinate, and
radius.
</p>
<p>The output arrangement as a data.frame with columns for circle ID,
centre X and Y ordinates, and radius. For external circles the radius will
equal input values.
</p>


<h3>Note</h3>

<p>Please treat this function as experimental.
</p>


<h3>References</h3>

<p>C.R. Collins &amp; K. Stephenson (2003) An algorithm for circle
packing. Computational Geometry Theory and Applications 25:233-256.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple example with two internal circles surrounded by
## four external circles. Internal circle IDs are 1 and 2.
internal &lt;- list( c(1, 3, 4, 5), c(2, 3, 4, 6) )

## Uniform radius for external circles
external &lt;- data.frame(id=3:6, radius=1.0)

## Generate the circle packing
packing &lt;- circleGraphLayout(internal, external)

</code></pre>

<hr>
<h2 id='circleLayout'>Arranges circles by iterative pair-wise repulsion within a bounding rectangle</h2><span id='topic+circleLayout'></span>

<h3>Description</h3>

<p>This function is deprecated and will be removed in a future release. 
Please use <code><a href="#topic+circleRepelLayout">circleRepelLayout</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleLayout(xyr, xlim, ylim, maxiter = 1000, wrap = TRUE, weights = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleLayout_+3A_xyr">xyr</code></td>
<td>
<p>A 3-column matrix or data frame (centre X, centre Y, radius).</p>
</td></tr>
<tr><td><code id="circleLayout_+3A_xlim">xlim</code></td>
<td>
<p>The bounds in the X direction; either a vector for [xmin, xmax) 
or a single value interpreted as [0, xmax). Alternatively, omitting this 
argument or passing any of <code>NULL</code>, a vector of <code>NA</code> or an empty
vector will result in unbounded movement in the X direction.</p>
</td></tr>
<tr><td><code id="circleLayout_+3A_ylim">ylim</code></td>
<td>
<p>The bounds in the Y direction; either a vector for [ymin, ymax) 
or a single value interpreted as [0, ymax). Alternatively, omitting this 
argument or passing any of <code>NULL</code>, a vector of <code>NA</code> or an empty
vector will result in unbounded movement in the Y direction.</p>
</td></tr>
<tr><td><code id="circleLayout_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="circleLayout_+3A_wrap">wrap</code></td>
<td>
<p>Whether to treat the bounding rectangle as a toroid (default 
<code>TRUE</code>). When this is in effect, a circle leaving the bounds on one 
side re-enters on the opposite side.</p>
</td></tr>
<tr><td><code id="circleLayout_+3A_weights">weights</code></td>
<td>
<p>An optional vector of numeric weights (0 to 1 inclusive) to 
apply to the distance each circle moves during pair-repulsion. A weight of 
0 prevents any movement. A weight of 1 gives the default movement distance.
A single value can be supplied for uniform weights. A vector with length 
less than the number of circles will be silently extended by repeating the 
final value. Any values outside the range [0, 1] will be clamped to 0 or 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components: 
</p>
 
<dl>
<dt>layout</dt><dd><p>A 3-column matrix or data.frame (centre x, centre y, radius).</p>
</dd> 
<dt>niter</dt><dd><p>Number of iterations performed.</p>
</dd> 
</dl>



<h3>Note</h3>

<p>This function assumes that circle sizes are expressed as radii
whereas the default for <code>circleRepelLayout</code> is area.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circleRepelLayout">circleRepelLayout</a></code>
</p>

<hr>
<h2 id='circleLayoutVertices'>Generate a set of circle vertices suitable for plotting</h2><span id='topic+circleLayoutVertices'></span>

<h3>Description</h3>

<p>Given a matrix or data frame for a circle layout, with columns for centre x-y
coordinates and sizes, this function generates a data set of vertices which 
can then be used with ggplot or base graphics functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleLayoutVertices(
  layout,
  npoints = 25,
  xysizecols = 1:3,
  sizetype = c("radius", "area"),
  idcol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleLayoutVertices_+3A_layout">layout</code></td>
<td>
<p>A matrix or data.frame of circle data (x, y, size). May also 
contain other columns including an optional identifier column.</p>
</td></tr>
<tr><td><code id="circleLayoutVertices_+3A_npoints">npoints</code></td>
<td>
<p>The number of vertices to generate for each circle.</p>
</td></tr>
<tr><td><code id="circleLayoutVertices_+3A_xysizecols">xysizecols</code></td>
<td>
<p>The integer indices or names of columns for the centre X, 
centre Y and size values. Default is 'c(1,2,3)'.</p>
</td></tr>
<tr><td><code id="circleLayoutVertices_+3A_sizetype">sizetype</code></td>
<td>
<p>The type of size values: either <code>"radius"</code> (default) or 
<code>"area"</code>. May be abbreviated.</p>
</td></tr>
<tr><td><code id="circleLayoutVertices_+3A_idcol">idcol</code></td>
<td>
<p>Optional index or name of column for circle identifiers. These 
may be numeric or character but must be unique. If not provided, the output
circle IDs will be the row numbers of the input circle data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns: id, x, y; where id is the unique integer 
identifier for each circle.
</p>


<h3>Note</h3>

<p><strong>Input sizes are assumed to be radii</strong>. This is slightly confusing
because the layout functions <code>circleRepelLayout</code> and 
<code>circleProgressiveLayout</code> treat their input sizes as areas by default.
To be safe, you can always set the <code>sizetype</code> argument explicitly
for both this function and layout functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circleVertices">circleVertices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xmax &lt;- 100
ymax &lt;- 100
rmin &lt;- 10
rmax &lt;- 20
N &lt;- 20

## Random centre coordinates and radii
layout &lt;- data.frame(id = 1:N,
                     x = runif(N, 0, xmax), 
                     y = runif(N, 0, ymax), 
                     radius = runif(N, rmin, rmax))

## Get data for circle vertices
verts &lt;- circleLayoutVertices(layout, idcol=1, xysizecols=2:4,
                              sizetype = "radius")

## Not run: 
library(ggplot2)

## Draw circles annotated with their IDs
ggplot() + 
  geom_polygon(data = verts, aes(x, y, group = id), 
               fill = "grey90", 
               colour = "black") +
               
  geom_text(data = layout, aes(x, y, label = id)) + 
  
  coord_equal() +
  theme_bw()

## End(Not run)

</code></pre>

<hr>
<h2 id='circlePlotData'>Generate a set of circle vertices suitable for plotting</h2><span id='topic+circlePlotData'></span>

<h3>Description</h3>

<p>This function is deprecated and will be removed in a future release. 
Please use <code>circleLayoutVertices</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circlePlotData(layout, npoints = 25, xyr.cols = 1:3, id.col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circlePlotData_+3A_layout">layout</code></td>
<td>
<p>A matrix or data.frame of circle data (x, y, radius). May contain
other columns, including an optional ID column.</p>
</td></tr>
<tr><td><code id="circlePlotData_+3A_npoints">npoints</code></td>
<td>
<p>The number of vertices to generate for each circle.</p>
</td></tr>
<tr><td><code id="circlePlotData_+3A_xyr.cols">xyr.cols</code></td>
<td>
<p>Indices or names of columns for x, y, radius (in that order).
Default is columns 1-3.</p>
</td></tr>
<tr><td><code id="circlePlotData_+3A_id.col">id.col</code></td>
<td>
<p>Optional index or name of column for circle IDs in output. 
If not provided, the output circle IDs will be the row numbers of
the input circle data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns: id, x, y; where id is the unique
integer identifier for each circle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circleLayoutVertices">circleLayoutVertices</a></code> <code><a href="#topic+circleVertices">circleVertices</a></code>
</p>

<hr>
<h2 id='circleProgressiveLayout'>Progressive layout algorithm</h2><span id='topic+circleProgressiveLayout'></span>

<h3>Description</h3>

<p>Arranges a set of circles, which are denoted by their sizes, by consecutively 
placing each circle externally tangent to two previously placed circles while 
avoiding overlaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleProgressiveLayout(x, sizecol = 1, sizetype = c("area", "radius"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleProgressiveLayout_+3A_x">x</code></td>
<td>
<p>Either a vector of circle sizes, or a matrix or data frame
with one column for circle sizes.</p>
</td></tr>
<tr><td><code id="circleProgressiveLayout_+3A_sizecol">sizecol</code></td>
<td>
<p>The index or name of the column in <code>x</code> for circle sizes.
Ignored if <code>x</code> is a vector.</p>
</td></tr>
<tr><td><code id="circleProgressiveLayout_+3A_sizetype">sizetype</code></td>
<td>
<p>The type of size values: either <code>"area"</code> (default) 
or <code>"radius"</code>. May be abbreviated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on an algorithm described in the paper:
<em>Visualization of large hierarchical data by circle packing</em>
by Weixin Wang, Hui Wang, Guozhong Dai, and Hongan Wang. Published
in <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</em>,
2006, pp. 517-520 <a href="https://doi.org/10.1145/1124772.1124851">doi:10.1145/1124772.1124851</a>
</p>
<p>The implementation here was adapted from a version written in C by Peter Menzel:
<a href="https://github.com/pmenzel/packCircles">https://github.com/pmenzel/packCircles</a>.
</p>


<h3>Value</h3>

<p>A data frame with columns: x, y, radius. If any of the input size values
were non-positive or missing, the corresponding rows of the output data frame
will be filled with <code>NA</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>areas &lt;- sample(c(4, 16, 64), 100, rep = TRUE, prob = c(60, 30, 10))
packing &lt;- circleProgressiveLayout(areas)

## Not run: 

# Graph the result with ggplot
library(ggplot2)

dat.gg &lt;- circleLayoutVertices(packing)

ggplot(data = dat.gg, aes(x, y, group = id)) +
  geom_polygon(colour = "black", fill = "grey90") +
  coord_equal() +
  theme_void()


## End(Not run)

</code></pre>

<hr>
<h2 id='circleRemoveOverlaps'>Filters a set of circles to remove all overlaps</h2><span id='topic+circleRemoveOverlaps'></span>

<h3>Description</h3>

<p>Given an initial set of circles, this function identifies a subset of
non-overlapping circles using a simple heuristic algorithm. Circle positions
remain fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleRemoveOverlaps(
  x,
  xysizecols = 1:3,
  sizetype = c("area", "radius"),
  tolerance = 1,
  method = c("maxov", "minov", "largest", "smallest", "random", "lparea", "lpnum")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleRemoveOverlaps_+3A_x">x</code></td>
<td>
<p>A matrix or data frame containing circle x-y centre coordinates
and sizes (area or radius).</p>
</td></tr>
<tr><td><code id="circleRemoveOverlaps_+3A_xysizecols">xysizecols</code></td>
<td>
<p>The integer indices or names of the columns in <code>x</code> for
the centre x-y coordinates and sizes of circles. Default is <code>c(1,2,3)</code>.</p>
</td></tr>
<tr><td><code id="circleRemoveOverlaps_+3A_sizetype">sizetype</code></td>
<td>
<p>The type of size values: either <code>"area"</code> (default) or 
<code>"radius"</code>. May be abbreviated.</p>
</td></tr>
<tr><td><code id="circleRemoveOverlaps_+3A_tolerance">tolerance</code></td>
<td>
<p>Controls the amount of overlap allowed. Set to 1 for 
simple exclusion of overlaps. Values lower than 1 allow more overlap.
Values &gt; 1 have the effect of expanding the influence of circles so that
more space is required between them. The input value must be &gt; 0.</p>
</td></tr>
<tr><td><code id="circleRemoveOverlaps_+3A_method">method</code></td>
<td>
<p>Specifies whether to use linear programming (default) or one of
the variants of the heuristic algorithm. Alternatives are:
<code>"maxov"</code>, <code>"minov"</code>, <code>"largest"</code>, <code>"smallest"</code>,
<code>"random"</code>, <code>"lparea"</code>, <code>"lpnum"</code>. See Details for further
explanation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>method</code> argument specifies whether to use the heuristic algorithm or
linear programming. The following options select the heuristic algorithm and
specify how to choose an overlapping circle for rejection at each iteration: 
</p>

<dl>
<dt>maxov</dt><dd><p>Choose one of the circles with the greatest number of overlaps.</p>
</dd>
<dt>minov</dt><dd><p>Choose one of the circle with the least number of overlaps.</p>
</dd>
<dt>largest</dt><dd><p>Choose one of the largest circles.</p>
</dd>
<dt>smallest</dt><dd><p>Choose one of the smallest circles.</p>
</dd>
<dt>random</dt><dd><p>Choose a circle at random.</p>
</dd>
</dl>

<p>At each iteration the number of overlaps is checked for each candidate
circle and any non-overlapping circles added to the selected subset. Then a
single overlapping circle is chosen, based on the method being used, from
among the remainder and marked as rejected. Iterations continue until all
circles have been either selected or rejected. The 'maxov' option (default)
generally seems to perform best at maximizing the number of circles retained.
The other options are provided for comparison and experiment. Beware that
some can perform surprisingly poorly, especially 'minov'.
</p>
<p>Two further options select linear programming:
</p>

<dl>
<dt>lparea</dt><dd><p>Maximise the total area of circles in the subset.</p>
</dd>
<dt>lpnum</dt><dd><p>Maximise the total number of circles in the subset.</p>
</dd>
</dl>

<p>The 'lpSolve' package must be installed to use the linear programming options.
These options will find an optimal subset, but for anything other than a small
number of initial circles the running time can be prohibitive.
</p>


<h3>Value</h3>

<p>A data frame with centre coordinates and radii of selected circles.
</p>


<h3>Note</h3>

<p><em>This function is experimental</em> and will almost certainly change before
the next package release. In particular, it will probably return something
other than a data frame.
</p>

<hr>
<h2 id='circleRepelLayout'>Arranges circles by iterative pair-wise repulsion within a bounding rectangle</h2><span id='topic+circleRepelLayout'></span>

<h3>Description</h3>

<p>This function takes a set of circles, defined by a data frame of initial 
centre positions and radii, and uses iterative pair-wise repulsion to try to 
find a non-overlapping arrangement where all circle centres lie inside a 
bounding rectangle. If no such arrangement can be found within the specified 
maximum number of iterations, the last attempt is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleRepelLayout(
  x,
  xlim,
  ylim,
  xysizecols = c(1, 2, 3),
  sizetype = c("area", "radius"),
  maxiter = 1000,
  wrap = TRUE,
  weights = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleRepelLayout_+3A_x">x</code></td>
<td>
<p>Either a vector of circle sizes (areas or radii) or a matrix or 
data frame with a column of sizes and, optionally, columns for initial
x-y coordinates of circle centres.</p>
</td></tr>
<tr><td><code id="circleRepelLayout_+3A_xlim">xlim</code></td>
<td>
<p>The bounds in the X direction; either a vector for [xmin, xmax) 
or a single value interpreted as [0, xmax). Alternatively, omitting this 
argument or passing any of <code>NULL</code>, a vector of <code>NA</code> or an empty
vector will result in unbounded movement in the X direction.</p>
</td></tr>
<tr><td><code id="circleRepelLayout_+3A_ylim">ylim</code></td>
<td>
<p>The bounds in the Y direction; either a vector for [ymin, ymax) 
or a single value interpreted as [0, ymax). Alternatively, omitting this 
argument or passing any of <code>NULL</code>, a vector of <code>NA</code> or an empty
vector will result in unbounded movement in the Y direction.</p>
</td></tr>
<tr><td><code id="circleRepelLayout_+3A_xysizecols">xysizecols</code></td>
<td>
<p>The integer indices or names of the columns in <code>x</code> 
for the centre x-y coordinates and sizes of circles. This argument is
ignored if <code>x</code> is a vector.  If <code>x</code> is a matrix or data frame
but does not contain initial x-y coordinates, this can be indicated as
<code>xysizecols = c(NA, NA, 1)</code> for example.</p>
</td></tr>
<tr><td><code id="circleRepelLayout_+3A_sizetype">sizetype</code></td>
<td>
<p>The type of size values: either <code>"area"</code> or <code>"radius"</code>.
May be abbreviated.</p>
</td></tr>
<tr><td><code id="circleRepelLayout_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="circleRepelLayout_+3A_wrap">wrap</code></td>
<td>
<p>Whether to treat the bounding rectangle as a toroid (default 
<code>TRUE</code>). When this is in effect, a circle leaving the bounds on one 
side re-enters on the opposite side.</p>
</td></tr>
<tr><td><code id="circleRepelLayout_+3A_weights">weights</code></td>
<td>
<p>An optional vector of numeric weights (0 to 1 inclusive) to 
apply to the distance each circle moves during pair-repulsion. A weight of 
0 prevents any movement. A weight of 1 gives the default movement distance.
A single value can be supplied for uniform weights. A vector with length 
less than the number of circles will be silently extended by repeating the 
final value. Any values outside the range [0, 1] will be clamped to 0 or 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is adapted from a demo written in the Processing language by 
Sean McCullough (this no longer seems to be available online).
Each circle in the input data is compared to those following it. If two 
circles overlap, they are moved apart such that the distance moved by each is
proportional to the radius of the other, loosely simulating inertia. So when 
a small circle is overlapped by a larger circle, the small circle moves 
furthest. This process is repeated until no more movement takes place 
(acceptable layout) or the maximum number of iterations is reached (layout 
failure).
</p>
<p>To avoid edge effects, the bounding rectangle can be treated as a toroid by 
setting the <code>wrap</code> argument to <code>TRUE</code>. With this option, a circle 
moving outside the bounds re-enters at the opposite side.
</p>


<h3>Value</h3>

<p>A list with components: </p>
 <dl>
<dt>layout</dt><dd><p>A 3-column matrix or
data frame (centre x, centre y, radius).</p>
</dd> <dt>niter</dt><dd><p>Number of iterations
performed.</p>
</dd> </dl>


<hr>
<h2 id='circleVertices'>Generate vertex coordinates for a circle</h2><span id='topic+circleVertices'></span>

<h3>Description</h3>

<p>Generates vertex coordinates for a circle given its centre coordinates
and radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleVertices(xc, yc, radius, npoints = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleVertices_+3A_xc">xc</code></td>
<td>
<p>Circle centre X ordinate.</p>
</td></tr>
<tr><td><code id="circleVertices_+3A_yc">yc</code></td>
<td>
<p>Circle centre Y ordinate.</p>
</td></tr>
<tr><td><code id="circleVertices_+3A_radius">radius</code></td>
<td>
<p>Circle radius.</p>
</td></tr>
<tr><td><code id="circleVertices_+3A_npoints">npoints</code></td>
<td>
<p>Number of distinct vertices required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-column matrix of X and Y values. The final row is a copy
of the first row to create a closed polygon, so the matrix has
<code>npoints + 1</code> rows.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circleLayoutVertices">circleLayoutVertices</a></code>
</p>

<hr>
<h2 id='packcircles-package'>packcircles: Simple algorithms for circle packing</h2><span id='topic+packcircles'></span><span id='topic+packcircles-package'></span>

<h3>Description</h3>

<p>This package provides several algorithms to find non-overlapping
arrangements of circles:
</p>

<dl>
<dt>circleRepelLayout</dt><dd><p>Arranges circles within a bounding rectangle
by pairwise repulsion.</p>
</dd>
<dt>circleProgressiveLayout</dt><dd><p>Arranges circles in an unbounded area
by progressive placement. This is a very efficient algorithm that can
handle large numbers of circles.</p>
</dd>
<dt>circleGraphLayout</dt><dd><p>Finds an arrangement of circles conforming to
a graph specification.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Bedward <a href="mailto:michael.bedward@gmail.com">michael.bedward@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> David Eppstein <a href="mailto:david.eppstein@gmail.com">david.eppstein@gmail.com</a> (Author of Python code for graph-based circle packing ported to C++ for this package)
</p>
</li>
<li><p> Peter Menzel <a href="mailto:pmenzel@gmail.com">pmenzel@gmail.com</a> (Author of C code for progressive circle packing ported to C++ for this package)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mbedward/packcircles">https://github.com/mbedward/packcircles</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mbedward/packcircles/issues">https://github.com/mbedward/packcircles/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
