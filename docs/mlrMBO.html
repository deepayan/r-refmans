<!DOCTYPE html><html><head><title>Help for package mlrMBO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlrMBO}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#error_handling'><p>Error handling for mlrMBO</p></a></li>
<li><a href='#exampleRun'><p>Perform an mbo run on a test function and and visualize what happens.</p></a></li>
<li><a href='#exampleRunMultiObj'><p>Perform an MBO run on a multi-objective test function and and visualize what happens.</p></a></li>
<li><a href='#finalizeSMBO'><p>Finalizes the SMBO Optimization</p></a></li>
<li><a href='#getGlobalOpt'><p>Helper function which returns the (estimated) global optimum.</p></a></li>
<li><a href='#getMBOInfillCrit'><p>Get properties of MBO infill criterion.</p></a></li>
<li><a href='#getSupportedInfillOptFunctions'><p>Get names of supported infill-criteria optimizers.</p></a></li>
<li><a href='#getSupportedMultipointInfillOptFunctions'><p>Get names of supported multi-point infill-criteria optimizers.</p></a></li>
<li><a href='#infillcrits'><p>Infill criteria.</p></a></li>
<li><a href='#initCrit'><p>Initialize an MBO infill criterion.</p></a></li>
<li><a href='#initSMBO'><p>Initialize a manual sequential MBO run.</p></a></li>
<li><a href='#makeMBOControl'><p>Set MBO options.</p></a></li>
<li><a href='#makeMBOInfillCrit'><p>Create an infill criterion.</p></a></li>
<li><a href='#makeMBOLearner'><p>Generate default learner.</p></a></li>
<li><a href='#makeMBOTrafoFunction'><p>Create a transformation function for MBOExampleRun.</p></a></li>
<li><a href='#mbo'><p>Optimizes a function with sequential model based optimization.</p></a></li>
<li><a href='#mbo_OptPath'><p>OptPath in mlrMBO</p></a></li>
<li><a href='#mbo_parallel'><p>Parallelization in mlrMBO</p></a></li>
<li><a href='#mboContinue'><p>Continues an mbo run from a save-file.</p></a></li>
<li><a href='#mboFinalize'><p>Finalizes an mbo run from a save-file.</p></a></li>
<li><a href='#MBOMultiObjResult'><p>Multi-Objective result object.</p></a></li>
<li><a href='#MBOSingleObjResult'><p>Single-Objective result object.</p></a></li>
<li><a href='#mlrMBO_examples'><p>mlrMBO examples</p></a></li>
<li><a href='#OptProblem'><p>OptProblem object.</p></a></li>
<li><a href='#OptResult'><p>OptResult object.</p></a></li>
<li><a href='#OptState'><p>OptState object.</p></a></li>
<li><a href='#plot.OptState'><p>Generate ggplot2 Object</p></a></li>
<li><a href='#plotExampleRun'><p>Renders plots for exampleRun objects and displays them.</p></a></li>
<li><a href='#plotMBOResult'><p>MBO Result Plotting</p></a></li>
<li><a href='#print.MBOControl'><p>Print mbo control object.</p></a></li>
<li><a href='#proposePoints'><p>Propose candidates for the objective function</p></a></li>
<li><a href='#renderExampleRunPlot'><p>Renders plots for exampleRun objects, either in 1D or 2D, or</p>
exampleRunMultiObj objects.</a></li>
<li><a href='#setMBOControlInfill'><p>Extends mbo control object with infill criteria and infill optimizer options.</p></a></li>
<li><a href='#setMBOControlMultiObj'><p>Set multi-objective options.</p></a></li>
<li><a href='#setMBOControlMultiPoint'><p>Set multipoint proposal options.</p></a></li>
<li><a href='#setMBOControlTermination'><p>Set termination options.</p></a></li>
<li><a href='#trafos'><p>Transformation methods.</p></a></li>
<li><a href='#updateSMBO'><p>Updates SMBO with the new observations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Optimization and Model-Based Optimization of Expensive
Black-Box Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexible and comprehensive R toolbox for model-based optimization
    ('MBO'), also known as Bayesian optimization. It implements the Efficient
    Global Optimization Algorithm and is designed for both single- and multi-
    objective optimization with mixed continuous, categorical and conditional
    parameters. The machine learning toolbox 'mlr' provide dozens of regression
    learners to model the performance of the target algorithm with respect to
    the parameter settings. It provides many different infill criteria to guide
    the search process. Additional features include multi-point batch proposal,
    parallel execution as well as visualization and sophisticated logging
    mechanisms, which is especially useful for teaching and understanding of
    algorithm behavior. 'mlrMBO' is implemented in a modular fashion, such that
    single components can be easily replaced or adapted by the user for specific
    use cases.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlr-org/mlrMBO">https://github.com/mlr-org/mlrMBO</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/mlrMBO/issues">https://github.com/mlr-org/mlrMBO/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mlr (&ge; 2.10), ParamHelpers (&ge; 1.10), smoof (&ge; 1.5.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>backports (&ge; 1.1.0), BBmisc (&ge; 1.11), checkmate (&ge; 1.8.2),
data.table, lhs, parallelMap (&ge; 1.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cmaesr (&ge; 1.0.3), ggplot2, DiceKriging, earth, emoa, GGally,
gridExtra, kernlab, kknn, knitr, mco, nnet, party,
randomForest, reshape2, rmarkdown, rgenoud, rpart, testthat,
covr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-04 07:35:16 UTC; ripley</td>
</tr>
<tr>
<td>Author:</td>
<td>Bernd Bischl <a href="https://orcid.org/0000-0001-6002-6980"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jakob Richter <a href="https://orcid.org/0000-0003-4481-5554"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jakob Bossek <a href="https://orcid.org/0000-0002-4121-4668"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniel Horn [aut],
  Michel Lang <a href="https://orcid.org/0000-0001-9754-0393"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Janek Thomas <a href="https://orcid.org/0000-0003-4511-6245"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakob Richter &lt;code@jakob-r.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-04 08:50:50 UTC</td>
</tr>
</table>
<hr>
<h2 id='error_handling'>Error handling for mlrMBO</h2><span id='topic+error_handling'></span>

<h3>Description</h3>

<p>There are multiple types of errors that can occur during one optimization
process. mlrMBO tries to handle most of them as smart as possible.
</p>
<p>The target function could
</p>

<ul>
<li><p>1The target function returns NA(s) or NaN(s) (plural for the multi-objective case).
</p>
</li>
<li><p>2The target function stops with an error.
</p>
</li>
<li><p>3The target function does not return at all (infinite or very long execution time).
</p>
</li>
<li><p>4The target function crashes the whole R process.
</p>
</li>
<li><p>5The surrogate machine learning model might crash.
Kriging quite often can run into numerical problems.
</p>
</li>
<li><p>6The proposal mechanism - in multi-point or single point mode - produces
a point which is either close to another candidate point in the same iteration or
an already visited point in a previous iteration.
</p>
</li>
<li><p>7The mbo process exits / stops / crashes itself. Maybe because it hit a walltime.
</p>
</li></ul>

<p><strong>Mechanism I - Objective value imputation</strong>
Issues 1-4 all have in common that the optimizer does not obtain a useful
objective value. 3-4 are problematic, because we completely lose control of the R process.
We are currently only able to handle them, if you are parallelizing your optimization
via <code><a href="parallelMap.html#topic+parallelMap">parallelMap</a></code> and use the BatchJobs mode.
In this case, you can specify a walltime (handles 3) and the function evaluation is performed
in a separate R process (handles 4). A later path might be to allow function evaluation in
a separate process in general, with a capping time. If you really need this now, you can always
do this yourself.
</p>
<p>Now back to the problem of invalid objective values. By default, the mbo function stops with an error
(if it still has control of the process). But in many cases you still want the algorithm to continue.
Hence, mbo allows imputation of bad values via the control option <code>impute.y.fun</code>.
</p>
<p><strong>Logging:</strong> All error messages are logged into the optimization path <code>opt.path</code> if problems occur.
</p>
<p><strong>Mechanism II - The mlr's on.learner.error</strong>
If your surrogate learner crashes you can set <code>on.surrogate.error</code> in <code><a href="#topic+makeMBOControl">makeMBOControl</a></code> to &ldquo;quiet&rdquo; or &ldquo;warn&rdquo;.
This will set mlr's <code>on.learner.error</code> for the surrogate.
It prevents MBO from crashing in total (issue 5), if the surrogate learner produces an error.
As a resort a FailureModel will be returned instead of a the surrogate.
Subsequently a random point (or multiple ones) are proposed now for the current iteration.
And we pray that we can fit the model again in the next iteration.
<strong>Logging:</strong> The entry &ldquo;model.error&rdquo; is set in the <code>opt.path</code>.
</p>
<p><strong>Mechanism III - Filtering of proposed point which are too close</strong>
</p>
<p>Issue 6 is solved by filtering points that are to close to other proposed points or points already
proposed in preceding iterations. Filtering in this context means replacing the proposed points by
a randomly generated new point. The heuristics mechanism is (de)activated via the logical
<code>filter.proposed.points.tol</code> parameter of the <code><a href="#topic+setMBOControlInfill">setMBOControlInfill</a></code> function, which defaults to
<code>TRUE</code>.(closeness of two points is determined via the <code>filter.proposed.points.tol</code> parameter).
</p>
<p><strong>Logging:</strong> The logical entry &ldquo;filtered.point&rdquo; is set in the opt.path indicating whether the
corresponding point was filtered.
</p>
<p><strong>Mechanism IV - Continue optimization process</strong>
</p>
<p>The mechanism is a save-state-then-continue-mechanism, that allows you to continue
your optimization after your system or the optimization process crashed for
some reason (issue 7). The <code><a href="#topic+mbo">mbo</a></code> function has the option to save the
current state after certain iterations of the main loop on disk via the control
option <code>save.on.disk.at</code> of <code><a href="#topic+makeMBOControl">makeMBOControl</a></code>.
Note that this saving mechanism is <em>disabled</em> by default.
Here you can specify, after which iteration you want the current state to be
saved (option <code>save.on.disk.at</code>). Notice that 0 denotes saving the initial
design and <code>iters</code> + 1 denotes saving the final results.
With <code><a href="#topic+mboContinue">mboContinue</a></code> you can continue the optimization from the last
saved state. This function only requires the path of the saved state.
</p>
<p>You will get a warning if you turn on saving in general, but not for the the final result, as
this seems a bit stupid. <code>save.file.path</code> defines the path of the RData file where
the state is stored. It is overwritten (= extended) in each saving iteration.
</p>

<hr>
<h2 id='exampleRun'>Perform an mbo run on a test function and and visualize what happens.</h2><span id='topic+exampleRun'></span>

<h3>Description</h3>

<p>Usually used for 1D or 2D examples,
useful for figuring out how stuff works and for teaching purposes.
Currently only parameter spaces with numerical parameters are supported.
For visualization, run <code>plotExampleRun</code> on the resulting object.
What is displayed is documented here: <code><a href="#topic+plotExampleRun">plotExampleRun</a></code>.
Rendering the plots without displaying them is possible via the function
<code><a href="#topic+renderExampleRunPlot">renderExampleRunPlot</a></code>.
</p>
<p>Please note the following things:
- The true objective function (and later everything which is predicted from our surrogate model)
is evaluated on a regular spaced grid. These evaluations are stored in the result object.
You can control the resolution of this grid via <code>points.per.dim</code>.
Parallelization of these evaluations is possible with the R package parallelMap on the level <code>mlrMBO.feval</code>.
- In every iteration the fitted, approximating surrogate model is stored in the result object
(via <code>store.model.at</code> in <code>control</code>) so we can later visualize it quickly.
- The global optimum of the function (if defined) is extracted from the passed smoof function.
- If the passed objective function <code>fun</code> does not provide the true, unnoisy objective function
some features will not be displayed (for example the gap between the best point so far and the global optimum).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleRun(
  fun,
  design = NULL,
  learner = NULL,
  control,
  points.per.dim = 50,
  noisy.evals = 10,
  show.info = getOption("mlrMBO.show.info", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exampleRun_+3A_fun">fun</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Fitness function to optimize.
For one dimensional target functions you can obtain a <code>smoof_function</code> by using <code><a href="smoof.html#topic+makeSingleObjectiveFunction">makeSingleObjectiveFunction</a></code>.
For multi dimensional functions use <code><a href="smoof.html#topic+makeMultiObjectiveFunction">makeMultiObjectiveFunction</a></code>.
It is possible to return even more information which will be stored
in the optimization path. To achieve this, simply append the attribute &ldquo;extras&rdquo;
to the return value of the target function. This has to be a named list of scalar values.
Each of these values will be stored additionally in the optimization path.</p>
</td></tr>
<tr><td><code id="exampleRun_+3A_design">design</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Initial design as data frame.
If the y-values are not already present in design, mbo will evaluate the points.
If the parameters have corresponding trafo functions, the design must not be transformed before it is passed!
Functions to generate designs are available in <code>ParamHelpers</code>: <code><a href="ParamHelpers.html#topic+generateDesign">generateDesign</a></code>, <code><a href="ParamHelpers.html#topic+generateGridDesign">generateGridDesign</a></code>, <code><a href="ParamHelpers.html#topic+generateRandomDesign">generateRandomDesign</a></code>.
Default is <code>NULL</code>, which means <code><a href="ParamHelpers.html#topic+generateDesign">generateDesign</a></code> is called and a design of size 4 times number of all parameters is created
The points are drawn via <code><a href="lhs.html#topic+maximinLHS">maximinLHS</a></code> to maximize the minimal distance between design points.</p>
</td></tr>
<tr><td><code id="exampleRun_+3A_learner">learner</code></td>
<td>
<p>[<code><a href="mlr.html#topic+Learner">Learner</a></code>]<br />
Regression learner from mlr, which is used as a surrogate to model our fitness function.
If <code>NULL</code> (default), the default learner is determined as described here: <a href="#topic+mbo_default_learner">mbo_default_learner</a>.</p>
</td></tr>
<tr><td><code id="exampleRun_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object for mbo.</p>
</td></tr>
<tr><td><code id="exampleRun_+3A_points.per.dim">points.per.dim</code></td>
<td>
<p>[<code>integer</code>]<br />
Number of (regular spaced) locations at which to
sample the <code>fun</code> function per dimension.
Default is 50.</p>
</td></tr>
<tr><td><code id="exampleRun_+3A_noisy.evals">noisy.evals</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of function evaluations per point if <code>fun</code> is noisy.
Default is 10.</p>
</td></tr>
<tr><td><code id="exampleRun_+3A_show.info">show.info</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Verbose output on console?
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>MBOExampleRun</code>]
</p>

<hr>
<h2 id='exampleRunMultiObj'>Perform an MBO run on a multi-objective test function and and visualize what happens.</h2><span id='topic+exampleRunMultiObj'></span>

<h3>Description</h3>

<p>Only available for 2D -&gt; 2D examples,
useful for figuring out how stuff works and for teaching purposes.
Currently only parameter spaces with numerical parameters are supported.
For visualization, run <code>plotExampleRun</code> on the resulting object.
What is displayed is documented here: <code><a href="#topic+plotExampleRun">plotExampleRun</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleRunMultiObj(
  fun,
  design = NULL,
  learner,
  control,
  points.per.dim = 50,
  show.info = getOption("mlrMBO.show.info", TRUE),
  nsga2.args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exampleRunMultiObj_+3A_fun">fun</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Fitness function to optimize.
For one dimensional target functions you can obtain a <code>smoof_function</code> by using <code><a href="smoof.html#topic+makeSingleObjectiveFunction">makeSingleObjectiveFunction</a></code>.
For multi dimensional functions use <code><a href="smoof.html#topic+makeMultiObjectiveFunction">makeMultiObjectiveFunction</a></code>.
It is possible to return even more information which will be stored
in the optimization path. To achieve this, simply append the attribute &ldquo;extras&rdquo;
to the return value of the target function. This has to be a named list of scalar values.
Each of these values will be stored additionally in the optimization path.</p>
</td></tr>
<tr><td><code id="exampleRunMultiObj_+3A_design">design</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Initial design as data frame.
If the y-values are not already present in design, mbo will evaluate the points.
If the parameters have corresponding trafo functions, the design must not be transformed before it is passed!
Functions to generate designs are available in <code>ParamHelpers</code>: <code><a href="ParamHelpers.html#topic+generateDesign">generateDesign</a></code>, <code><a href="ParamHelpers.html#topic+generateGridDesign">generateGridDesign</a></code>, <code><a href="ParamHelpers.html#topic+generateRandomDesign">generateRandomDesign</a></code>.
Default is <code>NULL</code>, which means <code><a href="ParamHelpers.html#topic+generateDesign">generateDesign</a></code> is called and a design of size 4 times number of all parameters is created
The points are drawn via <code><a href="lhs.html#topic+maximinLHS">maximinLHS</a></code> to maximize the minimal distance between design points.</p>
</td></tr>
<tr><td><code id="exampleRunMultiObj_+3A_learner">learner</code></td>
<td>
<p>[<code><a href="mlr.html#topic+Learner">Learner</a></code>]<br />
Regression learner from mlr, which is used as a surrogate to model our fitness function.
If <code>NULL</code> (default), the default learner is determined as described here: <a href="#topic+mbo_default_learner">mbo_default_learner</a>.</p>
</td></tr>
<tr><td><code id="exampleRunMultiObj_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object for mbo.</p>
</td></tr>
<tr><td><code id="exampleRunMultiObj_+3A_points.per.dim">points.per.dim</code></td>
<td>
<p>[<code>integer</code>]<br />
Number of (regular spaced) locations at which to
sample the <code>fun</code> function per dimension.
Default is 50.</p>
</td></tr>
<tr><td><code id="exampleRunMultiObj_+3A_show.info">show.info</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Verbose output on console?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="exampleRunMultiObj_+3A_nsga2.args">nsga2.args</code></td>
<td>
<p>[<code>list</code>]<br />
Further arguments passed to the nsga2 call.
Default is <code>list()</code>.</p>
</td></tr>
<tr><td><code id="exampleRunMultiObj_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed to the learner.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>MBOExampleRunMultiObj</code>]
</p>


<h3>Note</h3>

<p>If the passed objective function has no associated reference point max(y_i) + 1
of the nsga2 front is used.
</p>

<hr>
<h2 id='finalizeSMBO'>Finalizes the SMBO Optimization</h2><span id='topic+finalizeSMBO'></span>

<h3>Description</h3>

<p>Returns the common mlrMBO result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalizeSMBO(opt.state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalizeSMBO_+3A_opt.state">opt.state</code></td>
<td>
<p>[<code><a href="#topic+OptState">OptState</a></code>]
The optimization state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+MBOSingleObjResult">MBOSingleObjResult</a></code> | <code><a href="#topic+MBOMultiObjResult">MBOMultiObjResult</a></code>]
</p>

<hr>
<h2 id='getGlobalOpt'>Helper function which returns the (estimated) global optimum.</h2><span id='topic+getGlobalOpt'></span>

<h3>Description</h3>

<p>Helper function which returns the (estimated) global optimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGlobalOpt(run)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGlobalOpt_+3A_run">run</code></td>
<td>
<p>[<code>MBOExampleRun</code>]<br />
Object of type <code>MBOExampleRun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(1)</code>]. (Estimated) global optimum.
</p>

<hr>
<h2 id='getMBOInfillCrit'>Get properties of MBO infill criterion.</h2><span id='topic+getMBOInfillCrit'></span><span id='topic+getMBOInfillCritParams'></span><span id='topic+getMBOInfillCritParam'></span><span id='topic+getMBOInfillCritName'></span><span id='topic+getMBOInfillCritId'></span><span id='topic+hasRequiresInfillCritStandardError'></span><span id='topic+getMBOInfillCritComponents'></span>

<h3>Description</h3>

<p>Returns properties of an infill criterion, e.g., name or id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMBOInfillCritParams(x)

getMBOInfillCritParam(x, par.name)

getMBOInfillCritName(x)

getMBOInfillCritId(x)

hasRequiresInfillCritStandardError(x)

getMBOInfillCritComponents(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMBOInfillCrit_+3A_x">x</code></td>
<td>
<p>[<code><a href="#topic+MBOInfillCrit">MBOInfillCrit</a></code>]<br />
Infill criterion.</p>
</td></tr>
<tr><td><code id="getMBOInfillCrit_+3A_par.name">par.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Parameter name.</p>
</td></tr>
</table>

<hr>
<h2 id='getSupportedInfillOptFunctions'>Get names of supported infill-criteria optimizers.</h2><span id='topic+getSupportedInfillOptFunctions'></span>

<h3>Description</h3>

<p>None.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSupportedInfillOptFunctions()
</code></pre>


<h3>Value</h3>

<p>[<code>character</code>]
</p>

<hr>
<h2 id='getSupportedMultipointInfillOptFunctions'>Get names of supported multi-point infill-criteria optimizers.</h2><span id='topic+getSupportedMultipointInfillOptFunctions'></span>

<h3>Description</h3>

<p>Returns all names of supported multi-point infill-criteria optimizers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSupportedMultipointInfillOptFunctions()
</code></pre>


<h3>Value</h3>

<p>[<code>character</code>]
</p>

<hr>
<h2 id='infillcrits'>Infill criteria.</h2><span id='topic+infillcrits'></span><span id='topic+makeMBOInfillCritMeanResponse'></span><span id='topic+makeMBOInfillCritStandardError'></span><span id='topic+makeMBOInfillCritEI'></span><span id='topic+makeMBOInfillCritCB'></span><span id='topic+makeMBOInfillCritAEI'></span><span id='topic+makeMBOInfillCritEQI'></span><span id='topic+makeMBOInfillCritDIB'></span><span id='topic+makeMBOInfillCritAdaCB'></span>

<h3>Description</h3>

<p><span class="pkg">mlrMBO</span> contains most of the most popular infill criteria, e.g., expected
improvement, (lower) confidence bound etc. Moreover, custom infill criteria
may be generated with the <code><a href="#topic+makeMBOInfillCrit">makeMBOInfillCrit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMBOInfillCritMeanResponse()

makeMBOInfillCritStandardError()

makeMBOInfillCritEI(se.threshold = 1e-06)

makeMBOInfillCritCB(cb.lambda = NULL)

makeMBOInfillCritAEI(aei.use.nugget = FALSE, se.threshold = 1e-06)

makeMBOInfillCritEQI(eqi.beta = 0.75, se.threshold = 1e-06)

makeMBOInfillCritDIB(cb.lambda = 1, sms.eps = NULL)

makeMBOInfillCritAdaCB(cb.lambda.start = NULL, cb.lambda.end = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infillcrits_+3A_se.threshold">se.threshold</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
In order to avoid numerical problems the standard error estimation is assumed to
be exactly zero, if it is below <code>se.threshold</code>.
Default is 1e-6.</p>
</td></tr>
<tr><td><code id="infillcrits_+3A_cb.lambda">cb.lambda</code></td>
<td>
<p>[<code>numeric(1)</code> | <code>NULL</code>]<br />
Lambda parameter for confidence bound infill criterion.
Default is <code>NULL</code>, which means 1 in case of a fully numeric parameter set and 2 otherwise.
Any non-negative real valued numbers are valid.</p>
</td></tr>
<tr><td><code id="infillcrits_+3A_aei.use.nugget">aei.use.nugget</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the nugget effect be used for the pure variance estimation for augmented
expected improvement?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="infillcrits_+3A_eqi.beta">eqi.beta</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Beta parameter for expected quantile improvement criterion.
Default is 0.75.
Valid values are between 0.5 and 1.</p>
</td></tr>
<tr><td><code id="infillcrits_+3A_sms.eps">sms.eps</code></td>
<td>
<p>[<code>numeric(1)</code> | <code>NULL</code>]<br />
Epsilon for epsilon-dominance for <code>dib.indicator = "sms"</code>.
Default is <code>NULL</code>, in this case it is adaptively set.</p>
</td></tr>
<tr><td><code id="infillcrits_+3A_cb.lambda.start">cb.lambda.start</code></td>
<td>
<p>[<code>numeric(1)</code> | <code>NULL</code>]<br />
The value of <code>cb.lambda</code> at the beginning of the optimization.
The <code>makeMBOInfillCritAdaCB</code> crit takes the progress of the optimization determined by the termination criterion to linearly move from <code>cb.lambda.start</code> to <code>cb.lambda.end</code>.
The initial desgin does not account for the progress of the optimization.
Eexcept for <code>makeMBOTerminationMaxExecBudget</code>) if you dont pass a precalculated initial design.</p>
</td></tr>
<tr><td><code id="infillcrits_+3A_cb.lambda.end">cb.lambda.end</code></td>
<td>
<p>[<code>numeric(1)</code> | <code>NULL</code>]<br />
The value of <code>cb.lambda</code> at the end of the optimization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the multi-objective case we recommend to set <code>cb.lambda</code> to
<code class="reqn">q(0.5 \cdot \pi_{CB}^{(1 / n)})</code> where <code class="reqn">q</code> is the quantile
function of the standard normal distribution, <code class="reqn">\pi_CB</code> is the probability
of improvement value and <code class="reqn">n</code> is the number of objectives of the considered problem.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMBOInfillCrit">makeMBOInfillCrit</a></code>
</p>

<hr>
<h2 id='initCrit'>Initialize an MBO infill criterion.</h2><span id='topic+initCrit'></span>

<h3>Description</h3>

<p>Some infill criteria have parameters that are dependent on values in the parameter set, design,
used learner or other control settings.
To actually set these default values, this function is called, which returns a fully
initialized [<code><a href="#topic+MBOInfillCrit">MBOInfillCrit</a></code>].
This function is mainly for internal use. If a custom infill criterion is created, it may be
required to create a separate method <code>initCrit.InfillCritID</code> where <code>ID</code> is the
<code>id</code> of the custom <a href="#topic+MBOInfillCrit">MBOInfillCrit</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initCrit(crit, fun, design, learner, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initCrit_+3A_crit">crit</code></td>
<td>
<p>[<code><a href="#topic+MBOInfillCrit">MBOInfillCrit</a></code>]<br />
Uninitialized infill criterion.</p>
</td></tr>
<tr><td><code id="initCrit_+3A_fun">fun</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Fitness function to optimize.</p>
</td></tr>
<tr><td><code id="initCrit_+3A_design">design</code></td>
<td>
<p>Sampling plan.</p>
</td></tr>
<tr><td><code id="initCrit_+3A_learner">learner</code></td>
<td>
<p>[<code><a href="mlr.html#topic+Learner">Learner</a></code>]<br />
Regression learner from mlr, which is used as a surrogate to model our fitness function.</p>
</td></tr>
<tr><td><code id="initCrit_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
MBO control object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+MBOInfillCrit">MBOInfillCrit</a></code>]
</p>

<hr>
<h2 id='initSMBO'>Initialize a manual sequential MBO run.</h2><span id='topic+initSMBO'></span>

<h3>Description</h3>

<p>When you want to run a human-in-the-loop MBO run you need to initialize it first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initSMBO(
  par.set,
  design,
  learner = NULL,
  control,
  minimize = rep(TRUE, control$n.objectives),
  noisy = FALSE,
  show.info = getOption("mlrMBO.show.info", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initSMBO_+3A_par.set">par.set</code></td>
<td>
<p>[<code><a href="ParamHelpers.html#topic+ParamSet">ParamSet</a></code>]<br />
See <code><a href="#topic+mbo">mbo</a></code>.</p>
</td></tr>
<tr><td><code id="initSMBO_+3A_design">design</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Initial design as data frame.
If the y-values are not already present in design, mbo will evaluate the points.
If the parameters have corresponding trafo functions, the design must not be transformed before it is passed!
Functions to generate designs are available in <code>ParamHelpers</code>: <code><a href="ParamHelpers.html#topic+generateDesign">generateDesign</a></code>, <code><a href="ParamHelpers.html#topic+generateGridDesign">generateGridDesign</a></code>, <code><a href="ParamHelpers.html#topic+generateRandomDesign">generateRandomDesign</a></code>.
Default is <code>NULL</code>, which means <code><a href="ParamHelpers.html#topic+generateDesign">generateDesign</a></code> is called and a design of size 4 times number of all parameters is created
The points are drawn via <code><a href="lhs.html#topic+maximinLHS">maximinLHS</a></code> to maximize the minimal distance between design points.</p>
</td></tr>
<tr><td><code id="initSMBO_+3A_learner">learner</code></td>
<td>
<p>[<code><a href="mlr.html#topic+Learner">Learner</a></code>]<br />
Regression learner from mlr, which is used as a surrogate to model our fitness function.
If <code>NULL</code> (default), the default learner is determined as described here: <a href="#topic+mbo_default_learner">mbo_default_learner</a>.</p>
</td></tr>
<tr><td><code id="initSMBO_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object for mbo.</p>
</td></tr>
<tr><td><code id="initSMBO_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical</code>]<br />
Should objective values of the target functions be minimized? One value par objective.
Default is <code>TRUE</code> for every objective.</p>
</td></tr>
<tr><td><code id="initSMBO_+3A_noisy">noisy</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Is the target function noisy?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="initSMBO_+3A_show.info">show.info</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Verbose output on console?
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+OptState">OptState</a></code>]
</p>

<hr>
<h2 id='makeMBOControl'>Set MBO options.</h2><span id='topic+makeMBOControl'></span><span id='topic+MBOControl'></span>

<h3>Description</h3>

<p>Creates a control object for MBO optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMBOControl(
  n.objectives = 1L,
  propose.points = 1L,
  final.method = "best.true.y",
  final.evals = 0L,
  y.name = "y",
  impute.y.fun = NULL,
  trafo.y.fun = NULL,
  suppress.eval.errors = TRUE,
  save.on.disk.at = integer(0L),
  save.on.disk.at.time = Inf,
  save.file.path = file.path(getwd(), "mlrMBO_run.RData"),
  store.model.at = NULL,
  resample.at = integer(0),
  resample.desc = makeResampleDesc("CV", iter = 10),
  resample.measures = list(mse),
  output.num.format = "%.3g",
  on.surrogate.error = "stop"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMBOControl_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
How many objectives are to be optimized? <code>n.objectives = 1</code> implies normal single
criteria optimization, <code>n.objectives &gt; 1</code> implies multi-objective optimization.
Default is 1.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_propose.points">propose.points</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of proposed / really evaluated points each iteration.
Default is 1.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_final.method">final.method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
How should the final point be proposed. Possible values are:
&ldquo;best.true.y&rdquo;: Return best point ever visited according to true value of target function.
Can be bad if target function is noisy.
&ldquo;last.proposed&rdquo;: Return the last point proposed by the model.
&ldquo;best.predicted&rdquo;: Use the final model to predict all points ever visited and use the best one.
This might average-out noisy function values.
Default is: &ldquo;best.true.y&rdquo;.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_final.evals">final.evals</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
How many target function evals should be done at final point to reduce noise?
Default is 0.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_y.name">y.name</code></td>
<td>
<p>[<code>character</code>]<br />
Vector for names of y-columns for target values in optimization path.
Default is &ldquo;y_i&rdquo;, i = 1, ..., n.objectives.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_impute.y.fun">impute.y.fun</code></td>
<td>
<p>[<code>function(x, y, opt.path, ...)</code>*]<br />
Functions that gets triggered if your objective evaluation produced
a) an exception b) a return object of invalid type c) a numeric vector that
contains <code>NA</code>, <code>NaN</code>, <code>Inf</code>.
You now have a chance to handle this. You are expected to return a numeric vector
of the correct length with concrete values.
The optimization path will show some information whether y-values where imputed
and what the original, faulty object was.
<code>x</code> is the current x-value, <code>y</code> the current (invalid) y-object (or an error object)
and <code>opt.path</code> the current optimization path.
Default is <code>NULL</code> which means to stop if the objective function did not produce the desired
result.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_trafo.y.fun">trafo.y.fun</code></td>
<td>
<p>[<code>MBOTrafoFunction</code>]<br />
Sometimes it is favorable to transform the target function values before modeling. Provide a
MBO transformation function to do so.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_suppress.eval.errors">suppress.eval.errors</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should reporting of error messages during target function evaluations be suppressed?
Only used if <code>impute.errors</code> is <code>TRUE</code>.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_save.on.disk.at">save.on.disk.at</code></td>
<td>
<p>[<code>integer</code>] <br />
Sequential optimization iteration when the actual state should be saved
on disk. Iteration 0 denotes the initial design. If the optimization
stops with an crucial error, it can be restarted with this file via the
function <code><a href="#topic+mboContinue">mboContinue</a></code>.
Default is <code>integer(0L)</code>, i. e., not to save.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_save.on.disk.at.time">save.on.disk.at.time</code></td>
<td>
<p>[<code>integer</code>] <br />
Same as above. But here you define the time which have to be passed until the last save in seconds. Any finite value will lead to save at end.
Default is <code>Inf</code>, i. e., not to save ever.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_save.file.path">save.file.path</code></td>
<td>
<p>[<code>character(1)</code>] <br />
If <code>save.on.disk.at</code> is used, this is the name of the file where the data
will be saved.
Default &ldquo;mbo_run.RData&rdquo; in your current working directory.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_store.model.at">store.model.at</code></td>
<td>
<p>[<code>integer</code>]<br />
Sequential optimization iterations when the model should be saved.
Iteration 1 is the model fit for the initial design, iters + 1 is a final
save containing the final results of the optimization. .
Default is <code>iters + 1</code>.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_resample.at">resample.at</code></td>
<td>
<p>[<code>integer</code>]<br />
At which iterations should the model be resampled and assessed?
Iteration 0 does some resampling on the initial design.
Default is none.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_resample.desc">resample.desc</code></td>
<td>
<p>[<code><a href="mlr.html#topic+ResampleDesc">ResampleDesc</a></code>]<br />
How should the model be resampled?
Default is 10-fold CV.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_resample.measures">resample.measures</code></td>
<td>
<p>[list of <code><a href="mlr.html#topic+Measure">Measure</a></code>]<br />
Performance measures to assess model with during resampling.
Default is <code><a href="mlr.html#topic+mse">mse</a></code>.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_output.num.format">output.num.format</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Format string for the precision of the numeric output of mbo.</p>
</td></tr>
<tr><td><code id="makeMBOControl_+3A_on.surrogate.error">on.surrogate.error</code></td>
<td>
<p>[<code>character(1)</code>]<br />
What should happen when the surrogate learner can not train the model.
Possible values are:
&ldquo;stop&rdquo;: R exception is generated.
&ldquo;warn&rdquo;: The error will be converted to a waring and a random point will be proposed.
&ldquo;quiet&rdquo;: Same as “warn” but without the warning.
This will overwrite the mlr setting <code>on.learner.error</code> for the surrogate learner.
Default is: &ldquo;stop&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>].
</p>


<h3>See Also</h3>

<p>Other MBOControl: 
<code><a href="#topic+setMBOControlInfill">setMBOControlInfill</a>()</code>,
<code><a href="#topic+setMBOControlMultiObj">setMBOControlMultiObj</a>()</code>,
<code><a href="#topic+setMBOControlMultiPoint">setMBOControlMultiPoint</a>()</code>,
<code><a href="#topic+setMBOControlTermination">setMBOControlTermination</a>()</code>
</p>

<hr>
<h2 id='makeMBOInfillCrit'>Create an infill criterion.</h2><span id='topic+makeMBOInfillCrit'></span><span id='topic+MBOInfillCrit'></span><span id='topic+crit.ei'></span><span id='topic+crit.mr'></span><span id='topic+crit.se'></span><span id='topic+crit.cb'></span><span id='topic+crit.cb1'></span><span id='topic+crit.cb2'></span><span id='topic+crit.aei'></span><span id='topic+crit.eqi'></span><span id='topic+crit.dib1'></span>

<h3>Description</h3>

<p>The infill criterion guides the model based search process.
The most prominent infill criteria, e.g., expected improvement, lower
confidence bound and others, are already implemented in mlrMBO. Moreover,
the package allows for the creation of custom infill criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMBOInfillCrit(
  fun,
  name,
  id,
  opt.direction = "minimize",
  components = character(0L),
  params = list(),
  requires.se = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMBOInfillCrit_+3A_fun">fun</code></td>
<td>
<p>[<code>function(points, models, control, par.set, design, iter)</code>]<br />
A function which expects the following parameters in exactly this order
and return a numeric vector of criteria values at the points:
</p>

<dl>
<dt>points [<code>data.frame</code>]</dt><dd><p>n points where to evaluate.</p>
</dd>
<dt>models [<code><a href="mlr.html#topic+WrappedModel">WrappedModel</a></code> | <code>list</code>]</dt><dd><p>Model(s) fitted on design.</p>
</dd>
<dt>control [<code>MBOControl</code>]</dt><dd><p>Control object.</p>
</dd>
<dt>par.set [<code>ParamSet</code>]</dt><dd><p>Parameter set.</p>
</dd>
<dt>design [<code>data.frame</code>]</dt><dd><p>Design of already visited points.</p>
</dd>
<dt>iter [<code>integer(1)</code>]</dt><dd><p>Current iteration.</p>
</dd>
<dt>progress [<code>numeric{1}</code>]</dt><dd><p>A value between 0 and 1 indicating the progress of the optimization.</p>
</dd>
<dt>attributes [<code>logical{1}</code>]</dt><dd><p>Are there attributes appended to the return
value that should be added to the <code>OptPath</code>?</p>
</dd>
</dl>

<p>Important: Internally, this function will be minimized. So the proposals will be where this function is low.</p>
</td></tr>
<tr><td><code id="makeMBOInfillCrit_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Full name of the criterion.</p>
</td></tr>
<tr><td><code id="makeMBOInfillCrit_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Short name of the criterion.
Used internally and in plots.</p>
</td></tr>
<tr><td><code id="makeMBOInfillCrit_+3A_opt.direction">opt.direction</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Only for visualization: Shall this criterion be plotted as if it were to be minimized (<code>minimize</code>), maximized (<code>maximize</code>) or is the direction the same as for the objective function (<code>objective</code>)?
Default is <code>minimize</code>.</p>
</td></tr>
<tr><td><code id="makeMBOInfillCrit_+3A_components">components</code></td>
<td>
<p>[<code>character</code>]<br />
Infill criteria may not return proposed point(s) only. Additional
information can be returned by appending a named <code>list</code> &ldquo;crit.components&rdquo;
to the returned value as an attribute.
The <code>components</code> argument takes a character vector of the names of the
meta information, i.e., the names of the named &ldquo;crit.components&rdquo; list.
Default is the empty character vector.</p>
</td></tr>
<tr><td><code id="makeMBOInfillCrit_+3A_params">params</code></td>
<td>
<p>[<code>list</code>]<br />
Named list of parameters for the infill criterion. There values may be used
by <span class="pkg">mlrMBO</span> internally.
Default is the empty list.</p>
</td></tr>
<tr><td><code id="makeMBOInfillCrit_+3A_requires.se">requires.se</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Does the infill criterion require the regression learner to provide a standard
error estimation?
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+MBOInfillCrit">MBOInfillCrit</a></code>]
</p>


<h3>Predefined standard infill criteria</h3>


<dl>
<dt>crit.ei</dt><dd><p>Expected Improvement</p>
</dd>
<dt>crit.mr</dt><dd><p>Mean response</p>
</dd>
<dt>crit.se</dt><dd><p>Standard error</p>
</dd>
<dt>crit.cb</dt><dd><p>Confidence bound with lambda automatically chosen, see <code><a href="#topic+infillcrits">infillcrits</a></code></p>
</dd>
<dt>crit.cb1</dt><dd><p>Confidence bound with lambda=1</p>
</dd>
<dt>crit.cb2</dt><dd><p>Confidence bound with lambda=2</p>
</dd>
<dt>crit.aei</dt><dd><p>Augmented expected improvement</p>
</dd>
<dt>crit.eqi</dt><dd><p>Expected quantile improvement</p>
</dd>
<dt>crit.dib1</dt><dd><p>Direct indicator-based with lambda=1</p>
</dd>
</dl>


<hr>
<h2 id='makeMBOLearner'>Generate default learner.</h2><span id='topic+makeMBOLearner'></span><span id='topic+mbo_default_learner'></span>

<h3>Description</h3>

<p>This is a helper function that generates a default surrogate, based on properties of the objective
function and the selected infill criterion.
</p>
<p>For numeric-only (including integers) parameter spaces without any dependencies:
</p>

<ul>
<li><p>A Kriging model &ldquo;regr.km&rdquo; with kernel &ldquo;matern3_2&rdquo; is created.
</p>
</li>
<li><p>If the objective function is deterministic we add a small nugget effect (10^-8*Var(y),
y is vector of observed outcomes in current design) to increase numerical stability to
hopefully prevent crashes of DiceKriging.
</p>
</li>
<li><p>If the objective function is noisy the nugget effect will be estimated with
<code>nugget.estim = TRUE</code> (but you can override this in <code>...</code>.
Also <code>jitter</code> is set to <code>TRUE</code> to circumvent a problem with DiceKriging where already
trained input values produce the exact trained output.
For further information check the <code>$note</code> slot of the created learner.
</p>
</li>
<li><p>Instead of the default <code>"BFGS"</code> optimization method we use rgenoud (<code>"gen"</code>),
which is a hybrid algorithm, to combine global search based on genetic algorithms and local search
based on gradients.
This may improve the model fit and will less frequently produce a constant surrogate model.
You can also override this setting in <code>...</code>.
</p>
</li></ul>

<p>For mixed numeric-categorical parameter spaces, or spaces with conditional parameters:
</p>

<ul>
<li><p>A random regression forest &ldquo;regr.randomForest&rdquo; with 500 trees is created.
</p>
</li>
<li><p>The standard error of a prediction (if required by the infill criterion) is estimated
by computing the jackknife-after-bootstrap.
This is the <code>se.method = "jackknife"</code> option of the &ldquo;regr.randomForest&rdquo; Learner.

</p>
</li></ul>

<p>If additionally dependencies are in present in the parameter space, inactive conditional parameters
are represented by missing <code>NA</code> values in the training design data.frame.
We simply handle those with an imputation method, added to the random forest:
</p>

<ul>
<li><p>If a numeric value is inactive, i.e., missing, it will be imputed by 2 times the
maximum of observed values
</p>
</li>
<li><p>If a categorical value is inactive, i.e., missing, it will be imputed by the
special class label <code>"__miss__"</code>
</p>
</li></ul>

<p>Both of these techniques make sense for tree-based methods and are usually hard to beat, see
Ding et.al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMBOLearner(control, fun, config = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMBOLearner_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object for mbo.</p>
</td></tr>
<tr><td><code id="makeMBOLearner_+3A_fun">fun</code></td>
<td>
<p>[<code>smoof_function</code>] <br />
The same objective function which is also passed to <code><a href="#topic+mbo">mbo</a></code>.</p>
</td></tr>
<tr><td><code id="makeMBOLearner_+3A_config">config</code></td>
<td>
<p>[<code>named list</code>] <br />
Named list of config option to overwrite global settings set via <code><a href="mlr.html#topic+configureMlr">configureMlr</a></code> for this specific learner.</p>
</td></tr>
<tr><td><code id="makeMBOLearner_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further parameters passed to the constructed learner.
Will overwrite mlrMBO's defaults.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>Learner</code>]
</p>


<h3>References</h3>

<p>Ding, Yufeng, and Jeffrey S. Simonoff. An investigation of missing data methods for
classification trees applied to binary response data.
Journal of Machine Learning Research 11.Jan (2010): 131-170.
</p>

<hr>
<h2 id='makeMBOTrafoFunction'>Create a transformation function for MBOExampleRun.</h2><span id='topic+makeMBOTrafoFunction'></span>

<h3>Description</h3>

<p>Creates a transformation function for MBOExampleRun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMBOTrafoFunction(name, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMBOTrafoFunction_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the transformation.</p>
</td></tr>
<tr><td><code id="makeMBOTrafoFunction_+3A_fun">fun</code></td>
<td>
<p>[<code>function</code>]<br />
R function which expects a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of type MBOTrafoFunction.
</p>


<h3>See Also</h3>

<p><a href="#topic+trafos">trafos</a>
</p>

<hr>
<h2 id='mbo'>Optimizes a function with sequential model based optimization.</h2><span id='topic+mbo'></span>

<h3>Description</h3>

<p>See <a href="#topic+mbo_parallel">mbo_parallel</a> for all parallelization options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbo(
  fun,
  design = NULL,
  learner = NULL,
  control = NULL,
  show.info = getOption("mlrMBO.show.info", TRUE),
  more.args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbo_+3A_fun">fun</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Fitness function to optimize.
For one dimensional target functions you can obtain a <code>smoof_function</code> by using <code><a href="smoof.html#topic+makeSingleObjectiveFunction">makeSingleObjectiveFunction</a></code>.
For multi dimensional functions use <code><a href="smoof.html#topic+makeMultiObjectiveFunction">makeMultiObjectiveFunction</a></code>.
It is possible to return even more information which will be stored
in the optimization path. To achieve this, simply append the attribute &ldquo;extras&rdquo;
to the return value of the target function. This has to be a named list of scalar values.
Each of these values will be stored additionally in the optimization path.</p>
</td></tr>
<tr><td><code id="mbo_+3A_design">design</code></td>
<td>
<p>[<code>data.frame</code>]<br />
Initial design as data frame.
If the y-values are not already present in design, mbo will evaluate the points.
If the parameters have corresponding trafo functions, the design must not be transformed before it is passed!
Functions to generate designs are available in <code>ParamHelpers</code>: <code><a href="ParamHelpers.html#topic+generateDesign">generateDesign</a></code>, <code><a href="ParamHelpers.html#topic+generateGridDesign">generateGridDesign</a></code>, <code><a href="ParamHelpers.html#topic+generateRandomDesign">generateRandomDesign</a></code>.
Default is <code>NULL</code>, which means <code><a href="ParamHelpers.html#topic+generateDesign">generateDesign</a></code> is called and a design of size 4 times number of all parameters is created
The points are drawn via <code><a href="lhs.html#topic+maximinLHS">maximinLHS</a></code> to maximize the minimal distance between design points.</p>
</td></tr>
<tr><td><code id="mbo_+3A_learner">learner</code></td>
<td>
<p>[<code><a href="mlr.html#topic+Learner">Learner</a></code>]<br />
Regression learner from mlr, which is used as a surrogate to model our fitness function.
If <code>NULL</code> (default), the default learner is determined as described here: <a href="#topic+mbo_default_learner">mbo_default_learner</a>.</p>
</td></tr>
<tr><td><code id="mbo_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object for mbo.</p>
</td></tr>
<tr><td><code id="mbo_+3A_show.info">show.info</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Verbose output on console?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mbo_+3A_more.args">more.args</code></td>
<td>
<p>[list]<br />
Further arguments passed to fitness function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+MBOSingleObjResult">MBOSingleObjResult</a></code> | <code><a href="#topic+MBOMultiObjResult">MBOMultiObjResult</a></code>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple 2d objective function
obj.fun = makeSingleObjectiveFunction(
 fn = function(x) x[1]^2 + sin(x[2]),
 par.set = makeNumericParamSet(id = "x", lower = -1, upper = 1, len = 2)
)

# create base control object
ctrl = makeMBOControl()

# do three MBO iterations
ctrl = setMBOControlTermination(ctrl, iters = 3L)

# use 500 points in the focussearch (should be sufficient for 2d)
ctrl = setMBOControlInfill(ctrl, opt.focussearch.points = 500)
# create initial design
des = generateDesign(n = 5L, getParamSet(obj.fun), fun = lhs::maximinLHS)

# start mbo
res = mbo(obj.fun, design = des, control = ctrl)

print(res)
## Not run: 
plot(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='mbo_OptPath'>OptPath in mlrMBO</h2><span id='topic+mbo_OptPath'></span>

<h3>Description</h3>

<p>In mlrMBO the <code><a href="ParamHelpers.html#topic+OptPath">OptPath</a></code> contains extra information next to the information documented in <code><a href="ParamHelpers.html#topic+OptPath">OptPath</a></code>.
</p>
<p>The extras are:
</p>

<dl>
<dt>train.time</dt><dd><p>Time to train the model(s) that produced the points. Only the first slot of the vector is used (if we have multiple points), rest are NA.</p>
</dd>
<dt>propose.time</dt><dd><p>Time needed to propose the point. If we have individual timings from the proposal mechanism, we have one different value per point here. If all were generated in one go, we only have one timing, we store it in the slot for the first point, rest are NA.</p>
</dd>
<dt>errors.model</dt><dd><p>Possible Error Messages. If point-producing model(s) crashed they are replicated for all n points, if only one error message was passed we store it for the first point, rest are NA.</p>
</dd>
<dt>prop.type</dt><dd><p>Type of point proposal. Possible values are
</p>

<dl>
<dt>initdesign</dt><dd><p>Points actually not proposed, but in the initial design.</p>
</dd>
<dt>infill_x</dt><dd><p>Here x is a placeholder for the selected infill criterion, e.g., infill_ei for expected improvement.</p>
</dd>
<dt>random_interleave</dt><dd><p>Uniformly sampled points added additionally to the proposed points.</p>
</dd>
<dt>random_filtered</dt><dd><p>If filtering of proposed points located too close to each other is active, these are replaced by random points.</p>
</dd>
<dt>final_eval</dt><dd><p>If <code>final.evals</code> is set in <code><a href="#topic+makeMBOControl">makeMBOControl</a></code>: Final evaluations of the proposed solution to reduce noise in y.</p>
</dd>
</dl>

</dd>
<dt>parego.weight</dt><dd><p>Weight vector sampled for multi-point ParEGO</p>
</dd>
<dt>...</dt><dd><p>Depending on the chosen infill criterion there will be additional columns, e.g. <code>se</code> and <code>mean</code> for the Expected Improvement)</p>
</dd>
</dl>

<p>Moreover, the user may pass additional &ldquo;user extras&rdquo; by appending a named list
of scalar values to the return value of the objective function.
</p>

<hr>
<h2 id='mbo_parallel'>Parallelization in mlrMBO</h2><span id='topic+mbo_parallel'></span>

<h3>Description</h3>

<p>In mlrMBO you can parallelize the tuning on two different levels to speed up computation:
</p>

<ul>
<li><p><code>mlrMBO.feval</code>Multiple evaluations of the target function.
</p>
</li>
<li><p><code>mlrMBO.propose.points</code>Optimization of the infill criteria if multiple are used (e.g. ParEGO and ParallelLCB)
</p>
</li></ul>

<p>Internally the evaluation of the target function is realized with the R package parallelMap.
See the mlrMBO tutorial and the Github project pages of parallelMap for instructions on how to set up parallelization.
The different levels of parallelization can be specified in <code>parallelStart*</code>.
Details for the levels mentioned above are given below:
</p>

<ul>
<li><p>Evaluation of the objective function can be parallelized in cases multiple points are to be evaluated at once. These are: evaluation of the initial design, multiple proposed points per iteration and evaluation of the target function in <code><a href="#topic+exampleRun">exampleRun</a></code>. (Level: <code>mlrMBO.feval</code>)
</p>
</li>
<li><p>Model fitting / point proposal - in some cases where independent, expensive operations are performed. (Level: <code>mlrMBO.propose.points</code>)
</p>
</li></ul>

<p>Details regarding the latter:
</p>

<dl>
<dt>single-objective MBO with LCB multi-point</dt><dd><p>Parallel optimization of LCBs for the lambda-values.</p>
</dd>
<dt>Multi-objective MBO with ParEGO</dt><dd><p>Parallel optimization of scalarization functions.</p>
</dd>
</dl>


<hr>
<h2 id='mboContinue'>Continues an mbo run from a save-file.</h2><span id='topic+mboContinue'></span>

<h3>Description</h3>

<p>Useful if your optimization is likely to crash,
so you can continue from a save point and will not lose too much information and runtime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mboContinue(opt.state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mboContinue_+3A_opt.state">opt.state</code></td>
<td>
<p>[<code>OptState</code> | <code>character(1)</code>]<br />
Either the <code>save.state</code> slot of an <code>MBOResult</code> object, or a file path of a saved MBO state.
See <code>save.on.disk.at</code> argument of <code><a href="#topic+MBOControl">MBOControl</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="#topic+mbo">mbo</a></code>.
</p>

<hr>
<h2 id='mboFinalize'>Finalizes an mbo run from a save-file.</h2><span id='topic+mboFinalize'></span>

<h3>Description</h3>

<p>Useful if your optimization didn't terminate but you want a results nonetheless.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mboFinalize(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mboFinalize_+3A_file">file</code></td>
<td>
<p>[<code>character(1)</code>]<br />
File path of saved MBO state.
See <code>save.on.disk.at</code> argument of <code><a href="#topic+MBOControl">MBOControl</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="#topic+mbo">mbo</a></code>.
</p>

<hr>
<h2 id='MBOMultiObjResult'>Multi-Objective result object.</h2><span id='topic+MBOMultiObjResult'></span>

<h3>Description</h3>


<ul>
<li><p>pareto.front [<code>matrix</code>]Pareto front of all evaluated points.
</p>
</li>
<li><p>pareto.set [<code>list</code> of <code>list</code>s]Pareto set of all evaluated points.
</p>
</li>
<li><p>pareto.inds [<code>numeric</code>]Indices of the Pareto-optimal points in the opt.path
</p>
</li>
<li><p>opt.path [<code><a href="ParamHelpers.html#topic+OptPath">OptPath</a></code>]Optimization path.
Includes all evaluated points and additional information as documented in <a href="#topic+mbo_OptPath">mbo_OptPath</a>.
You can convert it via <code>as.data.frame</code>.
</p>
</li>
<li><p>final.state [<code>character</code>] The final termination state. Gives information why the optimization ended
</p>
</li>
<li><p>models [List of <code><a href="mlr.html#topic+WrappedModel">WrappedModel</a></code>]List of saved regression models.
</p>
</li>
<li><p>control[<code>MBOControl</code>] Control object used in optimization
</p>
</li></ul>


<hr>
<h2 id='MBOSingleObjResult'>Single-Objective result object.</h2><span id='topic+MBOSingleObjResult'></span>

<h3>Description</h3>


<ul>
<li><p>x [<code>list</code>]Named list of proposed optimal parameters.
</p>
</li>
<li><p>y [<code>numeric(1)</code>]Value of objective function at <code>x</code>,
either from evals during optimization or from requested final evaluations,
if those were greater than 0.
</p>
</li>
<li><p>best.ind [<code>numeric(1)</code>]Index of <code>x</code> in the opt.path.
</p>
</li>
<li><p>opt.path [<code><a href="ParamHelpers.html#topic+OptPath">OptPath</a></code>]Optimization path.
Includes all evaluated points and additional information as documented in <a href="#topic+mbo_OptPath">mbo_OptPath</a>.
You can convert it via <code>as.data.frame</code>.
</p>
</li>
<li><p>resample.results [List of <code><a href="mlr.html#topic+ResampleResult">ResampleResult</a></code>]List of the desired <code>resample.results</code> if <code>resample.at</code> is set in <code>makeMBOControl</code>.
</p>
</li>
<li><p>final.state [<code>character</code>] The final termination state. Gives information why the optimization ended. Possible values are
</p>

<dl>
<dt>term.iter</dt><dd><p>Maximal number of iterations reached.</p>
</dd>
<dt>term.time</dt><dd><p>Maximal running time exceeded.</p>
</dd>
<dt>term.exectime</dt><dd><p>Maximal execution time of function evaluations reached.</p>
</dd>
<dt>term.yval</dt><dd><p>Target function value reached.</p>
</dd>
<dt>term.fevals</dt><dd><p>maximal number of function evaluations reached.</p>
</dd>
<dt>term.custom</dt><dd><p>Terminated due to custom, user-defined termination condition.</p>
</dd>
</dl>


</li>
<li><p>models [List of <code><a href="mlr.html#topic+WrappedModel">WrappedModel</a></code>]List of saved regression models if <code>store.model.at</code> is set in <code>makeMBOControl</code>. The default is that it contains the model generated after the last iteration.
</p>
</li>
<li><p>control [<code>MBOControl</code>] Control object used in optimization
</p>
</li></ul>


<hr>
<h2 id='mlrMBO_examples'>mlrMBO examples</h2><span id='topic+mlrMBO_examples'></span>

<h3>Description</h3>

<p>Different scenarios of the usage of mlrMBO and visualizations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################################################
###
### optimizing a simple sin(x) with mbo / EI
###
#####################################################
## Not run: 
library(ggplot2)
library(mlrMBO)
configureMlr(show.learner.output = FALSE)
set.seed(1)

obj.fun = makeSingleObjectiveFunction(
  name = "Sine",
  fn = function(x) sin(x),
  par.set = makeNumericParamSet(lower = 3, upper = 13, len = 1),
  global.opt.value = -1
)

ctrl = makeMBOControl(propose.points = 1)
ctrl = setMBOControlTermination(ctrl, iters = 10L)
ctrl = setMBOControlInfill(ctrl, crit = makeMBOInfillCritEI(), 
  opt = "focussearch", opt.focussearch.points = 500L)

lrn = makeMBOLearner(ctrl, obj.fun)

design = generateDesign(6L, getParamSet(obj.fun), fun = lhs::maximinLHS)

run = exampleRun(obj.fun, design = design, learner = lrn,
  control = ctrl, points.per.dim = 100, show.info = TRUE)

plotExampleRun(run, densregion = TRUE, gg.objects = list(theme_bw()))

## End(Not run)
#####################################################
###
### optimizing branin in 2D with mbo / EI #####
###
#####################################################
## Not run: 
library(mlrMBO)
library(ggplot2)
set.seed(1)
configureMlr(show.learner.output = FALSE)

obj.fun = makeBraninFunction()

ctrl = makeMBOControl(propose.points = 1L)
ctrl = setMBOControlTermination(ctrl, iters = 10L)
ctrl = setMBOControlInfill(ctrl, crit = makeMBOInfillCritEI(), 
  opt = "focussearch", opt.focussearch.points = 2000L)

lrn = makeMBOLearner(ctrl, obj.fun)
design = generateDesign(10L, getParamSet(obj.fun), fun = lhs::maximinLHS)

run = exampleRun(obj.fun, design = design, learner = lrn, control = ctrl,
	points.per.dim = 50L, show.info = TRUE)

print(run)

plotExampleRun(run, gg.objects = list(theme_bw()))

## End(Not run)
#####################################################
###
### optimizing a simple sin(x) with multipoint proposal
###
#####################################################
## Not run: 
library(mlrMBO)
library(ggplot2)
set.seed(1)
configureMlr(show.learner.output = FALSE)

obj.fun = makeSingleObjectiveFunction(
  name = "Sine",
  fn = function(x) sin(x),
  par.set = makeNumericParamSet(lower = 3, upper = 13, len = 1L),
  global.opt.value = -1
)

ctrl = makeMBOControl(propose.points = 2L)
ctrl = setMBOControlTermination(ctrl, iters = 10L)
ctrl = setMBOControlInfill(ctrl, crit = makeMBOInfillCritMeanResponse())
ctrl = setMBOControlMultiPoint(
	ctrl,
  method = "moimbo",
  moimbo.objective = "ei.dist",
  moimbo.dist = "nearest.neighbor",
  moimbo.maxit = 200L
)

lrn = makeMBOLearner(ctrl, obj.fun)

design = generateDesign(4L, getParamSet(obj.fun), fun = lhs::maximinLHS)

run = exampleRun(obj.fun, design = design, learner = lrn,
  control = ctrl, points.per.dim = 100, show.info = TRUE)

print(run)

plotExampleRun(run, densregion = TRUE, gg.objects = list(theme_bw()))

## End(Not run)
#####################################################
###
### optimizing branin in 2D with multipoint proposal #####
###
#####################################################
## Not run: 
library(mlrMBO)
library(ggplot2)
set.seed(2)
configureMlr(show.learner.output = FALSE)

obj.fun = makeBraninFunction()

ctrl = makeMBOControl(propose.points = 5L)
ctrl = setMBOControlInfill(ctrl, crit = makeMBOInfillCritMeanResponse())
ctrl = setMBOControlTermination(ctrl, iters = 10L)
ctrl = setMBOControlMultiPoint(ctrl,
  method = "moimbo",
  moimbo.objective = "ei.dist",
  moimbo.dist = "nearest.neighbor",
  moimbo.maxit = 200L
)

lrn = makeLearner("regr.km", predict.type = "se")
design = generateDesign(10L, getParamSet(obj.fun), fun = lhs::maximinLHS)

run = exampleRun(obj.fun, design = design, learner = lrn, control = ctrl,
	points.per.dim = 50L, show.info = TRUE)

print(run)

plotExampleRun(run, gg.objects = list(theme_bw()))

## End(Not run)
#####################################################
###
### optimizing a simple noisy sin(x) with mbo / EI
###
#####################################################
## Not run: 
library(mlrMBO)
library(ggplot2)
set.seed(1)
configureMlr(show.learner.output = FALSE)

# function with noise
obj.fun = makeSingleObjectiveFunction(
  name = "Some noisy function",
  fn = function(x) sin(x) + rnorm(1, 0, 0.1),
  par.set = makeNumericParamSet(lower = 3, upper = 13, len = 1L),
  noisy = TRUE,
  global.opt.value = -1,
  fn.mean = function(x) sin(x)
)

ctrl = makeMBOControl(
  propose.points = 1L,
  final.method = "best.predicted",
  final.evals = 10L
)
ctrl = setMBOControlTermination(ctrl, iters = 5L)

ctrl = setMBOControlInfill(ctrl, crit = makeMBOInfillCritEI(),
 opt = "focussearch", opt.focussearch.points = 500L)

lrn = makeMBOLearner(ctrl, obj.fun)

design = generateDesign(6L, getParamSet(obj.fun), fun = lhs::maximinLHS)

run = exampleRun(obj.fun, design = design, learner = lrn,
  control = ctrl, points.per.dim = 200L, noisy.evals = 50L,
  show.info = TRUE)

print(run)

plotExampleRun(run, densregion = TRUE, gg.objects = list(theme_bw()))

## End(Not run)
#####################################################
###
### optimizing 1D fun with 3 categorical level and
### noisy outout with random forest
###
#####################################################
## Not run: 
library(mlrMBO)
library(ggplot2)
set.seed(1)
configureMlr(show.learner.output = FALSE)

obj.fun = makeSingleObjectiveFunction(
  name = "Mixed decision space function",
  fn = function(x) {
    if (x$foo == "a") {
      return(5 + x$bar^2 + rnorm(1))
    } else if (x$foo == "b") {
      return(4 + x$bar^2 + rnorm(1, sd = 0.5))
    } else {
      return(3 + x$bar^2 + rnorm(1, sd = 1))
    }
  },
  par.set = makeParamSet(
    makeDiscreteParam("foo", values = letters[1:3]),
    makeNumericParam("bar", lower = -5, upper = 5)
  ),
  has.simple.signature = FALSE, # function expects a named list of parameter values
  noisy = TRUE
)

ctrl = makeMBOControl()
ctrl = setMBOControlTermination(ctrl, iters = 10L)

# we can basically do an exhaustive search in 3 values
ctrl = setMBOControlInfill(ctrl, crit = makeMBOInfillCritEI(),
  opt.restarts = 1L, opt.focussearch.points = 3L, opt.focussearch.maxit = 1L)

design = generateDesign(20L, getParamSet(obj.fun), fun = lhs::maximinLHS)

lrn = makeMBOLearner(ctrl, obj.fun)

run = exampleRun(obj.fun, design = design, learner = lrn, control = ctrl,
	points.per.dim = 50L, show.info = TRUE)

print(run)
plotExampleRun(run, densregion = TRUE, gg.objects = list(theme_bw()))

## End(Not run)
#####################################################
###
### optimizing mixed space function
###
#####################################################
## Not run: 
library(mlrMBO)
library(ggplot2)
set.seed(1)
configureMlr(show.learner.output = FALSE)

obj.fun = makeSingleObjectiveFunction(
  name = "Mixed functions",
  fn = function(x) {
    if (x$cat == "a")
      x$num^2
    else
      x$num^2 + 3
  },
  par.set = makeParamSet(
    makeDiscreteParam("cat", values = c("a", "b")),
    makeNumericParam("num", lower = -5, upper = 5)
  ),
  has.simple.signature = FALSE,
  global.opt.value = -1
)

ctrl = makeMBOControl(propose.points = 1L)
ctrl = setMBOControlTermination(ctrl, iters = 10L)
ctrl = setMBOControlInfill(ctrl, crit = makeMBOInfillCritEI(), 
  opt = "focussearch", opt.focussearch.points = 500L)

lrn = makeMBOLearner(ctrl, obj.fun)

design = generateDesign(4L, getParamSet(obj.fun), fun = lhs::maximinLHS)

run = exampleRun(obj.fun, design = design, learner = lrn,
  control = ctrl, points.per.dim = 100L, show.info = TRUE)

print(run)

plotExampleRun(run, densregion = TRUE, gg.objects = list(theme_bw()))

## End(Not run)
#####################################################
###
### optimizing multi-objective function
###
#####################################################
## Not run: 
library(mlrMBO)
library(ggplot2)
set.seed(1)
configureMlr(show.learner.output = FALSE)

obj.fun = makeZDT1Function(dimensions = 2L)

ctrl = makeMBOControl(n.objectives = 2L, propose.points = 2L, save.on.disk.at = integer(0L))
ctrl = setMBOControlTermination(ctrl, iters = 5L)
ctrl = setMBOControlInfill(ctrl, crit = makeMBOInfillCritDIB(),
  opt.focussearch.points = 10000L)
ctrl = setMBOControlMultiObj(ctrl, parego.s = 100)
learner = makeMBOLearner(ctrl, obj.fun)

design = generateDesign(5L, getParamSet(obj.fun), fun = lhs::maximinLHS)

run = exampleRunMultiObj(obj.fun, design = design, learner = learner, ctrl, points.per.dim = 50L,
  show.info = TRUE, nsga2.args = list())

plotExampleRun(run, gg.objects = list(theme_bw()))

## End(Not run)
#####################################################
###
### optimizing multi objective function and plots
###
#####################################################
## Not run: 
library(mlrMBO)
library(ggplot2)
set.seed(1)
configureMlr(show.learner.output = FALSE)

obj.fun = makeDTLZ1Function(dimensions = 5L, n.objectives = 2L)

ctrl = makeMBOControl(n.objectives = 2L,
  propose.points = 2L)
ctrl = setMBOControlTermination(ctrl, iters = 10L)
ctrl = setMBOControlInfill(ctrl, crit = makeMBOInfillCritEI(), opt.focussearch.points = 1000L,
  opt.focussearch.maxit = 3L)
ctrl = setMBOControlMultiObj(ctrl, method = "parego")
lrn = makeMBOLearner(ctrl, obj.fun)

design = generateDesign(8L, getParamSet(obj.fun), fun = lhs::maximinLHS)

res = mbo(obj.fun, design = design, learner = lrn, control = ctrl, show.info = TRUE)

plot(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='OptProblem'>OptProblem object.</h2><span id='topic+OptProblem'></span>

<h3>Description</h3>

<p>The OptProblem contains all the constants values which define a OptProblem within our MBO Steps.
It is an environment and is always pointed at by the OptState.
</p>

<hr>
<h2 id='OptResult'>OptResult object.</h2><span id='topic+OptResult'></span>

<h3>Description</h3>

<p>The OptResult stores all entities which are not needed while optimizing but are needed to build the final result.
It can contains fitted surrogate models at certain times as well as resample objects.
When the optimization ended it will contain the [<code>MBOResult</code>].
</p>

<hr>
<h2 id='OptState'>OptState object.</h2><span id='topic+OptState'></span>

<h3>Description</h3>

<p>The OptState is the central component of the mbo iterations.
This environment contains every necessary information needed during optimization in MBO.
It also links to the <code><a href="#topic+OptProblem">OptProblem</a></code> and to the <code><a href="#topic+OptResult">OptResult</a></code>.
</p>

<hr>
<h2 id='plot.OptState'>Generate ggplot2 Object</h2><span id='topic+plot.OptState'></span>

<h3>Description</h3>

<p>Plots the values of the infill criterion for a 1- and 2-dimensional numerical search space for a given <code><a href="#topic+OptState">OptState</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OptState'
plot(x, scale.panels = FALSE, points.per.dim = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.OptState_+3A_x">x</code></td>
<td>
<p>[<code>OptState</code>]<br />
The OptState.</p>
</td></tr>
<tr><td><code id="plot.OptState_+3A_scale.panels">scale.panels</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code> the values in each panel will be scaled to [0,1].</p>
</td></tr>
<tr><td><code id="plot.OptState_+3A_points.per.dim">points.per.dim</code></td>
<td>
<p>[<code>integer</code>]<br />
Number of (regular spaced) points at which to
evaluate the surrogate per dimension.
Default is 100.</p>
</td></tr>
<tr><td><code id="plot.OptState_+3A_...">...</code></td>
<td>
<p>[any] <br />
Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='plotExampleRun'>Renders plots for exampleRun objects and displays them.</h2><span id='topic+plotExampleRun'></span>

<h3>Description</h3>

<p>The graphical output depends on the target function at hand.
- For 1D numeric functions the upper plot shows the true function (if known),
the model and the (infill) points. The lower plot shows the infill criterion.
- For 2D mixed target functions only one plot is displayed.
- For 2D numeric only target functions up to four plots are presented to the
viewer:
- levelplot of the true function landscape (with [infill] points),
- levelplot of the model landscape (with [infill] points),
- levelplot of the infill criterion
- levelplot of the standard error (only if learner supports standard error estimation).
- For bi-criteria target functions the upper plot shows the target space and the lower
plot displays the x-space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotExampleRun(
  object,
  iters,
  pause = interactive(),
  densregion = TRUE,
  se.factor = 1,
  single.prop.point.plots = FALSE,
  xlim = NULL,
  ylim = NULL,
  point.size = 3,
  line.size = 1,
  trafo = NULL,
  colors = c("red", "blue", "green"),
  gg.objects = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotExampleRun_+3A_object">object</code></td>
<td>
<p>[<code>function</code>]<br />
<code>MBOExampleRun</code> object from <code>exampleRun</code> or
<code>MBOExampleRunMultiObj</code> object from <code>exampleRunMultiObj</code>.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_iters">iters</code></td>
<td>
<p>[<code>integer</code>]<br />
Selected iterations of <code>object</code> to produce plots.
Default is all iterations.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_pause">pause</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the process be paused after each iteration?
Default is <code>interactive()</code>.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_densregion">densregion</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the background be shaded? Default is <code>TRUE</code>.
Only used if learner supports computation of standard error.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_se.factor">se.factor</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
If the model provides local standard error estimation,
in addition to the mean response <code>yhat(x) +- se.factor * se(x)</code>
is plotted above and below.
Default is 1.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_single.prop.point.plots">single.prop.point.plots</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Parameter for MOI-MBO Multi-point proposal: Should every proposed point
be displayed in a single plot - or one plot per Iteration? Default is FALSE
indicating single plots per proposed points.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_xlim">xlim</code></td>
<td>
<p>[<code>numeric(2)</code>]<br />
For 1D: <code>xlim</code> parameter for first and second plot.
Default is range of x-values evaluated in run object <code>x</code>.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_ylim">ylim</code></td>
<td>
<p>[<code>numeric(2)</code>]<br />
For 1D: <code>ylim</code> parameter for first plot, for the second plot <code>ylim</code> is always set
automatically, depending on the range of the evaluated infill criterion.
Default for the first plot is a heuristic to have the true function
and <code>yhat(x) +- se.factor2 * se(x)</code> both in the plot. Note that this heuristic might
change the <code>ylim</code> setting between plot iterations.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_point.size">point.size</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Point size for plotted points. Default is 3.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_line.size">line.size</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Line width of the graphs of plotted functions.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_trafo">trafo</code></td>
<td>
<p>[<code>list</code>]<br />
List of transformation functions of type <code>MBOTrafoFunction</code> for
the different plots.
For 1D: The list elements should be named with &ldquo;y&rdquo; (applied to objective function and model)
or &ldquo;crit&rdquo; (applied to the criterion). Only applied to plots with numeric parameters.
For 2D: The list should contain at least one element &ldquo;y&rdquo;, &ldquo;yhat&rdquo;, &ldquo;crit&rdquo;
or &ldquo;se&rdquo;.
This way one can specify different transformations for different plots.
If a single function is provided, this function is used for all plots.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_colors">colors</code></td>
<td>
<p>[<code>character(3)</code>]
Specify colors for point in the plots. Must be a vector of length 3,
each element a color for the type design, prop and seq respectively.
Default is red for the initial design, blue for already proposed points
and green for the actual iteration.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_gg.objects">gg.objects</code></td>
<td>
<p>[<code>list)</code>]
List of <code>gg</code> objects that should be added to all ggplots.</p>
</td></tr>
<tr><td><code id="plotExampleRun_+3A_...">...</code></td>
<td>
<p>[any]<br />
Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>

<hr>
<h2 id='plotMBOResult'>MBO Result Plotting</h2><span id='topic+plotMBOResult'></span><span id='topic+plot.MBOSingleObjResult'></span><span id='topic+plot.MBOMultiObjResult'></span>

<h3>Description</h3>

<p>Plots any MBO result objects. Plots for X-Space, Y-Space and any column in
the optimization path are available. This function uses
<code><a href="ParamHelpers.html#topic+plotOptPath">plotOptPath</a></code> from package <code>ParamHelpers</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MBOSingleObjResult'
plot(x, iters = NULL, pause = interactive(), ...)

## S3 method for class 'MBOMultiObjResult'
plot(x, iters = NULL, pause = interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMBOResult_+3A_x">x</code></td>
<td>
<p>[<code>MBOResult</code>]<br />
<code>MBOSingleObjResult</code> or <code>MBOMultiObjResult</code> object.</p>
</td></tr>
<tr><td><code id="plotMBOResult_+3A_iters">iters</code></td>
<td>
<p>[<code>integer</code>]<br />
Iterations to be plotted, 0 indicates the initial design. Default is all iterations.</p>
</td></tr>
<tr><td><code id="plotMBOResult_+3A_pause">pause</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the process be paused after each iteration?
Default is <code>interactive()</code>.</p>
</td></tr>
<tr><td><code id="plotMBOResult_+3A_...">...</code></td>
<td>
<p>Additional parameters for the <code><a href="ParamHelpers.html#topic+plotOptPath">plotOptPath</a></code>
function in package <code>ParamHelpers</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.MBOControl'>Print mbo control object.</h2><span id='topic+print.MBOControl'></span>

<h3>Description</h3>

<p>Print mbo control object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MBOControl'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.MBOControl_+3A_x">x</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object.</p>
</td></tr>
<tr><td><code id="print.MBOControl_+3A_...">...</code></td>
<td>
<p>[any]<br />
Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='proposePoints'>Propose candidates for the objective function</h2><span id='topic+proposePoints'></span>

<h3>Description</h3>

<p>Propose points for the objective function that should be evaluated according to the infill criterion and the recent evaluations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proposePoints(opt.state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proposePoints_+3A_opt.state">opt.state</code></td>
<td>
<p>[<code><a href="#topic+OptState">OptState</a></code>]</p>
</td></tr>
</table>

<hr>
<h2 id='renderExampleRunPlot'>Renders plots for exampleRun objects, either in 1D or 2D, or
exampleRunMultiObj objects.</h2><span id='topic+renderExampleRunPlot'></span>

<h3>Description</h3>

<p>The graphical output depends on the target function at hand.
- For 1D numeric functions the upper plot shows the true function (if known),
the model and the (infill) points. The lower plot shows the infill criterion.
- For 2D mixed target functions only one plot is displayed.
- For 2D numeric only target functions up to four plots are presented to the
viewer:
- levelplot of the true function landscape (with [infill] points),
- levelplot of the model landscape (with [infill] points),
- levelplot of the infill criterion
- levelplot of the standard error (only if learner supports standard error estimation).
- For bi-criteria target functions the upper plot shows the target space and the lower
plot displays the x-space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renderExampleRunPlot(
  object,
  iter,
  densregion = TRUE,
  se.factor = 1,
  single.prop.point.plots = FALSE,
  xlim = NULL,
  ylim = NULL,
  point.size = 3,
  line.size = 1,
  trafo = NULL,
  colors = c("red", "blue", "green"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renderExampleRunPlot_+3A_object">object</code></td>
<td>
<p>[<code>function</code>]<br />
<code>MBOExampleRun</code> or <code>MBOExampleRunMultiObj</code> object.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_iter">iter</code></td>
<td>
<p>[<code>integer</code>]<br />
Selected iteration of <code>object</code> to render plots for.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_densregion">densregion</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the background be shaded? Default is <code>TRUE</code>.
Only used if learner supports computation of standard error.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_se.factor">se.factor</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
If the model provides local standard error estimation,
in addition to the mean response <code>yhat(x) +- se.factor * se(x)</code>
is plotted above and below.
Default is 1.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_single.prop.point.plots">single.prop.point.plots</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Parameter for MOI-MBO Multi-point proposal: Should every proposed point
be displayed in a single plot - or one plot per Iteration? Default is FALSE
indicating single plots per proposed points.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_xlim">xlim</code></td>
<td>
<p>[<code>numeric(2)</code>]<br />
For 1D: <code>xlim</code> parameter for first and second plot.
Default is range of x-values evaluated in run object <code>object</code>.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_ylim">ylim</code></td>
<td>
<p>[<code>numeric(2)</code>]<br />
For 1D: <code>ylim</code> parameter for first plot, for the second plot <code>ylim</code> is always set
automatically, depending on the range of the evaluated infill criterion.
Default for the first plot is a heuristic to have the true function
and <code>yhat(x) +- se.factor2 * se(x)</code> both in the plot. Note that this heuristic might
change the <code>ylim</code> setting between plot iterations.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_point.size">point.size</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Point size for plotted points. Default is 3.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_line.size">line.size</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Line width of the graphs of plotted functions.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_trafo">trafo</code></td>
<td>
<p>[<code>list</code>]<br />
List of transformation functions of type <code>MBOTrafoFunction</code> for
the different plots.
For 1D: The list elements should be named with &ldquo;y&rdquo; (applied to objective function and model)
or &ldquo;crit&rdquo; (applied to the criterion). Only applied to plots with numeric parameters.
For 2D: The list should contain at least one element &ldquo;y&rdquo;, &ldquo;yhat&rdquo;, &ldquo;crit&rdquo;
or &ldquo;se&rdquo;.
This way one can specify different transformations for different plots.
If a single function is provided, this function is used for all plots.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_colors">colors</code></td>
<td>
<p>[<code>character(3)</code>]
Specify colors for point in the plots. Must be a vector of length 3,
each element a color for the type design, prop and seq respectively.
Default is red for the initial design, blue for already proposed points
and green for the actual iteration.</p>
</td></tr>
<tr><td><code id="renderExampleRunPlot_+3A_...">...</code></td>
<td>
<p>[any]<br />
Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>]. List containing separate ggplot object. The number of plots depends on
the type of MBO problem. See the description for details.
</p>

<hr>
<h2 id='setMBOControlInfill'>Extends mbo control object with infill criteria and infill optimizer options.</h2><span id='topic+setMBOControlInfill'></span>

<h3>Description</h3>

<p>Please note that internally all infill criteria are minimized. So for some of them,
we internally compute their negated version, e.g., for EI or also for CB when the objective is to
be maximized. In the latter case mlrMBO actually computes the negative upper confidence bound and
minimizes that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMBOControlInfill(
  control,
  crit = NULL,
  interleave.random.points = 0L,
  filter.proposed.points = NULL,
  filter.proposed.points.tol = NULL,
  opt = "focussearch",
  opt.restarts = NULL,
  opt.focussearch.maxit = NULL,
  opt.focussearch.points = NULL,
  opt.cmaes.control = NULL,
  opt.ea.maxit = NULL,
  opt.ea.mu = NULL,
  opt.ea.sbx.eta = NULL,
  opt.ea.sbx.p = NULL,
  opt.ea.pm.eta = NULL,
  opt.ea.pm.p = NULL,
  opt.ea.lambda = NULL,
  opt.nsga2.popsize = NULL,
  opt.nsga2.generations = NULL,
  opt.nsga2.cprob = NULL,
  opt.nsga2.cdist = NULL,
  opt.nsga2.mprob = NULL,
  opt.nsga2.mdist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMBOControlInfill_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object for mbo.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_crit">crit</code></td>
<td>
<p>[<code><a href="#topic+MBOInfillCrit">MBOInfillCrit</a></code>]<br />
How should infill points be rated. See <code><a href="#topic+infillcrits">infillcrits</a></code> for an overview
of available infill criteria or implement a custom one via <code><a href="#topic+makeMBOInfillCrit">makeMBOInfillCrit</a></code>.#
Default is &ldquo;(lower) confidence bound&rdquo; (see <code><a href="#topic+makeMBOInfillCritCB">makeMBOInfillCritCB</a></code>).</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_interleave.random.points">interleave.random.points</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Add <code>interleave.random.points</code> uniformly sampled points additionally to the
regular proposed points in each step.
If <code>crit="random"</code> this value will be neglected.
Default is 0.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_filter.proposed.points">filter.proposed.points</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Design points located too close to each other can lead to
numerical problems when using e.g. kriging as a surrogate model.
This may solve the 'leading minor of order ...' error during model fit.
This parameter activates or deactivates a heuristic to handle this issue.
If <code>TRUE</code>, proposed points whose distance to design points or other current
candidate points is smaller than <code>filter.proposed.points.tol</code>, are replaced by random points.
If enabled, the column entry for <code>prop.type</code> is set to &ldquo;random_filter&rdquo; in the resulting <code>opt.path</code>,
so you can see whether such a replacement happened.
This does only work for numeric parameter sets without any discrete parameters.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_filter.proposed.points.tol">filter.proposed.points.tol</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Tolerance value filtering of proposed points. We currently use a maximum metric
to calculate the distance between points.
Default is 0.0001.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt">opt</code></td>
<td>
<p>[<code>character(1)</code>]<br />
How should SINGLE points be proposed by using the surrogate model. Possible values are:
&ldquo;focussearch&rdquo;: In several iteration steps the parameter space is
focused on an especial promising region according to infill criterion.
&ldquo;cmaes&rdquo;: Use CMA-ES (function <code><a href="cmaesr.html#topic+cmaes">cmaes</a></code> from package <span class="pkg">cmaesr</span>
to optimize infill criterion. If all CMA-ES runs fail, a random point is generated
instead and a warning informs about it.
&ldquo;ea&rdquo;: Use an (mu+1) EA to optimize infill criterion.
&ldquo;nsga2&rdquo;: NSGA2 for multi obj. optimizations. Needed for mspot.
Default is &ldquo;focussearch&rdquo;.
Alternatively, you may pass a function name as string.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.restarts">opt.restarts</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of independent restarts for optimizer of infill criterion.
If <code>opt == "cmaes"</code> the first start point for the optimizer is always the
currently best point in the design of already visited points. Subsequent starting
points are chosen according to the CMA-ES restart strategy introduced by Auger
and Hansen. For details see the corresponding paper in the references and the help
page of the underlying optimizer <code><a href="cmaesr.html#topic+cmaes">cmaes</a></code>.
Default is 3.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.focussearch.maxit">opt.focussearch.maxit</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
For <code>opt = "focussearch"</code>:
Number of iteration to shrink local focus.
Default is 5.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.focussearch.points">opt.focussearch.points</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
For <code>opt = "focussearch"</code>:
Number of points in each iteration of the focus search optimizer.
Default is 1000.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.cmaes.control">opt.cmaes.control</code></td>
<td>
<p>[<code>list</code>]<br />
For <code>opt = "cmaes"</code>:
Control argument for cmaes optimizer.
For the default see the help page of the underlying optimizer <code><a href="cmaesr.html#topic+cmaes">cmaes</a></code>.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.ea.maxit">opt.ea.maxit</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
For <code>opt = "ea"</code>:
Number of iterations / generations of EA.
Default is 500.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.ea.mu">opt.ea.mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
For <code>opt = "ea"</code>:
Population size of EA.
The default is 10 times the number of parameters of the function to optimize.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.ea.sbx.eta">opt.ea.sbx.eta</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
For <code>opt = "ea"</code>:
Distance parameter of crossover distribution , see <code><a href="emoa.html#topic+sbx_operator">sbx_operator</a></code>.
Default is 15.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.ea.sbx.p">opt.ea.sbx.p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
For <code>opt = "ea"</code>:
Probability of 1-point crossover, see <code><a href="emoa.html#topic+sbx_operator">sbx_operator</a></code>.
Default is 0.5.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.ea.pm.eta">opt.ea.pm.eta</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
For <code>opt = "ea"</code>:
Distance parameter of mutation distribution, see <code><a href="emoa.html#topic+pm_operator">pm_operator</a></code>.
Default is 15.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.ea.pm.p">opt.ea.pm.p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
For <code>opt = "ea"</code>:
Probability of 1-point mutation, see <code><a href="emoa.html#topic+pm_operator">pm_operator</a></code>.
Default is 0.5.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.ea.lambda">opt.ea.lambda</code></td>
<td>
<p>[<code>integer{1}</code>]<br />
For <code>opt.ea = "ea"</code>.
Number of children generated in each generation.
Default is 1.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.nsga2.popsize">opt.nsga2.popsize</code></td>
<td>
<p>[<code>integer{1}</code>]<br />
For <code>opt.multiobj.method = "nsga2"</code>.
Population size of nsga2.
Default is 100.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.nsga2.generations">opt.nsga2.generations</code></td>
<td>
<p>[<code>integer{1}</code>]<br />
For <code>opt.multiobj.method = "nsga2"</code>.
Number of populations for of nsga2.
Default is 50.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.nsga2.cprob">opt.nsga2.cprob</code></td>
<td>
<p>[<code>numeric{1}</code>]<br />
For <code>opt.multiobj.method = "nsga2"</code>.
nsga2 param. Default is 0.7.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.nsga2.cdist">opt.nsga2.cdist</code></td>
<td>
<p>[<code>numeric{1}</code>]<br />
For <code>opt.multiobj.method = "nsga2"</code>.
nsga2 param. Default is 5.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.nsga2.mprob">opt.nsga2.mprob</code></td>
<td>
<p>[<code>numeric{1}</code>]<br />
For <code>opt.multiobj.method = "nsga2"</code>.
nsga2 param. Default is 0.2.</p>
</td></tr>
<tr><td><code id="setMBOControlInfill_+3A_opt.nsga2.mdist">opt.nsga2.mdist</code></td>
<td>
<p>[<code>numeric{1}</code>]<br />
For <code>opt.multiobj.method = "nsga2"</code>.
nsga2 param. Default is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>].
</p>


<h3>See Also</h3>

<p>Other MBOControl: 
<code><a href="#topic+makeMBOControl">makeMBOControl</a>()</code>,
<code><a href="#topic+setMBOControlMultiObj">setMBOControlMultiObj</a>()</code>,
<code><a href="#topic+setMBOControlMultiPoint">setMBOControlMultiPoint</a>()</code>,
<code><a href="#topic+setMBOControlTermination">setMBOControlTermination</a>()</code>
</p>

<hr>
<h2 id='setMBOControlMultiObj'>Set multi-objective options.</h2><span id='topic+setMBOControlMultiObj'></span>

<h3>Description</h3>

<p>Extends MBO control object with multi-objective specific options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMBOControlMultiObj(
  control,
  method = NULL,
  ref.point.method = NULL,
  ref.point.offset = NULL,
  ref.point.val = NULL,
  parego.s = NULL,
  parego.rho = NULL,
  parego.use.margin.points = NULL,
  parego.sample.more.weights = NULL,
  parego.normalize = NULL,
  dib.indicator = NULL,
  mspot.select.crit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMBOControlMultiObj_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object for mbo.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_method">method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Which multi-objective method should be used?
&ldquo;parego&rdquo;: The ParEGO algorithm.
&ldquo;dib&rdquo;: Direct indicator-based method. Subsumes SMS-EGO and epsilon-EGO.
&ldquo;mspot&rdquo;: Directly optimizes multicrit problem where we substitute the true
objectives with model-based infill crits via an EMOA.
All methods can also propose multiple points in parallel.
Default is &ldquo;dib&rdquo;.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_ref.point.method">ref.point.method</code></td>
<td>
<p>[<code>character(1)</code>] <br />
Method for the determination of the reference point used for S-metric.
Currently used for &ldquo;mspot&rdquo; and &ldquo;dib&rdquo; with indicator &ldquo;sms&rdquo;.
Possible Values are:
&ldquo;all&rdquo;: In each dimension: maximum of all points + <code>ref.point.offset</code>.
&ldquo;front&rdquo;: In each dimension: maximum of all non-dominated points + <code>ref.point.offset</code>
&ldquo;const&rdquo;: Constant value, see <code>ref.point.val</code>.
Default is &ldquo;all&rdquo;.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_ref.point.offset">ref.point.offset</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
See <code>ref.point.method</code>, default is 1.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_ref.point.val">ref.point.val</code></td>
<td>
<p>[<code>numeric</code>]<br />
Constant value of reference point for hypervolume calculation.
Used if <code>ref.point.method = "const"</code>. Has to be specified in this case.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_parego.s">parego.s</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Parameter of parego - controls the number of weighting vectors. The default
depends on <code>n.objectives</code> and leads to ca. 100000 different possible
weight vectors. The defaults for (2, 3, 4, 5, 6) dimensions are (100000,
450, 75, 37, 23) and 10 for higher dimensions.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_parego.rho">parego.rho</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Parameter of parego - factor for Tchebycheff function. Default 0.05 as
suggested in parego paper.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_parego.use.margin.points">parego.use.margin.points</code></td>
<td>
<p>[<code>logical</code>]<br />
For each target function: Should the weight vector (0, ..., 0, 1, 0, ..., 0),
i.e. the weight vector with only 0 and a single 1 at the i-th position for
the i-th target function, be drawn with probability 1? Number of TRUE entries
must be less or equal to <code>propose.points</code>
Default is not to do this.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_parego.sample.more.weights">parego.sample.more.weights</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
In each iteration <code>parego.sample.more.weights</code> * <code>propose.points</code>
are sampled and the weights with maximum distance to each other are chosen.
Default is 1, if only 1 point is proposed each iteration, otherwise 5.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_parego.normalize">parego.normalize</code></td>
<td>
<p>[<code>character</code>] <br />
Normalization to use. Either map the whole image space to [0, 1] (<code>standard</code>, the default)
or just the paretofront (<code>front</code>).</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_dib.indicator">dib.indicator</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Either &ldquo;sms&rdquo; (SMS-EGO like algorithm) or &ldquo;eps&rdquo; (epsilon-EGO like algorithm).
Default is &ldquo;sms&rdquo;.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiObj_+3A_mspot.select.crit">mspot.select.crit</code></td>
<td>
<p>[<code><a href="#topic+MBOInfillCrit">MBOInfillCrit</a></code>]<br />
Which infill.crit to use in the candidate selection. After the NSGA2
proposed a set of candidates, &ldquo;propose.points&rdquo; are selected via
the hypervolume contribution of this infill.crit.
Possible values are &ldquo;crit.mr&rdquo; and &ldquo;crit.cb&rdquo; (or any other InfillCrit generated with <code><a href="#topic+makeMBOInfillCritCB">makeMBOInfillCritCB</a></code>), default is &ldquo;crit.mr&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>].
</p>


<h3>References</h3>

<p>For more information on the implemented multi-objective procedures the following
sources might be helpful:
Knowles, J.: ParEGO: A hybrid algorithm with on-line landscape
approximation for expensive multiobjective optimization problems. IEEE
Transactions on Evolutionary Computation, 10 (2006) 1, pp. 50-66
</p>
<p>Wagner, T.; Emmerich, M.; Deutz, A.; Ponweiser, W.: On Expected-
Improvement Criteria for Model-Based Multi-Objective Optimization.
In: Proc. 11th Int. Conf. Parallel Problem Solving From Nature (PPSN
XI) - Part I, Krakow, Poland, Schaefer, R.; Cotta, C.; Kolodziej, J.;
Rudolph, G. (eds.), no. 6238 in Lecture Notes in Computer Science,
Springer, Berlin, 2010, ISBN 978-3-642-15843-8, pp. 718-727, doi:10.
1007/978-3-642-15844-5 72
</p>
<p>Wagner, T.: Planning and Multi-Objective Optimization of Manufacturing
Processes by Means of Empirical Surrogate Models.
No. 71 in Schriftenreihe des ISF, Vulkan Verlag, Essen, 2013, ISBN
978-3-8027-8775-1
</p>
<p>Zaefferer, M.; Bartz-Beielstein, T.; Naujoks, B.; Wagner, T.;
Emmerich, M.: A Case Study on Multi-Criteria Optimization of
an Event Detection Software under Limited Budgets. In: Proc.
7th International. Conf. Evolutionary Multi-Criterion Optimization (EMO
2013), March 19-22, Sheffield, UK, R. Purshouse; P. J. Fleming;
C. M. Fonseca; S. Greco; J. Shaw, eds., 2013, vol. 7811 of Lecture
Notes in Computer Science, ISBN 978-3-642-37139-4, pp. 756770,
doi:10.1007/978-3-642-37140-0 56
</p>
<p>Jeong, S.; Obayashi, S.: Efficient global optimization (EGO) for Multi-Objective Problem and Data Mining.
In: Proc. IEEE Congress on
Evolutionary Computation (CEC 2005), Edinburgh, UK, Corne, D.;
et.al. (eds.), IEEE, 2005, ISBN 0-7803-9363-5, pp. 2138-2145
</p>


<h3>See Also</h3>

<p>Other MBOControl: 
<code><a href="#topic+makeMBOControl">makeMBOControl</a>()</code>,
<code><a href="#topic+setMBOControlInfill">setMBOControlInfill</a>()</code>,
<code><a href="#topic+setMBOControlMultiPoint">setMBOControlMultiPoint</a>()</code>,
<code><a href="#topic+setMBOControlTermination">setMBOControlTermination</a>()</code>
</p>

<hr>
<h2 id='setMBOControlMultiPoint'>Set multipoint proposal options.</h2><span id='topic+setMBOControlMultiPoint'></span>

<h3>Description</h3>

<p>Extends an MBO control object with options for multipoint proposal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMBOControlMultiPoint(
  control,
  method = NULL,
  cl.lie = NULL,
  moimbo.objective = NULL,
  moimbo.dist = NULL,
  moimbo.selection = NULL,
  moimbo.maxit = NULL,
  moimbo.sbx.eta = NULL,
  moimbo.sbx.p = NULL,
  moimbo.pm.eta = NULL,
  moimbo.pm.p = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMBOControlMultiPoint_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object for mbo.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_method">method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Method used for proposal of multiple infill points, for parallel batch evaluation.
Possible values are:
&ldquo;cb&rdquo;: Proposes points by optimizing the confidence bound &ldquo;cb&rdquo; criterion,
<code>propose.points</code> times. Each lambda value for &ldquo;cb&rdquo; is drawn randomly from an
exp(1)-distribution, so do not define <code>infill.opt.cb.lambda</code>.
The optimizer for each proposal is configured in the same way as for the single point case,
i. e., by specifying <code>infill.opt</code> and related stuff.
&ldquo;moimbo&rdquo;: Proposes points by multi-objective infill criteria via evolutionary multi-objective optimization.
The EA is a (mu+1) type of algorithm and runs for <code>moimbo.maxit</code> generations.
The population size is set to <code>propose.points</code>.
The selection criterion is <code>moimbo.selection</code>.
If this method is selected the infill criterion in <code>setMBOInfillCrit</code> is ignored.
&ldquo;cl&rdquo;: Proposes points by constant liar strategy.
Only meaningful if <code>infill.crit == "cb"</code>
In the first step the kriging model is fitted based on the real data and the best point is calculated
according to the regular EI-criterion.
Then, the function value of the best point is simply guessed by the worst seen function evaluation.
This lie is used to update the model in order to propose the subsequent point.
The procedure is applied until the number of best points achieves <code>propose.points</code>.
Default is <code>cb</code>.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_cl.lie">cl.lie</code></td>
<td>
<p>[<code>function</code>]<br />
Function used by constant liar method for lying. Default is <code>min</code>.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_moimbo.objective">moimbo.objective</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Objectives which are optimized in multi-objective approach.
Possible values are: &ldquo;mean.dist&rdquo;, &ldquo;ei.dist&rdquo;, &ldquo;mean.se&rdquo;, &ldquo;mean.se.dist&rdquo;.
Default is &ldquo;ei.dist&rdquo;.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_moimbo.dist">moimbo.dist</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Distance function used in multi-objective EA.
Possible values are: &ldquo;nearest.neighbor&rdquo;, &ldquo;nearest.better&rdquo;.
Default is &ldquo;nearest.better&rdquo;.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_moimbo.selection">moimbo.selection</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Method used for selecting 1 element for removal from the population
in each iteration of the multi-objective EA.
Possible values are:
&ldquo;hypervolume&rdquo;: Non-dominated sorting + hypervolume contribution.
&ldquo;crowdingdist&rdquo;: Non-dominated sorting + crowding distance based ranking.
&ldquo;first&rdquo;: Non-dominated sorting + first objective of <code>moimbo.objective</code> as criterion.
&ldquo;last&rdquo;: Non-dominated sorting + last objective of <code>moimbo.objective</code> as criterion.
Default is <code>hypervolume</code>.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_moimbo.maxit">moimbo.maxit</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of generations for multi-objective EA.
Default is 100.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_moimbo.sbx.eta">moimbo.sbx.eta</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Distance parameter of crossover distribution, see <code><a href="emoa.html#topic+sbx_operator">sbx_operator</a></code>.
Default is 15.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_moimbo.sbx.p">moimbo.sbx.p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability of 1-point crossover, see <code><a href="emoa.html#topic+sbx_operator">sbx_operator</a></code>.
Default is 1.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_moimbo.pm.eta">moimbo.pm.eta</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Distance parameter of mutation distribution, see <code><a href="emoa.html#topic+pm_operator">pm_operator</a></code>.
Default is 15.</p>
</td></tr>
<tr><td><code id="setMBOControlMultiPoint_+3A_moimbo.pm.p">moimbo.pm.p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability of 1-point mutation, see <code><a href="emoa.html#topic+pm_operator">pm_operator</a></code>.
Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>].
</p>


<h3>See Also</h3>

<p>Other MBOControl: 
<code><a href="#topic+makeMBOControl">makeMBOControl</a>()</code>,
<code><a href="#topic+setMBOControlInfill">setMBOControlInfill</a>()</code>,
<code><a href="#topic+setMBOControlMultiObj">setMBOControlMultiObj</a>()</code>,
<code><a href="#topic+setMBOControlTermination">setMBOControlTermination</a>()</code>
</p>

<hr>
<h2 id='setMBOControlTermination'>Set termination options.</h2><span id='topic+setMBOControlTermination'></span>

<h3>Description</h3>

<p>Extends an MBO control object with infill criteria and infill optimizer options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMBOControlTermination(
  control,
  iters = NULL,
  time.budget = NULL,
  exec.time.budget = NULL,
  target.fun.value = NULL,
  max.evals = NULL,
  more.termination.conds = list(),
  use.for.adaptive.infill = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMBOControlTermination_+3A_control">control</code></td>
<td>
<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>]<br />
Control object for mbo.</p>
</td></tr>
<tr><td><code id="setMBOControlTermination_+3A_iters">iters</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of sequential optimization steps.</p>
</td></tr>
<tr><td><code id="setMBOControlTermination_+3A_time.budget">time.budget</code></td>
<td>
<p>[<code>numeric(1)</code> | NULL]<br />
Running time budget in seconds. Note that the actual mbo run can take more time since
the condition is checked after each iteration.
The default <code>NULL</code> means: There is no time budget.</p>
</td></tr>
<tr><td><code id="setMBOControlTermination_+3A_exec.time.budget">exec.time.budget</code></td>
<td>
<p>[<code>numeric(1)</code> | NULL]<br />
Execution time (time spent executing the function passed to <code>mbo</code>)
budget in seconds. Note that the actual mbo run can take more time since
the condition is checked after each iteration.
The default <code>NULL</code> means: There is no execution time budget.</p>
</td></tr>
<tr><td><code id="setMBOControlTermination_+3A_target.fun.value">target.fun.value</code></td>
<td>
<p>[<code>numeric(1)</code>] | NULL]<br />
Termination criterion for single-objective optimization: Stop if a function evaluation
is better than this given target.value.
The default <code>NULL</code> means: The function value won't be taken into account for termination.</p>
</td></tr>
<tr><td><code id="setMBOControlTermination_+3A_max.evals">max.evals</code></td>
<td>
<p>[<code>integer(1) | NULL</code>]<br />
Maximal number of function evaluations.
The default <code>NULL</code> means: The total number of evaluations won't be taken into account for termination.</p>
</td></tr>
<tr><td><code id="setMBOControlTermination_+3A_more.termination.conds">more.termination.conds</code></td>
<td>
<p>[<code>list</code>]<br />
Optional list of termination conditions. Each condition needs to be a function
of a single argument <code>opt.state</code> of type <code><a href="#topic+OptState">OptState</a></code> and should
return a list with the following elements:
</p>

<dl>
<dt>term [<code>logical(1)</code>]</dt><dd><p>Logical value indicating whether the
termination condition is met.</p>
</dd>
<dt>message [<code>character(1)</code>]</dt><dd><p>Termination message. At the moment we just allow <code>term.custom</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="setMBOControlTermination_+3A_use.for.adaptive.infill">use.for.adaptive.infill</code></td>
<td>
<p>[<code>character(1)</code>|NULL]<br />
Which termination criterion should determine the progress that is used for adaptive infill criteria like [<code><a href="#topic+makeMBOInfillCritAdaCB">makeMBOInfillCritAdaCB</a></code>].
The default is <code>NULL</code> which means, that the first supplied argument is taken, following the order of the function signature.
Other values can be <code>"iters"</code>, <code>"time.budget"</code>, etc.<br />
If you want to to use it together with a criterion you supplied in <code>more.termination.conds</code>, <code>more.termination.conds</code> has to be a named list and the function further has to return a list element <code>progress</code> with values between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+MBOControl">MBOControl</a></code>].
</p>


<h3>See Also</h3>

<p>Other MBOControl: 
<code><a href="#topic+makeMBOControl">makeMBOControl</a>()</code>,
<code><a href="#topic+setMBOControlInfill">setMBOControlInfill</a>()</code>,
<code><a href="#topic+setMBOControlMultiObj">setMBOControlMultiObj</a>()</code>,
<code><a href="#topic+setMBOControlMultiPoint">setMBOControlMultiPoint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn = smoof::makeSphereFunction(1L)
ctrl = makeMBOControl()

# custom termination condition (stop if target function value reached)
# We neglect the optimization direction (min/max) in this example.
yTargetValueTerminator = function(y.val) {
  force(y.val)
  function(opt.state) {
    opt.path = opt.state$opt.path
    current.best = getOptPathEl(opt.path, getOptPathBestIndex((opt.path)))$y
    term = (current.best &lt;= y.val)
    message = if (!term) NA_character_ else sprintf("Target function value %f reached.", y.val)
    return(list(term = term, message = message))
  }
}

# assign custom termination condition
ctrl = setMBOControlTermination(ctrl, more.termination.conds = list(yTargetValueTerminator(0.05)))
res = mbo(fn, control = ctrl)
print(res)
</code></pre>

<hr>
<h2 id='trafos'>Transformation methods.</h2><span id='topic+trafos'></span><span id='topic+trafoLog'></span><span id='topic+trafoSqrt'></span>

<h3>Description</h3>


<ul>
<li><p><b>logTrafo</b><br /> Natural logarithm.
</p>
</li>
<li><p><b>sqrtTrafo</b><br /> Square root.
</p>
</li></ul>

<p>If negative values occur and the trafo function can handle only positive values,
a shift of the form x - min(x) + 1 is performed prior to the transformation if the
argument <code>handle.violations</code> is set to &ldquo;warn&rdquo; which is the default
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trafoLog(base = 10, handle.violations = "warn")

trafoSqrt(handle.violations = "warn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trafos_+3A_base">base</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
The base with respect to which logarithms are computed.
Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="trafos_+3A_handle.violations">handle.violations</code></td>
<td>
<p>[<code>character(1)</code>]<br />
What should be done, if negative values occur? Setting this option to
&ldquo;warn&rdquo;, which is the default, shifts the function. &ldquo;error&rdquo;
stops the process immediately.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>None
</p>

<hr>
<h2 id='updateSMBO'>Updates SMBO with the new observations</h2><span id='topic+updateSMBO'></span>

<h3>Description</h3>

<p>After a function evaluation you want to update the <code><a href="#topic+OptState">OptState</a></code> to get new proposals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateSMBO(opt.state, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateSMBO_+3A_opt.state">opt.state</code></td>
<td>
<p>[<code><a href="#topic+OptState">OptState</a></code>]
The optimization state.
Generated by <code><a href="#topic+initSMBO">initSMBO</a></code>, this function or an <code><a href="#topic+mbo">mbo</a></code> run.</p>
</td></tr>
<tr><td><code id="updateSMBO_+3A_x">x</code></td>
<td>
<p>[<code>data.frame</code>]
Named x values.
One row per set of x values.</p>
</td></tr>
<tr><td><code id="updateSMBO_+3A_y">y</code></td>
<td>
<p>[<code>numeric|list</code>]
Outcome of the optimization.
For multiple results use a list.
For a result of a multi-objective function use a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="#topic+OptState">OptState</a></code>]
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
