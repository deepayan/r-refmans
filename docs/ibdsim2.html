<!DOCTYPE html><html><head><title>Help for package ibdsim2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ibdsim2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ibdsim2-package'><p>ibdsim2: Simulation of Chromosomal Regions Shared by Family Members</p></a></li>
<li><a href='#convertPos'><p>Conversion of genetic map positions</p></a></li>
<li><a href='#customMap'><p>Custom recombination map</p></a></li>
<li><a href='#estimateCoeffs'><p>Estimation of one- and two-locus relatedness coefficients</p></a></li>
<li><a href='#extractIds'><p>Extract ID labels from simulation output</p></a></li>
<li><a href='#findPattern'><p>Find specific IBD patterns</p></a></li>
<li><a href='#haploDraw'><p>Draw haplotypes onto a pedigree plot</p></a></li>
<li><a href='#ibdsim'><p>IBD simulation</p></a></li>
<li><a href='#karyoDiploid'><p>Diploid karyogram</p></a></li>
<li><a href='#karyogram2'><p>Karyogram plots</p></a></li>
<li><a href='#karyoHaploid'><p>Haploid karyogram</p></a></li>
<li><a href='#loadMap'><p>Load a built-in genetic map</p></a></li>
<li><a href='#maplengths'><p>Physical and genetic map lengths</p></a></li>
<li><a href='#plotSegmentDistribution'><p>Scatter plots of IBD segment distributions</p></a></li>
<li><a href='#profileSimIBD'><p>Simulate markers conditional on a given IBD pattern</p></a></li>
<li><a href='#realised'><p>Realised relatedness</p></a></li>
<li><a href='#segmentStats'><p>Summary statistics for identified segments</p></a></li>
<li><a href='#uniformMap'><p>Uniform recombination maps</p></a></li>
<li><a href='#zeroIBD'><p>Probability of zero IBD</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation of Chromosomal Regions Shared by Family Members</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation of segments shared identical-by-descent (IBD) by
    pedigree members. Using sex specific recombination rates along the
    human genome (Halldorsson et al. (2019)
    &lt;<a href="https://doi.org/10.1126%2Fscience.aau1043">doi:10.1126/science.aau1043</a>&gt;), phased chromosomes are simulated for
    all pedigree members. Applications include calculation of realised
    relatedness coefficients and IBD segment distributions. 'ibdsim2' is
    part of the 'ped suite' collection of packages for pedigree analysis.
    A detailed presentation of the 'ped suite', including a separate
    chapter on 'ibdsim2', is available in the book 'Pedigree analysis in
    R' (Vigeland, 2021, ISBN:9780128244302). A 'shiny' app for visualising
    and comparing IBD distributions is available at
    <a href="https://magnusdv.shinyapps.io/ibdsim2-shiny/">https://magnusdv.shinyapps.io/ibdsim2-shiny/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/magnusdv/ibdsim2">https://github.com/magnusdv/ibdsim2</a>,
<a href="https://magnusdv.github.io/pedsuite/">https://magnusdv.github.io/pedsuite/</a>,
<a href="https://magnusdv.shinyapps.io/ibdsim2-shiny/">https://magnusdv.shinyapps.io/ibdsim2-shiny/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), pedtools (&ge; 2.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, ggplot2, glue, ribd (&ge; 1.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-17 14:31:39 UTC; magnusdv</td>
</tr>
<tr>
<td>Author:</td>
<td>Magnus Dehli Vigeland
    <a href="https://orcid.org/0000-0002-9134-4962"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Magnus Dehli Vigeland &lt;m.d.vigeland@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-17 15:52:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='ibdsim2-package'>ibdsim2: Simulation of Chromosomal Regions Shared by Family Members</h2><span id='topic+ibdsim2'></span><span id='topic+ibdsim2-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Simulation of segments shared identical-by-descent (IBD) by pedigree members. Using sex specific recombination rates along the human genome (Halldorsson et al. (2019) <a href="https://doi.org/10.1126/science.aau1043">doi:10.1126/science.aau1043</a>), phased chromosomes are simulated for all pedigree members. Applications include calculation of realised relatedness coefficients and IBD segment distributions. 'ibdsim2' is part of the 'ped suite' collection of packages for pedigree analysis. A detailed presentation of the 'ped suite', including a separate chapter on 'ibdsim2', is available in the book 'Pedigree analysis in R' (Vigeland, 2021, ISBN:9780128244302). A 'shiny' app for visualising and comparing IBD distributions is available at <a href="https://magnusdv.shinyapps.io/ibdsim2-shiny/">https://magnusdv.shinyapps.io/ibdsim2-shiny/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Magnus Dehli Vigeland <a href="mailto:m.d.vigeland@medisin.uio.no">m.d.vigeland@medisin.uio.no</a> (<a href="https://orcid.org/0000-0002-9134-4962">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/magnusdv/ibdsim2">https://github.com/magnusdv/ibdsim2</a>
</p>
</li>
<li> <p><a href="https://magnusdv.github.io/pedsuite/">https://magnusdv.github.io/pedsuite/</a>
</p>
</li>
<li> <p><a href="https://magnusdv.shinyapps.io/ibdsim2-shiny/">https://magnusdv.shinyapps.io/ibdsim2-shiny/</a>
</p>
</li></ul>


<hr>
<h2 id='convertPos'>Conversion of genetic map positions</h2><span id='topic+convertPos'></span>

<h3>Description</h3>

<p>Convert between physical position (in megabases) and genetic position
(centiMorgan) given a chromosome map. Linear extrapolation is used to convert
positions between map points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertPos(
  chrom = NULL,
  Mb = NULL,
  cM = NULL,
  map = "decode19",
  sex = c("average", "male", "female")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertPos_+3A_chrom">chrom</code></td>
<td>
<p>(Optional) A vector of chromosome labels.</p>
</td></tr>
<tr><td><code id="convertPos_+3A_mb">Mb</code></td>
<td>
<p>A vector of physical positions (in Mb), or NULL.</p>
</td></tr>
<tr><td><code id="convertPos_+3A_cm">cM</code></td>
<td>
<p>A vector of genetic positions (in cM), or NULL.</p>
</td></tr>
<tr><td><code id="convertPos_+3A_map">map</code></td>
<td>
<p>A <code>genomeMap</code>, a <code>chromMap</code>, or a data frame with columns <code>Mb</code> and
<code>cM</code>. By default, <code>loadMap("decode19")</code> is used.</p>
</td></tr>
<tr><td><code id="convertPos_+3A_sex">sex</code></td>
<td>
<p>Either &quot;average&quot;, &quot;male&quot; or &quot;female&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Chromosome 1 of the built-in recombination map
map = loadMap(chrom = 1)[[1]]
head(map$male)

# Conversion Mb -&gt; cM
phys = 1:5
gen = convertPos(Mb = phys, map = map, sex = "male")
gen

# Convert back (note the first position, which was outside of map)
convertPos(cM = gen, map = map, sex = "male")

</code></pre>

<hr>
<h2 id='customMap'>Custom recombination map</h2><span id='topic+customMap'></span>

<h3>Description</h3>

<p>Create custom recombination maps for use in <code><a href="#topic+ibdsim">ibdsim()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>customMap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="customMap_+3A_x">x</code></td>
<td>
<p>A data frame or matrix. See details for format specifications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The column names of <code>x</code> must include either
</p>

<ul>
<li> <p><code>chrom</code>, <code>mb</code> and <code>cm</code>   (sex-averaged map)
</p>
</li></ul>

<p>or
</p>

<ul>
<li> <p><code>chrom</code>, <code>mb</code>, <code>male</code> and <code>female</code>  (sex-specific map)
</p>
</li></ul>

<p>Upper-case letters are allowed in these names. The <code>mb</code> column should contain
physical positions in megabases, while <code>cm</code>, <code>male</code>, <code>female</code> give the
corresponding genetic position in centiMorgans.
</p>


<h3>Value</h3>

<p>An object of class <code>genomeMap</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uniformMap">uniformMap()</a></code>, <code><a href="#topic+loadMap">loadMap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A map including two chromosomes.
df1 = data.frame(chrom = c(1, 1, 2, 2),
                 mb = c(0, 2, 0, 5),
                 cm = c(0, 3, 0, 6))
map1 = customMap(df1)
map1

# Use columns "male" and "female" to make sex specific maps
df2 = data.frame(chrom = c(1, 1, 2, 2),
                 mb = c(0, 2, 0, 5),
                 male = c(0, 3, 0, 6),
                 female = c(0, 4, 0, 7))
map2 = customMap(df2)
map2

</code></pre>

<hr>
<h2 id='estimateCoeffs'>Estimation of one- and two-locus relatedness coefficients</h2><span id='topic+estimateCoeffs'></span><span id='topic+estimateInbreeding'></span><span id='topic+estimateTwoLocusInbreeding'></span><span id='topic+estimateKinship'></span><span id='topic+estimateTwoLocusKinship'></span><span id='topic+estimateKappa'></span><span id='topic+estimateTwoLocusKappa'></span><span id='topic+estimateIdentity'></span><span id='topic+estimateTwoLocusIdentity'></span>

<h3>Description</h3>

<p>Estimate by simulation various relatedness coefficients, and two-locus
versions of the same coefficients, for a given recombination rate. The
current implementation covers inbreeding coefficients, kinship coefficients,
IBD (kappa) coefficients between noninbred individuals, and condensed
identity coefficients. These functions are primarily meant as tools for
validating exact algorithms, e.g., as implemented in the <code>ribd</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateInbreeding(x, id, Nsim, Xchrom = FALSE, verbose = FALSE, ...)

estimateTwoLocusInbreeding(
  x,
  id,
  rho = NULL,
  cM = NULL,
  Nsim,
  Xchrom = FALSE,
  verbose = FALSE,
  ...
)

estimateKinship(x, ids, Nsim, Xchrom = FALSE, verbose = FALSE, ...)

estimateTwoLocusKinship(
  x,
  ids,
  rho = NULL,
  cM = NULL,
  Nsim,
  Xchrom = FALSE,
  verbose = FALSE,
  ...
)

estimateKappa(x, ids, Nsim, Xchrom = FALSE, verbose = FALSE, ...)

estimateTwoLocusKappa(
  x,
  ids,
  rho = NULL,
  cM = NULL,
  Nsim,
  Xchrom = FALSE,
  verbose = FALSE,
  ...
)

estimateIdentity(x, ids, Nsim, Xchrom = FALSE, verbose = FALSE, ...)

estimateTwoLocusIdentity(
  x,
  ids,
  rho = NULL,
  cM = NULL,
  Nsim,
  Xchrom = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateCoeffs_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code><a href="pedtools.html#topic+ped">pedtools::ped()</a></code> object.</p>
</td></tr>
<tr><td><code id="estimateCoeffs_+3A_id">id</code>, <code id="estimateCoeffs_+3A_ids">ids</code></td>
<td>
<p>A vector of one or two ID labels.</p>
</td></tr>
<tr><td><code id="estimateCoeffs_+3A_nsim">Nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="estimateCoeffs_+3A_xchrom">Xchrom</code></td>
<td>
<p>A logical indicating if the loci are X-linked or autosomal.</p>
</td></tr>
<tr><td><code id="estimateCoeffs_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="estimateCoeffs_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+ibdsim">ibdsim()</a></code>, e.g. <code>seed</code>.</p>
</td></tr>
<tr><td><code id="estimateCoeffs_+3A_rho">rho</code></td>
<td>
<p>A scalar in the interval <code style="white-space: pre;">&#8288;[0, 0.5]&#8288;</code>: the recombination fraction
between the two loci, converted to centiMorgans using Haldane's map
function: cM = -50 * log(1 - 2 * rho). Either <code>rho</code> or <code>cM</code> (but not both)
must be non-NULL.</p>
</td></tr>
<tr><td><code id="estimateCoeffs_+3A_cm">cM</code></td>
<td>
<p>A non-negative number: the genetic distance between the two loci,
given in centiMorgans. Either <code>rho</code> or <code>cM</code> (but not both) must be
non-NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the following, let L1 and L2 denote two arbitrary autosomal loci with
recombination rate <code class="reqn">\rho</code>, and let A and B be members of the pedigree
<code>x</code>.
</p>
<p>The <em>two-locus inbreeding coefficient</em> <code class="reqn">f_2(\rho)</code> of A is defined as the
probability that A is autozygous at both L1 and L2 simultaneously.
</p>
<p>The <em>two-locus kinship coefficient</em> <code class="reqn">\phi_2(\rho)</code> of A and B is defined
as the probability that a random gamete emitted from A, and a random gamete
emitted from B, contain IBD alleles at both L1 and L2.
</p>
<p>The <em>two-locus kappa coefficient</em> <code class="reqn">\kappa_{ij}(\rho)</code>, for <code class="reqn">i,j =
0,1,2</code>, of noninbred A and B, is the probability that A and B share exactly
<code>i</code> alleles IBD at L1, and exactly <code>j</code> alleles IBD at L2.
</p>
<p>The <em>two-locus identity coefficient</em> <code class="reqn">\Delta_{ij}</code>, <code class="reqn">i,j = 1,...,9</code>
is defined for any (possibly inbred) A and B, as the probability that A and B
are in identity state <code>i</code> at L1, and state <code>j</code> at L2. This uses the
conventional ordering of the nine condensed identity states. For details, see
for instance the <a href="https://github.com/magnusdv/ribd">GitHub page of the <code>ribd</code> package</a>.
</p>


<h3>Value</h3>

<p><code>estimateInbreeding()</code>: a single probability.
</p>
<p><code>estimateTwoLocusInbreeding()</code>: a single probability.
</p>
<p><code>estimateKappa()</code>: a numeric vector of length 3, with the estimated
<code class="reqn">\kappa</code> coefficients.
</p>
<p><code>estimateTwoLocusKappa()</code>: a symmetric, numerical 3*3 matrix, with the
estimated values of <code class="reqn">\kappa_{ij}</code>, for <code class="reqn">i,j = 0,1,2</code>.
</p>
<p><code>estimateIdentity()</code>: a numeric vector of length 9, with the estimated
identity coefficients.
</p>
<p><code>estimateTwoLocusIdentity()</code>: a symmetric, numerical 9*9 matrix, with the
estimated values of <code class="reqn">\Delta_{ij}</code>, for <code class="reqn">i,j = 1,...,9</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
############################
### Two-locus inbreeding ###
############################

x = cousinPed(0, child = TRUE)
rho = 0.25
Nsim = 10 # Increase!
estimateTwoLocusInbreeding(x, id = 5, rho = rho, Nsim = Nsim, seed = 123)

# Exact:
ribd::twoLocusInbreeding(x, id = 5, rho = rho)

########################################
### Two-locus kappa:                 ###
### Grandparent vs half sib vs uncle ###
########################################

# These are indistinguishable with unlinked loci, see e.g.
# pages 182-183 in Egeland, Kling and Mostad (2016).
# In the following, each simulation approximation is followed
# by its exact counterpart.

rho = 0.25; R = .5 * (rho^2 + (1-rho)^2)
Nsim = 10 # Should be increased to at least 10000

# Grandparent/grandchild
G = linearPed(2); G.ids = c(1,5); # plot(G, hatched = G.ids)
estimateTwoLocusKappa(G, G.ids, rho = rho, Nsim = Nsim, seed = 123)[2,2]
.5*(1-rho) # exact

# Half sibs
H = halfSibPed(); H.ids = c(4,5); # plot(H, hatched = H.ids)
estimateTwoLocusKappa(H, H.ids, rho = rho, Nsim = Nsim, seed = 123)[2,2]
R # exact

# Uncle
U = avuncularPed(); U.ids = c(3,6); # plot(U, hatched = U.ids)
estimateTwoLocusKappa(U, U.ids, rho = rho, Nsim = Nsim, seed = 123)[2,2]
(1-rho) * R + rho/4 # exact

# Exact calculations by ribd:
# ribd::twoLocusIBD(G, G.ids, rho = rho, coefs = "k11")
# ribd::twoLocusIBD(H, H.ids, rho = rho, coefs = "k11")
# ribd::twoLocusIBD(U, U.ids, rho = rho, coefs = "k11")

##########################
### Two-locus Jacquard ###
##########################

x = fullSibMating(1)
rho = 0.25
Nsim = 10 # (increase to at least 10000)

estimateTwoLocusIdentity(x, ids = 5:6, rho = rho, Nsim = Nsim, seed = 123)

# Exact by ribd:
# ribd::twoLocusIdentity(x, ids = 5:6, rho = rho)

</code></pre>

<hr>
<h2 id='extractIds'>Extract ID labels from simulation output</h2><span id='topic+extractIds'></span>

<h3>Description</h3>

<p>Extract ID labels from simulation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractIds(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractIds_+3A_sim">sim</code></td>
<td>
<p>Output from <code><a href="#topic+ibdsim">ibdsim()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s = ibdsim(nuclearPed(2), N=1, ids = 3:4)
stopifnot(all(extractIds(s) == c("3", "4")))

</code></pre>

<hr>
<h2 id='findPattern'>Find specific IBD patterns</h2><span id='topic+findPattern'></span>

<h3>Description</h3>

<p>Find segments satisfying a particular pattern of IBD sharing, in a list of
IBD simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPattern(sims, pattern, merge = TRUE, cutoff = 0, unit = "mb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPattern_+3A_sims">sims</code></td>
<td>
<p>A <code>genomeSim</code> object, or a list of such. Typically made by
<code><a href="#topic+ibdsim">ibdsim()</a></code>.</p>
</td></tr>
<tr><td><code id="findPattern_+3A_pattern">pattern</code></td>
<td>
<p>A named list of vectors containing ID labels. Allowed names
are <code>autozygous</code>, <code>heterozygous</code>, <code>carriers</code>, <code>noncarriers</code>.</p>
</td></tr>
<tr><td><code id="findPattern_+3A_merge">merge</code></td>
<td>
<p>A logical, indicating if adjacent segments should be merged.
Default: TRUE.</p>
</td></tr>
<tr><td><code id="findPattern_+3A_cutoff">cutoff</code></td>
<td>
<p>A non-negative number. Segments shorter than this are excluded
from the output. Default: 0.</p>
</td></tr>
<tr><td><code id="findPattern_+3A_unit">unit</code></td>
<td>
<p>The unit of <code>cutoff</code>: either &quot;mb&quot; or &quot;cm&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each simulation, this function extracts the subset of rows satisfying the
allele sharing specified by <code>pattern</code>. That is, segments where, for some allele,
</p>

<ul>
<li><p> all of <code>pattern$autozygous</code> are autozygous
</p>
</li>
<li><p> all of <code>pattern$heterozygous</code> have exactly one copy
</p>
</li>
<li><p> all of <code>pattern$carriers</code> have at least one copy
</p>
</li>
<li><p> none of <code>pattern$noncarriers</code> carry the allele.
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix (if <code>sims</code> is a single <code>genomeSim</code> object), or a list of
matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+segmentStats">segmentStats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(3)
s = ibdsim(x, N = 1, map = uniformMap(M = 1), seed = 1729)

# Segments where some allele is shared by 3 and 4, but not 5
pattern = list(carriers = 3:4, noncarriers = 5)
findPattern(s, pattern)

# Exclude segments less than 7 cM
findPattern(s, pattern, cutoff = 7)

# Visual confirmation:
haploDraw(x, s)

</code></pre>

<hr>
<h2 id='haploDraw'>Draw haplotypes onto a pedigree plot</h2><span id='topic+haploDraw'></span>

<h3>Description</h3>

<p>Visualise the IBD pattern of a single chromosome, by drawing haplotypes onto
the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haploDraw(
  x,
  ibd,
  chrom = NULL,
  ids = NULL,
  unit = "mb",
  L = NULL,
  pos = 1,
  cols = NULL,
  height = 4,
  width = 0.75,
  sep = 0.75,
  dist = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haploDraw_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_ibd">ibd</code></td>
<td>
<p>A <code>genomeSim</code> object, typically made by <code><a href="#topic+ibdsim">ibdsim()</a></code>.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_chrom">chrom</code></td>
<td>
<p>A chromosome number, needed if <code>ibd</code> contains data from multiple
chromosomes.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_ids">ids</code></td>
<td>
<p>A vector indicating for which pedigree members haplotypes should
be drawn. If NULL (default), all individuals in <code>ibd</code> are included.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_unit">unit</code></td>
<td>
<p>Either &quot;mb&quot; (default) or &quot;cm&quot;.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_l">L</code></td>
<td>
<p>A positive number: the chromosome length. By default derived from
<code>ibd</code>.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_pos">pos</code></td>
<td>
<p>A vector recycled to <code>pedsize(x)</code>, indicating where haplotypes
should be drawn relative to the pedigree symbols: 0 = no haplotypes; 1 =
below; 2 = left; 3 = above; 4 = right. By default, all are placed below.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_cols">cols</code></td>
<td>
<p>A colour vector corresponding to the alleles in <code>ibd</code>.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_height">height</code></td>
<td>
<p>The haplotype height divided by the height of a pedigree
symbol.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_width">width</code></td>
<td>
<p>The haplotype width, divided by the width of a pedigree symbol.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_sep">sep</code></td>
<td>
<p>The separation between haplotypes within a pair, measured in
pedigree symbol widths.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_dist">dist</code></td>
<td>
<p>The distance between pedigree symbols and the closest haplotype,
measured in pedigree symbol widths.</p>
</td></tr>
<tr><td><code id="haploDraw_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>plot.ped()</code>, e.g. <code>margins</code>,
<code>cex</code>, <code>keep.par</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###############################
# Example 1: A family quartet #
###############################

x = nuclearPed(2)
map = uniformMap(M = 1)
s = ibdsim(x, map = map, seed = 4276)

haploDraw(x, s)

# Custom colours and placements
haploDraw(x, s, cols = c(3,7,2,4), pos = c(2,4,2,4))

# Standard plot options apply
haploDraw(x, s, margins = 3, cex = 1.5, title = "Full sibs")


###########################
# Example 2: Autozygosity #
###########################

x = halfCousinPed(0, child = TRUE)
map = uniformMap(M = 1)
s = ibdsim(x, map = map, skipRecomb = c(1,3), seed = 2)

# Only include relevant individuals (skip 1 and 3)
haploDraw(x, s, ids = c(2,4,5,6), pos = c(1,2,4,4))

###############################
# Example 3: X-chromosomal sims
###############################

x = nuclearPed(2, sex = 2:1)
s = ibdsim(x, N = 1, map = uniformMap(M = 1, chrom = "X"), seed = 123)

haploDraw(x, s)


</code></pre>

<hr>
<h2 id='ibdsim'>IBD simulation</h2><span id='topic+ibdsim'></span>

<h3>Description</h3>

<p>This is the main function of the package, simulating the recombination
process in each meioses of a pedigree. The output summarises the IBD segments
between all or a subset of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdsim(
  x,
  N = 1,
  ids = labels(x),
  map = "decode",
  model = c("chi", "haldane"),
  skipRecomb = NULL,
  simplify1 = TRUE,
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibdsim_+3A_x">x</code></td>
<td>
<p>A <code><a href="pedtools.html#topic+ped">pedtools::ped()</a></code> object.</p>
</td></tr>
<tr><td><code id="ibdsim_+3A_n">N</code></td>
<td>
<p>A positive integer indicating the number of simulations.</p>
</td></tr>
<tr><td><code id="ibdsim_+3A_ids">ids</code></td>
<td>
<p>A subset of pedigree members whose IBD sharing should be analysed.
If NULL, all members are included.</p>
</td></tr>
<tr><td><code id="ibdsim_+3A_map">map</code></td>
<td>
<p>The genetic map to be used in the simulations: Allowed values are:
</p>

<ul>
<li><p> a <code>genomeMap</code> object, typically produced by <code><a href="#topic+loadMap">loadMap()</a></code>
</p>
</li>
<li><p> a single <code>chromMap</code> object, for instance as produced by <code><a href="#topic+uniformMap">uniformMap()</a></code>
</p>
</li>
<li><p> a character, which is passed on to <code><a href="#topic+loadMap">loadMap()</a></code> with default parameters.
Currently the only valid option is &quot;decode19&quot; (or abbreviations of this).
</p>
</li></ul>

<p>Default: &quot;decode19&quot;.</p>
</td></tr>
<tr><td><code id="ibdsim_+3A_model">model</code></td>
<td>
<p>Either &quot;chi&quot; or &quot;haldane&quot;, indicating the statistical model for
recombination (see details). Default: &quot;chi&quot;.</p>
</td></tr>
<tr><td><code id="ibdsim_+3A_skiprecomb">skipRecomb</code></td>
<td>
<p>A vector of ID labels indicating individuals whose meioses
should be simulated without recombination. (Each child will then receive a
random strand of each chromosome.) The default action is to skip
recombination in founders who are uninformative for IBD sharing in the
<code>ids</code> individuals.</p>
</td></tr>
<tr><td><code id="ibdsim_+3A_simplify1">simplify1</code></td>
<td>
<p>A logical, by default TRUE, removing the outer list layer
when N = 1. See Value.</p>
</td></tr>
<tr><td><code id="ibdsim_+3A_seed">seed</code></td>
<td>
<p>An integer to be passed on to <code><a href="base.html#topic+set.seed">set.seed()</a></code>).</p>
</td></tr>
<tr><td><code id="ibdsim_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each simulation starts by unique alleles (labelled 1, 2, ...) being
distributed to the pedigree founders. In each meiosis, homologue chromosomes
are made to recombine according to the value of <code>model</code>:
</p>

<ul>
<li> <p><code>model = "haldane"</code>: In this model, crossover events are modelled as a
Poisson process along each chromosome.
</p>
</li>
<li> <p><code>model = "chi"</code> (default): This uses a renewal process along the
four-strand bundle, with waiting times following a chi square distribution.
</p>
</li></ul>

<p>Recombination rates along each chromosome are determined by the <code>map</code>
parameter. The default value (&quot;decode19&quot;) loads a thinned version of the
recombination map of the human genome published by Halldorsson et al (2019).
</p>
<p>In many applications, the fine-scale default map is not necessary, and should
be replaced by simpler maps with constant recombination rates. See
<code><a href="#topic+uniformMap">uniformMap()</a></code> and <code><a href="#topic+loadMap">loadMap()</a></code> for ways to produce such maps.
</p>


<h3>Value</h3>

<p>A list of <code>N</code> objects of class <code>genomeSim</code>.
</p>
<p>If N = 1 the outer list layer is removed by default, which is typically
desired in interactive use (especially when piping). To enforce a list
output, add <code>simplify1 = FALSE</code>.
</p>
<p>A <code>genomeSim</code> object is essentially a numerical matrix describing the
allele flow through the pedigree in a single simulated. Each row
corresponds to a chromosomal segment. The first 3 columns (chrom, startMB,
endMB) describe the physical location of the segment. Next, the genetic
coordinates (startCM, endCM), which are computed from <code>map</code> by averaging
the male and female values. Then follow the allele columns, two for each
individual in <code>ids</code>, suffixed by &quot;:p&quot; and &quot;:m&quot; signifying the paternal and
maternal alleles, respectively.
</p>
<p>If <code>ids</code> has length 1, a column named <code>Aut</code> is added, whose entries are 1
for autozygous segments and 0 otherwise.
</p>
<p>If <code>ids</code> has length 2, two columns are added:
</p>

<ul>
<li> <p><code>IBD</code> : The IBD status of each segment (= number of alleles shared
identical by descent). For a given segment, the IBD status is either 0, 1,
2 or NA. If either individual is autozygous in a segment, the IBD status is
reported as NA. With inbred individuals the <code>Sigma</code> column (see below) is
more informative than the <code>IBD</code> column.
</p>
</li>
<li> <p><code>Sigma</code> : The condensed identity (&quot;Jacquard&quot;) state of each segment,
given as an integer in the range 1-9. The numbers correspond to the
standard ordering of the condensed states. In particular, for non-inbred
individuals, the states 9, 8, 7 correspond to IBD status 0, 1, 2
respectively.
</p>
</li></ul>



<h3>References</h3>

<p>Halldorsson et al. <em>Characterizing mutagenic effects of
recombination through a sequence-level genetic map.</em> Science 363, no. 6425
(2019).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1: Half siblings ###

hs = halfSibPed()
sim = ibdsim(hs, map = uniformMap(M = 1), seed = 10)
sim

# Plot haplotypes
haploDraw(hs, sim)

#' ### Example 2: Full sib mating ###

x = fullSibMating(1)
sim = ibdsim(x, ids = 5:6, map = uniformMap(M = 10), seed = 1)
head(sim)

# All 9 identity states are present
stopifnot(setequal(sim[, 'Sigma'], 1:9))

</code></pre>

<hr>
<h2 id='karyoDiploid'>Diploid karyogram</h2><span id='topic+karyoDiploid'></span>

<h3>Description</h3>

<p>Show chromosomal segments in a diploid karyogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karyoDiploid(
  paternal,
  maternal,
  chrom = 1:22,
  col = c(paternal = "lightblue", maternal = "orange"),
  alpha = 1,
  bgcol = "gray95",
  title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="karyoDiploid_+3A_paternal">paternal</code>, <code id="karyoDiploid_+3A_maternal">maternal</code></td>
<td>
<p>data.frames (or objects coercible to data.frames)
containing the segments to be shown on the paternal and maternal strands of
the karyogram. The first three columns must contain chromosome (with or
without &quot;chr&quot; prefix), start position and stop position (in Mb). Column
names are ignored, as well as any further columns.</p>
</td></tr>
<tr><td><code id="karyoDiploid_+3A_chrom">chrom</code></td>
<td>
<p>The (autosomal) chromosomes to be included in the plot,
given as a subset of the integers 1, 2,..., 22.</p>
</td></tr>
<tr><td><code id="karyoDiploid_+3A_col">col</code></td>
<td>
<p>A vector of two colours (in any form recognisable by R). If only
one colour is given it is recycled. If the vector is named, a colour legend
is included in the plot, using the names as labels.</p>
</td></tr>
<tr><td><code id="karyoDiploid_+3A_alpha">alpha</code></td>
<td>
<p>A single numeric in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> indicating colour transparency.</p>
</td></tr>
<tr><td><code id="karyoDiploid_+3A_bgcol">bgcol</code></td>
<td>
<p>The background colour of the chromosomes.</p>
</td></tr>
<tr><td><code id="karyoDiploid_+3A_title">title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot object is returned invisibly, so that additional ggplot
layers may be added if needed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
pat = data.frame(chrom = c(1,4,5,5,10,10), start = c(100,50,20,80,10,80),
                 end = c(120,100,25,100,70,120))
mat = data.frame(chrom = c(2,4,5,5,10), start = c(80,50,10,80,50),
                 end = c(120,100,35,100,120))
karyoDiploid(pat, mat)

## End(Not run)


</code></pre>

<hr>
<h2 id='karyogram2'>Karyogram plots</h2><span id='topic+karyogram2'></span>

<h3>Description</h3>

<p>Functions for visualising IBD segments in karyograms. The <code>karyogram1()</code> and
<code>karyogram2()</code> functions produces karyograms illustrating the output of
<code><a href="#topic+ibdsim">ibdsim()</a></code> for one or two specified individuals. The actual plotting is done
by functions <code>karyoHaploid()</code> and <code>karyoDiploid()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karyogram2(sim, ids = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="karyogram2_+3A_sim">sim</code></td>
<td>
<p>A <code>genomeSim</code> object.</p>
</td></tr>
<tr><td><code id="karyogram2_+3A_ids">ids</code></td>
<td>
<p>A vector of one or two ID labels.</p>
</td></tr>
<tr><td><code id="karyogram2_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="karyogram2_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>karyoHaploid()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = quadHalfFirstCousins()
s = ibdsim(x, seed = 1729)
# karyogram2(s, ids = leaves(x), title = "QHFC")


</code></pre>

<hr>
<h2 id='karyoHaploid'>Haploid karyogram</h2><span id='topic+karyoHaploid'></span>

<h3>Description</h3>

<p>Show chromosomal segments in a haploid karyogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karyoHaploid(
  segments,
  chrom = 1:22,
  colBy = NULL,
  col = NULL,
  separate = TRUE,
  alpha = 1,
  bgcol = "gray92",
  title = NULL,
  legendTitle = NULL,
  base_size = 16
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="karyoHaploid_+3A_segments">segments</code></td>
<td>
<p>A data.frame (or an object coercible to data.frame)
containing the segments to be shown on the karyogram. The first three
columns must contain chromosome (with or without &quot;chr&quot; prefix), start
position and stop position (in Mb). Any further columns are ignored, except
possibly a column indicated by <code>colBy</code>.</p>
</td></tr>
<tr><td><code id="karyoHaploid_+3A_chrom">chrom</code></td>
<td>
<p>A vector indicating which chromosomes to include.</p>
</td></tr>
<tr><td><code id="karyoHaploid_+3A_colby">colBy</code></td>
<td>
<p>A character vector naming the columns to be used for colouring.
If NULL (default), all segments have the same colour.</p>
</td></tr>
<tr><td><code id="karyoHaploid_+3A_col">col</code></td>
<td>
<p>A single fill colour for all the segments, or (if <code>colBy</code> is used)
a named vector of colours. In the latter case, the names should include all
entries in the <code>colBy</code> column.</p>
</td></tr>
<tr><td><code id="karyoHaploid_+3A_separate">separate</code></td>
<td>
<p>A logical; relevant only if the <code>colBy</code> column has more than
one level. If FALSE, all segments are drawn in full height. This may not be
optimal if segments of different colours overlap. If TRUE the levels are
drawn in separate bands on the chromosomes.</p>
</td></tr>
<tr><td><code id="karyoHaploid_+3A_alpha">alpha</code></td>
<td>
<p>A single numeric in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> indicating colour transparency.</p>
</td></tr>
<tr><td><code id="karyoHaploid_+3A_bgcol">bgcol</code></td>
<td>
<p>The background colour of the chromosomes.</p>
</td></tr>
<tr><td><code id="karyoHaploid_+3A_title">title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="karyoHaploid_+3A_legendtitle">legendTitle</code></td>
<td>
<p>Legend title.</p>
</td></tr>
<tr><td><code id="karyoHaploid_+3A_base_size">base_size</code></td>
<td>
<p>Font size, passed onto <code>ggplot2::theme()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot object is returned invisibly, so that additional <code>ggplot</code>
layers may be added if needed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
segs = data.frame(chrom = c(1,4,5,5,10,10),
                  start = c(100,50,20,80,10,50),
                  end = c(120,100,25,100,70,120),
                  IBD = c("paternal","maternal"))
cols = c(paternal = "blue", maternal = "red")

karyoHaploid(segs, col = "cyan")
karyoHaploid(segs, colBy = "IBD", col = cols)

# Note difference if `separate = FALSE`
karyoHaploid(segs, colBy = "IBD", col = cols, separate = FALSE)

# Reduce alpha to see the overlaps:
karyoHaploid(segs, colBy = "IBD", col = cols, separate = FALSE, alpha = 0.7)


## End(Not run)

</code></pre>

<hr>
<h2 id='loadMap'>Load a built-in genetic map</h2><span id='topic+loadMap'></span>

<h3>Description</h3>

<p>This function loads one of the built-in genetic maps. Currently, the only
option is a detailed human recombination map, based on the publication by
Halldorsson et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadMap(map = "decode19", chrom = 1:22, uniform = FALSE, sexAverage = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadMap_+3A_map">map</code></td>
<td>
<p>The name of the wanted map, possibly abbreviated. Currently, the
only valid choice is &quot;decode19&quot; (default).</p>
</td></tr>
<tr><td><code id="loadMap_+3A_chrom">chrom</code></td>
<td>
<p>A vector containing a subset of the numbers 1,2,...,23,
indicating which chromosomes to load. As a special case, <code>chrom = "X"</code> is
synonymous to <code>chrom = 23</code>. Default: <code>1:22</code> (the autosomes).</p>
</td></tr>
<tr><td><code id="loadMap_+3A_uniform">uniform</code></td>
<td>
<p>A logical. If FALSE (default), the complete inhomogeneous map
is used. If TRUE, a uniform version of the same map is produced, i.e., with
the correct physical range and genetic lengths, but with constant
recombination rates along each chromosome.</p>
</td></tr>
<tr><td><code id="loadMap_+3A_sexaverage">sexAverage</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, a sex-averaged map is
returned, with equal recombination rates for males and females.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For reasons of speed and efficiency, the map published by map Halldorsson et
al. (2019) has been thinned down to around 60 000 data points.
</p>
<p>By setting <code>uniform = TRUE</code>, a uniform version of the map is returned, in
which each chromosome has the same genetic lengths as in the original, but
with constant recombination rates. This gives much faster simulations and may
be preferable in some applications.
</p>


<h3>Value</h3>

<p>An object of class <code>genomeMap</code>, which is a list of <code>chromMap</code>
objects. A <code>chromMap</code> is a list of two matrices, named &quot;male&quot; and &quot;female&quot;,
with various attributes:
</p>

<ul>
<li> <p><code>physStart</code>: The first physical position (Mb) on the chromosome covered
by the map
</p>
</li>
<li> <p><code>physEnd</code>: The last physical position (Mb) on the chromosome covered by
the map
</p>
</li>
<li> <p><code>physRange</code>: The physical map length (Mb), equal to <code>physEnd - physStart</code>
</p>
</li>
<li> <p><code>mapLen</code>: A vector of length 2, containing the centiMorgan lengths of the
male and female strands
</p>
</li>
<li> <p><code>chrom</code>: A chromosome label
</p>
</li>
<li> <p><code>Xchrom</code>: A logical. This is checked by <code>ibdsim()</code> and other function, to
select mode of inheritance
</p>
</li></ul>



<h3>References</h3>

<p>Halldorsson et al. <em>Characterizing mutagenic effects of
recombination through a sequence-level genetic map.</em> Science 363, no. 6425
(2019).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uniformMap">uniformMap()</a></code>, <code><a href="#topic+customMap">customMap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># By default, the complete map of all 22 autosomes is returned
loadMap()

# Uniform version
m = loadMap(uniform = TRUE)
m

# Check chromosome 1
m1 = m[[1]]
m1
m1$male
m1$female

# The X chromosome
loadMap(chrom = "X")[[1]]

</code></pre>

<hr>
<h2 id='maplengths'>Physical and genetic map lengths</h2><span id='topic+maplengths'></span><span id='topic+mapLen'></span><span id='topic+mapLen.chromMap'></span><span id='topic+mapLen.genomeMap'></span><span id='topic+physRange'></span><span id='topic+physRange.chromMap'></span><span id='topic+physRange.genomeMap'></span>

<h3>Description</h3>

<p>Utility functions for extracting the physical or genetic length of chromosome
maps and genome maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapLen(x, ...)

## S3 method for class 'chromMap'
mapLen(x, sex = c("male", "female"), ...)

## S3 method for class 'genomeMap'
mapLen(x, sex = c("male", "female"), ...)

physRange(x, ...)

## S3 method for class 'chromMap'
physRange(x, ...)

## S3 method for class 'genomeMap'
physRange(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maplengths_+3A_x">x</code></td>
<td>
<p>A <code>chromMap</code> or <code>genomeMap</code> object.</p>
</td></tr>
<tr><td><code id="maplengths_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="maplengths_+3A_sex">sex</code></td>
<td>
<p>Either &quot;male&quot;, &quot;female&quot; or both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mapLen()</code> returns a numeric of the same length as <code>sex</code>, with the
genetic length(s) in centiMorgan.
</p>
<p><code>physRange()</code> returns the physical length (in Mb) of the chromosome/genome
covered by the map. For example, for a chromosome map starting at 2 Mb and
ending at 8 Mb, the output is 6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadMap">loadMap()</a></code>, <code><a href="#topic+uniformMap">uniformMap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = loadMap(chrom = 1:2)
m

# Applied to `genomeMap` object:
physRange(m)
mapLen(m)

# Applied to `chromMap` object:
physRange(m[[1]])
mapLen(m[[1]])

</code></pre>

<hr>
<h2 id='plotSegmentDistribution'>Scatter plots of IBD segment distributions</h2><span id='topic+plotSegmentDistribution'></span>

<h3>Description</h3>

<p>Visualise and compare count/length distributions of IBD segments. Two types
are currently implemented: Segments of autozygosity (for a single person) and
segments with (pairwise) IBD state 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSegmentDistribution(
  ...,
  type = c("autozygosity", "ibd1"),
  ids = NULL,
  unit = "cm",
  labels = NULL,
  col = NULL,
  shape = 1,
  alpha = 1,
  ellipses = TRUE,
  title = NULL,
  xlab = NULL,
  ylab = NULL,
  legendInside = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSegmentDistribution_+3A_...">...</code></td>
<td>
<p>One or several objects of class <code>genomeSimList</code>, typically
created by <code><a href="#topic+ibdsim">ibdsim()</a></code>. They can be entered separately or as a <code>list</code>.</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_type">type</code></td>
<td>
<p>A string indicating which segments should be plotted. Currently,
the allowed entries are &quot;autozygosity&quot; and &quot;ibd1&quot;.</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_ids">ids</code></td>
<td>
<p>A list of the same length as <code>...</code>, where each entry contains one
or two ID labels (depending on <code>type</code>). By default (NULL), these labels are
extracted from the inputs in <code>...</code>.
</p>
<p>Two other short-cuts are possible: If a single vector is given, it is
repeated for all pedigrees. Finally, if <code>ids</code> is the word &quot;leaves&quot; then
<code>pedtools::leaves()</code> is used to extract labels in each pedigree.</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_unit">unit</code></td>
<td>
<p>Length unit; either &quot;cm&quot; (centiMorgan) or &quot;mb&quot; (megabases).</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_labels">labels</code></td>
<td>
<p>An optional character vector of labels used in the legend. If
NULL, the labels are taken from <code>names(...)</code>.</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_col">col</code></td>
<td>
<p>An optional colour vector of the same length as <code>...</code>.</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_shape">shape</code></td>
<td>
<p>A vector with point shapes, of the same length as <code>...</code>.</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_alpha">alpha</code></td>
<td>
<p>A transparency parameter for the scatter points.</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_ellipses">ellipses</code></td>
<td>
<p>A logical: Should confidence ellipses be added to the plot?</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_title">title</code>, <code id="plotSegmentDistribution_+3A_xlab">xlab</code>, <code id="plotSegmentDistribution_+3A_ylab">ylab</code></td>
<td>
<p>Title and axis labels.</p>
</td></tr>
<tr><td><code id="plotSegmentDistribution_+3A_legendinside">legendInside</code></td>
<td>
<p>A logical controlling the legend placement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes as input one or several complete outputs from the
<code><a href="#topic+ibdsim">ibdsim()</a></code>, and produces a scatter plot of the number and average length of
IBD segments from each.
</p>
<p>Contour curves are added to plot, corresponding to the
theoretical/pedigree-based values: either inbreeding coefficients (if <code>type = "autozygosity"</code>) or <code class="reqn">\kappa_1</code> (if <code>type = "ibd1"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulation parameters used in the below examples.
map = uniformMap(M = 10)   # recombination map
N = 5                      # number of sims

# For more realistic results, replace with e.g.:
# map = loadMap("decode19")
# N = 1000


#################################################################
# EXAMPLE 1
# Comparison of IBD segment distributions
# between paternal and maternal half siblings.
#################################################################

# Define the pedigrees
xPat = halfSibPed()
xMat = swapSex(xPat, 1)

simPat = ibdsim(xPat, N = N, map = map)
simMat = ibdsim(xMat, N = N, map = map)

# By default, the IBD segments of the "leaves" are computed and plotted
plotSegmentDistribution(simPat, simMat, type = "ibd1", ids = 4:5,
                        labels = c("HSpat", "HSmat"))

#################################################################
# EXAMPLE 2
# Half siblings vs half uncle vs grandparent/grandchild
#################################################################

# Only one pedigree needed here
x = addSon(halfSibPed(), 5)

s = ibdsim(x, N = N, map = map)

# Indicate the pairs explicitly this time.
ids = list(GR = c(2,7), HS = 4:5, HU = c(4,7))

# List names are used as labels in the plot
plotSegmentDistribution(s, type = "ibd1", ids = ids, shape = 1:3)


#################################################################
# EXAMPLE 3
# Comparison of autozygosity distributions in various individuals
# with the same expected inbreeding coefficient (f = 1/8)
#################################################################

G = swapSex(linearPed(2), 5)           # grandfather/granddaughter
G = addChildren(G, 1, 5, 1)
HSpat = swapSex(halfSibPed(), 5)       # paternal half sibs
HSpat = addChildren(HSpat, 4, 5, 1)
HSmat = swapSex(HSpat, 1)              # maternal half sibs
QHFC = quadHalfFirstCousins()          # quad half first cousins
QHFC = addChildren(QHFC, 9, 10, nch = 1)

peds = list(G = G, HSpat = HSpat, HSmat = HSmat, QHFC = QHFC)
plotPedList(peds, newdev = TRUE)
dev.off()

# Simulations
s = lapply(peds, function(p)
  ibdsim(p, N = N, ids = leaves(p), verbose = FALSE, map = map))

# Plot distributions
plotSegmentDistribution(s, type = "autoz", title = "Autozygous segments")

</code></pre>

<hr>
<h2 id='profileSimIBD'>Simulate markers conditional on a given IBD pattern</h2><span id='topic+profileSimIBD'></span>

<h3>Description</h3>

<p>This function simulates genotypes for a set of markers conditional on a
specific underlying IBD pattern (typically produced with <code><a href="#topic+ibdsim">ibdsim()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileSimIBD(
  x,
  ibdpattern,
  ids = NULL,
  markers = NULL,
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profileSimIBD_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="profileSimIBD_+3A_ibdpattern">ibdpattern</code></td>
<td>
<p>A <code>genomeSim()</code> object, typically created by <code><a href="#topic+ibdsim">ibdsim()</a></code>.
(See Examples).</p>
</td></tr>
<tr><td><code id="profileSimIBD_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels. If NULL, extracted from <code>ibdpattern</code>.</p>
</td></tr>
<tr><td><code id="profileSimIBD_+3A_markers">markers</code></td>
<td>
<p>A vector with names or indices of markers attached to <code>x</code>.</p>
</td></tr>
<tr><td><code id="profileSimIBD_+3A_seed">seed</code></td>
<td>
<p>An integer seed for the random number generator.</p>
</td></tr>
<tr><td><code id="profileSimIBD_+3A_verbose">verbose</code></td>
<td>
<p>A logical, by default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It should be noted that the only <em>random</em> part of this function is the
sampling of founder alleles for each marker. Given those, all other genotypes
in the pedigree are determined by the underlying IBD pattern.
</p>


<h3>Value</h3>

<p>A copy of <code>x</code> where marker genotypes have been simulated conditional
on <code>ibdpattern</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ibdsim">ibdsim()</a></code>, <code>forrel::profileSim()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Brother-sister pedigree
ped = nuclearPed(2, sex = 1:2)

# Alleles
als = letters[1:10]


### Autosomal simulation

x = ped |&gt; 
  addMarker(alleles = als, chrom = 1, posMb = 20) |&gt; 
  addMarker(alleles = als, chrom = 1, posMb = 50) |&gt; 
  addMarker(alleles = als, chrom = 1, posMb = 70)
  
# Simulate the underlying IBD pattern in the pedigree
sim = ibdsim(x, map = uniformMap(M = 1, chrom = 1), seed = 123)

# Simulate genotypes for the sibs conditional on the given IBD pattern
profileSimIBD(x, sim, ids = 3:4, seed = 123)

# With a different seed
profileSimIBD(x, sim, ids = 3:4, seed = 124)


### X chromosomal simulation

y = ped |&gt; 
  addMarker(alleles = als, chrom = "X", posMb = 1) |&gt; 
  addMarker(alleles = als, chrom = "X", posMb = 50) |&gt; 
  addMarker(alleles = als, chrom = "X", posMb = 100)

simy = ibdsim(y, map = loadMap("decode19", chrom = 23), seed = 11)

profileSimIBD(y, simy, seed = 12)

</code></pre>

<hr>
<h2 id='realised'>Realised relatedness</h2><span id='topic+realised'></span><span id='topic+realisedInbreeding'></span><span id='topic+realisedKinship'></span><span id='topic+realisedKappa'></span><span id='topic+realisedIdentity'></span>

<h3>Description</h3>

<p>Compute the realised values of various pedigree coefficients, from simulated
data. The current implementation covers inbreeding coefficients for single
pedigree members, and kinship, kappa and condensed identity coefficients for
pairwise relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realisedInbreeding(sims, id = NULL, unit = "cm")

realisedKinship(sims, ids = NULL, unit = "cm")

realisedKappa(sims, ids = NULL, unit = "cm")

realisedIdentity(sims, ids = NULL, unit = "cm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="realised_+3A_sims">sims</code></td>
<td>
<p>A list of genome simulations, as output by <code><a href="#topic+ibdsim">ibdsim()</a></code>.</p>
</td></tr>
<tr><td><code id="realised_+3A_id">id</code>, <code id="realised_+3A_ids">ids</code></td>
<td>
<p>A vector with one or two ID labels.</p>
</td></tr>
<tr><td><code id="realised_+3A_unit">unit</code></td>
<td>
<p>Either &quot;mb&quot; (megabases) or &quot;cm&quot; (centiMorgan); the length unit
for genomic segments. Default is &quot;cm&quot;, which normally gives lower variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inbreeding coefficient <code class="reqn">f</code> of a pedigree member is defined as the
probability of autozygosity (homozygous for alleles that are identical by
descent) in a random autosomal locus. Equivalently, the inbreeding
coefficient is the <em>expected</em> autozygous proportion of the autosomal
chromosomes.
</p>
<p>The <em>realised</em> inbreeding coefficient <code class="reqn">f_R</code> in a given individual is the
actual fraction of the autosomes covered by autozygous segments. Because of
the stochastic nature of meiotic recombination, this may deviate
substantially from the pedigree-based expectation.
</p>
<p>Similarly, the pedigree-based IBD coefficients <code class="reqn">\kappa_0, \kappa_1,
\kappa_2</code> of noninbred pairs of individuals have realised counterparts. For
any given pair of individuals we define <code class="reqn">k_i</code> to be the actual fraction
of the autosome where the individuals share exactly <code class="reqn">i</code> alleles IBD,
where <code class="reqn">i = 0,1,2</code>.
</p>
<p>Finally, we can do the same thing for each of the nine condensed identity
coefficients of Jacquard. For each <code class="reqn">i = 1,...,9</code> we define <code class="reqn">D_i</code> the
be the fraction of the autosome where a given pair of individuals are in
identity state <code class="reqn">i</code>. This uses the conventional ordering of the nine
condensed identity states; see for instance the <a href="https://github.com/magnusdv/ribd"><code>ribd</code> GitHub page</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Realised IBD coefficients between full siblings
x = nuclearPed(2)
s = ibdsim(x, N = 2) # increase N
realisedKappa(s, ids = 3:4)

###########

# Realised inbreeding coefficients, child of first cousins
x = cousinPed(1, child = TRUE)
s = ibdsim(x, N = 2) # increase N
realisedInbreeding(s, id = 9)

# Same data: realised kinship coefficients between the parents
realisedKinship(s, ids = parents(x, 9))

###########

# Realised identity coefficients after full sib mating
x = fullSibMating(1)
s = ibdsim(x, N = 2) # increase N
realisedIdentity(s, ids = 5:6)

</code></pre>

<hr>
<h2 id='segmentStats'>Summary statistics for identified segments</h2><span id='topic+segmentStats'></span>

<h3>Description</h3>

<p>Compute summary statistics for segments identified by <code><a href="#topic+findPattern">findPattern()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentStats(
  x,
  quantiles = c(0.025, 0.5, 0.975),
  returnAll = FALSE,
  unit = "mb"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentStats_+3A_x">x</code></td>
<td>
<p>A list of matrices produced with <code><a href="#topic+findPattern">findPattern()</a></code>.</p>
</td></tr>
<tr><td><code id="segmentStats_+3A_quantiles">quantiles</code></td>
<td>
<p>A vector of quantiles to include in the summary.</p>
</td></tr>
<tr><td><code id="segmentStats_+3A_returnall">returnAll</code></td>
<td>
<p>A logical, by default FALSE. If TRUE, the output includes a
vector <code>allSegs</code> containing the lengths of all segments in all simulations.</p>
</td></tr>
<tr><td><code id="segmentStats_+3A_unit">unit</code></td>
<td>
<p>Either &quot;mb&quot; (megabases) or &quot;cm&quot; (centiMorgan); the length unit
for genomic segments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a data frame <code>perSim</code>, a matrix <code>summary</code> and (if
<code>returnAll</code> is TRUE) a vector <code>allSegs</code>.
</p>
<p>Variables used in the output:
</p>

<ul>
<li> <p><code>Count</code>: The total number of segments in a simulation
</p>
</li>
<li> <p><code>Total</code>: The total sum of the segment lengths in a simulation
</p>
</li>
<li> <p><code>Average</code>: The average segment lengths in a simulation
</p>
</li>
<li> <p><code>Shortest</code>: The length of the shortest segment in a simulation
</p>
</li>
<li> <p><code>Longest</code>: The length of the longest segment in a simulation
</p>
</li>
<li> <p><code>Overall</code> (only in <code>summary</code>): A summary of all segments from all
simulations
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+findPattern">findPattern()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed(3)
sims = ibdsim(x, N = 2, map = uniformMap(M = 2), model = "haldane", seed = 1729)

# Segments where all siblings carry the same allele
segs = findPattern(sims, pattern = list(carriers = 3:5))

# Summarise
segmentStats(segs, unit = "mb")

# The unit does not matter in this case (since the map is trivial)
segmentStats(segs, unit = "cm")

</code></pre>

<hr>
<h2 id='uniformMap'>Uniform recombination maps</h2><span id='topic+uniformMap'></span>

<h3>Description</h3>

<p>Create a uniform recombination map of a given length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniformMap(Mb = NULL, cM = NULL, M = NULL, cmPerMb = 1, chrom = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniformMap_+3A_mb">Mb</code></td>
<td>
<p>Map length in megabases.</p>
</td></tr>
<tr><td><code id="uniformMap_+3A_cm">cM</code></td>
<td>
<p>Map length in centiMorgan.</p>
</td></tr>
<tr><td><code id="uniformMap_+3A_m">M</code></td>
<td>
<p>Map length in Morgan.</p>
</td></tr>
<tr><td><code id="uniformMap_+3A_cmpermb">cmPerMb</code></td>
<td>
<p>A positive number; the cM/Mb ratio.</p>
</td></tr>
<tr><td><code id="uniformMap_+3A_chrom">chrom</code></td>
<td>
<p>A chromosome label, which may be any string. The values &quot;X&quot; and
&quot;23&quot; have a special meaning, both resulting in the <code>Xchrom</code> attribute being
set to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>chromMap</code>. See <code><a href="#topic+loadMap">loadMap()</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadMap">loadMap()</a></code>, <code><a href="#topic+customMap">customMap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = uniformMap(Mb = 1, cM = 2:3)
m
m$male
m$female

mx = uniformMap(M = 1, chrom = "X")
mx
mx$male
mx$female

</code></pre>

<hr>
<h2 id='zeroIBD'>Probability of zero IBD</h2><span id='topic+zeroIBD'></span>

<h3>Description</h3>

<p>Estimate the probability of no IBD sharing in a pairwise relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroIBD(sims, ids = NULL, threshold = 0, unit = "cm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeroIBD_+3A_sims">sims</code></td>
<td>
<p>A list of genome simulations, as output by <code><a href="#topic+ibdsim">ibdsim()</a></code>.</p>
</td></tr>
<tr><td><code id="zeroIBD_+3A_ids">ids</code></td>
<td>
<p>A vector with two ID labels. If NULL (default), these are deduced
from the <code>sims</code> object.</p>
</td></tr>
<tr><td><code id="zeroIBD_+3A_threshold">threshold</code></td>
<td>
<p>A nonnegative number (default:0). Only IBD segments longer
than this are included in the computation.</p>
</td></tr>
<tr><td><code id="zeroIBD_+3A_unit">unit</code></td>
<td>
<p>The unit of measurement for <code>threshold</code>: Either &quot;mb&quot; or &quot;cm&quot;
(default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following two entries:
</p>

<ul>
<li> <p><code>zeroprob</code>: The fraction of <code>sims</code> in which <code>ids</code> have no IBD sharing
</p>
</li>
<li> <p><code>stErr</code>: The standard error of <code>zeroprob</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>###
# The following example computes the probability of
# no IBD sharing between a pair of fourth cousins.
# We also show how the probability is affected by
# truncation, i.e., ignoring short segments.
###

# Define the pedigree
x = cousinPed(4)
cous = leaves(x)

# Simulate (increase N!)
s = ibdsim(x, N = 10)

# Probability of zero ibd segments. (By default all segs are used)
zeroIBD(s, ids = cous)

# Re-compute with nonzero threshold
zeroIBD(s, ids = cous, threshold = 1, unit = "cm")
zeroIBD(s, ids = cous, threshold = 1, unit = "mb")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
