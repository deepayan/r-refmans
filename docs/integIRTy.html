<!DOCTYPE html><html><head><title>Help for package integIRTy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {integIRTy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculatePermutedScoreByGeneSampling'>
<p>Calculate the permuted latent trait by gene sampling</p></a></li>
<li><a href='#computeAbility'>
<p>Calculate latent traits for a given response matrix and item parameters using MLE</p></a></li>
<li><a href='#dichotomize'>
<p>A wrapper that is able to dichotomize expression, methylation and CN data</p></a></li>
<li><a href='#dichotomizeCN'>
<p>Dichotomizing copy number data based on segmented data (i.e. log2ratio).</p></a></li>
<li><a href='#dichotomizeExpr'>
<p>Dichotomize the expression data given both tumor and normal samples.</p></a></li>
<li><a href='#dichotomizeMethy'>
<p>Dichotomize the methylation data given both tumor and normal controls.</p></a></li>
<li><a href='#fitOnSinglePlat'>
<p>Fit IRT model on a single platform</p></a></li>
<li><a href='#intIRTeasyRun'>
<p>The easyrun function for integrating multiple modalities of high throughput assays using binary input matrix.</p></a></li>
<li><a href='#intIRTeasyRunFromRaw'>
<p>The easyrun function for integrating multiple modalities of high throughput assays using raw data.</p></a></li>
<li><a href='#OV'><p>Ovarian Cancer Datasets</p></a></li>
<li><a href='#simulateBinaryResponseMat'>
<p>Simulate binary response matrix according to 2-parameter Item Characteristic Function for</p>
given latent traits and item parameters.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Title:</td>
<td>Integrating Multiple Modalities of High Throughput Assays Using
Item Response Theory</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Pan Tong, Kevin R Coombes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin R. Coombes &lt;krc@silicovore.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a systematic framework for
 integrating multiple modalities of assays profiled on the same set of
 samples. The goal is to identify genes that are altered in cancer
 either marginally or consistently across different assays. The
 heterogeneity among different platforms and different samples are
 automatically adjusted so that the overall alteration magnitude can
 be accurately inferred. See Tong and Coombes (2012) 
 &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbts561">doi:10.1093/bioinformatics/bts561</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), ltm, foreach, doParallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>mclust, MASS, abind</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KernSmooth</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-03 01:16:25 UTC; KRC</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-03 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculatePermutedScoreByGeneSampling'>
Calculate the permuted latent trait by gene sampling
</h2><span id='topic+calculatePermutedScoreByGeneSampling'></span>

<h3>Description</h3>

<p>Given the original binary matrix and item parameters, calculate the permuted latent trait by
gene sampling. Basically this function permutes within columns and recompute the latent trait
using pre-specified item parameters and the permuted binary matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculatePermutedScoreByGeneSampling(originalMat, dscrmn = dscrmn,
      dffclt = dffclt, c = rep(0, length(dffclt)), fold = 1, parallel=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculatePermutedScoreByGeneSampling_+3A_originalmat">originalMat</code></td>
<td>

<p>The original response matrix
</p>
</td></tr>
<tr><td><code id="calculatePermutedScoreByGeneSampling_+3A_dscrmn">dscrmn</code></td>
<td>

<p>The estimated item discrimination parameter
</p>
</td></tr>
<tr><td><code id="calculatePermutedScoreByGeneSampling_+3A_dffclt">dffclt</code></td>
<td>

<p>The estimated item difficulty parameter
</p>
</td></tr>
<tr><td><code id="calculatePermutedScoreByGeneSampling_+3A_c">c</code></td>
<td>

<p>The estimated item guessing parameter if available
</p>
</td></tr>
<tr><td><code id="calculatePermutedScoreByGeneSampling_+3A_fold">fold</code></td>
<td>

<p>The fold relative to the number of genes present should gene sampling achieve. Default is 1, meaning equal number
of genes are sampled. Increasing fold would increase the precesion in estimating empirical P value
</p>
</td></tr>
<tr><td><code id="calculatePermutedScoreByGeneSampling_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating whether to use parallel computing with foreach package as backend.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both gene sampling and sample label permutation can be used to infer the null distribution of altent
traits. For sample label permutation, one can simply first construct the binary matrix
after permuting the sample labels and feed it to computeAbility() function together with item parameters
</p>


<h3>Value</h3>

<p>A vector of null latent traits by gene sampling
</p>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>References</h3>

<p>David Magis, Gilles Raiche (2012). Random Generation of Response Patterns under Computerized Adaptive Testing with the 
R Package catR. Journal of Statistical Software, 48(8), 1-31.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitOnSinglePlat">fitOnSinglePlat</a>, <a href="#topic+intIRTeasyRun">intIRTeasyRun</a>, <a href="#topic+computeAbility">computeAbility</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of items and number of genes
nSample &lt;- 10
nGene &lt;- 2000
set.seed(1000)
a &lt;- rgamma(nSample, shape=1, scale=1)
b &lt;- rgamma(nSample, shape=1, scale=1)
# true latent traits
theta &lt;- rnorm(nGene, mean=0)

# probability of correct response (P_ij) for gene i in sample j
P &lt;- matrix(NA, nrow=nGene, ncol=nSample)
for(i in 1:nSample){
	P[, i] &lt;- exp(a[i]*(theta-b[i]))/(1+exp(a[i]*(theta-b[i])))
}
# binary matrix
X &lt;- matrix(NA, nrow=nGene, ncol=nSample)
for(i in 1:nSample){
	X[, i] &lt;- rbinom(nGene, size=1, prob=P[, i])
}
# IRT fitting
fit2PL &lt;- fitOnSinglePlat(X, model=3)
dffclt &lt;- coef(fit2PL$fit)[, 'Dffclt']
dscrmn &lt;- coef(fit2PL$fit)[, 'Dscrmn']
# estimated null latent trait by gene sampling
scoreNull &lt;- calculatePermutedScoreByGeneSampling(X, dffclt=dffclt,
	  dscrmn=dscrmn, fold=1)


</code></pre>

<hr>
<h2 id='computeAbility'>
Calculate latent traits for a given response matrix and item parameters using MLE
</h2><span id='topic+computeAbility'></span>

<h3>Description</h3>

<p>This function calculates the MLE of latent traits for a given response matrix with rows being examinees and columns being
items for given item parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeAbility(respMat, dscrmn = dscrmn, dffclt = dffclt,
		c = rep(0, length(dffclt)), parallel=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeAbility_+3A_respmat">respMat</code></td>
<td>

<p>The response matrix of 0 and 1 with rows being examinees and columns being items.
</p>
</td></tr>
<tr><td><code id="computeAbility_+3A_dscrmn">dscrmn</code></td>
<td>

<p>A vector of item discrimination parameter.
</p>
</td></tr>
<tr><td><code id="computeAbility_+3A_dffclt">dffclt</code></td>
<td>

<p>A vector of item difficulty parameter.
</p>
</td></tr>
<tr><td><code id="computeAbility_+3A_c">c</code></td>
<td>

<p>A vector of guessing parameter. Default is set to all 0 indicating no guessing allowed.
</p>
</td></tr>
<tr><td><code id="computeAbility_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating whether to use parallel computing with foreach package as backend.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper of the thetaEst() function from catR package (Magis, 2012). 
</p>


<h3>Value</h3>

<p>A vector of latent trait estimates for each examinee.
</p>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>References</h3>

<p>David Magis, Gilles Raiche (2012). Random Generation of Response Patterns under Computerized Adaptive Testing with the 
R Package catR. Journal of Statistical Software, 48(8), 1-31. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitOnSinglePlat">fitOnSinglePlat</a>, <a href="#topic+intIRTeasyRun">intIRTeasyRun</a>, <a href="#topic+calculatePermutedScoreByGeneSampling">calculatePermutedScoreByGeneSampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of items and number of genes
nSample &lt;- 10
nGene &lt;- 2000
set.seed(1000)
a &lt;- rgamma(nSample, shape=1, scale=1)
b &lt;- rgamma(nSample, shape=1, scale=1)
# true latent traits
theta &lt;- rnorm(nGene, mean=0)

# probability of correct response (P_ij) for gene i in sample j
P &lt;- matrix(NA, nrow=nGene, ncol=nSample)
for(i in 1:nSample){
	P[, i] &lt;- exp(a[i]*(theta-b[i]))/(1+exp(a[i]*(theta-b[i])))
}
# binary matrix
X &lt;- matrix(NA, nrow=nGene, ncol=nSample)
for(i in 1:nSample){
	X[, i] &lt;- rbinom(nGene, size=1, prob=P[, i])
}
# IRT fitting
fit2PL &lt;- fitOnSinglePlat(X, model=3)
dffclt &lt;- coef(fit2PL$fit)[, 'Dffclt']
dscrmn &lt;- coef(fit2PL$fit)[, 'Dscrmn']
# estimated latent trait
score &lt;- computeAbility(X, dffclt=dffclt, dscrmn=dscrmn)

</code></pre>

<hr>
<h2 id='dichotomize'>
A wrapper that is able to dichotomize expression, methylation and CN data
</h2><span id='topic+dichotomize'></span>

<h3>Description</h3>

<p>This function provides a common interface for the user so that data dichotomization 
can be done easily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichotomize(mat, matCtr, assayType = c("Expr", "Methy", "CN"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dichotomize_+3A_mat">mat</code></td>
<td>

<p>A matrix, either expression, methylation or CN
</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_matctr">matCtr</code></td>
<td>

<p>A matrix corresponding to normal controls. 
</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_assaytype">assayType</code></td>
<td>

<p>A character string specifying the assay type. It can only be any of &quot;Expr&quot;, &quot;Methy&quot;, &quot;CN&quot;. For assays none of these types,
the program will quite. To run intIRT, the user can manually dichotomize the data and feed them into intIRTeasyRun function.
</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_...">...</code></td>
<td>

<p>Additional parameters to be passed to the specific dichotomization function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Abinary matrix of the same dimension as input mat.
</p>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>References</h3>

<p>Tong P, Coombes KR. <em>integIRTy: a method to identify altered
genes in cancer accounting for multiple mechanisms of regulation
using item response theory</em>. Bioinformatics, 2012 Nov 15;
28(22):2861&ndash;9.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dichotomizeCN">dichotomizeCN</a>, <a href="#topic+dichotomizeExpr">dichotomizeExpr</a>, <a href="#topic+dichotomizeMethy">dichotomizeMethy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OV)
binDat_expr &lt;- dichotomize(Expr_T[1:20, ], Expr_N[1:20, ], assayType='Expr')
binDat_methy &lt;- dichotomize(Methy_T[1:20, ], Methy_N[1:20, ], assayType='Methy')
</code></pre>

<hr>
<h2 id='dichotomizeCN'>
Dichotomizing copy number data based on segmented data (i.e. log2ratio).
</h2><span id='topic+dichotomizeCN'></span>

<h3>Description</h3>

<p>A simple dichotomization procedure is implemented for CN data that only requires
two cutoffs. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichotomizeCN(CN, CNctr = NULL, tau1 = -0.3, tau2 = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dichotomizeCN_+3A_cn">CN</code></td>
<td>

<p>A matrix of gene wise copy number data for tumor samples. Rows are the genes; columns are the samples.
</p>
</td></tr>
<tr><td><code id="dichotomizeCN_+3A_cnctr">CNctr</code></td>
<td>

<p>A matrix of copy number data for normal samples. The program first guess if this is paired data by comparing if 
tumor and normal sample has equal sample size. If TRUE, then normal samples will be subtracted element by element to
correct for germline CN change. Otherwise, no correction is performed. The program proceeds with only tumor data.
</p>
</td></tr>
<tr><td><code id="dichotomizeCN_+3A_tau1">tau1</code></td>
<td>

<p>The lower bound for log2Ratio when converting to a code as 0.
</p>
</td></tr>
<tr><td><code id="dichotomizeCN_+3A_tau2">tau2</code></td>
<td>

<p>The upper bound for log2Ratio when converting to a code as 0. Log2ratio between tau1 and tau2 is converted to 0 and 1 otherwise.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a binary matrix of the same dimension. Missing value would be propogated into the binary matrix.
</p>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>References</h3>

<p>Tong P, Coombes KR. <em>integIRTy: a method to identify altered
genes in cancer accounting for multiple mechanisms of regulation
using item response theory</em>. Bioinformatics, 2012 Nov 15;
28(22):2861&ndash;9.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dichotomizeExpr">dichotomizeExpr</a>, <a href="#topic+dichotomizeMethy">dichotomizeMethy</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OV)
binDat &lt;- dichotomizeCN(CN_T[1:20, ], CN_N[1:20, ])
binDat[15:20, 1:2]
</code></pre>

<hr>
<h2 id='dichotomizeExpr'>
Dichotomize the expression data given both tumor and normal samples.
</h2><span id='topic+dichotomizeExpr'></span>

<h3>Description</h3>

<p>This function implements the  z-like metric described in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichotomizeExpr(expr, exprCtr, refUseMean = FALSE, BIthr = NULL,
                tau1 = -2.5, tau2 = 2.5, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dichotomizeExpr_+3A_expr">expr</code></td>
<td>

<p>The expression matrix for tumor samples. Rows are genes and columns are samples.
</p>
</td></tr>
<tr><td><code id="dichotomizeExpr_+3A_exprctr">exprCtr</code></td>
<td>

<p>Expression matrix of normal controls. Genes should exactly the same as the tumor sample. The sample size are not
necessarily the same as tumor sample. 
</p>
</td></tr>
<tr><td><code id="dichotomizeExpr_+3A_refusemean">refUseMean</code></td>
<td>

<p>Logical indicating whether to use mean of normal sample as reference. Default is set to FALSE which means to use median
as it is more robust.
</p>
</td></tr>
<tr><td><code id="dichotomizeExpr_+3A_bithr">BIthr</code></td>
<td>

<p>Threshold of bimodality index to flag bimodal genes. If not specified, it will be set according to the sample size of tumor
samples. Specifically, if tumor sample size is over 100, BIthr=1.1. If sample size is between 50 and 100, BIthr=1.5. If sample
size is below 50, BIthr=2.0.
</p>
</td></tr>
<tr><td><code id="dichotomizeExpr_+3A_tau1">tau1</code></td>
<td>

<p>Lower bound of z-like metric to be coded as 0. 
</p>
</td></tr>
<tr><td><code id="dichotomizeExpr_+3A_tau2">tau2</code></td>
<td>

<p>Upper bound of z-like metric to be coded as 0. The z-like metric between tau1 and tau2 will be finally converted to 0 and otherwise.
</p>
</td></tr>
<tr><td><code id="dichotomizeExpr_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating whether to use parallel backend provided by foreach and related packages.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parallelism is written to speedup BI computation. If the number of genes is not large, i.e. below 4000, we recommend not to use
parallel since this will only slow down the computation. In fact, except BI computation, all other operations are written with vector
operation.  
</p>


<h3>Value</h3>

<p>A binary matrix of the same dimension of input expr. Missing values will be propogated into binary matrix.
</p>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>References</h3>

<p>Tong P, Coombes KR. <em>integIRTy: a method to identify altered
genes in cancer accounting for multiple mechanisms of regulation
using item response theory</em>. Bioinformatics, 2012 Nov 15;
28(22):2861&ndash;9.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dichotomizeCN">dichotomizeCN</a>, <a href="#topic+dichotomizeMethy">dichotomizeMethy</a>, <a href="#topic+dichotomize">dichotomize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OV)
binDat &lt;- dichotomizeExpr(Expr_T[1:200, ], Expr_N[1:200, ])
#binDat &lt;- dichotomizeExpr(Expr_T[1:200, ], Expr_N[1:200, ], parallel=TRUE)
binDat[15:20, 1:2]
</code></pre>

<hr>
<h2 id='dichotomizeMethy'>
Dichotomize the methylation data given both tumor and normal controls.
</h2><span id='topic+dichotomizeMethy'></span>

<h3>Description</h3>

<p>This function implements the procedure for dichotomizing methylation data described
in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichotomizeMethy(methy, methyCtr, refUseMean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dichotomizeMethy_+3A_methy">methy</code></td>
<td>

<p>The methylation matrix for tumor samples. Each element represents the beta value which is 
bounded between 0 and 1. Rows are genes and columns are samples.
</p>
</td></tr>
<tr><td><code id="dichotomizeMethy_+3A_methyctr">methyCtr</code></td>
<td>

<p>Methylation matrix of normal controls. Genes should exactly the same as the tumor sample. The sample size are not
necessarily the same as tumor sample. </p>
</td></tr>
<tr><td><code id="dichotomizeMethy_+3A_refusemean">refUseMean</code></td>
<td>

<p>Logical indicating whether to use mean of normal sample as reference. Default is set to FALSE which means to use median
as it is more robust.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary matrix of the same dimension of input methy. 
</p>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>References</h3>

<p>Tong P, Coombes KR. <em>integIRTy: a method to identify altered
genes in cancer accounting for multiple mechanisms of regulation
using item response theory</em>. Bioinformatics, 2012 Nov 15;
28(22):2861&ndash;9.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dichotomizeCN">dichotomizeCN</a>, <a href="#topic+dichotomizeExpr">dichotomizeExpr</a>, <a href="#topic+dichotomize">dichotomize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OV)
binDat &lt;- dichotomizeMethy(Methy_T[1:200, ], Methy_N[1:200, ])
binDat[15:20, 1:2]
</code></pre>

<hr>
<h2 id='fitOnSinglePlat'>
Fit IRT model on a single platform
</h2><span id='topic+fitOnSinglePlat'></span>

<h3>Description</h3>

<p>This function fits the Item Response Model for one platform. It assumes the user has already dichotomized the data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitOnSinglePlat(data, model = 2, guessing = FALSE,
    sampleIndices = 1:ncol(data), geneIndices = 1:nrow(data), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitOnSinglePlat_+3A_data">data</code></td>
<td>

<p>A matrix of 0's and 1's with rows being genes (treated as examinees) and columns being samples (treated as items).
</p>
</td></tr>
<tr><td><code id="fitOnSinglePlat_+3A_model">model</code></td>
<td>

<p>IRT model. 1-Rasch model where all item discrination are set to 1;
2-all item discrimation are set to be equal but not necessarily as 1; 
3-the 2PL model where no constraint is put on the item difficulty and discrimination parameter.  
</p>
</td></tr>
<tr><td><code id="fitOnSinglePlat_+3A_guessing">guessing</code></td>
<td>

<p>A logical variable indicating whether to include guessing parameter in the model.
</p>
</td></tr>
<tr><td><code id="fitOnSinglePlat_+3A_sampleindices">sampleIndices</code></td>
<td>

<p>Indices of the samples to be feeded into the model. Default is set to use all samples.
</p>
</td></tr>
<tr><td><code id="fitOnSinglePlat_+3A_geneindices">geneIndices</code></td>
<td>

<p>Indices of the genes to be feeded into the model. Default is to use all genes.
</p>
</td></tr>
<tr><td><code id="fitOnSinglePlat_+3A_...">...</code></td>
<td>

<p>Additional options available in ltm package. Currently not used in intIRT package.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list giving the estimated IRT model and related information
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>An object returned by calling ltm package. Item parameters and other auxillary inforamtion (i.e. loglikelihood, convergence, Hessian) can be accessed
from this object. For more details, please refer to ltm package</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model type</p>
</td></tr>
<tr><td><code>guessing</code></td>
<td>
<p>The guessing parameter</p>
</td></tr>
<tr><td><code>sampleIndices</code></td>
<td>
<p>The sample indices used in the model</p>
</td></tr>
<tr><td><code>geneIndices</code></td>
<td>
<p>The gene indices used in the model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>References</h3>

<p>Rizopoulos, D. (2006) ltm: An R package for latent variable modelling and item response theory analyses. 
Journal of Statistical Software, 17(5), 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeAbility">computeAbility</a>, <a href="#topic+intIRTeasyRun">intIRTeasyRun</a>, <a href="#topic+calculatePermutedScoreByGeneSampling">calculatePermutedScoreByGeneSampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of items and number of genes
nSample &lt;- 10
nGene &lt;- 2000
set.seed(1000)
a &lt;- rgamma(nSample, shape=1, scale=1)
b &lt;- rgamma(nSample, shape=1, scale=1)
# true latent traits
theta &lt;- rnorm(nGene, mean=0)

# probability of correct response (P_ij) for gene i in sample j
P &lt;- matrix(NA, nrow=nGene, ncol=nSample)
for(i in 1:nSample){
	P[, i] &lt;- exp(a[i]*(theta-b[i]))/(1+exp(a[i]*(theta-b[i])))
}
# binary matrix
X &lt;- matrix(NA, nrow=nGene, ncol=nSample)
for(i in 1:nSample){
	X[, i] &lt;- rbinom(nGene, size=1, prob=P[, i])
}
# IRT fitting
fit2PL &lt;- fitOnSinglePlat(X, model=3)
</code></pre>

<hr>
<h2 id='intIRTeasyRun'>
The easyrun function for integrating multiple modalities of high throughput assays using binary input matrix. 
</h2><span id='topic+intIRTeasyRun'></span>

<h3>Description</h3>

<p>It fits IRT models on each
of the specified platform and calculate integrated latent trait. If required, permuted latent trait by gene sampling
will also be calculated. An option for parallel computing is implemented to speed up the computation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intIRTeasyRun(platforms, model = 3, guessing = FALSE,
    addPermutedScore = FALSE, fold = 1, echo = TRUE, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intIRTeasyRun_+3A_platforms">platforms</code></td>
<td>

<p>A list of response matrices representing different platforms. It assumes that the number of rows (genes ) must be equal whiel the number of columns (samples)
can be different.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRun_+3A_model">model</code></td>
<td>

<p>The model type as described in fitOnSinglePlat.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRun_+3A_guessing">guessing</code></td>
<td>

<p>A logical variable indicating whether to include guessing parameter in the model.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRun_+3A_addpermutedscore">addPermutedScore</code></td>
<td>

<p>A logical variable indicating whether to also calculate permuted latent trait by gene sampling.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRun_+3A_fold">fold</code></td>
<td>

<p>The fold of sampling to calculate permuted score as used in calculatePermutedScoreByGeneSampling(). Only relevant when addPermutedScore=TRUE is used.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRun_+3A_echo">echo</code></td>
<td>

<p>A logical variable indicating whether to print out the progress information.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRun_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating whether to use parallel computing with foreach package as backend.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parallel computing uses foreach and related packages for backend. The parallelism assumes computation on each 
platform individually takes similar time; the latent trait computation of the integrated data is assumed to be
comparable to computation on individual platform. By default, all parallel options are set to be FALSE. 
Parallelism happens on the individual assay and combined data level;
No parallelism happens on genes since it would only slow donw the computation due to data transfering!
</p>


<h3>Value</h3>

<p>A list with following elements:
</p>
<table>
<tr><td><code>fits</code></td>
<td>
<p>Model fits for each platform as returned by fitOnSinglePlat function</p>
</td></tr>
<tr><td><code>estimatedScoreMat</code></td>
<td>
<p>A matrix of estimated latent traits. The first several columns correspond to the
individual assays; the last column represents the integrated latent trait with all data.</p>
</td></tr>
<tr><td><code>permutedScoreMat</code></td>
<td>
<p>A matrix of latent trait estimates after permuting the binary matrix within columns. This is only available
if addPermutedScore is set to TRUE. The first several columns correspond to the
individual assays; the last column represents the integrated data.
</p>
</td></tr>
<tr><td><code>dscrmnList</code></td>
<td>
<p>A list of discrimination parameters. Each element contains all of the discrimination parameters as a vector for each
assay. The last element contains the discrimination parameters for the integrated data which is formed by combining discrimination
parameters from each assay sequentially.</p>
</td></tr>
<tr><td><code>dffcltList</code></td>
<td>
<p> Same format as dscrmnList except it contains difficulty parameter.
</p>
</td></tr>
<tr><td><code>gussngList</code></td>
<td>
<p> Same format as dscrmnList except it contains guessing parameter. Be default, this is just all 0's.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>References</h3>

<p>Tong P, Coombes KR. <em>integIRTy: a method to identify altered
genes in cancer accounting for multiple mechanisms of regulation
using item response theory</em>. Bioinformatics, 2012 Nov 15;
28(22):2861&ndash;9.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intIRTeasyRunFromRaw">intIRTeasyRunFromRaw</a>, <a href="#topic+fitOnSinglePlat">fitOnSinglePlat</a>, <a href="#topic+calculatePermutedScoreByGeneSampling">calculatePermutedScoreByGeneSampling</a></code>
</p>

<hr>
<h2 id='intIRTeasyRunFromRaw'>
The easyrun function for integrating multiple modalities of high throughput assays using raw data. 
</h2><span id='topic+intIRTeasyRunFromRaw'></span>

<h3>Description</h3>

<p>This function performs data dichotomization, IRT fitting on individual assay, latent trait estimation for integrated data and significance
assessment of latent trait by permutation. An option for parallel computing is implemented to speed up the computation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intIRTeasyRunFromRaw(platforms, platformsCtr, 
	assayType = c("Expr", "Methy", "CN"), 
	model = 3, guessing = FALSE, permutationMethod = NULL, 
	fold = 1, nPerm = 200, echo = TRUE, 
	parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_platforms">platforms</code></td>
<td>

<p>A list of matrices of the raw data for tumor samples. The matrices should have equal row number corresponding to the same set of genes. The columns representing the tumor
samples can differ.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_platformsctr">platformsCtr</code></td>
<td>

<p>A list of matrices of the raw data for normal control samples. The matrices should have equal row number corresponding to the same set of genes. The column number of each
matrix can differ. When normal control is not available, i.e. in CN data, use NA instead.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_assaytype">assayType</code></td>
<td>

<p>A vector of assay types. Candidates can only be a combination of &quot;Expr&quot;, &quot;Methy&quot;, &quot;CN&quot; in the order of the assays specified in the input platforms. 
When assays other then these three types, we recommend the user to dichotomize the data first and use the intIRTeasyRun function. 
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_model">model</code></td>
<td>

<p>The model type as described in fitOnSinglePlat. 1: Rasch model where all item discrination are set to 1; 2: all item discrimation are set to be equal but not necessarily as 1;
3: the 2PL model where no constraint is put on the item difficulty and discrimination parameter.  
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_guessing">guessing</code></td>
<td>

<p>A logical variable indicating whether to include guessing parameter in the model.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_permutationmethod">permutationMethod</code></td>
<td>

<p>What permutation method to use. It can only be 'gene sampling', 'sample label permutation' or NULL. if NULL,
no permutation is performed
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_fold">fold</code></td>
<td>

<p>The fold of sampling to calculate permuted score as used in calculatePermutedScoreByGeneSampling(). 
Only relevant when permutationMethod=gene sampling is used.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_nperm">nPerm</code></td>
<td>

<p>Number of permutations for sample label permutation. It is effective only when permutationMethod='sample label permutation'.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_echo">echo</code></td>
<td>

<p>A logical variable indicating whether to print out the progress information.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating whether to use parallel computing with foreach package as backend.
</p>
</td></tr>
<tr><td><code id="intIRTeasyRunFromRaw_+3A_...">...</code></td>
<td>

<p>Additional parameters for dichotomizing binary data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list quite similar to the results returned by intIRTeasyRun. The following elements are included:
</p>
<table>
<tr><td><code>fits</code></td>
<td>
<p>Model fits for each platform as returned by fitOnSinglePlat function</p>
</td></tr>
<tr><td><code>estimatedScoreMat</code></td>
<td>
<p>A matrix of estimated latent traits. The first several columns correspond to the
individual assays; the last column represents the integrated latent trait with all data.</p>
</td></tr>
<tr><td><code>permutedScoreMat</code></td>
<td>
<p>A matrix of latent trait estimates after permuting the binary matrix within columns. This is only available
if permutationMethod='gene sampling' is used. The first several columns correspond to the
individual assays; the last column represents the integrated data.
</p>
</td></tr>
<tr><td><code>dscrmnList</code></td>
<td>
<p>A list of discrimination parameters. Each element contains all of the discrimination parameters as a vector for each
assay. The last element contains the discrimination parameters for the integrated data which is formed by combining discrimination
parameters from each assay sequentially.</p>
</td></tr>
<tr><td><code>dffcltList</code></td>
<td>
<p> Same format as dscrmnList except it contains difficulty parameter.
</p>
</td></tr>
<tr><td><code>gussngList</code></td>
<td>
<p> Same format as dscrmnList except it contains guessing parameter. Be default, this is just all 0's.
</p>
</td></tr>
<tr><td><code>permutedScoreMatWithLabelPerm</code></td>
<td>
<p> A matrix of latent trait estimates using sample label permutation. This is only available
if permutationMethod='sample label permutation' is used. The first several columns correspond to the
individual assays; the last column represents the integrated data.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>References</h3>

<p>Tong P, Coombes KR. <em>integIRTy: a method to identify altered
genes in cancer accounting for multiple mechanisms of regulation
using item response theory</em>. Bioinformatics, 2012 Nov 15;
28(22):2861&ndash;9.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intIRTeasyRun">intIRTeasyRun</a>, <a href="#topic+fitOnSinglePlat">fitOnSinglePlat</a>, <a href="#topic+calculatePermutedScoreByGeneSampling">calculatePermutedScoreByGeneSampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OV)
# 
controlList &lt;- list(Expr_N, Methy_N, CN_N)
tumorList &lt;- list(Expr_T, Methy_T, CN_T)
# not run as it takes time
#runFromRaw &lt;- intIRTeasyRunFromRaw(platforms=tumorList, 
#		platformsCtr=controlList, 
#		assayType=c("Expr", "Methy", "CN"), 
#		permutationMethod="gene sampling")
</code></pre>

<hr>
<h2 id='OV'>Ovarian Cancer Datasets</h2><span id='topic+OV'></span><span id='topic+CN_N'></span><span id='topic+CN_T'></span><span id='topic+Methy_N'></span><span id='topic+Methy_T'></span><span id='topic+Expr_N'></span><span id='topic+Expr_T'></span>

<h3>Description</h3>

<p>Six matrices containing a subset of TCGA ovarian cancer data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OV)
</code></pre>


<h3>Format</h3>

<p>Each of the six objects (CN_N, CN_T, Methy_N, Methy_T, Expr_N, Expr_T)
is a matrix with rows for 1000 (matched) genes and columns as samples. Gene expression, methylation
and copy number data for 30 tumor samples and around 10 normal samples are provided.
</p>


<h3>Source</h3>

<p>This data is a subset of the TCGA ovarian cancer datasets. The full datasets can be downloaded through the
TCGA data portal at: http://cancergenome.nih.gov/
</p>


<h3>References</h3>

<p>Cancer Genome Atlas Research Network (2011). Integrated genomic analyses of ovarian carcinoma. Nature 474, 609-615
</p>

<hr>
<h2 id='simulateBinaryResponseMat'>
Simulate binary response matrix according to 2-parameter Item Characteristic Function for
given latent traits and item parameters. 
</h2><span id='topic+simulateBinaryResponseMat'></span>

<h3>Description</h3>

<p>This function generates binary response matrix according to the Item Characteristic Function for specified
item parameter and latent traits. It can be used for simulation purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateBinaryResponseMat(a = a, b = b, theta = theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateBinaryResponseMat_+3A_a">a</code></td>
<td>

<p>A vector of item discrimination parameter 
</p>
</td></tr>
<tr><td><code id="simulateBinaryResponseMat_+3A_b">b</code></td>
<td>

<p>A vector of item difficulty parameter 
</p>
</td></tr>
<tr><td><code id="simulateBinaryResponseMat_+3A_theta">theta</code></td>
<td>

<p>A vector of true latent traits
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not necessary for the integration purpose. It serves as a utility function to help the
user conduct simulation.
</p>


<h3>Value</h3>

<p>A matrix of 0's and 1's where rows are genes (examinees) and columns are samples (items).
</p>


<h3>Author(s)</h3>

<p>Pan Tong (nickytong@gmail.com), Kevin R Coombes (krc@silicovore.com)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeAbility">computeAbility</a>, <a href="#topic+fitOnSinglePlat">fitOnSinglePlat</a>, <a href="#topic+intIRTeasyRun">intIRTeasyRun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of samples and genes to simulate
nSample &lt;- 50
nGene &lt;- 1000
# mean and variance of item parameters
meanDffclt_Expr &lt;- 3; varDffclt_Expr &lt;- 0.2
meanDscrmn_Expr &lt;- 1.5; varDscrmn_Expr &lt;- 0.1
# generate item parameters from gamma distribution
set.seed(1000)
Dffclt_Expr &lt;-  rgamma(nSample, shape=meanDffclt_Expr^2/varDffclt_Expr,
                      scale=varDffclt_Expr/meanDffclt_Expr)
Dscrmn_Expr &lt;-  rgamma(nSample, shape=meanDscrmn_Expr^2/varDscrmn_Expr,
                      scale=varDscrmn_Expr/meanDscrmn_Expr)
# generate latent trait
theta &lt;- rnorm(nGene)
# the binary response matrix
binary_Expr &lt;- simulateBinaryResponseMat(a=Dscrmn_Expr, b=Dffclt_Expr, theta=theta)
dim(binary_Expr)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
