<!DOCTYPE html><html lang="en"><head><title>Help for package wavScalogram</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wavScalogram}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#core'><p>Extracts the center of a vector</p></a></li>
<li><a href='#cwt_wst'><p>Continuous wavelet transform</p></a></li>
<li><a href='#fourier_factor'><p>Fourier factor of a wavelet</p></a></li>
<li><a href='#pow2scales'><p>Power 2 scales</p></a></li>
<li><a href='#scale_index'><p>Scale index of a signal</p></a></li>
<li><a href='#scalogram'><p>Scalogram of a signal</p></a></li>
<li><a href='#wavelet_radius'><p>Wavelet radius</p></a></li>
<li><a href='#wavPlot'><p>Wavelet plots</p></a></li>
<li><a href='#windowed_scale_index'><p>Windowed scale index</p></a></li>
<li><a href='#windowed_scalogram'><p>Windowed scalograms of a signal</p></a></li>
<li><a href='#wsd'><p>Windowed Scalogram Difference</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wavelet Scalogram Tools for Time Series Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Vicente J. Bolos and Rafael Benitez</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vicente J. Bolos &lt;vicente.bolos@uv.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides scalogram based wavelet tools for time series analysis: wavelet power spectrum, scalogram, windowed scalogram, windowed scalogram difference (see Bolos et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.amc.2017.05.046">doi:10.1016/j.amc.2017.05.046</a>&gt;), scale index and windowed scale index (Benitez et al. (2010) &lt;<a href="https://doi.org/10.1016%2Fj.camwa.2010.05.010">doi:10.1016/j.camwa.2010.05.010</a>&gt;).</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, fields, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-01 09:30:02 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-01 09:04:04 UTC; Vicente</td>
</tr>
</table>
<hr>
<h2 id='core'>Extracts the center of a vector</h2><span id='topic+core'></span>

<h3>Description</h3>

<p>This function is an internal function which extracts from a vector <code>x</code>,
the center of the vector of length <code>n</code>. It emulates the Matlab(R) function <code>wkeep</code>.
This function is used by the cwt_wst function when the HAAR wavelet is selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>core(x,n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="core_+3A_x">x</code></td>
<td>
<p>A vector from wich the center is extracted.</p>
</td></tr>
<tr><td><code id="core_+3A_n">n</code></td>
<td>
<p>Numeric. The length of the center of <code>x</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='cwt_wst'>Continuous wavelet transform</h2><span id='topic+cwt_wst'></span>

<h3>Description</h3>

<p>This function computes the continuous wavelet transform for some families of wavelet
bases: &quot;MORLET&quot;, &quot;DOG&quot;, &quot;PAUL&quot; and &quot;HAAR&quot;.
It is a translation from the Matlab(R) function published by Torrence and Compo
(Torrence &amp; Compo, 1998).
</p>
<p>The difference between <code>cwt_wst</code> and <code>cwt</code> from package <code>Rwave</code> is that
<code>cwt_wst</code> normalizes using <code class="reqn">L^2</code> and <code>cwt</code> uses <code class="reqn">L^1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwt_wst(signal,
               dt = 1,
               scales = NULL,
               powerscales = TRUE,
               wname = c("MORLET", "DOG", "PAUL", "HAAR", "HAAR2"),
               wparam = NULL,
               waverad = NULL,
               border_effects = c("BE", "PER", "SYM"),
               makefigure = TRUE,
               time_values = NULL,
               energy_density = FALSE,
               figureperiod = TRUE,
               xlab = "Time",
               ylab = NULL,
               main = NULL,
               zlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cwt_wst_+3A_signal">signal</code></td>
<td>
<p>A vector containing the signal whose wavelet transform is wanted.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_dt">dt</code></td>
<td>
<p>Numeric. The time step of the signal.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_scales">scales</code></td>
<td>
<p>A vector containing the wavelet scales at which the CWT
is computed. This can be either a vector with all the scales or, following Torrence
and Compo 1998, a vector of 3 elements with the minimum scale, the maximum scale and
the number of suboctaves per octave (in this case, <code>powerscales</code> must be TRUE in
order to construct power 2 scales using a base 2 logarithmic scale). If <code>scales</code>
is NULL, they are automatically constructed.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_powerscales">powerscales</code></td>
<td>
<p>Logical. It must be TRUE (default) in these cases:
</p>

<ul>
<li><p> If <code>scales</code> are power 2 scales, i.e. they use a base 2 logarithmic scale.
</p>
</li>
<li><p> If we want to construct power 2 scales automatically. In this case, <code>scales</code>
must be <code>NULL</code>.
</p>
</li>
<li><p> If we want to construct power 2 scales from <code>scales</code>. In this case,
<code>length(scales)</code> must be 3.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cwt_wst_+3A_wname">wname</code></td>
<td>
<p>A string, equal to &quot;MORLET&quot;, &quot;DOG&quot;, &quot;PAUL&quot;, &quot;HAAR&quot; or &quot;HAAR2&quot;. The
difference between &quot;HAAR&quot; and &quot;HAAR2&quot; is that &quot;HAAR2&quot; is more accurate but slower.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_wparam">wparam</code></td>
<td>
<p>The corresponding nondimensional parameter for the wavelet function
(Morlet, DoG or Paul).</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_waverad">waverad</code></td>
<td>
<p>Numeric. The radius of the wavelet used in the computations for the cone
of influence. If it is not specified, it is asumed to be <code class="reqn">\sqrt{2}</code> for Morlet and DoG,
<code class="reqn">1/\sqrt{2}</code> for Paul and 0.5 for Haar.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_border_effects">border_effects</code></td>
<td>
<p>String, equal to &quot;BE&quot;, &quot;PER&quot; or &quot;SYM&quot;, which indicates how to
manage the border effects which arise usually when a convolution is performed on
finite-length signals.
</p>

<ul>
<li><p> &quot;BE&quot;: Padding time series with zeroes.
</p>
</li>
<li><p> &quot;PER&quot;: Using boundary wavelets (periodization of the original time series).
</p>
</li>
<li><p> &quot;SYM&quot;: Using a symmetric catenation of the original time series.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cwt_wst_+3A_makefigure">makefigure</code></td>
<td>
<p>Logical. If TRUE (default), a figure with the wavelet power spectrum
is plotted.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_time_values">time_values</code></td>
<td>
<p>A numerical vector of length <code>length(signal)</code> containing custom
time values for the figure. If NULL (default), it will be computed starting at 0.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_energy_density">energy_density</code></td>
<td>
<p>Logical. If TRUE (default), divide the wavelet power spectrum by
the scales in the figure and so, values for different scales are comparable.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_figureperiod">figureperiod</code></td>
<td>
<p>Logical. If TRUE (default), periods are used in the figure instead
of scales.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_xlab">xlab</code></td>
<td>
<p>A string giving a custom X axis label.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_ylab">ylab</code></td>
<td>
<p>A string giving a custom Y axis label. If NULL (default) the Y label is
either &quot;Scale&quot; or &quot;Period&quot; depending on the value of <code>figureperiod</code>.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_main">main</code></td>
<td>
<p>A string giving a custom main title for the figure. If NULL
(default) the main title is either &quot;Wavelet Power Spectrum / Scales&quot; or &quot;Wavelet Power
Spectrum&quot; depending on the value of <code>energy_density</code>.</p>
</td></tr>
<tr><td><code id="cwt_wst_+3A_zlim">zlim</code></td>
<td>
<p>A vector of length 2 with the limits for the z-axis (the color bar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>coefs</code>: A matrix of size <code>length(signal)</code> x <code>length(scales)</code>,
containing the CWT coefficients of the signal.
</p>
</li>
<li> <p><code>scales</code>: The vector of scales.
</p>
</li>
<li> <p><code>fourierfactor</code>: A factor for converting scales into periods.
</p>
</li>
<li> <p><code>coi_maxscale</code>: A vector of length <code>length(signal)</code> containing the
values of the maximum scale from which there are border effects at each time.
</p>
</li></ul>



<h3>References</h3>

<p>C. Torrence, G. P. Compo. A practical guide to wavelet analysis. B. Am. Meteorol. Soc.
79 (1998), 61–78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- 0.1
time &lt;- seq(0, 50, dt)
signal &lt;- c(sin(pi * time), sin(pi * time / 2))
cwt &lt;- cwt_wst(signal = signal, dt = dt, energy_density = TRUE)

</code></pre>

<hr>
<h2 id='fourier_factor'>Fourier factor of a wavelet</h2><span id='topic+fourier_factor'></span>

<h3>Description</h3>

<p>This function computes the Fourier factor of a wavelet, according to
Torrence and Compo (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourier_factor(wname = c("MORLET", "DOG", "PAUL", "HAAR", "HAAR2"),
                      wparam = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fourier_factor_+3A_wname">wname</code></td>
<td>
<p>A string, equal to &quot;MORLET&quot;, &quot;DOG&quot;, &quot;PAUL&quot;, &quot;HAAR&quot; or &quot;HAAR2&quot; that
determines the wavelet function.</p>
</td></tr>
<tr><td><code id="fourier_factor_+3A_wparam">wparam</code></td>
<td>
<p>The corresponding nondimensional parameter for the wavelet function
(Morlet, DoG or Paul).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric value of the Fourier factor.
</p>


<h3>References</h3>

<p>C. Torrence, G. P. Compo. A practical guide to wavelet analysis. B. Am. Meteorol. Soc.
79 (1998), 61–78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- fourier_factor(wname = "DOG", wparam = 6)

</code></pre>

<hr>
<h2 id='pow2scales'>Power 2 scales</h2><span id='topic+pow2scales'></span>

<h3>Description</h3>

<p>This function constructs power 2 scales (i.e. using a base 2 logarithmic
scale) from a vector of three elements with the minimum scale, the maximum scale and
the number of suboctaves per octave, following Torrence and Compo 1998.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow2scales(scales)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pow2scales_+3A_scales">scales</code></td>
<td>
<p>A vector of three elements with the minimum scale, the maximum scale and
the number ofsuboctaves per octave.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with all the scales.
</p>


<h3>References</h3>

<p>C. Torrence, G. P. Compo. A practical guide to wavelet analysis. B. Am. Meteorol. Soc.
79 (1998), 61–78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scales &lt;- pow2scales(c(2,128,8))

</code></pre>

<hr>
<h2 id='scale_index'>Scale index of a signal</h2><span id='topic+scale_index'></span>

<h3>Description</h3>

<p>This function computes the scale index of a signal in the scale interval
<code class="reqn">[s_0,s_1]</code>, for a given set of scale parameters <code class="reqn">s_1</code> and taking <code class="reqn">s_0</code> as
the minimum scale (see Benítez et al. 2010).
</p>
<p>The scale index of a signal in the scale interval <code class="reqn">[s_0,s_1]</code> is given by the
quotient </p>
<p style="text-align: center;"><code class="reqn">\frac{S(s_{min})}{S(s_{max})},</code>
</p>
<p> where <code class="reqn">S</code> is
the scalogram, <code class="reqn">s_{max} \in [s_0,s_1]</code> is the smallest scale such that
<code class="reqn">S(s)\le S(s_{max})</code> for all <code class="reqn">s \in [s_0,s_1]</code>, and
<code class="reqn">s_{min} \in [s_{max},2s_1]</code> is the smallest scale such that
<code class="reqn">S(s_{min})\le S(s)</code> for all <code class="reqn">s \in [s_{max},2s_1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_index(signal = NULL,
                   scalog = NULL,
                   dt = 1,
                   scales = NULL,
                   powerscales = TRUE,
                   s1 = NULL,
                   wname = c("MORLET", "DOG", "PAUL", "HAAR", "HAAR2"),
                   wparam = NULL,
                   waverad = NULL,
                   border_effects = c("BE", "INNER", "PER", "SYM"),
                   makefigure = TRUE,
                   figureperiod = TRUE,
                   plot_scalog = FALSE,
                   xlab = NULL,
                   ylab = "Scale index",
                   main = "Scale Index")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_index_+3A_signal">signal</code></td>
<td>
<p>A vector containing the signal whose scale indices are wanted.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_scalog">scalog</code></td>
<td>
<p>A vector containing the scalogram from which the scale indices are going
to be computed. If <code>scalog</code> is not <code>NULL</code>, then <code>signal</code>, <code>waverad</code>
and <code>border_effects</code> are not necessary and they are ignored.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_dt">dt</code></td>
<td>
<p>Numeric. The time step of the signals.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_scales">scales</code></td>
<td>
<p>A vector containing the wavelet scales at wich the scalogram
is computed. This can be either a vector with all the scales or, following Torrence
and Compo 1998, a vector of 3 elements with the minimum scale, the maximum scale and
the number of suboctaves per octave (in this case, <code>powerscales</code> must be TRUE in
order to construct power 2 scales using a base 2 logarithmic scale). If <code>scales</code>
is NULL, they are automatically constructed.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_powerscales">powerscales</code></td>
<td>
<p>Logical. It must be TRUE (default) in these cases:
</p>

<ul>
<li><p> If <code>scales</code> are power 2 scales, i.e. they use a base 2 logarithmic scale.
</p>
</li>
<li><p> If we want to construct power 2 scales automatically. In this case, <code>scales</code>
must be <code>NULL</code>.
</p>
</li>
<li><p> If we want to construct power 2 scales from <code>scales</code>. In this case,
<code>length(scales)</code> must be 3.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_index_+3A_s1">s1</code></td>
<td>
<p>A vector containing the scales <code class="reqn">s_1</code>. The scale indices are computed in
the intervals <code class="reqn">[s_0,s_1]</code>, where <code class="reqn">s_0</code> is the minimum scale in <code>scales</code>.
If <code>s1</code> are not power 2 scales, then <code>scales</code> should not be power 2 scales
either and hence, <code>powerscales</code> must be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_wname">wname</code></td>
<td>
<p>A string, equal to &quot;MORLET&quot;, &quot;DOG&quot;, &quot;PAUL&quot;, &quot;HAAR&quot; or &quot;HAAR2&quot;. The
difference between &quot;HAAR&quot; and &quot;HAAR2&quot; is that &quot;HAAR2&quot; is more accurate but slower.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_wparam">wparam</code></td>
<td>
<p>The corresponding nondimensional parameter for the wavelet function
(Morlet, DoG or Paul).</p>
</td></tr>
<tr><td><code id="scale_index_+3A_waverad">waverad</code></td>
<td>
<p>Numeric. The radius of the wavelet used in the computations for the cone
of influence. If it is not specified, it is asumed to be <code class="reqn">\sqrt{2}</code> for Morlet and DoG,
<code class="reqn">1/\sqrt{2}</code> for Paul and 0.5 for Haar.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_border_effects">border_effects</code></td>
<td>
<p>A string, equal to &quot;BE&quot;, &quot;INNER&quot;, &quot;PER&quot; or &quot;SYM&quot;, which indicates
how to manage the border effects which arise usually when a convolution is performed on
finite-lenght signals.
</p>

<ul>
<li><p> &quot;BE&quot;: With border effects, padding time series with zeroes.
</p>
</li>
<li><p> &quot;INNER&quot;: Normalized inner scalogram with security margin adapted for each
different scale.
</p>
</li>
<li><p> &quot;PER&quot;: With border effects, using boundary wavelets (periodization of the
original time series).
</p>
</li>
<li><p> &quot;SYM&quot;: With border effects, using a symmetric catenation of the original time
series.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_index_+3A_makefigure">makefigure</code></td>
<td>
<p>Logical. If TRUE (default), a figure with the scale indices is
plotted.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_figureperiod">figureperiod</code></td>
<td>
<p>Logical. If TRUE (default), periods are used in the figure instead
of scales.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_plot_scalog">plot_scalog</code></td>
<td>
<p>Logical. If TRUE, it plots the scalogram from which the scale indices
are computed.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_xlab">xlab</code></td>
<td>
<p>A string giving a custom X axis label. If NULL (default) the X label is
either &quot;s1&quot; or &quot;Period of s1&quot; depending on the value of <code>figureperiod</code>.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_ylab">ylab</code></td>
<td>
<p>A string giving a custom Y axis label.</p>
</td></tr>
<tr><td><code id="scale_index_+3A_main">main</code></td>
<td>
<p>A string giving a custom main title for the figure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>si</code>: A vector with the scale indices.
</p>
</li>
<li> <p><code>s0</code>: The scale <code class="reqn">s_0</code>.
</p>
</li>
<li> <p><code>s1</code>: A vector with the scales <code class="reqn">s_1</code>.
</p>
</li>
<li> <p><code>smax</code>: A vector with the scales <code class="reqn">s_{max}</code>.
</p>
</li>
<li> <p><code>smin</code>: A vector with the scales <code class="reqn">s_{min}</code>.
</p>
</li>
<li> <p><code>scalog</code>: A vector with the scalogram from which the scale indices are
computed.
</p>
</li>
<li> <p><code>scalog_smax</code>: A vector with the maximum scalogram values <code class="reqn">S(s_{max})</code>.
</p>
</li>
<li> <p><code>scalog_smin</code>: A vector with the minimum scalogram values <code class="reqn">S(s_{min})</code>.
</p>
</li>
<li> <p><code>fourierfactor</code>: A factor for converting scales into periods.
</p>
</li></ul>



<h3>References</h3>

<p>R. Benítez, V. J. Bolós, M. E. Ramírez. A wavelet-based tool for studying
non-periodicity. Comput. Math. Appl. 60 (2010), no. 3, 634-641.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dt &lt;- 0.1
time &lt;- seq(0, 50, dt)
signal &lt;- c(sin(pi * time), sin(pi * time / 2))
si &lt;- scale_index(signal = signal, dt = dt)

# Another way, giving the scalogram instead of the signal:

sc &lt;- scalogram(signal = signal, dt = dt, energy_density = FALSE, makefigure = FALSE)
si &lt;- scale_index(scalog = sc$scalog, scales = sc$scales, dt = dt)

</code></pre>

<hr>
<h2 id='scalogram'>Scalogram of a signal</h2><span id='topic+scalogram'></span>

<h3>Description</h3>

<p>This function computes the normalized scalogram of a signal for the scales
given. It is important to note that the notion of scalogram here is analogous
to the spectrum of the Fourier transform. It gives the contribution of each scale to
the total energy of the signal. For each scale <code class="reqn">s</code>, it is defined as the square
root of the integral of the squared modulus of the wavelet transform w.r.t. the time
variable <code class="reqn">t</code>, i.e.
</p>
<p style="text-align: center;"><code class="reqn">S(s):= (\int_{-\infty}^{+\infty}|Wf(t,s)|^2 dt)^{1/2}.</code>
</p>

<p>&quot;Normalized&quot; means that the scalogram is divided by the square root of the number of
times, for comparison purposes between different values of the parameter
<code>border_effects</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalogram(signal,
                 dt = 1,
                 scales = NULL,
                 powerscales = TRUE,
                 wname = c("MORLET", "DOG", "PAUL", "HAAR", "HAAR2"),
                 wparam = NULL,
                 waverad = NULL,
                 border_effects = c("BE", "INNER", "PER", "SYM"),
                 energy_density = TRUE,
                 makefigure = TRUE,
                 figureperiod = TRUE,
                 xlab = NULL,
                 ylab = "Scalogram",
                 main = "Scalogram")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scalogram_+3A_signal">signal</code></td>
<td>
<p>A vector containing the signal whose scalogram is wanted.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_dt">dt</code></td>
<td>
<p>Numeric. The time step of the signal.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_scales">scales</code></td>
<td>
<p>A vector containing the wavelet scales at wich the scalogram
is computed. This can be either a vector with all the scales or, following Torrence
and Compo 1998, a vector of 3 elements with the minimum scale, the maximum scale and
the number of suboctaves per octave (in this case, <code>powerscales</code> must be TRUE in
order to construct power 2 scales using a base 2 logarithmic scale). If <code>scales</code>
is NULL, they are automatically constructed.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_powerscales">powerscales</code></td>
<td>
<p>Logical. It must be TRUE (default) in these cases:
</p>

<ul>
<li><p> If <code>scales</code> are power 2 scales, i.e. they use a base 2 logarithmic scale.
</p>
</li>
<li><p> If we want to construct power 2 scales automatically. In this case, <code>scales</code>
must be <code>NULL</code>.
</p>
</li>
<li><p> If we want to construct power 2 scales from <code>scales</code>. In this case,
<code>length(scales)</code> must be 3.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scalogram_+3A_wname">wname</code></td>
<td>
<p>A string, equal to &quot;MORLET&quot;, &quot;DOG&quot;, &quot;PAUL&quot;, &quot;HAAR&quot; or &quot;HAAR2&quot;. The
difference between &quot;HAAR&quot; and &quot;HAAR2&quot; is that &quot;HAAR2&quot; is more accurate but slower.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_wparam">wparam</code></td>
<td>
<p>The corresponding nondimensional parameter for the wavelet function
(Morlet, DoG or Paul).</p>
</td></tr>
<tr><td><code id="scalogram_+3A_waverad">waverad</code></td>
<td>
<p>Numeric. The radius of the wavelet used in the computations for the cone
of influence. If it is not specified, it is asumed to be <code class="reqn">\sqrt{2}</code> for Morlet and DoG,
<code class="reqn">1/\sqrt{2}</code> for Paul and 0.5 for Haar.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_border_effects">border_effects</code></td>
<td>
<p>String, equal to &quot;BE&quot;, &quot;INNER&quot;, &quot;PER&quot; or &quot;SYM&quot;, which indicates
how to manage the border effects which arise usually when a convolution is performed on
finite-lenght signals.
</p>

<ul>
<li><p> &quot;BE&quot;: With border effects, padding time series with zeroes.
</p>
</li>
<li><p> &quot;INNER&quot;: Normalized inner scalogram with security margin adapted for each
different scale.
</p>
</li>
<li><p> &quot;PER&quot;: With border effects, using boundary wavelets (periodization of the
original time series).
</p>
</li>
<li><p> &quot;SYM&quot;: With border effects, using a symmetric catenation of the original time
series.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scalogram_+3A_energy_density">energy_density</code></td>
<td>
<p>Logical. If TRUE (default), divide the scalogram by the square
root of the scales for convert it into energy density.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_makefigure">makefigure</code></td>
<td>
<p>Logical. If TRUE (default), a figure with the scalogram is plotted.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_figureperiod">figureperiod</code></td>
<td>
<p>Logical. If TRUE (default), periods are used in the figure instead
of scales.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_xlab">xlab</code></td>
<td>
<p>A string giving a custom X axis label. If NULL (default) the X label is
either &quot;Scale&quot; or &quot;Period&quot; depending on the value of <code>figureperiod</code>.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_ylab">ylab</code></td>
<td>
<p>A string giving a custom Y axis label.</p>
</td></tr>
<tr><td><code id="scalogram_+3A_main">main</code></td>
<td>
<p>A string giving a custom main title for the figure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>scalog</code>: A vector of length <code>length(scales)</code>, containing the values of
the scalogram at each scale.
</p>
</li>
<li> <p><code>scales</code>: The vector of scales.
</p>
</li>
<li> <p><code>energy</code>: If <code>energy_density</code> is TRUE, it is the <code class="reqn">L^2</code> norm of
<code>scalog</code>.
</p>
</li>
<li> <p><code>fourierfactor</code>: A factor for converting scales into periods.
</p>
</li></ul>



<h3>References</h3>

<p>C. Torrence, G. P. Compo. A practical guide to wavelet analysis. B. Am. Meteorol. Soc.
79 (1998), 61–78.
</p>
<p>V. J. Bolós, R. Benítez, R. Ferrer, R. Jammazi. The windowed scalogram difference: a
novel wavelet tool for comparing time series. Appl. Math. Comput., 312 (2017), 49-65.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- 0.1
time &lt;- seq(0, 50, dt)
signal &lt;- c(sin(pi * time), sin(pi * time / 2))
scalog &lt;- scalogram(signal = signal, dt = dt, border_effects = "INNER")

</code></pre>

<hr>
<h2 id='wavelet_radius'>Wavelet radius</h2><span id='topic+wavelet_radius'></span>

<h3>Description</h3>

<p>This function computes an approximation of the effective radius of a mother wavelet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavelet_radius(wname = c("MORLET", "DOG", "PAUL", "HAAR", "HAAR2"),
                      wparam = NULL,
                      perc = .0025,
                      scale = 100,
                      n = 1000,
                      makefigure = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wavelet_radius_+3A_wname">wname</code></td>
<td>
<p>A string, equal to &quot;MORLET&quot;, &quot;DOG&quot;, &quot;PAUL&quot;, &quot;HAAR&quot; or &quot;HAAR2&quot;. The
difference between &quot;HAAR&quot; and &quot;HAAR2&quot; is that &quot;HAAR2&quot; is more accurate but slower.</p>
</td></tr>
<tr><td><code id="wavelet_radius_+3A_wparam">wparam</code></td>
<td>
<p>The corresponding nondimensional parameter for the wavelet function
(Morlet, DoG or Paul).</p>
</td></tr>
<tr><td><code id="wavelet_radius_+3A_perc">perc</code></td>
<td>
<p>Numeric. The wavelet radius is computed so that the area covered is at
least the 100*(1-<code>perc</code>)% of the total area of the mother wavelet.</p>
</td></tr>
<tr><td><code id="wavelet_radius_+3A_scale">scale</code></td>
<td>
<p>Numeric. Scale of the wavelet used in the computations. It only affects
the accuracy.</p>
</td></tr>
<tr><td><code id="wavelet_radius_+3A_n">n</code></td>
<td>
<p>Numeric. The computations use a time series of length <code class="reqn">2n+1</code>.</p>
</td></tr>
<tr><td><code id="wavelet_radius_+3A_makefigure">makefigure</code></td>
<td>
<p>Logical. Plots a figure with the real part of the mother wavelet and
its modulus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>left</code>: The radius on the left.
</p>
</li>
<li> <p><code>right</code>: The radius on the right.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>waverad &lt;- wavelet_radius(wname = "MORLET", makefigure = TRUE)

</code></pre>

<hr>
<h2 id='wavPlot'>Wavelet plots</h2><span id='topic+wavPlot'></span>

<h3>Description</h3>

<p>This function plots a function of two variables (usually times and
scales). It is suitable for plotting windowed scalograms, windowed scalogram
differences, wavelet coherences and windowed scale indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavPlot(Z,
               X = NULL,
               Y = NULL,
               Ylog = FALSE,
               Yrev = TRUE,
               zlim = NULL,
               coi = NULL,
               rdist = NULL,
               sig95 = NULL,
               sig05 = NULL,
               Xname = "X",
               Yname = "Y",
               Zname = "Z")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wavPlot_+3A_z">Z</code></td>
<td>
<p>A matrix with the images of the function to be plotted.</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_x">X</code></td>
<td>
<p>A vector with x-coordinates (times).</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_y">Y</code></td>
<td>
<p>A vector with y-coordinates (scales).</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_ylog">Ylog</code></td>
<td>
<p>Logical. Considers logarithmic scale for the y-axis.</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_yrev">Yrev</code></td>
<td>
<p>Logical. Considers reverse the y-axis.</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_zlim">zlim</code></td>
<td>
<p>A vector of length 2 with the limits for the z-axis (the color bar).</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_coi">coi</code></td>
<td>
<p>A vector of size <code>length(X)</code> with the y-coordinates of the frontier of
the cone of influence.</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_rdist">rdist</code></td>
<td>
<p>Numeric. Only for WSD plots, margin in the y-axis where appear border
effects.</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_sig95">sig95</code></td>
<td>
<p>Logical matrix with the same size as Z. TRUE if the corresponding point in
Z is inside the significance at 95%.</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_sig05">sig05</code></td>
<td>
<p>Logical matrix with the same size as Z. TRUE if the corresponding point in
Z is inside the significance at 5%.</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_xname">Xname</code></td>
<td>
<p>A string with the name of the x-axis.</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_yname">Yname</code></td>
<td>
<p>A string with the name of the y-axis.</p>
</td></tr>
<tr><td><code id="wavPlot_+3A_zname">Zname</code></td>
<td>
<p>A string with the name of the function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
nt &lt;- 1500
time &lt;- 1:nt
sd_noise &lt;-  0.2 #% In Bolós et al. 2017 Figure 1, sd_noise = 1.
signal1 &lt;- rnorm(n = nt, mean = 0, sd = sd_noise) + sin(time / 10)
signal2 &lt;- rnorm(n = nt, mean = 0, sd = sd_noise) + sin(time / 10)
signal2[500:1000] = signal2[500:1000] + sin((500:1000) / 2)
## Not run: 
wsd &lt;- wsd(signal1 = signal1, signal2 = signal2, mc_nrand = 10, makefigure = FALSE)
wavPlot(Z = -log2(wsd$wsd), X = wsd$t, Y = wsd$scales, Ylog = TRUE, coi = wsd$coi,
        rdist = wsd$rdist, sig95 = wsd$signif95, sig05 = wsd$signif05, Xname = "Time",
        Yname = "Scale", Zname = "-log2(WSD)")

## End(Not run)

</code></pre>

<hr>
<h2 id='windowed_scale_index'>Windowed scale index</h2><span id='topic+windowed_scale_index'></span>

<h3>Description</h3>

<p>This function computes the windowed scale indices of a signal in the scale
interval <code class="reqn">[s_0,s_1]</code>, for a given set of scale parameters <code class="reqn">s_1</code> and taking
<code class="reqn">s_0</code> as the minimum scale (see Benítez et al. 2010).
</p>
<p>The windowed scale index of a signal in the scale interval <code class="reqn">[s_0,s_1]</code> centered at
time <code class="reqn">tc</code> and with time windows radius <code>windowrad</code> is given by the quotient
</p>
<p style="text-align: center;"><code class="reqn">\frac{WS_{windowrad}(tc,s_{min})}{WS_{windowrad}(tc,s_{max})},</code>
</p>

<p>where <code class="reqn">WS_{windowrad}</code> is the corresponding windowed scalogram with time windows
radius <code>windowrad</code>, <code class="reqn">s_{max} \in [s_0,s_1]</code> is the smallest scale such that
<code class="reqn">WS_{windowrad}(tc,s)\le WS_{windowrad}(tc,s_{max})</code> for all <code class="reqn">s \in [s_0,s_1]</code>,
and <code class="reqn">s_{min} \in [s_{max},2s_1]</code> is the smallest scale such that
<code class="reqn">WS_{windowrad}(tc,s_{min})\le WS_{windowrad}(tc,s)</code> for all
<code class="reqn">s \in [s_{max},2s_1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windowed_scale_index(signal = NULL,
                            wsc = NULL,
                            wsc_coi = NULL,
                            dt = 1,
                            scales = NULL,
                            powerscales = TRUE,
                            s1 = NULL,
                            windowrad = NULL,
                            delta_t = NULL,
                            wname = c("MORLET", "DOG", "PAUL", "HAAR", "HAAR2"),
                            wparam = NULL,
                            waverad = NULL,
                            border_effects = c("BE", "INNER", "PER", "SYM"),
                            makefigure = TRUE,
                            time_values = NULL,
                            figureperiod = TRUE,
                            plot_wsc = FALSE,
                            xlab = "Time",
                            ylab = NULL,
                            main = "Windowed Scale Index",
                            zlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="windowed_scale_index_+3A_signal">signal</code></td>
<td>
<p>A vector containing the signal whose windowed scale indices are wanted.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_wsc">wsc</code></td>
<td>
<p>A matrix containing the windowed scalograms from which the windowed scale
indices are going to be computed (number of times x number of scales, as it is returned
by the <code>windowed_scalogram</code> function). If <code>wsc</code> is not <code>NULL</code>, then
<code>signal</code>, <code>windowrad</code>, <code>delta_t</code>, <code>waverad</code> and
<code>border_effects</code> are not necessary and they are ignored.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_wsc_coi">wsc_coi</code></td>
<td>
<p>A vector of length <code>nrow(wsc)</code> (i.e. number of times) containing
the values of the maximum scale at each time from which there are border effects in the
windowed scalogram <code>wsc</code>. If <code>wsc</code> is <code>NULL</code>, then <code>wsc_coi</code> is not
necessary and it is ignored.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_dt">dt</code></td>
<td>
<p>Numeric. The time step of the signal.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_scales">scales</code></td>
<td>
<p>A vector containing the wavelet scales at wich the windowed scalograms
are computed. This can be either a vector with all the scales or, following Torrence
and Compo 1998, a vector of 3 elements with the minimum scale, the maximum scale and
the number of suboctaves per octave. In the first case, <code>powerscales</code> must be
<code>FALSE</code> if the given scales are not power 2 scales. In the second case,
<code>powerscales</code> must be <code>TRUE</code> in order to construct power 2 scales using a
base 2 logarithmic scale). If <code>scales</code> is NULL, they are automatically constructed.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_powerscales">powerscales</code></td>
<td>
<p>Logical. It must be TRUE (default) only in these cases:
</p>

<ul>
<li><p> If <code>scales</code> are power 2 scales, i.e. they use a base 2 logarithmic scale.
</p>
</li>
<li><p> If we want to construct power 2 scales automatically. In this case, <code>scales</code>
must be <code>NULL</code>.
</p>
</li>
<li><p> If we want to construct power 2 scales from <code>scales</code>. In this case,
<code>length(scales)</code> must be 3.
</p>
</li></ul>

<p>Otherwise, it must be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_s1">s1</code></td>
<td>
<p>A vector containing the scales <code class="reqn">s_1</code>. The windowed scale indices are
computed in the intervals <code class="reqn">[s_0,s_1]</code>, where <code class="reqn">s_0</code> is the minimum scale in
<code>scales</code>. If <code>s1</code> are not power 2 scales, then <code>scales</code> should not be
power 2 scales either and hence, <code>powerscales</code> must be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_windowrad">windowrad</code></td>
<td>
<p>Integer. Time radius for the windows, measured in dt. By default,
it is set to <code class="reqn">ceiling(length(signal) / 20)</code>.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_delta_t">delta_t</code></td>
<td>
<p>Integer. Increment of time for the construction of windows central
times, measured in <code>dt</code>. By default, it is set to
<code class="reqn">ceiling(length(signal) / 256)</code>.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_wname">wname</code></td>
<td>
<p>A string, equal to &quot;MORLET&quot;, &quot;DOG&quot;, &quot;PAUL&quot;, &quot;HAAR&quot; or &quot;HAAR2&quot;. The
difference between &quot;HAAR&quot; and &quot;HAAR2&quot; is that &quot;HAAR2&quot; is more accurate but slower.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_wparam">wparam</code></td>
<td>
<p>The corresponding nondimensional parameter for the wavelet function
(Morlet, DoG or Paul).</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_waverad">waverad</code></td>
<td>
<p>Numeric. The radius of the wavelet used in the computations for the cone
of influence. If it is not specified, it is asumed to be <code class="reqn">\sqrt{2}</code> for Morlet and DoG,
<code class="reqn">1/\sqrt{2}</code> for Paul and 0.5 for Haar.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_border_effects">border_effects</code></td>
<td>
<p>A string, equal to &quot;BE&quot;, &quot;INNER&quot;, &quot;PER&quot; or &quot;SYM&quot;, which indicates
how to manage the border effects which arise usually when a convolution is performed on
finite-lenght signals.
</p>

<ul>
<li><p> &quot;BE&quot;: With border effects, padding time series with zeroes.
</p>
</li>
<li><p> &quot;INNER&quot;: Normalized inner scalogram with security margin adapted for each
different scale.
</p>
</li>
<li><p> &quot;PER&quot;: With border effects, using boundary wavelets (periodization of the
original time series).
</p>
</li>
<li><p> &quot;SYM&quot;: With border effects, using a symmetric catenation of the original time
series.
</p>
</li></ul>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_makefigure">makefigure</code></td>
<td>
<p>Logical. If TRUE (default), a figure with the windowed scale indices
is plotted.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_time_values">time_values</code></td>
<td>
<p>A numerical vector of length <code>length(signal)</code> containing custom
time values for the figure. If NULL (default), it will be computed starting at 0.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_figureperiod">figureperiod</code></td>
<td>
<p>Logical. If TRUE (default), periods are used in the figure instead
of scales.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_plot_wsc">plot_wsc</code></td>
<td>
<p>Logical. If TRUE, it plots the windowed scalograms from which the
windowed scale indices are computed.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_xlab">xlab</code></td>
<td>
<p>A string giving a custom X axis label.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_ylab">ylab</code></td>
<td>
<p>A string giving a custom Y axis label. If NULL (default) the Y label is
either &quot;s1&quot; or &quot;Period of s1&quot; depending on the value of <code>figureperiod</code> if
<code>length(s1) &gt; 1</code>, or &quot;Windowed Scale Index&quot; if <code>length(s1) == 1</code>.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_main">main</code></td>
<td>
<p>A string giving a custom main title for the figure.</p>
</td></tr>
<tr><td><code id="windowed_scale_index_+3A_zlim">zlim</code></td>
<td>
<p>A vector of length 2 with the limits for the z-axis (the color bar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>wsi</code>: A matrix of size <code>length(tcentral)</code> x <code>length(s1)</code>
containing the values of the corresponding windowed scale indices.
</p>
</li>
<li> <p><code>s0</code>: The scale <code class="reqn">s_0</code>.
</p>
</li>
<li> <p><code>s1</code>: The vector of scales <code class="reqn">s_1</code>.
</p>
</li>
<li> <p><code>smax</code>: A matrix of size <code>length(tcentral)</code> x <code>length(s1)</code>
containing the scales <code class="reqn">s_{max}</code>.
</p>
</li>
<li> <p><code>smin</code>: A matrix of size <code>length(tcentral)</code> x <code>length(s1)</code>
containing the scales <code class="reqn">s_{min}</code>.
</p>
</li>
<li> <p><code>wsc</code>: A matrix of size <code>length(tcentral)</code> x <code>length(scales)</code>
containing the windowed scalograms from which the windowed scale indices are computed.
</p>
</li>
<li> <p><code>scalog_smax</code>: A matrix of size <code>length(tcentral)</code> x <code>length(s1)</code>
containing the values of the corresponding scalograms at scales <code class="reqn">s_{max}</code>.
</p>
</li>
<li> <p><code>scalog_smin</code>: A matrix of size <code>length(tcentral)</code> x <code>length(s1)</code>
containing the values of the corresponding scalograms at scales <code class="reqn">s_{min}</code>.
</p>
</li>
<li> <p><code>tcentral</code>: The vector of central times used in the computation of
<code>wsi</code>.
</p>
</li>
<li> <p><code>windowrad</code>: Radius for the time windows, measured in <code>dt</code>.
</p>
</li>
<li> <p><code>fourierfactor</code>: A factor for converting scales into periods.
</p>
</li>
<li> <p><code>coi_maxscale</code>: A vector of length <code>length(tcentral)</code> containing the
values of the maximum scale at each time from which there are border effects.
</p>
</li></ul>



<h3>References</h3>

<p>R. Benítez, V. J. Bolós, M. E. Ramírez. A wavelet-based tool for studying
non-periodicity. Comput. Math. Appl. 60 (2010), no. 3, 634-641.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dt &lt;- 0.1
time &lt;- seq(0, 50, dt)
signal &lt;- c(sin(pi * time), sin(pi * time / 2))
# First, we try with default s1 scales (a vector with a wide range of values for s1).
wsi_full &lt;- windowed_scale_index(signal = signal, dt = dt, figureperiod = FALSE)
# Next, we choose a meaningful s1 value, greater than all relevant scales.
wsi &lt;- windowed_scale_index(signal = signal, dt = dt, s1 = 4, figureperiod = FALSE)

# Another way, giving the windowed scalograms instead of the signal:

wsc &lt;- windowed_scalogram(signal = signal, dt = dt, figureperiod = FALSE,
                          energy_density = FALSE, makefigure = FALSE)
wsi_full &lt;- windowed_scale_index(wsc = wsc$wsc, wsc_coi = wsc$coi_maxscale,
                                 scales = wsc$scales, time_values = wsc$tcentral,
                                 figureperiod = FALSE)
wsi &lt;- windowed_scale_index(wsc = wsc$wsc, wsc_coi = wsc$coi_maxscale,
                            scales = wsc$scales, s1 = 4, time_values = wsc$tcentral,
                            figureperiod = FALSE)

</code></pre>

<hr>
<h2 id='windowed_scalogram'>Windowed scalograms of a signal</h2><span id='topic+windowed_scalogram'></span>

<h3>Description</h3>

<p>This function computes the normalized windowed scalograms of a signal for
the scales given. It is computed using time windows with radius <code>windowrad</code>
centered at a vector of central times with increment of time <code>delta_t</code>. It is
important to note that the notion of scalogram here is analogous to the spectrum of the
Fourier transform. It gives the contribution of each scale to the total energy of the
signal. For each scale <code class="reqn">s</code> and central time <code class="reqn">tc</code>, it is defined as the square
root of the integral of the squared modulus of the wavelet transform w.r.t the time
variable <code class="reqn">t</code>, i.e.
</p>
<p style="text-align: center;"><code class="reqn">WS_{windowrad}(tc,s):=
  (\int_{tc-windowrad}^{tc+windowrad}|Wf(t,s)|^2 dt)^{1/2}.</code>
</p>

<p>&quot;Normalized&quot; means that the windowed scalograms are divided by the square root of the
length of the respective time windows in order to be comparable between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windowed_scalogram(signal,
                          dt = 1,
                          scales = NULL,
                          powerscales = TRUE,
                          windowrad = NULL,
                          delta_t = NULL,
                          wname = c("MORLET", "DOG", "PAUL", "HAAR", "HAAR2"),
                          wparam = NULL,
                          waverad = NULL,
                          border_effects = c("BE", "INNER", "PER", "SYM"),
                          energy_density = TRUE,
                          makefigure = TRUE,
                          time_values = NULL,
                          figureperiod = TRUE,
                          xlab = "Time",
                          ylab = NULL,
                          main = "Windowed Scalogram",
                          zlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="windowed_scalogram_+3A_signal">signal</code></td>
<td>
<p>A vector containing the signal whose windowed scalogram is wanted.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_dt">dt</code></td>
<td>
<p>Numeric. The time step of the signal.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_scales">scales</code></td>
<td>
<p>A vector containing the wavelet scales at wich the windowed scalograms
are computed. This can be either a vector with all the scales or, following Torrence
and Compo 1998, a vector of 3 elements with the minimum scale, the maximum scale and
the number of suboctaves per octave. In the first case, <code>powerscales</code> must be
<code>FALSE</code> if the given scales are not power 2 scales. In the second case,
<code>powerscales</code> must be <code>TRUE</code> in order to construct power 2 scales using a
base 2 logarithmic scale). If <code>scales</code> is NULL, they are automatically constructed.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_powerscales">powerscales</code></td>
<td>
<p>Logical. It must be TRUE (default) only in these cases:
</p>

<ul>
<li><p> If <code>scales</code> are power 2 scales, i.e. they use a base 2 logarithmic scale.
</p>
</li>
<li><p> If we want to construct power 2 scales automatically. In this case, <code>scales</code>
must be <code>NULL</code>.
</p>
</li>
<li><p> If we want to construct power 2 scales from <code>scales</code>. In this case,
<code>length(scales)</code> must be 3.
</p>
</li></ul>

<p>Otherwise, it must be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_windowrad">windowrad</code></td>
<td>
<p>Integer. Time radius for the windows, measured in <code>dt</code>. By
default, it is set to <code class="reqn">ceiling(length(signal) / 20)</code>.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_delta_t">delta_t</code></td>
<td>
<p>Integer. Increment of time for the construction of windows central
times, measured in <code>dt</code>. By default, it is set to
<code class="reqn">ceiling(length(signal) / 256)</code>.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_wname">wname</code></td>
<td>
<p>A string, equal to &quot;MORLET&quot;, &quot;DOG&quot;, &quot;PAUL&quot;, &quot;HAAR&quot; or &quot;HAAR2&quot;. The
difference between &quot;HAAR&quot; and &quot;HAAR2&quot; is that &quot;HAAR2&quot; is more accurate but slower.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_wparam">wparam</code></td>
<td>
<p>The corresponding nondimensional parameter for the wavelet function
(Morlet, DoG or Paul).</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_waverad">waverad</code></td>
<td>
<p>Numeric. The radius of the wavelet used in the computations for the cone
of influence. If it is not specified, it is asumed to be <code class="reqn">\sqrt{2}</code> for Morlet and DoG,
<code class="reqn">1/\sqrt{2}</code> for Paul and 0.5 for Haar.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_border_effects">border_effects</code></td>
<td>
<p>String, equal to &quot;BE&quot;, &quot;INNER&quot;, &quot;PER&quot; or &quot;SYM&quot;, which indicates
how to manage the border effects which arise usually when a convolution is performed on
finite-lenght signals.
</p>

<ul>
<li><p> &quot;BE&quot;: With border effects, padding time series with zeroes.
</p>
</li>
<li><p> &quot;INNER&quot;: Normalized inner scalogram with security margin adapted for each
different scale. Although there are no border effects, it is shown as a regular COI
the zone in which the length of <code class="reqn">J(s)</code> (see Benítez et al. 2010) is smaller and
it has to be normalized.
</p>
</li>
<li><p> &quot;PER&quot;: With border effects, using boundary wavelets (periodization of the
original time series).
</p>
</li>
<li><p> &quot;SYM&quot;: With border effects, using a symmetric catenation of the original time
series.
</p>
</li></ul>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_energy_density">energy_density</code></td>
<td>
<p>Logical. If TRUE (default), divide the scalograms by the square
root of the scales for convert them into energy density.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_makefigure">makefigure</code></td>
<td>
<p>Logical. If TRUE (default), a figure with the scalograms is plotted.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_time_values">time_values</code></td>
<td>
<p>A numerical vector of length <code>length(signal)</code> containing custom
time values for the figure. If NULL (default), it will be computed starting at 0.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_figureperiod">figureperiod</code></td>
<td>
<p>Logical. If TRUE (default), periods are used in the figure instead
of scales.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_xlab">xlab</code></td>
<td>
<p>A string giving a custom X axis label.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_ylab">ylab</code></td>
<td>
<p>A string giving a custom Y axis label. If NULL (default) the Y label is
either &quot;Scale&quot; or &quot;Period&quot; depending on the value of <code>figureperiod</code> if
<code>length(scales) &gt; 1</code>, or &quot;Windowed Scalogram&quot; if <code>length(scales) == 1</code>.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_main">main</code></td>
<td>
<p>A string giving a custom main title for the figure.</p>
</td></tr>
<tr><td><code id="windowed_scalogram_+3A_zlim">zlim</code></td>
<td>
<p>A vector of length 2 with the limits for the z-axis (the color bar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>wsc</code>: A matrix of size <code>length(tcentral)</code> x <code>length(scales)</code>
containing the values of the windowed scalograms at each scale and at each time window.
</p>
</li>
<li> <p><code>tcentral</code>: The vector of central times at which the windows are centered.
</p>
</li>
<li> <p><code>scales</code>: The vector of the scales.
</p>
</li>
<li> <p><code>windowrad</code>: Radius for the time windows, measured in <code>dt</code>.
</p>
</li>
<li> <p><code>fourierfactor</code>: A factor for converting scales into periods.
</p>
</li>
<li> <p><code>coi_maxscale</code>: A vector of length <code>length(tcentral)</code> containing the
values of the maximum scale from which there are border effects for the respective
central time.
</p>
</li></ul>



<h3>References</h3>

<p>C. Torrence, G. P. Compo. A practical guide to wavelet analysis. B. Am. Meteorol. Soc.
79 (1998), 61–78.
</p>
<p>V. J. Bolós, R. Benítez, R. Ferrer, R. Jammazi. The windowed scalogram difference: a
novel wavelet tool for comparing time series. Appl. Math. Comput., 312 (2017), 49-65.
</p>
<p>R. Benítez, V. J. Bolós, M. E. Ramírez. A wavelet-based tool for studying
non-periodicity. Comput. Math. Appl. 60 (2010), no. 3, 634-641.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- 0.1
time &lt;- seq(0, 50, dt)
signal &lt;- c(sin(pi * time), sin(pi * time / 2))
wscalog &lt;- windowed_scalogram(signal = signal, dt = dt)


</code></pre>

<hr>
<h2 id='wsd'>Windowed Scalogram Difference</h2><span id='topic+wsd'></span>

<h3>Description</h3>

<p>This function computes the Windowed Scalogram Difference of two signals.
The definition and details can be found in (Bolós et al. 2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wsd(signal1,
           signal2,
           dt = 1,
           scaleparam = NULL,
           windowrad = NULL,
           rdist = NULL,
           delta_t = NULL,
           normalize = c("NO", "ENERGY", "MAX", "SCALE"),
           refscale = NULL,
           wname = c("MORLET", "DOG", "PAUL", "HAAR", "HAAR2"),
           wparam = NULL,
           waverad = NULL,
           border_effects = c("BE", "INNER", "PER", "SYM"),
           mc_nrand = 0,
           commutative = TRUE,
           wscnoise = 0.02,
           compensation = 0,
           energy_density = TRUE,
           parallel = FALSE,
           makefigure = TRUE,
           time_values = NULL,
           figureperiod = TRUE,
           xlab = "Time",
           ylab = NULL,
           main = "-log2(WSD)",
           zlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wsd_+3A_signal1">signal1</code></td>
<td>
<p>A vector containing the first signal.</p>
</td></tr>
<tr><td><code id="wsd_+3A_signal2">signal2</code></td>
<td>
<p>A vector containing the second signal (its length should be equal to
that of <code>signal1</code>).</p>
</td></tr>
<tr><td><code id="wsd_+3A_dt">dt</code></td>
<td>
<p>Numeric. The time step of the signals.</p>
</td></tr>
<tr><td><code id="wsd_+3A_scaleparam">scaleparam</code></td>
<td>
<p>A vector of three elements with the minimum scale, the maximum scale
and the number of suboctaves per octave for constructing power 2 scales (following
Torrence and Compo 1998). If NULL, they are automatically constructed.</p>
</td></tr>
<tr><td><code id="wsd_+3A_windowrad">windowrad</code></td>
<td>
<p>Integer. Time radius for the windows, measured in <code>dt</code>. By
default, it is set to <code class="reqn">ceiling(length(signal1) / 20)</code>.</p>
</td></tr>
<tr><td><code id="wsd_+3A_rdist">rdist</code></td>
<td>
<p>Integer. Log-scale radius for the windows measured in suboctaves. By
default, it is set to <code class="reqn">ceiling(length(scales) / 20)</code>.</p>
</td></tr>
<tr><td><code id="wsd_+3A_delta_t">delta_t</code></td>
<td>
<p>Integer. Increment of time for the construction of windows central
times, measured in <code>dt</code>. By default, it is set to
<code class="reqn">ceiling(length(signal1) / 256)</code>.</p>
</td></tr>
<tr><td><code id="wsd_+3A_normalize">normalize</code></td>
<td>
<p>String, equal to &quot;NO&quot;, &quot;ENERGY&quot;, &quot;MAX&quot; or &quot;SCALE&quot;. If &quot;ENERGY&quot;, signals are
divided by their respective energies. If &quot;MAX&quot;, each signal is divided by the maximum
value attained by its scalogram. In these two cases, <code>energy_density</code> must be TRUE.
Finally, if &quot;SCALE&quot;, each signal is divided by their scalogram value at scale
<code>refscale</code>.</p>
</td></tr>
<tr><td><code id="wsd_+3A_refscale">refscale</code></td>
<td>
<p>Numeric. The reference scale for <code>normalize</code>.</p>
</td></tr>
<tr><td><code id="wsd_+3A_wname">wname</code></td>
<td>
<p>A string, equal to &quot;MORLET&quot;, &quot;DOG&quot;, &quot;PAUL&quot;, &quot;HAAR&quot; or &quot;HAAR2&quot;. The
difference between &quot;HAAR&quot; and &quot;HAAR2&quot; is that &quot;HAAR2&quot; is more accurate but slower.</p>
</td></tr>
<tr><td><code id="wsd_+3A_wparam">wparam</code></td>
<td>
<p>The corresponding nondimensional parameter for the wavelet function
(Morlet, DoG or Paul).</p>
</td></tr>
<tr><td><code id="wsd_+3A_waverad">waverad</code></td>
<td>
<p>Numeric. The radius of the wavelet used in the computations for the cone
of influence. If it is not specified, it is asumed to be <code class="reqn">\sqrt{2}</code> for Morlet and DoG,
<code class="reqn">1/\sqrt{2}</code> for Paul and 0.5 for Haar.</p>
</td></tr>
<tr><td><code id="wsd_+3A_border_effects">border_effects</code></td>
<td>
<p>String, equal to &quot;BE&quot;, &quot;INNER&quot;, &quot;PER&quot; or &quot;SYM&quot;,
which indicates how to manage the border effects which arise usually when a convolution
is performed on finite-lenght signals.
</p>

<ul>
<li><p> &quot;BE&quot;: With border effects, padding time series with zeroes.
</p>
</li>
<li><p> &quot;INNER&quot;: Normalized inner scalogram with security margin adapted for each
different scale.
</p>
</li>
<li><p> &quot;PER&quot;: With border effects, using boundary wavelets (periodization of the
original time series).
</p>
</li>
<li><p> &quot;SYM&quot;: With border effects, using a symmetric catenation of the original time
series.
</p>
</li></ul>
</td></tr>
<tr><td><code id="wsd_+3A_mc_nrand">mc_nrand</code></td>
<td>
<p>Integer. Number of Montecarlo simulations to be performed in order to
determine the 95% and 5% significance contours.</p>
</td></tr>
<tr><td><code id="wsd_+3A_commutative">commutative</code></td>
<td>
<p>Logical. If TRUE (default) the commutative windowed scalogram
difference. Otherwise a non-commutative (but simpler) version is computed (see Bolós et
al. 2017).</p>
</td></tr>
<tr><td><code id="wsd_+3A_wscnoise">wscnoise</code></td>
<td>
<p>Numeric in <code class="reqn">[0,1]</code>. If a (windowed) scalogram takes values close to
zero, some problems may appear because we are considering relative differences.
Specifically, we can get high relative differences that in fact are not relevant, or
even divisions by zero.
</p>
<p>If we consider absolute differences this would not happen but, on the other hand,
using absolute differences is not appropriate for scalogram values not close to zero.
</p>
<p>So, the parameter <code>wscnoise</code> stablishes a threshold for the scalogram values
above which a relative difference is computed, and below which a difference
proportional to the absolute difference is computed (the proportionality factor is
determined by requiring continuity).
</p>
<p>Finally, <code>wscnoise</code> can be interpreted as the relative amplitude of the noise in
the scalograms and is chosen in order to make a relative (<code class="reqn">= 0</code>), absolute
(<code class="reqn">= 1</code>) or mix (in <code class="reqn">(0,1)</code>) difference between scalograms. Default value is
set to <code class="reqn">0.02</code>.</p>
</td></tr>
<tr><td><code id="wsd_+3A_compensation">compensation</code></td>
<td>
<p>Numeric. It is an alternative to <code>wscnoise</code> for
preventing numerical errors or non-relevant high relative differences when scalogram
values are close to zero (see Bolós et al. 2017). It should be a non-negative
relatively small value.</p>
</td></tr>
<tr><td><code id="wsd_+3A_energy_density">energy_density</code></td>
<td>
<p>Logical. If TRUE (default), divide the scalograms by the square
root of the scales for convert them into energy density. Note that it does not affect
the results if <code>wscnoise</code> <code class="reqn">= 0</code>.</p>
</td></tr>
<tr><td><code id="wsd_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If TRUE, it uses function <code>parApply</code> from package
<code>parallel</code> for the Montecarlo simulations. When FALSE (default) it uses the normal
<code>apply</code> function.</p>
</td></tr>
<tr><td><code id="wsd_+3A_makefigure">makefigure</code></td>
<td>
<p>Logical. If TRUE (default), a figure with the WSD is plotted.</p>
</td></tr>
<tr><td><code id="wsd_+3A_time_values">time_values</code></td>
<td>
<p>A numerical vector of length <code>length(signal)</code> containing custom
time values for the figure. If NULL (default), it will be computed starting at 0.</p>
</td></tr>
<tr><td><code id="wsd_+3A_figureperiod">figureperiod</code></td>
<td>
<p>Logical. If TRUE (default), periods are used in the figure instead
of scales.</p>
</td></tr>
<tr><td><code id="wsd_+3A_xlab">xlab</code></td>
<td>
<p>A string giving a custom X axis label.</p>
</td></tr>
<tr><td><code id="wsd_+3A_ylab">ylab</code></td>
<td>
<p>A string giving a custom Y axis label. If NULL (default) the Y label is
either &quot;Scale&quot; or &quot;Period&quot; depending on the value of <code>figureperiod</code>.</p>
</td></tr>
<tr><td><code id="wsd_+3A_main">main</code></td>
<td>
<p>A string giving a custom main title for the figure.</p>
</td></tr>
<tr><td><code id="wsd_+3A_zlim">zlim</code></td>
<td>
<p>A vector of length 2 with the limits for the z-axis (the color bar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>

<ul>
<li> <p><code>wsd</code>: A matrix of size <code>length(tcentral)</code> x <code>length(scales)</code>
containing the values of the windowed scalogram differences at each scale and at each
time window.
</p>
</li>
<li> <p><code>tcentral</code>: The vector of central times used in the computations of the
windowed scalograms.
</p>
</li>
<li> <p><code>scales</code>: The vector of scales.
</p>
</li>
<li> <p><code>windowrad</code>: Radius for the time windows of the windowed scalograms,
measured in <code>dt</code>.
</p>
</li>
<li> <p><code>rdist</code>: The log-scale radius for the windows measured in suboctaves.
</p>
</li>
<li> <p><code>signif95</code>: A logical matrix of size <code>length(tcentral)</code> x
<code>length(scales)</code>. If TRUE, the corresponding point of the <code>wsd</code> matrix is in
the 95% significance.
</p>
</li>
<li> <p><code>signif05</code>: A logical matrix of size <code>length(tcentral)</code> x
<code>length(scales)</code>. If TRUE, the corresponding point of the <code>wsd</code> matrix is in
the 5% significance.
</p>
</li>
<li> <p><code>fourierfactor</code>: A factor for converting scales into periods.
</p>
</li>
<li> <p><code>coi_maxscale</code>: A vector of length <code>length(tcentral)</code> containing the
values of the maximum scale from which there are border effects for the respective
central time.
</p>
</li></ul>



<h3>References</h3>

<p>C. Torrence, G. P. Compo. A practical guide to wavelet analysis. B. Am. Meteorol. Soc.
79 (1998), 61–78.
</p>
<p>V. J. Bolós, R. Benítez, R. Ferrer, R. Jammazi. The windowed scalogram difference: a
novel wavelet tool for comparing time series. Appl. Math. Comput., 312 (2017), 49-65.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nt &lt;- 1500
time &lt;- 1:nt
sd_noise &lt;-  0.2 #% In Bolós et al. 2017 Figure 1, sd_noise = 1.
signal1 &lt;- rnorm(n = nt, mean = 0, sd = sd_noise) + sin(time / 10)
signal2 &lt;- rnorm(n = nt, mean = 0, sd = sd_noise) + sin(time / 10)
signal2[500:1000] = signal2[500:1000] + sin((500:1000) / 2)
## Not run: 
wsd &lt;- wsd(signal1 = signal1, signal2 = signal2)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
