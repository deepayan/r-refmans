<!DOCTYPE html><html><head><title>Help for package clarabel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clarabel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clarabel'><p>Interface to 'Clarabel', an interior point conic solver</p></a></li>
<li><a href='#clarabel_control'><p>Control parameters with default values and types in parenthesis</p></a></li>
<li><a href='#clarabel-package'><p>Interface to Clarabel solver implemented in Rust.</p></a></li>
<li><a href='#solver_status_descriptions'><p>Return the solver status description as a named character vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interior Point Conic Optimization Solver</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A versatile interior point solver that solves linear programs (LPs), quadratic programs (QPs), second-order cone programs (SOCPs), semidefinite programs (SDPs), and problems with exponential and power cone constraints (<a href="https://oxfordcontrol.github.io/ClarabelDocs/stable/">https://oxfordcontrol.github.io/ClarabelDocs/stable/</a>). For quadratic objectives, unlike interior point solvers based on the standard homogeneous self-dual embedding (HSDE) model, 'Clarabel' handles quadratic objective without requiring any epigraphical reformulation of its objective function. It can therefore be significantly faster than other HSDE-based solvers for problems with quadratic objective functions. Infeasible problems are detected using using a homogeneous embedding technique.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Cargo (rustc package manager) and GNU make</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/rextendr/version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://oxfordcontrol.github.io/clarabel-r/">https://oxfordcontrol.github.io/clarabel-r/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/oxfordcontrol/clarabel-r/issues">https://github.com/oxfordcontrol/clarabel-r/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, Matrix, rmarkdown, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-24 05:31:21 UTC; naras</td>
</tr>
<tr>
<td>Author:</td>
<td>Balasubramanian Narasimhan [aut, cre],
  Paul Goulart [aut, cph],
  Yuwen Chen [aut],
  Hiroaki Yutani [ctb] (For vendoring/Makefile hints/R scripts for
    generating crate authors/licenses),
  The authors of the dependency Rust crates [ctb] (see inst/AUTHORS file
    for details)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Balasubramanian Narasimhan &lt;naras@stanford.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-24 18:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='clarabel'>Interface to 'Clarabel', an interior point conic solver</h2><span id='topic+clarabel'></span>

<h3>Description</h3>

<p>Clarabel solves linear programs (LPs), quadratic programs (QPs),
second-order cone programs (SOCPs) and semidefinite programs
(SDPs). It also solves problems with exponential and power cone
constraints. The specific problem solved is:
</p>
<p>Minimize </p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2}x^TPx + q^Tx</code>
</p>
<p> subject to </p>
<p style="text-align: center;"><code class="reqn">Ax + s =
  b</code>
</p>
 <p style="text-align: center;"><code class="reqn">s \in K</code>
</p>
<p> where <code class="reqn">x \in R^n</code>, <code class="reqn">s \in R^m</code>, <code class="reqn">P
  = P^T</code> and nonnegative-definite, <code class="reqn">q \in R^n</code>, <code class="reqn">A \in
  R^{m\times n}</code>, and <code class="reqn">b \in R^m</code>. The set <code class="reqn">K</code> is a
composition of convex cones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clarabel(A, b, q, P = NULL, cones, control = list(), strict_cone_order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clarabel_+3A_a">A</code></td>
<td>
<p>a matrix of constraint coefficients.</p>
</td></tr>
<tr><td><code id="clarabel_+3A_b">b</code></td>
<td>
<p>a numeric vector giving the primal constraints</p>
</td></tr>
<tr><td><code id="clarabel_+3A_q">q</code></td>
<td>
<p>a numeric vector giving the primal objective</p>
</td></tr>
<tr><td><code id="clarabel_+3A_p">P</code></td>
<td>
<p>a symmetric positive semidefinite matrix, default
<code>NULL</code></p>
</td></tr>
<tr><td><code id="clarabel_+3A_cones">cones</code></td>
<td>
<p>a named list giving the cone sizes, see &ldquo;Cone
Parameters&rdquo; below for specification</p>
</td></tr>
<tr><td><code id="clarabel_+3A_control">control</code></td>
<td>
<p>a list giving specific control parameters to use in
place of default values, with an empty list indicating the
default control parameters. Specified parameters should be
correctly named and typed to avoid Rust system panics as no
sanitization is done for efficiency reasons</p>
</td></tr>
<tr><td><code id="clarabel_+3A_strict_cone_order">strict_cone_order</code></td>
<td>
<p>a logical flag, default <code>TRUE</code> for forcing
order of cones described below. If <code>FALSE</code> cones can be specified
in any order and even repeated and directly passed to the solver
without type and length checks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the rows in matrix <code class="reqn">A</code> has to correspond to the
order given in the table &ldquo;Cone Parameters&rdquo;, which means
means rows corresponding to <em>primal zero cones</em> should be
first, rows corresponding to <em>non-negative cones</em> second,
rows corresponding to <em>second-order cone</em> third, rows
corresponding to <em>positive semidefinite cones</em> fourth, rows
corresponding to <em>exponential cones</em> fifth and rows
corresponding to <em>power cones</em> at last.
</p>
<p>When the parameter <code>strict_cone_order</code> is <code>FALSE</code>, one can specify
the cones in any order and even repeat them in the order they
appear in the <code>A</code> matrix. See below.
</p>


<h4>Clarabel can solve</h4>

  <ol>
<li><p> linear programs
(LPs) </p>
</li>
<li><p> second-order cone programs (SOCPs) </p>
</li>
<li><p> exponential
cone programs (ECPs) </p>
</li>
<li><p> power cone programs (PCPs) </p>
</li>
<li>
<p>problems with any combination of cones, defined by the parameters
listed in &ldquo;Cone Parameters&rdquo; below </p>
</li></ol>
 


<h4>Cone Parameters</h4>

<p>The table below shows the cone parameter specifications
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <b>Parameter</b> </td><td style="text-align: left;"> <b>Type</b> </td><td style="text-align: left;"> <b>Length</b> </td><td style="text-align: left;"> <b>Description</b>                       </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>z</code>         </td><td style="text-align: left;"> integer     </td><td style="text-align: left;"> <code class="reqn">1</code>       </td><td style="text-align: left;"> number of primal zero cones (dual free cones),       </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;">                  </td><td style="text-align: left;">             </td><td style="text-align: left;">               </td><td style="text-align: left;"> which corresponds to the primal equality constraints </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>l</code>         </td><td style="text-align: left;"> integer     </td><td style="text-align: left;"> <code class="reqn">1</code>       </td><td style="text-align: left;"> number of linear cones (non-negative cones)          </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>q</code>         </td><td style="text-align: left;"> integer     </td><td style="text-align: left;"> <code class="reqn">\geq1</code>   </td><td style="text-align: left;"> vector of second-order cone sizes                    </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>s</code>         </td><td style="text-align: left;"> integer     </td><td style="text-align: left;"> <code class="reqn">\geq1</code>   </td><td style="text-align: left;"> vector of positive semidefinite cone sizes           </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>ep</code>        </td><td style="text-align: left;"> integer     </td><td style="text-align: left;"> <code class="reqn">1</code>       </td><td style="text-align: left;"> number of primal exponential cones                   </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>p</code>         </td><td style="text-align: left;"> numeric     </td><td style="text-align: left;"> <code class="reqn">\geq1</code>   </td><td style="text-align: left;"> vector of primal power cone parameters
</td>
</tr>

</table>
 
<p>When the parameter <code>strict_cone_order</code> is <code>FALSE</code>, one can specify
the cones in the order they appear in the <code>A</code> matrix. The <code>cones</code>
argument in such a case should be a named list with names matching
<code style="white-space: pre;">&#8288;^z*&#8288;</code> indicating primal zero cones, <code style="white-space: pre;">&#8288;^l*&#8288;</code> indicating linear cones,
and so on. For example, either of the following would be valid: <code>list(z = 2L, l = 2L, q = 2L, z = 3L, q = 3L)</code>, or, <code>list(z1 = 2L, l1 = 2L, q1 = 2L, zb = 3L, qx = 3L)</code>, indicating a zero
cone of size 2, followed by a linear cone of size 2, followed by a second-order
cone of size 2, followed by a zero cone of size 3, and finally a second-order
cone of size 3.
</p>


<h3>Value</h3>

<p>named list of solution vectors x, y, s and information
about run
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clarabel_control">clarabel_control()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1, 1), ncol = 1)
b &lt;- c(1, 1)
obj &lt;- 1
cone &lt;- list(z = 2L)
control &lt;- clarabel_control(tol_gap_rel = 1e-7, tol_gap_abs = 1e-7, max_iter = 100)
clarabel(A = A, b = b, q = obj, cones = cone, control = control)

</code></pre>

<hr>
<h2 id='clarabel_control'>Control parameters with default values and types in parenthesis</h2><span id='topic+clarabel_control'></span>

<h3>Description</h3>

<p>Control parameters with default values and types in parenthesis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clarabel_control(
  max_iter = 200L,
  time_limit = Inf,
  verbose = TRUE,
  max_step_fraction = 0.99,
  tol_gap_abs = 1e-08,
  tol_gap_rel = 1e-08,
  tol_feas = 1e-08,
  tol_infeas_abs = 1e-08,
  tol_infeas_rel = 1e-08,
  tol_ktratio = 1e-06,
  reduced_tol_gap_abs = 5e-05,
  reduced_tol_gap_rel = 5e-05,
  reduced_tol_feas = 1e-04,
  reduced_tol_infeas_abs = 5e-05,
  reduced_tol_infeas_rel = 5e-05,
  reduced_tol_ktratio = 1e-04,
  equilibrate_enable = TRUE,
  equilibrate_max_iter = 10L,
  equilibrate_min_scaling = 1e-04,
  equilibrate_max_scaling = 10000,
  linesearch_backtrack_step = 0.8,
  min_switch_step_length = 0.1,
  min_terminate_step_length = 1e-04,
  direct_kkt_solver = TRUE,
  direct_solve_method = c("qdldl", "mkl", "cholmod"),
  static_regularization_enable = TRUE,
  static_regularization_constant = 1e-08,
  static_regularization_proportional = .Machine$double.eps * .Machine$double.eps,
  dynamic_regularization_enable = TRUE,
  dynamic_regularization_eps = 1e-13,
  dynamic_regularization_delta = 2e-07,
  iterative_refinement_enable = TRUE,
  iterative_refinement_reltol = 1e-13,
  iterative_refinement_abstol = 1e-12,
  iterative_refinement_max_iter = 10L,
  iterative_refinement_stop_ratio = 5,
  presolve_enable = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clarabel_control_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations (<code>200L</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_time_limit">time_limit</code></td>
<td>
<p>maximum run time (seconds) (<code>Inf</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_verbose">verbose</code></td>
<td>
<p>verbose printing (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_max_step_fraction">max_step_fraction</code></td>
<td>
<p>maximum interior point step length (<code>0.99</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_tol_gap_abs">tol_gap_abs</code></td>
<td>
<p>absolute duality gap tolerance (<code>1e-8</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_tol_gap_rel">tol_gap_rel</code></td>
<td>
<p>relative duality gap tolerance (<code>1e-8</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_tol_feas">tol_feas</code></td>
<td>
<p>feasibility check tolerance (primal and dual) (<code>1e-8</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_tol_infeas_abs">tol_infeas_abs</code></td>
<td>
<p>absolute infeasibility tolerance (primal and dual) (<code>1e-8</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_tol_infeas_rel">tol_infeas_rel</code></td>
<td>
<p>relative infeasibility tolerance (primal and dual) (<code>1e-8</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_tol_ktratio">tol_ktratio</code></td>
<td>
<p>KT tolerance (<code>1e-7</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_reduced_tol_gap_abs">reduced_tol_gap_abs</code></td>
<td>
<p>reduced absolute duality gap tolerance (<code>5e-5</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_reduced_tol_gap_rel">reduced_tol_gap_rel</code></td>
<td>
<p>reduced relative duality gap tolerance (<code>5e-5</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_reduced_tol_feas">reduced_tol_feas</code></td>
<td>
<p>reduced feasibility check tolerance (primal and dual) (<code>1e-4</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_reduced_tol_infeas_abs">reduced_tol_infeas_abs</code></td>
<td>
<p>reduced absolute infeasibility tolerance (primal and dual) (<code>5e-5</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_reduced_tol_infeas_rel">reduced_tol_infeas_rel</code></td>
<td>
<p>reduced relative infeasibility tolerance (primal and dual) (<code>5e-5</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_reduced_tol_ktratio">reduced_tol_ktratio</code></td>
<td>
<p>reduced KT tolerance (<code>1e-4</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_equilibrate_enable">equilibrate_enable</code></td>
<td>
<p>enable data equilibration pre-scaling (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_equilibrate_max_iter">equilibrate_max_iter</code></td>
<td>
<p>maximum equilibration scaling iterations (<code>10L</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_equilibrate_min_scaling">equilibrate_min_scaling</code></td>
<td>
<p>minimum equilibration scaling allowed (<code>1e-4</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_equilibrate_max_scaling">equilibrate_max_scaling</code></td>
<td>
<p>maximum equilibration scaling allowed (<code>1e+4</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_linesearch_backtrack_step">linesearch_backtrack_step</code></td>
<td>
<p>linesearch backtracking (<code>0.8</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_min_switch_step_length">min_switch_step_length</code></td>
<td>
<p>minimum step size allowed for asymmetric cones with PrimalDual scaling (<code>1e-1</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_min_terminate_step_length">min_terminate_step_length</code></td>
<td>
<p>minimum step size allowed for symmetric cones &amp;&amp; asymmetric cones with Dual scaling (<code>1e-4</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_direct_kkt_solver">direct_kkt_solver</code></td>
<td>
<p>use a direct linear solver method (required true) (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_direct_solve_method">direct_solve_method</code></td>
<td>
<p>direct linear solver (<code>"qdldl"</code>, <code>"mkl"</code> or <code>"cholmod"</code>) (<code>"qdldl"</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_static_regularization_enable">static_regularization_enable</code></td>
<td>
<p>enable KKT static regularization (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_static_regularization_constant">static_regularization_constant</code></td>
<td>
<p>KKT static regularization parameter (<code>1e-8</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_static_regularization_proportional">static_regularization_proportional</code></td>
<td>
<p>additional regularization parameter w.r.t. the maximum abs diagonal term (<code>.Machine.double_eps^2</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_dynamic_regularization_enable">dynamic_regularization_enable</code></td>
<td>
<p>enable KKT dynamic regularization (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_dynamic_regularization_eps">dynamic_regularization_eps</code></td>
<td>
<p>KKT dynamic regularization threshold (<code>1e-13</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_dynamic_regularization_delta">dynamic_regularization_delta</code></td>
<td>
<p>KKT dynamic regularization shift (<code>2e-7</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_iterative_refinement_enable">iterative_refinement_enable</code></td>
<td>
<p>KKT solve with iterative refinement (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_iterative_refinement_reltol">iterative_refinement_reltol</code></td>
<td>
<p>iterative refinement relative tolerance (<code>1e-12</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_iterative_refinement_abstol">iterative_refinement_abstol</code></td>
<td>
<p>iterative refinement absolute tolerance (<code>1e-12</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_iterative_refinement_max_iter">iterative_refinement_max_iter</code></td>
<td>
<p>iterative refinement maximum iterations (<code>10L</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_iterative_refinement_stop_ratio">iterative_refinement_stop_ratio</code></td>
<td>
<p>iterative refinement stalling tolerance (<code>5.0</code>)</p>
</td></tr>
<tr><td><code id="clarabel_control_+3A_presolve_enable">presolve_enable</code></td>
<td>
<p>whether to enable presolvle (<code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the control parameters.
</p>

<hr>
<h2 id='clarabel-package'>Interface to Clarabel solver implemented in Rust.</h2><span id='topic+clarabel-package'></span>

<h3>Description</h3>

<p>Clarabel is a versatile interior point solver for convex programs using a new homogeneous embedding. It solves solves linear programs (LPs), quadratic programs (QPs), second-order cone programs (SOCPs), and problems with exponential and power cone constraints. For quadratic objectives, unlike interior point solvers based on the standard homogeneous self-dual embedding (HSDE) model, Clarabel handles quadratic objective without requiring any epigraphical reformulation of its objective function. It can therefore be significantly faster than other HSDE-based solvers for problems with quadratic objective functions. Infeasible problems are detected using a homogeneous embedding technique. See <a href="https://oxfordcontrol.github.io/ClarabelDocs/stable/">https://oxfordcontrol.github.io/ClarabelDocs/stable/</a>.
</p>


<h3>Author(s)</h3>

<p>Balasubramanian Narasimhan, Paul Goulart, Yuwen Chen
</p>

<hr>
<h2 id='solver_status_descriptions'>Return the solver status description as a named character vector</h2><span id='topic+solver_status_descriptions'></span>

<h3>Description</h3>

<p>Return the solver status description as a named character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solver_status_descriptions()
</code></pre>


<h3>Value</h3>

<p>a named list of solver status descriptions, in order of status codes returned by the solver
</p>


<h3>Examples</h3>

<pre><code class='language-R'>solver_status_descriptions()[2] ## for solved problem
solver_status_descriptions()[8] ## for max iterations limit reached
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
