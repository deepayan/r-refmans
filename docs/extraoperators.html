<!DOCTYPE html><html><head><title>Help for package extraoperators</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {extraoperators}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.set1'><p>Process Sets</p></a></li>
<li><a href='#%c%'><p>Chain Operator</p></a></li>
<li><a href='#%e%'><p>Element In Set Operator</p></a></li>
<li><a href='#logical all'><p>Several ways to evaluate whether all values meet logical conditions including logical range comparison helpers</p></a></li>
<li><a href='#logical indexes (which)'><p>Several ways to return an index based on logical range comparison helpers</p></a></li>
<li><a href='#logicals'><p>Several logical range comparison helpers</p></a></li>
<li><a href='#subsetting'><p>Several ways to subset based on logical range comparison helpers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Extra Binary Relational and Logical Operators</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://joshuawiley.com/extraoperators/">https://joshuawiley.com/extraoperators/</a>,
<a href="https://github.com/JWiley/extraoperators">https://github.com/JWiley/extraoperators</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JWiley/extraoperators/issues">https://github.com/JWiley/extraoperators/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Speed up common tasks, particularly logical or
  relational comparisons and routine follow up tasks such as finding the
  indices and subsetting. Inspired by mathematics, where something like:
  3 &lt; x &lt; 6 is a standard, elegant and clear way to assert that
  x is both greater than 3 and less than 6
  (see for example <a href="https://en.wikipedia.org/wiki/Relational_operator">https://en.wikipedia.org/wiki/Relational_operator</a>),
  a chaining operator is implemented. The chaining operator, %c%,
  allows multiple relational operations to be used in quotes on the right
  hand side for the same object, on the left hand side.
  The %e% operator allows something like set-builder notation 
  (see for example <a href="https://en.wikipedia.org/wiki/Set-builder_notation">https://en.wikipedia.org/wiki/Set-builder_notation</a>) 
  to be used on the right hand side.
  All operators have built in prefixes defined for all, subset, and which
  to reduce the amount of code needed for common tasks, such as return those
  values that are true.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-14 00:27:20 UTC; wileyj</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua F. Wiley <a href="https://orcid.org/0000-0002-0271-6702"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua F. Wiley &lt;jwiley.psych@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-14 01:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.set1'>Process Sets</h2><span id='topic+.set1'></span>

<h3>Description</h3>

<p>This is an internal function and not intended to be used directly.
It processes small sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.set1(x, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".set1_+3A_x">x</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id=".set1_+3A_envir">envir</code></td>
<td>
<p>An environment in which to evaluate values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the processed set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ## below is an example that should generate an (informative) error
## extraoperators:::.set1("(-Inf,x)", envir = environment())

z &lt;- max(mtcars$mpg)
extraoperators:::.set1("(-Inf,z)", envir = environment())

extraoperators:::.set1("(-Inf,30)", envir = environment())

## clean up
rm(z)
</code></pre>

<hr>
<h2 id='+25c+25'>Chain Operator</h2><span id='topic++25c+25'></span>

<h3>Description</h3>

<p>This operator allows operators on the right hand side to be
chained together. The intended use case is when you have a
single object on which you want to perform several operations.
For example, testing whether a variable is between 1 and 5 or
equals special number 9, which might be used to indicate that
someone responded to a question (i.e., its not missing per se)
but that they preferred not to answer or did not know the answer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %c% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25c+2B25_+3A_e1">e1</code></td>
<td>
<p>The values to be operated on, on the left hand side</p>
</td></tr>
<tr><td><code id="+2B25c+2B25_+3A_e2">e2</code></td>
<td>
<p>A character string (it MUST be quoted) containing all
the operators and their values to apply to 'e1'. Note that in
this character string, operators can be chained together using either
'|' or '&amp;'. Parentheses are also supported and work as expected. See
examples for more information on how this function is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'
'is.na', '!is.na', 'is.nan', and '!is.nan'. These do not need
any values supplied but they work as expected to add those logical
assessments into the chain of operators.
</p>


<h3>Value</h3>

<p>a logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## define a variable
sample_data &lt;- c(1, 3, 9, 5, NA, -9)

## suppose that we expect that values should fall in [1, 10]
## unless they are special character, -9 used for unknown / refused
sample_data %c% "( &gt;= 1 &amp; &lt;= 10 ) | == -9"

## we might expect some missing values and be OK as long as
## above conditions are met or values are missing
sample_data %c% "( &gt;= 1 &amp; &lt;= 10 ) | == -9 | is.na"

## equally we might be expecting NO missing values
## and want missing values to come up as FALSE
sample_data %c% "(( &gt;= 1 &amp; &lt;= 10 ) | == -9) &amp; !is.na"

c(1, 3, 9, 5, NA, -9) %c% "is.na &amp; (( &gt;= 1 &amp; &lt;= 10 ) | == -9)"

## clean up
rm(sample_data)
</code></pre>

<hr>
<h2 id='+25e+25'>Element In Set Operator</h2><span id='topic++25e+25'></span>

<h3>Description</h3>

<p>This operator allows use of set notation style definitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %e% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25e+2B25_+3A_e1">e1</code></td>
<td>
<p>The values to be operated on, on the left hand side</p>
</td></tr>
<tr><td><code id="+2B25e+2B25_+3A_e2">e2</code></td>
<td>
<p>A character string containing set notation style
defined ranges on the real number line. Separate sets with the
&ldquo;&amp;&rdquo; or &ldquo;|&rdquo; operator for AND or OR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c(-1, 0, 1, 9, 10, 16, 17, 20) %e% "(-Inf, 0) | [1, 9) | [10, 16] | (17, Inf]"
table(mtcars$mpg %e% "(0, 15.5) | [22.8, 40)")
table(mtcars$mpg %e% "(0, 15) | [16, 18] | [30, 50)")
c(-1, 0, 1) %e% "(-Inf, Inf) &amp; [0, 0] | [1, 1]"

z &lt;- max(mtcars$mpg)
table(mtcars$mpg %e% "(-Inf, z)")

## clean up
rm(z)
</code></pre>

<hr>
<h2 id='logical+20all'>Several ways to evaluate whether all values meet logical conditions including logical range comparison helpers</h2><span id='topic+logical+20all'></span><span id='topic++25agele+25'></span><span id='topic++25agel+25'></span><span id='topic++25agle+25'></span><span id='topic++25agl+25'></span><span id='topic++25age+25'></span><span id='topic++25ag+25'></span><span id='topic++25ale+25'></span><span id='topic++25al+25'></span><span id='topic++25ain+25'></span><span id='topic++25a+21in+25'></span><span id='topic++25anin+25'></span><span id='topic++25a+3D+3D+25'></span><span id='topic++25a+21+3D+25'></span><span id='topic++ac+'></span><span id='topic++ae+'></span><span id='topic++25agrepl+25'></span><span id='topic++25a+21grepl+25'></span>

<h3>Description</h3>

<p>Several ways to evaluate whether all values meet logical conditions including logical range comparison helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %agele% e2

e1 %agel% e2

e1 %agle% e2

e1 %agl% e2

e1 %age% e2

e1 %ag% e2

e1 %ale% e2

e1 %al% e2

e1 %ain% e2

e1 %a!in% e2

e1 %anin% e2

e1 %a==% e2

e1 %a!=% e2

e1 %ac% e2

e1 %ae% e2

e1 %agrepl% e2

e1 %a!grepl% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logical+2B20all_+3A_e1">e1</code></td>
<td>
<p>A number of vector to be evaluated</p>
</td></tr>
<tr><td><code id="logical+2B20all_+3A_e2">e2</code></td>
<td>
<p>A vector of one or two numbers used to denote the
limits for logical comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value whether all <code>e1</code> meet the logical conditions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
1:5 %agele% c(2, 4)
1:5 %agele% c(4, 2) # order does not matter uses min / max

1:5 %agel% c(2, 4)
1:5 %agel% c(4, 2) # order does not matter uses min / max

1:5 %agle% c(2, 4)
1:5 %agle% c(4, 2) # order does not matter uses min / max

1:5 %agl% c(2, 4)
1:5 %agl% c(4, 2) # order does not matter uses min / max

1:5 %age% 2
1:5 %age% 4

1:5 %ag% 2
1:5 %ag% 4

1:5 %ale% 2
1:5 %ale% 4

1:5 %al% 2
1:5 %al% 4

1:5 %ain% c(2, 99)
c("jack", "jill", "john", "jane") %ain% c("jill", "jane", "bill")

1:5 %a!in% c(2, 99)
c("jack", "jill", "john", "jane") %a!in% c("jill", "jane", "bill")

1:5 %a==% 1:5
1:5 %a==% 5:1

1:5 %a!=% 1:5
1:5 %a!=% 5:1
1:5 %a!=% c(5, 4, 1, 3, 2)
## define a variable
sample_data &lt;- c(1, 3, 9, 5, NA, -9)

## suppose that we expect that values should fall in [1, 10]
## unless they are special character, -9 used for unknown / refused
sample_data %ac% "( &gt;= 1 &amp; &lt;= 10 ) | == -9"

## we might expect some missing values and be OK as long as
## above conditions are met or values are missing
sample_data %ac% "( &gt;= 1 &amp; &lt;= 10 ) | == -9 | is.na"

## equally we might be expecting NO missing values
## and want missing values to come up as FALSE
sample_data %ac% "(( &gt;= 1 &amp; &lt;= 10 ) | == -9) &amp; !is.na"

## clean up
rm(sample_data)
## define a variable
sample_data &lt;- c(1, 3, 9, 5, -9)

sample_data %ae% "(-8, 1] | [2, 9)"
sample_data %ae% "(-Inf, Inf)"

## clean up
rm(sample_data)

c("jack", "jane", "ajay") %agrepl% "ja"
c("jack", "jill", "john", "jane", "sill", "ajay") %agrepl% "^ja"

c("jack", "jane", "ajay") %a!grepl% "ja"
c("jack", "jill", "john", "jane", "sill", "ajay") %a!grepl% "^ja"
c("jack", "jill", "john", "jane", "sill", "ajay") %a!grepl% "ja$"
</code></pre>

<hr>
<h2 id='logical+20indexes+20+28which+29'>Several ways to return an index based on logical range comparison helpers</h2><span id='topic+logical+20indexes+20+28which+29'></span><span id='topic++25+3Fgele+25'></span><span id='topic++25+3Fgel+25'></span><span id='topic++25+3Fgle+25'></span><span id='topic++25+3Fgl+25'></span><span id='topic++25+3Fge+25'></span><span id='topic++25+3Fg+25'></span><span id='topic++25+3Fle+25'></span><span id='topic++25+3Fl+25'></span><span id='topic++25+3Fin+25'></span><span id='topic++25+3F+21in+25'></span><span id='topic++25+3Fnin+25'></span><span id='topic++25+3F+3D+3D+25'></span><span id='topic++25+3F+21+3D+25'></span><span id='topic++25+3Fc+25'></span><span id='topic++25+3Fe+25'></span><span id='topic++25+3Fgrepl+25'></span><span id='topic++25+3F+21grepl+25'></span>

<h3>Description</h3>

<p>Several ways to return an index based on logical range comparison helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %?gele% e2

e1 %?gel% e2

e1 %?gle% e2

e1 %?gl% e2

e1 %?ge% e2

e1 %?g% e2

e1 %?le% e2

e1 %?l% e2

e1 %?in% e2

e1 %?!in% e2

e1 %?nin% e2

e1 %?==% e2

e1 %?!=% e2

e1 %?c% e2

e1 %?e% e2

e1 %?grepl% e2

e1 %?!grepl% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logical+2B20indexes+2B20+2B28which+2B29_+3A_e1">e1</code></td>
<td>
<p>A number of vector to be evaluated and for which the indices will be returned</p>
</td></tr>
<tr><td><code id="logical+2B20indexes+2B20+2B28which+2B29_+3A_e2">e2</code></td>
<td>
<p>A vector of one or two numbers used to denote the
limits for logical comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the indices identifying which values of <code>e1</code> meet the logical conditions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
1:5 %?gele% c(2, 4)
1:5 %?gele% c(4, 2) # order does not matter uses min / max

1:5 %?gel% c(2, 4)
1:5 %?gel% c(4, 2) # order does not matter uses min / max

1:5 %?gle% c(2, 4)
1:5 %?gle% c(4, 2) # order does not matter uses min / max

1:5 %?gl% c(2, 4)
1:5 %?gl% c(4, 2) # order does not matter uses min / max

1:5 %?ge% 2
1:5 %?ge% 4

1:5 %?g% 2
1:5 %?g% 4

1:5 %?le% 2
1:5 %?le% 4

1:5 %?l% 2
1:5 %?l% 4

1:5 %?in% c(2, 99)
c("jack", "jill", "john", "jane") %?in% c("jill", "jane", "bill")

1:5 %?!in% c(2, 99)
c("jack", "jill", "john", "jane") %?!in% c("jill", "jane", "bill")

1:5 %?nin% c(2, 99)
c("jack", "jill", "john", "jane") %snin% c("jill", "jane", "bill")

11:15 %?==% c(11, 1, 13, 15, 15)

11:15 %?!=% c(11, 1, 13, 15, 15)
## define a variable
sample_data &lt;- c(1, 3, 9, 5, NA, -9)

## suppose that we expect that values should fall in [1, 10]
## unless they are special character, -9 used for unknown / refused
sample_data %?c% "( &gt;= 1 &amp; &lt;= 10 ) | == -9"

## we might expect some missing values and be OK as long as
## above conditions are met or values are missing
sample_data %?c% "( &gt;= 1 &amp; &lt;= 10 ) | == -9 | is.na"

## equally we might be expecting NO missing values
## and want missing values to come up as FALSE
sample_data %?c% "(( &gt;= 1 &amp; &lt;= 10 ) | == -9) &amp; !is.na"

## clean up
rm(sample_data)
## define a variable
sample_data &lt;- c(1, 3, 9, 5, -9)

sample_data %?e% "(-8, 1] | [2, 9)"

## clean up
rm(sample_data)

c("jack", "jill", "john", "jane", "sill", "ajay") %?grepl% "ja"
c("jack", "jill", "john", "jane", "sill", "ajay") %?grepl% "^ja"

c("jack", "jill", "john", "jane", "sill", "ajay") %?!grepl% "ja"
c("jack", "jill", "john", "jane", "sill", "ajay") %?!grepl% "^ja"
</code></pre>

<hr>
<h2 id='logicals'>Several logical range comparison helpers</h2><span id='topic+logicals'></span><span id='topic++25gele+25'></span><span id='topic++25gel+25'></span><span id='topic++25gle+25'></span><span id='topic++25gl+25'></span><span id='topic++25g+25'></span><span id='topic++25ge+25'></span><span id='topic++25l+25'></span><span id='topic++25le+25'></span><span id='topic++25+21in+25'></span><span id='topic++25nin+25'></span><span id='topic++25flipIn+25'></span><span id='topic++25grepl+25'></span><span id='topic++25+21grepl+25'></span>

<h3>Description</h3>

<p>Several logical range comparison helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %gele% e2

e1 %gel% e2

e1 %gle% e2

e1 %gl% e2

e1 %g% e2

e1 %ge% e2

e1 %l% e2

e1 %le% e2

e1 %!in% e2

e1 %nin% e2

e1 %flipIn% e2

e1 %grepl% e2

e1 %!grepl% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logicals_+3A_e1">e1</code></td>
<td>
<p>A number of vector to be evaluated</p>
</td></tr>
<tr><td><code id="logicals_+3A_e2">e2</code></td>
<td>
<p>A vector of one or two numbers used to denote the
limits for logical comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as <code>e1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
1:5 %gele% c(2, 4)
1:5 %gele% c(4, 2) # order does not matter uses min / max

1:5 %gel% c(2, 4)
1:5 %gel% c(4, 2) # order does not matter uses min / max

1:5 %gle% c(2, 4)
1:5 %gle% c(4, 2) # order does not matter uses min / max

1:5 %gl% c(2, 4)
1:5 %gl% c(4, 2) # order does not matter uses min / max

1:5 %g% c(2)

1:5 %ge% c(2)

1:5 %l% c(2)

1:5 %le% c(2)

1:5 %!in% c(2, 99)
c("jack", "jill", "john", "jane") %!in% c("jill", "jane", "bill")

c("jack", "jill", "john", "jane", "sill", "ajay") %grepl% "ja"
c("jack", "jill", "john", "jane", "sill", "ajay") %grepl% "^ja"

c("jack", "jill", "john", "jane", "sill", "ajay") %!grepl% "ja"
c("jack", "jill", "john", "jane", "sill", "ajay") %!grepl% "^ja"
</code></pre>

<hr>
<h2 id='subsetting'>Several ways to subset based on logical range comparison helpers</h2><span id='topic+subsetting'></span><span id='topic++25sgele+25'></span><span id='topic++25sgel+25'></span><span id='topic++25sgle+25'></span><span id='topic++25sgl+25'></span><span id='topic++25sge+25'></span><span id='topic++25sg+25'></span><span id='topic++25sle+25'></span><span id='topic++25sl+25'></span><span id='topic++25sin+25'></span><span id='topic++25s+21in+25'></span><span id='topic++25snin+25'></span><span id='topic++25s+3D+3D+25'></span><span id='topic++25s+21+3D+25'></span><span id='topic++25sc+25'></span><span id='topic++25se+25'></span><span id='topic++25sgrepl+25'></span><span id='topic++25s+21grepl+25'></span>

<h3>Description</h3>

<p>Several ways to subset based on logical range comparison helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %sgele% e2

e1 %sgel% e2

e1 %sgle% e2

e1 %sgl% e2

e1 %sge% e2

e1 %sg% e2

e1 %sle% e2

e1 %sl% e2

e1 %sin% e2

e1 %s!in% e2

e1 %snin% e2

e1 %s==% e2

e1 %s!=% e2

e1 %sc% e2

e1 %se% e2

e1 %sgrepl% e2

e1 %s!grepl% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetting_+3A_e1">e1</code></td>
<td>
<p>A number of vector to be evaluated and subset</p>
</td></tr>
<tr><td><code id="subsetting_+3A_e2">e2</code></td>
<td>
<p>A vector of one or two numbers used to denote the
limits for logical comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of <code>e1</code> that meets the logical conditions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
1:5 %sgele% c(2, 4)
1:5 %sgele% c(4, 2) # order does not matter uses min / max

1:5 %sgel% c(2, 4)
1:5 %sgel% c(4, 2) # order does not matter uses min / max

1:5 %sgle% c(2, 4)
1:5 %sgle% c(4, 2) # order does not matter uses min / max

1:5 %sgl% c(2, 4)
1:5 %sgl% c(4, 2) # order does not matter uses min / max

1:5 %sge% 2
1:5 %sge% 4

1:5 %sg% 2
1:5 %sg% 4

1:5 %sle% 2
1:5 %sle% 4

1:5 %sl% 2
1:5 %sl% 4

1:5 %sin% c(2, 99)
c("jack", "jill", "john", "jane") %sin% c("jill", "jane", "bill")

1:5 %s!in% c(2, 99)
c("jack", "jill", "john", "jane") %s!in% c("jill", "jane", "bill")

1:5 %s==% 1:5
1:5 %s==% c(1:4, 1)

1:5 %s!=% 1:5
1:5 %s!=% c(1:4, 1)
## define a variable
sample_data &lt;- c(1, 3, 9, 5, NA, -9)

## suppose that we expect that values should fall in [1, 10]
## unless they are special character, -9 used for unknown / refused
sample_data %sc% "( &gt;= 1 &amp; &lt;= 10 ) | == -9"

## we might expect some missing values and be OK as long as
## above conditions are met or values are missing
sample_data %sc% "( &gt;= 1 &amp; &lt;= 10 ) | == -9 | is.na"

## equally we might be expecting NO missing values
## and want missing values to come up as FALSE
sample_data %sc% "(( &gt;= 1 &amp; &lt;= 10 ) | == -9) &amp; !is.na"

## clean up
rm(sample_data)
## define a variable
sample_data &lt;- c(1, 3, 9, 5, -9)

sample_data %se% "(-8, 1] | [2, 9)"

## clean up
rm(sample_data)

c("jack", "jill", "john", "jane", "sill", "ajay") %sgrepl% "ja"
c("jack", "jill", "john", "jane", "sill", "ajay") %sgrepl% "^ja"

c("jack", "jill", "john", "jane", "sill", "ajay") %s!grepl% "ja"
c("jack", "jill", "john", "jane", "sill", "ajay") %s!grepl% "^ja"
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
