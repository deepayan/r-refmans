<!DOCTYPE html><html><head><title>Help for package mosaicCalc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mosaicCalc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Aquaman'><p>Box office from the movie Aquaman</p></a></li>
<li><a href='#argM'><p>Find local extreme points</p></a></li>
<li><a href='#basis_sets'><p>Basis sets for for function approximation</p></a></li>
<li><a href='#Blob1'><p>Shapes used in moment of inertia calculations</p></a></li>
<li><a href='#Body_fat'><p>Measurements of body-fat percentage and related quantities</p></a></li>
<li><a href='#bounds'><p>Specify a domain over which a function is to be graphed</p></a></li>
<li><a href='#box_set'><p>Evenly spaced samples across a one- or two-dim domain</p></a></li>
<li><a href='#Boyle'><p>Robert Boyle's pressure vs volume measurements</p></a></li>
<li><a href='#Cello'><p>Short recordings of a cello and a violin</p></a></li>
<li><a href='#Chirps'><p>Cricket chirp rate and temperature</p></a></li>
<li><a href='#contour_plot'><p>Contour plots of functions of two variables</p></a></li>
<li><a href='#Covid_US'><p>COVID data from the first half of the pandemic</p></a></li>
<li><a href='#CPUs'><p>Characteristics of computer central processing unit chips over the decades</p></a></li>
<li><a href='#create_num_antiD'><p>Create a numerical anti-derivative function which can be</p>
called with one or many values of the w.r.t. input</a></li>
<li><a href='#D'><p>Derivative and Anti-derivative operators</p></a></li>
<li><a href='#df2matrix'><p>Construct a model matrix from data as if by hand</p></a></li>
<li><a href='#EbolaAll'><p>Case numbers in an Ebola outbreak in 2014</p></a></li>
<li><a href='#Effective_oxygen'><p>Effective amount of oxygen available at different altitudes</p></a></li>
<li><a href='#Engines'><p>Characteristics of various internal combustion engines</p></a></li>
<li><a href='#first_three_args'><p>Handle the first three arguments of graphics functions</p></a></li>
<li><a href='#fitSpline'><p>Find zeros of a function</p></a></li>
<li><a href='#Fly_ball'><p>Trajectory of a fly ball in baseball</p></a></li>
<li><a href='#gradient_plot'><p>Plot a vector field</p></a></li>
<li><a href='#HDD_Minneapolis'><p>Heating degree days in Minneapolis, Minnesota, USA</p></a></li>
<li><a href='#Home_utilities'><p>Gas  and electricity usage by a home in St. Paul, MN</p></a></li>
<li><a href='#inequality_constraint'><p>Graphics for constraints</p></a></li>
<li><a href='#infer_RHS'><p>Utilities for formulas and graphics arguments</p></a></li>
<li><a href='#inscribed_circle'><p>Create a data frame for a circle marking the curvature of a function.</p></a></li>
<li><a href='#Integrate'><p>Integrate a function</p></a></li>
<li><a href='#integrateODE'><p>Integrate ordinary differential equations</p></a></li>
<li><a href='#is_in_domain'><p>check whether a value is in a domain</p></a></li>
<li><a href='#Iterate'><p>Iterate a function on an initial condition</p></a></li>
<li><a href='#Kepler'><p>Kepler's calculation of the position of Mars</p></a></li>
<li><a href='#M2014F'><p>Mortality versus age for females in the US in 2014</p></a></li>
<li><a href='#makeODE'><p>Create a dynamics object for use in <code>integrateODE()</code> and the ODE graphics</p></a></li>
<li><a href='#numD'><p>Numerical Derivatives</p></a></li>
<li><a href='#PE_fun1'><p>Potential energy functions used as examples in <em>MOSAIC Calculus</em>.</p></a></li>
<li><a href='#Picket'><p>Creates a &quot;picket fence&quot; of points for illustrating numerical integration</p></a></li>
<li><a href='#Planet_solar'><p>Solar irradiance of the planets</p></a></li>
<li><a href='#Planets'><p>NASA data on planets</p></a></li>
<li><a href='#plotFun'><p>Plot functions of one and two variables using lattice system</p></a></li>
<li><a href='#qspliner'><p>Create a quadratic spline (inefficiently)</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rfun'><p>Generate a &quot;natural looking&quot; function of one or multiple variables</p></a></li>
<li><a href='#RI_tide'><p>Tide levels from the US NOAA</p></a></li>
<li><a href='#Robot_stations'><p>Waypoints on the path of a fictitious robot</p></a></li>
<li><a href='#Runners'><p>Running times</p></a></li>
<li><a href='#simpleYacasIntegrate'><p>Interface to integration using Ryacas</p></a></li>
<li><a href='#simplify_fun'><p>Turn a 1-line function into an inline formula</p></a></li>
<li><a href='#slice_plot'><p>Plot a function of a single variable</p></a></li>
<li><a href='#smoother'><p>Create a smoothing function approximating a cloud of points</p></a></li>
<li><a href='#SSA_2007'><p>US Mortality table from 2007</p></a></li>
<li><a href='#streamlines'><p>Dynamical systems calculations and graphics</p></a></li>
<li><a href='#surface_plot'><p>Make an interactive plotly plot of a function of two variables</p></a></li>
<li><a href='#symbolicD'><p>Symbolic Derivatives</p></a></li>
<li><a href='#traj_plot'><p>Plots a trajectory</p></a></li>
<li><a href='#traj_plot_3D'><p>Simple 3D plot of a trajectory</p></a></li>
<li><a href='#UK_GDP'><p>Gross Domestic Product of the United Kingdom over a millenium</p></a></li>
<li><a href='#unbound'><p>Identifying unbound inputs to a function</p></a></li>
<li><a href='#US_income'><p>Income distribution data from the US in 2009</p></a></li>
<li><a href='#vector_arg'><p>convert a function with separate arguments</p>
into one with a single vector argument
For use with optim.</a></li>
<li><a href='#vectors'><p>Utilities for vector calculations</p></a></li>
<li><a href='#Vowel_ee'><p>Recordings of vowel sounds</p></a></li>
<li><a href='#Zeros'><p>Finds zeros of a function within a specified domain</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R-Language Based Calculus Operations for Teaching</td>
</tr>
<tr>
<td>Description:</td>
<td>Software to support the introductory *MOSAIC Calculus* 
    textbook <a href="https://www.mosaic-web.org/MOSAIC-Calculus/">https://www.mosaic-web.org/MOSAIC-Calculus/</a>),
    one of many data- and modeling-oriented educational resources developed by 
    Project MOSAIC (<a href="https://www.mosaic-web.org/">https://www.mosaic-web.org/</a>). Provides symbolic and
    numerical differentiation and integration, as well as support for 
    applied linear algebra (for data science), and differential equations/dynamics.
    Includes grammar-of-graphics-based functions for drawing vector fields, trajectories, etc.
    The software is suitable for general use, but intended mainly for teaching calculus.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), mosaic, mosaicCore (&ge; 0.9.2),</td>
</tr>
<tr>
<td>Imports:</td>
<td>cubature, Deriv, dplyr, ggformula, ggplot2, glue, grDevices,
MASS, Matrix, metR (&ge; 0.11.0), orthopolynom, plotly, rlang,
Ryacas, sp, stats, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, palmerpenguins, rmarkdown, mosaicData</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel T. Kaplan &lt;kaplan@macalester.edu&gt;, Randall Pruim &lt;rpruim@calvin.edu&gt;, Nicholas J. Horton &lt;nhorton@amherst.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Kaplan &lt;kaplan@macalester.edu&gt;</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ProjectMOSAIC/mosaicCalc">https://github.com/ProjectMOSAIC/mosaicCalc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ProjectMOSAIC/mosaicCalc/issues">https://github.com/ProjectMOSAIC/mosaicCalc/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-16 00:51:14 UTC; kaplan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-16 07:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='Aquaman'>Box office from the movie Aquaman</h2><span id='topic+Aquaman'></span>

<h3>Description</h3>

<p>Earnings each weekend after the release of the movie <em>Aquaman</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aquaman
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and variables <code>Date</code>, <code>Earnings</code> (in USD), and the count of the <code>Weekend</code>.
</p>


<h3>Source</h3>

<p>Beth Schaubroeck at USAFA.
Scraped from <a href="https://www.boxofficemojo.com/release/rl3108800001/weekend/?ref_=bo_rl_tab">https://www.boxofficemojo.com/release/rl3108800001/weekend/?ref_=bo_rl_tab</a>.
</p>

<hr>
<h2 id='argM'>Find local extreme points</h2><span id='topic+argM'></span>

<h3>Description</h3>

<p>Find local extreme points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argM(tilde, domain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="argM_+3A_tilde">tilde</code></td>
<td>
<p>specification of a function as in makeFun()</p>
</td></tr>
<tr><td><code id="argM_+3A_domain">domain</code></td>
<td>
<p>a domain to search in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>End-points of the domain may be included in the output.
</p>


<h3>Value</h3>

<p>A data frame with values for x, the function
output at those values of x, and the concavity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>argM(x^2 ~ x, domain(x=-1:1))

</code></pre>

<hr>
<h2 id='basis_sets'>Basis sets for for function approximation</h2><span id='topic+basis_sets'></span><span id='topic+legendre_set'></span><span id='topic+legendre_M'></span><span id='topic+ns_set'></span><span id='topic+fourier_M'></span><span id='topic+ns_M'></span><span id='topic+fourier_set'></span>

<h3>Description</h3>

<p>These functions generate the mathematical functions for three
different basis sets: Fourier (sines), Legendre (orthogonal polynomials),
and Splines (low-order smooth approximation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendre_set(df = 3, left = -1, right = 1)

legendre_M(x, df, left = -1, right = 1)

ns_set(df = 3, left = -1, right = 1)

fourier_M(x, n, fperiod = NULL)

ns_M(x, df = NULL, knots = NULL, intercept = FALSE, Boundary.knots = range(x))

fourier_set(df, left = -1, right = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_sets_+3A_df">df</code></td>
<td>
<p>number of basis functions to construct</p>
</td></tr>
<tr><td><code id="basis_sets_+3A_left">left</code></td>
<td>
<p>number giving left-hand boundary of the interval</p>
</td></tr>
<tr><td><code id="basis_sets_+3A_right">right</code></td>
<td>
<p>number giving right-hand boundary of the interval</p>
</td></tr>
<tr><td><code id="basis_sets_+3A_x">x</code></td>
<td>
<p>inputs at which to evaluate the functions (in the <code style="white-space: pre;">&#8288;_M&#8288;</code> functions)</p>
</td></tr>
<tr><td><code id="basis_sets_+3A_n">n</code></td>
<td>
<p>number of fourier components to generate</p>
</td></tr>
<tr><td><code id="basis_sets_+3A_fperiod">fperiod</code></td>
<td>
<p>number giving the fundamental period length for the Fourier basis</p>
</td></tr>
<tr><td><code id="basis_sets_+3A_knots">knots</code></td>
<td>
<p>breakpoints that define the spline.  The default is no
knots; together with the natural boundary conditions this results in
a basis for linear regression on <code>x</code>.  Typical values are the
mean or median for one knot, quantiles for more knots.  See also
<code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="basis_sets_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, an intercept is included in the
basis; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="basis_sets_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to impose the natural
boundary conditions and anchor the B-spline basis (default the range
of the data).  If both <code>knots</code> and <code>Boundary.knots</code> are
supplied, the basis parameters do not depend on <code>x</code>. Data can
extend beyond <code>Boundary.knots</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each basis, there are two different forms for the
generating functions. Names ending in <code style="white-space: pre;">&#8288;_set&#8288;</code> create a set of functions with
arguments <code>x</code> and <code>n</code>, where integer <code>n</code> provides an index into the set.
The same names with a <code style="white-space: pre;">&#8288;_M&#8288;</code> suffix produce a model matrix
corresponding to a specified set of x values. These are useful
with <code>lm()</code> and similar model-building functions in the same way that
<code>poly()</code> and <code>ns()</code> are useful. (<code>ns_M()</code> is just an alias for <code>splines::ns()</code>.) Like
<code>poly()</code> and <code>ns()</code>, the <code style="white-space: pre;">&#8288;_M&#8288;</code> suffix functions do <em>NOT</em> include an
intercept column.
</p>


<h3>Value</h3>

<p>The <code style="white-space: pre;">&#8288;_M&#8288;</code> functions return a model matrix. The <code style="white-space: pre;">&#8288;_set&#8288;</code> functions
return a function with arguments <code>x</code> and <code>n</code>. The integer <code>n</code> specifies
which function to use, while <code>x</code> is the set of values at which to evaluate
that function.
</p>

<hr>
<h2 id='Blob1'>Shapes used in moment of inertia calculations</h2><span id='topic+Blob1'></span><span id='topic+Blob2'></span><span id='topic+Blob3'></span><span id='topic+Blob4'></span>

<h3>Description</h3>

<p>These are used in a handful of examples in the <em>MOSAIC Calculus</em> text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Blob1

Blob2

Blob3

Blob4
</code></pre>


<h3>Format</h3>

<p>Data frames with coordinates <code>x</code> and <code>y</code> as columns
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 200 rows and 2 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 200 rows and 2 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 200 rows and 2 columns.
</p>

<hr>
<h2 id='Body_fat'>Measurements of body-fat percentage and related quantities</h2><span id='topic+Body_fat'></span>

<h3>Description</h3>

<p>It's hard to measure body fat. This data frame records a direct
measure of body-fat percentage along with easier-to-make measurements.
The question of interest in collecting the data is whether there
is a way to estimate body-fat percentage from the easier-to-measure
quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Body_fat
</code></pre>


<h3>Format</h3>

<p>An object of class <code>spec_tbl_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 252 rows and 14 columns.
</p>

<hr>
<h2 id='bounds'>Specify a domain over which a function is to be graphed</h2><span id='topic+bounds'></span><span id='topic+domain'></span>

<h3>Description</h3>

<p>domain() is used with slice_plot(), contour_plot(), or interactive_plot()
to describe the plotting region. There is a standard syntax for
domain() (see the first example) but there are also shortcuts.
In the shorthand syntaxes, you can but don't have to specify the name of
the input. If it's not specified, the plotting programs will try
to do something sensible. But better to specify the names explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds(...)

domain(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounds_+3A_...">...</code></td>
<td>
<p>One or more expression of the form <code>x = -5:5</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The colon operator is masked so that, for instance,
<code>x = 0.5:1.3</code> literally means &quot;0.5 to 1.3&quot;, and not just 0.5 as the
base colon operator would give.
</p>


<h3>Value</h3>

<p>a list with one component for each element in ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
contour_plot(x / y ~ x + y, bounds(x=-5:5, y=1:4))
slice_plot(x^2 ~ x, bounds(x = 2.5:4.2)) # overrides colon operator
slice_plot(x^2 ~ x, bounds(x = c(2.5, 4.2)))
slice_plot(x^2 ~ x, bounds(x = 1 %pm% 0.5))

## End(Not run)

</code></pre>

<hr>
<h2 id='box_set'>Evenly spaced samples across a one- or two-dim domain</h2><span id='topic+box_set'></span>

<h3>Description</h3>

<p>This function breaks up a domain in 1- or 2- dimensions into evenly
spaced samples. It returns a data frame of the position of the samples,
each of which can be considered to correspond to a Riemann bin
for the purposes of integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_set(tilde = NULL, domain, n = 10, sum = FALSE, dx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box_set_+3A_tilde">tilde</code></td>
<td>
<p>A tilde expression specifying the function to be evaluated on the domain.</p>
</td></tr>
<tr><td><code id="box_set_+3A_domain">domain</code></td>
<td>
<p>Either a one- or two-dimensional domain in the same format
as for <code>slice_plot()</code> or <code>contour_plot()</code>, or a data frame with two columns
specifying the coordinates of a polygon defining the area.</p>
</td></tr>
<tr><td><code id="box_set_+3A_n">n</code></td>
<td>
<p>the number of divisions along each of the x- and y-directions. Can
be a vector of length 2 giving different numbers for the x and for the y directions.</p>
</td></tr>
<tr><td><code id="box_set_+3A_sum">sum</code></td>
<td>
<p>If <code>TRUE</code> carry out the integral and return the numerical result.</p>
</td></tr>
<tr><td><code id="box_set_+3A_dx">dx</code></td>
<td>
<p>An alternative way of specifying the box size directly. Same
for all dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a data frame listing the location of the samples,
the <code>.output.</code> value of the given function at those samples, the spatial
extent of the samples (that is, dx for one-dimension or dx and dy for two dimensions. There
is also a <code>dA</code> giving the dx or dx*dy depending on the dimension). If <code>sum=TRUE</code>,
then returns the sum of <code>.output * dA</code>, that is, the estimate of the integral of
the function over the domain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>box_set(x*y ~ x &amp; y, domain(x=0:1, y=0:1), n = 4)
# approximation to the variance of a uniform [0,1] distribution
box_set((x-.5)^2 ~ x, domain(x=0:1), n=100, sum=TRUE)
# a polygon
poly &lt;- tibble(x = c(1:9, 8:1), y = c(1, 2*(5:3), 2, -1, 17, 9, 8, 2:9))
boxes &lt;- box_set(1 ~ x &amp; y, poly, dx = 1)
gf_polygon(y ~ x, data = poly, color="blue", fill="blue", alpha=0.2) %&gt;%
  gf_rect((y - dy/3) + (y + dy/3) ~ (x - dx/3) + (x + dx/3),
  data = boxes)
# area inside polygon
box_set(1 ~ x &amp; y, poly, n=100)
</code></pre>

<hr>
<h2 id='Boyle'>Robert Boyle's pressure vs volume measurements</h2><span id='topic+Boyle'></span>

<h3>Description</h3>

<p>Pressure versus volume of air at a constant temperature as collected by Robert Boyle. Units are arbitrary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Boyle
</code></pre>


<h3>Format</h3>

<p>A data frame with 7 rows and numerical variables <code>pressure</code> and <code>volume</code>.
</p>


<h3>Details</h3>

<p>Robert Boyle (1627-1691) was a founder of modern chemistry
and the scientific method in general. As any chemistry student already knows,
Boyle sought to understand the properties of gasses.
His results are summarized in <em>Boyle's Law</em>.
The data frame <code>Boyle</code> contains two variables from one of Boyle's
experiments as reported in his lab notebook: pressure in a bag of
air and volume of the bag. The units of pressure are mmHg and the units of
volume are cubic inches.
</p>


<h3>Source</h3>

<p>Boyle's notebooks are preserved at the Royal Society in London. The data in the <code>Boyle</code> data frame have been copied from <code style="white-space: pre;">&#8288;https://chem.libretexts.org/Courses/University_of_California_Davis/UCD_Chem_002A/UCD_Chem_2A/Text/Unit_III%3A_Physical_Properties_of_Gases/06.03_Relationships_among_Pressure%2C_Temperature%2C_Volume%2C_and_Amount&#8288;</code>
</p>

<hr>
<h2 id='Cello'>Short recordings of a cello and a violin</h2><span id='topic+Cello'></span><span id='topic+Cello_seg'></span><span id='topic+Violin'></span><span id='topic+Violin_seg'></span>

<h3>Description</h3>

<p>Only one note is involved.
</p>

<ul>
<li> <p><code>Cello</code>: a complete note
</p>
</li>
<li> <p><code>Violin</code>: a complete note
</p>
</li>
<li> <p><code>Cello_seg</code>: a brief snipet of sound after the initial transient
</p>
</li>
<li> <p><code>Violin_seg</code>: as in <code>Cello_seg</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>Cello

Cello_seg

Violin

Violin_seg
</code></pre>


<h3>Format</h3>

<p>Data frames (for convenience) with many rows and these variables:
</p>

<ul>
<li> <p><code>y</code> the amplitude of the sound wave (arbitrary units)
</p>
</li>
<li> <p><code>t</code> the time of the sample in seconds.
</p>
</li></ul>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 3616 rows and 2 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 43776 rows and 2 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 3638 rows and 2 columns.
</p>

<hr>
<h2 id='Chirps'>Cricket chirp rate and temperature</h2><span id='topic+Chirps'></span>

<h3>Description</h3>

<p>The rate at which crickets chirp is related to the ambient temperature. These data
are motivated and described at <a href="https://www.globe.gov/explore-science/scientists-blog/archived-posts/sciblog/index.html_p=45.html">https://www.globe.gov/explore-science/scientists-blog/archived-posts/sciblog/index.html_p=45.html</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Chirps)
</code></pre>


<h3>Format</h3>

<p>A data frame with 55 rows
</p>

<ul>
<li> <p><code>date</code> Which year the estimate is for.
</p>
</li>
<li> <p><code>time</code> in 24-hour format
</p>
</li>
<li> <p><code>chirps</code> the number of chirps per 15 seconds
</p>
</li>
<li> <p><code>temperature</code> in degrees F
</p>
</li></ul>


<hr>
<h2 id='contour_plot'>Contour plots of functions of two variables</h2><span id='topic+contour_plot'></span>

<h3>Description</h3>

<p>Creates a ggplot2-compatible contour plot of a function
of two variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contour_plot(
  ...,
  npts = 100,
  labels = TRUE,
  filled = TRUE,
  contours_at = NULL,
  n_contours = 10,
  n_fill = 50,
  alpha = 1,
  fill_alpha = 0.1,
  label_alpha = 1,
  label_placement = 0.5,
  contour_color = "blue",
  label_color = contour_color,
  skip = 1,
  guide = FALSE,
  guide_title = "output",
  color_scale = scale_color_viridis_c(),
  fill_scale = scale_fill_viridis_d()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour_plot_+3A_...">...</code></td>
<td>
<p>Canonical first &quot;three&quot; arguments: <code style="white-space: pre;">&#8288;[Previous layer]&#8288;</code>, tilde expression, <a href="#topic+domain">domain</a></p>
</td></tr>
<tr><td><code id="contour_plot_+3A_npts">npts</code></td>
<td>
<p>Integer number of points on each axis at which to evaluate the function</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_labels">labels</code></td>
<td>
<p>Logical flag: label the contours</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_filled">filled</code></td>
<td>
<p>Logical flag: fill between the contours</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_contours_at">contours_at</code></td>
<td>
<p>Vector of numbers. Contours will be drawn
at these levels of the output.</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_n_contours">n_contours</code></td>
<td>
<p>hint at number of contours to show</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_n_fill">n_fill</code></td>
<td>
<p>Integer number of points for calculating fill</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_alpha">alpha</code></td>
<td>
<p>Transparency of contours in <code style="white-space: pre;">&#8288;[0-1]&#8288;</code></p>
</td></tr>
<tr><td><code id="contour_plot_+3A_fill_alpha">fill_alpha</code></td>
<td>
<p>Transparency of fill</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_label_alpha">label_alpha</code></td>
<td>
<p>Likewise, for contour labels</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_label_placement">label_placement</code></td>
<td>
<p>A number, between 0 and 1, suggesting where to place
the contour labels. Default: 0.5. This can be useful when there are two contour layers in one plaot.</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_contour_color">contour_color</code></td>
<td>
<p>Set to a string, e.g. <code>"blue"</code> for contours
to be drawn in a fixed color</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_label_color">label_color</code></td>
<td>
<p>Defaults to <code>contour_color</code>. Can be set to a</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_skip">skip</code></td>
<td>
<p>Small integer. Skip this many contours between labeled contours</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_guide">guide</code></td>
<td>
<p>Logical flag, whether to show a color guide.</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_guide_title">guide_title</code></td>
<td>
<p>Character string  for title of guide (if any)</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_color_scale">color_scale</code></td>
<td>
<p>See ggplot2 color scales.</p>
</td></tr>
<tr><td><code id="contour_plot_+3A_fill_scale">fill_scale</code></td>
<td>
<p>See ggplot2 fill scales</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 graphics layers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
contour_plot(sin(0.2*x*y) ~ x &amp; y, domain(x=-10.3:4.5, y=2:7.5))
contour_plot(x + y ~ x &amp; y)
contour_plot(sin(0.2*x*y)) # but better to use tilde expression

## End(Not run)

</code></pre>

<hr>
<h2 id='Covid_US'>COVID data from the first half of the pandemic</h2><span id='topic+Covid_US'></span>

<h3>Description</h3>

<p>For documentation, see <code style="white-space: pre;">&#8288;https://covid19datahub.io/articles/doc/data.html&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Covid_US
</code></pre>


<h3>Format</h3>

<p>An object of class <code>grouped_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 575 rows and 36 columns.
</p>


<h3>Details</h3>

<p>See Guidotti, E., Ardia, D., (2020), &quot;COVID-19 Data Hub&quot;, Journal
of Open Source Software 5(51):2376, doi: 10.21105/joss.02376.
</p>

<hr>
<h2 id='CPUs'>Characteristics of computer central processing unit chips over the decades</h2><span id='topic+CPUs'></span>

<h3>Description</h3>

<p>Since single-chip central processing units were introduced in the early 1970s,
performance has increased exponentially. Around 1965, Gorden E. Moore, a co-founder
of the integrated circuit giant Intel, postulated that capacity of chips, measured as
the number of transistors, doubles approximately every two years. Known as Moore's Law, this
pattern has held true for decades.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CPUs)
</code></pre>


<h3>Format</h3>

<p>A data frame with 128 cases, each a computer CPU.
</p>

<ul>
<li> <p><code>processor</code> Model name/number of the processor
</p>
</li>
<li> <p><code>transistors</code> Number of transistors
</p>
</li>
<li> <p><code>year</code> Year of market introduction of the CPU
</p>
</li>
<li> <p><code>designer</code> The company that introduced the CPU
</p>
</li>
<li> <p><code>process</code> The width of circuit elements, in nm.
</p>
</li>
<li> <p><code>area</code> Area of the chip in mm-squared.
</p>
</li>
<li> <p><code>density</code> The number of transistors per unit area, simply <code>transistors/area</code>.
</p>
</li></ul>



<h3>Source</h3>

<p>Dr. Joe Eichholz
</p>

<hr>
<h2 id='create_num_antiD'>Create a numerical anti-derivative function which can be
called with one or many values of the w.r.t. input</h2><span id='topic+create_num_antiD'></span>

<h3>Description</h3>

<p>This will typically be called directly from <code>antiD()</code> when an
integral can't be handled symbolically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_num_antiD(tilde, ..., lower = NULL, .tol = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_num_antiD_+3A_tilde">tilde</code></td>
<td>
<p>Tilde expression for the function to be anti-differentiated.
Right-hand side will be the w.r.t. variable</p>
</td></tr>
<tr><td><code id="create_num_antiD_+3A_...">...</code></td>
<td>
<p>arguments and parameters to the function described by <code>tilde</code></p>
</td></tr>
<tr><td><code id="create_num_antiD_+3A_lower">lower</code></td>
<td>
<p>Optional lower bound of integration. Useful to avoid domain
problems with the function being integrated, but not generally needed.</p>
</td></tr>
<tr><td><code id="create_num_antiD_+3A_.tol">.tol</code></td>
<td>
<p>Numerical tolerance for the integration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function with the w.r.t. variable as the first argument. The function
is a wrapper around numerical integration routines.
</p>

<hr>
<h2 id='D'>Derivative and Anti-derivative operators</h2><span id='topic+D'></span><span id='topic+antiD'></span>

<h3>Description</h3>

<p>Operators for computing derivatives and anti-derivatives as
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D(tilde, ...)

antiD(tilde, ..., lower.bound = 0, force.numeric = FALSE, .tol = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_+3A_tilde">tilde</code></td>
<td>
<p>A tilde expression. The right side of a formula specifies
the variable(s) with which to
carry out the integration or differentiation.  On the left side should be
an expression or a function that returns a numerical vector
of the same length as its argument.
The expression can contain unbound variables.  Functions
will be differentiated as if the formula <code>f(x) ~ x</code> were specified
but with <code>x</code> replaced by the first argument of <code>f</code>.</p>
</td></tr>
<tr><td><code id="D_+3A_...">...</code></td>
<td>
<p>Default values to be given to unbound variables in the expression <code>expr</code>.
See examples.#'  Note that in creating anti-derivative functions,
default values of &quot;from&quot; and &quot;to&quot; can be assigned.  They are to be written with
the name of the variable as a prefix, e.g. <code>y.from</code>.</p>
</td></tr>
<tr><td><code id="D_+3A_lower.bound">lower.bound</code></td>
<td>
<p>for numerical integration only, the lower bound used</p>
</td></tr>
<tr><td><code id="D_+3A_force.numeric">force.numeric</code></td>
<td>
<p>If <code>TRUE</code>, a numerical integral is performed even when a
symbolic integral is available.</p>
</td></tr>
<tr><td><code id="D_+3A_.tol">.tol</code></td>
<td>
<p>Tolerance for numerical integration. Most users do not need this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>D()</code> attempts to find a symbolic derivative for simple expressions, but
will provide a function that is a numerical derivative if the attempt at
symbolic differentiation is unsuccessful.  The symbolic derivative can be of
any order (although the expression may become unmanageably complex).  The
numerical derivative is limited to first or second-order partial derivatives
(including mixed partials).
<code>antiD()</code> will attempt simple symbolic integration but if it fails
it will return a numerically-based anti-derivative.
</p>
<p><code>antiD()</code> returns a function with the same arguments as the
expression passed to it.  The returned function is the anti-derivative
of the expression, e.g., <code>antiD(f(x)~x) -&gt; F(x)</code>.
To calculate the integral of <code>f(x)</code>, use <code>F(to) - F(from)</code>.
</p>


<h3>Value</h3>

<p>For derivatives, the return value is a function of the variable(s)
of differentiation, as well as any other symbols used in the expression.  Thus,
<code>D(A*x^2 + B*y ~ x + y)</code> will compute the mixed partial with respect to x
then y (that is, <code class="reqn">\frac{d^2 f}{dy\;dx}</code>).  The returned value will be a function of x and y,
as well as A and B.  In evaluating the returned function, it's best to use the
named form of arguments, to ensure the order is correct.
</p>
<p>a function of the same arguments as the original expression with a
constant of integration set to zero by default, named &quot;C&quot;, &quot;D&quot;, ... depending on the first
such letter not otherwise in the argument list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D(sin(t) ~ t)
D(A*sin(t) ~ t )
D(A*sin(2*pi*t/P) ~ t, A=2, P=10) # default values for parameters.
f &lt;- D(A*x^3 ~ x + x, A=1) # 2nd order partial -- note, it's a function of x
f(x=2)
f(x=2,A=10) # override default value of parameter A
g &lt;- D(f(x=t, A=1)^2 ~ t)  # note: it's a function of t
g(t=1)
gg &lt;- D(f(x=t, A=B)^2 ~ t, B=10)  # note: it's a function of t and B
gg(t=1)
gg(t=1, B=100)
f &lt;- makeFun(x^2~x)
D(f(cos(z))~z) #will look in user functions also
antiD( a*x^2 ~ x, a = 3)
G &lt;- antiD( A/x~x ) # there will be an unbound parameter in G()
G(2, A=1) # Need to bound parameter. G(2) will produce an error.
F &lt;- antiD( A*exp(-k*t^2 ) ~ t, A=1, k=0.1)
F(t=Inf)
one = makeFun(1 ~ x)
by.x = antiD(one(x) ~ x)
by.xy = antiD(by.x(sqrt(1-y^2)) ~ y)
4 * by.xy(y = 1) # area of quarter circle
</code></pre>

<hr>
<h2 id='df2matrix'>Construct a model matrix from data as if by hand</h2><span id='topic+df2matrix'></span>

<h3>Description</h3>

<p>The <em>MOSAIC Calculus</em> course includes a block on linear algebra.
As part of this block, we want to cover creating model matrices and evaluating
the model constructed from them. One way to do this is to introduce
<code>lm()</code> and the domain specific language for specifying model terms. However,
that introduces oddities. For instance, <code>lm(mpg ~ hp + hp^2, data = mtcars)</code> does
NOT add the quadratic term to the model matrix. Also, <code>lm()</code> doesn't produce
a residual or the model vector (ahem ... the fitted values) in the form of vectors.
That's fine if you're teaching statistical modeling, but in the <em>MOSAIC Calculus</em>
linear algebra block we are not teaching statistics, but the mathematical
pre-requisites to understanding statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df2matrix(..., data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df2matrix_+3A_...">...</code></td>
<td>
<p>Expressions, written in terms of the variable names in the data frame,
that are to be collected into the model matrix.</p>
</td></tr>
<tr><td><code id="df2matrix_+3A_data">data</code></td>
<td>
<p>The data frame from which to which the variable names will be bound.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifically for <em>MOSAIC Calculus</em>, we have added this <code>df2matrix()</code> function.
It serves much the same purpose as <code>cbind()</code>, that is, collecting vectors into a
matrix. But is has two additional features:
</p>

<ol>
<li><p> It has a <code style="white-space: pre;">&#8288;data=&#8288;</code> argument so that it can refer to a data frame.
</p>
</li>
<li><p> It names the columns of the matrix with the code that was used to create
each column.
</p>
</li></ol>

<p>The consequence of (2) is that the <code>x</code> vector produced by <code>qr.solve()</code> will have the
same names as the matrix. That helps in interpreting <code>x</code>. But those names
can also be used by <code>makeFun()</code> to generate a function from <code>x</code>.
</p>
<p><code>1</code> is a good form in which to write the intercept term.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- df2matrix(1, disp, log(hp), sin(cyl)*sqrt(hp), data = mtcars)
b &lt;- df2matrix(mpg, data = mtcars)
x &lt;- qr.solve(A, b)
f &lt;- makeFun(x)
f(hp=3, disp=2, cyl=4)

</code></pre>

<hr>
<h2 id='EbolaAll'>Case numbers in an Ebola outbreak in 2014</h2><span id='topic+EbolaAll'></span><span id='topic+EbolaGuinea'></span>

<h3>Description</h3>

<p>In December 2013, an 18-month-old boy from a village in Guinea suffered fatal diarrhea.  Over the next months a broader outbreak was discovered, and in mid-March 2014, the Pasteur Institute in France confirmed the illness as Ebola-Virus Disease caused by the Zaire ebolavirus.
Although the outbreak was first recognized in Guinea,
it eventually encompassed Liberia and Sierra Leone
as well.  By July 2014, the outbreak spread to the
capitals of all three countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EbolaAll

EbolaGuinea
</code></pre>


<h3>Format</h3>

<p>A dataframe with 182 rows. Each row is a daily report
during a period of over 18 months during 2014 and 2015.
Each report gives the number of new cases and disease-related
deaths since the last report in each or three countries:
Sierra Leon, Liberia, and Guinea. These values have been calculated
from the raw, cumulative data. The data have been scrubbed to remove
obvious errors.
</p>

<ul>
<li> <p><code>Date</code>: Date when the World Health Organization issued the report
</p>
</li>
<li> <p><code>Gcases</code>:  Number of new cases in Guinea
</p>
</li>
<li> <p><code>Gdeaths</code>: Number of new deaths in Guinea
</p>
</li>
<li> <p><code>Lcases</code>: Number of new cases in Liberia
</p>
</li>
<li> <p><code>Ldeaths</code>: Number of new deaths in Liberia
</p>
</li>
<li> <p><code>SLcases</code>: Number of new cases in Sierra Leone
</p>
</li>
<li> <p><code>SLdeaths</code>: Number of new deaths in Sierra Leone
</p>
</li>
<li> <p><code>TotCases</code>: Cumulative number of cases across all three countries
</p>
</li>
<li> <p><code>TotDeaths</code>: Cumulative number of deaths across all three countries
Added in <code>EbolaGuinea</code>
</p>
</li>
<li> <p><code>Days</code>: When the report was issued in terms of a count of days from the initial report.
</p>
</li>
<li> <p><code>G7Rcases</code>:  Number of new cases in Guinea averaged across 7 reports
</p>
</li>
<li> <p><code>G7Rdeaths</code>:  Number of new deaths in Guinea averaged across 7 reports
</p>
</li></ul>

<p>An object of class <code>spec_tbl_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 182 rows and 6 columns.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>EbolaAll</code> gives daily reports for Guinea, Liberia, and Sierra Leone.
</p>
</li>
<li> <p><code>EbolaGuinea</code> contains just the Guinea data, but adds
columns containing a 7-day moving average.
</p>
</li></ul>



<h3>Source</h3>

<p>US Centers for Disease Control (CDC).
</p>

<hr>
<h2 id='Effective_oxygen'>Effective amount of oxygen available at different altitudes</h2><span id='topic+Effective_oxygen'></span>

<h3>Description</h3>

<p>Air pressure changes with altitude and therefore the amount of oxygen
available changes as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Effective_oxygen)
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows
</p>

<ul>
<li><p> altitude' In feet above sea level
</p>
</li>
<li><p> oxygen' Effective oxygen as a proportion of ai-
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://wildsafe.org/resources/ask-the-experts/altitude-safety-101/oxygen-levels/">https://wildsafe.org/resources/ask-the-experts/altitude-safety-101/oxygen-levels/</a>
</p>

<hr>
<h2 id='Engines'>Characteristics of various internal combustion engines</h2><span id='topic+Engines'></span>

<h3>Description</h3>

<p>Internal combustion engines have been built for a variety of purposes
ranging from propelling small model airplanes to powering trucks to driving
the propellers of giant ships.  This data frame gives the characteristics
of a wide size range of such engines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Engines)
</code></pre>


<h3>Format</h3>

<p>A data frame with 39 cases, each of which is an internal combustion engine, with observations on the following variables.
</p>

<ul>
<li> <p><code>mass</code> In pounds
</p>
</li>
<li> <p><code>ncylinder</code> Number of cylinders
</p>
</li>
<li> <p><code>stroke</code> The length  of the stroke made by a piston
</p>
</li>
<li> <p><code>strokes</code> Whether the engine cycle is 2-stroke or 4-stroke.
</p>
</li>
<li> <p><code>displacement</code> In cc
</p>
</li>
<li> <p><code>bore</code> Diameter of the piston
</p>
</li>
<li> <p><code>BHP</code> The power generated by  the engine. One BHP is the same as 745.7 Watts.
</p>
</li>
<li> <p><code>RPM</code> The speed, in revolutions per second, at which the engine generates the listed BHP.
</p>
</li></ul>



<h3>Source</h3>

<p>McMahon, Thomas A., and John Tyler Bonner. On Size and Life. New York: Scientific American Library, 1983. pp. 60-61
</p>

<hr>
<h2 id='first_three_args'>Handle the first three arguments of graphics functions</h2><span id='topic+first_three_args'></span>

<h3>Description</h3>

<p>This function is intended for package developers, not end-users. Canonically, <code>mosaicCalc</code> functions that produce layerable graphics have
three initial arguments in a specific order: (1) a previous gg layer, (2) a tilde expression, and (3)
a domain. But either (1) or (3) can be missing. <code>first_three_args()</code> translates a leading
... argument into the list of the canonical three initial arguments, returning them
as components of a list.  In addition, there may be additional arguments
in ... that specify other aspects of the plot, e.g. color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_three_args(..., two_tildes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_three_args_+3A_...">...</code></td>
<td>
<p>unnamed arguments to be translated into a list with the three canonical arguments
and any other arguments not named explicitly in the parent function definition.</p>
</td></tr>
<tr><td><code id="first_three_args_+3A_two_tildes">two_tildes</code></td>
<td>
<p>if <code>TRUE</code> then look for the first FOUR arguments, the middle
two of which will be tilde expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In constructing a mosaicCalc graphics layer, the function (e.g. <code>slice_plot()</code> or <code>contour_plot()</code>)
whould have ... as its first argument. Intercept that ... with <code>first_three_args()</code> to
extract the first three canonical arguments as components <code>gg</code>, <code>tilde</code>, and <code>domain</code> of a
list. Any remaining arguments in ... will be placed in the <code>dots</code> component.
</p>

<hr>
<h2 id='fitSpline'>Find zeros of a function</h2><span id='topic+fitSpline'></span>

<h3>Description</h3>

<p>This is defined in the <code style="white-space: pre;">&#8288;mosaic package&#8288;</code>:
See <code><a href="mosaic.html#topic+fitSpline">fitSpline</a></code>
</p>

<hr>
<h2 id='Fly_ball'>Trajectory of a fly ball in baseball</h2><span id='topic+Fly_ball'></span>

<h3>Description</h3>

<p>The trajectory of a fly ball as calculated by a sophisticated
model involving drag, spin, and such. The physics and mathematics are described
at <a href="http://baseball.physics.illinois.edu/TrajectoryAnalysis.pdf">http://baseball.physics.illinois.edu/TrajectoryAnalysis.pdf</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fly_ball
</code></pre>


<h3>Format</h3>

<p>A data frame with 552 rows.
</p>

<ul>
<li> <p><code>t</code> - (seconds). Runs from 0 to 5.51 s
</p>
</li>
<li> <p><code>y</code> - horizontal position (feet)
</p>
</li>
<li> <p><code>z</code> - vertical position (feet)
</p>
</li></ul>



<h3>Details</h3>

<p>The ball has a mass of 5.125 ounces and a circumference of 9.125 inches
The speed off the bat was 103 mph at a launch angle of 27.5 degrees from
the horizontal. The ball was hit with backspin at 2500 rpm by a right-handed
batter. Ambient temperature 70 deg F with a relative humidity of 50% and a
barometric pressure of 29.92 inHg. The field was at an elevation of 15 feet.
</p>
<p>The position of the ball was recorded every 0.01 seconds, for 5.5 seconds altogether.
If you prefer to work with continuous functions of time, you
can construct them. See the examples.
</p>


<h3>Source</h3>

<p><a href="http://baseball.physics.illinois.edu/TrajectoryCalculator-new-3D.xlsx">http://baseball.physics.illinois.edu/TrajectoryCalculator-new-3D.xlsx</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constructing continuous functions of time
ball_z &lt;- mosaic::connector(z ~ t, data = Fly_ball)
ball_y &lt;- mosaic::connector(y ~ t, data = Fly_ball)

</code></pre>

<hr>
<h2 id='gradient_plot'>Plot a vector field</h2><span id='topic+gradient_plot'></span><span id='topic+vectorfield_plot'></span>

<h3>Description</h3>

<p>Plot a vector field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient_plot(..., npts = 20, color = "black", alpha = 0.5, transform = sqrt)

vectorfield_plot(
  ...,
  npts = 20,
  color = "black",
  alpha = 0.5,
  transform = sqrt,
  env = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient_plot_+3A_...">...</code></td>
<td>
<p>(Optional: a previous graphics layer), tilde expressions for horiz and vertical
component of vectors, a domain (if not inherited from the graphics layer). The tilde expressions
should be in the same style as for <code>makeODE()</code>. See details.</p>
</td></tr>
<tr><td><code id="gradient_plot_+3A_npts">npts</code></td>
<td>
<p>number of arrows to draw in one row or column of the field.</p>
</td></tr>
<tr><td><code id="gradient_plot_+3A_color">color</code></td>
<td>
<p>character string specifying the color of the arrows.</p>
</td></tr>
<tr><td><code id="gradient_plot_+3A_alpha">alpha</code></td>
<td>
<p>transparency of the arrots</p>
</td></tr>
<tr><td><code id="gradient_plot_+3A_transform">transform</code></td>
<td>
<p>controls the relative length of the arrows. See details.</p>
</td></tr>
<tr><td><code id="gradient_plot_+3A_env">env</code></td>
<td>
<p>Not for end-users. Handles details of where things are defined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There will be one tilde expression for the horizontal component of the vector and another tilde
expression for the vertical component. Suppose the horizontal axis is called u and the vertical axis is called
v, as would be established by a bounds specification like <code>bounds(u=-1:1, v=-1:1)</code>. Then the horizontal
tilde expression <strong>must</strong> have a left side called <code style="white-space: pre;">&#8288;u ~&#8288;</code>. Similarly, the vertical
tilde expression will have a left side called <code style="white-space: pre;">&#8288;v ~&#8288;</code>. On the right side of the tilde expressions
will go the formulas for the respective components of the vectors, e.g. <code>u ~ sin(u-v)</code> and <code>v ~ v*u^2</code>.
</p>
<p>Typically, the length of the arrows is not meaningful in the units of the
horizontal or vertical axis. For instance, in a gradient plot of f(x,y), the axis is in units of x, but
the gradient component has units of f(x,y)/x. Similarly for the flow of a differential
equation. Nonetheless, the relative lengths of the arrows, one to another, does have meaning.
In drawing the vector field, the arrows are scaled so that the longest one barely avoids contact with it's neighbors.
This natural scaling has the disadvantage that it can be hard to discern the lengths of the
shortest arrows, which often are near zero (as with the gradient near the argmax or argmin, or near
a fixed point of a differential equation flow field). By default, the relative lengths of the arrow
are transformed by sqrt, to make the long arrows shorter and therefore enable the sort arrows to
be drawn somewhat longer. If you want the natural scaling instead, use <code>transform=I</code>. Or you might
want to make the arrows even more similar in length. Then use, for instance <code>transform=function(L) L^0.1</code>
</p>


<h3>Value</h3>

<p>ggplot2 graphics layers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gradient_plot(x * sin(y) ~ x &amp; y, bounds(x=-1:1, y=-1:1), transform=I)
vectorfield_plot(x ~ -y, y ~ x, bounds(x=-1:1, y=-1:1))
gf_label(0 ~ 0, label="center", color="red") %&gt;%
vectorfield_plot(x ~ -y, y ~ x, bounds(x=-1:1, y=-1:1), transform=function(x) x^0.2 )
vectorfield_plot(u ~ sin(u-v), v ~ v*u^2, bounds(u=0:1, v=-1:1))
 
</code></pre>

<hr>
<h2 id='HDD_Minneapolis'>Heating degree days in Minneapolis, Minnesota, USA</h2><span id='topic+HDD_Minneapolis'></span>

<h3>Description</h3>

<p>A &quot;heating degree day&quot; is a measure of weather coldness. It's defined to be the difference
between the outdoor ambient temperature and 65 degrees F, but has a value of zero when the ambient
temperature is above 65 degrees. This difference is averaged over time and multiplied by the number
of days in the time period covered. The heating degree day is often used as a measure of the demand for
domestic heating in a locale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HDD_Minneapolis)
</code></pre>


<h3>Format</h3>

<p>A data frame <code>HDD_Minneapolis</code> with 1412 rows and 4 variables:
</p>

<ul>
<li><p> year the year
</p>
</li>
<li><p> month the month
</p>
</li>
<li><p> hdd the number of heating degree days for that period.
</p>
</li>
<li><p> loc the location at which the temperature was measured. In the early years, this was downtown Minneapolis.
Later, the site was moved to the Minneapolis/Saint-Paul International Airport.
</p>
</li></ul>



<h3>Details</h3>

<p>These data report monthly heating degree days. For teaching purposes, the data give an extreme example
of how a relationship (hdd vs year) can be revealed by including a covariate (month). Although interest focusses
on the change in temperature over the century the data cover, there is such regular seasonal variation that
no systematic trend over the years is evident unless month is taken into account.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod_1 &lt;- lm(hdd ~ year, data = HDD_Minneapolis)
mod_2 &lt;- lm(hdd ~ year + month, data = HDD_Minneapolis)
</code></pre>

<hr>
<h2 id='Home_utilities'>Gas  and electricity usage by a home in St. Paul, MN</h2><span id='topic+Home_utilities'></span>

<h3>Description</h3>

<p>Gas  and electricity usage by a home in St. Paul, MN
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Home_utilities)
</code></pre>


<h3>Format</h3>

<p>A data.frame object with one row for each month
</p>

<ul>
<li> <p><code>month</code> - the month covered by the bill as a number
</p>
</li>
<li> <p><code>day</code> - the terminating day of the bill
</p>
</li>
<li> <p><code>year</code> - the year in which the month fell
</p>
</li>
<li> <p><code>temp</code> -  average temperature over the entire  month
</p>
</li>
<li> <p><code>kwh</code> - electricity usage in kilowatt-hours
</p>
</li>
<li> <p><code>ccf</code> - natural gas usage in cubic feet
</p>
</li>
<li> <p><code>thermsPerDay</code> - another measure of natural gas usage
</p>
</li>
<li> <p><code>dur</code> - duration of the period covered by the bill, in days (typically about 30)
</p>
</li>
<li> <p><code>totalbill</code> - dollar amount of the bill
</p>
</li>
<li> <p><code>gasbill</code>: - dollar amount of the natural gas  part of the bill
</p>
</li>
<li> <p><code>elecbill</code> - dollar amount of the electricity bill
</p>
</li>
<li> <p><code>generatedKwh</code> - Energy generated by the photovoltaic system
</p>
</li>
<li> <p><code>notes</code> - miscellaneous  comments on the month's bill or changes in the house
</p>
</li></ul>



<h3>Details</h3>

<p>A college mathematics professor teaching in St. Paul, Minnesota, USA collected these records
of his utility  bills starting in 1999. Starting in June 2022,
solar photovoltaics were installed on the roof of the house. There are months missing, a few transcription errors, etc.
<strong>These data will be updated occasionally, as new bills come in.</strong>
</p>


<h3>Source</h3>

<p>Personal communication from the homeowner
</p>

<hr>
<h2 id='inequality_constraint'>Graphics for constraints</h2><span id='topic+inequality_constraint'></span><span id='topic+equality_constraint'></span>

<h3>Description</h3>

<p>These functions are intended to annotate contour plots with constraint regions. Inequality
constraints are shaded where the constraint is NOT satisfied. Equality constraints
are shaded in a small region near where the constraint is satisfied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inequality_constraint(
  previous = NULL,
  tilde,
  domain,
  npts = 100,
  fill = "blue",
  alpha = 1
)

equality_constraint(
  previous = NULL,
  tilde,
  domain,
  npts = 100,
  fill = "blue",
  alpha = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inequality_constraint_+3A_previous">previous</code></td>
<td>
<p>can be ignored by user. It supports the pipe syntax for layering
graphics.</p>
</td></tr>
<tr><td><code id="inequality_constraint_+3A_tilde">tilde</code></td>
<td>
<p>a tilde expression specifying the constraint. For an inequality constraint
this should be a logical expression that is TRUE where the constraint is satisfied.
For an equality constraint, the left-hand side of the tilde expression should
be zero where the constraint IS satisfied.</p>
</td></tr>
<tr><td><code id="inequality_constraint_+3A_domain">domain</code></td>
<td>
<p>as in contour_plot(), the domain over which to graph the constraint</p>
</td></tr>
<tr><td><code id="inequality_constraint_+3A_npts">npts</code></td>
<td>
<p>a number specifying how finely to divide the domain in each direction. Default
is 100, but this gives a discernably pixelated appearance to the shading.  200 or 300
is more appropriate for publication-quality graphics.</p>
</td></tr>
<tr><td><code id="inequality_constraint_+3A_fill">fill</code></td>
<td>
<p>the color to use for shading</p>
</td></tr>
<tr><td><code id="inequality_constraint_+3A_alpha">alpha</code></td>
<td>
<p>the opacity of the shading</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 graphics layers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inequality_constraint(x + y &gt; 2 ~ y + x, domain(y=0:3, x=0:2))
equality_constraint(x + y - 2 ~ y + x, domain(y=0:3, x=0:2), npts=200, alpha=.3, fill="red")

</code></pre>

<hr>
<h2 id='infer_RHS'>Utilities for formulas and graphics arguments</h2><span id='topic+infer_RHS'></span><span id='topic+formals_from_expr'></span>

<h3>Description</h3>

<p><code>infer_RHS</code> turns a one-sided formula into a two-sided formula suitable for <code>makeFun()</code>.
<code>formals_from_expression</code> creates a &quot;formals&quot; list for creating a function.
The list will have arguments in the canonical order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_RHS(ex)

formals_from_expr(ex, others = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_RHS_+3A_ex">ex</code></td>
<td>
<p>An expression as in <code>quote(x^2)</code> or the left side of a tilde expression.</p>
</td></tr>
<tr><td><code id="infer_RHS_+3A_others">others</code></td>
<td>
<p>Character string(s) with names of additional arguments to be
included in the formals</p>
</td></tr>
</table>

<hr>
<h2 id='inscribed_circle'>Create a data frame for a circle marking the curvature of a function.</h2><span id='topic+inscribed_circle'></span>

<h3>Description</h3>

<p>Create a data frame for a circle marking the curvature of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inscribed_circle(ftilde, x0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inscribed_circle_+3A_ftilde">ftilde</code></td>
<td>
<p>A tilde expression defining a function</p>
</td></tr>
<tr><td><code id="inscribed_circle_+3A_x0">x0</code></td>
<td>
<p>The value for the input at which the curvature is to be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>inscribed_circle()</code> return a data frame with <code>x</code> and <code>y</code> components describing the inscribed circle
located at the point $(x_0, f(x_0))$. Plot this with <code>gf_path(y ~ x)</code>
<code>curvature_function()</code> returns a function that gives the curvature of the specified
function for any input $x$. It's much like <code>D()</code> in the way it is used.
</p>

<hr>
<h2 id='Integrate'>Integrate a function</h2><span id='topic+Integrate'></span>

<h3>Description</h3>

<p>Calculates the definite integral of a function. That is, the result of the
integration will be a number. There can be no free parameters in the function
being integrated. (If you want free parameters, use <code>antiD()</code>.) <code>Integrate()</code> can
handle integration over up to 3 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Integrate(tilde, domain, ..., tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Integrate_+3A_tilde">tilde</code></td>
<td>
<p>A tilde expression describing the function.</p>
</td></tr>
<tr><td><code id="Integrate_+3A_domain">domain</code></td>
<td>
<p>The domain over which to perform the integration</p>
</td></tr>
<tr><td><code id="Integrate_+3A_...">...</code></td>
<td>
<p>values assigned to free parameters in the tilde expression, e.g. a=1</p>
</td></tr>
<tr><td><code id="Integrate_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance for integration, see <code>stats::integrate()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For functions constructed as a spline interpolant, <code>Integrate()</code> can handle
more segments than <code>antiD()</code>. It's reasonable to do up to 2000 segments with <code>Integrate()</code>,
whereas <code>antiD()</code> handles only about 100.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Integrate(dnorm(x) ~ x, domain(x=-2:2))
Integrate(dnorm(x, sd=sigma) ~ x, domain(x=-2:2), sigma=2)
Integrate(sqrt(1- x^2) ~ x, domain(x=-1:1)) # area of semi-circle

</code></pre>

<hr>
<h2 id='integrateODE'>Integrate ordinary differential equations</h2><span id='topic+integrateODE'></span>

<h3>Description</h3>

<p>A formula interface to integration of an ODE with respect to &quot;t&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateODE(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrateODE_+3A_...">...</code></td>
<td>
<p>A dynamics object (see <code>makeODE()</code>) and/or arguments giving additional formulas for dynamics in other variables,
assignments of parameters, assignments of initial conditions, the start and end times of the
integration (through <code>domain()</code>), and the step size (through <code style="white-space: pre;">&#8288;dt=&#8288;</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equations must be in first-order form.  Each dynamical equation uses
a formula interface with the variable name given on the left-hand side of the
formula, preceded by a <code>d</code>, so use <code>dx~-k*x</code> for exponential decay.
All parameters (such as <code>k</code>) must be assigned numerical values in the
argument list.  All dynamical variables must be assigned initial conditions in the
argument list.  The returned value will be a list with one component named after each
dynamical variable.  The component will be a spline-generated function of <code>t</code>.
</p>


<h3>Value</h3>

<p>a list with splined function of time for each dynamical variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>soln = integrateODE(dx~r*x*(1-x/k), k=10, r=.5, domain(t=0:20), x=1)
soln$x(10)
soln$x(30) # outside the time interval for integration
traj_plot(x(t)~t, soln, domain(t=0:10)) 
soln2 = integrateODE(dx~y, dy~-x, x=1, y=0, domain(t=0:10))
traj_plot(y(t)~t, soln2)
SIR &lt;- makeODE(dS~ -a*S*I, dI ~ a*S*I - b*I, a=0.0026, b=.5, S=762, I=1)
epi = integrateODE(SIR, domain(t=0:20)) 
traj_plot(I(t) ~ t, epi)
</code></pre>

<hr>
<h2 id='is_in_domain'>check whether a value is in a domain</h2><span id='topic+is_in_domain'></span>

<h3>Description</h3>

<p>A convenience function to see if a value is inside
(or on the boundaries of) a domain or a set of domain segments.
In the case of multiple segments, the check is
whether <code>val</code> is within any of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_in_domain(val, domain, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_in_domain_+3A_val">val</code></td>
<td>
<p>the values to be checked</p>
</td></tr>
<tr><td><code id="is_in_domain_+3A_domain">domain</code></td>
<td>
<p>the domain</p>
</td></tr>
<tr><td><code id="is_in_domain_+3A_...">...</code></td>
<td>
<p>additional domains</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_in_domain(1:10, domain(x=5.5:8.5), domain(x=1:2))
is_in_domain(mtcars, domain(mpg=15:20, wt=2:4.5), domain(mpg=25:28))
</code></pre>

<hr>
<h2 id='Iterate'>Iterate a function on an initial condition</h2><span id='topic+Iterate'></span>

<h3>Description</h3>

<p>Iterates a function a specified number of times on an initial condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Iterate(f = NULL, A = NULL, x0 = 0, n = 10, fargs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Iterate_+3A_f">f</code></td>
<td>
<p>a function of one or more state variables which returns a vector containing
those same state variables. Parameters to <code>f()</code>, if any, should be named and at
the end of the argument list. State variables should <strong>not</strong> have default values.</p>
</td></tr>
<tr><td><code id="Iterate_+3A_a">A</code></td>
<td>
<p>As an alternative to <code>f</code> you can give a square matrix and iteration
will be done on the system <code style="white-space: pre;">&#8288;x[n+1] = A x[n]&#8288;</code>. In lieu of a square matrix
you can also give a vector to be rendered into a square matrix rowwise.</p>
</td></tr>
<tr><td><code id="Iterate_+3A_x0">x0</code></td>
<td>
<p>a vector with the numerical initial condition. There should be 1 component
in <code>x0</code> for each of the state variables in <code>f()</code>.</p>
</td></tr>
<tr><td><code id="Iterate_+3A_n">n</code></td>
<td>
<p>an integer specifying the number of iterations</p>
</td></tr>
<tr><td><code id="Iterate_+3A_fargs">fargs</code></td>
<td>
<p>list containing values for numerical parameters to the function <code>f()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>f</code> can take one or more arguments. The first of these
should represent the <em>state</em> of the dynamical system, e.g. x, or x and y, etc.
At the end of the argument list to <code>f</code> can come named parameters. The length of the
initial condition <code>x0</code> must match the number of state arguments. Numerical values for
parameters (if any) must be provided in the <code>...</code> slot.
</p>


<h3>Value</h3>

<p>A data frame with a column <code>.i</code> listing the iteration number
and columns for each component of the initial condition. There will be n+1
rows, the first for the initial condition and the remaining for the n iterations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Iterate(function(x, mu=3.5) mu*x*(1-x), x0=.232, n=10, list(mu=4)) # chaos
Iterate(function(x, y) c(x+y, x-y), x0 = c(1,1), n=10)
Iterate(function(x, y) c(x+y, x), x0=c(1,0), n=10) # fibonacci
Iterate(A = cbind(rbind(1, 1), rbind(1, 0)), x0=c(1,0), n=5) # fibonacci described by a matrix
</code></pre>

<hr>
<h2 id='Kepler'>Kepler's calculation of the position of Mars</h2><span id='topic+Kepler'></span>

<h3>Description</h3>

<p>Astronomer <a href="https://en.wikipedia.org/wiki/Johannes_Kepler">Johannes Kepler</a> (1571-1630) famously measured
the position of the planet Mars. His interpretation of this data
led substantially to Newton's theory of universal gravity. This
data frame gives Kepler's measurements as a function of time, together
with a modern reconstruction of the &quot;actual&quot; position of Mars at the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Kepler)
</code></pre>


<h3>Format</h3>

<p>A data frame with 28 rows and these variables:
</p>

<ul>
<li> <p><code>time</code> - Interval in Earth days from 8:15am Greenwich
time on 9 March 1584.
</p>
</li>
<li> <p><code>kepler.radius</code> - The radius of the orbit in AU (astronomical units. 1 AU is 93 million miles)
</p>
</li>
<li> <p><code>kepler.angle</code> - The &quot;true anomoly&quot; measured in radians
</p>
</li>
<li> <p><code>actual.radius</code> - Modern calculation of the above
</p>
</li>
<li> <p><code>actual.angle</code> - Modern calculation of the above
</p>
</li></ul>



<h3>Details</h3>

<p>The raw measurements (not included here) that Kepler
used in his calculation were made by Tycho Brahe (1546-1601).
Those raw measurements were of the angle of Mars with respect to Earth.
Kepler estimated the orbital period of Mars to be 687 Earth days.
(The current accepted value is 686.980 days.) Knowing the period, Kepler
could find pairs of Earth days separated by multiples of the period. In each pair,
the Earth would be in a different position, but Mars would be in the same position.
Thus the distance of Mars from Earth could be estimated by triangulation.
</p>
<p>The angle was not directly measured for each occasion. Instead, knowing the
radius versus time Kepler was able to discern when Mars was at its greatest and
closest distance to the Sun. The angle tells where Mars is along its orbit. An
angle of 0 is the position when Mars is closest to the Sun. An angle of 3.14 is
when Mars is farthest from the Sun.
</p>


<h3>Source</h3>

<p>Drawn from  from McLaughlin, Michael P. ( 1999 ) &quot;A Tutorial on
<a href="http://www.causascientia.org/math_stat/Tutorial.pdf">Mathematical Modelling&quot;</a>
p. 21-23.
</p>


<h3>References</h3>

<p>See <code style="white-space: pre;">&#8288;https://faculty.uca.edu/saustin/3110/mars.pdf&#8288;</code> for a useful
description of the estimation process.
</p>

<hr>
<h2 id='M2014F'>Mortality versus age for females in the US in 2014</h2><span id='topic+M2014F'></span>

<h3>Description</h3>

<p>These data are from the US Social Security Administration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M2014F
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 120 rows and 5 columns.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>pmort</code> the probability of a person of the given age dying in 2014
</p>
</li>
<li> <p><code>nliving</code> traces a hypothetical population of 100,000 people through the mortality at each age.
</p>
</li>
<li> <p><code>died</code> for the hypothetical population the number of people at that age who
survived to the age and then died at that age.
Source: <a href="https://www.ssa.gov/oact/HistEst/PerLifeTables/2017/PerLifeTables2017.html">https://www.ssa.gov/oact/HistEst/PerLifeTables/2017/PerLifeTables2017.html</a>
</p>
</li></ul>


<hr>
<h2 id='makeODE'>Create a dynamics object for use in <code>integrateODE()</code> and the ODE graphics</h2><span id='topic+makeODE'></span>

<h3>Description</h3>

<p>An ODE object consists of some dynamics, initial conditions, parameter values,
time domain, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeODE(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeODE_+3A_...">...</code></td>
<td>
<p>The components of an ODE and/or a set of other ODE objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing various functions and values specifying the
ODE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SIR &lt;- makeODE(dS~ -a*S*I, dI ~ a*S*I - b*I, a=0.0026, b=.5, S=762, I=1)
soln &lt;- integrateODE(SIR, domain(t=0:20))

</code></pre>

<hr>
<h2 id='numD'>Numerical Derivatives</h2><span id='topic+numD'></span>

<h3>Description</h3>

<p>Constructs the numerical derivatives of mathematical expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numD(tilde, ..., .h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numD_+3A_tilde">tilde</code></td>
<td>
<p>a mathematical expression (see examples and <code><a href="#topic+plotFun">plotFun</a></code>)</p>
</td></tr>
<tr><td><code id="numD_+3A_...">...</code></td>
<td>
<p>additional parameters, typically default values for mathematical parameters</p>
</td></tr>
<tr><td><code id="numD_+3A_.h">.h</code></td>
<td>
<p>numerical step size to enforce.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a simple finite-difference scheme to evaluate the derivative.  The function created
will not contain a formula for the derivative.  Instead, the original function is stored
at the time the derivative is constructed and that original function is re-evaluated at the
finitely-spaced points of an interval.  If you redefine the original function, that won't affect
any derivatives that were already defined from it.
Numerical derivatives, particularly high-order ones, are unstable.  The finite-difference parameter
<code>.h</code> is set, by default, to give reasonable results for first- and second-order derivatives.
It's tweaked a bit so that taking a second derivative by differentiating a first derivative
will give reasonably accurate results.  But,
if taking a second derivative, much better to do it in one step to preserve numerical accuracy.
</p>


<h3>Value</h3>

<p>a function implementing the derivative as a finite-difference approximation.
This has a second argument, <code>.h</code>, that allow the finite-difference to be set when evaluating
the function. The default values are set for reasonable numerical precision.
</p>


<h3>Note</h3>

<p>WARNING: In the expressions, do not use variable names beginning with a dot, particularly <code>.f</code> or <code>.h</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Kaplan (<a href="mailto:kaplan@macalester.edu">kaplan@macalester.edu</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = numD( a*x^2 + x*y ~ x, a=1)
g(x=2,y=10)
gg = numD( a*x^2 + x*y ~ x&amp;x, a=1)
gg(x=2,y=10)
ggg = numD( a*x^2 + x*y ~ x&amp;y, a=1)
ggg(x=2,y=10)
h = numD( g(x=x,y=y,a=a) ~ y, a=1)
h(x=2,y=10)
f = numD( sin(x)~x)
# slice_plot( f(3,.h=hlim)~h, bounds(h=.00000001 :000001)) %&gt;% gf_hline(yintercept = cos(3))

</code></pre>

<hr>
<h2 id='PE_fun1'>Potential energy functions used as examples in <em>MOSAIC Calculus</em>.</h2><span id='topic+PE_fun1'></span><span id='topic+PE_fun2'></span>

<h3>Description</h3>

<p>These appear in the &quot;Optimization &amp; constraint&quot; chapter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PE_fun1(x1, y1)

PE_fun2(x1, y1, x2, y2, x3, y3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PE_fun1_+3A_x1">x1</code>, <code id="PE_fun1_+3A_y1">y1</code>, <code id="PE_fun1_+3A_x2">x2</code>, <code id="PE_fun1_+3A_y2">y2</code>, <code id="PE_fun1_+3A_x3">x3</code>, <code id="PE_fun1_+3A_y3">y3</code></td>
<td>
<p>coordinates of the masses.</p>
</td></tr>
</table>

<hr>
<h2 id='Picket'>Creates a &quot;picket fence&quot; of points for illustrating numerical integration</h2><span id='topic+Picket'></span>

<h3>Description</h3>

<p>Creates a &quot;picket fence&quot; of points for illustrating numerical integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Picket(
  domain,
  h = 0.1,
  method = c("left", "right", "center", "trapezoid", "gauss")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Picket_+3A_domain">domain</code></td>
<td>
<p>domain of integration as used in <code>slice_plot()</code>, <code>Integrate()</code>, and the similar mosaicCalc functions</p>
</td></tr>
<tr><td><code id="Picket_+3A_h">h</code></td>
<td>
<p>number giving the width between pickets. Could also have been called <code>dt</code> or <code>dx</code>, and so on.</p>
</td></tr>
<tr><td><code id="Picket_+3A_method">method</code></td>
<td>
<p>determines the weights for each element in the picket</p>
</td></tr>
</table>

<hr>
<h2 id='Planet_solar'>Solar irradiance of the planets</h2><span id='topic+Planet_solar'></span>

<h3>Description</h3>

<p>Brightness of the sun at the various planets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Planet_solar)
</code></pre>


<h3>Format</h3>

<p>A data frame with 9 rows
</p>

<ul>
<li> <p><code>planet</code> Name of the planet (or planetoid)
</p>
</li>
<li> <p><code>distance</code> distance from the sun in millions of km
</p>
</li>
<li> <p><code>irradiance</code> solar brightness (in what units?)
</p>
</li></ul>


<hr>
<h2 id='Planets'>NASA data on planets</h2><span id='topic+Planets'></span>

<h3>Description</h3>

<p>NASA data on planets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Planets)
</code></pre>


<h3>Format</h3>

<p>A data frame with 10 rows and these variables:
</p>

<ul>
<li> <p><code>planet</code> name of the planet
</p>
</li>
<li> <p><code>mass</code>  in 10^24 kg
</p>
</li>
<li> <p><code>diameter</code> in  km
</p>
</li>
<li> <p><code>density</code> in kg/m^3
</p>
</li>
<li> <p><code>gravity</code>  in m/s^2
</p>
</li>
<li> <p><code>escape_velocity</code> in km/s
</p>
</li>
<li> <p><code>rotational_period</code> in hours
</p>
</li>
<li> <p><code>day_length</code> in  hours
</p>
</li>
<li> <p><code>distance_from_sun</code> in 10^6 km
</p>
</li>
<li> <p><code>perihelion</code> in  10^6 km
</p>
</li>
<li> <p><code>aphelion</code> in  10^6  km
</p>
</li>
<li> <p><code>orbital_period</code> in days
</p>
</li>
<li> <p><code>orbital_velocity</code>  in km/s
</p>
</li>
<li> <p><code>orbital_inclination</code> in degrees
</p>
</li>
<li> <p><code>orbital_eccentricity</code>
</p>
</li>
<li> <p><code>obliquity_to_orbit</code> in  degrees
</p>
</li>
<li> <p><code>mean_temperature</code> in C
</p>
</li>
<li> <p><code>surface_pressure</code> in  bars
</p>
</li>
<li> <p><code>n_moons</code> a count
</p>
</li>
<li> <p><code>ring_system</code> does the planet have a ring system
</p>
</li>
<li> <p><code>global_magnetic_field</code> does the planet have a magnetic field
</p>
</li></ul>



<h3>Details</h3>

<p>Two of the rows, MOON and  PLUTO, are not considered planets. The
orbital parameters  of the MOON are with respect to EARTH. Others are with respect
to the Sun. Negative rotation period denotes a rotation opposite that of most of the
other planets.
</p>


<h3>Source</h3>

<p>https://nssdc.gsfc.nasa.gov/planetary/factsheet/
</p>

<hr>
<h2 id='plotFun'>Plot functions of one and two variables using lattice system</h2><span id='topic+plotFun'></span>

<h3>Description</h3>

<p>This is defined in the <code style="white-space: pre;">&#8288;mosaic package&#8288;</code>:
See <code><a href="mosaic.html#topic+plotFun">plotFun</a></code>
</p>

<hr>
<h2 id='qspliner'>Create a quadratic spline (inefficiently)</h2><span id='topic+qspliner'></span>

<h3>Description</h3>

<p>A handmade function to construct quadratic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspliner(tilde, data, free = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qspliner_+3A_tilde">tilde</code></td>
<td>
<p>A tilde expression of the form <code>y ~ x</code> specifying the output variable (on the LHS)
and the input variable (on the RHS). Together with <code>data</code>, these (x,y) pairs will be the
knots for the spline.</p>
</td></tr>
<tr><td><code id="qspliner_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in <code>tilde</code>.</p>
</td></tr>
<tr><td><code id="qspliner_+3A_free">free</code></td>
<td>
<p>A number specifying the slope of the output function at the last knot. Default is 0: that is, flat.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless you have a good reason otherwise, you should be using <code>spliner()</code>,
which generates cubic splines,
rather than <code>qspliner()</code>.  <code>qspliner()</code> is intended only for demonstration purposes.
</p>


<h3>Value</h3>

<p>a function suitable for, for instance, graphing or optimizing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Pts &lt;- tibble(x = seq(-4,4, by=.7), y = dnorm(x))
f &lt;- qspliner(y ~ x, data = Pts)
slice_plot(dnorm(x) ~ x, domain(x=-4:4)) %&gt;%
  slice_plot(f(x) ~ x, color= "blue") %&gt;%
  gf_point(y ~ x, data = Pts, color = "orange", size=4, alpha=0.3) %&gt;%
  gf_lims(y= c(NA,.5))
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+spliner'></span><span id='topic+connector'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>mosaic</dt><dd><p><code><a href="mosaic.html#topic+FunctionsFromData">connector</a></code>, <code><a href="mosaic.html#topic+FunctionsFromData">spliner</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rfun'>Generate a &quot;natural looking&quot; function of one or multiple variables</h2><span id='topic+rfun'></span>

<h3>Description</h3>

<p>This is defined in the <code style="white-space: pre;">&#8288;mosaic package&#8288;</code>:
See <code><a href="mosaic.html#topic+rfun">rfun</a></code>.
</p>

<hr>
<h2 id='RI_tide'>Tide levels from the US NOAA</h2><span id='topic+RI_tide'></span><span id='topic+RI_tide+2C'></span><span id='topic+Anchorage_tide'></span>

<h3>Description</h3>


<ul>
<li> <p><code>RI_tide</code>: For Providence, RI, Minute-by-minute tide data during April 1-5 2010.
</p>
</li>
<li> <p><code>Anchorage_tide</code>: For Anchorage, AK, Every six-minute data during 2018
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>RI_tide
</code></pre>


<h3>Format</h3>

<p>An object of class <code>spec_tbl_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 6426 rows and 3 columns.
</p>


<h3>Details</h3>

<p>Variables:
</p>

<ul>
<li> <p><code>level</code> meters
</p>
</li>
<li> <p><code>date_time</code> GMT
</p>
</li>
<li> <p><code>hour</code> time in hours after start of April 2010.
</p>
</li></ul>

<p>Lat/Long: 41.8071N, -71.4012W
Request: <code style="white-space: pre;">&#8288;https://tidesandcurrents.noaa.gov/api/datagetter?begin_date=20200401%2010:00&amp;end_date=20200405%201:59&amp;station=8454000&amp;product=one_minute_water_level&amp;datum=mllw&amp;units=metric&amp;time_zone=gmt&amp;application=web_services&amp;format=csv&#8288;</code>
Other product documentation: https://tidesandcurrents.noaa.gov/api/
Google Map: https://www.google.com/maps/place/Providence,+RI/@41.8071,-71.4012,14z/data=!4m5!3m4!1s0x89e444e0437e735d:0x69df7c4d48b3b627!8m2!3d41.8071!4d-71.4012
</p>

<hr>
<h2 id='Robot_stations'>Waypoints on the path of a fictitious robot</h2><span id='topic+Robot_stations'></span>

<h3>Description</h3>

<p>This is used in <em>MOSAIC Calculus</em> examples about splining.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Robot_stations
</code></pre>


<h3>Format</h3>

<p>A data frame with 16 cases, each of which is an x-y location at the indicated time.
</p>

<ul>
<li><p> x,y X-Y location in mm
</p>
</li>
<li><p> t time in seconds
</p>
</li></ul>


<hr>
<h2 id='Runners'>Running times</h2><span id='topic+Runners'></span>

<h3>Description</h3>

<p>A longitudinal record of running times. There are 5977 individual runners included
here, each with a unique <code>id</code>. Each runner ran the 10-mile race (See <code>mosaicData::TenMileRace</code>)
on multiple occasions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Runners
</code></pre>


<h3>Format</h3>

<p>Data frame with 24,334 rows
</p>

<ul>
<li> <p><code>year</code> the occasion on which the runner ran the Cherry Blossom Ten Miler
</p>
</li>
<li> <p><code>age</code> the runners age at the time of that occasion
</p>
</li>
<li> <p><code>gun</code> the time (in minutes) from the gun to crossing the finish line.
</p>
</li>
<li> <p><code>net</code> time between crossing the start line and crossing the finish line. Sometimes this is missing. It's typically smaller than <code>gun</code> because it takes time to reach the starting line.
</p>
</li>
<li> <p><code>sex</code> as recorded by the race organizers.
</p>
</li>
<li> <p><code>previous</code> How many previous occasions did this person run the race.
</p>
</li>
<li> <p><code>nruns</code> The total number of runs recorded for this person (including future runs)
</p>
</li>
<li> <p><code>start_position</code> A qualitative indication of how close to the front of the pack the person was positioned at the time the gun went off.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Kaplan
</p>


<h3>Source</h3>

<p>Scraped from the Cherry Blossom web site by patient, unremunerated toil of the author.
</p>

<hr>
<h2 id='simpleYacasIntegrate'>Interface to integration using Ryacas</h2><span id='topic+simpleYacasIntegrate'></span>

<h3>Description</h3>

<p>Interface to integration using Ryacas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleYacasIntegrate(tilde, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleYacasIntegrate_+3A_tilde">tilde</code></td>
<td>
<p>The tilde expression for the integration</p>
</td></tr>
<tr><td><code id="simpleYacasIntegrate_+3A_...">...</code></td>
<td>
<p>Bindings for parameters in <code>tilde</code></p>
</td></tr>
</table>

<hr>
<h2 id='simplify_fun'>Turn a 1-line function into an inline formula</h2><span id='topic+simplify_fun'></span><span id='topic+inline_expr'></span><span id='topic+replace_arg_in_expr'></span>

<h3>Description</h3>

<p>Turn a 1-line function into an inline formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_fun(fun)

inline_expr(ex, old, new, env)

replace_arg_in_expr(ex, old, new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_fun_+3A_fun">fun</code></td>
<td>
<p>a function, such as produced by <code>makeFun()</code>.</p>
</td></tr>
<tr><td><code id="simplify_fun_+3A_ex">ex</code></td>
<td>
<p>an expression</p>
</td></tr>
<tr><td><code id="simplify_fun_+3A_old">old</code></td>
<td>
<p>the name to be replaced as produced by as.name()</p>
</td></tr>
<tr><td><code id="simplify_fun_+3A_new">new</code></td>
<td>
<p>the name to be substituted in for arg_name</p>
</td></tr>
<tr><td><code id="simplify_fun_+3A_env">env</code></td>
<td>
<p>the environment for the expression</p>
</td></tr>
</table>

<hr>
<h2 id='slice_plot'>Plot a function of a single variable</h2><span id='topic+slice_plot'></span>

<h3>Description</h3>

<p>In a slice plot, there  is one independent variable. The graph
shows the output of the function versus the independent variable. It's
called a slice plot to distinguish it from a contour plot, in which
the graph has one axis for each independent variable and the output
of the function is shown by color and labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_plot(
  ...,
  npts = 101,
  color = "black",
  alpha = 1,
  label_text = "",
  label_x = 1,
  label_vjust = "top",
  label_color = color,
  label_alpha = alpha,
  singularities = numeric(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_plot_+3A_...">...</code></td>
<td>
<p>Canonical first three argument: <code style="white-space: pre;">&#8288;[gg]&#8288;</code>, tilde expression, <code style="white-space: pre;">&#8288;[domain]&#8288;</code> as well
as any parameters to be assigned or re-assigned.</p>
</td></tr>
<tr><td><code id="slice_plot_+3A_npts">npts</code></td>
<td>
<p>Integer, number of points at which to evaluate the function.</p>
</td></tr>
<tr><td><code id="slice_plot_+3A_color">color</code></td>
<td>
<p>Color of curve</p>
</td></tr>
<tr><td><code id="slice_plot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha of curve</p>
</td></tr>
<tr><td><code id="slice_plot_+3A_label_text">label_text</code></td>
<td>
<p>character string label to place near the graph curve. Default: none.</p>
</td></tr>
<tr><td><code id="slice_plot_+3A_label_x">label_x</code></td>
<td>
<p>number between 0 and 1 indicating the horizontal placement  of the <code>label_text</code>.</p>
</td></tr>
<tr><td><code id="slice_plot_+3A_label_vjust">label_vjust</code></td>
<td>
<p>vertical justification of label. One of &quot;left&quot;, &quot;middle&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;center&quot;, &quot;top&quot;, &quot;inward&quot;, or &quot;outward&quot;</p>
</td></tr>
<tr><td><code id="slice_plot_+3A_label_color">label_color</code></td>
<td>
<p>color of label</p>
</td></tr>
<tr><td><code id="slice_plot_+3A_label_alpha">label_alpha</code></td>
<td>
<p>alpha of label</p>
</td></tr>
<tr><td><code id="slice_plot_+3A_singularities">singularities</code></td>
<td>
<p>numeric vector of x positions at which to break
the graph.
</p>
<p>Additional arguments will be passed to <code>geom_line()</code>. Use, e.g. <code>color="red"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 layers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
slice_plot(sin(x) ~ x, domain(x = range(-5, 15)))
f &lt;- makeFun(sin(2*pi*t/P) ~ t)
slice_plot(f(t, P=20) ~ t, domain(t = -5:10), label_text = "Period 20", label_x=0.9)
slice_plot(x^2 ~ x) # Error: no domain specified
slice_plot(cos(x) ~ x, domain(x[-10:10]) # domain will be -10 &lt; x &lt; 10
# see domain

## End(Not run)

</code></pre>

<hr>
<h2 id='smoother'>Create a smoothing function approximating a cloud of points</h2><span id='topic+smoother'></span>

<h3>Description</h3>

<p>This is defined in the <code style="white-space: pre;">&#8288;mosaic package&#8288;</code>:
See <code><a href="mosaic.html#topic+smoother">smoother</a></code>.
</p>

<hr>
<h2 id='SSA_2007'>US Mortality table from 2007</h2><span id='topic+SSA_2007'></span>

<h3>Description</h3>

<p>Mortality table from the US Social Security Adminstration
issued in 2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSA_2007
</code></pre>


<h3>Format</h3>

<p>A data frame with 240 rows. Each row corresponds
to one age year from 0 to 120.
</p>

<ul>
<li> <p><code>Age</code>: The age year. 0 corresponds to birth through one year of age.
</p>
</li>
<li> <p><code>Sex</code>: The sex for which the row is relevant.
</p>
</li>
<li> <p><code>Mortality</code>: The fraction of people of that age who died in 2007.
</p>
</li>
<li> <p><code>LifeExpectancy</code>: The calculated &quot;life expectancy&quot; at that age for that sex.
</p>
</li></ul>



<h3>Details</h3>

<p>Life expectancy is a measure constructed from
a simulation. Start with 100,000 people at birth. Use the
mortality at each age to follow the living through successive
ages. The &quot;life expectancy at birth&quot; (age 0) is the average
age at death of those 100,000 people. For the life expectancy in
year n, consider only that fraction of the original 100,000 who survived to
year n. The life expectancy will be the average time until death for those survivors.
</p>

<hr>
<h2 id='streamlines'>Dynamical systems calculations and graphics</h2><span id='topic+streamlines'></span><span id='topic+flow_field'></span><span id='topic+trajectory_euler'></span>

<h3>Description</h3>


<ul>
<li> <p><code>streamlines()</code> draws raindrop-shaped paths at a randomized grid of points that follow trajectories
</p>
</li>
<li> <p><code>flow_field()</code> draws arrows showing the flow at a grid of points
</p>
</li>
<li> <p><code>trajectory_euler()</code> compute an Euler solution. ()
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>streamlines(..., npts = 8, dt = 0.01, nsteps = 10, color = "black", alpha = 1)

flow_field(..., npts = 8, scale = 0.8, color = "black", alpha = 1)

trajectory_euler(..., dt = 0.01, nsteps = 4, full = TRUE, every = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streamlines_+3A_...">...</code></td>
<td>
<p>The first arguments should describe the dynamics. See details.</p>
</td></tr>
<tr><td><code id="streamlines_+3A_npts">npts</code></td>
<td>
<p>The number of points on an edge of the grid</p>
</td></tr>
<tr><td><code id="streamlines_+3A_dt">dt</code></td>
<td>
<p>time step (e.g. 0.01)</p>
</td></tr>
<tr><td><code id="streamlines_+3A_nsteps">nsteps</code></td>
<td>
<p>how many Euler steps to take</p>
</td></tr>
<tr><td><code id="streamlines_+3A_color">color</code></td>
<td>
<p>What color to use</p>
</td></tr>
<tr><td><code id="streamlines_+3A_alpha">alpha</code></td>
<td>
<p>What alpha to use</p>
</td></tr>
<tr><td><code id="streamlines_+3A_scale">scale</code></td>
<td>
<p>Number indicating how long to draw arrows. By default,
the longest arrows take up a full box in the grid</p>
</td></tr>
<tr><td><code id="streamlines_+3A_full">full</code></td>
<td>
<p>report the derivative and the step size for each variable</p>
</td></tr>
<tr><td><code id="streamlines_+3A_every">every</code></td>
<td>
<p>n, report will contain every nth step</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dynamical functions themselves will be formulas like <code>dx ~ a*x*y</code> and <code>dy ~ y/x</code>.
Initial conditions will be arguments of the form <code>x=3</code> and <code>y=4</code>.
If there are parameters in the dynamical functions, you should also
add the parameter values, for instance <code>a=2</code>.
</p>
<p>For <code>flow_field()</code> and <code>streamlines()</code> you do not need to specify
initial conditions. The grid will be set by the domain argument.
</p>
<p>The graphics functions are all arranged to accept,
if given, a ggplot object piped in. The new graphics layer will be drawn on
top of that. If there is no ggplot object piped in, then the graphics
will be made as a first layer, which can optionally piped into other
ggformula functions or <code>+</code> into ggplot layers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streamlines(dx ~ x+y, dy~ x-y, domain(x=0:6, y=0:3))
flow_field(dx ~ x+y, dy~ x-y, domain(x=0:6, y=0:3))
Dyn &lt;- makeODE(dx ~ 0.06*x, dy ~-x - y, domain(t=0:20), dt=0.1,x=3, y=4)
streamlines(Dyn, domain(x=-5:5, y=-5:5), npts=15)
flow_field(Dyn, domain(x=-6:6, y=-10:10))
trajectory_euler(dx ~ -y, dy ~ .5*x, x=3, y=3)
rabbits &lt;- drabbit ~ 0.2*rabbit - 0.01*rabbit*fox
foxes &lt;- dfox ~ -.2*fox + 0.0005*rabbit*fox 
trajectory_euler(rabbits, foxes, rabbit=100, fox=3, dt=0.1, nsteps=500, every=10)

</code></pre>

<hr>
<h2 id='surface_plot'>Make an interactive plotly plot of a function of two variables</h2><span id='topic+surface_plot'></span><span id='topic+interactive_plot'></span><span id='topic+surface_with_contours'></span>

<h3>Description</h3>

<p>An interactive plot lets you interrogate the plot to get
numerical values at each point. When <code>type = "surface"</code>, the
plot can be rotated to see the &quot;shape&quot; of the function from
various perspectives. Using the  interactive controls, you
can save the plot as a PNG file. But it's not possible to overlay
plots the way you can with <code>contourPlot()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface_plot(
  formula,
  domain = c(-5, 5),
  npts = 50,
  type = c("both", "surface", "contour", "heatmap")
)

interactive_plot(
  formula,
  domain = c(-5, 5),
  npts = 50,
  type = c("both", "surface", "contour", "heatmap")
)

surface_with_contours(formula, domain = c(-5, 5), npts = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surface_plot_+3A_formula">formula</code></td>
<td>
<p>a formula describing a function in  the manner
of <code>mosaicCalc::makeFun()</code></p>
</td></tr>
<tr><td><code id="surface_plot_+3A_domain">domain</code></td>
<td>
<p>a call to the <code>domain()</code> function giving ranges
using the same independent variables as in the <code>formula</code></p>
</td></tr>
<tr><td><code id="surface_plot_+3A_npts">npts</code></td>
<td>
<p>The fineness at which to evaluate the function specified
by the formula in the  plot. Default: 50</p>
</td></tr>
<tr><td><code id="surface_plot_+3A_type">type</code></td>
<td>
<p>Plot type: <code>"surface"</code>,  <code>"contour"</code>, <code>"both"</code>, or <code>"heatmap"</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
interactive_plot(
    sin(fred*ginger) ~ fred + ginger,
    domain(fred=range(0,pi),
           ginger = range(0, pi)),
    type = "both")

## End(Not run)

</code></pre>

<hr>
<h2 id='symbolicD'>Symbolic Derivatives</h2><span id='topic+symbolicD'></span>

<h3>Description</h3>

<p>Constructs symbolic derivatives of some mathematical expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolicD(tilde, ..., .order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbolicD_+3A_tilde">tilde</code></td>
<td>
<p>a tilde expression with the function call on the left side and the w.r.t. variables
on the right side.</p>
</td></tr>
<tr><td><code id="symbolicD_+3A_...">...</code></td>
<td>
<p>additional parameters, typically default values for mathematical parameters</p>
</td></tr>
<tr><td><code id="symbolicD_+3A_.order">.order</code></td>
<td>
<p>a number specifying the order of a derivative with respect to a single variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the Derivs package for constructing the derivative
The <code>.order</code> argument is just for convenience when programming
high-order derivatives, e.g. the 5th derivative w.r.t. one variable.
</p>
<p>When re-assigning default values for arguments in a function
being called, as in <code>D(dnorm(x, mean=3) ~ x)</code>, you will get a
numerical derivative even when the analytic form is known. To avoid
this (when possible) use <code>D(dnorm(x) ~ x, mean=3)</code>
</p>


<h3>Value</h3>

<p>a function implementing the derivative
</p>


<h3>Author(s)</h3>

<p>Daniel Kaplan (<a href="mailto:kaplan@macalester.edu">kaplan@macalester.edu</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D">D</a></code>, <code><a href="#topic+numD">numD</a></code>, <code>makeFun</code>, <code><a href="#topic+antiD">antiD</a></code>, <code><a href="#topic+plotFun">plotFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symbolicD( a*x^2 ~ x)
symbolicD( a*x^2 ~ x&amp;x)
symbolicD( a*sin(x)~x, .order=4)
symbolicD( a*x^2*y+b*y ~ x, a=10, b=100 )
symbolicD( dnorm(x, mn, sd) ~ x, mn=3, sd=2)
</code></pre>

<hr>
<h2 id='traj_plot'>Plots a trajectory</h2><span id='topic+traj_plot'></span>

<h3>Description</h3>

<p>This function handles trajectories can stem from either of two sources:
</p>

<ol>
<li><p> A parametric description of a curve, such as <code>sin(t) ~ cos(t)</code>, along with a
domain in t.
</p>
</li>
<li><p> The solution to an ordinary differential equation as produce by <code>integrateODE()</code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>traj_plot(..., npts = 500, nt = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traj_plot_+3A_...">...</code></td>
<td>
<p>Handles the first several objects which are, in this order
- tilde: a two sided tilde expression
- soln: optionally, a solution object such as from <code>integrateODE()</code>, or instead
- domain: a domain object, e.g. <code>domain(t=0:10)</code></p>
</td></tr>
<tr><td><code id="traj_plot_+3A_npts">npts</code></td>
<td>
<p>number of plotted points (default: 500)</p>
</td></tr>
<tr><td><code id="traj_plot_+3A_nt">nt</code></td>
<td>
<p>number of tick marks to use in a trajectory plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tilde expression is the critical part
</p>


<h3>Examples</h3>

<pre><code class='language-R'>traj_plot(2*x + 3 ~ sin(x), domain(x=0:10))
PPdyn &lt;- makeODE(dR ~  0.3*R - 0.03*R*F, dF ~ -0.3*F + 0.0003*R*F)
Soln &lt;- integrateODE(PPdyn, domain(t=0:20), R=1200, F=8)
traj_plot(R(t) ~ F(t), Soln, nt=10)
traj_plot(R(t)*F(t) ~ t, Soln, nt=0)

</code></pre>

<hr>
<h2 id='traj_plot_3D'>Simple 3D plot of a trajectory</h2><span id='topic+traj_plot_3D'></span>

<h3>Description</h3>

<p>Takes a trajectory with three state variables as produced by <code>integrateODE()</code>
and plots out in a 3-dimensional perspective plot, which can be rotated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traj_plot_3D(x, y, z, soln, domain = NULL, npts = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traj_plot_3D_+3A_x">x</code></td>
<td>
<p>Name of one of the state variables to be plotted.</p>
</td></tr>
<tr><td><code id="traj_plot_3D_+3A_y">y</code></td>
<td>
<p>Similar to <code>x</code></p>
</td></tr>
<tr><td><code id="traj_plot_3D_+3A_z">z</code></td>
<td>
<p>Similar to <code>y</code> and <code>x</code></p>
</td></tr>
<tr><td><code id="traj_plot_3D_+3A_soln">soln</code></td>
<td>
<p>Solution output from <code>integrateODE()</code></p>
</td></tr>
<tr><td><code id="traj_plot_3D_+3A_domain">domain</code></td>
<td>
<p>Optional list like <code>domain=domain(t=c(0,100))</code>. By default, this
will be inferred from <code>soln</code></p>
</td></tr>
<tr><td><code id="traj_plot_3D_+3A_npts">npts</code></td>
<td>
<p>Number of points at which to evaluate the solution.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Lorenz &lt;- makeODE(dx ~ sigma*(y-x), dy ~(x*(rho-z) - y), dz ~ (x*y - beta*z), 
                  rho=28, sigma=10, beta = 8/3)
T1 &lt;- integrateODE(Lorenz, domain(t=0:50), x=-5, y=-7, z=19.4)
traj_plot_3D(x, y, z, T1, npts=5000)
</code></pre>

<hr>
<h2 id='UK_GDP'>Gross Domestic Product of the United Kingdom over a millenium</h2><span id='topic+UK_GDP'></span>

<h3>Description</h3>

<p>An estimate of the real GDP of the United Kingdom over about 7 centuries. &quot;Real&quot;
means adjusted for inflation. Take such estimates with a large amount of salt, since
pre-industrial era data is very limited and because the components of GDP change substantially
over a few decades, let alone a few centuries. Also, the name <code>UK_GDP</code> is anachronistic,
since for most of the record is before the UK was created as a political entity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(UK_GDP)
</code></pre>


<h3>Format</h3>

<p>A data frame with 747 rows
</p>

<ul>
<li> <p><code>year</code> Which year the estimate is for.
</p>
</li>
<li> <p><code>GDP</code> <em>per capita</em> Gross domestic product in GBP (pounds)
</p>
</li></ul>


<hr>
<h2 id='unbound'>Identifying unbound inputs to a function</h2><span id='topic+unbound'></span><span id='topic+bind_params'></span>

<h3>Description</h3>

<p><code>unbound()</code> finds if there are any unbound parameters in a function. This can be
useful for checking before handing a function over to a numerical routine.
<code>bind_params()</code> lets you add parameter bindings or override existing ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbound(f)

bind_params(f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbound_+3A_f">f</code></td>
<td>
<p>a function (not a tilde expr.)</p>
</td></tr>
<tr><td><code id="unbound_+3A_...">...</code></td>
<td>
<p>bindings for parameters</p>
</td></tr>
</table>

<hr>
<h2 id='US_income'>Income distribution data from the US in 2009</h2><span id='topic+US_income'></span>

<h3>Description</h3>

<p>Data such as these are used to study income inequality. One measure of
this is the &quot;Gini coefficient,&quot; which can be estimated from a Lorenz
function fitted to such data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>US_income
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 6 rows and 2 columns.
</p>


<h3>Source</h3>

<p>La Haye and Zizler (2021) &quot;The Lorenz Curve in the Classroom&quot;, <em>The American Statistician</em>, 75(2):217-225]
</p>
<p>Variables:
</p>

<ul>
<li> <p><code>income</code> The fraction of total household income that goes to the corresponding
poorest fraction of the population.
</p>
</li>
<li> <p><code>pop</code> The fraction of the population whose aggregated income is reported
as the <code>income</code> value.
</p>
</li></ul>


<hr>
<h2 id='vector_arg'>convert a function with separate arguments
into one with a single vector argument
For use with optim.</h2><span id='topic+vector_arg'></span>

<h3>Description</h3>

<p>convert a function with separate arguments
into one with a single vector argument
For use with optim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_arg(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector_arg_+3A_f">f</code></td>
<td>
<p>a function with multiple arguments</p>
</td></tr>
</table>

<hr>
<h2 id='vectors'>Utilities for vector calculations</h2><span id='topic+vectors'></span><span id='topic++25dot+25'></span><span id='topic++25onto+25'></span><span id='topic++25perp+25'></span><span id='topic+normalize'></span><span id='topic+as_magnitude'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;%dot%&#8288;</code>, <code style="white-space: pre;">&#8288;%onto%&#8288;</code>, and <code style="white-space: pre;">&#8288;%perp%&#8288;</code> are infix operators.
The left-hand argument is a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u %dot% b

b %onto% A

b %perp% A

normalize(A)

as_magnitude(A, metric = c("2", "O", "I", "F", "M"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectors_+3A_u">u</code></td>
<td>
<p>a row vector, but a column vector is acceptable too</p>
</td></tr>
<tr><td><code id="vectors_+3A_b">b</code></td>
<td>
<p>a column vector</p>
</td></tr>
<tr><td><code id="vectors_+3A_a">A</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="vectors_+3A_metric">metric</code></td>
<td>
<p>metric to use for matrix norm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convenience functions for basic operations relating to vector projection. These use
the <em>MOSAIC Calc</em> conventions that require vectors to be one column matrices.
</p>


<h3>Value</h3>

<p>either a number (for <code style="white-space: pre;">&#8288;%dot%&#8288;</code>) or a vector
</p>

<hr>
<h2 id='Vowel_ee'>Recordings of vowel sounds</h2><span id='topic+Vowel_ee'></span><span id='topic+Vowel_oh'></span><span id='topic+Oh_sound'></span><span id='topic+Ee_sound'></span>

<h3>Description</h3>

<p>&quot;Oh&quot; refers to &quot;o&quot; as in &quot;stone.&quot; &quot;Ee&quot; to &quot;eel&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vowel_ee

Vowel_oh

Oh_sound

Ee_sound
</code></pre>


<h3>Format</h3>

<p>Data frames with two columns
</p>

<ul>
<li> <p><code>y</code>: The instantaneous amplitude of the vowel sound.
</p>
</li>
<li> <p><code>t</code>: Time (seconds)
</p>
</li></ul>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 780 rows and 2 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 7192 rows and 2 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 10194 rows and 2 columns.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>Oh_sound</code> and <code>Ee_sound</code> contain the complete utterances.
</p>
</li>
<li> <p><code>Vowel_ee</code> and <code>Vowel_oh</code> are snippets of about 0.04 seconds duration.
</p>
</li></ul>


<hr>
<h2 id='Zeros'>Finds zeros of a function within a specified domain</h2><span id='topic+Zeros'></span>

<h3>Description</h3>

<p>Finds zeros of a function within a specified domain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zeros(tilde, domain = NULL, ..., nsegs = 131)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Zeros_+3A_tilde">tilde</code></td>
<td>
<p>tilde expression defining a function, suitable
for <code>makeFun()</code></p>
</td></tr>
<tr><td><code id="Zeros_+3A_domain">domain</code></td>
<td>
<p>specification of domain, as in <code>slice_plot()</code></p>
</td></tr>
<tr><td><code id="Zeros_+3A_...">...</code></td>
<td>
<p>Assignments to parameters</p>
</td></tr>
<tr><td><code id="Zeros_+3A_nsegs">nsegs</code></td>
<td>
<p>Subdivide the domain into this many segments, looking for a zero
in each of those segments. This helps to find multiple zeros.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns. The first has the name
of the input in the tilde expression, and gives the values
for that input at which the function is approximately zero.
The second column, <code>.output.</code> gives
the actual value of the function at the inputs in the first column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Zeros(a*x + b ~ x, a=1, b=2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
