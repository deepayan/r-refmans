<!DOCTYPE html><html><head><title>Help for package adestr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adestr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adestr'><p>adestr</p></a></li>
<li><a href='#analyze'><p>Analyze a dataset</p></a></li>
<li><a href='#c+2CEstimatorScoreResult-method'><p>Combine EstimatoreScoreResult objects into a list</p></a></li>
<li><a href='#c+2CEstimatorScoreResultList-method'><p>Combine EstimatoreScoreResult objects into a list</p></a></li>
<li><a href='#c2_extrapol'><p>Calculate the second-stage critical value for a design with cached spline parameters</p></a></li>
<li><a href='#EstimatorScore-class'><p>Performance scores for point and interval estimators</p></a></li>
<li><a href='#evaluate_estimator'><p>Evaluate performance characteristics of an estimator</p></a></li>
<li><a href='#evaluate_estimator-methods'><p>Evaluate performance characteristics of an estimator</p></a></li>
<li><a href='#evaluate_scenarios_parallel'><p>Evaluate different scenarios in parallel</p></a></li>
<li><a href='#get_example_design'><p>Generate an exemplary adaptive design</p></a></li>
<li><a href='#get_example_statistics'><p>Generate a list of estimators and p-values to use in examples</p></a></li>
<li><a href='#get_stagewise_estimators'><p>Conditional representations of an estimator or p-value</p></a></li>
<li><a href='#get_statistics_from_paper'><p>Generate the list of estimators and p-values that were used in the paper</p></a></li>
<li><a href='#IntervalEstimator-class'><p>Interval estimators</p></a></li>
<li><a href='#n2_extrapol'><p>Calculate the second-stage sample size for a design with cached spline parameters</p></a></li>
<li><a href='#NormalPrior'><p>Normal prior distribution for the parameter mu</p></a></li>
<li><a href='#plot_p'><p>Plot p-values and implied rejection boundaries</p></a></li>
<li><a href='#plot+2CEstimatorScoreResult-method'><p>Plot performance scores for point and interval estimators</p></a></li>
<li><a href='#plot+2CEstimatorScoreResultList-method'><p>Plot performance scores for point and interval estimators</p></a></li>
<li><a href='#plot+2Clist-method'><p>Plot performance scores for point and interval estimators</p></a></li>
<li><a href='#PointEstimator-class'><p>Point estimators</p></a></li>
<li><a href='#PValue-class'><p>P-values</p></a></li>
<li><a href='#Statistic-class'><p>Statistics and Estimators of the adestr package</p></a></li>
<li><a href='#TwoStageDesignWithCache'><p>TwoStageDesignWithCache constructor function</p></a></li>
<li><a href='#UniformPrior'><p>Uniform prior distribution for the parameter mu</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation in Optimal Adaptive Two-Stage Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Methods to evaluate the performance characteristics of
  various point and interval estimators for optimal adaptive two-stage designs as described
  in Meis et al. (2024) &lt;<a href="https://doi.org/10.1002%2Fsim.10020">doi:10.1002/sim.10020</a>&gt;.
  Specifically, this package is written to work with trial designs created by the 'adoptr' package
  (Kunzmann et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v098.i09">doi:10.18637/jss.v098.i09</a>&gt;; Pilz et al. (2021) &lt;<a href="https://doi.org/10.1002%2Fsim.8953">doi:10.1002/sim.8953</a>&gt;)).
  Apart from the a priori evaluation of performance characteristics, this package also allows for the
  evaluation of the implemented estimators on real datasets, and it implements methods
  to calculate p-values.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>This package contains a modified version of the monotonic
spline functions from the 'stats' package. Specifically, the
code is containted in the files 'R/fastmonoHFC.R',
'src/fastmonoHFC.c', 'src/modreg.h' and 'src/monoSpl.c'. The R
Core team and Martin Maechler are the copyright holders of the
original code. Jan Meis is the copyright holder of everything
else.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), adoptr</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, grDevices, cubature, ggplot2, ggpubr, scales,
latex2exp, forcats, future.apply, progressr, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat (&ge; 3.0.0), microbenchmark</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'adestr_package.R' 'twostagedesign_with_cache.R' 'analyze.R'
'estimators.R' 'densities.R' 'evaluate_estimator.R'
'fastmonoHFC.R' 'fisher_information.R' 'hcubature.R'
'helper_functions.R' 'integrate_over_sample_space.R'
'reference_implementation.R' 'mle_distribution.R'
'mlmse_score.R' 'n2c2_helpers.R' 'plot.R' 'priors.R' 'print.R'</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jan-imbi.github.io/adestr/">https://jan-imbi.github.io/adestr/</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-12 13:14:06 UTC; pn425</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Meis <a href="https://orcid.org/0000-0001-5407-7220"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cph] (Original author of monoSpl.c (from the 'stats' package).)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Meis &lt;meis@imbi.uni-heidelberg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-12 13:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='adestr'>adestr</h2><span id='topic+adestr'></span><span id='topic+adestr-package'></span>

<h3>Description</h3>

<p>Point estimates, confidence intervals, and p-values for optimal adaptive two-stage designs.
</p>


<h3>Details</h3>

<p>This package implements methods to <a href="#topic+evaluate_estimator">evaluate the performance characteristics</a> of
various <a href="#topic+PointEstimator">point</a> and <a href="#topic+IntervalEstimator">interval</a> estimators for optimal adaptive two-stage designs.
Specifically, this package is written to interface with trial designs created by the <code>adoptr</code> package
(Kunzmann et al. 2021; Pilz et al. 2021).
Apart from the a priori evaluation of performance characteristics, this package also allows for the
<a href="#topic+analyze">calculation of the values of the estimators</a> given real datasets, and it implements methods
to calculate <a href="#topic+PValue">p-values</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jan Meis <a href="mailto:meis@imbi.uni-heidelberg.de">meis@imbi.uni-heidelberg.de</a> (<a href="https://orcid.org/0000-0001-5407-7220">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Martin Maechler <a href="mailto:maechler@stat.math.ethz.ch">maechler@stat.math.ethz.ch</a> (<a href="https://orcid.org/0000-0002-8685-9910">ORCID</a>) (Original author of monoSpl.c (from the 'stats' package).) [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>Kunzmann K, Pilz M, Herrmann C, Rauch G, Kieser M (2021).
&ldquo;The adoptr package: Adaptive Optimal Designs for Clinical Trials in R.&rdquo;
<em>Journal of Statistical Software</em>, <b>98</b>(9), 1â€“21.
<a href="https://doi.org/10.18637/jss.v098.i09">doi:10.18637/jss.v098.i09</a>.<br /><br /> Pilz M, Kunzmann K, Herrmann C, Rauch G, Kieser M (2021).
&ldquo;Optimal planning of adaptive two-stage designs.&rdquo;
<em>Statistics in Medicine</em>, <b>40</b>(13), 3196-3213.
<a href="https://doi.org/10.1002/sim.8953">doi:10.1002/sim.8953</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code>
</p>
<p><code><a href="#topic+analyze">analyze</a></code>
</p>
<p><code><a href="#topic+Statistic">Statistic</a></code> <code><a href="#topic+PointEstimator">PointEstimator</a></code> <code><a href="#topic+IntervalEstimator">IntervalEstimator</a></code> <code><a href="#topic+PValue">PValue</a></code>
</p>
<p><code><a href="#topic+plot+2CEstimatorScoreResultList-method">plot</a></code> <code><a href="#topic+plot_p">plot_p</a></code>
</p>
<p><a href="https://jan-imbi.github.io/adestr/">https://jan-imbi.github.io/adestr/</a>
</p>

<hr>
<h2 id='analyze'>Analyze a dataset</h2><span id='topic+analyze'></span><span id='topic+analyze+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>The <code>analyze</code> function can be used calculate the values of a list of
<a href="#topic+PointEstimator">point estimators</a>,
<a href="#topic+ConfidenceInterval">confidence intervals</a>,
and <a href="#topic+PValue">p-values</a> for a given dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze(
  data,
  statistics = list(),
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'data.frame'
analyze(
  data,
  statistics = list(),
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to be analyzed.</p>
</td></tr>
<tr><td><code id="analyze_+3A_statistics">statistics</code></td>
<td>
<p>a list of objects of class <code><a href="#topic+PointEstimator">PointEstimator</a></code>,
<code><a href="#topic+ConfidenceInterval">ConfidenceInterval</a></code> or
<code><a href="#topic+PValue">PValue</a></code>.</p>
</td></tr>
<tr><td><code id="analyze_+3A_data_distribution">data_distribution</code></td>
<td>
<p>object of class <code>Normal</code> or <code>Student</code>.</p>
</td></tr>
<tr><td><code id="analyze_+3A_use_full_twoarm_sampling_distribution">use_full_twoarm_sampling_distribution</code></td>
<td>
<p>logical indicating whether this estimator is intended to be used
with the full sampling distribution in a two-armed trial.</p>
</td></tr>
<tr><td><code id="analyze_+3A_design">design</code></td>
<td>
<p>object of class <code>TwoStageDesign</code>.</p>
</td></tr>
<tr><td><code id="analyze_+3A_sigma">sigma</code></td>
<td>
<p>assumed standard deviation.</p>
</td></tr>
<tr><td><code id="analyze_+3A_exact">exact</code></td>
<td>
<p>logical indicating usage of exact n2 function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in <code><a href="#topic+adestr">adestr</a></code>, statistics are codes as functions of the
stage-wise sample means (and stage-wise sample variances if data_distribution is
<code><a href="adoptr.html#topic+Student">Student</a></code>). In a first-step, the data is summarized to produce these
parameters. Then, the list of statistics are evaluated at the values of these parameters.
</p>
<p>The output of the <code>analyze</code> function also displays information on the hypothesis
test and the interim decision. If the <code><a href="#topic+Statistic-class">statistics</a></code> list is empty, this will
be the only information displayed.
</p>


<h3>Value</h3>

<p><code>Results</code> object containing the values of the statistics
when applied to data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
dat &lt;- data.frame(
  endpoint = c(rnorm(28, 0.3)),
  stage = rep(1, 28)
)
analyze(data = dat,
        statistics = list(),
        data_distribution = Normal(FALSE),
        design = get_example_design(),
        sigma = 1)

# The results suggest recruiting 32 patients for the second stage
dat &lt;- rbind(
  dat,
  data.frame(
    endpoint = rnorm(32, mean = 0.3),
    stage = rep(2, 32)))
analyze(data = dat,
        statistics = get_example_statistics(),
        data_distribution = Normal(FALSE),
        design = get_example_design(),
        sigma = 1)
</code></pre>

<hr>
<h2 id='c+2CEstimatorScoreResult-method'>Combine EstimatoreScoreResult objects into a list</h2><span id='topic+c+2CEstimatorScoreResult-method'></span>

<h3>Description</h3>

<p>Creates an object of class EstimatoreScoreResultList,
which is a basically list with the respective
EstimatoreScoreResult objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EstimatorScoreResult'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c+2B2CEstimatorScoreResult-method_+3A_x">x</code></td>
<td>
<p>an object of class EstimatorScoreResult.</p>
</td></tr>
<tr><td><code id="c+2B2CEstimatorScoreResult-method_+3A_...">...</code></td>
<td>
<p>additional arguments passed along to the <code><a href="base.html#topic+list">list</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class EstimatoreScoreResultList.
</p>

<hr>
<h2 id='c+2CEstimatorScoreResultList-method'>Combine EstimatoreScoreResult objects into a list</h2><span id='topic+c+2CEstimatorScoreResultList-method'></span>

<h3>Description</h3>

<p>Creates an object of class EstimatoreScoreResultList,
which is a basically list with the respective
EstimatoreScoreResult objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EstimatorScoreResultList'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c+2B2CEstimatorScoreResultList-method_+3A_x">x</code></td>
<td>
<p>an object of class EstimatorScoreResult.</p>
</td></tr>
<tr><td><code id="c+2B2CEstimatorScoreResultList-method_+3A_...">...</code></td>
<td>
<p>additional arguments passed along to the <code><a href="base.html#topic+list">list</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class EstimatoreScoreResultList.
</p>

<hr>
<h2 id='c2_extrapol'>Calculate the second-stage critical value for a design with cached spline parameters</h2><span id='topic+c2_extrapol'></span>

<h3>Description</h3>

<p>Also extrapolates results for values outside of [c1f, c1e].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2_extrapol(design, x1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c2_extrapol_+3A_design">design</code></td>
<td>
<p>an object of class <code><a href="#topic+TwoStageDesignWithCache">TwoStageDesignWithCache</a></code>.</p>
</td></tr>
<tr><td><code id="c2_extrapol_+3A_x1">x1</code></td>
<td>
<p>first-stage test statistic</p>
</td></tr>
</table>

<hr>
<h2 id='EstimatorScore-class'>Performance scores for point and interval estimators</h2><span id='topic+EstimatorScore-class'></span><span id='topic+EstimatorScore'></span><span id='topic+Expectation'></span><span id='topic+Bias'></span><span id='topic+Variance'></span><span id='topic+MSE'></span><span id='topic+OverestimationProbability'></span><span id='topic+Coverage'></span><span id='topic+SoftCoverage'></span><span id='topic+Width'></span><span id='topic+TestAgreement'></span><span id='topic+Centrality'></span>

<h3>Description</h3>

<p>These classes encode various metrics which can be used to evaluate
the performance characteristics of point and interval estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Expectation()

Bias()

Variance()

MSE()

OverestimationProbability()

Coverage()

SoftCoverage(shrinkage = 1)

Width()

TestAgreement()

Centrality(interval = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstimatorScore-class_+3A_shrinkage">shrinkage</code></td>
<td>
<p>shrinkage factor for bump function.</p>
</td></tr>
<tr><td><code id="EstimatorScore-class_+3A_interval">interval</code></td>
<td>
<p>confidence interval with respect to which centrality of a point
estimator should be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>EstimatorScore</code>. This class signals that
an object can be used with the <code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>label</code></dt><dd><p>name of the performance score. Used in printing methods.</p>
</dd>
</dl>


<h3>Details on the implemented estimators</h3>

<p>In the following, precise definitions of the performance scores implemented
in <code><a href="#topic+adestr">adestr</a></code>
are given. To this end,
let <code class="reqn">\hat{\mu}</code> denote a point estimator, (<code class="reqn">\hat{l}</code>, <code class="reqn">\hat{u}</code>)
an interval estimator, denote the expected value of a random variable
by <code class="reqn">\mathbb{E}</code>, the probability of an event by <code class="reqn">P</code>,
and let <code class="reqn">\mu</code> be the real value of the underlying
parameter to be estimated.
</p>


<h4>Scores for point estimators (<code>PointEstimatorScore</code>):</h4>


<ul>
<li> <p><code>Expectation()</code>: <code class="reqn">\mathbb{E}[\hat{\mu}]</code>
</p>
</li>
<li> <p><code>Bias()</code>: <code class="reqn">\mathbb{E}[\hat{\mu} - \mu]</code>
</p>
</li>
<li> <p><code>Variance()</code>: <code class="reqn">\mathbb{E}[(\hat{\mu} - \mathbb{E}[\hat{\mu}])^2]</code>
</p>
</li>
<li> <p><code>MSE()</code>: <code class="reqn">\mathbb{E}[(\hat{\mu} - mu)^2]</code>
</p>
</li>
<li> <p><code>OverestimationProbability()</code>: <code class="reqn">P(\hat{\mu} &gt; \mu)</code>
</p>
</li>
<li> <p><code>Centrality(interval)</code>: <code class="reqn">\mathbb{E}[(\hat{\mu} - \hat{l}) + (\hat{\mu} - \hat{u}]</code>
</p>
</li></ul>




<h4>Scores for confidence intervals (<code>IntervalEstimatorScore</code>):</h4>


<ul>
<li> <p><code>Coverage()</code>: <code class="reqn">P(\hat{l} \leq \mu \leq \hat{u})</code>
</p>
</li>
<li> <p><code>Width()</code>: <code class="reqn">\mathbb{E}[\hat{u} - \hat{l}]</code>
</p>
</li>
<li> <p><code>TestAgreement()</code>: <code class="reqn">P\left( \left(\{0 &lt; \hat{l} \text{ and } (c_{1, e} &lt; Z_1 \text{ or } c_{2}(Z_1) &lt; Z_2 ) \right) \text{ or } \left(\{\hat{l} \leq 0  \text{ and } ( Z_1 &lt; c_{1, f} \text{ or } Z_2 \leq c_{2}(Z_1))\}\right)\right)</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evaluate_estimator(
  score = MSE(),
  estimator = SampleMean(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu = c(0, 0.3, 0.6),
  sigma = 1,
  exact = FALSE
)

evaluate_estimator(
  score = Coverage(),
  estimator = StagewiseCombinationFunctionOrderingCI(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu = c(0, 0.3),
  sigma = 1,
  exact = FALSE
)

</code></pre>

<hr>
<h2 id='evaluate_estimator'>Evaluate performance characteristics of an estimator</h2><span id='topic+evaluate_estimator'></span>

<h3>Description</h3>

<p>This function evaluates an <code><a href="#topic+EstimatorScore">EstimatorScore</a></code> for a <code><a href="#topic+PointEstimator">PointEstimator</a></code>
or and <code><a href="#topic+IntervalEstimator">IntervalEstimator</a></code> by integrating over the sampling distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_estimator_+3A_score">score</code></td>
<td>
<p>performance measure to evaluate.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_estimator">estimator</code></td>
<td>
<p>object of class <code>PointEstimator</code>, <code>IntervalEstimator</code> or <code>PValue</code>.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_data_distribution">data_distribution</code></td>
<td>
<p>object of class <code>Normal</code> or <code>Student</code>.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_use_full_twoarm_sampling_distribution">use_full_twoarm_sampling_distribution</code></td>
<td>
<p>logical indicating whether this estimator is intended to be used
with the full sampling distribution in a two-armed trial.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_design">design</code></td>
<td>
<p>object of class <code>TwoStageDesign</code>.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_true_parameter">true_parameter</code></td>
<td>
<p>true value of the parameter (used e.g. when evaluating bias).</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_mu">mu</code></td>
<td>
<p>expected value of the underlying normal distribution.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_sigma">sigma</code></td>
<td>
<p>assumed standard deviation.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_tol">tol</code></td>
<td>
<p>relative tolerance.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_maxeval">maxEval</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_abserror">absError</code></td>
<td>
<p>absolute tolerance.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_exact">exact</code></td>
<td>
<p>logical indicating usage of exact n2 function.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_early_futility_part">early_futility_part</code></td>
<td>
<p>include early futility part of integral.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_continuation_part">continuation_part</code></td>
<td>
<p>include continuation part of integral.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_early_efficacy_part">early_efficacy_part</code></td>
<td>
<p>include early efficacy part of integral.</p>
</td></tr>
<tr><td><code id="evaluate_estimator_+3A_conditional_integral">conditional_integral</code></td>
<td>
<p>treat integral as a conditional integral.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>General</h4>

<p>First, a functional representation of the integrand is created by combining information
from the <code><a href="#topic+EstimatorScore">EstimatorScore</a></code> object (<code>score</code>) and the <code><a href="#topic+PointEstimator">PointEstimator</a></code> or
<code><a href="#topic+IntervalEstimator">IntervalEstimator</a></code> object (<code>estimator</code>).
The sampling distribution of a design is determined by the <code>TwoStageDesign</code> object
(<code>design</code>) and the <code>DataDistribution</code> object (<code>data_distribution</code>),
as well as the assumed parameters <code class="reqn">\mu</code> (mu) and <code class="reqn">\sigma</code> (sigma).
The other parameters control various details of the integration problem.
</p>



<h4>Other parameters</h4>

<p>For a two-armed <code>data_distribution</code>,
if <code>use_full_twoarm_sampling_distribution</code> is <code>TRUE</code>, the sample means
for both groups are integrated independently. If <code>use_full_twoarm_sampling_distribution</code>
is <code>FALSE</code>, only the difference in sample means is integrated.
</p>
<p><code>true_parameter</code> controls which parameters is supposed to be estimated. This
is usually <code>mu</code>, but could be set to <code>sigma</code> if one is interested in
estimating the standard deviation.
</p>
<p>If the parameter <code>exact</code> is set to <code>FALSE</code>
(the default), the continuous version of the second-stage sample-size function <code>n2</code>
is used. Otherwise, an integer valued version of that function will be used,
though this is considerably slower.
</p>
<p>The parameters <code>early_futility_part</code>,
<code>continuation_part</code> and <code>early_efficacy_part</code> control which parts
of the sample-space should be integrated over (all default to <code>TRUE</code>).
They can be used in conjunction with the parameter <code>conditional_integral</code>,
which enables the calculation of the expected value of performance score conditional
on reaching any of the selected integration regions.
</p>
<p>Lastly, the paramters
<code>tol</code>, <code>maxEval</code>, and <code>absError</code> control the integration accuracy.
They are handed down to the <code><a href="cubature.html#topic+hcubature">hcubature</a></code> function.
</p>



<h3>Value</h3>

<p>an object of class <code>EstimatorScoreResult</code>
containing the values of the evaluated <code><a href="#topic+EstimatorScore">EstimatorScore</a></code> and
information about the setting for which they were calculated
(e.g. the <code>estimator</code>, <code>data_distribution</code>, <code>design</code>, <code>mu</code>, and <code>sigma</code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+EstimatorScore">EstimatorScore</a>
</p>
<p><a href="#topic+PointEstimator">PointEstimator</a> <a href="#topic+IntervalEstimator">IntervalEstimator</a>
</p>
<p><a href="#topic+plot+2CEstimatorScoreResultList-method">plot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evaluate_estimator(
  score = MSE(),
  estimator = SampleMean(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu = c(0, 0.3, 0.6),
  sigma = 1,
  exact = FALSE
)

evaluate_estimator(
  score = Coverage(),
  estimator = StagewiseCombinationFunctionOrderingCI(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu = c(0, 0.3),
  sigma = 1,
  exact = FALSE
)

</code></pre>

<hr>
<h2 id='evaluate_estimator-methods'>Evaluate performance characteristics of an estimator</h2><span id='topic+evaluate_estimator-methods'></span><span id='topic+evaluate_estimator+2CPointEstimatorScore+2CIntervalEstimator-method'></span><span id='topic+evaluate_estimator+2CIntervalEstimatorScore+2CPointEstimator-method'></span><span id='topic+evaluate_estimator+2Clist+2CEstimator-method'></span><span id='topic+evaluate_estimator+2CExpectation+2CPointEstimator-method'></span><span id='topic+evaluate_estimator+2CBias+2CPointEstimator-method'></span><span id='topic+evaluate_estimator+2CVariance+2CPointEstimator-method'></span><span id='topic+evaluate_estimator+2CMSE+2CPointEstimator-method'></span><span id='topic+evaluate_estimator+2COverestimationProbability+2CPointEstimator-method'></span><span id='topic+evaluate_estimator+2CCoverage+2CIntervalEstimator-method'></span><span id='topic+evaluate_estimator+2CSoftCoverage+2CIntervalEstimator-method'></span><span id='topic+evaluate_estimator+2CWidth+2CIntervalEstimator-method'></span><span id='topic+evaluate_estimator+2CTestAgreement+2CIntervalEstimator-method'></span><span id='topic+evaluate_estimator+2CTestAgreement+2CPValue-method'></span><span id='topic+evaluate_estimator+2CCentrality+2CPointEstimator-method'></span>

<h3>Description</h3>

<p>This function evaluates an <code><a href="#topic+EstimatorScore">EstimatorScore</a></code> for a <code><a href="#topic+PointEstimator">PointEstimator</a></code>
or and <code><a href="#topic+IntervalEstimator">IntervalEstimator</a></code> by integrating over the sampling distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PointEstimatorScore,IntervalEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'IntervalEstimatorScore,PointEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'list,Estimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'Expectation,PointEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'Bias,PointEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'Variance,PointEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'MSE,PointEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'OverestimationProbability,PointEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'Coverage,IntervalEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'SoftCoverage,IntervalEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'Width,IntervalEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'TestAgreement,IntervalEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'TestAgreement,PValue'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)

## S4 method for signature 'Centrality,PointEstimator'
evaluate_estimator(
  score,
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  true_parameter = mu,
  mu,
  sigma,
  tol = getOption("adestr_tol_outer", default = .adestr_options[["adestr_tol_outer"]]),
  maxEval = getOption("adestr_maxEval_outer", default =
    .adestr_options[["adestr_maxEval_outer"]]),
  absError = getOption("adestr_absError_outer", default =
    .adestr_options[["adestr_absError_outer"]]),
  exact = FALSE,
  early_futility_part = TRUE,
  continuation_part = TRUE,
  early_efficacy_part = TRUE,
  conditional_integral = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_estimator-methods_+3A_score">score</code></td>
<td>
<p>performance measure to evaluate.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_estimator">estimator</code></td>
<td>
<p>object of class <code>PointEstimator</code>, <code>IntervalEstimator</code> or <code>PValue</code>.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_data_distribution">data_distribution</code></td>
<td>
<p>object of class <code>Normal</code> or <code>Student</code>.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_use_full_twoarm_sampling_distribution">use_full_twoarm_sampling_distribution</code></td>
<td>
<p>logical indicating whether this estimator is intended to be used
with the full sampling distribution in a two-armed trial.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_design">design</code></td>
<td>
<p>object of class <code>TwoStageDesign</code>.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_true_parameter">true_parameter</code></td>
<td>
<p>true value of the parameter (used e.g. when evaluating bias).</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_mu">mu</code></td>
<td>
<p>expected value of the underlying normal distribution.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_sigma">sigma</code></td>
<td>
<p>assumed standard deviation.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_tol">tol</code></td>
<td>
<p>relative tolerance.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_maxeval">maxEval</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_abserror">absError</code></td>
<td>
<p>absolute tolerance.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_exact">exact</code></td>
<td>
<p>logical indicating usage of exact n2 function.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_early_futility_part">early_futility_part</code></td>
<td>
<p>include early futility part of integral.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_continuation_part">continuation_part</code></td>
<td>
<p>include continuation part of integral.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_early_efficacy_part">early_efficacy_part</code></td>
<td>
<p>include early efficacy part of integral.</p>
</td></tr>
<tr><td><code id="evaluate_estimator-methods_+3A_conditional_integral">conditional_integral</code></td>
<td>
<p>treat integral as a conditional integral.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>General</h4>

<p>First, a functional representation of the integrand is created by combining information
from the <code><a href="#topic+EstimatorScore">EstimatorScore</a></code> object (<code>score</code>) and the <code><a href="#topic+PointEstimator">PointEstimator</a></code> or
<code><a href="#topic+IntervalEstimator">IntervalEstimator</a></code> object (<code>estimator</code>).
The sampling distribution of a design is determined by the <code>TwoStageDesign</code> object
(<code>design</code>) and the <code>DataDistribution</code> object (<code>data_distribution</code>),
as well as the assumed parameters <code class="reqn">\mu</code> (mu) and <code class="reqn">\sigma</code> (sigma).
The other parameters control various details of the integration problem.
</p>



<h4>Other parameters</h4>

<p>For a two-armed <code>data_distribution</code>,
if <code>use_full_twoarm_sampling_distribution</code> is <code>TRUE</code>, the sample means
for both groups are integrated independently. If <code>use_full_twoarm_sampling_distribution</code>
is <code>FALSE</code>, only the difference in sample means is integrated.
</p>
<p><code>true_parameter</code> controls which parameters is supposed to be estimated. This
is usually <code>mu</code>, but could be set to <code>sigma</code> if one is interested in
estimating the standard deviation.
</p>
<p>If the parameter <code>exact</code> is set to <code>FALSE</code>
(the default), the continuous version of the second-stage sample-size function <code>n2</code>
is used. Otherwise, an integer valued version of that function will be used,
though this is considerably slower.
</p>
<p>The parameters <code>early_futility_part</code>,
<code>continuation_part</code> and <code>early_efficacy_part</code> control which parts
of the sample-space should be integrated over (all default to <code>TRUE</code>).
They can be used in conjunction with the parameter <code>conditional_integral</code>,
which enables the calculation of the expected value of performance score conditional
on reaching any of the selected integration regions.
</p>
<p>Lastly, the paramters
<code>tol</code>, <code>maxEval</code>, and <code>absError</code> control the integration accuracy.
They are handed down to the <code><a href="cubature.html#topic+hcubature">hcubature</a></code> function.
</p>



<h3>Value</h3>

<p>an object of class <code>EstimatorScoreResult</code>
containing the values of the evaluated <code><a href="#topic+EstimatorScore">EstimatorScore</a></code> and
information about the setting for which they were calculated
(e.g. the <code>estimator</code>, <code>data_distribution</code>, <code>design</code>, <code>mu</code>, and <code>sigma</code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+EstimatorScore">EstimatorScore</a>
</p>
<p><a href="#topic+PointEstimator">PointEstimator</a> <a href="#topic+IntervalEstimator">IntervalEstimator</a>
</p>
<p><a href="#topic+plot+2CEstimatorScoreResultList-method">plot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evaluate_estimator(
  score = MSE(),
  estimator = SampleMean(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu = c(0, 0.3, 0.6),
  sigma = 1,
  exact = FALSE
)

evaluate_estimator(
  score = Coverage(),
  estimator = StagewiseCombinationFunctionOrderingCI(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu = c(0, 0.3),
  sigma = 1,
  exact = FALSE
)

</code></pre>

<hr>
<h2 id='evaluate_scenarios_parallel'>Evaluate different scenarios in parallel</h2><span id='topic+evaluate_scenarios_parallel'></span>

<h3>Description</h3>

<p>This function takes a list of lists of scores, a list of lists of estimators,
and lists lists of various other design parameters. Each possible combination
of the elements of the respective sublists is then used to create separate
scenarios.
These scenarios are than evaluated independelty of each other,
allowing for parallelization via the <code><a href="future.html#topic+future">future</a></code> framework. For each scenario,
one call to the <code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code> function is made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_scenarios_parallel(
  score_lists,
  estimator_lists,
  data_distribution_lists,
  use_full_twoarm_sampling_distribution_lists,
  design_lists,
  true_parameter_lists,
  mu_lists,
  sigma_lists,
  tol_lists,
  maxEval_lists,
  absError_lists,
  exact_lists,
  early_futility_part_lists,
  continuation_part_lists,
  early_efficacy_part_lists,
  conditional_integral_lists
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_scenarios_parallel_+3A_score_lists">score_lists</code></td>
<td>
<p>a list of lists of estimator scores.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_estimator_lists">estimator_lists</code></td>
<td>
<p>a list of lists of estimators.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_data_distribution_lists">data_distribution_lists</code></td>
<td>
<p>a list of lists of data distributions.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_use_full_twoarm_sampling_distribution_lists">use_full_twoarm_sampling_distribution_lists</code></td>
<td>
<p>a list of lists of use_full_twoarm_sampling_distribution_lists parameters.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_design_lists">design_lists</code></td>
<td>
<p>a list of lists of designs.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_true_parameter_lists">true_parameter_lists</code></td>
<td>
<p>a list of lists of true parameters.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_mu_lists">mu_lists</code></td>
<td>
<p>a list of lists of mu vectors.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_sigma_lists">sigma_lists</code></td>
<td>
<p>a list of lists of sigma values.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_tol_lists">tol_lists</code></td>
<td>
<p>a list of lists of relative tolerances.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_maxeval_lists">maxEval_lists</code></td>
<td>
<p>a list of lists of maxEval boundaries.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_abserror_lists">absError_lists</code></td>
<td>
<p>a list of lists of absError boundaries.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_exact_lists">exact_lists</code></td>
<td>
<p>a list of lists of 'exact' parameters.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_early_futility_part_lists">early_futility_part_lists</code></td>
<td>
<p>a list of lists of 'early_futility_part_lists' parameters.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_continuation_part_lists">continuation_part_lists</code></td>
<td>
<p>a list of lists of 'continuation_part_lists' parameters.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_early_efficacy_part_lists">early_efficacy_part_lists</code></td>
<td>
<p>a list of lists of 'early_efficacy_part_lists' parameters.</p>
</td></tr>
<tr><td><code id="evaluate_scenarios_parallel_+3A_conditional_integral_lists">conditional_integral_lists</code></td>
<td>
<p>a list of lists of 'conditional_integral_lists' parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Concretely, the cross product of
the first sublist of scores and the first sublist of estimators and the other parameters
is calculated. Then the cross product of the second sublist of scores, estimators
and other design parameters is calculated. All of these cross products together
make up the set of all scenarios. The combinations say the first sublist of scores
and the second sublist of estimators are not considered.
</p>


<h3>Value</h3>

<p>a list of data.frames containing the results for the respective scenarios.
</p>


<h3>See Also</h3>

<p>[evaluate_estimator]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;-evaluate_scenarios_parallel(
 score_lists = list(c(MSE(), OverestimationProbability())),
 estimator_lists =  list(c(SampleMean(), FirstStageSampleMean())),
 data_distribution_lists = list(c(Normal(FALSE), Normal(TRUE))),
 design_lists =  list(c(get_example_design())),
 mu_lists = list(c(-1, 0, 1)),
 sigma_lists = list(1)
)

</code></pre>

<hr>
<h2 id='get_example_design'>Generate an exemplary adaptive design</h2><span id='topic+get_example_design'></span>

<h3>Description</h3>

<p>The design was optimized to minimize the expected sample size
under the alternative hypothesis for a one-armed trial.
The boundaries are chosen to control the type I error at 0.025
for a normally distributed test statistic (i.e. known variance).
For an alternative hypothesis of mu=0.4, the overall power is 80%.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_example_design(two_armed = FALSE, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_example_design_+3A_two_armed">two_armed</code></td>
<td>
<p>(logical) determins whether the design is for one- or
two-armed trials.</p>
</td></tr>
<tr><td><code id="get_example_design_+3A_label">label</code></td>
<td>
<p>(optional) label to be assigned to the design.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an exemplary design of class <code>TwoStageDesign</code>. This object
contains information about the sample size recalculation rule <code>n2</code>, the
futility and efficacy boundaries <code>c1f</code> and <code>c1e</code> and the
second-stage rejection boundary <code>c2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_example_design()

</code></pre>

<hr>
<h2 id='get_example_statistics'>Generate a list of estimators and p-values to use in examples</h2><span id='topic+get_example_statistics'></span>

<h3>Description</h3>

<p>This function generates a list of objects of class <code><a href="#topic+PointEstimator">PointEstimator</a></code>,
<code><a href="#topic+IntervalEstimator">IntervalEstimator</a></code>s, and <code><a href="#topic+PValue">PValue</a></code>s to use in
examples of the <code><a href="#topic+analyze">analyze</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_example_statistics(
  point_estimators = TRUE,
  interval_estimators = TRUE,
  p_values = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_example_statistics_+3A_point_estimators">point_estimators</code></td>
<td>
<p>logical indicating whether point estimators should be included in output list</p>
</td></tr>
<tr><td><code id="get_example_statistics_+3A_interval_estimators">interval_estimators</code></td>
<td>
<p>logical indicating whether interval estimators should be included in output list</p>
</td></tr>
<tr><td><code id="get_example_statistics_+3A_p_values">p_values</code></td>
<td>
<p>logical indicating whether p-values should be included in output list</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Point estimators</h4>

<p>The following <code><a href="#topic+PointEstimator">PointEstimator</a></code>s are included:
</p>

<ul>
<li> <p><code><a href="#topic+SampleMean">SampleMean</a></code>
</p>
</li>
<li> <p><code><a href="#topic+PseudoRaoBlackwell">PseudoRaoBlackwell</a></code>
</p>
</li>
<li> <p><code><a href="#topic+MedianUnbiasedLikelihoodRatioOrdering">MedianUnbiasedLikelihoodRatioOrdering</a></code>
</p>
</li>
<li> <p><code><a href="#topic+BiasReduced">BiasReduced</a></code>
</p>
</li></ul>




<h4>Confidence intervals</h4>

<p>The following <code><a href="#topic+IntervalEstimator">IntervalEstimator</a></code>s are included:
</p>

<ul>
<li> <p><code><a href="#topic+StagewiseCombinationFunctionOrderingCI">StagewiseCombinationFunctionOrderingCI</a></code>
</p>
</li>
<li> <p><code><a href="#topic+LikelihoodRatioOrderingCI">LikelihoodRatioOrderingCI</a></code>
</p>
</li></ul>




<h4>P-Values</h4>

<p>The following <code><a href="#topic+PValue">PValue</a></code>s are included:
</p>

<ul>
<li> <p><code><a href="#topic+StagewiseCombinationFunctionOrderingPValue">StagewiseCombinationFunctionOrderingPValue</a></code>
</p>
</li>
<li> <p><code><a href="#topic+LikelihoodRatioOrderingPValue">LikelihoodRatioOrderingPValue</a></code>
</p>
</li></ul>




<h3>Value</h3>

<p>a list of <code><a href="#topic+PointEstimator">PointEstimator</a></code>s, <code><a href="#topic+IntervalEstimator">IntervalEstimator</a></code>s and
<code><a href="#topic+PValue">PValue</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
dat &lt;- data.frame(
  endpoint = c(rnorm(28, 0.3)),
  stage = rep(1, 28)
)
analyze(data = dat,
        statistics = list(),
        data_distribution = Normal(FALSE),
        design = get_example_design(),
        sigma = 1)

# The results suggest recruiting 32 patients for the second stage
dat &lt;- rbind(
  dat,
  data.frame(
    endpoint = rnorm(32, mean = 0.3),
    stage = rep(2, 32)))
analyze(data = dat,
        statistics = get_example_statistics(),
        data_distribution = Normal(FALSE),
        design = get_example_design(),
        sigma = 1)
</code></pre>

<hr>
<h2 id='get_stagewise_estimators'>Conditional representations of an estimator or p-value</h2><span id='topic+get_stagewise_estimators'></span><span id='topic+get_stagewise_estimators+2CVirtualPointEstimator+2CANY-method'></span><span id='topic+get_stagewise_estimators+2CVirtualPValue+2CANY-method'></span><span id='topic+get_stagewise_estimators+2CVirtualIntervalEstimator+2CANY-method'></span><span id='topic+get_stagewise_estimators+2CPointEstimator+2CStudent-method'></span><span id='topic+get_stagewise_estimators+2CPValue+2CStudent-method'></span><span id='topic+get_stagewise_estimators+2CIntervalEstimator+2CStudent-method'></span><span id='topic+get_stagewise_estimators+2CVirtualPointEstimator+2CStudent-method'></span><span id='topic+get_stagewise_estimators+2CVirtualIntervalEstimator+2CStudent-method'></span><span id='topic+get_stagewise_estimators+2CVirtualPValue+2CStudent-method'></span><span id='topic+get_stagewise_estimators+2CPointEstimator+2CDataDistribution-method'></span><span id='topic+get_stagewise_estimators+2CPValue+2CDataDistribution-method'></span><span id='topic+get_stagewise_estimators+2CIntervalEstimator+2CDataDistribution-method'></span><span id='topic+get_stagewise_estimators+2CAdaptivelyWeightedSampleMean+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMinimizePeakVariance+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CBiasReduced+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CRaoBlackwell+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CPseudoRaoBlackwell+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CRepeatedCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CLinearShiftRepeatedPValue+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMLEOrderingPValue+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CLikelihoodRatioOrderingPValue+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CScoreTestOrderingPValue+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CStagewiseCombinationFunctionOrderingPValue+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CNeymanPearsonOrderingPValue+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CNaivePValue+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CStagewiseCombinationFunctionOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMLEOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CLikelihoodRatioOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CScoreTestOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CNeymanPearsonOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CNaiveCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMidpointStagewiseCombinationFunctionOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMidpointMLEOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMidpointLikelihoodRatioOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMidpointScoreTestOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMidpointNeymanPearsonOrderingCI+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMedianUnbiasedStagewiseCombinationFunctionOrdering+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMedianUnbiasedMLEOrdering+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMedianUnbiasedLikelihoodRatioOrdering+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMedianUnbiasedScoreTestOrdering+2CNormal-method'></span><span id='topic+get_stagewise_estimators+2CMedianUnbiasedNeymanPearsonOrdering+2CNormal-method'></span>

<h3>Description</h3>

<p>This generic determines the functional representations of
point and interval estimators and p-values. The functions are
returned in two parts, one part to calculate the values conditional
on early futility or efficacy stops
(i.e. where no second stage mean and sample size is available),
and one conditional on continuation to the second stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'VirtualPointEstimator,ANY'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'VirtualPValue,ANY'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'VirtualIntervalEstimator,ANY'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'PointEstimator,Student'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'PValue,Student'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'IntervalEstimator,Student'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'VirtualPointEstimator,Student'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'VirtualIntervalEstimator,Student'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'VirtualPValue,Student'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'PointEstimator,DataDistribution'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'PValue,DataDistribution'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'IntervalEstimator,DataDistribution'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'AdaptivelyWeightedSampleMean,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MinimizePeakVariance,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'BiasReduced,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'RaoBlackwell,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'PseudoRaoBlackwell,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'RepeatedCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'LinearShiftRepeatedPValue,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MLEOrderingPValue,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'LikelihoodRatioOrderingPValue,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'ScoreTestOrderingPValue,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'StagewiseCombinationFunctionOrderingPValue,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'NeymanPearsonOrderingPValue,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'NaivePValue,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'StagewiseCombinationFunctionOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MLEOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'LikelihoodRatioOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'ScoreTestOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'NeymanPearsonOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'NaiveCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 
## 'MidpointStagewiseCombinationFunctionOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MidpointMLEOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MidpointLikelihoodRatioOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MidpointScoreTestOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MidpointNeymanPearsonOrderingCI,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 
## 'MedianUnbiasedStagewiseCombinationFunctionOrdering,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MedianUnbiasedMLEOrdering,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MedianUnbiasedLikelihoodRatioOrdering,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MedianUnbiasedScoreTestOrdering,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)

## S4 method for signature 'MedianUnbiasedNeymanPearsonOrdering,Normal'
get_stagewise_estimators(
  estimator,
  data_distribution,
  use_full_twoarm_sampling_distribution = FALSE,
  design,
  sigma,
  exact = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stagewise_estimators_+3A_estimator">estimator</code></td>
<td>
<p>object of class <code>PointEstimator</code>, <code>IntervalEstimator</code> or <code>PValue</code>.</p>
</td></tr>
<tr><td><code id="get_stagewise_estimators_+3A_data_distribution">data_distribution</code></td>
<td>
<p>object of class <code>Normal</code> or <code>Student</code>.</p>
</td></tr>
<tr><td><code id="get_stagewise_estimators_+3A_use_full_twoarm_sampling_distribution">use_full_twoarm_sampling_distribution</code></td>
<td>
<p>logical indicating whether this estimator is intended to be used
with the full sampling distribution in a two-armed trial.</p>
</td></tr>
<tr><td><code id="get_stagewise_estimators_+3A_design">design</code></td>
<td>
<p>object of class <code>TwoStageDesign</code>.</p>
</td></tr>
<tr><td><code id="get_stagewise_estimators_+3A_sigma">sigma</code></td>
<td>
<p>assumed standard deviation.</p>
</td></tr>
<tr><td><code id="get_stagewise_estimators_+3A_exact">exact</code></td>
<td>
<p>logical indicating usage of exact n2 function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the conditional functional representations
(one for each stage where the trial might end) of the estimator or p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_stagewise_estimators(
  estimator = SampleMean(),
  data_distribution = Normal(FALSE),
  use_full_twoarm_sampling_distribution = FALSE,
  design = get_example_design(),
  sigma = 1,
  exact = FALSE
)
</code></pre>

<hr>
<h2 id='get_statistics_from_paper'>Generate the list of estimators and p-values that were used in the paper</h2><span id='topic+get_statistics_from_paper'></span>

<h3>Description</h3>

<p>Generate the list of estimators and p-values that were used in the paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_statistics_from_paper(
  point_estimators = TRUE,
  interval_estimators = TRUE,
  p_values = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_statistics_from_paper_+3A_point_estimators">point_estimators</code></td>
<td>
<p>logical indicating whether point estimators should be included in output list</p>
</td></tr>
<tr><td><code id="get_statistics_from_paper_+3A_interval_estimators">interval_estimators</code></td>
<td>
<p>logical indicating whether interval estimators should be included in output list</p>
</td></tr>
<tr><td><code id="get_statistics_from_paper_+3A_p_values">p_values</code></td>
<td>
<p>logical indicating whether p-values should be included in output list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code><a href="#topic+PointEstimator">PointEstimator</a></code>s, <code><a href="#topic+IntervalEstimator">IntervalEstimator</a></code>s and
<code><a href="#topic+PValue">PValue</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
dat &lt;- data.frame(
  endpoint = c(rnorm(28, 0.3)),
  stage = rep(1, 28)
)
analyze(data = dat,
        statistics = list(),
        data_distribution = Normal(FALSE),
        design = get_example_design(),
        sigma = 1)

# The results suggest recruiting 32 patients for the second stage
dat &lt;- rbind(
  dat,
  data.frame(
    endpoint = rnorm(32, mean = 0.3),
    stage = rep(2, 32)))
analyze(data = dat,
        statistics = get_example_statistics(),
        data_distribution = Normal(FALSE),
        design = get_example_design(),
        sigma = 1)
</code></pre>

<hr>
<h2 id='IntervalEstimator-class'>Interval estimators</h2><span id='topic+IntervalEstimator-class'></span><span id='topic+ConfidenceInterval'></span><span id='topic+ConfidenceInterval-class'></span><span id='topic+IntervalEstimator'></span><span id='topic+RepeatedCI'></span><span id='topic+StagewiseCombinationFunctionOrderingCI'></span><span id='topic+MLEOrderingCI'></span><span id='topic+LikelihoodRatioOrderingCI'></span><span id='topic+ScoreTestOrderingCI'></span><span id='topic+NeymanPearsonOrderingCI'></span><span id='topic+NaiveCI'></span>

<h3>Description</h3>

<p>This is the parent class for all confidence intervals implemented in this package.
Currently, only confidence intervals for the parameter <code class="reqn">\mu</code> of a normal distribution
are implemented. Details about the methods for calculating confidence intervals can be found in
(our upcoming paper).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntervalEstimator(two_sided, l1, u1, l2, u2, label)

RepeatedCI(two_sided = TRUE)

StagewiseCombinationFunctionOrderingCI(two_sided = TRUE)

MLEOrderingCI(two_sided = TRUE)

LikelihoodRatioOrderingCI(two_sided = TRUE)

ScoreTestOrderingCI(two_sided = TRUE)

NeymanPearsonOrderingCI(two_sided = TRUE, mu0 = 0, mu1 = 0.4)

NaiveCI(two_sided = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntervalEstimator-class_+3A_two_sided">two_sided</code></td>
<td>
<p>logical indicating whether the confidence interval is two-sided.</p>
</td></tr>
<tr><td><code id="IntervalEstimator-class_+3A_l1">l1</code></td>
<td>
<p>functional representation of the lower boundary of the interval in the early futility and efficacy regions.</p>
</td></tr>
<tr><td><code id="IntervalEstimator-class_+3A_u1">u1</code></td>
<td>
<p>functional representation of the upper boundary of the interval in the early futility and efficacy regions.</p>
</td></tr>
<tr><td><code id="IntervalEstimator-class_+3A_l2">l2</code></td>
<td>
<p>functional representation of the lower boundary of the interval in the continuation region.</p>
</td></tr>
<tr><td><code id="IntervalEstimator-class_+3A_u2">u2</code></td>
<td>
<p>functional representation of the upper boundary of the interval in the continuation region.</p>
</td></tr>
<tr><td><code id="IntervalEstimator-class_+3A_label">label</code></td>
<td>
<p>name of the estimator. Used in printing methods.</p>
</td></tr>
<tr><td><code id="IntervalEstimator-class_+3A_mu0">mu0</code></td>
<td>
<p>expected value of the normal distribution under the null hypothesis.</p>
</td></tr>
<tr><td><code id="IntervalEstimator-class_+3A_mu1">mu1</code></td>
<td>
<p>expected value of the normal distribution under the null hypothesis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented confidence intervals are:
</p>

<ul>
<li> <p><code>MLEOrderingCI()</code>
</p>
</li>
<li> <p><code>LikelihoodRatioOrderingCI()</code>
</p>
</li>
<li> <p><code>ScoreTestOrderingCI()</code>
</p>
</li>
<li> <p><code>StagewiseCombinationFunctionOrderingCI()</code>
</p>
</li></ul>

<p>These confidence intervals are constructed by specifying an ordering of the sample space
and finding the value of <code class="reqn">\mu</code>, such that the observed sample is the
<code class="reqn">\alpha/2</code> (or (<code class="reqn">1-\alpha/2</code>)) quantile of the sample space according to the
chosen ordering.
Some of the implemented orderings are based on the work presented in
(Emerson and Fleming 1990),
(Sections 8.4 in Jennison and Turnbull 1999),
and (Sections 4.1.1 and 8.2.1 in Wassmer and Brannath 2016).
</p>


<h3>Value</h3>

<p>an object of class <code>IntervalEstimator</code>. This class signals that an
object can be supplied to the <code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code> and the
<code><a href="#topic+analyze">analyze</a></code> functions.
</p>


<h3>References</h3>

<p>Emerson SS, Fleming TR (1990).
&ldquo;Parameter estimation following group sequential hypothesis testing.&rdquo;
<em>Biometrika</em>, <b>77</b>(4), 875&ndash;892.
<a href="https://doi.org/10.2307/2337110">doi:10.2307/2337110</a>.<br /><br /> Jennison C, Turnbull BW (1999).
<em>Group Sequential Methods with Applications to Clinical Trials</em>, 1 edition.
Chapman and Hall/CRC., New York.
<a href="https://doi.org/10.1201/9780367805326">doi:10.1201/9780367805326</a>.<br /><br /> Wassmer G, Brannath W (2016).
<em>Group Sequential and Confirmatory Adaptive Designs in Clinical Trials</em>, 1 edition.
Springer, Cham, Switzerland.
<a href="https://doi.org/10.1007/978-3-319-32562-0">doi:10.1007/978-3-319-32562-0</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is the definition of the 'naive' confidence interval for one-armed trials
IntervalEstimator(
  two_sided = TRUE,
  l1 = \(smean1, n1, sigma, ...) smean1 - qnorm(.95, sd = sigma/sqrt(n1)),
  u1 = \(smean1, n1, sigma, ...) smean1 + qnorm(.95, sd = sigma/sqrt(n1)),
  l2 = \(smean1, smean2, n1, n2, sigma, ...) smean2 - qnorm(.95, sd = sigma/sqrt(n1 + n2)),
  u2 = \(smean1, smean2, n1, n2, sigma, ...) smean2 + qnorm(.95, sd = sigma/sqrt(n1 + n2)),
  label="My custom CI")
</code></pre>

<hr>
<h2 id='n2_extrapol'>Calculate the second-stage sample size for a design with cached spline parameters</h2><span id='topic+n2_extrapol'></span>

<h3>Description</h3>

<p>Also extrapolates results for values outside of [c1f, c1e].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n2_extrapol(design, x1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n2_extrapol_+3A_design">design</code></td>
<td>
<p>an object of class <code><a href="#topic+TwoStageDesignWithCache">TwoStageDesignWithCache</a></code>.</p>
</td></tr>
<tr><td><code id="n2_extrapol_+3A_x1">x1</code></td>
<td>
<p>first-stage test statistic</p>
</td></tr>
</table>

<hr>
<h2 id='NormalPrior'>Normal prior distribution for the parameter mu</h2><span id='topic+NormalPrior'></span>

<h3>Description</h3>

<p>Normal prior distribution for the parameter mu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalPrior(mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalPrior_+3A_mu">mu</code></td>
<td>
<p>mean of prior distribution.</p>
</td></tr>
<tr><td><code id="NormalPrior_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of the prior distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>NormalPrior</code>. This object can be supplied
as the argument <code>mu</code> of the <code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code> function
to calculate performance scores weighted by a prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NormalPrior(mu = 0, sigma = 1)
</code></pre>

<hr>
<h2 id='plot_p'>Plot p-values and implied rejection boundaries</h2><span id='topic+plot_p'></span>

<h3>Description</h3>

<p>Creates a plot of the p-values and implied rejection boundaries on a grid
of values for the first and second-stage test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_p(
  estimator,
  data_distribution,
  design,
  mu = 0,
  sigma,
  boundary_color = "lightgreen",
  subdivisions = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_p_+3A_estimator">estimator</code></td>
<td>
<p>object of class <code>PointEstimator</code>, <code>IntervalEstimator</code> or <code>PValue</code>.</p>
</td></tr>
<tr><td><code id="plot_p_+3A_data_distribution">data_distribution</code></td>
<td>
<p>object of class <code>Normal</code> or <code>Student</code>.</p>
</td></tr>
<tr><td><code id="plot_p_+3A_design">design</code></td>
<td>
<p>object of class <code>TwoStageDesign</code>.</p>
</td></tr>
<tr><td><code id="plot_p_+3A_mu">mu</code></td>
<td>
<p>expected value of the underlying normal distribution.</p>
</td></tr>
<tr><td><code id="plot_p_+3A_sigma">sigma</code></td>
<td>
<p>assumed standard deviation.</p>
</td></tr>
<tr><td><code id="plot_p_+3A_boundary_color">boundary_color</code></td>
<td>
<p>color of the implied rejection boundary.</p>
</td></tr>
<tr><td><code id="plot_p_+3A_subdivisions">subdivisions</code></td>
<td>
<p>number of subdivisions per axis for the grid of test statistic values.</p>
</td></tr>
<tr><td><code id="plot_p_+3A_...">...</code></td>
<td>
<p>additional arguments handed down to ggplot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the first-stage test statistic lies below the futility threshold (c1f) or
above the early efficacy threshold (c1e) of the <code>TwoStageDesign</code>,
there is no second-stage test statistics. The p-values in these regions are only
based on the first-stage values.
For first-stage test statistic values between c1f and c1e, the first and second-stage
test statistic determine the p-value.
</p>
<p>The rejection boundary signals the line where
</p>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object visualizing the p-values on a grid of possible test-statistic values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_p(estimator = StagewiseCombinationFunctionOrderingPValue(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu = 0,
  sigma = 1)
</code></pre>

<hr>
<h2 id='plot+2CEstimatorScoreResult-method'>Plot performance scores for point and interval estimators</h2><span id='topic+plot+2CEstimatorScoreResult-method'></span>

<h3>Description</h3>

<p>This function extract the values of mu and the score values and a facet plot with
one facet per score. If the input argument is a list, the different estimators
will be displayed in the same facets, differentiated by color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EstimatorScoreResult'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CEstimatorScoreResult-method_+3A_x">x</code></td>
<td>
<p>an output object from evaluate_estimator (<code>EstimatorScoreResult</code>) or a list
of such objects (<code>EstimatorScoreResultList</code>).</p>
</td></tr>
<tr><td><code id="plot+2B2CEstimatorScoreResult-method_+3A_y">y</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="plot+2B2CEstimatorScoreResult-method_+3A_...">...</code></td>
<td>
<p>additional arguments handed down to ggplot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object visualizing the score values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>score_result1 &lt;- evaluate_estimator(
  MSE(),
  estimator = SampleMean(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu=seq(-.75, 1.32, 0.03),
  sigma=1)
# Plotting the result of evaluate_estimator
plot(score_result1)

score_result2 &lt;- evaluate_estimator(
  MSE(),
  estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu=seq(-.75, 1.32, 0.03),
  sigma=1)
# Plotting a list of different score results
plot(c(score_result1, score_result2))
</code></pre>

<hr>
<h2 id='plot+2CEstimatorScoreResultList-method'>Plot performance scores for point and interval estimators</h2><span id='topic+plot+2CEstimatorScoreResultList-method'></span>

<h3>Description</h3>

<p>This function extract the values of mu and the score values and a facet plot with
one facet per score. If the input argument is a list, the different estimators
will be displayed in the same facets, differentiated by color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EstimatorScoreResultList'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CEstimatorScoreResultList-method_+3A_x">x</code></td>
<td>
<p>an output object from evaluate_estimator (<code>EstimatorScoreResult</code>) or a list
of such objects (<code>EstimatorScoreResultList</code>).</p>
</td></tr>
<tr><td><code id="plot+2B2CEstimatorScoreResultList-method_+3A_y">y</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="plot+2B2CEstimatorScoreResultList-method_+3A_...">...</code></td>
<td>
<p>additional arguments handed down to ggplot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object visualizing the score values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>score_result1 &lt;- evaluate_estimator(
  MSE(),
  estimator = SampleMean(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu=seq(-.75, 1.32, 0.03),
  sigma=1)
# Plotting the result of evaluate_estimator
plot(score_result1)

score_result2 &lt;- evaluate_estimator(
  MSE(),
  estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu=seq(-.75, 1.32, 0.03),
  sigma=1)
# Plotting a list of different score results
plot(c(score_result1, score_result2))
</code></pre>

<hr>
<h2 id='plot+2Clist-method'>Plot performance scores for point and interval estimators</h2><span id='topic+plot+2Clist-method'></span>

<h3>Description</h3>

<p>This function extract the values of mu and the score values and a facet plot with
one facet per score. If the input argument is a list, the different estimators
will be displayed in the same facets, differentiated by color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Clist-method_+3A_x">x</code></td>
<td>
<p>an output object from evaluate_estimator (<code>EstimatorScoreResult</code>) or a list
of such objects (<code>EstimatorScoreResultList</code>).</p>
</td></tr>
<tr><td><code id="plot+2B2Clist-method_+3A_y">y</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="plot+2B2Clist-method_+3A_...">...</code></td>
<td>
<p>additional arguments handed down to ggplot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object visualizing the score values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>score_result1 &lt;- evaluate_estimator(
  MSE(),
  estimator = SampleMean(),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu=seq(-.75, 1.32, 0.03),
  sigma=1)
# Plotting the result of evaluate_estimator
plot(score_result1)

score_result2 &lt;- evaluate_estimator(
  MSE(),
  estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),
  data_distribution = Normal(FALSE),
  design = get_example_design(),
  mu=seq(-.75, 1.32, 0.03),
  sigma=1)
# Plotting a list of different score results
plot(c(score_result1, score_result2))
</code></pre>

<hr>
<h2 id='PointEstimator-class'>Point estimators</h2><span id='topic+PointEstimator-class'></span><span id='topic+PointEstimator'></span><span id='topic+SampleMean'></span><span id='topic+FirstStageSampleMean'></span><span id='topic+WeightedSampleMean'></span><span id='topic+AdaptivelyWeightedSampleMean'></span><span id='topic+MinimizePeakVariance'></span><span id='topic+BiasReduced'></span><span id='topic+RaoBlackwell'></span><span id='topic+PseudoRaoBlackwell'></span><span id='topic+MidpointStagewiseCombinationFunctionOrderingCI'></span><span id='topic+MidpointMLEOrderingCI'></span><span id='topic+MidpointLikelihoodRatioOrderingCI'></span><span id='topic+MidpointScoreTestOrderingCI'></span><span id='topic+MidpointNeymanPearsonOrderingCI'></span><span id='topic+MedianUnbiasedStagewiseCombinationFunctionOrdering'></span><span id='topic+MedianUnbiasedMLEOrdering'></span><span id='topic+MedianUnbiasedLikelihoodRatioOrdering'></span><span id='topic+MedianUnbiasedScoreTestOrdering'></span><span id='topic+MedianUnbiasedNeymanPearsonOrdering'></span>

<h3>Description</h3>

<p>This is the parent class for all point estimators implemented in this package.
Currently, only estimators for the parameter <code class="reqn">\mu</code> of a normal distribution
are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PointEstimator(g1, g2, label)

SampleMean()

FirstStageSampleMean()

WeightedSampleMean(w1 = 0.5)

AdaptivelyWeightedSampleMean(w1 = 1/sqrt(2))

MinimizePeakVariance()

BiasReduced(iterations = 1L)

RaoBlackwell()

PseudoRaoBlackwell()

MidpointStagewiseCombinationFunctionOrderingCI()

MidpointMLEOrderingCI()

MidpointLikelihoodRatioOrderingCI()

MidpointScoreTestOrderingCI()

MidpointNeymanPearsonOrderingCI()

MedianUnbiasedStagewiseCombinationFunctionOrdering()

MedianUnbiasedMLEOrdering()

MedianUnbiasedLikelihoodRatioOrdering()

MedianUnbiasedScoreTestOrdering()

MedianUnbiasedNeymanPearsonOrdering(mu0 = 0, mu1 = 0.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PointEstimator-class_+3A_g1">g1</code></td>
<td>
<p>functional representation of the estimator in the early futility and efficacy regions.</p>
</td></tr>
<tr><td><code id="PointEstimator-class_+3A_g2">g2</code></td>
<td>
<p>functional representation of the estimator in the continuation region.</p>
</td></tr>
<tr><td><code id="PointEstimator-class_+3A_label">label</code></td>
<td>
<p>name of the estimator. Used in printing methods.</p>
</td></tr>
<tr><td><code id="PointEstimator-class_+3A_w1">w1</code></td>
<td>
<p>weight of the first-stage data.</p>
</td></tr>
<tr><td><code id="PointEstimator-class_+3A_iterations">iterations</code></td>
<td>
<p>number of bias reduction iterations. Defaults to 1.</p>
</td></tr>
<tr><td><code id="PointEstimator-class_+3A_mu0">mu0</code></td>
<td>
<p>expected value of the normal distribution under the null hypothesis.</p>
</td></tr>
<tr><td><code id="PointEstimator-class_+3A_mu1">mu1</code></td>
<td>
<p>expected value of the normal distribution under the null hypothesis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details about the point estimators can be found in (our upcoming paper).
</p>


<h4>Sample Mean (<code>SampleMean()</code>)</h4>

<p>The sample mean is the maximum likelihood estimator for the mean and probably the
'most straightforward' of the implemented estimators.
</p>



<h4>Fixed weighted sample means (<code>WeightedSampleMean()</code>)</h4>

<p>The first- and second-stage (if available) sample means are combined via fixed, predefined
weights. See (Brannath et al. 2006) and (Section 8.3.2 in Wassmer and Brannath 2016).
</p>



<h4>Adaptively weighted sample means (<code>AdaptivelyWeightedSampleMean()</code>)</h4>

<p>The first- and second-stage (if available) sample means are combined via a combination of
fixed and adaptively modified
weights that depend on the standard error.
See (Section 8.3.4 in Wassmer and Brannath 2016).
</p>



<h4>Minimizing peak variance in adaptively weighted sample means (<code>MinimizePeakVariance()</code>)</h4>

<p>For this estimator, the weights of the adaptively weighted sample mean are chosen to
minimize the variance of the estimator for the value of <code class="reqn">\mu</code> which maximizes
the expected sample size.
</p>



<h4>(Pseudo) Rao-Blackwell estimators (<code>RaoBlackwell</code> and <code>PseudoRaoBlackwell</code>)</h4>

<p>The conditional expectation of the first-stage sample mean given the overall sample
mean and the second-stage sample size. See (Emerson and Kittelson 1997).
</p>



<h4>A bias-reduced estimator (<code>BiasReduced()</code>)</h4>

<p>This estimator is calculated by subtracting an estimate of the bias from the MLE.
See (Whitehead 1986).
</p>



<h4>Median-unbiased estimators</h4>

<p>The implemented median-unbiased estimators are:
</p>

<ul>
<li> <p><code>MedianUnbiasedMLEOrdering()</code>
</p>
</li>
<li> <p><code>MedianUnbiasedLikelihoodRatioOrdering()</code>
</p>
</li>
<li> <p><code>MedianUnbiasedScoreTestOrdering()</code>
</p>
</li>
<li> <p><code>MedianUnbiasedStagewiseCombinationFunctionOrdering()</code>
</p>
</li></ul>

<p>These estimators are constructed by specifying an ordering of the sample space
and finding the value of <code class="reqn">\mu</code>, such that the observed sample is the
median of the sample space according to the chosen ordering.
Some of the implemented orderings are based on the work presented in
(Emerson and Fleming 1990),
(Sections 8.4 in Jennison and Turnbull 1999),
and (Sections 4.1.1 and 8.2.1 in Wassmer and Brannath 2016).
</p>



<h3>Value</h3>

<p>an object of class <code>PointEstimator</code>. This class signals that an
object can be supplied to the <code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code> and the
<code><a href="#topic+analyze">analyze</a></code> functions.
</p>


<h3>References</h3>

<p>Brannath W, KÃ¶nig F, Bauer P (2006).
&ldquo;Estimation in flexible two stage designs.&rdquo;
<em>Statistics in Medicine</em>, <b>25</b>(19), 3366-3381.
<a href="https://doi.org/10.1002/sim.2258">doi:10.1002/sim.2258</a>.<br /><br /> Emerson SS, Fleming TR (1990).
&ldquo;Parameter estimation following group sequential hypothesis testing.&rdquo;
<em>Biometrika</em>, <b>77</b>(4), 875&ndash;892.
<a href="https://doi.org/10.2307/2337110">doi:10.2307/2337110</a>.<br /><br /> Emerson SS, Kittelson JM (1997).
&ldquo;A computationally simpler algorithm for the UMVUE of a normal mean following a group sequential trial.&rdquo;
<em>Biometrics</em>, <b>53</b>(1), 365&ndash;369.
<a href="https://doi.org/10.2307/2533122">doi:10.2307/2533122</a>.<br /><br /> Jennison C, Turnbull BW (1999).
<em>Group Sequential Methods with Applications to Clinical Trials</em>, 1 edition.
Chapman and Hall/CRC., New York.
<a href="https://doi.org/10.1201/9780367805326">doi:10.1201/9780367805326</a>.<br /><br /> Wassmer G, Brannath W (2016).
<em>Group Sequential and Confirmatory Adaptive Designs in Clinical Trials</em>, 1 edition.
Springer, Cham, Switzerland.
<a href="https://doi.org/10.1007/978-3-319-32562-0">doi:10.1007/978-3-319-32562-0</a>.<br /><br /> Whitehead J (1986).
&ldquo;On the bias of maximum likelihood estimation following a sequential test.&rdquo;
<em>Biometrika</em>, <b>73</b>(3), 573&ndash;581.
<a href="https://doi.org/10.2307/2336521">doi:10.2307/2336521</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PointEstimator(g1 = \(smean1, ...) smean1,g2 = \(smean2, ...) smean2, label="My custom estimator")
</code></pre>

<hr>
<h2 id='PValue-class'>P-values</h2><span id='topic+PValue-class'></span><span id='topic+PValue'></span><span id='topic+LinearShiftRepeatedPValue'></span><span id='topic+MLEOrderingPValue'></span><span id='topic+LikelihoodRatioOrderingPValue'></span><span id='topic+ScoreTestOrderingPValue'></span><span id='topic+StagewiseCombinationFunctionOrderingPValue'></span><span id='topic+NeymanPearsonOrderingPValue'></span><span id='topic+NaivePValue'></span>

<h3>Description</h3>

<p>This is the parent class for all p-values implemented in this package.
Details about the methods for calculating p-values can be found in
(our upcoming paper).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PValue(g1, g2, label)

LinearShiftRepeatedPValue(wc1f = 0, wc1e = 1/2, wc2 = 1/2)

MLEOrderingPValue()

LikelihoodRatioOrderingPValue()

ScoreTestOrderingPValue()

StagewiseCombinationFunctionOrderingPValue()

NeymanPearsonOrderingPValue(mu0 = 0, mu1 = 0.4)

NaivePValue()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PValue-class_+3A_g1">g1</code></td>
<td>
<p>functional representation of the p-value in the early futility and efficacy regions.</p>
</td></tr>
<tr><td><code id="PValue-class_+3A_g2">g2</code></td>
<td>
<p>functional representation of the p-value in the continuation region.</p>
</td></tr>
<tr><td><code id="PValue-class_+3A_label">label</code></td>
<td>
<p>name of the p-value. Used in printing methods.</p>
</td></tr>
<tr><td><code id="PValue-class_+3A_wc1f">wc1f</code></td>
<td>
<p>slope of futility boundary change.</p>
</td></tr>
<tr><td><code id="PValue-class_+3A_wc1e">wc1e</code></td>
<td>
<p>slope of efficacy boundary change.</p>
</td></tr>
<tr><td><code id="PValue-class_+3A_wc2">wc2</code></td>
<td>
<p>slope of c2 boundary change.</p>
</td></tr>
<tr><td><code id="PValue-class_+3A_mu0">mu0</code></td>
<td>
<p>expected value of the normal distribution under the null hypothesis.</p>
</td></tr>
<tr><td><code id="PValue-class_+3A_mu1">mu1</code></td>
<td>
<p>expected value of the normal distribution under the null hypothesis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented p-values are:
</p>

<ul>
<li> <p><code>MLEOrderingPValue()</code>
</p>
</li>
<li> <p><code>LikelihoodRatioOrderingPValue()</code>
</p>
</li>
<li> <p><code>ScoreTestOrderingPValue()</code>
</p>
</li>
<li> <p><code>StagewiseCombinationFunctionOrderingPValue()</code>
</p>
</li></ul>

<p>The p-values are calculated by specifying an ordering of the sample space
calculating the probability that a random sample under the null hypothesis is
larger than the observed sample.
Some of the implemented orderings are based on the work presented in
(Emerson and Fleming 1990),
(Sections 8.4 in Jennison and Turnbull 1999),
and (Sections 4.1.1 and 8.2.1 in Wassmer and Brannath 2016).
</p>


<h3>Value</h3>

<p>an object of class <code>PValue</code>. This class signals that an
object can be supplied to the <code><a href="#topic+analyze">analyze</a></code> function.
</p>


<h3>References</h3>

<p>Emerson SS, Fleming TR (1990).
&ldquo;Parameter estimation following group sequential hypothesis testing.&rdquo;
<em>Biometrika</em>, <b>77</b>(4), 875&ndash;892.
<a href="https://doi.org/10.2307/2337110">doi:10.2307/2337110</a>.<br /><br /> Jennison C, Turnbull BW (1999).
<em>Group Sequential Methods with Applications to Clinical Trials</em>, 1 edition.
Chapman and Hall/CRC., New York.
<a href="https://doi.org/10.1201/9780367805326">doi:10.1201/9780367805326</a>.<br /><br /> Wassmer G, Brannath W (2016).
<em>Group Sequential and Confirmatory Adaptive Designs in Clinical Trials</em>, 1 edition.
Springer, Cham, Switzerland.
<a href="https://doi.org/10.1007/978-3-319-32562-0">doi:10.1007/978-3-319-32562-0</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_p">plot_p</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is the definition of a 'naive' p-value based on a Z-test for a one-armed trial
PValue(
  g1 = \(smean1, n1, sigma, ...) pnorm(smean1*sqrt(n1)/sigma, lower.tail=FALSE),
  g2 = \(smean1, smean2, n1, n2, ...) pnorm((n1 * smean1 + n2 * smean2)/(n1 + n2) *
                                        sqrt(n1+n2)/sigma, lower.tail=FALSE),
  label="My custom p-value")
</code></pre>

<hr>
<h2 id='Statistic-class'>Statistics and Estimators of the adestr package</h2><span id='topic+Statistic-class'></span><span id='topic+Statistic'></span><span id='topic+Statistics'></span><span id='topic+Estimator'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+Statistic">Statistic</a></code> class is a parent class for the classes
<code><a href="#topic+Estimator">Estimator</a></code> and <code><a href="#topic+PValue">PValue</a></code>. The <code><a href="#topic+Estimator">Estimator</a></code> class is a parent
for the classes <code><a href="#topic+PointEstimator">PointEstimator</a></code> and <code><a href="#topic+ConfidenceInterval">ConfidenceInterval</a></code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Statistic-class_+3A_label">label</code></td>
<td>
<p>name of the statistic. Used in printing methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+analyze">analyze</a></code> can be used to calculate the value
of a <code><a href="#topic+Statistic">Statistic</a></code> for a given dataset.
</p>
<p>The function <code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code> can be used to evaluate
<a href="#topic+EstimatorScore">distributional quantities</a> of an <code><a href="#topic+Estimator">Estimator</a></code>
like the <code><a href="#topic+MSE">MSE</a></code> for a <code><a href="#topic+PointEstimator">PointEstimator</a></code> or the
<code><a href="#topic+Coverage">Coverage</a></code> for a <code><a href="#topic+ConfidenceInterval">ConfidenceInterval</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>Statistic</code>. This class signals that
an object can be supplied to the <code><a href="#topic+analyze">analyze</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PointEstimator">PointEstimator</a></code> <code><a href="#topic+ConfidenceInterval">ConfidenceInterval</a></code> <code><a href="#topic+PValue">PValue</a></code>
</p>
<p><code><a href="#topic+analyze">analyze</a></code> <code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code>
</p>
<p><code><a href="#topic+EstimatorScore">EstimatorScore</a></code>
</p>

<hr>
<h2 id='TwoStageDesignWithCache'>TwoStageDesignWithCache constructor function</h2><span id='topic+TwoStageDesignWithCache'></span>

<h3>Description</h3>

<p>Creates an object of class <code>TwoStageDesignWithCache</code>.
This object stores the precalculated spline paramters of the <code>n2</code>
and <code>c2</code> functions, which allows for quicker evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoStageDesignWithCache(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwoStageDesignWithCache_+3A_design">design</code></td>
<td>
<p>an object of class TwoStageDesign</p>
</td></tr>
</table>

<hr>
<h2 id='UniformPrior'>Uniform prior distribution for the parameter mu</h2><span id='topic+UniformPrior'></span>

<h3>Description</h3>

<p>Uniform prior distribution for the parameter mu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniformPrior(min = -1, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UniformPrior_+3A_min">min</code></td>
<td>
<p>minimum of support interval.</p>
</td></tr>
<tr><td><code id="UniformPrior_+3A_max">max</code></td>
<td>
<p>maximum of support interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>UniformPrior</code>. This object can be supplied
as the argument <code>mu</code> of the <code><a href="#topic+evaluate_estimator">evaluate_estimator</a></code> function
to calculate performance scores weighted by a prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>UniformPrior(min = -1, max = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
