<!DOCTYPE html><html><head><title>Help for package DDM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DDM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addcod'><p>append a <code>$cod</code> column if missing</p></a></li>
<li><a href='#adjustages'><p>adjust the range of ages used by <code>ggbChooseAges()</code></p></a></li>
<li><a href='#assignNoteCode'><p>a cheap way to choose which column to assign a <code>NoteCode</code> to</p></a></li>
<li><a href='#avgDeaths'><p>if necessary divide deaths by intercensal interval</p></a></li>
<li><a href='#BrasilFemales'><p>Example data for Brasil females by federal states, years 1991 to 2000</p></a></li>
<li><a href='#BrasilMales'><p>Example data for Brasil males by federal states, years 1980 to 1991</p></a></li>
<li><a href='#cdmltw'><p>Coale-Demeny model life table: West</p></a></li>
<li><a href='#ddm'><p>run all three deaths registration coverage estimation methods</p></a></li>
<li><a href='#ddmplot'><p>get a quick overview of the different estimates produced</p></a></li>
<li><a href='#detectAgeInterval'><p>Detect the age interval for some demographic data</p></a></li>
<li><a href='#detectSex'><p>Detect the sex for some demographic data</p></a></li>
<li><a href='#eOpenCD'><p>estimate remaining life expectancy in the open age group</p></a></li>
<li><a href='#fakeDates'><p>assume Jan 1 if no month or day given</p></a></li>
<li><a href='#ggb'><p>estimate death registration coverage using the GGB method</p></a></li>
<li><a href='#ggbChooseAges'><p>interactively determine ages to use for estimating coverage</p></a></li>
<li><a href='#ggbcoverageFromAges'><p>given a set of ages, what is the implied death registration coverage?</p></a></li>
<li><a href='#ggbcoverageFromYear'><p>estimate death registration coverage for a single year/sex/region using the GGB method</p></a></li>
<li><a href='#ggbFittedFromAges'><p>make the growth-adjusted quasi life table columns required by GGB method</p></a></li>
<li><a href='#ggbgetAgesFit'><p>determine the age range that minimizes the mean squared error</p></a></li>
<li><a href='#ggbgetRMS'><p>calculate the root means square of the error to help find optimal age range</p></a></li>
<li><a href='#ggbMakeColumns'><p>make the growth-adjusted quasi life table columns required by GGB method</p></a></li>
<li><a href='#ggbseg'><p>estimate death registration coverage using the hybrid generalized growth balance and synthetic extinct generation</p></a></li>
<li><a href='#ggbsegCoverageFromYear'><p>estimate death registration coverage for a single year/sex/region using the modified Bennett-Horiuchi method</p></a></li>
<li><a href='#ggbsegMakeColumns'><p>make the Bennett-Horiuchi quasi life table columns required by the second estimation method</p></a></li>
<li><a href='#group01'><p>group down standard abridged data in child mortality group</p></a></li>
<li><a href='#guessage'><p>which age is closest to the point clicked?</p></a></li>
<li><a href='#guessDeathsColumn'><p>Figure out which column is the deaths column</p></a></li>
<li><a href='#headerPrep'><p>a utility function to prep the header</p></a></li>
<li><a href='#HMDlogic'><p>Logical utility functions</p></a></li>
<li><a href='#inUSR'><p>does a given pairlist of x and y coordinates fall within the plot region?</p></a></li>
<li><a href='#isLeapYear'><p>determine whether a year is a leap year.</p></a></li>
<li><a href='#Moz'><p>Example data for Mozambique females 1997-2007</p></a></li>
<li><a href='#reduceOpen'><p>chop down or group down the open age</p></a></li>
<li><a href='#seg'><p>estimate death registration coverage using the synthetic extinct generation method</p></a></li>
<li><a href='#segCoverageFromAges'><p>given a set of ages, what is the implied death registration coverage?</p></a></li>
<li><a href='#segCoverageFromYear'><p>estimate death registration coverage for a single year/sex/region using the Bennett-Horiuchi method</p></a></li>
<li><a href='#segMakeColumns'><p>make the Bennett-Horiuchi quasi life table columns required by the estimation method</p></a></li>
<li><a href='#segplot'><p>plot the age-pattern of coverage estimates</p></a></li>
<li><a href='#single2abr'><p>single ages to standard abridged ages</p></a></li>
<li><a href='#slopeint'><p>get the slope the slope and intercept implied by a set of ages</p></a></li>
<li><a href='#yint'><p>get interval as fraction of full years</p></a></li>
<li><a href='#yint2'><p>get the time interval without having to specify so many arguments</p></a></li>
<li><a href='#ypart'><p>determine the proportion of a year passed as of a particular date</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Death Registration Coverage Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-05-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Riffe, Everton Lima, Bernardo Queiroz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Riffe &lt;riffe@demogr.mpg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of three two-census methods to the estimate the degree of death registration coverage for a population. Implemented methods include the Generalized Growth Balance method (GGB), the Synthetic Extinct Generation method (SEG), and a hybrid of the two, GGB-SEG. Each method offers automatic estimation, but users may also specify exact parameters or use a graphical interface to guess parameters in the traditional way if desired.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-05-29 14:42:47 UTC; tim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-05-29 14:55:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='addcod'>append a <code>$cod</code> column if missing</h2><span id='topic+addcod'></span>

<h3>Description</h3>

<p>Only handles the case of missing <code>$cod</code> splitting variable for data of a single year/region. This is not super robust. If you have many regions or whatever then do it yourself. This function was just written to make <code>ggb()</code> robust to the case of a user specifying data that don't have any territorial or other subgroups, aside from sex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addcod(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addcod_+3A_x">X</code></td>
<td>
<p>a <code>data.frame</code>, possibly but not necessarily with column <code>$sex</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X with a new column, <code>$cod</code> appended.
</p>

<hr>
<h2 id='adjustages'>adjust the range of ages used by <code>ggbChooseAges()</code></h2><span id='topic+adjustages'></span>

<h3>Description</h3>

<p>a utility function called by <code>ggbChooseAges()</code>. After clicking a point, this function readjusts the age range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustages(a, age, agesfit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustages_+3A_a">a</code></td>
<td>
<p>an age specified by the user, as returned by <code>guessage()</code></p>
</td></tr>
<tr><td><code id="adjustages_+3A_age">age</code></td>
<td>
<p>ages present in dataset</p>
</td></tr>
<tr><td><code id="adjustages_+3A_agesfit">agesfit</code></td>
<td>
<p>the former age range used for calculating the coverage coefficient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the adjusted set of ages used for calculating the coverage coefficient
</p>

<hr>
<h2 id='assignNoteCode'>a cheap way to choose which column to assign a <code>NoteCode</code> to</h2><span id='topic+assignNoteCode'></span>

<h3>Description</h3>

<p>One property of the LexisDB scripts that might be useful for downstream checks is the ability to trace which functions have modified a given data object. These can go into NoteCode slots. This function writes <code>code</code> to the first unoccupied <code>NoteCode</code> column. If all three <code>NoteCode</code> columns are occupied, it concatenates the end of the third column. This way we preserve a full history. Unfortunately it gets split between columns. Oh well. Good for eyeballing. This function written for the sake of modularity. Function copied from Human Mortality Database collection directly as-is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignNoteCode(X, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignNoteCode_+3A_x">X</code></td>
<td>
<p>the HMD data object that presumably has three <code>NoteCode</code> columns</p>
</td></tr>
<tr><td><code id="assignNoteCode_+3A_code">code</code></td>
<td>
<p>character string to assign to the column, typically the name of the function operating on <code>X</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='avgDeaths'>if necessary divide deaths by intercensal interval</h2><span id='topic+avgDeaths'></span>

<h3>Description</h3>

<p>ideally <code>deaths</code> is the average annual deaths in the intercensal period, but it is also common to give it as the sum. If this was the case, set <code>deaths.summed</code> to <code>TRUE</code> and we take care of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avgDeaths(codi, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avgDeaths_+3A_codi">codi</code></td>
<td>
<p>the standard object as described in e.g. <code>ggb()</code>.</p>
</td></tr>
<tr><td><code id="avgDeaths_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. If <code>TRUE</code> then <code>deaths</code> was specified as the sum over the intercensal period. Otherwise it was the mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>codi a new column, <code>deathsAvg</code> will be appended.
</p>

<hr>
<h2 id='BrasilFemales'>Example data for Brasil females by federal states, years 1991 to 2000</h2><span id='topic+BrasilFemales'></span>

<h3>Description</h3>

<p>A dataset containing 486 rows and 7 variables: Population counts for 1991 and 2000 in abridged ages 0, 1, 5, ... 75, with an open age of 80. Deaths are given as the average death count per age group over the intercensal period. In total there are 53 states in this dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrasilFemales
</code></pre>


<h3>Format</h3>

<p>A data frame with 53940 rows and 10 variables:
</p>

<dl>
<dt>cod</dt><dd><p>integer an id number for each state</p>
</dd>
<dt>pop1</dt><dd><p>integer the census population count in 1991</p>
</dd>
<dt>pop2</dt><dd><p>integer the census population count in 2000</p>
</dd>
<dt>deaths</dt><dd><p>numeric average deaths between censuses</p>
</dd>
<dt>year1</dt><dd><p>integer 1991</p>
</dd>
<dt>year2</dt><dd><p>integer 2000</p>
</dd>
<dt>age</dt><dd><p>integer lower age bound for each age group</p>
</dd>
<dt>sex</dt><dd><p>character, 'f'</p>
</dd>
</dl>


<h3>Source</h3>

<p>data downloaded from DATASUS <code>http://www.datasus.gov.br</code>
</p>

<hr>
<h2 id='BrasilMales'>Example data for Brasil males by federal states, years 1980 to 1991</h2><span id='topic+BrasilMales'></span>

<h3>Description</h3>

<p>A dataset containing 486 rows and 7 variables: Population counts for 1980 and 1991 in abridged ages 0, 1, 5, ... 75, with an open age of 80. Deaths are given as the average death count per age group over the intercensal period. In total there are 53 states in this dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrasilMales
</code></pre>


<h3>Format</h3>

<p>A data frame with 53940 rows and 10 variables:
</p>

<dl>
<dt>cod</dt><dd><p>integer an id number for each state</p>
</dd>
<dt>pop1</dt><dd><p>integer the census population count in 1991</p>
</dd>
<dt>pop2</dt><dd><p>integer the census population count in 2000</p>
</dd>
<dt>deaths</dt><dd><p>numeric average deaths between censuses</p>
</dd>
<dt>year1</dt><dd><p>integer 1991</p>
</dd>
<dt>year2</dt><dd><p>integer 2000</p>
</dd>
<dt>age</dt><dd><p>integer lower age bound for each age group</p>
</dd>
<dt>sex</dt><dd><p>character, 'm'</p>
</dd>
</dl>


<h3>Source</h3>

<p>data downloaded from DATASUS <code>http://www.datasus.gov.br</code>
</p>

<hr>
<h2 id='cdmltw'>Coale-Demeny model life table: West</h2><span id='topic+cdmltw'></span>

<h3>Description</h3>

<p>function from now-deprecated <code>demogR</code> package. Originally written by Ken Wachter, modified by James Jones, and again by the current maintainer, Tim Riffe. Only minor edits to margin naming in the current version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmltw(sex = "F")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdmltw_+3A_sex">sex</code></td>
<td>
<p><code>"F"</code> or <code>"M"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tons of lifetable output in matrices. Age in columns, lifetable levels in rows.
</p>

<hr>
<h2 id='ddm'>run all three deaths registration coverage estimation methods</h2><span id='topic+ddm'></span>

<h3>Description</h3>

<p>Estimate the generalized growth balance method, and the two Bennett-Horiuchi methods of estimating death registration coverage. This requires two censuses and an estimate of the deaths in each 5-year age group between censuses. This might be the arithmetic average of deaths in each age class, or simply the average of deaths around the time of the two censuses. All methods use some stable population assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddm(X, minA = 15, maxA = 75, minAges = 8, exact.ages = NULL,
  eOpen = NULL, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddm_+3A_x">X</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, <code>$age</code>, <code>$sex</code>, and <code>$cod</code> (if there are more than 1 region/sex/intercensal period).</p>
</td></tr>
<tr><td><code id="ddm_+3A_mina">minA</code></td>
<td>
<p>the lowest age to be included in search</p>
</td></tr>
<tr><td><code id="ddm_+3A_maxa">maxA</code></td>
<td>
<p>the highest age to be included in search (the lower bound thereof)</p>
</td></tr>
<tr><td><code id="ddm_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages to be used in estimating</p>
</td></tr>
<tr><td><code id="ddm_+3A_exact.ages">exact.ages</code></td>
<td>
<p>optional. A user-specified vector of exact ages to use for coverage estimation</p>
</td></tr>
<tr><td><code id="ddm_+3A_eopen">eOpen</code></td>
<td>
<p>optional. A user-specified value for remaining life-expectancy in the open age group.</p>
</td></tr>
<tr><td><code id="ddm_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All methods require some specification about which age range to base results on. If not given, an optimal age range will be estimated automatically, and this information is returned to the user. To identify an age-range in the visually, see <code>plot.ggb()</code>, when working with a single year/sex/region of data. The automatic age-range determination feature of this function tries to implement an intuitive way of picking ages that follows the advice typically given for doing so visually. We minimize the square of the average squared residual between the fitted line and right term.If you want coverage estimates for a variety of partitions (intercensal periods/regions/by sex), then stack them, and use a variable called <code>$cod</code> with unique values for each data partition. If data is partitioned using the variable <code>$cod</code>, then the age range automatically determined might not be the same for each partition. If user-specified, (using a vector of <code>exact.ages</code>) the age ranges will be the same for all partitions. If you want to specify particular age ranges for each data partition, then you'll need to loop it somehow. 
</p>
<p>All three methods require time points of the two censuses. Census dates can be given in a variety of ways: 1) (preferred) using <code>Date</code> classes, and column names <code>$date1</code> and <code>$date2</code> (or an unambiguous character string of the date, like, <code>"1981-05-13"</code>) or 2) by giving column names <code>"day1","month1","year1","day2","month2","year2"</code> containing respective integers. If only <code>year1</code> and <code>year2</code> are given, then we assume January 1 dates. If year and month are given, then we assume dates on the first of the month.  Different values of <code>$cod</code> could indicate sexes, regions, intercensal periods, etc. The <code>$deaths</code> column should refer to the average annual deaths for each age class in the intercensal period. Sometimes one uses the arithmetic average of recorded deaths in each age, or simply the average of the deaths around the time of census 1 and census 2. 
</p>
<p>The synthetic extinct generation methods require an estimate of remaining life expectancy in the open age group of the data provided. This is produced using a standard reference to the Coale-Demeny West model life tables. That is a place where things can be improved.
</p>


<h3>Value</h3>

<p>data.frame with columns <code>$cod</code>, <code>$ggb</code>, <code>$bh1</code>, <code>$bh2</code>, <code>$lower</code>, and <code>$upper</code>.
</p>


<h3>References</h3>

<p>Bennett Neil G, Shiro Horiuchi. Estimating the completeness of death registration in a closed population. Population Index. 1981; 1:207-221.
</p>
<p>Hill K. Estimating census and death registration completeness. Asian and Pacific Population Forum. 1987; 1:1-13.
</p>
<p>Hill K, You D, Choi Y. Death distribution methods for estimating adult mortality: sensitivity analysis with simulated data errors. Demographic Research. 2009; 21:235-254.
</p>
<p>Brass, William, 1975.  Methods for Estimating Fertility and Mortality from Limited and Defective Data, Carolina Population Center, Laboratory for Population Studies, University of North Carolina, Chapel Hill.
</p>
<p>Preston, S. H., Coale, A. J., Trussel, J. &amp; Maxine, W. Estimating the completeness of reporting of adult deaths in populations that are approximately stable.  Population Studies, 1980; v.4: 179-202
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The Mozambique data
res &lt;- ddm(Moz)
head(res)
# The Brasil data
BM &lt;- ddm(BrasilMales)
BF &lt;- ddm(BrasilFemales)
head(BM)
head(BF)
</code></pre>

<hr>
<h2 id='ddmplot'>get a quick overview of the different estimates produced</h2><span id='topic+ddmplot'></span>

<h3>Description</h3>

<p>produce a dot plot, where each x position is a unique value of <code>$cod</code>, and points indicate the GGB, SEG, GGB-SEG, and harmonic mean of these. Feed this function the output of <code>ddm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddmplot(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddmplot_+3A_x">X</code></td>
<td>
<p>output of <code>ddm()</code>.</p>
</td></tr>
<tr><td><code id="ddmplot_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>plot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>called for its graphical device side-effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># just a rough sketch of the results!
res &lt;- ddm(Moz)
ddmplot(res)
</code></pre>

<hr>
<h2 id='detectAgeInterval'>Detect the age interval for some demographic data</h2><span id='topic+detectAgeInterval'></span>

<h3>Description</h3>

<p>Since death distribution methods are primarily used in adult ages, it's OK to chop off the irregular infant and child age intervals (0,1], (1,5]. Further, if high ages are in different intervals this might also be a non-issue. In principal, the user should set <code>MinAge</code> and <code>MaxAge</code> to the same values used in the death distribution methods. Here we have some defaults that should almost always return the result <code>5</code> for standard abridged data, or <code>1</code> for single age data. Really there are not any other common age-specifications, but it is best to identify these and be explicit about them. We return a warning and <code>NA</code> if more than one age interval is used. It is assumed that ages refer to the lower bounds of age intervals, as is the standard in demography.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectAgeInterval(Dat, MinAge = 5, MaxAge = 70, ageColumn = "Age")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectAgeInterval_+3A_dat">Dat</code></td>
<td>
<p>a <code>data.frame</code> containing a column called <code>Age</code>, or codeage.</p>
</td></tr>
<tr><td><code id="detectAgeInterval_+3A_minage">MinAge</code></td>
<td>
<p>integer ignore ages below this age.</p>
</td></tr>
<tr><td><code id="detectAgeInterval_+3A_maxage">MaxAge</code></td>
<td>
<p>integer ignore ages above this age.</p>
</td></tr>
<tr><td><code id="detectAgeInterval_+3A_agecolumn">ageColumn</code></td>
<td>
<p>character string giving the name of the Age column <code>"Age"</code> assumed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer the age interval. <code>NA</code> if this is not unique.
</p>

<hr>
<h2 id='detectSex'>Detect the sex for some demographic data</h2><span id='topic+detectSex'></span>

<h3>Description</h3>

<p>The column name can be <code>"sex"</code> or <code>"Sex"</code> and nothing else. If coded with integer, the number 1 is recognized as male and numbers, 0, 2, or 6 are assumed to be female. Any other integer will throw an error. If character, if the first letter is <code>"f"</code>, then we assume female, and if the first letter is <code>"m"</code> we assume male. Case does not matter. Anything else will throw an error. This function allows for just a little flexibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectSex(Dat, sexColumn = "Sex")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectSex_+3A_dat">Dat</code></td>
<td>
<p>a <code>data.frame</code> containing a column called <code>Sex</code>, or codesex.</p>
</td></tr>
<tr><td><code id="detectSex_+3A_sexcolumn">sexColumn</code></td>
<td>
<p>character string giving the name of the Sex column <code>"Sex"</code> assumed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either <code>"f"</code> or <code>"m"</code>
</p>

<hr>
<h2 id='eOpenCD'>estimate remaining life expectancy in the open age group</h2><span id='topic+eOpenCD'></span>

<h3>Description</h3>

<p>This calculation is based on an indirect method to reference the Coale-Demeny West model life table. First one makes a pseudo life table deaths column using some stable pop assumptions (different in SEG vs GGB-SEG). Then take the ratio of the sum of ages 10-39 to 40-59. These ratios have been worked out for each model life table level, so we can pick the level based on the ratio we produce from the data. From there, we just pick out the remaining life expectancy that corresponds to the top age in our data, which for now hopefully is not higher than 95. The model life tables do not go higher than 95 for now, but that's well beyond the range for this method family. If your data go beyond 85 or so, then just group down to 85, say, and estimate using that instead of keeping a high open age. Called by <code>segMakeColumns()</code> and <code>ggbsegMakeColumns()</code>, and not intended for direct user interface, because you need to produce the <code>$deathsLT</code> column. You can skip calling this function by specifying <code>eOpen</code> in the top call to <code>seg()</code> or <code>ggbseg()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eOpenCD(codiaugmented)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eOpenCD_+3A_codiaugmented">codiaugmented</code></td>
<td>
<p>the standard codi object being passed through the chain, but having been preprocessed in the course of <code>segMakeColumns()</code> or <code>ggbsegMakeColumns()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric an estimate of remaining life expectancy in the open age group
</p>

<hr>
<h2 id='fakeDates'>assume Jan 1 if no month or day given</h2><span id='topic+fakeDates'></span>

<h3>Description</h3>

<p>We still require two year columns, <code>year1</code> and <code>year2</code>, at a minimum. If this function is called, and if month and day columns are missing we add these columns, with values of 1. If date columns are given, then these must be either in an unambiguous character format (<code>"YYYY-MM-DD"</code>, e.g. <code>"2016-05-30"</code> is unambiguous). Date columns will override the presence of other year, month, day columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fakeDates(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fakeDates_+3A_x">X</code></td>
<td>
<p>a <code>data.frame</code> with at least columns <code>year1</code> and <code>year2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X the same <code>data.frame</code>, possibly with columns for year, month, or day added.
</p>

<hr>
<h2 id='ggb'>estimate death registration coverage using the GGB method</h2><span id='topic+ggb'></span>

<h3>Description</h3>

<p>Given two censuses and an average annual number of deaths in each age class between censuses, we can use stable population assumptions to estimate the degree of underregistration of deaths. The method is based on finding a best-fitting linear relationship between two modeled parameters (right term and left term), but the fit, and resulting coverage estimate, depend on exactly which age range is taken. This function either finds a nice age range for you automatically, or you can specify an exact vector of ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggb(X, minA = 15, maxA = 75, minAges = 8, exact.ages = NULL,
  deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggb_+3A_x">X</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, <code>$age</code>, and <code>$cod</code> (if there are more than 1 region/sex/intercensal period).</p>
</td></tr>
<tr><td><code id="ggb_+3A_mina">minA</code></td>
<td>
<p>the lowest age to be included in search</p>
</td></tr>
<tr><td><code id="ggb_+3A_maxa">maxA</code></td>
<td>
<p>the highest age to be included in search (the lower bound thereof)</p>
</td></tr>
<tr><td><code id="ggb_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages to be used in estimating</p>
</td></tr>
<tr><td><code id="ggb_+3A_exact.ages">exact.ages</code></td>
<td>
<p>optional. A user-specified vector of exact ages to use for coverage estimation</p>
</td></tr>
<tr><td><code id="ggb_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Census dates can be given in a variety of ways: 1) using Date classes, and column names <code>$date1</code> and <code>$date2</code> (or an unambiguous character string of the date, like, <code>"1981-05-13"</code>) or 2) by giving column names <code>"day1","month1","year1","day2","month2","year2"</code> containing integers. If only <code>year1</code> and <code>year2</code> are given, then we assume January 1 dates. If year and month are given, then we assume dates on the first of the month. If you want coverage estimates for a variety of intercensal periods/regions/by sex, then stack them, and use a variable called <code>$cod</code> with unique values for each data chunk. Different values of <code>$cod</code> could indicate sexes, regions, intercensal periods, etc. The <code>$deaths</code> column should refer to the average annual deaths for each age class in the intercensal period. Sometimes one uses the arithmetic average of recorded deaths in each age, or simply the average of the deaths around the time of census 1 and census 2. To identify an age-range in the traditional visual way, see <code>ggbChooseAges()</code>, when working with a single year/sex/region of data. The automatic age-range determination feature of this function tries to implement an intuitive way of picking ages that follows the advice typically given for doing so visually. We minimize the square of the average squared residual between the fitted line and right term.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns for the coverage coefficient <code>$coverage</code>, the minimum <code>$lower</code> and maximum <code>$upper</code> of the age range on which it is based. <code>$a</code> and <code>$b</code> give the intercept and slope of the line on which the coverage estimate is based. <code>$delta</code>, <code>$k1</code>, and <code>$k2</code>  are further derived quantities that may be interesting for advanced users. Rows indicate data partitions, as indicated by the optional <code>$cod</code> variable.
</p>


<h3>References</h3>

<p>Hill K. Estimating census and death registration completeness. Asian and Pacific Population Forum. 1987; 1:1-13.
</p>
<p>Brass, William, 1975.  Methods for Estimating Fertility and Mortality from Limited and Defective Data, Carolina Population Center, Laboratory for Population Studies, University of North Carolina, Chapel Hill.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The Mozambique data
res &lt;- ggb(Moz)
res
# The Brasil data
BM &lt;- ggb(BrasilMales)
BF &lt;- ggb(BrasilFemales)
head(BM)
head(BF)

</code></pre>

<hr>
<h2 id='ggbChooseAges'>interactively determine ages to use for estimating coverage</h2><span id='topic+ggbChooseAges'></span>

<h3>Description</h3>

<p>In a spreadsheet one would typically set up the GGB method to produce a plot that updates as the user changes the age range. This function implements that kind of work flow. This will be intuitive for spreadsheet users, but it does not scale well. Imagine you have 200 territorial units, then you would not want to repeat this task. <code>ggb()</code> does the same thing automatically. You can compare the age range you select manually with the one given back by <code>ggb()</code> as a diagnostic, for instance. To set up the plot device, just give a single year/region/sex of data. By default it will give the RMSE-optimized age range to start with, but you can specify a  vector of exact ages to use as well. All points are plotted, with a fitted line that has been set to a subset of the points, which is plotted in a different color. You can click any point to change the age range, and the plot updates accordingly, up to a maximum of 15 clicks so you don't waste your time. You can stop the plot by either clicking on the graphics device outside the plot area or clicking out the 15 tries (or more if you increase <code>maxit</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbChooseAges(codi, minA = 15, maxA = 75, minAges = 8,
  exact.ages = NULL, maxit = 15, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbChooseAges_+3A_codi">codi</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, and <code>$age</code>.</p>
</td></tr>
<tr><td><code id="ggbChooseAges_+3A_mina">minA</code></td>
<td>
<p>the lowest age to be included in search</p>
</td></tr>
<tr><td><code id="ggbChooseAges_+3A_maxa">maxA</code></td>
<td>
<p>the highest age to be included in search (the lower bound thereof)</p>
</td></tr>
<tr><td><code id="ggbChooseAges_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages to be used in estimating</p>
</td></tr>
<tr><td><code id="ggbChooseAges_+3A_exact.ages">exact.ages</code></td>
<td>
<p>optional. A user-specified vector of exact ages to use for coverage estimation.</p>
</td></tr>
<tr><td><code id="ggbChooseAges_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of clicks you can take. Default 15.</p>
</td></tr>
<tr><td><code id="ggbChooseAges_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you want to send the results of this into <code>ggb()</code>, you can do so by setting <code>Exact.ages</code> to <code>seq(lower,upper,by=5)</code>, where <code>$lower</code>, and <code>$upper</code> are the results returned from <code>ggbChooseAges()</code> after you're done manually determining the age range.
</p>


<h3>Value</h3>

<p><code>data.frame</code> containing elements <code>$coverage</code>, <code>$lower</code>, <code>$upper</code>, and <code>ages</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# for interactive sessions only
# *click points to adjus age range used (yellow)
# *click in margin to stop and return coverage results
ggbChooseAges(Moz)

## End(Not run)
</code></pre>

<hr>
<h2 id='ggbcoverageFromAges'>given a set of ages, what is the implied death registration coverage?</h2><span id='topic+ggbcoverageFromAges'></span>

<h3>Description</h3>

<p>For a single year/sex/region of data (formatted as required by <code>ggb()</code>), what is the registration coverage implied by a given age range? Called by <code>ggbcoverageFromYear()</code> and <code>ggbChooseAges()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbcoverageFromAges(codi, agesfit, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbcoverageFromAges_+3A_codi">codi</code></td>
<td>
<p>a chunk of data (single sex, year, region, etc) with all columns required by <code>ggb()</code></p>
</td></tr>
<tr><td><code id="ggbcoverageFromAges_+3A_agesfit">agesfit</code></td>
<td>
<p>an integer vector of ages, either returned from <code>ggbgetAgesFit</code> or user-supplied.</p>
</td></tr>
<tr><td><code id="ggbcoverageFromAges_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. the estimated level of coverage.
</p>

<hr>
<h2 id='ggbcoverageFromYear'>estimate death registration coverage for a single year/sex/region using the GGB method</h2><span id='topic+ggbcoverageFromYear'></span>

<h3>Description</h3>

<p>Given two censuses and an average annual number of deaths in each age class between censuses, we can use stable population assumptions to estimate the degree of underregistration of deaths. The method is based on finding a best-fitting linear relationship between two modeled parameters (right term and left term), but the fit, and resulting coverage estimate, depend on exactly which age range is taken. This function either finds a nice age range for you automatically, or you can specify an exact vector of ages. Called by <code>ggb()</code>. Users probably don't need to call this directly. Just use <code>ggb()</code> instead.
</p>
<p>Census dates can be given in a variety of ways: 1) using Date classes, and column names <code>$date1</code> and <code>$date2</code> (or an unambiguous character string of the date, like, <code>"1981-05-13"</code>) or 2) by giving column names <code>"day1","month1","year1","day2","month2","year2"</code> containing integers. If only <code>year1</code> and <code>year2</code> are given, then we assume January 1 dates. If year and month are given, then we assume dates on the first of the month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbcoverageFromYear(codi, exact.ages = NULL, minA = 15, maxA = 75,
  minAges = 8, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbcoverageFromYear_+3A_codi">codi</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, and <code>$age</code>.</p>
</td></tr>
<tr><td><code id="ggbcoverageFromYear_+3A_exact.ages">exact.ages</code></td>
<td>
<p>optional. use an exact set of ages to estimate coverage.</p>
</td></tr>
<tr><td><code id="ggbcoverageFromYear_+3A_mina">minA</code></td>
<td>
<p>the minimum of the age range searched. Default 15</p>
</td></tr>
<tr><td><code id="ggbcoverageFromYear_+3A_maxa">maxA</code></td>
<td>
<p>the maximum of the age range searched. Default 75</p>
</td></tr>
<tr><td><code id="ggbcoverageFromYear_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages needed as points for fitting. Default 8</p>
</td></tr>
<tr><td><code id="ggbcoverageFromYear_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns for the coverage coefficient, and the min and max of the age range on which it is based.
</p>

<hr>
<h2 id='ggbFittedFromAges'>make the growth-adjusted quasi life table columns required by GGB method</h2><span id='topic+ggbFittedFromAges'></span>

<h3>Description</h3>

<p>Called by <code>ggbChooseAges()</code> and <code>ggbcoverageFromYear()</code>. This simply modulates some code that would otherwise be repeated. Users probably don't need to call this function directly. If columns produced by <code>ggbMakeColumns()</code> are not present, then we call it here just to keep things from breaking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbFittedFromAges(codi, agesfit, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbFittedFromAges_+3A_codi">codi</code></td>
<td>
<p>a chunk of data (single sex, year, region, etc) with all columns required by <code>ggb()</code></p>
</td></tr>
<tr><td><code id="ggbFittedFromAges_+3A_agesfit">agesfit</code></td>
<td>
<p>an a priori set of ages for which to calculate the fit</p>
</td></tr>
<tr><td><code id="ggbFittedFromAges_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>codi, with many columns added, most importantly <code>$rightterm</code>, <code>$leftterm</code>, and <code>$exclude</code>.
</p>

<hr>
<h2 id='ggbgetAgesFit'>determine the age range that minimizes the mean squared error</h2><span id='topic+ggbgetAgesFit'></span>

<h3>Description</h3>

<p>Called by <code>ggbcoverageFromYear()</code> whenever <code>exact.ages</code> are not given. This automates what one typically does visually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbgetAgesFit(codi, minA = 15, maxA = 75, minAges = 8,
  deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbgetAgesFit_+3A_codi">codi</code></td>
<td>
<p>a chunk of data (single sex, year, region, etc) with all columns required by <code>ggb()</code></p>
</td></tr>
<tr><td><code id="ggbgetAgesFit_+3A_mina">minA</code></td>
<td>
<p>the lowest age to be included in search</p>
</td></tr>
<tr><td><code id="ggbgetAgesFit_+3A_maxa">maxA</code></td>
<td>
<p>the highest age to be included in search (the lower bound thereof)</p>
</td></tr>
<tr><td><code id="ggbgetAgesFit_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages to be used in estimating</p>
</td></tr>
<tr><td><code id="ggbgetAgesFit_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of ages that minimizes the RMSE
</p>


<h3>See Also</h3>

<p>code<a href="#topic+ggbChooseAges">ggbChooseAges</a>
</p>

<hr>
<h2 id='ggbgetRMS'>calculate the root means square of the error to help find optimal age range</h2><span id='topic+ggbgetRMS'></span>

<h3>Description</h3>

<p>Called by <code>ggbgetAgesFit()</code> whenever the user does not want to manually determine the age range used to determine registration coverage. Probably no need to be called by top-level users. If a user would rather determine the optimal age range some other way, then look to <code>ggbcoverageFromYear()</code> where <code>ggbgetRMS</code> is called and add another condition or make it call something else.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbgetRMS(agesi, codi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbgetRMS_+3A_agesi">agesi</code></td>
<td>
<p>the set of ages used for this iteration</p>
</td></tr>
<tr><td><code id="ggbgetRMS_+3A_codi">codi</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, and <code>$age</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the RMSE
</p>

<hr>
<h2 id='ggbMakeColumns'>make the growth-adjusted quasi life table columns required by GGB method</h2><span id='topic+ggbMakeColumns'></span>

<h3>Description</h3>

<p>Called by <code>ggbChooseAges()</code> and <code>ggbcoverageFromYear()</code>. This simply modulates some code that would otherwise be repeated. Users probably don't need to call this function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbMakeColumns(codi, minA = 15, maxA = 75, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbMakeColumns_+3A_codi">codi</code></td>
<td>
<p>a chunk of data (single sex, year, region, etc) with all columns required by <code>ggb()</code></p>
</td></tr>
<tr><td><code id="ggbMakeColumns_+3A_mina">minA</code></td>
<td>
<p>the minimum of the age range searched. Default 15</p>
</td></tr>
<tr><td><code id="ggbMakeColumns_+3A_maxa">maxA</code></td>
<td>
<p>the maximum of the age range searched. Default 75</p>
</td></tr>
<tr><td><code id="ggbMakeColumns_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>codi, with many columns added, most importantly <code>$rightterm</code>, <code>$leftterm</code>, and <code>$exclude</code>.
</p>

<hr>
<h2 id='ggbseg'>estimate death registration coverage using the hybrid generalized growth balance and synthetic extinct generation</h2><span id='topic+ggbseg'></span>

<h3>Description</h3>

<p>Given two censuses and an average annual number of deaths in each age class between censuses, we can use stable population assumptions to estimate the degree of underregistration of deaths. The method estimates age-specific degrees of coverage. The age pattern of these is assumed to be noisy, so we take the arithmetic mean over some range of ages. One may either specify a particular age-range, or let the age range be determined automatically. If the age-range is found automatically, this is done using the method developed for the generalized growth-balance method. Part of this method relies on a prior value for remaining life expectancy in the open age group. By default, this is estimated using a standard reference to the Coale-Demeny West model life table, although the user may also supply a value. The difference between this method and <code>seg()</code> is that here we adjust census 1 part way through processing, based on some calculations similar to GGB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbseg(X, minA = 15, maxA = 75, minAges = 8, exact.ages = NULL,
  eOpen = NULL, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbseg_+3A_x">X</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, <code>$age</code>, <code>$sex</code>, and <code>$cod</code> (if there are more than 1 region/sex/intercensal period).</p>
</td></tr>
<tr><td><code id="ggbseg_+3A_mina">minA</code></td>
<td>
<p>the lowest age to be included in search</p>
</td></tr>
<tr><td><code id="ggbseg_+3A_maxa">maxA</code></td>
<td>
<p>the highest age to be included in search (the lower bound thereof)</p>
</td></tr>
<tr><td><code id="ggbseg_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages to be used in estimating</p>
</td></tr>
<tr><td><code id="ggbseg_+3A_exact.ages">exact.ages</code></td>
<td>
<p>optional. A user-specified vector of exact ages to use for coverage estimation</p>
</td></tr>
<tr><td><code id="ggbseg_+3A_eopen">eOpen</code></td>
<td>
<p>optional. A user-specified value for remaining life-expectancy in the open age group.</p>
</td></tr>
<tr><td><code id="ggbseg_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. Is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Census dates can be given in a variety of ways: 1) using Date classes, and column names <code>$date1</code> and <code>$date2</code> (or an unambiguous character string of the date, like, <code>"1981-05-13"</code>) or 2) by giving column names <code>"day1","month1","year1","day2","month2","year2"</code> containing integers. If only <code>year1</code> and <code>year2</code> columns are given, then we assume January 1 dates. If year and month are given, then we assume dates on the first of the month. If you want coverage estimates for a variety of intercensal periods/regions/by sex, then stack them, and use a variable called <code>$cod</code> with a unique values for each data chunk. Different values of <code>$cod</code> could indicate sexes, regions, intercensal periods, etc. The <code>$deaths</code> column should refer to the average annual deaths in each age class in the intercensal period. Sometimes one uses the arithmetic average of recorded deaths in each age, or simply the average of the deaths around the time of census 1 and census 2. To identify an age-range in the traditional visual way, see <code>plot.ggb()</code>, when working with a single year/sex/region of data. The automatic age-range determination feature of this function tries to implement an intuitive way of picking ages that follows the advice typically given for doing so visually. We minimize the square of the average squared residual between the fitted line and right term. Finally, only specify <code>eOpen</code> when working with a single region/sex/period of data, otherwise the same value will be passed in irrespective of mortality and sex.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns for the coverage coefficient <code>$coverage</code>, and the minimum <code>$lower</code> and maximum <code>$upper</code> of the age range on which it is based. Rows indicate data partitions, as indicated by the optional <code>$cod</code> variable.
</p>


<h3>References</h3>

<p>Hill K. Methods for measuring adult mortality in developing countries: a comparative review. The global burden of disease 2000 in aging populations. Research paper; No. 01.13; 2001.
</p>
<p>Hill K, You D, Choi Y.  Death distribution methods for estimating adult mortality: sensitivity analysis with simulated data errors. Demographic Research. 2009; 21:235-254.
</p>
<p>Preston, S. H., Coale, A. J., Trussel, J. &amp; Maxine, W. Estimating the completeness of reporting of adult deaths in populations that are approximately stable.  Population Studies, 1980; v.4: 179-202
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The Mozambique data
res &lt;- ggbseg(Moz)
res
# The Brasil data
BM &lt;- ggbseg(BrasilMales)
BF &lt;- ggbseg(BrasilFemales)
head(BM)
head(BF)
</code></pre>

<hr>
<h2 id='ggbsegCoverageFromYear'>estimate death registration coverage for a single year/sex/region using the modified Bennett-Horiuchi method</h2><span id='topic+ggbsegCoverageFromYear'></span>

<h3>Description</h3>

<p>Given two censuses and an average annual number of deaths in each age class between censuses, we can use stable population assumptions to estimate the degree of underregistration of deaths. The method estimates age-specific degrees of coverage. The age pattern of these is assumed to be noisy, so we take the arithmetic mean over some range of ages. One may either specify a particular age-range, or let the age range be determined automatically. If the age-range is found automatically, this is done using the method developed for the generalized growth-balance method. Part of this method relies on a prior value for remaining life expectancy in the open age group. By default, this is estimated using a standard reference to the Coale-Demeny West model life table, although the user may also supply a value. The difference between this method and <code>seg()</code> is that here we adjust census 1 part way through processing, based on some calculations similar to GGB. Called by <code>ggbseg()</code>. Users probably do not need to use this function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbsegCoverageFromYear(codi, minA = 15, maxA = 75, minAges = 8,
  exact.ages = NULL, eOpen = NULL, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbsegCoverageFromYear_+3A_codi">codi</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, <code>$sex</code>, <code>$age</code>, and <code>$cod</code> (to indicate regions, periods, sexes).</p>
</td></tr>
<tr><td><code id="ggbsegCoverageFromYear_+3A_mina">minA</code></td>
<td>
<p>the minimum of the age range searched. Default 15</p>
</td></tr>
<tr><td><code id="ggbsegCoverageFromYear_+3A_maxa">maxA</code></td>
<td>
<p>the maximum of the age range searched. Default 75</p>
</td></tr>
<tr><td><code id="ggbsegCoverageFromYear_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages needed as points for fitting. Default 8</p>
</td></tr>
<tr><td><code id="ggbsegCoverageFromYear_+3A_exact.ages">exact.ages</code></td>
<td>
<p>optional. use an exact set of ages to estimate coverage.</p>
</td></tr>
<tr><td><code id="ggbsegCoverageFromYear_+3A_eopen">eOpen</code></td>
<td>
<p>optional. A user-specified value for remaining life-expectancy in the open age group.</p>
</td></tr>
<tr><td><code id="ggbsegCoverageFromYear_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Census dates can be given in a variety of ways: 1) using Date classes, and column names <code>$date1</code> and <code>$date2</code> (or an unambiguous character string of the date, like, <code>"1981-05-13"</code>) or 2) by giving column names <code>"day1","month1","year1","day2","month2","year2"</code> containing integers. If only <code>year1</code> and <code>year2</code> are given, then we assume January 1 dates. If year and month are given, then we assume dates on the first of the month.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns for the coverage coefficient, and the min and max of the age range on which it is based.
</p>

<hr>
<h2 id='ggbsegMakeColumns'>make the Bennett-Horiuchi quasi life table columns required by the second estimation method</h2><span id='topic+ggbsegMakeColumns'></span>

<h3>Description</h3>

<p>Called by <code>ggbsegCoverageFromYear()</code>. This simply modulates some code that would otherwise be repeated. Users probably don't need to call this function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbsegMakeColumns(codi, minA = 15, maxA = 75, agesFit, eOpen = NULL,
  deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbsegMakeColumns_+3A_codi">codi</code></td>
<td>
<p>a chunk of data (single sex, year, region, etc) with all columns required by <code>ggbseg()</code></p>
</td></tr>
<tr><td><code id="ggbsegMakeColumns_+3A_mina">minA</code></td>
<td>
<p>the minimum of the age range searched. Default 15</p>
</td></tr>
<tr><td><code id="ggbsegMakeColumns_+3A_maxa">maxA</code></td>
<td>
<p>the maximum of the age range searched. Default 75</p>
</td></tr>
<tr><td><code id="ggbsegMakeColumns_+3A_agesfit">agesFit</code></td>
<td>
<p>vector of ages as passed in by <code>ggbsegCoverageFromYear)</code></p>
</td></tr>
<tr><td><code id="ggbsegMakeColumns_+3A_eopen">eOpen</code></td>
<td>
<p>optional. A value for remaining life expectancy in the open age group.</p>
</td></tr>
<tr><td><code id="ggbsegMakeColumns_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>agesFit</code> is a vector passed in from <code>ggbsegMakeColumns()</code>, and it was either estimated using the GGB automatic method there, or simply came from the argument <code>exact.ages</code> specified in <code>ggbseg()</code>. By default we just automatically estimate these. <code>eOpen</code> can be either user-specified, or it will be estimated automatically using <code>eOpenCD()</code>.
</p>


<h3>Value</h3>

<p>codi, with many columns added, most importantly <code>$Cx</code>.
</p>

<hr>
<h2 id='group01'>group down standard abridged data in child mortality group</h2><span id='topic+group01'></span>

<h3>Description</h3>

<p>We want 5-year age groups starting from 0. Standard abridged data has 0i,1,5. So we need to group together 0 and 1. Just for the sake of getting comparable results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group01(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group01_+3A_x">X</code></td>
<td>
<p>standard input as required by <code>ddm()</code>, <code>ggb()</code>, <code>bh1()</code>, or <code>bh2()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>X, with child ages grouped as necessary (or not)
</p>

<hr>
<h2 id='guessage'>which age is closest to the point clicked?</h2><span id='topic+guessage'></span>

<h3>Description</h3>

<p>a utility function called by <code>ggbChooseAges()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guessage(xvec, yvec, click, age)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guessage_+3A_xvec">xvec</code></td>
<td>
<p><code>$rightterm</code>, as given by <code>ggbMakeColumns()</code></p>
</td></tr>
<tr><td><code id="guessage_+3A_yvec">yvec</code></td>
<td>
<p><code>$lefttterm</code>, as given by <code>ggbMakeColumns()</code></p>
</td></tr>
<tr><td><code id="guessage_+3A_click">click</code></td>
<td>
<p>a point given by <code>locator(1)</code></p>
</td></tr>
<tr><td><code id="guessage_+3A_age">age</code></td>
<td>
<p>ages present in dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the age corresponding to the x,y pair of <code>$rightterm</code>, <code>$lefttterm</code> closest to the point clicked.
</p>

<hr>
<h2 id='guessDeathsColumn'>Figure out which column is the deaths column</h2><span id='topic+guessDeathsColumn'></span>

<h3>Description</h3>

<p>This function will pick up <code>"death"</code>, <code>"deaths"</code>, <code>"Death"</code>, or <code>"Deaths"</code> (and maybe some others?) and rename it <code>"deaths"</code> for easier internal usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guessDeathsColumn(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guessDeathsColumn_+3A_x">X</code></td>
<td>
<p><code>data.frame</code> that we want to check for a deaths column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same <code>data.frame</code>, returned, with the deaths column renamed as <code>"deaths"</code>
</p>

<hr>
<h2 id='headerPrep'>a utility function to prep the header</h2><span id='topic+headerPrep'></span>

<h3>Description</h3>

<p>This is an internal utility function, to save on redundant lines of code. Not so useful for hand-processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headerPrep(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headerPrep_+3A_x">X</code></td>
<td>
<p>this is any codi-style <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of codi chunks (by intercensal period, region, etc), with standardized names, dates, etc.
</p>

<hr>
<h2 id='HMDlogic'>Logical utility functions</h2><span id='topic+HMDlogic'></span><span id='topic+logic'></span><span id='topic+HMDutils'></span><span id='topic++25+3D+3D+25'></span><span id='topic++25+21+3D+25'></span><span id='topic++25+3E+25'></span><span id='topic++25+3C+25'></span><span id='topic++25+3E+3D+25'></span><span id='topic++25+3C+3D+25'></span>

<h3>Description</h3>

<p>These logical functions are like the usual ones, but <code>NA</code> values are treated as <code>FALSE</code> by default. This is not an exhaustive list, but these are the ones that speed our coding, and reduce code clutter. Functions copied from HMD collection directly as-is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %==% y

x %!=% y

x %&gt;% y

x %&lt;% y

x %&gt;=% y

x %&lt;=% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HMDlogic_+3A_x">x</code>, <code id="HMDlogic_+3A_y">y</code></td>
<td>
<p>any two vectors that can be logically compared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that one of these, <code>%&gt;%</code> makes this package incompatible with the <code>magrittr</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
c(1,2,NA,4,5) == c(1,NA,3,4,NA)
# compare
c(1,2,NA,4,5) %==% c(1,NA,3,4,NA)

## End(Not run)
</code></pre>

<hr>
<h2 id='inUSR'>does a given pairlist of x and y coordinates fall within the plot region?</h2><span id='topic+inUSR'></span>

<h3>Description</h3>

<p>Check to see if a point clicked falls in the plot or outside it. This function is used by <code>ggbChooseAges()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inUSR(USR, click)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inUSR_+3A_usr">USR</code></td>
<td>
<p>as given by <code>par("usr")</code></p>
</td></tr>
<tr><td><code id="inUSR_+3A_click">click</code></td>
<td>
<p>a pairlist with elements <code>$x</code> and <code>$y</code>, as returned by <code>locator(1)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical. <code>TRUE</code> if in the plot region.
</p>

<hr>
<h2 id='isLeapYear'>determine whether a year is a leap year.</h2><span id='topic+isLeapYear'></span>

<h3>Description</h3>

<p>In order to remove <code>lubridate</code> dependency, we self-detect leap years and adjust February accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isLeapYear(Year)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isLeapYear_+3A_year">Year</code></td>
<td>
<p>integer of year to query</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical is the Year a leap year or not
</p>


<h3>Author(s)</h3>

<p>Carl Boe
</p>

<hr>
<h2 id='Moz'>Example data for Mozambique females 1997-2007</h2><span id='topic+Moz'></span>

<h3>Description</h3>

<p>A dataset containing 17 rows and 8 variables: Population counts for 1997 and 2007 in quinquennial age groups 0, 5, ... 75, with an open age of 80. Deaths are given as the average of the age-specific deaths in 1997 and 2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Moz
</code></pre>


<h3>Format</h3>

<p>A data frame with 17 rows and 8 variables:
</p>

<dl>
<dt>cod</dt><dd><p>integer a column of 1s  </p>
</dd>
<dt>pop1</dt><dd><p>integer the census population count in 1997</p>
</dd>
<dt>pop2</dt><dd><p>integer the census population count in 2007</p>
</dd>
<dt>deaths</dt><dd><p>integer average of 1997 and 2007 deaths</p>
</dd>
<dt>age</dt><dd><p>integer lower age bound for each age group</p>
</dd>
<dt>sex</dt><dd><p>character &ldquo;f&rdquo; for female</p>
</dd>
<dt>year1</dt><dd><p>integer 1997</p>
</dd>
<dt>year2</dt><dd><p>integer 2007</p>
</dd>
</dl>


<h3>Source</h3>

<p>Data courtesy of Bernardo Queiroz.
</p>

<hr>
<h2 id='reduceOpen'>chop down or group down the open age</h2><span id='topic+reduceOpen'></span>

<h3>Description</h3>

<p>These methods are not intended to be applied to ages greater than, say 90 or 95. Usually, we'd top out in the range 75 to 85. In any case, the Coale-Demeny life table implementation that we have only goes up to age 95, so there is a practical limitation to deriving a remaining life expectancy for the open age group. If a user tries to apply the Bennett-Horiuchi methods to data with higher open ages, stuff breaks for the time being. So this function chops the data off at <code>min(maxA,95)</code>, after having (optionally) grouped data down. This function needs to work with a single partition of data (intercensal period, sex, region, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceOpen(X, maxA = 75, group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceOpen_+3A_x">X</code></td>
<td>
<p>data formatted per the requirements of <code>bh1()</code>, <code>bh2()</code></p>
</td></tr>
<tr><td><code id="reduceOpen_+3A_maxa">maxA</code></td>
<td>
<p>integer ignore ages above this age.</p>
</td></tr>
<tr><td><code id="reduceOpen_+3A_group">group</code></td>
<td>
<p>logical. If <code>TRUE</code> we sum down to <code>min(maxA,95)</code>. If <code>FALSE</code>, we just chop off data above that age.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X, with the open age having been reduced either with or without aggregation.
</p>

<hr>
<h2 id='seg'>estimate death registration coverage using the synthetic extinct generation method</h2><span id='topic+seg'></span>

<h3>Description</h3>

<p>Given two censuses and an average annual number of deaths in each age class between censuses, we can use stable population assumptions to estimate the degree of underregistration of deaths. The method estimates age-specific degrees of coverage. The age pattern of these is assumed to be noisy, so we take the arithmetic mean over some range of ages. One may either specify a particular age-range, or let the age range be determined automatically. If the age-range is found automatically, this is done using the method developed for the generalized growth-balance method. Part of this method relies on a prior value for remaining life expectancy in the open age group. By default, this is estimated using a standard reference to the Coale-Demeny West model life table, although the user may also supply a value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg(X, minA = 15, maxA = 75, minAges = 8, exact.ages = NULL,
  eOpen = NULL, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seg_+3A_x">X</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, <code>$age</code>, <code>$sex</code>, and <code>$cod</code> (if there are more than 1 region/sex/intercensal period).</p>
</td></tr>
<tr><td><code id="seg_+3A_mina">minA</code></td>
<td>
<p>the lowest age to be included in search</p>
</td></tr>
<tr><td><code id="seg_+3A_maxa">maxA</code></td>
<td>
<p>the highest age to be included in search (the lower bound thereof)</p>
</td></tr>
<tr><td><code id="seg_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages to be used in estimating</p>
</td></tr>
<tr><td><code id="seg_+3A_exact.ages">exact.ages</code></td>
<td>
<p>optional. A user-specified vector of exact ages to use for coverage estimation</p>
</td></tr>
<tr><td><code id="seg_+3A_eopen">eOpen</code></td>
<td>
<p>optional. A user-specified value for remaining life-expectancy in the open age group.</p>
</td></tr>
<tr><td><code id="seg_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Census dates can be given in a variety of ways: 1) using Date classes, and column names <code>$date1</code> and <code>$date2</code> (or an unambiguous character string of the date, like, <code>"1981-05-13"</code>) or 2) by giving column names <code>"day1","month1","year1","day2","month2","year2"</code> containing integers. If only <code>year1</code> and <code>year2</code> columns are given, then we assume January 1 dates. If year and month are given, then we assume dates on the first of the month. If you want coverage estimates for a variety of intercensal periods/regions/by sex, then stack them, and use a variable called <code>$cod</code> with a unique values for each data chunk. Different values of <code>$cod</code> could indicate sexes, regions, intercensal periods, etc. The <code>$deaths</code> column should refer to the average annual deaths in each age class in the intercensal period. Sometimes one uses the arithmetic average of recorded deaths in each age, or simply the average of the deaths around the time of census 1 and census 2. To identify an age-range in the traditional visual way, see <code>plot.ggb()</code>, when working with a single year/sex/region of data. The automatic age-range determination feature of this function tries to implement an intuitive way of picking ages that follows the advice typically given for doing so visually. We minimize the square of the average squared residual between the fitted line and right term. Finally, only specify <code>eOpen</code> when working with a single region/sex/period of data, otherwise the same value will be passed in irrespective of mortality and sex.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns for the coverage coefficient <code>$coverage</code>, and the minimum <code>$lower</code> and maximum <code>$upper</code> of the age range on which it is based. Rows indicate data partitions, as indicated by the optional <code>$cod</code> variable. <code>$l25</code> (<code>$u25</code>) give the mean of the lower (upper) quartile of the distribution of age-specific coverage estimates.
</p>


<h3>References</h3>

<p>Bennett Neil G, Shiro Horiuchi. Estimating the completeness of death registration in a closed population. Population Index. 1981; 1:207-221.
</p>
<p>Preston, S. H., Coale, A. J., Trussel, J. &amp; Maxine, W. Estimating the completeness of reporting of adult deaths in populations that are approximately stable.  Population Studies, 1980; v.4: 179-202
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The Mozambique data
res &lt;- seg(Moz)
res
# The Brasil data
BM &lt;- seg(BrasilMales)
BF &lt;- seg(BrasilFemales)
head(BM)
head(BF)
</code></pre>

<hr>
<h2 id='segCoverageFromAges'>given a set of ages, what is the implied death registration coverage?</h2><span id='topic+segCoverageFromAges'></span>

<h3>Description</h3>

<p>For a single year/sex/region of data (formatted as required by <code>seg()</code>, <code>ggbseg()</code>), what is the registration coverage implied by a given age range? Called by <code>segCoverageFromYear()</code> and  <code>ggbsegCoverageFromYear()</code>. Here, the function simply takes the arithmetic mean of a given age range of <code>$Cx</code>, as returned by <code>segMakeColumns()</code> or <code>ggbsegMakeColumns()</code>. Not intended for top-level use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segCoverageFromAges(codi, agesFit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segCoverageFromAges_+3A_codi">codi</code></td>
<td>
<p>a chunk of data (single sex, year, region, etc) with all columns required by <code>ggb()</code></p>
</td></tr>
<tr><td><code id="segCoverageFromAges_+3A_agesfit">agesFit</code></td>
<td>
<p>an integer vector of ages, either returned from <code>ggbgetAgesFit</code> or user-supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. the estimated level of coverage.
</p>

<hr>
<h2 id='segCoverageFromYear'>estimate death registration coverage for a single year/sex/region using the Bennett-Horiuchi method</h2><span id='topic+segCoverageFromYear'></span>

<h3>Description</h3>

<p>Given two censuses and an average annual number of deaths in each age class between censuses, we can use stable population assumptions to estimate the degree of underregistration of deaths. The method estimates age-specific degrees of coverage. The age pattern of these is assumed to be noisy, so we take the arithmetic mean over some range of ages. One may either specify a particular age-range, or let the age range be determined automatically. If the age-range is found automatically, this is done using the method developed for the generalized growth-balance method. Part of this method relies on a prior value for remaining life expectancy in the open age group. By default, this is estimated using a standard reference to the Coale-Demeny West model life table, although the user may also supply a value. Called by <code>seg()</code>. Users probably do not need to use this function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segCoverageFromYear(codi, minA = 15, maxA = 75, minAges = 8,
  exact.ages = NULL, eOpen = NULL, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segCoverageFromYear_+3A_codi">codi</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, <code>$sex</code>, <code>$age</code>, and <code>$cod</code> (to indicate regions, periods, sexes).</p>
</td></tr>
<tr><td><code id="segCoverageFromYear_+3A_mina">minA</code></td>
<td>
<p>the minimum of the age range searched. Default 15</p>
</td></tr>
<tr><td><code id="segCoverageFromYear_+3A_maxa">maxA</code></td>
<td>
<p>the maximum of the age range searched. Default 75</p>
</td></tr>
<tr><td><code id="segCoverageFromYear_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages needed as points for fitting. Default 8</p>
</td></tr>
<tr><td><code id="segCoverageFromYear_+3A_exact.ages">exact.ages</code></td>
<td>
<p>optional. use an exact set of ages to estimate coverage.</p>
</td></tr>
<tr><td><code id="segCoverageFromYear_+3A_eopen">eOpen</code></td>
<td>
<p>optional. A user-specified value for remaining life-expectancy in the open age group.</p>
</td></tr>
<tr><td><code id="segCoverageFromYear_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Census dates can be given in a variety of ways: 1) using Date classes, and column names <code>$date1</code> and <code>$date2</code> (or an unambiguous character string of the date, like, <code>"1981-05-13"</code>) or 2) by giving column names <code>"day1","month1","year1","day2","month2","year2"</code> containing integers. If only <code>year1</code> and <code>year2</code> are given, then we assume January 1 dates. If year and month are given, then we assume dates on the first of the month.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns for the coverage coefficient, and the min and max of the age range on which it is based.
</p>

<hr>
<h2 id='segMakeColumns'>make the Bennett-Horiuchi quasi life table columns required by the estimation method</h2><span id='topic+segMakeColumns'></span>

<h3>Description</h3>

<p>Called by <code>segCoverageFromYear()</code>. This simply modulates some code that would otherwise be repeated. Users probably don't need to call this function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segMakeColumns(codi, minA = 15, maxA = 75, eOpen = NULL,
  deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segMakeColumns_+3A_codi">codi</code></td>
<td>
<p>a chunk of data (single sex, year, region, etc) with all columns required by <code>seg()</code></p>
</td></tr>
<tr><td><code id="segMakeColumns_+3A_mina">minA</code></td>
<td>
<p>the minimum of the age range searched. Default 15</p>
</td></tr>
<tr><td><code id="segMakeColumns_+3A_maxa">maxA</code></td>
<td>
<p>the maximum of the age range searched. Default 75</p>
</td></tr>
<tr><td><code id="segMakeColumns_+3A_eopen">eOpen</code></td>
<td>
<p>optional. A value for remaining life expectancy in the open age group.</p>
</td></tr>
<tr><td><code id="segMakeColumns_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>codi, with many columns added, most importantly <code>$Cx</code>.
</p>

<hr>
<h2 id='segplot'>plot the age-pattern of coverage estimates</h2><span id='topic+segplot'></span>

<h3>Description</h3>

<p>the SEG method works by averaging the coverage estimates over a range of ages. 
Users may wish to see the age pattern for diagnostic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segplot(X, minA = 15, maxA = 75, minAges = 8, exact.ages = NULL,
  eOpen = NULL, deaths.summed = FALSE, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segplot_+3A_x">X</code></td>
<td>
<p><code>data.frame</code> with columns, <code>$pop1</code>, <code>$pop2</code>, <code>$deaths</code>, <code>$date1</code>, <code>$date2</code>, <code>$age</code>, <code>$sex</code>, and <code>$cod</code> (if there are more than 1 region/sex/intercensal period).</p>
</td></tr>
<tr><td><code id="segplot_+3A_mina">minA</code></td>
<td>
<p>the lowest age to be included in search</p>
</td></tr>
<tr><td><code id="segplot_+3A_maxa">maxA</code></td>
<td>
<p>the highest age to be included in search (the lower bound thereof)</p>
</td></tr>
<tr><td><code id="segplot_+3A_minages">minAges</code></td>
<td>
<p>the minimum number of adjacent ages to be used in estimating</p>
</td></tr>
<tr><td><code id="segplot_+3A_exact.ages">exact.ages</code></td>
<td>
<p>optional. A user-specified vector of exact ages to use for coverage estimation</p>
</td></tr>
<tr><td><code id="segplot_+3A_eopen">eOpen</code></td>
<td>
<p>optional. A user-specified value for remaining life-expectancy in the open age group.</p>
</td></tr>
<tr><td><code id="segplot_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
<tr><td><code id="segplot_+3A_log">log</code></td>
<td>
<p>logical. should we log the y axis?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All arguments are essentially the same as those given to <code>seg()</code>
</p>


<h3>Value</h3>

<p>Function called for its graphical side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
segplot(Moz)

## End(Not run)
</code></pre>

<hr>
<h2 id='single2abr'>single ages to standard abridged ages</h2><span id='topic+single2abr'></span>

<h3>Description</h3>

<p>convert ages of the form 0,1,2,3,4,5,... into 0,1,1,1,1,5,...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single2abr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single2abr_+3A_x">x</code></td>
<td>
<p>vector of single ages (lower bound) a.k.a. completed age.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of the same length indicating which abridged age group each single age belongs to (lower bound)
</p>

<hr>
<h2 id='slopeint'>get the slope the slope and intercept implied by a set of ages</h2><span id='topic+slopeint'></span>

<h3>Description</h3>

<p>Called by <code>ggbFittedFromAges()</code> and <code>ggbChooseAges()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slopeint(codi, agesfit, deaths.summed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slopeint_+3A_codi">codi</code></td>
<td>
<p><code>data.frame</code> as produced by <code>ggbMakeColumns()</code></p>
</td></tr>
<tr><td><code id="slopeint_+3A_agesfit">agesfit</code></td>
<td>
<p>a set of ages to estimate coverage from</p>
</td></tr>
<tr><td><code id="slopeint_+3A_deaths.summed">deaths.summed</code></td>
<td>
<p>logical. is the deaths column given as the total per age in the intercensal period (<code>TRUE</code>). By default we assume <code>FALSE</code>, i.e. that the average annual was given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pairlist with elements <code>$a</code> for the intercept and <code>$b</code> for the slope
</p>

<hr>
<h2 id='yint'>get interval as fraction of full years</h2><span id='topic+yint'></span>

<h3>Description</h3>

<p>Either assume 365 days in the year, or get the precise duration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yint(Day1, Month1, Year1, Day2, Month2, Year2, reproduce.matlab = FALSE,
  detect.mid.year = TRUE, detect.start.end = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yint_+3A_day1">Day1</code></td>
<td>
<p>Day of first date</p>
</td></tr>
<tr><td><code id="yint_+3A_month1">Month1</code></td>
<td>
<p>Month of first date</p>
</td></tr>
<tr><td><code id="yint_+3A_year1">Year1</code></td>
<td>
<p>Year of first date</p>
</td></tr>
<tr><td><code id="yint_+3A_day2">Day2</code></td>
<td>
<p>Day of second date</p>
</td></tr>
<tr><td><code id="yint_+3A_month2">Month2</code></td>
<td>
<p>Month of second date</p>
</td></tr>
<tr><td><code id="yint_+3A_year2">Year2</code></td>
<td>
<p>Year of second date</p>
</td></tr>
<tr><td><code id="yint_+3A_reproduce.matlab">reproduce.matlab</code></td>
<td>
<p>logical. default <code>FALSE</code>. Assume 365 days in all years?</p>
</td></tr>
<tr><td><code id="yint_+3A_detect.mid.year">detect.mid.year</code></td>
<td>
<p>logical. default <code>TRUE</code>. Should June 30 and July 1 be considered .5?</p>
</td></tr>
<tr><td><code id="yint_+3A_detect.start.end">detect.start.end</code></td>
<td>
<p>logical. default <code>TRUE</code>. Should Jan 1 always be 0 and Dec 31 always be 1?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>decimal value of year fraction (can be greater than 1)
</p>

<hr>
<h2 id='yint2'>get the time interval without having to specify so many arguments</h2><span id='topic+yint2'></span>

<h3>Description</h3>

<p>We accept dates, and fake them otherwise. Dates must be unique. Iterate over data if necessary for multiple intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yint2(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yint2_+3A_x">X</code></td>
<td>
<p><code>data.frame</code> with at least columns <code>$date1</code> and <code>$date2</code>, or <code>$year1</code> and <code>$year2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an decimal year value of the time between two dates.
</p>

<hr>
<h2 id='ypart'>determine the proportion of a year passed as of a particular date</h2><span id='topic+ypart'></span>

<h3>Description</h3>

<p>The fraction returned by this is used e.g. for intercensal estimates. Function uses 'lubridate' package to handle dates elegantly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ypart(Year, Month, Day, reproduce.matlab = TRUE, detect.mid.year = FALSE,
  detect.start.end = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ypart_+3A_year">Year</code></td>
<td>
<p>4-digit year (string or integer)</p>
</td></tr>
<tr><td><code id="ypart_+3A_month">Month</code></td>
<td>
<p>month digits (string or integer, 1 or 2 characters)</p>
</td></tr>
<tr><td><code id="ypart_+3A_day">Day</code></td>
<td>
<p>Day of month digits (string or integer, 1 or 2 characters)</p>
</td></tr>
<tr><td><code id="ypart_+3A_reproduce.matlab">reproduce.matlab</code></td>
<td>
<p>logical. Default TRUE. Assume 365 days in a year.</p>
</td></tr>
<tr><td><code id="ypart_+3A_detect.mid.year">detect.mid.year</code></td>
<td>
<p>logical. if <code>TRUE</code>, June 30 or July 1 will always return .5.</p>
</td></tr>
<tr><td><code id="ypart_+3A_detect.start.end">detect.start.end</code></td>
<td>
<p>logical. default <code>TRUE</code>. Should Jan 1 always be 0 and Dec 31 always be 1?</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
