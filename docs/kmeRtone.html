<!DOCTYPE html><html lang="en"><head><title>Help for package kmeRtone</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kmeRtone}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addAlphaCol'><p>Add transparency to color.</p></a></li>
<li><a href='#bedToCoor'><p>Convert a BED file to chromosome-separated csv files.</p></a></li>
<li><a href='#buildControl'><p>Build control regions</p></a></li>
<li><a href='#buildKmerTable'><p>Count k-mers from given sequence(s) and build a data.table of k-mer counts.</p></a></li>
<li><a href='#buildMidPatternKmerTable'><p>Count k-mers with specified middle pattern from given sequence(s) and build</p>
a data.table of k-mer counts.</a></li>
<li><a href='#buildRangedKmerTable'><p>Count kmers from a sequence in given ranges and build a data.table of k-mer</p>
counts.</a></li>
<li><a href='#buildRESTurl'><p>Function constructs a URL for a REST API call by appending query parameters.</p></a></li>
<li><a href='#calKmerSkew'><p>Function calculates the skew of k-mers based on their occurrence in</p>
positive and negative strands.</a></li>
<li><a href='#calPWM'><p>Calculate position weight matrix of overlapping sequences.</p>
Simulation of human population is based on single nucleotide variation.</a></li>
<li><a href='#catHeader'><p>Function prints a given message in a formatted header with borders.</p></a></li>
<li><a href='#Coordinate'><p>Loading, manipulating, and analyzing coordinate data.</p></a></li>
<li><a href='#count_substring_fixed'><p>Count sequence content in a given sequence.</p></a></li>
<li><a href='#count_substring_regex'><p>Count sequence content in a given sequence.</p></a></li>
<li><a href='#countBaseComposition'><p>Function performs an analysis of base composition including sequence</p>
frequency, PWM calculations, and G/C content at various window sizes.</a></li>
<li><a href='#countChoppedKmers'><p>Function chops k-mers within specified ranges of a sequence and counts</p>
them. It uses either a substring method or functionalities from the
Biostrings package.</a></li>
<li><a href='#countDistribution'><p>Function performs an analysis of the distribution of genomic cases.</p></a></li>
<li><a href='#countKmers'><p>Count k-mers from string(s) using a simple hash table.</p></a></li>
<li><a href='#countMidPatternContext2'><p>Locate a middle sequence pattern and count its sequence context.</p></a></li>
<li><a href='#countMidPatternKmers'><p>Count Relevant K-mers with Specified Middle Pattern from Sequence String(s)</p></a></li>
<li><a href='#countPointContext2'><p>Ccount sequence context of given point positions.</p></a></li>
<li><a href='#countRangedKmers'><p>Count k-mers in given ranges of a sequence.</p></a></li>
<li><a href='#countRevCompKmers'><p>Count reverse complement sequence from its opposite strand.</p>
Build for k-mer table generated from initKmerTable function but applicable to
others with the same format.</a></li>
<li><a href='#countSlidingWindow'><p>Count sequence content in a sliding window of a sequence.</p></a></li>
<li><a href='#countSlidingWindow2'><p>Count sequence content in a sliding window of a sequence.</p></a></li>
<li><a href='#downloadNCBIGenomes'><p>Function downloads genome fasta files from the NCBI FTP database. Users can</p>
provide either organism names or an assembly summary data table.</a></li>
<li><a href='#downloadUCSCgenome'><p>Function downloads chromosome-separated fasta genome sequences from the UCSC</p>
database. Users can specify a genome name, an output folder, and a specific
chromosome or chromosomes. There's an option to choose the download method as well.</a></li>
<li><a href='#example_genome_coor'><p>Example genome coordinate file</p></a></li>
<li><a href='#example_kmeRtone_score'><p>Example 2-mer enrichment/depletion scores</p></a></li>
<li><a href='#EXPLORE'><p>Function generates various exploratory analyses.</p></a></li>
<li><a href='#extractKmers'><p>Extract k-mers from a given Coordinate object and Genome objects</p></a></li>
<li><a href='#generateGenicElementCoor'><p>Function processes UCSC genePred tables to generate coordinates for</p>
various genic elements like introns, exons, CDS, UTRs, and upstream and
downstream regions. It handles these coordinates with consideration for
strand sensitivity and genome information.</a></li>
<li><a href='#generateIntergenicCoor'><p>Resolve and generate genic element coordinates from UCSC genePred table.</p></a></li>
<li><a href='#getCOSMICauthURL'><p>Get COSMIC authenticated URL.</p></a></li>
<li><a href='#getCOSMICcancerGeneCensus'><p>Get Cancer Gene Census (CGC) from COSMIC database.</p></a></li>
<li><a href='#getCOSMIClatestVersion'><p>Function retrieves the latest version information of the COSMIC database</p>
and the associated genome version by scraping data from the COSMIC website.</a></li>
<li><a href='#getCOSMICmutantExport'><p>Function downloads the latest Cosmic Mutant Export data from the COSMIC</p>
database. It requires the user to be registered with COSMIC for non-commercial
use. The function constructs the URL for the latest mutant export file,
authenticates the URL, and then downloads the data.</a></li>
<li><a href='#getEnsemblData'><p>A generic function to get Ensembl data persistently from a URL. This is an</p>
internal function used by other getEnsemblXXX functions.</a></li>
<li><a href='#getEnsemblRegionFeatures'><p>Get features of a given region.</p></a></li>
<li><a href='#getEnsemblVariantFeatures'><p>Get features of given variant IDs.</p></a></li>
<li><a href='#getEnsemblVariantFeatures_serial'><p>Get features of given variant IDs.</p></a></li>
<li><a href='#getGnomADvariants'><p>Get gnomAD VCF file using tabix.</p></a></li>
<li><a href='#getICTVvirusMetadataResource'><p>Get Virus Metadata Resource (VMR) from International Committee on Taxonomy</p>
of Viruses (ICTV)</a></li>
<li><a href='#getNCBIassemblySummary'><p>Get NCBI assembly summary.</p></a></li>
<li><a href='#getScores'><p>Function calculates scores for k-mers based on case and control k-mer counts.</p></a></li>
<li><a href='#getUCSCgenePredTable'><p>Retrieve Gene Prediction Table from UCSC for a Given Genome</p></a></li>
<li><a href='#getVCFmetainfo'><p>Read VCF metainfo file using tabix.</p></a></li>
<li><a href='#initKmerTable'><p>Initialise k-mer table with all possible k-mers</p></a></li>
<li><a href='#Kmer_Table'><p>A R6 class wrapper for data.table</p></a></li>
<li><a href='#kmeRtone'><p>kmeRtone all-in-one user interface</p></a></li>
<li><a href='#loadCoordinate'><p>Build Coordinate object.</p></a></li>
<li><a href='#loadGenome'><p>Build Genome object.</p></a></li>
<li><a href='#loadGenomicContents'><p>Function calculates various genomic content metrics based on the provided genome object.</p></a></li>
<li><a href='#mapKmers'><p>Map k-mers of a given sequence and coordinate</p></a></li>
<li><a href='#mergeCoordinate'><p>Merge overlapping or continuous regions.</p></a></li>
<li><a href='#mixColors'><p>Mix color</p></a></li>
<li><a href='#NCBI_Genome'><p>Class constructor - build NCBI Genome object</p></a></li>
<li><a href='#partitionCoordinate'><p>Partition overlapping or continuous regions.</p></a></li>
<li><a href='#persistentDownload'><p>Download file until successful</p></a></li>
<li><a href='#readBED'><p>Read a BED file. One-based indexing is enforced.</p></a></li>
<li><a href='#readFASTA'><p>Read FASTA files.</p></a></li>
<li><a href='#readVCF'><p>Read VCF file using tabix.</p></a></li>
<li><a href='#readVCF2'><p>Read VCF file using tabix.</p></a></li>
<li><a href='#removeRegion'><p>Remove overlapping region in coordinate <code>data.table</code>.</p></a></li>
<li><a href='#reverseComplement'><p>Get reverse complement sequence of DNA</p></a></li>
<li><a href='#SCORE'><p>Calculate susceptibility scores for k-mers in case and control regions.</p></a></li>
<li><a href='#scoreKmers'><p>Function calculates the Z-score for each k-mer based on the observed</p>
case counts and expected case counts under the null hypothesis.</a></li>
<li><a href='#selectGenomesForCrossSpeciesStudy'><p>Select genomes for cross-species studies.</p></a></li>
<li><a href='#selectRepresentativeFromASM'><p>Select the best representative species from the NCBI assembly summary.</p></a></li>
<li><a href='#simulatePopulation'><p>Simulate a population given ranges of chromosome sequence to mutate.</p></a></li>
<li><a href='#splitFASTA'><p>Split a FASTA file by header.</p></a></li>
<li><a href='#STUDY_ACROSS_POPULATIONS'><p>Study k-mer composition of selected COSMIC causal cancer genes across human</p>
populations worldwide.</a></li>
<li><a href='#STUDY_ACROSS_SPECIES'><p>Study k-mer composition across species.</p></a></li>
<li><a href='#STUDY_CANCER_GENES'><p>Study k-mer composition of causal cancer genes from COSMIC Cancer Gene</p>
Census (CGC) database.</a></li>
<li><a href='#STUDY_GENIC_ELEMENTS'><p>Study k-mer composition across species.</p></a></li>
<li><a href='#system3'><p>A system2 wrapper. If anything happen, just give me error!</p></a></li>
<li><a href='#trimCoordinate'><p>Trim out-of-bound coordinates</p></a></li>
<li><a href='#UCSC_Genome'><p>Class constructor - build Genome object</p></a></li>
<li><a href='#writeBED'><p>Write a BED file. Zero-based indexing is enforced.</p></a></li>
<li><a href='#writeFASTA'><p>Write FASTA files.</p></a></li>
<li><a href='#writeVCF'><p>Write VCF file and compress using bgzip.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Purpose and Flexible k-Meric Enrichment Analysis Software</td>
</tr>
<tr>
<td>Description:</td>
<td>A multi-purpose and flexible k-meric enrichment analysis software. 
    'kmeRtone' measures the enrichment of k-mers by comparing the population of 
    k-mers in the case loci with a carefully devised internal negative control 
    group, consisting of k-mers from regions close to, yet sufficiently distant 
    from, the case loci to mitigate any potential sequencing bias. This method 
    effectively captures both the local sequencing variations and broader 
    sequence influences, while also correcting for potential biases, thereby 
    ensuring more accurate analysis. The core functionality of 'kmeRtone' is 
    the SCORE() function, which calculates the susceptibility scores for k-mers in 
    case and control regions. Case regions are defined by the genomic coordinates 
    provided in a file by the user and the control regions can be constructed 
    relative to the case regions or provided directly. The k-meric susceptibility 
    scores are calculated by using a one-proportion z-statistic. 'kmeRtone' is 
    highly flexible by allowing users to also specify their target k-mer patterns
    and quantify the corresponding k-mer enrichment scores in the context of 
    these patterns, allowing for a more comprehensive approach to understanding 
    the functional implications of specific DNA sequences on a genomic scale
    (e.g., CT motifs upon UV radiation damage).
    Adib A. Abdullah, Patrick Pflughaupt, Claudia Feng, Aleksandr B. Sahakyan (2024) Bioinformatics (submitted).</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.15.0), R6 (&ge; 2.5.1), Rcpp (&ge; 1.0.12),
R.utils (&ge; 2.12.3), openxlsx (&ge; 4.2.5.2), png (&ge; 0.1-8),
RcppSimdJson (&ge; 0.1.11), venneuler (&ge; 1.1-4), stringi, curl,
future, future.apply, jsonlite, progressr, Biostrings, seqLogo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, stringi</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SahakyanLab/kmeRtone">https://github.com/SahakyanLab/kmeRtone</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SahakyanLab/kmeRtone/issues">https://github.com/SahakyanLab/kmeRtone/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-26 14:25:31 UTC; paddy</td>
</tr>
<tr>
<td>Author:</td>
<td>Adib Abdullah [aut],
  Patrick Pflughaupt [aut],
  Aleksandr Sahakyan [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aleksandr Sahakyan &lt;sahakyanlab@cantab.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-30 10:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='addAlphaCol'>Add transparency to color.</h2><span id='topic+addAlphaCol'></span>

<h3>Description</h3>

<p>Add transparency to color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addAlphaCol(cols, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addAlphaCol_+3A_cols">cols</code></td>
<td>
<p>Colors in hex format or R color code e.g. &quot;red&quot;, &quot;black&quot;, etc.</p>
</td></tr>
<tr><td><code id="addAlphaCol_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Colors with alpha value in hex format.
</p>

<hr>
<h2 id='bedToCoor'>Convert a BED file to chromosome-separated csv files.</h2><span id='topic+bedToCoor'></span>

<h3>Description</h3>

<p>Convert a BED file to chromosome-separated csv files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedToCoor(bed.path, output.path = "coordinate/", compress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedToCoor_+3A_bed.path">bed.path</code></td>
<td>
<p>A path to a BED file.</p>
</td></tr>
<tr><td><code id="bedToCoor_+3A_output.path">output.path</code></td>
<td>
<p>Output directory path. It should be an empty directory.
Default to coordinate/</p>
</td></tr>
<tr><td><code id="bedToCoor_+3A_compress">compress</code></td>
<td>
<p>Logical. If TRUE, compress the output CSV files. Default to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='buildControl'>Build control regions</h2><span id='topic+buildControl'></span>

<h3>Description</h3>

<p>Build control regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildControl(
  case,
  k,
  ctrl.rel.pos,
  genome,
  output.path = "control/",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildControl_+3A_case">case</code></td>
<td>
<p>Case in Coordinate class object format.</p>
</td></tr>
<tr><td><code id="buildControl_+3A_k">k</code></td>
<td>
<p>Integer size of the expanded k-mer.</p>
</td></tr>
<tr><td><code id="buildControl_+3A_ctrl.rel.pos">ctrl.rel.pos</code></td>
<td>
<p>Control relative position.</p>
</td></tr>
<tr><td><code id="buildControl_+3A_genome">genome</code></td>
<td>
<p>Genome class object.</p>
</td></tr>
<tr><td><code id="buildControl_+3A_output.path">output.path</code></td>
<td>
<p>Output directory path to save control coordinate.</p>
</td></tr>
<tr><td><code id="buildControl_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Default is TRUE and will print progress updates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Control in Coordinate class object format.
</p>

<hr>
<h2 id='buildKmerTable'>Count k-mers from given sequence(s) and build a data.table of k-mer counts.</h2><span id='topic+buildKmerTable'></span>

<h3>Description</h3>

<p>Only existed k-mers are returned in data.table object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildKmerTable(dna.seqs, k, method = "auto", remove.N = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildKmerTable_+3A_dna.seqs">dna.seqs</code></td>
<td>
<p>String of sequence(s).</p>
</td></tr>
<tr><td><code id="buildKmerTable_+3A_k">k</code></td>
<td>
<p>Size of kmer.</p>
</td></tr>
<tr><td><code id="buildKmerTable_+3A_method">method</code></td>
<td>
<p>K-mer counting method: &quot;Biostrings&quot;, &quot;sliding&quot;, or &quot;auto&quot;.
Default is &quot;auto&quot;; For k &gt; 8, sliding method is used.</p>
</td></tr>
<tr><td><code id="buildKmerTable_+3A_remove.n">remove.N</code></td>
<td>
<p>Remove unknown base? Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> object with column kmer and N.
</p>

<hr>
<h2 id='buildMidPatternKmerTable'>Count k-mers with specified middle pattern from given sequence(s) and build
a data.table of k-mer counts.</h2><span id='topic+buildMidPatternKmerTable'></span>

<h3>Description</h3>

<p>Only existed k-mers are returned in data.table object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildMidPatternKmerTable(dna.seqs, k, mid.patterns, remove.N = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildMidPatternKmerTable_+3A_dna.seqs">dna.seqs</code></td>
<td>
<p>String of sequence(s).</p>
</td></tr>
<tr><td><code id="buildMidPatternKmerTable_+3A_k">k</code></td>
<td>
<p>Size of kmer.</p>
</td></tr>
<tr><td><code id="buildMidPatternKmerTable_+3A_mid.patterns">mid.patterns</code></td>
<td>
<p>Middle patterns.</p>
</td></tr>
<tr><td><code id="buildMidPatternKmerTable_+3A_remove.n">remove.N</code></td>
<td>
<p>Remove unknown base? Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> object with column kmer and N.
</p>

<hr>
<h2 id='buildRangedKmerTable'>Count kmers from a sequence in given ranges and build a data.table of k-mer
counts.</h2><span id='topic+buildRangedKmerTable'></span>

<h3>Description</h3>

<p>Count kmers from a sequence in given ranges and build a data.table of k-mer
counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRangedKmerTable(
  dna.seq,
  starts,
  ends,
  k,
  method = "sliding",
  chopping.method = "auto",
  remove.N = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildRangedKmerTable_+3A_dna.seq">dna.seq</code></td>
<td>
<p>String of sequence.</p>
</td></tr>
<tr><td><code id="buildRangedKmerTable_+3A_starts">starts</code></td>
<td>
<p>Start positions.</p>
</td></tr>
<tr><td><code id="buildRangedKmerTable_+3A_ends">ends</code></td>
<td>
<p>End positions.</p>
</td></tr>
<tr><td><code id="buildRangedKmerTable_+3A_k">k</code></td>
<td>
<p>Size of kmer.</p>
</td></tr>
<tr><td><code id="buildRangedKmerTable_+3A_method">method</code></td>
<td>
<p>Method options: &quot;sliding&quot; or &quot;chopping&quot;. Chopping consumes a
lot of memory for extremely long sequence using &quot;substring&quot; method. Using
&quot;Biostrings&quot; for k &gt; 12 is memory consuming. Default is &quot;sliding&quot;.</p>
</td></tr>
<tr><td><code id="buildRangedKmerTable_+3A_chopping.method">chopping.method</code></td>
<td>
<p>Chopping method: &quot;Biostrings&quot; or &quot;substring&quot;. Default
is &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="buildRangedKmerTable_+3A_remove.n">remove.N</code></td>
<td>
<p>Remove unknown base N? Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> object with column kmer and N.
</p>

<hr>
<h2 id='buildRESTurl'>Function constructs a URL for a REST API call by appending query parameters.</h2><span id='topic+buildRESTurl'></span>

<h3>Description</h3>

<p>Function constructs a URL for a REST API call by appending query parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRESTurl(url, .list = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildRESTurl_+3A_url">url</code></td>
<td>
<p>Base URL of the REST API.</p>
</td></tr>
<tr><td><code id="buildRESTurl_+3A_.list">.list</code></td>
<td>
<p>A list of named query parameters.</p>
</td></tr>
<tr><td><code id="buildRESTurl_+3A_...">...</code></td>
<td>
<p>additional optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string of the full REST API URL.
</p>

<hr>
<h2 id='calKmerSkew'>Function calculates the skew of k-mers based on their occurrence in
positive and negative strands.</h2><span id='topic+calKmerSkew'></span>

<h3>Description</h3>

<p>Function calculates the skew of k-mers based on their occurrence in
positive and negative strands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calKmerSkew(kmer.table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calKmerSkew_+3A_kmer.table">kmer.table</code></td>
<td>
<p>data.table with columns: kmer, pos_strand, neg_strand.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with the kmer_skew column.
</p>

<hr>
<h2 id='calPWM'>Calculate position weight matrix of overlapping sequences.
Simulation of human population is based on single nucleotide variation.</h2><span id='topic+calPWM'></span>

<h3>Description</h3>

<p>Calculate position weight matrix of overlapping sequences.
Simulation of human population is based on single nucleotide variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calPWM(
  kmers,
  pseudo.num = 0,
  bg.prop = c(a = 0.295, c = 0.205, g = 0.205, t = 0.295),
  output = "PWM"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calPWM_+3A_kmers">kmers</code></td>
<td>
<p>A vector of k-mers to overlap.</p>
</td></tr>
<tr><td><code id="calPWM_+3A_pseudo.num">pseudo.num</code></td>
<td>
<p>Pseudo-number to avoid numerical instability due to lack of
base at a position. Default is zero i.e. no pseudo-number.</p>
</td></tr>
<tr><td><code id="calPWM_+3A_bg.prop">bg.prop</code></td>
<td>
<p>Background proportion of bases. Default is c(a = 0.295,
c = 0.205, g = 0.205, t = 0.295) which is observed in human genome.</p>
</td></tr>
<tr><td><code id="calPWM_+3A_output">output</code></td>
<td>
<p>Output matrix type. Options are PCM, PPM, and PWM which refer
to position count/probability/weight matrix. Default is PWM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A position count/probability/weight matrix.
</p>

<hr>
<h2 id='catHeader'>Function prints a given message in a formatted header with borders.</h2><span id='topic+catHeader'></span>

<h3>Description</h3>

<p>Function prints a given message in a formatted header with borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catHeader(msg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="catHeader_+3A_msg">msg</code></td>
<td>
<p>message to be printed within the header.</p>
</td></tr>
</table>

<hr>
<h2 id='Coordinate'>Loading, manipulating, and analyzing coordinate data.</h2><span id='topic+Coordinate'></span>

<h3>Description</h3>

<p>Loading, manipulating, and analyzing coordinate data.
</p>
<p>Loading, manipulating, and analyzing coordinate data.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>root_path</code></dt><dd><p>A path to a directory containing coordinate files.</p>
</dd>
<dt><code>single_len</code></dt><dd><p>Single case length e.g. damage length. Default is NULL.</p>
</dd>
<dt><code>is_strand_sensitive</code></dt><dd><p>Coordinate strand polarity. Default is TRUE.</p>
</dd>
<dt><code>merge_replicate</code></dt><dd><p>Merge coordinate from different replicates.
Default is TRUE.</p>
</dd>
<dt><code>rm_dup</code></dt><dd><p>Remove duplicate entry in the coordinate table.
Default is TRUE.</p>
</dd>
<dt><code>add_col_rep</code></dt><dd><p>If add_col_rep is TRUE, column replicate is added to
the coordinate table. Default is TRUE.</p>
</dd>
<dt><code>paths</code></dt><dd><p>Individual coordinate files.</p>
</dd>
<dt><code>rep_names</code></dt><dd><p>Replicate names determined from coordinate subdirectory.</p>
</dd>
<dt><code>chr_names</code></dt><dd><p>Chromosome names determined from filenames.</p>
</dd>
<dt><code>coor</code></dt><dd><p>Chromosome-named list of coordinate data.table.</p>
</dd>
<dt><code>is_kmer</code></dt><dd><p>A data.table of is_kmer status. The first column is
original is_kmer status.</p>
</dd>
<dt><code>k</code></dt><dd><p>K-mer size when is_kmer is TRUE. When is_kmer is FALSE, k is NA.</p>
</dd>
<dt><code>ori_first_index</code></dt><dd><p>Original chromosome-separated table first index is
either starting from zero or one.</p>
</dd>
<dt><code>load_limit</code></dt><dd><p>Maximum coordinate table loaded.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Coordinate-new"><code>Coordinate$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Coordinate-mark_overlap"><code>Coordinate$mark_overlap()</code></a>
</p>
</li>
<li> <p><a href="#method-Coordinate-print"><code>Coordinate$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Coordinate-map_sequence"><code>Coordinate$map_sequence()</code></a>
</p>
</li>
<li> <p><a href="#method-Coordinate-clone"><code>Coordinate$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Coordinate-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Coordinate class
</p>


<h5>Usage</h5>

<div class="r"><pre>Coordinate$new(
  root.path,
  single.len,
  is.strand.sensitive,
  merge.replicate,
  rm.dup,
  add.col.rep,
  is.kmer,
  k,
  ori.first.index,
  load.limit
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>root.path</code></dt><dd><p>A path to a directory containing either:
(1) chromosome-separated coordinate files
(assume replicates for subdirectories) OR
(2) bedfile. (assume replicates for bedfiles)</p>
</dd>
<dt><code>single.len</code></dt><dd><p>Single case length e.g. damage length. Default is NULL</p>
</dd>
<dt><code>is.strand.sensitive</code></dt><dd><p>A boolean whether strand polarity matters.
Default is TRUE.</p>
</dd>
<dt><code>merge.replicate</code></dt><dd><p>Merge coordinate from different replicates.
Default is TRUE. If not merging, duplicates will give weight to the
kmer counting. If add_col_rep, merged coordinate will contain
column replicate e.g. &quot;rep1&amp;rep2&quot;.</p>
</dd>
<dt><code>rm.dup</code></dt><dd><p>Remove duplicates in each replicate. Default is FALSE
Default is FALSE</p>
</dd>
<dt><code>add.col.rep</code></dt><dd><p>Add column replicate to coordinate table.</p>
</dd>
<dt><code>is.kmer</code></dt><dd><p>Is the coordinate refers to k-mer i.e. expanded case?
Default is FALSE.</p>
</dd>
<dt><code>k</code></dt><dd><p>Length of k-mer if is_kmer is TRUE.</p>
</dd>
<dt><code>ori.first.index</code></dt><dd><p>Zero- or one-based index. Default is 1.</p>
</dd>
<dt><code>load.limit</code></dt><dd><p>Maximum coordinate data.table loaded. Default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Coordinate</code> object.
</p>


<hr>
<a id="method-Coordinate-["></a>



<h4>Method <code>[()</code></h4>

<p>Calling coordinate table by loading on demand. Maximum load is determine
by load_limit field.
</p>


<h5>Usage</h5>

<div class="r"><pre>Coordinate$[(
  chr.name,
  state = "current",
  k,
  reload = FALSE,
  rm.other.cols = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chr.name</code></dt><dd><p>Chromosome name. It can be a vector of chromosomes.</p>
</dd>
<dt><code>state</code></dt><dd><p>Coordinate state: &quot;current&quot;, &quot;case&quot;, &quot;kmer&quot;. The coordinate
state is changed automatically on demand. Default is &quot;current&quot;.</p>
</dd>
<dt><code>k</code></dt><dd><p>K-mer size. If state is &quot;kmer&quot;, k is needed to expand the
coordinate.</p>
</dd>
<dt><code>reload</code></dt><dd><p>Reload the coordinate table from the root.path.
Default is TRUE.</p>
</dd>
<dt><code>rm.other.cols</code></dt><dd><p>Remove unnecessary columns for kmeRtone operation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A single or list of data.table coordinate of requested
chromosome.
</p>


<hr>
<a id="method-Coordinate-mark_overlap"></a>



<h4>Method <code>mark_overlap()</code></h4>

<p>Mark overlapping regions in the coordinate table. A column name
is_overlap is added.
</p>


<h5>Usage</h5>

<div class="r"><pre>Coordinate$mark_overlap()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chr.names</code></dt><dd><p>Chromosome names</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New column is_overlap is added.
</p>


<hr>
<a id="method-Coordinate-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print <code>Coordinate</code> object parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Coordinate$print()</pre></div>



<h5>Returns</h5>

<p>Message of <code>Coordinate</code> object parameters.
</p>


<hr>
<a id="method-Coordinate-map_sequence"></a>



<h4>Method <code>map_sequence()</code></h4>

<p>Get corresponding sequence from the loaded coordinate.
</p>


<h5>Usage</h5>

<div class="r"><pre>Coordinate$map_sequence(genome)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genome</code></dt><dd><p>Genome object or vector of named chromosome sequences.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New column seq.
</p>


<hr>
<a id="method-Coordinate-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Coordinate$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='count_substring_fixed'>Count sequence content in a given sequence.</h2><span id='topic+count_substring_fixed'></span>

<h3>Description</h3>

<p>stringi has no function that search within substring without memory copy it.
This function has two versions. One without the need to memory copy denoted
as ***. The only downside to this is std::string::find cannot stop searching
past end of substring. I manage to at least stop it as soon as possible. If
the pattern is long and rare, it won't stop until it find post-substring
pattern. The other version is memory copy substring but as this operation is
in the loop, the memory is still within comfortable range. c++17 has
std::string_view that solve this but still new and not widely available. Use
count_substring_regex to avoid memory copy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_substring_fixed(sequence, start, end, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_substring_fixed_+3A_sequence">sequence</code></td>
<td>
<p>A sequence to map.</p>
</td></tr>
<tr><td><code id="count_substring_fixed_+3A_start">start</code></td>
<td>
<p>Start positions.</p>
</td></tr>
<tr><td><code id="count_substring_fixed_+3A_end">end</code></td>
<td>
<p>End positions.</p>
</td></tr>
<tr><td><code id="count_substring_fixed_+3A_pattern">pattern</code></td>
<td>
<p>A pattern to search for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of count.
</p>

<hr>
<h2 id='count_substring_regex'>Count sequence content in a given sequence.</h2><span id='topic+count_substring_regex'></span>

<h3>Description</h3>

<p>stringi has no function that search within substring without memory creating
it. This function solve that. Unlike count_substring_fixed, this function
does not need to memory copy substring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_substring_regex(sequence, start, end, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_substring_regex_+3A_sequence">sequence</code></td>
<td>
<p>A sequence to map.</p>
</td></tr>
<tr><td><code id="count_substring_regex_+3A_start">start</code></td>
<td>
<p>Start positions.</p>
</td></tr>
<tr><td><code id="count_substring_regex_+3A_end">end</code></td>
<td>
<p>End positions.</p>
</td></tr>
<tr><td><code id="count_substring_regex_+3A_pattern">pattern</code></td>
<td>
<p>A regex pattern to search for within start and end positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of count.
</p>

<hr>
<h2 id='countBaseComposition'>Function performs an analysis of base composition including sequence
frequency, PWM calculations, and G/C content at various window sizes.</h2><span id='topic+countBaseComposition'></span>

<h3>Description</h3>

<p>Function performs an analysis of base composition including sequence
frequency, PWM calculations, and G/C content at various window sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countBaseComposition(case, genome, case.pattern, output.path = "./")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countBaseComposition_+3A_case">case</code></td>
<td>
<p>A Coordinate class object or similar structure.</p>
</td></tr>
<tr><td><code id="countBaseComposition_+3A_genome">genome</code></td>
<td>
<p>Genome class object or similar structure.</p>
</td></tr>
<tr><td><code id="countBaseComposition_+3A_case.pattern">case.pattern</code></td>
<td>
<p>String patterns to consider in the analysis.</p>
</td></tr>
<tr><td><code id="countBaseComposition_+3A_output.path">output.path</code></td>
<td>
<p>Output path for saving the analysis results.</p>
</td></tr>
</table>

<hr>
<h2 id='countChoppedKmers'>Function chops k-mers within specified ranges of a sequence and counts
them. It uses either a substring method or functionalities from the
Biostrings package.</h2><span id='topic+countChoppedKmers'></span>

<h3>Description</h3>

<p>Function chops k-mers within specified ranges of a sequence and counts
them. It uses either a substring method or functionalities from the
Biostrings package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countChoppedKmers(dna.seq, starts, ends, k, method = "auto")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countChoppedKmers_+3A_dna.seq">dna.seq</code></td>
<td>
<p>A string of sequence.</p>
</td></tr>
<tr><td><code id="countChoppedKmers_+3A_starts">starts</code></td>
<td>
<p>Start positions.</p>
</td></tr>
<tr><td><code id="countChoppedKmers_+3A_ends">ends</code></td>
<td>
<p>End positions.</p>
</td></tr>
<tr><td><code id="countChoppedKmers_+3A_k">k</code></td>
<td>
<p>Size of kmer.</p>
</td></tr>
<tr><td><code id="countChoppedKmers_+3A_method">method</code></td>
<td>
<p>Method: &quot;Biostrings&quot; or &quot;substring&quot;. Default is Biostrings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A k-mer-named vector of counts.
</p>

<hr>
<h2 id='countDistribution'>Function performs an analysis of the distribution of genomic cases.</h2><span id='topic+countDistribution'></span>

<h3>Description</h3>

<p>Check case distribution in replicates, chromosomes, and strands.
Check case base composition and filter out other case.patterns.
Then, it generates various plots like bar plots and Venn/Euler diagrams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countDistribution(case, genome, case.pattern, output.path = "./")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countDistribution_+3A_case">case</code></td>
<td>
<p>A Coordinate class object or similar structure for genomic data.</p>
</td></tr>
<tr><td><code id="countDistribution_+3A_genome">genome</code></td>
<td>
<p>Genome class object or similar structure.</p>
</td></tr>
<tr><td><code id="countDistribution_+3A_case.pattern">case.pattern</code></td>
<td>
<p>String patterns to consider in the analysis.</p>
</td></tr>
<tr><td><code id="countDistribution_+3A_output.path">output.path</code></td>
<td>
<p>Output path for saving the analysis results.</p>
</td></tr>
</table>

<hr>
<h2 id='countKmers'>Count k-mers from string(s) using a simple hash table.</h2><span id='topic+countKmers'></span>

<h3>Description</h3>

<p>Count only observed k-mers. Biostrings::oligonucleotideFrequency reports all
possible k-mers. For k &gt; 12, the memory for creating empty k-mer counts
spiked and crashed the R session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countKmers(sequences, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countKmers_+3A_sequences">sequences</code></td>
<td>
<p>Sequence strings.</p>
</td></tr>
<tr><td><code id="countKmers_+3A_k">k</code></td>
<td>
<p>Size of k-mer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of k-mer counts. The counts of multiple sequences are
combined, similar to Biostrings::oligonucleotideFrequency simplify.as
&quot;collapsed&quot;.
</p>

<hr>
<h2 id='countMidPatternContext2'>Locate a middle sequence pattern and count its sequence context.</h2><span id='topic+countMidPatternContext2'></span>

<h3>Description</h3>

<p>This function searches for a specified middle pattern within a given sequence.
It then counts the occurrences of specific context patterns within a defined window
size around the middle pattern. The function returns a map where keys are the
counts of context patterns found and values are the frequencies of these counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countMidPatternContext2(sequence, mid_pattern, window, context_patterns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countMidPatternContext2_+3A_sequence">sequence</code></td>
<td>
<p>A string representing the sequence to be analyzed.</p>
</td></tr>
<tr><td><code id="countMidPatternContext2_+3A_mid_pattern">mid_pattern</code></td>
<td>
<p>A string representing the middle pattern to search for within the sequence.</p>
</td></tr>
<tr><td><code id="countMidPatternContext2_+3A_window">window</code></td>
<td>
<p>An integer specifying the size of the surrounding window around the middle pattern.</p>
</td></tr>
<tr><td><code id="countMidPatternContext2_+3A_context_patterns">context_patterns</code></td>
<td>
<p>A vector of strings representing the context patterns to search for within the window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A std::unordered_map&lt;int,int&gt; where keys are the counts of context patterns found
and values are the frequencies of these counts.
</p>

<hr>
<h2 id='countMidPatternKmers'>Count Relevant K-mers with Specified Middle Pattern from Sequence String(s)</h2><span id='topic+countMidPatternKmers'></span>

<h3>Description</h3>

<p>This function scans through each sequence in the provided vector, locating a specified middle pattern.
For each occurrence of the middle pattern, the function extracts and counts the surrounding k-mers.
The k-mers are identified based on the given k-mer size and centered around the middle pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countMidPatternKmers(sequences, k, mid_pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countMidPatternKmers_+3A_sequences">sequences</code></td>
<td>
<p>A vector of strings, each representing a sequence to be analyzed.</p>
</td></tr>
<tr><td><code id="countMidPatternKmers_+3A_k">k</code></td>
<td>
<p>An integer specifying the size of the k-mers to be extracted and counted.</p>
</td></tr>
<tr><td><code id="countMidPatternKmers_+3A_mid_pattern">mid_pattern</code></td>
<td>
<p>A string representing the middle pattern to search for within each sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A std::unordered_map with k-mers as keys and their counts as values.
</p>

<hr>
<h2 id='countPointContext2'>Ccount sequence context of given point positions.</h2><span id='topic+countPointContext2'></span>

<h3>Description</h3>

<p>Ccount sequence context of given point positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countPointContext2(sequence, points, len, window, context_patterns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countPointContext2_+3A_sequence">sequence</code></td>
<td>
<p>A sequence to slide.</p>
</td></tr>
<tr><td><code id="countPointContext2_+3A_points">points</code></td>
<td>
<p>Middle point positions.</p>
</td></tr>
<tr><td><code id="countPointContext2_+3A_len">len</code></td>
<td>
<p>Length of the middle point.</p>
</td></tr>
<tr><td><code id="countPointContext2_+3A_window">window</code></td>
<td>
<p>Size of a surrounding window.</p>
</td></tr>
<tr><td><code id="countPointContext2_+3A_context_patterns">context_patterns</code></td>
<td>
<p>Context patterns to search for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of frequency of counts.
</p>

<hr>
<h2 id='countRangedKmers'>Count k-mers in given ranges of a sequence.</h2><span id='topic+countRangedKmers'></span>

<h3>Description</h3>

<p>Slide and update the cummulated table count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countRangedKmers(sequence, starts, ends, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countRangedKmers_+3A_sequence">sequence</code></td>
<td>
<p>A sequence to count.</p>
</td></tr>
<tr><td><code id="countRangedKmers_+3A_starts">starts</code></td>
<td>
<p>Start positions.</p>
</td></tr>
<tr><td><code id="countRangedKmers_+3A_ends">ends</code></td>
<td>
<p>End positions.</p>
</td></tr>
<tr><td><code id="countRangedKmers_+3A_k">k</code></td>
<td>
<p>K-mer size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A k-mer-named vector of count.
</p>

<hr>
<h2 id='countRevCompKmers'>Count reverse complement sequence from its opposite strand.
Build for k-mer table generated from initKmerTable function but applicable to
others with the same format.</h2><span id='topic+countRevCompKmers'></span>

<h3>Description</h3>

<p>Count reverse complement sequence from its opposite strand.
Build for k-mer table generated from initKmerTable function but applicable to
others with the same format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countRevCompKmers(kmer.table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countRevCompKmers_+3A_kmer.table">kmer.table</code></td>
<td>
<p>A data.table of k-mer with at least 3 columns: kmer,
pos_strand, and neg_strand. Splitted k-mer columns: kmer_part1 and
kmer_part2 is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated k-mer table.
</p>

<hr>
<h2 id='countSlidingWindow'>Count sequence content in a sliding window of a sequence.</h2><span id='topic+countSlidingWindow'></span>

<h3>Description</h3>

<p>Count sequence content in a sliding window of a sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countSlidingWindow(sequence, window, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countSlidingWindow_+3A_sequence">sequence</code></td>
<td>
<p>A sequence to slide.</p>
</td></tr>
<tr><td><code id="countSlidingWindow_+3A_window">window</code></td>
<td>
<p>Size of a window.</p>
</td></tr>
<tr><td><code id="countSlidingWindow_+3A_pattern">pattern</code></td>
<td>
<p>A pattern to search for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of count.
</p>

<hr>
<h2 id='countSlidingWindow2'>Count sequence content in a sliding window of a sequence.</h2><span id='topic+countSlidingWindow2'></span>

<h3>Description</h3>

<p>Count sequence content in a sliding window of a sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countSlidingWindow2(sequence, window, patterns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countSlidingWindow2_+3A_sequence">sequence</code></td>
<td>
<p>A sequence to slide.</p>
</td></tr>
<tr><td><code id="countSlidingWindow2_+3A_window">window</code></td>
<td>
<p>Size of a window.</p>
</td></tr>
<tr><td><code id="countSlidingWindow2_+3A_patterns">patterns</code></td>
<td>
<p>Patterns of the same size to search for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector of frequency of count.
</p>

<hr>
<h2 id='downloadNCBIGenomes'>Function downloads genome fasta files from the NCBI FTP database. Users can
provide either organism names or an assembly summary data table.</h2><span id='topic+downloadNCBIGenomes'></span>

<h3>Description</h3>

<p>Supports options for splitting multi-header fasta files and overwriting existing files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadNCBIGenomes(
  asm,
  species,
  db,
  output.dir = "./",
  split.fasta = FALSE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="downloadNCBIGenomes_+3A_asm">asm</code></td>
<td>
<p>NCBI assembly summary data.table</p>
</td></tr>
<tr><td><code id="downloadNCBIGenomes_+3A_species">species</code></td>
<td>
<p>Species names.</p>
</td></tr>
<tr><td><code id="downloadNCBIGenomes_+3A_db">db</code></td>
<td>
<p>Database record to use: refseq or genbank</p>
</td></tr>
<tr><td><code id="downloadNCBIGenomes_+3A_output.dir">output.dir</code></td>
<td>
<p>Output directory path. Default is current directory.</p>
</td></tr>
<tr><td><code id="downloadNCBIGenomes_+3A_split.fasta">split.fasta</code></td>
<td>
<p>NCBI fasta files are multi-header. Split them? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="downloadNCBIGenomes_+3A_overwrite">overwrite</code></td>
<td>
<p>Overwrite any existed genome file? Default is FALSE to skip
the download.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genome fasta file(s) named according to the FTP database convention.
</p>

<hr>
<h2 id='downloadUCSCgenome'>Function downloads chromosome-separated fasta genome sequences from the UCSC
database. Users can specify a genome name, an output folder, and a specific
chromosome or chromosomes. There's an option to choose the download method as well.</h2><span id='topic+downloadUCSCgenome'></span>

<h3>Description</h3>

<p>Function downloads chromosome-separated fasta genome sequences from the UCSC
database. Users can specify a genome name, an output folder, and a specific
chromosome or chromosomes. There's an option to choose the download method as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadUCSCgenome(genome.name, output.path, chr.name, method = "curl")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="downloadUCSCgenome_+3A_genome.name">genome.name</code></td>
<td>
<p>Genome name (e.g., hg19, hg38, mm19).</p>
</td></tr>
<tr><td><code id="downloadUCSCgenome_+3A_output.path">output.path</code></td>
<td>
<p>Output folder for the downloaded sequences.</p>
</td></tr>
<tr><td><code id="downloadUCSCgenome_+3A_chr.name">chr.name</code></td>
<td>
<p>Specific chromosome to download; defaults to all if unspecified.</p>
</td></tr>
<tr><td><code id="downloadUCSCgenome_+3A_method">method</code></td>
<td>
<p>Download method for the <code>download.file</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output folder containing chromosome-separated fasta files.
</p>

<hr>
<h2 id='example_genome_coor'>Example genome coordinate file</h2><span id='topic+example_genome_coor'></span>

<h3>Description</h3>

<p>Below is an example code that generates random genomic coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_genome_coor
</code></pre>


<h3>Format</h3>

<p>A data frame with 1001 rows and 3 columns
</p>

<dl>
<dt>seqnames</dt><dd><p>Chromosome number of the recorded biological event, e.g. DNA strand breaks</p>
</dd>
<dt>start</dt><dd><p>5' start position of the recorded biological event</p>
</dd>
<dt>width</dt><dd><p>Sequence width of the recorded biological event, e.g. 2 for a DNA strand break</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
library(kmeRtone)

# 1. Randomly generate genomic positions and save results
temp_dir &lt;- tempdir()

set.seed(1234)
temp_files &lt;- character(1)
for(chr in 1){
    genomic_coor &lt;- data.table::data.table(
        seqnames = paste0("chr", chr),
        start = sample(
            x = 10000:10000000, 
            size = 100000, 
            replace = FALSE
        ),
        width = 2
    )

    f &lt;- file.path(temp_dir, paste0("chr", chr, ".csv"))
    fwrite(genomic_coor, f)
    temp_files[chr] &lt;- f
}

rm_files &lt;- file.remove(temp_files)


</code></pre>

<hr>
<h2 id='example_kmeRtone_score'>Example 2-mer enrichment/depletion scores</h2><span id='topic+example_kmeRtone_score'></span>

<h3>Description</h3>

<p>Below is an example code that generates random genomic coordinates
and runs the default kmeRtone <code>SCORE</code> function to quantify the
k-meric enrichment and depletion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_kmeRtone_score
</code></pre>


<h3>Format</h3>

<p>A data frame with 1001 rows and 3 columns
</p>

<dl>
<dt>case</dt><dd><p>Case k-mers, e.g. damage k-mer counts</p>
</dd>
<dt>case_skew</dt><dd><p>Case k-mers skews, e.g. skew of the damage k-mers counts</p>
</dd>
<dt>control</dt><dd><p>control k-mers, e.g. damage k-mer counts</p>
</dd>
<dt>control_skew</dt><dd><p>control k-mers skews, e.g. skew of the damage k-mers counts</p>
</dd>
<dt>kmer</dt><dd><p>K-meric sequence</p>
</dd>
<dt>z</dt><dd><p>Intrinsic susceptibility z-score for each k-mer</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/SahakyanLab/kmeRtone/blob/master/README.md">https://github.com/SahakyanLab/kmeRtone/blob/master/README.md</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1. Randomly generate genomic positions and save results
library(data.table)
library(kmeRtone)
temp_dir &lt;- tempdir()

set.seed(1234)
temp_files &lt;- character(1)
for(chr in 1){
    genomic_coor &lt;- data.table(
        seqnames = paste0("chr", chr),
        start = sample(
            x = 10000:10000000, 
            size = 100000, 
            replace = FALSE
        ),
        width = 2
    )

    f &lt;- file.path(temp_dir, paste0("chr", chr, ".csv"))
    fwrite(genomic_coor, f)
    temp_files[chr] &lt;- f
}

# 2. Run kmeRtone score function
temp_dir_genome &lt;- tempdir()
kmeRtone::kmeRtone(
    case.coor.path = temp_dir, 
    genome.name = "hg19", 
    genome.path = temp_dir_genome,
    strand.sensitive = FALSE, 
    k = 2,
    ctrl.rel.pos = c(80, 500),
    case.pattern = NULL,
    single.case.len = 2,
    output.dir = temp_dir,
    module = "score",
    rm.case.kmer.overlaps = FALSE,
    merge.replicate = TRUE, 
    kmer.table = NULL,
    verbose = TRUE
)

# 3. Clean up temporary files
rm_files &lt;- file.remove(temp_files)


</code></pre>

<hr>
<h2 id='EXPLORE'>Function generates various exploratory analyses.</h2><span id='topic+EXPLORE'></span>

<h3>Description</h3>

<p>Function generates various exploratory analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EXPLORE(
  case.coor.path,
  genome.name,
  strand.sensitive,
  k,
  case.pattern,
  output.path,
  case,
  genome,
  control,
  genome.path,
  single.case.len,
  rm.dup,
  case.coor.1st.idx,
  coor.load.limit,
  genome.load.limit,
  genome.fasta.style,
  genome.ncbi.db,
  use.UCSC.chr.name,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EXPLORE_+3A_case.coor.path">case.coor.path</code></td>
<td>
<p>Path to case coordinates.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_genome.name">genome.name</code></td>
<td>
<p>Genome name (e.g., hg19, hg38).</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_strand.sensitive">strand.sensitive</code></td>
<td>
<p>Boolean indicating if strand sensitivity is considered.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_k">k</code></td>
<td>
<p>K-mer size.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_case.pattern">case.pattern</code></td>
<td>
<p>String patterns to consider in the analysis.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_output.path">output.path</code></td>
<td>
<p>Output directory path for exploration plots.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_case">case</code></td>
<td>
<p>Coordinate class object or similar structure for case data.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_genome">genome</code></td>
<td>
<p>Genome class object or similar structure.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_control">control</code></td>
<td>
<p>Control class object or similar structure.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_genome.path">genome.path</code></td>
<td>
<p>Path to genome fasta files.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_single.case.len">single.case.len</code></td>
<td>
<p>Length of single cases.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_rm.dup">rm.dup</code></td>
<td>
<p>Boolean indicating if duplicates should be removed.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_case.coor.1st.idx">case.coor.1st.idx</code></td>
<td>
<p>Indexing of case coordinates.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_coor.load.limit">coor.load.limit</code></td>
<td>
<p>Maximum number of coordinates to load.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_genome.load.limit">genome.load.limit</code></td>
<td>
<p>Maximum number of genome data to load.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_genome.fasta.style">genome.fasta.style</code></td>
<td>
<p>Fasta file style for genome data.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_genome.ncbi.db">genome.ncbi.db</code></td>
<td>
<p>NCBI database for genome data.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_use.ucsc.chr.name">use.UCSC.chr.name</code></td>
<td>
<p>Boolean indicating if UCSC chromosome naming is used.</p>
</td></tr>
<tr><td><code id="EXPLORE_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicating if verbose output is enabled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output directory containing exploration plots.
</p>

<hr>
<h2 id='extractKmers'>Extract k-mers from a given Coordinate object and Genome objects</h2><span id='topic+extractKmers'></span>

<h3>Description</h3>

<p>A k-mer table is initialized and updated in every chromosome-loop operation.
There are 3 modes of extraction. (1) When k is smaller than 9 or k is
larger than 15, the k-mer is extracted in a standard way. A k-mer table
with every possible k-mers is created and updated. (2) For k between
9 and 13, the k-mer sequence is split to half to reduce memory usage
significantly. e.g. ACGTACGTA will become ACGT ACGTA. (3) When k is
larger than 14, k-mers are extracted the same way as (1) but the k-mer
table is grown or expanded for every new k-mer found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractKmers(
  coor,
  genome,
  k,
  central.pattern = NULL,
  rm.overlap.region = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractKmers_+3A_coor">coor</code></td>
<td>
<p>Coordinate class object.</p>
</td></tr>
<tr><td><code id="extractKmers_+3A_genome">genome</code></td>
<td>
<p>Genome class object.</p>
</td></tr>
<tr><td><code id="extractKmers_+3A_k">k</code></td>
<td>
<p>Length of k-mer.</p>
</td></tr>
<tr><td><code id="extractKmers_+3A_central.pattern">central.pattern</code></td>
<td>
<p>Central pattern of the k-mer, if applicable.</p>
</td></tr>
<tr><td><code id="extractKmers_+3A_rm.overlap.region">rm.overlap.region</code></td>
<td>
<p>Boolean indicating if overlapping regions should be
removed. Default is TRUE.</p>
</td></tr>
<tr><td><code id="extractKmers_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicating if verbose output is enabled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A k-mer table with counts for each k-mer.
</p>

<hr>
<h2 id='generateGenicElementCoor'>Function processes UCSC genePred tables to generate coordinates for
various genic elements like introns, exons, CDS, UTRs, and upstream and
downstream regions. It handles these coordinates with consideration for
strand sensitivity and genome information.</h2><span id='topic+generateGenicElementCoor'></span>

<h3>Description</h3>

<p>All the operations in here are vectorized. If the table is big, expect a
spike in memory. Using ncbiRefSeq table and genome hg38, the memory is
stable at 4-5 GB. I can utilise data.table package to process by chunk if
needed.
Original table is zero-based open-end index. The indexing system is changed
temporarily to follow Rs system. The output coordinate table is one-based
close-end index. Critical information based on UCSC Genome website:
Column        Explanation
bin           Indexing field to speed chromosome range queries. (Only
relevant to UCSC program)
name 	     Name of gene (usually transcript_id from GTF)
chrom 	     Reference sequence chromosome or scaffold
strand 	     + or - for strand
txStart 	     Transcription start position (or end position for minus
strand item)
txEnd 	     Transcription end position (or start position for minus
strand item)
cdsStart      Coding region start (or end position for minus strand item)
cdsEnd 	     Coding region end (or start position for minus strand item)
exonCount     Number of exons
exonEnds      Exon end positions (or start positions for minus strand
item)
exonStart     Exon start positions (or end positions for minus strand
item)
name2 	     Alternate name (e.g. gene_id from GTF)
cdsStartStat  Status of CDS start annotation (none, unknown, incomplete,
or complete) = ('none','unk','incmpl','cmpl')
cdsEndStat    Status of CDS end annotation (none, unknown, incomplete,
or complete)
exonFrames    Exon frame (0,1,2), or -1 if no frame for exon (Related to
codon. Number represents extra bases (modulus of 3) from
previous exon block brought to a current exon block.)
If cdsStart == cdsEnd, that means non-coding sequence.
</p>

<ul>
<li><p> maybe cdsStartStat and cdsEndStat == &quot;none&quot; mean the same thing.
maybe exonFrames == &quot;-1,&quot; means the same thing.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>generateGenicElementCoor(
  genepred,
  element.names = "all",
  upstream = NULL,
  downstream = NULL,
  genome.name = NULL,
  genome = NULL,
  return.coor.obj = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateGenicElementCoor_+3A_genepred">genepred</code></td>
<td>
<p>UCSC genome name (e.g., hg19, mm39).</p>
</td></tr>
<tr><td><code id="generateGenicElementCoor_+3A_element.names">element.names</code></td>
<td>
<p>Types of genic elements to output: &quot;all&quot;, &quot;intron&quot;,
&quot;exon&quot;, &quot;CDS&quot;, or &quot;UTR&quot;. Default is &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="generateGenicElementCoor_+3A_upstream">upstream</code></td>
<td>
<p>Length of upstream sequence (can overlap other genes).</p>
</td></tr>
<tr><td><code id="generateGenicElementCoor_+3A_downstream">downstream</code></td>
<td>
<p>Length of downstream sequence (can overlap other genes).</p>
</td></tr>
<tr><td><code id="generateGenicElementCoor_+3A_genome.name">genome.name</code></td>
<td>
<p>UCSC genome name for trimming overflowing coordinates.</p>
</td></tr>
<tr><td><code id="generateGenicElementCoor_+3A_genome">genome</code></td>
<td>
<p>Genome object for coordinate resolution.</p>
</td></tr>
<tr><td><code id="generateGenicElementCoor_+3A_return.coor.obj">return.coor.obj</code></td>
<td>
<p>Whether to return a <code>Coordinate</code> object (default: FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genic element coordinates in a <code>data.table</code> or <code>Coordinate</code> object.
</p>

<hr>
<h2 id='generateIntergenicCoor'>Resolve and generate genic element coordinates from UCSC genePred table.</h2><span id='topic+generateIntergenicCoor'></span>

<h3>Description</h3>

<p>Function generates intergenic coordinates from a UCSC genePred table.
It allows users to specify the genePred data source, the relative position
and minimum length for intergenic regions, and whether to return the results
as a <code>Coordinate</code> object or a <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateIntergenicCoor(
  genepred,
  genome.name,
  fasta.path,
  igr.rel.pos = c(5000, 7500),
  igr.min.length = 150,
  return.coor.obj = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateIntergenicCoor_+3A_genepred">genepred</code></td>
<td>
<p>UCSC genePred table or database name (&quot;refseq&quot; or &quot;gencode&quot;).</p>
</td></tr>
<tr><td><code id="generateIntergenicCoor_+3A_genome.name">genome.name</code></td>
<td>
<p>UCSC genome name (e.g., hg38, mm39).</p>
</td></tr>
<tr><td><code id="generateIntergenicCoor_+3A_fasta.path">fasta.path</code></td>
<td>
<p>Path to a directory of user-provided genome FASTA files or
the destination to save the NCBI/UCSC downloaded reference genome files.</p>
</td></tr>
<tr><td><code id="generateIntergenicCoor_+3A_igr.rel.pos">igr.rel.pos</code></td>
<td>
<p>Intergenic relative position, defaults to c(5000, 7500).</p>
</td></tr>
<tr><td><code id="generateIntergenicCoor_+3A_igr.min.length">igr.min.length</code></td>
<td>
<p>Minimum length for intergenic regions, default is 150.</p>
</td></tr>
<tr><td><code id="generateIntergenicCoor_+3A_return.coor.obj">return.coor.obj</code></td>
<td>
<p>Return results as a <code>Coordinate</code> object? Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Intergenic coordinates as a <code>data.table</code> or <code>Coordinate</code> object.
</p>

<hr>
<h2 id='getCOSMICauthURL'>Get COSMIC authenticated URL.</h2><span id='topic+getCOSMICauthURL'></span>

<h3>Description</h3>

<p>To access the data for non-commercial usage, you must register with the
COSMIC. This function fetch the authenticated URL from the public URL
given by the COSMIC website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCOSMICauthURL(email, password, url)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCOSMICauthURL_+3A_email">email</code></td>
<td>
<p>Email registered with COSMIC.</p>
</td></tr>
<tr><td><code id="getCOSMICauthURL_+3A_password">password</code></td>
<td>
<p>Password associated with the registered email.</p>
</td></tr>
<tr><td><code id="getCOSMICauthURL_+3A_url">url</code></td>
<td>
<p>Public URL provided by the COSMIC website for data access.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Authenticated URL valid for 1-hour access to COSMIC data.
</p>

<hr>
<h2 id='getCOSMICcancerGeneCensus'>Get Cancer Gene Census (CGC) from COSMIC database.</h2><span id='topic+getCOSMICcancerGeneCensus'></span>

<h3>Description</h3>

<p>To access the data for non-commercial usage, you must register with the
COSMIC. This function fetch the latest CGC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCOSMICcancerGeneCensus(email, password)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCOSMICcancerGeneCensus_+3A_email">email</code></td>
<td>
<p>Email registered with COSMIC.</p>
</td></tr>
<tr><td><code id="getCOSMICcancerGeneCensus_+3A_password">password</code></td>
<td>
<p>Password associated with the registered email.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> containing the Cancer Gene Census data.
</p>

<hr>
<h2 id='getCOSMIClatestVersion'>Function retrieves the latest version information of the COSMIC database
and the associated genome version by scraping data from the COSMIC website.</h2><span id='topic+getCOSMIClatestVersion'></span>

<h3>Description</h3>

<p>Function retrieves the latest version information of the COSMIC database
and the associated genome version by scraping data from the COSMIC website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCOSMIClatestVersion()
</code></pre>


<h3>Value</h3>

<p>A named vector containing the latest COSMIC version (<code>cosmic</code>) and
genome version (<code>genome</code>).
</p>

<hr>
<h2 id='getCOSMICmutantExport'>Function downloads the latest Cosmic Mutant Export data from the COSMIC
database. It requires the user to be registered with COSMIC for non-commercial
use. The function constructs the URL for the latest mutant export file,
authenticates the URL, and then downloads the data.</h2><span id='topic+getCOSMICmutantExport'></span>

<h3>Description</h3>

<p>Function downloads the latest Cosmic Mutant Export data from the COSMIC
database. It requires the user to be registered with COSMIC for non-commercial
use. The function constructs the URL for the latest mutant export file,
authenticates the URL, and then downloads the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCOSMICmutantExport(email, password)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCOSMICmutantExport_+3A_email">email</code></td>
<td>
<p>Email registered with COSMIC for accessing data.</p>
</td></tr>
<tr><td><code id="getCOSMICmutantExport_+3A_password">password</code></td>
<td>
<p>Password for the COSMIC account.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> containing the Cosmic Mutant Export data.
</p>

<hr>
<h2 id='getEnsemblData'>A generic function to get Ensembl data persistently from a URL. This is an
internal function used by other getEnsemblXXX functions.</h2><span id='topic+getEnsemblData'></span>

<h3>Description</h3>

<p>Error is handled based on their rule as set out at
https://github.com/Ensembl/ensembl-rest/wiki/HTTP-Response-Codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEnsemblData(url, handle, max.attempt = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEnsemblData_+3A_url">url</code></td>
<td>
<p>Pre-built Ensembl REST API URL.</p>
</td></tr>
<tr><td><code id="getEnsemblData_+3A_handle">handle</code></td>
<td>
<p><code>curl</code> handle object configured for the Ensembl REST API.</p>
</td></tr>
<tr><td><code id="getEnsemblData_+3A_max.attempt">max.attempt</code></td>
<td>
<p>Maximum number of attempts to fetch the data, default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parsed JSON data, which could be in the form of a data.frame or
a list of lists, depending on the API response.
</p>

<hr>
<h2 id='getEnsemblRegionFeatures'>Get features of a given region.</h2><span id='topic+getEnsemblRegionFeatures'></span>

<h3>Description</h3>

<p>Function fetches various genomic features for a specified region from the
Ensembl database. It allows specifying the species, chromosome, region range,
and types of features to query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEnsemblRegionFeatures(species, chromosome, start, end, features)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEnsemblRegionFeatures_+3A_species">species</code></td>
<td>
<p>Species name or alias (e.g., homo_sapiens, human).</p>
</td></tr>
<tr><td><code id="getEnsemblRegionFeatures_+3A_chromosome">chromosome</code></td>
<td>
<p>Chromosome name in Ensembl format (without 'chr' prefix).</p>
</td></tr>
<tr><td><code id="getEnsemblRegionFeatures_+3A_start">start</code></td>
<td>
<p>Start position of the region.</p>
</td></tr>
<tr><td><code id="getEnsemblRegionFeatures_+3A_end">end</code></td>
<td>
<p>End position of the region.</p>
</td></tr>
<tr><td><code id="getEnsemblRegionFeatures_+3A_features">features</code></td>
<td>
<p>List of region features to retrieve from Ensembl. Valid
options include &quot;band&quot;, &quot;gene&quot;, &quot;transcript&quot;, &quot;cds&quot;, &quot;exon&quot;, &quot;repeat&quot;,
&quot;simple&quot;, &quot;misc&quot;, &quot;variation&quot;, &quot;somatic_variation&quot;,
&quot;structural_variation&quot;, &quot;somatic_structural_variation&quot;, &quot;constrained&quot;,
&quot;regulatory&quot;, &quot;motif&quot;, &quot;peak&quot;, &quot;other_regulatory&quot;, &quot;array_probe&quot;, &quot;mane&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> containing the requested Ensembl features.
</p>

<hr>
<h2 id='getEnsemblVariantFeatures'>Get features of given variant IDs.</h2><span id='topic+getEnsemblVariantFeatures'></span>

<h3>Description</h3>

<p>Function retrieves features for given variant IDs from the Ensembl
database. It handles requests asynchronously in batches due to server limits
and includes options to fetch additional variant information. Error handling
for different HTTP response statuses is implemented to manage request failures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEnsemblVariantFeatures(
  species,
  variant.ids,
  include.genotypes = FALSE,
  include.phenotypes = FALSE,
  include.allele.frequencies = FALSE,
  include.genotype.frequencies = FALSE,
  curl.max.con = 100,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEnsemblVariantFeatures_+3A_species">species</code></td>
<td>
<p>Species name or alias (e.g., homo_sapiens, human).</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_+3A_variant.ids">variant.ids</code></td>
<td>
<p>A vector of variant IDs (e.g., rs56116432, COSM476).</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_+3A_include.genotypes">include.genotypes</code></td>
<td>
<p>Include genotypes in the response? Default FALSE.</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_+3A_include.phenotypes">include.phenotypes</code></td>
<td>
<p>Include phenotypes in the response? Default FALSE.</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_+3A_include.allele.frequencies">include.allele.frequencies</code></td>
<td>
<p>Include allele frequencies? Default FALSE.</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_+3A_include.genotype.frequencies">include.genotype.frequencies</code></td>
<td>
<p>Include genotype frequencies? Default FALSE.</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_+3A_curl.max.con">curl.max.con</code></td>
<td>
<p>Maximum number of concurrent connections for curl requests.
Default is 100.</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_+3A_verbose">verbose</code></td>
<td>
<p>Verbosity level: 1 for error only, 2 for all requests. Default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variant-named list containing lists of variant features.
</p>

<hr>
<h2 id='getEnsemblVariantFeatures_serial'>Get features of given variant IDs.</h2><span id='topic+getEnsemblVariantFeatures_serial'></span>

<h3>Description</h3>

<p>Function fetches variant features from the Ensembl database for a set
of variant IDs. It handles variant IDs in batches to comply with server limits
and can include additional information like genotypes, phenotypes, allele
frequencies, and genotype frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEnsemblVariantFeatures_serial(
  species,
  variant.ids,
  include.genotypes = FALSE,
  include.phenotypes = FALSE,
  include.allele.frequencies = FALSE,
  include.genotype.frequencies = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEnsemblVariantFeatures_serial_+3A_species">species</code></td>
<td>
<p>Species name or alias (e.g., homo_sapiens, human).</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_serial_+3A_variant.ids">variant.ids</code></td>
<td>
<p>A vector of variant IDs (e.g., rs56116432, COSM476).</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_serial_+3A_include.genotypes">include.genotypes</code></td>
<td>
<p>Include genotypes in the response? Default FALSE.</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_serial_+3A_include.phenotypes">include.phenotypes</code></td>
<td>
<p>Include phenotypes in the response? Default FALSE.</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_serial_+3A_include.allele.frequencies">include.allele.frequencies</code></td>
<td>
<p>Include allele frequencies? Default FALSE.</p>
</td></tr>
<tr><td><code id="getEnsemblVariantFeatures_serial_+3A_include.genotype.frequencies">include.genotype.frequencies</code></td>
<td>
<p>Include genotype frequencies? Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, named by variant IDs, containing lists of variant features.
</p>

<hr>
<h2 id='getGnomADvariants'>Get gnomAD VCF file using tabix.</h2><span id='topic+getGnomADvariants'></span>

<h3>Description</h3>

<p>Function retrieves variant data from gnomAD VCF files using tabix for a
specified set of genomic regions. It allows users to select the gnomAD
version and server location (Google, Amazon, or Microsoft) for fetching the
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGnomADvariants(
  chr.names,
  starts,
  ends,
  INFO.filter = NULL,
  version = "3.1.2",
  server = "random"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGnomADvariants_+3A_chr.names">chr.names</code></td>
<td>
<p>Chromosome names.</p>
</td></tr>
<tr><td><code id="getGnomADvariants_+3A_starts">starts</code></td>
<td>
<p>Start positions.</p>
</td></tr>
<tr><td><code id="getGnomADvariants_+3A_ends">ends</code></td>
<td>
<p>End positions.</p>
</td></tr>
<tr><td><code id="getGnomADvariants_+3A_info.filter">INFO.filter</code></td>
<td>
<p>Parse only filtered INFO ID. Default is to parse all IDs.</p>
</td></tr>
<tr><td><code id="getGnomADvariants_+3A_version">version</code></td>
<td>
<p>The gnomAD version. Default to latest version 3.1.2.</p>
</td></tr>
<tr><td><code id="getGnomADvariants_+3A_server">server</code></td>
<td>
<p>Server locations: &quot;google&quot;, &quot;amazon&quot;, or &quot;microsoft&quot;. Default
is random.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table of VCF.
</p>

<hr>
<h2 id='getICTVvirusMetadataResource'>Get Virus Metadata Resource (VMR) from International Committee on Taxonomy
of Viruses (ICTV)</h2><span id='topic+getICTVvirusMetadataResource'></span>

<h3>Description</h3>

<p>Always get the latest VMR table, so no argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getICTVvirusMetadataResource()
</code></pre>


<h3>Value</h3>

<p>Virus Metadata Resource data.table.
</p>

<hr>
<h2 id='getNCBIassemblySummary'>Get NCBI assembly summary.</h2><span id='topic+getNCBIassemblySummary'></span>

<h3>Description</h3>

<p>Retrieves the assembly summary from NCBI for a specified taxonomic group.
This function allows users to obtain genome assembly information from either
RefSeq or GenBank databases for various taxonomic groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNCBIassemblySummary(organism.group, db = "refseq")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNCBIassemblySummary_+3A_organism.group">organism.group</code></td>
<td>
<p>A string specifying the taxonomic group for which the
assembly summary is requested. Options include 'archaea', 'bacteria', 'fungi',
'invertebrate', 'plant', 'protozoa', 'vertebrate_mammalian', 'vertebrate_other',
'viral', or 'all'.</p>
</td></tr>
<tr><td><code id="getNCBIassemblySummary_+3A_db">db</code></td>
<td>
<p>A string specifying the database to use, either 'refseq' or 'genbank'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the assembly summary for the specified taxonomic group.
</p>

<hr>
<h2 id='getScores'>Function calculates scores for k-mers based on case and control k-mer counts.</h2><span id='topic+getScores'></span>

<h3>Description</h3>

<p>Function calculates scores for k-mers based on case and control k-mer counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScores(case.kmers, control.kmers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getScores_+3A_case.kmers">case.kmers</code></td>
<td>
<p>A data.table containing k-mer counts in case samples.</p>
</td></tr>
<tr><td><code id="getScores_+3A_control.kmers">control.kmers</code></td>
<td>
<p>A data.table containing k-mer counts in control samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing scores for each k-mer.
</p>

<hr>
<h2 id='getUCSCgenePredTable'>Retrieve Gene Prediction Table from UCSC for a Given Genome</h2><span id='topic+getUCSCgenePredTable'></span>

<h3>Description</h3>

<p>This function retrieves the gene prediction table from the UCSC genome database
for a specified genome. It can fetch data from either the RefSeq or GENCODE databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUCSCgenePredTable(genome.name, db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getUCSCgenePredTable_+3A_genome.name">genome.name</code></td>
<td>
<p>A string specifying the UCSC genome name for which the gene
prediction table is to be retrieved, e.g., 'hg38', 'mm39'.</p>
</td></tr>
<tr><td><code id="getUCSCgenePredTable_+3A_db">db</code></td>
<td>
<p>A string specifying the database used by UCSC to generate the table.
Options are 'refseq' or 'gencode'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> containing the gene prediction table from the specified
UCSC genome and database.
</p>

<hr>
<h2 id='getVCFmetainfo'>Read VCF metainfo file using tabix.</h2><span id='topic+getVCFmetainfo'></span>

<h3>Description</h3>

<p>Require tabix in PATH
VCF manual is referred from https://samtools.github.io/hts-specs/VCFv4.3.pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVCFmetainfo(vcf.file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getVCFmetainfo_+3A_vcf.file">vcf.file</code></td>
<td>
<p>A path to a local or remote tabix-indexed VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>VCF metainfo.
</p>

<hr>
<h2 id='initKmerTable'>Initialise k-mer table with all possible k-mers</h2><span id='topic+initKmerTable'></span>

<h3>Description</h3>

<p>Initialise k-mer table with the following columns: kmer, pos_strand, and
neg_strand
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initKmerTable(k, central.pattern = NULL, split.kmer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initKmerTable_+3A_k">k</code></td>
<td>
<p>K-mer size. Limit to 15 because vector size is limited to
.Machine$integer.max. For 9- to 15-mer, the kmer sequence is separated to
two columns (kmer_part1 and kmer_part2) to reduce memory significantly.</p>
</td></tr>
<tr><td><code id="initKmerTable_+3A_central.pattern">central.pattern</code></td>
<td>
<p>Central pattern(s) of the k-mer. Default is NULL.</p>
</td></tr>
<tr><td><code id="initKmerTable_+3A_split.kmer">split.kmer</code></td>
<td>
<p>Whether to split the k-mer sequence into two parts for large k values. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with 3 columns: kmer, pos_strand, neg_strand
</p>

<hr>
<h2 id='Kmer_Table'>A R6 class wrapper for data.table</h2><span id='topic+Kmer_Table'></span>

<h3>Description</h3>

<p>A R6 class wrapper for data.table
</p>
<p>A R6 class wrapper for data.table
</p>


<h3>Details</h3>

<p>A way to grow data.table in different environment but still retaining access
to it. A temporary fix until data.table developer develop update row
by reference.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>DT</code></dt><dd><p>data.table of k-mers</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Kmer_Table-new"><code>Kmer_Table$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Kmer_Table-print"><code>Kmer_Table$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Kmer_Table-remove_N"><code>Kmer_Table$remove_N()</code></a>
</p>
</li>
<li> <p><a href="#method-Kmer_Table-filter_central_pattern"><code>Kmer_Table$filter_central_pattern()</code></a>
</p>
</li>
<li> <p><a href="#method-Kmer_Table-update_count"><code>Kmer_Table$update_count()</code></a>
</p>
</li>
<li> <p><a href="#method-Kmer_Table-update_row"><code>Kmer_Table$update_row()</code></a>
</p>
</li>
<li> <p><a href="#method-Kmer_Table-clone"><code>Kmer_Table$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Kmer_Table-new"></a>



<h4>Method <code>new()</code></h4>

<p>initialize empty data.table of k-mers
</p>


<h5>Usage</h5>

<div class="r"><pre>Kmer_Table$new()</pre></div>


<hr>
<a id="method-Kmer_Table-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kmer_Table$print()</pre></div>


<hr>
<a id="method-Kmer_Table-remove_N"></a>



<h4>Method <code>remove_N()</code></h4>

<p>Remove unknown base N.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kmer_Table$remove_N()</pre></div>


<hr>
<a id="method-Kmer_Table-filter_central_pattern"></a>



<h4>Method <code>filter_central_pattern()</code></h4>

<p>Filter out k-mers without defined central patterns.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kmer_Table$filter_central_pattern(central.pattern, k)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>central.pattern</code></dt><dd><p>Central pattern.</p>
</dd>
<dt><code>k</code></dt><dd><p>Length of k-mer.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None.
</p>


<hr>
<a id="method-Kmer_Table-update_count"></a>



<h4>Method <code>update_count()</code></h4>

<p>Update count for existed k-mers in the table.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kmer_Table$update_count(kmers, is.strand.sensitive, strand)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>kmers</code></dt><dd><p>K-mer table with new count to be added to the main table.</p>
</dd>
<dt><code>is.strand.sensitive</code></dt><dd><p>Does strand polarity matter?</p>
</dd>
<dt><code>strand</code></dt><dd><p>If yes, what is the strand refers to? &quot;+&quot; or &quot;-&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None.
</p>


<hr>
<a id="method-Kmer_Table-update_row"></a>



<h4>Method <code>update_row()</code></h4>

<p>Add new rows for new k-mers with their respective counts that is not
existed yet in the main table.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kmer_Table$update_row(kmers, is.strand.sensitive, strand)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>kmers</code></dt><dd><p>K-mer table with new k-mers to be added to the main table.</p>
</dd>
<dt><code>is.strand.sensitive</code></dt><dd><p>Does strand polarity matter?</p>
</dd>
<dt><code>strand</code></dt><dd><p>If yes, what is the strand refers to? &quot;+&quot; or &quot;-&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None.
</p>


<hr>
<a id="method-Kmer_Table-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kmer_Table$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='kmeRtone'>kmeRtone all-in-one user interface</h2><span id='topic+kmeRtone'></span>

<h3>Description</h3>

<p>This function serves as an all-in-one interface for various genomic data analyses
leveraging k-mer based techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeRtone(
  case.coor.path,
  genome.name,
  strand.sensitive,
  k,
  ctrl.rel.pos = c(80, 500),
  case.pattern,
  output.dir = "output/",
  case,
  genome,
  control,
  control.path,
  genome.path,
  rm.case.kmer.overlaps,
  single.case.len,
  merge.replicates,
  kmer.table,
  module = "score",
  rm.dup = TRUE,
  case.coor.1st.idx = 1,
  ctrl.coor.1st.idx = 1,
  coor.load.limit = 1,
  genome.load.limit = 1,
  genome.fasta.style = "UCSC",
  genome.ncbi.db = "refseq",
  use.UCSC.chr.name = FALSE,
  verbose = TRUE,
  kmer.cutoff = 5,
  selected.extremophiles,
  other.extremophiles,
  cosmic.username,
  cosmic.password,
  tumour.type.regex = NULL,
  tumour.type.exact = NULL,
  cell.type = "somatic",
  genic.elements.counts.dt,
  population.size = 1e+06,
  selected.genes,
  add.to.existing.population = FALSE,
  population.snv.dt = NULL,
  pop.plot = TRUE,
  pop.loop.chr = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmeRtone_+3A_case.coor.path">case.coor.path</code></td>
<td>
<p>Path to a folder containing chromosome-separated coordinate
files or bedfiles. Assumed replicates for subfolder or bedfiles.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_genome.name">genome.name</code></td>
<td>
<p>Name of the genome (e.g., &quot;hg19&quot;, &quot;hg38&quot;). Default is &quot;unknown&quot;.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_strand.sensitive">strand.sensitive</code></td>
<td>
<p>Logical value indicating whether strand polarity matters.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_k">k</code></td>
<td>
<p>Length of k-mer to be investigated. Recommended values are 7 or 8.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_ctrl.rel.pos">ctrl.rel.pos</code></td>
<td>
<p>A vector of two integers specifying the relative range positions
of control regions.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_case.pattern">case.pattern</code></td>
<td>
<p>Regular expression pattern for identifying case regions.
Default is NULL.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory path for saving output files. Default is &quot;output/&quot;.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_case">case</code></td>
<td>
<p>Optional pre-built Coordinate object.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_genome">genome</code></td>
<td>
<p>Optional pre-built Genome object.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_control">control</code></td>
<td>
<p>Optional pre-built control Coordinate object.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_control.path">control.path</code></td>
<td>
<p>Path for pre-built control Coordinate object.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_genome.path">genome.path</code></td>
<td>
<p>Path to a directory of user-provided genome FASTA files.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_rm.case.kmer.overlaps">rm.case.kmer.overlaps</code></td>
<td>
<p>Logical indicating whether to remove overlapping
k-mers in case regions. Default is FALSE.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_single.case.len">single.case.len</code></td>
<td>
<p>Integer indicating uniform length of case regions.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_merge.replicates">merge.replicates</code></td>
<td>
<p>Logical indicating whether to merge replicates.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_kmer.table">kmer.table</code></td>
<td>
<p>Pre-calculated k-mer score table.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_module">module</code></td>
<td>
<p>Selected kmeRtone module to run. Possible values include &quot;score&quot;,
&quot;explore&quot;, &quot;tune&quot;, among others.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_rm.dup">rm.dup</code></td>
<td>
<p>Logical indicating whether to remove duplicate coordinates.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_case.coor.1st.idx">case.coor.1st.idx</code></td>
<td>
<p>Integer specifying indexing format for case coordinates.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_ctrl.coor.1st.idx">ctrl.coor.1st.idx</code></td>
<td>
<p>Integer specifying indexing format for control coordinates.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_coor.load.limit">coor.load.limit</code></td>
<td>
<p>Maximum number of coordinates to load. Default is 1.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_genome.load.limit">genome.load.limit</code></td>
<td>
<p>Maximum number of genome sequences to load. Default is 1.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_genome.fasta.style">genome.fasta.style</code></td>
<td>
<p>String specifying the style of the genome FASTA.
Possible values are &quot;UCSC&quot;, &quot;NCBI&quot;. Default is &quot;UCSC&quot;.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_genome.ncbi.db">genome.ncbi.db</code></td>
<td>
<p>String specifying the NCBI database to use. Possible values
are &quot;refseq&quot;, &quot;genbank&quot;. Default is &quot;refseq&quot;.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_use.ucsc.chr.name">use.UCSC.chr.name</code></td>
<td>
<p>Logical indicating whether to use UCSC chromosome names.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to display progress messages.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_kmer.cutoff">kmer.cutoff</code></td>
<td>
<p>Cutoff percentage for k-mer selection in case studies.
Default is 5.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_selected.extremophiles">selected.extremophiles</code></td>
<td>
<p>Vector of selected extremophile species for study.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_other.extremophiles">other.extremophiles</code></td>
<td>
<p>Vector of other extremophile species for control.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_cosmic.username">cosmic.username</code></td>
<td>
<p>COSMIC username for accessing the cancer gene census.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_cosmic.password">cosmic.password</code></td>
<td>
<p>COSMIC password for accessing the cancer gene census.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_tumour.type.regex">tumour.type.regex</code></td>
<td>
<p>Regular expression pattern for filtering tumour types.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_tumour.type.exact">tumour.type.exact</code></td>
<td>
<p>Exact tumour type to be included in the cancer gene census.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_cell.type">cell.type</code></td>
<td>
<p>Cell type to be included in the cancer gene census. Default is
&quot;somatic&quot;.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_genic.elements.counts.dt">genic.elements.counts.dt</code></td>
<td>
<p>Data table of susceptible k-mer counts in genic
elements.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_population.size">population.size</code></td>
<td>
<p>Size of the population for cross-population studies.
Default is 1 million.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_selected.genes">selected.genes</code></td>
<td>
<p>Selected genes for mutation in cross-population studies.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_add.to.existing.population">add.to.existing.population</code></td>
<td>
<p>Logical indicating whether to add to the existing
simulated population. Default is FALSE.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_population.snv.dt">population.snv.dt</code></td>
<td>
<p>Data table of single nucleotide variants used in
population simulations.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_pop.plot">pop.plot</code></td>
<td>
<p>Logical indicating whether to plot the outcome of the cross-population
study. Default is TRUE.</p>
</td></tr>
<tr><td><code id="kmeRtone_+3A_pop.loop.chr">pop.loop.chr</code></td>
<td>
<p>Logical indicating whether to loop based on chromosome name
in cross-population studies. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the selected module.
</p>

<hr>
<h2 id='loadCoordinate'>Build Coordinate object.</h2><span id='topic+loadCoordinate'></span>

<h3>Description</h3>

<p>The Coordinate object is capable of loading genomic coordinates on demand.
Chromosome-specific coordinates can be called in a bracket.
The coordinates can also be expanded to k-mer size equally on both flanks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadCoordinate(
  root.path = NULL,
  single.len = NULL,
  is.strand.sensitive = TRUE,
  merge.replicates = TRUE,
  rm.dup = TRUE,
  add.col.rep = FALSE,
  is.kmer = FALSE,
  k = NA,
  ori.first.index = 1,
  load.limit = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadCoordinate_+3A_root.path">root.path</code></td>
<td>
<p>A path to a directory containing either:
(1) chromosome-separated coordinate files
(multiple replicates is assumed for sub-folder) or
(2) bedfile (multiple replicates is assumed for separate bedfiles).</p>
</td></tr>
<tr><td><code id="loadCoordinate_+3A_single.len">single.len</code></td>
<td>
<p>Single case length relevant when all coordinates have the
same length. This is for memory optimization. Default is NULL.</p>
</td></tr>
<tr><td><code id="loadCoordinate_+3A_is.strand.sensitive">is.strand.sensitive</code></td>
<td>
<p>A boolean whether strand polarity matters.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="loadCoordinate_+3A_merge.replicates">merge.replicates</code></td>
<td>
<p>Merge coordinate from different replicates.
Default is TRUE. If not merging, duplicates will give weight to the
k-mer counting. If add.col.rep, merged coordinate will contain
column replicate e.g. &quot;rep1&amp;rep2&quot;.</p>
</td></tr>
<tr><td><code id="loadCoordinate_+3A_rm.dup">rm.dup</code></td>
<td>
<p>Remove duplicates in each replicate. Default is TRUE.</p>
</td></tr>
<tr><td><code id="loadCoordinate_+3A_add.col.rep">add.col.rep</code></td>
<td>
<p>Add column replicate to the coordinate table.</p>
</td></tr>
<tr><td><code id="loadCoordinate_+3A_is.kmer">is.kmer</code></td>
<td>
<p>Is the coordinate refers to k-mer i.e. expanded case?
Default is FALSE.</p>
</td></tr>
<tr><td><code id="loadCoordinate_+3A_k">k</code></td>
<td>
<p>Length of k-mer relevant only when is.kmer is TRUE.</p>
</td></tr>
<tr><td><code id="loadCoordinate_+3A_ori.first.index">ori.first.index</code></td>
<td>
<p>Indexing format of the coordinate:
0 for zero-based (start, end) and 1 for one-based (start, end).
Default is 1.</p>
</td></tr>
<tr><td><code id="loadCoordinate_+3A_load.limit">load.limit</code></td>
<td>
<p>Maximum number of coordinate data.table loaded on RAM.
Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coordinate object.
</p>

<hr>
<h2 id='loadGenome'>Build Genome object.</h2><span id='topic+loadGenome'></span>

<h3>Description</h3>

<p>The Genome object is capable of loading chromosome sequence on demand.
UCSC Genomes are included in this kmeRtone package. Their specific
chromosome sequence will be downloaded on demand once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadGenome(
  genome.name,
  fasta.style,
  mask = "none",
  fasta.path,
  ncbi.db,
  ncbi.asm,
  use.UCSC.name = FALSE,
  load.limit = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadGenome_+3A_genome.name">genome.name</code></td>
<td>
<p>A genome name. UCSC and NCBI genome is included with
kmeRtone. Input their name e.g. hg19 or GRCh37.</p>
</td></tr>
<tr><td><code id="loadGenome_+3A_fasta.style">fasta.style</code></td>
<td>
<p>FASTA version: &quot;UCSC&quot; or &quot;NCBI&quot;.</p>
</td></tr>
<tr><td><code id="loadGenome_+3A_mask">mask</code></td>
<td>
<p>Genome mask: &quot;none&quot;, &quot;soft&quot;, or &quot;hard&quot;. Default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="loadGenome_+3A_fasta.path">fasta.path</code></td>
<td>
<p>Path to a directory of user-provided genome FASTA files or
the destination to save the NCBI/UCSC downloaded reference genome files.</p>
</td></tr>
<tr><td><code id="loadGenome_+3A_ncbi.db">ncbi.db</code></td>
<td>
<p>NCBI database: &quot;refseq&quot; or &quot;genbank&quot;.</p>
</td></tr>
<tr><td><code id="loadGenome_+3A_ncbi.asm">ncbi.asm</code></td>
<td>
<p>NCBI assembly table.</p>
</td></tr>
<tr><td><code id="loadGenome_+3A_use.ucsc.name">use.UCSC.name</code></td>
<td>
<p>For NCBI Genome, use UCSC-style chromosome name? Default
is FALSE.</p>
</td></tr>
<tr><td><code id="loadGenome_+3A_load.limit">load.limit</code></td>
<td>
<p>Maximum chromosome sequences loaded. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>UCSC_Genome</code> or <code>NCBI_Genome</code> object.
</p>

<hr>
<h2 id='loadGenomicContents'>Function calculates various genomic content metrics based on the provided genome object.</h2><span id='topic+loadGenomicContents'></span>

<h3>Description</h3>

<p>Function calculates various genomic content metrics based on the provided genome object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadGenomicContents(genome)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadGenomicContents_+3A_genome">genome</code></td>
<td>
<p>An object of class 'NCBI_Genome' containing genomic information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing calculated genomic content metrics.
</p>

<hr>
<h2 id='mapKmers'>Map k-mers of a given sequence and coordinate</h2><span id='topic+mapKmers'></span>

<h3>Description</h3>

<p>This function maps k-mers within a specified sequence based on provided start
and end coordinates, or based on a fixed length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapKmers(seq, start, end = NULL, len = NULL, k, rm.trunc.kmer = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapKmers_+3A_seq">seq</code></td>
<td>
<p>A single sequence string in which k-mers are to be mapped.</p>
</td></tr>
<tr><td><code id="mapKmers_+3A_start">start</code></td>
<td>
<p>A vector of start coordinates for mapping k-mers.
If only start positions are provided, exact k-mer extraction is performed.</p>
</td></tr>
<tr><td><code id="mapKmers_+3A_end">end</code></td>
<td>
<p>A vector of end coordinates corresponding to the start positions.
If NULL, all regions are assumed to have the same length.
Used for varied region lengths to perform a sliding window.</p>
</td></tr>
<tr><td><code id="mapKmers_+3A_len">len</code></td>
<td>
<p>An integer specifying the fixed length of regions.
Used when regions have a uniform length greater than k.
End coordinates are assumed NULL in this case.</p>
</td></tr>
<tr><td><code id="mapKmers_+3A_k">k</code></td>
<td>
<p>An integer specifying the length of k-mers to be mapped.</p>
</td></tr>
<tr><td><code id="mapKmers_+3A_rm.trunc.kmer">rm.trunc.kmer</code></td>
<td>
<p>Logical indicating whether to remove truncated k-mers
resulting from out-of-bound regions. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mapped k-mers.
</p>

<hr>
<h2 id='mergeCoordinate'>Merge overlapping or continuous regions.</h2><span id='topic+mergeCoordinate'></span>

<h3>Description</h3>

<p>Table must have start and end columns. The output is exactly similar to the
reduce function from GenomicRanges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeCoordinate(coor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeCoordinate_+3A_coor">coor</code></td>
<td>
<p>Coordinate <code>data.table</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Merged coordinate <code>data.table</code>.
</p>

<hr>
<h2 id='mixColors'>Mix color</h2><span id='topic+mixColors'></span>

<h3>Description</h3>

<p>This is useful to get overlayed colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixColors(cols, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixColors_+3A_cols">cols</code></td>
<td>
<p>Colors in hex format or R color code e.g. &quot;red&quot;, &quot;black&quot;, etc.</p>
</td></tr>
<tr><td><code id="mixColors_+3A_alpha">alpha</code></td>
<td>
<p>Add alpha transparency value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New mixed colors in hex format.
</p>

<hr>
<h2 id='NCBI_Genome'>Class constructor - build NCBI Genome object</h2><span id='topic+NCBI_Genome'></span>

<h3>Description</h3>

<p>Class constructor - build NCBI Genome object
</p>
<p>Class constructor - build NCBI Genome object
</p>


<h3>Details</h3>

<p>NCBI FASTA file contain nucleotide accession number at the headers, followed
by some information about the sequence whether they are chromosome,
plasmid, or mictochondria, their assembly status, etc.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>fasta_file</code></dt><dd><p>A path to FASTA file.
fasta files.</p>
</dd>
<dt><code>genome_name</code></dt><dd><p>A genome name.</p>
</dd>
<dt><code>db</code></dt><dd><p>NCBI database: &quot;refseq&quot; or &quot;genbank&quot;</p>
</dd>
<dt><code>seq</code></dt><dd><p>A chromosome-named list of sequences.</p>
</dd>
<dt><code>seq_len</code></dt><dd><p>A chromosome-named vector of sequence length.</p>
</dd>
<dt><code>load_limit</code></dt><dd><p>Maximum chromosome sequences loaded.</p>
</dd>
<dt><code>mask</code></dt><dd><p>Genome mask status: &quot;hard&quot;, &quot;soft&quot;, or &quot;none&quot;.</p>
</dd>
<dt><code>use_UCSC_name</code></dt><dd><p>Use UCSC style chromosome name? Default to FALSE.</p>
</dd>
<dt><code>headers</code></dt><dd><p>A chromosome-named vector of headers.</p>
</dd>
<dt><code>avail_seqs</code></dt><dd><p>Available chromosome sequences in the fasta file.</p>
</dd>
<dt><code>asm</code></dt><dd><p>Assembly summary.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NCBI_Genome-new"><code>NCBI_Genome$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NCBI_Genome-print"><code>NCBI_Genome$print()</code></a>
</p>
</li>
<li> <p><a href="#method-NCBI_Genome-get_assembly_report"><code>NCBI_Genome$get_assembly_report()</code></a>
</p>
</li>
<li> <p><a href="#method-NCBI_Genome-clone"><code>NCBI_Genome$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-NCBI_Genome-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new NCBI Genome class
</p>


<h5>Usage</h5>

<div class="r"><pre>NCBI_Genome$new(
  genome.name,
  db,
  fasta.file,
  asm,
  mask,
  use.UCSC.name,
  load.limit
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genome.name</code></dt><dd><p>A genome name. NCBI genome is included with kmeRtone.</p>
</dd>
<dt><code>db</code></dt><dd><p>NCBI database: &quot;refseq&quot; or &quot;genbank&quot;.</p>
</dd>
<dt><code>fasta.file</code></dt><dd><p>A path to the NCBI-style fasta files. This is for
user's own FASTA file.</p>
</dd>
<dt><code>asm</code></dt><dd><p>NCBI assembly summary.</p>
</dd>
<dt><code>mask</code></dt><dd><p>Genome mask status: &quot;hard&quot;, &quot;soft&quot;, or &quot;none&quot;. Default is
&quot;none&quot;.</p>
</dd>
<dt><code>use.UCSC.name</code></dt><dd><p>Use UCSC style chromosome name? Default to FALSE.</p>
</dd>
<dt><code>load.limit</code></dt><dd><p>Maximum chromosome sequences loaded. Default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code style="white-space: pre;">&#8288;NCBI Genome&#8288;</code> object.
</p>


<hr>
<a id="method-NCBI_Genome-["></a>



<h4>Method <code>[()</code></h4>

<p>Calling chromosome sequence by loading on demand.
Maximum load is determine by load_limit field.
</p>


<h5>Usage</h5>

<div class="r"><pre>NCBI_Genome$[(chr.names, reload = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chr.names</code></dt><dd><p>Chromosome name. It can be a vector of chromosomes.</p>
</dd>
<dt><code>reload</code></dt><dd><p>Reload the sequence from the fasta_file.
Default is FALSE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A single or list of sequence of requested chromosome.
</p>


<hr>
<a id="method-NCBI_Genome-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print summary of <code>Genome</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>NCBI_Genome$print()</pre></div>



<h5>Returns</h5>

<p>Message of <code>Genome</code> object summary.
</p>


<hr>
<a id="method-NCBI_Genome-get_assembly_report"></a>



<h4>Method <code>get_assembly_report()</code></h4>

<p>Get NCBI assembly report for the genome.
</p>


<h5>Usage</h5>

<div class="r"><pre>NCBI_Genome$get_assembly_report()</pre></div>



<h5>Returns</h5>

<p>Message of <code>Genome</code> object summary.
</p>


<hr>
<a id="method-NCBI_Genome-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NCBI_Genome$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='partitionCoordinate'>Partition overlapping or continuous regions.</h2><span id='topic+partitionCoordinate'></span>

<h3>Description</h3>

<p>Table must have start and end columns. The mechanism is similar to the
disjoin function from GenomicRanges but the end coordinate is different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partitionCoordinate(coor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partitionCoordinate_+3A_coor">coor</code></td>
<td>
<p>Coordinate <code>data.table</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Partitioned coordinate <code>data.table</code>.
</p>

<hr>
<h2 id='persistentDownload'>Download file until successful</h2><span id='topic+persistentDownload'></span>

<h3>Description</h3>

<p>If download failed, it will be repeated until max attempt reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>persistentDownload(
  file.url,
  output.name,
  max.attempt = 5,
  user.invoke = TRUE,
  header
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="persistentDownload_+3A_file.url">file.url</code></td>
<td>
<p>File uniform resource locator.</p>
</td></tr>
<tr><td><code id="persistentDownload_+3A_output.name">output.name</code></td>
<td>
<p>Output name.</p>
</td></tr>
<tr><td><code id="persistentDownload_+3A_max.attempt">max.attempt</code></td>
<td>
<p>Maximum number of attempt. Default is 5.</p>
</td></tr>
<tr><td><code id="persistentDownload_+3A_user.invoke">user.invoke</code></td>
<td>
<p>If number of attempt is reached, ask user whether to keep
trying. Default is TRUE to invoke the prompt.</p>
</td></tr>
<tr><td><code id="persistentDownload_+3A_header">header</code></td>
<td>
<p>A named list or vector of curl header.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A downloaded file.
</p>

<hr>
<h2 id='readBED'>Read a BED file. One-based indexing is enforced.</h2><span id='topic+readBED'></span>

<h3>Description</h3>

<p>Read a BED file. One-based indexing is enforced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBED(bed.path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readBED_+3A_bed.path">bed.path</code></td>
<td>
<p>A path to a BED file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table.
</p>

<hr>
<h2 id='readFASTA'>Read FASTA files.</h2><span id='topic+readFASTA'></span>

<h3>Description</h3>

<p>Read FASTA files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFASTA(fasta.file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readFASTA_+3A_fasta.file">fasta.file</code></td>
<td>
<p>A path to a FASTA file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence vector with header names
</p>

<hr>
<h2 id='readVCF'>Read VCF file using tabix.</h2><span id='topic+readVCF'></span>

<h3>Description</h3>

<p>Require tabix in PATH
VCF manual is referred from https://samtools.github.io/hts-specs/VCFv4.3.pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readVCF(vcf.file, chr.names, starts, ends, INFO.filter = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readVCF_+3A_vcf.file">vcf.file</code></td>
<td>
<p>A path to a local or remote tabix-indexed VCF file.</p>
</td></tr>
<tr><td><code id="readVCF_+3A_chr.names">chr.names</code></td>
<td>
<p>Chromosome names.</p>
</td></tr>
<tr><td><code id="readVCF_+3A_starts">starts</code></td>
<td>
<p>Start positions.</p>
</td></tr>
<tr><td><code id="readVCF_+3A_ends">ends</code></td>
<td>
<p>End positions.</p>
</td></tr>
<tr><td><code id="readVCF_+3A_info.filter">INFO.filter</code></td>
<td>
<p>Parse only filtered INFO ID. Default is to parse all IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table of VCF.
</p>

<hr>
<h2 id='readVCF2'>Read VCF file using tabix.</h2><span id='topic+readVCF2'></span>

<h3>Description</h3>

<p>Require tabix in PATH
VCF manual is referred from https://samtools.github.io/hts-specs/VCFv4.3.pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readVCF2(vcf.file, chr.names, starts, ends, INFO.filter = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readVCF2_+3A_vcf.file">vcf.file</code></td>
<td>
<p>A path to a local or remote tabix-indexed VCF file.</p>
</td></tr>
<tr><td><code id="readVCF2_+3A_chr.names">chr.names</code></td>
<td>
<p>Chromosome names.</p>
</td></tr>
<tr><td><code id="readVCF2_+3A_starts">starts</code></td>
<td>
<p>Start positions.</p>
</td></tr>
<tr><td><code id="readVCF2_+3A_ends">ends</code></td>
<td>
<p>End positions.</p>
</td></tr>
<tr><td><code id="readVCF2_+3A_info.filter">INFO.filter</code></td>
<td>
<p>Parse only filtered INFO ID. Default is to parse all IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table of VCF.
</p>

<hr>
<h2 id='removeRegion'>Remove overlapping region in coordinate <code>data.table</code>.</h2><span id='topic+removeRegion'></span>

<h3>Description</h3>

<p>Any &quot;coor&quot; that overlap within the &quot;region&quot; will be removed
e.g. region = 10-20 and coor = 1-30
The results will be: coor = 1-10, 20-30
The coor still overlap one base at the terminal. This is done to
produce exact result as the previous MPhil research.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeRegion(coor, region)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeRegion_+3A_coor">coor</code></td>
<td>
<p>Coordinate <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="removeRegion_+3A_region">region</code></td>
<td>
<p>A <code>data.table</code> of region coordinate to be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New coordinate <code>data.table</code> with the regions removed.
</p>

<hr>
<h2 id='reverseComplement'>Get reverse complement sequence of DNA</h2><span id='topic+reverseComplement'></span>

<h3>Description</h3>

<p>Get reverse complement sequence of DNA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverseComplement(DNA.sequence, form = "string")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverseComplement_+3A_dna.sequence">DNA.sequence</code></td>
<td>
<p>DNA sequence can be in a form of character vector or
string. Multiple sequences are accepted.</p>
</td></tr>
<tr><td><code id="reverseComplement_+3A_form">form</code></td>
<td>
<p>Specify the form: &quot;string&quot; of &quot;vector&quot;. Default is &quot;string&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reverse complementary sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   reverseComplement("AAAAA")
   reverseComplement(c("AAAAA", "CCCCC"))
   reverseComplement(c("A", "A", "A", "A"), form = "vector")
 
</code></pre>

<hr>
<h2 id='SCORE'>Calculate susceptibility scores for k-mers in case and control regions.</h2><span id='topic+SCORE'></span>

<h3>Description</h3>

<p>Function calculates susceptibility scores for k-mers in case and control regions.
Case regions are defined by genomic coordinates provided in a file or data.table.
Control regions can be constructed relative to the case regions or provided directly.
The scores are computed based on the occurrence of k-mers in case and control regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCORE(
  case.coor.path,
  genome.name,
  strand.sensitive,
  k,
  ctrl.rel.pos,
  case.pattern,
  output.path,
  case,
  genome,
  control,
  control.path,
  genome.path,
  rm.case.kmer.overlaps,
  single.case.len,
  merge.replicates,
  rm.dup,
  case.coor.1st.idx,
  ctrl.coor.1st.idx,
  coor.load.limit,
  genome.load.limit,
  genome.fasta.style,
  genome.ncbi.db,
  use.UCSC.chr.name,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SCORE_+3A_case.coor.path">case.coor.path</code></td>
<td>
<p>Path to the file containing genomic coordinates of case regions.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_genome.name">genome.name</code></td>
<td>
<p>Name of the genome to be used.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_strand.sensitive">strand.sensitive</code></td>
<td>
<p>Logical indicating whether strand information should be considered.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_k">k</code></td>
<td>
<p>Integer size of the expanded k-mer.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_ctrl.rel.pos">ctrl.rel.pos</code></td>
<td>
<p>Relative positions of control regions with respect to case regions.
It should be a vector of two integers indicating the upstream and downstream
distances from the case regions.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_case.pattern">case.pattern</code></td>
<td>
<p>Regular expression pattern to identify the central sequence in case regions.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_output.path">output.path</code></td>
<td>
<p>Directory path where the output files will be saved.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_case">case</code></td>
<td>
<p>Data.table containing the genomic coordinates of case regions.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_genome">genome</code></td>
<td>
<p>Genome data.table containing the genomic sequence information.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_control">control</code></td>
<td>
<p>Data.table containing the genomic coordinates of control regions.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_control.path">control.path</code></td>
<td>
<p>Path to the file containing genomic coordinates of control regions (optional).</p>
</td></tr>
<tr><td><code id="SCORE_+3A_genome.path">genome.path</code></td>
<td>
<p>Path to the genome FASTA file.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_rm.case.kmer.overlaps">rm.case.kmer.overlaps</code></td>
<td>
<p>Logical indicating whether overlapping k-mers within case regions should be removed.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_single.case.len">single.case.len</code></td>
<td>
<p>Single case length.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_merge.replicates">merge.replicates</code></td>
<td>
<p>Logical indicating whether replicates should be merged.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_rm.dup">rm.dup</code></td>
<td>
<p>Logical indicating whether duplicate k-mers should be removed.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_case.coor.1st.idx">case.coor.1st.idx</code></td>
<td>
<p>First index in the case coordinate file.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_ctrl.coor.1st.idx">ctrl.coor.1st.idx</code></td>
<td>
<p>First index in the control coordinate file.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_coor.load.limit">coor.load.limit</code></td>
<td>
<p>Maximum number of coordinates to load.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_genome.load.limit">genome.load.limit</code></td>
<td>
<p>Maximum number of genome sequences to load.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_genome.fasta.style">genome.fasta.style</code></td>
<td>
<p>FASTA style.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_genome.ncbi.db">genome.ncbi.db</code></td>
<td>
<p>NCBI database.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_use.ucsc.chr.name">use.UCSC.chr.name</code></td>
<td>
<p>Logical indicating whether to use UCSC chromosome names.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to display progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.table containing susceptibility scores for k-mers.
</p>

<hr>
<h2 id='scoreKmers'>Function calculates the Z-score for each k-mer based on the observed
case counts and expected case counts under the null hypothesis.</h2><span id='topic+scoreKmers'></span>

<h3>Description</h3>

<p>Function calculates the Z-score for each k-mer based on the observed
case counts and expected case counts under the null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreKmers(kmer.table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreKmers_+3A_kmer.table">kmer.table</code></td>
<td>
<p>A data.table containing k-mer counts, where each row represents a
k-mer and columns &quot;case&quot; and &quot;control&quot; represent the counts in case and control samples respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the input <code>kmer.table</code> with an additional column
&quot;z&quot; containing the calculated Z-scores for each k-mer.
</p>

<hr>
<h2 id='selectGenomesForCrossSpeciesStudy'>Select genomes for cross-species studies.</h2><span id='topic+selectGenomesForCrossSpeciesStudy'></span>

<h3>Description</h3>

<p>The following filters are applied:
</p>

<ol>
<li><p> assembly_level: &quot;Complete Genome&quot; or &quot;Chromosome&quot;
</p>
</li>
<li><p> genome_rep: &quot;Full&quot;
</p>
</li>
<li><p> Unique species_taxid (single representative species)
</p>
</li>
<li><p> refseq_category of &quot;reference genome&quot; is prioritised over
&quot;representative genome&quot;
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>selectGenomesForCrossSpeciesStudy(organism.group = "bacteria", db = "refseq")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectGenomesForCrossSpeciesStudy_+3A_organism.group">organism.group</code></td>
<td>
<p>Species group: archaea, bacteria, fungi, invertebrate,
plant, protozoa, vertebrate_mammalian, vertebrate_other, or viral.</p>
</td></tr>
<tr><td><code id="selectGenomesForCrossSpeciesStudy_+3A_db">db</code></td>
<td>
<p>Database record to use: refseq or genbank</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NCBI assembly summary with added column organism.group.
</p>

<hr>
<h2 id='selectRepresentativeFromASM'>Select the best representative species from the NCBI assembly summary.</h2><span id='topic+selectRepresentativeFromASM'></span>

<h3>Description</h3>

<p>sort.idx is a weight to sort where heavier will be preffered. Any tie weight
will be further sorted by organism_name. Only the top unique species_taxid
will be retained in the final assembly summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectRepresentativeFromASM(asm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectRepresentativeFromASM_+3A_asm">asm</code></td>
<td>
<p>NCBI assembly summary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Trimmed NCBI assembly summary.
</p>

<hr>
<h2 id='simulatePopulation'>Simulate a population given ranges of chromosome sequence to mutate.</h2><span id='topic+simulatePopulation'></span>

<h3>Description</h3>

<p>Simulate a population given ranges of chromosome sequence to mutate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatePopulation(
  chrom_seq,
  starts,
  ends,
  strand,
  snv_df,
  pop_size,
  top_kmers,
  central_pattern,
  k
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulatePopulation_+3A_chrom_seq">chrom_seq</code></td>
<td>
<p>A chromosome sequence.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_starts">starts</code></td>
<td>
<p>Start positions.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_ends">ends</code></td>
<td>
<p>End positions.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_strand">strand</code></td>
<td>
<p>Strand type: &quot;+&quot; or &quot;-&quot;.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_snv_df">snv_df</code></td>
<td>
<p>A table of SNV frequency. Columns: position, base, count.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_pop_size">pop_size</code></td>
<td>
<p>Size of population.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_top_kmers">top_kmers</code></td>
<td>
<p>Extreme k-mers i.e. highly susceptible k-mers.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_central_pattern">central_pattern</code></td>
<td>
<p>K-mer central pattern.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_k">k</code></td>
<td>
<p>K-mer size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A count matrix with 4 rows for total top k-mers and susceptible
k-mers in sense and antisense. Columns correspond to population
individuals.
</p>

<hr>
<h2 id='splitFASTA'>Split a FASTA file by header.</h2><span id='topic+splitFASTA'></span>

<h3>Description</h3>

<p>The first non-space word in the header will be used as the file name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitFASTA(fasta.file, output.dir = "./")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitFASTA_+3A_fasta.file">fasta.file</code></td>
<td>
<p>A path to a FASTA file.</p>
</td></tr>
<tr><td><code id="splitFASTA_+3A_output.dir">output.dir</code></td>
<td>
<p>A path to save the output results. Default is current working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>data.table::fread is not built for reading in chunks. The developers expect
skip and nrow arguments to be in a small number. Large number slows the
reading a bit.
</p>


<h3>Value</h3>

<p>A splitted fasta files by its headers.
</p>

<hr>
<h2 id='STUDY_ACROSS_POPULATIONS'>Study k-mer composition of selected COSMIC causal cancer genes across human
populations worldwide.</h2><span id='topic+STUDY_ACROSS_POPULATIONS'></span>

<h3>Description</h3>

<p>Simulation of human population is based on single nucleotide variantion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STUDY_ACROSS_POPULATIONS(
  kmer.table,
  kmer.cutoff = 5,
  genome.name,
  k,
  db = "refseq",
  central.pattern = NULL,
  population.size = 1e+06,
  selected.genes,
  add.to.existing.population = FALSE,
  output.dir = "study_across_populations/",
  population.snv.dt = NULL,
  loop.chr = TRUE,
  plot = FALSE,
  fasta.path
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_kmer.table">kmer.table</code></td>
<td>
<p>A data.table of kmer table.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_kmer.cutoff">kmer.cutoff</code></td>
<td>
<p>Percentage of extreme kmers to study. Default to 5.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_genome.name">genome.name</code></td>
<td>
<p>UCSC genome name.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_k">k</code></td>
<td>
<p>K-mer size.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_db">db</code></td>
<td>
<p>Database used by UCSC to generate gene prediction: &quot;refseq&quot; or
&quot;gencode&quot;. Default is &quot;refseq&quot;.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_central.pattern">central.pattern</code></td>
<td>
<p>K-mer's central patterns. Default is NULL.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_population.size">population.size</code></td>
<td>
<p>Size of population to simulate. Default is 1 million.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_selected.genes">selected.genes</code></td>
<td>
<p>Set of genes to study e.g. skin cancer genes.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_add.to.existing.population">add.to.existing.population</code></td>
<td>
<p>Add counts to counts.csv? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_output.dir">output.dir</code></td>
<td>
<p>A directory for the outputs. Default to
study_across_populations.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_population.snv.dt">population.snv.dt</code></td>
<td>
<p>Population SNV table.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_loop.chr">loop.chr</code></td>
<td>
<p>Loop chromosome?. Default is TRUE. If FALSE, beware of a
memory spike because of VCF content. VCF contains zero counts for every
population. Input pre-computed trimmed-version population.snv.dt.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_plot">plot</code></td>
<td>
<p>Boolean. Default is FALSE. If TRUE, will plot results.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_POPULATIONS_+3A_fasta.path">fasta.path</code></td>
<td>
<p>Path to a directory of user-provided genome FASTA files or
the destination to save the NCBI/UCSC downloaded reference genome files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output directory containing plots.
</p>

<hr>
<h2 id='STUDY_ACROSS_SPECIES'>Study k-mer composition across species.</h2><span id='topic+STUDY_ACROSS_SPECIES'></span>

<h3>Description</h3>

<p>Analysis of distribution of highly enriched k-mers across species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STUDY_ACROSS_SPECIES(
  kmer.table,
  kmer.cutoff = 5,
  k,
  central.pattern = NULL,
  selected.extremophiles,
  other.extremophiles,
  output.dir = "study_across_species/",
  fasta.path
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STUDY_ACROSS_SPECIES_+3A_kmer.table">kmer.table</code></td>
<td>
<p>A data.table of kmer table or path to it.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_SPECIES_+3A_kmer.cutoff">kmer.cutoff</code></td>
<td>
<p>Percentage of extreme kmers to study. Default to 5
percent.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_SPECIES_+3A_k">k</code></td>
<td>
<p>K-mer size.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_SPECIES_+3A_central.pattern">central.pattern</code></td>
<td>
<p>K-mer's central patterns. Default is NULL.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_SPECIES_+3A_selected.extremophiles">selected.extremophiles</code></td>
<td>
<p>A vector of selected extremophile species. e.g.
c(&quot;Deinococcus soli&quot;, &quot;Deinococcus deserti&quot;)
The best representative will be selected from the assembly summary.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_SPECIES_+3A_other.extremophiles">other.extremophiles</code></td>
<td>
<p>A vector of other extremophile species. These are
used as a control to compare with the selected extremophiles.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_SPECIES_+3A_output.dir">output.dir</code></td>
<td>
<p>A directory for the outputs.</p>
</td></tr>
<tr><td><code id="STUDY_ACROSS_SPECIES_+3A_fasta.path">fasta.path</code></td>
<td>
<p>Path to a directory of user-provided genome FASTA files or
the destination to save the NCBI/UCSC downloaded reference genome files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output directory containing plots.
</p>

<hr>
<h2 id='STUDY_CANCER_GENES'>Study k-mer composition of causal cancer genes from COSMIC Cancer Gene
Census (CGC) database.</h2><span id='topic+STUDY_CANCER_GENES'></span>

<h3>Description</h3>

<p>Detail of Cancer Gene Census can be accessed and read at
https://cancer.sanger.ac.uk/census
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STUDY_CANCER_GENES(
  cosmic.username,
  cosmic.password,
  tumour.type.regex = NULL,
  tumour.type.exact = NULL,
  cell.type = "somatic",
  genic.elements.counts.dt,
  output.dir = "study_cancer_genes/"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STUDY_CANCER_GENES_+3A_cosmic.username">cosmic.username</code></td>
<td>
<p>COSMIC username i.e. registered email.</p>
</td></tr>
<tr><td><code id="STUDY_CANCER_GENES_+3A_cosmic.password">cosmic.password</code></td>
<td>
<p>COSMIC password.</p>
</td></tr>
<tr><td><code id="STUDY_CANCER_GENES_+3A_tumour.type.regex">tumour.type.regex</code></td>
<td>
<p>Regular expression for &quot;Tumour Types&quot; column in
Cancer Gene Census table. Default is NULL.</p>
</td></tr>
<tr><td><code id="STUDY_CANCER_GENES_+3A_tumour.type.exact">tumour.type.exact</code></td>
<td>
<p>Exact keywords for &quot;Tumour Types&quot; column in
Cancer Gene Census table. Default is NULL.</p>
</td></tr>
<tr><td><code id="STUDY_CANCER_GENES_+3A_cell.type">cell.type</code></td>
<td>
<p>Type of cell: &quot;somatic&quot; or &quot;germline&quot;. Default is &quot;somatic&quot;.</p>
</td></tr>
<tr><td><code id="STUDY_CANCER_GENES_+3A_genic.elements.counts.dt">genic.elements.counts.dt</code></td>
<td>
<p>Genic element count table generated from
STUDY_GENIC_ELEMENTS.</p>
</td></tr>
<tr><td><code id="STUDY_CANCER_GENES_+3A_output.dir">output.dir</code></td>
<td>
<p>A directory for the outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output directory containing plots.
</p>

<hr>
<h2 id='STUDY_GENIC_ELEMENTS'>Study k-mer composition across species.</h2><span id='topic+STUDY_GENIC_ELEMENTS'></span>

<h3>Description</h3>

<p>Study k-mer composition across species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STUDY_GENIC_ELEMENTS(
  kmer.table,
  kmer.cutoff = 5,
  k,
  genome.name = "hg38",
  central.pattern = NULL,
  db = "refseq",
  output.dir = "study_genic_elements/",
  fasta.path
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STUDY_GENIC_ELEMENTS_+3A_kmer.table">kmer.table</code></td>
<td>
<p>A data.table of kmer table.</p>
</td></tr>
<tr><td><code id="STUDY_GENIC_ELEMENTS_+3A_kmer.cutoff">kmer.cutoff</code></td>
<td>
<p>Percentage of extreme kmers to study. Default to 5.</p>
</td></tr>
<tr><td><code id="STUDY_GENIC_ELEMENTS_+3A_k">k</code></td>
<td>
<p>K-mer size.</p>
</td></tr>
<tr><td><code id="STUDY_GENIC_ELEMENTS_+3A_genome.name">genome.name</code></td>
<td>
<p>UCSC genome name.</p>
</td></tr>
<tr><td><code id="STUDY_GENIC_ELEMENTS_+3A_central.pattern">central.pattern</code></td>
<td>
<p>K-mer's central patterns. Default is NULL.</p>
</td></tr>
<tr><td><code id="STUDY_GENIC_ELEMENTS_+3A_db">db</code></td>
<td>
<p>Database used by UCSC to generate gene prediction: &quot;refseq&quot; or
&quot;gencode&quot;. Default is &quot;refseq&quot;.</p>
</td></tr>
<tr><td><code id="STUDY_GENIC_ELEMENTS_+3A_output.dir">output.dir</code></td>
<td>
<p>A directory for the outputs.</p>
</td></tr>
<tr><td><code id="STUDY_GENIC_ELEMENTS_+3A_fasta.path">fasta.path</code></td>
<td>
<p>Path to a directory of user-provided genome FASTA files or
the destination to save the NCBI/UCSC downloaded reference genome files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output directory containing plots.
</p>

<hr>
<h2 id='system3'>A system2 wrapper. If anything happen, just give me error!</h2><span id='topic+system3'></span>

<h3>Description</h3>

<p>Turn warning to error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>system3(
  command,
  args = character(),
  stdout = "",
  stderr = "",
  stdin = "",
  input = NULL,
  env = character(),
  wait = TRUE,
  minimized,
  invisible,
  timeout = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="system3_+3A_command">command</code></td>
<td>
<p>the system command to be invoked, as a character string.</p>
</td></tr>
<tr><td><code id="system3_+3A_args">args</code></td>
<td>
<p>a character vector of arguments to <code>command</code>.</p>
</td></tr>
<tr><td><code id="system3_+3A_stdout">stdout</code>, <code id="system3_+3A_stderr">stderr</code></td>
<td>
<p>where output to ‘stdout’ or ‘stderr’ should be sent.
Possible values are &quot;&quot;, to the R console (the default), <code>NULL</code> or <code>FALSE</code>
(discard output), <code>TRUE</code> (capture the output in a character vector) or a
character string naming a file.</p>
</td></tr>
<tr><td><code id="system3_+3A_stdin">stdin</code></td>
<td>
<p>should input be diverted? &quot;&quot; means the default, alternatively a
character string naming a file. Ignored if input is supplied.</p>
</td></tr>
<tr><td><code id="system3_+3A_input">input</code></td>
<td>
<p>if a character vector is supplied, this is copied one string per
line to a temporary file, and the standard input of command is redirected
to the file.</p>
</td></tr>
<tr><td><code id="system3_+3A_env">env</code></td>
<td>
<p>character vector of name=value strings to set environment
variables.</p>
</td></tr>
<tr><td><code id="system3_+3A_wait">wait</code></td>
<td>
<p>a logical (not <code>NA</code>) indicating whether the <code>R</code> interpreter
should wait for the command to finish, or run it asynchronously. This
will be ignored (and the interpreter will always wait) if stdout = <code>TRUE</code>
or stderr = <code>TRUE.</code> When running the command asynchronously, no output
will be displayed on the Rgui console in Windows (it will be dropped,
instead).</p>
</td></tr>
<tr><td><code id="system3_+3A_minimized">minimized</code>, <code id="system3_+3A_invisible">invisible</code></td>
<td>
<p>arguments that are accepted on Windows but ignored
on this platform, with a warning.</p>
</td></tr>
<tr><td><code id="system3_+3A_timeout">timeout</code></td>
<td>
<p>timeout in seconds, ignored if 0. This is a limit for the
elapsed time running command in a separate process. Fractions of seconds
are ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='trimCoordinate'>Trim out-of-bound coordinates</h2><span id='topic+trimCoordinate'></span>

<h3>Description</h3>

<p>It operates in two mode: coordinate table with and without chromosome. The
former require <code>Genome</code> for the chromosomal sequence length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimCoordinate(coor, seq.len, genome)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimCoordinate_+3A_coor">coor</code></td>
<td>
<p>Coordinate <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="trimCoordinate_+3A_seq.len">seq.len</code></td>
<td>
<p>Sequence length to trim end position.</p>
</td></tr>
<tr><td><code id="trimCoordinate_+3A_genome">genome</code></td>
<td>
<p><code>Genome</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Trimmed coordinate <code>data.table</code>.
</p>

<hr>
<h2 id='UCSC_Genome'>Class constructor - build Genome object</h2><span id='topic+UCSC_Genome'></span>

<h3>Description</h3>

<p>Class constructor - build Genome object
</p>
<p>Class constructor - build Genome object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>root_path</code></dt><dd><p>A path to a directory containing chromosome-separated
fasta files.</p>
</dd>
<dt><code>genome_name</code></dt><dd><p>A genome name.</p>
</dd>
<dt><code>paths</code></dt><dd><p>Individual chromosome sequence files.</p>
</dd>
<dt><code>seq</code></dt><dd><p>A chromosome-named list of sequences.</p>
</dd>
<dt><code>seq_len</code></dt><dd><p>A chromosome-named vector of sequence length.</p>
</dd>
<dt><code>load_limit</code></dt><dd><p>Maximum chromosome sequences loaded.</p>
</dd>
<dt><code>mask</code></dt><dd><p>Genome mask status: &quot;hard&quot;, &quot;soft&quot;, or &quot;none&quot;.</p>
</dd>
<dt><code>info_file</code></dt><dd><p>Path to info file with pre-computed values.</p>
</dd>
<dt><code>chr_names</code></dt><dd><p>Chromosome names.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-UCSC_Genome-new"><code>UCSC_Genome$new()</code></a>
</p>
</li>
<li> <p><a href="#method-UCSC_Genome-print"><code>UCSC_Genome$print()</code></a>
</p>
</li>
<li> <p><a href="#method-UCSC_Genome-get_length"><code>UCSC_Genome$get_length()</code></a>
</p>
</li>
<li> <p><a href="#method-UCSC_Genome-get_content"><code>UCSC_Genome$get_content()</code></a>
</p>
</li>
<li> <p><a href="#method-UCSC_Genome-clone"><code>UCSC_Genome$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-UCSC_Genome-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Genome class
</p>


<h5>Usage</h5>

<div class="r"><pre>UCSC_Genome$new(genome.name, root.path, mask, load.limit)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genome.name</code></dt><dd><p>A genome name. UCSC genome is included with kmeRtone.</p>
</dd>
<dt><code>root.path</code></dt><dd><p>Path to a directory of user-provided genome FASTA files or
the destination to save the NCBI/UCSC downloaded reference genome files.</p>
</dd>
<dt><code>mask</code></dt><dd><p>Genome mask status: &quot;hard&quot;, &quot;soft&quot;, or &quot;none&quot;. Default is
&quot;none&quot;.</p>
</dd>
<dt><code>load.limit</code></dt><dd><p>Maximum chromosome sequences loaded. Default is 1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Genome</code> object.
</p>


<hr>
<a id="method-UCSC_Genome-["></a>



<h4>Method <code>[()</code></h4>

<p>Calling chromosome sequence by loading on demand.
Maximum load is determine by load_limit field.
</p>


<h5>Usage</h5>

<div class="r"><pre>UCSC_Genome$[(chr.names, reload = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chr.names</code></dt><dd><p>Chromosome name. It can be a vector of chromosomes.</p>
</dd>
<dt><code>reload</code></dt><dd><p>Reload the sequence from the root_path.
Default is FALSE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A single or list of sequence of requested chromosome.
</p>


<hr>
<a id="method-UCSC_Genome-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print summary of <code>Genome</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>UCSC_Genome$print()</pre></div>



<h5>Returns</h5>

<p>Message of <code>Genome</code> object summary.
</p>


<hr>
<a id="method-UCSC_Genome-get_length"></a>



<h4>Method <code>get_length()</code></h4>

<p>Get chromosome length from pre-calculated length
</p>


<h5>Usage</h5>

<div class="r"><pre>UCSC_Genome$get_length(chr.names, recalculate = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chr.names</code></dt><dd><p>Chromosome name. It can be a vector of chromosomes.</p>
</dd>
<dt><code>recalculate</code></dt><dd><p>Recalculate the pre-calculated length.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A chromosome-named vector of length value.
</p>


<hr>
<a id="method-UCSC_Genome-get_content"></a>



<h4>Method <code>get_content()</code></h4>

<p>Get pre-calculated sequence content e.g. G+C content
</p>


<h5>Usage</h5>

<div class="r"><pre>UCSC_Genome$get_content(chr.names, seq, recalculate = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chr.names</code></dt><dd><p>Chromosome name. It can be a vector of chromosomes.</p>
</dd>
<dt><code>seq</code></dt><dd><p>Sequence to count. e.g. c(&quot;G&quot;, &quot;C&quot;)</p>
</dd>
<dt><code>recalculate</code></dt><dd><p>Recalculate the pre-calculated length.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A chromosome-named vector of sequence content.
</p>


<hr>
<a id="method-UCSC_Genome-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>UCSC_Genome$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='writeBED'>Write a BED file. Zero-based indexing is enforced.</h2><span id='topic+writeBED'></span>

<h3>Description</h3>

<p>Write a BED file. Zero-based indexing is enforced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeBED(bed, output.filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeBED_+3A_bed">bed</code></td>
<td>
<p>A BED <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="writeBED_+3A_output.filename">output.filename</code></td>
<td>
<p>An output BED filename.</p>
</td></tr>
</table>

<hr>
<h2 id='writeFASTA'>Write FASTA files.</h2><span id='topic+writeFASTA'></span>

<h3>Description</h3>

<p>Write FASTA files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFASTA(seqs, fasta.path, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeFASTA_+3A_seqs">seqs</code></td>
<td>
<p>A vector or list of sequences with header name. If it is a list,
it must only contain one single sequence string for every element e.g.
list(chr1 = &quot;NNNNNNNN&quot;) not list(chr1 = c(&quot;NNNNNN&quot;, &quot;AAAAAA&quot;))</p>
</td></tr>
<tr><td><code id="writeFASTA_+3A_fasta.path">fasta.path</code></td>
<td>
<p>A path to a FASTA file.</p>
</td></tr>
<tr><td><code id="writeFASTA_+3A_append">append</code></td>
<td>
<p>Boolean. Default is FALSE. If TRUE, will append the results to existing file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='writeVCF'>Write VCF file and compress using bgzip.</h2><span id='topic+writeVCF'></span>

<h3>Description</h3>

<p>Require bgzip in PATH
VCF manual is referred from https://samtools.github.io/hts-specs/VCFv4.3.pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeVCF(vcf, output.vcf.gz, append = FALSE, tabix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeVCF_+3A_vcf">vcf</code></td>
<td>
<p>A VCF object.</p>
</td></tr>
<tr><td><code id="writeVCF_+3A_output.vcf.gz">output.vcf.gz</code></td>
<td>
<p>Output filename including vcf.gz extension.</p>
</td></tr>
<tr><td><code id="writeVCF_+3A_append">append</code></td>
<td>
<p>To append or not? Default is FALSE.</p>
</td></tr>
<tr><td><code id="writeVCF_+3A_tabix">tabix</code></td>
<td>
<p>To tabix or not? Default is FALSE.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
