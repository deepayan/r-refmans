<!DOCTYPE html><html><head><title>Help for package bsamGP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bsamGP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blq'><p>Bayesian Quantile Regression</p></a></li>
<li><a href='#blr'><p>Bayesian Linear Regression</p></a></li>
<li><a href='#bsad'><p>Bayesian Semiparametric Density Estimation</p></a></li>
<li><a href='#bsaq'><p>Bayesian Shape-Restricted Spectral Analysis Quantile Regression</p></a></li>
<li><a href='#bsaqdpm'><p>Bayesian Shape-Restricted Spectral Analysis Quantile Regression with Dirichlet Process Mixture Errors</p></a></li>
<li><a href='#bsar'><p>Bayesian Shape-Restricted Spectral Analysis Regression</p></a></li>
<li><a href='#bsarBig'><p>Bayesian Spectral Analysis Regression for Big data</p></a></li>
<li><a href='#bsardpm'><p>Bayesian Shape-Restricted Spectral Analysis Regression with Dirichlet Process Mixture Errors</p></a></li>
<li><a href='#cadmium'>
<p>Cadmium dose-response meta data</p></a></li>
<li><a href='#Elec.demand'><p>Electricity demand data</p></a></li>
<li><a href='#fitted.blm'><p> Compute fitted values for a blm object</p></a></li>
<li><a href='#fitted.bsad'><p> Compute fitted values for a bsad object</p></a></li>
<li><a href='#fitted.bsam'><p> Compute fitted values for a bsam object</p></a></li>
<li><a href='#fitted.bsamdpm'><p> Compute fitted values for a bsamdpm object</p></a></li>
<li><a href='#fs'><p>Specify a Fourier Basis Fit in a BSAM Formula</p></a></li>
<li><a href='#gblr'><p>Generalized Bayesian Linear Models</p></a></li>
<li><a href='#gbsar'><p>Bayesian Shape-Restricted Spectral Analysis for Generalized Partial Linear Models</p></a></li>
<li><a href='#intgrat'>
<p>Numerical integration using a simple Trapezoidal rule</p></a></li>
<li><a href='#intsim'><p>Numerical integration using Simpson's rule</p></a></li>
<li><a href='#London.Mortality'><p>Daily Moratlity in London</p></a></li>
<li><a href='#plasma'><p>A Data Set for Plasma Levels of Retinol and Beta-Carotene</p></a></li>
<li><a href='#plot.blm'><p> Plot a blm object</p></a></li>
<li><a href='#plot.bsad'><p> Plot a bsad object</p></a></li>
<li><a href='#plot.bsam'><p> Plot a bsam object</p></a></li>
<li><a href='#plot.bsamdpm'><p> Plot a bsamdpm object</p></a></li>
<li><a href='#plot.fitted.bsad'><p>Plot a fitted.bsad object</p></a></li>
<li><a href='#plot.fitted.bsam'><p> Plot a fitted.bsam object</p></a></li>
<li><a href='#plot.fitted.bsamdpm'><p> Plot a fitted.bsamdpm object</p></a></li>
<li><a href='#predict.blm'><p> Predict method for a blm object</p></a></li>
<li><a href='#predict.bsam'><p>Predict method for a bsam object</p></a></li>
<li><a href='#predict.bsamdpm'><p>Predict method for a bsamdpm object</p></a></li>
<li><a href='#rald'><p>The asymmetric Laplace distribution</p></a></li>
<li><a href='#traffic'><p>Monthly traffic accidents data</p></a></li>
<li><a href='#wage.union'><p>Wage-Union data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Spectral Analysis Models using Gaussian Process Priors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Seongil Jo [aut, cre], 
    Taeryon Choi [aut], 
    Beomjo Park [aut, cre],
    Peter J. Lenk [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Beomjo Park &lt;beomjop@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, ggplot2, gridExtra</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions to perform Bayesian inference
    using a spectral analysis of Gaussian process priors.
    Gaussian processes are represented with a Fourier series 
    based on cosine basis functions. Currently the package
    includes parametric linear models, partial linear additive
    models with/without shape restrictions, generalized linear
    additive models with/without shape restrictions, and  
    density estimation model. To maximize computational 
    efficiency, the actual Markov chain Monte Carlo sampling 
    for each model is done using codes written in FORTRAN 90.
    This software has been developed using funding supported by
    Basic Science Research Program through the National Research
    Foundation of Korea (NRF) funded by the Ministry of Education
    (no. NRF-2016R1D1A1B03932178 and no. NRF-2017R1D1A3B03035235).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://statlab2.korea.ac.kr/software/bsamgp">http://statlab2.korea.ac.kr/software/bsamgp</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 05:07:37 UTC; beomjo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-18 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='blq'>Bayesian Quantile Regression</h2><span id='topic+blq'></span>

<h3>Description</h3>

<p>This function fits a Bayesian quantile regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blq(formula, data = NULL, p, mcmc = list(), prior = list(), marginal.likelihood = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blq_+3A_formula">formula</code></td>
<td>
<p>		an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo; </p>
</td></tr>
<tr><td><code id="blq_+3A_data">data</code></td>
<td>
<p>	    an optional data frame.</p>
</td></tr>
<tr><td><code id="blq_+3A_p">p</code></td>
<td>
<p>			quantile of interest (default=0.5). </p>
</td></tr>
<tr><td><code id="blq_+3A_mcmc">mcmc</code></td>
<td>
<p>			a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>nblow (1000)</code> giving the number of MCMC in transition period,
<code>nskip (1)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis. </p>
</td></tr>
<tr><td><code id="blq_+3A_prior">prior</code></td>
<td>
<p>			a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>beta_m0</code> and <code>beta_v0</code> giving the hyperparameters of the
multivariate normal distribution for parametric part including intercept,
<code>sigma2_m0</code> and <code>sigma2_v0</code> giving the prior mean and variance
of the inverse gamma prior for the scale parameter of response. </p>
</td></tr>
<tr><td><code id="blq_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>	a logical variable indicating whether the log marginal likelihood is calculated.
The methods of Gelfand and Dey (1994) is used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a Bayesian quantile regression model.
</p>
<p>Let <code class="reqn">y_i</code> and <code class="reqn">w_i</code> be the response and the vector of parametric predictors, respectively.
Further, let <code class="reqn">x_{i,k}</code> be the covariate related to the response, linearly.
The model is as follows.
</p>
<p style="text-align: center;"><code class="reqn">y_i = w_i^T\beta + \epsilon_i, ~ i=1,\ldots,n, </code>
</p>

<p>where the error terms <code class="reqn">\{\epsilon_i\}</code> are a random sample from an asymmetric Laplace distribution, <code class="reqn">ALD_p(0,\sigma^2)</code>,
which has the following probability density function:
</p>
<p style="text-align: center;"><code class="reqn">ALD_p(\epsilon; \mu, \sigma^2) = \frac{p(1-p)}{\sigma^2}\exp\Big(-\frac{(x-\mu)[p - I(x \le \mu)]}{\sigma^2}\Big),</code>
</p>

<p>where <code class="reqn">0 &lt; p &lt; 1</code> is the skew parameter, <code class="reqn">\sigma^2 &gt; 0</code> is the scale parameter, <code class="reqn">-\infty &lt; \mu &lt; \infty</code> is
the location parameter, and <code class="reqn">I(\cdot)</code> is the indication function.
</p>
<p>The conjugate priors are assumed for <code class="reqn">\beta</code> and <code class="reqn">\sigma</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta | \sigma \sim N(m_{0,\beta}, \sigma^2V_{0,\beta}), \quad \sigma^2 \sim IG\Big(\frac{r_{0,\sigma}}{2}, \frac{s_{0,\sigma}}{2}\Big)</code>
</p>



<h3>Value</h3>

<p>An object of class <code>blm</code> representing the Bayesian parametric linear model fit.
Generic functions such as <code>print</code> and <code>fitted</code> have methods to show the results of the fit.
</p>
<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code>,
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>, and
the MCMC samples for the log marginal likelihood are saved in the list <code>loglik.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>lmarg</code></td>
<td>
<p>		log marginal likelihood using Gelfand-Dey method. </p>
</td></tr>
<tr><td><code>rsquarey</code></td>
<td>
<p> 	correlation between <code class="reqn">y</code> and <code class="reqn">\hat{y}</code>. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>     running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Gelfand, A. E. and Dey, K. K. (1994) Bayesian model choice: asymptotics and exact calculations.
<em>Journal of the Royal Statistical Society. Series B - Statistical Methodology</em>, <b>56</b>, 501-514.
</p>
<p>Kozumi, H. and Kobayashi, G. (2011) Gibbs sampling methods for Bayesian quantile regression.
<em>Journal of Statistical Computation and Simulation</em>, <b>81</b>(11), 1565-1578.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blr">blr</a></code>, <code><a href="#topic+gblr">gblr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
# Simulated example #
#####################

# Simulate data
set.seed(1)

n &lt;- 100
w &lt;- runif(n)
y &lt;- 3 + 2*w + rald(n, scale = 0.8, p = 0.5)

# Fit median regression
fout &lt;- blq(y ~ w, p = 0.5)

# Summary
print(fout); summary(fout)

# fitted values
fit &lt;- fitted(fout)

# Plots
plot(fout)
</code></pre>

<hr>
<h2 id='blr'>Bayesian Linear Regression</h2><span id='topic+blr'></span>

<h3>Description</h3>

<p>This function fits a Bayesian linear regression model using scale invariant prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blr(formula, data = NULL, mcmc = list(), prior = list(), marginal.likelihood = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blr_+3A_formula">formula</code></td>
<td>
<p>		an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo; </p>
</td></tr>
<tr><td><code id="blr_+3A_data">data</code></td>
<td>
<p>	    an optional data frame.</p>
</td></tr>
<tr><td><code id="blr_+3A_mcmc">mcmc</code></td>
<td>
<p>			a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>nblow (1000)</code> giving the number of MCMC in transition period,
<code>nskip (1)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis. </p>
</td></tr>
<tr><td><code id="blr_+3A_prior">prior</code></td>
<td>
<p>			a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>beta_m0</code> and <code>beta_v0</code> giving the hyperparameters of the
multivariate normal distribution for parametric part including intercept,
<code>sigma2_m0</code> and <code>sigma2_v0</code> giving the prior mean and variance
of the inverse gamma prior for the scale parameter of response.</p>
</td></tr>
<tr><td><code id="blr_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>	a logical variable indicating whether the log marginal likelihood is calculated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a Bayesian linear regression model using scale invariant prior.
</p>
<p>Let <code class="reqn">y_i</code> and <code class="reqn">w_i</code> be the response and the vector of parametric predictors, respectively.
The model for regression function is as follows.
</p>
<p style="text-align: center;"><code class="reqn">y_i = w_i^T\beta + \epsilon_i, ~ i=1,\ldots,n, </code>
</p>

<p>where the error terms <code class="reqn">\{\epsilon_i\}</code> are a random sample from a normal distribution, <code class="reqn">N(0,\sigma^2)</code>.
</p>
<p>The conjugate priors are assumed for <code class="reqn">\beta</code> and <code class="reqn">\sigma</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta | \sigma \sim N(m_{0,\beta}, \sigma^2V_{0,\beta}), \quad \sigma^2 \sim IG\Big(\frac{r_{0,\sigma}}{2}, \frac{s_{0,\sigma}}{2}\Big)</code>
</p>



<h3>Value</h3>

<p>An object of class <code>blm</code> representing the Bayesian spectral analysis model fit.
Generic functions such as <code>print</code> and <code>fitted</code> have methods to show the results of the fit.
</p>
<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code> and
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>lmarg</code></td>
<td>
<p>		log marginal likelihood. </p>
</td></tr>
<tr><td><code>rsquarey</code></td>
<td>
<p> 	correlation between <code class="reqn">y</code> and <code class="reqn">\hat{y}</code>. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>      running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+blq">blq</a></code>, <code><a href="#topic+gblr">gblr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
# Simulated example #
#####################

# Simulate data
set.seed(1)

n &lt;- 100
w &lt;- runif(n)
y &lt;- 3 + 2*w + rnorm(n, sd = 0.8)

# Fit the model with default priors and mcmc parameters
fout &lt;- blr(y ~ w)

# Summary
print(fout); summary(fout)

# Fitted values
fit &lt;- fitted(fout)

# Plots
plot(fout)
</code></pre>

<hr>
<h2 id='bsad'>Bayesian Semiparametric Density Estimation</h2><span id='topic+bsad'></span>

<h3>Description</h3>

<p>This function fits a semiparametric model, which consists of parametric and
nonparametric components, for estimating density using a logistic Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
bsad(x, xmin, xmax, nint, MaxNCos, mcmc = list(), prior = list(),
smoother = c('geometric', 'algebraic'),
parametric = c('none', 'normal', 'gamma', 'laplace'), marginal.likelihood = TRUE,
verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsad_+3A_x">x</code></td>
<td>
<p>			a vector giving the data from which the density estimate is to be computed.</p>
</td></tr>
<tr><td><code id="bsad_+3A_xmin">xmin</code></td>
<td>
<p>			minimum value of x. </p>
</td></tr>
<tr><td><code id="bsad_+3A_xmax">xmax</code></td>
<td>
<p>			maximum value of x. </p>
</td></tr>
<tr><td><code id="bsad_+3A_nint">nint</code></td>
<td>
<p>			number of grid points for plots (need to be odd).
The default is 201.</p>
</td></tr>
<tr><td><code id="bsad_+3A_maxncos">MaxNCos</code></td>
<td>
<p>		maximum number of Fourier coefficients. </p>
</td></tr>
<tr><td><code id="bsad_+3A_mcmc">mcmc</code></td>
<td>
<p>			a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>kappaloop (5)</code> giving the number of MCMC loops within each choice of kappa,
<code>nblow (10000)</code> giving the number of MCMC in transition period,
<code>nskip (10)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis, and
<code>ndisp (1000)</code> giving the number of saved draws to be displayed on screen
(the function reports on the screen when every
<code>ndisp</code> iterations have been carried out). </p>
</td></tr>
<tr><td><code id="bsad_+3A_prior">prior</code></td>
<td>
<p>			a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>gmax</code> giving maximum value for gamma (default = 5),
<code>PriorProbs</code> giving prior probability of parametric and semiparametric models,
<code>beta_m0</code> and <code>beta_v0</code> giving the hyperparameters
for prior distribution of the parametric coefficients,
<code>r0</code> and <code>s0</code> giving the hyperparameters of <code class="reqn">\sigma^2</code> for the logits,
<code>u0</code> and <code>v0</code> giving the hyperparameters of <code class="reqn">\tau^2</code> for Fourier coefficients,
<code>PriorKappa</code> and <code>KappaGrid</code> giving prior on the number of cosine terms.</p>
</td></tr>
<tr><td><code id="bsad_+3A_smoother">smoother</code></td>
<td>
<p>		types of smoothing priors for Fourier coefficients. See Details.</p>
</td></tr>
<tr><td><code id="bsad_+3A_parametric">parametric</code></td>
<td>
<p>		specifying a distribution of the parametric part to be test.</p>
</td></tr>
<tr><td><code id="bsad_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>	  a logical variable indicating whether the log marginal likelihood is calculated.</p>
</td></tr>
<tr><td><code id="bsad_+3A_verbose">verbose</code></td>
<td>
<p>   a logical variable. If <code>TRUE</code>, the iteration number and the Metropolis acceptance rate are printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a semiparametric model, which consists of parametric and nonparametric, for density estimation (Lenk, 2003):
</p>
<p style="text-align: center;"><code class="reqn">f(x | \beta, Z) = \frac{\exp[h(x)^\top\beta + Z(x)]}{\int_\mathcal{X} \exp[h(y)^\top\beta + Z(y)]dG(y)}</code>
</p>

<p>where <code class="reqn">Z</code> is a zero mean, second-order Gaussian process with bounded, continuous covariance function. i.e.,
</p>
<p style="text-align: center;"><code class="reqn">E[Z(x), Z(y)] = \sigma(x,y), \quad \int_\mathcal{X}ZdG = 0 ~~(a.s.)</code>
</p>

<p>Using the Karhunen-Loeve Expansion, <code class="reqn">Z</code> is represented as infinite series with random coefficients
</p>
<p style="text-align: center;"><code class="reqn">Z(x) = \sum_{j=1}^\infty \theta_j\varphi_j(x), </code>
</p>

<p>where <code class="reqn">\{\varphi_j\}</code> is the cosine basis, <code class="reqn">\varphi_j(x)=\sqrt{2}\cos[j\pi G(x)]</code>.
</p>
<p>For the random Fourier coefficients of the expansion, two smoother priors are assumed (optional),
</p>
<p style="text-align: center;"><code class="reqn">\theta_j | \tau, \gamma \sim N(0, \tau^2\exp[-j\gamma]), ~ j \ge 1 ~ (geometric ~smoother)</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_j | \tau, \gamma \sim N(0, \tau^2\exp[-ln(j+1)\gamma]), ~ j \ge 1 ~ (algebraic ~smoother)</code>
</p>

<p>The coefficient <code class="reqn">\beta</code> have the popular normal prior,
</p>
<p style="text-align: center;"><code class="reqn">\beta | m_{0,\beta}, V_{0,\beta} \sim N(m_{0,\beta}, V_{0,\beta})</code>
</p>

<p>To complete the model specification, independent hyper priors are assumed,
</p>
<p style="text-align: center;"><code class="reqn">\tau^2 | r_0, s_0 \sim IGa(r_0/2, s_0/2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma | w_0 \sim Exp(w_0)</code>
</p>

<p>Note that the posterior algorithm is based on computing a discrete version of the likelihood over a fine mesh on <code class="reqn">\mathcal{X}</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>bsad</code> representing the Bayesian spectral analysis density estimation model fit.
Generic functions such as <code>print</code>, <code>fitted</code> and <code>plot</code> have methods to show the results of the fit.
</p>
<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code>,
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>, and
the MCMC samples for the log marginal likelihood are saved in the list <code>loglik.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>lmarg</code></td>
<td>
<p>		log marginal likelihood. </p>
</td></tr>
<tr><td><code>ProbProbs</code></td>
<td>
<p>	posterior probability of models. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>     running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Jo, S., Choi, T., Park, B. and Lenk, P. (2019). bsamGP: An R Package for Bayesian Spectral Analysis Models
Using Gaussian Process Priors. <em>Journal of Statistical Software</em>, <b>90</b>, 310-320.
</p>
<p>Lenk, P. (2003) Bayesian semiparametric density estimation and model verification
using a logistic Gaussian process. <em>Journal of Computational and Graphical Statistics</em>, <b>12</b>, 548-565.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
############################
# Old Faithful geyser data #
############################
data(faithful)
attach(faithful)

# mcmc parameters
mcmc &lt;- list(nblow = 10000,
	           smcmc = 1000,
	           nskip = 10,
	           ndisp = 1000,
	           kappaloop = 5)

# fits BSAD model
fout &lt;- bsad(x = eruptions, xmin = 0, xmax = 8, nint = 501, mcmc = mcmc,
             smoother = 'geometric', parametric = 'gamma')

# Summary
print(fout); summary(fout)

# fitted values
fit &lt;- fitted(fout)

# predictive density plot
plot(fit, ask = TRUE)

detach(faithful)

## End(Not run)
</code></pre>

<hr>
<h2 id='bsaq'>Bayesian Shape-Restricted Spectral Analysis Quantile Regression</h2><span id='topic+bsaq'></span>

<h3>Description</h3>

<p>This function fits a Bayesian semiparametric quantile regression model
to estimate shape-restricted functions
using a spectral analysis of Gaussian process priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
bsaq(formula, xmin, xmax, p, nbasis, nint, mcmc = list(), prior = list(),
shape = c('Free', 'Increasing', 'Decreasing', 'IncreasingConvex', 'DecreasingConcave',
'IncreasingConcave', 'DecreasingConvex', 'IncreasingS', 'DecreasingS',
'IncreasingRotatedS','DecreasingRotatedS','InvertedU','Ushape',
'IncMultExtreme','DecMultExtreme'), nExtreme = NULL,
marginal.likelihood = TRUE, spm.adequacy = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsaq_+3A_formula">formula</code></td>
<td>
<p>		an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo; </p>
</td></tr>
<tr><td><code id="bsaq_+3A_xmin">xmin</code></td>
<td>
<p>		a vector or scalar giving user-specific minimum values of x.
The default values are minimum values of x.</p>
</td></tr>
<tr><td><code id="bsaq_+3A_xmax">xmax</code></td>
<td>
<p>		a vector or scalar giving user-specific maximum values of x.
The default values are maximum values of x.</p>
</td></tr>
<tr><td><code id="bsaq_+3A_p">p</code></td>
<td>
<p>			quantile of interest (default=0.5). </p>
</td></tr>
<tr><td><code id="bsaq_+3A_nbasis">nbasis</code></td>
<td>
<p>		number of cosine basis functions. </p>
</td></tr>
<tr><td><code id="bsaq_+3A_nint">nint</code></td>
<td>
<p>			number of grid points where the unknown function is evaluated for plotting.
The default is 200.</p>
</td></tr>
<tr><td><code id="bsaq_+3A_mcmc">mcmc</code></td>
<td>
<p>			a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>nblow0 (1000)</code> giving the number of initialization period for adaptive metropolis,
<code>maxmodmet (5)</code> giving the maximum number of times to modify metropolis,
<code>nblow (10000)</code> giving the number of MCMC in transition period,
<code>nskip (10)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis, and
<code>ndisp (1000)</code> giving the number of saved draws to be displayed on screen
(the function reports on the screen when every
<code>ndisp</code> iterations have been carried out). </p>
</td></tr>
<tr><td><code id="bsaq_+3A_prior">prior</code></td>
<td>
<p>			a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>iflagprior</code> choosing a smoothing prior for spectral coefficients
(iflagprior=0 assigns T-Smoother prior (default), iflagprior=1 chooses Lasso-Smoother prior),
<code>theta0_m0</code> and <code>theta0_s0</code> giving the hyperparameters
for prior distribution of the spectral coefficients
(<code>theta0_m0</code> and <code>theta0_s0</code> are used when the functions have shape-restriction),
<code>tau2_m0</code>, <code>tau2_s0</code> and <code>w0</code> giving the prior mean and standard deviation of
smoothing prior (When iflagprior=1, tau2_m0 is only used as the hyperparameter),
<code>beta_m0</code> and <code>beta_v0</code> giving the hyperparameters of the
multivariate normal distribution for parametric part including intercept,
<code>sigma2_m0</code> and <code>sigma2_v0</code> giving the prior mean and variance
of the inverse gamma prior for the scale parameter of response,
<code>alpha_m0</code> and <code>alpha_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the constant of integration,
<code>iflagpsi</code> determining the prior of slope for logisitic function in <code>S</code> or <code>U</code> shaped
(iflagpsi=1 (default), slope <code class="reqn">\psi</code> is sampled and iflagpsi=0, <code class="reqn">\psi</code> is fixed),
<code>psifixed</code> giving initial value (iflagpsi=1) or fixed value (iflagpsi=0) of slope,
<code>omega_m0</code> and <code>omega_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the inflection point of <code>S</code> or <code>U</code> shaped function.</p>
</td></tr>
<tr><td><code id="bsaq_+3A_shape">shape</code></td>
<td>
<p>			a vector giving types of shape restriction. </p>
</td></tr>
<tr><td><code id="bsaq_+3A_nextreme">nExtreme</code></td>
<td>
<p>  a vector of extreme points for 'IncMultExtreme', 'DecMultExtreme' shape restrictions.</p>
</td></tr>
<tr><td><code id="bsaq_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>	a logical variable indicating whether the log marginal likelihood is calculated.
The methods of Gelfand and Dey (1994) and Newton and Raftery (1994) are used. </p>
</td></tr>
<tr><td><code id="bsaq_+3A_spm.adequacy">spm.adequacy</code></td>
<td>
<p>		a logical variable indicating whether the log marginal likelihood of linear model is calculated.
The marginal likelihood gives the values of the linear regression model excluding the nonlinear parts.</p>
</td></tr>
<tr><td><code id="bsaq_+3A_verbose">verbose</code></td>
<td>
<p>   a logical variable. If <code>TRUE</code>, the iteration number and the Metropolis acceptance rate are printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a Bayesian spectral analysis quantile regression model
for estimating shape-restricted functions using Gaussian process priors.
For enforcing shape-restrictions, the model assumed that the derivatives of the functions are squares of Gaussian processes.
</p>
<p>Let <code class="reqn">y_i</code> and <code class="reqn">w_i</code> be the response and the vector of parametric predictors, respectively.
Further, let <code class="reqn">x_{i,k}</code> be the covariate related to the response through an unknown shape-restricted function.
The model for estimating shape-restricted functions is as follows.
</p>
<p style="text-align: center;"><code class="reqn">y_i = w_i^T\beta + \sum_{k=1}^K f_k(x_{i,k}) + \epsilon_i, ~ i=1,\ldots,n, </code>
</p>

<p>where <code class="reqn">f_k</code> is an unknown shape-restricted function of the scalar <code class="reqn">x_{i,k} \in [0,1]</code> and
the error terms <code class="reqn">\{\epsilon_i\}</code> are a random sample from an asymmetric Laplace distribution, <code class="reqn">ALD_p(0,\sigma^2)</code>,
which has the following probability density function:
</p>
<p style="text-align: center;"><code class="reqn">ALD_p(\epsilon; \mu, \sigma^2) = \frac{p(1-p)}{\sigma^2}\exp\Big(-\frac{(x-\mu)[p - I(x \le \mu)]}{\sigma^2}\Big),</code>
</p>

<p>where <code class="reqn">0 &lt; p &lt; 1</code> is the skew parameter, <code class="reqn">\sigma^2 &gt; 0</code> is the scale parameter, <code class="reqn">-\infty &lt; \mu &lt; \infty</code> is
the location parameter, and <code class="reqn">I(\cdot)</code> is the indication function.
</p>
<p>The prior of function without shape restriction is:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = Z(x), </code>
</p>

<p>where <code class="reqn">Z</code> is a second-order Gaussian process with mean function equal to zero and covariance function
<code class="reqn">\nu(s,t) = E[Z(s)Z(t)]</code> for <code class="reqn">s, t \in [0, 1]</code>. The Gaussian process is expressed with
the spectral representation based on cosine basis functions:
</p>
<p style="text-align: center;"><code class="reqn">Z(x) = \sum_{j=0}^\infty \theta_j\varphi_j(x)</code>
</p>

<p style="text-align: center;"><code class="reqn">\varphi_0(x) = 1 ~~ \code{and} ~~ \varphi_j(x) = \sqrt{2}\cos(\pi j x), ~ j \ge 1, ~ 0 \le x \le 1</code>
</p>

<p>The shape-restricted functions are modeled by assuming the <code class="reqn">q</code>th derivatives of <code class="reqn">f</code> are squares of Gaussian processes:
</p>
<p style="text-align: center;"><code class="reqn">f^{(q)}(x) = \delta Z^2(x)h(x), ~~ \delta \in \{1, -1\}, ~~ q \in \{1, 2\},</code>
</p>

<p>where <code class="reqn">h</code> is the squish function. For monotonic, monotonic convex, and concave functions, <code class="reqn">h(x)=1</code>, while
for <code>S</code> and <code>U</code> shaped functions, <code class="reqn">h</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">h(x) = \frac{1 - \exp[\psi(x - \omega)]}{1 + \exp[\psi(x - \omega)]}, ~~ \psi &gt; 0, ~~ 0 &lt; \omega &lt; 1</code>
</p>

<p>For the spectral coefficients of functions without shape constraints, the scale-invariant prior is used
(The intercept is included in <code class="reqn">\beta</code>):
</p>
<p style="text-align: center;"><code class="reqn">\theta_j | \sigma, \tau, \gamma \sim N(0, \sigma^2\tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>The priors for the spectral coefficients of shape restricted functions are:
</p>
<p style="text-align: center;"><code class="reqn">\theta_0 | \sigma \sim N(m_{\theta_0}, \sigma v^2_{\theta_0}), \quad
	\theta_j | \sigma, \tau, \gamma \sim N(m_{\theta_j}, \sigma\tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>To complete the model specification, the conjugate priors are assumed for <code class="reqn">\beta</code> and <code class="reqn">\sigma</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta | \sigma \sim N(m_{0,\beta}, \sigma^2V_{0,\beta}), \quad \sigma^2 \sim IG\left(\frac{r_{0,\sigma}}{2}, \frac{s_{0,\sigma}}{2}\right)</code>
</p>



<h3>Value</h3>

<p>An object of class <code>bsam</code> representing the Bayesian spectral analysis model fit.
Generic functions such as <code>print</code>, <code>fitted</code> and <code>plot</code> have methods to show the results of the fit.
</p>
<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code>,
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>, and
the MCMC samples for the log marginal likelihood are saved in the list <code>loglik.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>lmarg.lm</code></td>
<td>
<p>	log marginal likelihood for linear quantile regression model. </p>
</td></tr>
<tr><td><code>lmarg.gd</code></td>
<td>
<p>	log marginal likelihood using Gelfand-Dey method. </p>
</td></tr>
<tr><td><code>lmarg.nr</code></td>
<td>
<p>	log marginal likelihood using Netwon-Raftery method, which is biased. </p>
</td></tr>
<tr><td><code>rsquarey</code></td>
<td>
<p> 	correlation between <code class="reqn">y</code> and <code class="reqn">\hat{y}</code>. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>     running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Jo, S., Choi, T., Park, B. and Lenk, P. (2019). bsamGP: An R Package for Bayesian Spectral Analysis Models
Using Gaussian Process Priors. <em>Journal of Statistical Software</em>, <b>90</b>, 310-320.
</p>
<p>Lenk, P. and Choi, T. (2017) Bayesian Analysis of Shape-Restricted Functions using
Gaussian Process Priors. <em>Statistica Sinica</em>, <b>27</b>: 43-69.
</p>
<p>Gelfand, A. E. and Dey, K. K. (1994) Bayesian model choice: asymptotics and exact calculations.
<em>Journal of the Royal Statistical Society. Series B - Statistical Methodology</em>, <b>56</b>, 501-514.
</p>
<p>Kozumi, H. and Kobayashi, G. (2011) Gibbs sampling methods for Bayesian quantile regression.
<em>Journal of Statistical Computation and Simulation</em>, <b>81</b>(11), 1565-1578.
</p>
<p>Newton, M. A. and Raftery, A. E. (1994) Approximate Bayesian inference with the weighted likelihood bootstrap (with discussion).
<em>Journal of the Royal Statistical Society. Series B - Statistical Methodology</em>, <b>56</b>, 3-48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsar">bsar</a></code>, <code><a href="#topic+gbsar">gbsar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
######################
# Increasing-concave #
######################

# Simulate data
set.seed(1)

n &lt;- 200
x &lt;- runif(n)
y &lt;- log(1 + 10*x) + rald(n, scale = 0.5, p = 0.5)

# Number of cosine basis functions
nbasis &lt;- 50

# Fit the model with default priors and mcmc parameters
fout1 &lt;- bsaq(y ~ fs(x), p = 0.25, nbasis = nbasis,
              shape = 'IncreasingConcave')
fout2 &lt;- bsaq(y ~ fs(x), p = 0.5, nbasis = nbasis,
              shape = 'IncreasingConcave')
fout3 &lt;- bsaq(y ~ fs(x), p = 0.75, nbasis = nbasis,
              shape = 'IncreasingConcave')

# fitted values
fit1 &lt;- fitted(fout1)
fit2 &lt;- fitted(fout2)
fit3 &lt;- fitted(fout3)

# plots
plot(x, y, lwd = 2, xlab = 'x', ylab = 'y')
lines(fit1$xgrid, fit1$wbeta$mean[1] + fit1$fxgrid$mean, lwd=2, col=2)
lines(fit2$xgrid, fit2$wbeta$mean[1] + fit2$fxgrid$mean, lwd=2, col=3)
lines(fit3$xgrid, fit3$wbeta$mean[1] + fit3$fxgrid$mean, lwd=2, col=4)
legend('topleft', legend = c('1st Quartile', '2nd Quartile', '3rd Quartile'),
       lwd = 2, col = 2:4, lty = 1)


## End(Not run)
</code></pre>

<hr>
<h2 id='bsaqdpm'>Bayesian Shape-Restricted Spectral Analysis Quantile Regression with Dirichlet Process Mixture Errors</h2><span id='topic+bsaqdpm'></span>

<h3>Description</h3>

<p>This function fits a Bayesian semiparametric quantile regression model
to estimate shape-restricted functions
using a spectral analysis of Gaussian process priors.
The model assumes that the errors follow a Dirichlet process mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
bsaqdpm(formula, xmin, xmax, p, nbasis, nint,
mcmc = list(), prior = list(), egrid, ngrid = 500,
shape = c('Free', 'Increasing', 'Decreasing', 'IncreasingConvex', 'DecreasingConcave',
'IncreasingConcave', 'DecreasingConvex', 'IncreasingS', 'DecreasingS',
'IncreasingRotatedS', 'DecreasingRotatedS', 'InvertedU', 'Ushape'),
verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsaqdpm_+3A_formula">formula</code></td>
<td>
<p>		an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo; </p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_xmin">xmin</code></td>
<td>
<p>		a vector or scalar giving user-specific minimum values of x.
The default values are minimum values of x.</p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_xmax">xmax</code></td>
<td>
<p>		a vector or scalar giving user-specific maximum values of x.
The default values are maximum values of x.</p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_p">p</code></td>
<td>
<p>			quantile of interest (default=0.5). </p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_nbasis">nbasis</code></td>
<td>
<p>		number of cosine basis functions. </p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_nint">nint</code></td>
<td>
<p>			number of grid points where the unknown function is evaluated for plotting.
The default is 200.</p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_mcmc">mcmc</code></td>
<td>
<p>			a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>nblow0 (1000)</code> giving the number of initialization period for adaptive metropolis,
<code>maxmodmet (5)</code> giving the maximum number of times to modify metropolis,
<code>nblow (10000)</code> giving the number of MCMC in transition period,
<code>nskip (10)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis, and
<code>ndisp (1000)</code> giving the number of saved draws to be displayed on screen
(the function reports on the screen when every
<code>ndisp</code> iterations have been carried out). </p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_prior">prior</code></td>
<td>
<p>			a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>iflagprior</code> choosing a smoothing prior for spectral coefficients
(iflagprior=0 assigns T-Smoother prior (default), iflagprior=1 chooses Lasso-Smoother prior),
<code>theta0_m0</code> and <code>theta0_s0</code> giving the hyperparameters
for prior distribution of the spectral coefficients
(<code>theta0_m0</code> and <code>theta0_s0</code> are used when the functions have shape-restriction),
<code>tau2_m0</code>, <code>tau2_s0</code> and <code>w0</code> giving the prior mean and standard deviation of
smoothing prior (When iflagprior=1, tau2_m0 is only used as the hyperparameter),
<code>beta_m0</code> and <code>beta_v0</code> giving the hyperparameters of the
multivariate normal distribution for parametric part including intercept,
<code>sigma2_m0</code> and <code>sigma2_v0</code> giving the prior mean and variance
of the inverse gamma prior for the scale parameter of response,
<code>alpha_m0</code> and <code>alpha_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the constant of integration,
<code>iflagpsi</code> determining the prior of slope for logisitic function in <code>S</code> or <code>U</code> shaped
(iflagpsi=1 (default), slope <code class="reqn">\psi</code> is sampled and iflagpsi=0, <code class="reqn">\psi</code> is fixed),
<code>psifixed</code> giving initial value (iflagpsi=1) or fixed value (iflagpsi=0) of slope,
<code>omega_m0</code> and <code>omega_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the inflection point of <code>S</code> or <code>U</code> shaped function.</p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_egrid">egrid</code></td>
<td>
<p>			a vector giving grid points where the residual density estimate is evaluated.
The default range is from -10 to 10.</p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_ngrid">ngrid</code></td>
<td>
<p>			a vector giving number of grid points where the residual density estimate is evaluated.
The default value is 500.</p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_shape">shape</code></td>
<td>
<p>			a vector giving types of shape restriction. </p>
</td></tr>
<tr><td><code id="bsaqdpm_+3A_verbose">verbose</code></td>
<td>
<p>   a logical variable. If <code>TRUE</code>, the iteration number and the Metropolis acceptance rate are printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a Bayesian spectral analysis quantile regression model
for estimating shape-restricted functions using Gaussian process priors.
For enforcing shape-restrictions, the model assumes that the derivatives of the functions are squares of Gaussian processes.
The model also assumes that the errors follow a Dirichlet process mixture model.
</p>
<p>Let <code class="reqn">y_i</code> and <code class="reqn">w_i</code> be the response and the vector of parametric predictors, respectively.
Further, let <code class="reqn">x_{i,k}</code> be the covariate related to the response through an unknown shape-restricted function.
The model for estimating shape-restricted functions is as follows.
</p>
<p style="text-align: center;"><code class="reqn">y_i = w_i^T\beta + \sum_{k=1}^K f_k(x_{i,k}) + \epsilon_i, ~ i=1,\ldots,n, </code>
</p>

<p>where <code class="reqn">f_k</code> is an unknown shape-restricted function of the scalar <code class="reqn">x_{i,k} \in [0,1]</code> and
the error terms <code class="reqn">\{\epsilon_i\}</code> are a random sample from a Dirichlet process mixture of an asymmetric Laplace distribution,
<code class="reqn">ALD_p(0,\sigma^2)</code>, which has the following probability density function:
</p>
<p style="text-align: center;"><code class="reqn">\epsilon_i \sim f(\epsilon) = \int ALD_p(\epsilon; 0,\sigma^2)dG(\sigma^2), </code>
</p>

<p style="text-align: center;"><code class="reqn">G \sim DP(M,G0), ~~ G0 = Ga\left(\sigma^{-2}; \frac{r_{0,\sigma}}{2},\frac{s_{0,\sigma}}{2}\right).</code>
</p>

<p>The prior of function without shape restriction is:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = Z(x), </code>
</p>

<p>where <code class="reqn">Z</code> is a second-order Gaussian process with mean function equal to zero and covariance function
<code class="reqn">\nu(s,t) = E[Z(s)Z(t)]</code> for <code class="reqn">s, t \in [0, 1]</code>. The Gaussian process is expressed with
the spectral representation based on cosine basis functions:
</p>
<p style="text-align: center;"><code class="reqn">Z(x) = \sum_{j=0}^\infty \theta_j\varphi_j(x)</code>
</p>

<p style="text-align: center;"><code class="reqn">\varphi_0(x) = 1 ~~ \code{and} ~~ \varphi_j(x) = \sqrt{2}\cos(\pi j x), ~ j \ge 1, ~ 0 \le x \le 1</code>
</p>

<p>The shape-restricted functions are modeled by assuming the <code class="reqn">q</code>th derivatives of <code class="reqn">f</code> are squares of Gaussian processes:
</p>
<p style="text-align: center;"><code class="reqn">f^{(q)}(x) = \delta Z^2(x)h(x), ~~ \delta \in \{1, -1\}, ~~ q \in \{1, 2\},</code>
</p>

<p>where <code class="reqn">h</code> is the squish function. For monotonic, monotonic convex, and concave functions, <code class="reqn">h(x)=1</code>, while
for <code>S</code> and <code>U</code> shaped functions, <code class="reqn">h</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">h(x) = \frac{1 - \exp[\psi(x - \omega)]}{1 + \exp[\psi(x - \omega)]}, ~~ \psi &gt; 0, ~~ 0 &lt; \omega &lt; 1</code>
</p>

<p>For the spectral coefficients of functions without shape constraints, the scale-invariant prior is used
(The intercept is included in <code class="reqn">\beta</code>):
</p>
<p style="text-align: center;"><code class="reqn">\theta_j | \tau, \gamma \sim N(0, \tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>The priors for the spectral coefficients of shape restricted functions are:
</p>
<p style="text-align: center;"><code class="reqn">\theta_0  \sim N(m_{\theta_0}, v^2_{\theta_0}), \quad
	\theta_j | \tau, \gamma \sim N(m_{\theta_j}, \tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>To complete the model specification, the popular normal prior is assumed for <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta | \sim N(m_{0,\beta}, V_{0,\beta})</code>
</p>



<h3>Value</h3>

<p>An object of class <code>bsam</code> representing the Bayesian spectral analysis model fit.
Generic functions such as <code>print</code>, <code>fitted</code> and <code>plot</code> have methods to show the results of the fit.
</p>
<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code>,
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>, and
the MCMC samples for the log marginal likelihood are saved in the list <code>loglik.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>lpml</code></td>
<td>
<p>		log pseudo marginal likelihood using Mukhopadhyay and Gelfand method. </p>
</td></tr>
<tr><td><code>rsquarey</code></td>
<td>
<p> 	correlation between <code class="reqn">y</code> and <code class="reqn">\hat{y}</code>. </p>
</td></tr>
<tr><td><code>imodmet</code></td>
<td>
<p>	the number of times to modify Metropolis. </p>
</td></tr>
<tr><td><code>pmet</code></td>
<td>
<p>		proportion of <code class="reqn">\theta</code> accepted after burn-in. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>     running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Jo, S., Choi, T., Park, B. and Lenk, P. (2019). bsamGP: An R Package for Bayesian Spectral Analysis Models
Using Gaussian Process Priors. <em>Journal of Statistical Software</em>, <b>90</b>, 310-320.
</p>
<p>Kozumi, H. and Kobayashi, G. (2011) Gibbs sampling methods for Bayesian quantile regression.
<em>Journal of Statistical Computation and Simulation</em>, <b>81</b>(11), 1565-1578.
</p>
<p>Lenk, P. and Choi, T. (2017) Bayesian Analysis of Shape-Restricted Functions using
Gaussian Process Priors. <em>Statistica Sinica</em>, <b>27</b>, 43-69.
</p>
<p>MacEachern, S. N. and MÃ¼ller, P. (1998) Estimating mixture of Dirichlet process models.
<em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 223-238.
</p>
<p>Mukhopadhyay, S. and Gelfand, A. E. (1997) Dirichlet process mixed generalized linear models.
<em>Journal of the American Statistical Association</em>, <b>92</b>, 633-639.
</p>
<p>Neal, R. M. (2000) Markov chain sampling methods for Dirichlet process mixture models.
<em>Journal of Computational and Graphical Statistics</em>, <b>9</b>, 249-265.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsaq">bsaq</a></code>, <code><a href="#topic+bsardpm">bsardpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
######################
# Increasing-concave #
######################

# Simulate data
set.seed(1)

n &lt;- 500
x &lt;- runif(n)
e &lt;- c(rald(n/2, scale = 0.5, p = 0.5),
       rald(n/2, scale = 3, p = 0.5))
y &lt;- log(1 + 10*x) + e

# Number of cosine basis functions
nbasis &lt;- 50

# Fit the model with default priors and mcmc parameters
fout1 &lt;- bsaqdpm(y ~ fs(x), p = 0.25, nbasis = nbasis,
                 shape = 'IncreasingConcave')
fout2 &lt;- bsaqdpm(y ~ fs(x), p = 0.5, nbasis = nbasis,
                 shape = 'IncreasingConcave')
fout3 &lt;- bsaqdpm(y ~ fs(x), p = 0.75, nbasis = nbasis,
                 shape = 'IncreasingConcave')

# fitted values
fit1 &lt;- fitted(fout1)
fit2 &lt;- fitted(fout2)
fit3 &lt;- fitted(fout3)

# plots
plot(x, y, lwd = 2, xlab = 'x', ylab = 'y')
lines(fit1$xgrid, fit1$wbeta$mean[1] + fit1$fxgrid$mean, lwd=2, col=2)
lines(fit2$xgrid, fit2$wbeta$mean[1] + fit2$fxgrid$mean, lwd=2, col=3)
lines(fit3$xgrid, fit3$wbeta$mean[1] + fit3$fxgrid$mean, lwd=2, col=4)
legend('topleft',legend=c('1st Quartile','2nd Quartile','3rd Quartile'),
       lwd=2, col=2:4, lty=1)


## End(Not run)
</code></pre>

<hr>
<h2 id='bsar'>Bayesian Shape-Restricted Spectral Analysis Regression</h2><span id='topic+bsar'></span>

<h3>Description</h3>

<p>This function fits a Bayesian semiparametric regression model
to estimate shape-restricted functions
using a spectral analysis of Gaussian process priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
bsar(formula, xmin, xmax, nbasis, nint, mcmc = list(), prior = list(),
shape = c('Free', 'Increasing', 'Decreasing', 'IncreasingConvex', 'DecreasingConcave',
'IncreasingConcave', 'DecreasingConvex', 'IncreasingS', 'DecreasingS',
'IncreasingRotatedS','DecreasingRotatedS','InvertedU','Ushape',
'IncMultExtreme','DecMultExtreme'), nExtreme = NULL,
marginal.likelihood = TRUE, spm.adequacy = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsar_+3A_formula">formula</code></td>
<td>
<p>		an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo; </p>
</td></tr>
<tr><td><code id="bsar_+3A_xmin">xmin</code></td>
<td>
<p>		a vector or scalar giving user-specific minimum values of x.
The default values are minimum values of x.</p>
</td></tr>
<tr><td><code id="bsar_+3A_xmax">xmax</code></td>
<td>
<p>		a vector or scalar giving user-specific maximum values of x.
The default values are maximum values of x.</p>
</td></tr>
<tr><td><code id="bsar_+3A_nbasis">nbasis</code></td>
<td>
<p>		number of cosine basis functions. </p>
</td></tr>
<tr><td><code id="bsar_+3A_nint">nint</code></td>
<td>
<p>			number of grid points where the unknown function is evaluated for plotting.
The default is 200.</p>
</td></tr>
<tr><td><code id="bsar_+3A_mcmc">mcmc</code></td>
<td>
<p>			a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>nblow0 (1000)</code> giving the number of initialization period for adaptive metropolis,
<code>maxmodmet (5)</code> giving the maximum number of times to modify metropolis,
<code>nblow (10000)</code> giving the number of MCMC in transition period,
<code>nskip (10)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis, and
<code>ndisp (1000)</code> giving the number of saved draws to be displayed on screen
(the function reports on the screen when every
<code>ndisp</code> iterations have been carried out). </p>
</td></tr>
<tr><td><code id="bsar_+3A_prior">prior</code></td>
<td>
<p>			a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>iflagprior</code> choosing a smoothing prior for spectral coefficients
(iflagprior=0 assigns T-Smoother prior (default), iflagprior=1 chooses Lasso-Smoother prior),
<code>theta0_m0</code> and <code>theta0_s0</code> giving the hyperparameters
for prior distribution of the spectral coefficients
(<code>theta0_m0</code> and <code>theta0_s0</code> are used when the functions have shape-restriction),
<code>tau2_m0</code>, <code>tau2_s0</code> and <code>w0</code> giving the prior mean and standard deviation of
smoothing prior (When iflagprior=1, tau2_m0 is only used as the hyperparameter),
<code>beta_m0</code> and <code>beta_v0</code> giving the hyperparameters of the
multivariate normal distribution for parametric part including intercept,
<code>sigma2_m0</code> and <code>sigma2_v0</code> giving the prior mean and variance
of the inverse gamma prior for the scale parameter of response,
<code>alpha_m0</code> and <code>alpha_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the constant of integration,
<code>iflagpsi</code> determining the prior of slope for logisitic function in <code>S</code> or <code>U</code> shaped
(iflagpsi=1 (default), slope <code class="reqn">\psi</code> is sampled and iflagpsi=0, <code class="reqn">\psi</code> is fixed),
<code>psifixed</code> giving initial value (iflagpsi=1) or fixed value (iflagpsi=0) of slope,
<code>omega_m0</code> and <code>omega_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the inflection point of <code>S</code> or <code>U</code> shaped function.</p>
</td></tr>
<tr><td><code id="bsar_+3A_shape">shape</code></td>
<td>
<p>			a vector giving types of shape restriction. </p>
</td></tr>
<tr><td><code id="bsar_+3A_nextreme">nExtreme</code></td>
<td>
<p>  a vector of extreme points for 'IncMultExtreme', 'DecMultExtreme' shape restrictions.</p>
</td></tr>
<tr><td><code id="bsar_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>	a logical variable indicating whether the log marginal likelihood is calculated.
The methods of Gelfand and Dey (1994) and Newton and Raftery (1994) are used. </p>
</td></tr>
<tr><td><code id="bsar_+3A_spm.adequacy">spm.adequacy</code></td>
<td>
<p>		a logical variable indicating whether the log marginal likelihood of linear model is calculated.
The marginal likelihood gives the values of the linear regression model excluding the nonlinear parts.</p>
</td></tr>
<tr><td><code id="bsar_+3A_verbose">verbose</code></td>
<td>
<p>   a logical variable. If <code>TRUE</code>, the iteration number and the Metropolis acceptance rate are printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a Bayesian spectral analysis regression model (Lenk and Choi, 2015)
for estimating shape-restricted functions using Gaussian process priors.
For enforcing shape-restrictions, they assumed that the derivatives of the functions are squares of Gaussian processes.
</p>
<p>Let <code class="reqn">y_i</code> and <code class="reqn">w_i</code> be the response and the vector of parametric predictors, respectively.
Further, let <code class="reqn">x_{i,k}</code> be the covariate related to the response through an unknown shape-restricted function.
The model for estimating shape-restricted functions is as follows.
</p>
<p style="text-align: center;"><code class="reqn">y_i = w_i^T\beta + \sum_{k=1}^K f_k(x_{i,k}) + \epsilon_i, ~ i=1,\ldots,n, </code>
</p>

<p>where <code class="reqn">f_k</code> is an unknown shape-restricted function of the scalar <code class="reqn">x_{i,k} \in [0,1]</code> and
the error terms <code class="reqn">\{\epsilon_i\}</code> are a random sample from a normal distribution, <code class="reqn">N(0,\sigma^2)</code>.
</p>
<p>The prior of function without shape restriction is:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = Z(x), </code>
</p>

<p>where <code class="reqn">Z</code> is a second-order Gaussian process with mean function equal to zero and covariance function
<code class="reqn">\nu(s,t) = E[Z(s)Z(t)]</code> for <code class="reqn">s, t \in [0, 1]</code>. The Gaussian process is expressed with
the spectral representation based on cosine basis functions:
</p>
<p style="text-align: center;"><code class="reqn">Z(x) = \sum_{j=0}^\infty \theta_j\varphi_j(x)</code>
</p>

<p style="text-align: center;"><code class="reqn">\varphi_0(x) = 1 ~~ \code{and} ~~ \varphi_j(x) = \sqrt{2}\cos(\pi j x), ~ j \ge 1, ~ 0 \le x \le 1</code>
</p>

<p>The shape-restricted functions are modeled by assuming the <code class="reqn">q</code>th derivatives of <code class="reqn">f</code> are squares of Gaussian processes:
</p>
<p style="text-align: center;"><code class="reqn">f^{(q)}(x) = \delta Z^2(x)h(x), ~~ \delta \in \{1, -1\}, ~~ q \in \{1, 2\},</code>
</p>

<p>where <code class="reqn">h</code> is the squish function. For monotonic, monotonic convex, and concave functions, <code class="reqn">h(x)=1</code>, while
for <code>S</code> and <code>U</code> shaped functions, <code class="reqn">h</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">h(x) = \frac{1 - \exp[\psi(x - \omega)]}{1 + \exp[\psi(x - \omega)]}, ~~ \psi &gt; 0, ~~ 0 &lt; \omega &lt; 1</code>
</p>

<p>For the spectral coefficients of functions without shape constraints, the scale-invariant prior is used
(The intercept is included in <code class="reqn">\beta</code>):
</p>
<p style="text-align: center;"><code class="reqn">\theta_j | \sigma, \tau, \gamma \sim N(0, \sigma^2\tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>The priors for the spectral coefficients of shape restricted functions are:
</p>
<p style="text-align: center;"><code class="reqn">\theta_0 | \sigma \sim N(m_{\theta_0}, \sigma v^2_{\theta_0}), \quad
	\theta_j | \sigma, \tau, \gamma \sim N(m_{\theta_j}, \sigma\tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>To complete the model specification, the conjugate priors are assumed for <code class="reqn">\beta</code> and <code class="reqn">\sigma</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta | \sigma \sim N(m_{0,\beta}, \sigma^2V_{0,\beta}), \quad \sigma^2 \sim IG\left(\frac{r_{0,\sigma}}{2}, \frac{s_{0,\sigma}}{2}\right)</code>
</p>



<h3>Value</h3>

<p>An object of class <code>bsam</code> representing the Bayesian spectral analysis model fit.
Generic functions such as <code>print</code>, <code>fitted</code> and <code>plot</code> have methods to show the results of the fit.
</p>
<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code>,
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>, and
the MCMC samples for the log marginal likelihood are saved in the list <code>loglik.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>lmarg.lm</code></td>
<td>
<p>	log marginal likelihood for linear regression model. </p>
</td></tr>
<tr><td><code>lmarg.gd</code></td>
<td>
<p>	log marginal likelihood using Gelfand-Dey method. </p>
</td></tr>
<tr><td><code>lmarg.nr</code></td>
<td>
<p>	log marginal likelihood using Netwon-Raftery method, which is biased. </p>
</td></tr>
<tr><td><code>rsquarey</code></td>
<td>
<p> 	correlation between <code class="reqn">y</code> and <code class="reqn">\hat{y}</code>. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>      running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Jo, S., Choi, T., Park, B. and Lenk, P. (2019). bsamGP: An R Package for Bayesian Spectral Analysis Models
Using Gaussian Process Priors. <em>Journal of Statistical Software</em>, <b>90</b>, 310-320.
</p>
<p>Lenk, P. and Choi, T. (2017) Bayesian Analysis of Shape-Restricted Functions using
Gaussian Process Priors. <em>Statistica Sinica</em>, <b>27</b>, 43-69.
</p>
<p>Gelfand, A. E. and Dey, K. K. (1994) Bayesian model choice: asymptotics and exact calculations.
<em>Journal of the Royal Statistical Society. Series B - Statistical Methodology</em>, <b>56</b>, 501-514.
</p>
<p>Newton, M. A. and Raftery, A. E. (1994) Approximate Bayesian inference with the weighted likelihood bootstrap (with discussion).
<em>Journal of the Royal Statistical Society. Series B - Statistical Methodology</em>, <b>56</b>, 3-48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsardpm">bsardpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

##########################################
# Increasing Convex to Concave (S-shape) #
##########################################

# simulate data
f &lt;- function(x) 5*exp(-10*(x - 1)^4) + 5*x^2

set.seed(1)

n &lt;- 100
x &lt;- runif(n)
y &lt;- f(x) + rnorm(n, sd = 1)

# Number of cosine basis functions
nbasis &lt;- 50

# Fit the model with default priors and mcmc parameters
fout &lt;- bsar(y ~ fs(x), nbasis = nbasis, shape = 'IncreasingConvex',
             spm.adequacy = TRUE)

# Summary
print(fout); summary(fout)

# Trace plots
plot(fout)

# fitted values
fit &lt;- fitted(fout)

# Plot
plot(fit, ask = TRUE)

#############################################
# Additive Model                            #
# Monotone-Increasing and Increasing-Convex #
#############################################

# Simulate data
f1 &lt;- function(x) 2*pi*x + sin(2*pi*x)
f2 &lt;- function(x) exp(6*x - 3)

n &lt;- 200
x1 &lt;- runif(n)
x2 &lt;- runif(n)
x &lt;- cbind(x1, x2)

y &lt;- 5 + f1(x1) + f2(x2) + rnorm(n, sd = 0.5)

# Number of cosine basis functions
nbasis &lt;- 50

# MCMC parameters
mcmc &lt;- list(nblow0 = 1000, nblow = 10000, nskip = 10,
             smcmc = 5000, ndisp = 1000, maxmodmet = 10)

# Prior information
xmin &lt;- apply(x, 2, min)
xmax &lt;- apply(x, 2, max)
xrange &lt;- xmax - xmin
prior &lt;- list(iflagprior = 0, theta0_m0 = 0, theta0_s0 = 100,
              tau2_m0 = 1, tau2_v0 = 100, w0 = 2,
              beta_m0 = numeric(1), beta_v0 = diag(100,1),
              sigma2_m0 = 1, sigma2_v0 = 1000,
              alpha_m0 = 3, alpha_s0 = 50, iflagpsi = 1,
              psifixed = 1000, omega_m0 = (xmin + xmax)/2,
              omega_s0 = (xrange)/8)

# Fit the model with user specific priors and mcmc parameters
fout &lt;- bsar(y ~ fs(x1) + fs(x2), nbasis = nbasis, mcmc = mcmc, prior = prior,
             shape = c('Increasing', 'IncreasingS'))

# Summary
print(fout); summary(fout)

## End(Not run)
</code></pre>

<hr>
<h2 id='bsarBig'>Bayesian Spectral Analysis Regression for Big data</h2><span id='topic+bsarBig'></span>

<h3>Description</h3>

<p>This function fits a Bayesian spectral analysis regression model for Big data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsarBig(formula, nbasis, nint, mcmc = list(), prior = list(), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsarBig_+3A_formula">formula</code></td>
<td>
<p> an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo; </p>
</td></tr>
<tr><td><code id="bsarBig_+3A_nbasis">nbasis</code></td>
<td>
<p>  number of cosine basis functions. </p>
</td></tr>
<tr><td><code id="bsarBig_+3A_nint">nint</code></td>
<td>
<p>    number of grid points where the unknown function is evaluated for plotting.
The default is 500. </p>
</td></tr>
<tr><td><code id="bsarBig_+3A_mcmc">mcmc</code></td>
<td>
<p>    a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>nblow (10000)</code> giving the number of MCMC in transition period,
<code>nskip (10)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis, and
<code>ndisp (1000)</code> giving the number of saved draws to be displayed on screen
(the function reports on the screen when every
<code>ndisp</code> iterations have been carried out). </p>
</td></tr>
<tr><td><code id="bsarBig_+3A_prior">prior</code></td>
<td>
<p>   a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>sigma2_m0</code> and <code>sigma2_v0</code> giving the prior mean and variance
of the inverse gamma prior for the scale parameter of response,
<code>tau2_m0</code>, <code>tau2_s0</code> and <code>w0</code> giving the prior mean and standard deviation of
smoothing prior. </p>
</td></tr>
<tr><td><code id="bsarBig_+3A_verbose">verbose</code></td>
<td>
<p> a logical variable. If <code>TRUE</code>, the iteration number and the Metropolis acceptance rate are printed to the screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code> and
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>      running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bsar">bsar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ttrue function
ftrue &lt;- function(x){
  ft &lt;- 7*exp(-3*x) + 2*exp(-70*(x-.6)^2) - 2 + 5*x
  return(ft)
}

# Generate data
set.seed(1)

nobs &lt;- 100000 # Number of observations
sigmat &lt;- .5 # True sigma
nxgrid &lt;- 500 # number of grid points: approximate likelihood &amp; plots

xdata &lt;- runif(nobs) # Generate x values
fobst &lt;- ftrue(xdata) # True f at observations
ydata &lt;- fobst + sigmat*rnorm(nobs)

# Compute grid on 0 to 1
xdelta &lt;- 1/nxgrid
xgrid &lt;- seq(xdelta/2, 1-xdelta/2, xdelta)
xgrid &lt;- matrix(xgrid,nxgrid)
fxgridt &lt;- ftrue(xgrid) # True f on xgrid

# Fit data
fout &lt;- bsarBig(ydata ~ xdata, nbasis = 50, nint = nxgrid, verbose = TRUE)

# Plots
smcmc &lt;- fout$mcmc$smcmc
t &lt;- 1:smcmc
par(mfrow=c(2,2))
matplot(t, fout$mcmc.draws$theta, type = "l", main = "Theta", xlab = "Iteration", ylab = "Draw")
plot(t, fout$mcmc.draws$sigma, type = "l", main = "Sigma", xlab = "Iteration", ylab = "Draw")
matplot(t, fout$mcmc.draws$tau, type = "l", main = "Tau", xlab = "Iteration", ylab = "Draw")
matplot(t, fout$mcmc.draws$gamma, type = "l", main = "Gamma", xlab = "Iteration", ylab = "Draw")

dev.new()
matplot(fout$fit.draws$xgrid, cbind(fxgridt, fout$post.est$fhatm, fout$post.est$fhatq),
        type = "l", main = "Regression Function", xlab = "X", ylab = "Y")

# Compute RMISE for regression function
sse &lt;- (fout$post.est$fhatm - fxgridt)^2
rmise &lt;- intgrat(sse, 1/nxgrid)
rmise &lt;- sqrt(rmise)
rmise
</code></pre>

<hr>
<h2 id='bsardpm'>Bayesian Shape-Restricted Spectral Analysis Regression with Dirichlet Process Mixture Errors</h2><span id='topic+bsardpm'></span>

<h3>Description</h3>

<p>This function fits a Bayesian semiparametric regression model
to estimate shape-restricted functions
using a spectral analysis of Gaussian process priors.
The model assumes that the errors follow a Dirichlet process mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
bsardpm(formula, xmin, xmax, nbasis, nint,
mcmc = list(), prior = list(), egrid, ngrid, location = TRUE,
shape = c('Free', 'Increasing', 'Decreasing', 'IncreasingConvex', 'DecreasingConcave',
'IncreasingConcave', 'DecreasingConvex', 'IncreasingS', 'DecreasingS',
'IncreasingRotatedS','DecreasingRotatedS','InvertedU','Ushape'),
verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsardpm_+3A_formula">formula</code></td>
<td>
<p>		an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo; </p>
</td></tr>
<tr><td><code id="bsardpm_+3A_xmin">xmin</code></td>
<td>
<p>		a vector or scalar giving user-specific minimum values of x.
The default values are minimum values of x.</p>
</td></tr>
<tr><td><code id="bsardpm_+3A_xmax">xmax</code></td>
<td>
<p>		a vector or scalar giving user-specific maximum values of x.
The default values are maximum values of x.</p>
</td></tr>
<tr><td><code id="bsardpm_+3A_nbasis">nbasis</code></td>
<td>
<p>		number of cosine basis functions. </p>
</td></tr>
<tr><td><code id="bsardpm_+3A_nint">nint</code></td>
<td>
<p>			number of grid points where the unknown function is evaluated for plotting.
The default is 200.</p>
</td></tr>
<tr><td><code id="bsardpm_+3A_mcmc">mcmc</code></td>
<td>
<p>			a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>nblow0 (1000)</code> giving the number of initialization period for adaptive metropolis,
<code>maxmodmet (5)</code> giving the maximum number of times to modify metropolis,
<code>nblow (10000)</code> giving the number of MCMC in transition period,
<code>nskip (10)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis, and
<code>ndisp (1000)</code> giving the number of saved draws to be displayed on screen
(the function reports on the screen when every
<code>ndisp</code> iterations have been carried out). </p>
</td></tr>
<tr><td><code id="bsardpm_+3A_prior">prior</code></td>
<td>
<p>			a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>iflagprior</code> choosing a smoothing prior for spectral coefficients
(iflagprior=0 assigns T-Smoother prior (default), iflagprior=1 chooses Lasso-Smoother prior),
<code>theta0_m0</code> and <code>theta0_s0</code> giving the hyperparameters
for prior distribution of the spectral coefficients
(<code>theta0_m0</code> and <code>theta0_s0</code> are used when the functions have shape-restriction),
<code>tau2_m0</code>, <code>tau2_s0</code> and <code>w0</code> giving the prior mean and standard deviation of
smoothing prior (When iflagprior=1, tau2_m0 is only used as the hyperparameter),
<code>beta_m0</code> and <code>beta_v0</code> giving the hyperparameters of the
multivariate normal distribution for parametric part including intercept,
<code>sigma2_m0</code> and <code>sigma2_v0</code> giving the prior mean and variance
of the inverse gamma prior for the scale parameter of response,
<code>alpha_m0</code> and <code>alpha_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the constant of integration,
<code>iflagpsi</code> determining the prior of slope for logisitic function in <code>S</code> or <code>U</code> shaped
(iflagpsi=1 (default), slope <code class="reqn">\psi</code> is sampled and iflagpsi=0, <code class="reqn">\psi</code> is fixed),
<code>psifixed</code> giving initial value (iflagpsi=1) or fixed value (iflagpsi=0) of slope,
<code>omega_m0</code> and <code>omega_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the inflection point of <code>S</code> or <code>U</code> shaped function.</p>
</td></tr>
<tr><td><code id="bsardpm_+3A_egrid">egrid</code></td>
<td>
<p>			a vector giving grid points where the residual density estimate is evaluated.
The default range is from -10 to 10.</p>
</td></tr>
<tr><td><code id="bsardpm_+3A_ngrid">ngrid</code></td>
<td>
<p>			a vector giving number of grid points where the residual density estimate is evaluated.
The default value is 500.</p>
</td></tr>
<tr><td><code id="bsardpm_+3A_location">location</code></td>
<td>
<p>		a logical value. If it is true, error density is modelled using location-scale mixture.</p>
</td></tr>
<tr><td><code id="bsardpm_+3A_shape">shape</code></td>
<td>
<p>			a vector giving types of shape restriction. </p>
</td></tr>
<tr><td><code id="bsardpm_+3A_verbose">verbose</code></td>
<td>
<p>   a logical variable. If <code>TRUE</code>, the iteration number and the Metropolis acceptance rate are printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a Bayesian spectral analysis regression model
for estimating shape-restricted functions using Gaussian process priors.
For enforcing shape-restrictions, the model assumes that the derivatives of the functions are squares of Gaussian processes.
The model also assumes that the errors follow a Dirichlet process mixture model.
</p>
<p>Let <code class="reqn">y_i</code> and <code class="reqn">w_i</code> be the response and the vector of parametric predictors, respectively.
Further, let <code class="reqn">x_{i,k}</code> be the covariate related to the response through an unknown shape-restricted function.
The model for estimating shape-restricted functions is as follows.
</p>
<p style="text-align: center;"><code class="reqn">y_i = w_i^T\beta + \sum_{k=1}^K f_k(x_{i,k}) + \epsilon_i, ~ i=1,\ldots,n, </code>
</p>

<p>where <code class="reqn">f_k</code> is an unknown shape-restricted function of the scalar <code class="reqn">x_{i,k} \in [0,1]</code> and
the error terms <code class="reqn">\{\epsilon_i\}</code> are a random sample from a Dirichlet process mixture model,
</p>
<p>1. scale mixture :
</p>
<p style="text-align: center;"><code class="reqn">\epsilon_i \sim f(\epsilon) = \int N(\epsilon; 0,\sigma^2)dG(\sigma^2), </code>
</p>

<p style="text-align: center;"><code class="reqn">G \sim DP(M,G0), ~~ G0 = Ga\left(\sigma^{-2}; \frac{r_{0,\sigma}}{2},\frac{s_{0,\sigma}}{2}\right).</code>
</p>

<p>2. location-scale mixture :
</p>
<p style="text-align: center;"><code class="reqn">\epsilon_i \sim f(\epsilon) = \int N(\epsilon; \mu,\sigma^2)dG(\mu,\sigma^2), </code>
</p>

<p style="text-align: center;"><code class="reqn">G \sim DP(M,G0), ~~ G0 = N\left(\mu;\mu_0,\kappa\sigma^2\right)Ga\left(\sigma^{-2}; \frac{r_{0,\sigma}}{2},\frac{s_{0,\sigma}}{2}\right).</code>
</p>

<p>The prior of function without shape restriction is:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = Z(x), </code>
</p>

<p>where <code class="reqn">Z</code> is a second-order Gaussian process with mean function equal to zero and covariance function
<code class="reqn">\nu(s,t) = E[Z(s)Z(t)]</code> for <code class="reqn">s, t \in [0, 1]</code>. The Gaussian process is expressed with
the spectral representation based on cosine basis functions:
</p>
<p style="text-align: center;"><code class="reqn">Z(x) = \sum_{j=0}^\infty \theta_j\varphi_j(x)</code>
</p>

<p style="text-align: center;"><code class="reqn">\varphi_0(x) = 1 ~~ \code{and} ~~ \varphi_j(x) = \sqrt{2}\cos(\pi j x), ~ j \ge 1, ~ 0 \le x \le 1</code>
</p>

<p>The shape-restricted functions are modeled by assuming the <code class="reqn">q</code>th derivatives of <code class="reqn">f</code> are squares of Gaussian processes:
</p>
<p style="text-align: center;"><code class="reqn">f^{(q)}(x) = \delta Z^2(x)h(x), ~~ \delta \in \{1, -1\}, ~~ q \in \{1, 2\},</code>
</p>

<p>where <code class="reqn">h</code> is the squish function. For monotonic, monotonic convex, and concave functions, <code class="reqn">h(x)=1</code>, while
for <code>S</code> and <code>U</code> shaped functions, <code class="reqn">h</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">h(x) = \frac{1 - \exp[\psi(x - \omega)]}{1 + \exp[\psi(x - \omega)]}, ~~ \psi &gt; 0, ~~ 0 &lt; \omega &lt; 1</code>
</p>

<p>For the spectral coefficients of functions without shape constraints, the scale-invariant prior is used
(The intercept is included in <code class="reqn">\beta</code>):
</p>
<p style="text-align: center;"><code class="reqn">\theta_j | \tau, \gamma \sim N(0, \tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>The priors for the spectral coefficients of shape restricted functions are:
</p>
<p style="text-align: center;"><code class="reqn">\theta_0 \sim N(m_{\theta_0}, v^2_{\theta_0}), \quad
	\theta_j | \tau, \gamma \sim N(m_{\theta_j}, \tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>To complete the model specification, the popular normal prior is assumed for <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta | \sim N(m_{0,\beta}, V_{0,\beta})</code>
</p>



<h3>Value</h3>

<p>An object of class <code>bsam</code> representing the Bayesian spectral analysis model fit.
Generic functions such as <code>print</code>, <code>fitted</code> and <code>plot</code> have methods to show the results of the fit.
</p>
<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code>,
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>, and
the MCMC samples for the log marginal likelihood are saved in the list <code>loglik.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>lpml</code></td>
<td>
<p>		log pseudo marginal likelihood using Mukhopadhyay and Gelfand method. </p>
</td></tr>
<tr><td><code>imodmet</code></td>
<td>
<p>	the number of times to modify Metropolis. </p>
</td></tr>
<tr><td><code>pmet</code></td>
<td>
<p>		proportion of <code class="reqn">\theta</code> accepted after burn-in. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>     running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Jo, S., Choi, T., Park, B. and Lenk, P. (2019). bsamGP: An R Package for Bayesian Spectral Analysis Models
Using Gaussian Process Priors. <em>Journal of Statistical Software</em>, <b>90</b>, 310-320.
</p>
<p>Lenk, P. and Choi, T. (2017) Bayesian Analysis of Shape-Restricted Functions using
Gaussian Process Priors. <em>Statistica Sinica</em>, <b>27</b>, 43-69.
</p>
<p>MacEachern, S. N. and MÃ¼ller, P. (1998) Estimating mixture of Dirichlet process models.
<em>Journal of Computational and Graphical Statistics</em>, <b>7</b>, 223-238.
</p>
<p>Mukhopadhyay, S. and Gelfand, A. E. (1997) Dirichlet process mixed generalized linear models.
<em>Journal of the American Statistical Association</em>, <b>92</b>, 633-639.
</p>
<p>Neal, R. M. (2000) Markov chain sampling methods for Dirichlet process mixture models.
<em>Journal of Computational and Graphical Statistics</em>, <b>9</b>, 249-265.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsar">bsar</a></code>, <code><a href="#topic+bsaqdpm">bsaqdpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#####################
# Increasing-convex #
#####################

# Simulate data
set.seed(1)

n &lt;- 200
x &lt;- runif(n)
e &lt;- c(rnorm(n/2, sd = 0.5), rnorm(n/2, sd = 3))
y &lt;- exp(6*x - 3) + e

# Number of cosine basis functions
nbasis &lt;- 50

# Fit the model with default priors and mcmc parameters
fout &lt;- bsardpm(y ~ fs(x), nbasis = nbasis, shape = 'IncreasingConvex')

# Summary
print(fout); summary(fout)

# fitted values
fit &lt;- fitted(fout)

# Plot
plot(fit, ask = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='cadmium'>
Cadmium dose-response meta data
</h2><span id='topic+cadmium'></span>

<h3>Description</h3>

<p>This dataset includes minimal information of NCC-2012 meta data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("cadmium")</code></pre>


<h3>Format</h3>

<p>A data frame with 190 observations on the following 5 variables.
</p>

<dl>
<dt><code>gender</code></dt><dd><p>a numeric vector with 1 : Female, 0 : Male, 0.5 : Unknown or both</p>
</dd>
<dt><code>ethnicity</code></dt><dd><p>a integer vector with 1 : Asian, 2 : Caucasian</p>
</dd>
<dt><code>Ucd_GM</code></dt><dd><p>a numeric vector of Geometric means of urinary cadmium</p>
</dd>
<dt><code>b2_GM</code></dt><dd><p>a numeric vector of Geometric means of Beta2-Microglobulin</p>
</dd>
<dt><code>isOld</code></dt><dd><p>a logical vector whether the observation is older than 50</p>
</dd>
</dl>



<h3>References</h3>

<p>Lee, Minjea, Choi, Taeryon; Kim, Jeongseon; Woo, Hae Dong (2013) Bayesian Analysis of Dose-Effect Relationship of Cadmium for Benchmark Dose Evaluation. <em>Korean Journal of Applied Statistics</em>, <b>26</b>(3), 453â470.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(cadmium)

## End(Not run)
</code></pre>

<hr>
<h2 id='Elec.demand'>Electricity demand data</h2><span id='topic+Elec.demand'></span>

<h3>Description</h3>

<p>The Elec.demand data consists of 288 quarterly observations in Ontario from 1971 to 1994.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Elec.demand)</code></pre>


<h3>Format</h3>

<p>A data frame with 288 observations on the following 7 variables.
</p>

<dl>
<dt>quarter</dt><dd><p>date (yyyy-mm) from 1971 to 1994</p>
</dd>
<dt>enerm</dt><dd><p>electricity demand.</p>
</dd>
<dt>gdp</dt><dd><p>gross domestic product.</p>
</dd>
<dt>pelec</dt><dd><p>price of electricity.</p>
</dd>
<dt>pgas</dt><dd><p>price of natural gas.</p>
</dd>
<dt>hddqm</dt><dd><p>the number of heating degree days relative to a reference temperature.</p>
</dd>
<dt>cddqm</dt><dd><p>the number of cooling degree days relative to a reference temperature.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Yatchew, A. (2003). <em>Semiparametric Regression for the Applied Econometrician</em>.
Cambridge University Press.
</p>


<h3>References</h3>

<p>Engle, R. F., Granger, C. W. J., Rice, J. and Weiss, A. (1986). Semiparametric estimates of
the relation between weather and electricity sales.
<em>Journal of the American Statistical Association</em>, <b>81</b>, 310-320.
</p>
<p>Lenk, P. and Choi, T. (2017). Bayesian analysis of shape-restricted functions using
Gaussian process priors. <em>Statistica Sinica</em>, <b>27</b>, 43-69.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(Elec.demand)
	plot(Elec.demand)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted.blm'> Compute fitted values for a blm object</h2><span id='topic+fitted.blm'></span>

<h3>Description</h3>

<p>Computes pointwise posterior means and 95% credible intervals of the fitted Bayesian linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'blm'
fitted(object, alpha = 0.05, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.blm_+3A_object">object</code></td>
<td>
<p> a <code>bsam</code> object</p>
</td></tr>
<tr><td><code id="fitted.blm_+3A_alpha">alpha</code></td>
<td>
<p>	 a numeric scalar in the interval (0,1) giving the <code class="reqn">100(1-\alpha)</code>% credible intervals.</p>
</td></tr>
<tr><td><code id="fitted.blm_+3A_hpd">HPD</code></td>
<td>
<p>    a logical variable indicating whether the <code class="reqn">100(1-\alpha)</code>% Highest Posterior Density (HPD) intervals are calculated.
If <code>HPD</code>=FALSE, the <code class="reqn">100(1-\alpha)</code>% equal-tail credible intervals are calculated.
The default is TRUE.</p>
</td></tr>
<tr><td><code id="fitted.blm_+3A_...">...</code></td>
<td>
<p>  not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>None.
</p>


<h3>Value</h3>

<p>A list containing posterior means and 95% credible intervals.
</p>
<p>The output list includes the following objects:
</p>
<table>
<tr><td><code>wbeta</code></td>
<td>
<p>	posterior estimates for regression function.</p>
</td></tr>
<tr><td><code>yhat</code></td>
<td>
<p>	posterior estimates for generalised regression function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chen, M., Shao, Q. and Ibrahim, J. (2000) <em>Monte Carlo Methods in Bayesian computation</em>. 
Springer-Verlag New York, Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blq">blq</a></code>, <code><a href="#topic+blr">blr</a></code>, <code><a href="#topic+gblr">gblr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for blq and blr
</code></pre>

<hr>
<h2 id='fitted.bsad'> Compute fitted values for a bsad object</h2><span id='topic+fitted.bsad'></span>

<h3>Description</h3>

<p>Computes pointwise posterior means and <code class="reqn">100(1-\alpha)</code>% credible intervals of the fitted Bayesian spectral analysis density estimation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsad'
fitted(object, alpha = 0.05, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bsad_+3A_object">object</code></td>
<td>
<p> a <code>bsad</code> object</p>
</td></tr>
<tr><td><code id="fitted.bsad_+3A_alpha">alpha</code></td>
<td>
<p>	 a numeric scalar in the interval (0,1) giving the <code class="reqn">100(1-\alpha)</code>% credible intervals.</p>
</td></tr>
<tr><td><code id="fitted.bsad_+3A_hpd">HPD</code></td>
<td>
<p>    a logical variable indicating whether the <code class="reqn">100(1-\alpha)</code>% Highest Posterior Density (HPD) intervals are calculated.
If <code>HPD</code>=FALSE, the <code class="reqn">100(1-\alpha)</code>% equal-tail credible intervals are calculated.
The default is TRUE.</p>
</td></tr>
<tr><td><code id="fitted.bsad_+3A_...">...</code></td>
<td>
<p>  not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>None.
</p>


<h3>Value</h3>

<p>A list object of class <code>fitted.bsad</code> containing posterior means and <code class="reqn">100(1-\alpha)</code>% credible intervals.
Generic function <code>plot</code> displays the results of the fit.
</p>
<p>The output list includes the following objects:
</p>
<table>
<tr><td><code>fpar</code></td>
<td>
<p>	posterior estimates for parametric model.</p>
</td></tr>
<tr><td><code>fsemi</code></td>
<td>
<p>	posterior estimates for semiparametric model.</p>
</td></tr>
<tr><td><code>fsemiMaxKappa</code></td>
<td>
<p>	posterior estimates for semiparametric model with maximum number of basis.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bsad">bsad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for bsad
</code></pre>

<hr>
<h2 id='fitted.bsam'> Compute fitted values for a bsam object</h2><span id='topic+fitted.bsam'></span>

<h3>Description</h3>

<p>Computes pointwise posterior means and <code class="reqn">100(1-\alpha)</code>% credible intervals of the fitted Bayesian spectral analysis models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsam'
fitted(object, alpha = 0.05, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bsam_+3A_object">object</code></td>
<td>
<p> a <code>bsam</code> object</p>
</td></tr>
<tr><td><code id="fitted.bsam_+3A_alpha">alpha</code></td>
<td>
<p>	 a numeric scalar in the interval (0,1) giving the <code class="reqn">100(1-\alpha)</code>% credible intervals.</p>
</td></tr>
<tr><td><code id="fitted.bsam_+3A_hpd">HPD</code></td>
<td>
<p>    a logical variable indicating whether the <code class="reqn">100(1-\alpha)</code>% Highest Posterior Density (HPD) intervals are calculated.
If <code>HPD</code>=FALSE, the <code class="reqn">100(1-\alpha)</code>% equal-tail credible intervals are calculated.
The default is TRUE.</p>
</td></tr>
<tr><td><code id="fitted.bsam_+3A_...">...</code></td>
<td>
<p>  not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>None.
</p>


<h3>Value</h3>

<p>A list object of class <code>fitted.bsam</code> containing posterior means and <code class="reqn">100(1-\alpha)</code>% credible intervals.
Generic function <code>plot</code> displays the results of the fit.
</p>
<p>The output list includes the following objects:
</p>
<table>
<tr><td><code>fxobs</code></td>
<td>
<p>	posterior estimates for unknown functions over observation.</p>
</td></tr>
<tr><td><code>fxgrid</code></td>
<td>
<p>	posterior estimates for unknown functions over grid points.</p>
</td></tr>
<tr><td><code>wbeta</code></td>
<td>
<p>	posterior estimates for parametric part.</p>
</td></tr>
<tr><td><code>yhat</code></td>
<td>
<p>	posterior estimates for fitted values of response.
For <code><a href="#topic+gbsar">gbsar</a></code>, it gives posterior estimates for expectation of response.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bsaq">bsaq</a></code>, <code><a href="#topic+bsaqdpm">bsaqdpm</a></code>, <code><a href="#topic+bsar">bsar</a></code>, <code><a href="#topic+bsardpm">bsardpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for bsaq, bsaqdpm, bsar, and bsardpm
</code></pre>

<hr>
<h2 id='fitted.bsamdpm'> Compute fitted values for a bsamdpm object</h2><span id='topic+fitted.bsamdpm'></span>

<h3>Description</h3>

<p>Computes pointwise posterior means and <code class="reqn">100(1-\alpha)</code>% credible intervals of the fitted Bayesian spectral analysis models with Dirichlet process mixture error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsamdpm'
fitted(object, alpha = 0.05, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bsamdpm_+3A_object">object</code></td>
<td>
<p> a <code>bsamdpm</code> object</p>
</td></tr>
<tr><td><code id="fitted.bsamdpm_+3A_alpha">alpha</code></td>
<td>
<p>	 a numeric scalar in the interval (0,1) giving the <code class="reqn">100(1-\alpha)</code>% credible intervals.</p>
</td></tr>
<tr><td><code id="fitted.bsamdpm_+3A_hpd">HPD</code></td>
<td>
<p>    a logical variable indicating whether the <code class="reqn">100(1-\alpha)</code>% Highest Posterior Density (HPD) intervals are calculated.
If <code>HPD</code>=FALSE, the <code class="reqn">100(1-\alpha)</code>% equal-tail credible intervals are calculated.
The default is TRUE.</p>
</td></tr>
<tr><td><code id="fitted.bsamdpm_+3A_...">...</code></td>
<td>
<p>  not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>None.
</p>


<h3>Value</h3>

<p>A list object of class <code>fitted.bsamdpm</code> containing posterior means and 95% credible intervals.
Generic function <code>plot</code> displays the results of the fit.
</p>
<p>The output list includes the following objects:
</p>
<table>
<tr><td><code>edens</code></td>
<td>
<p>	posterior estimate for unknown error distribution over grid points.</p>
</td></tr>
<tr><td><code>fxobs</code></td>
<td>
<p>	posterior estimates for unknown functions over observation.</p>
</td></tr>
<tr><td><code>fxgrid</code></td>
<td>
<p>	posterior estimates for unknown functions over grid points.</p>
</td></tr>
<tr><td><code>wbeta</code></td>
<td>
<p>	posterior estimates for parametric part.</p>
</td></tr>
<tr><td><code>yhat</code></td>
<td>
<p>	posterior estimates for fitted values of response.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bsaqdpm">bsaqdpm</a></code>, <code><a href="#topic+bsardpm">bsardpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for bsaqdpm and bsardpm
</code></pre>

<hr>
<h2 id='fs'>Specify a Fourier Basis Fit in a BSAM Formula</h2><span id='topic+fs'></span>

<h3>Description</h3>

<p>A symbolic wrapper to indicate a nonparametric term in a formula argument to bsaq, bsaqdpm, bsar, bsardpm, and gbsar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs_+3A_x">x</code></td>
<td>
<p>a vector of the univariate covariate for nonparametric component</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# fit x using a Fourier basis
y ~ w + fs(x)

# fit x1 and x2 using a Fourier basis
y ~ fs(x1) + fs(x2)


## End(Not run)
</code></pre>

<hr>
<h2 id='gblr'>Generalized Bayesian Linear Models</h2><span id='topic+gblr'></span>

<h3>Description</h3>

<p>This function fits a Bayesian generalized linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
gblr(formula, data = NULL, family, link, mcmc = list(), prior = list(),
marginal.likelihood = TRUE, algorithm = c('AM', 'KS'), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gblr_+3A_formula">formula</code></td>
<td>
<p>		an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo; </p>
</td></tr>
<tr><td><code id="gblr_+3A_data">data</code></td>
<td>
<p>	    an optional data frame.</p>
</td></tr>
<tr><td><code id="gblr_+3A_family">family</code></td>
<td>
<p>		a description of the error distribution to be used in the model:
The family contains bernoulli (&ldquo;bernoulli&rdquo;),
poisson (&ldquo;poisson&rdquo;), negative-binomial (&ldquo;negative.binomial&rdquo;),
poisson-gamma mixture (&ldquo;poisson.gamma&rdquo;). </p>
</td></tr>
<tr><td><code id="gblr_+3A_link">link</code></td>
<td>
<p>			a description of the link function to be used in the model. </p>
</td></tr>
<tr><td><code id="gblr_+3A_mcmc">mcmc</code></td>
<td>
<p>			a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>nblow (10000)</code> giving the number of MCMC in transition period,
<code>nskip (10)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis, and
<code>ndisp (1000)</code> giving the number of saved draws to be displayed on screen
(the function reports on the screen when every <code>ndisp</code> iterations have been carried out). </p>
</td></tr>
<tr><td><code id="gblr_+3A_prior">prior</code></td>
<td>
<p>			a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>beta_m0</code> and <code>beta_v0</code> giving the hyperparameters of the
multivariate normal distribution for parametric part including intercept,
<code>kappa_m0</code> and <code>kappa_v0</code> giving the prior mean and variance of the
gammal prior distribution for dispersion parameter (negative-binomial). </p>
</td></tr>
<tr><td><code id="gblr_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>	a logical variable indicating whether the log marginal likelihood is calculated.
The methods of Gelfand and Dey (1994) is used. </p>
</td></tr>
<tr><td><code id="gblr_+3A_algorithm">algorithm</code></td>
<td>
<p> a description of the algorithm to be used in the fitting of the logistic model:
The algorithm contains the Gibbs sampler based on the Kolmogorov-Smirnov distribution (<code>KS</code>)
and an adaptive Metropolis  algorithm (<code>AM</code>).</p>
</td></tr>
<tr><td><code id="gblr_+3A_verbose">verbose</code></td>
<td>
<p> a logical variable. If <code>TRUE</code>, the iteration number and the Metropolis acceptance rate are printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a Bayesian generalized linear regression models.
</p>
<p>Let <code class="reqn">y_i</code> and <code class="reqn">w_i</code> be the response and the vector of parametric predictors, respectively.
The model is as follows.
</p>
<p style="text-align: center;"><code class="reqn">y_i | \mu_i \sim F(\mu_i), </code>
</p>

<p style="text-align: center;"><code class="reqn">g(\mu_i) = w_i^T\beta, ~ i=1,\ldots,n, </code>
</p>

<p>where <code class="reqn">g(\cdot)</code> is a link function and <code class="reqn">F(\cdot)</code> is a distribution of an exponential family.
</p>
<p>For unknown coefficients, the following prior is assumed for <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim N(m_{0,\beta}, V_{0,\beta})</code>
</p>

<p>The prior for the dispersion parameter of negative-binomial regression is
</p>
<p style="text-align: center;"><code class="reqn">\kappa \sim Ga(r_0, s_0)</code>
</p>



<h3>Value</h3>

<p>An object of class <code>blm</code> representing the generalized Bayesian linear model fit.
Generic functions such as <code>print</code>, <code>fitted</code> and <code>plot</code> have methods to show the results of the fit.
</p>
<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code>,
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>, and
the MCMC samples for the log marginal likelihood are saved in the list <code>loglik.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>lmarg</code></td>
<td>
<p> 	log marginal likelihood using Gelfand-Dey method. </p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>	the family object used. </p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>		the link object used. </p>
</td></tr>
<tr><td><code>methods</code></td>
<td>
<p>	the method object used in the logit model. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>     running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Albert, J. H. and Chib, S. (1993) Bayesian Analysis of Binary and Polychotomous Response Data.
<em>Journal of the American Statistical Association</em>, <b>88</b>, 669-679.
</p>
<p>Holmes, C. C. and Held, L. (2006) Bayesian Auxiliary Variables Models for Binary and Multinomial Regression.
<em>Bayesian Analysis</em>, <b>1</b>, 145-168.
</p>
<p>Gelfand, A. E. and Dey, K. K. (1994) Bayesian Model Choice: Asymptotics and Exact Calculations.
<em>Journal of the Royal Statistical Society. Series B - Statistical Methodology</em>, <b>56</b>, 501-514.
</p>
<p>Roberts, G. O. and Rosenthal, J. S. (2009) Examples of Adaptive MCMC. <em>Journal of Computational and Graphical Statistics</em>, <b>18</b>, 349-367.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blr">blr</a></code>, <code><a href="#topic+blq">blq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############################
# Poisson Regression Model #
############################

# Simulate data
set.seed(1)

n &lt;- 100
x &lt;- runif(n)
y &lt;- rpois(n, exp(0.5 + x*0.4))

# Fit the model with default priors and mcmc parameters
fout &lt;- gblr(y ~ x, family = 'poisson', link = 'log')

# Summary
print(fout); summary(fout)

# Plot
plot(fout)

# fitted values
fitf &lt;- fitted(fout)
</code></pre>

<hr>
<h2 id='gbsar'>Bayesian Shape-Restricted Spectral Analysis for Generalized Partial Linear Models</h2><span id='topic+gbsar'></span>

<h3>Description</h3>

<p>This function fits a Bayesian generalized partial linear regression model
to estimate shape-restricted functions
using a spectral analysis of Gaussian process priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
gbsar(formula, xmin, xmax, family, link, nbasis, nint, mcmc = list(), prior = list(),
shape = c('Free','Increasing','Decreasing','IncreasingConvex','DecreasingConcave',
          'IncreasingConcave','DecreasingConvex','IncreasingS','DecreasingS',
          'IncreasingRotatedS','DecreasingRotatedS','InvertedU','Ushape'),
marginal.likelihood = TRUE, algorithm = c('AM', 'KS'), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbsar_+3A_formula">formula</code></td>
<td>
<p>		an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo; </p>
</td></tr>
<tr><td><code id="gbsar_+3A_xmin">xmin</code></td>
<td>
<p>		a vector or scalar giving user-specific minimum values of x.
The default values are minimum values of x.</p>
</td></tr>
<tr><td><code id="gbsar_+3A_xmax">xmax</code></td>
<td>
<p>		a vector or scalar giving user-specific maximum values of x.
The default values are maximum values of x.</p>
</td></tr>
<tr><td><code id="gbsar_+3A_family">family</code></td>
<td>
<p>		a description of the error distribution to be used in the model:
The family contains bernoulli (&ldquo;bernoulli&rdquo;), poisson (&ldquo;poisson&rdquo;),
negative-binomial (&ldquo;negative.binomial&rdquo;), poisson-gamma mixture (&ldquo;poisson.gamma&rdquo;). </p>
</td></tr>
<tr><td><code id="gbsar_+3A_link">link</code></td>
<td>
<p>			a description of the link function to be used in the model. </p>
</td></tr>
<tr><td><code id="gbsar_+3A_nbasis">nbasis</code></td>
<td>
<p>		number of cosine basis functions. </p>
</td></tr>
<tr><td><code id="gbsar_+3A_nint">nint</code></td>
<td>
<p>			number of grid points where the unknown function is evaluated for plotting.
The default is 200.</p>
</td></tr>
<tr><td><code id="gbsar_+3A_mcmc">mcmc</code></td>
<td>
<p>			a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>nblow0 (1000)</code> giving the number of initialization period for adaptive metropolis,
<code>maxmodmet (5)</code> giving the maximum number of times to modify metropolis,
<code>nblow (10000)</code> giving the number of MCMC in transition period,
<code>nskip (10)</code> giving the thinning interval,
<code>smcmc (1000)</code> giving the number of MCMC for analysis, and
<code>ndisp (1000)</code> giving the number of saved draws to be displayed on screen
(the function reports on the screen when every
<code>ndisp</code> iterations have been carried out). </p>
</td></tr>
<tr><td><code id="gbsar_+3A_prior">prior</code></td>
<td>
<p>			a list giving the prior information. The list includes the following parameters
(default values specify the non-informative prior):
<code>iflagprior</code> choosing a smoothing prior for spectral coefficients
(iflagprior=0 assigns T-Smoother prior (default), iflagprior=1 chooses Lasso-Smoother prior),
<code>theta_m0</code>, <code>theta0_m0</code> and <code>theta0_s0</code> giving the hyperparameters
for prior distribution of the spectral coefficients
(<code>theta0_m0</code> and <code>theta0_s0</code> are used when the functions have shape-restriction),
<code>tau2_m0</code>, <code>tau2_s0</code> and <code>w0</code> giving the prior mean and standard deviation of
smoothing prior (When iflagprior=1, tau2_m0 is only used as the hyperparameter),
<code>beta_m0</code> and <code>beta_v0</code> giving the hyperparameters of the
multivariate normal distribution for parametric part including intercept,
<code>alpha_m0</code> and <code>alpha_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the constant of integration,
<code>iflagpsi</code> determining the prior of slope for logisitic function in <code>S</code> or <code>U</code> shaped
(iflagpsi=1 (default), slope <code class="reqn">\psi</code> is sampled and iflagpsi=0, <code class="reqn">\psi</code> is fixed),
<code>psifixed</code> giving initial value (iflagpsi=1) or fixed value (iflagpsi=0) of slope,
<code>omega_m0</code> and <code>omega_s0</code> giving the prior mean and standard deviation of the
truncated normal prior distribution for the inflection point of <code>S</code> or <code>U</code> shaped function,
<code>kappa_m0</code> and <code>kappa_v0</code> giving the prior mean and variance of the
gammal prior distribution for dispersion parameter (negative-binomial). </p>
</td></tr>
<tr><td><code id="gbsar_+3A_shape">shape</code></td>
<td>
<p>			a vector giving types of shape restriction. </p>
</td></tr>
<tr><td><code id="gbsar_+3A_marginal.likelihood">marginal.likelihood</code></td>
<td>
<p>	a logical variable indicating whether the log marginal likelihood is calculated.
The methods of Gelfand and Dey (1994) and Newton and Raftery (1994) are used.</p>
</td></tr>
<tr><td><code id="gbsar_+3A_algorithm">algorithm</code></td>
<td>
<p> a description of the algorithm to be used in the fitting of the logistic model:
The algorithm contains the Gibbs sampler based on the Kolmogorov-Smirnov distribution (<code>KS</code>)
and an adaptive Metropolis algorithm (<code>AM</code>).</p>
</td></tr>
<tr><td><code id="gbsar_+3A_verbose">verbose</code></td>
<td>
<p> a logical variable. If <code>TRUE</code>, the iteration number and the Metropolis acceptance rate are printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a Bayesian generalized partial linear regression models
for estimating shape-restricted functions using Gaussian process priors.
For enforcing shape-restrictions, they assumed that the derivatives of the functions are squares of Gaussian processes.
</p>
<p>Let <code class="reqn">y_i</code> and <code class="reqn">w_i</code> be the response and the vector of parametric predictors, respectively.
Further, let <code class="reqn">x_{i,k}</code> be the covariate related to the response through an unknown shape-restricted function.
The model for estimating shape-restricted functions is as follows.
</p>
<p style="text-align: center;"><code class="reqn">y_i | \mu_i \sim F(\mu_i), </code>
</p>

<p style="text-align: center;"><code class="reqn">g(\mu_i) = w_i^T\beta + \sum_{k=1}^K f_k(x_{i,k}), ~ i=1,\ldots,n, </code>
</p>

<p>where <code class="reqn">g(\cdot)</code> is a link function and <code class="reqn">f_k</code> is an unknown nonlinear function of the scalar <code class="reqn">x_{i,k} \in [0,1]</code>.
</p>
<p>The prior of function without shape restriction is:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = Z(x), </code>
</p>

<p>where <code class="reqn">Z</code> is a second-order Gaussian process with mean function equal to zero and covariance function
<code class="reqn">\nu(s,t) = E[Z(s)Z(t)]</code> for <code class="reqn">s, t \in [0, 1]</code>. The Gaussian process is expressed with
the spectral representation based on cosine basis functions:
</p>
<p style="text-align: center;"><code class="reqn">Z(x) = \sum_{j=0}^\infty \theta_j\varphi_j(x)</code>
</p>

<p style="text-align: center;"><code class="reqn">\varphi_0(x) = 1 ~~ \code{and} ~~ \varphi_j(x) = \sqrt{2}\cos(\pi j x), ~ j \ge 1, ~ 0 \le x \le 1</code>
</p>

<p>The shape-restricted functions are modeled by assuming the <code class="reqn">q</code>th derivatives of <code class="reqn">f</code> are squares of Gaussian processes:
</p>
<p style="text-align: center;"><code class="reqn">f^{(q)}(x) = \delta Z^2(x)h(x), ~~ \delta \in \{1, -1\}, ~~ q \in \{1, 2\},</code>
</p>

<p>where <code class="reqn">h</code> is the squish function. For monotonic, monotonic convex, and concave functions, <code class="reqn">h(x)=1</code>, while
for <code>S</code> and <code>U</code> shaped functions, <code class="reqn">h</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">h(x) = \frac{1 - \exp[\psi(x - \omega)]}{1 + \exp[\psi(x - \omega)]}, ~~ \psi &gt; 0, ~~ 0 &lt; \omega &lt; 1</code>
</p>

<p>For the spectral coefficients of functions without shape constraints, the following prior is used
(The intercept is included in <code class="reqn">\beta</code>):
</p>
<p style="text-align: center;"><code class="reqn">\theta_j | \tau, \gamma \sim N(0, \tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>The priors for the spectral coefficients of shape restricted functions are:
</p>
<p style="text-align: center;"><code class="reqn">\theta_0 | \sim N(m_{\theta_0}, v^2_{\theta_0}), \quad
	\theta_j | \tau, \gamma \sim N(m_{\theta_j}, \tau^2\exp[-j\gamma]), ~ j \ge 1</code>
</p>

<p>To complete the model specification, the following prior is assumed for <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta | \sim N(m_{0,\beta}, V_{0,\beta})</code>
</p>



<h3>Value</h3>

<p>An object of class <code>bsam</code> representing the Bayesian spectral analysis model fit.
Generic functions such as <code>print</code>, <code>fitted</code> and <code>plot</code> have methods to show the results of the fit.
</p>
<p>The MCMC samples of the parameters in the model are stored in the list <code>mcmc.draws</code>,
the posterior samples of the fitted values are stored in the list <code>fit.draws</code>, and
the MCMC samples for the log marginal likelihood are saved in the list <code>loglik.draws</code>.
The output list also includes the following objects:
</p>
<table>
<tr><td><code>post.est</code></td>
<td>
<p>	posterior estimates for all parameters in the model. </p>
</td></tr>
<tr><td><code>lmarg.gd</code></td>
<td>
<p>	log marginal likelihood using Gelfand-Dey method. </p>
</td></tr>
<tr><td><code>lmarg.nr</code></td>
<td>
<p>	log marginal likelihood using Netwon-Raftery method, which is biased. </p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>	the family object used. </p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>		the link object used. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>		the matched call. </p>
</td></tr>
<tr><td><code>mcmctime</code></td>
<td>
<p>      running time of Markov chain from <code>system.time()</code>. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Jo, S., Choi, T., Park, B. and Lenk, P. (2019). bsamGP: An R Package for Bayesian Spectral Analysis Models
Using Gaussian Process Priors. <em>Journal of Statistical Software</em>, <b>90</b>, 310-320.
</p>
<p>Lenk, P. and Choi, T. (2017) Bayesian Analysis of Shape-Restricted Functions using
Gaussian Process Priors. <em>Statistica Sinica</em>, <b>27</b>, 43-69.
</p>
<p>Roberts, G. O. and Rosenthal, J. S. (2009) Examples of Adaptive MCMC. <em>Journal of Computational and Graphical Statistics</em>, <b>18</b>, 349-367.
</p>
<p>Holmes, C. C. and Held, L. (2006) Bayesian Auxiliary Variables Models for Binary and Multinomial Regression.
<em>Bayesian Analysis</em>, <b>1</b>, 145-168.
</p>
<p>Gelfand, A. E. and Dey, K. K. (1994) Bayesian model choice: asymptotics and exact calculations.
<em>Journal of the Royal Statistical Society. Series B - Statistical Methodology</em>, <b>56</b>, 501-514.
</p>
<p>Newton, M. A. and Raftery, A. E. (1994) Approximate Bayesian inference with the weighted likelihood bootstrap (with discussion).
<em>Journal of the Royal Statistical Society. Series B - Statistical Methodology</em>, <b>56</b>, 3-48.
</p>
<p>Albert, J. H. and Chib, S. (1993) Bayesian Analysis of Binary and Polychotomous Response Data.
<em>Journal of the American Statistical Association</em>, <b>88</b>, 669-679.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsaq">bsaq</a></code>, <code><a href="#topic+bsar">bsar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
###########################
# Probit Regression Model #
###########################

# Simulate data
set.seed(1)

f &lt;- function(x) 1.5 * sin(pi * x)

n &lt;- 1000
b &lt;- c(1,-1)
rho &lt;- 0.7
u  &lt;- runif(n, min = -1, max = 1)
x  &lt;- runif(n, min = -1, max = 1)
w1 &lt;- runif(n, min = -1, max = 1)
w2 &lt;- round(f(rho * x + (1 - rho) * u))
w  &lt;- cbind(w1, w2)

y  &lt;- w %*% b + f(x) + rnorm(n)
y &lt;- (y &gt; 0)

# Number of cosine basis functions
nbasis &lt;- 50

# Fit the model with default priors and mcmc parameters
fout &lt;- gbsar(y ~ w1 + w2 + fs(x), family = "bernoulli", link = "probit",
              nbasis = nbasis, shape = 'Free')

# Summary
print(fout); summary(fout)

# fitted values
fit &lt;- fitted(fout)

# Plot
plot(fit, ask = TRUE)

######################################
# Logistic Additive Regression Model #
######################################

# Wage-Union data
data(wage.union); attach(wage.union)

race[race==1 | race==2]=0
race[race==3]=1

y &lt;- union
w &lt;- cbind(race,sex,south)
x &lt;- cbind(wage,education,age)

# mcmc parameters
mcmc &lt;- list(nblow0 = 10000,
             nblow = 10000,
             nskip = 10,
             smcmc = 1000,
             ndisp = 1000,
             maxmodmet = 10)

foutGBSAR &lt;- gbsar(y ~ race + sex + south + fs(wage) + fs(education) + fs(age),
                   family = 'bernoulli', link = 'logit', nbasis = 50, mcmc = mcmc,
                   shape = c('Free','Decreasing','Increasing'))

# fitted values
fitGBSAR &lt;- fitted(foutGBSAR)

# Plot
plot(fitGBSAR, ask = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='intgrat'>
Numerical integration using a simple Trapezoidal rule
</h2><span id='topic+intgrat'></span>

<h3>Description</h3>

<p>Trapezoidal rule is a technique for approximating the definite integral.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intgrat(f, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intgrat_+3A_f">f</code></td>
<td>
<p>		Function values to be integrated. </p>
</td></tr>
<tr><td><code id="intgrat_+3A_delta">delta</code></td>
<td>
<p>		Spacing size. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>intgrat</code> returns the value of the intergral.
</p>

<hr>
<h2 id='intsim'>Numerical integration using Simpson's rule</h2><span id='topic+intsim'></span>

<h3>Description</h3>

<p>Simpson's rule is a method for numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  intsim(f, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intsim_+3A_f">f</code></td>
<td>
<p>		Function values to be integrated. </p>
</td></tr>
<tr><td><code id="intsim_+3A_delta">delta</code></td>
<td>
<p>		Spacing size. </p>
</td></tr>
</table>


<h3>Value</h3>

  
<p><code>intsim</code> returns the value of the intergral.
</p>

<hr>
<h2 id='London.Mortality'>Daily Moratlity in London</h2><span id='topic+London.Mortality'></span>

<h3>Description</h3>

<p>The London.Mortality data consists of daily death occurrences from Jan. 1st, 1993 to Dec. 31st, 2006 and corresponding weather observations including temperature and humidity in London.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(London.Mortality)</code></pre>


<h3>Format</h3>

<p>A data frame with 5113 observations on the following 7 variables.
</p>

<dl>
<dt>date</dt><dd><p>date in YYYY-MM-DD.</p>
</dd>
<dt>tmean</dt><dd><p>Mean temperature.</p>
</dd>
<dt>tmin</dt><dd><p>Minimum dry-bulb temperature.</p>
</dd>
<dt>tmax</dt><dd><p>Maximum dry-bulb temperature.</p>
</dd>
<dt>dewp</dt><dd><p>Dew point.</p>
</dd>
<dt>rh</dt><dd><p>Relative humidity.</p>
</dd>
<dt>death</dt><dd><p>the number of death occurences.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Office for National Statistics
</p>
<p>British Atmospheric Data Centre
</p>
<p>https://github.com/gasparrini/2015_gasparrini_Lancet_Rcodedata
</p>


<h3>References</h3>

<p>Armstrong BG, Chalabi Z, Fenn B, Hajat S, Kovats S, Milojevic A, Wilkinson P (2011). Association of mortality with high temperatures in a temperate climate: England and Wales. <em>Journal of Epidemiology &amp; Community Health</em>, <b>65</b>(4), 340â345.
</p>
<p>Gasparrini A, Armstrong B, Kovats S, Wilkinson P (2012). The effect of high temperatures on cause-specific mortality in England and Wales. <em>Occupational and Environmental Medicine</em>, <b>69</b>(1), 56â61.
</p>
<p>Gasparrini A, Guo Y, Hashizume M, Lavigne E, Zanobetti A, Schwartz J, Tobias A, Tong S, RocklÃ¶v J, Forsberg B, et al.(2015). Mortality risk attributable to high and low ambient temperature: a multicountry observational study. 
<em>The Lancet</em>, <b>386</b>(9991), 369-375. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(London.Mortality)

## End(Not run)
</code></pre>

<hr>
<h2 id='plasma'>A Data Set for Plasma Levels of Retinol and Beta-Carotene</h2><span id='topic+plasma'></span>

<h3>Description</h3>

<p>This data set contains 314 observations on 14 variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(plasma)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>age</code></dt><dd><p>Age (years).</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex (1=Male, 2=Female).</p>
</dd>
<dt><code>smoke</code></dt><dd><p>Smoking status (1=Never, 2=Former, 3=Current Smoker).</p>
</dd>
<dt><code>vmi</code></dt><dd><p>BMI values (weight/(height^2)).</p>
</dd>
<dt><code>vitas</code></dt><dd><p>Vitamin use (1=Yes,fairly often, 2=Yes, not often, 3=No).</p>
</dd>
<dt><code>calories</code></dt><dd><p>Number of calories consumed per day.</p>
</dd>
<dt><code>fat</code></dt><dd><p>Grams of fat consumed per day.</p>
</dd>
<dt><code>fiber</code></dt><dd><p>Grams of fiber consumed per day.</p>
</dd>
<dt><code>alcohol</code></dt><dd><p>Number of alcoholic drinks consumed per week.</p>
</dd>
<dt><code>cholesterol</code></dt><dd><p>Cholesterol consumed (mg per day).</p>
</dd>
<dt><code>beta diet</code></dt><dd><p>Dietary beta-carotene consumed (mcg per day).</p>
</dd>
<dt><code>reedit</code></dt><dd><p>Dietary retinol consumed (mcg per day).</p>
</dd>
<dt><code>betaplasma</code></dt><dd><p>Plasma beta-carotene (ng/ml).</p>
</dd>
<dt><code>retplasma</code></dt><dd><p>Plasma Retinol (ng/ml).</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://lib.stat.cmu.edu/datasets/Plasma_Retinol">https://lib.stat.cmu.edu/datasets/Plasma_Retinol</a></p>


<h3>References</h3>

<p>Nierenberg, D. W., Stukel, T. A., Baron, J. A., Dain, B. J., and Greenberg, E. R. (1989).
Determinants of plasma levels of beta-carotene and retinol. <em>American Journal of Epidemiology</em>, <b>130</b>, 511-521.
</p>
<p>Meyer, M. C., Hackstadt, A. J., and Hoeting, J. A. (2011).
Bayesian estimation and inference for generalized partial linear models using shape-restricted splines.
<em>Journal of Nonparametric Statistics</em>, <b>23</b>(4), 867-884.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(plasma)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.blm'> Plot a blm object</h2><span id='topic+plot.blm'></span>

<h3>Description</h3>

<p>Plots the posterior samples for Bayesian linear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.blm_+3A_x">x</code></td>
<td>
<p> a <code>blm</code> object</p>
</td></tr>
<tr><td><code id="plot.blm_+3A_...">...</code></td>
<td>
<p> other options to pass to the plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot.</p>


<h3>See Also</h3>

<p><code><a href="#topic+blq">blq</a></code>, <code><a href="#topic+blr">blr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for blq and blr
</code></pre>

<hr>
<h2 id='plot.bsad'> Plot a bsad object</h2><span id='topic+plot.bsad'></span>

<h3>Description</h3>

<p>Plots the posterior samples for Bayesian semiparametric density estimation using a logistic Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsad'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bsad_+3A_x">x</code></td>
<td>
<p> a <code>bsad</code> object</p>
</td></tr>
<tr><td><code id="plot.bsad_+3A_...">...</code></td>
<td>
<p> other options to pass to the plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsad">bsad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for bsad
</code></pre>

<hr>
<h2 id='plot.bsam'> Plot a bsam object</h2><span id='topic+plot.bsam'></span>

<h3>Description</h3>

<p>Plots the posterior samples for Bayesian spectral analysis models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsam'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bsam_+3A_x">x</code></td>
<td>
<p> a <code>bsam</code> object</p>
</td></tr>
<tr><td><code id="plot.bsam_+3A_...">...</code></td>
<td>
<p> other options to pass to the plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsaq">bsaq</a></code>, <code><a href="#topic+bsaqdpm">bsaqdpm</a></code>, <code><a href="#topic+bsar">bsar</a></code>, <code><a href="#topic+bsardpm">bsardpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for bsaq, bsaqdpm, bsar, and bsardpm
</code></pre>

<hr>
<h2 id='plot.bsamdpm'> Plot a bsamdpm object</h2><span id='topic+plot.bsamdpm'></span>

<h3>Description</h3>

<p>Plots the posterior samples for Bayesian spectral analysis models with Dirichlet process mixture error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsamdpm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bsamdpm_+3A_x">x</code></td>
<td>
<p> a <code>bsamdpm</code> object</p>
</td></tr>
<tr><td><code id="plot.bsamdpm_+3A_...">...</code></td>
<td>
<p> other options to pass to the plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsaqdpm">bsaqdpm</a></code>, <code><a href="#topic+bsardpm">bsardpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for bsaqdpm and bsardpm
</code></pre>

<hr>
<h2 id='plot.fitted.bsad'>Plot a fitted.bsad object</h2><span id='topic+plot.fitted.bsad'></span>

<h3>Description</h3>

<p>Plots the predictive density for Bayesian density estimation model using logistic Gaussian process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted.bsad'
plot(x, ggplot2, legend.position, nbins, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fitted.bsad_+3A_x">x</code></td>
<td>
<p> a <code>fitted.bsad</code> object</p>
</td></tr>
<tr><td><code id="plot.fitted.bsad_+3A_ggplot2">ggplot2</code></td>
<td>
<p>a logical variable. If <code>TRUE</code> the <code>ggplot2</code> package is used.</p>
</td></tr>
<tr><td><code id="plot.fitted.bsad_+3A_legend.position">legend.position</code></td>
<td>
<p>the position of legends (&ldquo;none&rdquo;, &ldquo;left&rdquo;, &ldquo;right&rdquo;, &ldquo;bottom&rdquo;, &ldquo;top&rdquo;). It is used when <code>ggplot2 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.fitted.bsad_+3A_nbins">nbins</code></td>
<td>
<p>Number of bins used. Default is 30.</p>
</td></tr>
<tr><td><code id="plot.fitted.bsad_+3A_...">...</code></td>
<td>
<p> other options to pass to the plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsad">bsad</a></code>, <code><a href="#topic+fitted.bsad">fitted.bsad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example for bsad
</code></pre>

<hr>
<h2 id='plot.fitted.bsam'> Plot a fitted.bsam object</h2><span id='topic+plot.fitted.bsam'></span>

<h3>Description</h3>

<p>Plots the data and the fit for Bayesian spectral analysis models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted.bsam'
plot(x, type, ask, ggplot2, legend.position, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fitted.bsam_+3A_x">x</code></td>
<td>
<p> a <code>fitted.bsam</code> object</p>
</td></tr>
<tr><td><code id="plot.fitted.bsam_+3A_type">type</code></td>
<td>
<p> the type of fitted plot. The default is on the scale of the response variable<code>type="response"</code>; the alternative <code>type="term"</code> is on the scale of the nonparametric predictor. Note that this affects only on glm type models. For example, binomial model with the default option gives the predicted probabilites.</p>
</td></tr>
<tr><td><code id="plot.fitted.bsam_+3A_ask">ask</code></td>
<td>
<p>see. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.fitted.bsam_+3A_ggplot2">ggplot2</code></td>
<td>
<p>a logical variable. If <code>TRUE</code> the <code>ggplot2</code> package is used.</p>
</td></tr>
<tr><td><code id="plot.fitted.bsam_+3A_legend.position">legend.position</code></td>
<td>
<p>the position of legends (&ldquo;none&rdquo;, &ldquo;left&rdquo;, &ldquo;right&rdquo;, &ldquo;bottom&rdquo;, &ldquo;top&rdquo;). It is used when <code>ggplot2 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.fitted.bsam_+3A_...">...</code></td>
<td>
<p> other options to pass to the plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsaq">bsaq</a></code>, <code><a href="#topic+bsaqdpm">bsaqdpm</a></code>, <code><a href="#topic+bsar">bsar</a></code>, <code><a href="#topic+bsardpm">bsardpm</a></code>, <code><a href="#topic+fitted.bsam">fitted.bsam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for bsaq, bsaqdpm, bsar, and bsardpm
</code></pre>

<hr>
<h2 id='plot.fitted.bsamdpm'> Plot a fitted.bsamdpm object</h2><span id='topic+plot.fitted.bsamdpm'></span>

<h3>Description</h3>

<p>Plots the data and the fit for Bayesian spectral analysis models with Dirichlet process mixture error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted.bsamdpm'
plot(x, ask, ggplot2, legend.position, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fitted.bsamdpm_+3A_x">x</code></td>
<td>
<p> a <code>fitted.bsamdpm</code> object</p>
</td></tr>
<tr><td><code id="plot.fitted.bsamdpm_+3A_ask">ask</code></td>
<td>
<p>see. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.fitted.bsamdpm_+3A_ggplot2">ggplot2</code></td>
<td>
<p>a logical variable. If <code>TRUE</code> the <code>ggplot2</code> package is used.</p>
</td></tr>
<tr><td><code id="plot.fitted.bsamdpm_+3A_legend.position">legend.position</code></td>
<td>
<p>the position of legends (&ldquo;none&rdquo;, &ldquo;left&rdquo;, &ldquo;right&rdquo;, &ldquo;bottom&rdquo;, &ldquo;top&rdquo;). It is used when <code>ggplot2 = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.fitted.bsamdpm_+3A_...">...</code></td>
<td>
<p> other options to pass to the plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsaqdpm">bsaqdpm</a></code>, <code><a href="#topic+bsardpm">bsardpm</a></code>, <code><a href="#topic+fitted.bsamdpm">fitted.bsamdpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for bsaqdpm and bsardpm
</code></pre>

<hr>
<h2 id='predict.blm'> Predict method for a blm object</h2><span id='topic+predict.blm'></span>

<h3>Description</h3>

<p>Computes predicted values of Bayesian linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'blm'
predict(object, newdata, alpha = 0.05, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.blm_+3A_object">object</code></td>
<td>
<p>  a <code>bsam</code> object</p>
</td></tr>
<tr><td><code id="predict.blm_+3A_newdata">newdata</code></td>
<td>
<p> an optional data matrix or vector with which to predict. If omitted, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.blm_+3A_alpha">alpha</code></td>
<td>
<p>	  a numeric scalar in the interval (0,1) giving the <code class="reqn">100(1-\alpha)</code>% credible intervals.</p>
</td></tr>
<tr><td><code id="predict.blm_+3A_hpd">HPD</code></td>
<td>
<p>     a logical variable indicating whether the <code class="reqn">100(1-\alpha)</code>% Highest Posterior Density (HPD) intervals are calculated.
If <code>HPD</code>=FALSE, the <code class="reqn">100(1-\alpha)</code>% equal-tail credible intervals are calculated.
The default is TRUE.</p>
</td></tr>
<tr><td><code id="predict.blm_+3A_...">...</code></td>
<td>
<p>  not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>None.
</p>


<h3>Value</h3>

<p>A list containing posterior means and 95% credible intervals.
</p>
<p>The output list includes the following objects:
</p>
<table>
<tr><td><code>wbeta</code></td>
<td>
<p>	posterior estimates for regression function.</p>
</td></tr>
<tr><td><code>yhat</code></td>
<td>
<p>	posterior estimates for generalised regression function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chen, M., Shao, Q. and Ibrahim, J. (2000) <em>Monte Carlo Methods in Bayesian computation</em>.
Springer-Verlag New York, Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blq">blq</a></code>, <code><a href="#topic+blr">blr</a></code>, <code><a href="#topic+gblr">gblr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	#####################
	# Simulated example #
	#####################

	# Simulate data
	  set.seed(1)

	  n &lt;- 100
	  w &lt;- runif(n)
	  y &lt;- 3 + 2*w + rnorm(n, sd = 0.8)

	  # Fit the model with default priors and mcmc parameters
	  fout &lt;- blr(y ~ w)

	  # Predict
	  new &lt;- rnorm(n)
	  predict(fout, newdata = new)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.bsam'>Predict method for a bsam object</h2><span id='topic+predict.bsam'></span>

<h3>Description</h3>

<p>Computes the predicted values of Bayesian spectral analysis models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsam'
predict(object, newp, newnp, alpha = 0.05, HPD = TRUE, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bsam_+3A_object">object</code></td>
<td>
<p> a <code>bsam</code> object</p>
</td></tr>
<tr><td><code id="predict.bsam_+3A_newp">newp</code></td>
<td>
<p>   an optional data of parametric components with which to predict. If omitted, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.bsam_+3A_newnp">newnp</code></td>
<td>
<p>  an optional data of nonparametric components with which to predict. If omitted, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.bsam_+3A_alpha">alpha</code></td>
<td>
<p>	 a numeric scalar in the interval (0,1) giving the <code class="reqn">100(1-\alpha)</code>% credible intervals.</p>
</td></tr>
<tr><td><code id="predict.bsam_+3A_hpd">HPD</code></td>
<td>
<p>    a logical variable indicating whether the <code class="reqn">100(1-\alpha)</code>% Highest Posterior Density (HPD) intervals are calculated.
If <code>HPD</code>=FALSE, the <code class="reqn">100(1-\alpha)</code>% equal-tail credible intervals are calculated.
The default is TRUE.</p>
</td></tr>
<tr><td><code id="predict.bsam_+3A_type">type</code></td>
<td>
<p>  the type of prediction required. <code>type = "response"</code> gives the posterior predictive samples as default. The <code>"mean"</code> option returns expectation of the posterior estimates. </p>
</td></tr>
<tr><td><code id="predict.bsam_+3A_...">...</code></td>
<td>
<p>  not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>None.
</p>


<h3>Value</h3>

<p>A list object of class <code>predict.bsam</code> containing posterior means and <code class="reqn">100(1-\alpha)</code>% credible intervals.
</p>
<p>The output list includes the following objects:
</p>
<table>
<tr><td><code>fxobs</code></td>
<td>
<p>	posterior estimates for unknown functions over observation.</p>
</td></tr>
<tr><td><code>wbeta</code></td>
<td>
<p>	posterior estimates for parametric part.</p>
</td></tr>
<tr><td><code>yhat</code></td>
<td>
<p>	posterior estimates for fitted values of either response or expectation of response.
For <code><a href="#topic+gbsar">gbsar</a></code>, it gives posterior estimates for expectation of response.</p>
</td></tr>
<tr><td><code>fxResid</code></td>
<td>
<p> posterior estimates for fitted parametric residuals. Not applicable for <code><a href="#topic+gbsar">gbsar</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bsaq">bsaq</a></code>, <code><a href="#topic+bsar">bsar</a></code>, <code><a href="#topic+gbsar">gbsar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##########################################
# Increasing Convex to Concave (S-shape) #
##########################################

# simulate data
f &lt;- function(x) 5*exp(-10*(x - 1)^4) + 5*x^2

set.seed(1)

n &lt;- 100
x &lt;- runif(n)
y &lt;- f(x) + rnorm(n, sd = 1)

# Number of cosine basis functions
nbasis &lt;- 50

# Fit the model with default priors and mcmc parameters
fout &lt;- bsar(y ~ fs(x), nbasis = nbasis, shape = 'IncreasingConvex',
             spm.adequacy = TRUE)

# Prediction
xnew &lt;- runif(n)
predict(fout, newnp = xnew)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.bsamdpm'>Predict method for a bsamdpm object</h2><span id='topic+predict.bsamdpm'></span>

<h3>Description</h3>

<p>Computes the predicted values of Bayesian spectral analysis models with Dirichlet process mixture errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsamdpm'
predict(object, newp, newnp, alpha = 0.05, HPD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bsamdpm_+3A_object">object</code></td>
<td>
<p> a <code>bsamdpm</code> object</p>
</td></tr>
<tr><td><code id="predict.bsamdpm_+3A_newp">newp</code></td>
<td>
<p>   an optional data of parametric components with which to predict. If omitted, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.bsamdpm_+3A_newnp">newnp</code></td>
<td>
<p>  an optional data of nonparametric components with which to predict. If omitted, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.bsamdpm_+3A_alpha">alpha</code></td>
<td>
<p>	 a numeric scalar in the interval (0,1) giving the <code class="reqn">100(1-\alpha)</code>% credible intervals.</p>
</td></tr>
<tr><td><code id="predict.bsamdpm_+3A_hpd">HPD</code></td>
<td>
<p>    a logical variable indicating whether the <code class="reqn">100(1-\alpha)</code>% Highest Posterior Density (HPD) intervals are calculated.
If <code>HPD</code>=FALSE, the <code class="reqn">100(1-\alpha)</code>% equal-tail credible intervals are calculated.
The default is TRUE.</p>
</td></tr>
<tr><td><code id="predict.bsamdpm_+3A_...">...</code></td>
<td>
<p>  not used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>None.
</p>


<h3>Value</h3>

<p>A list object of class <code>predict.bsamdpm</code> containing posterior means and <code class="reqn">100(1-\alpha)</code>% credible intervals.
</p>
<p>The output list includes the following objects:
</p>
<table>
<tr><td><code>fxobs</code></td>
<td>
<p>	posterior estimates for unknown functions over observation.</p>
</td></tr>
<tr><td><code>wbeta</code></td>
<td>
<p>	posterior estimates for parametric part.</p>
</td></tr>
<tr><td><code>yhat</code></td>
<td>
<p>	posterior estimates for fitted values of response.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bsaqdpm">bsaqdpm</a></code>, <code><a href="#topic+bsardpm">bsardpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#####################
# Increasing-convex #
#####################

# Simulate data
set.seed(1)

n &lt;- 200
x &lt;- runif(n)
e &lt;- c(rnorm(n/2, sd = 0.5), rnorm(n/2, sd = 3))
y &lt;- exp(6*x - 3) + e

# Number of cosine basis functions
nbasis &lt;- 50

# Fit the model with default priors and mcmc parameters
fout &lt;- bsardpm(y ~ fs(x), nbasis = nbasis, shape = 'IncreasingConvex')

# Prediction
xnew &lt;- runif(n)
predict(fout, newnp = xnew)


## End(Not run)
</code></pre>

<hr>
<h2 id='rald'>The asymmetric Laplace distribution</h2><span id='topic+rald'></span><span id='topic+rald'></span>

<h3>Description</h3>

<p>Density for and random values from a three-parameter asymmetric
Laplace distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rald(n, location=0, scale=1, p=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rald_+3A_n">n</code></td>
<td>
<p>		Number of random values to be generated. </p>
</td></tr>
<tr><td><code id="rald_+3A_location">location</code></td>
<td>
<p>	Location parameter. </p>
</td></tr>
<tr><td><code id="rald_+3A_scale">scale</code></td>
<td>
<p>		Scale parameter. </p>
</td></tr>
<tr><td><code id="rald_+3A_p">p</code></td>
<td>
<p>		Skewness parameter. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function generates a random variable from an asymmetric Laplace distribution (ALD).
The ALD has the following probability density function:
</p>
<p style="text-align: center;"><code class="reqn">ALD_p(x ; \mu, \sigma) = \frac{p(1-p)}{\sigma}\exp\Big(-\frac{(x-\mu)[p-I(x\le\mu)]}{\sigma}\Big),</code>
</p>

<p>where <code class="reqn">0 &lt; p &lt; 1</code> is the skew parameter, <code class="reqn">\sigma &gt; 0</code> is the scale parameter, <code class="reqn">-\infty &lt; \mu &lt; \infty</code>
is the location parameter, and <code class="reqn">I(\cdot)</code> is the indication function. The range of <code class="reqn">x</code> is <code class="reqn">(-\infty, \infty)</code>.
</p>


<h3>Value</h3>

  
<p><code>rald</code> gives out a vector of random numbers generated by
the asymmetric Laplace distribution.
</p>


<h3>References</h3>

<p>Koenker, R. and Machado, J. (1999). Goodness of fit and related inference processes for quantile regression. 
<em>Journal of the American Statistical Association</em>, <b>94</b>(3), 1296-1309.
</p>
<p>Yu, K. and Zhang, J. (2005). A Three-parameter asymmetric Laplace distribution and its extension.
<em>Communications in Statistics - Theory and Methods</em>, <b>34</b>, 1867-1879.
</p>

<hr>
<h2 id='traffic'>Monthly traffic accidents data</h2><span id='topic+traffic'></span>

<h3>Description</h3>

<p>This data set contains 108 observations on 6 variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(traffic)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>ln_number</code></dt><dd><p>logarithm of the number of monthly automobile accidents in the state of Michigan.</p>
</dd>
<dt><code>month</code></dt><dd><p>months from January 1st, 1979 to Decembe 31st, 1987.</p>
</dd>
<dt><code>ln_unemp</code></dt><dd><p>logarithm of unemployment rate</p>
</dd>
<dt><code>spring</code></dt><dd><p>indicator for spring season.</p>
</dd>
<dt><code>summer</code></dt><dd><p>indicator for summer season.</p>
</dd>
<dt><code>fall</code></dt><dd><p>indicator for fall season.</p>
</dd>
</dl>



<h3>References</h3>

<p>Lenk (1999) Bayesian inference for semiparametric regression using a Fourier representation. 
<em>Journal of the Royal Statistical Society: Series B</em>, <b>61</b>(4), 863-879. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(traffic)
	pairs(traffic)

## End(Not run)
</code></pre>

<hr>
<h2 id='wage.union'>Wage-Union data</h2><span id='topic+wage.union'></span>

<h3>Description</h3>

<p>This data set contains 534 observations on 11 variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wage.union)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>education</code></dt><dd><p>number of years of education.</p>
</dd>
<dt><code>south</code></dt><dd><p>indicator of living in southern region of U.S.A.</p>
</dd>
<dt><code>sex</code></dt><dd><p>gender indicator: 0=male,1=female.</p>
</dd>
<dt><code>experience</code></dt><dd><p>number of years of work experience.</p>
</dd>
<dt><code>union</code></dt><dd><p>indicator of trade union membership: 0=non-member, 1=member.</p>
</dd>
<dt><code>wage</code></dt><dd><p>wages in dollars per hour.</p>
</dd>
<dt><code>age</code></dt><dd><p>age in years.</p>
</dd>
<dt><code>race</code></dt><dd><p>1=black, 2=Hispanic, 3=white.</p>
</dd>
<dt><code>occupation</code></dt><dd><p>1=management, 2=sales, 3=clerical, 4=service, 5=professional, 6=other.</p>
</dd>
<dt><code>sector</code></dt><dd><p>0=other, 1=manufacturing, 2=construction.</p>
</dd>
<dt><code>married</code></dt><dd><p>indicator of being married: 0=unmarried, 1=married.</p>
</dd>
</dl>



<h3>References</h3>

<p>Berndt, E.R. (1991) <em>The Practice of Econometrics</em>. New York: Addison-Wesley.
</p>
<p>Ruppert, D., Wand, M.P. and Carroll, R.J. (2003) <em>Semiparametric Regression</em>. Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(wage.union)
	pairs(wage.union)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
