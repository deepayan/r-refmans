<!DOCTYPE html><html><head><title>Help for package psBayesborrow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {psBayesborrow}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#psBayesborrow-package'><p>The 'psBayesborrow' package.</p></a></li>
<li><a href='#commensurate.bin'><p>Bayesian analysis with commensurate prior for binary outcome</p></a></li>
<li><a href='#commensurate.cont'><p>Bayesian analysis with commensurate prior for continuous outcome</p></a></li>
<li><a href='#commensurate.t2e'><p>Bayesian analysis with commensurate prior for time-to-event outcome</p></a></li>
<li><a href='#datagen'><p>Generate multivariate correlated data</p></a></li>
<li><a href='#psborrow.bin'><p>Simulation study of hybrid control design with Bayesian dynamic borrowing</p>
incorporating propensity score matched external control: binary outcome</a></li>
<li><a href='#psborrow.cont'><p>Simulation study of hybrid control design with Bayesian dynamic borrowing</p>
incorporating propensity score matched external control: continuous outcome</a></li>
<li><a href='#psborrow.summary'><p>Summarizing simulation study results</p></a></li>
<li><a href='#psborrow.t2e'><p>Simulation study of hybrid control design with Bayesian dynamic borrowing</p>
incorporating propensity score matched external control: time-to-event outcome</a></li>
<li><a href='#psmatch'><p>Propensity score matching</p></a></li>
<li><a href='#trial.simulation.bin'><p>Simulating binary data for current trial and external control</p></a></li>
<li><a href='#trial.simulation.cont'><p>Simulating continuous data for current trial and external control</p></a></li>
<li><a href='#trial.simulation.t2e'><p>Simulating time-to-event data for current trial and external control</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Information Borrowing with Propensity Score Matching</td>
</tr>
<tr>
<td>Description:</td>
<td>Hybrid control design is a way to borrow information from external controls to augment concurrent controls in a randomized controlled trial and is expected to overcome the feasibility issue when adequate randomized controlled trials cannot be conducted. A major challenge in the hybrid control design is its inability to eliminate a prior-data conflict caused by systematic imbalances in measured or unmeasured confounding factors between patients in the concurrent treatment/control group and external controls. To prevent the prior-data conflict, a combined use of propensity score matching and Bayesian commensurate prior has been proposed in the context of hybrid control design. The propensity score matching is first performed to guarantee the balance in baseline characteristics, and then the Bayesian commensurate prior is constructed while discounting the information based on the similarity in outcomes between the concurrent and external controls. 'psBayesborrow' is a package to implement the propensity score matching and the Bayesian analysis with commensurate prior, as well as to conduct a simulation study to assess operating characteristics of the hybrid control design, where users can choose design parameters in flexible and straightforward ways depending on their own application.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, copula, Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1),
rstan (&ge; 2.18.1), rstantools (&ge; 2.2.0), boot, MatchIt,
optmatch, survival, e1071, overlapping, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 21:55:35 UTC; API18340</td>
</tr>
<tr>
<td>Author:</td>
<td>Yusuke Yamaguchi [aut, cre],
  Jun Takeda [aut],
  Kentaro Takeda [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yusuke Yamaguchi &lt;yamagubed@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='psBayesborrow-package'>The 'psBayesborrow' package.</h2><span id='topic+psBayesborrow-package'></span><span id='topic+psBayesborrow'></span>

<h3>Description</h3>

<p>A DESCRIPTION OF THE PACKAGE
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Yusuke Yamaguchi <a href="mailto:yamagubed@gmail.com">yamagubed@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jun Takeda
</p>
</li>
<li><p> Kentaro Takeda
</p>
</li></ul>



<h3>References</h3>

<p>Stan Development Team (NA). RStan: the R interface to Stan. R package version 2.26.13. https://mc-stan.org
</p>

<hr>
<h2 id='commensurate.bin'>Bayesian analysis with commensurate prior for binary outcome</h2><span id='topic+commensurate.bin'></span>

<h3>Description</h3>

<p>Bayesian analysis for binary outcome is implemented via MCMC, where a
commensurate prior is used for incorporating data from external controls.
No borrowing and full borrowing are also applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commensurate.bin(
  formula, data, method.borrow,
  chains=2, iter=4000, warmup=floor(iter/2), thin=1,
  alternative="greater", sig.level=0.025,
  seed=sample.int(.Machine$integer.max,1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commensurate.bin_+3A_formula">formula</code></td>
<td>
<p>Object of class <code>formula</code>, which is a symbolic
description of the model to be fitted. The explanatory variables only include
covariates of interest, which must be specified in the form of linear
combination.</p>
</td></tr>
<tr><td><code id="commensurate.bin_+3A_data">data</code></td>
<td>
<p>Data frame, which must have variables named <code>study</code> for
study indicator (0 for external control, and 1 for current trial) and
<code>treat</code> for treatment indicator (0 for concurrent and external control,
and 1 for treatment).</p>
</td></tr>
<tr><td><code id="commensurate.bin_+3A_method.borrow">method.borrow</code></td>
<td>
<p>List of information borrowing method. <code>"noborrow"</code>
uses the concurrent data only. <code>"fullborrow"</code> uses the external control
data without discounting. <code>"cauchy"</code> uses the commensurate prior to
dynamically borrow the external control data, and the commensurability
parameter is assumed to follow a half-Cauchy distribution. <code>"normal"</code>
uses the commensurate prior to dynamically borrow the external control data,
and the commensurability parameter is assumed to follow a half-normal
distribution. <code>"cauchy"</code> and <code>"normal"</code> require to specify the
scale parameter <code>scale</code> of half-Cauchy and half-normal distribution
respectively.</p>
</td></tr>
<tr><td><code id="commensurate.bin_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains in MCMC sampling. The default value is
<code>chains=2</code>.</p>
</td></tr>
<tr><td><code id="commensurate.bin_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for each chain (including warmup) in MCMC
sampling. The default value is <code>iter=4000</code>.</p>
</td></tr>
<tr><td><code id="commensurate.bin_+3A_warmup">warmup</code></td>
<td>
<p>Number of warmup (aka burnin) iterations per chain in MCMC
sampling. The default value is <code>warmup=floor(iter/2)</code>.</p>
</td></tr>
<tr><td><code id="commensurate.bin_+3A_thin">thin</code></td>
<td>
<p>Period for saving samples in MCMC sampling. The default value
is <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="commensurate.bin_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hypothesis to be tested (&quot;greater&quot; or &quot;less&quot;).
The default value is <code>alternative="greater"</code>.</p>
</td></tr>
<tr><td><code id="commensurate.bin_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level. The default value is
<code>sig.level=0.025</code>.</p>
</td></tr>
<tr><td><code id="commensurate.bin_+3A_seed">seed</code></td>
<td>
<p>Setting a seed for MCMC sampling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The binary outcome is assumed to follow a binomial distribution.
Given more than one covariates, a logistic regression model is built
and its Bayesian estimation is performed via MCMC. Commensurate prior is used
to dynamically discount the information to be borrowed from external control
based on the similarity between the current trial and external controls,
where the commensurability parameter determines the extent of borrowing. The
commensurability parameter is assumed to follow a half-cauchy or a
half-normal distribution, and its scale parameter needs to be carefully
specified. No borrowing approach is to perform the analysis without
incorporating the external controls. Full borrowing approach is just to pool
the concurrent and external controls, which is used as a comparator in the
analysis.
</p>


<h3>Value</h3>

<p>The <code>commensurate.cont</code> returns a list containing the following objects:
</p>
<table>
<tr><td><code>reject</code></td>
<td>
<p>Data frame containing results of Bayesian one-sided hypothesis
testing (whether or not the posterior probability that the log odds ratio
is greater or less than 0 exceeds 1 minus significance level): <code>TRUE</code>
when significant, otherwise <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Data frame containing posterior mean, median, and sd of log
odds ratio.</p>
</td></tr>
<tr><td><code>stan.obj</code></td>
<td>
<p>Stanfit object.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hobbs BP, Carlin BP, Mandrekar SJ, Sargent DJ. Hierarchical commensurate and
power prior models for adaptive incorporation of historical information in
clinical trials. <em>Biometrics</em> 2011; 67:1047-1056.
</p>
<p>Hobbs BP, Sargent DJ, Carlin BP. Commensurate priors for incorporating
historical information in clinical trials using general and generalized
linear models. <em>Bayesian Analysis</em> 2012; 7:639-674.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT  &lt;- 100
n.CC  &lt;- 50
n.ECp &lt;- 200

out.prob.CT &lt;- 0.2
out.prob.CC &lt;- 0.2
driftOR     &lt;- 1.0

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.9,0.9)

indata &lt;- trial.simulation.bin(
  n.CT=n.CT, n.CC=n.CC, n.ECp=n.ECp,
  out.prob.CT=out.prob.CT, out.prob.CC=out.prob.CC, driftOR=driftOR,
  cov.C=cov.C, cov.cor.C=cov.cor.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect)

n.EC &lt;- 50

method.whomatch &lt;- "conc.treat"
method.matching &lt;- "optimal"
method.psorder  &lt;- NULL

out.psmatch &lt;- psmatch(
  study~cov1+cov2, data=indata, n.EC=n.EC,
  method.whomatch=method.whomatch, method.matching=method.matching,
  method.psorder=method.psorder)

indata.match &lt;- rbind(indata[indata$study==1,],indata[out.psmatch$subjid.EC,])

method.borrow &lt;- list(list(prior="cauchy",scale=2.0),
                      list(prior="normal",scale=0.5))

commensurate.bin(y~cov1,data=indata.match,method.borrow=method.borrow,chains=1,iter=100)
</code></pre>

<hr>
<h2 id='commensurate.cont'>Bayesian analysis with commensurate prior for continuous outcome</h2><span id='topic+commensurate.cont'></span>

<h3>Description</h3>

<p>Bayesian analysis for continuous outcome is implemented via MCMC, where a
commensurate prior is used for incorporating data from external controls.
No borrowing and full borrowing are also applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commensurate.cont(
  formula, data, method.borrow,
  chains=2, iter=4000, warmup=floor(iter/2), thin=1,
  alternative="greater", sig.level=0.025,
  seed=sample.int(.Machine$integer.max,1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commensurate.cont_+3A_formula">formula</code></td>
<td>
<p>Object of class <code>formula</code>, which is a symbolic
description of the model to be fitted. The explanatory variables only include
covariates of interest, which must be specified in the form of linear
combination.</p>
</td></tr>
<tr><td><code id="commensurate.cont_+3A_data">data</code></td>
<td>
<p>Data frame, which must have variables named <code>study</code> for
study indicator (0 for external control, and 1 for current trial) and
<code>treat</code> for treatment indicator (0 for concurrent and external control,
and 1 for treatment).</p>
</td></tr>
<tr><td><code id="commensurate.cont_+3A_method.borrow">method.borrow</code></td>
<td>
<p>List of information borrowing method. <code>"noborrow"</code>
uses the concurrent data only. <code>"fullborrow"</code> uses the external control
data without discounting. <code>"cauchy"</code> uses the commensurate prior to
dynamically borrow the external control data, and the commensurability
parameter is assumed to follow a half-Cauchy distribution. <code>"normal"</code>
uses the commensurate prior to dynamically borrow the external control data,
and the commensurability parameter is assumed to follow a half-normal
distribution. <code>"cauchy"</code> and <code>"normal"</code> require to specify the
scale parameter <code>scale</code> of half-Cauchy and half-normal distribution
respectively.</p>
</td></tr>
<tr><td><code id="commensurate.cont_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains in MCMC sampling. The default value is
<code>chains=2</code>.</p>
</td></tr>
<tr><td><code id="commensurate.cont_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for each chain (including warmup) in MCMC
sampling. The default value is <code>iter=4000</code>.</p>
</td></tr>
<tr><td><code id="commensurate.cont_+3A_warmup">warmup</code></td>
<td>
<p>Number of warmup (aka burnin) iterations per chain in MCMC
sampling. The default value is <code>warmup=floor(iter/2)</code>.</p>
</td></tr>
<tr><td><code id="commensurate.cont_+3A_thin">thin</code></td>
<td>
<p>Period for saving samples in MCMC sampling. The default value
is <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="commensurate.cont_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hypothesis to be tested (&quot;greater&quot; or &quot;less&quot;).
The default value is <code>alternative="greater"</code>.</p>
</td></tr>
<tr><td><code id="commensurate.cont_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level. The default value is
<code>sig.level=0.025</code>.</p>
</td></tr>
<tr><td><code id="commensurate.cont_+3A_seed">seed</code></td>
<td>
<p>Setting a seed for MCMC sampling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The continuous outcome is assumed to follow a normal distribution.
Given more than one covariates, a normal linear regression model is built
and its Bayesian estimation is performed via MCMC. Commensurate prior is used
to dynamically discount the information to be borrowed from external control
based on the similarity between the current trial and external controls,
where the commensurability parameter determines the extent of borrowing. The
commensurability parameter is assumed to follow a half-cauchy or a
half-normal distribution, and its scale parameter needs to be carefully
specified. No borrowing approach is to perform the analysis without
incorporating the external controls. Full borrowing approach is just to pool
the concurrent and external controls, which is used as a comparator in the
analysis.
</p>


<h3>Value</h3>

<p>The <code>commensurate.cont</code> returns a list containing the following objects:
</p>
<table>
<tr><td><code>reject</code></td>
<td>
<p>Data frame containing results of Bayesian one-sided hypothesis
testing (whether or not the posterior probability that the mean difference
is greater or less than 0 exceeds 1 minus significance level): <code>TRUE</code>
when significant, otherwise <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Data frame containing posterior mean, median, and sd of mean
difference.</p>
</td></tr>
<tr><td><code>stan.obj</code></td>
<td>
<p>Stanfit object.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hobbs BP, Carlin BP, Mandrekar SJ, Sargent DJ. Hierarchical commensurate and
power prior models for adaptive incorporation of historical information in
clinical trials. <em>Biometrics</em> 2011; 67:1047-1056.
</p>
<p>Hobbs BP, Sargent DJ, Carlin BP. Commensurate priors for incorporating
historical information in clinical trials using general and generalized
linear models. <em>Bayesian Analysis</em> 2012; 7:639-674.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT  &lt;- 100
n.CC  &lt;- 50
n.ECp &lt;- 200

out.mean.CT &lt;- 0
out.sd.CT   &lt;- 1
out.mean.CC &lt;- 0
out.sd.CC   &lt;- 1
driftdiff   &lt;- 0
out.sd.EC   &lt;- 1

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.1,0.1)

indata &lt;- trial.simulation.cont(
  n.CT=n.CT, n.CC=n.CC, n.ECp=n.ECp,
  out.mean.CT=out.mean.CT, out.sd.CT=out.sd.CT,
  out.mean.CC=out.mean.CC, out.sd.CC=out.sd.CC,
  driftdiff=driftdiff, out.sd.EC=out.sd.EC,
  cov.C=cov.C, cov.cor.C=cov.cor.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect)

n.EC &lt;- 50

method.whomatch &lt;- "conc.treat"
method.matching &lt;- "optimal"
method.psorder  &lt;- NULL

out.psmatch &lt;- psmatch(
  study~cov1+cov2, data=indata, n.EC=n.EC,
  method.whomatch=method.whomatch, method.matching=method.matching,
  method.psorder=method.psorder)

indata.match &lt;- rbind(indata[indata$study==1,],indata[out.psmatch$subjid.EC,])

method.borrow &lt;- list(list(prior="cauchy",scale=2.0),
                      list(prior="normal",scale=0.5))

commensurate.cont(y~cov1,data=indata.match,method.borrow=method.borrow,chains=1,iter=100)
</code></pre>

<hr>
<h2 id='commensurate.t2e'>Bayesian analysis with commensurate prior for time-to-event outcome</h2><span id='topic+commensurate.t2e'></span>

<h3>Description</h3>

<p>Bayesian analysis for time-to-event outcome is implemented via MCMC, where a
commensurate prior is used for incorporating data from external controls.
No borrowing and full borrowing are also applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commensurate.t2e(
  formula, data, method.borrow,
  chains=2, iter=4000, warmup=floor(iter/2), thin=1,
  alternative="greater", sig.level=0.025,
  seed=sample.int(.Machine$integer.max,1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commensurate.t2e_+3A_formula">formula</code></td>
<td>
<p>Object of class <code>formula</code>, which is a symbolic
description of the model to be fitted. The dependent variable must be an
object of class <code>Surv</code>. The explanatory variables only include
covariates of interest, which must be specified in the form of linear
combination.</p>
</td></tr>
<tr><td><code id="commensurate.t2e_+3A_data">data</code></td>
<td>
<p>Data frame, which must have variables named <code>study</code> for
study indicator (0 for external control, and 1 for current trial) and
<code>treat</code> for treatment indicator (0 for concurrent and external control,
and 1 for treatment).</p>
</td></tr>
<tr><td><code id="commensurate.t2e_+3A_method.borrow">method.borrow</code></td>
<td>
<p>List of information borrowing method. <code>"noborrow"</code>
uses the concurrent data only. <code>"fullborrow"</code> uses the external control
data without discounting. <code>"cauchy"</code> uses the commensurate prior to
dynamically borrow the external control data, and the commensurability
parameter is assumed to follow a half-Cauchy distribution. <code>"normal"</code>
uses the commensurate prior to dynamically borrow the external control data,
and the commensurability parameter is assumed to follow a half-normal
distribution. <code>"cauchy"</code> and <code>"normal"</code> require to specify the
scale parameter <code>scale</code> of half-Cauchy and half-normal distribution
respectively.</p>
</td></tr>
<tr><td><code id="commensurate.t2e_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains in MCMC sampling. The default value is
<code>chains=2</code>.</p>
</td></tr>
<tr><td><code id="commensurate.t2e_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for each chain (including warmup) in MCMC
sampling. The default value is <code>iter=4000</code>.</p>
</td></tr>
<tr><td><code id="commensurate.t2e_+3A_warmup">warmup</code></td>
<td>
<p>Number of warmup (burnin) iterations per chain in MCMC
sampling. The default value is <code>warmup=floor(iter/2)</code>.</p>
</td></tr>
<tr><td><code id="commensurate.t2e_+3A_thin">thin</code></td>
<td>
<p>Period for saving samples in MCMC sampling. The default value
is <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="commensurate.t2e_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hypothesis to be tested (&quot;greater&quot; or &quot;less&quot;).
The default value is <code>alternative="greater"</code>.</p>
</td></tr>
<tr><td><code id="commensurate.t2e_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level. The default value is
<code>sig.level=0.025</code>.</p>
</td></tr>
<tr><td><code id="commensurate.t2e_+3A_seed">seed</code></td>
<td>
<p>Setting a seed for MCMC sampling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time to event outcome is assumed to follow a Weibull
distribution. Given more than one covariates, a Weibull proportional
hazards model is built and its Bayesian estimation is performed via
MCMC. Commensurate prior is used to dynamically discount the information to
be borrowed from external control based on the similarity between the current
trial and external controls, where the commensurability parameter determines
the extent of borrowing. The commensurability parameter is assumed to follow
a half-cauchy or a half-normal distribution, and its scale parameter needs to
be carefully specified. No borrowing approach is to perform the analysis
without incorporating the external controls. Full borrowing approach is just
to pool the concurrent and external controls, which is used as a comparator
in the analysis.
</p>


<h3>Value</h3>

<p>The <code>commensurate.t2e</code> returns a list containing the following objects:
</p>
<table>
<tr><td><code>reject</code></td>
<td>
<p>Data frame containing results of Bayesian one-sided hypothesis
testing (whether or not the posterior probability that the log hazard ratio
is greater or less than 0 exceeds 1 minus significance level): <code>TRUE</code>
when significant, otherwise <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Data frame containing posterior mean, median, and sd of log
hazard ratio.</p>
</td></tr>
<tr><td><code>stan.obj</code></td>
<td>
<p>Stanfit object.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hobbs BP, Carlin BP, Mandrekar SJ, Sargent DJ. Hierarchical commensurate and
power prior models for adaptive incorporation of historical information in
clinical trials. <em>Biometrics</em> 2011; 67:1047-1056.
</p>
<p>Hobbs BP, Sargent DJ, Carlin BP. Commensurate priors for incorporating
historical information in clinical trials using general and generalized
linear models. <em>Bayesian Analysis</em> 2012; 7:639-674.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT       &lt;- 100
n.CC       &lt;- 50
nevent.C   &lt;- 100
n.ECp      &lt;- 200
nevent.ECp &lt;- 180
accrual    &lt;- 16

out.mevent.CT &lt;- 6
out.mevent.CC &lt;- 6
driftHR       &lt;- 1

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.9,0.9)

indata &lt;- trial.simulation.t2e(
  n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
  n.ECp=n.ECp, nevent.ECp=nevent.ECp, accrual=accrual,
  out.mevent.CT, out.mevent.CC, driftHR,
  cov.C=cov.C, cov.cor.C=cov.cor.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect)

n.EC &lt;- 50

method.whomatch &lt;- "conc.treat"
method.matching &lt;- "optimal"
method.psorder  &lt;- NULL

out.psmatch &lt;- psmatch(
  study~cov1+cov2, data=indata, n.EC=n.EC,
  method.whomatch=method.whomatch, method.matching=method.matching,
  method.psorder=method.psorder)

indata.match &lt;- rbind(indata[indata$study==1,],indata[out.psmatch$subjid.EC,])

method.borrow &lt;- list(list(prior="cauchy",scale=2.0),
                      list(prior="normal",scale=0.5))

commensurate.t2e(
  survival::Surv(time,status)~cov1+cov2,data=indata.match,
  method.borrow=method.borrow,chains=1,iter=100)
</code></pre>

<hr>
<h2 id='datagen'>Generate multivariate correlated data</h2><span id='topic+datagen'></span>

<h3>Description</h3>

<p>Multivariate correlated data are generated. Gaussian copula is used to
specify the correlation between variables. Any probability distributions
available in R STAT is applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datagen(margdist, corvec, nsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datagen_+3A_margdist">margdist</code></td>
<td>
<p>List of distributions to be used for the data generation.</p>
</td></tr>
<tr><td><code id="datagen_+3A_corvec">corvec</code></td>
<td>
<p>Vector of Gaussian copula correlation parameter.</p>
</td></tr>
<tr><td><code id="datagen_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data drawn from a multivariate distribution specified.
</p>

<hr>
<h2 id='psborrow.bin'>Simulation study of hybrid control design with Bayesian dynamic borrowing
incorporating propensity score matched external control: binary outcome</h2><span id='topic+psborrow.bin'></span>

<h3>Description</h3>

<p>Simulation study is conducted to assess operating characteristics of hybrid
control design with Bayesian dynamic borrowing, where the concurrent control
is augmented by external control. The external controls are selected from
external control pool using a propensity score matching. Commensurate power
prior is used for Bayesian dynamic borrowing. The binary outcome is
applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psborrow.bin(
  n.CT, n.CC, n.ECp, n.EC,
  out.prob.CT, out.prob.CC, driftOR,
  cov.C, cov.cor.C, cov.EC, cov.cor.EC, cov.effect,
  psmatch.cov,
  method.psest="glm", method.pslink="logit",
  method.whomatch, method.matching, method.psorder, n.boot=100,
  analysis.cov, method.borrow,
  chains=2, iter=4000, warmup=floor(iter/2), thin=1,
  alternative="greater", sig.level=0.025, nsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psborrow.bin_+3A_n.ct">n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_n.cc">n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_n.ecp">n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_n.ec">n.EC</code></td>
<td>
<p>Number of patients in external control.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_out.prob.ct">out.prob.CT</code></td>
<td>
<p>True rate of outcome in treatment group in the current
trial.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_out.prob.cc">out.prob.CC</code></td>
<td>
<p>True rate of outcome in concurrent control group in the
current trial.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_driftor">driftOR</code></td>
<td>
<p>Odds ratio between concurrent and external control
for which the bias should be plotted (odds in external control divided by
odds in concurrent control).</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_cov.c">cov.C</code></td>
<td>
<p>List of covariate distributions for treatment and concurrent
control group in the current trial. Continuous and binary covariate are
applicable. The continuous covariate is assumed to follow a normal
distribution; for example, specified as
<code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary covariate is
assumed to follow a binomial distribution; for example, specified as
<code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is the column
name of the covariate in the data frame generated.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_cov.cor.c">cov.cor.C</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for treatment and concurrent control group in the current trial,
specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_cov.ec">cov.EC</code></td>
<td>
<p>List of covariate distributions for external control. The
continuous covariate is assumed to follow a normal distribution; for example,
specified as <code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary
covariate is assumed to follow a binomial distribution; for example,
specified as <code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is
the column name of the covariate in the data frame generated, which must be
consistent with those used for <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_cov.cor.ec">cov.cor.EC</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for external control, specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_cov.effect">cov.effect</code></td>
<td>
<p>Vector of covariate effects on the outcome, specified as
odds ratio per one unit increase in continuous covariates or as odds ratio
between categories for binary covariates.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_psmatch.cov">psmatch.cov</code></td>
<td>
<p>Vector of names of covariates which are used for the
propensity score matching. The names of covariates must be included in
<code>lab</code> values specified in <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_method.psest">method.psest</code></td>
<td>
<p>Method of estimating the propensity score. Allowable
options include, for example, <code>"glm"</code> for generalized linear model
(e.g., logistic regression); <code>"gam"</code> for generalized additive model;
<code>"gbm"</code> for generalized boosted model; <code>"lasso"</code> for lasso
regression; <code>"rpart"</code> for classification tree. The default value is
<code>method.psest="glm"</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_method.pslink">method.pslink</code></td>
<td>
<p>Link function used in estimating the propensity score.
Allowable options depend on the specific <code>method.psest</code> value specified.
The default value is <code>method.pslink="logit"</code>, which, along with
<code>method.psest="glm"</code>, identifies the default method as logistic
regression.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_method.whomatch">method.whomatch</code></td>
<td>
<p>Options of who to match. Allowable options include
<code>conc.contl</code> for matching concurrent control to external control pool;
<code>conc.treat</code> for matching treatment to external control pool;
<code>conc.all</code> for matching treatment plus concurrent control to external
control pool; <code>treat2contl</code> for matching treatment to concurrent control
plus external control pool.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_method.matching">method.matching</code></td>
<td>
<p>Matching method. Allowable options include
<code>"optimal"</code> for optimal matching; <code>"nearest"</code> for nearest neighbor
matching without replacement; <code>"med.optimal"</code> for equally splitting
patients in the current trial and taking the median of each subset, followed
by 1:1 optimal matching; <code>"med.nearest"</code> for equally splitting
patients in the current trial and taking the median of each subset, followed
by 1:1 nearest neighbor matching without replacement; <code>"km.optimal"</code> for
k-means clustering of patients in the current trial, followed by 1:1 optimal
matching; <code>"km.nearest"</code> for k-means clustering of patients in the
current trial, followed by 1:1 nearest neighbor matching without replacement;
<code>"cm.optimal"</code> for fuzzy c-means clustering of patients in the current
trial, followed by 1:1 optimal matching; <code>"cm.nearest"</code> for fuzzy
c-means of patients in the current trial, followed by 1:1 nearest neighbor
matching without replacement; <code>"boot.optimal"</code> for bootstrap sampling
from patients in the current trial, followed by 1:1 optimal matching;
<code>"boot.nearest"</code> for bootstrap sampling from patient in the current
trial, followed by 1:1 nearest neighbor matching without replacement.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_method.psorder">method.psorder</code></td>
<td>
<p>Order that the matching takes place when a nearest
neighbor matching is used. Allowable options include <code>"largest"</code>,
where matching takes place in descending order of propensity score;
<code>"smallest"</code>, where matching takes place in ascending order of
propensity score; <code>"random"</code>, where matching takes place in a random
order; <code>"data"</code>, where matching takes place based on the order of units
in the data. The matching order must be specified when using the nearest
neighbor matching.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_n.boot">n.boot</code></td>
<td>
<p>Number of bootstrap sampling, which must be specified when
<code>method.matching="boot.optimal"</code> or
<code>method.matching="boot.nearest"</code>. The default value is <code>n.boot=100</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_analysis.cov">analysis.cov</code></td>
<td>
<p>Vector of names of covariates which are used for the
Bayesian analysis with commensurate prior. The names of covariates must be
included in <code>lab</code> values specified in <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_method.borrow">method.borrow</code></td>
<td>
<p>List of information borrowing method. <code>"noborrow"</code>
uses the concurrent data only. <code>"fullborrow"</code> uses the external control
data without discounting. <code>"cauchy"</code> uses the commensurate prior to
dynamically borrow the external control data, and the commensurability
parameter is assumed to follow a half-Cauchy distribution. <code>"normal"</code>
uses the commensurate prior to dynamically borrow the external control data,
and the commensurability parameter is assumed to follow a half-normal
distribution. <code>"cauchy"</code> and <code>"normal"</code> require to specify the
scale parameter <code>scale</code> of half-Cauchy and half-normal distribution
respectively.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains in MCMC sampling. The default value is
<code>chains=2</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for each chain (including warmup) in MCMC
sampling. The default value is <code>iter=4000</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_warmup">warmup</code></td>
<td>
<p>Number of warmup (burnin) iterations per chain in MCMC
sampling. The default value is <code>warmup=floor(iter/2)</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_thin">thin</code></td>
<td>
<p>Period for saving samples in MCMC sampling. The default value
is <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hypothesis to be tested (&quot;greater&quot; or &quot;less&quot;).
The default value is <code>alternative="greater"</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level. The default value is
<code>sig.level=0.025</code>.</p>
</td></tr>
<tr><td><code id="psborrow.bin_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated trials.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation study consists of three part: data generation
conducted by <code>trial.simulation.bin</code> function, propensity score matching
conducted by <code>psmatch</code> function, and Bayesian analysis with commensurate
prior conducted by <code>commensurate.bin</code> function. Users can specify
different sets of covariates for the propensity score matching and the
Bayesian analysis.
</p>


<h3>Value</h3>

<p>The <code>psborrow.bin</code> returns a list containing the following objects:
</p>
<table>
<tr><td><code>reject</code></td>
<td>
<p>Data frame containing results of Bayesian one-sided hypothesis
testing (whether or not the posterior probability that the log odds ratio
is greater or less than 0 exceeds 1 minus significance level): <code>TRUE</code>
when significant, otherwise <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Data frame containing posterior mean, median, and sd of log
odds ratio.</p>
</td></tr>
<tr><td><code>ov</code></td>
<td>
<p>Data frame containing (1) overlapping coefficient of propensity
score densities between treatment versus concurrent control plus external
control and between concurrent control versus external control, (2)
overlapping coefficient of continuous covariate densities between treatment
versus concurrent control plus external control and between concurrent
control versus external control, and (3) rate difference of binary covariate
between treatment versus concurrent control plus external control and
between concurrent control versus external control.</p>
</td></tr>
<tr><td><code>n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code>n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code>n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code>n.EC</code></td>
<td>
<p>Number of patients in external control.</p>
</td></tr>
<tr><td><code>drift</code></td>
<td>
<p>Odds ratio between concurrent and external control.</p>
</td></tr>
<tr><td><code>true.theta</code></td>
<td>
<p>True log odds ratio</p>
</td></tr>
<tr><td><code>method.psest</code></td>
<td>
<p>Method of estimating the propensity score.</p>
</td></tr>
<tr><td><code>method.pslink</code></td>
<td>
<p>Link function used in estimating the propensity score.</p>
</td></tr>
<tr><td><code>method.whomatch</code></td>
<td>
<p>Option of who to match.</p>
</td></tr>
<tr><td><code>method.matching</code></td>
<td>
<p>Propensity score matching method.</p>
</td></tr>
<tr><td><code>method.psorder</code></td>
<td>
<p>Order that the matching takes place when a nearest
neighbor matching is used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT  &lt;- 100
n.CC  &lt;- 50
n.ECp &lt;- 200
n.EC  &lt;- 50

out.prob.CT &lt;- 0.2
out.prob.CC &lt;- 0.2
driftOR     &lt;- 1.0

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.9,0.9)

psmatch.cov &lt;- c("cov1","cov2")

method.whomatch &lt;- "conc.treat"
method.matching &lt;- "optimal"
method.psorder  &lt;- NULL

analysis.cov &lt;- c("cov1")

method.borrow &lt;- list(list(prior="noborrow"),
                      list(prior="normal",scale=0.5))

nsim &lt;- 5

psborrow.bin(
  n.CT=n.CT, n.CC=n.CC, n.ECp=n.ECp, n.EC=n.EC,
  out.prob.CT=out.prob.CT, out.prob.CC=out.prob.CC, driftOR=driftOR,
  cov.C=cov.C, cov.cor.C=cov.cor.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect,
  psmatch.cov=psmatch.cov, method.whomatch=method.whomatch,
  method.matching=method.matching, method.psorder=method.psorder,
  analysis.cov=analysis.cov, method.borrow=method.borrow,
  chains=1, iter=100, nsim=nsim)
</code></pre>

<hr>
<h2 id='psborrow.cont'>Simulation study of hybrid control design with Bayesian dynamic borrowing
incorporating propensity score matched external control: continuous outcome</h2><span id='topic+psborrow.cont'></span>

<h3>Description</h3>

<p>Simulation study is conducted to assess operating characteristics of hybrid
control design with Bayesian dynamic borrowing, where the concurrent control
is augmented by external control. The external controls are selected from
external control pool using a propensity score matching. Commensurate power
prior is used for Bayesian dynamic borrowing. The continuous outcome is
applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psborrow.cont(
  n.CT, n.CC, n.ECp, n.EC,
  out.mean.CT, out.sd.CT, out.mean.CC, out.sd.CC, driftdiff, out.sd.EC,
  cov.C, cov.cor.C, cov.EC, cov.cor.EC, cov.effect,
  psmatch.cov,
  method.psest="glm", method.pslink="logit",
  method.whomatch, method.matching, method.psorder, n.boot=100,
  analysis.cov, method.borrow,
  chains=2, iter=4000, warmup=floor(iter/2), thin=1,
  alternative="greater", sig.level=0.025, nsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psborrow.cont_+3A_n.ct">n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_n.cc">n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_n.ecp">n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_n.ec">n.EC</code></td>
<td>
<p>Number of patients in external control.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_out.mean.ct">out.mean.CT</code></td>
<td>
<p>True mean of outcome in treatment group in the current
trial.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_out.sd.ct">out.sd.CT</code></td>
<td>
<p>True sd of outcome in treatment group in the current trial.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_out.mean.cc">out.mean.CC</code></td>
<td>
<p>True mean of outcome in concurrent control group in the
current trial.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_out.sd.cc">out.sd.CC</code></td>
<td>
<p>True as of outcome in concurrent control group in the
current trial.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_driftdiff">driftdiff</code></td>
<td>
<p>Mean difference between concurrent and external control
for which the bias should be plotted (mean in external control minus mean
in concurrent control).</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_out.sd.ec">out.sd.EC</code></td>
<td>
<p>True as of outcome in external control.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_cov.c">cov.C</code></td>
<td>
<p>List of covariate distributions for treatment and concurrent
control group in the current trial. Continuous and binary covariate are
applicable. The continuous covariate is assumed to follow a normal
distribution; for example specified as
<code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary covariate is
assumed to follow a binomial distribution; for example, specified as
<code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is the column
name of the covariate in the data frame generated.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_cov.cor.c">cov.cor.C</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for treatment and concurrent control group in the current trial,
specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_cov.ec">cov.EC</code></td>
<td>
<p>List of covariate distributions for external control. The
continuous covariate is assumed to follow a normal distribution; for example,
specified as <code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary
covariate is assumed to follow a binomial distribution; for example,
specified as <code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is
the column name of the covariate in the data frame generated, which must be
consistent with those used for <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_cov.cor.ec">cov.cor.EC</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for external control, specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_cov.effect">cov.effect</code></td>
<td>
<p>Vector of covariate effects on the outcome, specified as
mean change per one unit increase in continuous covariates or as mean change
between categories for binary covariates.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_psmatch.cov">psmatch.cov</code></td>
<td>
<p>Vector of names of covariates which are used for the
propensity score matching. The names of covariates must be included in
<code>lab</code> values specified in <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_method.psest">method.psest</code></td>
<td>
<p>Method of estimating the propensity score. Allowable
options include, for example, <code>"glm"</code> for generalized linear model
(e.g., logistic regression); <code>"gam"</code> for generalized additive model;
<code>"gbm"</code> for generalized boosted model; <code>"lasso"</code> for lasso
regression; <code>"rpart"</code> for classification tree. The default value is
<code>method.psest="glm"</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_method.pslink">method.pslink</code></td>
<td>
<p>Link function used in estimating the propensity score.
Allowable options depend on the specific <code>method.psest</code> value specified.
The default value is <code>method.pslink="logit"</code>, which, along with
<code>method.psest="glm"</code>, identifies the default method as logistic
regression.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_method.whomatch">method.whomatch</code></td>
<td>
<p>Options of who to match. Allowable options include
<code>conc.contl</code> for matching concurrent control to external control pool;
<code>conc.treat</code> for matching treatment to external control pool;
<code>conc.all</code> for matching treatment plus concurrent control to external
control pool; <code>treat2contl</code> for matching treatment to concurrent control
plus external control pool.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_method.matching">method.matching</code></td>
<td>
<p>Matching method. Allowable options include
<code>"optimal"</code> for optimal matching; <code>"nearest"</code> for nearest neighbor
matching without replacement; <code>"med.optimal"</code> for equally splitting
patients in the current trial and taking the median of each subset, followed
by 1:1 optimal matching; <code>"med.nearest"</code> for equally splitting
patients in the current trial and taking the median of each subset, followed
by 1:1 nearest neighbor matching without replacement; <code>"km.optimal"</code> for
k-means clustering of patients in the current trial, followed by 1:1 optimal
matching; <code>"km.nearest"</code> for k-means clustering of patients in the
current trial, followed by 1:1 nearest neighbor matching without replacement;
<code>"cm.optimal"</code> for fuzzy c-means clustering of patients in the current
trial, followed by 1:1 optimal matching; <code>"cm.nearest"</code> for fuzzy
c-means of patients in the current trial, followed by 1:1 nearest neighbor
matching without replacement; <code>"boot.optimal"</code> for bootstrap sampling
from patients in the current trial, followed by 1:1 optimal matching;
<code>"boot.nearest"</code> for bootstrap sampling from patient in the current
trial, followed by 1:1 nearest neighbor matching without replacement.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_method.psorder">method.psorder</code></td>
<td>
<p>Order that the matching takes place when a nearest
neighbor matching is used. Allowable options include <code>"largest"</code>,
where matching takes place in descending order of propensity score;
<code>"smallest"</code>, where matching takes place in ascending order of
propensity score; <code>"random"</code>, where matching takes place in a random
order; <code>"data"</code>, where matching takes place based on the order of units
in the data. The matching order must be specified when using the nearest
neighbor matching.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_n.boot">n.boot</code></td>
<td>
<p>Number of bootstrap sampling, which must be specified when
<code>method.matching="boot.optimal"</code> or
<code>method.matching="boot.nearest"</code>. The default value is <code>n.boot=100</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_analysis.cov">analysis.cov</code></td>
<td>
<p>Vector of names of covariates which are used for the
Bayesian analysis with commensurate prior. The names of covariates must be
included in <code>lab</code> values specified in <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_method.borrow">method.borrow</code></td>
<td>
<p>List of information borrowing method. <code>"noborrow"</code>
uses the concurrent data only. <code>"fullborrow"</code> uses the external control
data without discounting. <code>"cauchy"</code> uses the commensurate prior to
dynamically borrow the external control data, and the commensurability
parameter is assumed to follow a half-Cauchy distribution. <code>"normal"</code>
uses the commensurate prior to dynamically borrow the external control data,
and the commensurability parameter is assumed to follow a half-normal
distribution. <code>"cauchy"</code> and <code>"normal"</code> require to specify the
scale parameter <code>scale</code> of half-Cauchy and half-normal distribution
respectively.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains in MCMC sampling. The default value is
<code>chains=2</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for each chain (including warmup) in MCMC
sampling. The default value is <code>iter=4000</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_warmup">warmup</code></td>
<td>
<p>Number of warmup (burnin) iterations per chain in MCMC
sampling. The default value is <code>warmup=floor(iter/2)</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_thin">thin</code></td>
<td>
<p>Period for saving samples in MCMC sampling. The default value
is <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hypothesis to be tested (&quot;greater&quot; or &quot;less&quot;).
The default value is <code>alternative="greater"</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level. The default value is
<code>sig.level=0.025</code>.</p>
</td></tr>
<tr><td><code id="psborrow.cont_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated trials.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation study consists of three part: data generation
conducted by <code>trial.simulation.cont</code> function, propensity score matching
conducted by <code>psmatch</code> function, and Bayesian analysis with commensurate
prior conducted by <code>commensurate.cont</code> function. Users can specify
different sets of covariates for the propensity score matching and the
Bayesian analysis.
</p>


<h3>Value</h3>

<p>The <code>psborrow.cont</code> returns a list containing the following objects:
</p>
<table>
<tr><td><code>reject</code></td>
<td>
<p>Data frame containing results of Bayesian one-sided hypothesis
testing (whether or not the posterior probability that the mean difference
is greater or less than 0 exceeds 1 minus significance level): <code>TRUE</code>
when significant, otherwise <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Data frame containing posterior mean, median, and sd of mean
difference.</p>
</td></tr>
<tr><td><code>ov</code></td>
<td>
<p>Data frame containing (1) overlapping coefficient of propensity
score densities between treatment versus concurrent control plus external
control and between concurrent control versus external control, (2)
overlapping coefficient of continuous covariate densities between treatment
versus concurrent control plus external control and between concurrent
control versus external control, and (3) rate difference of binary covariate
between treatment versus concurrent control plus external control and
between concurrent control versus external control.</p>
</td></tr>
<tr><td><code>n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code>n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code>n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code>n.EC</code></td>
<td>
<p>Number of patients in external control.</p>
</td></tr>
<tr><td><code>drift</code></td>
<td>
<p>Mean difference between concurrent and external control.</p>
</td></tr>
<tr><td><code>true.theta</code></td>
<td>
<p>True mean difference</p>
</td></tr>
<tr><td><code>method.psest</code></td>
<td>
<p>Method of estimating the propensity score.</p>
</td></tr>
<tr><td><code>method.pslink</code></td>
<td>
<p>Link function used in estimating the propensity score.</p>
</td></tr>
<tr><td><code>method.whomatch</code></td>
<td>
<p>Option of who to match.</p>
</td></tr>
<tr><td><code>method.matching</code></td>
<td>
<p>Propensity score matching method.</p>
</td></tr>
<tr><td><code>method.psorder</code></td>
<td>
<p>Order that the matching takes place when a nearest
neighbor matching is used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT  &lt;- 100
n.CC  &lt;- 50
n.ECp &lt;- 200
n.EC  &lt;- 50

out.mean.CT &lt;- 0
out.sd.CT   &lt;- 1
out.mean.CC &lt;- 0
out.sd.CC   &lt;- 1
driftdiff   &lt;- 0
out.sd.EC   &lt;- 1

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.1,0.1)

psmatch.cov &lt;- c("cov1","cov2")

method.whomatch &lt;- "conc.treat"
method.matching &lt;- "optimal"
method.psorder  &lt;- NULL

analysis.cov &lt;- c("cov1")

method.borrow &lt;- list(list(prior="noborrow"),
                      list(prior="normal",scale=0.5))

nsim &lt;- 5

psborrow.cont(
  n.CT=n.CT, n.CC=n.CC, n.ECp=n.ECp, n.EC=n.EC,
  out.mean.CT=out.mean.CT, out.sd.CT=out.sd.CT,
  out.mean.CC=out.mean.CC, out.sd.CC=out.sd.CC,
  driftdiff=driftdiff, out.sd.EC=out.sd.EC,
  cov.C=cov.C, cov.cor.C=cov.cor.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect,
  psmatch.cov=psmatch.cov, method.whomatch=method.whomatch,
  method.matching=method.matching, method.psorder=method.psorder,
  analysis.cov=analysis.cov, method.borrow=method.borrow,
  chains=1, iter=100, nsim=nsim)
</code></pre>

<hr>
<h2 id='psborrow.summary'>Summarizing simulation study results</h2><span id='topic+psborrow.summary'></span>

<h3>Description</h3>

<p>Simulation study results are summarized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psborrow.summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psborrow.summary_+3A_object">object</code></td>
<td>
<p>List of simulation results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>psborrow.summary</code> returns a list containing the following objects:
</p>
<table>
<tr><td><code>res.out</code></td>
<td>
<p>Data frame containing (1) rate that the null hypothesis is
rejected in Bayesian one-sided hypothesis testing, (2) bias in posterior mean
of treatment effect (log hazard ratio, log odds ratio, or mean difference),
(3) empirical standard deviation (<code>EmpSD</code>), derived by taking the
standard deviation of posterior mean of treatment effect that each simulated
trial yielded, (4) model standard deviation ((<code>ModSD</code>)), derived by
taking the average of posterior standard deviation of treatment effect that
each simulated trial yielded, (5) ratio of <code>ModSD</code> to <code>EmpSD</code>,
(6) Coverage probability of credible interval.</p>
</td></tr>
<tr><td><code>res.cov</code></td>
<td>
<p>Data frame containing (1) mean, median, and standard deviation
of overlapping coefficients of propensity score densities between treatment
versus concurrent control plus external control and between concurrent
control versus external control, (2) mean, median, and standard deviation
of overlapping coefficients of continuous covariate densities between treatment
versus concurrent control plus external control and between concurrent
control versus external control, and (3) mean, median, and standard deviation
of rate differences of binary covariate between treatment versus concurrent
control plus external control and between concurrent control versus external
control.</p>
</td></tr>
<tr><td><code>n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code>n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code>n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code>n.EC</code></td>
<td>
<p>Number of patients in external control.</p>
</td></tr>
<tr><td><code>drift</code></td>
<td>
<p>Hazard ratio, odds ratio, or mean difference between concurrent
and external control for which the bias should be plotted. The measure
depends on the outcome type.</p>
</td></tr>
<tr><td><code>method.psest</code></td>
<td>
<p>Method of estimating the propensity score.</p>
</td></tr>
<tr><td><code>method.pslink</code></td>
<td>
<p>Link function used in estimating the propensity score.</p>
</td></tr>
<tr><td><code>method.whomatch</code></td>
<td>
<p>Options of who to match.</p>
</td></tr>
<tr><td><code>method.matching</code></td>
<td>
<p>Matching method.</p>
</td></tr>
<tr><td><code>method.psorder</code></td>
<td>
<p>Order that the matching takes place when a nearest
neighbor matching is used.</p>
</td></tr>
</table>

<hr>
<h2 id='psborrow.t2e'>Simulation study of hybrid control design with Bayesian dynamic borrowing
incorporating propensity score matched external control: time-to-event outcome</h2><span id='topic+psborrow.t2e'></span>

<h3>Description</h3>

<p>Simulation study is conducted to assess operating characteristics of hybrid
control design with Bayesian dynamic borrowing, where the concurrent control
is augmented by external control. The external controls are selected from
external control pool using a propensity score matching. Commensurate power
prior is used for Bayesian dynamic borrowing. The time-to-event outcome is
applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psborrow.t2e(
  n.CT, n.CC, nevent.C, n.ECp, nevent.ECp, n.EC, accrual,
  out.mevent.CT, out.mevent.CC, driftHR,
  cov.C, cov.cor.C, cov.EC, cov.cor.EC, cov.effect,
  psmatch.cov,
  method.psest="glm", method.pslink="logit",
  method.whomatch, method.matching, method.psorder, n.boot=100,
  analysis.cov, method.borrow,
  chains=2, iter=4000, warmup=floor(iter/2), thin=1,
  alternative="greater", sig.level=0.025, nsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psborrow.t2e_+3A_n.ct">n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_n.cc">n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_nevent.c">nevent.C</code></td>
<td>
<p>Number of events in treatment and concurrent control group
in the current trial.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_n.ecp">n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_nevent.ecp">nevent.ECp</code></td>
<td>
<p>Number of events in external control pool.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_n.ec">n.EC</code></td>
<td>
<p>Number of patients in external control.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_accrual">accrual</code></td>
<td>
<p>Accrual rate, defined as the number of enrolled patients per
month.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_out.mevent.ct">out.mevent.CT</code></td>
<td>
<p>True median time to event in treatment group in the
current trial.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_out.mevent.cc">out.mevent.CC</code></td>
<td>
<p>True median time to event in concurrent control group
in the current trial.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_drifthr">driftHR</code></td>
<td>
<p>Hazard ratio between concurrent and external control for
which the bias should be plotted (hazard in external control divided by
hazard in concurrent control).</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_cov.c">cov.C</code></td>
<td>
<p>List of covariate distributions for treatment and concurrent
control group in the current trial. Continuous and binary covariate are
applicable. The continuous covariate is assumed to follow a normal
distribution; for example, specified as
<code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary covariate is
assumed to follow a binomial distribution; for example, specified as
<code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is the column
name of the covariate in the data frame generated.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_cov.cor.c">cov.cor.C</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for treatment and concurrent control group in the current trial,
specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_cov.ec">cov.EC</code></td>
<td>
<p>List of covariate distributions for external control. The
continuous covariate is assumed to follow a normal distribution; for example,
specified as <code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary
covariate is assumed to follow a binomial distribution; for example,
specified as <code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is
the column name of the covariate in the data frame generated, which must be
consistent with those used for <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_cov.cor.ec">cov.cor.EC</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for external control, specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_cov.effect">cov.effect</code></td>
<td>
<p>Vector of covariate effects on the outcome, specified as
hazard ratio per one unit increase in continuous covariate or as hazard
ratio between categories for binary covariate.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_psmatch.cov">psmatch.cov</code></td>
<td>
<p>Vector of names of covariates which are used for the
propensity score matching. The names of covariates must be included in
<code>lab</code> values specified in <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_method.psest">method.psest</code></td>
<td>
<p>Method of estimating the propensity score. Allowable
options include, for example, <code>"glm"</code> for generalized linear model
(e.g., logistic regression); <code>"gam"</code> for generalized additive model;
<code>"gbm"</code> for generalized boosted model; <code>"lasso"</code> for lasso
regression; <code>"rpart"</code> for classification tree. The default value is
<code>method.psest="glm"</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_method.pslink">method.pslink</code></td>
<td>
<p>Link function used in estimating the propensity score.
Allowable options depend on the specific <code>method.psest</code> value specified.
The default value is <code>method.pslink="logit"</code>, which, along with
<code>method.psest="glm"</code>, identifies the default method as logistic
regression.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_method.whomatch">method.whomatch</code></td>
<td>
<p>Options of who to match. Allowable options include
<code>conc.contl</code> for matching concurrent control to external control pool;
<code>conc.treat</code> for matching treatment to external control pool;
<code>conc.all</code> for matching treatment plus concurrent control to external
control pool; <code>treat2contl</code> for matching treatment to concurrent control
plus external control pool.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_method.matching">method.matching</code></td>
<td>
<p>Matching method. Allowable options include
<code>"optimal"</code> for optimal matching; <code>"nearest"</code> for nearest neighbor
matching without replacement; <code>"med.optimal"</code> for equally splitting
patients in the current trial and taking the median of each subset, followed
by 1:1 optimal matching; <code>"med.nearest"</code> for equally splitting
patients in the current trial and taking the median of each subset, followed
by 1:1 nearest neighbor matching without replacement; <code>"km.optimal"</code> for
k-means clustering of patients in the current trial, followed by 1:1 optimal
matching; <code>"km.nearest"</code> for k-means clustering of patients in the
current trial, followed by 1:1 nearest neighbor matching without replacement;
<code>"cm.optimal"</code> for fuzzy c-means clustering of patients in the current
trial, followed by 1:1 optimal matching; <code>"cm.nearest"</code> for fuzzy
c-means of patients in the current trial, followed by 1:1 nearest neighbor
matching without replacement; <code>"boot.optimal"</code> for bootstrap sampling
from patients in the current trial, followed by 1:1 optimal matching;
<code>"boot.nearest"</code> for bootstrap sampling from patient in the current
trial, followed by 1:1 nearest neighbor matching without replacement.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_method.psorder">method.psorder</code></td>
<td>
<p>Order that the matching takes place when a nearest
neighbor matching is used. Allowable options include <code>"largest"</code>,
where matching takes place in descending order of propensity score;
<code>"smallest"</code>, where matching takes place in ascending order of
propensity score; <code>"random"</code>, where matching takes place in a random
order; <code>"data"</code>, where matching takes place based on the order of units
in the data. The matching order must be specified when using the nearest
neighbor matching.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_n.boot">n.boot</code></td>
<td>
<p>Number of bootstrap sampling, which must be specified when
<code>method.matching="boot.optimal"</code> or
<code>method.matching="boot.nearest"</code>. The default value is <code>n.boot=100</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_analysis.cov">analysis.cov</code></td>
<td>
<p>Vector of names of covariates which are used for the
Bayesian analysis with commensurate prior. The names of covariates must be
included in <code>lab</code> values specified in <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_method.borrow">method.borrow</code></td>
<td>
<p>List of information borrowing method. <code>"noborrow"</code>
uses the concurrent data only. <code>"fullborrow"</code> uses the external control
data without discounting. <code>"cauchy"</code> uses the commensurate prior to
dynamically borrow the external control data, and the commensurability
parameter is assumed to follow a half-Cauchy distribution. <code>"normal"</code>
uses the commensurate prior to dynamically borrow the external control data,
and the commensurability parameter is assumed to follow a half-normal
distribution. <code>"cauchy"</code> and <code>"normal"</code> require to specify the
scale parameter <code>scale</code> of half-Cauchy and half-normal distribution
respectively.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains in MCMC sampling. The default value is
<code>chains=2</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_iter">iter</code></td>
<td>
<p>Number of iterations for each chain (including warmup) in MCMC
sampling. The default value is <code>iter=4000</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_warmup">warmup</code></td>
<td>
<p>Number of warmup (burnin) iterations per chain in MCMC
sampling. The default value is <code>warmup=floor(iter/2)</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_thin">thin</code></td>
<td>
<p>Period for saving samples in MCMC sampling. The default value
is <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_alternative">alternative</code></td>
<td>
<p>Alternative hypothesis to be tested (&quot;greater&quot; or &quot;less&quot;).
The default value is <code>alternative="greater"</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level. The default value is
<code>sig.level=0.025</code>.</p>
</td></tr>
<tr><td><code id="psborrow.t2e_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated trials.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation study consists of three part: data generation
conducted by <code>trial.simulation.t2e</code> function, propensity score matching
conducted by <code>psmatch</code> function, and Bayesian analysis with commensurate
prior conducted by <code>commensurate.t2e</code> function. Users can specify
different sets of covariates for the propensity score matching and the
Bayesian analysis.
</p>


<h3>Value</h3>

<p>The <code>psborrow.t2e</code> returns a list containing the following objects:
</p>
<table>
<tr><td><code>reject</code></td>
<td>
<p>Data frame containing results of Bayesian one-sided hypothesis
testing (whether or not the posterior probability that the log hazard ratio
is greater or less than 0 exceeds 1 minus significance level): <code>TRUE</code>
when significant, otherwise <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Data frame containing posterior mean, median, and sd of log
hazard ratio.</p>
</td></tr>
<tr><td><code>ov</code></td>
<td>
<p>Data frame containing (1) overlapping coefficient of propensity
score densities between treatment versus concurrent control plus external
control and between concurrent control versus external control, (2)
overlapping coefficient of continuous covariate densities between treatment
versus concurrent control plus external control and between concurrent
control versus external control, and (3) rate difference of binary covariate
between treatment versus concurrent control plus external control and
between concurrent control versus external control.</p>
</td></tr>
<tr><td><code>n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code>n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code>n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code>n.EC</code></td>
<td>
<p>Number of patients in external control.</p>
</td></tr>
<tr><td><code>drift</code></td>
<td>
<p>Hazard ratio between concurrent and external control.</p>
</td></tr>
<tr><td><code>true.theta</code></td>
<td>
<p>True log hazard ratio</p>
</td></tr>
<tr><td><code>method.psest</code></td>
<td>
<p>Method of estimating the propensity score.</p>
</td></tr>
<tr><td><code>method.pslink</code></td>
<td>
<p>Link function used in estimating the propensity score.</p>
</td></tr>
<tr><td><code>method.whomatch</code></td>
<td>
<p>Option of who to match.</p>
</td></tr>
<tr><td><code>method.matching</code></td>
<td>
<p>Propensity score matching method.</p>
</td></tr>
<tr><td><code>method.psorder</code></td>
<td>
<p>Order that the matching takes place when a nearest
neighbor matching is used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT       &lt;- 100
n.CC       &lt;- 50
nevent.C   &lt;- 100
n.ECp      &lt;- 200
nevent.ECp &lt;- 180
n.EC       &lt;- 50
accrual    &lt;- 16

out.mevent.CT &lt;- 6
out.mevent.CC &lt;- 6
driftHR       &lt;- 1

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.9,0.9)

psmatch.cov &lt;- c("cov1","cov2")

method.whomatch &lt;- "conc.treat"
method.matching &lt;- "optimal"
method.psorder  &lt;- NULL

analysis.cov &lt;- c("cov1")

method.borrow &lt;- list(list(prior="noborrow"),
                      list(prior="normal",scale=0.5))

nsim &lt;- 5

psborrow.t2e(
  n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
  n.ECp=n.ECp, nevent.ECp=nevent.ECp, n.EC=n.EC, accrual=accrual,
  out.mevent.CT=out.mevent.CT, out.mevent.CC=out.mevent.CC, driftHR=driftHR,
  cov.C=cov.C, cov.cor.C=cov.cor.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect,
  psmatch.cov=psmatch.cov, method.whomatch=method.whomatch,
  method.matching=method.matching, method.psorder=method.psorder,
  analysis.cov=analysis.cov, method.borrow=method.borrow,
  chains=1, iter=100, nsim=nsim)
</code></pre>

<hr>
<h2 id='psmatch'>Propensity score matching</h2><span id='topic+psmatch'></span>

<h3>Description</h3>

<p>Propensity score matching is implemented to select external controls who are
more relevant to patients in the current trial with respect to covariates
of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psmatch(
  formula, data, n.EC,
  method.psest="glm", method.pslink="logit",
  method.whomatch, method.matching, method.psorder, n.boot=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psmatch_+3A_formula">formula</code></td>
<td>
<p>Object of class <code>formula</code>, which is a symbolic
description of the propensity score model to be fitted. The dependent
variable must be named <code>study</code>. The explanatory variables only include
covariates of interest, which must be specified in the form of linear
combination.</p>
</td></tr>
<tr><td><code id="psmatch_+3A_data">data</code></td>
<td>
<p>Data frame, which must contain variables named <code>study</code> for
study indicator (0 for external control, and 1 for current trial) and
<code>treat</code> for treatment indicator (0 for concurrent and external control,
and 1 for treatment).</p>
</td></tr>
<tr><td><code id="psmatch_+3A_n.ec">n.EC</code></td>
<td>
<p>Number of patients in external control to be selected, which must
be smaller than the number of patients in external control pool.</p>
</td></tr>
<tr><td><code id="psmatch_+3A_method.psest">method.psest</code></td>
<td>
<p>Method of estimating the propensity score. Allowable
options include, for example, <code>"glm"</code> for generalized linear model
(e.g., logistic regression); <code>"gam"</code> for generalized additive model;
<code>"gbm"</code> for generalized boosted model; <code>"lasso"</code> for lasso
regression; <code>"rpart"</code> for classification tree. The default value is
<code>method.psest="glm"</code>.</p>
</td></tr>
<tr><td><code id="psmatch_+3A_method.pslink">method.pslink</code></td>
<td>
<p>Link function used in estimating the propensity score.
Allowable options depend on the specific <code>method.psest</code> value specified.
The default value is <code>method.pslink="logit"</code>, which, along with
<code>method.psest="glm"</code>, identifies the default method as logistic
regression.</p>
</td></tr>
<tr><td><code id="psmatch_+3A_method.whomatch">method.whomatch</code></td>
<td>
<p>Options of who to match. Allowable options include
<code>conc.contl</code> for matching concurrent control to external control pool;
<code>conc.treat</code> for matching treatment to external control pool;
<code>conc.all</code> for matching treatment plus concurrent control to external
control pool; <code>treat2contl</code> for matching treatment to concurrent control
plus external control pool.</p>
</td></tr>
<tr><td><code id="psmatch_+3A_method.matching">method.matching</code></td>
<td>
<p>Propensity score matching method. Allowable options include
<code>"optimal"</code> for optimal matching; <code>"nearest"</code> for nearest neighbor
matching without replacement; <code>"med.optimal"</code> for equally splitting
patients in the current trial and taking the median of each subset, followed
by 1:1 optimal matching; <code>"med.nearest"</code> for equally splitting
patients in the current trial and taking the median of each subset, followed
by 1:1 nearest neighbor matching without replacement; <code>"km.optimal"</code> for
k-means clustering of patients in the current trial, followed by 1:1 optimal
matching; <code>"km.nearest"</code> for k-means clustering of patients in the
current trial, followed by 1:1 nearest neighbor matching without replacement;
<code>"cm.optimal"</code> for fuzzy c-means clustering of patients in the current
trial, followed by 1:1 optimal matching; <code>"cm.nearest"</code> for fuzzy
c-means of patients in the current trial, followed by 1:1 nearest neighbor
matching without replacement; <code>"boot.optimal"</code> for bootstrap sampling
from patients in the current trial, followed by 1:1 optimal matching;
<code>"boot.nearest"</code> for bootstrap sampling from patient in the current
trial, followed by 1:1 nearest neighbor matching without replacement.</p>
</td></tr>
<tr><td><code id="psmatch_+3A_method.psorder">method.psorder</code></td>
<td>
<p>Order that the matching takes place when a nearest
neighbor matching is used. Allowable options include <code>"largest"</code>,
where matching takes place in descending order of propensity score;
<code>"smallest"</code>, where matching takes place in ascending order of
propensity score; <code>"random"</code>, where matching takes place in a random
order; <code>"data"</code>, where matching takes place based on the order of units
in the data. The matching order must be specified when using the nearest
neighbor matching.</p>
</td></tr>
<tr><td><code id="psmatch_+3A_n.boot">n.boot</code></td>
<td>
<p>Number of bootstrap sampling, which must be specified when
<code>method.matching="boot.optimal"</code> or
<code>method.matching="boot.nearest"</code>. The default value is <code>n.boot=100</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The propensity score is defined as the conditional probability of
having been included in the current trial given observed covariates. There
are four options applicable for to whom the patients in external control
pool are matched, including (i) concurrent control versus external control
pool (<code>"conc.contl"</code>), (ii) treatment versus external control pool
(<code>"conc.treat"</code>), (iii) treatment plus concurrent control versus
external control pool (<code>"conc.all"</code>), and (iv) treatment versus
concurrent control plus external control pool (<code>"treat2contl"</code>).
Along with <code>method.whomatch="conc.contl"</code>, two 1:1 matching methods are
applicable: (1) optimal matching (<code>"optimal"</code>), and (2) nearest neighbor
matching without caliper (<code>"nearest"</code>). Along with
<code>method.whomatch="conc.treat"</code> or <code>method.whomatch="conc.all"</code>,
ten matching methods are applicable: (1) optimal matching, where 1:1
matching is first done, followed by random sampling (<code>"optimal"</code>),
(2) nearest neighbor matching, where caliper is tuned iteratively
to obtain the fixed number of external controls (<code>"nearest"</code>), (3)
equally splitting patients in the current trial and taking the median of
each subset, followed by 1:1 optimal matching (<code>"medm.optimal"</code>), (4)
equally splitting patients in the current trial and taking the median of
each subset, followed by 1:1 nearest neighbor matching matching
(<code>"med.nearest"</code>), (5) k-means clustering of patients in the current
trial, followed by 1:1 optimal matching (<code>"km.optimal"</code>), (6) k-means
clustering of patients in the current trial, followed by 1:1 nearest neighbor
matching (<code>"km.nearest"</code>), (7) fuzzy c-means clustering of patients in
the current trial, followed by 1:1 optimal matching (<code>"cm.optimal"</code>),
(8) fuzzy c-means of patients in the current trial, followed by 1:1 nearest
neighbor matching (<code>"cm.nearest"</code>), (9) bootstrap sampling from patients
in the current trial, followed by 1:1 optimal matching
(<code>"boot.nearest"</code>), and (10) bootstrap sampling from patient in the
current trial, followed by 1:1 nearest neighbor matching
(<code>"boot.nearest"</code>). Along with <code>method.whomatch="treat2contl"</code>,
two matching methods are applicable: (1) optimal matching, followed by
random sampling (<code>"optimal"</code>), and (2) nearest neighbor matching, where
caliper is tuned iteratively to obtain the fixed number of external controls
(<code>"nearest"</code>).
</p>


<h3>Value</h3>

<p>The <code>psmatch</code> returns a list containing the following objects:
</p>
<table>
<tr><td><code>subjid.EC</code></td>
<td>
<p>Vector of subject ID of external control.</p>
</td></tr>
<tr><td><code>data.ps</code></td>
<td>
<p>Data frame with estimated propensity score.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Austin PC. A comparison of 12 algorithms for matching on the propensity
score. <em>Statistics in Medicine</em> 2014; 33:1057-1069.
</p>
<p>Lin J, Gamalo-Siebers M, Tiwari R. Propensity score matched augmented
controls in randomized clinical trials: A case study.
<em>Pharmaceutical Statistics</em> 2018; 17:629-647.
</p>
<p>Lin J, Gamalo-Siebers M, Tiwari R. Propensity-score-based priors for
Bayesian augmented control design. <em>Pharmaceutical Statistics</em> 2019;
18:223-238.
</p>
<p>Rosenbaum PR. Optimal matching for observational studies.
<em>Journal of the American Statistical Association</em> 1989; 84:1024-1032.
</p>
<p>Sawamoto R, Oba K, Matsuyama Y. Bayesian adaptive randomization design
incorporating propensity score-matched historical controls.
<em>Pharmaceutical Statistics</em> 2022; 21:1074-1089.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT       &lt;- 100
n.CC       &lt;- 50
nevent.C   &lt;- 100
n.ECp      &lt;- 1000
nevent.ECp &lt;- 800
accrual    &lt;- 16

out.mevent.CT &lt;- 6
out.mevent.CC &lt;- 6
driftHR       &lt;- 1

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.1,0.1)

indata &lt;- trial.simulation.t2e(
  n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
  n.ECp=n.ECp, nevent.ECp=nevent.ECp, accrual=accrual,
  out.mevent.CT, out.mevent.CC, driftHR,
  cov.C=cov.C, cov.cor.C=cov.cor.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect)

n.EC &lt;- 50

method.whomatch &lt;- "conc.treat"
method.matching &lt;- "optimal"
method.psorder  &lt;- NULL

psmatch(
  study~cov1+cov2, data=indata, n.EC=n.EC,
  method.whomatch=method.whomatch, method.matching=method.matching,
  method.psorder=method.psorder)
</code></pre>

<hr>
<h2 id='trial.simulation.bin'>Simulating binary data for current trial and external control</h2><span id='topic+trial.simulation.bin'></span>

<h3>Description</h3>

<p>A two-arm randomized clinical trial with a binary outcome, which is
augmented by external control data, is simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trial.simulation.bin(
 n.CT, n.CC, n.ECp,
 out.prob.CT, out.prob.CC, driftOR,
 cov.C, cov.cor.C, cov.EC, cov.cor.EC, cov.effect,
 seed=sample.int(.Machine$integer.max,1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trial.simulation.bin_+3A_n.ct">n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_n.cc">n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_n.ecp">n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_out.prob.ct">out.prob.CT</code></td>
<td>
<p>True rate of outcome in treatment group in the current
trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_out.prob.cc">out.prob.CC</code></td>
<td>
<p>True rate of outcome in concurrent control group in the
current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_driftor">driftOR</code></td>
<td>
<p>Odds ratio between concurrent and external control
for which the bias should be plotted (odds in external control divided by
odds in concurrent control).</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_cov.c">cov.C</code></td>
<td>
<p>List of covariate distributions for treatment and concurrent
control group in the current trial. Continuous and binary covariate are
applicable. The continuous covariate is assumed to follow a normal
distribution; for example, specified as
<code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary covariate is
assumed to follow a binomial distribution; for example, specified as
<code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is the column
name of the covariate in the data frame generated.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_cov.cor.c">cov.cor.C</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for treatment and concurrent control in the current trial,
specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_cov.ec">cov.EC</code></td>
<td>
<p>List of covariate distributions for external control. The
continuous covariate is assumed to follow a normal distribution; for example,
specified as <code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary
covariate is assumed to follow a binomial distribution; for example,
specified as <code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is
the column name of the covariate in the data frame generated, which must be
consistent with those used for <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_cov.cor.ec">cov.cor.EC</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for external control, specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_cov.effect">cov.effect</code></td>
<td>
<p>Vector of covariate effects on the outcome, specified as
odds ratio per one unit increase in continuous covariates or as odds ratio
between categories for binary covariates.</p>
</td></tr>
<tr><td><code id="trial.simulation.bin_+3A_seed">seed</code></td>
<td>
<p>Setting a seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The binary outcome is assumed to follow a binomial distribution.
Given more than one covariates with their effects on the outcome, a logistic
regression model is constructed for data generation. The data frame
generated include the binary outcome data and covariates for <code>n.CT</code>
and <code>n.CC</code> patients in treatment and concurrent control group in the
current trial respectively, and <code>n.ECp</code> patients in external control
pool. One record per patient. More than one covariates must be specified.
</p>


<h3>Value</h3>

<p>The <code>trial.simulation.bin</code> returns a data frame containing the
following variables:
</p>
<table>
<tr><td><code>study</code></td>
<td>
<p>Study indicator (0 for external control, and 1 for current
trial)</p>
</td></tr>
<tr><td><code>treat</code></td>
<td>
<p>Treatment indicator (0 for concurrent and external control, and
1 for treatment)</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Binary outcome</p>
</td></tr>
<tr><td><code>column name specified</code></td>
<td>
<p>Covariate of interest</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT  &lt;- 100
n.CC  &lt;- 50
n.ECp &lt;- 1000

out.prob.CT &lt;- 0.2
out.prob.CC &lt;- 0.2
driftOR     &lt;- 1.0

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.8,0.8)

trial.simulation.bin(
   n.CT=n.CT, n.CC=n.CC, n.ECp=n.ECp,
   out.prob.CT=out.prob.CT, out.prob.CC=out.prob.CC, driftOR=driftOR,
   cov.C=cov.C, cov.cor.C=cov.cor.C,
   cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect, seed=100)
</code></pre>

<hr>
<h2 id='trial.simulation.cont'>Simulating continuous data for current trial and external control</h2><span id='topic+trial.simulation.cont'></span>

<h3>Description</h3>

<p>A two-arm randomized clinical trial with a continuous outcome, which is
augmented by external control data, is simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trial.simulation.cont(
 n.CT, n.CC, n.ECp,
 out.mean.CT, out.sd.CT, out.mean.CC, out.sd.CC, driftdiff, out.sd.EC,
 cov.C, cov.cor.C, cov.EC, cov.cor.EC, cov.effect,
 seed=sample.int(.Machine$integer.max,1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trial.simulation.cont_+3A_n.ct">n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_n.cc">n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_n.ecp">n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_out.mean.ct">out.mean.CT</code></td>
<td>
<p>True mean of outcome in treatment group in the current
trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_out.sd.ct">out.sd.CT</code></td>
<td>
<p>True sd of outcome in treatment group in the current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_out.mean.cc">out.mean.CC</code></td>
<td>
<p>True mean of outcome in concurrent control group in the
current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_out.sd.cc">out.sd.CC</code></td>
<td>
<p>True sd of outcome in concurrent control group in the
current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_driftdiff">driftdiff</code></td>
<td>
<p>Mean difference between concurrent and external control
for which the bias should be plotted (mean in external control minus mean
in concurrent control).</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_out.sd.ec">out.sd.EC</code></td>
<td>
<p>True sd of outcome in external control.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_cov.c">cov.C</code></td>
<td>
<p>List of covariate distributions for treatment and concurrent
control group in the current trial. Continuous and binary covariate are
applicable. The continuous covariate is assumed to follow a normal
distribution; for example specified as
<code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary covariate is
assumed to follow a binomial distribution; for example, specified as
<code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is the column
name of the covariate in the data frame generated.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_cov.cor.c">cov.cor.C</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for treatment and concurrent control group in the current trial,
specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_cov.ec">cov.EC</code></td>
<td>
<p>List of covariate distributions for external control. The
continuous covariate is assumed to follow a normal distribution; for example,
specified as <code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary
covariate is assumed to follow a binomial distribution; for example,
specified as <code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is
the column name of the covariate in the data frame generated, which must be
consistent with those used for <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_cov.cor.ec">cov.cor.EC</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for external control, specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_cov.effect">cov.effect</code></td>
<td>
<p>Vector of covariate effects on the outcome, specified as
mean change per one unit increase in continuous covariates or as mean change
between categories for binary covariates.</p>
</td></tr>
<tr><td><code id="trial.simulation.cont_+3A_seed">seed</code></td>
<td>
<p>Setting a seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The continuous outcome is assumed to follow a normal distribution.
Given more than one covariates with their effects on the outcome, a normal
linear regression model is constructed for data generation. The data frame
generated include the continuous outcome data and covariates for <code>n.CT</code>
and <code>n.CC</code> patients in treatment and concurrent control group in the
current trial respectively, and <code>n.ECp</code> patients in external control
pool. One record per patient. More than one covariates must be specified.
</p>


<h3>Value</h3>

<p>The <code>trial.simulation.cont</code> returns a data frame containing the
following variables:
</p>
<table>
<tr><td><code>study</code></td>
<td>
<p>Study indicator (0 for external control, and 1 for current
trial)</p>
</td></tr>
<tr><td><code>treat</code></td>
<td>
<p>Treatment indicator (0 for concurrent and external control, and
1 for treatment)</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Continuous outcome</p>
</td></tr>
<tr><td><code>column name specified</code></td>
<td>
<p>Covariate of interest</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT  &lt;- 100
n.CC  &lt;- 50
n.ECp &lt;- 1000

out.mean.CT &lt;- 0
out.sd.CT   &lt;- 1
out.mean.CC &lt;- 0
out.sd.CC   &lt;- 1
driftdiff   &lt;- 0
out.sd.EC   &lt;- 1

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.1,0.1)

trial.simulation.cont(
  n.CT=n.CT, n.CC=n.CC, n.ECp=n.ECp,
  out.mean.CT=out.mean.CT, out.sd.CT=out.sd.CT,
  out.mean.CC=out.mean.CC, out.sd.CC=out.sd.CC,
  driftdiff=driftdiff, out.sd.EC=out.sd.EC,
  cov.C=cov.C, cov.cor.C=cov.cor.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect, seed=100)
</code></pre>

<hr>
<h2 id='trial.simulation.t2e'>Simulating time-to-event data for current trial and external control</h2><span id='topic+trial.simulation.t2e'></span>

<h3>Description</h3>

<p>A two-arm randomized clinical trial with a time-to-event outcome, which is
augmented by external control data, is simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trial.simulation.t2e(
 n.CT, n.CC, nevent.C, n.ECp, nevent.ECp, accrual,
 out.mevent.CT, out.mevent.CC, driftHR,
 cov.C, cov.cor.C, cov.EC, cov.cor.EC, cov.effect,
 seed=sample.int(.Machine$integer.max,1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trial.simulation.t2e_+3A_n.ct">n.CT</code></td>
<td>
<p>Number of patients in treatment group in the current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_n.cc">n.CC</code></td>
<td>
<p>Number of patients in concurrent control group in the current
trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_nevent.c">nevent.C</code></td>
<td>
<p>Number of events in treatment and concurrent control group
in the current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_n.ecp">n.ECp</code></td>
<td>
<p>Number of patients in external control pool.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_nevent.ecp">nevent.ECp</code></td>
<td>
<p>Number of events in external control pool.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_accrual">accrual</code></td>
<td>
<p>Accrual rate, defined as the number of enrolled patients per
month.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_out.mevent.ct">out.mevent.CT</code></td>
<td>
<p>True median time to event in treatment group in the
current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_out.mevent.cc">out.mevent.CC</code></td>
<td>
<p>True median time to event in concurrent control group
in the current trial.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_drifthr">driftHR</code></td>
<td>
<p>Hazard ratio between concurrent and external control for
which the bias should be plotted (hazard in external control divided by
hazard in concurrent control).</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_cov.c">cov.C</code></td>
<td>
<p>List of covariate distributions for treatment and concurrent
control group in the current trial. Continuous and binary covariate are
applicable. The continuous covariate is assumed to follow a normal
distribution; for example, specified as
<code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary covariate is
assumed to follow a binomial distribution; for example, specified as
<code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is the column
name of the covariate in the data frame generated.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_cov.cor.c">cov.cor.C</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for treatment and concurrent control group in the current trial,
specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_cov.ec">cov.EC</code></td>
<td>
<p>List of covariate distributions for external control. The
continuous covariate is assumed to follow a normal distribution; for example,
specified as <code>list(dist="norm", mean=0, sd=1, lab="cov1")</code>. The binary
covariate is assumed to follow a binomial distribution; for example,
specified as <code>list(dist="binom", prob=0.4, lab="cov2")</code>. <code>lab</code> is
the column name of the covariate in the data frame generated, which must be
consistent with those used for <code>cov.C</code>.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_cov.cor.ec">cov.cor.EC</code></td>
<td>
<p>Matrix of correlation coefficients for each pair of
covariate for external control, specified as Gaussian copula parameter.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_cov.effect">cov.effect</code></td>
<td>
<p>Vector of covariate effects on the outcome , specified as
hazard ratio per one unit increase in continuous covariates or as hazard
ratio between categories for binary covariates.</p>
</td></tr>
<tr><td><code id="trial.simulation.t2e_+3A_seed">seed</code></td>
<td>
<p>Setting a seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time to event outcome is assumed to follow a Weibull
distribution. Given more than one covariates with their effects on the
outcome, a Weibull proportional hazards model is constructed for data
generation. The data frame generated include the time-to-event outcome data
and covariates for <code>n.CT</code> and <code>n.CC</code> patients in treatment and
concurrent control group in the current trial respectively, and <code>n.ECp</code>
patients in external control pool. One record per patient. More than one
covariates must be specified.
</p>


<h3>Value</h3>

<p>The <code>trial.simulation.t2e</code> returns a data frame containing the
following variables:
</p>
<table>
<tr><td><code>study</code></td>
<td>
<p>Study indicator (0 for external control, and 1 for current
trial)</p>
</td></tr>
<tr><td><code>treat</code></td>
<td>
<p>Treatment indicator (0 for concurrent and external control, and
1 for treatment)</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Time to event or censoring</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>Censoring (0 for censored, and 1 for event occurred)</p>
</td></tr>
<tr><td><code>column name specified</code></td>
<td>
<p>Covariate of interest</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n.CT       &lt;- 100
n.CC       &lt;- 50
nevent.C   &lt;- 100
n.ECp      &lt;- 1000
nevent.ECp &lt;- 800
accrual    &lt;- 16

out.mevent.CT &lt;- 6
out.mevent.CC &lt;- 6
driftHR       &lt;- 1

cov.C &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
              list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.C &lt;- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.EC &lt;- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
               list(dist="binom",prob=0.4,lab="cov2"))

cov.cor.EC &lt;- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect &lt;- c(0.8,0.8)

trial.simulation.t2e(
   n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
   n.ECp=n.ECp, nevent.ECp=nevent.ECp, accrual=accrual,
   out.mevent.CT, out.mevent.CC, driftHR,
   cov.C=cov.C, cov.cor.C=cov.cor.C,
   cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect, seed=100)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
