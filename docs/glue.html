<!DOCTYPE html><html><head><title>Help for package glue</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glue}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_glue'><p>Coerce object to glue</p></a></li>
<li><a href='#glue'><p>Format and interpolate a string</p></a></li>
<li><a href='#glue_col'><p>Construct strings with color</p></a></li>
<li><a href='#glue_collapse'><p>Collapse a character vector</p></a></li>
<li><a href='#glue_safe'><p>Safely interpolate strings</p></a></li>
<li><a href='#glue_sql'><p>Interpolate strings with SQL escaping</p></a></li>
<li><a href='#glue-deprecated'><p>Deprecated Functions</p></a></li>
<li><a href='#identity_transformer'><p>Parse and Evaluate R code</p></a></li>
<li><a href='#quoting'><p>Quoting operators</p></a></li>
<li><a href='#trim'><p>Trim a character vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interpreted String Literals</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of interpreted string literals, inspired by
    Python's Literal String Interpolation
    <a href="https://www.python.org/dev/peps/pep-0498/">https://www.python.org/dev/peps/pep-0498/</a> and Docstrings
    <a href="https://www.python.org/dev/peps/pep-0257/">https://www.python.org/dev/peps/pep-0257/</a> and Julia's Triple-Quoted
    String Literals
    <a href="https://docs.julialang.org/en/v1.3/manual/strings/#Triple-Quoted-String-Literals-1">https://docs.julialang.org/en/v1.3/manual/strings/#Triple-Quoted-String-Literals-1</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://glue.tidyverse.org/">https://glue.tidyverse.org/</a>, <a href="https://github.com/tidyverse/glue">https://github.com/tidyverse/glue</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/glue/issues">https://github.com/tidyverse/glue/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>crayon, DBI (&ge; 1.2.0), dplyr, knitr, magrittr, rlang,
rmarkdown, RSQLite, testthat (&ge; 3.2.0), vctrs (&ge; 0.3.0),
waldo (&ge; 0.3.0), withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>bench, forcats, ggbeeswarm, ggplot2, R.utils,
rprintf, tidyr, tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 16:10:57 UTC; jenny</td>
</tr>
<tr>
<td>Author:</td>
<td>Jim Hester <a href="https://orcid.org/0000-0002-2739-7082"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jennifer Bryan <a href="https://orcid.org/0000-0002-6983-2759"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jennifer Bryan &lt;jenny@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 23:13:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_glue'>Coerce object to glue</h2><span id='topic+as_glue'></span>

<h3>Description</h3>

<p>A glue object is a character vector with S3 class <code>"glue"</code>. The <code>"glue"</code>
class implements a print method that shows the literal contents (rather than
the string implementation) and a <code>+</code> method, so that you can concatenate with
the addition operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_glue(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_glue_+3A_x">x</code></td>
<td>
<p>object to be coerced.</p>
</td></tr>
<tr><td><code id="as_glue_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with S3 class <code>"glue"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_glue(c("abc", "\"\\\\", "\n"))
x

x &lt;- 1
y &lt;- 3
glue("x + y") + " = {x + y}"
</code></pre>

<hr>
<h2 id='glue'>Format and interpolate a string</h2><span id='topic+glue'></span><span id='topic+glue_data'></span>

<h3>Description</h3>

<p>Expressions enclosed by braces will be evaluated as R code. Long strings are
broken by line and concatenated together. Leading whitespace and blank lines
from the first and last lines are automatically trimmed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glue_data(
  .x,
  ...,
  .sep = "",
  .envir = parent.frame(),
  .open = "{",
  .close = "}",
  .na = "NA",
  .null = character(),
  .comment = "#",
  .literal = FALSE,
  .transformer = identity_transformer,
  .trim = TRUE
)

glue(
  ...,
  .sep = "",
  .envir = parent.frame(),
  .open = "{",
  .close = "}",
  .na = "NA",
  .null = character(),
  .comment = "#",
  .literal = FALSE,
  .transformer = identity_transformer,
  .trim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glue_+3A_.x">.x</code></td>
<td>
<p>[<code>listish</code>]<br /> An environment, list, or data frame used to lookup values.</p>
</td></tr>
<tr><td><code id="glue_+3A_...">...</code></td>
<td>
<p>[<code>expressions</code>]<br /> Unnamed arguments are taken to be expression
string(s) to format. Multiple inputs are concatenated together before formatting.
Named arguments are taken to be temporary variables available for substitution.
</p>
<div class="sourceCode"><pre>For `glue_data()`, elements in `...` override the values in `.x`.
</pre></div></td></tr>
<tr><td><code id="glue_+3A_.sep">.sep</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;&quot;&quot;&rsquo;]<br /> Separator used to separate elements.</p>
</td></tr>
<tr><td><code id="glue_+3A_.envir">.envir</code></td>
<td>
<p>[<code>environment</code>: <code>parent.frame()</code>]<br /> Environment to evaluate each expression in. Expressions are
evaluated from left to right. If <code>.x</code> is an environment, the expressions are
evaluated in that environment and <code>.envir</code> is ignored. If <code>NULL</code> is passed, it is equivalent to <code><a href="base.html#topic+emptyenv">emptyenv()</a></code>.</p>
</td></tr>
<tr><td><code id="glue_+3A_.open">.open</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;\{&rsquo;]<br /> The opening delimiter. Doubling the
full delimiter escapes it.</p>
</td></tr>
<tr><td><code id="glue_+3A_.close">.close</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;\}&rsquo;]<br /> The closing delimiter. Doubling the
full delimiter escapes it.</p>
</td></tr>
<tr><td><code id="glue_+3A_.na">.na</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;NA&rsquo;]<br /> Value to replace <code>NA</code> values
with. If <code>NULL</code> missing values are propagated, that is an <code>NA</code> result will
cause <code>NA</code> output. Otherwise the value is replaced by the value of <code>.na</code>.</p>
</td></tr>
<tr><td><code id="glue_+3A_.null">.null</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;character()&rsquo;]<br /> Value to replace
NULL values with. If <code>character()</code> whole output is <code>character()</code>. If
<code>NULL</code> all NULL values are dropped (as in <code>paste0()</code>). Otherwise the
value is replaced by the value of <code>.null</code>.</p>
</td></tr>
<tr><td><code id="glue_+3A_.comment">.comment</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;#&rsquo;]<br /> Value to use as the comment
character.</p>
</td></tr>
<tr><td><code id="glue_+3A_.literal">.literal</code></td>
<td>
<p>[<code>boolean(1)</code>: &lsquo;FALSE&rsquo;]<br /> Whether to treat single or
double quotes, backticks, and comments as regular characters (vs. as
syntactic elements), when parsing the expression string. Setting <code>.literal = TRUE</code> probably only makes sense in combination with a custom
<code>.transformer</code>, as is the case with <code>glue_col()</code>. Regard this argument
(especially, its name) as experimental.</p>
</td></tr>
<tr><td><code id="glue_+3A_.transformer">.transformer</code></td>
<td>
<p>[<code style="white-space: pre;">&#8288;function]&#8288;</code><br /> A function taking two arguments, <code>text</code>
and <code>envir</code>, where <code>text</code> is the unparsed string inside the glue block and
<code>envir</code> is the execution environment. A <code>.transformer</code> lets you modify a
glue block before, during, or after evaluation, allowing you to create your
own custom <code>glue()</code>-like functions. See <code>vignette("transformers")</code> for
examples.</p>
</td></tr>
<tr><td><code id="glue_+3A_.trim">.trim</code></td>
<td>
<p>[<code>logical(1)</code>: &lsquo;TRUE&rsquo;]<br /> Whether to trim the input
template with <code><a href="#topic+trim">trim()</a></code> or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A glue object, as created by <code><a href="#topic+as_glue">as_glue()</a></code>.
</p>


<h3>See Also</h3>

<p><a href="https://www.python.org/dev/peps/pep-0498/">https://www.python.org/dev/peps/pep-0498/</a> and
<a href="https://www.python.org/dev/peps/pep-0257/">https://www.python.org/dev/peps/pep-0257/</a> upon which this is based.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name &lt;- "Fred"
age &lt;- 50
anniversary &lt;- as.Date("1991-10-12")
glue('My name is {name},',
  'my age next year is {age + 1},',
  'my anniversary is {format(anniversary, "%A, %B %d, %Y")}.')

# single braces can be inserted by doubling them
glue("My name is {name}, not {{name}}.")

# Named arguments can be used to assign temporary variables.
glue('My name is {name},',
  ' my age next year is {age + 1},',
  ' my anniversary is {format(anniversary, "%A, %B %d, %Y")}.',
  name = "Joe",
  age = 40,
  anniversary = as.Date("2001-10-12"))

# `glue()` can also be used in user defined functions
intro &lt;- function(name, profession, country){
  glue("My name is {name}, a {profession}, from {country}")
}
intro("Shelmith", "Senior Data Analyst", "Kenya")
intro("Cate", "Data Scientist", "Kenya")

# `glue_data()` is useful in magrittr pipes
if (require(magrittr)) {

mtcars %&gt;% glue_data("{rownames(.)} has {hp} hp")

# Or within dplyr pipelines
if (require(dplyr)) {

head(iris) %&gt;%
  mutate(description = glue("This {Species} has a petal length of {Petal.Length}"))

}}

# Alternative delimiters can also be used if needed
one &lt;- "1"
glue("The value of $e^{2\\pi i}$ is $&lt;&lt;one&gt;&gt;$.", .open = "&lt;&lt;", .close = "&gt;&gt;")
</code></pre>

<hr>
<h2 id='glue_col'>Construct strings with color</h2><span id='topic+glue_col'></span><span id='topic+glue_data_col'></span>

<h3>Description</h3>

<p>The <a href="crayon.html#topic+crayon">crayon</a> package defines a number of functions used to
color terminal output. <code>glue_col()</code> and <code>glue_data_col()</code> functions provide
additional syntax to make using these functions in glue strings easier.
</p>
<p>Using the following syntax will apply the function <code><a href="crayon.html#topic+crayon">crayon::blue()</a></code> to the text 'foo bar'.
</p>
<div class="sourceCode"><pre>{blue foo bar}
</pre></div>
<p>If you want an expression to be evaluated, simply place that in a normal brace
expression (these can be nested).
</p>
<div class="sourceCode"><pre>{blue 1 + 1 = {1 + 1}}
</pre></div>
<p>If the text you want to color contains, e.g., an unpaired quote or a comment
character, specify <code>.literal = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glue_col(..., .envir = parent.frame(), .na = "NA", .literal = FALSE)

glue_data_col(.x, ..., .envir = parent.frame(), .na = "NA", .literal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glue_col_+3A_...">...</code></td>
<td>
<p>[<code>expressions</code>]<br /> Unnamed arguments are taken to be expression
string(s) to format. Multiple inputs are concatenated together before formatting.
Named arguments are taken to be temporary variables available for substitution.
</p>
<div class="sourceCode"><pre>For `glue_data()`, elements in `...` override the values in `.x`.
</pre></div></td></tr>
<tr><td><code id="glue_col_+3A_.envir">.envir</code></td>
<td>
<p>[<code>environment</code>: <code>parent.frame()</code>]<br /> Environment to evaluate each expression in. Expressions are
evaluated from left to right. If <code>.x</code> is an environment, the expressions are
evaluated in that environment and <code>.envir</code> is ignored. If <code>NULL</code> is passed, it is equivalent to <code><a href="base.html#topic+emptyenv">emptyenv()</a></code>.</p>
</td></tr>
<tr><td><code id="glue_col_+3A_.na">.na</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;NA&rsquo;]<br /> Value to replace <code>NA</code> values
with. If <code>NULL</code> missing values are propagated, that is an <code>NA</code> result will
cause <code>NA</code> output. Otherwise the value is replaced by the value of <code>.na</code>.</p>
</td></tr>
<tr><td><code id="glue_col_+3A_.literal">.literal</code></td>
<td>
<p>[<code>boolean(1)</code>: &lsquo;FALSE&rsquo;]<br /> Whether to treat single or
double quotes, backticks, and comments as regular characters (vs. as
syntactic elements), when parsing the expression string. Setting <code>.literal = TRUE</code> probably only makes sense in combination with a custom
<code>.transformer</code>, as is the case with <code>glue_col()</code>. Regard this argument
(especially, its name) as experimental.</p>
</td></tr>
<tr><td><code id="glue_col_+3A_.x">.x</code></td>
<td>
<p>[<code>listish</code>]<br /> An environment, list, or data frame used to lookup values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A glue object, as created by <code><a href="#topic+as_glue">as_glue()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(crayon)

glue_col("{blue foo bar}")

glue_col("{blue 1 + 1 = {1 + 1}}")

glue_col("{blue 2 + 2 = {green {2 + 2}}}")

white_on_black &lt;- bgBlack $ white
glue_col("{white_on_black
  Roses are {red {colors()[[552]]}},
  Violets are {blue {colors()[[26]]}},
  `glue_col()` can show \\
  {red c}{yellow o}{green l}{cyan o}{blue r}{magenta s}
  and {bold bold} and {underline underline} too!
}")

# this would error due to an unterminated quote, if we did not specify
# `.literal = TRUE`
glue_col("{yellow It's} happening!", .literal = TRUE)

# `.literal = TRUE` also prevents an error here due to the `#` comment
glue_col(
  "A URL: {magenta https://github.com/tidyverse/glue#readme}",
  .literal = TRUE
)

# `.literal = TRUE` does NOT prevent evaluation
x &lt;- "world"
y &lt;- "day"
glue_col("hello {x}! {green it's a new {y}!}", .literal = TRUE)

</code></pre>

<hr>
<h2 id='glue_collapse'>Collapse a character vector</h2><span id='topic+glue_collapse'></span><span id='topic+glue_sql_collapse'></span>

<h3>Description</h3>

<p><code>glue_collapse()</code> collapses a character vector of any length into a length 1 vector.
<code>glue_sql_collapse()</code> does the same but returns a <code style="white-space: pre;">&#8288;[DBI::SQL()]&#8288;</code>
object rather than a glue object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glue_collapse(x, sep = "", width = Inf, last = "")

glue_sql_collapse(x, sep = "", width = Inf, last = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glue_collapse_+3A_x">x</code></td>
<td>
<p>The character vector to collapse.</p>
</td></tr>
<tr><td><code id="glue_collapse_+3A_sep">sep</code></td>
<td>
<p>a character string to separate the terms.  Not
<code><a href="base.html#topic+NA_character_">NA_character_</a></code>.</p>
</td></tr>
<tr><td><code id="glue_collapse_+3A_width">width</code></td>
<td>
<p>The maximum string width before truncating with <code>...</code>.</p>
</td></tr>
<tr><td><code id="glue_collapse_+3A_last">last</code></td>
<td>
<p>String used to separate the last two items if <code>x</code> has at least
2 items.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns a length-1 glue object, as created by <code><a href="#topic+as_glue">as_glue()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>glue_collapse(glue("{1:10}"))

# Wide values can be truncated
glue_collapse(glue("{1:10}"), width = 5)

glue_collapse(1:4, ", ", last = " and ")
</code></pre>

<hr>
<h2 id='glue_safe'>Safely interpolate strings</h2><span id='topic+glue_safe'></span><span id='topic+glue_data_safe'></span>

<h3>Description</h3>

<p><code>glue_safe()</code> and <code>glue_data_safe()</code> differ from <code><a href="#topic+glue">glue()</a></code> and <code><a href="#topic+glue_data">glue_data()</a></code>
in that the safe versions only look up symbols from an environment using
<code><a href="base.html#topic+get">get()</a></code>. They do not execute any R code. This makes them suitable for use
with untrusted input, such as inputs in a Shiny application, where using the
normal functions would allow an attacker to execute arbitrary code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glue_safe(..., .envir = parent.frame())

glue_data_safe(.x, ..., .envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glue_safe_+3A_...">...</code></td>
<td>
<p>[<code>expressions</code>]<br /> Unnamed arguments are taken to be expression
string(s) to format. Multiple inputs are concatenated together before formatting.
Named arguments are taken to be temporary variables available for substitution.
</p>
<div class="sourceCode"><pre>For `glue_data()`, elements in `...` override the values in `.x`.
</pre></div></td></tr>
<tr><td><code id="glue_safe_+3A_.envir">.envir</code></td>
<td>
<p>[<code>environment</code>: <code>parent.frame()</code>]<br /> Environment to evaluate each expression in. Expressions are
evaluated from left to right. If <code>.x</code> is an environment, the expressions are
evaluated in that environment and <code>.envir</code> is ignored. If <code>NULL</code> is passed, it is equivalent to <code><a href="base.html#topic+emptyenv">emptyenv()</a></code>.</p>
</td></tr>
<tr><td><code id="glue_safe_+3A_.x">.x</code></td>
<td>
<p>[<code>listish</code>]<br /> An environment, list, or data frame used to lookup values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A glue object, as created by <code><a href="#topic+as_glue">as_glue()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"1 + 1" &lt;- 5
# glue actually executes the code
glue("{1 + 1}")

# glue_safe just looks up the value
glue_safe("{1 + 1}")

rm("1 + 1")
</code></pre>

<hr>
<h2 id='glue_sql'>Interpolate strings with SQL escaping</h2><span id='topic+glue_sql'></span><span id='topic+glue_data_sql'></span>

<h3>Description</h3>

<p>SQL databases often have custom quotation syntax for identifiers and strings
which make writing SQL queries error prone and cumbersome to do. <code>glue_sql()</code> and
<code>glue_data_sql()</code> are analogs to <code><a href="#topic+glue">glue()</a></code> and <code><a href="#topic+glue_data">glue_data()</a></code> which handle the
SQL quoting. <code>glue_sql_collapse()</code> can be used to collapse <code><a href="DBI.html#topic+SQL">DBI::SQL()</a></code> objects.
</p>
<p>They automatically quote character results, quote identifiers if the glue
expression is surrounded by backticks '<code style="white-space: pre;">&#8288;`&#8288;</code>' and do not quote
non-characters such as numbers. If numeric data is stored in a character
column (which should be quoted) pass the data to <code>glue_sql()</code> as a
character.
</p>
<p>Returning the result with <code><a href="DBI.html#topic+SQL">DBI::SQL()</a></code> will suppress quoting if desired for
a given value.
</p>
<p>Note <a href="https://solutions.posit.co/connections/db/best-practices/run-queries-safely/#parameterized-queries">parameterized queries</a>
are generally the safest and most efficient way to pass user defined
values in a query, however not every database driver supports them.
</p>
<p>If you place a <code>*</code> at the end of a glue expression the values will be
collapsed with commas. This is useful for the <a href="https://www.w3schools.com/sql/sql_in.asp">SQL IN Operator</a>
for instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glue_sql(
  ...,
  .con,
  .sep = "",
  .envir = parent.frame(),
  .open = "{",
  .close = "}",
  .na = DBI::SQL("NULL"),
  .null = character(),
  .comment = "#",
  .literal = FALSE,
  .trim = TRUE
)

glue_data_sql(
  .x,
  ...,
  .con,
  .sep = "",
  .envir = parent.frame(),
  .open = "{",
  .close = "}",
  .na = DBI::SQL("NULL"),
  .null = character(),
  .comment = "#",
  .literal = FALSE,
  .trim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glue_sql_+3A_...">...</code></td>
<td>
<p>[<code>expressions</code>]<br /> Unnamed arguments are taken to be expression
string(s) to format. Multiple inputs are concatenated together before formatting.
Named arguments are taken to be temporary variables available for substitution.
</p>
<div class="sourceCode"><pre>For `glue_data()`, elements in `...` override the values in `.x`.
</pre></div></td></tr>
<tr><td><code id="glue_sql_+3A_.con">.con</code></td>
<td>
<p>[<code>DBIConnection</code>]: A DBI connection object obtained from
<code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.sep">.sep</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;&quot;&quot;&rsquo;]<br /> Separator used to separate elements.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.envir">.envir</code></td>
<td>
<p>[<code>environment</code>: <code>parent.frame()</code>]<br /> Environment to evaluate each expression in. Expressions are
evaluated from left to right. If <code>.x</code> is an environment, the expressions are
evaluated in that environment and <code>.envir</code> is ignored. If <code>NULL</code> is passed, it is equivalent to <code><a href="base.html#topic+emptyenv">emptyenv()</a></code>.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.open">.open</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;\{&rsquo;]<br /> The opening delimiter. Doubling the
full delimiter escapes it.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.close">.close</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;\}&rsquo;]<br /> The closing delimiter. Doubling the
full delimiter escapes it.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.na">.na</code></td>
<td>
<p>[<code>character(1)</code>: <code>DBI::SQL("NULL")</code>]<br /> Value to replace
<code>NA</code> values with. If <code>NULL</code> missing values are propagated, that is an <code>NA</code>
result will cause <code>NA</code> output. Otherwise the value is replaced by the
value of <code>.na</code>.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.null">.null</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;character()&rsquo;]<br /> Value to replace
NULL values with. If <code>character()</code> whole output is <code>character()</code>. If
<code>NULL</code> all NULL values are dropped (as in <code>paste0()</code>). Otherwise the
value is replaced by the value of <code>.null</code>.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.comment">.comment</code></td>
<td>
<p>[<code>character(1)</code>: &lsquo;#&rsquo;]<br /> Value to use as the comment
character.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.literal">.literal</code></td>
<td>
<p>[<code>boolean(1)</code>: &lsquo;FALSE&rsquo;]<br /> Whether to treat single or
double quotes, backticks, and comments as regular characters (vs. as
syntactic elements), when parsing the expression string. Setting <code>.literal = TRUE</code> probably only makes sense in combination with a custom
<code>.transformer</code>, as is the case with <code>glue_col()</code>. Regard this argument
(especially, its name) as experimental.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.trim">.trim</code></td>
<td>
<p>[<code>logical(1)</code>: &lsquo;TRUE&rsquo;]<br /> Whether to trim the input
template with <code><a href="#topic+trim">trim()</a></code> or not.</p>
</td></tr>
<tr><td><code id="glue_sql_+3A_.x">.x</code></td>
<td>
<p>[<code>listish</code>]<br /> An environment, list, or data frame used to lookup values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="DBI.html#topic+SQL">DBI::SQL()</a></code> object with the given query.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glue_sql_collapse">glue_sql_collapse()</a></code> to collapse <code><a href="DBI.html#topic+SQL">DBI::SQL()</a></code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
iris2 &lt;- iris
colnames(iris2) &lt;- gsub("[.]", "_", tolower(colnames(iris)))
DBI::dbWriteTable(con, "iris", iris2)
var &lt;- "sepal_width"
tbl &lt;- "iris"
num &lt;- 2
val &lt;- "setosa"
glue_sql("
  SELECT {`var`}
  FROM {`tbl`}
  WHERE {`tbl`}.sepal_length &gt; {num}
    AND {`tbl`}.species = {val}
  ", .con = con)

# If sepal_length is store on the database as a character explicitly convert
# the data to character to quote appropriately.
glue_sql("
  SELECT {`var`}
  FROM {`tbl`}
  WHERE {`tbl`}.sepal_length &gt; {as.character(num)}
    AND {`tbl`}.species = {val}
  ", .con = con)


# `glue_sql()` can be used in conjuction with parameterized queries using
# `DBI::dbBind()` to provide protection for SQL Injection attacks
 sql &lt;- glue_sql("
    SELECT {`var`}
    FROM {`tbl`}
    WHERE {`tbl`}.sepal_length &gt; ?
  ", .con = con)
query &lt;- DBI::dbSendQuery(con, sql)
DBI::dbBind(query, list(num))
DBI::dbFetch(query, n = 4)
DBI::dbClearResult(query)

# `glue_sql()` can be used to build up more complex queries with
# interchangeable sub queries. It returns `DBI::SQL()` objects which are
# properly protected from quoting.
sub_query &lt;- glue_sql("
  SELECT *
  FROM {`tbl`}
  ", .con = con)

glue_sql("
  SELECT s.{`var`}
  FROM ({sub_query}) AS s
  ", .con = con)

# If you want to input multiple values for use in SQL IN statements put `*`
# at the end of the value and the values will be collapsed and quoted appropriately.
glue_sql("SELECT * FROM {`tbl`} WHERE sepal_length IN ({vals*})",
  vals = 1, .con = con)

glue_sql("SELECT * FROM {`tbl`} WHERE sepal_length IN ({vals*})",
  vals = 1:5, .con = con)

glue_sql("SELECT * FROM {`tbl`} WHERE species IN ({vals*})",
  vals = "setosa", .con = con)

glue_sql("SELECT * FROM {`tbl`} WHERE species IN ({vals*})",
  vals = c("setosa", "versicolor"), .con = con)

# If you need to reference variables from multiple tables use `DBI::Id()`.
# Here we create a new table of nicknames, join the two tables together and
# select columns from both tables. Using `DBI::Id()` and the special
# `glue_sql()` syntax ensures all the table and column identifiers are quoted
# appropriately.

iris_db &lt;- "iris"
nicknames_db &lt;- "nicknames"

nicknames &lt;- data.frame(
  species = c("setosa", "versicolor", "virginica"),
  nickname = c("Beachhead Iris", "Harlequin Blueflag", "Virginia Iris"),
  stringsAsFactors = FALSE
)

DBI::dbWriteTable(con, nicknames_db, nicknames)

cols &lt;- list(
  DBI::Id(iris_db, "sepal_length"),
  DBI::Id(iris_db, "sepal_width"),
  DBI::Id(nicknames_db, "nickname")
)

iris_species &lt;- DBI::Id(iris_db, "species")
nicknames_species &lt;- DBI::Id(nicknames_db, "species")

query &lt;- glue_sql("
  SELECT {`cols`*}
  FROM {`iris_db`}
  JOIN {`nicknames_db`}
  ON {`iris_species`}={`nicknames_species`}",
  .con = con
)
query

DBI::dbGetQuery(con, query, n = 5)

DBI::dbDisconnect(con)

</code></pre>

<hr>
<h2 id='glue-deprecated'>Deprecated Functions</h2><span id='topic+glue-deprecated'></span>

<h3>Description</h3>

<p>These functions are Deprecated in this release of glue, they will be removed
in a future version.
</p>

<hr>
<h2 id='identity_transformer'>Parse and Evaluate R code</h2><span id='topic+identity_transformer'></span>

<h3>Description</h3>

<p>This is a simple wrapper around <code>eval(parse())</code>, used as the default
transformer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identity_transformer(text, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identity_transformer_+3A_text">text</code></td>
<td>
<p>Text (typically) R code to parse and evaluate.</p>
</td></tr>
<tr><td><code id="identity_transformer_+3A_envir">envir</code></td>
<td>
<p>environment to evaluate the code in</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>vignette("transformers", "glue")</code> for documentation on creating
custom glue transformers and some common use cases.
</p>

<hr>
<h2 id='quoting'>Quoting operators</h2><span id='topic+quoting'></span><span id='topic+single_quote'></span><span id='topic+double_quote'></span><span id='topic+backtick'></span>

<h3>Description</h3>

<p>These functions make it easy to quote each individual element and are useful
in conjunction with <code><a href="#topic+glue_collapse">glue_collapse()</a></code>. These are thin wrappers around
<code><a href="base.html#topic+encodeString">base::encodeString()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_quote(x)

double_quote(x)

backtick(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quoting_+3A_x">x</code></td>
<td>
<p>A character to quote.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same length as <code>x</code>, with the same
attributes (including names and dimensions) but with no class set.
</p>
<p>Marked UTF-8 encodings are preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
glue('Values of x: {glue_collapse(backtick(x), sep = ", ", last = " and ")}')
</code></pre>

<hr>
<h2 id='trim'>Trim a character vector</h2><span id='topic+trim'></span>

<h3>Description</h3>

<p>This trims a character vector according to the trimming rules used by glue.
These follow similar rules to <a href="https://www.python.org/dev/peps/pep-0257/">Python Docstrings</a>,
with the following features.
</p>

<ul>
<li><p> Leading and trailing whitespace from the first and last lines is removed.
</p>
</li>
<li><p> A uniform amount of indentation is stripped from the second line on, equal
to the minimum indentation of all non-blank lines after the first.
</p>
</li>
<li><p> Lines can be continued across newlines by using <code style="white-space: pre;">&#8288;\\&#8288;</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>trim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_x">x</code></td>
<td>
<p>A character vector to trim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>glue("
    A formatted string
    Can have multiple lines
      with additional indention preserved
    ")

glue("
  \ntrailing or leading newlines can be added explicitly\n
  ")

glue("
    A formatted string \\
    can also be on a \\
    single line
    ")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
