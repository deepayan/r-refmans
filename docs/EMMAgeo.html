<!DOCTYPE html><html lang="en"><head><title>Help for package EMMAgeo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EMMAgeo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EMMAgeo-package'><p>End-member modelling algorithm and supporting functions for unmixing</p>
grain-size distributions and further compositional data.</a></li>
<li><a href='#check.data'><p>Check correctness and consistency of input data</p></a></li>
<li><a href='#click.limits'><p>Define mode limits by mouse clicks.</p></a></li>
<li><a href='#convert.units'><p>Convert between phi and micrometers.</p></a></li>
<li><a href='#create.EM'><p>Create grain-size-distributions.</p></a></li>
<li><a href='#EMMA'><p>End-member modelling analysis algorithm.</p></a></li>
<li><a href='#EMpot'><p>example data</p></a></li>
<li><a href='#EMrob'><p>example data</p></a></li>
<li><a href='#get.l'><p>Generate a vector of weight transformation values from l.min to l.max.</p></a></li>
<li><a href='#get.l.opt'><p>Identify optimum weight transformation value</p></a></li>
<li><a href='#get.limits'><p>Infer lower and upper mode position limits to define robust end-members.</p></a></li>
<li><a href='#get.q'><p>Generate a parameter matrix with q.min and q.max values for robust EMMA.</p></a></li>
<li><a href='#GUI'><p>Start GUI for EMMA</p></a></li>
<li><a href='#interpolate.classes'><p>Interpolate data between different classes.</p></a></li>
<li><a href='#mix.EM'><p>Function to mix sample spectres.</p></a></li>
<li><a href='#model.EM'><p>Model all possible end-member scenarios</p></a></li>
<li><a href='#residual.EM'><p>Calculate a residual end-member loading.</p></a></li>
<li><a href='#robust.EM'><p>Extract robust end-members</p></a></li>
<li><a href='#robust.loadings'><p>Extract robust end-member loadings</p></a></li>
<li><a href='#robust.scores'><p>Extract robust end-member scores.</p></a></li>
<li><a href='#test.factors'><p>Calculate the initial cumulative explained variance of factors.</p></a></li>
<li><a href='#test.l'><p>Test a vector of weight transformation limits for mximum value.</p></a></li>
<li><a href='#test.l.max'><p>Find maximum possible wight transformation value.</p></a></li>
<li><a href='#test.parameters'><p>Evaluate influence of model parameters.</p></a></li>
<li><a href='#test.robustness'><p>Test model robustness.</p></a></li>
<li><a href='#X'><p>example data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>End-Member Modelling of Grain-Size Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Dietze, Elisabeth Dietze</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Dietze &lt;mdietze@gfz-potsdam.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>End-member modelling analysis of grain-size data is an approach 
    to unmix a data set's underlying distributions and their contribution to 
    the data set. EMMAgeo provides deterministic and robust protocols for 
    that purpose. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>GPArotation, limSolve, caTools, shiny, matrixStats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-16 14:21:35 UTC; mdietze</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-16 15:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='EMMAgeo-package'>End-member modelling algorithm and supporting functions for unmixing 
grain-size distributions and further compositional data.</h2><span id='topic+EMMAgeo-package'></span><span id='topic+EMMAgeo'></span>

<h3>Description</h3>

<p>EMMAgeo provides a set of functions for end-member modelling analysis
(EMMA) of grain-size data and other cases of compositional data. EMMA 
describes a multivariate data set of m samples, each comprising n parameters 
(e.g. grain-size classes), as a linear combination of end-member loadings 
(the underlying distributions) and end-member scores (the contribution of
each loading to each sample).<br /> EMMA can be run in two principal ways, 
a deterministic and a robust, including modelling the uncertainties. The 
deterministic way can be accessed simply with the function <code>EMMA()</code>. 
For the robust way there are two protocols that need to be respected. There 
is a compact protocol, which is mainly automated but needs adjustments by 
the user, and there is an extended protocol, which allows access to all 
parameterisation steps of robust EMMA.<br /> The package contains further 
auxiliary functions to check and prepare input data, test parameters and
use a graphic user interface for deterministic EMMA. The package also 
contains an example data set, comprising meaured grain-size distributions 
of real world sediment end-members.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> EMMAgeo</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
0.9.7</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2019-05-10</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>

<hr>
<h2 id='check.data'>Check correctness and consistency of input data</h2><span id='topic+check.data'></span>

<h3>Description</h3>

<p>The input data matrix (<code>X</code>), number of end-members (<code>q</code>), 
weight transformation limits (l) and constant sum scaling parameter 
(<code>c</code>) are checked. This includes checking for absence of missing 
values, columns containing only zero-values and for numeric data type of 
all variables. A furthercheck tests if <code>l</code> is below the maximum 
possible value, preventing numerical instability prior to factor rotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.data(X, q, l, c, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.data_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="check.data_+3A_q">q</code></td>
<td>
<p><code>Numeric</code> scalar, number of end-members to be modelled.</p>
</td></tr>
<tr><td><code id="check.data_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> scalar or vector, weight transformation
limit, i.e.  quantile.</p>
</td></tr>
<tr><td><code id="check.data_+3A_c">c</code></td>
<td>
<p><code>Numeric</code> scalar, constant sum scaling parameter, e.g.
1, 100, 1000.</p>
</td></tr>
<tr><td><code id="check.data_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Character</code> vector, verbose test results.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

## perform data set check
check.data(X = X, 
           q = 6, 
           l = seq(from = 0, 
                   to = 0.2, 
                   by = 0.01), 
           c = 1)

</code></pre>

<hr>
<h2 id='click.limits'>Define mode limits by mouse clicks.</h2><span id='topic+click.limits'></span>

<h3>Description</h3>

<p>This function allows defining limits for robust end-members by mouse clicks
on a combined plot output, showing a histogram and all end-members together.
Clicks must be placed in the order lower limit, upper limit - for each
end-member successively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>click.limits(data, n, classunits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="click.limits_+3A_data">data</code></td>
<td>
<p><code>List</code> object, output of <code><a href="#topic+test.robustness">test.robustness</a></code>.</p>
</td></tr>
<tr><td><code id="click.limits_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> scalar, number of target end-members.</p>
</td></tr>
<tr><td><code id="click.limits_+3A_classunits">classunits</code></td>
<td>
<p><code>Numeric</code> vector, optional class units (e.g. 
micrometers or phi-units).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> matrix, limit classes. The first row contains lower
limits, the second row upper limits for each end-member.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.robustness">test.robustness</a></code>, <code><a href="#topic+robust.EM">robust.EM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

## Test robustness
q &lt;- 4:7
l &lt;- seq(from = 0, to = 0.1, by = 0.02)
TR &lt;- test.robustness(X = X, q = q, l = l)

## define 2 limits by mouse clicks (uncomment to use).
# limits &lt;- click.limits(data = TR, n = 2)
# limits  

</code></pre>

<hr>
<h2 id='convert.units'>Convert between phi and micrometers.</h2><span id='topic+convert.units'></span>

<h3>Description</h3>

<p>The function converts values from the phi-scale to the micrometer-scale and
vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.units(phi, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.units_+3A_phi">phi</code></td>
<td>
<p><code>Numeric</code> vector, grain-size class values in phi to be
converted.</p>
</td></tr>
<tr><td><code id="convert.units_+3A_mu">mu</code></td>
<td>
<p><code>Numeric</code> vector, grain-size class values in micrometres 
to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector, converted grain-size class values.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpolate.classes">interpolate.classes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate phi-values
phi &lt;- -2:5

## convert and show phi to mu
mu  &lt;- convert.units(phi = phi)
mu

## convert and show mu to phi
convert.units(mu = mu)

</code></pre>

<hr>
<h2 id='create.EM'>Create grain-size-distributions.</h2><span id='topic+create.EM'></span>

<h3>Description</h3>

<p>This function allows creating artificial grain-size end-members. One such
&quot;artificial end-member loading&quot; may be composed of one or more superimposed
normal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.EM(p1, p2, s, boundaries, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.EM_+3A_p1">p1</code></td>
<td>
<p><code>Numeric</code> vector, means of normal distributions, i.e. mode
positions.</p>
</td></tr>
<tr><td><code id="create.EM_+3A_p2">p2</code></td>
<td>
<p><code>Numeric</code> vector, standard deviations of normal 
distributions, i.e. mode width.</p>
</td></tr>
<tr><td><code id="create.EM_+3A_s">s</code></td>
<td>
<p><code>Numeric</code> vector, relative proportions of each mode, i.e.
relative mode height.</p>
</td></tr>
<tr><td><code id="create.EM_+3A_boundaries">boundaries</code></td>
<td>
<p><code>Numeric</code> vector of length two with class boundaries 
(i.e. <code>c(lower boundary, upper boundary)</code>).</p>
</td></tr>
<tr><td><code id="create.EM_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> scalar with number of classes, i.e. resolution of 
the end-member.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When building a data set of many artificial end member loadings, these 
should all have the same <code>boundaries</code> and <code>n</code>. The function 
builds composites of individual normal distributions. Each distribution is 
scaled according to <code>s</code>. Finally the distribution is scaled to 100 %.
</p>


<h3>Value</h3>

<p><code>Numeric</code> vector with normalised end-member loadings, 
consisting of the mixed normal distributions according to the input 
parameters.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mix.EM">mix.EM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set lower and upper class boundary, number of classes and class units
boundaries &lt;- c(0, 11)
n &lt;- 40
phi &lt;- seq(from = boundaries[1], 
           to = boundaries[2], 
           length.out = n)

## create two artificial end-member loadings
EMa.1 &lt;- create.EM(p1 = c(2, 5), p2 = c(1, 0.8), s = c(0.7, 0.3), 
                   boundaries = boundaries, n = n)
EMa.2 &lt;- create.EM(p1 = c(4, 7), p2 = c(1.1, 1.4), s = c(0.5, 0.5),
                   boundaries = boundaries, n = n)

## plot the two artificial end-member loadings
plot(phi, EMa.1, type = "l")
lines(phi, EMa.2, col = "red")

</code></pre>

<hr>
<h2 id='EMMA'>End-member modelling analysis algorithm.</h2><span id='topic+EMMA'></span>

<h3>Description</h3>

<p>A multivariate data set (m samples composed of n variables) is decomposed by
eigenspace analysis and modelled with a given number of end-members (q).
Several steps of scaling, transformation, normalisation, eigenspace
decomposition, factor rotation, data modelling and evaluation are performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMMA(
  X,
  q,
  l,
  c,
  Vqn,
  classunits,
  ID,
  EM.ID,
  rotation = "Varimax",
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMMA_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="EMMA_+3A_q">q</code></td>
<td>
<p><code>Numeric</code> scalar, number of end-members to be modelled.</p>
</td></tr>
<tr><td><code id="EMMA_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> scalar or vector, weight transformation
limit, i.e.  quantile. Set to zero if omitted.</p>
</td></tr>
<tr><td><code id="EMMA_+3A_c">c</code></td>
<td>
<p><code>Numeric</code> scalar, constant sum scaling parameter, e.g.
1, 100, 1000. Set to 100 if omitted.</p>
</td></tr>
<tr><td><code id="EMMA_+3A_vqn">Vqn</code></td>
<td>
<p><code>Numeric</code> matrix, optional unscaled user-defined
end-member loadings. If provided, these are used instead of model-derived
ones. See details.</p>
</td></tr>
<tr><td><code id="EMMA_+3A_classunits">classunits</code></td>
<td>
<p><code>Numeric</code> vector, optional class units 
(e.g. micrometers or phi-units) of the same length as columns of <code>X</code>.</p>
</td></tr>
<tr><td><code id="EMMA_+3A_id">ID</code></td>
<td>
<p><code>Numeric</code> or character vector, optional sample IDs of the 
same length as rows of X.</p>
</td></tr>
<tr><td><code id="EMMA_+3A_em.id">EM.ID</code></td>
<td>
<p><code>Character</code> vector, end-member names. If present, 
these will be set as row-names of the output data set and used in the 
legend text.</p>
</td></tr>
<tr><td><code id="EMMA_+3A_rotation">rotation</code></td>
<td>
<p><code>Character</code> scalar, rotation type, default is 
&quot;Varimax&quot;. See details.</p>
</td></tr>
<tr><td><code id="EMMA_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> scalar, optional graphical output of the results,
default is FALSE. If set to TRUE, end-member loadings and end-member scores
are plotted.</p>
</td></tr>
<tr><td><code id="EMMA_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function. Since the
function returns two plots some additional graphical parameters must be
specified as vector with the first element for the first plot and the second
element for the second plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>Vqn</code> is useful when <code>EMMA</code> shall be performed with 
a set of prior unscaled end-members, e.g. from other data sets that are to 
be used as reference or when modelling a data set with mean end-members, as
in the output of <code>robust.loadings</code>.<br />
The rotation type <code>Varimax</code> was used by Dietze et al. (2012). In this 
R package, one out of the rotations provided by the package GPArotation 
is possible, as well. However, tests showed that the rotation type has no 
dramatic consequences for the result.<br /> 
The function values <code>$loadings</code> and <code>$scores</code> are redundant. They 
are essentially the same as <code>$Vqsn</code> and <code>$Mqs</code>. However, they are 
included for user convenience.
</p>


<h3>Value</h3>

<p>A list with numeric matrix objects. </p>
<table role = "presentation">
<tr><td><code>loadings</code></td>
<td>
<p>Normalised
rescaled end-member loadings.</p>
</td></tr> <tr><td><code>scores</code></td>
<td>
<p>Rescaled end-member scores.</p>
</td></tr>
<tr><td><code>Vqn</code></td>
<td>
<p>Normalised end-member loadings.</p>
</td></tr> <tr><td><code>Vqsn</code></td>
<td>
<p>Normalised rescaled
end-member loadings.</p>
</td></tr> <tr><td><code>Mqs</code></td>
<td>
<p>Rescaled end-member scores.</p>
</td></tr>
<tr><td><code>Xm</code></td>
<td>
<p>Modelled data.</p>
</td></tr> <tr><td><code>modes</code></td>
<td>
<p>Mode class of end-member loadings.</p>
</td></tr>
<tr><td><code>Mqs.var</code></td>
<td>
<p>Explained variance of end-members</p>
</td></tr> <tr><td><code>Em</code></td>
<td>
<p>Absolute
row-wise model error.</p>
</td></tr> <tr><td><code>En</code></td>
<td>
<p>Absolute column-wise model error.</p>
</td></tr> 
<tr><td><code>RMSEm</code></td>
<td>
<p>row-wise root mean square erroe</p>
</td></tr> <tr><td><code>RMSEn</code></td>
<td>
<p>column-wise root 
mean square erroe</p>
</td></tr> <tr><td><code>Rm</code></td>
<td>
<p>Row-wise (sample-wise) explained variance.</p>
</td></tr> 
<tr><td><code>Rn</code></td>
<td>
<p>Column-wise (variable-wise) explained variance.</p>
</td></tr> <tr><td><code>ol</code></td>
<td>
<p>Number 
of overlapping end-members.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180.<br />
Klovan JE, Imbrie J. 1971. An Algorithm and FORTRAN-IV Program for
Large-Scale Q-Mode Factor Analysis and Calculation of Factor Scores.
Mathematical Geology 3: 61-77. Miesch AT. 1976. Q-Mode factor analysis of
geochemical and petrologic data matrices with constant row sums. U.S.
Geological Survey Professsional Papers 574.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.parameters">test.parameters</a></code>, <code><a href="GPArotation.html#topic+rotations">rotations</a></code>,
<code><a href="base.html#topic+eigen">eigen</a></code>, <code><a href="limSolve.html#topic+nnls">nnls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data and set phi-vector
data(example_X)
phi &lt;- seq(from = 1, to = 10, length.out = ncol(X))

## perform EMMA with 5 end-members
EM &lt;- EMMA(X = X, q = 5, l = 0.05, c = 100, plot = TRUE)

## perform EMMA with 4 end-members and more graphical settings
EM &lt;- EMMA(X = X, q = 4, l = 0.05, c = 100, 
           plot = TRUE,
           EM.ID = c("EM 1", "EM 2", "EM 3", "EM 4"),
           classunits = phi,
           xlab = c(expression(paste("Class [", phi, "]")), "Sample ID"),
           cex = 0.7,
           col = rainbow(n = 4))

</code></pre>

<hr>
<h2 id='EMpot'>example data</h2><span id='topic+EMpot'></span>

<h3>Description</h3>

<p>A list with output of the function test.robustness()
</p>


<h3>Format</h3>

<p>The format is: List of 8 $ q : num [1:90] 4 4 4 4 4 4 4 4 4 4 ...  $
lw : num [1:90] 0 0 0 0 0.05 0.05 0.05 0.05 0.1 0.1 ...  $ modes : num
[1:90] 12 32 61 80 12 32 61 80 12 32 ...</p>


<h3>Details</h3>

<p>The dataset is the result of the function test.robustness() of the R-package
EMMAgeo.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_EMpot)

</code></pre>

<hr>
<h2 id='EMrob'>example data</h2><span id='topic+EMrob'></span>

<h3>Description</h3>

<p>Robust end-members, a list with output of the function robust.EM()
</p>


<h3>Format</h3>

<p>The format is: List of 12 $ Vqsn.data :List of 4 ..$ : num [1:15,
1:80] 0.18929 0.184 0.18304 0.00698 0.02033 ...</p>


<h3>Details</h3>

<p>The dataset is the result of the function robust.EM() of the R-package
EMMAgeo.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_EMrob)

</code></pre>

<hr>
<h2 id='get.l'>Generate a vector of weight transformation values from l.min to l.max.</h2><span id='topic+get.l'></span>

<h3>Description</h3>

<p>This function generates a sequence of weight transformation values that
range from l_min (by default zero) to l_max (by default 95 % of the 
maximum possible value). It uses the function <code>test.l.max()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.l(X, n = 10, max = 0.95, min = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.l_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="get.l_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> scalar, length of the output vector (by default 10).</p>
</td></tr>
<tr><td><code id="get.l_+3A_max">max</code></td>
<td>
<p><code>Numeric</code> scalar, fraction of the maximum value 
(by default 0.95).</p>
</td></tr>
<tr><td><code id="get.l_+3A_min">min</code></td>
<td>
<p><code>Numeric</code> scalar, minimum value (by default zero).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector of class <code>"EMMAgeo_l"</code>, weight 
transformation values.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.l.max">test.l.max</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

## infer l-vector
l &lt;- get.l(X = X, 
           n = 5, 
           max = 0.8, 
           min = 0.02)

</code></pre>

<hr>
<h2 id='get.l.opt'>Identify optimum weight transformation value</h2><span id='topic+get.l.opt'></span>

<h3>Description</h3>

<p>This function returns for a series of input vaules the weight 
transformation value, which yielded the highest measure of model quality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.l.opt(X, l, quality = "mRt", Vqn, rotation, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.l.opt_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="get.l.opt_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> vector, weight transformation values to test.</p>
</td></tr>
<tr><td><code id="get.l.opt_+3A_quality">quality</code></td>
<td>
<p><code>Character</code> scalar, quality measure for against 
which to test the influence of <code>l</code>. See details for a list 
of the a vailable keywords. Default is <code>"mRt"</code>.</p>
</td></tr>
<tr><td><code id="get.l.opt_+3A_vqn">Vqn</code></td>
<td>
<p><code>Numeric</code> matrix specifying optional unscaled user-defined
end-member loadings.</p>
</td></tr>
<tr><td><code id="get.l.opt_+3A_rotation">rotation</code></td>
<td>
<p><code>Character</code> scalar, rotation type, default is &quot;Varimax&quot;
(cf. <code><a href="#topic+EMMA">EMMA</a></code> for further information).</p>
</td></tr>
<tr><td><code id="get.l.opt_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> scalar, optional graphical output of the result.</p>
</td></tr>
<tr><td><code id="get.l.opt_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>quality</code> can be one out of the following keywords: 
<code>"mRm"</code>, <code>"mRn"</code>, <code>"mRt"</code>, <code>"mEm"</code>, <code>"mEn"</code> and 
<code>"mEt"</code>. See <code><a href="#topic+EMMA">EMMA</a></code> for definition of these keywords.
</p>


<h3>Value</h3>

<p><code>Numeric</code> scalar, weight tranformation value with optimal 
EMMA result.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)
data(example_EMpot)

## get optimal l-value, uncomment to run
# get.l.opt(X = X, 
#           l = seq(from = 0, to = 0.1, by = 0.01), 
#           Vqn = EMpot$Vqn, 
#           quality = "mRt")

</code></pre>

<hr>
<h2 id='get.limits'>Infer lower and upper mode position limits to define robust end-members.</h2><span id='topic+get.limits'></span>

<h3>Description</h3>

<p>This function identifies the lower and upper limits within which robust 
end-members have clustered mode positions. It uses a kernel density estimate
of the mode positions of all input end-member loadings, clips it at a 
user-defined minimum density and returns the resulting rising and falling 
shoulders of the kde peaks as limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.limits(loadings, classunits, bw, threshold = 0.7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.limits_+3A_loadings">loadings</code></td>
<td>
<p><code>Numeric</code> matrix, m loadings (rows) and n classes 
(columns).</p>
</td></tr>
<tr><td><code id="get.limits_+3A_classunits">classunits</code></td>
<td>
<p><code>Numeric</code> vector, optional class units 
(e.g. micrometers or phi-units) of the same length as columns of <code>X</code>.</p>
</td></tr>
<tr><td><code id="get.limits_+3A_bw">bw</code></td>
<td>
<p><code>Numeric</code> scalar, bandwidth of the kernel, moved over the 
data set. If omitted, the default value of 1 
used.</p>
</td></tr>
<tr><td><code id="get.limits_+3A_threshold">threshold</code></td>
<td>
<p><code>Numeric</code> scalar, threshold quantile which is used to 
identify mode clusters. Only kde densities above this values are kept and 
used to derieve mode cluster limits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the threshold above which a mode cluster is identified is an 
arbitrary, user-defined value and probably needs to be adjusted iteratively
to get reasonable results. The default value may or may not be adequate!
</p>


<h3>Value</h3>

<p><code>Numeric</code> matrix with lower and upper mode limits.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>, <code><a href="#topic+model.EM">model.EM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_EMpot)

## infer mode cluster limits
limits &lt;- get.limits(loadings = EMpot)

</code></pre>

<hr>
<h2 id='get.q'>Generate a parameter matrix with q.min and q.max values for robust EMMA.</h2><span id='topic+get.q'></span>

<h3>Description</h3>

<p>This function uses the input data matrix <code>X</code> and a vector of weight
transformation limits to generate a matrix of minimum and maximum likely 
numbers of end-members to be used to model and extract robust end-members.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.q(
  X,
  l = 0,
  q.min = 2,
  q.max = 10,
  criteria.min = 0.5,
  criteria.max = "local_max",
  correct.output = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.q_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="get.q_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> vector, weight transformation limits, default 
is zero.</p>
</td></tr>
<tr><td><code id="get.q_+3A_q.min">q.min</code></td>
<td>
<p><code>Numeric</code> scalar, minimum number of end-members to use, 
default is 2.</p>
</td></tr>
<tr><td><code id="get.q_+3A_q.max">q.max</code></td>
<td>
<p><code>Numeric</code> scalar, maximum number of end-members to use, 
default is 10.</p>
</td></tr>
<tr><td><code id="get.q_+3A_criteria.min">criteria.min</code></td>
<td>
<p><code>Numeric</code> scalar, minimum value of explained 
variance reached to be a valid model realisation, default is 0.5.</p>
</td></tr>
<tr><td><code id="get.q_+3A_criteria.max">criteria.max</code></td>
<td>
<p><code>Character</code> or numeric scalar, either keyword 
<code>"local_max"</code> to use first local maximum or any numeric value of 
explained variance, default is <code>"local_max"</code>.</p>
</td></tr>
<tr><td><code id="get.q_+3A_correct.output">correct.output</code></td>
<td>
<p><code>Logical</code> scalar, option to correct the output 
for twisted values and remove combinations with NA-values. See details.</p>
</td></tr>
<tr><td><code id="get.q_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>q.min</code> should be at least 2 because otherwise the 
entire dataset would consist of one end-member and there would be no
variability at all. The parameter <code>q.max</code> is set to 10 by default,
based on practical issues. In natural systems, there are only rarely 
occasions when such a high number of sediment transport regimes may be
preserved in and can be resolved from sedimentary deposits. The parameter
<code>l</code> should be a vector between the minimum possible (zero) and maximum
possible value (by definition the median, 0.5, but usually a lower value).
Whensubmitting only a scalar, the variability can be only due to the range
of possible endmembers (between <code>q.min</code> and <code>q.max</code>). If the 
parameter <code>correct.output</code> is enabled, this can decrease the number of 
valid values for <code>l</code>, i.e. the number of rows of the output matrix 
may no longer be the same as the length of the input vector of <code>l</code>. In 
such a case the vector <code>l</code> must be replaced by the rownames of the 
output matrix (<code>l &lt;- as.numeric(rownames(get.q()))</code>).
</p>


<h3>Value</h3>

<p><code>Numeric</code> matrix of class <code>"EMMAgeo_q"</code>, minimum and 
maximum numbers of end-members as well as corresponding weight 
transformation values as rownames.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>, <code><a href="#topic+test.parameters">test.parameters</a></code>, 
<code><a href="#topic+test.robustness">test.robustness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data("example_X")

## create parameter matrix
get.q(X = X, l = c(0, 0.05, 0.10, 0.15))

</code></pre>

<hr>
<h2 id='GUI'>Start GUI for EMMA</h2><span id='topic+GUI'></span>

<h3>Description</h3>

<p>This function starts a browser-based graphic user interface for EMMA. The 
GUI has so far been tested on a Linux system, both with the browser of 
RStudio and Mozilla Firefox. It permits basic access to import, display 
and model a user-provided data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GUI(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GUI_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code><a href="shiny.html#topic+runApp">runApp</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use own data set, this should be a plain ASCII file with samples 
organsised as rows and grain-size classes organised as columns. The ASCII 
file can be separated by spaces, commas, semi colons or tab stops. The 
file may contain a leading column with sample IDs and/or one leading row 
with grain-size class breaks. To run EMMA make sure that there are no 
classes that contain only zeros throught all samples (i.e., remove them 
beforehand, e.g., by <code>X = X[,colSums(X) &gt; 0]</code>).
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>See Also</h3>

<p><code><a href="shiny.html#topic+runApp">runApp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Start the GUI
GUI()

## End(Not run)

</code></pre>

<hr>
<h2 id='interpolate.classes'>Interpolate data between different classes.</h2><span id='topic+interpolate.classes'></span>

<h3>Description</h3>

<p>This function interpolates grain-size data for different classes, either to 
higher or to lower resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate.classes(
  X,
  boundaries.in,
  boundaries.out,
  method = "natural",
  fixed.start = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate.classes_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="interpolate.classes_+3A_boundaries.in">boundaries.in</code></td>
<td>
<p><code>Numeric</code> vector, class boundaries of the 
input data.</p>
</td></tr>
<tr><td><code id="interpolate.classes_+3A_boundaries.out">boundaries.out</code></td>
<td>
<p><code>Numeric</code> vector, class boundaries of the output
data.</p>
</td></tr>
<tr><td><code id="interpolate.classes_+3A_method">method</code></td>
<td>
<p><code>Logical</code> scalar, interpolation method, one out of 
&quot;linear&quot; (linear interpolation), &quot;fmm&quot; (cubic spline), &quot;natural&quot; 
(natural spline), &quot;periodic&quot; (periodic spline). Default is <code>"natural"</code>.</p>
</td></tr>
<tr><td><code id="interpolate.classes_+3A_fixed.start">fixed.start</code></td>
<td>
<p><code>Logocal</code> scalar, specifying if the outer boundaries 
should be set to the same values as in the original matrix, default is 
<code>TRUE</code>. This may become necessary to avoid interpolation errors, see 
example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> matrix, interpolated class values.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>, <code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="stats.html#topic+spline">spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(example_X)
classes.in &lt;- seq(from = 1, to = 10, length.out = ncol(X))
  
## Example 1 - decrease the class numbers
## define number of output classes
classes.out &lt;- seq(1, 10, length.out = 20)

## interpolate the data set
Y &lt;- interpolate.classes(X = X, 
                         boundaries.in = classes.in, 
                         boundaries.out = classes.out,
                         method = "linear")

## show original vs. interpolation for first 10 samples
plot(NA, xlim = c(1, 10), ylim = c(0, 40))
for(i in 1:10) {
  lines(classes.in, X[i,] * 20 + i)
  lines(classes.out, Y[i,] * 20 + i, col = 2)
}

## Example 2 - increase the class numbers
## define number of output classes
classes.out &lt;- seq(1, 10, length.out = 200)

## interpolate the data set
Y &lt;- interpolate.classes(X = X, 
                         boundaries.in = classes.in, 
                         boundaries.out = classes.out)

## show original vs. interpolation for first 10 samples
plot(NA, xlim = c(1, 10), ylim = c(0, 40))
for(i in 1:10) {
  lines(classes.in, X[i,] * 20 + i)
  lines(classes.out, Y[i,] * 20 + i, col = 2)
}

</code></pre>

<hr>
<h2 id='mix.EM'>Function to mix sample spectres.</h2><span id='topic+mix.EM'></span>

<h3>Description</h3>

<p>This functions allows to mix grain-size distributions with specified
proportions and defined noise levels, for example to test the goodness of
the EMMA algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix.EM(EM, proportion, noise, autocorrelation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mix.EM_+3A_em">EM</code></td>
<td>
<p><code>Numeric</code> matrix, grain-size distribution definitions.
</p>
<p>Each definition is in a separate row with variable contributions in columns.</p>
</td></tr>
<tr><td><code id="mix.EM_+3A_proportion">proportion</code></td>
<td>
<p><code>Numeric</code> vector, relative proportions of each
distribution per sample.</p>
</td></tr>
<tr><td><code id="mix.EM_+3A_noise">noise</code></td>
<td>
<p><code>Numeric</code> scalar, optional relative white noise levels.</p>
</td></tr>
<tr><td><code id="mix.EM_+3A_autocorrelation">autocorrelation</code></td>
<td>
<p><code>Numeric</code> scalar, the degree of
autocorrelation among classes.  Autocorrelation is realised as running mean
of the specified length. Only odd values are allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function multiplies each end-member with the respective proportion
value, sums the resulting variables, adds uniform noise and normalises the
resulting mixed sample to 100 %.
</p>


<h3>Value</h3>

<p><code>Numeric</code> vector, a sample composed of known proportions of
end-members.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.EM">create.EM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## define end-member loadings and phi vector
EMa.1 &lt;- create.EM(p1 = c(2, 8), p2 = c(1, 0.8), s = c(0.7, 0.3), 
                   boundaries = c(0, 11), n = 80)
EMa.2 &lt;- create.EM(p1 = c(4, 7), p2 = c(1.1, 1.4), s = c(0.5, 0.5),
                   boundaries = c(0, 11), n = 80)
EMa   &lt;- rbind(EMa.1, EMa.2)

phi   &lt;- seq(0, 11, length.out = 80)

## mix end-member loadings
sample1 &lt;- mix.EM(EMa, proportion = c(0.3, 0.7))
sample2 &lt;- mix.EM(EMa, proportion = c(0.5, 0.5), noise = 0.1,
                  autocorrelation = 3)

## plot end-member loadings (grey) and resulting samples (black)
plot(phi, EMa.1, type="l", col = "grey")
lines(phi, EMa.2, col = "grey")
lines(phi, sample1)
lines(phi, sample2)

</code></pre>

<hr>
<h2 id='model.EM'>Model all possible end-member scenarios</h2><span id='topic+model.EM'></span>

<h3>Description</h3>

<p>This function takes a definition of weight transformation 
limits and corresponding minimum and maximum numbers of end-members to 
model all end-member scenarios in accordance with these parameters. Based 
on the output the user can decide on robust end-members.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.EM(X, q, l, classunits, plot = TRUE, col.q = TRUE, bw, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.EM_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="model.EM_+3A_q">q</code></td>
<td>
<p><code>Numeric</code> matrix, definitions of minimum and maximum number
of end-members (cf. <code>get.q()</code>), required.</p>
</td></tr>
<tr><td><code id="model.EM_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> vector, weight transformation limit values, 
corresponding to the matrix q, required.</p>
</td></tr>
<tr><td><code id="model.EM_+3A_classunits">classunits</code></td>
<td>
<p><code>Numeric</code> vector, optional class units 
(e.g. micrometers or phi-units) of the same length as columns of <code>X</code>.</p>
</td></tr>
<tr><td><code id="model.EM_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> scalar, option to plot the results (cf. 
details for explanations), default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="model.EM_+3A_col.q">col.q</code></td>
<td>
<p><code>Logical</code> scalar, option to colour end-member loadings by
the number of end-members which were used to create the model realisation,
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="model.EM_+3A_bw">bw</code></td>
<td>
<p><code>Numeric</code> scalar, optional manual setting of the kde 
bandwidth. By default, bw is calculated as 1 percent of the number of 
grain-size classes.</p>
</td></tr>
<tr><td><code id="model.EM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot output is an overlay of several data. The coloured lines in the 
background are end-member loadings (number noted in the plot title), 
resulting from all possible model scenarios. If <code>col.q == TRUE</code> they
are coloured according to the number of end-members with which the model 
was generated. This colour scheme allows to depict end-members that emerge
for model realisations with specific number of end-members. The thick 
black line is a kernel density estimate curve, generated from the mode 
positions of all end-members. The kernel bandwidth is set to 1 percent of 
the number of grain-size classes of the input data set, which gave useful
results for most of our test data sets. The cumulaitve dot-line-plot is a
further visualisation of end-member mode positions. The function is a 
modified wrapper function for the function <code>test.robustness()</code>.
</p>


<h3>Value</h3>

<p><code>List</code> object with all modelled end-members, each described by
input parameters, mode position, quality measures and value distributions.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>, <code><a href="#topic+test.l.max">test.l.max</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

## define input parameters
l &lt;- c(0, 0.05, 0.10)
q &lt;- cbind(c(2, 2, 3), c(5, 6, 4))

## infer l-vector
em_pot &lt;- model.EM(X = X, q = q, l = l)

</code></pre>

<hr>
<h2 id='residual.EM'>Calculate a residual end-member loading.</h2><span id='topic+residual.EM'></span>

<h3>Description</h3>

<p>This function calculates an optional residual end-member loading. It uses
the modelled end-member loadings as input and evaluates the root of 1 minus
the sum of all squared loadings. The residual end-member can be used to 
analyse the remaining variance, e.g.  if not all (robust) EMs are included 
(cf. Dietze et al., 2012). Negative values are set to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual.EM(Vqn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residual.EM_+3A_vqn">Vqn</code></td>
<td>
<p><code>Numeric</code> matrix, m unscaled robust end-member loadings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector, residual end-member loading.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>, <code><a href="#topic+robust.EM">robust.EM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(example_X)
data(example_EMrob)

## define mean robust end-member loadings
Vqn &lt;- EMMA(X = X, q = 2, plot = TRUE)$loadings

## perform residual end-member loading calculation
Vqn.res &lt;- residual.EM(Vqn)

## model EMMA with the residual end-member
E_res &lt;- EMMA(X = X, 
              q = 3, 
              Vqn = rbind(Vqn, Vqn.res), 
              plot = TRUE)

</code></pre>

<hr>
<h2 id='robust.EM'>Extract robust end-members</h2><span id='topic+robust.EM'></span>

<h3>Description</h3>

<p>This function takes a list object with potential end-member loadings and 
extracts those with modes in specified limits to describe them by mean and
standard deviation and use these descriptions to propagate the uncertainties
to end-member scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust.EM(
  em,
  limits,
  classunits,
  amount,
  l,
  mc_n,
  type = "mean",
  qt = c(0.25, 0.75),
  cores = 1,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust.EM_+3A_em">em</code></td>
<td>
<p><code>List</code> of class <code>"EMMAgeo_empot"</code>, i.e. the outout of 
<code>model.em()</code> or <code>test.robustness()</code>, containing potential 
end-members, both in unscaled and rescaled version as well as further 
parameters.</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_limits">limits</code></td>
<td>
<p><code>Numeric</code> matrix with two columns, defining the class 
limits for the robust end-members to calculate. The first column defines the 
lower limits, the second column the upper limits. End-members are organised 
in rows.</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_classunits">classunits</code></td>
<td>
<p><code>Numeric</code> vector, optional class units 
(e.g. micrometers or phi-units) of the same length as columns of <code>X</code>.</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_amount">amount</code></td>
<td>
<p><code>Numeric</code> matrix with two columns, defining the minimum 
and maximum amount of the modal class for each end-member.</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> scalar, weight transformation limit for 
modelling the average end-member output.</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_mc_n">mc_n</code></td>
<td>
<p><code>Numeric</code> scalar, number of Monte Carlo simulations to 
estimate end-member scores uncertainty. The default setting is ten times the 
product of number of end-members and number of weight transformation limits. 
The latter is inherited from <code>model.em()</code>. To disable modelling of 
scores uncertainty, set <code>mc_n = 0</code>.</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_type">type</code></td>
<td>
<p><code>Character</code> scalar, type of oadings statistics. One out of 
<code>"mean"</code> and <code>"median"</code>. Default is <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_qt">qt</code></td>
<td>
<p><code>Numeric</code> vector of length two, quantiles to describe 
end-member loadings. Default is <code>c(0.25, 0.75)</code> (i.e., the quartile 
range).</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_cores">cores</code></td>
<td>
<p><code>Numeric</code> scalar, number of CPU cores to be used for 
calculations. Only useful in multicore architectures. Default is <code>1</code> 
(single core).</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> scalar, option for plot output. Default is 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="robust.EM_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>EMMA</code> and <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used to extract potential end-member loadings based on their
mode positions and, optionally the height of the mode class, and use them to 
infer mean and stanard deviation of all 
end-members that match the group criteria defined by <code>limits</code>. These 
information are then used to model the uncertainty of the corresponding
end-member scores. The function uses input from two preceeding approaches. 
In a compact protocol <code>model.em</code> delivers these data in a predefined 
way. In the extended protocol <code>test.robustness</code> does this.
</p>


<h3>Value</h3>

<p><code>List</code> with statistic descriptions of end-member loadings 
and scores.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robust.loadings">robust.loadings</a></code>, <code><a href="#topic+robust.scores">robust.scores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## load example data set
data(example_X)

## get weight transformation limit vector
l &lt;- get.l(X = X)

## get minimum and maximum number of end-members
q &lt;- get.q(X = X, l = l)

## get all potential model scenarios
EM_pot &lt;- model.EM(X = X, q = q, plot = TRUE)

## define end-member mode class limits
limits &lt;- cbind(c(61, 74, 95, 102), 
                c(64, 76, 100, 105))

## get robust end-members in the default way, with plot output
rem &lt;- robust.EM(em = EM_pot,
                 limits = limits,
                 plot = TRUE)
                    
## get robust end-members by only modelling uncertainty in loadings
robust_EM &lt;- robust.EM(em = EM_pot, 
                       limits = limits, 
                       plot = TRUE)


## End(Not run)
                    
</code></pre>

<hr>
<h2 id='robust.loadings'>Extract robust end-member loadings</h2><span id='topic+robust.loadings'></span>

<h3>Description</h3>

<p>This function takes a list object with potential end-member loadings and 
extracts those with modes in specified limits to describe them by mean and
standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust.loadings(
  em,
  limits,
  classunits,
  amount,
  type = "mean",
  qt = c(0.25, 0.75),
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust.loadings_+3A_em">em</code></td>
<td>
<p><code>List</code> of class <code>"EMMAgeo_empot"</code>, i.e. the outout of 
<code>model.EM()</code> or <code>test.robustness()</code>, containing potential 
end-members, both in unscaled and rescaled version as well as further 
parameters.</p>
</td></tr>
<tr><td><code id="robust.loadings_+3A_limits">limits</code></td>
<td>
<p><code>Numeric</code> matrix with two columns, defining the class limits 
for the robust end-members to calculate. The first column defines the lower
limits, the second column the upper limits. End-members are organised in 
rows.</p>
</td></tr>
<tr><td><code id="robust.loadings_+3A_classunits">classunits</code></td>
<td>
<p><code>Numeric</code> vector, optional class units 
(e.g. micrometers or phi-units) of the same length as the number of 
(grain-size) classes per sample.</p>
</td></tr>
<tr><td><code id="robust.loadings_+3A_amount">amount</code></td>
<td>
<p><code>Numeric</code> matrix with two columns, defining the minimum and 
maximum amount of the modal class for each end-member.</p>
</td></tr>
<tr><td><code id="robust.loadings_+3A_type">type</code></td>
<td>
<p><code>Character</code> scalar, type of statistics. One out of 
<code>"mean"</code> and <code>"median"</code>. Default is <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="robust.loadings_+3A_qt">qt</code></td>
<td>
<p><code>Numeric</code> vector of length two, quantiles to describe 
end-member loadings Default is <code>c(0.25, 0.75)</code> (i.e., 
the quartile range).</p>
</td></tr>
<tr><td><code id="robust.loadings_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> scalar, option to enable plot output. Default 
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="robust.loadings_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>EMMA</code> and <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>List</code> with statistic descriptions of unscaled and scaled 
end-member loadings.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robust.EM">robust.EM</a></code>, <code><a href="#topic+robust.scores">robust.scores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set, potential end-members, output of model.EM()
data(example_EMpot)

## define limits for robust end-members
limits &lt;- cbind(c(61, 74, 95, 102), 
                c(64, 76, 100, 105))

## get robust end-member loadings with plot output
robust_loadings &lt;- robust.loadings(em = EMpot,
                                   limits = limits,
                                   plot = TRUE)
                    
</code></pre>

<hr>
<h2 id='robust.scores'>Extract robust end-member scores.</h2><span id='topic+robust.scores'></span>

<h3>Description</h3>

<p>This function takes a list object with statistics of end-member loadings and 
propagates these uncertainties to end-member scores using Monte Carlo 
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust.scores(loadings, l, mc_n, cores = 1, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust.scores_+3A_loadings">loadings</code></td>
<td>
<p><code>List</code> of class <code>"EMMAgeo_robload"</code>, i.e. the 
outout of <code>robust.loadings()</code>, containing statistic descriptions of 
robust end-member loadings.</p>
</td></tr>
<tr><td><code id="robust.scores_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> scalar, weight transformation limit to use for 
modelling the average end-member output. Can be output of 
<code>get.l.opt()</code>. If omitted, it is set to <code>0</code>.</p>
</td></tr>
<tr><td><code id="robust.scores_+3A_mc_n">mc_n</code></td>
<td>
<p><code>Numeric</code> scalar, number of Monte Carlo simulations to 
estimate end-member scores uncertainty. The default setting is ten times the 
product of number of end-members and number of weight transformation limits. 
The latter is inherited from <code>model.em()</code>. To disable modelling of 
scores uncertainty, set <code>mc_n = 0</code>.</p>
</td></tr>
<tr><td><code id="robust.scores_+3A_cores">cores</code></td>
<td>
<p><code>Numeric</code> scalar, number of CPU cores to be used for 
calculations. Only useful in multicore architectures. Default is <code>1</code> 
(single core).</p>
</td></tr>
<tr><td><code id="robust.scores_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> scalar, option for plot output. Default is 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="robust.scores_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>EMMA</code> and <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>List</code> with statistic descriptions of robust end-member 
scores.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robust.EM">robust.EM</a></code>, <code><a href="#topic+robust.loadings">robust.loadings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set, potential end-members, output of model.EM()
data(example_EMpot)

## define limits for robust end-members
limits &lt;- cbind(c(61, 74, 95, 102), 
                c(64, 76, 100, 105))

## get robust end-member loadings
robust_loadings &lt;- robust.loadings(em = EMpot, limits = limits)

## model end-member scores uncertainties with minimum Monte Carlo runs
robust_scores &lt;- robust.scores(loadings = robust_loadings, 
                               mc_n = 5, 
                               plot = TRUE)
                    
</code></pre>

<hr>
<h2 id='test.factors'>Calculate the initial cumulative explained variance of factors.</h2><span id='topic+test.factors'></span>

<h3>Description</h3>

<p>This function performs eigenspace decomposition using the weight-transformed
matrix W to determine the explained variance with increasing number of 
factors. Depending on the number of provided weight transformation limits 
(<code>l</code>) a vector or a matrix is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.factors(X, l, c, r.min = 0.95, plot = FALSE, legend, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.factors_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="test.factors_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> vector, weight tranformation limits, i.e.
quantiles; default is 0.</p>
</td></tr>
<tr><td><code id="test.factors_+3A_c">c</code></td>
<td>
<p><code>Numeric</code> scalar, constant sum scaling parameter, e.g.
1, 100, 1000; default is 100.</p>
</td></tr>
<tr><td><code id="test.factors_+3A_r.min">r.min</code></td>
<td>
<p><code>Numeric</code> scalar, minimum value of explained variance to
be reached by the end-members included, default is 0.95.</p>
</td></tr>
<tr><td><code id="test.factors_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> scalar, optional graphical output of the results,
default is FALSE.</p>
</td></tr>
<tr><td><code id="test.factors_+3A_legend">legend</code></td>
<td>
<p><code>Character</code> scalar, specify legend position (cf.
<code><a href="graphics.html#topic+legend">legend</a></code>). If omitted, no legend will be plotted, default is no
legend.</p>
</td></tr>
<tr><td><code id="test.factors_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function. Use
<code>colour</code> instead of <code>col</code> to create different colours.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results may be used to define a minimum number of end-members for
subsequent modelling steps, e.g. by using the Kaiser criterion, which
demands a minimum number of eigenvalues to reach a squared R of 0.95.
</p>


<h3>Value</h3>

<p><code>List</code> with objects </p>
<table role = "presentation">
<tr><td><code>L</code></td>
<td>
<p>Vector or matrix of cumulative
explained variance.</p>
</td></tr> <tr><td><code>q.min</code></td>
<td>
<p>Vector with number of factors that passed
r.min. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

## create sequence of weight transformation limits
l &lt;- seq(from = 0, to = 0.2, 0.02)

## perform the test and show q.min
L &lt;- test.factors(X = X, l = l, c = 100, plot = TRUE)
L$q.min

## a visualisation with more plot parameters
L &lt;- test.factors(X = X, l = l, c = 100, plot = TRUE, 
                  ylim = c(0.5, 1), xlim = c(1, 7), 
                  legend = "bottomright", cex = 0.7)

## another visualisation, a close-up
plot(1:7, L$L[1,1:7], type = "l", 
     xlab = "q", ylab = "Explained variance")
for(i in 2:7) {lines(1:7, L$L[i,1:7], col = i)}

</code></pre>

<hr>
<h2 id='test.l'>Test a vector of weight transformation limits for mximum value.</h2><span id='topic+test.l'></span>

<h3>Description</h3>

<p>This function performs the weight transformation of the data matrix after
Klovan &amp; Imbrie (1971) and performs EMMA() with different weight limits to
check if valied results are yielded. It returns the maximum value for which
the transformation remains stable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.l(X, l, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.l_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="test.l_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> vector, weight transformation limit, i.e.
quantile; default is 0.</p>
</td></tr>
<tr><td><code id="test.l_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>List</code> with objects </p>
<table role = "presentation">
<tr><td><code>step</code></td>
<td>
<p>Numeric scalar with position 
of the last valid value.</p>
</td></tr> <tr><td><code>l.max</code></td>
<td>
<p>Numeric scalar with last valid 
value of <code>l</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180. <br />
Klovan JE, Imbrie J. 1971. An Algorithm and FORTRAN-IV Program for
Large-Scale Q-Mode Factor Analysis and Calculation of Factor Scores.
Mathematical Geology 3: 61-77.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>, <code><a href="#topic+check.data">check.data</a></code>,
<code><a href="#topic+test.parameters">test.parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

test &lt;- test.l(X = X, l = seq(from = 0, to = 0.6, by = 0.1))


</code></pre>

<hr>
<h2 id='test.l.max'>Find maximum possible wight transformation value.</h2><span id='topic+test.l.max'></span>

<h3>Description</h3>

<p>This function approximates the highest possible value for l in a nested
loop. It uses <code>test.l</code> and does not need any further parameters. It 
starts with l between zero and 0.5 and iteratively approximates the last 
possible vlaues for which the weight-transformed matrix of the input data
still allows eigenspace extraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.l.max(X, n = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.l.max_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="test.l.max_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> scalar, number of loop runs and values per loop.</p>
</td></tr>
<tr><td><code id="test.l.max_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> scalar, maximal possible l value.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180. <br />
Klovan JE, Imbrie J. 1971. An Algorithm and FORTRAN-IV Program for
Large-Scale Q-Mode Factor Analysis and Calculation of Factor Scores.
Mathematical Geology 3: 61-77.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>, <code><a href="#topic+test.l">test.l</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

## create weight transformation limits vector
l &lt;- seq(from = 0, to = 0.6, by = 0.02)

## test l.max
l.max &lt;- test.l.max(X = X)



</code></pre>

<hr>
<h2 id='test.parameters'>Evaluate influence of model parameters.</h2><span id='topic+test.parameters'></span>

<h3>Description</h3>

<p>All possible combinations of number of end-members and weight transformation
limits are used to perform EMMA and evaluate the absolute and relative 
measures of individual model performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.parameters(
  X,
  q,
  l = 0,
  c = 100,
  rotation = "Varimax",
  plot = FALSE,
  legend,
  multicore = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.parameters_+3A_x">X</code></td>
<td>
<p><code>Numeric</code> matrix, input data set with m samples (rows) 
and n variables (columns).</p>
</td></tr>
<tr><td><code id="test.parameters_+3A_q">q</code></td>
<td>
<p><code>Numeric</code> vector, numbers of end-members to be modelled,
e.g., <code>2:10</code>.</p>
</td></tr>
<tr><td><code id="test.parameters_+3A_l">l</code></td>
<td>
<p><code>Numeric</code> vector specifying the weight tranformation limit, 
i.e. quantile; default is 0.</p>
</td></tr>
<tr><td><code id="test.parameters_+3A_c">c</code></td>
<td>
<p><code>Numeric</code> scalar specifying the constant sum scaling 
parameter, e.g., 1, 100, 1000; default is 0.</p>
</td></tr>
<tr><td><code id="test.parameters_+3A_rotation">rotation</code></td>
<td>
<p><code>Character</code> scalar, rotation type, default is 
<code>"Varimax"</code>.</p>
</td></tr>
<tr><td><code id="test.parameters_+3A_plot">plot</code></td>
<td>
<p><code>Character</code> scalar, optional graphical output of the 
results as keyword (see details). All plots except &quot;ol&quot; are colour-coded 
bitmaps of q, l and the specified test parameter and line-plots the 
specified parameter vs. <code>q</code>.</p>
</td></tr>
<tr><td><code id="test.parameters_+3A_legend">legend</code></td>
<td>
<p><code>Character</code> scalar, specifying legend position (cf.
<code><a href="graphics.html#topic+legend">legend</a></code>).  If omitted, no legend will be plotted, default is no
legend.</p>
</td></tr>
<tr><td><code id="test.parameters_+3A_multicore">multicore</code></td>
<td>
<p><code>Logical</code> scalar, optionally ditribute calculations 
to all available cores of the computer, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="test.parameters_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean total explained variance mRt may be used to define a maximum number
of meaningful end-members for subsequent modelling, e.g. as the number of
end-members, which reaches the first local mRt maximum.<br /> Overlapping is
defined as one end-member having its mode within the &quot;area&quot; of any other
end-member, which is genetically not explainable.<br /> Keywords to specify, 
which tested parameter will be plotted: &quot;mEm&quot; (mean absolute row-wise 
error), &quot;mEn&quot; (mean absolute column-wise error), &quot;mRm&quot; (mean
relative row-wise error), &quot;mRn&quot; (mean relative column-wise error), &quot;mRt&quot;
(mean relative total error) and &quot;ol&quot; (number of overlapping end-members).<br />
Since the function returns two plots (except for option &quot;ol&quot;), additional
graphical parameters must be specified as vector with the first element for
the first plot and the second element for the second plot. If graphical
parameters are natively vectors (e.g. a sequence of colours), they must be
specified as matrices with each vector as a row. A legend can only be added
to the second plot. Colours only apply to the second plot as well. If
colours are specified, <code>colour</code> should be used instead of <code>col</code>.
See example section for further advice.
</p>


<h3>Value</h3>

<p><code>List</code> with result objects </p>
<table role = "presentation">
<tr><td><code>mEm</code></td>
<td>
<p>Absolute row-wise model
error.</p>
</td></tr> <tr><td><code>mEn</code></td>
<td>
<p>Absolute column-wise model error.</p>
</td></tr> <tr><td><code>mRm</code></td>
<td>
<p>Mean
row-wise explained variance.</p>
</td></tr> <tr><td><code>mRn</code></td>
<td>
<p>Mean column-wise explained
variance.</p>
</td></tr> <tr><td><code>mRt</code></td>
<td>
<p>Mean total explained variance.</p>
</td></tr> <tr><td><code>ol</code></td>
<td>
<p>Number of
overlapping end-member loadings.</p>
</td></tr> <tr><td><code>q.max</code></td>
<td>
<p>Maximum number of meaningful
end-members.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMMA">EMMA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

## truncate the data set for faster computation
X.trunc &lt;- X[1:20,]

## define test parameters
q &lt;- 2:8 # number of end-members
l &lt;- seq(from = 0, to = 0.3, by = 0.1)

## test parameter influence and plot mean total explained variance
TP &lt;- test.parameters(X = X.trunc, q = q, l = l, plot = "mRt",
                      legend = "bottomright", cex = 0.7,
                      multicore = FALSE,
                      colour = rgb((1:7) / 7, 0.9, 0.2, 1))

## show maximum number of end-members
TP$q.max

</code></pre>

<hr>
<h2 id='test.robustness'>Test model robustness.</h2><span id='topic+test.robustness'></span>

<h3>Description</h3>

<p>This function takes a definition of weight transformation 
limits and corresponding minimum and maximum numbers of end-members to 
model all end-member scenarios in accordance with these parameters. Based 
on the output the user can decide on robust end-members.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.robustness(
  X,
  q,
  l,
  P,
  c,
  classunits,
  ID,
  rotation = "Varimax",
  ol.rej,
  mRt.rej,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.robustness_+3A_x">X</code></td>
<td>
<p>Numeric matrix with m samples (rows) and n variables (columns).</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_q">q</code></td>
<td>
<p>Numeric vector with number of end-members to be modelled.</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_l">l</code></td>
<td>
<p>Numeric vector specifying the weight tranformation limits, i.e.
quantiles; default is 0.</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_p">P</code></td>
<td>
<p>Numeric matrix, optional alternative input parameters for q and l,
either of the form m:3 with m variations in the columns q.min, q.max, l or
of the form m:2 with m variations in the columns q, l.</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_c">c</code></td>
<td>
<p>Numeric scalar specifying the constant sum scaling parameter, e.g.
1, 100, 1000; default is 100.</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_classunits">classunits</code></td>
<td>
<p>Numeric vector, optional class units (e.g. phi classes or
micrometers) of the same length as columns of X.</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_id">ID</code></td>
<td>
<p>Numeric or character vector, optional sample IDs of the same
length as columns of X.</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_rotation">rotation</code></td>
<td>
<p>Character scalar, rotation type, default is &quot;Varimax&quot; (cf.
Dietze et al., 2012). One out of the rotations provided in GPArotation is
possible (cf. <code><a href="GPArotation.html#topic+rotations">rotations</a></code>).</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_ol.rej">ol.rej</code></td>
<td>
<p>Numeric scalar, optional rejection threshold for overlapping
criterion.  All model runs with overlapping end-members greater than the
specified integer will be removed.</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_mrt.rej">mRt.rej</code></td>
<td>
<p>Numeric scalar, optional rejection threshold for mean total
explained variance criterion. All modelled end-members below the specified
value will be removed.</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_plot">plot</code></td>
<td>
<p>Logical scalar, optional graphical output of the results,
default is FALSE. If set to TRUE, end-member loadings and end-member scores
are plotted.</p>
</td></tr>
<tr><td><code id="test.robustness_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function value <code>$loadings</code> is redundant but was added for user
convenience.<br /> Since the
function returns two plots, additional graphical parameters must be
specified as vector with the first element for the first plot and the second
element for the second plot. If graphical parameters are natively vectors
(e.g. a sequence of colours), they must be specified as matrices with each
vector as a row. If colours are specified, <code>colour</code> should be used
instead of <code>col</code>. <code>ylim</code> can only be modified for the first plot.
See example section for further advice.
</p>


<h3>Value</h3>

<p>A list with objects </p>
<table role = "presentation">
<tr><td><code>q</code></td>
<td>
<p>Vector with q.</p>
</td></tr> <tr><td><code>l</code></td>
<td>
<p>Vector with
l.</p>
</td></tr> <tr><td><code>modes</code></td>
<td>
<p>Vector with mode class.</p>
</td></tr> <tr><td><code>mRt</code></td>
<td>
<p>Vector with mean total
explained variance.</p>
</td></tr> <tr><td><code>ol</code></td>
<td>
<p>Vector with n overlapping end-members.</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>Matrix with normalised rescaled end-member loadings.</p>
</td></tr>
<tr><td><code>Vqsn</code></td>
<td>
<p>Matrix with rescaled end-member loadings.</p>
</td></tr> <tr><td><code>Vqn</code></td>
<td>
<p>Matrix
with normalised factor loadings.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Dietze, Elisabeth Dietze
</p>


<h3>References</h3>

<p>Dietze E, Hartmann K, Diekmann B, IJmker J, Lehmkuhl F, Opitz S,
Stauch G, Wuennemann B, Borchers A. 2012. An end-member algorithm for
deciphering modern detrital processes from lake sediments of Lake Donggi
Cona, NE Tibetan Plateau, China. Sedimentary Geology 243-244: 169-180. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

## Example 1 - perform the most simple test
q  &lt;- 4:7
l &lt;- seq(from = 0, to = 0.1, by = 0.02)

M1  &lt;- test.robustness(X = X, q = q, l = l, 
                       ol.rej = 1, mRt.rej = 0.8, 
                       plot = TRUE,
                       colour = c(4, 7),
                       xlab = c(expression(paste("Grain size (", phi, ")", 
                                                 sep = "")), 
                                expression(paste("Grain size (", phi, ")", 
                                                 sep = ""))))

## Example 2 -  perform the test without rejection criteria and plots
P  &lt;- cbind(rep(q[1], length(l)),
            rep(q[3], length(l)),
            l)
M2  &lt;- test.robustness(X = X, P = P)

## Plot 1 - end-member loadings which do not overlap and yielded mRt &gt; 0.80.
plot(M2$Vqsn[1,], type = "l", ylim = c(0, max(M2$Vqsn, na.rm = TRUE)),
     main = "End-member loadings")
  for (i in 2:nrow(M2$Vqsn)) lines(M2$Vqsn[i,])

# Plot 2 - histogram of mode positions
hist(M2$modes,
     breaks = 1:ncol(X), 
     main = "Mode positions",
     xlab = "Class")

# Plot 3 - positions of modelled end-member modes by number of end-members
# Note how scatter in end-member position decreases for the "correct" number 
# of modelled end-members (6) and an appropriate weight limit (ca. 0.1).
ii &lt;- order(M2$q, M2$modes)
modes &lt;- t(rbind(M2$modes, M2$q))[ii,]
plot(modes[,1],
     seq(1, nrow(modes)), 
     main = "Model overview",
     xlab = "Class", 
     ylab = "EM number in model run", 
     pch = as.character(modes[,2]), 
     cex = 0.7)

# Illustrate mode positions as stem-and-leave-plot, useful as a simple
# check, which mode maxima are consistently fall into which grain-size 
# class (useful to define "limits" in robust.EM).
stem(M2$modes, scale = 2)


</code></pre>

<hr>
<h2 id='X'>example data</h2><span id='topic+X'></span>

<h3>Description</h3>

<p>Synthetic data set created by randomly mixed natural end-members
</p>


<h3>Format</h3>

<p>num [1:100, 1:116] 0.000899 0.000516 0.00136 0.000989 0.00102 ...</p>


<h3>Details</h3>

<p>The dataset is the result of four mixed natural end-members.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(example_X)

## extract grain-size classes
s &lt;- as.numeric(colnames(X))

## plot first 10 samples stacked in one line plot
plot(NA, 
     xlim = c(1, ncol(X)), 
     ylim = c(1, 20))
     
for(i in 1:10) {
  lines(x = s, 
        y = X[i,] + i)
}

## plot grain-size map
image(x = s, 
      z = t(X), 
      log = "x", 
      col = rainbow(n = 250))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
