<!DOCTYPE html><html lang="en"><head><title>Help for package ctypesio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ctypesio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ctypesio-package'><p>ctypesio: Read and Write Standard 'C' Types from Files, Connections and Raw Vectors</p></a></li>
<li><a href='#aperm_array_to_vector'><p>Permute an R array to a linear vector of data</p></a></li>
<li><a href='#aperm_vector_to_array'><p>Permute a linear vector of data into an R array</p></a></li>
<li><a href='#flip_endian'><p>Flip the endianness of elements in a vector</p></a></li>
<li><a href='#fprintf'><p>Print formatted strings to a connection</p></a></li>
<li><a href='#read_f64'><p>Read floating point values from a connection</p></a></li>
<li><a href='#read_hex'><p>Read bytes as hexadecimal strings</p></a></li>
<li><a href='#read_raw'><p>Read raw bytes</p></a></li>
<li><a href='#read_str'><p>Read a character string from a connection</p></a></li>
<li><a href='#read_uint8'><p>Read integer data from a connection</p></a></li>
<li><a href='#scan_dbl'><p>Read values encoded as characters strings</p></a></li>
<li><a href='#set_bounds_check'><p>For this connection, set the response when values do not fit into given type before writing.</p></a></li>
<li><a href='#set_endian'><p>Tag a connection with the preferred endianness</p></a></li>
<li><a href='#set_eof_check'><p>Set EOF (End-of-file) handling for this connection</p></a></li>
<li><a href='#set_integer_promotion'><p>Tag a connection with the preferred integer promotion method for types</p>
larger that R's integer type i.e. uint32, uint64, int64</a></li>
<li><a href='#set_na_check'><p>Check for NAs in values before writing</p></a></li>
<li><a href='#write_f64'><p>Convert values to the given type and write to a connection</p></a></li>
<li><a href='#write_hex'><p>Write hexadecimal string as raw bytes</p></a></li>
<li><a href='#write_raw'><p>Write raw bytes</p></a></li>
<li><a href='#write_uint8'><p>Convert values to the given type and write to a connection</p></a></li>
<li><a href='#write_utf8'><p>Write UTF8 string</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read and Write Standard 'C' Types from Files, Connections and
Raw Vectors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mike Cheng &lt;mikefc@coolbutuseless.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Interacting with binary files can be difficult because R's types
    are a subset of what is generally supported by 'C'.  This package provides a 
    suite of functions for reading and writing binary data (with files, connections, 
    and raw vectors) using 'C' type descriptions.  These functions convert data
    between 'C' types and R types while checking for values outside the 
    type limits, 'NA' values, etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), jpeg</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/coolbutuseless/ctypesio">https://github.com/coolbutuseless/ctypesio</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/coolbutuseless/ctypesio/issues">https://github.com/coolbutuseless/ctypesio/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-18 05:51:39 UTC; mike</td>
</tr>
<tr>
<td>Author:</td>
<td>Mike Cheng [aut, cre, cph],
  Anne Fu <a href="https://orcid.org/0000-0002-9025-6071"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (Better UTF-8 support)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-18 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ctypesio-package'>ctypesio: Read and Write Standard 'C' Types from Files, Connections and Raw Vectors</h2><span id='topic+ctypesio'></span><span id='topic+ctypesio-package'></span>

<h3>Description</h3>

<p>Interacting with binary files can be difficult because R's types are a subset of what is generally supported by 'C'. This package provides a suite of functions for reading and writing binary data (with files, connections, and raw vectors) using 'C' type descriptions. These functions convert data between 'C' types and R types while checking for values outside the type limits, 'NA' values, etc.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mike Cheng <a href="mailto:mikefc@coolbutuseless.com">mikefc@coolbutuseless.com</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Anne Fu (<a href="https://orcid.org/0000-0002-9025-6071">ORCID</a>) (Better UTF-8 support) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/coolbutuseless/ctypesio">https://github.com/coolbutuseless/ctypesio</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/coolbutuseless/ctypesio/issues">https://github.com/coolbutuseless/ctypesio/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aperm_array_to_vector'>Permute an R array to a linear vector of data</h2><span id='topic+aperm_array_to_vector'></span>

<h3>Description</h3>

<p>Permute an R array to a linear vector of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aperm_array_to_vector(x, dst, flipy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aperm_array_to_vector_+3A_x">x</code></td>
<td>
<p>array</p>
</td></tr>
<tr><td><code id="aperm_array_to_vector_+3A_dst">dst</code></td>
<td>
<p>Specification of destination dimensions in the order of presentation
in the source data. Character vector which contains 3 strings:
'planes', 'rows', 'cols'.  The order of these strings determines
the order of output in the linear data. Currently, &quot;planes&quot; must always
be the final element.</p>
</td></tr>
<tr><td><code id="aperm_array_to_vector_+3A_flipy">flipy</code></td>
<td>
<p>flip the array vertically. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>See Also</h3>

<p>Other data permutation functions: 
<code><a href="#topic+aperm_vector_to_array">aperm_vector_to_array</a>()</code>,
<code><a href="#topic+flip_endian">flip_endian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a small RGBA array in R with each 
# plane of the array holding a different colour channel
  arr &lt;- array(c(paste0('r', 1:6), 
                 paste0('g', 1:6), 
                 paste0('b', 1:6),
                 paste0('a', 1:6)), c(2, 3, 4))
arr

# A very common C ordering is packaged RGBA data in column major format
# i.e. Iterate over: planes, then columns, then rows
# i.e. 
#    start at first element
#    (plane1, plane2, plane3, plane4)
#    go to next column
#    (plane1, plane2, plane3, plane4)
#    go to next column
#    ...
#    when last column is done
#    do to next row

# Convert to packed RGBA in column-major format
vec &lt;- aperm_array_to_vector(arr, dst = c('planes', 'cols', 'rows'))
vec

# To convert column-major packed RGBA to an R array, use the same ordering
# for the dimensions, but also need to specify length along each dimension
aperm_vector_to_array(vec, src = c(planes = 4, cols = 3, rows = 2))
</code></pre>

<hr>
<h2 id='aperm_vector_to_array'>Permute a linear vector of data into an R array</h2><span id='topic+aperm_vector_to_array'></span>

<h3>Description</h3>

<p>Permute a linear vector of data into an R array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aperm_vector_to_array(x, src, flipy = FALSE, simplify_matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aperm_vector_to_array_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="aperm_vector_to_array_+3A_src">src</code></td>
<td>
<p>Specification of source dimensions in the order of presentation
in the source data. This must a named integer vector with 
the names &quot;planes&quot;, &quot;rows&quot;, &quot;cols&quot; (and their corresponding sizes)
in the order in which they occur in the data.  The first 
named element must always be &quot;planes&quot;.  Use <code>planes = 1</code> to
indicate that this is matrix data.</p>
</td></tr>
<tr><td><code id="aperm_vector_to_array_+3A_flipy">flipy</code></td>
<td>
<p>flip the array vertically. Default: FALSE</p>
</td></tr>
<tr><td><code id="aperm_vector_to_array_+3A_simplify_matrix">simplify_matrix</code></td>
<td>
<p>If the resulting array only has a single plane, 
should this be simplified to a matrix? Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array or matrix
</p>


<h3>See Also</h3>

<p>Other data permutation functions: 
<code><a href="#topic+aperm_array_to_vector">aperm_array_to_vector</a>()</code>,
<code><a href="#topic+flip_endian">flip_endian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a vector of packed RGB data to an array with 3 planes
x &lt;- c(
  'r0', 'g0', 'b0',   'r1', 'g1', 'b1',   'r2', 'g2', 'b2',   
  'r3', 'g3', 'b3',   'r4', 'g4', 'b4',   'r5', 'g5', 'b5'
)
aperm_vector_to_array(x, src = c(planes = 3, cols = 3, rows = 2))
</code></pre>

<hr>
<h2 id='flip_endian'>Flip the endianness of elements in a vector</h2><span id='topic+flip_endian'></span>

<h3>Description</h3>

<p>This will create a new vector with the values reversed within the given 
block size. This can be used for changing the endianness of a set of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip_endian(x, size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flip_endian_+3A_x">x</code></td>
<td>
<p>vector. Usually a raw vector, but can be any type</p>
</td></tr>
<tr><td><code id="flip_endian_+3A_size">size</code></td>
<td>
<p>block size. Usually a power of 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same type as the initial vector with the values
within each block reversed.
</p>


<h3>See Also</h3>

<p>Other data permutation functions: 
<code><a href="#topic+aperm_array_to_vector">aperm_array_to_vector</a>()</code>,
<code><a href="#topic+aperm_vector_to_array">aperm_vector_to_array</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec &lt;- c(1, 2, 3, 4)
flip_endian(vec, 1)   # should give: c(1, 2, 3, 4)
flip_endian(vec, 2)   # should give: c(2, 1, 4, 3)
flip_endian(vec, 4)   # should give: c(4, 3, 2, 1)
</code></pre>

<hr>
<h2 id='fprintf'>Print formatted strings to a connection</h2><span id='topic+fprintf'></span><span id='topic+fprintf_raw'></span>

<h3>Description</h3>

<p><code>fprintf_raw()</code> writes the text without a nul-terminator. <code>fprintf()</code>
writes a nul-terminator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fprintf(con, fmt, ..., sep = "\n", useBytes = FALSE)

fprintf_raw(con, fmt, ..., sep = "\n", useBytes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fprintf_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. When con is a raw vector, new
data will be <em>appended</em> to the vector and returned.
Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="fprintf_+3A_fmt">fmt</code></td>
<td>
<p>a character vector of format strings. See <code><a href="base.html#topic+sprintf">sprintf</a>()</code></p>
</td></tr>
<tr><td><code id="fprintf_+3A_...">...</code></td>
<td>
<p>values to be passed in to <code>fmt</code>. See <code><a href="base.html#topic+sprintf">sprintf</a>()</code></p>
</td></tr>
<tr><td><code id="fprintf_+3A_sep">sep</code></td>
<td>
<p>If there are multiple strings to be printed, this separated will be 
written after each one.</p>
</td></tr>
<tr><td><code id="fprintf_+3A_usebytes">useBytes</code></td>
<td>
<p>See <code><a href="base.html#topic+writeLines">writeLines</a>()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>con</code> is a connection then this connection is returned invisibly.
If <code>con</code> is a raw vector then new data is appended to this vector
</p>


<h3>See Also</h3>

<p>Other data output functions: 
<code><a href="#topic+write_f64">write_f64</a>()</code>,
<code><a href="#topic+write_hex">write_hex</a>()</code>,
<code><a href="#topic+write_raw">write_raw</a>()</code>,
<code><a href="#topic+write_uint8">write_uint8</a>()</code>,
<code><a href="#topic+write_utf8">write_utf8</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- rawConnection(raw(), "wb")
fprintf(con, "%i,%6.2f", 1, 3.14159)
close(con)
</code></pre>

<hr>
<h2 id='read_f64'>Read floating point values from a connection</h2><span id='topic+read_f64'></span><span id='topic+read_f32'></span><span id='topic+read_f16'></span><span id='topic+read_bfloat'></span><span id='topic+read_dbl'></span><span id='topic+read_float'></span><span id='topic+read_half'></span>

<h3>Description</h3>

<p>Read floating point numbers into a standard R vector of doubles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_f64(con, n = 1, endian = NULL)

read_f32(con, n = 1, endian = NULL)

read_f16(con, n = 1, endian = NULL)

read_bfloat(con, n = 1, endian = NULL)

read_dbl(con, n = 1, endian = NULL)

read_float(con, n = 1, endian = NULL)

read_half(con, n = 1, endian = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_f64_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="read_f64_+3A_n">n</code></td>
<td>
<p>Number of elements to read. Default: 1</p>
</td></tr>
<tr><td><code id="read_f64_+3A_endian">endian</code></td>
<td>
<p>Ordering of bytes within the file when reading multi-byte values.
Possible values: 'big' or 'little'.  
Default: NULL indicates that
endian option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_endian">set_endian</a>()</code>) or otherwise 
will be set to <code>"little"</code></p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>double precision</dt><dd><p>8 byte floating point numbers. <code>read_f64()</code> 
also available as <code>read_dbl()</code></p>
</dd>
<dt>single precision</dt><dd><p>4 byte floating point numbers. <code>read_f32()</code> 
also available as <code>read_float()</code></p>
</dd>
<dt>half precision</dt><dd><p>2 byte floating point numbers. <code>read_f16()</code> 
also available as <code>read_half()</code>.  Consists of 1 sign bit, 
5 bits for exponent and 10 bits for fraction.</p>
</dd>
<dt>bfloat</dt><dd><p>2 byte floating point numbers in the bfloat format  <code>read_bfloat()</code>.
Consits of 1 sign bit, 8 bits fo exponent and 7 bits for fraction.</p>
</dd> 
</dl>



<h3>Value</h3>

<p>vector of double precision floating point numbers
</p>


<h3>See Also</h3>

<p>Other data input functions: 
<code><a href="#topic+read_hex">read_hex</a>()</code>,
<code><a href="#topic+read_raw">read_raw</a>()</code>,
<code><a href="#topic+read_str">read_str</a>()</code>,
<code><a href="#topic+read_uint8">read_uint8</a>()</code>,
<code><a href="#topic+scan_dbl">scan_dbl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Raw vector with 16 bytes (128 bits) of dummy data
data &lt;- as.raw(1:16)
con &lt;- rawConnection(data, 'rb')
read_f64(con, n = 1) # Read a 64-bit double-precision number
read_f16(con, n = 4) # Read 4 x 16-bit half-precision number
close(con)

</code></pre>

<hr>
<h2 id='read_hex'>Read bytes as hexadecimal strings</h2><span id='topic+read_hex'></span>

<h3>Description</h3>

<p>Read bytes as hexadecimal strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_hex(con, n = 1, size = 1, endian = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_hex_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="read_hex_+3A_n">n</code></td>
<td>
<p>Number of hexadecimal strings to read. Default: 1</p>
</td></tr>
<tr><td><code id="read_hex_+3A_size">size</code></td>
<td>
<p>size in bytes of each string. Default: 1</p>
</td></tr>
<tr><td><code id="read_hex_+3A_endian">endian</code></td>
<td>
<p>Ordering of bytes within the file when reading multi-byte values.
Possible values: 'big' or 'little'.  
Default: NULL indicates that
endian option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_endian">set_endian</a>()</code>) or otherwise 
will be set to <code>"little"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of hexadecimal character strings
</p>


<h3>See Also</h3>

<p>Other data input functions: 
<code><a href="#topic+read_f64">read_f64</a>()</code>,
<code><a href="#topic+read_raw">read_raw</a>()</code>,
<code><a href="#topic+read_str">read_str</a>()</code>,
<code><a href="#topic+read_uint8">read_uint8</a>()</code>,
<code><a href="#topic+scan_dbl">scan_dbl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- rawConnection(as.raw(1:4))
read_hex(con, n = 4, size = 1)
close(con)

con &lt;- rawConnection(as.raw(1:4))
read_hex(con, n = 1, size = 4)
close(con)

con &lt;- rawConnection(as.raw(1:4))
read_hex(con, n = 2, size = 2, endian = "big")
close(con)
</code></pre>

<hr>
<h2 id='read_raw'>Read raw bytes</h2><span id='topic+read_raw'></span>

<h3>Description</h3>

<p>Read raw bytes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_raw(con, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_raw_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="read_raw_+3A_n">n</code></td>
<td>
<p>Number of elements to read. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>raw vector
</p>


<h3>See Also</h3>

<p>Other data input functions: 
<code><a href="#topic+read_f64">read_f64</a>()</code>,
<code><a href="#topic+read_hex">read_hex</a>()</code>,
<code><a href="#topic+read_str">read_str</a>()</code>,
<code><a href="#topic+read_uint8">read_uint8</a>()</code>,
<code><a href="#topic+scan_dbl">scan_dbl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- rawConnection(charToRaw("hello12.3"))
read_raw(con, 5)
close(con)
</code></pre>

<hr>
<h2 id='read_str'>Read a character string from a connection</h2><span id='topic+read_str'></span><span id='topic+read_str_raw'></span><span id='topic+read_utf8'></span><span id='topic+read_utf8_raw'></span>

<h3>Description</h3>

<p>Read character string from a connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_str(con)

read_str_raw(con, n)

read_utf8(con)

read_utf8_raw(con, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_str_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="read_str_+3A_n">n</code></td>
<td>
<p>number of characters to read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions which have a suffix of <code>_raw</code> are for handling character 
strings without a nul-terminator.
</p>


<h3>Value</h3>

<p>single character string
</p>


<h3>See Also</h3>

<p>Other data input functions: 
<code><a href="#topic+read_f64">read_f64</a>()</code>,
<code><a href="#topic+read_hex">read_hex</a>()</code>,
<code><a href="#topic+read_raw">read_raw</a>()</code>,
<code><a href="#topic+read_uint8">read_uint8</a>()</code>,
<code><a href="#topic+scan_dbl">scan_dbl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- rawConnection(c(charToRaw("hello12.3"), as.raw(0)))
read_str(con)
close(con)

con &lt;- rawConnection(charToRaw("hello12.3"))
read_str_raw(con, 5)
close(con)

con &lt;- rawConnection(c(charToRaw("hello12.3"), as.raw(0)))
read_utf8(con)
close(con)

con &lt;- rawConnection(charToRaw("hello12.3"))
read_utf8_raw(con, 3)
close(con)
</code></pre>

<hr>
<h2 id='read_uint8'>Read integer data from a connection</h2><span id='topic+read_uint8'></span><span id='topic+read_int8'></span><span id='topic+read_int16'></span><span id='topic+read_uint16'></span><span id='topic+read_int32'></span><span id='topic+read_uint32'></span><span id='topic+read_int64'></span><span id='topic+read_uint64'></span>

<h3>Description</h3>

<p>Read integer values into a standard R vector of integers or alternate
containers for large types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_uint8(con, n = 1, endian = NULL)

read_int8(con, n = 1, endian = NULL)

read_int16(con, n = 1, endian = NULL)

read_uint16(con, n = 1, endian = NULL)

read_int32(con, n = 1, endian = NULL)

read_uint32(con, n = 1, endian = NULL, promote = NULL)

read_int64(con, n = 1, endian = NULL, promote = NULL, bounds_check = NULL)

read_uint64(con, n = 1, endian = NULL, promote = NULL, bounds_check = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_uint8_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="read_uint8_+3A_n">n</code></td>
<td>
<p>Number of elements to read. Default: 1</p>
</td></tr>
<tr><td><code id="read_uint8_+3A_endian">endian</code></td>
<td>
<p>Ordering of bytes within the file when reading multi-byte values.
Possible values: 'big' or 'little'.  
Default: NULL indicates that
endian option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_endian">set_endian</a>()</code>) or otherwise 
will be set to <code>"little"</code></p>
</td></tr>
<tr><td><code id="read_uint8_+3A_promote">promote</code></td>
<td>
<p>For 'uin32', 'int64' and 'uint64' types, the range of possible
values exceeds R's standard integer type.  For these integer types, 
values will be promoted to a different container type.
Possible options 'dbl', 'raw', 'hex' and 'bit64'.
Default: NULL indicates that
this option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_integer_promotion">set_integer_promotion</a>()</code>) or otherwise 
will default to <code>"dbl"</code>.
</p>

<dl>
<dt><code>dbl</code></dt><dd><p>Read integer values as double precision floating point. A 'double' will
hold integer values (without loss) from -(2^53) up to (2^53).  A 
further warning will be issued if an attempt is made to store 
an integer value that lies outside this range</p>
</dd>
<dt><code>hex</code></dt><dd><p>Read integers as character vector of hexadecimal strings</p>
</dd>
<dt><code>raw</code></dt><dd><p>Read integer value as a sequence of raw bytes</p>
</dd>
<dt><code>bit64</code></dt><dd><p>Read integer value as a vector of 
type <code>bit64::integer64</code>. This is valid only when reading
'int64' and 'uint64' types</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="read_uint8_+3A_bounds_check">bounds_check</code></td>
<td>
<p>Check values lie within bounds of the given type.
Default: NULL indicates that
this option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_bounds_check">set_bounds_check</a>()</code>) or otherwise 
will be set to <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>8-bit integers</dt><dd><p><code>read_int8()</code> and <code>read_uint8()</code></p>
</dd>
<dt>16-bit integers</dt><dd><p><code>read_int16()</code> and <code>read_uint16()</code></p>
</dd>
<dt>32-bit integers</dt><dd><p><code>read_int32()</code> and <code>read_uint32()</code></p>
</dd>
<dt>64-bit integers</dt><dd><p><code>read_int64()</code> and <code>read_uint64()</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>Integer data. Usually in standard R integer vector but depending on 
the <code>promote</code> option may be returned in alternate formats
</p>


<h3>See Also</h3>

<p>Other data input functions: 
<code><a href="#topic+read_f64">read_f64</a>()</code>,
<code><a href="#topic+read_hex">read_hex</a>()</code>,
<code><a href="#topic+read_raw">read_raw</a>()</code>,
<code><a href="#topic+read_str">read_str</a>()</code>,
<code><a href="#topic+scan_dbl">scan_dbl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Raw vector with 16 bytes (128 bits) of dummy data
data &lt;- as.raw(c(1:7, 0, 1:8))
con &lt;- rawConnection(data, 'rb')
read_int64(con, n = 1)
read_uint8(con, n = 4)
close(con)

</code></pre>

<hr>
<h2 id='scan_dbl'>Read values encoded as characters strings</h2><span id='topic+scan_dbl'></span><span id='topic+scan_int'></span><span id='topic+scan_str'></span>

<h3>Description</h3>

<p>A lightweight wrapper around the standard <code><a href="base.html#topic+scan">scan</a>()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_dbl(con, n = 1, quiet = TRUE, ...)

scan_int(con, n = 1, quiet = TRUE, ...)

scan_str(con, n = 1, quiet = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan_dbl_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="scan_dbl_+3A_n">n</code></td>
<td>
<p>Number of elements to read. Default: 1</p>
</td></tr>
<tr><td><code id="scan_dbl_+3A_quiet">quiet</code></td>
<td>
<p>Default: TRUE</p>
</td></tr>
<tr><td><code id="scan_dbl_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>scan()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are useful when the numeric values are encoded as strings written 
to the file, rather than as binary data.  Values must be delimited
by whitespace or other specified separator.  See documentation for 
<code>scan()</code> for more information.
</p>


<h3>Value</h3>

<p>Value of the given type
</p>


<h3>See Also</h3>

<p>Other data input functions: 
<code><a href="#topic+read_f64">read_f64</a>()</code>,
<code><a href="#topic+read_hex">read_hex</a>()</code>,
<code><a href="#topic+read_raw">read_raw</a>()</code>,
<code><a href="#topic+read_str">read_str</a>()</code>,
<code><a href="#topic+read_uint8">read_uint8</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- textConnection(r"(
  type
  20 30
  3.14159
)")

scan_str(con)
scan_int(con)
scan_int(con)
scan_dbl(con)
close(con)
</code></pre>

<hr>
<h2 id='set_bounds_check'>For this connection, set the response when values do not fit into given type before writing.</h2><span id='topic+set_bounds_check'></span>

<h3>Description</h3>

<p>For this connection, set the response when values do not fit into given type before writing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_bounds_check(con, bounds_check = "error")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_bounds_check_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="set_bounds_check_+3A_bounds_check">bounds_check</code></td>
<td>
<p>Default bounds checking behaviour. One of: 'ignore', 'warn', 'error'.
Default: 'error'.
This default may be over-ridden by specifying
the <code>bounds_check</code> argument when calling individual functions.
</p>

<dl>
<dt><code>ignore</code></dt><dd><p>No explicit checks will be made for
out-of-bound values.
The underlying R functions (e.g. <code>readBin()</code>, <code>writeBin()</code>) may still do checking.
</p>
</dd>
<dt><code>warn</code></dt><dd><p>Explicit checks will be made for
out-of-bound values.
If any are found, then a <code>warning()</code> will be issued.
</p>
</dd>
<dt><code>error</code></dt><dd><p>Explicit checks will be made for
out-of-bound values.
If any are found, then a error will be raised.
</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified connection object
</p>


<h3>See Also</h3>

<p>Other connection configuration functions: 
<code><a href="#topic+set_endian">set_endian</a>()</code>,
<code><a href="#topic+set_eof_check">set_eof_check</a>()</code>,
<code><a href="#topic+set_integer_promotion">set_integer_promotion</a>()</code>,
<code><a href="#topic+set_na_check">set_na_check</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Open a connection and configure it so out-of-bounds values
# will cause a warning only.
con &lt;- rawConnection(as.raw(1:8), "rb")
con &lt;- set_bounds_check(con, bounds_check = "warn")

# This line attempts to read a value from the connection which
# is too large to store in a double precision floating point without
# loss of integer precision.
# Usually this would cause an error to be raised, but the 'bounds_check'
# option has been set to give a warning only.
read_uint64(con, n = 1, promote = "dbl")

close(con)

</code></pre>

<hr>
<h2 id='set_endian'>Tag a connection with the preferred endianness</h2><span id='topic+set_endian'></span>

<h3>Description</h3>

<p>Tag a connection with the preferred endianness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_endian(con, endian = "little")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_endian_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="set_endian_+3A_endian">endian</code></td>
<td>
<p>Default endianness to assign to this connection. One of either
&quot;little&quot; or &quot;big&quot;.  Default: &quot;little&quot;.
This default may be over-ridden by specifying
the <code>endian</code> argument when calling individual functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified connection object
</p>


<h3>See Also</h3>

<p>Other connection configuration functions: 
<code><a href="#topic+set_bounds_check">set_bounds_check</a>()</code>,
<code><a href="#topic+set_eof_check">set_eof_check</a>()</code>,
<code><a href="#topic+set_integer_promotion">set_integer_promotion</a>()</code>,
<code><a href="#topic+set_na_check">set_na_check</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection and configure it so all subsequent read/write operations
# use big-endian ordering.
con &lt;- rawConnection(as.raw(c(0, 1, 0, 1)), "rb")
con &lt;- set_endian(con, endian = "big")

# Future reads will be be big endian
read_uint16(con, n = 1)

# Unless over-ridden during the read
read_uint16(con, n = 1, endian = "little")

close(con)

</code></pre>

<hr>
<h2 id='set_eof_check'>Set EOF (End-of-file) handling for this connection</h2><span id='topic+set_eof_check'></span>

<h3>Description</h3>

<p>When the end-of-file is reached and values are requested from the connection,
how should a <code>read</code> call check and react?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_eof_check(con, eof_check = "error")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_eof_check_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="set_eof_check_+3A_eof_check">eof_check</code></td>
<td>
<p>Default EOF checking behaviour. One of: 'ignore', 'warn', 'error'
Default: 'error'. 
</p>

<dl>
<dt><code>ignore</code></dt><dd><p>No explicit checks will be made for
EOF.
The underlying R functions (e.g. <code>readBin()</code>, <code>writeBin()</code>) may still do checking.
</p>
</dd>
<dt><code>warn</code></dt><dd><p>Explicit checks will be made for
reading data at EOF.
If this occurs, then a <code>warning()</code> will be issued.
</p>
</dd>
<dt><code>error</code></dt><dd><p>Explicit checks will be made for
reading data at EOF.
If any are found, then a error will be raised.
</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: R's <code>readBin()</code> does not necessarily react when the end-of-file 
is reached, and in many situations all that will happen is that fewer
data values will be returned than what was requested.
</p>
<p>By setting this option on the connection, work is done to check the count
of returned values after every call to try and detect when the
end-of-file has been reached.
</p>


<h3>Value</h3>

<p>Modified connection object
</p>


<h3>See Also</h3>

<p>Other connection configuration functions: 
<code><a href="#topic+set_bounds_check">set_bounds_check</a>()</code>,
<code><a href="#topic+set_endian">set_endian</a>()</code>,
<code><a href="#topic+set_integer_promotion">set_integer_promotion</a>()</code>,
<code><a href="#topic+set_na_check">set_na_check</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Open a connection and configure it so reading past the end-of-file 
# ignored, and operations simply return fewer values than requested
con &lt;- rawConnection(as.raw(1:8), "rb")
con &lt;- set_eof_check(con, eof_check = "ignore")

# There are only 8 bytes in the connection. 
# Attempting to read 12 bytes will reach the end of the file.
# Because "eof_check" has been set to "ignore", there will just be
# silent truncation of the data
read_uint8(con, n = 12)

# The connection can be configured to raise an error or warning
# when EOF is reached
con &lt;- set_eof_check(con, eof_check = "warn")
read_uint8(con, n = 12)

close(con)

</code></pre>

<hr>
<h2 id='set_integer_promotion'>Tag a connection with the preferred integer promotion method for types
larger that R's integer type i.e. uint32, uint64, int64</h2><span id='topic+set_integer_promotion'></span>

<h3>Description</h3>

<p>Tag a connection with the preferred integer promotion method for types
larger that R's integer type i.e. uint32, uint64, int64
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_integer_promotion(con, uint32 = "dbl", int64 = "dbl", uint64 = "dbl")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_integer_promotion_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="set_integer_promotion_+3A_uint32">uint32</code>, <code id="set_integer_promotion_+3A_int64">int64</code>, <code id="set_integer_promotion_+3A_uint64">uint64</code></td>
<td>
<p>specifiy separate promotion methods for these types
One of: 'dbl', 'hex', 'raw' and 'bit64' (for 64-bit types only) Default: 'dbl'.
This default may be over-ridden by specifying
the <code>promote</code> argument when calling individual functions.
</p>

<dl>
<dt><code>dbl</code></dt><dd><p>Read in integers as doubles. Integer values above 2^53
will lose precision.</p>
</dd>
<dt><code>hex</code></dt><dd><p>Each integer is returned as a
hexadecimal string</p>
</dd>
<dt><code>raw</code></dt><dd><p>A single raw vector containing all the integers 
in their original form</p>
</dd>
<dt><code>bit64</code></dt><dd><p>Return an <code>integer64</code> vector compatible with the
<code>bit64</code> package.  Note. <code>integer64</code> is a <em>signed</em> 64-bit
integer</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified connection object
</p>


<h3>See Also</h3>

<p>Other connection configuration functions: 
<code><a href="#topic+set_bounds_check">set_bounds_check</a>()</code>,
<code><a href="#topic+set_endian">set_endian</a>()</code>,
<code><a href="#topic+set_eof_check">set_eof_check</a>()</code>,
<code><a href="#topic+set_na_check">set_na_check</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection and configure it so all 'uint32' values are 
# read as floating point and all all 'uint64' values are read as hexadecimal strings
con &lt;- rawConnection(as.raw(c(1:7, 0, 1:7, 0, 1:7, 0, 1:7, 0)), "rb")
con &lt;- set_integer_promotion(con, uint32 = "dbl", uint64 = "hex")

# Future reads of uint64 will return hex strings
read_uint64(con, n = 2)

# Unless over-ridden during the read
read_uint64(con, n = 1, promote = "dbl")

close(con)

</code></pre>

<hr>
<h2 id='set_na_check'>Check for NAs in values before writing</h2><span id='topic+set_na_check'></span>

<h3>Description</h3>

<p>For the majority of binary file formats, there is never the need to 
store or retrieve an <code>NA</code> value.  The default behaviour of this
package is to raise an error if any attempt is made to write an <code>NA</code>
to file.  Set this option to <code>"warn"</code> or <code>"ignore"</code> to modify this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_na_check(con, na_check)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_na_check_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="set_na_check_+3A_na_check">na_check</code></td>
<td>
<p>Default NA checking behaviour. One of: 'ignore', 'warn', 'error'
Default: 'error'. 
This default may be over-ridden by specifying
the <code>na_check</code> argument when calling individual functions.
</p>

<dl>
<dt><code>ignore</code></dt><dd><p>No explicit checks will be made for
NA values
The underlying R functions (e.g. <code>readBin()</code>, <code>writeBin()</code>) may still do checking.
</p>
</dd>
<dt><code>warn</code></dt><dd><p>Explicit checks will be made for
NA values before writing.
If any NAs are present, then a <code>warning()</code> will be issued.
</p>
</dd>
<dt><code>error</code></dt><dd><p>Explicit checks will be made for
NA values before writing.
If any NAs are present, then an error will be raised.
</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified connection object
</p>


<h3>See Also</h3>

<p>Other connection configuration functions: 
<code><a href="#topic+set_bounds_check">set_bounds_check</a>()</code>,
<code><a href="#topic+set_endian">set_endian</a>()</code>,
<code><a href="#topic+set_eof_check">set_eof_check</a>()</code>,
<code><a href="#topic+set_integer_promotion">set_integer_promotion</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Open a connection and configure it so any attempt to write an NA
# value will cause a warning only (the default behaviour is to raise an error)
con &lt;- rawConnection(raw(), "wb")
con &lt;- set_na_check(con, na_check = "warn")

# This write should work without issues
write_dbl(con, c(1, 2, 3, 4))

# This write will cause a warning
write_dbl(con, c(1, 2, 3, NA))

close(con)

</code></pre>

<hr>
<h2 id='write_f64'>Convert values to the given type and write to a connection</h2><span id='topic+write_f64'></span><span id='topic+write_dbl'></span><span id='topic+write_f32'></span><span id='topic+write_single'></span><span id='topic+write_f16'></span><span id='topic+write_half'></span>

<h3>Description</h3>

<p>Convert values to the given type and write to a connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_f64(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_dbl(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_f32(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_single(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_f16(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_half(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_f64_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. When con is a raw vector, new
data will be <em>appended</em> to the vector and returned.
Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="write_f64_+3A_x">x</code></td>
<td>
<p>vector to write</p>
</td></tr>
<tr><td><code id="write_f64_+3A_endian">endian</code></td>
<td>
<p>Ordering of bytes within the file when reading multi-byte values.
Possible values: 'big' or 'little'.  
Default: NULL indicates that
endian option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_endian">set_endian</a>()</code>) or otherwise 
will be set to <code>"little"</code></p>
</td></tr>
<tr><td><code id="write_f64_+3A_bounds_check">bounds_check</code></td>
<td>
<p>Check values lie within bounds of the given type.
Default: NULL indicates that
this option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_bounds_check">set_bounds_check</a>()</code>) or otherwise 
will be set to <code>"error"</code></p>
</td></tr>
<tr><td><code id="write_f64_+3A_na_check">na_check</code></td>
<td>
<p>Check for NAs in the data to be written.
Default: NULL indicates that
this option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_na_check">set_na_check</a>()</code>) or otherwise 
will be set to <code>"error"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>con</code> is a connection then this connection is returned invisibly.
If <code>con</code> is a raw vector then new data is appended to this vector
</p>


<h3>See Also</h3>

<p>Other data output functions: 
<code><a href="#topic+fprintf">fprintf</a>()</code>,
<code><a href="#topic+write_hex">write_hex</a>()</code>,
<code><a href="#topic+write_raw">write_raw</a>()</code>,
<code><a href="#topic+write_uint8">write_uint8</a>()</code>,
<code><a href="#topic+write_utf8">write_utf8</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- file(tempfile(), "wb")
write_f64(con, c(1, 2, 3, 4))
close(con)
</code></pre>

<hr>
<h2 id='write_hex'>Write hexadecimal string as raw bytes</h2><span id='topic+write_hex'></span>

<h3>Description</h3>

<p>Write hexadecimal string as raw bytes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_hex(con, x, endian = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_hex_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. When con is a raw vector, new
data will be <em>appended</em> to the vector and returned.
Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="write_hex_+3A_x">x</code></td>
<td>
<p>vector to write</p>
</td></tr>
<tr><td><code id="write_hex_+3A_endian">endian</code></td>
<td>
<p>Ordering of bytes within the file when reading multi-byte values.
Possible values: 'big' or 'little'.  
Default: NULL indicates that
endian option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_endian">set_endian</a>()</code>) or otherwise 
will be set to <code>"little"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>con</code> is a connection then this connection is returned invisibly.
If <code>con</code> is a raw vector then new data is appended to this vector
</p>


<h3>See Also</h3>

<p>Other data output functions: 
<code><a href="#topic+fprintf">fprintf</a>()</code>,
<code><a href="#topic+write_f64">write_f64</a>()</code>,
<code><a href="#topic+write_raw">write_raw</a>()</code>,
<code><a href="#topic+write_uint8">write_uint8</a>()</code>,
<code><a href="#topic+write_utf8">write_utf8</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- file(tempfile(), "wb")
write_hex(con, c("ff80", "0102"))
close(con)
</code></pre>

<hr>
<h2 id='write_raw'>Write raw bytes</h2><span id='topic+write_raw'></span>

<h3>Description</h3>

<p>Write raw bytes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_raw(con, x, bounds_check = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_raw_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. When con is a raw vector, new
data will be <em>appended</em> to the vector and returned.
Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="write_raw_+3A_x">x</code></td>
<td>
<p>vector to write</p>
</td></tr>
<tr><td><code id="write_raw_+3A_bounds_check">bounds_check</code></td>
<td>
<p>Check values lie within bounds of the given type.
Default: NULL indicates that
this option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_bounds_check">set_bounds_check</a>()</code>) or otherwise 
will be set to <code>"error"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>con</code> is a connection then this connection is returned invisibly.
If <code>con</code> is a raw vector then new data is appended to this vector
</p>


<h3>See Also</h3>

<p>Other data output functions: 
<code><a href="#topic+fprintf">fprintf</a>()</code>,
<code><a href="#topic+write_f64">write_f64</a>()</code>,
<code><a href="#topic+write_hex">write_hex</a>()</code>,
<code><a href="#topic+write_uint8">write_uint8</a>()</code>,
<code><a href="#topic+write_utf8">write_utf8</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- file(tempfile(), "wb")
write_raw(con, as.raw(1:4))
write_raw(con, 1:4) 
close(con)
</code></pre>

<hr>
<h2 id='write_uint8'>Convert values to the given type and write to a connection</h2><span id='topic+write_uint8'></span><span id='topic+write_int8'></span><span id='topic+write_uint16'></span><span id='topic+write_int16'></span><span id='topic+write_uint32'></span><span id='topic+write_int32'></span><span id='topic+write_uint64'></span><span id='topic+write_int64'></span>

<h3>Description</h3>

<p>Convert values to the given type and write to a connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_uint8(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_int8(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_uint16(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_int16(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_uint32(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_int32(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_uint64(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)

write_int64(con, x, endian = NULL, bounds_check = NULL, na_check = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_uint8_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. When con is a raw vector, new
data will be <em>appended</em> to the vector and returned.
Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="write_uint8_+3A_x">x</code></td>
<td>
<p>vector to write</p>
</td></tr>
<tr><td><code id="write_uint8_+3A_endian">endian</code></td>
<td>
<p>Ordering of bytes within the file when reading multi-byte values.
Possible values: 'big' or 'little'.  
Default: NULL indicates that
endian option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_endian">set_endian</a>()</code>) or otherwise 
will be set to <code>"little"</code></p>
</td></tr>
<tr><td><code id="write_uint8_+3A_bounds_check">bounds_check</code></td>
<td>
<p>Check values lie within bounds of the given type.
Default: NULL indicates that
this option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_bounds_check">set_bounds_check</a>()</code>) or otherwise 
will be set to <code>"error"</code></p>
</td></tr>
<tr><td><code id="write_uint8_+3A_na_check">na_check</code></td>
<td>
<p>Check for NAs in the data to be written.
Default: NULL indicates that
this option should be retrieved from the connection object if possible
(where the user has used <code><a href="#topic+set_na_check">set_na_check</a>()</code>) or otherwise 
will be set to <code>"error"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>con</code> is a connection then this connection is returned invisibly.
If <code>con</code> is a raw vector then new data is appended to this vector
</p>


<h3>See Also</h3>

<p>Other data output functions: 
<code><a href="#topic+fprintf">fprintf</a>()</code>,
<code><a href="#topic+write_f64">write_f64</a>()</code>,
<code><a href="#topic+write_hex">write_hex</a>()</code>,
<code><a href="#topic+write_raw">write_raw</a>()</code>,
<code><a href="#topic+write_utf8">write_utf8</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- file(tempfile(), "wb")
write_uint8(con, 1:4)
close(con)
</code></pre>

<hr>
<h2 id='write_utf8'>Write UTF8 string</h2><span id='topic+write_utf8'></span><span id='topic+write_utf8_raw'></span>

<h3>Description</h3>

<p><code>write_utf8_raw()</code> writes the string without a nul-terminator.
<code>write_utf8()</code> includes a nul-terminator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_utf8(con, x)

write_utf8_raw(con, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_utf8_+3A_con">con</code></td>
<td>
<p>Connection object or raw vector. When con is a raw vector, new
data will be <em>appended</em> to the vector and returned.
Connection objects can be 
created with <code>file()</code>, <code>url()</code>, 
<code>rawConnection()</code> or any of the other many connection creation
functions.</p>
</td></tr>
<tr><td><code id="write_utf8_+3A_x">x</code></td>
<td>
<p>single character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>con</code> is a connection then this connection is returned invisibly.
If <code>con</code> is a raw vector then new data is appended to this vector
</p>


<h3>See Also</h3>

<p>Other data output functions: 
<code><a href="#topic+fprintf">fprintf</a>()</code>,
<code><a href="#topic+write_f64">write_f64</a>()</code>,
<code><a href="#topic+write_hex">write_hex</a>()</code>,
<code><a href="#topic+write_raw">write_raw</a>()</code>,
<code><a href="#topic+write_uint8">write_uint8</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con &lt;- file(tempfile(), "wb")
write_utf8(con, "hello")
close(con)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
