<!DOCTYPE html><html><head><title>Help for package StochBlock</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StochBlock}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#findActiveParam'><p>Finds the active model's parameters</p></a></li>
<li><a href='#ICLStochBlock'><p>Function that computes integrated classification likelihood based on stochastic one-mode and linked block modeling. If <code>clu</code> is a list, the method for linked/multilevel networks is applied. The support for multirelational networks is not tested.</p></a></li>
<li><a href='#llStochBlock'><p>Function that computes criterion function used in stochastic one-mode and linked blockmodeling. If <code>clu</code> is a list, the method for linked/multilevel networks is applied</p></a></li>
<li><a href='#stochBlock'><p>Function that performs stochastic one-mode and linked blockmodeling by optimizing a single partition. If <code>clu</code> is a list, the method for linked/multilevel networks is applied</p></a></li>
<li><a href='#StochBlock-package'><p>StochBlock: Stochastic Blockmodeling of One-Mode and Linked Networks</p></a></li>
<li><a href='#stochBlockKMint'><p>A function for using k-means to initialized the  stochastic one-mode and linked blockmodeling.</p></a></li>
<li><a href='#stochBlockORP'><p>A function for optimizing multiple random partitions using stochastic one-mode and linked blockmodeling. Similar to optRandomParC, but calling stochBlock for optimizing individual partitions.</p></a></li>
<li><a href='#weightsMlLoglik'><p>Computes weights for parts of the multilevel network based on random errors using the SS approach with complete blocks only (compatible with k-means)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stochastic Blockmodeling of One-Mode and Linked Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aleš Žiberna &lt;ales.ziberna@fdv.uni-lj.si&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Stochastic blockmodeling of one-mode and linked networks as implemented in Škulj and Žiberna (2022) &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2022.02.001">doi:10.1016/j.socnet.2022.02.001</a>&gt;. The optimization is done via CEM (Classification Expectation Maximization) algorithm that can be initialized by random partitions or the results of k-means algorithm. The development of this package is financially supported by the Slovenian Research Agency (<a href="https://www.arrs.si/">https://www.arrs.si/</a>) within the research programs P5-0168 and the research projects J7-8279 (Blockmodeling multilevel and temporal networks) and J5-2557 (Comparison and evaluation of different approaches to blockmodeling dynamic networks by simulations with application to Slovenian co-authorship networks).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>blockmodeling, doParallel, doRNG, foreach, Rcpp (&ge; 1.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-23 06:21:33 UTC; zibernaa</td>
</tr>
<tr>
<td>Author:</td>
<td>Aleš Žiberna <a href="https://orcid.org/0000-0003-1534-6971"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Fabio Ashtar Telarico
    <a href="https://orcid.org/0000-0002-8740-7078"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-24 10:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='findActiveParam'>Finds the active model's parameters</h2><span id='topic+findActiveParam'></span>

<h3>Description</h3>

<p>Finds the active model's parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findActiveParam(M, n, k, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findActiveParam_+3A_m">M</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="findActiveParam_+3A_n">n</code></td>
<td>
<p>number of units (equal to number of <code>M</code>'s rows)</p>
</td></tr>
<tr><td><code id="findActiveParam_+3A_k">k</code></td>
<td>
<p>parameters to retrieve</p>
</td></tr>
<tr><td><code id="findActiveParam_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, whether to ignore <code>NA</code> data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing the parameters
</p>

<hr>
<h2 id='ICLStochBlock'>Function that computes integrated classification likelihood based on stochastic one-mode and linked block modeling. If <code>clu</code> is a list, the method for linked/multilevel networks is applied. The support for multirelational networks is not tested.</h2><span id='topic+ICLStochBlock'></span>

<h3>Description</h3>

<p>Function that computes integrated classification likelihood based on stochastic one-mode and linked block modeling. If <code>clu</code> is a list, the method for linked/multilevel networks is applied. The support for multirelational networks is not tested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICLStochBlock(
  M,
  clu,
  weights = NULL,
  uWeights = NULL,
  diagonal = c("ignore", "seperate", "same"),
  limitType = c("none", "inside", "outside"),
  limits = NULL,
  weightClusterSize = 1,
  addOne = TRUE,
  eps = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICLStochBlock_+3A_m">M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For multi-relational networks, this should be an array with the third dimension representing the relation.</p>
</td></tr>
<tr><td><code id="ICLStochBlock_+3A_clu">clu</code></td>
<td>
<p>A partition. Each unique value represents one cluster. If the nework is one-mode, than this should be a vector, else a list of vectors, one for each mode. Similarly, if units are comprised of several sets, clu should be the list containing one vector for each set.</p>
</td></tr>
<tr><td><code id="ICLStochBlock_+3A_weights">weights</code></td>
<td>
<p>The weights for each cell in the matrix/array. A matrix or an array with the same dimmensions as <code>M</code>.</p>
</td></tr>
<tr><td><code id="ICLStochBlock_+3A_uweights">uWeights</code></td>
<td>
<p>The weights for each unin. A vector with the length equal to the number of units (in all sets).</p>
</td></tr>
<tr><td><code id="ICLStochBlock_+3A_diagonal">diagonal</code></td>
<td>
<p>How should the diagonal values be treated. Possible values are:
</p>

<ul>
<li><p> ignore - diagonal values are ignored
</p>
</li>
<li><p> seperate - diagonal values are treated seperately
</p>
</li>
<li><p> same - diagonal values are treated the same as all other values
</p>
</li></ul>
</td></tr>
<tr><td><code id="ICLStochBlock_+3A_limittype">limitType</code></td>
<td>
<p>Type of limit to use. Forced to 'none' if <code>limits</code> is <code>NULL</code>. Otherwise, one of either <code>outer</code> or <code>inner</code>.</p>
</td></tr>
<tr><td><code id="ICLStochBlock_+3A_limits">limits</code></td>
<td>
<p>If <code>diagonal</code> is <code>"ignore"</code> or <code>"same"</code>, an array with dimensions equal to:
</p>

<ul>
<li><p> number of clusters (of all types)
</p>
</li>
<li><p> number of clusters (of all types)
</p>
</li>
<li><p> number of relations
</p>
</li>
<li><p> 2 - the first is lower limit and the second is upper limit
</p>
</li></ul>

<p>If <code>diagonal</code> is <code>"seperate"</code>, a list of two array. The first should be as described above, representing limits for off diagonal values. The second should be similar with only 3 dimensions, as one of the first two must be omitted.</p>
</td></tr>
<tr><td><code id="ICLStochBlock_+3A_weightclustersize">weightClusterSize</code></td>
<td>
<p>The weight given to cluster sizes (logprobabilites) compared to ties in loglikelihood. Defaults to 1, which is &quot;classical&quot; stochastic blockmodeling.</p>
</td></tr>
<tr><td><code id="ICLStochBlock_+3A_addone">addOne</code></td>
<td>
<p>Should one tie with the value of the tie equal to the density of the superBlock be added to each block to prevent block means equal to 0 or 1 and also &quot;shrink&quot; the block means toward the superBlock mean. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="ICLStochBlock_+3A_eps">eps</code></td>
<td>
<p>If addOne = FALSE, the minimal deviation from 0 or 1 that the block mean/density can take.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of ICL
</p>


<h3>See Also</h3>

<p><code><a href="#topic+llStochBlock">llStochBlock</a></code>; <code><a href="#topic+weightsMlLoglik">weightsMlLoglik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a synthetic network matrix
set.seed(2022)
library(blockmodeling)
k&lt;-2 # number of blocks to generate
blockSizes&lt;-rep(20,k)
IM&lt;-matrix(c(0.8,.4,0.2,0.8), nrow=2)
clu&lt;-rep(1:k, times=blockSizes)
n&lt;-length(clu)
M&lt;-matrix(rbinom(n*n,1,IM[clu,clu]),ncol=n, nrow=n)
clu&lt;-sample(1:2,nrow(M),replace=TRUE)
plotMat(M,clu) # Have a look at this random partition
ICL_pre&lt;-ICLStochBlock(M,clu) # Calculate its ICL
ICL_pre
res&lt;-stochBlock(M,clu=clu) # Optimizing the partition
plot(res) # Have a look at the optimized partition
ICL_post&lt;-res$ICL # Calculate its ICL
ICL_post
# We expect the ICL pre-optimisation to be smaller:
ICL_pre&lt;ICL_post			   

</code></pre>

<hr>
<h2 id='llStochBlock'>Function that computes criterion function used in stochastic one-mode and linked blockmodeling. If <code>clu</code> is a list, the method for linked/multilevel networks is applied</h2><span id='topic+llStochBlock'></span>

<h3>Description</h3>

<p>Function that computes criterion function used in stochastic one-mode and linked blockmodeling. If <code>clu</code> is a list, the method for linked/multilevel networks is applied
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llStochBlock(
  M,
  clu,
  weights = NULL,
  uWeights = NULL,
  diagonal = c("ignore", "seperate", "same"),
  limitType = c("none", "inside", "outside"),
  limits = NULL,
  weightClusterSize = 1,
  addOne = TRUE,
  eps = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llStochBlock_+3A_m">M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For multi-relational networks, this should be an array with the third dimension representing the relation.</p>
</td></tr>
<tr><td><code id="llStochBlock_+3A_clu">clu</code></td>
<td>
<p>A partition. Each unique value represents one cluster. If the network is one-mode, than this should be a vector, else a list of vectors, one for each mode. Similarly, if units are comprised of several sets, clu should be the list containing one vector for each set.</p>
</td></tr>
<tr><td><code id="llStochBlock_+3A_weights">weights</code></td>
<td>
<p>The weights for each cell in the matrix/array. A matrix or an array with the same dimensions as <code>M</code>.</p>
</td></tr>
<tr><td><code id="llStochBlock_+3A_uweights">uWeights</code></td>
<td>
<p>The weights for each unit. A vector with the length equal to the number of units (in all sets).</p>
</td></tr>
<tr><td><code id="llStochBlock_+3A_diagonal">diagonal</code></td>
<td>
<p>How should the diagonal values be treated. Possible values are:
</p>

<ul>
<li><p> ignore - diagonal values are ignored
</p>
</li>
<li><p> seperate - diagonal values are treated separately
</p>
</li>
<li><p> same - diagonal values are treated the same as all other values
</p>
</li></ul>
</td></tr>
<tr><td><code id="llStochBlock_+3A_limittype">limitType</code></td>
<td>
<p>Type of limit to use. Forced to 'none' if <code>limits</code> is <code>NULL</code>. Otherwise, one of either <code>outer</code> or <code>inner</code>.</p>
</td></tr>
<tr><td><code id="llStochBlock_+3A_limits">limits</code></td>
<td>
<p>If <code>diagonal</code> is <code>"ignore"</code> or <code>"same"</code>, an array with dimensions equal to:
</p>

<ul>
<li><p> number of clusters (of all types)
</p>
</li>
<li><p> number of clusters (of all types)
</p>
</li>
<li><p> number of relations
</p>
</li>
<li><p> 2 - the first is lower limit and the second is upper limit
</p>
</li></ul>

<p>If <code>diagonal</code> is <code>"seperate"</code>, a list of two array. The first should be as described above, representing limits for off diagonal values. The second should be similar with only 3 dimensions, as one of the first two must be omitted.</p>
</td></tr>
<tr><td><code id="llStochBlock_+3A_weightclustersize">weightClusterSize</code></td>
<td>
<p>The weight given to cluster sizes (log-probabilities) compared to ties in loglikelihood. Defaults to 1, which is &quot;classical&quot; stochastic blockmodeling.</p>
</td></tr>
<tr><td><code id="llStochBlock_+3A_addone">addOne</code></td>
<td>
<p>Should one tie with the value of the tie equal to the density of the superBlock be added to each block to prevent block means equal to 0 or 1 and also &quot;shrink&quot; the block means toward the superBlock mean. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="llStochBlock_+3A_eps">eps</code></td>
<td>
<p>If addOne = FALSE, the minimal deviation from 0 or 1 that the block mean/density can take.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>- the value of the log-likelihood criterion for the partition <code>clu</code> on the network represented by <code>M</code> for binary stochastic blockmodel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a synthetic network matrix
set.seed(2022)
library(blockmodeling)
k&lt;-2 # number of blocks to generate
blockSizes&lt;-rep(20,k)
IM&lt;-matrix(c(0.8,.4,0.2,0.8), nrow=2)
clu&lt;-rep(1:k, times=blockSizes)
n&lt;-length(clu)
M&lt;-matrix(rbinom(n*n,1,IM[clu,clu]),ncol=n, nrow=n)
clu&lt;-sample(1:2,nrow(M),replace=TRUE)
plotMat(M,clu) # Have a look at this random partition
ll_pre&lt;-llStochBlock(M,clu) # Calculate its loglikelihood
res&lt;-stochBlockORP(M,k=2,rep=10) # Optimizing the partition
plot(res) # Have a look at the optimized partition
ll_post&lt;-llStochBlock(M,clu(res)) # Calculate its loglikelihood
# We expect the loglikelihood pre-optimization to be smaller:
(-ll_pre)&lt;(-ll_post)
  

</code></pre>

<hr>
<h2 id='stochBlock'>Function that performs stochastic one-mode and linked blockmodeling by optimizing a single partition. If <code>clu</code> is a list, the method for linked/multilevel networks is applied</h2><span id='topic+stochBlock'></span>

<h3>Description</h3>

<p>Function that performs stochastic one-mode and linked blockmodeling by optimizing a single partition. If <code>clu</code> is a list, the method for linked/multilevel networks is applied
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stochBlock(
  M,
  clu,
  weights = NULL,
  uWeights = NULL,
  diagonal = c("ignore", "seperate", "same"),
  limitType = c("none", "inside", "outside"),
  limits = NULL,
  weightClusterSize = 1,
  addOne = TRUE,
  eps = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stochBlock_+3A_m">M</code></td>
<td>
<p>A matrix representing the (usually valued) network. For multi-relational networks, this should be an array with the third dimension representing the relation.</p>
</td></tr>
<tr><td><code id="stochBlock_+3A_clu">clu</code></td>
<td>
<p>A partition. Each unique value represents one cluster. If the network is one-mode, than this should be a vector, else a list of vectors, one for each mode. Similarly, if units are comprised of several sets, clu should be the list containing one vector for each set.</p>
</td></tr>
<tr><td><code id="stochBlock_+3A_weights">weights</code></td>
<td>
<p>The weights for each cell in the matrix/array. A matrix or an array with the same dimensions as <code>M</code>.</p>
</td></tr>
<tr><td><code id="stochBlock_+3A_uweights">uWeights</code></td>
<td>
<p>The weights for each unin. A vector with the length equal to the number of units (in all sets).</p>
</td></tr>
<tr><td><code id="stochBlock_+3A_diagonal">diagonal</code></td>
<td>
<p>How should the diagonal values be treated. Possible values are:
</p>

<ul>
<li><p> ignore - diagonal values are ignored
</p>
</li>
<li><p> seperate - diagonal values are treated seperately
</p>
</li>
<li><p> same - diagonal values are treated the same as all other values
</p>
</li></ul>
</td></tr>
<tr><td><code id="stochBlock_+3A_limittype">limitType</code></td>
<td>
<p>Type of limit to use. Forced to 'none' if <code>limits</code> is <code>NULL</code>. Otherwise, one of either <code>outer</code> or <code>inner</code>.</p>
</td></tr>
<tr><td><code id="stochBlock_+3A_limits">limits</code></td>
<td>
<p>If <code>diagonal</code> is <code>"ignore"</code> or <code>"same"</code>, an array with dimensions equal to:
</p>

<ul>
<li><p> number of clusters (of all types)
</p>
</li>
<li><p> number of clusters (of all types)
</p>
</li>
<li><p> number of relations
</p>
</li>
<li><p> 2 - the first is lower limit and the second is upper limit
</p>
</li></ul>

<p>If <code>diagonal</code> is <code>"seperate"</code>, a list of two array. The first should be as described above, representing limits for off diagonal values. The second should be similar with only 3 dimensions, as one of the first two must be omitted.</p>
</td></tr>
<tr><td><code id="stochBlock_+3A_weightclustersize">weightClusterSize</code></td>
<td>
<p>The weight given to cluster sizes (logprobabilites) compared to ties in loglikelihood. Defaults to 1, which is &quot;classical&quot; stochastic blockmodeling.</p>
</td></tr>
<tr><td><code id="stochBlock_+3A_addone">addOne</code></td>
<td>
<p>Should one tie with the value of the tie equal to the density of the superBlock be added to each block to prevent block means equal to 0 or 1 and also &quot;shrink&quot; the block means toward the superBlock mean. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="stochBlock_+3A_eps">eps</code></td>
<td>
<p>If addOne = FALSE, the minimal deviation from 0 or 1 that the block mean/density can take.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>opt.par</code> normally passed other commands with <code>StockBlockORP</code> and containing:
</p>
<table>
<tr><td><code>clu</code></td>
<td>
<p>A vector (a list for multi-mode networks) indicating the cluster to which each unit belongs;</p>
</td></tr>
<tr><td><code>IM</code></td>
<td>
<p>Image matrix of this partition;</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>The weights for each cell in the matrix/array. A matrix or an array with the same dimensions as <code>M</code>.</p>
</td></tr>
<tr><td><code>uWeights</code></td>
<td>
<p>The weights for each unit. A vector with the length equal to the number of units (in all sets).</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>The error as the sum of the inconsistencies between this network and the ideal partitions.</p>
</td></tr>
<tr><td><code>ICL</code></td>
<td>
<p>Integrated Criterion Likelihood for this partition</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleš, Žiberna
</p>


<h3>References</h3>

<p>Škulj, D., &amp; Žiberna, A. (2022). Stochastic blockmodeling of linked networks. Social Networks, 70, 240-252.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stochBlockORP">stochBlockORP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a synthetic network matrix
set.seed(2022)
library(blockmodeling)
k&lt;-2 # number of blocks to generate
blockSizes&lt;-rep(20,k)
IM&lt;-matrix(c(0.8,.4,0.2,0.8), nrow=2)
clu&lt;-rep(1:k, times=blockSizes)
n&lt;-length(clu)
M&lt;-matrix(rbinom(n*n,1,IM[clu,clu]),ncol=n, nrow=n)
clu&lt;-sample(1:2,nrow(M),replace=TRUE)
plotMat(M,clu) # Have a look at this random partition
res&lt;-stochBlock(M,clu) # Optimising the partition
plot(res) # Have a look at the optimised parition

# Create a synthetic linked-network matrix
set.seed(2022)
library(blockmodeling)
IM&lt;-matrix(c(0.8,.4,0.2,0.8), nrow=2)
clu&lt;-rep(1:2, each=20) # Partition to generate
n&lt;-length(clu)
nClu&lt;-length(unique(clu)) # Number of clusters to generate
M1&lt;-matrix(rbinom(n^2,1,IM[clu,clu]),ncol=n, nrow=n) # First network
M2&lt;-matrix(rbinom(n^2,1,IM[clu,clu]),ncol=n, nrow=n) # Second network
M12&lt;-diag(n) # Linking network
nn&lt;-c(n,n)
k&lt;-c(2,2)
Ml&lt;-matrix(0, nrow=sum(nn),ncol=sum(nn)) 
Ml[1:n,1:n]&lt;-M1
Ml[n+1:n,n+1:n]&lt;-M2
Ml[n+1:n, 1:n]&lt;-M12 
plotMat(Ml) # Linked network
clu1&lt;-sample(1:2,nrow(M1),replace=TRUE)
clu2&lt;-sample(3:4,nrow(M1),replace=TRUE)
plotMat(Ml,list(clu1,clu2)) # Have a look at this random partition
res&lt;-stochBlock(Ml,list(clu1,clu2)) # Optimising the partition
plot(res) # Have a look at the optimised parition

</code></pre>

<hr>
<h2 id='StochBlock-package'>StochBlock: Stochastic Blockmodeling of One-Mode and Linked Networks</h2><span id='topic+StochBlock'></span><span id='topic+StochBlock-package'></span>

<h3>Description</h3>

<p>Stochastic blockmodeling of one-mode and linked networks as implemented in Škulj and Žiberna (2022) <a href="https://doi.org/10.1016/j.socnet.2022.02.001">doi:10.1016/j.socnet.2022.02.001</a>. The optimization is done via CEM (Classification Expectation Maximization) algorithm that can be initialized by random partitions or the results of k-means algorithm. The development of this package is financially supported by the Slovenian Research Agency (<a href="https://www.arrs.si/">https://www.arrs.si/</a>) within the research programs P5-0168 and the research projects J7-8279 (Blockmodeling multilevel and temporal networks) and J5-2557 (Comparison and evaluation of different approaches to blockmodeling dynamic networks by simulations with application to Slovenian co-authorship networks).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aleš Žiberna <a href="mailto:ales.ziberna@fdv.uni-lj.si">ales.ziberna@fdv.uni-lj.si</a> (<a href="https://orcid.org/0000-0003-1534-6971">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Fabio Ashtar Telarico <a href="mailto:Fabio-Ashtar.Telarico@fdv.uni-lj.si">Fabio-Ashtar.Telarico@fdv.uni-lj.si</a> (<a href="https://orcid.org/0000-0002-8740-7078">ORCID</a>) [contributor]
</p>
</li></ul>


<hr>
<h2 id='stochBlockKMint'>A function for using k-means to initialized the  stochastic one-mode and linked blockmodeling.</h2><span id='topic+stochBlockKMint'></span>

<h3>Description</h3>

<p>A function for using k-means to initialized the  stochastic one-mode and linked blockmodeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stochBlockKMint(
  M,
  k,
  nstart = 100,
  perm = 0,
  sharePerm = 0.2,
  save.initial.param = TRUE,
  deleteMs = TRUE,
  max.iden = 10,
  return.all = FALSE,
  return.err = TRUE,
  seed = NULL,
  maxTriesToFindNewPar = perm * 10,
  skip.par = NULL,
  printRep = ifelse(perm &lt;= 10, 1, round(perm/10)),
  n = NULL,
  nCores = 1,
  useParLapply = FALSE,
  cl = NULL,
  stopcl = is.null(cl),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stochBlockKMint_+3A_m">M</code></td>
<td>
<p>A square matrix giving the adjaciency relationg between the network's nodes (aka vertexes)</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_k">k</code></td>
<td>
<p>The number of clusters used in the generation of partitions.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_nstart">nstart</code></td>
<td>
<p>number of random starting points for the classical k-means algorithm (for each set of units). Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_perm">perm</code></td>
<td>
<p>Number or partitions obtained by randomly permuting the k-means partition - if 0, no permutations are made, only the original partition is analyzed.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_shareperm">sharePerm</code></td>
<td>
<p>The probability that a unit will have their randomly assigned. Defaults to <code>0.20</code>.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_save.initial.param">save.initial.param</code></td>
<td>
<p>Should the inital parameters(<code>approaches</code>, ...) of using <code>stochBlock</code> be saved. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_deletems">deleteMs</code></td>
<td>
<p>Delete networks/matrices from the results of to save space. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_max.iden">max.iden</code></td>
<td>
<p>Maximum number of results that should be saved (in case there are more than <code>max.iden</code> results with minimal error, only the first <code>max.iden</code> will be saved).</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_return.all">return.all</code></td>
<td>
<p>If <code>FALSE</code>, solution for only the best (one or more) partition/s is/are returned.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_return.err">return.err</code></td>
<td>
<p>Should the error for each optimized partition be returned. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_seed">seed</code></td>
<td>
<p>Optional. The seed for random generation of partitions.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_maxtriestofindnewpar">maxTriesToFindNewPar</code></td>
<td>
<p>The maximum number of partition try when trying to find a new partition to optimize that was not yet checked before - the default value is <code>rep * 1000</code>.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_skip.par">skip.par</code></td>
<td>
<p>The partitions that are not allowed or were already checked and should therefore be skipped.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_printrep">printRep</code></td>
<td>
<p>Should some information about each optimization be printed.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_n">n</code></td>
<td>
<p>The number of units by &quot;modes&quot;. It is used only for generating random partitions. It has to be set only if there are more than two modes or if there are two modes, but the matrix representing the network is one mode (both modes are in rows and columns).</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_ncores">nCores</code></td>
<td>
<p>Number of cores to be used. Value <code>0</code> means all available cores. It can also be a cluster object.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_useparlapply">useParLapply</code></td>
<td>
<p>Should <code>parLapplyLB</code> be used (otherwise <code>foreach</code> is used). Defaults to true as it needs less dependencies. It might be removed in future releases and only allow the use of parLapplyLB.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_cl">cl</code></td>
<td>
<p>The cluster to use (if formed beforehand). Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_stopcl">stopcl</code></td>
<td>
<p>Should the cluster be stopped after the function finishes. Defaults to <code>is.null(cl)</code>.</p>
</td></tr>
<tr><td><code id="stochBlockKMint_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions, see <code><a href="#topic+stochBlock">stochBlock</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>The one- or multi-mode matrix of the network analyzed</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>If <code>return.all = TRUE</code> - A list of results the same as <code>best</code> - one <code>best</code> for each partition optimized.</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>A list of results from <code>stochblock</code>, only without <code>M</code>.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>If <code>return.err = TRUE</code> - The vector of errors or inconsistencies of the empirical  network with the ideal partitions.</p>
</td></tr>
<tr><td><code>nIter</code></td>
<td>
<p>The vector of the iterations on each starting partition. If many of the values equal<code>maxiter</code>, then  <code>maxiter</code> may be too small.</p>
</td></tr>
<tr><td><code>checked.par</code></td>
<td>
<p>If selected - A list of checked partitions. If <code>merge.save.skip.par</code> is <code>TRUE</code>, this list also includes the partitions in <code>skip.par</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call to this function.</p>
</td></tr>
<tr><td><code>initial.param</code></td>
<td>
<p>If selected - The initial parameters are used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleš, Žiberna
</p>


<h3>References</h3>

<p>Škulj, D., &amp; Žiberna, A. (2022). Stochastic blockmodeling of linked networks. Social Networks, 70, 240-252.
</p>

<hr>
<h2 id='stochBlockORP'>A function for optimizing multiple random partitions using stochastic one-mode and linked blockmodeling. Similar to optRandomParC, but calling stochBlock for optimizing individual partitions.</h2><span id='topic+stochBlockORP'></span>

<h3>Description</h3>

<p>A function for optimizing multiple random partitions using stochastic one-mode and linked blockmodeling. Similar to optRandomParC, but calling stochBlock for optimizing individual partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stochBlockORP(
  M,
  k,
  rep,
  save.initial.param = TRUE,
  deleteMs = TRUE,
  max.iden = 10,
  return.all = FALSE,
  return.err = TRUE,
  seed = NULL,
  parGenFun = blockmodeling::genRandomPar,
  mingr = NULL,
  maxgr = NULL,
  addParam = list(genPajekPar = TRUE, probGenMech = NULL),
  maxTriesToFindNewPar = rep * 10,
  skip.par = NULL,
  printRep = ifelse(rep &lt;= 10, 1, round(rep/10)),
  n = NULL,
  nCores = 1,
  useParLapply = FALSE,
  cl = NULL,
  stopcl = is.null(cl),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stochBlockORP_+3A_m">M</code></td>
<td>
<p>A square matrix giving the adjaciency relationg between the network's nodes (aka vertexes)</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_k">k</code></td>
<td>
<p>The number of clusters used in the generation of partitions.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_rep">rep</code></td>
<td>
<p>The number of repetitions/different starting partitions to check.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_save.initial.param">save.initial.param</code></td>
<td>
<p>Should the inital parameters(<code>approaches</code>, ...) of using <code>stochBlock</code> be saved. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_deletems">deleteMs</code></td>
<td>
<p>Delete networks/matrices from the results of to save space. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_max.iden">max.iden</code></td>
<td>
<p>Maximum number of results that should be saved (in case there are more than <code>max.iden</code> results with minimal error, only the first <code>max.iden</code> will be saved).</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_return.all">return.all</code></td>
<td>
<p>If <code>FALSE</code>, solution for only the best (one or more) partition/s is/are returned.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_return.err">return.err</code></td>
<td>
<p>Should the error for each optimized partition be returned. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_seed">seed</code></td>
<td>
<p>Optional. The seed for random generation of partitions.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_pargenfun">parGenFun</code></td>
<td>
<p>The function (object) that will generate random partitions. The default function is   <code><a href="blockmodeling.html#topic+genRandomPar">genRandomPar</a></code>. The function has to accept the following parameters: <code>k</code> (number o of partitions by modes, <code>n</code> (number of units by modes), <code>seed</code> (seed value for random generation of partition), <code>addParam</code> (a list of additional parameters).</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_mingr">mingr</code></td>
<td>
<p>Minimal allowed group size.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_maxgr">maxgr</code></td>
<td>
<p>Maximal allowed group size.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_addparam">addParam</code></td>
<td>
<p>A list of additional parameters for function specified above. In the usage section they are specified for the default function <code><a href="blockmodeling.html#topic+genRandomPar">genRandomPar</a></code>.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_maxtriestofindnewpar">maxTriesToFindNewPar</code></td>
<td>
<p>The maximum number of partition try when trying to find a new partition to optimize that was not yet checked before - the default value is <code>rep * 1000</code>.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_skip.par">skip.par</code></td>
<td>
<p>The partitions that are not allowed or were already checked and should therefore be skipped.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_printrep">printRep</code></td>
<td>
<p>Should some information about each optimization be printed.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_n">n</code></td>
<td>
<p>The number of units by &quot;modes&quot;. It is used only for generating random partitions. It has to be set only if there are more than two modes or if there are two modes, but the matrix representing the network is one mode (both modes are in rows and columns).</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_ncores">nCores</code></td>
<td>
<p>Number of cores to be used. Value <code>0</code> means all available cores. It can also be a cluster object.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_useparlapply">useParLapply</code></td>
<td>
<p>Should <code>parLapplyLB</code> be used (otherwise <code>foreach</code> is used). Defaults to true as it needs less dependencies. It might be removed in future releases and only allow the use of parLapplyLB.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_cl">cl</code></td>
<td>
<p>The cluster to use (if formed beforehand). Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_stopcl">stopcl</code></td>
<td>
<p>Should the cluster be stopped after the function finishes. Defaults to <code>is.null(cl)</code>.</p>
</td></tr>
<tr><td><code id="stochBlockORP_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions, see <code><a href="#topic+stochBlock">stochBlock</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;opt.more.par&quot; containing:
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>The one- or multi-mode matrix of the network analyzed</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>If <code>return.all = TRUE</code> - A list of results the same as <code>best</code> - one <code>best</code> for each partition optimized.</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>A list of results from <code>stochblock</code>, only without <code>M</code>.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>If <code>return.err = TRUE</code> - The vector of errors or inconsistencies = -log-likelihoods.</p>
</td></tr>
<tr><td><code>ICL</code></td>
<td>
<p>Integrated classification likelihood for the best partition.</p>
</td></tr>
<tr><td><code>checked.par</code></td>
<td>
<p>If selected - A list of checked partitions. If <code>merge.save.skip.par</code> is <code>TRUE</code>, this list also includes the partitions in <code>skip.par</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call to this function.</p>
</td></tr>
<tr><td><code>initial.param</code></td>
<td>
<p>If selected - The initial parameters are used.</p>
</td></tr>
<tr><td><code>Random.seed</code></td>
<td>
<p>.Random.seed at the end of the function.</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>Cluster used for parallel computations if supplied as an input parameter.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>It should be noted that the time needed to optimise the partition depends on the number of units (aka nodes) in the networks as well as the number of clusters
due to the underlying algorithm. Hence, partitioning networks with 100 units and large number of blocks (e.g., &gt;5) can take a long time (from 20 minutes to a few hours or even days).
</p>


<h3>Author(s)</h3>

<p>Aleš, Žiberna
</p>


<h3>References</h3>

<p>Škulj, D., &amp; Žiberna, A. (2022). Stochastic blockmodeling of linked networks. Social Networks, 70, 240-252.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple one-mode network
library(blockmodeling)
k&lt;-2
blockSizes&lt;-rep(20,k)
IM&lt;-matrix(c(0.8,.4,0.2,0.8), nrow=2)
if(any(dim(IM)!=c(k,k))) stop("invalid dimensions")

set.seed(2021)
clu&lt;-rep(1:k, times=blockSizes)
n&lt;-length(clu)
M&lt;-matrix(rbinom(n*n,1,IM[clu,clu]),ncol=n, nrow=n)
diag(M)&lt;-0
plotMat(M)

resORP&lt;-stochBlockORP(M,k=2, rep=10, return.all = TRUE)
resORP$ICL
plot(resORP)
clu(resORP)


# Linked network
library(blockmodeling)
set.seed(2021)
IM&lt;-matrix(c(0.8,.4,0.2,0.8), nrow=2)
clu&lt;-rep(1:2, each=20)
n&lt;-length(clu)
nClu&lt;-length(unique(clu))
M1&lt;-matrix(rbinom(n^2,1,IM[clu,clu]),ncol=n, nrow=n)
M2&lt;-matrix(rbinom(n^2,1,IM[clu,clu]),ncol=n, nrow=n)
M12&lt;-diag(n)
nn&lt;-c(n,n)
k&lt;-c(2,2)
Ml&lt;-matrix(0, nrow=sum(nn),ncol=sum(nn))
Ml[1:n,1:n]&lt;-M1
Ml[n+1:n,n+1:n]&lt;-M2
Ml[n+1:n, 1:n]&lt;-M12
plotMat(Ml)

resMl&lt;-stochBlockORP(M=Ml, k=k, n=nn, rep=10)
resMl$ICL
plot(resMl)
clu(resMl)

</code></pre>

<hr>
<h2 id='weightsMlLoglik'>Computes weights for parts of the multilevel network based on random errors using the SS approach with complete blocks only (compatible with k-means)</h2><span id='topic+weightsMlLoglik'></span>

<h3>Description</h3>

<p>Computes weights for parts of the multilevel network based on random errors using the SS approach with complete blocks only (compatible with k-means)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightsMlLoglik(
  mlNet,
  cluParts,
  k,
  mWeights = 1000,
  sumFun = sd,
  nCores = 0,
  weightClusterSize = 0,
  paramGenPar = list(genPajekPar = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightsMlLoglik_+3A_mlnet">mlNet</code></td>
<td>
<p>A multilevel/linked network - The code assumes only one relation &ndash;&gt; a matrix.</p>
</td></tr>
<tr><td><code id="weightsMlLoglik_+3A_cluparts">cluParts</code></td>
<td>
<p>A partition spliting the units into different sets</p>
</td></tr>
<tr><td><code id="weightsMlLoglik_+3A_k">k</code></td>
<td>
<p>A vecotor of number of clusters for each set of units in the network.</p>
</td></tr>
<tr><td><code id="weightsMlLoglik_+3A_mweights">mWeights</code></td>
<td>
<p>The number of repetitions for computing random errors. Defaults to 1000</p>
</td></tr>
<tr><td><code id="weightsMlLoglik_+3A_sumfun">sumFun</code></td>
<td>
<p>The function to compute the summary of errors, which is then used to compute the weights by computing 1/summary. Defaults to <code>sd</code>.</p>
</td></tr>
<tr><td><code id="weightsMlLoglik_+3A_ncores">nCores</code></td>
<td>
<p>The number of to use for parallel computing. 0 means all available - 1, 1 means only once core - no parallel computing.</p>
</td></tr>
<tr><td><code id="weightsMlLoglik_+3A_weightclustersize">weightClusterSize</code></td>
<td>
<p>The weight given to cluster sizes. Defalults to 0, as only this is weighted my the tie-based weights.</p>
</td></tr>
<tr><td><code id="weightsMlLoglik_+3A_paramgenpar">paramGenPar</code></td>
<td>
<p>The parameter <code>addParam</code> from  <code><a href="blockmodeling.html#topic+genRandomPar">genRandomPar</a></code> (see documentation there). Default here is paramGenPar=list(genPajekPar = FALSE), which is different from the default in <code><a href="blockmodeling.html#topic+genRandomPar">genRandomPar</a></code>. The same value is used for generating partitions for all partitions.</p>
</td></tr>
<tr><td><code id="weightsMlLoglik_+3A_...">...</code></td>
<td>
<p>Paramters passed to <code><a href="#topic+llStochBlock">llStochBlock</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Weights and &quot;intermediate results&quot;:
</p>
<table>
<tr><td><code>errArr</code></td>
<td>
<p>A 3d array of errors (<code>mWeights</code> for each part of the network)</p>
</td></tr>
<tr><td><code>errMatSum</code></td>
<td>
<p><code>errArr</code> summed over all repetitions.</p>
</td></tr>
<tr><td><code>weightsMat</code></td>
<td>
<p>A matrix of weights, one for each part. An inverse of <code>errMatSum</code> with NaNs replaced by zeros.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleš, Žiberna
</p>


<h3>References</h3>

<p>Škulj, D., &amp; Žiberna, A. (2022). Stochastic blockmodeling of linked networks. Social Networks, 70, 240-252.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+llStochBlock">llStochBlock</a></code>; <code><a href="#topic+ICLStochBlock">ICLStochBlock</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
