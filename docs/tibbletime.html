<!DOCTYPE html><html lang="en"><head><title>Help for package tibbletime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tibbletime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tibbletime'><p>tibbletime: time-aware tibbles</p></a></li>
<li><a href='#as_period'><p>Change <code>tbl_time</code> periodicity</p></a></li>
<li><a href='#as_tbl_time'><p>Create <code>tbl_time</code> objects</p></a></li>
<li><a href='#ceiling_index'><p>A simple wrapper of <code>lubridate::ceiling_date()</code></p></a></li>
<li><a href='#collapse_by'><p>Collapse a tbl_time object by its index</p></a></li>
<li><a href='#collapse_index'><p>Collapse an index vector so that all observations in an interval share the</p>
same date</a></li>
<li><a href='#create_series'><p>Create a <code>tbl_time</code> object with a sequence of regularly spaced dates</p></a></li>
<li><a href='#FANG'><p>Stock prices for Facebook, Amazon, Netflix and Google from 2013-2016</p></a></li>
<li><a href='#FB'><p>Stock prices for Facebook from 2013-2016</p></a></li>
<li><a href='#filter_time'><p>Succinctly filter a <code>tbl_time</code> object by its index</p></a></li>
<li><a href='#floor_index'><p>A simple wrapper of <code>lubridate::floor_date()</code></p></a></li>
<li><a href='#getters'><p>Getters</p></a></li>
<li><a href='#new_tbl_time'><p>Create a new tbl_time object</p></a></li>
<li><a href='#parse_period'><p>Parse a character period specification</p></a></li>
<li><a href='#partition_index'><p>Partition an index vector into an integer vector representing groups</p></a></li>
<li><a href='#posixct_numeric_to_datetime'><p>Converting a posixct numeric time back to a classed datetime</p></a></li>
<li><a href='#reconstruct'><p>Reconstruct an S3 class from a template</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rollify'><p>Create a rolling version of any function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Aware Tibbles</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.9</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Davis Vaughan &lt;davis@posit.co&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Built on top of the 'tibble' package, 'tibbletime' is an extension
  that allows for the creation of time aware tibbles. Some immediate
  advantages of this include: the ability to perform time-based subsetting
  on tibbles, quickly summarising and aggregating results by time periods,
  and creating columns that can be used as 'dplyr' time-based groups.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/business-science/tibbletime">https://github.com/business-science/tibbletime</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/business-science/tibbletime/issues">https://github.com/business-science/tibbletime/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat (&ge; 0.2.1), dplyr (&ge; 1.0.10), glue (&ge; 1.6.2), hms
(&ge; 1.1.2), lubridate (&ge; 1.9.1), pillar (&ge; 1.8.1), purrr (&ge;
0.3.5), Rcpp (&ge; 1.0.9), rlang (&ge; 1.0.6), tibble (&ge; 3.1.8),
vctrs (&ge; 0.5.0), zoo (&ge; 1.8-11), lifecycle (&ge; 1.0.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom, covr, gapminder, knitr, rmarkdown, testthat, tidyr (&ge;
1.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-03 21:48:17 UTC; davis</td>
</tr>
<tr>
<td>Author:</td>
<td>Davis Vaughan [aut, cre],
  Matt Dancho [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-03 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tibbletime'>tibbletime: time-aware tibbles</h2><span id='topic+tibbletime-package'></span><span id='topic+tibbletime'></span>

<h3>Description</h3>

<p>Built on top of the 'tibble' package, 'tibbletime' is an extension
that allows for the creation of time aware tibbles. Some immediate
advantages of this include: the ability to perform time based subsetting
on tibbles, quickly summarising and aggregating results by time periods,
and calling functions similar in spirit to the map family from 'purrr'
on time based tibbles.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Matt Dancho <a href="mailto:mdancho@business-science.io">mdancho@business-science.io</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/business-science/tibbletime">https://github.com/business-science/tibbletime</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/business-science/tibbletime/issues">https://github.com/business-science/tibbletime/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_period'>Change <code>tbl_time</code> periodicity</h2><span id='topic+as_period'></span>

<h3>Description</h3>

<p>Convert a <code>tbl_time</code> object from daily to monthly,
from minute data to hourly, and more. This allows the user to easily
aggregate data to a less granular level by taking the value from either
the beginning or end of the period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_period(
  .tbl_time,
  period = "year",
  start_date = NULL,
  side = "start",
  include_endpoints = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_period_+3A_.tbl_time">.tbl_time</code></td>
<td>
<p>A <code>tbl_time</code> object.</p>
</td></tr>
<tr><td><code id="as_period_+3A_period">period</code></td>
<td>
<p>A character specification used for time-based grouping. The
general format to use is <code>"frequency period"</code> where frequency is a number
like 1 or 2, and period is an interval like weekly or yearly. There must be
a space between the two.
</p>
<p>Note that you can pass the specification in a flexible way:
</p>

<ul>
<li><p> 1 Year: <code>'1 year'</code> / <code>'1 Y'</code>
</p>
</li></ul>

<p>This shorthand is available for year, quarter, month, day, hour, minute,
second, millisecond and microsecond periodicities.
</p>
<p>Additionally, you have the option of passing in a vector of dates to
use as custom and more flexible boundaries.</p>
</td></tr>
<tr><td><code id="as_period_+3A_start_date">start_date</code></td>
<td>
<p>Optional argument used to
specify the start date for the
first group. The default is to start at the closest period boundary
below the minimum date in the supplied index.</p>
</td></tr>
<tr><td><code id="as_period_+3A_side">side</code></td>
<td>
<p>Whether to return the date at the beginning or the end of the
new period. By default, the <code>"start"</code> of the period. Use <code>"end"</code> to change
to the end of the period.</p>
</td></tr>
<tr><td><code id="as_period_+3A_include_endpoints">include_endpoints</code></td>
<td>
<p>Whether to include the first or last data point in
addition to the transformed data.</p>
</td></tr>
<tr><td><code id="as_period_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function respects <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> groups.
</p>
<p>The <code>side</code> argument is useful when you want to return data at, say, the
end of a quarter, or the end of a month.
</p>
<p><code>include_endpoints</code> can be useful when calculating a change over time.
In addition to changing to monthly dates, you often need the first data point
as a baseline for the first calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic usage ---------------------------------------------------------------

# FB stock prices
data(FB)
FB &lt;- as_tbl_time(FB, date)

# Aggregate FB to yearly data
as_period(FB, "year")

# Aggregate FB to every 2 years
as_period(FB, "2 years")

# Aggregate FB to yearly data, but use the last data point available
# in that period
as_period(FB, "year", side = "end")

# Aggregate FB to yearly data, end of period, and include the first
# endpoint
as_period(FB, "year", side = "end", include_endpoints = TRUE)

# Aggregate to weekly. Notice that it only uses the earliest day available
# in the data set at that periodicity. It will not set the date of the first
# row to 2013-01-01 because that date did not exist in the original data set.
as_period(FB, "weekly")

# FB is daily data, aggregate to minute?
# Not allowed for Date class indices, an error is thrown
# as_period(FB, "minute")

# Grouped usage -------------------------------------------------------------

# FANG contains Facebook, Amazon, Netflix and Google stock prices
data(FANG)
FANG &lt;- as_tbl_time(FANG, date)

FANG &lt;- dplyr::group_by(FANG, symbol)

# Respects groups
as_period(FANG, "year")

# Every 6 months, respecting groups
as_period(FANG, "6 months")

# Using start_date ----------------------------------------------------------


#### One method using start_date

# FB stock prices
data(FB)
FB &lt;- as_tbl_time(FB, date)

# The Facebook series starts at 2013-01-02 so the 'every 2 day' counter
# starts at that date as well. Groups become (2013-01-02, 2013-01-03),
# (2013-01-04, 2013-01-05) and so on.
as_period(FB, "2 day")

# Specifying the `start_date = "2013-01-01"` might be preferable.
# Groups become (2013-01-01, 2013-01-02), (2013-01-03, 2013-01-04) and so on.
as_period(FB, "2 day", start_date = "2013-01-01")

#### Equivalent method using an index vector

# FB stock prices
data(FB)
FB &lt;- as_tbl_time(FB, date)

custom_period &lt;- create_series(
  time_formula = dplyr::first(FB$date) - 1 ~ dplyr::last(FB$date),
  period       = "2 day",
  class        = "Date",
  as_vector    = TRUE)

FB %&gt;%
  as_tbl_time(date) %&gt;%
  as_period(period = custom_period)

# Manually calculating returns at different periods -------------------------

data(FB)

# Annual Returns
# Convert to end of year periodicity, but include the endpoints to use as
# a reference for the first return calculation. Then calculate returns.
FB %&gt;%
  as_tbl_time(date) %&gt;%
  as_period("1 y", side = "end", include_endpoints = TRUE) %&gt;%
  dplyr::mutate(yearly_return = adjusted / dplyr::lag(adjusted) - 1)

</code></pre>

<hr>
<h2 id='as_tbl_time'>Create <code>tbl_time</code> objects</h2><span id='topic+as_tbl_time'></span><span id='topic+tbl_time'></span>

<h3>Description</h3>

<p><code>tbl_time</code> objects have a time index that contains information about
which column should be used for time-based subsetting and other time-based
manipulation. Otherwise, they function as normal tibbles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tbl_time(x, index = NULL, ...)

tbl_time(x, index = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tbl_time_+3A_x">x</code></td>
<td>
<p>An object to be converted to <code>tbl_time</code>. This is generally
a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>, or an object that can first be coerced to a <code>tibble</code>.</p>
</td></tr>
<tr><td><code id="as_tbl_time_+3A_index">index</code></td>
<td>
<p>The bare column name of the column to be used as the index.</p>
</td></tr>
<tr><td><code id="as_tbl_time_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code> if coercion is
necessary first.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information stored about <code>tbl_time</code> objects are the <code>index_quo</code> and the
<code>index_time_zone</code>. These are stored as attributes, with the <code>index_quo</code> as a
<code><a href="rlang.html#topic+quosure-tools">rlang::quosure()</a></code> and the <code>time_zone</code> as a string.
</p>
<p>Currently, <code>Date</code> and <code>POSIXct</code> classes are fully supported. <code>yearmon</code>,
<code>yearqtr</code>, and <code>hms</code> have experimental support. Due to dplyr's
handling of S3 classes like these 3, the classes are lost when you
manipulate the index columns directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Converting a data.frame to a `tbl_time`
# Using Date index
ex1 &lt;- data.frame(date = Sys.Date(), value = 1)
ex1_tbl_time &lt;- as_tbl_time(ex1, date)
class(ex1_tbl_time)
attributes(ex1_tbl_time)

# Converting a tibble to a `tbl_time`
# Using POSIXct index
ex2 &lt;- tibble::tibble(
  time  = as.POSIXct(c("2017-01-01 10:12:01", "2017-01-02 12:12:01")),
  value = c(1, 2)
)
as_tbl_time(ex2, time)

</code></pre>

<hr>
<h2 id='ceiling_index'>A simple wrapper of <code><a href="lubridate.html#topic+round_date">lubridate::ceiling_date()</a></code></h2><span id='topic+ceiling_index'></span>

<h3>Description</h3>

<p>This is a thin wrapper around a <code><a href="lubridate.html#topic+round_date">lubridate::ceiling_date()</a></code> that works
for <code>hms</code>, <code>yearmon</code>, and <code>yearqtr</code> classes as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceiling_index(x, unit = "seconds")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ceiling_index_+3A_x">x</code></td>
<td>
<p>a vector of date-time objects</p>
</td></tr>
<tr><td><code id="ceiling_index_+3A_unit">unit</code></td>
<td>
<p>a string, <code>Period</code> object or a date-time object. When a singleton string,
it specifies a time unit or a multiple of a unit to be rounded to. Valid base units
are <code>second</code>, <code>minute</code>, <code>hour</code>, <code>day</code>, <code>week</code>, <code>month</code>, <code>bimonth</code>, <code>quarter</code>,
<code>season</code>, <code>halfyear</code> and <code>year</code>. Arbitrary unique English abbreviations as in the
<code><a href="lubridate.html#topic+period">period()</a></code> constructor are allowed. Rounding to multiples of units (except weeks)
is supported.
</p>
<p>When <code>unit</code> is a <code>Period</code> object, it is first converted to a string representation
which might not be in the same units as the constructor. For example <code>weeks(1)</code> is
converted to &quot;7d 0H 0M 0S&quot;. Thus, always check the string representation of the
period before passing to this function.
</p>
<p>When <code>unit</code> is a date-time object rounding is done to the nearest of the
elements in <code>unit</code>. If range of <code>unit</code> vector does not cover the range of
<code>x</code> <code>ceiling_date()</code> and <code>floor_date()</code> round to the <code>max(x)</code> and <code>min(x)</code>
for elements that fall outside of <code>range(unit)</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="lubridate.html#topic+round_date">lubridate::ceiling_date()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FB)
dplyr::mutate(FB, date2 = ceiling_index(date, "year"))

time_test &lt;- create_series('00:00:00'~'12:00:00',
                           '1 minute', class = "hms")

dplyr::mutate(time_test, date2 = ceiling_index(date, "hour"))

</code></pre>

<hr>
<h2 id='collapse_by'>Collapse a tbl_time object by its index</h2><span id='topic+collapse_by'></span>

<h3>Description</h3>

<p>Collapse the index of a <code>tbl_time</code> object by time period. The index column
is altered so that all dates that fall in a specified interval share a
common date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_by(
  .tbl_time,
  period = "year",
  start_date = NULL,
  side = "end",
  clean = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_by_+3A_.tbl_time">.tbl_time</code></td>
<td>
<p>A <code>tbl_time</code> object.</p>
</td></tr>
<tr><td><code id="collapse_by_+3A_period">period</code></td>
<td>
<p>A character specification used for time-based grouping. The
general format to use is <code>"frequency period"</code> where frequency is a number
like 1 or 2, and period is an interval like weekly or yearly. There must be
a space between the two.
</p>
<p>Note that you can pass the specification in a flexible way:
</p>

<ul>
<li><p> 1 Year: <code>'1 year'</code> / <code>'1 Y'</code>
</p>
</li></ul>

<p>This shorthand is available for year, quarter, month, day, hour, minute,
second, millisecond and microsecond periodicities.
</p>
<p>Additionally, you have the option of passing in a vector of dates to
use as custom and more flexible boundaries.</p>
</td></tr>
<tr><td><code id="collapse_by_+3A_start_date">start_date</code></td>
<td>
<p>Optional argument used to
specify the start date for the
first group. The default is to start at the closest period boundary
below the minimum date in the supplied index.</p>
</td></tr>
<tr><td><code id="collapse_by_+3A_side">side</code></td>
<td>
<p>Whether to return the date at the beginning or the end of
the new period. By default, the &quot;end&quot; of the period.
Use &quot;start&quot; to change to the start of the period.</p>
</td></tr>
<tr><td><code id="collapse_by_+3A_clean">clean</code></td>
<td>
<p>Whether or not to round the collapsed index up / down to the next
period boundary. The decision to round up / down is controlled by the side
argument.</p>
</td></tr>
<tr><td><code id="collapse_by_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>collapse_by()</code> is a simplification of a call to <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> to collapse an
index column using <code><a href="#topic+collapse_index">collapse_index()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic functionality -------------------------------------------------------

# Facebook stock prices
data(FB)
FB &lt;- as_tbl_time(FB, date)

# Collapse to weekly dates
collapse_by(FB, "weekly")

# A common workflow is to group on the collapsed date column
# to perform a time based summary
FB %&gt;%
  collapse_by("year") %&gt;%
  dplyr::group_by(date) %&gt;%
  dplyr::summarise_if(is.numeric, mean)

# Grouped functionality -----------------------------------------------------

data(FANG)
FANG &lt;- FANG %&gt;%
  as_tbl_time(date) %&gt;%
  dplyr::group_by(symbol)

# Collapse each group to monthly,
# calculate monthly standard deviation for each column
FANG %&gt;%
  collapse_by("month") %&gt;%
  dplyr::group_by(symbol, date) %&gt;%
  dplyr::summarise_all(sd)

</code></pre>

<hr>
<h2 id='collapse_index'>Collapse an index vector so that all observations in an interval share the
same date</h2><span id='topic+collapse_index'></span>

<h3>Description</h3>

<p>When <code>collapse_index()</code> is used, the index vector is altered
so that all dates that fall in a specified interval share a common date.
The most common use case for this is to then group on the collapsed index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_index(
  index,
  period = "year",
  start_date = NULL,
  side = "end",
  clean = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_index_+3A_index">index</code></td>
<td>
<p>An index vector.</p>
</td></tr>
<tr><td><code id="collapse_index_+3A_period">period</code></td>
<td>
<p>A character specification used for time-based grouping. The
general format to use is <code>"frequency period"</code> where frequency is a number
like 1 or 2, and period is an interval like weekly or yearly. There must be
a space between the two.
</p>
<p>Note that you can pass the specification in a flexible way:
</p>

<ul>
<li><p> 1 Year: <code>'1 year'</code> / <code>'1 Y'</code>
</p>
</li></ul>

<p>This shorthand is available for year, quarter, month, day, hour, minute,
second, millisecond and microsecond periodicities.
</p>
<p>Additionally, you have the option of passing in a vector of dates to
use as custom and more flexible boundaries.</p>
</td></tr>
<tr><td><code id="collapse_index_+3A_start_date">start_date</code></td>
<td>
<p>Optional argument used to
specify the start date for the
first group. The default is to start at the closest period boundary
below the minimum date in the supplied index.</p>
</td></tr>
<tr><td><code id="collapse_index_+3A_side">side</code></td>
<td>
<p>Whether to return the date at the beginning or the end of
the new period. By default, the &quot;end&quot; of the period.
Use &quot;start&quot; to change to the start of the period.</p>
</td></tr>
<tr><td><code id="collapse_index_+3A_clean">clean</code></td>
<td>
<p>Whether or not to round the collapsed index up / down to the next
period boundary. The decision to round up / down is controlled by the side
argument.</p>
</td></tr>
<tr><td><code id="collapse_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+collapse_by">collapse_by()</a></code> function provides a shortcut for the most common use
of <code>collapse_index()</code>, calling the function inside a call to <code>mutate()</code> to
modify the index directly. For more flexibility, like the nesting example
below, use <code>collapse_index()</code>.
</p>
<p>Because this is often used for end of period summaries, the default is to
use <code>side = "end"</code>. Note that this is the opposite of <code><a href="#topic+as_period">as_period()</a></code> where
the default is <code>side = "start"</code>.
</p>
<p>The <code>clean</code> argument is especially useful if you have an irregular series
and want cleaner dates to report for summary values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic functionality -------------------------------------------------------

# Facebook stock prices
data(FB)
FB &lt;- as_tbl_time(FB, date)

# Collapse to weekly dates
dplyr::mutate(FB, date = collapse_index(date, "weekly"))

# A common workflow is to group on the new date column
# to perform a time based summary
FB %&gt;%
  dplyr::mutate(date = collapse_index(date, "year")) %&gt;%
  dplyr::group_by(date) %&gt;%
  dplyr::summarise_if(is.numeric, mean)

# You can also assign the result to a separate column and use that
# to nest on, allowing for 'period nests' that keep the
# original dates in the nested tibbles.
FB %&gt;%
  dplyr::mutate(nest_date = collapse_index(date, "2 year")) %&gt;%
  dplyr::group_by(nest_date) %&gt;%
  tidyr::nest()

# Grouped functionality -----------------------------------------------------

data(FANG)
FANG &lt;- FANG %&gt;%
  as_tbl_time(date) %&gt;%
  dplyr::group_by(symbol)

# Collapse each group to monthly,
# calculate monthly standard deviation for each column
FANG %&gt;%
  dplyr::mutate(date = collapse_index(date, "month")) %&gt;%
  dplyr::group_by(symbol, date) %&gt;%
  dplyr::summarise_all(sd)


</code></pre>

<hr>
<h2 id='create_series'>Create a <code>tbl_time</code> object with a sequence of regularly spaced dates</h2><span id='topic+create_series'></span>

<h3>Description</h3>

<p><code><a href="#topic+create_series">create_series()</a></code> allows the user to quickly create a <code>tbl_time</code> object with
a <code>date</code> column populated with a sequence of dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_series(
  time_formula,
  period = "day",
  class = "POSIXct",
  include_end = FALSE,
  tz = "UTC",
  as_vector = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_series_+3A_time_formula">time_formula</code></td>
<td>
<p>A period to create the series over.
This is specified as a formula.
See the <code>Details</code> section of <code><a href="#topic+filter_time">filter_time()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="create_series_+3A_period">period</code></td>
<td>
<p>A character specification used for time-based grouping. The
general format to use is <code>"frequency period"</code> where frequency is a number
like 1 or 2, and period is an interval like weekly or yearly. There must be
a space between the two.
</p>
<p>Note that you can pass the specification in a flexible way:
</p>

<ul>
<li><p> 1 Year: <code>'1 year'</code> / <code>'1 Y'</code>
</p>
</li></ul>

<p>This shorthand is available for year, quarter, month, day, hour, minute,
second, millisecond and microsecond periodicities.
</p>
<p>Additionally, you have the option of passing in a vector of dates to
use as custom and more flexible boundaries.</p>
</td></tr>
<tr><td><code id="create_series_+3A_class">class</code></td>
<td>
<p>One of <code>"Date"</code>, <code>"POSIXct"</code>, <code>"hms"</code>, <code>"yearmon"</code>, <code>"yearqtr"</code>.
The default is <code>"POSIXct"</code>.</p>
</td></tr>
<tr><td><code id="create_series_+3A_include_end">include_end</code></td>
<td>
<p>Whether to always include the RHS of the <code>time_formula</code>
even if it does not match the regularly spaced index.</p>
</td></tr>
<tr><td><code id="create_series_+3A_tz">tz</code></td>
<td>
<p>Time zone of the new series.</p>
</td></tr>
<tr><td><code id="create_series_+3A_as_vector">as_vector</code></td>
<td>
<p>Should the series be returned as a vector instead of
a tibble?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Every day in 2013
create_series(~'2013', 'day')

# Every other day in 2013
create_series(~'2013', '2 d')

# Every quarter in 2013
create_series(~'2013', '1 q')

# Daily series for 2013-2015
create_series('2013' ~ '2015', '1 d')

# Minute series for 2 months
create_series('2012-01' ~ '2012-02', 'M')

# Second series for 2 minutes
create_series('2011-01-01 12:10:00' ~ '2011-01-01 12:12:00', 's')

# Date class
create_series(~'2013', 'day', class = "Date")

# yearmon class
create_series(~'2013', 'month', class = "yearmon")

# hms class. time_formula specified as HH:MM:SS here
create_series('00:00:00' ~ '12:00:00', 'second' , class = "hms")

# Subsecond series
create_series('2013' ~ '2013-01-01 00:00:01', period = "10 millisec")
milli &lt;- create_series('2013' ~ '2013-01-01 00:00:01', period = ".1 sec")
# Check that 'milli' is correct by running:
# options("digits.secs" = 4)
# options("digits" = 18)
# milli$date
# as.numeric(milli$date)


</code></pre>

<hr>
<h2 id='FANG'>Stock prices for Facebook, Amazon, Netflix and Google from 2013-2016</h2><span id='topic+FANG'></span>

<h3>Description</h3>

<p>A dataset containing the date, open, high, low, close, volume, and adjusted
stock prices for Facebook, Amazon, Netflix and Google from 2013-2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FANG
</code></pre>


<h3>Format</h3>

<p>A tibble with 4,032 rows and 8 variables:
</p>

<dl>
<dt>symbol</dt><dd><p>stock ticker symbol</p>
</dd>
<dt>date</dt><dd><p>trade date</p>
</dd>
<dt>open</dt><dd><p>stock price at the open of trading, in USD</p>
</dd>
<dt>high</dt><dd><p>stock price at the highest point during trading, in USD</p>
</dd>
<dt>low</dt><dd><p>stock price at the lowest point during trading, in USD</p>
</dd>
<dt>close</dt><dd><p>stock price at the close of trading, in USD</p>
</dd>
<dt>volume</dt><dd><p>number of shares traded</p>
</dd>
<dt>adjusted</dt><dd><p>stock price at the close of trading adjusted for stock splits, in USD</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.investopedia.com/terms/f/fang-stocks-fb-amzn.asp">https://www.investopedia.com/terms/f/fang-stocks-fb-amzn.asp</a>
</p>

<hr>
<h2 id='FB'>Stock prices for Facebook from 2013-2016</h2><span id='topic+FB'></span>

<h3>Description</h3>

<p>A dataset containing the date, open, high, low, close, volume, and adjusted
stock prices for Facebook from 2013-2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FB
</code></pre>


<h3>Format</h3>

<p>A tibble with 1,008 rows and 8 variables:
</p>

<dl>
<dt>symbol</dt><dd><p>stock ticker symbol</p>
</dd>
<dt>date</dt><dd><p>trade date</p>
</dd>
<dt>open</dt><dd><p>stock price at the open of trading, in USD</p>
</dd>
<dt>high</dt><dd><p>stock price at the highest point during trading, in USD</p>
</dd>
<dt>low</dt><dd><p>stock price at the lowest point during trading, in USD</p>
</dd>
<dt>close</dt><dd><p>stock price at the close of trading, in USD</p>
</dd>
<dt>volume</dt><dd><p>number of shares traded</p>
</dd>
<dt>adjusted</dt><dd><p>stock price at the close of trading adjusted for stock splits, in USD</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.investopedia.com/terms/f/fang-stocks-fb-amzn.asp">https://www.investopedia.com/terms/f/fang-stocks-fb-amzn.asp</a>
</p>

<hr>
<h2 id='filter_time'>Succinctly filter a <code>tbl_time</code> object by its index</h2><span id='topic+filter_time'></span><span id='topic++5B.tbl_time'></span>

<h3>Description</h3>

<p>Use a concise filtering method to filter a <code>tbl_time</code> object by its <code>index</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_time(.tbl_time, time_formula)

## S3 method for class 'tbl_time'
x[i, j, drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_time_+3A_.tbl_time">.tbl_time</code></td>
<td>
<p>A <code>tbl_time</code> object.</p>
</td></tr>
<tr><td><code id="filter_time_+3A_time_formula">time_formula</code></td>
<td>
<p>A period to filter over.
This is specified as a <code>formula</code>. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="filter_time_+3A_x">x</code></td>
<td>
<p>Same as <code>.tbl_time</code> but consistent naming with base R.</p>
</td></tr>
<tr><td><code id="filter_time_+3A_i">i</code></td>
<td>
<p>A period to filter over. This is specified the same as
<code>time_formula</code> or can use the traditional row extraction method.</p>
</td></tr>
<tr><td><code id="filter_time_+3A_j">j</code></td>
<td>
<p>Optional argument to also specify column index to subset. Works
exactly like the normal extraction operator.</p>
</td></tr>
<tr><td><code id="filter_time_+3A_drop">drop</code></td>
<td>
<p>Will always be coerced to <code>FALSE</code> by <code>tibble</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>time_formula</code> is specified using the format <code>from ~ to</code>.
Each side of the <code>time_formula</code> is specified as the character
<code>'YYYY-MM-DD HH:MM:SS'</code>, but powerful shorthand is available.
Some examples are:
</p>

<ul>
<li> <p><strong>Year:</strong> <code>'2013' ~ '2015'</code>
</p>
</li>
<li> <p><strong>Month:</strong> <code>'2013-01' ~ '2016-06'</code>
</p>
</li>
<li> <p><strong>Day:</strong> <code>'2013-01-05' ~ '2016-06-04'</code>
</p>
</li>
<li> <p><strong>Second:</strong> <code>'2013-01-05 10:22:15' ~ '2018-06-03 12:14:22'</code>
</p>
</li>
<li> <p><strong>Variations:</strong> <code>'2013' ~ '2016-06'</code>
</p>
</li></ul>

<p>The <code>time_formula</code> can also use a one sided formula.
</p>

<ul>
<li> <p><strong>Only dates in 2015:</strong> <code>~'2015'</code>
</p>
</li>
<li> <p><strong>Only dates March 2015:</strong> <code>~'2015-03'</code>
</p>
</li></ul>

<p>The <code>time_formula</code> can also use <code>'start'</code> and <code>'end'</code> as keywords for
your filter.
</p>

<ul>
<li> <p><strong>Start of the series to end of 2015:</strong> <code>'start' ~ '2015'</code>
</p>
</li>
<li> <p><strong>Start of 2014 to end of series:</strong> <code>'2014' ~ 'end'</code>
</p>
</li></ul>

<p>All shorthand dates are expanded:
</p>

<ul>
<li><p> The <code>from</code> side is expanded to be the first date in that period
</p>
</li>
<li><p> The <code>to</code> side is expanded to be the last date in that period
</p>
</li></ul>

<p>This means that the following examples are equivalent (assuming your
index is a POSIXct):
</p>

<ul>
<li> <p><code>'2015' ~ '2016' == '2015-01-01 + 00:00:00' ~ '2016-12-31 + 23:59:59'</code>
</p>
</li>
<li> <p><code>~'2015' == '2015-01-01 + 00:00:00' ~ '2015-12-31 + 23:59:59'</code>
</p>
</li>
<li> <p><code>'2015-01-04 + 10:12' ~ '2015-01-05' == '2015-01-04 + 10:12:00' ~ '2015-01-05 + 23:59:59'</code>
</p>
</li></ul>

<p>Special parsing is done for indices of class <code>hms</code>. The <code>from ~ to</code> time
formula is specified as only <code>HH:MM:SS</code>.
</p>

<ul>
<li> <p><strong>Start to 5th second of the 12th hour:</strong> <code>'start' ~ '12:00:05'</code>
</p>
</li>
<li> <p><strong>Every second in the 12th hour:</strong> <code>~'12'</code>
</p>
</li></ul>

<p>Subsecond resolution is also supported, however, R has a unique way of
handling and printing subsecond dates and the user should be comfortable with
this already. Specify subsecond resolution like so:
<code>'2013-01-01 00:00:00.1' ~ '2013-01-01 00:00:00.2'</code>. Note that one sided
expansion does not work with subsecond resolution due to seconds and subseconds
being grouped together into 1 number (i.e. 1.2 seconds). This means <code>~'2013-01-01 00:00:00'</code> does
not expand to something like <code>'2013-01-01 00:00:00.00' ~ '2013-01-01 00:00:00.99'</code>,
but only expands to include whole seconds.
</p>
<p>This function respects <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# FANG contains Facebook, Amazon, Netflix and Google stock prices
data(FANG)
FANG &lt;- as_tbl_time(FANG, date) %&gt;%
  dplyr::group_by(symbol)

# 2013-01-01 to 2014-12-31
filter_time(FANG, '2013' ~ '2014')

# 2013-05-25 to 2014-06-04
filter_time(FANG, '2013-05-25' ~ '2014-06-04')

# Using the `[` subset operator
FANG['2014'~'2015']

# Using `[` and one sided formula for only dates in 2014
FANG[~'2014']

# Using `[` and column selection
FANG['2013'~'2016', c("date", "adjusted")]

# Variables are unquoted using rlang
lhs_date &lt;- "2013"
rhs_date &lt;- as.Date("2014-01-01")
filter_time(FANG, lhs_date ~ rhs_date)

# Use the keywords 'start' and 'end' to conveniently access ends
filter_time(FANG, 'start' ~ '2014')

# hms (hour, minute, second) classes have special parsing
hms_example &lt;- create_series(~'12:01', 'second', class = 'hms')
filter_time(hms_example, 'start' ~ '12:01:30')


</code></pre>

<hr>
<h2 id='floor_index'>A simple wrapper of <code><a href="lubridate.html#topic+round_date">lubridate::floor_date()</a></code></h2><span id='topic+floor_index'></span>

<h3>Description</h3>

<p>This is a thin wrapper around a <code><a href="lubridate.html#topic+round_date">lubridate::floor_date()</a></code> that works
for <code>hms</code>, <code>yearmon</code>, and <code>yearqtr</code> classes as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>floor_index(x, unit = "seconds")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="floor_index_+3A_x">x</code></td>
<td>
<p>a vector of date-time objects</p>
</td></tr>
<tr><td><code id="floor_index_+3A_unit">unit</code></td>
<td>
<p>a string, <code>Period</code> object or a date-time object. When a singleton string,
it specifies a time unit or a multiple of a unit to be rounded to. Valid base units
are <code>second</code>, <code>minute</code>, <code>hour</code>, <code>day</code>, <code>week</code>, <code>month</code>, <code>bimonth</code>, <code>quarter</code>,
<code>season</code>, <code>halfyear</code> and <code>year</code>. Arbitrary unique English abbreviations as in the
<code><a href="lubridate.html#topic+period">period()</a></code> constructor are allowed. Rounding to multiples of units (except weeks)
is supported.
</p>
<p>When <code>unit</code> is a <code>Period</code> object, it is first converted to a string representation
which might not be in the same units as the constructor. For example <code>weeks(1)</code> is
converted to &quot;7d 0H 0M 0S&quot;. Thus, always check the string representation of the
period before passing to this function.
</p>
<p>When <code>unit</code> is a date-time object rounding is done to the nearest of the
elements in <code>unit</code>. If range of <code>unit</code> vector does not cover the range of
<code>x</code> <code>ceiling_date()</code> and <code>floor_date()</code> round to the <code>max(x)</code> and <code>min(x)</code>
for elements that fall outside of <code>range(unit)</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="lubridate.html#topic+round_date">lubridate::floor_date()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FB)
dplyr::mutate(FB, date2 = floor_index(date, "year"))

time_test &lt;- create_series('00:00:00'~'12:00:00',
                           '1 minute', class = "hms")

dplyr::mutate(time_test, date2 = floor_index(date, "hour"))

</code></pre>

<hr>
<h2 id='getters'>Getters</h2><span id='topic+getters'></span><span id='topic+get_index_quo'></span><span id='topic+get_index_char'></span><span id='topic+get_index_col'></span><span id='topic+get_index_time_zone'></span><span id='topic+get_index_class'></span>

<h3>Description</h3>

<p>Accessors to attributes of <code>tbl_time</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_index_quo(.tbl_time)

get_index_char(.tbl_time)

get_index_col(.tbl_time)

get_index_time_zone(.tbl_time)

get_index_class(.tbl_time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getters_+3A_.tbl_time">.tbl_time</code></td>
<td>
<p>A <code>tbl_time</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='new_tbl_time'>Create a new tbl_time object</h2><span id='topic+new_tbl_time'></span>

<h3>Description</h3>

<p>Often used internally by developers extending tibbletime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_tbl_time(x, index_quo, index_time_zone, ..., subclass = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_tbl_time_+3A_x">x</code></td>
<td>
<p>A tibble or data.frame</p>
</td></tr>
<tr><td><code id="new_tbl_time_+3A_index_quo">index_quo</code></td>
<td>
<p>The quo that references the index column</p>
</td></tr>
<tr><td><code id="new_tbl_time_+3A_index_time_zone">index_time_zone</code></td>
<td>
<p>The index time zone</p>
</td></tr>
<tr><td><code id="new_tbl_time_+3A_...">...</code></td>
<td>
<p>Other attributes passed through to new_tibble()</p>
</td></tr>
<tr><td><code id="new_tbl_time_+3A_subclass">subclass</code></td>
<td>
<p>A subclass to have as a child</p>
</td></tr>
</table>

<hr>
<h2 id='parse_period'>Parse a character period specification</h2><span id='topic+parse_period'></span>

<h3>Description</h3>

<p>The period is parsed into frequency and period and returned as a named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_period(period)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_period_+3A_period">period</code></td>
<td>
<p>A character specification used for time-based grouping. The
general format to use is <code>"frequency period"</code> where frequency is a number
like 1 or 2, and period is an interval like weekly or yearly. There must be
a space between the two.
</p>
<p>Note that you can pass the specification in a flexible way:
</p>

<ul>
<li><p> 1 Year: <code>'1 year'</code> / <code>'1 Y'</code>
</p>
</li></ul>

<p>This shorthand is available for year, quarter, month, day, hour, minute,
second, millisecond and microsecond periodicities.
</p>
<p>Additionally, you have the option of passing in a vector of dates to
use as custom and more flexible boundaries.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
parse_period('2 day')

</code></pre>

<hr>
<h2 id='partition_index'>Partition an index vector into an integer vector representing groups</h2><span id='topic+partition_index'></span>

<h3>Description</h3>

<p><code><a href="#topic+partition_index">partition_index()</a></code> takes an index vector and returns an integer vector that
can be used for grouping by periods. This is the workhorse for many other
<code>tibbletime</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_index(index, period = "year", start_date = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partition_index_+3A_index">index</code></td>
<td>
<p>A vector of date indices to create groups for.</p>
</td></tr>
<tr><td><code id="partition_index_+3A_period">period</code></td>
<td>
<p>A character specification used for time-based grouping. The
general format to use is <code>"frequency period"</code> where frequency is a number
like 1 or 2, and period is an interval like weekly or yearly. There must be
a space between the two.
</p>
<p>Note that you can pass the specification in a flexible way:
</p>

<ul>
<li><p> 1 Year: <code>'1 year'</code> / <code>'1 Y'</code>
</p>
</li></ul>

<p>This shorthand is available for year, quarter, month, day, hour, minute,
second, millisecond and microsecond periodicities.
</p>
<p>Additionally, you have the option of passing in a vector of dates to
use as custom and more flexible boundaries.</p>
</td></tr>
<tr><td><code id="partition_index_+3A_start_date">start_date</code></td>
<td>
<p>Optional argument used to
specify the start date for the
first group. The default is to start at the closest period boundary
below the minimum date in the supplied index.</p>
</td></tr>
<tr><td><code id="partition_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally, but may provide the user extra flexibility
in some cases.
</p>
<p>Grouping can only be done on the minimum periodicity of the index and above.
This means that a daily series cannot be grouped by minute. An hourly series
cannot be grouped by 5 seconds, and so on. If the user attempts this,
an error will be thrown.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_period">as_period()</a></code>, <code><a href="#topic+collapse_index">collapse_index()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FB)

partition_index(FB$date, '2 year')

dplyr::mutate(FB, partition_index = partition_index(date, '2 day'))

</code></pre>

<hr>
<h2 id='posixct_numeric_to_datetime'>Converting a posixct numeric time back to a classed datetime</h2><span id='topic+posixct_numeric_to_datetime'></span>

<h3>Description</h3>

<p>Converting a posixct numeric time back to a classed datetime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posixct_numeric_to_datetime(x, class = "POSIXct", ..., tz = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posixct_numeric_to_datetime_+3A_x">x</code></td>
<td>
<p>A posixct numeric vector</p>
</td></tr>
<tr><td><code id="posixct_numeric_to_datetime_+3A_class">class</code></td>
<td>
<p>The class to convert to</p>
</td></tr>
<tr><td><code id="posixct_numeric_to_datetime_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on the the specific coercion function</p>
</td></tr>
<tr><td><code id="posixct_numeric_to_datetime_+3A_tz">tz</code></td>
<td>
<p>The time zone to convert to. The default UTC is used if none is
supplied</p>
</td></tr>
</table>

<hr>
<h2 id='reconstruct'>Reconstruct an S3 class from a template</h2><span id='topic+reconstruct'></span>

<h3>Description</h3>

<p>This is an implementation of <code>sloop::reconstruct()</code> that users can
ignore. Once <code>sloop</code> is on CRAN, this function will be removed and that
version will be used. It currently must be exported for use in <code>tidyquant</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct(new, old)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstruct_+3A_new">new</code></td>
<td>
<p>Freshly created object</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_old">old</code></td>
<td>
<p>Existing object to use as template</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rollify'>Create a rolling version of any function</h2><span id='topic+rollify'></span>

<h3>Description</h3>

<p><code>rollify</code> returns a rolling version of the input function, with a
rolling <code>window</code> specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollify(.f, window = 1, unlist = TRUE, na_value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rollify_+3A_.f">.f</code></td>
<td>
<p>A function to modify, specified in one of the following ways:
</p>

<ul>
<li><p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li><p> An anonymous function, e.g. <code style="white-space: pre;">&#8288;\(x) x + 1&#8288;</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li><p> A formula, e.g. <code>~ .x + 1</code>. Only recommended if you require backward
compatibility with older versions of R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rollify_+3A_window">window</code></td>
<td>
<p>The window size to roll over</p>
</td></tr>
<tr><td><code id="rollify_+3A_unlist">unlist</code></td>
<td>
<p>If the function returns a single value each time it is called,
use <code>unlist = TRUE</code>. If the function returns more than one value, or a more
complicated object (like a linear model), use <code>unlist = FALSE</code> to create
a list-column of the rolling results.</p>
</td></tr>
<tr><td><code id="rollify_+3A_na_value">na_value</code></td>
<td>
<p>A default value for the <code>NA</code> values at the beginning of the
roll.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intended use of <code>rollify</code> is to turn a function into a rolling version
of itself for use inside of a call to <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, however it works
equally as well when called from <code><a href="purrr.html#topic+map">purrr::map()</a></code>.
</p>
<p>Because of it's intended use with <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code>rollify</code>
creates a function that always returns output with the same length of the
input, aligned right, and filled with <code>NA</code> unless otherwise specified
by <code>na_value</code>.
</p>
<p>The form of the <code>.f</code> argument is the same as the form that can be passed
to <code><a href="purrr.html#topic+map">purrr::map()</a></code>. Use <code>.x</code> or <code>.</code> to refer to the first object to roll over,
and <code>.y</code> to refer to the second object if required. The examples explain this
further.
</p>
<p>If optional arguments to the function are required, specify them in the
call to <code>rollify</code>, and not in the call to the rolling version of the
function. See the examples for more details.
</p>


<h3>See Also</h3>

<p><a href="purrr.html#topic+safely">purrr::safely</a>, <a href="purrr.html#topic+possibly">purrr::possibly</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Rolling mean --------------------------------------------------------------

data(FB)

# Turn the normal mean function into a rolling mean with a 5 row window
mean_roll_5 &lt;- rollify(mean, window = 5)

dplyr::mutate(FB,
       normal_mean  = mean(adjusted),
       rolling_mean = mean_roll_5(adjusted))

# There's nothing stopping you from combining multiple rolling functions with
# different window sizes in the same mutate call
mean_roll_10 &lt;- rollify(mean, window = 10)

dplyr::mutate(FB,
       rolling_mean_5  = mean_roll_5(adjusted),
       rolling_mean_10 = mean_roll_10(adjusted))

# Functions with multiple args and optional args ----------------------------

# With 2 args, use the purrr syntax of ~ and .x, .y
# Rolling correlation example
cor_roll &lt;- rollify(~cor(.x, .y), window = 5)

dplyr::mutate(FB, running_cor = cor_roll(adjusted, open))

# With &gt;2 args, create an anonymous function with &gt;2 args or use
# the purrr convention of ..1, ..2, ..3 to refer to the arguments
avg_of_avgs &lt;- rollify(function(x, y, z) {
                         (mean(x) + mean(y) + mean(z)) / 3
                       },
                       window = 10)

# Or
avg_of_avgs &lt;- rollify(~(mean(..1) + mean(..2) + mean(..3)) / 3,
                       window = 10)

dplyr::mutate(FB, avg_of_avgs = avg_of_avgs(open, high, low))

# Optional arguments MUST be passed at the creation of the rolling function
# Only data arguments that are "rolled over" are allowed when calling the
# rolling version of the function
FB$adjusted[1] &lt;- NA

roll_mean_na_rm &lt;- rollify(~mean(.x, na.rm = TRUE), window = 5)

dplyr::mutate(FB, roll_mean = roll_mean_na_rm(adjusted))

# Returning multiple values -------------------------------------------------

data(FB)

summary2 &lt;- function(x) {
  unclass(summary(x))
}

# If the function returns &gt;1 value, set the `unlist = FALSE` argument
# Running 5 number summary
summary_roll &lt;- rollify(summary2, window = 5, unlist = FALSE)

FB_summarised &lt;- dplyr::mutate(FB, summary_roll = summary_roll(adjusted))
FB_summarised$summary_roll[[5]]

# dplyr::bind_rows() is often helpful in these cases to get
# meaningful output

summary_roll &lt;- rollify(~dplyr::bind_rows(summary2(.)), window = 5, unlist = FALSE)
FB_summarised &lt;- dplyr::mutate(FB, summary_roll = summary_roll(adjusted))
FB_summarised %&gt;%
  dplyr::filter(!is.na(summary_roll)) %&gt;%
  tidyr::unnest(summary_roll)

# Rolling regressions -------------------------------------------------------

# Extending an example from R 4 Data Science on "Many Models".
# For each country in the gapminder data, calculate a linear regression
# every 5 periods of lifeExp ~ year
library(gapminder)

# Rolling regressions are easy to implement
lm_roll &lt;- rollify(~lm(.x ~ .y), window = 5, unlist = FALSE)

gapminder %&gt;%
  dplyr::group_by(country) %&gt;%
  dplyr::mutate(rolling_lm = lm_roll(lifeExp, year))

# Rolling with groups -------------------------------------------------------

# One of the most powerful things about this is that it works with
# groups since `mutate` is being used
data(FANG)
FANG &lt;- FANG %&gt;%
  dplyr::group_by(symbol)

mean_roll_3 &lt;- rollify(mean, window = 3)

FANG %&gt;%
  dplyr::mutate(mean_roll = mean_roll_3(adjusted)) %&gt;%
  dplyr::slice(1:5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
