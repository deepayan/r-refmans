<!DOCTYPE html><html><head><title>Help for package OutliersLearn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OutliersLearn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boxandwhiskers'><p>Box And Whiskers</p></a></li>
<li><a href='#DBSCAN_method'><p>DBSCAN_method</p></a></li>
<li><a href='#euclidean_distance'><p>euclidean_distance</p></a></li>
<li><a href='#knn'><p>knn</p></a></li>
<li><a href='#lof'><p>lof</p></a></li>
<li><a href='#mahalanobis_distance'><p>mahalanobis_distance</p></a></li>
<li><a href='#mahalanobis_method'><p>mahalanobis_method</p></a></li>
<li><a href='#manhattan_dist'><p>manhattan_dist</p></a></li>
<li><a href='#mean_outliersLearn'><p>mean_outliersLearn</p></a></li>
<li><a href='#quantile_outliersLearn'><p>quantile_outliersLearn</p></a></li>
<li><a href='#sd_outliersLearn'><p>sd_outliersLearn</p></a></li>
<li><a href='#transform_to_vector'><p>transform_to_vector</p></a></li>
<li><a href='#z_score_method'><p>z_score_method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Educational Outlier Package with Common Outlier Detection
Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Andres Missiego Manjon [aut, cre],
        Juan Jose Cuadrado Gallego [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andres Missiego Manjon &lt;andres.missiego@edu.uah.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides implementations of some of the most important outlier detection algorithms. 
    Includes a tutorial mode option that shows a description of each algorithm and provides 
    a step-by-step execution explanation of how it identifies outliers from the given data 
    with the specified input parameters. References include the works of Azzedine Boukerche, 
    Lining Zheng, and Omar Alfandi (2020) &lt;<a href="https://doi.org/10.1145%2F3381028">doi:10.1145/3381028</a>&gt;, Abir Smiti (2020) 
    &lt;<a href="https://doi.org/10.1016%2Fj.cosrev.2020.100306">doi:10.1016/j.cosrev.2020.100306</a>&gt;, and Xiaogang Su, Chih-Ling Tsai (2011) 
    &lt;<a href="https://doi.org/10.1002%2Fwidm.19">doi:10.1002/widm.19</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-05 08:13:41 UTC; missi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-05 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='boxandwhiskers'>Box And Whiskers</h2><span id='topic+boxandwhiskers'></span>

<h3>Description</h3>

<p>This function implements the box &amp; whiskers algorithm to detect outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxandwhiskers(data, d, tutorialMode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxandwhiskers_+3A_data">data</code></td>
<td>
<p>Input data.</p>
</td></tr>
<tr><td><code id="boxandwhiskers_+3A_d">d</code></td>
<td>
<p>Degree of outlier or distance at which an event is considered an outlier</p>
</td></tr>
<tr><td><code id="boxandwhiskers_+3A_tutorialmode">tutorialMode</code></td>
<td>
<p>if TRUE the tutorial mode is activated (the algorithm will include an explanation detailing the theory behind the outlier detection algorithm and a step by step explanation of how is the data processed to obtain the outliers following the theory mentioned earlier)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, does not return any value
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputData = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,
4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))))
inputData = data.frame(inputData)
boxandwhiskers(inputData,2,FALSE) # Can be set to TRUE

</code></pre>

<hr>
<h2 id='DBSCAN_method'>DBSCAN_method</h2><span id='topic+DBSCAN_method'></span>

<h3>Description</h3>

<p>Outlier detection method using DBSCAN
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBSCAN_method(inputData, max_distance_threshold, min_pts, tutorialMode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBSCAN_method_+3A_inputdata">inputData</code></td>
<td>
<p>Input Data (must be a data.frame)</p>
</td></tr>
<tr><td><code id="DBSCAN_method_+3A_max_distance_threshold">max_distance_threshold</code></td>
<td>
<p>This is used to calculate the distance between all the points and check if the euclidean distance is less than the max_distance_threshold parameter to decide if add it to the neighbors or not</p>
</td></tr>
<tr><td><code id="DBSCAN_method_+3A_min_pts">min_pts</code></td>
<td>
<p>the minimum number of points to form a dense region</p>
</td></tr>
<tr><td><code id="DBSCAN_method_+3A_tutorialmode">tutorialMode</code></td>
<td>
<p>if TRUE the tutorial mode is activated (the algorithm will include an explanation detailing the theory behind the outlier detection algorithm and a step by step explanation of how is the data processed to obtain the outliers following the theory mentioned earlier)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, does not return any value
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputData = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,
4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))));
inputData = data.frame(inputData);
eps = 4;
min_pts = 3;
DBSCAN_method(inputData, eps, min_pts, FALSE); #Can be set to TRUE

</code></pre>

<hr>
<h2 id='euclidean_distance'>euclidean_distance</h2><span id='topic+euclidean_distance'></span>

<h3>Description</h3>

<p>This function calculates the euclidean distance between 2 points. They must have the same number of dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean_distance(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidean_distance_+3A_p1">p1</code></td>
<td>
<p>One of the points that will be used by the algorithm with N dimensions</p>
</td></tr>
<tr><td><code id="euclidean_distance_+3A_p2">p2</code></td>
<td>
<p>The other point that will be used by the algorithm with N dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euclidean Distance calculated between the two N-dimensional points
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputData = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,
4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))));
inputData = data.frame(inputData);
point1 = inputData[1,];
point2 = inputData[4,];
distance = euclidean_distance(point1, point2);

</code></pre>

<hr>
<h2 id='knn'>knn</h2><span id='topic+knn'></span>

<h3>Description</h3>

<p>This function implements the knn algorithm for outlier detection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn(data, d, K, tutorialMode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_+3A_data">data</code></td>
<td>
<p>Input Data (must be a data.frame)</p>
</td></tr>
<tr><td><code id="knn_+3A_d">d</code></td>
<td>
<p>Degree of outlier or distance at which an event is considered an outlier</p>
</td></tr>
<tr><td><code id="knn_+3A_k">K</code></td>
<td>
<p>Nearest neighbor for which an event must have a degree of outlier to be considered an outlier</p>
</td></tr>
<tr><td><code id="knn_+3A_tutorialmode">tutorialMode</code></td>
<td>
<p>if TRUE the tutorial mode is activated (the algorithm will include an explanation detailing the theory behind the outlier detection algorithm and a step by step explanation of how is the data processed to obtain the outliers following the theory mentioned earlier)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, does not return any value
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputData = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,
4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))))
inputData = data.frame(inputData)
knn(inputData,3,2,FALSE) #Can be changed to TRUE

</code></pre>

<hr>
<h2 id='lof'>lof</h2><span id='topic+lof'></span>

<h3>Description</h3>

<p>Local Outlier Factor algorithm to detect outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lof(inputData, K, threshold, tutorialMode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lof_+3A_inputdata">inputData</code></td>
<td>
<p>Input Data (must be a data.frame)</p>
</td></tr>
<tr><td><code id="lof_+3A_k">K</code></td>
<td>
<p>This number represents the nearest neighbor to use to calculate the density of each point. This value is chosen arbitrarily and is responsibility of the data scientist/user to select a number adequate to the dataset.</p>
</td></tr>
<tr><td><code id="lof_+3A_threshold">threshold</code></td>
<td>
<p>Value that is used to classify the points comparing it to the calculated ARDs of the points in the dataset. If the ARD is smaller, the point is classified as an outliers. If not, the point is classified as a normal point (inlier)</p>
</td></tr>
<tr><td><code id="lof_+3A_tutorialmode">tutorialMode</code></td>
<td>
<p>if TRUE the tutorial mode is activated (the algorithm will include an explanation detailing the theory behind the outlier detection algorithm and a step by step explanation of how is the data processed to obtain the outliers following the theory mentioned earlier)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, does not return any value
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputData = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,
4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))));
inputData = data.frame(inputData);
lof(inputData,3,0.5,FALSE) #Can be changed to TRUE

</code></pre>

<hr>
<h2 id='mahalanobis_distance'>mahalanobis_distance</h2><span id='topic+mahalanobis_distance'></span>

<h3>Description</h3>

<p>Calculates the mahalanobis_distance given the input data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobis_distance(value, sample_mean, sample_covariance_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahalanobis_distance_+3A_value">value</code></td>
<td>
<p>Point to calculate the mahalanobis_distance</p>
</td></tr>
<tr><td><code id="mahalanobis_distance_+3A_sample_mean">sample_mean</code></td>
<td>
<p>Sample mean</p>
</td></tr>
<tr><td><code id="mahalanobis_distance_+3A_sample_covariance_matrix">sample_covariance_matrix</code></td>
<td>
<p>Sample Covariance Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mahalanobis distance associated to the point
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputData = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,
4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))));
inputData = data.frame(inputData);
inputData = as.matrix(inputData);
sampleMeans = c();
for(i in 1:ncol(inputData)){
  column = inputData[,i];
  calculatedMean = sum(column)/length(column);
  print(sprintf("Calculated mean for column %d: %f", i, calculatedMean))
  sampleMeans = c(sampleMeans, calculatedMean);
}
covariance_matrix = cov(inputData);
distance = mahalanobis_distance(inputData[3,], sampleMeans, covariance_matrix);

</code></pre>

<hr>
<h2 id='mahalanobis_method'>mahalanobis_method</h2><span id='topic+mahalanobis_method'></span>

<h3>Description</h3>

<p>Detect outliers using the Mahalanobis Distance method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobis_method(inputData, alpha, tutorialMode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahalanobis_method_+3A_inputdata">inputData</code></td>
<td>
<p>Input Data dataset that will be processed (with or not the step by step explanation) to obtain the underlying outliers. It must be a data.frame type.</p>
</td></tr>
<tr><td><code id="mahalanobis_method_+3A_alpha">alpha</code></td>
<td>
<p>Significance level alpha. This value indicates the proportion that it is expected to be outliers out of the dataset. It has to be in the range from 0 to 1</p>
</td></tr>
<tr><td><code id="mahalanobis_method_+3A_tutorialmode">tutorialMode</code></td>
<td>
<p>if TRUE the tutorial mode is activated (the algorithm will include an explanation detailing the theory behind the outlier detection algorithm and a step by step explanation of how is the data processed to obtain the outliers following the theory mentioned earlier)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, does not return any value
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputData = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,
4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))));
inputData = data.frame(inputData);
mahalanobis_method(inputData, 0.7, FALSE); #Can be set to TRUE

</code></pre>

<hr>
<h2 id='manhattan_dist'>manhattan_dist</h2><span id='topic+manhattan_dist'></span>

<h3>Description</h3>

<p>Calculates the manhattan distance between two 2D points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan_dist(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manhattan_dist_+3A_a">A</code></td>
<td>
<p>One of the 2D points</p>
</td></tr>
<tr><td><code id="manhattan_dist_+3A_b">B</code></td>
<td>
<p>The other 2D point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Manhattan distance calculated between point A and B
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance = manhattan_dist(c(1,2), c(3,4));

</code></pre>

<hr>
<h2 id='mean_outliersLearn'>mean_outliersLearn</h2><span id='topic+mean_outliersLearn'></span>

<h3>Description</h3>

<p>Calculates the mean of the given data vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_outliersLearn(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_outliersLearn_+3A_data">data</code></td>
<td>
<p>Input Data that will be processed to calculate the mean. It must be a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean of the input data
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean = mean_outliersLearn(c(2,3,2.3,7.8));

</code></pre>

<hr>
<h2 id='quantile_outliersLearn'>quantile_outliersLearn</h2><span id='topic+quantile_outliersLearn'></span>

<h3>Description</h3>

<p>Function that obtains the 'v' quantile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_outliersLearn(data, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_outliersLearn_+3A_data">data</code></td>
<td>
<p>Input Data</p>
</td></tr>
<tr><td><code id="quantile_outliersLearn_+3A_v">v</code></td>
<td>
<p>Goes from 0 to 1 (e.g. 0.25). Indicates the quantile that wants to be obtained</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quantile v calculated
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q = quantile_outliersLearn(c(12,2,3,4,1,13), 0.60)

</code></pre>

<hr>
<h2 id='sd_outliersLearn'>sd_outliersLearn</h2><span id='topic+sd_outliersLearn'></span>

<h3>Description</h3>

<p>Calculates the standard deviation of the input data given the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_outliersLearn(data, mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_outliersLearn_+3A_data">data</code></td>
<td>
<p>Input Data that will be used to calculate the standard deviation. Must be a vector</p>
</td></tr>
<tr><td><code id="sd_outliersLearn_+3A_mean">mean</code></td>
<td>
<p>Mean of the input data vector of the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard Deviation of the input data
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputData = c(1,2,3,4,5,6,1);
mean = sum(inputData)/length(inputData);
sd = sd_outliersLearn(inputData, mean);

</code></pre>

<hr>
<h2 id='transform_to_vector'>transform_to_vector</h2><span id='topic+transform_to_vector'></span>

<h3>Description</h3>

<p>Transform any type of data to a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_to_vector(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_to_vector_+3A_data">data</code></td>
<td>
<p>Input data that will be transformed into a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data formatted as a vector
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numeric_data = c(1, 2, 3)
character_data = c("a", "b", "c")
logical_data = c(TRUE, FALSE, TRUE)
factor_data = factor(c("A", "B", "A"))
integer_data = as.integer(c(1, 2, 3))
complex_data = complex(real = c(1, 2, 3), imaginary = c(4, 5, 6))
list_data = list(1, "apple", TRUE)
data_frame_data = data.frame(x = c(1, 2, 3), y = c("a", "b", "c"))

transformed_numeric = transform_to_vector(numeric_data)
transformed_character = transform_to_vector(character_data)
transformed_logical = transform_to_vector(logical_data)
transformed_factor = transform_to_vector(factor_data)
transformed_integer = transform_to_vector(integer_data)
transformed_complex = transform_to_vector(complex_data)
transformed_list = transform_to_vector(list_data)
transformed_data_frame = transform_to_vector(data_frame_data)

</code></pre>

<hr>
<h2 id='z_score_method'>z_score_method</h2><span id='topic+z_score_method'></span>

<h3>Description</h3>

<p>This function implements the outlier detection algorithm using standard deviation and mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_score_method(data, d, tutorialMode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z_score_method_+3A_data">data</code></td>
<td>
<p>Input Data that will be processed with or without the tutorial mode activated</p>
</td></tr>
<tr><td><code id="z_score_method_+3A_d">d</code></td>
<td>
<p>Degree of outlier or distance at which an event is considered an outlier</p>
</td></tr>
<tr><td><code id="z_score_method_+3A_tutorialmode">tutorialMode</code></td>
<td>
<p>if TRUE the tutorial mode is activated (the algorithm will include an explanation detailing the theory behind the outlier detection algorithm and a step by step explanation of how is the data processed to obtain the outliers following the theory mentioned earlier)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, does not return any value
</p>


<h3>Author(s)</h3>

<p>Andres Missiego Manjon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputData = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,
4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))))
inputData = data.frame(inputData)
z_score_method(inputData,2,FALSE) #Can be changed to TRUE

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
