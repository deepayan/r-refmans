<!DOCTYPE html><html lang="en"><head><title>Help for package epm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#epm'><p>EcoPhyloMapper (epm)</p></a></li>
<li><a href='#addLegend'><p>addLegend</p></a></li>
<li><a href='#addPhylo'><p>addPhylo</p></a></li>
<li><a href='#addTraits'><p>addTraits</p></a></li>
<li><a href='#betadiv_disparity'><p>Map change in morphological disparity</p></a></li>
<li><a href='#betadiv_phylogenetic'><p>Map phylogenetic turnover in species communities</p></a></li>
<li><a href='#betadiv_taxonomic'><p>Map turnover in species communities</p></a></li>
<li><a href='#calcMeanShape'><p>Calculate mean shape per grid cell</p></a></li>
<li><a href='#coordsFromEpmGrid'><p>Retrieve coordinates from epmGrid</p></a></li>
<li><a href='#createEPMgrid'><p>Create epmGrid object</p></a></li>
<li><a href='#customBetaDiv'><p>Custom beta diversity metrics</p></a></li>
<li><a href='#customGridMetric'><p>Custom grid metrics</p></a></li>
<li><a href='#dropSpecies'><p>Drop species from epmGrid</p></a></li>
<li><a href='#DRstat'><p>Calculate the DR statistic</p></a></li>
<li><a href='#epm-example'><p>Eco Phylo Mapper datasets</p></a></li>
<li><a href='#epmToPhyloComm'><p>Convert epmGrid to community matrix</p></a></li>
<li><a href='#expandSpeciesCellList'><p>Expand species list</p></a></li>
<li><a href='#extractFromEpmGrid'><p>Extract from epmGrid</p></a></li>
<li><a href='#faithPD'><p>Calculate Faith's Phylogenetic Diversity</p></a></li>
<li><a href='#generateOccurrenceMatrix'><p>Convert epmGrid to community matrix</p></a></li>
<li><a href='#getExtentOfList'><p>Get extent of list</p></a></li>
<li><a href='#getMultiMapRamp'><p>Extract min and max for multiple epmGrids</p></a></li>
<li><a href='#getSpPartialDisparities'><p>Partial Disparity</p></a></li>
<li><a href='#gridMetrics'><p>Grid Metrics</p></a></li>
<li><a href='#identify.epmGrid'><p>Interactively identify species in epmGrid</p></a></li>
<li><a href='#interactiveExtent'><p>Interactively choose extent</p></a></li>
<li><a href='#plot.epmGrid'><p>Plot epmGrid</p></a></li>
<li><a href='#plotDispersionField'><p>Plot dispersion fields</p></a></li>
<li><a href='#plotSpRange'><p>plot a single species' range</p></a></li>
<li><a href='#rasterToGrid'><p>Convert raster to sf grid</p></a></li>
<li><a href='#read.epmGrid'><p>Read a epmGrid object</p></a></li>
<li><a href='#reduceToCommonTaxa'><p>Subset epmGrid to shared taxa</p></a></li>
<li><a href='#singleSpCellIndex'><p>Identify single-species cells</p></a></li>
<li><a href='#spCountIndex'><p>Identify cells that have a certain number of taxa</p></a></li>
<li><a href='#summarizeEpmGridList'><p>Summarize lists of epmGrid objects</p></a></li>
<li><a href='#summary.epmGrid'><p>epmGrid summary</p></a></li>
<li><a href='#tableFromEpmGrid'><p>Data table from epmGrid</p></a></li>
<li><a href='#write.epmGrid'><p>Save epmGrid object</p></a></li>
<li><a href='#writeEpmSpatial'><p>Write epmGrid Spatial Object to Disk</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>EcoPhyloMapper</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>terra (&ge; 1.5-21), sf, ape, viridisLite, pbapply, methods,
Rcpp (&ge; 0.12.9), RcppProgress</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tmap, data.table, spdep, exactextractr</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates the aggregation of species' geographic ranges from vector or raster spatial data, and that enables the calculation of various morphological and phylogenetic community metrics across geography. Citation: Title, PO, DL Swiderski and ML Zelditch (2022) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13914">doi:10.1111/2041-210X.13914</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ptitle/epm">https://github.com/ptitle/epm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ptitle/epm/issues">https://github.com/ptitle/epm/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-14 18:27:27 UTC; pascaltitle</td>
</tr>
<tr>
<td>Author:</td>
<td>Pascal Title <a href="https://orcid.org/0000-0002-6316-0736"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Donald Swiderski [aut],
  Miriam Zelditch [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pascal Title &lt;pascal.title@stonybrook.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-14 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='epm'>EcoPhyloMapper (epm)</h2><span id='topic+epm-package'></span><span id='topic+epm'></span>

<h3>Description</h3>

<p>An R package that facilitates the aggregation of species'
geographic ranges from vector or raster spatial data, and that enables
the calculation of various morphological and phylogenetic metacommunity metrics
across geography.
</p>
<p>A detailed wiki for the R package can be found on the epm github page:
<a href="https://github.com/ptitle/epm/wiki#table-of-contents">https://github.com/ptitle/epm/wiki#table-of-contents</a>
</p>
<p>To cite the epm package in publications, please use: <br />
Pascal O. Title, Donald L. Swiderski and Miriam L. Zelditch. 2022. EcoPhyloMapper: 
an R package for integrating geographic ranges, phylogeny, and morphology. Methods 
in Ecology and Evolution. <a href="https://doi.org/10.1111/2041-210X.13914">doi:10.1111/2041-210X.13914</a>
</p>


<h3>Details</h3>

<p><strong>Creating and enhancing an epmGrid object</strong> <br />
Use <code><a href="#topic+createEPMgrid">createEPMgrid</a></code> to create an epmGrid object from species spatial data. <br />
Optionally, you can draw the spatial extent that you would like to use with <code><a href="#topic+interactiveExtent">interactiveExtent</a></code>.  <br />
Add in species attributes with <code><a href="#topic+addTraits">addTraits</a></code>, and/or a phylogeny with <code><a href="#topic+addPhylo">addPhylo</a></code>. <br />
Use the function <code><a href="#topic+reduceToCommonTaxa">reduceToCommonTaxa</a></code> to reduce the epmGrid object to species that are present for all data types. <br />
<br />
<strong>Calculating diversity metrics</strong> <br />
Calculate various diversity metrics with <code><a href="#topic+gridMetrics">gridMetrics</a></code>, or define your own, using <code><a href="#topic+customGridMetric">customGridMetric</a></code>. <br />
Calculate moving window turnover metrics with <code><a href="#topic+betadiv_taxonomic">betadiv_taxonomic</a></code>, <code><a href="#topic+betadiv_phylogenetic">betadiv_phylogenetic</a></code>, <code><a href="#topic+betadiv_disparity">betadiv_disparity</a></code>. You can also define your own beta diversity metric with <code><a href="#topic+customBetaDiv">customBetaDiv</a></code>. <br />
If you have a posterior set of trees, summarize phylogenetic uncertainty with <code><a href="#topic+summarizeEpmGridList">summarizeEpmGridList</a></code>. <br />
<br />
<strong>Plotting epmGrid objects</strong> <br />
Plot epmGrid object with <code><a href="#topic+plot.epmGrid">plot.epmGrid</a></code>. <br />
You get finer control over the legend with <code><a href="#topic+addLegend">addLegend</a></code>. <br />
The function <code><a href="#topic+getMultiMapRamp">getMultiMapRamp</a></code> will be helpful if you are trying to plot multiple epmGrid objects on the same color scale.  <br />
Use <code><a href="#topic+plotDispersionField">plotDispersionField</a></code> to plot the assemblage dispersion field for a given site. <br />
<br />
<strong>Getting derived data from epmGrid objects</strong> <br />
Use <code><a href="#topic+calcMeanShape">calcMeanShape</a></code> to get mean morphological shape per grid cell. <br />
Use <code><a href="#topic+coordsFromEpmGrid">coordsFromEpmGrid</a></code> to get the spatial coordinates of specific grid cells. <br />
Use <code><a href="#topic+extractFromEpmGrid">extractFromEpmGrid</a></code> to get the species that are found at certain coordinates or within a defined polygon. <br />
Use <code><a href="#topic+generateOccurrenceMatrix">generateOccurrenceMatrix</a></code> to produce a species-by-site presence/absence matrix. <br />
Use <code><a href="#topic+tableFromEpmGrid">tableFromEpmGrid</a></code> to pull data from epmGrids and rasters from a set of random points for statistical analysis.  <br />
<br />
<strong>Writing to disk</strong> <br />
You can save an epmGrid with <code><a href="#topic+write.epmGrid">write.epmGrid</a></code>, and read it back in with <code><a href="#topic+read.epmGrid">read.epmGrid</a></code>.  <br />
You can also write an epmGrid object to a spatial file format for use in GIS software with <code><a href="#topic+writeEpmSpatial">writeEpmSpatial</a></code>. <br />
</p>


<h3>Author(s)</h3>

<p>Pascal O. Title, Donald L. Swiderski, Miriam L. Zelditch
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ptitle/epm">https://github.com/ptitle/epm</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ptitle/epm/issues">https://github.com/ptitle/epm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addLegend'>addLegend</h2><span id='topic+addLegend'></span>

<h3>Description</h3>

<p>Adds a legend to an existing plot, with some additional manual
controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLegend(
  r,
  params = NULL,
  direction,
  side,
  location = "right",
  nTicks = 3,
  adj = NULL,
  shortFrac = 0.02,
  longFrac = 0.3,
  axisOffset = 0,
  border = TRUE,
  ramp,
  isInteger = "auto",
  ncolors = 64,
  breaks = NULL,
  minmax = NULL,
  locs = NULL,
  label = "",
  cex.axis = 0.8,
  tcl = NA,
  labelDist = 0.7,
  minDigits = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addLegend_+3A_r">r</code></td>
<td>
<p>the epmGrid, rasterLayer, SpatRaster or sf object that has been plotted</p>
</td></tr>
<tr><td><code id="addLegend_+3A_params">params</code></td>
<td>
<p>If an epmGrid plot was saved to a variable, provide that here.
Contents will override other arguments.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_direction">direction</code></td>
<td>
<p>direction of color ramp. If omitted, then direction is
automatically inferred, otherwise can be specified as <code>horizontal</code> or
<code>vertical</code>.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_side">side</code></td>
<td>
<p>side for tick marks, see <code><a href="graphics.html#topic+axis">axis</a></code> documentation.
Automatically inferred if omitted.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_location">location</code></td>
<td>
<p>either a location name (see <code>Details</code>), or coordinates
for the corners of the bar legend <code>c(xmin, xmax, ymin, ymax)</code>.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_nticks">nTicks</code></td>
<td>
<p>number of tick marks, besides min and max.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_adj">adj</code></td>
<td>
<p>if location is top, left, bottom or right, use this argument to
adjust the location of the legend, defined in percent of the figure width.
See Details for additional information.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_shortfrac">shortFrac</code></td>
<td>
<p>Percent of the plot width range that will be used as the
short dimension of the legend. Only applies to preset location options.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_longfrac">longFrac</code></td>
<td>
<p>Percent of the plot width range that will be used as the
long dimension of the legend. Only applies to preset location options.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_axisoffset">axisOffset</code></td>
<td>
<p>distance from color bar for labels, as a percent of the
plot width.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_border">border</code></td>
<td>
<p>logical, should the color legend have a black border</p>
</td></tr>
<tr><td><code id="addLegend_+3A_ramp">ramp</code></td>
<td>
<p>either a vector of color names that will be interpolated, or a
color ramp function that takes an integer (see for example
<code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>). If omitted, defaults to default epm color
palette.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_isinteger">isInteger</code></td>
<td>
<p>If <code>auto</code>, automatically determines if <code>r</code> is
made up of integer values, otherwise <code>TRUE</code> or <code>FALSE</code></p>
</td></tr>
<tr><td><code id="addLegend_+3A_ncolors">ncolors</code></td>
<td>
<p>grain size of color ramp</p>
</td></tr>
<tr><td><code id="addLegend_+3A_breaks">breaks</code></td>
<td>
<p>If a custom set of color breaks were used in plotting
<code>r</code>, pass those color breaks here. This overrides the minmax option.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_minmax">minmax</code></td>
<td>
<p>min and max values from which the color ramp will be derived.
If left as <code>NULL</code>, the min and max of <code>r</code> will be used.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_locs">locs</code></td>
<td>
<p>locations of tick marks, if <code>NULL</code> automatically placed. If
this is supplied as a character vector, then the labels will be plotted
verbatim.</p>
</td></tr>
<tr><td><code id="addLegend_+3A_label">label</code></td>
<td>
<p>text to plot alongside the legend</p>
</td></tr>
<tr><td><code id="addLegend_+3A_cex.axis">cex.axis</code></td>
<td>
<p>size of axis labels</p>
</td></tr>
<tr><td><code id="addLegend_+3A_tcl">tcl</code></td>
<td>
<p>length of tick marks (see help for tcl in ?par)</p>
</td></tr>
<tr><td><code id="addLegend_+3A_labeldist">labelDist</code></td>
<td>
<p>distance from axis to axis labels (passed to <code>mgp</code>)</p>
</td></tr>
<tr><td><code id="addLegend_+3A_mindigits">minDigits</code></td>
<td>
<p>minimum number of significant digits for labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A number of predefined locations exist in this function to make it
easy to add a legend to a plot.
</p>
<p>Preset <code>locations</code> are: <code>topleft</code>, <code>topright</code>,
<code>bottomleft</code>, <code>bottomright</code>, <code>left</code>, <code>right</code>,
<code>top</code> and <code>bottom</code>. <br /> If more fine-tuned control is desired,
then a numeric vector of length 4 can be supplied to <code>location</code>,
specifying the min x, max x, min y and max y values for the legend.
</p>
<p>Additionally, the <code>adj</code> argument can be used to more intuitively
adjust where the legend is placed. <code>adj</code> is defined as a percentage
of the figure width or height, left to right, or bottom to top,
respectively. For example, if the legend is at the bottom, <code>adj =
  0.8</code> will place the legend 80% of the distance from the top of the
figure, horizontally centered.
</p>
<p>If an epmGrid object was plotted with <code><a href="#topic+plot.epmGrid">plot.epmGrid</a></code>, and if
<code>use_tmap = FALSE</code> was specified, and if that plot was assigned to
a variable, then you can supply that variable here to the <code>params</code>
argument, and a number of options will be automatically handed over to 
this function.
</p>
<p>See examples.
</p>


<h3>Value</h3>

<p>Invisibly returns a list with the following components.
</p>

<ul>
<li><p> coords: 2-column matrix of xy coordinates for each color bin in the legend.
</p>
</li>
<li><p> width: Coordinates for the short dimension of the legend.
</p>
</li>
<li><p> pal: the color ramp
</p>
</li>
<li><p> tickLocs: the tick mark locations in plotting units
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create square-cell epmGrid object
tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'square', method = 'centroid')

# need to disable tmap if we want to anything to a plot
plot(tamiasEPM2, use_tmap = FALSE, legend = FALSE)
addLegend(tamiasEPM2, location = 'right', label = 'richness')
addLegend(tamiasEPM2, location = 'top', label = 'richness')

# fine-tune placement
addLegend(tamiasEPM2, location=c(113281, 1265200, -1500000, -1401898), side = 1)

# Using the params option
xx &lt;- plot(tamiasEPM2, use_tmap = FALSE, legend = FALSE, 
col = viridisLite::magma)
addLegend(tamiasEPM2, params = xx, location = 'top')

# works with hex grids as well
xx &lt;- plot(tamiasEPM, use_tmap = FALSE, legend = FALSE, 
col = viridisLite::magma)
addLegend(tamiasEPM, params = xx, location = 'top')

</code></pre>

<hr>
<h2 id='addPhylo'>addPhylo</h2><span id='topic+addPhylo'></span>

<h3>Description</h3>

<p>Add a phylogeny to epmGrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPhylo(x, tree, replace = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addPhylo_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="addPhylo_+3A_tree">tree</code></td>
<td>
<p>a phylogeny of class <code>phylo</code>, or a set of trees of class <code>multiPhylo</code></p>
</td></tr>
<tr><td><code id="addPhylo_+3A_replace">replace</code></td>
<td>
<p>boolean; if a tree is already a part of <code>x</code>, should it
be replaced?</p>
</td></tr>
<tr><td><code id="addPhylo_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, list out all species that are dropped/excluded,
rather than counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any species in the phylogeny are not found in the epmGrid
geographical data, then those species will be dropped from the phylogeny,
and a warning will be issued.
</p>
<p>If providing a set of trees as a multiPhylo object, it is expected that all
trees have the same tips.
</p>


<h3>Value</h3>

<p>object of class <code>epmGrid</code>, with a <code>phylo</code> object as the
list element named <code>phylo</code>.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM
tamiasTree

addPhylo(tamiasEPM, tamiasTree)

</code></pre>

<hr>
<h2 id='addTraits'>addTraits</h2><span id='topic+addTraits'></span>

<h3>Description</h3>

<p>Add univariate or multivariate trait data to an epmGrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addTraits(x, data, replace = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addTraits_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="addTraits_+3A_data">data</code></td>
<td>
<p>named numeric vector, matrix or dataframe with rownames
corresponding to species in <code>x</code> or pairwise matrix with row and
column names corresponding to species in <code>x</code>. If pairwise matrix, the
upper triangle of the matrix will be used for calculations.</p>
</td></tr>
<tr><td><code id="addTraits_+3A_replace">replace</code></td>
<td>
<p>boolean; if data is already a part of <code>x</code>, should it be
replaced?</p>
</td></tr>
<tr><td><code id="addTraits_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, list out all species that are dropped/excluded,
rather than counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any species in <code>data</code> are not found in the epmGrid
geographical data, then those species will be dropped from <code>data</code>,
and a warning will be issued.
</p>


<h3>Value</h3>

<p>object of class <code>epmGrid</code>, with trait data as the list element
named <code>data</code>.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM
tamiasTraits

addTraits(tamiasEPM, tamiasTraits)

</code></pre>

<hr>
<h2 id='betadiv_disparity'>Map change in morphological disparity</h2><span id='topic+betadiv_disparity'></span>

<h3>Description</h3>

<p>Change in morphological disparity is calculating across a
moving window of neighboring grid cells. To implement a custom function,
see <code><a href="#topic+customBetaDiv">customBetaDiv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betadiv_disparity(x, radius, slow = FALSE, nThreads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betadiv_disparity_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code>.</p>
</td></tr>
<tr><td><code id="betadiv_disparity_+3A_radius">radius</code></td>
<td>
<p>Radius of the moving window in map units.</p>
</td></tr>
<tr><td><code id="betadiv_disparity_+3A_slow">slow</code></td>
<td>
<p>if TRUE, use an alternate implementation that has a smaller
memory footprint but that is likely to be much slower. Most useful for
high spatial resolution.</p>
</td></tr>
<tr><td><code id="betadiv_disparity_+3A_nthreads">nThreads</code></td>
<td>
<p>number of threads for parallelization</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each gridcell neighborhood (defined by the radius), we
calculate the proportion of the full disparity contained in those grid
cells, and then take the standard deviation of those proportions across the
gridcell neighborhood. This way, the returned values reflect how much
disparity (relative to the overall total disparity) changes across a moving
window.
</p>
<p>If the R package spdep is installed, this function should run more quickly.
</p>


<h3>Value</h3>

<p>Returns a sf polygons object (if hex grid) or a SpatRaster object
(if square grid).
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>References</h3>

<p>Foote M. 1993. Contributions of individual taxa to overall morphological
disparity. Paleobiology. 19:403–419.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tamiasEPM

tamiasEPM &lt;- addTraits(tamiasEPM, tamiasTraits)

z &lt;- betadiv_disparity(tamiasEPM, radius = 150000)

plot(z)

# using square grid epmGrid
tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'square', method = 'centroid')
tamiasEPM2 &lt;- addTraits(tamiasEPM2, tamiasTraits)
z2 &lt;- betadiv_disparity(tamiasEPM2, radius = 150000)

terra::plot(z2, col = sf::sf.colors(100))


</code></pre>

<hr>
<h2 id='betadiv_phylogenetic'>Map phylogenetic turnover in species communities</h2><span id='topic+betadiv_phylogenetic'></span>

<h3>Description</h3>

<p>Multisite phylogenetic community dissimilarity is calculated for
each cell within a circular moving window of neighboring cells. To implement a 
custom function, see <code><a href="#topic+customBetaDiv">customBetaDiv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betadiv_phylogenetic(
  x,
  radius,
  component = "full",
  focalCoord = NULL,
  slow = FALSE,
  nThreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betadiv_phylogenetic_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code>.</p>
</td></tr>
<tr><td><code id="betadiv_phylogenetic_+3A_radius">radius</code></td>
<td>
<p>Radius of the moving window in map units.</p>
</td></tr>
<tr><td><code id="betadiv_phylogenetic_+3A_component">component</code></td>
<td>
<p>which component of beta diversity to use, can be
<code>"turnover"</code>, <code>"nestedness"</code> or <code>"full"</code></p>
</td></tr>
<tr><td><code id="betadiv_phylogenetic_+3A_focalcoord">focalCoord</code></td>
<td>
<p>vector of x and y coordinate, see details</p>
</td></tr>
<tr><td><code id="betadiv_phylogenetic_+3A_slow">slow</code></td>
<td>
<p>if TRUE, use an alternate implementation that has a smaller
memory footprint but that is likely to be much slower. Most useful for high
spatial resolution.</p>
</td></tr>
<tr><td><code id="betadiv_phylogenetic_+3A_nthreads">nThreads</code></td>
<td>
<p>number of threads for parallelization</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each cell, multisite dissimilarity is calculated for the focal
cell and its neighbors. If <code>focalCoord</code> is specified, then instead of
multisite dissimilarity within a moving window of gridcells, pairwise
dissimilarity is calculated from the cell at the focal coordinates, to all
other cells.
</p>
<p>All metrics are based on Sorensen dissimilarity and range from 0 to 1: For
each metric, the following components can be specified. These components
are additive, such that the full metric = turnover + nestedness. </p>

<ul>
<li><p>turnover: species turnover without the influence of richness
differences </p>
</li>
<li><p>nestedness: species turnover due to differences in
richness </p>
</li>
<li><p>full: the combined turnover due to both differences in
richness and pure turnover </p>
</li></ul>

<p>If the R package spdep is installed, this function should run more quickly.
</p>


<h3>Value</h3>

<p>Returns a sf polygons object (if hex grid) or a SpatRaster object (if
square grid) with multisite community dissimilarity for each grid cell.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>References</h3>

<p>Baselga, A. The relationship between species replacement, dissimilarity
derived from nestedness, and nestedness. Global Ecology and Biogeography 21
(2012): 1223–1232.
</p>
<p>Leprieur, F, Albouy, C, De Bortoli, J, Cowman, PF, Bellwood, DR &amp; Mouillot,
D. Quantifying Phylogenetic Beta Diversity: Distinguishing between &quot;True&quot;
Turnover of Lineages and Phylogenetic Diversity Gradients. PLoS ONE 7 (2012):
e42760–12.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tamiasEPM

tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTree)

# phylogenetic turnover
beta_phylo_turnover &lt;- betadiv_phylogenetic(tamiasEPM, radius = 70000,
		component = 'turnover')
beta_phylo_nestedness &lt;- betadiv_phylogenetic(tamiasEPM, radius = 70000,
		component = 'nestedness')
beta_phylo_full &lt;- betadiv_phylogenetic(tamiasEPM, radius = 70000,
		component = 'full')

oldpar &lt;- par(mfrow=c(1,3))
plot(beta_phylo_turnover, reset = FALSE, key.pos = NULL)
plot(beta_phylo_nestedness, reset = FALSE, key.pos = NULL)
plot(beta_phylo_full, reset = FALSE, key.pos = NULL)

# using square grid epmGrid
tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'square', method = 'centroid')
tamiasEPM2 &lt;- addPhylo(tamiasEPM2, tamiasTree)

beta_phylo_full &lt;- betadiv_phylogenetic(tamiasEPM2, radius = 70000,
		component = 'full')
beta_phylo_full_slow &lt;- betadiv_phylogenetic(tamiasEPM2, radius = 70000,
		component = 'full', slow = TRUE)

par(mfrow = c(1,2))
terra::plot(beta_phylo_full, col = sf::sf.colors(100))
terra::plot(beta_phylo_full_slow, col = sf::sf.colors(100))

# dissimilarity from a focal cell
focalBeta &lt;- betadiv_phylogenetic(tamiasEPM, radius = 70000,
		component = 'full', focalCoord = c(-1413764, 573610.8))
plot(focalBeta, reset = FALSE)
points(-1413764, 573610.8, pch = 3, col = 'white')

par(oldpar)

</code></pre>

<hr>
<h2 id='betadiv_taxonomic'>Map turnover in species communities</h2><span id='topic+betadiv_taxonomic'></span>

<h3>Description</h3>

<p>Multisite taxonomic community dissimilarity is calculated for
each cell within a circular moving window of neighboring cells. To implement 
a custom function, see <code><a href="#topic+customBetaDiv">customBetaDiv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betadiv_taxonomic(
  x,
  radius,
  component = "full",
  focalCoord = NULL,
  slow = FALSE,
  nThreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betadiv_taxonomic_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code>.</p>
</td></tr>
<tr><td><code id="betadiv_taxonomic_+3A_radius">radius</code></td>
<td>
<p>Radius of the moving window in map units.</p>
</td></tr>
<tr><td><code id="betadiv_taxonomic_+3A_component">component</code></td>
<td>
<p>which component of beta diversity to use, can be
<code>"turnover"</code>, <code>"nestedness"</code> or <code>"full"</code></p>
</td></tr>
<tr><td><code id="betadiv_taxonomic_+3A_focalcoord">focalCoord</code></td>
<td>
<p>vector of x and y coordinate, see details</p>
</td></tr>
<tr><td><code id="betadiv_taxonomic_+3A_slow">slow</code></td>
<td>
<p>if TRUE, use an alternate implementation that has a smaller
memory footprint but that is likely to be much slower. Most useful for high
spatial resolution.</p>
</td></tr>
<tr><td><code id="betadiv_taxonomic_+3A_nthreads">nThreads</code></td>
<td>
<p>number of threads for parallelization</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each cell, multisite dissimilarity is calculated from the focal
cell and its neighbors. If <code>focalCoord</code> is specified, then instead of
multisite dissimilarity within a moving window of gridcells, pairwise
dissimilarity is calculated from the cell at the focal coordinates, to all
other cells.
</p>
<p>All metrics are based on Sorensen dissimilarity and range from 0 to 1. <br />
For each metric, the following components can be specified. These components
are additive, such that the full metric = turnover + nestedness. 
</p>

<ul>
<li><p>turnover: species turnover without the influence of richness
differences 
</p>
</li>
<li><p>nestedness: species turnover due to differences in
richness 
richness and pure turnover 
</p>
</li></ul>

<p>If the R package spdep is installed, this function should run more quickly.
</p>


<h3>Value</h3>

<p>Returns a grid with multi-site community dissimilarity for each cell.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>References</h3>

<p>Baselga, A. The relationship between species replacement, dissimilarity
derived from nestedness, and nestedness. Global Ecology and Biogeography 21
(2012): 1223–1232.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tamiasEPM

tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTree)
tamiasEPM &lt;- addTraits(tamiasEPM, tamiasTraits)

# taxonomic turnover
beta_taxonomic_turnover &lt;- betadiv_taxonomic(tamiasEPM, radius = 70000,
		component = 'turnover')
beta_taxonomic_nestedness &lt;- betadiv_taxonomic(tamiasEPM, radius = 70000,
		component = 'nestedness')
beta_taxonomic_full &lt;- betadiv_taxonomic(tamiasEPM, radius = 70000,
		component = 'full')



oldpar &lt;- par(mfrow = c(1, 3))
plot(beta_taxonomic_turnover, reset = FALSE, key.pos = NULL)
plot(beta_taxonomic_nestedness, reset = FALSE, key.pos = NULL)
plot(beta_taxonomic_full, reset = FALSE, key.pos = NULL)



# using square grid epmGrid
tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'square', method = 'centroid')

beta_taxonomic_full &lt;- betadiv_taxonomic(tamiasEPM2, radius = 70000,
		component = 'full')
beta_taxonomic_full_slow &lt;- betadiv_taxonomic(tamiasEPM2, radius = 70000,
		component = 'full', slow = TRUE)

par(mfrow=c(1,2))
terra::plot(beta_taxonomic_full, col = sf::sf.colors(100))
terra::plot(beta_taxonomic_full_slow, col = sf::sf.colors(100))

# dissimilarity from a focal cell
focalBeta &lt;- betadiv_taxonomic(tamiasEPM, radius = 70000,
		component = 'full', focalCoord = c(-1413764, 573610.8))
plot(focalBeta, reset = FALSE)
points(-1413764, 573610.8, pch = 3, col = 'white')

par(oldpar)

</code></pre>

<hr>
<h2 id='calcMeanShape'>Calculate mean shape per grid cell</h2><span id='topic+calcMeanShape'></span>

<h3>Description</h3>

<p>For an epmGrid object that contains geometric
morphometric shape coordinates, calculate the per-grid-cell
mean shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcMeanShape(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcMeanShape_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will ignore cells that are empty.
</p>


<h3>Value</h3>

<p>a list with 2 elements:
(1) matrix where nrow = number of grid cells and ncol = 
the number of data columns. Each row is a vector of mean shape coordinates.
(2) a matrix of xy coordinates corresponding to those grid cells.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tamiasEPM
tamiasEPM &lt;- addTraits(tamiasEPM, tamiasTraits)
meanshape &lt;- calcMeanShape(tamiasEPM)

head(meanshape[[1]])
head(meanshape[[2]])

</code></pre>

<hr>
<h2 id='coordsFromEpmGrid'>Retrieve coordinates from epmGrid</h2><span id='topic+coordsFromEpmGrid'></span>

<h3>Description</h3>

<p>Return the centroid coordinates for a specified set of grid cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordsFromEpmGrid(x, sites)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coordsFromEpmGrid_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="coordsFromEpmGrid_+3A_sites">sites</code></td>
<td>
<p>locations of sites, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sites can be cell indices as a numeric vector, or you can specify 
<code>sites = 'all'</code> to get all grid cells. If the epmGrid object
is hexagon-based, then all grid cells that are occupied are returned.
If the epmGrid is square-based, then all grid cells, occupied or empty,
are returned.
</p>


<h3>Value</h3>

<p>matrix with x and y coordinates.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM

# from cell indices
cells &lt;- c(2703, 90, 3112, 179)
coordsFromEpmGrid(tamiasEPM, cells)

# for all grid cells
dim(coordsFromEpmGrid(tamiasEPM, 'all'))


</code></pre>

<hr>
<h2 id='createEPMgrid'>Create epmGrid object</h2><span id='topic+createEPMgrid'></span>

<h3>Description</h3>

<p>Creates an epmGrid object from a range of species-specific
inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEPMgrid(
  spDat,
  resolution = 50000,
  method = "centroid",
  cellType = "hexagon",
  percentThreshold = 0.25,
  retainSmallRanges = TRUE,
  extent = "auto",
  percentWithin = 0,
  dropEmptyCells = TRUE,
  checkValidity = FALSE,
  crs = NULL,
  nThreads = 1,
  template = NULL,
  verbose = FALSE,
  use.data.table = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createEPMgrid_+3A_spdat">spDat</code></td>
<td>
<p>a number of possible input formats are possible. See details
below.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_resolution">resolution</code></td>
<td>
<p>vertical and horizontal spacing of grid cells, in units of
the polygons' or points' projection.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_method">method</code></td>
<td>
<p>approach used for gridding. Either <code>centroid</code> or
<code>percentOverlap</code>. See details below.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_celltype">cellType</code></td>
<td>
<p>either <code>hexagon</code> or <code>square</code>. See details below.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_percentthreshold">percentThreshold</code></td>
<td>
<p>the percent that a species range must cover a grid
cell to be considered present. Specified as a proportion.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_retainsmallranges">retainSmallRanges</code></td>
<td>
<p>boolean; should small ranged species be dropped or
preserved. See details.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_extent">extent</code></td>
<td>
<p>if 'auto', then the maximal extent of the polygons will be
used. If not 'auto', can be a SpatialPolygon, sf object, or raster, in
which case the resulting epmGrid will be cropped and masked with respect to
the polygon; or a spatial coordinates object, from which an extent object
will be generated; or a numeric vector of length 4 with minLong, maxLong,
minLat, maxLat. If 'global', a global extent will be specified. 
See <code><a href="#topic+interactiveExtent">interactiveExtent</a></code> to draw your own extent.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_percentwithin">percentWithin</code></td>
<td>
<p>The percentage of a species range that must be within
the defined extent in order for that species to be included. This filter
can be used to exclude species whose range barely enters the area of
interest. The default value of 0 will disable this filter. If <code>extent
== 'auto'</code>, then this filter will also have no effect, as the extent is
defined by the species' ranges.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_dropemptycells">dropEmptyCells</code></td>
<td>
<p>only relevant for hexagonal grids, should empty cells be
excluded from the resulting grid. Default is TRUE. Reasons to set this to FALSE
may be if you want to retain a grid of a certain extent, regardless of which
cells contain species.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_checkvalidity">checkValidity</code></td>
<td>
<p>if <code>TRUE</code>, then check polygon validity and repair
if needed, using sf::st_make_valid.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_crs">crs</code></td>
<td>
<p>if supplying occurrence records in a non-spatial format, then you
must specify the crs. For unprojected long/lat data, you can simply provide
<code>crs = 4326</code>.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_nthreads">nThreads</code></td>
<td>
<p>if &gt; 1, then employ parallel computing. This won't
necessarily improve runtime.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_template">template</code></td>
<td>
<p>a grid (SpatRaster, RasterLayer or sf)
that will be directly used as the reference grid, bypassing any inference from
the input data.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, list out all species that are dropped/excluded,
rather than counts.</p>
</td></tr>
<tr><td><code id="createEPMgrid_+3A_use.data.table">use.data.table</code></td>
<td>
<p>if <code>'auto'</code>, this is determined by the size of the
dataset. Primarily intended for debugging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Types of accepted inputs for argument <code>spDat</code>: 
</p>

<ol>
<li><p> a list of polygon objects (sf or sp), named with taxon names. 
</p>
</li>
<li><p> a list of SpatRaster or RasterLayer grids, named with taxon names. </p>
</li>
<li><p> a
multi-layer RasterStack or multi-layer SpatRaster. 
</p>
</li>
<li><p> a set of occurrence records, multiple accepted formats, see below. 
</p>
</li>
<li><p> a site-by-taxon presence/absence matrix. 
</p>
</li></ol>

<p>If input data consist of <strong>occurrence records</strong> rather than polygons,
then a couple of formats are possible: 
</p>
 
<ol>
<li><p> You can provide a list of species-specific spatial point objects. 
</p>
</li>
<li><p> You can provide a single spatial object, where points have a taxon attribute. 
</p>
</li>
<li><p> You can provide a list of non-spatial species-specific dataframes. 
</p>
</li>
<li><p> You can provide a single non-spatial dataframe. 
</p>
</li></ol>

<p>For options (1) and (3), the taxon names must be provided as the list names.
For options (2) and (4), the columns must be 'taxon', 'x' and 'y' (or 'long',
'lat'). For options (3) and (4), as these are non-spatial, you must provide a
crs object to the <code>crs</code> argument, so that the function knows what
projection to use.
</p>
<p>It is also possible to supply a <strong>matrix with sites as rows and taxa as
columns</strong>. The contents of this matrix must be either 0 or 1. If this is the
case, then a raster grid must be supplied under the template argument. This
will be the grid system used for converting this presence/absence matrix to
an epmGrid object. It is expected that the index order of the grid is the
same as the row order of the matrix.
</p>
<p>If input is a set of <strong>species-specific grids</strong>, then it is expected
that all grids belong to the same overall grid system, i.e. that the cells
align and that all grids have the same resolution. Grids do not need to have
the same extent.
</p>
<p>Any SpatialPolygon or SpatialPoints objects are converted to objects of class
<code>sf</code>.
</p>
<p>If <code>cellType = 'hexagon'</code>, then the grid is made of polygons via the sf
package. If <code>cellType = 'square'</code>, then the grid is a raster generated
via the terra package. Hexagonal cells have several advantages, including
being able to be of different sizes (if the grid is in unprojected long/lat),
and may be able to more naturally follow coastlines and non-linear features.
However, the raster-based square cells will be much less memory intensive for
high resolution datasets. Choice of grid type matters more for spatial
resolution (total number of cells), than for number of species.
</p>
<p>In the polygon-to-grid conversion process, two approaches are implemented.
For <code>method = 'centroid'</code>, a range polygon registers in a cell if the
polygon overlaps with the cell centroid. For <code>method =
'percentOverlap'</code>, a range polygon registers in a cell if it covers that cell
by at least <code>percentThreshold</code> fraction of the cell.
</p>
<p>If <code>retainSmallRanges = FALSE</code>, then species whose ranges are so small
that no cell registers as present will be dropped. If <code>retainSmallRanges
= TRUE</code>, then the cell that contains the majority of the the small polygon
will be considered as present, even if it's a small percent of the cell.
</p>
<p>If <code>retainSmallRanges = TRUE</code>, and an extent is provided, then species
may still be dropped if they fall outside of that extent.
</p>
<p>You may see the message <code>Failed to compute min/max, no valid pixels found in 
sampling. (GDAL error 1)</code> . This just means that a species did not register in any 
grid cells. If you specified <code>retainSmallRanges = TRUE</code>, then those species will
be included in a subsequent step. Therefore, this message can be ignored.
</p>
<p>For very large datasets, this function will make a determination as to
whether or not there is sufficient memory. If there is not, an alternative
approach that uses the data.table package will be employed. Please install
this R package to take advantage of this feature.
</p>
<p>This function is also enhanced by the installation of the exactextractr R package.
</p>


<h3>Value</h3>

<p>an object of class <code>epmGrid</code>.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
# example dataset: a list of 24 chipmunk distributions as polygons
head(tamiasPolyList)

# hexagonal grid

tamiasEPM &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'hexagon', method = 'centroid')
tamiasEPM

# square grid
tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'square', method = 'centroid')
tamiasEPM2

# use of a grid from one analysis for another analysis

tamiasEPM &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'hexagon', method = 'centroid')

tamiasEPM &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'hexagon', method = 'centroid', template = tamiasEPM[[1]])
	
#######

# demonstration of site-by-species matrix as input.
tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'square', method = 'centroid')

## first we will use the function generateOccurrenceMatrix() to get
## a presence/absence matrix
pamat &lt;- generateOccurrenceMatrix(tamiasEPM2, sites = 'all')

# here, our grid template will be tamiasEPM2[[1]]
tamiasEPM2[[1]]
xx &lt;- createEPMgrid(pamat, template = tamiasEPM2[[1]])


#######
# demonstration with grids as inputs
## We will first generate grids from the range polygons
## (you normally would not do this -- you would have grids from some other source)

# define the extent that contains all range polygons
fullExtent &lt;- terra::ext(terra::vect(tamiasPolyList[[1]]))
for (i in 2:length(tamiasPolyList)) {
	fullExtent &lt;- terra::union(fullExtent, terra::ext(terra::vect(tamiasPolyList[[i]])))
}

# create raster template
fullGrid &lt;- terra::rast(fullExtent, res = 50000, crs = terra::crs(terra::vect(tamiasPolyList[[1]])))

# now we can convert polygons to a common grid system
spGrids &lt;- list()
for (i in 1:length(tamiasPolyList)) {
	spGrids[[i]] &lt;- terra::trim(terra::rasterize(terra::vect(tamiasPolyList[[i]]), fullGrid))
}
names(spGrids) &lt;- names(tamiasPolyList)

createEPMgrid(spGrids)


#######
# With point occurrences
## demonstrating all possible input formats

# list of sf spatial objects
spOccList &lt;- lapply(tamiasPolyList, function(x) st_sample(x, size = 10, type= 'random'))
tamiasEPM &lt;- createEPMgrid(spOccList, resolution = 100000, cellType = 'hexagon')

# list of coordinate tables
spOccList2 &lt;- lapply(spOccList, function(x) st_coordinates(x))
tamiasEPM &lt;- createEPMgrid(spOccList2, resolution = 100000, cellType = 'square', 
	crs = st_crs(tamiasPolyList[[1]]))

# single table of coordinates
spOccList3 &lt;- spOccList2
for (i in 1:length(spOccList3)) {
	spOccList3[[i]] &lt;- cbind.data.frame(taxon = names(spOccList3)[i], spOccList3[[i]])
	colnames(spOccList3[[i]]) &lt;- c('taxon', 'X', 'Y')
}
spOccList3 &lt;- do.call(rbind, spOccList3)
rownames(spOccList3) &lt;- NULL
spOccList3[, "taxon"] &lt;- as.character(spOccList3[, "taxon"])
tamiasEPM &lt;- createEPMgrid(spOccList3, resolution = 100000, cellType = 'square', 
	crs = st_crs(tamiasPolyList[[1]]))

# a single labeled spatial object
spOccList4 &lt;- st_as_sf(spOccList3[, c("taxon", "X", "Y")], coords = c("X","Y"),
crs = st_crs(spOccList[[1]]))
tamiasEPM &lt;- createEPMgrid(spOccList4, resolution = 100000, cellType = 'square')



</code></pre>

<hr>
<h2 id='customBetaDiv'>Custom beta diversity metrics</h2><span id='topic+customBetaDiv'></span>

<h3>Description</h3>

<p>Define your own function for summarizing information across a
moving window of grid cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>customBetaDiv(
  x,
  fun,
  radius,
  minTaxCount = 1,
  focalCoord = NULL,
  metricName = "custom_metric"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="customBetaDiv_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="customBetaDiv_+3A_fun">fun</code></td>
<td>
<p>a function to apply to grid cell neighborhoods (see details)</p>
</td></tr>
<tr><td><code id="customBetaDiv_+3A_radius">radius</code></td>
<td>
<p>Radius of the moving window in map units.</p>
</td></tr>
<tr><td><code id="customBetaDiv_+3A_mintaxcount">minTaxCount</code></td>
<td>
<p>the minimum number of taxa needed to apply the function.
For instance, should the function be applied to gridcells with just 1
taxon?</p>
</td></tr>
<tr><td><code id="customBetaDiv_+3A_focalcoord">focalCoord</code></td>
<td>
<p>vector of x and y coordinate, see details</p>
</td></tr>
<tr><td><code id="customBetaDiv_+3A_metricname">metricName</code></td>
<td>
<p>the name you would like to attach to the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will identify the neighbors of every cell and will
apply the specified function to those sets of cell neighborhoods. 
</p>
<p>The custom function should have just one input: a list of taxon names, where
the list will represent a set of grid cells (focal cell + neighboring cells).
</p>
<p>However, if a set of focal coordinates is provided, then rather than apply the
function to each neighborhood of cells, the function should have two inputs: the
focal cell and another cell, and that function will be applied to every pair 
defined by the focal cell and another cell. See examples.
</p>
<p>Within the function call, the trait data already attached to the epmGrid object 
must be referred to as dat, and the phylogenetic tree already attached to the 
epmGrid must be referred to as phylo.<br /> 
</p>
<p>If the input epmGrid object contains a set of trees, then this function will
be applied, using each tree in turn, and will return a list of results. This
list can then be passed to <code><a href="#topic+summarizeEpmGridList">summarizeEpmGridList</a></code> to be summarized.
</p>
<p>See examples below.
</p>


<h3>Value</h3>

<p>object of class <code>epmGrid</code>, or list of <code>epmGrid</code> objects
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTree)
tamiasEPM &lt;- addTraits(tamiasEPM, tamiasTraits)

# An example using a multivariate dataset
## For each focal cell + neighbors, calculate the morphological standard deviation
## per grid cell and return the standard deviation.
f &lt;- function(cellList) {
	vec &lt;- numeric(length(cellList))
	for (i in 1:length(cellList)) {
		vec[[i]] &lt;- max(dist(dat[cellList[[i]], ]))
	}
	return(sd(vec, na.rm = TRUE))	
}

xx &lt;- customBetaDiv(tamiasEPM, fun = f, radius = 70000, minTaxCount = 2, metricName = 'maxdist')


# An example using only the phylogeny.
## Calculate standard deviation of phylogenetic diversity across cell neighborhood.
f &lt;- function(cellList) {
	vec &lt;- numeric(length(cellList))
	for (i in 1:length(cellList)) {
		vec[[i]] &lt;- faithPD(phylo, cellList[[i]])
	}
	return(sd(vec, na.rm = TRUE))	
}

xx &lt;- customBetaDiv(tamiasEPM, fun = f, radius = 70000, minTaxCount = 1, metricName = 'faithPD')



# an example that involves both morphological and phylogenetic data
## nonsensical, but for illustrative purposes:
## ratio of Faith's phylogenetic diversity to morphological range
## the standard deviation of this measure across grid cells 
## in a neighborhood.
f &lt;- function(cellList) {
	vec &lt;- numeric(length(cellList))
	for (i in 1:length(cellList)) {
		vec[[i]] &lt;- faithPD(phylo, cellList[[i]]) / 
		max(dist(dat[cellList[[i]], ]))
	}
	return(sd(vec, na.rm = TRUE))	
}

xx &lt;- customBetaDiv(tamiasEPM, fun = f, radius = 70000, minTaxCount = 2, 
  metricName = 'ratio_PD_maxdist')




# from a focal coordinate to all other sites
## Here, the function has 2 inputs.
## Example: calculate the per grid cell mean and take the distance.
f &lt;- function(focalCell, otherCell) {
	x1 &lt;- colMeans(dat[focalCell, ])
	x2 &lt;- colMeans(dat[otherCell, ])
	return(as.matrix(dist(rbind(x1, x2)))[1,2])
}

xx &lt;- customBetaDiv(tamiasEPM, fun = f, radius = 70000, minTaxCount = 1,
 focalCoord = c(-1413764, 573610.8), metricName = 'meandist')



# Example involving a set of trees
tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTreeSet, replace = TRUE)

## Calculate standard deviation of phylogenetic diversity across cell
## neighborhood.
f &lt;- function(cellList) {
	vec &lt;- numeric(length(cellList))
	for (i in 1:length(cellList)) {
		vec[[i]] &lt;- faithPD(phylo, cellList[[i]])
	}
	return(sd(vec, na.rm = TRUE))	
}

# This time, a list of sf objects will be returned, one for each input tree.
xx &lt;- customBetaDiv(tamiasEPM, fun = f, radius = 70000, minTaxCount = 1,
 metricName = 'faithPD')



# also works with square grid cells
tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'square', method = 'centroid')
tamiasEPM2 &lt;- addPhylo(tamiasEPM2, tamiasTree)
tamiasEPM2 &lt;- addTraits(tamiasEPM2, tamiasTraits)


f &lt;- function(cellList) {
	vec &lt;- numeric(length(cellList))
	for (i in 1:length(cellList)) {
		vec[[i]] &lt;- faithPD(phylo, cellList[[i]]) / 
		max(dist(dat[cellList[[i]], ]))
	}
	return(sd(vec, na.rm = TRUE))	
}

xx &lt;- customBetaDiv(tamiasEPM2, fun = f, radius = 70000, minTaxCount = 2,
 metricName = 'ratio_PD_maxdist')



</code></pre>

<hr>
<h2 id='customGridMetric'>Custom grid metrics</h2><span id='topic+customGridMetric'></span>

<h3>Description</h3>

<p>Define your own function for summarizing information across grid
cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>customGridMetric(
  x,
  fun,
  column = NULL,
  minTaxCount = 1,
  metricName = "custom_metric"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="customGridMetric_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="customGridMetric_+3A_fun">fun</code></td>
<td>
<p>a function to apply to all grid cells (see details)</p>
</td></tr>
<tr><td><code id="customGridMetric_+3A_column">column</code></td>
<td>
<p>If a univariate morphological metric is specified, and the data
in <code>x</code> are multivariate, which trait should be used? This can also
specify which subset of columns a multivariate metric should be applied to.</p>
</td></tr>
<tr><td><code id="customGridMetric_+3A_mintaxcount">minTaxCount</code></td>
<td>
<p>the minimum number of taxa needed to apply the function.
For instance, should the function be applied to gridcells with just 1
taxon?</p>
</td></tr>
<tr><td><code id="customGridMetric_+3A_metricname">metricName</code></td>
<td>
<p>the name you would like to attach to the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows you to not be limited to the diversity metrics
available via the <code><a href="#topic+gridMetrics">gridMetrics</a></code> function. <br />
</p>
<p>The custom function should have just one input: a vector of taxon names
that will then be used to subset the trait or phylogenetic data. Within the
function call, the trait data already attached to the epmGrid object must
be referred to as dat, and the phylogenetic tree already attached to the
epmGrid must be referred to as phylo.<br /> 
</p>
<p>If the input epmGrid object contains a set of trees, then this function will
be applied, using each tree in turn, and will return a list of results. This
list can then be passed to <code><a href="#topic+summarizeEpmGridList">summarizeEpmGridList</a></code> to be summarized.
</p>
<p>See examples below.
</p>


<h3>Value</h3>

<p>object of class <code>epmGrid</code>, or list of <code>epmGrid</code> objects
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM
tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTree)
tamiasEPM &lt;- addTraits(tamiasEPM, tamiasTraits)

# In the following examples, notice that any mention of the trait data or 
## phylogeny that are already attached to the epmGrid object are referred 
## to as dat and phylo.

# example: calculate morphological disparity 
## (already implemented in gridMetrics)
f &lt;- function(cells) {
	sum(diag(cov(dat[cells,])))
}

# to calculate disparity, we need at least 2 taxa

xx &lt;- customGridMetric(tamiasEPM, fun = f, minTaxCount = 2, 
metricName = 'disparity')

# In the example above, gridcells with 1 species are left as NA. 
## But if we wanted those gridcells to have a value of 0 rather than NA, 
## we could do the following:
f &lt;- function(sp) {
	if (length(sp) == 1) {
		0
	} else {
		sum(diag(cov(dat[sp,])))
	}
}

# and change minTaxCount to 1
xx &lt;- customGridMetric(tamiasEPM, fun = f, minTaxCount = 1, 
metricName = 'disparity')


# phylogenetic example: mean patristic distance
## this example doesn't actually involve the phylogeny internally,
## we can just supply what is needed to the function
patdist &lt;- cophenetic(tamiasEPM[['phylo']])
patdist[upper.tri(patdist, diag = TRUE)] &lt;- NA
f &lt;- function(cells) {
	mean(patdist[cells, cells], na.rm = TRUE)
}

xx &lt;- customGridMetric(tamiasEPM, fun = f, minTaxCount = 1, 
metricName = 'mean patristic')

# an example that involves both morphological and phylogenetic data
## nonsensical, but for illustrative purposes:
## ratio of Faith's phylogenetic diversity to morphological range
f &lt;- function(cells) {
	faithPD(phylo, cells) / max(dist(dat[cells, ]))
}

xx &lt;- customGridMetric(tamiasEPM, fun = f, minTaxCount = 2, 
metricName = 'PD_range_ratio')


# Example involving a set of trees
tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTreeSet, replace = TRUE)

# get crown clade age of clade containing taxa present in grid cell
f &lt;- function(sp) {
	ape::branching.times(phylo)[as.character(ape::getMRCA(phylo, sp))]
}

xx &lt;- customGridMetric(tamiasEPM, fun = f, minTaxCount = 2, metric = 'nodeAge')



</code></pre>

<hr>
<h2 id='dropSpecies'>Drop species from epmGrid</h2><span id='topic+dropSpecies'></span>

<h3>Description</h3>

<p>Removes particular species from a epmGrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropSpecies(x, sp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropSpecies_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="dropSpecies_+3A_sp">sp</code></td>
<td>
<p>a character vector of species names to be dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If species in <code>sp</code> are not in <code>x</code>, they will be ignored.
</p>


<h3>Value</h3>

<p>new <code>epmGrid</code> object.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM

new &lt;- dropSpecies(tamiasEPM, sp = c('Tamias_alpinus', 'Tamias_bulleri'))

setdiff(tamiasEPM[['geogSpecies']], new[['geogSpecies']])


</code></pre>

<hr>
<h2 id='DRstat'>Calculate the DR statistic</h2><span id='topic+DRstat'></span>

<h3>Description</h3>

<p>Calculates the tip-specific DR statistic for speciation rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DRstat(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DRstat_+3A_tree">tree</code></td>
<td>
<p>phylogeny of class <code>phylo</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>named numeric vector of speciation rates
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>References</h3>

<p>Jetz, W., Thomas, G. H., Joy, J. B., Hartmann, K., &amp; Mooers, A. O. (2012). 
The global diversity of birds in space and time. Nature, 491, 444–448.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasTree
DRstat(tamiasTree)

</code></pre>

<hr>
<h2 id='epm-example'>Eco Phylo Mapper datasets</h2><span id='topic+epm-example'></span><span id='topic+tamiasEPM'></span><span id='topic+tamiasPolyList'></span><span id='topic+tamiasTraits'></span><span id='topic+tamiasTree'></span><span id='topic+tamiasTreeSet'></span>

<h3>Description</h3>

<p>Included datasets in <code>epm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tamiasEPM

tamiasPolyList

tamiasTraits

tamiasTree

tamiasTreeSet
</code></pre>


<h3>Details</h3>

<p>Included north american chipmunk dataset: <br />
tamiasTree is a phylogeny for chipmunks from Zelditch et al. 2017 <br />
tamiasTreeSet is a distribution of 10 phylogenies for chipmunks, extracted
from the mammal tree from Upham et al. 2019
tamiasTraits is a geometric morphometrics dataset of mean values for 
chipmunks from Zelditch et al. 2017 <br />
tamiasPolyList is a set of geographic ranges for chimpunks from IUCN 2021.<br />
tamiasEPM is an <code>epmGrid</code> object created with <code><a href="#topic+createEPMgrid">createEPMgrid</a></code> 
using these datasets.
</p>


<h3>References</h3>

<p>Zelditch, M. L., Ye, J., Mitchell, J. S., &amp; Swiderski, D. L.
(2017). Rare ecomorphological convergence on a complex adaptive landscape:
Body size and diet mediate evolution of jaw shape in squirrels (Sciuridae).
Evolution, 1–17. https://doi.org/10.1111/evo.13168 <br />
</p>
<p>Upham, N. S., Esselstyn, J. A., &amp; Jetz, W. (2019). Inferring the mammal tree: 
Species-level sets of phylogenies for questions in ecology, evolution, and 
conservation. PLoS Biology, 17(12), e3000494. 
https://doi.org/10.1371/journal.pbio.3000494 <br />
</p>
<p>IUCN 2021. The IUCN Red List of Threatened Species. 2021-3. 
<a href="https://www.iucnredlist.org">https://www.iucnredlist.org</a>. Downloaded on 17 March 2021.
</p>

<hr>
<h2 id='epmToPhyloComm'>Convert epmGrid to community matrix</h2><span id='topic+epmToPhyloComm'></span>

<h3>Description</h3>

<p>Given specific sites, convert epmGrid to 
phylocomm matrix, with sites as rows, and species as columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epmToPhyloComm(x, sites)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="epmToPhyloComm_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="epmToPhyloComm_+3A_sites">sites</code></td>
<td>
<p>locations of sites, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If sites are site coordinates, 
then dataframe or matrix with two columns; 
if sites are cell indices, then numeric vector;
if <code>sites = 'all'</code>, then all cells will be returned as sites.
</p>


<h3>Value</h3>

<p>community matrix, with sites as rows and species as columns
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM

# from cell indices
cells &lt;- c(2703, 90, 3112, 179)
epmToPhyloComm(tamiasEPM, cells)

# from coordinates
library(sf)
# get the projection of the epmGrid object
proj &lt;- summary(tamiasEPM)$crs
# define some points
pts &lt;- rbind.data.frame(
		c(-120.5, 38.82),
		c(-84.02, 42.75),
		c(-117.95, 55.53))
colnames(pts) &lt;- c('x', 'y')
ptsSF &lt;- st_as_sf(pts, coords = 1:2, crs = "epsg:4326")
pts &lt;- st_coordinates(st_transform(ptsSF, crs = proj))

epmToPhyloComm(tamiasEPM, pts)

</code></pre>

<hr>
<h2 id='expandSpeciesCellList'>Expand species list</h2><span id='topic+expandSpeciesCellList'></span>

<h3>Description</h3>

<p>The epmGrid object contains an accounting of species per
cell in a condensed format. This function returns a complete list of species
per cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandSpeciesCellList(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandSpeciesCellList_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to expand condensed species list to full set of cells
</p>


<h3>Value</h3>

<p>list of species for each cell.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM
head(expandSpeciesCellList(tamiasEPM))

</code></pre>

<hr>
<h2 id='extractFromEpmGrid'>Extract from epmGrid</h2><span id='topic+extractFromEpmGrid'></span>

<h3>Description</h3>

<p>Return species from intersection between spatial points or
polygons and a epmGrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractFromEpmGrid(x, spatial, returnCells = FALSE, collapse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractFromEpmGrid_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="extractFromEpmGrid_+3A_spatial">spatial</code></td>
<td>
<p>coordinates as either a spatial points object (sp or sf), a
matrix/dataframe with two columns, a numeric vector of c(long, lat), or as
a spatial polygon object (sp or sf).</p>
</td></tr>
<tr><td><code id="extractFromEpmGrid_+3A_returncells">returnCells</code></td>
<td>
<p>boolean, if <code>TRUE</code>, cell indices are returned rather
than taxa</p>
</td></tr>
<tr><td><code id="extractFromEpmGrid_+3A_collapse">collapse</code></td>
<td>
<p>boolean; if <code>TRUE</code>, then a vector of unique species is
returned, pooled from all cells, if <code>FALSE</code>, then list is returned
with species from every cell as intersected by <code>spatial</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>spatial</code> is a spatial object, it will be transformed to
the same projection as <code>x</code> if needed. If <code>spatial</code> is not a
spatial object, it is assumed to be in the same projection as <code>x</code>.
</p>


<h3>Value</h3>

<p>A vector of species if <code>collapse = TRUE</code>, or a list of species
by cell if <code>collapse = FALSE</code>. If <code>returnCells = TRUE</code>, a vector
of cell indices that correspond to the rows in the epmGrid sf object.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
# get the projection of the epmGrid object
proj &lt;- summary(tamiasEPM)$crs
# define some points
pts &lt;- rbind.data.frame(
		c(-120.5, 38.82),
		c(-84.02, 42.75),
		c(-117.95, 55.53))
colnames(pts) &lt;- c('x', 'y')
ptsSF &lt;- st_as_sf(pts, coords = 1:2, crs = "epsg:4326")
pts &lt;- st_coordinates(st_transform(ptsSF, crs = proj))

# extract with table of coordinates
extractFromEpmGrid(tamiasEPM, pts)

# extract with spatial points object
extractFromEpmGrid(tamiasEPM, ptsSF)

# extract with spatial polygon
hull &lt;- st_convex_hull(st_union(ptsSF))
extractFromEpmGrid(tamiasEPM, hull)


# returns each cell's contents
extractFromEpmGrid(tamiasEPM, hull, collapse=FALSE)

# collapses results to unique set of species
extractFromEpmGrid(tamiasEPM, hull, collapse=TRUE)

</code></pre>

<hr>
<h2 id='faithPD'>Calculate Faith's Phylogenetic Diversity</h2><span id='topic+faithPD'></span>

<h3>Description</h3>

<p>Calculates Faith's PD for a specific set of tips
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faithPD(phy, tips)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="faithPD_+3A_phy">phy</code></td>
<td>
<p>phylogeny of class <code>phylo</code></p>
</td></tr>
<tr><td><code id="faithPD_+3A_tips">tips</code></td>
<td>
<p>tip names to be included</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the sum of total branch lengths that unite a 
set of species. The root is always included in these calculations. 
If tip is just one species, then the root-to-tip distance is returned.
</p>


<h3>Value</h3>

<p>numeric value of summed phylogenetic diversity
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>References</h3>

<p>Faith D.P. (1992) Conservation evaluation and phylogenetic diversity. 
Biological Conservation, 61, 1-10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasTree
faithPD(tamiasTree, c('Tamias_minimus', 'Tamias_speciosus'))

</code></pre>

<hr>
<h2 id='generateOccurrenceMatrix'>Convert epmGrid to community matrix</h2><span id='topic+generateOccurrenceMatrix'></span>

<h3>Description</h3>

<p>Given specific sites (or all sites), convert epmGrid to 
a species occurrence matrix, with sites as rows, and species as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateOccurrenceMatrix(x, sites)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateOccurrenceMatrix_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="generateOccurrenceMatrix_+3A_sites">sites</code></td>
<td>
<p>locations of sites, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If sites are site coordinates, 
then this should be a dataframe or matrix with two columns; 
if sites are cell indices, then a numeric vector;
if <code>sites = 'all'</code>, then all cells will be returned as sites. 
</p>
<p>To get the associated site coordinates, see <code><a href="#topic+coordsFromEpmGrid">coordsFromEpmGrid</a></code>.
</p>


<h3>Value</h3>

<p>a presence/absence matrix, with sites as 
rows and species as columns.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM

# from cell indices
cells &lt;- c(2703, 90, 3112, 179)
generateOccurrenceMatrix(tamiasEPM, cells)

# get the associated site coordinates
coordsFromEpmGrid(tamiasEPM, cells)

# from coordinates
library(sf)
# get the projection of the epmGrid object
proj &lt;- summary(tamiasEPM)$crs
# define some points
pts &lt;- rbind.data.frame(
		c(-120.5, 38.82),
		c(-84.02, 42.75),
		c(-117.95, 55.53))
colnames(pts) &lt;- c('x', 'y')
ptsSF &lt;- st_as_sf(pts, coords = 1:2, crs = "epsg:4326")
pts &lt;- st_coordinates(st_transform(ptsSF, crs = proj))

generateOccurrenceMatrix(tamiasEPM, pts)


</code></pre>

<hr>
<h2 id='getExtentOfList'>Get extent of list</h2><span id='topic+getExtentOfList'></span>

<h3>Description</h3>

<p>Given a list of SpatialPolygons, return an extent
object that encompasses all items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExtentOfList(shapes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getExtentOfList_+3A_shapes">shapes</code></td>
<td>
<p>a list of SpatialPolygons or simple features</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bbox</code>.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getExtentOfList(tamiasPolyList)

</code></pre>

<hr>
<h2 id='getMultiMapRamp'>Extract min and max for multiple epmGrids</h2><span id='topic+getMultiMapRamp'></span>

<h3>Description</h3>

<p>Extracts the range of values across a list of input
objects for use in plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMultiMapRamp(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMultiMapRamp_+3A_...">...</code></td>
<td>
<p>objects of class <code>epmGrid</code>, <code>RasterLayer</code>
<code>SpatRaster</code> or <code>sf</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the user would like to plot multiple epmGrid objects
with a standardized color ramp, then the returned values from this function
can be supplied to <code><a href="#topic+plot.epmGrid">plot.epmGrid</a></code>. Also works with RasterLayer
and sf objects. For sf object, only one attribute can be specified.
</p>


<h3>Value</h3>

<p>a numeric vector of length 2: overall min and max value.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
tamiasEPM

# create a dummy raster for demonstration purposes.
ras &lt;- rast()
values(ras) &lt;- runif(ncell(ras), min = 0, max = 40)

getMultiMapRamp(tamiasEPM, ras)
 
</code></pre>

<hr>
<h2 id='getSpPartialDisparities'>Partial Disparity</h2><span id='topic+getSpPartialDisparities'></span>

<h3>Description</h3>

<p>Calculate species-specific partial disparity, relative to some
group mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSpPartialDisparities(dat, groupMean = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSpPartialDisparities_+3A_dat">dat</code></td>
<td>
<p>matrix of multivariate morphological data</p>
</td></tr>
<tr><td><code id="getSpPartialDisparities_+3A_groupmean">groupMean</code></td>
<td>
<p>if <code>NULL</code>, calculated from <code>dat</code>, otherwise can
be provided as a vector of mean values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates partial disparities, as in Foote 1993. By default, the
group mean is calculated from the full input data.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasTraits[1:5, 1:5]
getSpPartialDisparities(tamiasTraits)


</code></pre>

<hr>
<h2 id='gridMetrics'>Grid Metrics</h2><span id='topic+gridMetrics'></span>

<h3>Description</h3>

<p>Calculate various morphological and phylogenetic community
metrics for every cell in a <code>epmGrid</code> object. To implement other 
metrics not available here, see <code><a href="#topic+customGridMetric">customGridMetric</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridMetrics(
  x,
  metric,
  column = NULL,
  verbose = TRUE,
  dataType = c("auto", "univariate", "multivariate", "pairwise")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gridMetrics_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="gridMetrics_+3A_metric">metric</code></td>
<td>
<p>name of metric to use, see Details.</p>
</td></tr>
<tr><td><code id="gridMetrics_+3A_column">column</code></td>
<td>
<p>If a univariate morphological metric is specified, and the data
in <code>x</code> are multivariate, which trait should be used? This can also
specify which subset of columns a multivariate metric should be applied to.</p>
</td></tr>
<tr><td><code id="gridMetrics_+3A_verbose">verbose</code></td>
<td>
<p>Print various messages to the console. Default is TRUE.</p>
</td></tr>
<tr><td><code id="gridMetrics_+3A_datatype">dataType</code></td>
<td>
<p>Specify the type of input data that the metric will be calculated from.
Defaults to <code>'auto'</code> in which case this is determined based on the data structure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Univariate trait metrics 
</p>
 
<ul>
<li><p> mean
</p>
</li>
<li><p> median
</p>
</li>
<li><p> range
</p>
</li>
<li><p> variance
</p>
</li>
<li><p> mean_NN_dist: mean nearest neighbor distance
</p>
</li>
<li><p> min_NN_dist: minimum nearest neighbor distance
</p>
</li>
<li><p> evenness: variance of nearest neighbor distances, 
larger values imply decreasing evenness
</p>
</li>
<li><p> arithmeticWeightedMean (see below)
</p>
</li>
<li><p> geometricWeightedMean (see below)
</p>
</li></ul>

<p>Multivariate trait metrics 
</p>
 
<ul>
<li><p> mean: mean of pairwise distance matrix derived from multivariate data
</p>
</li>
<li><p> median: median of pairwise distance matrix derived from multivariate data
</p>
</li>
<li><p> disparity
</p>
</li>
<li><p> partialDisparity: contribution of species in each gridcell to 
overall disparity, returned as the ratio of summed partial disparities
to total disparity.
</p>
</li>
<li><p> range
</p>
</li>
<li><p> mean_NN_dist: mean nearest neighbor distance 
</p>
</li>
<li><p> min_NN_dist: minimum nearest neighbor distance
</p>
</li>
<li><p> evenness: variance of nearest neighbor distances, 
larger values imply decreasing evenness.
</p>
</li></ul>
 
<p>Phylogenetic metrics 
</p>
 
<ul>
<li><p> pd: Faith's phylogenetic diversity, including the root
</p>
</li>
<li><p> meanPatristic
</p>
</li>
<li><p> meanPatristicNN: mean nearest neighbor in patristic distance
</p>
</li>
<li><p> minPatristicNN: minimum nearest neighbor in patristic distance
</p>
</li>
<li><p> phyloEvenness: variance of nearest neighbor patristic distances,
larger values imply decreasing evenness
</p>
</li>
<li><p> phyloDisparity: sum of squared deviations in patristic distance
</p>
</li>
<li><p> PSV: Phylogenetic Species Variability
</p>
</li>
<li><p> PSR: Phylogenetic Species Richness
</p>
</li>
<li><p> DR: non-parametric estimate of speciation rates
</p>
</li></ul>

<p>Range-weighted metrics 
</p>
 
<ul>
<li><p> weightedEndemism: Species richness inversely weighted by range size.
</p>
</li>
<li><p> correctedWeightedEndemism: Weighted endemism standardized by 
species richness
</p>
</li>
<li><p> phyloWeightedEndemism: Phylogenetic diversity inversely weighted 
by range size associated with each phylogenetic branch.
</p>
</li></ul>

<p>If data slot contains a pairwise matrix, <code>column</code> is ignored. Weighted
mean options are available where, for each cell, a weighting scheme (inverse
of species range sizes) is applied such that small-ranged species are
up-weighted, and broadly distributed species are down-weighted. This can be a
useful way to lessen the influence of broadly distributed species in the
geographic mapping of trait data.
</p>
<p>It may be desirable to have metrics calculated for a dataset where only taxa
shared across geography, traits and phylogeny are included. The function
<code><a href="#topic+reduceToCommonTaxa">reduceToCommonTaxa</a></code> does exactly that.
</p>
<p>If a set of trees are associated with the input epmGrid object <code>x</code>, 
then the metric is calculated for each tree, and a list of epmGrid objects 
is returned. This resulting list can be summarized with the function
<code><a href="#topic+summarizeEpmGridList">summarizeEpmGridList</a></code>. For instance the mean and variance can 
be calculated, to show the central tendency of the metric across grid cells, 
and to quantify where across geography variability in phylogenetic topography
manifests itself.  
</p>
<p>To implement other metrics not available here, see
<code><a href="#topic+customGridMetric">customGridMetric</a></code>.
</p>


<h3>Value</h3>

<p>object of class <code>epmGrid</code> where the grid represents calculations
of the metric at every cell. The species identities per grid cell are those
that had data for the calculation of the metric. If taxa were dropped from
the initial epmGrid object, then they have been removed from this epmGrid.
If a set of trees was involved, then returns a list of <code>epmGrid</code> objects.
</p>


<h3>References</h3>

<p>partial disparity<br /> Foote, M. (1993). Contributions of individual taxa to
overall morphological disparity. Paleobiology, 19(4), 403–419.
https://doi.org/10.1017/s0094837300014056
</p>
<p>PSV, RSV<br /> Helmus, M. R., Bland, T. J., Williams, C. K., &amp; Ives, A. R.
(2007). Phylogenetic Measures of Biodiversity. The American Naturalist,
169(3), E68–E83. https://doi.org/10.1086/511334
</p>
<p>DR<br /> Jetz, W., Thomas, G. H., Joy, J. B., Hartmann, K., &amp; Mooers, A. O.
(2012). The global diversity of birds in space and time. Nature, 491(7424),
444–448. https://doi.org/10.1038/nature11631
</p>
<p>weighted endemism<br /> Crisp, M. D., Laffan, S., Linder, H. P., &amp; Monro, A.
(2001). Endemism in the Australian flora. Journal of Biogeography, 28(2),
183–198. https://doi.org/10.1046/j.1365-2699.2001.00524.x
</p>
<p>phylo weighted endemism<br /> Rosauer, D., Laffan, S. W., Crisp, M. D.,
Donnellan, S. C., &amp; Cook, L. G. (2009). Phylogenetic endemism: a new approach
for identifying geographical concentrations of evolutionary history.
Molecular Ecology, 18(19), 4061–4072.
https://doi.org/10.1111/j.1365-294x.2009.04311.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTree)
tamiasEPM &lt;- addTraits(tamiasEPM, tamiasTraits)

# univariate morphological example
x &lt;- gridMetrics(tamiasEPM, metric='mean', column='V2')
plot(x, use_tmap = FALSE)

# multivariate morphological
x &lt;- gridMetrics(tamiasEPM, metric='disparity')
plot(x, use_tmap = FALSE)

# phylogenetic metrics
x &lt;- gridMetrics(tamiasEPM, metric='meanPatristic')
plot(x, use_tmap = FALSE)

</code></pre>

<hr>
<h2 id='identify.epmGrid'>Interactively identify species in epmGrid</h2><span id='topic+identify.epmGrid'></span>

<h3>Description</h3>

<p>Plots a epmGrid object and allows you to click on the plot
to return the species found in the cell you clicked on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epmGrid'
identify(x, returnCell = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify.epmGrid_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="identify.epmGrid_+3A_returncell">returnCell</code></td>
<td>
<p>boolean; if FALSE, then species names are returned,
if TRUE, then cell indices are returned.</p>
</td></tr>
<tr><td><code id="identify.epmGrid_+3A_...">...</code></td>
<td>
<p>additional arguments passed to sf::plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for the <code>identify</code> function
in base graphics. This is primarily intended as a useful function for 
data exploration and spot-checking.
</p>


<h3>Value</h3>

<p>A vector of species names or cell indices.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>

<hr>
<h2 id='interactiveExtent'>Interactively choose extent</h2><span id='topic+interactiveExtent'></span>

<h3>Description</h3>

<p>Given a list of polygons or point occurrences, sets up
an interactive plot	to allow the user to draw the desired extent. 
This can be used to	define the extent in <code><a href="#topic+createEPMgrid">createEPMgrid</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactiveExtent(polyList, cellType = "square", bb = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interactiveExtent_+3A_polylist">polyList</code></td>
<td>
<p>a list of Simple Feature polygons or points.</p>
</td></tr>
<tr><td><code id="interactiveExtent_+3A_celltype">cellType</code></td>
<td>
<p>either <code>hexagon</code> or <code>square</code>.</p>
</td></tr>
<tr><td><code id="interactiveExtent_+3A_bb">bb</code></td>
<td>
<p>c(xmin, xmax, ymin, ymax) to limit the extent for 
the interactive plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns both a sf polygon and the same polygon
as a WKT string. Either can be supplied to <code><a href="#topic+createEPMgrid">createEPMgrid</a></code>
as the extent. A recommended strategy is to use this function to find
your extent, and to copy/paste the WKT string into your R script so that 
you can retain it for future use, and maintain reproducibility. 
See example.
</p>
<p>What is chosen for <code>cellType</code> has no effect on what you might choose in 
<code><a href="#topic+createEPMgrid">createEPMgrid</a></code>. Square cells will probably be fastest. If hexagons
are selected, grid cell points are plotted instead of polygons to speed up plotting.
</p>
<p>You may see the message <code>Failed to compute min/max, no valid pixels found in 
		sampling. (GDAL error 1)</code> . This just means that a species did not register in any 
grid cells. This can be ignored.
</p>
<p>The basemap is from <a href="https://www.naturalearthdata.com/">https://www.naturalearthdata.com/</a>.
</p>


<h3>Value</h3>

<p>A list with a polygon, and its WKT string
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
	ex &lt;- interactiveExtent(tamiasPolyList)

	# You can use this as the extent in createEPMgrid
	grid &lt;- createEPMgrid(tamiasPolyList, resolution = 50000, extent = ex$wkt)

	# One way to make your code reproducible would be to copy/paste the wkt 
	# in your code for future use:
	ex &lt;- interactiveExtent(tamiasPolyList)
	ex$wkt
	customExtent &lt;- "POLYGON ((-2238201 3532133, -2675450 1722657, -2470677 -317634, 
	-1863632 -1854074, -521614.8 -2170280, -349356.8 799040.9, -2238201 3532133))"

	grid &lt;- createEPMgrid(tamiasPolyList, resolution = 50000, extent = customExtent)

}
</code></pre>

<hr>
<h2 id='plot.epmGrid'>Plot epmGrid</h2><span id='topic+plot.epmGrid'></span>

<h3>Description</h3>

<p>Plot a epmGrid object. This function uses the tmap package 
for plotting by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epmGrid'
plot(
  x,
  log = FALSE,
  legend = TRUE,
  col,
  basemap = "worldmap",
  colorRampRange = NULL,
  minTaxCount = "auto",
  zoom = TRUE,
  ignoredColor = gray(0.9),
  lwd,
  borderCol = "black",
  alpha = 1,
  includeFrame = FALSE,
  use_tmap = FALSE,
  fastPoints = FALSE,
  title = "",
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.epmGrid_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_log">log</code></td>
<td>
<p>boolean; should the cell values be logged?</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_legend">legend</code></td>
<td>
<p>boolean; should legend be included?</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_col">col</code></td>
<td>
<p>either a vector of color names that will be interpolated, 
or a color ramp function that takes an integer 
(see for example <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>).</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_basemap">basemap</code></td>
<td>
<p>if <code>'none'</code>, then only the grid is plotted. 
If <code>'worldmap'</code>, then vector map is plotted.
If <code>'interactive'</code>, then the plot is sent to the web browser.</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_colorramprange">colorRampRange</code></td>
<td>
<p>numeric vector of min and max value for scaling the 
color ramp. Automatically inferred if set to <code>NULL</code>. 
This is relevant if multiple plots are desired on the same scale. 
See <code><a href="#topic+getMultiMapRamp">getMultiMapRamp</a></code>.</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_mintaxcount">minTaxCount</code></td>
<td>
<p>an integer, or 'auto'. Should cells 
containing certain numbers of taxa be grayed out? For example, 
should single-taxon cells be ignored because the metric only makes sense 
for multi-taxon cells? This is predetermined for all metrics in
<code><a href="#topic+gridMetrics">gridMetrics</a></code> if  minTaxCount = 'auto'.</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_zoom">zoom</code></td>
<td>
<p>Should plot zoom in on cells with data. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_ignoredcolor">ignoredColor</code></td>
<td>
<p>color for ignored cells. See details.</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_lwd">lwd</code></td>
<td>
<p>grid cell border width</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_bordercol">borderCol</code></td>
<td>
<p>color for grid cell borders</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_alpha">alpha</code></td>
<td>
<p>opacity of all colors and borders, ranging from 0 
(fully transparent) to 1 (fully opaque)</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_includeframe">includeFrame</code></td>
<td>
<p>boolean; include frame around plot?</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_use_tmap">use_tmap</code></td>
<td>
<p>boolean; if FALSE, plotting will be done via sf 
instead of tmap package</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_fastpoints">fastPoints</code></td>
<td>
<p>Intended for debugging purposes. For hex grids and <code>use_tmap = F</code>, plot points instead of polygons. Helpful for sorting out plotting 
details without waiting for slow polygon plotting.</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_title">title</code></td>
<td>
<p>text to add to the plot</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_add">add</code></td>
<td>
<p>logical, add to existing plot?</p>
</td></tr>
<tr><td><code id="plot.epmGrid_+3A_...">...</code></td>
<td>
<p>additional arguments that can be passed to sf::plot or terra::plot 
if <code>use_tmap = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a metric as generated with <code>gridMetrics</code> 
that returns 0 for single-species cells, then those cells 
(that have a value of 0) will be plotted in gray (or any color as specified 
with <code>ignoredColor</code>) if <code>minTaxCount = 'auto'</code>. You can specify
other values as well. For instance, if you use the function
<code><a href="#topic+customGridMetric">customGridMetric</a></code> to calculate phylogenetic signal, which is 
a metric that only makes sense for cells with 3 or more taxa, then you could 
then specify <code>minTaxCount = 3</code>. Setting <code>minTaxCount = 1</code> shows all
cells with data.
</p>
<p>If the tmap package is not installed, then this function will default 
to plotting with <code>sf::plot</code>.
</p>
<p>If you would like more control over the legend, then plot with 
<code>tmap = FALSE</code> and <code>legend = FALSE</code>, and then call the function
<code><a href="#topic+addLegend">addLegend</a></code>.
</p>


<h3>Value</h3>

<p>Nothing is returned if plotting with tmap (the default). 
If plotting with <code>use_tmap = FALSE</code>, and if the plot is directed to 
a variable, then this variable will contain relevant information to be passed
on to the function <code><a href="#topic+addLegend">addLegend</a></code>:
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(tamiasEPM, use_tmap = FALSE)

plot(tamiasEPM, legend = FALSE, use_tmap = FALSE, col = viridisLite::inferno)
addLegend(tamiasEPM, location = 'top', ramp = viridisLite::inferno)

 
# Example for how to plot multiple epmGrids on the same color scale
# for illustration purposes, we will compare weighted endemism to
# phylogenetic weighted endemism
library(tmap)

tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTree)
epm1 &lt;- gridMetrics(tamiasEPM, metric='weightedEndemism')
epm2 &lt;- gridMetrics(tamiasEPM, metric='phyloWeightedEndemism')
# get global min and max values
minmax &lt;- getMultiMapRamp(epm1, epm2)

map1 &lt;- plot(epm1, colorRampRange = log(minmax), log = TRUE, legend = FALSE)
map2 &lt;- plot(epm2, colorRampRange = log(minmax), log = TRUE, legend = FALSE)
# tmap_arrange(map1, map2)

# view your plot in the web-browser as a dynamic plot.
plot(tamiasEPM, basemap = 'interactive')


# Adding a custom legend, and passing along arguments via params
xx &lt;- plot(tamiasEPM, use_tmap = FALSE, legend = FALSE, 
col = viridisLite::magma)
addLegend(tamiasEPM, params = xx, location = 'bottom')

</code></pre>

<hr>
<h2 id='plotDispersionField'>Plot dispersion fields</h2><span id='topic+plotDispersionField'></span>

<h3>Description</h3>

<p>For a set of specified coordinates, plot a richness map for 
the species that are found at those coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDispersionField(
  x,
  coords,
  plotCoords = TRUE,
  legend = TRUE,
  col,
  lwd = 0.5,
  basemap = "worldmap",
  borderCol = "black",
  alpha = 1,
  includeFrame = FALSE,
  use_tmap = FALSE,
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotDispersionField_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_coords">coords</code></td>
<td>
<p>coordinates as either a spatial points object (sp or sf), 
a matrix/dataframe with two columns or a numeric vector of c(long, lat).</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_plotcoords">plotCoords</code></td>
<td>
<p>boolean; should the coordinates be plotted as well?</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_legend">legend</code></td>
<td>
<p>boolean; should legend be included?</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_col">col</code></td>
<td>
<p>either a vector of color names that will be interpolated, 
or a color ramp function that takes an integer 
(see for example <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>).</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_lwd">lwd</code></td>
<td>
<p>grid cell border width</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_basemap">basemap</code></td>
<td>
<p>if <code>'none'</code>, then only the grid is plotted. 
If <code>'worldmap'</code>, then vector map is plotted.
If <code>'interactive'</code>, then the <code>mapview</code> package is used.</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_bordercol">borderCol</code></td>
<td>
<p>color for grid cell borders</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_alpha">alpha</code></td>
<td>
<p>opacity of all colors and borders, ranging from 0 
(fully transparent) to 1 (fully opaque)</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_includeframe">includeFrame</code></td>
<td>
<p>boolean; include frame around plot?</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_use_tmap">use_tmap</code></td>
<td>
<p>boolean; if FALSE, plotting will be done via sf instead 
of tmap package</p>
</td></tr>
<tr><td><code id="plotDispersionField_+3A_add">add</code></td>
<td>
<p>logical, add to existing plot?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assemblage dispersion fields represent an overlapping of 
geographic ranges for the taxa that occur in the focal grid cells.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>References</h3>

<p>Graves, G. R., &amp; Rahbek, C. (2005). Source pool geometry and the assembly 
of continental avifaunas. Proceedings of the National Academy of Sciences, 
102(22), 7871–7876.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plotDispersionField(tamiasEPM, c(-1944951, 69588.74))
plotDispersionField(tamiasEPM, c(-1944951, 69588.74), use_tmap = FALSE)

</code></pre>

<hr>
<h2 id='plotSpRange'>plot a single species' range</h2><span id='topic+plotSpRange'></span>

<h3>Description</h3>

<p>Plot one species' geographic range, as encoded in the epmGrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpRange(
  x,
  taxon,
  taxonColor = "orange",
  basemap = "worldmap",
  lwd = 0.5,
  alpha = 1,
  use_tmap = FALSE,
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSpRange_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="plotSpRange_+3A_taxon">taxon</code></td>
<td>
<p>taxon to plot</p>
</td></tr>
<tr><td><code id="plotSpRange_+3A_taxoncolor">taxonColor</code></td>
<td>
<p>color for plotting taxon's range</p>
</td></tr>
<tr><td><code id="plotSpRange_+3A_basemap">basemap</code></td>
<td>
<p>if <code>'none'</code>, then only the grid is plotted. 
If <code>'worldmap'</code>, then vector map is plotted.
If <code>'interactive'</code>, then the plotting is done via your web browser.</p>
</td></tr>
<tr><td><code id="plotSpRange_+3A_lwd">lwd</code></td>
<td>
<p>grid cell border width</p>
</td></tr>
<tr><td><code id="plotSpRange_+3A_alpha">alpha</code></td>
<td>
<p>opacity of all colors and borders, ranging from 0 
(fully transparent) to 1 (fully opaque)</p>
</td></tr>
<tr><td><code id="plotSpRange_+3A_use_tmap">use_tmap</code></td>
<td>
<p>if false, use sf or terra packages for plotting</p>
</td></tr>
<tr><td><code id="plotSpRange_+3A_add">add</code></td>
<td>
<p>logical. If TRUE, adds the gridded taxon range to existing plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing is returned
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM

plotSpRange(tamiasEPM, 'Tamias_speciosus', use_tmap = FALSE)

</code></pre>

<hr>
<h2 id='rasterToGrid'>Convert raster to sf grid</h2><span id='topic+rasterToGrid'></span>

<h3>Description</h3>

<p>Convert a raster to sf polygons object, matching the attributes
of the target object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToGrid(x, target, fun = "mean", crop = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rasterToGrid_+3A_x">x</code></td>
<td>
<p>rasterLayer or rasterStack or SpatRaster</p>
</td></tr>
<tr><td><code id="rasterToGrid_+3A_target">target</code></td>
<td>
<p>epmGrid or sf object</p>
</td></tr>
<tr><td><code id="rasterToGrid_+3A_fun">fun</code></td>
<td>
<p>function for summarizing raster cells to polygons</p>
</td></tr>
<tr><td><code id="rasterToGrid_+3A_crop">crop</code></td>
<td>
<p>if TRUE, the raster will be cropped to the bounding box of the target</p>
</td></tr>
<tr><td><code id="rasterToGrid_+3A_na.rm">na.rm</code></td>
<td>
<p>determines how <code>NA</code> cells are summarized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, raster cells that overlap with target grid cell polygons
will be averaged. If target is a raster grid, then <code>terra::resample</code>
is used.
</p>


<h3>Value</h3>

<p>sf polygons object, or a list of such objects if input has multiple layers.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

# We have a terra grid object (for example, climate data read in as a raster)
# Here, we are just generating some random data for demo
env &lt;- rast(vect(tamiasEPM[[1]]), resolution = 100000)
env[] &lt;- sample(1:100, ncell(env), replace = TRUE)
plot(env)

# Now, if we are interested in doing analyses of environmental data in relation to 
# the epmGrid data we have, we want to convert the env data to the same grid structure
# where the cells align and where raster grid values are resampled and averaged.

newgrid &lt;- rasterToGrid(env, target = tamiasEPM, fun = 'mean')
plot(newgrid)


# again but this time the input has multiple layers
env &lt;- rast(vect(tamiasEPM[[1]]), resolution = 100000, nlyr = 3)
values(env[[1]]) &lt;- sample(1:100, ncell(env), replace = TRUE)
values(env[[2]]) &lt;- sample(1:200, ncell(env), replace = TRUE)
values(env[[3]]) &lt;- sample(1:300, ncell(env), replace = TRUE)

newgrid &lt;- rasterToGrid(env, target = tamiasEPM, fun = 'mean')






</code></pre>

<hr>
<h2 id='read.epmGrid'>Read a epmGrid object</h2><span id='topic+read.epmGrid'></span>

<h3>Description</h3>

<p>Load a saved epmGrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.epmGrid(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.epmGrid_+3A_filename">filename</code></td>
<td>
<p>filename, with extension <code>rds</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will read in epmGrid objects that
were saved with <code><a href="#topic+write.epmGrid">write.epmGrid</a></code>.
</p>


<h3>Value</h3>

<p>object of class epmGrid
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#save
write.epmGrid(tamiasEPM, paste0(tempdir(), '/tamiasEPM'))

# read back in
tamiasEPM &lt;- read.epmGrid(paste0(tempdir(), '/tamiasEPM.rds'))

# delete the file
unlink(paste0(tempdir(), '/tamiasEPM.rds'))

</code></pre>

<hr>
<h2 id='reduceToCommonTaxa'>Subset epmGrid to shared taxa</h2><span id='topic+reduceToCommonTaxa'></span>

<h3>Description</h3>

<p>An epmGrid object may contain more taxa with morphological
data than taxa with phylogenetic information, or vice versa. This 
function subsets all epmGrid components to the set of taxa shared 
across geographic, phenotypic and phylogenetic datasets. This might
desirable to ensure that all diversity metrics are based on the same 
set of taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceToCommonTaxa(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduceToCommonTaxa_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>new <code>epmGrid</code> object.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tamiasEPM
# randomly drop a few species for demonstration
tamiasEPM &lt;- addPhylo(tamiasEPM, ape::drop.tip(tamiasTree, sample(tamiasTree$tip.label, 5)))
tamiasEPM &lt;- addTraits(tamiasEPM, tamiasTraits[-(3:5),])

new &lt;- reduceToCommonTaxa(tamiasEPM)

tamiasEPM
new


</code></pre>

<hr>
<h2 id='singleSpCellIndex'>Identify single-species cells</h2><span id='topic+singleSpCellIndex'></span>

<h3>Description</h3>

<p>Given a epmGrid object, return the grid cell indices
of those cells that have just one species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singleSpCellIndex(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="singleSpCellIndex_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be useful when further analyzing epmGrid
objects generated by <code><a href="#topic+gridMetrics">gridMetrics</a></code>, as it might
make sense to exclude these single-species cells in further analyses.
</p>


<h3>Value</h3>

<p>numeric vector of grid cell indices.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>singleSpCellIndex(tamiasEPM)

</code></pre>

<hr>
<h2 id='spCountIndex'>Identify cells that have a certain number of taxa</h2><span id='topic+spCountIndex'></span>

<h3>Description</h3>

<p>Given a epmGrid object, return the grid cell indices
of those cells that have the specified number of taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spCountIndex(x, count)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spCountIndex_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="spCountIndex_+3A_count">count</code></td>
<td>
<p>number of species to consider (can be a vector of integers)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be useful when further analyzing epmGrid
objects generated by <code><a href="#topic+gridMetrics">gridMetrics</a></code>, as it might
make sense to exclude certain grid cells in further analyses.
</p>


<h3>Value</h3>

<p>numeric vector of grid cell indices.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spCountIndex(tamiasEPM, count = 1)
spCountIndex(tamiasEPM, count = 1:3)

</code></pre>

<hr>
<h2 id='summarizeEpmGridList'>Summarize lists of epmGrid objects</h2><span id='topic+summarizeEpmGridList'></span>

<h3>Description</h3>

<p>If a diversity metric was calculated for an epmGrid object
that contained a phylogenetic distribution, then a list of resulting
epmGrid objects was returned. This function will take that list, and 
apply a summary statistic, returning a single epmGrid object. 
If the input list is from <code><a href="#topic+betadiv_phylogenetic">betadiv_phylogenetic</a></code>, then that
list of sf or SpatRaster objects can also be summarized with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeEpmGridList(x, fun = mean)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarizeEpmGridList_+3A_x">x</code></td>
<td>
<p>a list of objects of class <code>epmGrid</code> or <code>sf</code> or <code>SpatRaster</code>.</p>
</td></tr>
<tr><td><code id="summarizeEpmGridList_+3A_fun">fun</code></td>
<td>
<p>a function to apply to grid cells across the list x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that across the objects in list x,
the only difference is the values for the grid cells.
</p>


<h3>Value</h3>

<p>a single object of class <code>epmGrid</code> or <code>sf</code> or <code>SpatRaster</code>.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTreeSet)
tamiasEPM &lt;- addTraits(tamiasEPM, tamiasTraits)

x &lt;- gridMetrics(tamiasEPM, metric='meanPatristicNN')
z &lt;- summarizeEpmGridList(x, fun = var)

# using a custom function
f &lt;- function(y) sum(y) / length(y)

z &lt;- summarizeEpmGridList(x, fun = f)

# works with square grid epmGrids too
tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000, 
	cellType = 'square', method = 'centroid')
tamiasEPM2 &lt;- addPhylo(tamiasEPM2, tamiasTreeSet)
tamiasEPM2 &lt;- addTraits(tamiasEPM2, tamiasTraits)

x &lt;- gridMetrics(tamiasEPM2, metric='meanPatristicNN')

z &lt;- summarizeEpmGridList(x, fun = median)


# With phylogenetic distribution

tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTreeSet, replace = TRUE)
beta_phylo_turnover &lt;- betadiv_phylogenetic(tamiasEPM, radius = 70000,
	component = 'turnover')

z &lt;- summarizeEpmGridList(beta_phylo_turnover)

tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
	cellType = 'square', method = 'centroid')
tamiasEPM2 &lt;- addPhylo(tamiasEPM2, tamiasTreeSet)

beta_phylo_turnover &lt;- betadiv_phylogenetic(tamiasEPM2, radius = 70000,
		component = 'turnover')

z &lt;- summarizeEpmGridList(beta_phylo_turnover, fun = median)



</code></pre>

<hr>
<h2 id='summary.epmGrid'>epmGrid summary</h2><span id='topic+summary.epmGrid'></span>

<h3>Description</h3>

<p>Generates a summary of a epmGrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epmGrid'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.epmGrid_+3A_object">object</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="summary.epmGrid_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+summary">summary</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summary information includes
</p>


<h3>Value</h3>

<p>A list containing the summary information is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(tamiasEPM)
attr &lt;- summary(tamiasEPM)
attr

</code></pre>

<hr>
<h2 id='tableFromEpmGrid'>Data table from epmGrid</h2><span id='topic+tableFromEpmGrid'></span>

<h3>Description</h3>

<p>Given one or several epmGrid objects, sf objects, rasterLayers,
SpatRasters, create a table of values and associated coordinate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableFromEpmGrid(..., n = NULL, minTaxCount = 1, coords = NULL, id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tableFromEpmGrid_+3A_...">...</code></td>
<td>
<p>objects of class <code>epmGrid</code>, <code>sf</code>, <code>sp</code>,
<code>SpatRaster</code>, <code>RasterLayer</code> or <code>RasterStack</code>. All should
have the same projection.</p>
</td></tr>
<tr><td><code id="tableFromEpmGrid_+3A_n">n</code></td>
<td>
<p>number of cells to randomly subsample, no subsampling if <code>NULL</code></p>
</td></tr>
<tr><td><code id="tableFromEpmGrid_+3A_mintaxcount">minTaxCount</code></td>
<td>
<p>integer; cells with at least this many taxa will be included.</p>
</td></tr>
<tr><td><code id="tableFromEpmGrid_+3A_coords">coords</code></td>
<td>
<p>if NULL, then points are sampled as needed, otherwise, data
will be extracted at these specified coordinates.</p>
</td></tr>
<tr><td><code id="tableFromEpmGrid_+3A_id">id</code></td>
<td>
<p>boolean, should the grid cell index (of the first item in the inputs) be returned as well?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of cells are identified in the input objects. If
<code>n=NULL</code>, then all cells are used, otherwise cells are randomly
subsampled. Values at those cells are then returned. This table
construction can be particularly useful for subsequent statistical
analyses.
</p>
<p>Only cells with data in all inputs are returned. If n is greater than the
number of cells with data, then fewer than n cells will be returned.
</p>
<p>The first element provided should be a <code>epmGrid</code> object, and that will
be the one used as a template for the sampled grid system.
</p>
<p>If <code>coords</code> is provided, then data are extracted at those coordinates,
and no subsetting of those points is done.
</p>


<h3>Value</h3>

<p>data.frame with input variables, as well as <code>"x"</code> and
<code>"y"</code>.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tamiasEPM
tamiasEPM &lt;- addPhylo(tamiasEPM, tamiasTree)
tamiasEPM &lt;- addTraits(tamiasEPM, tamiasTraits)
morphoDisp &lt;- gridMetrics(tamiasEPM, metric='disparity')
meanPat &lt;- gridMetrics(tamiasEPM, metric='meanPatristic')

tableFromEpmGrid(tamiasEPM, morphoDisp, meanPat, n = 100, 
minTaxCount = 2)

# this time request grid cell ID's, which would be useful
# for linking this table back to the grid system
tableFromEpmGrid(tamiasEPM, morphoDisp, meanPat, n = 100, 
minTaxCount = 2, id = TRUE)

# from predetermined set of coordinates
pts &lt;- sf::st_sample(tamiasEPM[[1]], size = 10)
tableFromEpmGrid(tamiasEPM, morphoDisp, meanPat, n = 100, 
minTaxCount = 1, coords = pts)

</code></pre>

<hr>
<h2 id='write.epmGrid'>Save epmGrid object</h2><span id='topic+write.epmGrid'></span>

<h3>Description</h3>

<p>Write a epmGrid object to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.epmGrid(x, filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.epmGrid_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="write.epmGrid_+3A_filename">filename</code></td>
<td>
<p>filename with no extension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function writes a .rds file with xz compression. 
This file can be read back in with <code><a href="#topic+read.epmGrid">read.epmGrid</a></code>.
</p>


<h3>Value</h3>

<p>Nothing is returned, but object is written to disk.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#save
write.epmGrid(tamiasEPM, paste0(tempdir(), '/tamiasEPM'))

# read back in
tamiasEPM &lt;- read.epmGrid(paste0(tempdir(), '/tamiasEPM.rds'))

# delete the file
unlink(paste0(tempdir(), '/tamiasEPM.rds'))


</code></pre>

<hr>
<h2 id='writeEpmSpatial'>Write epmGrid Spatial Object to Disk</h2><span id='topic+writeEpmSpatial'></span>

<h3>Description</h3>

<p>Writes the grid to disk for use in other GIS applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeEpmSpatial(x, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeEpmSpatial_+3A_x">x</code></td>
<td>
<p>object of class <code>epmGrid</code></p>
</td></tr>
<tr><td><code id="writeEpmSpatial_+3A_filename">filename</code></td>
<td>
<p>filename to be written to, with the appropriate file
extension</p>
</td></tr>
<tr><td><code id="writeEpmSpatial_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="sf.html#topic+st_write">st_write</a></code> or
<code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For hexagonal grid systems, appending .shp to the filename will
result in a shapefile, whereas appending .gpkg results in a geopackage
file. See <code><a href="sf.html#topic+st_write">st_write</a></code> for additional options. For square
grid cells, appending .tif will result in a GeoTiff file being written to
disk. If no extensions are included with the filename, then this function
will default to geopackage files for hexagonal grids and GeoTiffs for
square grids.
</p>


<h3>Value</h3>

<p>the object is written to disk, nothing is returned.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tamiasEPM
tamiasEPM2 &lt;- createEPMgrid(tamiasPolyList, resolution = 50000,
cellType = 'square', method = 'centroid')
writeEpmSpatial(tamiasEPM, filename = paste0(tempdir(), '/tamiasGrid.shp'))
writeEpmSpatial(tamiasEPM, filename = paste0(tempdir(), '/tamiasGrid.gpkg'))
unlink(paste0(tempdir(), '/tamiasGrid.gpkg'))
# will automatically append .gpkg
writeEpmSpatial(tamiasEPM, filename = paste0(tempdir(), '/tamiasGrid')) 

writeEpmSpatial(tamiasEPM2, filename = paste0(tempdir(), '/tamiasGrid.tif'))
unlink(paste0(tempdir(), '/tamiasGrid.tif'))
# will automatically append .tif
writeEpmSpatial(tamiasEPM2, filename = paste0(tempdir(), '/tamiasGrid'))

# remove files generated by example
unlink(paste0(tempdir(), '/tamiasGrid', c('.dbf', '.gpkg', '.prj', '.shp', '.shx', '.tif')))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
