<!DOCTYPE html><html lang="en"><head><title>Help for package RPMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RPMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#betaEst'><p>Beta Distribution Maximum Likelihood Estimator</p></a></li>
<li><a href='#betaEstMultiple'><p>Beta Maximum Likelihood on a Matrix</p></a></li>
<li><a href='#betaObjf'><p>Beta Maximum Likelihood Objective Function</p></a></li>
<li><a href='#blc'><p>Beta Latent Class Model</p></a></li>
<li><a href='#blcInitializeSplitDichotomizeUsingMean'><p>Initialize Gaussian Latent Class via Mean Dichotomization</p></a></li>
<li><a href='#blcInitializeSplitEigen'><p>Initialize Gaussian Latent Class via Eigendecomposition</p></a></li>
<li><a href='#blcInitializeSplitFanny'><p>Initialize Beta Latent Class via Fanny</p></a></li>
<li><a href='#blcInitializeSplitHClust'><p>Initialize Beta Latent Class via Hierarchical Clustering</p></a></li>
<li><a href='#blcSplit'><p>Beta Latent Class Splitter</p></a></li>
<li><a href='#blcSplitCriterionBIC'><p>Beta RPMM Split Criterion: Use BIC</p></a></li>
<li><a href='#blcSplitCriterionBICICL'><p>Beta RPMM Split Criterion: Use ICL-BIC</p></a></li>
<li><a href='#blcSplitCriterionJustRecordEverything'><p>Beta RPMM Split Criterion: Always Split and Record Everything</p></a></li>
<li><a href='#blcSplitCriterionLevelWtdBIC'><p>Beta RPMM Split Criterion:  Level-Weighted BIC</p></a></li>
<li><a href='#blcSplitCriterionLRT'><p>Beta RPMM Split Criterion: use likelihood ratio test p value</p></a></li>
<li><a href='#blcSubTree'><p>Beta Subtree</p></a></li>
<li><a href='#blcTree'><p> Beta RPMM Tree</p></a></li>
<li><a href='#blcTreeApply'><p>Recursive Apply Function for Beta RPMM Objects</p></a></li>
<li><a href='#blcTreeLeafClasses'><p>Posterior Class Assignments for Beta RPMM</p></a></li>
<li><a href='#blcTreeLeafMatrix'><p>Posterior Weight Matrix for Beta RPMM</p></a></li>
<li><a href='#blcTreeOverallBIC'><p>Overall BIC for Entire RPMM Tree (Beta version)</p></a></li>
<li><a href='#ebayes'><p>Empirical Bayes predictions for a specific RPMM model</p></a></li>
<li><a href='#gaussEstMultiple'><p>Gaussian Maximum Likelihood on a Matrix</p></a></li>
<li><a href='#glc'><p>Gaussian Finite Mixture Model</p></a></li>
<li><a href='#glcInitializeSplitEigen'><p>Initialize Gaussian Latent Class via Eigendecomposition</p></a></li>
<li><a href='#glcInitializeSplitFanny'><p>Initialize Gaussian Latent Class via Fanny</p></a></li>
<li><a href='#glcInitializeSplitHClust'><p>Initialize Gaussian Latent Class via Hierarchical Clustering</p></a></li>
<li><a href='#glcSplit'><p>Gaussian Latent Class Splitter</p></a></li>
<li><a href='#glcSplitCriterionBIC'><p>Gaussian RPMM Split Criterion: Use BIC</p></a></li>
<li><a href='#glcSplitCriterionBICICL'><p>Gaussian RPMM Split Criterion: Use ICL-BIC</p></a></li>
<li><a href='#glcSplitCriterionJustRecordEverything'><p>Gaussian RPMM Split Criterion: Always Split and Record Everything</p></a></li>
<li><a href='#glcSplitCriterionLevelWtdBIC'><p>Gaussian RPMM Split Criterion:  Level-Weighted BIC</p></a></li>
<li><a href='#glcSplitCriterionLRT'><p>Gaussian RPMM Split Criterion: Use likelihood ratio test p value</p></a></li>
<li><a href='#glcSubTree'><p>Gaussian Subtree</p></a></li>
<li><a href='#glcTree'><p> Gaussian RPMM Tree</p></a></li>
<li><a href='#glcTreeApply'><p>Recursive Apply Function for Gaussian RPMM Objects</p></a></li>
<li><a href='#glcTreeLeafClasses'><p>Posterior Class Assignments for Gaussian RPMM</p></a></li>
<li><a href='#glcTreeLeafMatrix'><p>Posterior Weight Matrix for Gaussian RPMM</p></a></li>
<li><a href='#glcTreeOverallBIC'><p>Overall BIC for Entire RPMM Tree (Gaussian version)</p></a></li>
<li><a href='#glmLC'><p>Weighted GLM for latent class covariates</p></a></li>
<li><a href='#IlluminaMethylation'><p>DNA Methylation Data for Normal Tissue Types</p></a></li>
<li><a href='#llikeRPMMObject'><p>Data log-likelihood implied by a specific RPMM model</p></a></li>
<li><a href='#plot.blcTree'><p>Plot a Beta RPMM Tree Profile</p></a></li>
<li><a href='#plot.glcTree'><p>Plot a Gaussian RPMM Tree Profile</p></a></li>
<li><a href='#plotImage.blcTree'><p>Plot a Beta RPMM Tree Profile</p></a></li>
<li><a href='#plotImage.glcTree'><p>Plot a Gaussian RPMM Tree Profile</p></a></li>
<li><a href='#plotTree.blcTree'><p>Plot a Beta RPMM Tree Dendrogram</p></a></li>
<li><a href='#plotTree.glcTree'><p>Plot a Gaussian RPMM Tree Dendrogram</p></a></li>
<li><a href='#predict.blcTree'><p>Predict using a Beta RPMM object</p></a></li>
<li><a href='#predict.glcTree'><p>Predict using a Gaussian RPMM object</p></a></li>
<li><a href='#print.blcTree'><p>Print a Beta RPMM object</p></a></li>
<li><a href='#print.glcTree'><p>Print a Gaussian RPMM object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Recursively Partitioned Mixture Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.25</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-02-28</td>
</tr>
<tr>
<td>Author:</td>
<td>E. Andres Houseman, Sc.D. and Devin C. Koestler, Ph.D.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>E. Andres Houseman &lt;eahouseman@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.3.12), cluster</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Recursively Partitioned Mixture Model for Beta and Gaussian Mixtures.  
    This is a model-based clustering algorithm that returns a hierarchy
    of classes, similar to hierarchical clustering, but also similar to
    finite mixture models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-02-28 17:51:47 UTC; housemae</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-02-28 23:05:39</td>
</tr>
</table>
<hr>
<h2 id='betaEst'>Beta Distribution Maximum Likelihood Estimator</h2><span id='topic+betaEst'></span>

<h3>Description</h3>

<p>Estimates a beta distribution via Maximum Likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaEst(y, w, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betaEst_+3A_y">y</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="betaEst_+3A_w">w</code></td>
<td>
<p>posterior weights</p>
</td></tr>
<tr><td><code id="betaEst_+3A_weights">weights</code></td>
<td>
<p>case weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically not be called by user.
</p>


<h3>Value</h3>

<p>(a,b) parameters
</p>

<hr>
<h2 id='betaEstMultiple'>Beta Maximum Likelihood on a Matrix</h2><span id='topic+betaEstMultiple'></span>

<h3>Description</h3>

<p>Maximum likelihood estimator for beta model on matrix of values
(columns having different, independent beta distributions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaEstMultiple(Y, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betaEstMultiple_+3A_y">Y</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="betaEstMultiple_+3A_weights">weights</code></td>
<td>
<p>case weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of beta parameters and BIC
</p>

<hr>
<h2 id='betaObjf'>Beta Maximum Likelihood Objective Function</h2><span id='topic+betaObjf'></span>

<h3>Description</h3>

<p>Objective function for fitting a beta model using maximum likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaObjf(logab, ydata, wdata, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betaObjf_+3A_logab">logab</code></td>
<td>
<p>log(a,b) parameters</p>
</td></tr>
<tr><td><code id="betaObjf_+3A_ydata">ydata</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="betaObjf_+3A_wdata">wdata</code></td>
<td>
<p>posterior weights</p>
</td></tr>
<tr><td><code id="betaObjf_+3A_weights">weights</code></td>
<td>
<p>case weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically not be called by user.
</p>


<h3>Value</h3>

<p>negative log-likelihood
</p>

<hr>
<h2 id='blc'>Beta Latent Class Model</h2><span id='topic+blc'></span>

<h3>Description</h3>

<p>Fits a beta mixture model for any number of classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blc(Y, w, maxiter = 25, tol = 1e-06, weights = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blc_+3A_y">Y</code></td>
<td>
<p>Data matrix (n x j) on which to perform clustering</p>
</td></tr>
<tr><td><code id="blc_+3A_w">w</code></td>
<td>
<p>Initial weight matrix (n x k) representing classification</p>
</td></tr>
<tr><td><code id="blc_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of EM iterations</p>
</td></tr>
<tr><td><code id="blc_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance</p>
</td></tr>
<tr><td><code id="blc_+3A_weights">weights</code></td>
<td>
<p>Case weights</p>
</td></tr>
<tr><td><code id="blc_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically not be called by user.
</p>


<h3>Value</h3>

<p>A list of parameters representing mixture model fit, including posterior weights and log-likelihood
</p>

<hr>
<h2 id='blcInitializeSplitDichotomizeUsingMean'>Initialize Gaussian Latent Class via Mean Dichotomization</h2><span id='topic+blcInitializeSplitDichotomizeUsingMean'></span>

<h3>Description</h3>

<p>Creates a function for initializing latent class model by dichotomizing via mean over all responses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcInitializeSplitDichotomizeUsingMean(threshold = 0.5, fuzz = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcInitializeSplitDichotomizeUsingMean_+3A_threshold">threshold</code></td>
<td>
<p>Mean threshold for determining class</p>
</td></tr>
<tr><td><code id="blcInitializeSplitDichotomizeUsingMean_+3A_fuzz">fuzz</code></td>
<td>
<p>&ldquo;fuzz&rdquo; factor for producing imperfectly clustered subjects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a function <code>f(x)</code> that will take a data matrix <code>x</code> and 
initialize a weight matrix for a two-class latent class model.
Here, a simple threshold will be applied to the mean over all item responses.
See <code><a href="#topic+blcTree">blcTree</a></code> for example of using &ldquo;blcInitializeSplit...&rdquo; to create starting values.
</p>


<h3>Value</h3>

<p>A function <code>f(x)</code> (see Details.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glcInitializeSplitFanny">glcInitializeSplitFanny</a></code>, 
<code><a href="#topic+glcInitializeSplitHClust">glcInitializeSplitHClust</a></code></p>

<hr>
<h2 id='blcInitializeSplitEigen'>Initialize Gaussian Latent Class via Eigendecomposition</h2><span id='topic+blcInitializeSplitEigen'></span>

<h3>Description</h3>

<p>Creates a function for initializing latent class model based on Eigendecomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcInitializeSplitEigen(eigendim = 1, 
    assignmentf = function(s) (rank(s) - 0.5)/length(s))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcInitializeSplitEigen_+3A_eigendim">eigendim</code></td>
<td>
<p>How many eigenvalues to use</p>
</td></tr>
<tr><td><code id="blcInitializeSplitEigen_+3A_assignmentf">assignmentf</code></td>
<td>
<p>assignment function for transforming eigenvector to weight</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a function <code>f(x)</code> that will take a data matrix <code>x</code> and 
initialize a weight matrix for a two-class latent class model.
Here, the initialized classes will be based on eigendecomposition of the variance of <code>x</code>.
See <code><a href="#topic+blcTree">blcTree</a></code> for example of using &ldquo;blcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<p>A function <code>f(x)</code> (see Details.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blcInitializeSplitDichotomizeUsingMean">blcInitializeSplitDichotomizeUsingMean</a></code>, 
<code><a href="#topic+glcInitializeSplitFanny">glcInitializeSplitFanny</a></code>, 
<code><a href="#topic+glcInitializeSplitHClust">glcInitializeSplitHClust</a></code></p>

<hr>
<h2 id='blcInitializeSplitFanny'>Initialize Beta Latent Class via Fanny</h2><span id='topic+blcInitializeSplitFanny'></span>

<h3>Description</h3>

<p>Creates a function for initializing latent class model using the <code>fanny</code> algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcInitializeSplitFanny(nu = 2, nufac = 0.875, metric = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcInitializeSplitFanny_+3A_nu">nu</code></td>
<td>
<p><code>memb.exp</code> parameter in <code>fanny</code></p>
</td></tr>
<tr><td><code id="blcInitializeSplitFanny_+3A_nufac">nufac</code></td>
<td>
<p>Factor by which to multiply <code>nu</code> if an error occurs</p>
</td></tr>
<tr><td><code id="blcInitializeSplitFanny_+3A_metric">metric</code></td>
<td>
<p>Metric to use for <code>fanny</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a function <code>f(x)</code> that will take a data matrix <code>x</code> and 
initialize a weight matrix for a two-class latent class model.
Here, the &ldquo;fanny&rdquo; algorithm will be used.
See <code><a href="#topic+blcTree">blcTree</a></code> for example of using &ldquo;blcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<p>A function <code>f(x)</code> (see Details.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blcInitializeSplitDichotomizeUsingMean">blcInitializeSplitDichotomizeUsingMean</a></code>, 
<code><a href="#topic+blcInitializeSplitEigen">blcInitializeSplitEigen</a></code>, 
<code><a href="#topic+blcInitializeSplitHClust">blcInitializeSplitHClust</a></code></p>

<hr>
<h2 id='blcInitializeSplitHClust'>Initialize Beta Latent Class via Hierarchical Clustering</h2><span id='topic+blcInitializeSplitHClust'></span>

<h3>Description</h3>

<p>Creates a function for initializing latent class model using hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcInitializeSplitHClust(metric = "manhattan", method = "ward")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcInitializeSplitHClust_+3A_metric">metric</code></td>
<td>
<p>Dissimilarity metric used for hierarchical clustering</p>
</td></tr>
<tr><td><code id="blcInitializeSplitHClust_+3A_method">method</code></td>
<td>
<p>Linkage method used for hierarchical clustering</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a function <code>f(x)</code> that will take a data matrix <code>x</code> and 
initialize a weight matrix for a two-class latent class model.
Here, a two-branch split from hierarchical clustering will be used.
See <code><a href="#topic+blcTree">blcTree</a></code> for example of using &ldquo;blcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<p>A function <code>f(x)</code> (see Details.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blcInitializeSplitDichotomizeUsingMean">blcInitializeSplitDichotomizeUsingMean</a></code>, 
<code><a href="#topic+blcInitializeSplitEigen">blcInitializeSplitEigen</a></code>, 
<code><a href="#topic+blcInitializeSplitFanny">blcInitializeSplitFanny</a></code></p>

<hr>
<h2 id='blcSplit'>Beta Latent Class Splitter</h2><span id='topic+blcSplit'></span>

<h3>Description</h3>

<p>Splits a data set into two via a beta mixture model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcSplit(x, initFunctions, weight = NULL, index = NULL, level = NULL, 
    wthresh = 1e-09, verbose = TRUE, nthresh = 5, 
    splitCriterion = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcSplit_+3A_x">x</code></td>
<td>
<p>Data matrix (n x j) on which to perform clustering</p>
</td></tr>
<tr><td><code id="blcSplit_+3A_initfunctions">initFunctions</code></td>
<td>
<p>List of functions of type &ldquo;blcInitialize...&rdquo; for initializing latent class model.
See <code>blcInitializeFanny</code> for an example of arguments and return values.</p>
</td></tr>
<tr><td><code id="blcSplit_+3A_weight">weight</code></td>
<td>
<p>Weight corresponding to the indices passed (see <code>index</code>). Defaults to 1 for all indices</p>
</td></tr>
<tr><td><code id="blcSplit_+3A_index">index</code></td>
<td>
<p>Row indices of data matrix to include. Defaults to all (1 to n).</p>
</td></tr>
<tr><td><code id="blcSplit_+3A_level">level</code></td>
<td>
<p> Current level. </p>
</td></tr>
<tr><td><code id="blcSplit_+3A_wthresh">wthresh</code></td>
<td>
<p>Weight threshold for filtering data to children. 
Indices having weight less than this value will not be passed to children nodes.</p>
</td></tr>
<tr><td><code id="blcSplit_+3A_verbose">verbose</code></td>
<td>
<p>Level of verbosity.  Default=2 (too much).  0 for quiet.</p>
</td></tr>
<tr><td><code id="blcSplit_+3A_nthresh">nthresh</code></td>
<td>
<p>Total weight in node required for node to be a candidate for splitting.  
Nodes with weight less than this value will never split.</p>
</td></tr>
<tr><td><code id="blcSplit_+3A_splitcriterion">splitCriterion</code></td>
<td>
<p>Function of type &ldquo;blcSplitCriterion...&rdquo; for determining whether split should occur.
See <code>blcSplitCriterionBIC</code> for an example of arguments and return values. Default behavior is <code>blcSplitCriterionBIC</code> (though the function is bypassed by internal calculations for some modest computational efficiency gains).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Should not be called by user.
</p>


<h3>Value</h3>

<p>A list of objects representing split.
</p>

<hr>
<h2 id='blcSplitCriterionBIC'>Beta RPMM Split Criterion: Use BIC</h2><span id='topic+blcSplitCriterionBIC'></span>

<h3>Description</h3>

<p>Split criterion function:  compare BICs to determine split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcSplitCriterionBIC(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcSplitCriterionBIC_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBIC_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBIC_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBIC_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBIC_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBIC_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;glcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
See <code><a href="#topic+blcTree">blcTree</a></code> for example of using &ldquo;blcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bic1</code></td>
<td>
<p>one-class (weighted) BIC</p>
</td></tr>
<tr><td><code>bic2</code></td>
<td>
<p>two-class (weighted) BIC</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+blcSplitCriterionBIC">blcSplitCriterionBIC</a></code>, 
<code><a href="#topic+blcSplitCriterionJustRecordEverything">blcSplitCriterionJustRecordEverything</a></code>, 
<code><a href="#topic+blcSplitCriterionLevelWtdBIC">blcSplitCriterionLevelWtdBIC</a></code>, 
<code><a href="#topic+blcSplitCriterionLRT">blcSplitCriterionLRT</a></code></p>

<hr>
<h2 id='blcSplitCriterionBICICL'>Beta RPMM Split Criterion: Use ICL-BIC</h2><span id='topic+blcSplitCriterionBICICL'></span>

<h3>Description</h3>

<p>Split criterion function:  compare ICL-BICs to determine split (i.e. include entropy term in comparison).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcSplitCriterionBICICL(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcSplitCriterionBICICL_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBICICL_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBICICL_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBICICL_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBICICL_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionBICICL_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;glcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
See <code><a href="#topic+blcTree">blcTree</a></code> for example of using &ldquo;blcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bic1</code></td>
<td>
<p>one-class (weighted) BIC</p>
</td></tr>
<tr><td><code>bic2</code></td>
<td>
<p>two-class (weighted) BIC</p>
</td></tr>
<tr><td><code>entropy</code></td>
<td>
<p>two-class entropy</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+blcSplitCriterionBICICL">blcSplitCriterionBICICL</a></code>, 
<code><a href="#topic+blcSplitCriterionJustRecordEverything">blcSplitCriterionJustRecordEverything</a></code>, 
<code><a href="#topic+blcSplitCriterionLevelWtdBIC">blcSplitCriterionLevelWtdBIC</a></code>, 
<code><a href="#topic+blcSplitCriterionLRT">blcSplitCriterionLRT</a></code></p>

<hr>
<h2 id='blcSplitCriterionJustRecordEverything'>Beta RPMM Split Criterion: Always Split and Record Everything</h2><span id='topic+blcSplitCriterionJustRecordEverything'></span>

<h3>Description</h3>

<p>Split criterion function: always split, but record everything as you go.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcSplitCriterionJustRecordEverything(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcSplitCriterionJustRecordEverything_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionJustRecordEverything_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionJustRecordEverything_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionJustRecordEverything_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionJustRecordEverything_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionJustRecordEverything_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;glcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
This function ALWAYS returns <code>split=TRUE</code>.  Useful for gathering information.
It is recommended that you set the <code>maxlev</code> argument in the main function to something
less than infinity (say, 3 or 4).
See <code><a href="#topic+blcTree">blcTree</a></code> for example of using &ldquo;blcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>llike1</code></td>
<td>
<p>Just returns <code>llike1</code></p>
</td></tr>
<tr><td><code>llike2</code></td>
<td>
<p>Just returns <code>llike2</code></p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>Just returns <code>J</code></p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>Just returns <code>weight</code></p>
</td></tr>
<tr><td><code>ww</code></td>
<td>
<p>Just returns <code>ww</code></p>
</td></tr>
<tr><td><code>degFreedom</code></td>
<td>
<p>Degrees-of-freedom for LRT</p>
</td></tr>  
<tr><td><code>chiSquareStat</code></td>
<td>
<p>Chi-square statistic</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+blcSplitCriterionBIC">blcSplitCriterionBIC</a></code>, 
<code><a href="#topic+blcSplitCriterionBICICL">blcSplitCriterionBICICL</a></code>, 
<code><a href="#topic+blcSplitCriterionLevelWtdBIC">blcSplitCriterionLevelWtdBIC</a></code>, 
<code><a href="#topic+blcSplitCriterionLRT">blcSplitCriterionLRT</a></code></p>

<hr>
<h2 id='blcSplitCriterionLevelWtdBIC'>Beta RPMM Split Criterion:  Level-Weighted BIC</h2><span id='topic+blcSplitCriterionLevelWtdBIC'></span>

<h3>Description</h3>

<p>Split criterion function: use a level-weighted version of BIC to determine split; there is an additional penalty incorporated for deep recursion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcSplitCriterionLevelWtdBIC(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcSplitCriterionLevelWtdBIC_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLevelWtdBIC_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLevelWtdBIC_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLevelWtdBIC_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLevelWtdBIC_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLevelWtdBIC_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;glcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
See <code><a href="#topic+blcTree">blcTree</a></code> for example of using &ldquo;blcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bic1</code></td>
<td>
<p>One-class BIC, with additional penalty for deeper levels</p>
</td></tr>
<tr><td><code>bic2</code></td>
<td>
<p>Two-class BIC, with additional penalty for deeper levels</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+blcSplitCriterionBIC">blcSplitCriterionBIC</a></code>, 
<code><a href="#topic+blcSplitCriterionBICICL">blcSplitCriterionBICICL</a></code>, 
<code><a href="#topic+blcSplitCriterionJustRecordEverything">blcSplitCriterionJustRecordEverything</a></code>, 
<code><a href="#topic+blcSplitCriterionLRT">blcSplitCriterionLRT</a></code></p>

<hr>
<h2 id='blcSplitCriterionLRT'>Beta RPMM Split Criterion: use likelihood ratio test p value</h2><span id='topic+blcSplitCriterionLRT'></span>

<h3>Description</h3>

<p>Split criterion function:  Use likelihood ratio test p value to determine split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcSplitCriterionLRT(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcSplitCriterionLRT_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLRT_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLRT_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLRT_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLRT_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="blcSplitCriterionLRT_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;blcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
See <code><a href="#topic+blcTree">blcTree</a></code> for example of using &ldquo;blcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>llike1</code></td>
<td>
<p>Just returns <code>llike1</code></p>
</td></tr>
<tr><td><code>llike2</code></td>
<td>
<p>Just returns <code>llike2</code></p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>Just returns <code>J</code></p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>Just returns <code>weight</code></p>
</td></tr>
<tr><td><code>degFreedom</code></td>
<td>
<p>Degrees-of-freedom for LRT</p>
</td></tr>  
<tr><td><code>chiSquareStat</code></td>
<td>
<p>Chi-square statistic</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+blcSplitCriterionBIC">blcSplitCriterionBIC</a></code>, 
<code><a href="#topic+blcSplitCriterionBICICL">blcSplitCriterionBICICL</a></code>, 
<code><a href="#topic+blcSplitCriterionJustRecordEverything">blcSplitCriterionJustRecordEverything</a></code>, 
<code><a href="#topic+blcSplitCriterionLevelWtdBIC">blcSplitCriterionLevelWtdBIC</a></code></p>

<hr>
<h2 id='blcSubTree'>Beta Subtree</h2><span id='topic+blcSubTree'></span>

<h3>Description</h3>

<p>Subsets a &ldquo;blcTree&rdquo; object, i.e. considers the tree whose root is a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcSubTree(tr, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcSubTree_+3A_tr">tr</code></td>
<td>
<p>&ldquo;blcTree&rdquo; object to subset</p>
</td></tr>
<tr><td><code id="blcSubTree_+3A_node">node</code></td>
<td>
<p>Name of node to make root.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically not be called by user.
</p>


<h3>Value</h3>

<p>A &ldquo;blcTree&rdquo; object whose root is the given node of <code>tr</code>
</p>

<hr>
<h2 id='blcTree'> Beta RPMM Tree </h2><span id='topic+blcTree'></span>

<h3>Description</h3>

<p>Performs beta latent class modeling using recursively-partitioned mixture model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcTree(x, initFunctions = list(blcInitializeSplitFanny()), 
   weight = NULL, index = NULL, wthresh = 1e-08, nodename = "root",
   maxlevel = Inf, verbose = 2, nthresh = 5, level = 0, env = NULL, 
   unsplit = NULL, splitCriterion = blcSplitCriterionBIC)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcTree_+3A_x">x</code></td>
<td>
<p>Data matrix (n x j) on which to perform clustering.  Missing values are supported.  All values should lie strictly between 0 and 1.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_initfunctions">initFunctions</code></td>
<td>
<p>List of functions of type &ldquo;blcInitialize...&rdquo; for initializing latent class model.  See <code>blcInitializeFanny</code> for an example of arguments and return values.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_weight">weight</code></td>
<td>
<p>Weight corresponding to the indices passed (see <code>index</code>).  Defaults to 1 for all indices</p>
</td></tr>
<tr><td><code id="blcTree_+3A_index">index</code></td>
<td>
<p>Row indices of data matrix to include. Defaults to all (1 to n).</p>
</td></tr>
<tr><td><code id="blcTree_+3A_wthresh">wthresh</code></td>
<td>
<p>Weight threshold for filtering data to children.  Indices having weight less than this value will not be passed to children nodes.  Default=1E-8.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_nodename">nodename</code></td>
<td>
<p>Name of object that will represent node in tree data object.  Defaults to &ldquo;root&rdquo;.  USER SHOULD NOT SET THIS.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_maxlevel">maxlevel</code></td>
<td>
<p>Maximum depth to recurse.  Default=Inf.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_verbose">verbose</code></td>
<td>
<p>Level of verbosity.  Default=2 (too much).  0 for quiet.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_nthresh">nthresh</code></td>
<td>
<p>Total weight in node required for node to be a candidate for splitting.  Nodes with weight less than this value will never split.  Defaults to 5.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_level">level</code></td>
<td>
<p>Current level.  Defaults to 0.  USER SHUOLD NOT SET THIS.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_env">env</code></td>
<td>
<p>Object of class &ldquo;blcTree&rdquo; to store tree data.  Defaults to a new object.  USER SHOULD NOT SET THIS.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_unsplit">unsplit</code></td>
<td>
<p>Latent class parameters from parent, to store in current node.  Defaults to NULL for root.  This is used in plotting functions.  USER SHOULD NOT SET THIS.</p>
</td></tr>
<tr><td><code id="blcTree_+3A_splitcriterion">splitCriterion</code></td>
<td>
<p>Function of type &ldquo;blcSplitCriterion...&rdquo; for determining whether a node should be split.  See <code>blcSplitCriterionBIC</code> for an example of arguments and return values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called recursively by itself.  Upon each recursion, certain arguments (e.g. nodename) are reset.  Do not attempt to set these arguments yourself.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;blcTree&rdquo;.  This is an environment, each of whose component objects represents a node in the tree.
</p>


<h3>Note</h3>

<p>The class &ldquo;blcTree&rdquo; is currently implemented as an environment object with
nodes represented flatly, with name indicating positition in hierarchy
(e.g. &ldquo;rLLR&rdquo; = &ldquo;right child of left child of left child of root&rdquo;)
This implementation is to make certain plotting and update functions simpler
than would be required if the data were stored in a more natural &ldquo;list of list&rdquo;
format.
</p>
<p>The following error may appear during the course of the algorithm:
</p>
<pre>
      Error in optim(logab, betaObjf, ydata = y, wdata = w, weights = weights,  : 
           non-finite value supplied by optim
      </pre>
<p>This is merely an indication that the node being split is too small, in which case
the splitting will terminate at that node; in other words, it is nothing 
to worry about.
</p>


<h3>Author(s)</h3>

<p>E. Andres Houseman</p>


<h3>References</h3>

<p>Houseman et al., Model-based clustering of DNA methylation array data: a recursive-partitioning algorithm for high-dimensional data arising as a mixture of beta distributions. BMC Bioinformatics 9:365, 2008. </p>


<h3>See Also</h3>

<p><code><a href="#topic+glcTree">glcTree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(IlluminaMethylation)

heatmap(IllumBeta, scale="n",
  col=colorRampPalette(c("yellow","black","blue"),space="Lab")(128))

# Fit Gaussian RPMM
rpmm &lt;- blcTree(IllumBeta, verbose=0)
rpmm

# Get weight matrix and show first few rows
rpmmWeightMatrix &lt;- blcTreeLeafMatrix(rpmm)
rpmmWeightMatrix[1:3,]

# Get class assignments and compare with tissue
rpmmClass &lt;- blcTreeLeafClasses(rpmm)
table(rpmmClass,tissue)

# Plot fit
par(mfrow=c(2,2))
plot(rpmm) ; title("Image of RPMM Profile")
plotTree.blcTree(rpmm) ; title("Dendrogram with Labels")
plotTree.blcTree(rpmm, 
  labelFunction=function(u,digits) table(as.character(tissue[u$index])))
title("Dendrogram with Tissue Counts")

# Alternate initialization
rpmm2 &lt;- blcTree(IllumBeta, verbose=0, 
  initFunctions=list(blcInitializeSplitEigen(),
                     blcInitializeSplitFanny(nu=2.5)))
rpmm2

# Alternate split criterion
rpmm3 &lt;- blcTree(IllumBeta, verbose=0, maxlev=3,
  splitCriterion=blcSplitCriterionLevelWtdBIC)
rpmm3

rpmm4 &lt;- blcTree(IllumBeta, verbose=0, maxlev=3,
  splitCriterion=blcSplitCriterionJustRecordEverything)
rpmm4$rLL$splitInfo$llike1
rpmm4$rLL$splitInfo$llike2

## End(Not run)
</code></pre>

<hr>
<h2 id='blcTreeApply'>Recursive Apply Function for Beta RPMM Objects</h2><span id='topic+blcTreeApply'></span>

<h3>Description</h3>

<p>Recursively applies a function down the nodes of a Gaussian RPMM tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcTreeApply(tr, f, start = "root", terminalOnly = FALSE, asObject = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcTreeApply_+3A_tr">tr</code></td>
<td>
<p>Tree object to recurse</p>
</td></tr>
<tr><td><code id="blcTreeApply_+3A_f">f</code></td>
<td>
<p>Function to apply to every node</p>
</td></tr>
<tr><td><code id="blcTreeApply_+3A_start">start</code></td>
<td>
<p>Starting node.  Default = &ldquo;root&rdquo;.</p>
</td></tr>
<tr><td><code id="blcTreeApply_+3A_terminalonly">terminalOnly</code></td>
<td>
<p><code>TRUE</code>=only terminal nodes, <code>FALSE</code>=all nodes.</p>
</td></tr>
<tr><td><code id="blcTreeApply_+3A_asobject">asObject</code></td>
<td>
<p><code>TRUE</code>: <code>f</code> accepts node as object.  
<code>FALSE</code>: <code>f</code> accepts node by node name and object name, f(nn,tr)</p>
</td></tr></table>
<p>.
In the latter case, <code>f</code> should be defined as <code>f &lt;- function(nn,tree){...}</code>.
</p>
<table role = "presentation">
<tr><td><code id="blcTreeApply_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>f</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results; names of elements are names of nodes.
</p>

<hr>
<h2 id='blcTreeLeafClasses'>Posterior Class Assignments for Beta RPMM</h2><span id='topic+blcTreeLeafClasses'></span>

<h3>Description</h3>

<p>Gets a vector of posterior class membership assignments for terminal nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcTreeLeafClasses(tr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcTreeLeafClasses_+3A_tr">tr</code></td>
<td>
<p>Tree from which to create assignments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+blcTree">blcTree</a></code> for example.
</p>


<h3>Value</h3>

<p>Vector of class assignments
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blcTreeLeafMatrix">blcTreeLeafMatrix</a></code> </p>

<hr>
<h2 id='blcTreeLeafMatrix'>Posterior Weight Matrix for Beta RPMM</h2><span id='topic+blcTreeLeafMatrix'></span>

<h3>Description</h3>

<p>Gets a matrix of posterior class membership weights for terminal nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcTreeLeafMatrix(tr, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcTreeLeafMatrix_+3A_tr">tr</code></td>
<td>
<p>Tree from which to create matrix.</p>
</td></tr>
<tr><td><code id="blcTreeLeafMatrix_+3A_rounding">rounding</code></td>
<td>
<p>Digits to round.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+blcTree">blcTree</a></code> for example.
</p>


<h3>Value</h3>

<p>N x K matrix of posterior weights
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blcTreeLeafClasses">blcTreeLeafClasses</a></code> </p>

<hr>
<h2 id='blcTreeOverallBIC'>Overall BIC for Entire RPMM Tree (Beta version) </h2><span id='topic+blcTreeOverallBIC'></span>

<h3>Description</h3>

<p>Computes the BIC for the latent class model represented by terminal nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blcTreeOverallBIC(tr, ICL = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blcTreeOverallBIC_+3A_tr">tr</code></td>
<td>
<p>Tree object on which to compute BIC</p>
</td></tr>
<tr><td><code id="blcTreeOverallBIC_+3A_icl">ICL</code></td>
<td>
<p>Include ICL entropy term?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BIC or BIC-ICL.
</p>

<hr>
<h2 id='ebayes'>Empirical Bayes predictions for a specific RPMM model</h2><span id='topic+ebayes'></span>

<h3>Description</h3>

<p>Empirical Bayes predictions for a specific RPMM model 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebayes(rpmm, x, type, nodelist=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ebayes_+3A_rpmm">rpmm</code></td>
<td>
<p>RPMM object</p>
</td></tr>
<tr><td><code id="ebayes_+3A_x">x</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="ebayes_+3A_type">type</code></td>
<td>
<p>RPMM type (&quot;blc&quot; or &quot;glc&quot;)</p>
</td></tr>
<tr><td><code id="ebayes_+3A_nodelist">nodelist</code></td>
<td>
<p>RPMM subnode to use (default = root)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically not be called by user.
</p>


<h3>Value</h3>

<p>Matrix of empirical bayes predictions corresponding to <code>x</code>.
</p>

<hr>
<h2 id='gaussEstMultiple'>Gaussian Maximum Likelihood on a Matrix</h2><span id='topic+gaussEstMultiple'></span>

<h3>Description</h3>

<p>Maximum likelihood estimator for Gaussian model on matrix of values
(columns having different, independent Gaussian distributions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussEstMultiple(Y, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussEstMultiple_+3A_y">Y</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="gaussEstMultiple_+3A_weights">weights</code></td>
<td>
<p>case weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of beta parameters and BIC
</p>

<hr>
<h2 id='glc'>Gaussian Finite Mixture Model</h2><span id='topic+glc'></span>

<h3>Description</h3>

<p>Fits a Gaussian mixture model for any number of classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glc(Y, w, maxiter = 100, tol = 1e-06, weights = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glc_+3A_y">Y</code></td>
<td>
<p>Data matrix (n x j) on which to perform clustering</p>
</td></tr>
<tr><td><code id="glc_+3A_w">w</code></td>
<td>
<p>Initial weight matrix (n x k) representing classification</p>
</td></tr>
<tr><td><code id="glc_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of EM iterations</p>
</td></tr>
<tr><td><code id="glc_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance</p>
</td></tr>
<tr><td><code id="glc_+3A_weights">weights</code></td>
<td>
<p>Case weights</p>
</td></tr>
<tr><td><code id="glc_+3A_verbose">verbose</code></td>
<td>
<p>Verbose output?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically not be called by user.
</p>


<h3>Value</h3>

<p>A list of parameters representing mixture model fit, including posterior weights and log-likelihood
</p>

<hr>
<h2 id='glcInitializeSplitEigen'>Initialize Gaussian Latent Class via Eigendecomposition</h2><span id='topic+glcInitializeSplitEigen'></span>

<h3>Description</h3>

<p>Creates a function for initializing latent class model based on Eigendecomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcInitializeSplitEigen(eigendim = 1, 
   assignmentf = function(s) (rank(s) - 0.5)/length(s))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcInitializeSplitEigen_+3A_eigendim">eigendim</code></td>
<td>
<p>How many eigenvalues to use</p>
</td></tr>
<tr><td><code id="glcInitializeSplitEigen_+3A_assignmentf">assignmentf</code></td>
<td>
<p>assignment function for transforming eigenvector to weight</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a function <code>f(x)</code> that will take a data matrix <code>x</code> and 
initialize a weight matrix for a two-class latent class model.
Here, the initialized classes will be based on eigendecomposition of the variance of <code>x</code>.
See <code><a href="#topic+glcTree">glcTree</a></code> for example of using &ldquo;glcInitializeSplit...&rdquo; to create starting values.
</p>


<h3>Value</h3>

<p>A function <code>f(x)</code> (see Details.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glcInitializeSplitFanny">glcInitializeSplitFanny</a></code>, 
<code><a href="#topic+glcInitializeSplitHClust">glcInitializeSplitHClust</a></code></p>

<hr>
<h2 id='glcInitializeSplitFanny'>Initialize Gaussian Latent Class via Fanny</h2><span id='topic+glcInitializeSplitFanny'></span>

<h3>Description</h3>

<p>Creates a function for initializing latent class model using the <code>fanny</code> algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcInitializeSplitFanny(nu = 2, nufac = 0.875, metric = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcInitializeSplitFanny_+3A_nu">nu</code></td>
<td>
<p><code>memb.exp</code> parameter in <code>fanny</code></p>
</td></tr>
<tr><td><code id="glcInitializeSplitFanny_+3A_nufac">nufac</code></td>
<td>
<p>Factor by which to multiply <code>nu</code> if an error occurs</p>
</td></tr>
<tr><td><code id="glcInitializeSplitFanny_+3A_metric">metric</code></td>
<td>
<p>Metric to use for <code>fanny</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a function <code>f(x)</code> that will take a data matrix <code>x</code> and 
initialize a weight matrix for a two-class latent class model.
Here, the &ldquo;fanny&rdquo; algorithm will be used.
See <code><a href="#topic+glcTree">glcTree</a></code> for example of using &ldquo;glcInitializeSplit...&rdquo; to create starting values.
</p>


<h3>Value</h3>

<p>A function <code>f(x)</code> (see Details.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glcInitializeSplitEigen">glcInitializeSplitEigen</a></code>, 
<code><a href="#topic+glcInitializeSplitHClust">glcInitializeSplitHClust</a></code></p>

<hr>
<h2 id='glcInitializeSplitHClust'>Initialize Gaussian Latent Class via Hierarchical Clustering</h2><span id='topic+glcInitializeSplitHClust'></span>

<h3>Description</h3>

<p>Creates a function for initializing latent class model using hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcInitializeSplitHClust(metric = "manhattan", method = "ward")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcInitializeSplitHClust_+3A_metric">metric</code></td>
<td>
<p>Dissimilarity metric used for hierarchical clustering</p>
</td></tr>
<tr><td><code id="glcInitializeSplitHClust_+3A_method">method</code></td>
<td>
<p>Linkage method used for hierarchical clustering</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a function <code>f(x)</code> that will take a data matrix <code>x</code> and 
initialize a weight matrix for a two-class latent class model.
Here, a two-branch split from hierarchical clustering will be used.
See <code><a href="#topic+glcTree">glcTree</a></code> for example of using &ldquo;glcInitializeSplit...&rdquo; to create starting values.
</p>


<h3>Value</h3>

<p>A function <code>f(x)</code> (see Details.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glcInitializeSplitEigen">glcInitializeSplitEigen</a></code>, 
<code><a href="#topic+glcInitializeSplitFanny">glcInitializeSplitFanny</a></code></p>

<hr>
<h2 id='glcSplit'>Gaussian Latent Class Splitter</h2><span id='topic+glcSplit'></span>

<h3>Description</h3>

<p>Splits a data set into two via a Gaussian mixture models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcSplit(x, initFunctions, weight = NULL, index = NULL, level =
                 0, wthresh = 1e-09, verbose = TRUE, nthresh = 5,
                 splitCriterion = glcSplitCriterionBIC)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcSplit_+3A_x">x</code></td>
<td>
<p>Data matrix (n x j) on which to perform clustering</p>
</td></tr>
<tr><td><code id="glcSplit_+3A_initfunctions">initFunctions</code></td>
<td>
<p>List of functions of type &ldquo;glcInitialize...&rdquo; for initializing latent class model.
See <code>glcInitializeFanny</code> for an example of arguments and return values.</p>
</td></tr>
<tr><td><code id="glcSplit_+3A_weight">weight</code></td>
<td>
<p>Weight corresponding to the indices passed (see <code>index</code>). Defaults to 1 for all indices</p>
</td></tr>
<tr><td><code id="glcSplit_+3A_index">index</code></td>
<td>
<p>Row indices of data matrix to include. Defaults to all (1 to n).</p>
</td></tr>
<tr><td><code id="glcSplit_+3A_level">level</code></td>
<td>
<p> Current level. </p>
</td></tr>
<tr><td><code id="glcSplit_+3A_wthresh">wthresh</code></td>
<td>
<p>Weight threshold for filtering data to children. 
Indices having weight less than this value will not be passed to children nodes.</p>
</td></tr>
<tr><td><code id="glcSplit_+3A_verbose">verbose</code></td>
<td>
<p>Level of verbosity.  Default=2 (too much).  0 for quiet.</p>
</td></tr>
<tr><td><code id="glcSplit_+3A_nthresh">nthresh</code></td>
<td>
<p>Total weight in node required for node to be a candidate for splitting.  
Nodes with weight less than this value will never split.</p>
</td></tr>
<tr><td><code id="glcSplit_+3A_splitcriterion">splitCriterion</code></td>
<td>
<p>Function of type &ldquo;glcSplitCriterion...&rdquo; for determining whether split should occur.
See <code>glcSplitCriterionBIC</code> for an example of arguments and return values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Should not be called by user.
</p>


<h3>Value</h3>

<p>A list of objects representing split.
</p>

<hr>
<h2 id='glcSplitCriterionBIC'>Gaussian RPMM Split Criterion: Use BIC</h2><span id='topic+glcSplitCriterionBIC'></span>

<h3>Description</h3>

<p>Split criterion function:  compare BICs to determine split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcSplitCriterionBIC(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcSplitCriterionBIC_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBIC_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBIC_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBIC_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBIC_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBIC_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;glcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
See <code><a href="#topic+glcTree">glcTree</a></code> for example of using &ldquo;glcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bic1</code></td>
<td>
<p>one-class (weighted) BIC</p>
</td></tr>
<tr><td><code>bic2</code></td>
<td>
<p>two-class (weighted) BIC</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glcSplitCriterionBIC">glcSplitCriterionBIC</a></code>, 
<code><a href="#topic+glcSplitCriterionJustRecordEverything">glcSplitCriterionJustRecordEverything</a></code>, 
<code><a href="#topic+glcSplitCriterionLevelWtdBIC">glcSplitCriterionLevelWtdBIC</a></code>, 
<code><a href="#topic+glcSplitCriterionLRT">glcSplitCriterionLRT</a></code></p>

<hr>
<h2 id='glcSplitCriterionBICICL'>Gaussian RPMM Split Criterion: Use ICL-BIC</h2><span id='topic+glcSplitCriterionBICICL'></span>

<h3>Description</h3>

<p>Split criterion function:  compare ICL-BICs to determine split (i.e. include entropy term in comparison).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcSplitCriterionBICICL(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcSplitCriterionBICICL_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBICICL_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBICICL_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBICICL_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBICICL_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionBICICL_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;glcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
See <code><a href="#topic+glcTree">glcTree</a></code> for example of using &ldquo;glcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bic1</code></td>
<td>
<p>one-class (weighted) BIC</p>
</td></tr>
<tr><td><code>bic2</code></td>
<td>
<p>two-class (weighted) BIC</p>
</td></tr>
<tr><td><code>entropy</code></td>
<td>
<p>two-class entropy</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glcSplitCriterionBICICL">glcSplitCriterionBICICL</a></code>, 
<code><a href="#topic+glcSplitCriterionJustRecordEverything">glcSplitCriterionJustRecordEverything</a></code>, 
<code><a href="#topic+glcSplitCriterionLevelWtdBIC">glcSplitCriterionLevelWtdBIC</a></code>, 
<code><a href="#topic+glcSplitCriterionLRT">glcSplitCriterionLRT</a></code></p>

<hr>
<h2 id='glcSplitCriterionJustRecordEverything'>Gaussian RPMM Split Criterion: Always Split and Record Everything</h2><span id='topic+glcSplitCriterionJustRecordEverything'></span>

<h3>Description</h3>

<p>Split criterion function: always split, but record everything as you go.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcSplitCriterionJustRecordEverything(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcSplitCriterionJustRecordEverything_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionJustRecordEverything_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionJustRecordEverything_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionJustRecordEverything_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionJustRecordEverything_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionJustRecordEverything_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;glcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
This function ALWAYS returns <code>split=TRUE</code>.  Useful for gathering information.
It is recommended that you set the <code>maxlev</code> argument in the main function to something
less than infinity (say, 3 or 4).
See <code><a href="#topic+glcTree">glcTree</a></code> for example of using &ldquo;glcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>llike1</code></td>
<td>
<p>Just returns <code>llike1</code></p>
</td></tr>
<tr><td><code>llike2</code></td>
<td>
<p>Just returns <code>llike2</code></p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>Just returns <code>J</code></p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>Just returns <code>weight</code></p>
</td></tr>
<tr><td><code>ww</code></td>
<td>
<p>Just returns <code>ww</code></p>
</td></tr>
<tr><td><code>degFreedom</code></td>
<td>
<p>Degrees-of-freedom for LRT</p>
</td></tr>  
<tr><td><code>chiSquareStat</code></td>
<td>
<p>Chi-square statistic</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glcSplitCriterionBIC">glcSplitCriterionBIC</a></code>, 
<code><a href="#topic+glcSplitCriterionBICICL">glcSplitCriterionBICICL</a></code>, 
<code><a href="#topic+glcSplitCriterionLevelWtdBIC">glcSplitCriterionLevelWtdBIC</a></code>, 
<code><a href="#topic+glcSplitCriterionLRT">glcSplitCriterionLRT</a></code></p>

<hr>
<h2 id='glcSplitCriterionLevelWtdBIC'>Gaussian RPMM Split Criterion:  Level-Weighted BIC</h2><span id='topic+glcSplitCriterionLevelWtdBIC'></span>

<h3>Description</h3>

<p>Split criterion function: use a level-weighted version of BIC to determine split; there is an additional penalty incorporated for deep recursion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcSplitCriterionLevelWtdBIC(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcSplitCriterionLevelWtdBIC_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLevelWtdBIC_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLevelWtdBIC_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLevelWtdBIC_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLevelWtdBIC_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLevelWtdBIC_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;glcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
See <code><a href="#topic+glcTree">glcTree</a></code> for example of using &ldquo;glcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bic1</code></td>
<td>
<p>One-class BIC, with additional penalty for deeper levels</p>
</td></tr>
<tr><td><code>bic2</code></td>
<td>
<p>Two-class BIC, with additional penalty for deeper levels</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glcSplitCriterionBIC">glcSplitCriterionBIC</a></code>, 
<code><a href="#topic+glcSplitCriterionBICICL">glcSplitCriterionBICICL</a></code>, 
<code><a href="#topic+glcSplitCriterionJustRecordEverything">glcSplitCriterionJustRecordEverything</a></code>, 
<code><a href="#topic+glcSplitCriterionLRT">glcSplitCriterionLRT</a></code></p>

<hr>
<h2 id='glcSplitCriterionLRT'>Gaussian RPMM Split Criterion: Use likelihood ratio test p value</h2><span id='topic+glcSplitCriterionLRT'></span>

<h3>Description</h3>

<p>Split criterion function:  use likelihood ratio test p value to determine split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcSplitCriterionLRT(llike1, llike2, weight, ww, J, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcSplitCriterionLRT_+3A_llike1">llike1</code></td>
<td>
<p>one-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLRT_+3A_llike2">llike2</code></td>
<td>
<p>two-class likelihood.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLRT_+3A_weight">weight</code></td>
<td>
<p>weights from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLRT_+3A_ww">ww</code></td>
<td>
<p>&ldquo;ww&rdquo; from RPMM node.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLRT_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="glcSplitCriterionLRT_+3A_level">level</code></td>
<td>
<p>Node level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function of the form &ldquo;glcSplitCriterion...&rdquo;, which is required to return a list
with at least a boolean value <code>split</code>, along with supporting information.
See <code><a href="#topic+glcTree">glcTree</a></code> for example of using &ldquo;glcSplitCriterion...&rdquo; to control split.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>llike1</code></td>
<td>
<p>Just returns <code>llike1</code></p>
</td></tr>
<tr><td><code>llike2</code></td>
<td>
<p>Just returns <code>llike2</code></p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>Just returns <code>J</code></p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>Just returns <code>weight</code></p>
</td></tr>
<tr><td><code>degFreedom</code></td>
<td>
<p>Degrees-of-freedom for LRT</p>
</td></tr>  
<tr><td><code>chiSquareStat</code></td>
<td>
<p>Chi-square statistic</p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p><code>TRUE</code>=split the node, <code>FALSE</code>=do not split the node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glcSplitCriterionBIC">glcSplitCriterionBIC</a></code>, 
<code><a href="#topic+glcSplitCriterionBICICL">glcSplitCriterionBICICL</a></code>, 
<code><a href="#topic+glcSplitCriterionJustRecordEverything">glcSplitCriterionJustRecordEverything</a></code>, 
<code><a href="#topic+glcSplitCriterionLevelWtdBIC">glcSplitCriterionLevelWtdBIC</a></code></p>

<hr>
<h2 id='glcSubTree'>Gaussian Subtree</h2><span id='topic+glcSubTree'></span>

<h3>Description</h3>

<p>Subsets a &ldquo;glcTree&rdquo; object, i.e. considers the tree whose root is a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcSubTree(tr, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcSubTree_+3A_tr">tr</code></td>
<td>
<p>&ldquo;glcTree&rdquo; object to subset</p>
</td></tr>
<tr><td><code id="glcSubTree_+3A_node">node</code></td>
<td>
<p>Name of node to make root.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically not be called by user.
</p>


<h3>Value</h3>

<p>A &ldquo;glcTree&rdquo; object whose root is the given node of <code>tr</code>
</p>

<hr>
<h2 id='glcTree'> Gaussian RPMM Tree </h2><span id='topic+glcTree'></span>

<h3>Description</h3>

<p>Performs Gaussian latent class modeling using recursively-partitioned mixture model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcTree(x, initFunctions = list(glcInitializeSplitFanny(nu=1.5)), 
   weight = NULL, index = NULL, wthresh = 1e-08, 
   nodename = "root", maxlevel = Inf, verbose = 2, nthresh = 5, level = 0, 
   env = NULL, unsplit = NULL, splitCriterion = glcSplitCriterionBIC)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcTree_+3A_x">x</code></td>
<td>
<p>Data matrix (n x j) on which to perform clustering.  Missing values are supported.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_initfunctions">initFunctions</code></td>
<td>
<p>List of functions of type &ldquo;glcInitialize...&rdquo; for initializing latent class model.  See <code>glcInitializeFanny</code> for an example of arguments and return values.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_weight">weight</code></td>
<td>
<p>Weight corresponding to the indices passed (see <code>index</code>).  Defaults to 1 for all indices</p>
</td></tr>
<tr><td><code id="glcTree_+3A_index">index</code></td>
<td>
<p>Row indices of data matrix to include. Defaults to all (1 to n).</p>
</td></tr>
<tr><td><code id="glcTree_+3A_wthresh">wthresh</code></td>
<td>
<p>Weight threshold for filtering data to children.  Indices having weight less than this value will not be passed to children nodes.  Default=1E-8.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_nodename">nodename</code></td>
<td>
<p>Name of object that will represent node in tree data object.  Defaults to &ldquo;root&rdquo;.  USER SHOULD NOT SET THIS.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_maxlevel">maxlevel</code></td>
<td>
<p>Maximum depth to recurse.  Default=Inf.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_verbose">verbose</code></td>
<td>
<p>Level of verbosity.  Default=2 (too much).  0 for quiet.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_nthresh">nthresh</code></td>
<td>
<p>Total weight in node required for node to be a candidate for splitting.  Nodes with weight less than this value will never split.  Defaults to 5.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_level">level</code></td>
<td>
<p>Current level.  Defaults to 0.  USER SHUOLD NOT SET THIS.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_env">env</code></td>
<td>
<p>Object of class &ldquo;glcTree&rdquo; to store tree data.  Defaults to a new object.  USER SHOULD NOT SET THIS.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_unsplit">unsplit</code></td>
<td>
<p>Latent class parameters from parent, to store in current node.  Defaults to NULL for root.  This is used in plotting functions.  USER SHOULD NOT SET THIS.</p>
</td></tr>
<tr><td><code id="glcTree_+3A_splitcriterion">splitCriterion</code></td>
<td>
<p>Function of type &ldquo;glcSplitCriterion...&rdquo; for determining whether a node should be split.  See <code>glcSplitCriterionBIC</code> for an example of arguments and return values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called recursively by itself.  Upon each recursion, certain arguments (e.g. nodename) are reset.  Do not attempt to set these arguments yourself.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;glcTree&rdquo;.  This is an environment, each of whose component objects represents a node in the tree.
</p>


<h3>Note</h3>

<p>The class &ldquo;glcTree&rdquo; is currently implemented as an environment object with
nodes represented flatly, with name indicating positition in hierarchy
(e.g. &ldquo;rLLR&rdquo; = &ldquo;right child of left child of left child of root&rdquo;)
This implementation is to make certain plotting and update functions simpler
than would be required if the data were stored in a more natural &ldquo;list of list&rdquo;
format.
</p>
<p>The following error may appear during the course of the algorithm:
</p>
<pre>
      Error in optim(logab, betaObjf, ydata = y, wdata = w, weights = weights,  : 
           non-finite value supplied by optim
      </pre>
<p>This is merely an indication that the node being split is too small, in which case
the splitting will terminate at that node; in other words, it is nothing 
to worry about.
</p>


<h3>Author(s)</h3>

<p>E. Andres Houseman</p>


<h3>References</h3>

<p>Houseman et al., Model-based clustering of DNA methylation array data: a recursive-partitioning algorithm for high-dimensional data arising as a mixture of beta distributions. BMC Bioinformatics 9:365, 2008. </p>


<h3>See Also</h3>

<p><code><a href="#topic+blcTree">blcTree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(IlluminaMethylation)

## Not run: 
heatmap(IllumBeta, scale="n",
  col=colorRampPalette(c("yellow","black","blue"),space="Lab")(128))

## End(Not run)

# Fit Gaussian RPMM
rpmm &lt;- glcTree(IllumBeta, verbose=0)
rpmm

# Get weight matrix and show first few rows
rpmmWeightMatrix &lt;- glcTreeLeafMatrix(rpmm)
rpmmWeightMatrix[1:3,]

# Get class assignments and compare with tissue
rpmmClass &lt;- glcTreeLeafClasses(rpmm)
table(rpmmClass,tissue)

## Not run: 
# Plot fit
par(mfrow=c(2,2))
plot(rpmm) ; title("Image of RPMM Profile")
plotTree.glcTree(rpmm) ; title("Dendrogram with Labels")
plotTree.glcTree(rpmm, 
  labelFunction=function(u,digits) table(as.character(tissue[u$index])))
title("Dendrogram with Tissue Counts")

# Alternate initialization
rpmm2 &lt;- glcTree(IllumBeta, verbose=0, 
  initFunctions=list(glcInitializeSplitEigen(),
                     glcInitializeSplitFanny(nu=2.5)))
rpmm2

# Alternate split criterion
rpmm3 &lt;- glcTree(IllumBeta, verbose=0, maxlev=3,
  splitCriterion=glcSplitCriterionLevelWtdBIC)
rpmm3

rpmm4 &lt;- glcTree(IllumBeta, verbose=0, maxlev=3,
  splitCriterion=glcSplitCriterionJustRecordEverything)
rpmm4$rLL$splitInfo$llike1
rpmm4$rLL$splitInfo$llike2

## End(Not run)
</code></pre>

<hr>
<h2 id='glcTreeApply'>Recursive Apply Function for Gaussian RPMM Objects</h2><span id='topic+glcTreeApply'></span>

<h3>Description</h3>

<p>Recursively applies a function down the nodes of a Gaussian RPMM tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcTreeApply(tr, f, start = "root", terminalOnly = FALSE, 
   asObject = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcTreeApply_+3A_tr">tr</code></td>
<td>
<p>Tree object to recurse</p>
</td></tr>
<tr><td><code id="glcTreeApply_+3A_f">f</code></td>
<td>
<p>Function to apply to every node</p>
</td></tr>
<tr><td><code id="glcTreeApply_+3A_start">start</code></td>
<td>
<p>Starting node.  Default = &ldquo;root&rdquo;.</p>
</td></tr>
<tr><td><code id="glcTreeApply_+3A_terminalonly">terminalOnly</code></td>
<td>
<p><code>TRUE</code>=only terminal nodes, <code>FALSE</code>=all nodes.</p>
</td></tr>
<tr><td><code id="glcTreeApply_+3A_asobject">asObject</code></td>
<td>
<p><code>TRUE</code>: <code>f</code> accepts node as object.  
<code>FALSE</code>: <code>f</code> accepts node by node name and object name, f(nn,tr)</p>
</td></tr></table>
<p>.
In the latter case, <code>f</code> should be defined as <code>f &lt;- function(nn,tree){...}</code>.
</p>
<table role = "presentation">
<tr><td><code id="glcTreeApply_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>f</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results; names of elements are names of nodes.
</p>

<hr>
<h2 id='glcTreeLeafClasses'>Posterior Class Assignments for Gaussian RPMM</h2><span id='topic+glcTreeLeafClasses'></span>

<h3>Description</h3>

<p>Gets a vector of posterior class membership assignments for terminal nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcTreeLeafClasses(tr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcTreeLeafClasses_+3A_tr">tr</code></td>
<td>
<p>Tree from which to create assignments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+glcTree">glcTree</a></code> for example.
</p>


<h3>Value</h3>

<p>Vector of class assignments
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glcTreeLeafMatrix">glcTreeLeafMatrix</a></code> </p>

<hr>
<h2 id='glcTreeLeafMatrix'>Posterior Weight Matrix for Gaussian RPMM</h2><span id='topic+glcTreeLeafMatrix'></span>

<h3>Description</h3>

<p>Gets a matrix of posterior class membership weights for terminal nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcTreeLeafMatrix(tr, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcTreeLeafMatrix_+3A_tr">tr</code></td>
<td>
<p>Tree from which to create matrix.</p>
</td></tr>
<tr><td><code id="glcTreeLeafMatrix_+3A_rounding">rounding</code></td>
<td>
<p>Digits to round.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+glcTree">glcTree</a></code> for example.
</p>


<h3>Value</h3>

<p>N x K matrix of posterior weights
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glcTreeLeafClasses">glcTreeLeafClasses</a></code> </p>

<hr>
<h2 id='glcTreeOverallBIC'>Overall BIC for Entire RPMM Tree (Gaussian version) </h2><span id='topic+glcTreeOverallBIC'></span>

<h3>Description</h3>

<p>Computes the BIC for the latent class model represented by terminal nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcTreeOverallBIC(tr, ICL = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcTreeOverallBIC_+3A_tr">tr</code></td>
<td>
<p>Tree object on which to compute BIC</p>
</td></tr>
<tr><td><code id="glcTreeOverallBIC_+3A_icl">ICL</code></td>
<td>
<p>Include ICL entropy term?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BIC or BIC-ICL.
</p>

<hr>
<h2 id='glmLC'>Weighted GLM for latent class covariates</h2><span id='topic+glmLC'></span>

<h3>Description</h3>

<p>Wrapper for glm function to incorporate weights corresponding to latent classes 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmLC(y,W,family=quasibinomial(),eps=1E-8,Z=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmLC_+3A_y">y</code></td>
<td>
<p>outcome</p>
</td></tr>
<tr><td><code id="glmLC_+3A_w">W</code></td>
<td>
<p>weight matrix (rows=cases, # rows = length of y)</p>
</td></tr>
<tr><td><code id="glmLC_+3A_family">family</code></td>
<td>
<p>glm family (default = quasibinomial for logistic regression)</p>
</td></tr>
<tr><td><code id="glmLC_+3A_eps">eps</code></td>
<td>
<p>threshold below which to delete pseudo-subject corresponding to a specific weight</p>
</td></tr>
<tr><td><code id="glmLC_+3A_z">Z</code></td>
<td>
<p>matrix of additional covariates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for glm to incorporate weights corresponding to latent classes (e.g. from an RPMM prediction)
</p>


<h3>Value</h3>

<p>a glm object
</p>

<hr>
<h2 id='IlluminaMethylation'>DNA Methylation Data for Normal Tissue Types</h2><span id='topic+IlluminaMethylation'></span><span id='topic+tissue'></span><span id='topic+IllumBeta'></span>

<h3>Description</h3>

<p>Illumina GoldenGate DNA methylation data for 217 normal tissues.
100 most variable CpG sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IlluminaMethylation</code></pre>


<h3>Format</h3>

<p>a 217 x 100 matrix containing Illumina Avg Beta values (IllumBeta), 
and a corresponding factor vector of 217 tissue types (tissue).</p>


<h3>References</h3>

<p>Christensen BC, Houseman EA, et al. 2009 Aging and Environmental Exposures Alter Tissue-Specific DNA Methylation Dependent upon CpG Island Context. PLoS Genet 5(8): e1000602.
</p>

<hr>
<h2 id='llikeRPMMObject'>Data log-likelihood implied by a specific RPMM model</h2><span id='topic+llikeRPMMObject'></span>

<h3>Description</h3>

<p>Data log-likelihood implied by a specific RPMM model 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikeRPMMObject(o, x, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikeRPMMObject_+3A_o">o</code></td>
<td>
<p>RPMM object</p>
</td></tr>
<tr><td><code id="llikeRPMMObject_+3A_x">x</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="llikeRPMMObject_+3A_type">type</code></td>
<td>
<p>RPMM type (&quot;blc&quot; or &quot;glc&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically not be called by user.
</p>


<h3>Value</h3>

<p>Vector of loglikelihoods corresponding to rows of <code>x</code>.
</p>

<hr>
<h2 id='plot.blcTree'>Plot a Beta RPMM Tree Profile</h2><span id='topic+plot.blcTree'></span>

<h3>Description</h3>

<p>Plot method for objects of type &ldquo;blcTree&rdquo;.  Plots profiles of terminal nodes in color.
Method wrapper for <code>plotImage.blcTree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blcTree'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.blcTree_+3A_x">x</code></td>
<td>
<p>RPMM object to plot.</p>
</td></tr>
<tr><td><code id="plot.blcTree_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plotImage.blcTree</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+blcTree">blcTree</a></code> for example.
</p>

<hr>
<h2 id='plot.glcTree'>Plot a Gaussian RPMM Tree Profile</h2><span id='topic+plot.glcTree'></span>

<h3>Description</h3>

<p>Plot method for objects of type &ldquo;glcTree&rdquo;.  Plots profiles of terminal nodes in color.
Method wrapper for <code>plotImage.glcTree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glcTree'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.glcTree_+3A_x">x</code></td>
<td>
<p>RPMM object to plot.</p>
</td></tr>
<tr><td><code id="plot.glcTree_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plotImage.glcTree</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+glcTree">glcTree</a></code> for example.
</p>

<hr>
<h2 id='plotImage.blcTree'>Plot a Beta RPMM Tree Profile</h2><span id='topic+plotImage.blcTree'></span>

<h3>Description</h3>

<p>Plots profiles of terminal nodes in color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImage.blcTree(env, 
   start = "r", method = "weight", 
   palette = colorRampPalette(c("yellow", "black", "blue"), space = "Lab")(128), 
   divcol = "red", xorder = NULL, dimensions = NULL, labelType = "LR")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotImage.blcTree_+3A_env">env</code></td>
<td>
<p>RPMM object to plot.</p>
</td></tr>
<tr><td><code id="plotImage.blcTree_+3A_start">start</code></td>
<td>
<p>Node to plot (usually root)</p>
</td></tr>
<tr><td><code id="plotImage.blcTree_+3A_method">method</code></td>
<td>
<p>Method to determine width of columns that represent classes: &ldquo;weight&rdquo; (subject weight in class) or dQuotebinary (depth in tree).</p>
</td></tr>
<tr><td><code id="plotImage.blcTree_+3A_palette">palette</code></td>
<td>
<p>Color palette to use for image plot.</p>
</td></tr>
<tr><td><code id="plotImage.blcTree_+3A_divcol">divcol</code></td>
<td>
<p>Divider color</p>
</td></tr>
<tr><td><code id="plotImage.blcTree_+3A_xorder">xorder</code></td>
<td>
<p>Order of variables.  Can be useful for constant ordering across multiple plots.</p>
</td></tr>
<tr><td><code id="plotImage.blcTree_+3A_dimensions">dimensions</code></td>
<td>
<p>Subset of dimensions of source data to show.  Defaults to all.  Useful to show a subset of dimensions.</p>
</td></tr>
<tr><td><code id="plotImage.blcTree_+3A_labeltype">labelType</code></td>
<td>
<p>Label name type: &ldquo;LR&rdquo; or &ldquo;01&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+blcTree">blcTree</a></code> for example.
</p>


<h3>Value</h3>

<p>Returns a vector of indices similar to the <code>order</code> function, representing the orrdering of items used in the plot.
This is useful for replicating the order in another plot, or for axis labeling.
</p>

<hr>
<h2 id='plotImage.glcTree'>Plot a Gaussian RPMM Tree Profile</h2><span id='topic+plotImage.glcTree'></span>

<h3>Description</h3>

<p>Plots profiles of terminal nodes in color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImage.glcTree(env, 
   start = "r", method = "weight", 
   palette = colorRampPalette(c("yellow", "black", "blue"), space = "Lab")(128), 
   divcol = "red", xorder = NULL, dimensions = NULL, labelType = "LR", muColorEps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotImage.glcTree_+3A_env">env</code></td>
<td>
<p>RPMM object to print.</p>
</td></tr>
<tr><td><code id="plotImage.glcTree_+3A_start">start</code></td>
<td>
<p>Node to plot (usually root)</p>
</td></tr>
<tr><td><code id="plotImage.glcTree_+3A_method">method</code></td>
<td>
<p>Method to determine width of columns that represent classes: &ldquo;weight&rdquo; (subject weight in class) or dQuotebinary (depth in tree).</p>
</td></tr>
<tr><td><code id="plotImage.glcTree_+3A_palette">palette</code></td>
<td>
<p>Color palette to use for image plot.</p>
</td></tr>
<tr><td><code id="plotImage.glcTree_+3A_divcol">divcol</code></td>
<td>
<p>Divider color</p>
</td></tr>
<tr><td><code id="plotImage.glcTree_+3A_xorder">xorder</code></td>
<td>
<p>Order of variables.  Can be useful for constant ordering across multiple plots.</p>
</td></tr>
<tr><td><code id="plotImage.glcTree_+3A_dimensions">dimensions</code></td>
<td>
<p>Subset of dimensions of source data to show.  Defaults to all.  Useful to show a subset of dimensions.</p>
</td></tr>
<tr><td><code id="plotImage.glcTree_+3A_labeltype">labelType</code></td>
<td>
<p>Label name type: &ldquo;LR&rdquo; or &ldquo;01&rdquo;.</p>
</td></tr>
<tr><td><code id="plotImage.glcTree_+3A_mucoloreps">muColorEps</code></td>
<td>
<p>Small value to stabilize color generation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+glcTree">glcTree</a></code> for example.
</p>


<h3>Value</h3>

<p>Returns a vector of indices similar to the <code>order</code> function, representing the orrdering of items used in the plot.
This is useful for replicating the order in another plot, or for axis labeling.
</p>

<hr>
<h2 id='plotTree.blcTree'>Plot a Beta RPMM Tree Dendrogram</h2><span id='topic+plotTree.blcTree'></span>

<h3>Description</h3>

<p>Alternate plot function for objects of type blcTree:  plots a dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTree.blcTree(env, start = "r", labelFunction = NULL, 
    buff = 4, cex = 0.9, square = TRUE, labelAllNodes = FALSE, labelDigits = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTree.blcTree_+3A_env">env</code></td>
<td>
<p>Tree object to print </p>
</td></tr>
<tr><td><code id="plotTree.blcTree_+3A_start">start</code></td>
<td>
<p>Note from which to start.  Default=&ldquo;r&rdquo; for &ldquo;root&rdquo;.</p>
</td></tr>
<tr><td><code id="plotTree.blcTree_+3A_labelfunction">labelFunction</code></td>
<td>
<p>Function for generating node labels.  Useful for labeling each node with a value.</p>
</td></tr>
<tr><td><code id="plotTree.blcTree_+3A_buff">buff</code></td>
<td>
<p>Buffer for placing tree in plot window.</p>
</td></tr>
<tr><td><code id="plotTree.blcTree_+3A_cex">cex</code></td>
<td>
<p>Text size</p>
</td></tr>
<tr><td><code id="plotTree.blcTree_+3A_square">square</code></td>
<td>
<p>Square dendrogram or &ldquo;V&rdquo; shaped</p>
</td></tr>
<tr><td><code id="plotTree.blcTree_+3A_labelallnodes">labelAllNodes</code></td>
<td>
<p><code>TRUE</code>=All nodes will be labeled; <code>FALSE</code>=Terminal nodes only.</p>
</td></tr>
<tr><td><code id="plotTree.blcTree_+3A_labeldigits">labelDigits</code></td>
<td>
<p>Digits to include in labels, if <code>labelFunction</code> returns numeric values.</p>
</td></tr>
<tr><td><code id="plotTree.blcTree_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code>labelFunction</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plots a dendrogram based on RPMM tree, with labels constructed from summaries of tree object.
See <code><a href="#topic+blcTree">blcTree</a></code> for example.
</p>

<hr>
<h2 id='plotTree.glcTree'>Plot a Gaussian RPMM Tree Dendrogram</h2><span id='topic+plotTree.glcTree'></span>

<h3>Description</h3>

<p>Alternate plot function for objects of type glcTree:  plots a dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTree.glcTree(env, start = "r", labelFunction = NULL, 
    buff = 4, cex = 0.9, square = TRUE, labelAllNodes = FALSE, labelDigits = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTree.glcTree_+3A_env">env</code></td>
<td>
<p>Tree object to print </p>
</td></tr>
<tr><td><code id="plotTree.glcTree_+3A_start">start</code></td>
<td>
<p>Note from which to start.  Default=&ldquo;r&rdquo; for &ldquo;root&rdquo;.</p>
</td></tr>
<tr><td><code id="plotTree.glcTree_+3A_labelfunction">labelFunction</code></td>
<td>
<p>Function for generating node labels.  Useful for labeling each node with a value.</p>
</td></tr>
<tr><td><code id="plotTree.glcTree_+3A_buff">buff</code></td>
<td>
<p>Buffer for placing tree in plot window.</p>
</td></tr>
<tr><td><code id="plotTree.glcTree_+3A_cex">cex</code></td>
<td>
<p>Text size</p>
</td></tr>
<tr><td><code id="plotTree.glcTree_+3A_square">square</code></td>
<td>
<p>Square dendrogram or &ldquo;V&rdquo; shaped</p>
</td></tr>
<tr><td><code id="plotTree.glcTree_+3A_labelallnodes">labelAllNodes</code></td>
<td>
<p><code>TRUE</code>=All nodes will be labeled; <code>FALSE</code>=Terminal nodes only.</p>
</td></tr>
<tr><td><code id="plotTree.glcTree_+3A_labeldigits">labelDigits</code></td>
<td>
<p>Digits to include in labels, if <code>labelFunction</code> returns numeric values.</p>
</td></tr>
<tr><td><code id="plotTree.glcTree_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code>labelFunction</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plots a dendrogram based on RPMM tree, with labels constructed from summaries of tree object.
See <code><a href="#topic+glcTree">glcTree</a></code> for example.
</p>

<hr>
<h2 id='predict.blcTree'>Predict using a Beta RPMM object</h2><span id='topic+predict.blcTree'></span>

<h3>Description</h3>

<p>Prediction method for objects of type blcTree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blcTree'
predict(object, newdata=NULL, nodelist=NULL, type="weight",...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.blcTree_+3A_object">object</code></td>
<td>
<p>RPMM object to print</p>
</td></tr>
<tr><td><code id="predict.blcTree_+3A_newdata">newdata</code></td>
<td>
<p>external data matrix from which to apply predictions</p>
</td></tr>
<tr><td><code id="predict.blcTree_+3A_nodelist">nodelist</code></td>
<td>
<p>RPMM subnode to use (default = root)</p>
</td></tr>
<tr><td><code id="predict.blcTree_+3A_type">type</code></td>
<td>
<p>output type: &quot;weight&quot; produces output similar to <code><a href="#topic+blcTreeLeafMatrix">blcTreeLeafMatrix</a></code>, &quot;class&quot; produces output similar to <code><a href="#topic+blcTreeLeafClasses">blcTreeLeafClasses</a></code>.</p>
</td></tr>
<tr><td><code id="predict.blcTree_+3A_...">...</code></td>
<td>
<p>(Unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="#topic+blcTreeLeafMatrix">blcTreeLeafMatrix</a></code> and <code><a href="#topic+blcTreeLeafClasses">blcTreeLeafClasses</a></code>, except that it supports prediction on an external data set via the argument <code>newdata</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blcTreeLeafMatrix">blcTreeLeafMatrix</a></code> </p>

<hr>
<h2 id='predict.glcTree'>Predict using a Gaussian RPMM object</h2><span id='topic+predict.glcTree'></span>

<h3>Description</h3>

<p>Prediction method for objects of type glcTree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glcTree'
predict(object, newdata=NULL, nodelist=NULL, type="weight",...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.glcTree_+3A_object">object</code></td>
<td>
<p>RPMM object to print</p>
</td></tr>
<tr><td><code id="predict.glcTree_+3A_newdata">newdata</code></td>
<td>
<p>external data matrix from which to apply predictions</p>
</td></tr>
<tr><td><code id="predict.glcTree_+3A_nodelist">nodelist</code></td>
<td>
<p>RPMM subnode to use (default = root)</p>
</td></tr>
<tr><td><code id="predict.glcTree_+3A_type">type</code></td>
<td>
<p>output type: &quot;weight&quot; produces output similar to <code><a href="#topic+glcTreeLeafMatrix">glcTreeLeafMatrix</a></code>, &quot;class&quot; produces output similar to <code><a href="#topic+glcTreeLeafClasses">glcTreeLeafClasses</a></code>.</p>
</td></tr>
<tr><td><code id="predict.glcTree_+3A_...">...</code></td>
<td>
<p>(Unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="#topic+glcTreeLeafMatrix">glcTreeLeafMatrix</a></code> and <code><a href="#topic+glcTreeLeafClasses">glcTreeLeafClasses</a></code>, except that it supports prediction on an external data set via the argument <code>newdata</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glcTreeLeafMatrix">glcTreeLeafMatrix</a></code> </p>

<hr>
<h2 id='print.blcTree'>Print a Beta RPMM object</h2><span id='topic+print.blcTree'></span>

<h3>Description</h3>

<p>Print method for objects of type blcTree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blcTree'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.blcTree_+3A_x">x</code></td>
<td>
<p>RPMM object to print</p>
</td></tr>
<tr><td><code id="print.blcTree_+3A_...">...</code></td>
<td>
<p>(Unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+blcTree">blcTree</a></code> for example.
</p>

<hr>
<h2 id='print.glcTree'>Print a Gaussian RPMM object</h2><span id='topic+print.glcTree'></span>

<h3>Description</h3>

<p>Print method for objects of type blcTree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glcTree'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.glcTree_+3A_x">x</code></td>
<td>
<p>RPMM object to print</p>
</td></tr>
<tr><td><code id="print.glcTree_+3A_...">...</code></td>
<td>
<p>(Unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+glcTree">glcTree</a></code> for example.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
