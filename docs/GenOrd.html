<!DOCTYPE html><html><head><title>Help for package GenOrd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GenOrd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#contord'>
<p>Correlations of discretized variables</p></a></li>
<li><a href='#corrcheck'>
<p>Checking correlations for feasibility</p></a></li>
<li><a href='#GenOrd-package'>
<p>Simulation of Discrete Random Variables with Given Correlation Matrix and Marginal Distributions</p></a></li>
<li><a href='#ordcont'>
<p>Computing the &quot;intermediate&quot; correlation matrix for the multivariate standard normal in order to achieve the &quot;target&quot; correlation matrix for the multivariate discrete variable</p></a></li>
<li><a href='#ordsample'>
<p>Drawing a sample of discrete data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation of Discrete Random Variables with Given Correlation
Matrix and Marginal Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-09-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessandro Barbiero, Pier Alda Ferrari</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessandro Barbiero &lt;alessandro.barbiero@unimi.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A gaussian copula based procedure for generating samples from discrete random variables with prescribed correlation matrix and marginal distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>mvtnorm, Matrix, MASS, stats</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-09-12 10:06:14 UTC; Barbiero</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-09-12 17:19:55</td>
</tr>
</table>
<hr>
<h2 id='contord'>
Correlations of discretized variables
</h2><span id='topic+contord'></span>

<h3>Description</h3>

<p>The function computes the correlation matrix of the <code class="reqn">k</code> variables, with given marginal distributions, derived discretizing a <code class="reqn">k</code>-variate standard normal variable with given correlation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contord(marginal, Sigma, support = list(), Spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contord_+3A_marginal">marginal</code></td>
<td>

<p>a list of <code class="reqn">k</code> elements, where <code class="reqn">k</code> is the number of variables.
The <code class="reqn">i</code>-th element of <code>marginal</code> is the vector of the cumulative probabilities defining the marginal distribution of the <code class="reqn">i</code>-th component of the  multivariate variable. If the <code class="reqn">i</code>-th component can take <code class="reqn">k_i</code> values, the <code class="reqn">i</code>-th element of <code>marginal</code> will contain <code class="reqn">k_i-1</code> probabilities (the <code class="reqn">k_i</code>-th is obviously 1 and shall not be included).
</p>
</td></tr>
<tr><td><code id="contord_+3A_sigma">Sigma</code></td>
<td>

<p>the correlation matrix of the standard multivariate normal variable
</p>
</td></tr>
<tr><td><code id="contord_+3A_support">support</code></td>
<td>

<p>a list of <code class="reqn">k</code> elements, where <code class="reqn">k</code> is the number of variables. The <code class="reqn">i</code>-th element of <code>support</code> is the vector containing the ordered values of the support of the <code class="reqn">i</code>-th variable. By default, the support of the <code class="reqn">i</code>-th variable is <code class="reqn">1,2,...,k_i</code>
</p>
</td></tr>
<tr><td><code id="contord_+3A_spearman">Spearman</code></td>
<td>

<p>if <code>TRUE</code>, the function finds Spearman's correlations (and it is not necessary to provide <code>support</code>), if <code>FALSE</code> (default) Pearson's correlations
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the correlation matrix of the discretized variables
</p>


<h3>Author(s)</h3>

<p>Alessandro Barbiero, Pier Alda Ferrari
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordcont">ordcont</a></code>, <code><a href="#topic+ordsample">ordsample</a></code>, <code><a href="#topic+corrcheck">corrcheck</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># consider 4 discrete variables
k &lt;- 4
# with these marginal distributions
marginal &lt;- list(0.4,c(0.3,0.6), c(0.25,0.5,0.75), c(0.1,0.2,0.8,0.9))
# generated discretizing a multivariate standard normal variable
# with correlation matrix
Sigma &lt;- matrix(0.5,4,4)
diag(Sigma) &lt;- 1
# the resulting correlation matrix for the discrete variables is
contord(marginal, Sigma)
# note all the correlations are smaller than the original 0.6
# change Sigma, adding a negative correlation
Sigma[1,2] &lt;- -0.15
Sigma[2,1] &lt;- Sigma[1,2]
Sigma
# checking whether Sigma is still positive definite
eigen(Sigma)$values # all &gt;0, OK
contord(marginal, Sigma)
</code></pre>

<hr>
<h2 id='corrcheck'>
Checking correlations for feasibility
</h2><span id='topic+corrcheck'></span>

<h3>Description</h3>

<p>The function returns the lower and upper bounds of the correlation coefficients of each pair of discrete variables given their marginal distributions, i.e., returns the range of feasible bivariate correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrcheck(marginal, support = list(), Spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrcheck_+3A_marginal">marginal</code></td>
<td>

<p>a list of <code class="reqn">k</code> elements, where <code class="reqn">k</code> is the number of variables.
The <code class="reqn">i</code>-th element of <code>marginal</code> is the vector of the cumulative probabilities defining the marginal distribution of the <code class="reqn">i</code>-th component of the  multivariate variable. If the <code class="reqn">i</code>-th component can take <code class="reqn">k_i</code> values, the <code class="reqn">i</code>-th element of <code>marginal</code> will contain <code class="reqn">k_i-1</code> probabilities (the <code class="reqn">k_i</code>-th is obviously 1 and shall not be included).
</p>
</td></tr>
<tr><td><code id="corrcheck_+3A_support">support</code></td>
<td>

<p>a list of <code class="reqn">k</code> elements, where <code class="reqn">k</code> is the number of variables. The <code class="reqn">i</code>-th element of <code>support</code> is the vector containing the ordered values of the support of the <code class="reqn">i</code>-th variable. By default, the support of the <code class="reqn">i</code>-th variable is <code class="reqn">1,2,...,k_i</code>
</p>
</td></tr>
<tr><td><code id="corrcheck_+3A_spearman">Spearman</code></td>
<td>

<p><code>TRUE</code> if we consider Spearman's correlation, <code>FALSE</code> (default) if we consider Pearson's correlation
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions returns a list of two matrices: the former contains the lower bounds, the latter the upper bounds of the feasible pairwise correlations (on the extra-diagonal elements)
</p>


<h3>Author(s)</h3>

<p>Alessandro Barbiero, Pier Alda Ferrari
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contord">contord</a></code>, <code><a href="#topic+ordcont">ordcont</a></code>, <code><a href="#topic+ordsample">ordsample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># four variables
k &lt;- 4
# with 2, 3, 4, and 5 categories (Likert scales, by default)
kj &lt;- c(2,3,4,5)
# and these marginal distributions (set of cumulative probabilities)
marginal &lt;- list(0.4, c(0.6,0.9), c(0.1,0.2,0.4), c(0.6,0.7,0.8,0.9))
corrcheck(marginal) # lower and upper bounds for Pearson's rho
corrcheck(marginal, Spearman=TRUE) # lower and upper bounds for Spearman's rho
# change the supports
support &lt;- list(c(0,1), c(1,2,4), c(1,2,3,4), c(0,1,2,5,10))
corrcheck(marginal, support=support) # updated bounds
</code></pre>

<hr>
<h2 id='GenOrd-package'>
Simulation of Discrete Random Variables with Given Correlation Matrix and Marginal Distributions
</h2><span id='topic+GenOrd-package'></span>

<h3>Description</h3>

<p>The package implements a procedure for generating samples from a multivariate discrete random variable with pre-specified correlation matrix and marginal distributions. The marginal distributions are linked together through a gaussian copula.
The procedure is developed in two steps: the first step (function <code><a href="#topic+ordcont">ordcont</a></code>) sets up the gaussian copula in order to achieve the desired correlation matrix on the target random discrete components; the second step (<code><a href="#topic+ordsample">ordsample</a></code>) generates samples from the target variables.
The procedure can handle both Pearson's and Spearman's correlations, and any finite support for the discrete variables.
The intermediate function <code><a href="#topic+contord">contord</a></code> computes the correlations of the multivariate discrete variable derived from correlated normal variables through discretization.
Function <code><a href="#topic+corrcheck">corrcheck</a></code> returns the lower and upper bounds of the correlation coefficient of each pair of discrete variables given their marginal distributions, i.e., returns the range of feasible bivariate correlations.
</p>
<p>This version has fixed some drawbacks in terminology in the previous version; the only actual change concerns the parameter <code>cormat</code> in the <code><a href="#topic+ordsample">ordsample</a></code> function. Further examples of implementation have been added.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GenOrd</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-09-11</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessandro Barbiero, Pier Alda Ferrari
</p>
<p>Maintainer: Alessandro Barbiero &lt;alessandro.barbiero@unimi.it&gt;
</p>


<h3>References</h3>

<p>P.A. Ferrari, A. Barbiero (2012) Simulating ordinal data, Multivariate Behavioral Research, 47(4), 566-589
</p>
<p>A. Barbiero, P.A. Ferrari (2014) Simulation of correlated Poisson variables. Applied Stochastic Models in Business and Industry, doi 10.1002/asmb.2072
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contord">contord</a></code>, <code><a href="#topic+ordcont">ordcont</a></code>, <code><a href="#topic+corrcheck">corrcheck</a></code>, <code><a href="#topic+ordsample">ordsample</a></code>
</p>

<hr>
<h2 id='ordcont'>
Computing the &quot;intermediate&quot; correlation matrix for the multivariate standard normal in order to achieve the &quot;target&quot; correlation matrix for the multivariate discrete variable
</h2><span id='topic+ordcont'></span>

<h3>Description</h3>

<p>The function computes the correlation matrix of the <code class="reqn">k</code>-dimensional standard normal r.v. yielding the desired correlation matrix <code>Sigma</code> for the <code class="reqn">k</code>-dimensional r.v. with desired marginal distributions <code>marginal</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordcont(marginal, Sigma, support = list(), Spearman = FALSE,
epsilon = 1e-06, maxit = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordcont_+3A_marginal">marginal</code></td>
<td>

<p>a list of <code class="reqn">k</code> elements, where <code class="reqn">k</code> is the number of variables.
The <code class="reqn">i</code>-th element of <code>marginal</code> is the vector of the cumulative probabilities defining the marginal distribution of the <code class="reqn">i</code>-th component of the  multivariate variable. If the <code class="reqn">i</code>-th component can take <code class="reqn">k_i</code> values, the <code class="reqn">i</code>-th element of <code>marginal</code> will contain <code class="reqn">k_i-1</code> probabilities (the <code class="reqn">k_i</code>-th is obviously 1 and shall not be included).
</p>
</td></tr>
<tr><td><code id="ordcont_+3A_sigma">Sigma</code></td>
<td>

<p>the target correlation matrix of the discrete variables
</p>
</td></tr>
<tr><td><code id="ordcont_+3A_support">support</code></td>
<td>

<p>a list of <code class="reqn">k</code> elements, where <code class="reqn">k</code> is the number of variables. The <code class="reqn">i</code>-th element of <code>support</code> is the vector containing the ordered values of the support of the <code class="reqn">i</code>-th variable. By default, the support of the <code class="reqn">i</code>-th variable is <code class="reqn">1,2,...,k_i</code>
</p>
</td></tr>
<tr><td><code id="ordcont_+3A_spearman">Spearman</code></td>
<td>

<p>if <code>TRUE</code>, the function finds Spearman's correlations (and it is not necessary to provide <code>support</code>), if <code>FALSE</code> (default) Pearson's correlations
</p>
</td></tr>
<tr><td><code id="ordcont_+3A_epsilon">epsilon</code></td>
<td>

<p>the maximum tolerated error between target and actual correlations
</p>
</td></tr>
<tr><td><code id="ordcont_+3A_maxit">maxit</code></td>
<td>

<p>the maximum number of iterations allowed for the algorithm
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of five elements
</p>
<table>
<tr><td><code>SigmaC</code></td>
<td>

<p>the correlation matrix of the multivariate standard normal variable
</p>
</td></tr>
<tr><td><code>SigmaO</code></td>
<td>

<p>the actual correlation matrix of the discretized variables (it should approximately coincide with the target correlation matrix <code>Sigma</code>)
</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>

<p>the target correlation matrix of the discrete variables
</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>

<p>a matrix containing the number of iterations performed by the algorithm, one for each pair of variables
</p>
</td></tr>
<tr><td><code>maxerr</code></td>
<td>

<p>the actual maximum error (the maximum absolute deviation between actual and target correlations of the discrete variables)
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For some choices of <code>marginal</code> and <code>Sigma</code>, there may not exist a feasible <code class="reqn">k</code>-variate probability mass function or the algorithm may not provide a feasible correlation matrix <code>SigmaC</code>. In this case, the procedure stops and exits with an error.
The value of the maximum tolerated absolute error <code>epsilon</code> on the elements of the correlation matrix for the target r.v. can be set by the user: a value between 1e-6 and 1e-2 seems to be an acceptable compromise assuring both the precision of the results and the convergence of the algorithm; moreover, a maximum number of iterations can be chosen (<code>maxit</code>), in order to avoid possible endless loops
</p>


<h3>Author(s)</h3>

<p>Alessandro Barbiero, Pier Alda Ferrari
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contord">contord</a></code>, <code><a href="#topic+ordsample">ordsample</a></code>, <code><a href="#topic+corrcheck">corrcheck</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># consider a 4-dimensional ordinal variable
k &lt;- 4
# with different number of categories
kj &lt;- c(2,3,4,5)
# and uniform marginal distributions
marginal &lt;- list(0.5, (1:2)/3, (1:3)/4, (1:4)/5)
corrcheck(marginal)
# and the following correlation matrix
Sigma &lt;- matrix(c(1,0.5,0.4,0.3,0.5,1,0.5,0.4,0.4,0.5,1,0.5,0.3,0.4,0.5,1),
4, 4, byrow=TRUE)
Sigma
# the correlation matrix of the standard 4-dimensional standard normal
# ensuring Sigma is
res &lt;- ordcont(marginal, Sigma)
res[[1]]
# change some marginal distributions
marginal &lt;- list(0.3, c(1/3, 2/3), c(1/5, 2/5, 3/5), c(0.1, 0.2, 0.4, 0.6))
corrcheck(marginal)
# and notice how the correlation matrix of the multivariate normal changes...
res &lt;- ordcont(marginal, Sigma)
res[[1]]
# change Sigma, adding a negative correlation
Sigma[1,2] &lt;- -0.2
Sigma[2,1] &lt;- Sigma[1,2]
Sigma
# checking whether Sigma is still positive definite
eigen(Sigma)$values # all &gt;0, OK
res &lt;- ordcont(marginal, Sigma)
res[[1]]
</code></pre>

<hr>
<h2 id='ordsample'>
Drawing a sample of discrete data
</h2><span id='topic+ordsample'></span>

<h3>Description</h3>

<p>The function draws a sample from a multivariate discrete variable with correlation matrix <code>Sigma</code> and prescribed marginal distributions <code>marginal</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>ordsample(n, marginal, Sigma, support = list(), Spearman = FALSE,
cormat = "discrete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordsample_+3A_n">n</code></td>
<td>

<p>the sample size
</p>
</td></tr>
<tr><td><code id="ordsample_+3A_marginal">marginal</code></td>
<td>

<p>a list of <code class="reqn">k</code> elements, where <code class="reqn">k</code> is the number of variables.
The <code class="reqn">i</code>-th element of <code>marginal</code> is the vector of the cumulative probabilities defining the marginal distribution of the <code class="reqn">i</code>-th component of the  multivariate variable. If the <code class="reqn">i</code>-th component can take <code class="reqn">k_i</code> values, the <code class="reqn">i</code>-th element of marginal will contain <code class="reqn">k_i-1</code> probabilities (the <code class="reqn">k_i</code>-th is obviously 1 and shall not be included).
</p>
</td></tr>
<tr><td><code id="ordsample_+3A_sigma">Sigma</code></td>
<td>

<p>the target correlation matrix of the multivariate discrete variable
</p>
</td></tr>
<tr><td><code id="ordsample_+3A_support">support</code></td>
<td>

<p>a list of <code class="reqn">k</code> elements, where <code class="reqn">k</code> is the number of variables. The <code class="reqn">i</code>-th element of <code>support</code> is the vector containing the ordered values of the support of the <code class="reqn">i</code>-th variable. By default, the support of the <code class="reqn">i</code>-th variable is <code class="reqn">1,2,...,k_i</code>
</p>
</td></tr>
<tr><td><code id="ordsample_+3A_spearman">Spearman</code></td>
<td>

<p>if <code>TRUE</code>, the function finds Spearman's correlations (and it is not necessary to provide <code>support</code>), if <code>FALSE</code> (default) Pearson's correlations 
</p>
</td></tr>
<tr><td><code id="ordsample_+3A_cormat">cormat</code></td>
<td>

<p><code>"discrete"</code> if the <code>Sigma</code> in input is the target correlation matrix of the multivariate discrete variable; <code>"continuous"</code> if the <code>Sigma</code> in input is the intermediate correlation matrix of the multivariate standard normal
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code class="reqn">n\times k</code> matrix of values drawn from the <code class="reqn">k</code>-variate discrete r.v. with the desired marginal distributions and correlation matrix
</p>


<h3>Author(s)</h3>

<p>Alessandro Barbiero, Pier Alda Ferrari
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contord">contord</a></code>, <code><a href="#topic+ordcont">ordcont</a></code>, <code><a href="#topic+corrcheck">corrcheck</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

# draw a sample from a bivariate ordinal variable
# with 4 of categories and asymmetrical marginal distributions
# and correlation coefficient 0.6 (to be checked)
k &lt;- 2
marginal &lt;- list(c(0.1,0.3,0.6), c(0.4,0.7,0.9))
corrcheck(marginal) # check ok
Sigma &lt;- matrix(c(1,0.6,0.6,1),2,2)
# sample size 1000
n &lt;- 1000
# generate a sample of size n
m &lt;- ordsample(n, marginal, Sigma)
head(m)
# sample correlation matrix
cor(m) # compare it with Sigma
# empirical marginal distributions
cumsum(table(m[,1]))/n
cumsum(table(m[,2]))/n # compare them with the two marginal distributions

# Example 1bis

# draw a sample from a bivariate ordinal variable
# with 4 of categories and asymmetrical marginal distributions
# and Spearman correlation coefficient 0.6 (to be checked)
k &lt;- 2
marginal &lt;- list(c(0.1,0.3,0.6), c(0.4,0.7,0.9))
corrcheck(marginal, Spearman=TRUE) # check ok
Sigma &lt;- matrix(c(1,0.6,0.6,1),2,2)
# sample size 1000
n &lt;- 1000
# generate a sample of size n
m &lt;- ordsample(n, marginal, Sigma, Spearman=TRUE)
head(m)
# sample correlation matrix
cor(rank(m[,1]),rank(m[,2])) # compare it with Sigma
# empirical marginal distributions
cumsum(table(m[,1]))/n
cumsum(table(m[,2]))/n # compare them with the two marginal distributions

# Example 1ter

# draw a sample from a bivariate random variable
# with binomial marginal distributions (n=3, p=1/3 and n=4, p=2/3)
# and Pearson correlation coefficient 0.6 (to be checked)
k &lt;- 2
marginal &lt;- list(pbinom(0:2, 3, 1/3),pbinom(0:3, 4, 2/3))
marginal
corrcheck(marginal, support=list(0:3, 0:4)) # check ok
Sigma &lt;- matrix(c(1,0.6,0.6,1),2,2)
# sample size 1000
n &lt;- 1000
# generate a sample of size n
m &lt;- ordsample(n, marginal, Sigma, support=list(0:3,0:4))
head(m)
# sample correlation matrix
cor(m) # compare it with Sigma
# empirical marginal distributions
cumsum(table(m[,1]))/n
cumsum(table(m[,2]))/n # compare them with the two marginal distributions

# Example 2

# draw a sample from a 4-dimensional ordinal variable
# with different number of categories and uniform marginal distributions
# and different correlation coefficients
k &lt;- 4
marginal &lt;- list(0.5, c(1/3,2/3), c(1/4,2/4,3/4), c(1/5,2/5,3/5,4/5))
corrcheck(marginal)
# select a feasible correlation matrix
Sigma &lt;- matrix(c(1,0.5,0.4,0.3,0.5,1,0.5,0.4,0.4,0.5,1,0.5,0.3,0.4,0.5,1),
4, 4, byrow=TRUE)
Sigma
# sample size 100
n &lt;- 100
# generate a sample of size n
set.seed(1)
m &lt;- ordsample(n, marginal, Sigma)
# sample correlation matrix
cor(m) # compare it with Sigma
# empirical marginal distribution
cumsum(table(m[,4]))/n # compare it with the fourth marginal
head(m)
# or equivalently...
set.seed(1)
res &lt;- ordcont(marginal, Sigma)
res[[1]] # the intermediate correlation matrix of the multivariate normal
m &lt;- ordsample(n, marginal, res[[1]], cormat="continuous")
head(m)

# Example 3
# simulation of two correlated Poisson r.v.
# modification to GenOrd sampling function for Poisson distribution
ordsamplep&lt;-function (n, lambda, Sigma) 
{
   k &lt;- length(lambda)
   valori &lt;- mvrnorm(n, rep(0, k), Sigma)
   for (i in 1:k)
   {
   valori[, i] &lt;- qpois(pnorm(valori[,i]), lambda[i])
   }
   return(valori)
}
# number of variables
k &lt;- 2
# Poisson parameters
lambda &lt;- c(2, 5)
# correlation matrix
Sigma &lt;- matrix(0.25, 2, 2)
diag(Sigma) &lt;- 1
# sample size
n &lt;- 10000
# preliminar stage: support TRUNCATION
# required for recovering the correlation matrix
# of the standard bivariate normal
# truncation error
epsilon &lt;- 0.0001
# corresponding maximum value
kmax &lt;- qpois(1-epsilon, lambda)
# truncated marginals
l &lt;- list()
for(i in 1:k)
{
l[[i]] &lt;- 0:kmax[i]
}
marg &lt;- list()
for(i in 1:k)
{
marg[[i]] &lt;- dpois(0:kmax[i],lambda[i])
marg[[i]][kmax[i]+1] &lt;- 1-sum(marg[[i]][1:(kmax[i])])
}
cm &lt;- list()
for(i in 1:k)
{
cm[[i]] &lt;- cumsum(marg[[i]])
cm[[i]] &lt;- cm[[i]][-(kmax[i]+1)]
}
# check feasibility of correlation matrix
RB &lt;- corrcheck(cm, support=l)
RL &lt;- RB[[1]]
RU &lt;- RB[[2]]
Sigma &lt;= RU &amp; Sigma &gt;= RL # OK
res &lt;- ordcont(cm, Sigma, support=l)
res[[1]]
Sigma &lt;- res[[1]]
# draw the sample
m &lt;- ordsamplep(n, lambda, Sigma)
# sample correlation matrix
cor(m)
head(m)

# Example 4
# simulation of 4 correlated binary and Poisson r.v.'s (2+2)
# modification to GenOrd sampling function
ordsamplep &lt;- function (n, marginal, lambda, Sigma) 
{
k &lt;- length(lambda)
valori &lt;- mvrnorm(n, rep(0, k), Sigma)
for(i in 1:k)
{
if(lambda[i]==0)
{
	valori[, i] &lt;- as.integer(cut(valori[, i], breaks = c(min(valori[,i]) - 1,
               qnorm(marginal[[i]]), max(valori[, i]) + 1)))
valori[, i] &lt;- support[[i]][valori[, i]]
}
else
{
	valori[, i] &lt;- qpois(pnorm(valori[,i]), lambda[i])
}
	}
return(valori)
}
# number of variables
k &lt;- 4
# Poisson parameters (only 3rd and 4th are Poisson)
lambda &lt;- c(0, 0, 2, 5)
# 1st and 2nd are Bernoulli with p=0.5
marginal &lt;- list()
marginal[[1]] &lt;- .5
marginal[[2]] &lt;- .5
marginal[[3]] &lt;- 0
marginal[[4]] &lt;- 0
# support
support &lt;- list()
support[[1]] &lt;- 0:1
support[[2]] &lt;- 0:1
# correlation matrix
Sigma &lt;- matrix(0.25, k, k)
diag(Sigma) &lt;- 1
# sample size
n &lt;- 10000
# preliminar stage: support TRUNCATION
# required for recovering the correlation matrix
# of the standard bivariate normal
# truncation error
epsilon &lt;- 0.0001
# corresponding maximum value
kmax &lt;- qpois(1-epsilon, lambda)
# truncated marginals
for(i in 3:4)
{
support[[i]] &lt;- 0:kmax[i]
}
marg &lt;- list()
for(i in 3:4)
{
marg[[i]] &lt;- dpois(0:kmax[i],lambda[i])
marg[[i]][kmax[i]+1] &lt;- 1-sum(marg[[i]][1:(kmax[i])])
}
for(i in 3:4)
{
marginal[[i]] &lt;- cumsum(marg[[i]])
marginal[[i]] &lt;- marginal[[i]][-(kmax[i]+1)]
}
# check feasibility of correlation matrix
RB &lt;- corrcheck(marginal, support=support)
RL &lt;- RB[[1]]
RU &lt;- RB[[2]]
Sigma &lt;= RU &amp; Sigma &gt;= RL # OK
# compute correlation matrix of the 4-variate standard normal
res &lt;- ordcont(marginal, Sigma, support=support)
res[[1]]
Sigma &lt;- res[[1]]
# draw the sample
m &lt;- ordsamplep(n, marginal, lambda, Sigma)
# sample correlation matrix
cor(m)
head(m)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
