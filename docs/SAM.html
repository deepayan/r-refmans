<!DOCTYPE html><html><head><title>Help for package SAM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SAM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SAM-package'><p>Sparse Additive Modelling</p></a></li>
<li><a href='#plot.samEL'><p>Plot function for S3 class <code>"samEL"</code></p></a></li>
<li><a href='#plot.samHL'><p>Plot function for S3 class <code>"samHL"</code></p></a></li>
<li><a href='#plot.samLL'><p>Plot function for S3 class <code>"samLL"</code></p></a></li>
<li><a href='#plot.samQL'><p>Plot function for S3 class <code>"samQL"</code></p></a></li>
<li><a href='#predict.samEL'><p>Prediction function for S3 class <code>"samEL"</code></p></a></li>
<li><a href='#predict.samHL'><p>Prediction function for S3 class <code>"samHL"</code></p></a></li>
<li><a href='#predict.samLL'><p>Prediction function for S3 class <code>"samLL"</code></p></a></li>
<li><a href='#predict.samQL'><p>Prediction function for S3 class <code>"samQL"</code></p></a></li>
<li><a href='#print.samEL'><p>Printing function for S3 class <code>"samEL"</code></p></a></li>
<li><a href='#print.samHL'><p>Printing function for S3 class <code>"samHL"</code></p></a></li>
<li><a href='#print.samLL'><p>Printing function for S3 class <code>"samLL"</code></p></a></li>
<li><a href='#print.samQL'><p>Printing function for S3 class <code>"samQL"</code></p></a></li>
<li><a href='#samEL'><p>Training function of Sparse Additive Possion Regression</p></a></li>
<li><a href='#samHL'><p>Training function of Sparse Additive Machine</p></a></li>
<li><a href='#samLL'><p>Training function of Sparse Additive Logistic Regression</p></a></li>
<li><a href='#samQL'><p>Training function of Sparse Additive Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Additive Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Haoming Jiang, Yukun Ma, Han Liu, Kathryn Roeder, Xingguo Li, and Tuo Zhao</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haoming Jiang &lt;jianghm.ustc@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14), splines</td>
</tr>
<tr>
<td>Description:</td>
<td>Computationally efficient tools for high dimensional predictive
        modeling (regression and classification). SAM is short for sparse 
        additive modeling, and adopts the computationally efficient basis 
        spline technique. We solve  the optimization problems by various 
        computational algorithms including the block coordinate descent 
        algorithm, fast iterative soft-thresholding algorithm, and newton method. 
        The computation is further accelerated by warm-start and active-set tricks.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-30 17:15:07 UTC; jhaoming</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-01 07:10:27 UTC</td>
</tr>
</table>
<hr>
<h2 id='SAM-package'>Sparse Additive Modelling</h2><span id='topic+SAM'></span><span id='topic+SAM-package'></span>

<h3>Description</h3>

<p>The package SAM targets at high dimensional predictive modeling (regression and classification) for complex data analysis. SAM is short for sparse additive modeling, and adopts the computationally efficient basis spline technique. We solve the optimization problems by various computational algorithms including the block coordinate descent algorithm, fast iterative soft-thresholding algorithm, and newton method. The computation is further accelerated by warm-start and active-set tricks.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> SAM</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 1.0.5</td>
</tr>
<tr>
 <td style="text-align: left;">
  Date: </td><td style="text-align: left;"> 2014-02-11</td>
</tr>
<tr>
 <td style="text-align: left;">
  License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Tuo Zhao, Xingguo Li, Haoming Jiang, Han Liu, and Kathryn Roeder<br />
Maintainers: Haoming Jiang&lt;hjiang98@gatech.edu&gt;;
</p>


<h3>References</h3>

<p>P. Ravikumar, J. Lafferty, H.Liu and L. Wasserman. &quot;Sparse Additive Models&quot;, <em>Journal of Royal Statistical Society: Series B</em>, 2009.<br />
T. Zhao and H.Liu. &quot;Sparse Additive Machine&quot;, <em>International Conference on Artificial Intelligence and Statistics</em>, 2012.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samQL">samQL</a></code>,<code><a href="#topic+samHL">samHL</a></code>,<code><a href="#topic+samLL">samLL</a></code>,<code><a href="#topic+samEL">samEL</a></code>
</p>

<hr>
<h2 id='plot.samEL'>Plot function for S3 class <code>"samEL"</code></h2><span id='topic+plot.samEL'></span>

<h3>Description</h3>

<p>This function plots the regularization path (regularization parameter versus functional norm)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samEL'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.samEL_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"samEL"</code></p>
</td></tr>
<tr><td><code id="plot.samEL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The horizontal axis is for the regularization parameters in log scale. The vertical axis is for the functional norm of each component.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samEL">samEL</a></code>
</p>

<hr>
<h2 id='plot.samHL'>Plot function for S3 class <code>"samHL"</code></h2><span id='topic+plot.samHL'></span>

<h3>Description</h3>

<p>This function plots the regularization path (regularization parameter versus functional norm)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samHL'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.samHL_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"samHL"</code></p>
</td></tr>
<tr><td><code id="plot.samHL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The horizontal axis is for the regularization parameters in log scale. The vertical axis is for the functional norm of each component.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samHL">samHL</a></code>
</p>

<hr>
<h2 id='plot.samLL'>Plot function for S3 class <code>"samLL"</code></h2><span id='topic+plot.samLL'></span>

<h3>Description</h3>

<p>This function plots the regularization path (regularization parameter versus functional norm)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samLL'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.samLL_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"samLL"</code></p>
</td></tr>
<tr><td><code id="plot.samLL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The horizontal axis is for the regularization parameters in log scale. The vertical axis is for the functional norm of each component.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samLL">samLL</a></code>
</p>

<hr>
<h2 id='plot.samQL'>Plot function for S3 class <code>"samQL"</code></h2><span id='topic+plot.samQL'></span>

<h3>Description</h3>

<p>This function plots the regularization path (regularization parameter versus functional norm)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samQL'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.samQL_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"samQL"</code></p>
</td></tr>
<tr><td><code id="plot.samQL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The horizontal axis is for the regularization parameters in log scale. The vertical axis is for the functional norm of each component.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samQL">samQL</a></code>
</p>

<hr>
<h2 id='predict.samEL'>Prediction function for S3 class <code>"samEL"</code></h2><span id='topic+predict.samEL'></span>

<h3>Description</h3>

<p>Predict the labels for testing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samEL'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.samEL_+3A_object">object</code></td>
<td>
<p>An object with S3 class <code>"samEL"</code>.</p>
</td></tr>
<tr><td><code id="predict.samEL_+3A_newdata">newdata</code></td>
<td>
<p>The testing dataset represented in a <code>n</code> by <code>d</code> matrix, where <code>n</code> is testing sample size and <code>d</code> is dimension.</p>
</td></tr>
<tr><td><code id="predict.samEL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The testing dataset is rescale to the samELe range, and expanded by the samELe spline basis functions as the training data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>expectations</code></td>
<td>

<p>Estimated expected counts also represented in a <code>n</code> by the length of <code>lambda</code> matrix, where <code>n</code> is testing sample size.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+samEL">samEL</a></code>
</p>

<hr>
<h2 id='predict.samHL'>Prediction function for S3 class <code>"samHL"</code></h2><span id='topic+predict.samHL'></span>

<h3>Description</h3>

<p>Predict the labels for testing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samHL'
predict(object, newdata, thol = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.samHL_+3A_object">object</code></td>
<td>
<p>An object with S3 class <code>"samHL"</code>.</p>
</td></tr>
<tr><td><code id="predict.samHL_+3A_newdata">newdata</code></td>
<td>
<p>The testing dataset represented in a <code>n</code> by <code>d</code> matrix, where <code>n</code> is testing sample size and <code>d</code> is dimension.</p>
</td></tr>
<tr><td><code id="predict.samHL_+3A_thol">thol</code></td>
<td>
<p>The decision value threshold for prediction. The default value is 0.5</p>
</td></tr>
<tr><td><code id="predict.samHL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The testing dataset is rescale to the samHLe range, and expanded by the samHLe spline basis functions as the training data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>values</code></td>
<td>

<p>Predicted decision values also represented in a <code>n</code> by the length of <code>lambda</code> matrix, where <code>n</code> is testing sample size.
</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>

<p>Predicted labels also represented in a <code>n</code> by the length of <code>lambda</code> matrix, where <code>n</code> is testing sample size. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+samHL">samHL</a></code>
</p>

<hr>
<h2 id='predict.samLL'>Prediction function for S3 class <code>"samLL"</code></h2><span id='topic+predict.samLL'></span>

<h3>Description</h3>

<p>Predict the labels for testing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samLL'
predict(object, newdata, thol = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.samLL_+3A_object">object</code></td>
<td>
<p>An object with S3 class <code>"samLL"</code>.</p>
</td></tr>
<tr><td><code id="predict.samLL_+3A_newdata">newdata</code></td>
<td>
<p>The testing dataset represented in a <code>n</code> by <code>d</code> matrix, where <code>n</code> is testing sample size and <code>d</code> is dimension.</p>
</td></tr>
<tr><td><code id="predict.samLL_+3A_thol">thol</code></td>
<td>
<p>The decision value threshold for prediction. The default value is 0.5</p>
</td></tr>
<tr><td><code id="predict.samLL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The testing dataset is rescale to the samLLe range, and expanded by the samLLe spline basis functions as the training data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>probs</code></td>
<td>

<p>Estimated Posterior Probability for Prediction also represented in a <code>n</code> by the length of <code>lambda</code> matrix, where <code>n</code> is testing sample size.
</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>

<p>Predicted labels also represented in a <code>n</code> by the length of <code>lambda</code> matrix, where <code>n</code> is testing sample size. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+samLL">samLL</a></code>
</p>

<hr>
<h2 id='predict.samQL'>Prediction function for S3 class <code>"samQL"</code></h2><span id='topic+predict.samQL'></span>

<h3>Description</h3>

<p>Predict the labels for testing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samQL'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.samQL_+3A_object">object</code></td>
<td>
<p>An object with S3 class <code>"samQL"</code>.</p>
</td></tr>
<tr><td><code id="predict.samQL_+3A_newdata">newdata</code></td>
<td>
<p>The testing dataset represented in a <code>n</code> by <code>d</code> matrix, where <code>n</code> is testing sample size and <code>d</code> is dimension.</p>
</td></tr>
<tr><td><code id="predict.samQL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The testing dataset is rescale to the samQLe range, and expanded by the samQLe spline basis functions as the training data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>values</code></td>
<td>

<p>Predicted values also represented in a <code>n</code> by the length of <code>lambda</code> matrix, where <code>n</code> is testing sample size.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+samQL">samQL</a></code>
</p>

<hr>
<h2 id='print.samEL'>Printing function for S3 class <code>"samEL"</code></h2><span id='topic+print.samEL'></span>

<h3>Description</h3>

<p>Summarize the information of the object with S3 class <code>samEL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samEL'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.samEL_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"samEL"</code></p>
</td></tr>
<tr><td><code id="print.samEL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output includes length and d.f. of the regularization path.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samEL">samEL</a></code>
</p>

<hr>
<h2 id='print.samHL'>Printing function for S3 class <code>"samHL"</code></h2><span id='topic+print.samHL'></span>

<h3>Description</h3>

<p>Summarize the information of the object with S3 class <code>samHL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samHL'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.samHL_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"samHL"</code></p>
</td></tr>
<tr><td><code id="print.samHL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output includes length and d.f. of the regularization path.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samHL">samHL</a></code>
</p>

<hr>
<h2 id='print.samLL'>Printing function for S3 class <code>"samLL"</code></h2><span id='topic+print.samLL'></span>

<h3>Description</h3>

<p>Summarize the information of the object with S3 class <code>samLL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samLL'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.samLL_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"samLL"</code></p>
</td></tr>
<tr><td><code id="print.samLL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output includes length and d.f. of the regularization path.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samLL">samLL</a></code>
</p>

<hr>
<h2 id='print.samQL'>Printing function for S3 class <code>"samQL"</code></h2><span id='topic+print.samQL'></span>

<h3>Description</h3>

<p>Summarize the information of the object with S3 class <code>samQL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'samQL'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.samQL_+3A_x">x</code></td>
<td>
<p>An object with S3 class <code>"samQL"</code></p>
</td></tr>
<tr><td><code id="print.samQL_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output includes length and d.f. of the regularization path.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samQL">samQL</a></code>
</p>

<hr>
<h2 id='samEL'>Training function of Sparse Additive Possion Regression</h2><span id='topic+samEL'></span>

<h3>Description</h3>

<p>The log-linear model is learned using training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samEL(
  X,
  y,
  p = 3,
  lambda = NULL,
  nlambda = NULL,
  lambda.min.ratio = 0.25,
  thol = 1e-05,
  max.ite = 1e+05,
  regfunc = "L1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samEL_+3A_x">X</code></td>
<td>
<p>The <code>n</code> by <code>d</code> design matrix of the training set, where <code>n</code> is sample size and <code>d</code> is dimension.</p>
</td></tr>
<tr><td><code id="samEL_+3A_y">y</code></td>
<td>
<p>The <code>n</code>-dimensional response vector of the training set, where <code>n</code> is sample size. Responses must be non-negative integers.</p>
</td></tr>
<tr><td><code id="samEL_+3A_p">p</code></td>
<td>
<p>The number of basis spline functions. The default value is 3.</p>
</td></tr>
<tr><td><code id="samEL_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on nlambda and lambda.min.ratio. Supplying a value of lambda overrides this. WARNING: use with care. Do not supply a single value for lambda. Supply instead a decreasing sequence of lambda values. samEL relies on its warms starts for speed, and its often faster to fit a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="samEL_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of lambda values. The default value is 20.</p>
</td></tr>
<tr><td><code id="samEL_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero). The default is 0.1.</p>
</td></tr>
<tr><td><code id="samEL_+3A_thol">thol</code></td>
<td>
<p>Stopping precision. The default value is 1e-5.</p>
</td></tr>
<tr><td><code id="samEL_+3A_max.ite">max.ite</code></td>
<td>
<p>The number of maximum iterations. The default value is 1e5.</p>
</td></tr>
<tr><td><code id="samEL_+3A_regfunc">regfunc</code></td>
<td>
<p>A string indicating the regularizer. The default value is &quot;L1&quot;. You can also assign &quot;MCP&quot; or &quot;SCAD&quot; to it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We adopt various computational algorithms including the block coordinate descent, fast iterative soft-thresholding algorithm, and newton method. The computation is further accelerated by &quot;warm-start&quot; and &quot;active-set&quot; tricks.
</p>


<h3>Value</h3>

<table>
<tr><td><code>p</code></td>
<td>

<p>The number of basis spline functions used in training.
</p>
</td></tr>
<tr><td><code>X.min</code></td>
<td>

<p>A vector with each entry corresponding to the minimum of each input variable. (Used for rescaling in testing)
</p>
</td></tr>
<tr><td><code>X.ran</code></td>
<td>

<p>A vector with each entry corresponding to the range of each input variable. (Used for rescaling in testing)
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>A sequence of regularization parameter used in training.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>The solution path matrix (<code>d*p+1</code> by length of <code>lambda</code>) with each column corresponding to a regularization parameter. Since we use the basis expansion with the intercept, the length of each column is <code>d*p+1</code>.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freedom of the solution path (The number of non-zero component function)
</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>

<p>The <code>p-1</code> by <code>d</code> matrix. Each column contains the knots applied to the corresponding variable.
</p>
</td></tr>
<tr><td><code>Boundary.knots</code></td>
<td>

<p>The <code>2</code> by <code>d</code> matrix. Each column contains the boundary points applied to the corresponding variable.
</p>
</td></tr>
<tr><td><code>func_norm</code></td>
<td>

<p>The functional norm matrix (<code>d</code> by length of <code>lambda</code>) with each column corresponds to a regularization parameter. Since we have <code>d</code> input variables, the length of each column is <code>d</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+SAM">SAM</a></code>,<code><a href="#topic+plot.samEL">plot.samEL</a>,<a href="#topic+print.samEL">print.samEL</a>,<a href="#topic+predict.samEL">predict.samEL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generating training data
n = 200
d = 100
X = 0.5*matrix(runif(n*d),n,d) + matrix(rep(0.5*runif(n),d),n,d)
u = exp(-2*sin(X[,1]) + X[,2]^2-1/3 + X[,3]-1/2 + exp(-X[,4])+exp(-1)-1+1)
y = rep(0,n)
for(i in 1:n) y[i] = rpois(1,u[i])

## Training
out.trn = samEL(X,y)
out.trn

## plotting solution path
plot(out.trn)

## generating testing data
nt = 1000
Xt = 0.5*matrix(runif(nt*d),nt,d) + matrix(rep(0.5*runif(nt),d),nt,d)
ut = exp(-2*sin(Xt[,1]) + Xt[,2]^2-1/3 + Xt[,3]-1/2 + exp(-Xt[,4])+exp(-1)-1+1)
yt = rep(0,nt)
for(i in 1:nt) yt[i] = rpois(1,ut[i])

## predicting response
out.tst = predict(out.trn,Xt)
</code></pre>

<hr>
<h2 id='samHL'>Training function of Sparse Additive Machine</h2><span id='topic+samHL'></span>

<h3>Description</h3>

<p>The classifier is learned using training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samHL(
  X,
  y,
  p = 3,
  lambda = NULL,
  nlambda = NULL,
  lambda.min.ratio = 0.4,
  thol = 1e-05,
  mu = 0.05,
  max.ite = 1e+05,
  w = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samHL_+3A_x">X</code></td>
<td>
<p>The <code>n</code> by <code>d</code> design matrix of the training set, where <code>n</code> is sample size and <code>d</code> is dimension.</p>
</td></tr>
<tr><td><code id="samHL_+3A_y">y</code></td>
<td>
<p>The <code>n</code>-dimensional label vector of the training set, where <code>n</code> is sample size. Labels must be coded in 1 and 0.</p>
</td></tr>
<tr><td><code id="samHL_+3A_p">p</code></td>
<td>
<p>The number of basis spline functions. The default value is 3.</p>
</td></tr>
<tr><td><code id="samHL_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on nlambda and lambda.min.ratio. Supplying a value of lambda overrides this. WARNING: use with care. Do not supply a single value for lambda. Supply instead a decreasing sequence of lambda values. samHL relies on its warms starts for speed, and its often faster to fit a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="samHL_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of lambda values. The default value is 20.</p>
</td></tr>
<tr><td><code id="samHL_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero). The default is 0.4.</p>
</td></tr>
<tr><td><code id="samHL_+3A_thol">thol</code></td>
<td>
<p>Stopping precision. The default value is 1e-5.</p>
</td></tr>
<tr><td><code id="samHL_+3A_mu">mu</code></td>
<td>
<p>Smoothing parameter used in approximate the Hinge Loss. The default value is 0.05.</p>
</td></tr>
<tr><td><code id="samHL_+3A_max.ite">max.ite</code></td>
<td>
<p>The number of maximum iterations. The default value is 1e5.</p>
</td></tr>
<tr><td><code id="samHL_+3A_w">w</code></td>
<td>
<p>The <code>n</code>-dimensional positive vector. It is the weight of each entry in the weighted loss. The default value is 1 for all entries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We adopt various computational algorithms including the block coordinate descent, fast iterative soft-thresholding algorithm, and newton method. The computation is further accelerated by &quot;warm-start&quot; and &quot;active-set&quot; tricks.
</p>


<h3>Value</h3>

<table>
<tr><td><code>p</code></td>
<td>

<p>The number of basis spline functions used in training.
</p>
</td></tr>
<tr><td><code>X.min</code></td>
<td>

<p>A vector with each entry corresponding to the minimum of each input variable. (Used for rescaling in testing)
</p>
</td></tr>
<tr><td><code>X.ran</code></td>
<td>

<p>A vector with each entry corresponding to the range of each input variable. (Used for rescaling in testing)
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>A sequence of regularization parameter used in training.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>The solution path matrix (<code>d*p+1</code> by length of <code>lambda</code>) with each column corresponding to a regularization parameter. Since we use the basis expansion with the intercept, the length of each column is <code>d*p+1</code>.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freedom of the solution path (The number of non-zero component function)
</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>

<p>The <code>p-1</code> by <code>d</code> matrix. Each column contains the knots applied to the corresponding variable.
</p>
</td></tr>
<tr><td><code>Boundary.knots</code></td>
<td>

<p>The <code>2</code> by <code>d</code> matrix. Each column contains the boundary points applied to the corresponding variable.
</p>
</td></tr>
<tr><td><code>func_norm</code></td>
<td>

<p>The functional norm matrix (<code>d</code> by length of <code>lambda</code>) with each column corresponds to a regularization parameter. Since we have <code>d</code> input variables, the length of each column is <code>d</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+SAM">SAM</a></code>,<code><a href="#topic+plot.samHL">plot.samHL</a>,<a href="#topic+print.samHL">print.samHL</a>,<a href="#topic+predict.samHL">predict.samHL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generating training data
n = 200
d = 100
X = 0.5*matrix(runif(n*d),n,d) + matrix(rep(0.5*runif(n),d),n,d)
y = sign(((X[,1]-0.5)^2 + (X[,2]-0.5)^2)-0.06)

## flipping about 5 percent of y
y = y*sign(runif(n)-0.05)

## Training
out.trn = samHL(X,y)
out.trn

## plotting solution path
plot(out.trn)

## generating testing data
nt = 1000
Xt = 0.5*matrix(runif(nt*d),nt,d) + matrix(rep(0.5*runif(nt),d),nt,d)

yt = sign(((Xt[,1]-0.5)^2 + (Xt[,2]-0.5)^2)-0.06)

## flipping about 5 percent of y
yt = yt*sign(runif(nt)-0.05)

## predicting response
out.tst = predict(out.trn,Xt)
</code></pre>

<hr>
<h2 id='samLL'>Training function of Sparse Additive Logistic Regression</h2><span id='topic+samLL'></span>

<h3>Description</h3>

<p>The logistic model is learned using training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samLL(
  X,
  y,
  p = 3,
  lambda = NULL,
  nlambda = NULL,
  lambda.min.ratio = 0.1,
  thol = 1e-05,
  max.ite = 1e+05,
  regfunc = "L1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samLL_+3A_x">X</code></td>
<td>
<p>The <code>n</code> by <code>d</code> design matrix of the training set, where <code>n</code> is sample size and <code>d</code> is dimension.</p>
</td></tr>
<tr><td><code id="samLL_+3A_y">y</code></td>
<td>
<p>The <code>n</code>-dimensional label vector of the training set, where <code>n</code> is sample size. Labels must be coded in 1 and 0.</p>
</td></tr>
<tr><td><code id="samLL_+3A_p">p</code></td>
<td>
<p>The number of basis spline functions. The default value is 3.</p>
</td></tr>
<tr><td><code id="samLL_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on nlambda and lambda.min.ratio. Supplying a value of lambda overrides this. WARNING: use with care. Do not supply a single value for lambda. Supply instead a decreasing sequence of lambda values. samLL relies on its warms starts for speed, and its often faster to fit a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="samLL_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of lambda values. The default value is 20.</p>
</td></tr>
<tr><td><code id="samLL_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero). The default is 0.1.</p>
</td></tr>
<tr><td><code id="samLL_+3A_thol">thol</code></td>
<td>
<p>Stopping precision. The default value is 1e-5.</p>
</td></tr>
<tr><td><code id="samLL_+3A_max.ite">max.ite</code></td>
<td>
<p>The number of maximum iterations. The default value is 1e5.</p>
</td></tr>
<tr><td><code id="samLL_+3A_regfunc">regfunc</code></td>
<td>
<p>A string indicating the regularizer. The default value is &quot;L1&quot;. You can also assign &quot;MCP&quot; or &quot;SCAD&quot; to it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We adopt various computational algorithms including the block coordinate descent, fast iterative soft-thresholding algorithm, and newton method. The computation is further accelerated by &quot;warm-start&quot; and &quot;active-set&quot; tricks.
</p>


<h3>Value</h3>

<table>
<tr><td><code>p</code></td>
<td>

<p>The number of basis spline functions used in training.
</p>
</td></tr>
<tr><td><code>X.min</code></td>
<td>

<p>A vector with each entry corresponding to the minimum of each input variable. (Used for rescaling in testing)
</p>
</td></tr>
<tr><td><code>X.ran</code></td>
<td>

<p>A vector with each entry corresponding to the range of each input variable. (Used for rescaling in testing)
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>A sequence of regularization parameter used in training.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>The solution path matrix (<code>d*p+1</code> by length of <code>lambda</code>) with each column corresponding to a regularization parameter. Since we use the basis expansion with the intercept, the length of each column is <code>d*p+1</code>.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freedom of the solution path (The number of non-zero component function)
</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>

<p>The <code>p-1</code> by <code>d</code> matrix. Each column contains the knots applied to the corresponding variable.
</p>
</td></tr>
<tr><td><code>Boundary.knots</code></td>
<td>

<p>The <code>2</code> by <code>d</code> matrix. Each column contains the boundary points applied to the corresponding variable.
</p>
</td></tr>
<tr><td><code>func_norm</code></td>
<td>

<p>The functional norm matrix (<code>d</code> by length of <code>lambda</code>) with each column corresponds to a regularization parameter. Since we have <code>d</code> input variables, the length of each column is <code>d</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+SAM">SAM</a></code>,<code><a href="#topic+plot.samLL">plot.samLL</a>,<a href="#topic+print.samLL">print.samLL</a>,<a href="#topic+predict.samLL">predict.samLL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generating training data
n = 200
d = 100
X = 0.5*matrix(runif(n*d),n,d) + matrix(rep(0.5*runif(n),d),n,d)
y = sign(((X[,1]-0.5)^2 + (X[,2]-0.5)^2)-0.06)

## flipping about 5 percent of y
y = y*sign(runif(n)-0.05)
y = sign(y==1)

## Training
out.trn = samLL(X,y)
out.trn

## plotting solution path
plot(out.trn)

## generating testing data
nt = 1000
Xt = 0.5*matrix(runif(nt*d),nt,d) + matrix(rep(0.5*runif(nt),d),nt,d)

yt = sign(((Xt[,1]-0.5)^2 + (Xt[,2]-0.5)^2)-0.06)

## flipping about 5 percent of y
yt = yt*sign(runif(nt)-0.05)
yt = sign(yt==1)

## predicting response
out.tst = predict(out.trn,Xt)
</code></pre>

<hr>
<h2 id='samQL'>Training function of Sparse Additive Models</h2><span id='topic+samQL'></span>

<h3>Description</h3>

<p>The regression model is learned using training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samQL(
  X,
  y,
  p = 3,
  lambda = NULL,
  nlambda = NULL,
  lambda.min.ratio = 0.005,
  thol = 1e-05,
  max.ite = 1e+05,
  regfunc = "L1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samQL_+3A_x">X</code></td>
<td>
<p>The <code>n</code> by <code>d</code> design matrix of the training set, where <code>n</code> is sample size and <code>d</code> is dimension.</p>
</td></tr>
<tr><td><code id="samQL_+3A_y">y</code></td>
<td>
<p>The <code>n</code>-dimensional response vector of the training set, where <code>n</code> is sample size.</p>
</td></tr>
<tr><td><code id="samQL_+3A_p">p</code></td>
<td>
<p>The number of basis spline functions. The default value is 3.</p>
</td></tr>
<tr><td><code id="samQL_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on nlambda and lambda.min.ratio. Supplying a value of lambda overrides this. WARNING: use with care. Do not supply a single value for lambda. Supply instead a decreasing sequence of lambda values. samQL relies on its warms starts for speed, and its often faster to fit a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="samQL_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of lambda values. The default value is 30.</p>
</td></tr>
<tr><td><code id="samQL_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for lambda, as a fraction of lambda.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero). The default is 5e-3.</p>
</td></tr>
<tr><td><code id="samQL_+3A_thol">thol</code></td>
<td>
<p>Stopping precision. The default value is 1e-5.</p>
</td></tr>
<tr><td><code id="samQL_+3A_max.ite">max.ite</code></td>
<td>
<p>The number of maximum iterations. The default value is 1e5.</p>
</td></tr>
<tr><td><code id="samQL_+3A_regfunc">regfunc</code></td>
<td>
<p>A string indicating the regularizer. The default value is &quot;L1&quot;. You can also assign &quot;MCP&quot; or &quot;SCAD&quot; to it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We adopt various computational algorithms including the block coordinate descent, fast iterative soft-thresholding algorithm, and newton method. The computation is further accelerated by &quot;warm-start&quot; and &quot;active-set&quot; tricks.
</p>


<h3>Value</h3>

<table>
<tr><td><code>p</code></td>
<td>

<p>The number of basis spline functions used in training.
</p>
</td></tr>
<tr><td><code>X.min</code></td>
<td>

<p>A vector with each entry corresponding to the minimum of each input variable. (Used for rescaling in testing)
</p>
</td></tr>
<tr><td><code>X.ran</code></td>
<td>

<p>A vector with each entry corresponding to the range of each input variable. (Used for rescaling in testing)
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>A sequence of regularization parameter used in training.
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>The solution path matrix (<code>d*p</code> by length of <code>lambda</code>) with each column corresponding to a regularization parameter. Since we use the basis expansion, the length of each column is <code>d*p+1</code>.
</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>

<p>The solution path of the intercept.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The degree of freedom of the solution path (The number of non-zero component function)
</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>

<p>The <code>p-1</code> by <code>d</code> matrix. Each column contains the knots applied to the corresponding variable.
</p>
</td></tr>
<tr><td><code>Boundary.knots</code></td>
<td>

<p>The <code>2</code> by <code>d</code> matrix. Each column contains the boundary points applied to the corresponding variable.
</p>
</td></tr>
<tr><td><code>func_norm</code></td>
<td>

<p>The functional norm matrix (<code>d</code> by length of <code>lambda</code>) with each column corresponds to a regularization parameter. Since we have <code>d</code> input variables, the length of each column is <code>d</code>.
</p>
</td></tr>
<tr><td><code>sse</code></td>
<td>

<p>Sums of square errors of the solution path.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+SAM">SAM</a></code>,<code><a href="#topic+plot.samQL">plot.samQL</a>,<a href="#topic+print.samQL">print.samQL</a>,<a href="#topic+predict.samQL">predict.samQL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generating training data
n = 100
d = 500
X = 0.5*matrix(runif(n*d),n,d) + matrix(rep(0.5*runif(n),d),n,d)

## generating response
y = -2*sin(X[,1]) + X[,2]^2-1/3 + X[,3]-1/2 + exp(-X[,4])+exp(-1)-1

## Training
out.trn = samQL(X,y)
out.trn

## plotting solution path
plot(out.trn)

## generating testing data
nt = 1000
Xt = 0.5*matrix(runif(nt*d),nt,d) + matrix(rep(0.5*runif(nt),d),nt,d)

yt = -2*sin(Xt[,1]) + Xt[,2]^2-1/3 + Xt[,3]-1/2 + exp(-Xt[,4])+exp(-1)-1

## predicting response
out.tst = predict(out.trn,Xt)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
