<!DOCTYPE html><html><head><title>Help for package gerbil</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gerbil}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cor_gerbil'><p>Correlation Analysis for <code>gerbil</code> Objects</p></a></li>
<li><a href='#gerbil'><p>General Efficient Regression-Based Imputation with Latent processes</p></a></li>
<li><a href='#gof_gerbil'><p>Goodness-of-fit testing for <code>gerbil</code> objects</p></a></li>
<li><a href='#ihd'><p>Example data from the India Human Development Survey</p></a></li>
<li><a href='#ihd_mar'><p>Missing at Random example data from the India Human Development Survey</p></a></li>
<li><a href='#ihd_mcar'><p>Missing Completely at Random example data from the India Human Development Survey</p></a></li>
<li><a href='#imputed'><p>Extracting imputed datasets from gerbil objects</p></a></li>
<li><a href='#plot.gerbil'><p>Plotting for gerbil objects</p></a></li>
<li><a href='#print.cor_gerbil'><p>Prints a <code>cor_gerbil</code> object. Printed output includes the average difference of correlations, as well as summaries of the test statistics based on Fisher's z and their p-values.</p></a></li>
<li><a href='#print.gerbil'><p>Prints a <code>gerbil</code> object. Printed output includes a variable-by-variable summary of variable types and missingness rates. The implemented predictor matrix is also provided.</p></a></li>
<li><a href='#print.gof_gerbil'><p>Prints a <code>gof_gerbil</code> object. Printed output pertains to the goodness-of-fit tests that are applied in order to compare the distribution between observed and imputed cases for relevant variables or variable pairs.</p></a></li>
<li><a href='#summary.cor_gerbil'><p>Summarises a <code>gerbil</code> object. Printed output includes a variable-by-variable summary of variable types and missingness rates. The implemented predictor matrix is also provided.</p></a></li>
<li><a href='#summary.gerbil'><p>Summarises a <code>gerbil</code> object. Printed output includes a variable-by-variable summary of variable types and missingness rates. The implemented predictor matrix is also provided.</p></a></li>
<li><a href='#summary.gof_gerbil'><p>Summarises a <code>gerbil</code> object. Printed output pertains to the goodness-of-fit tests that are applied in order to compare the distribution between observed and imputed cases for relevant variables or variable pairs.</p></a></li>
<li><a href='#write.gerbil'><p>Write imputed datasets from gerbil objects to a file or files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Efficient Regression-Based Imputation with Latent
Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.9</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Robbins [aut, cre],
  Max Griswold [ctb],
  Pedro Nascimento de Lima [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Robbins &lt;mrobbins@rand.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a new multiple imputation method that draws
    imputations from a latent joint multivariate normal model which
    underpins generally structured data. This model is constructed using a
    sequence of flexible conditional linear models that enables the
    resulting procedure to be efficiently implemented on high dimensional
    datasets in practice. See Robbins (2021) &lt;<a href="https://arxiv.org/abs/2008.02243">arXiv:2008.02243</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>base, DescTools, graphics, grDevices, lattice, MASS, mvtnorm,
openxlsx, parallel, pbapply, stats, truncnorm, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, knitr, mice, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-11 18:35:14 UTC; mrobbins</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-12 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cor_gerbil'>Correlation Analysis for <code>gerbil</code> Objects</h2><span id='topic+cor_gerbil'></span>

<h3>Description</h3>

<p>This function assesses the bivariate properties of imputed data using a correlation analysis.  
Specifically, it calculates pairwise correlations for observed cases and for imputed cases. 
The function also calculates the Fisher z-transformation for 
each correlation and performs a hypothesis test using the transformed correlations in order to 
compare correlations calculated using imputed cases to those calculated using observed cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_gerbil(x, y = NULL, imp = 1, log = NULL, partial = "imputed")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_gerbil_+3A_x">x</code></td>
<td>
<p>A <code>gerbil</code> object containing the imputed data.</p>
</td></tr>
<tr><td><code id="cor_gerbil_+3A_y">y</code></td>
<td>
<p>A vector listing the column names of the imputed data that will be included in the correlation analysis. By default, <code>y</code> contains all columns of the data that required imputation. If <code>TRUE</code>, all variables with missing values eligible for imputation are used.</p>
</td></tr>
<tr><td><code id="cor_gerbil_+3A_imp">imp</code></td>
<td>
<p>A scalar indicating which of the multiply imputed datasets should be used for the analysis.  Defaults to <code>imp = 1</code>.</p>
</td></tr>
<tr><td><code id="cor_gerbil_+3A_log">log</code></td>
<td>
<p>A character vector that includes names variable of which a log transformation is to be taken prior to calculating correlations.</p>
</td></tr>
<tr><td><code id="cor_gerbil_+3A_partial">partial</code></td>
<td>
<p>Indicates how partially imputed pairs are handled when calculating correlations. If <code>partial = 'imputed'</code>, cases with at least one missing variable in a pair are considered imputed. Otherwise (<code>partial = 'observed'</code>), only cases with both variables in the pair missing are considered imputed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cases are assigned a status of being observed or imputed in a pairwise fashion. That is, a specific 
data unit may be considered observed when calculating a correlation for one pair of variables and be
imputed when calculating a correlation for another pair. For a given pair of variables, cases that 
have both variables observed are always treated as observed, and cases that have both variables missing 
are always treated as imputed. Cases that have only one variable in the pair observed (i.e., those that are
partially imputed) are treated as imputed when the input <code>partial = 'imputed'</code> (the default) and are 
otherwise treated as observed.  
</p>
<p>Correlations are calculated across an expanded dataset that creates binary indicators for categorical variables and for semicontinuous variables.
Unlike the algorithm used to calculate the imputations, missingness is not artificially imposed in any binary indicator.  
Missingness is imposed, however, in the variable corresponding to the continuous portion of a semicontinuous variable. 
</p>
<p>Note that the hypothesis test based upon the Fisher z-transformation is based off of bivariate normal assumptions. 
As such, p-values may be misleading in data where this assumption does not hold.
</p>


<h3>Value</h3>

<p><code>cor_gerbil()</code> retuns an object of the class <code>cor_gerbil</code> that has following slots:
</p>

<dl>
<dt>Correlations</dt><dd><p>A list containing two elements &ndash; these are named <code>Observed</code>, <code>Imputed</code>, and <code>All</code>. The first is a matrix giving the sample correlations when calculated across cases labeled as observed. The second and third are analogous correlation matrices calculated across only cases labeled as imputed and across all cases, respectively.</p>
</dd>
<dt>n</dt><dd><p>A list containing two elements &ndash; these are named <code>Observed</code>, <code>Imputed</code>, and <code>All</code>. The first is a matrix giving number of cases in the respective pair of variables that have been labeled as observed. The second and third are analogous matrices indicating the number of cases labeled as imputed for each pair and indicating the total number of cases for each pair, respectively.</p>
</dd>
<dt>Fisher.Z</dt><dd><p>A list containing two elements &ndash; these are named <code>Observed</code>, <code>Imputed</code>, and <code>All</code>. These matrices give the Fisher z-transformation of the correlations in the matrices provided in the slot <code>Correlations</code>.</p>
</dd> 
<dt>Statistic</dt><dd><p>A matrix that gives the value of the test statistic based on the Fisher z-transformation for each pair of variables. This statistic may be used to assess whether the correlations calculated across cases labeled as observed are statistically different from the correlations calculated across cases labeled as imputed.</p>
</dd>
<dt>p.value</dt><dd><p>A matrix that list the p-value for each test statistic provided in the matrix in the slot labeled <code>Statistic</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
#Load the India Human Development Survey-II dataset
data(ihd_mcar) 

imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, mcmciter = 100, ords = "education_level", 
       semi = "farm_labour_days", bincat = c("sex", "marital_status", "job_field", "own_livestock"))

#Run the correlation analysis
cors.gerbil &lt;- cor_gerbil(imps.gerbil, imp = 1)

#Print a summary
cors.gerbil

</code></pre>

<hr>
<h2 id='gerbil'>General Efficient Regression-Based Imputation with Latent processes</h2><span id='topic+gerbil'></span>

<h3>Description</h3>

<p>Coherent multiple imputation of general multivariate data as implemented through the GERBIL algorithm described by Robbins (2020).  The algorithm is
</p>

<ul>
<li> <p><strong>coherent</strong> in that imputations are sampled from a valid joint distribution, ensuring MCMC convergence;
</p>
</li>
<li> <p><strong>general</strong> in that data of general structure (binary, categorical, continuous, etc.) may be allowed;
</p>
</li>
<li> <p><strong>efficient</strong> in that computational performance is optimized using the SWEEP operator for both modeling and sampling;
</p>
</li>
<li> <p><strong>regression-based</strong> in that the joint distribution is built through a sequence of conditional regression models;
</p>
</li>
<li> <p><strong>latent</strong> in that a latent multivariate normal process underpins all variables; and
</p>
</li>
<li> <p><strong>flexible</strong> in that the user may specify which dependencies are enabled within the conditional models.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>gerbil(
  dat,
  m = 1,
  mcmciter = 25,
  predMat = NULL,
  type = NULL,
  visitSeq = NULL,
  ords = NULL,
  semi = NULL,
  bincat = NULL,
  cont.meth = "EMP",
  num.cat = 12,
  r = 5,
  verbose = TRUE,
  n.cores = NULL,
  cl.type = NULL,
  mass = rep(0, length(semi)),
  ineligible = NULL,
  trace = TRUE,
  seed = NULL,
  fully.syn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gerbil_+3A_dat">dat</code></td>
<td>
<p>The dataset that is to be imputed.  Missing values must be coded with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_m">m</code></td>
<td>
<p>The number of multiply imputed datasets to be created.  By default, <code>m = 1</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_mcmciter">mcmciter</code></td>
<td>
<p>The number of iterations of Markov chain Monte Carlo that will be used to create each imputed dataset. By default, <code>m = 25</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_predmat">predMat</code></td>
<td>
<p>A numeric matrix of <code>ncol(dat)</code> columns and no more than <code>nrow(dat)</code> rows, containing 0/1 data specifying the set of predictors to be used for each target row. Each row corresponds to a variable. A value of 1 means that the column variable is used as a predictor for the variable in the target row. By default, <code>predMat</code> is a square matrix of <code>ncol(dat)</code> rows and columns with 1's below the diagonal and 0's on and above the diagonal.  Any non-zero value on or above the diagonal will be set to zero.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_type">type</code></td>
<td>
<p>A named vector that gives the type of each variable contained in <code>dat</code>.  Possible types include <code>'binary'</code>, <code>'categorical'</code>, <code>'ordinal'</code>, <code>'semicont'</code> (semi-continuous), and <code>'continuous'</code>.  The vector type should be named where the names indicate the corresponding column of <code>dat</code>.  Types for variables not listed in type will be determined by default, in which case a variable with no more than <code>num.cat</code> possible values will be set as binary/categorical and is set as continuous otherwise.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_visitseq">visitSeq</code></td>
<td>
<p>A vector of variable names that has (at least) contains all names of each column of <code>dat</code> that has missing values.  Within the I-Step and P-Step of gerbil, the variables will be modeled and imputed in the sequence given by <code>visitSeq</code>.   If <code>visitSeq = TRUE</code>, <code>visitSeq</code> is reset as being equal to the columns of <code>dat</code> ordered from least to most missingness.  If <code>visitSeq = NULL</code> (the default) or <code>visitSeq = FALSE</code> variables are ordered in accordance with the order of the rows of <code>predMat</code> or (if unavailable) the order in which they appear in the <code>dat</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_ords">ords</code></td>
<td>
<p>A character string giving a set of the column names of <code>dat</code> that indicate which variables are to be treated as ordinal. Elements of <code>ords</code> are overridden by any conflicting information in <code>type</code>. By default, <code>ords = NULL</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_semi">semi</code></td>
<td>
<p>A character string giving a set of the column names of <code>dat</code> that indicate which variables are to be treated as semi-continuous. Elements of <code>semi</code> are overridden by any conflicting information in <code>type</code>. By default, <code>semi = NULL</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_bincat">bincat</code></td>
<td>
<p>A character string giving a set of the column names of <code>dat</code> that indicate which variables are to be treated as binary or unordered categorical. Elements of <code>bincat</code> are overridden by any conflicting information in <code>type</code>. By default, <code>bincat = NULL</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_cont.meth">cont.meth</code></td>
<td>
<p>The type of marginal transformation used for continuous variables.  Set to <code>"EMP"</code> by default for the empirical distribution transformation of Robbins (2014). The current version also includes an option for no transformation (<code>cont.meth = "none"</code>). Other transformation types will be available in future versions of <code>gerbil</code>.  .</p>
</td></tr>
<tr><td><code id="gerbil_+3A_num.cat">num.cat</code></td>
<td>
<p>Any variable that does not have a type specified by any of the other parameters will be treated as categorical if it takes on no more than <code>num.cat</code> possible values and as continuous if it takes on more than <code>num.cat</code> possible values. By default, <code>num.cat = 12</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_r">r</code></td>
<td>
<p>The number of pairwise completely observed cases that must be available for any pair of variables to have dependencies enabled within the conditional models for imputation. By default, <code>r = 5</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (the default), history is printed on console. Use <code>verbose = FALSE</code> for silent computation.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_n.cores">n.cores</code></td>
<td>
<p>The number of CPU cores to use for parallelization. If <code>n.cores</code> is not specified by the user, it is guessed using the <code>detectCores</code> function in the parallel package.  If <code>TRUE</code>  (the default), it is set as <code>detectCores()</code>.  If <code>NULL</code>, it is set as <code>floor((detectCores()+1)/2)</code>.  If <code>FALSE</code>, it is set as <code>1</code>, in which case parallelization is not invoked.  Note that the documentation for <code>detectCores</code> makes clear that it is not failsafe and could return a spurious number of available cores. By default, <code>n.cores</code> is set as <code>floor((n + 1)/2)</code>, where <code>n</code> is the number of available clusters.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_cl.type">cl.type</code></td>
<td>
<p>The cluster type that is passed into the <code>makeCluster()</code> function in the <code>parallel</code> package.  Defaults to <code>'PSOCK'</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_mass">mass</code></td>
<td>
<p>A named vector of the same length as the number of semi-continuous variables in <code>dat</code> that gives the location (value) of the point mass for each such variable. The point of mass for each semicontinuous variable is set to zero by default.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_ineligible">ineligible</code></td>
<td>
<p>Either a scalar or a matrix that is used to determined which values are to be considered missing but ineligible for imputation. Such values will be imputed internally within <code>gerbil</code> to ensure a coherent imputation model but will be reset as missing after imputations have been created. If <code>ineligible</code> is a scalar, all data points that take on the respective value will be considered missing but ineligible for imputation. If <code>ineligible</code> is a matrix (with the same number of rows as <code>dat</code> and column names that overlap with <code>dat</code>), entries of <code>TRUE</code> or <code>1</code> in <code>ineligible</code> indicate values that are missing but ineligible for imputation. If <code>ineligible = NULL</code> (the default), all missing values will be considered eligible for imputation.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_trace">trace</code></td>
<td>
<p>A logical that, if <code>TRUE</code>, implies that means and variances of variables are tracked across iterations. Set to <code>FALSE</code> to save computation time. However, trace plots and R hat statistics are disabled for <code>gerbil</code> objects created with <code>trace = FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_seed">seed</code></td>
<td>
<p>An integer that, when specified, is used to set the random number generator via <code>set.seed()</code>.</p>
</td></tr>
<tr><td><code id="gerbil_+3A_fully.syn">fully.syn</code></td>
<td>
<p>A logical that, if <code>TRUE</code>, implies that a fully synthetic dataset will be created (although variables without missingness are not altered).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gerbil</code> is designed to handle the following classes of variables:
</p>

<ul>
<li> <p><code>'continuous'</code>: Variables are transformed to be (nearly) standard normal prior to imputation. The default transformation method is based on empirical distributions (see Robbins, 2014) and ensures that imputed values of a variable are sampled from the observed values of that variable.
</p>
</li>
<li> <p><code>'binary'</code>: Dichotomous variables are handled through probit-type models in that they are underpinned by a unit-variance normally distributed random variable.
</p>
</li>
<li> <p><code>'categorical'</code>: Unordered categorical variables are handled by creating nested binary variables that underpin the categorical data.  Missingness is artificially imposed in the nested variables in order to ensure conditional independence between them.  See Robbins (2020) for details.
</p>
</li>
<li> <p><code>'ordinal'</code>: Ordered categorical variables (ordinal) are handled through a probit-type model in that a latent normal distribution is assumed to underpin the ordinal observations.  See Robbins (2020) for details.
</p>
</li>
<li> <p><code>'semicont'</code>: Mixed discrete/continuous (semi-continuous) variables are assumed to observe a mass at a specific value (most often zero) and are continuous otherwise.  A binary variable is created that indicates whether the semi-continuous variable takes on the point-mass value; the continuous portion is set as missing when the observed semi-continuous variable takes on the value at the point-mass.  See Robbins et al. (2013) for details.
</p>
</li></ul>

<p>The parameter <code>type</code> allows the user to specify the class for each variable.  Routines are in place to establish the class by default for variables not stated in <code>type</code>. Note that it is not currently possible for a variable to be assigned a class of semi-continuous by default.
</p>
<p><code>gerbil</code> uses a joint modeling approach to imputation that builds a joint model using a sequence of conditional models, as outlined in Robbins et al. (2013).
This approach differs from fully conditional specification in that the regression model for any given variable is only allowed to depend upon variables that preceed it in an index ordering.
The order is established by the parameter <code>visitSeq</code>. <code>gerbil</code> contains the flexibility to allow its user to establish which of the permissible dependencies are enabled within the conditional models.
Enabled dependencies are stated within the parameter <code>predMat</code>.  Note that the data matrix used for imputation is an expanded version of the data that are fed into the algorithm (variables are created that underpin unordered categorical and semi-continuous variables).
Note also that conditional dependencies between the nested binary variables of a single undordered categorical variables or the discrete and continuous portions of a semi-continuous variable are not permitted.
</p>
<p>The output of <code>gerbil</code> is an object of class <code>gerbil</code> which is a list that contains the imputed datasets (<code>imputed</code>), missingness indicators (<code>missing</code> and <code>missing.latent</code>), summary information (<code>summary</code>), output used for MCMC convergence diagostics (<code>chainSeq</code> and <code>R.hat</code>),
and modeling summaries (<code>visitSeq.initial</code>, <code>visitSeq.final</code>, <code>predMat.initial</code>, <code>predMat.final</code>, <code>drops</code>, and <code>forms</code>).
Some output regarding convergence diagnostics and modeling regards the expanded dataset used for imputation (the expanded dataset includes binary indicators for unordered categorical and semi-continuous variables).
Note that the nested binary variables corresponding to an unordered categorical variable <code>X</code> with categories labeled <code>a</code>, <code>b</code>, <code>c</code>, etc., are named <code>X.a</code>, <code>X.b</code>, <code>X.c</code>, and so forth in the expanded dataset.
Likewise, the binary variable indicating the point mass of a semi-continuous variable <code>Y</code> is named <code>Y.B</code> in the expanded dataset, and the positive portion (with missingness imposed) is left as being named <code>Y</code>.
</p>
<p><code>gerbil</code> automatically checks each regression model for perfect collinearities and reduces the model as needed. 
Variables that have been dropped from a given model are listed in the element named <code>'drops'</code> in a <code>gerbil</code> object.
</p>


<h3>Value</h3>

<p><code>gerbil()</code> returns an object the class <code>gerbil</code> that contains the following slots:
</p>

<dl>
<dt>imputed</dt><dd><p>A list of length <code>m</code> that contains the imputed datasets.</p>
</dd>
<dt>missing</dt><dd><p>A matrix <code>0</code>s, <code>1</code>s, <code>2</code>s, and <code>4</code>s of the same dimension as <code>dat</code> that indicates which values were observed or missing.  A <code>0</code> indicates a fully observed value, a <code>1</code> indicates a missing value that was imputed, and a <code>4</code> indicates a missing value that was ineligible for imputation.</p>
</dd>
<dt>summary</dt><dd><p>A matrix with <code>ncol(dat)</code> number of rows that contains summary information, including the type of each variable and missingness rates. Note that for continuous variables, the type listed indicates the method of transformation used.</p>
</dd>
<dt>chainSeq</dt><dd><p>A list of six elements. Each element is a matrix with <code>mcmciter</code> columns and up to <code>ncol(dat)</code> rows. Objects <code>means.all</code> and <code>means.mis</code> give the variables means of data process across iterations of MCMC when all observations are incorporated and when only imputed values are incorporated, respectively. (Means of continuous variables are given on the transformed scale.) Similar objects are provided to track variances of variables. Variables are listed in the order provided by the <code>gerbil</code> object <code>visitSeq.latent</code>. Variables reported in this output are those contained in the dataset that has been expanded to include binary indicators for categorical and semi-continuous variables.</p>
</dd>
<dt>R.hat</dt><dd><p>The value of the R hat statistics of Gelman and Rubin (1992) for the means and variances of each variable. The R hat statistic is also provided for mean of binary variables.  Variables include those contained in the expanded dataset and are listed in the order provided by object <code>visitSeq.latent</code>. Only calculated if <code>m &gt; 2</code> and <code>mcmciter &gt;= 4</code>.</p>
</dd>
<dt>missing.latent</dt><dd><p>A matrix of the same dimensions as the expanded dataset, but used to indicate missingness in the expanded dataset. In this matrix, <code>0</code>s indicate fully observed values, <code>1</code>s indicate fully missing values, <code>3</code>s indicate values that have imposed missingness (for binary indicators corresponding to categorical or semi-continuous variables), and <code>4</code> indicates a missing value that is ineligible for imputation (as determined by the input <code>'ineligible'</code>)..</p>
</dd>
<dt>visitSeq.initial</dt><dd><p>A vector of variable names giving the sequential ordering of variables that is used for imputation prior to expanding the dataset include nested binary and point-mass indicators.  Variables without missing values are excluded.</p>
</dd>
<dt>visitSeq.final</dt><dd><p>A vector of variable names giving the sequential ordering of variables in the expanded dataset that is used for imputation.  Variables without missing values are excluded.</p>
</dd>
<dt>predMat.initial</dt><dd><p>A matrix of ones and zeros indicating the dependencies enabled in the conditional models used for imputation.  This matrix is determined from the input 'predMat'. Rows corresponding to variables with no missing values are removed.</p>
</dd>
<dt>predMat.final</dt><dd><p>A matrix of ones and zeros indicating the dependencies enabled in the conditional models used for imputation.  This is of a similar format to the input 'predMat' but pertains to the expanded dataset.  Rows corresponding to variables with no missing values are removed.</p>
</dd>
<dt>drops</dt><dd><p>A list of length equal to the number of variables in the expanded dataset that have missing values.  Elements of the list indicate which variables were dropped from the conditional model for the corresponding variable due to either insufficient pairwise complete observations (see the input 'r') or perfect collinearities.</p>
</dd>
<dt>forms</dt><dd><p>A list of length equal to the number of variables in the expanded dataset that have missing values.  Elements of the list indicate the regression formula used for imputation of the respective variable.</p>
</dd>
<dt>mass.final</dt><dd><p>The final version of the input parameter <code>mass</code>.</p>
</dd>
<dt>ineligibles</dt><dd><p>A logical matrix with the same number of rows and columns as <code>dat</code> that indicates which elements are considered missing but ineligible for imputation.</p>
</dd>
<dt>nams.out</dt><dd><p>A vector used to link column names in the expanded data to corresponding names in the original data.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gelman, A., &amp; Rubin, D. B. (1992). Inference from iterative simulation using multiple sequences. <em>Statistical Science</em>, 7(4), 457-472.
</p>
<p>Robbins, M. W. (2014). The Utility of Nonparametric Transformations for Imputation of Survey Data. <em>Journal of Official Statistics</em>, 30(4), 675-700.
</p>
<p>Robbins, M. W. (2020). A flexible and efficient algorithm for joint imputation of general data. arXiv preprint arXiv:2008.02243.
</p>
<p>Robbins, M. W., Ghosh, S. K., &amp; Habiger, J. D. (2013). Imputation in high-dimensional economic data as applied to the Agricultural Resource Management Survey. <em>Journal of the American Statistical Association</em>, 108(501), 81-95.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the India Human Development Survey-II dataset
data(ihd_mcar) 

# Gerbil without types specified
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, mcmciter = 10)

# Gerbil with types specified (method #1)
types.gerbil &lt;- c(
       sex = "binary", age = "continuous", 
       marital_status = "binary", job_field = "categorical", 
       farm_labour_days = "semicont", own_livestock = "binary", 
       education_level = "ordinal", income = "continuous")
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, type = types.gerbil)

# Gerbil with types specified (method #2)
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, ords = "education_level", semi = "farm_labour_days", 
       bincat = c("sex", "marital_status", "job_field", "own_livestock"))

# Gerbil with types specified (method #3)
types.gerbil &lt;- c("binary", "continuous", "binary", "categorical", "semicont", 
       "binary", "ordinal", "continuous")
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, type = types.gerbil)

# Variables of class factor are treated as binary/categorical by default
ihd.fac &lt;- ihd_mcar
ihd.fac$sex &lt;- factor(ihd_mcar$sex)
ihd.fac$marital_status &lt;- factor(ihd_mcar$marital_status)
ihd.fac$job_field &lt;- factor(ihd_mcar$job_field)
ihd.fac$own_livestock &lt;- factor(ihd_mcar$own_livestock)
ihd.fac$education_level &lt;- ordered(ihd_mcar$education_level)
imps.gerbil &lt;- gerbil(ihd.fac, m = 1)

# Univariate plotting of one variable
plot(imps.gerbil, type = 1, y = "job_field")

# gerbil with predMat specified (method #1)
predMat &lt;- matrix(c(1, 0, 0, 1), 2, 2)
dimnames(predMat) &lt;- list(c("education_level", "income"), c("sex", "job_field"))
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, type = types.gerbil, predMat = predMat)

# gerbil with predMat specified (method #2)
predMat &lt;- rbind(
       c(0, 0, 0, 0, 0, 0, 0, 0), 
       c(1, 0, 0, 0, 0, 0, 0, 0), 
       c(1, 1, 0, 0, 0, 0, 0, 0), 
       c(1, 1, 1, 0, 0, 0, 0, 0), 
       c(1, 1, 1, 1, 0, 0, 0, 0), 
       c(1, 1, 1, 1, 1, 0, 0, 0), 
       c(1, 1, 1, 0, 1, 1, 0, 0), 
       c(0, 1, 1, 1, 1, 1, 1, 0) 
       )
imps.gerbil &lt;- gerbil(ihd_mcar, type = types.gerbil, predMat = predMat)

# Multiple imputation with more iterations
imps.gerbil.5 &lt;- gerbil(ihd_mcar, m = 5, mcmciter = 100, ords = "education_level", 
       semi = "farm_labour_days", bincat = "job_field", n.cores = 1)

plot(imps.gerbil.5, type = 1, y = "job_field", imp = 1:5) 

# Extract the first imputed dataset
imputed.gerb &lt;- imputed(imps.gerbil.5, imp = 1)

# Write all imputed datasets to an Excel file
write.gerbil(imps.gerbil.5, file = file.path(tempdir(), "gerbil_example.xlsx"), imp = 1:5)


## Not run: 
if(requireNamespace('mice')){
# Impute using mice for comparison

types.mice &lt;- c("logreg", "pmm", "logreg", "polyreg", "pmm", "logreg", "pmm", "pmm")
imps.mice &lt;- mice(ihd.fac, m = 1, method = types.mice, maxit = 100)

imps.mice1 &lt;- mice(ihd.fac, m = 1, method = "pmm", maxit = 100)

imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, mcmciter = 100, ords = "education_level", 
    semi = "farm_labour_days", bincat = "job_field")

# Compare the performance of mice and gerbil

# Replace some gerbil datasets with mice datasets
imps.gerbil.m &lt;- imps.gerbil.5
imps.gerbil.m$imputed[[2]] &lt;- complete(imps.mice, action = 1)
imps.gerbil.m$imputed[[3]] &lt;- complete(imps.mice1, action = 1)

# Perform comparative correaltion analysis
cor_gerbil(imps.gerbil.m, imp = 1, log = "income")
cor_gerbil(imps.gerbil.m, imp = 2, log = "income")
cor_gerbil(imps.gerbil.m, imp = 3, log = "income")

# Perform comparative univariate goodness-of-fit testing
gof_gerbil(imps.gerbil.m, type = 1, imp = 1)
gof_gerbil(imps.gerbil.m, type = 1, imp = 2)
gof_gerbil(imps.gerbil.m, type = 1, imp = 3)

# Perform comparative bivariate goodness-of-fit testing
gof_gerbil(imps.gerbil.m, type = 2, imp = 1)
gof_gerbil(imps.gerbil.m, type = 2, imp = 2)
gof_gerbil(imps.gerbil.m, type = 2, imp = 3)

# Produce univariate plots for comparisons 
plot(imps.gerbil.m, type = 1, file = file.path(tempdir(), "gerbil_vs_mice_univariate.pdf"), 
     imp = c(1, 2, 3), log = "income", lty = c(1, 2, 4, 5), col = c("blue4", "brown2", 
     "green3", "orange2"), legend = c("Observed", "gerbil", "mice: logistic", "mice: pmm"))

### Produce bivariate plots for comparisons 
plot(imps.gerbil.m, type = 2, file = file.path(tempdir(), "gerbil_vs_mice_bivariate.pdf"), 
    imp = c(1, 2, 3), log = "income", lty = c(1, 2, 4, 5), col = c("blue4", "brown2", 
    "green3", "orange2"), pch = c(1, 3, 4, 5), legend = c("Observed", "gerbil", 
    "mice: logistic", "mice: pmm"))

}

## End(Not run)
</code></pre>

<hr>
<h2 id='gof_gerbil'>Goodness-of-fit testing for <code>gerbil</code> objects</h2><span id='topic+gof_gerbil'></span>

<h3>Description</h3>

<p>Using a <code>gerbil</code> object as an input, this function performs univariate and bivariate goodness-of-fit tests
to compare distributions of imputed and observed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof_gerbil(
  x,
  y = NULL,
  type = 1,
  imp = 1,
  breaks = NULL,
  method = c("chi-squared", "fisher", "G"),
  ks = FALSE,
  partial = "imputed",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_gerbil_+3A_x">x</code></td>
<td>
<p>A <code>gerbil</code> object containing the imputed data.</p>
</td></tr>
<tr><td><code id="gof_gerbil_+3A_y">y</code></td>
<td>
<p>A vector listing the column names of the imputed data for which tests should be run. See details. By default, <code>y</code> contains all columns of the data that required imputation.</p>
</td></tr>
<tr><td><code id="gof_gerbil_+3A_type">type</code></td>
<td>
<p>A scalar used to specify the type of tests that will be performed.  Options include univariate (marginal) tests (<code>type = 1</code>) and bivariate tests (<code>type = 2</code>). See details. Defaults to <code>type = 1</code>.</p>
</td></tr>
<tr><td><code id="gof_gerbil_+3A_imp">imp</code></td>
<td>
<p>A scalar or vector indicating which of the multiply imputed datasets should be used for testing.  Defaults to <code>imp = 1</code>.</p>
</td></tr>
<tr><td><code id="gof_gerbil_+3A_breaks">breaks</code></td>
<td>
<p>Used to determine the cut-points for binning of continuous variables into categories. Ideally, <code>breaks</code> is a named list, where the list names are the names of the continuous variables. 
Each element of the list can be a vector giving the respective cutpoints or a scalar which is used to indicate the number of bins (in which case cutpoints are determined from percentiles in order to yield bins of approximately equal size). 
If <code>breaks</code> is a scalar or a vector (and not a list), the binning strategy indicated by <code>breaks</code> is applied to each variable in accordance with the description above.  
Defaults to <code>breaks = 4</code>.</p>
</td></tr>
<tr><td><code id="gof_gerbil_+3A_method">method</code></td>
<td>
<p>The type of test that is used to compare contingency tables.  Options include <code>'chi-squared'</code> for chi-squared testing (the default), <code>'fisher'</code> for Fisher's exact test, and <code>'G'</code> for a G-test.</p>
</td></tr>
<tr><td><code id="gof_gerbil_+3A_ks">ks</code></td>
<td>
<p>If <code>TRUE</code>, a Kolmogorov-Smirnov test is used when for univariate comparisons with continuous variables.  This functionality is not enabled for bivariate testing.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gof_gerbil_+3A_partial">partial</code></td>
<td>
<p>Indicates how partially imputed pairs are handled in bivariate testing. If <code>'imputed'</code>, cases with at least one missing variable in a pair are considered imputed. Otherwise (<code>partial = 'observed'</code>), only cases with both variables in the pair missing are considered imputed.</p>
</td></tr>
<tr><td><code id="gof_gerbil_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Goodness of fit is determined using contingency tables of counts across categories of the corresponding variable(s). 
For univariate testing (<code>type = 1</code>), a one-way table is calculated for observed cases and compared to an analogous table for imputed cases, 
whereas for bivariate testing (<code>type = 2</code>), two-way tables are calculated.  
Continuous variables are binned according to cut-points defined using the parameter <code>breaks</code>. 
Tests are performed using one of three methods (determined from the parameter <code>method</code>): 1) Chi-squared (the default); 2) Fisher's exact; and 3) A G-test. 
G-testing is implemented via the function <code>GTest()</code> from the <code>DescTools</code> package.
Note that for univariate testing of continuous variables, a Kolmogorov-Smirnov test may be performed instead by setting <code>ks = TRUE</code>.
</p>
<p>The only required input is a parameter <code>x</code> which is a <code>gerbil</code> object.
</p>
<p>Note that univariate differences between observed and imputed data may be explained by the missingness mechanism and are not necessarily indicative of poor imputations.
Note also that most imputation methods like gerbil (and mice and related methods) are not designed to capture complete bivariate distributions. As such, the bivariate tests may be likely to return small p-values.
</p>


<h3>Value</h3>

<p><code>gof_gerbil()</code> returns an object of the class <code>gof_gerbil</code> that has following slots:
</p>

<dl>
<dt>Stats</dt><dd><p>A vector (when <code>type = 1</code>) or matrix (when <code>type = 2</code>) giving the value of the test statistic (or coefficient) for the corresponding variable (or variable pair).</p>
</dd>
<dt>p.values</dt><dd><p>A vector (when <code>type = 1</code>) or matrix (when <code>type = 2</code>) giving the value of the p-value for the test applied to the corresponding variable (or variable pair).</p>
</dd>
<dt>Test</dt><dd><p>A vector (when <code>type = 1</code>) or matrix (when <code>type = 2</code>) indicating the type of test applied to the corresponding variable (or variable pair).</p>
</dd> 
<dt>Breaks</dt><dd><p>A list giving the cutpoints used for binning each continuous or semi-continuous variable.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
#Load the India Human Development Survey-II dataset
data(ihd_mcar) 

imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, mcmciter = 200, ords = "education_level", 
       semi = "farm_labour_days", bincat = c("sex", "marital_status", "job_field", "own_livestock"))

#Run univariate tests
tests.gerbil.uni &lt;- gof_gerbil(imps.gerbil, imp = 1, type = 1)

#Print a summary
tests.gerbil.uni

#Run bivariate tests
tests.gerbil.bi &lt;- gof_gerbil(imps.gerbil, imp = 1, type = 2)

#Print a summary
tests.gerbil.bi

      
</code></pre>

<hr>
<h2 id='ihd'>Example data from the India Human Development Survey</h2><span id='topic+ihd'></span>

<h3>Description</h3>

<p>This dataset is a subset from the India Human Development survey. This dataset is included in the package only for demonstration purposes and should not be used for other purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ihd
</code></pre>


<h3>Format</h3>

<p>A data frame with 42155 rows and 8 variables:
</p>

<dl>
<dt>sex</dt><dd><p>0 = individual is male; 1 = individual is female</p>
</dd>
<dt>age</dt><dd><p>Age of the individual, between 0 &amp; 99</p>
</dd>
<dt>marital_status</dt><dd><p>Individual’s marital status. 0 = Unmarried; 1 = Married</p>
</dd>
<dt>job_field</dt><dd><p>Refer’s to the field of the individual’s profession or job status (i.e. agricultural worker; small business owner; student; unemployed; etc.</p>
</dd>
<dt>farm_labour_days</dt><dd><p>Number of days a year the individual worked on a farm. Can take on the value zero</p>
</dd>
<dt>own_livestock</dt><dd><p>0 = Individual does not own livestock. 1 = Individual does own livestock</p>
</dd>
<dt>education_level</dt><dd><p>Years of schooling attained by the individual. Censored for values above 16.</p>
</dd>
<dt>income</dt><dd><p>Household’s income, in rupees. Value can be negative</p>
</dd>
</dl>



<h3>Source</h3>

<p>Desai, Sonalde, and Vanneman, Reeve. India Human Development Survey-II (IHDS-II), 2011-12.
Inter-university Consortium for Political and Social Research [distributor],
2018-08-08.
<a href="https://doi.org/10.3886/ICPSR36151.v6">doi:10.3886/ICPSR36151.v6</a>
</p>

<hr>
<h2 id='ihd_mar'>Missing at Random example data from the India Human Development Survey</h2><span id='topic+ihd_mar'></span>

<h3>Description</h3>

<p>This dataset is a subset from the India Human Development survey. This dataset is included in the package only for demonstration purposes and should not be used for other purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ihd_mar
</code></pre>


<h3>Format</h3>

<p>A data frame with 42155 rows and 8 variables:
</p>

<dl>
<dt>sex</dt><dd><p>1 = individual is male; 2 = individual is female</p>
</dd>
<dt>age</dt><dd><p>Age of the individual, between 0 &amp; 99</p>
</dd>
<dt>marital_status</dt><dd><p>Individual’s marital status. 0 = married, absent spouse, 1 = Married, 2 = Unmarried, 3 = Widowed, 4 = Divorced/Separated, 5 = married, no gauna</p>
</dd>
<dt>job_field</dt><dd><p>Refer’s to the field of the individual’s profession or job status (i.e. agricultural worker; small business owner; student; unemployed; etc.</p>
</dd>
<dt>farm_labour_days</dt><dd><p>Number of days a year the individual worked on a farm. Can take on the value zero</p>
</dd>
<dt>own_livestock</dt><dd><p>0 = Individual does not own livestock. 1 = Individual does own livestock</p>
</dd>
<dt>education_level</dt><dd><p>Years of schooling attained by the individual. Censored for values above 16.</p>
</dd>
<dt>income</dt><dd><p>Household’s income, in rupees. Value can be negative</p>
</dd>
</dl>



<h3>Source</h3>

<p>Desai, Sonalde, and Vanneman, Reeve. India Human Development Survey-II (IHDS-II), 2011-12.
Inter-university Consortium for Political and Social Research [distributor],
2018-08-08.
<a href="https://doi.org/10.3886/ICPSR36151.v6">doi:10.3886/ICPSR36151.v6</a>
</p>

<hr>
<h2 id='ihd_mcar'>Missing Completely at Random example data from the India Human Development Survey</h2><span id='topic+ihd_mcar'></span>

<h3>Description</h3>

<p>This dataset is a subset from the India Human Development survey. This dataset is included in the package only for demonstration purposes and should not be used for other purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ihd_mcar
</code></pre>


<h3>Format</h3>

<p>A data frame with 42155 rows and 8 variables:
</p>

<dl>
<dt>sex</dt><dd><p>1 = individual is male; 2 = individual is female</p>
</dd>
<dt>age</dt><dd><p>Age of the individual, between 0 &amp; 99</p>
</dd>
<dt>marital_status</dt><dd><p>Individual’s marital status. 0 = married, absent spouse, 1 = Married, 2 = Unmarried, 3 = Widowed, 4 = Divorced/Separated, 5 = married, no gauna</p>
</dd>
<dt>job_field</dt><dd><p>Refer’s to the field of the individual’s profession or job status (i.e. agricultural worker; small business owner; student; unemployed; etc.</p>
</dd>
<dt>farm_labour_days</dt><dd><p>Number of days a year the individual worked on a farm. Can take on the value zero</p>
</dd>
<dt>own_livestock</dt><dd><p>0 = Individual does not own livestock. 1 = Individual does own livestock</p>
</dd>
<dt>education_level</dt><dd><p>Years of schooling attained by the individual. Censored for values above 16.</p>
</dd>
<dt>income</dt><dd><p>Household’s income, in rupees. Value can be negative</p>
</dd>
</dl>



<h3>Source</h3>

<p>Desai, Sonalde, and Vanneman, Reeve. India Human Development Survey-II (IHDS-II), 2011-12.
Inter-university Consortium for Political and Social Research [distributor],
2018-08-08.
<a href="https://doi.org/10.3886/ICPSR36151.v6">doi:10.3886/ICPSR36151.v6</a>
</p>

<hr>
<h2 id='imputed'>Extracting imputed datasets from gerbil objects</h2><span id='topic+imputed'></span>

<h3>Description</h3>

<p>Using a <code>gerbil</code> object as an input, this function returns imputed datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputed(gerb, imp = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputed_+3A_gerb">gerb</code></td>
<td>
<p>A <code>gerbil</code> object containing the imputed data.</p>
</td></tr>
<tr><td><code id="imputed_+3A_imp">imp</code></td>
<td>
<p>The imputed datasets which are to be returned (defaults to <code>imp = 1</code>).  Letting <code>m</code> indicate the number of imputed datasets contained in <code>gerb</code>, <code>imp</code> should be a subset of <code>1:m</code>.
If <code>imp</code> is a scalar, a single imputed dataset is returned.  If <code>imp</code> is a vector, then the individual datasets are stacked on top of each other and returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function either return a single imputed dataset (if <code>imp</code> is a scalar) or a tall dataset if (if <code>imp</code> is a vector) with the individual datsets stacked on top of each other.
</p>


<h3>Value</h3>

<p><code>imputed()</code> returns a data frame or matrix. If <code>imp</code> has multiple elements, columns are added to indicate the imputation number and the case ID.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Load the India Human Development Survey-II dataset
data(ihd_mcar)

# Create a gerbil object
imps.gerbil &lt;- gerbil(ihd_mcar, m = 5, ords = "education_level", semi = "farm_labour_days", 
       bincat = "job_field", n.cores = 1)

# Return a single imputed datasets
imp.gerb &lt;- imputed(imps.gerbil, imp = 2)

# Return multiple (stacked) datasets
imp.gerb &lt;- imputed(imps.gerbil, imp = 1:5)


</code></pre>

<hr>
<h2 id='plot.gerbil'>Plotting for gerbil objects</h2><span id='topic+plot.gerbil'></span>

<h3>Description</h3>

<p>Using a <code>gerbil</code> object as an input, this function gives
diagnostic plots for selected variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gerbil'
plot(
  x,
  y = NULL,
  type = "Univariate",
  imp = 1,
  col = NULL,
  lty = NULL,
  lwd = NULL,
  pch = NULL,
  log = NULL,
  legend = NULL,
  legend.loc = "topright",
  mfrow = c(3, 2),
  trace.type = "Mean",
  file = NULL,
  sep = FALSE,
  height = NULL,
  width = NULL,
  partial = "imputed",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gerbil_+3A_x">x</code></td>
<td>
<p>A <code>gerbil</code> object containing the imputed data.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_y">y</code></td>
<td>
<p>A vector listing the column names of the imputed data for which plots should be created. See details. By default, <code>y</code> contains all columns of the data that required imputation.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_type">type</code></td>
<td>
<p>A scalar used to specify the type of plots that will be created.  Options include univariate (marginal) plots (<code>type = 1</code>), bivariate plots (<code>type = 2</code>), and trace plots (<code>type = 3</code>). See details. Defaults to <code>type = 1</code>.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_imp">imp</code></td>
<td>
<p>A scalar or vector indicating which of the multiply imputed datasets should be used for plotting.  Defaults to <code>imp = 1</code>. Setting <code>imp = TRUE</code> will include all imputed datasets.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_col">col</code></td>
<td>
<p>The color used for plotting &ndash; should be a vector of length equal to <code>imp + 1</code>. The first element references plotting of observed data, and remaining elements reference plotting of imputed data.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_lty">lty</code></td>
<td>
<p>The line type used for plotting imputed values with trace lines or density plots &ndash; should be a vector of length equal to <code>imp + 1</code>. The first element references plotting of observed data, and remaining elements reference plotting of imputed data.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_lwd">lwd</code></td>
<td>
<p>The line width used for density and trace line plotting &ndash; should be a vector of length equal to <code>imp + 1</code>. The first element references plotting of observed data, and remaining elements reference plotting of imputed data.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_pch">pch</code></td>
<td>
<p>A length-2 vector that indicates the plotting symbol to be used for imputed and observed values in scatter and lattice plots.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_log">log</code></td>
<td>
<p>A character vector that includes names of variables of which a log transformation is to be taken prior to plotting.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_legend">legend</code></td>
<td>
<p>A character or expression vector to appear in the legend. If <code>FALSE</code> or <code>'n'</code>, no legend is created. Defaults to <code>c("Observed", "Imputed", ...)</code>.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_legend.loc">legend.loc</code></td>
<td>
<p>The location of the legend in the plots.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_mfrow">mfrow</code></td>
<td>
<p>The layout of plots across a single page when there are to be multiple plots per page (as is the case when <code>file</code> is non-<code>NULL</code> and <code>sep = FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_trace.type">trace.type</code></td>
<td>
<p>The type of trace plot to be created (only valid when <code>type = 3</code>).  See details.  Defaults to <code>trace.type = 1</code>.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_file">file</code></td>
<td>
<p>A character string giving the name of file that will be created in the home directory containing plots. The name should have a <code>.pdf</code> or <code>.png</code> extension. If <code>NULL</code> (the default), no file is created.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_sep">sep</code></td>
<td>
<p>If <code>sep = TRUE</code>, separate plots will be generated for each outcome.  Applicable only if plots are saved to file (<code>plot.file</code> is <code>non-NULL</code>). To change display of plots produced as output, use <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_height">height</code></td>
<td>
<p>The height of the graphics region (in inches) when a pdf is created.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_width">width</code></td>
<td>
<p>The width of the graphics region (in inches) when a pdf is created.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_partial">partial</code></td>
<td>
<p>Indicates how partially imputed pairs are handled in bivariate plotting. If <code>'imputed'</code>, cases with at least one missing variable in a pair are considered imputed. Otherwise (<code>partial = 'observed'</code>), only cases with both variables in the pair missing are considered imputed.</p>
</td></tr>
<tr><td><code id="plot.gerbil_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three types of plots may be produced:
1) Univariate (produced by setting <code>type = 1</code>): Compares the marginal distribution of observed and imputed values of a given variable.  Density plots are produced for continuous variables, and bar plots are given for binary, categorical, and ordinal variables.  For semi-continuous variables, two plots are constructed: a) a bar plot for the binary portion of the variable and 2) a density plot for the continuous portion.
2) Bivariate (produced by setting <code>type = 2</code>): Compares the bivariate distributions of observed and imputed values of two variables.  Scatter plots are produced if both variables are continuous or semi-continuous, box plots are produced if one variable is continuous or semi-continuous and the other is not, and a lattice plot is produced if neither variable is continuous or semi-continuous. For bivariate plots, imputed observations are those that have one or more of the values of the pair missing within the original dataset.
3) Trace lines (produced by setting <code>type = 3</code>): Plots a pre-specified parameter across iterations of MCMC in order to examine convergence for a given variable.  Parameters that may be plotted include means (<code>trace.type = 1</code>) and variances (<code>trace.type = 2</code>).
</p>
<p>Multiple plots may be created, as determined by the variable names listed in the parameter <code>y</code>. For univariate and trace plots, one plot is created for
each variable listed in <code>y</code>. For bivariate plotting, one plot is created for each combination of two elements within the vector <code>y</code> (as such, <code>y</code> must have a length of at least two in this case).
For trace plotting, elements of <code>y</code> should correspond to column names in the dataset that has been expanded to include binary indicators for categorical and semi-continuous variables.
If multiple plots are to be created, it is recommended to specify a file for output using the parameter <code>file</code>, in which case separate
files will be created for each plot (if <code>sep = TRUE</code>) or all plots will be written to the same file (if <code>sep = FALSE</code>).
</p>
<p>The only required input is a parameter <code>x</code> which is a <code>gerbil</code> object.
</p>


<h3>Value</h3>

<p>No returned value, but instead plots are generated in the workspace or written to a specified directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Load the India Human Development Survey-II dataset
data(ihd_mcar) 

# Create a gerbil object

imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, ords = "education_level", semi = "farm_labour_days", 
       bincat = "job_field")

# Univariate plotting of all variables to a file
plot(imps.gerbil, type = 1, file = file.path(tempdir(), "gerbil_univariate.pdf"))

# Bivariate plotting of all variables to a file
plot(imps.gerbil, type = 2, file = file.path(tempdir(), "gerbil_bivariate.pdf"))

# Trace plotting of all variables to a file
plot(imps.gerbil, type = 3, file = file.path(tempdir(), "gerbil_ts.pdf"))

# Univariate plotting of one variable (not to a file)
plot(imps.gerbil, type = 1, y = "job_field")

# Bivariate plotting of one pair of variables (not to a file)
plot(imps.gerbil, type = 2, y = c("job_field", "income"))

# Bivariate plotting of one pair of variables (not to a file) with income logged
plot(imps.gerbil, type = 2, y = c("job_field", "income"), log = "income")


</code></pre>

<hr>
<h2 id='print.cor_gerbil'>Prints a <code>cor_gerbil</code> object. Printed output includes the average difference of correlations, as well as summaries of the test statistics based on Fisher's z and their p-values.</h2><span id='topic+print.cor_gerbil'></span>

<h3>Description</h3>

<p>Prints a <code>cor_gerbil</code> object. Printed output includes the average difference of correlations, as well as summaries of the test statistics based on Fisher's z and their p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cor_gerbil'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cor_gerbil_+3A_x">x</code></td>
<td>
<p>object of <code>cor_gerbil</code> class</p>
</td></tr>
<tr><td><code id="print.cor_gerbil_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed down to inner functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>print.cor_gerbil</code> and <code>summary.cor_gerbil</code> display information 
about the <code>cor_gerbil</code> object. The output displayed includes: 
1) the average absolute difference in correlation between observed and imputed cases across all relevant variable pairs,
2) the average value of the test statistic based on Fisher's z across all variable pairs,
3) the largest test statistic observed across any variable pair, and
4) the portion of p-values for the test based on Fisher's z that are less than 0.05.
</p>

<hr>
<h2 id='print.gerbil'>Prints a <code>gerbil</code> object. Printed output includes a variable-by-variable summary of variable types and missingness rates. The implemented predictor matrix is also provided.</h2><span id='topic+print.gerbil'></span>

<h3>Description</h3>

<p>Prints a <code>gerbil</code> object. Printed output includes a variable-by-variable summary of variable types and missingness rates. The implemented predictor matrix is also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gerbil'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gerbil_+3A_x">x</code></td>
<td>
<p>object of <code>gerbil</code> class</p>
</td></tr>
<tr><td><code id="print.gerbil_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed down to inner functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>print.gerbil</code> and <code>summary.gerbil</code> display information about the <code>gerbil</code> object.
Primarily, the variable type and missingness rate are displayed for each variable. The predictor matrix is also provided.
</p>

<hr>
<h2 id='print.gof_gerbil'>Prints a <code>gof_gerbil</code> object. Printed output pertains to the goodness-of-fit tests that are applied in order to compare the distribution between observed and imputed cases for relevant variables or variable pairs.</h2><span id='topic+print.gof_gerbil'></span>

<h3>Description</h3>

<p>Prints a <code>gof_gerbil</code> object. Printed output pertains to the goodness-of-fit tests that are applied in order to compare the distribution between observed and imputed cases for relevant variables or variable pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gof_gerbil'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gof_gerbil_+3A_x">x</code></td>
<td>
<p>object of <code>gof_gerbil</code> class</p>
</td></tr>
<tr><td><code id="print.gof_gerbil_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed down to inner functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>print.gof_gerbil</code> and <code>summary.gof_gerbil</code> display information 
about the <code>cor_gerbil</code> object. The output displayed includes: 
1) the average test statistic value across all variables or variable pairs contained in the object,
2) the average p-value of all goodness-of-fit tests contained within the object, and
3) the number of tests that yieled a p-value of less than 0.05.
</p>

<hr>
<h2 id='summary.cor_gerbil'>Summarises a <code>gerbil</code> object. Printed output includes a variable-by-variable summary of variable types and missingness rates. The implemented predictor matrix is also provided.</h2><span id='topic+summary.cor_gerbil'></span>

<h3>Description</h3>

<p>Summarises a <code>gerbil</code> object. Printed output includes a variable-by-variable summary of variable types and missingness rates. The implemented predictor matrix is also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cor_gerbil'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cor_gerbil_+3A_object">object</code></td>
<td>
<p>An object of <code>cor_gerbil</code> class</p>
</td></tr>
<tr><td><code id="summary.cor_gerbil_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed down to inner functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>print.cor_gerbil</code> and <code>summary.cor_gerbil</code> display information 
about the <code>cor_gerbil</code> object. The output displayed includes: 
1) the average absolute difference in correlation between observed and imputed cases across all relevant variable pairs,
2) the average value of the test statistic based on Fisher's z across all variable pairs,
3) the largest test statistic observed across any variable pair, and
4) the portion of p-values for the test based on Fisher's z that are less than 0.05.
</p>

<hr>
<h2 id='summary.gerbil'>Summarises a <code>gerbil</code> object. Printed output includes a variable-by-variable summary of variable types and missingness rates. The implemented predictor matrix is also provided.</h2><span id='topic+summary.gerbil'></span>

<h3>Description</h3>

<p>Summarises a <code>gerbil</code> object. Printed output includes a variable-by-variable summary of variable types and missingness rates. The implemented predictor matrix is also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gerbil'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gerbil_+3A_object">object</code></td>
<td>
<p>An object of <code>gerbil</code> class</p>
</td></tr>
<tr><td><code id="summary.gerbil_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed down to inner functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>print.gerbil</code> and <code>summary.gerbil</code> display information about the <code>gerbil</code> object.
Primarily, the variable type and missingness rate are displayed for each variable. The predictor matrix is also provided.
</p>

<hr>
<h2 id='summary.gof_gerbil'>Summarises a <code>gerbil</code> object. Printed output pertains to the goodness-of-fit tests that are applied in order to compare the distribution between observed and imputed cases for relevant variables or variable pairs.</h2><span id='topic+summary.gof_gerbil'></span>

<h3>Description</h3>

<p>Summarises a <code>gerbil</code> object. Printed output pertains to the goodness-of-fit tests that are applied in order to compare the distribution between observed and imputed cases for relevant variables or variable pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gof_gerbil'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gof_gerbil_+3A_object">object</code></td>
<td>
<p>An object of <code>gof_gerbil</code> class</p>
</td></tr>
<tr><td><code id="summary.gof_gerbil_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed down to inner functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>print.gof_gerbil</code> and <code>summary.gof_gerbil</code> display information 
about the <code>cor_gerbil</code> object. The output displayed includes: 
1) the average test statistic value across all variables or variable pairs contained in the object,
2) the average p-value of all goodness-of-fit tests contained within the object, and
3) the number of tests that yieled a p-value of less than 0.05.
</p>

<hr>
<h2 id='write.gerbil'>Write imputed datasets from gerbil objects to a file or files</h2><span id='topic+write.gerbil'></span>

<h3>Description</h3>

<p>Using a <code>gerbil</code> object as an input, this function writes imputed datasets to an output file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.gerbil(gerb, file = NULL, imp = NULL, tall = FALSE, row.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.gerbil_+3A_gerb">gerb</code></td>
<td>
<p>A <code>gerbil</code> object containing the imputed data.</p>
</td></tr>
<tr><td><code id="write.gerbil_+3A_file">file</code></td>
<td>
<p>The name of the file to which the imputed datasets are to be written.
Which type of file (.xlsx or .csv) is created depends upon the extension of the parameter <code>file</code>.</p>
</td></tr>
<tr><td><code id="write.gerbil_+3A_imp">imp</code></td>
<td>
<p>The imputed datasets which are to be written.  Can be a scalar or, if multiple imputed datasets are to be written, a vector.
All elements of <code>imp</code> should be integers greater than 0 but no greater than <code>m</code>, which is the number of imputed datasets in <code>gerb</code>.
<code>imp</code> defaults to <code>1:m</code>.</p>
</td></tr>
<tr><td><code id="write.gerbil_+3A_tall">tall</code></td>
<td>
<p>A logical expression indicating whether the datasets are to be written in a tall (stacked) format
or written separately.  When writing to an XLSX file with <code>tall = FALSE</code>, one tab is created for each imputed dataset.
When writing to a CSV file with <code>tall = FALSE</code>, one file is created for each imputed dataset
(in this case, several file names will be created from the base string given by <code>file</code>).</p>
</td></tr>
<tr><td><code id="write.gerbil_+3A_row.names">row.names</code></td>
<td>
<p>A logical value indicating whether the row names of the datasets are to be written.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function writes imputed datasets to either an Excel (.xlsx) or a CSV (.csv) file, depending upon the extension of the parameter <code>file</code>.
No other file types are supported.
To write multiple imputed datasets simultaneously, specify <code>imp</code> as a vector with length greater than 1.
Multiple imputed datasets are either written in a stacked format (if <code>tall = TRUE</code>) or written separately (if <code>tall = FALSE</code>).
</p>


<h3>Value</h3>

<p>No returned value, but instead a data file is written to a specified directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Load the India Human Development Survey-II dataset
data(ihd_mcar)

# Create a gerbil object
imps.gerbil &lt;- gerbil(ihd_mcar, m = 5, ords = "education_level", semi = "farm_labour_days", 
       bincat = "job_field", n.cores = 1)

# Write all imputed datasets to separate CSV files
write.gerbil(imps.gerbil, file.path(tempdir(), "gerbil_example.csv"), imp = 1:5, tall = FALSE)

# Write all imputed datasets to a single CSV files
write.gerbil(imps.gerbil, file.path(tempdir(), "gerbil_example.csv"), imp = 1:5, tall = TRUE)

# Write all imputed datasets to an XLSX file
write.gerbil(imps.gerbil, file.path(tempdir(), "gerbil_example.xlsx"), imp = 1:5, tall = FALSE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
