<!DOCTYPE html><html><head><title>Help for package simecol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simecol}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simecol-package'>
<p>Simulation of Ecological (and Other) Dynamic Systems</p></a></li>
<li><a href='#addtoenv'>
<p>Add Functions from a Non-nested List of Named Functions to a Common</p>
Environment</a></li>
<li><a href='#approxTime'><p>Linear Interpolation with Complete Matrices or Data Frames</p></a></li>
<li><a href='#as.simObj'><p>Coerce simObj Objects to Lists and Vice-Versa</p></a></li>
<li><a href='#CA'><p>Stochastic Cellular Automaton</p></a></li>
<li><a href='#chemostat'><p>Chemostat Model</p></a></li>
<li><a href='#conway'><p>The Classical Coway's Game of Life</p></a></li>
<li><a href='#diffusion'><p>A Random Walk Particle Diffusion Model</p></a></li>
<li><a href='#editParms'>
<p>Edit &lsquo;parms&rsquo;, &lsquo;init&rsquo; or &lsquo;times&rsquo; Slot of &lsquo;simecol&rsquo; Objects</p></a></li>
<li><a href='#eightneighbours'><p>Count Number of Neighbours in a Rectangular Cellular Grid.</p></a></li>
<li><a href='#fitOdeModel'><p>Parameter Fitting for odeModel Objects</p></a></li>
<li><a href='#fromtoby'><p>Create Regular Sequence from 'from-to-by' Vector</p></a></li>
<li><a href='#initialize-methods'><p>Methods for Function &lsquo;initialize&rsquo; in Package &lsquo;simecol&rsquo;</p></a></li>
<li><a href='#iteration'><p>Discrete Simulation</p></a></li>
<li><a href='#listOrNULL-class'><p>Helpful Union Classes</p></a></li>
<li><a href='#lv'><p>Lotka-Volterra Predator-Prey Model</p></a></li>
<li><a href='#lv3'><p>Lotka-Volterra-Type Model with Resource, Prey and Predator</p></a></li>
<li><a href='#mixNamedVec'>
<p>Mix Two Named Vectors, Resolving Name Conflicts</p></a></li>
<li><a href='#modelFit-class'><p>Class of Fitted Model Parameters</p></a></li>
<li><a href='#modelFit-method'><p>Show Results of Model Fits</p></a></li>
<li><a href='#neighbours'><p>Count Number of Neighbours on a Rectangular Grid.</p></a></li>
<li><a href='#observer'><p>Get or Set an Observer Functions to an &lsquo;simObj&rsquo; Object</p></a></li>
<li><a href='#odeModel'><p>Generating-functions (Constructors) to Create Objects of</p>
Classes &lsquo;odeModel&rsquo;, &lsquo;rwalkModel&rsquo; and &lsquo;gridModel&rsquo;.</a></li>
<li><a href='#p.constrain'><p>Transform Data Between Unconstrained and Box-constrained Scale</p></a></li>
<li><a href='#parms'><p>Accessor Functions for &lsquo;simObj&rsquo; Objects</p></a></li>
<li><a href='#pcuseries'><p>Generate Plackett Bivariate Random Numbers</p></a></li>
<li><a href='#peaks'><p>Find Peaks Within xy-Data</p></a></li>
<li><a href='#plot-methods'><p>Methods for Function plot in Package &lsquo;simecol&rsquo;</p></a></li>
<li><a href='#print-methods'><p>Methods for Function &lsquo;print&rsquo; in Package &lsquo;simecol&rsquo;</p></a></li>
<li><a href='#sEdit'><p>Simple editing</p></a></li>
<li><a href='#seedfill'><p>Color Fill Algorithm</p></a></li>
<li><a href='#sim-methods'><p>Simulation of 'simObj' model objects</p></a></li>
<li><a href='#ssqOdeModel'><p>Sum of Squares Between odeModel and Data</p></a></li>
<li><a href='#upca'><p>The Uniform Period Chaotic Amplitude Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.8-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation of Ecological (and Other) Dynamic Systems</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Petzoldt <a href="https://orcid.org/0000-0002-4951-6468"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2), deSolve, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils, minqa</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tcltk, FME, lattice</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Petzoldt &lt;thomas.petzoldt@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An object oriented framework to simulate
  ecological (and other) dynamic systems. It can be used for
  differential equations, individual-based (or agent-based) and other
  models as well. It supports structuring of simulation scenarios (to avoid copy
  and paste) and aims to improve readability and re-usability of code.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.simecol.de/">http://www.simecol.de/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-06 21:47:19 UTC; thpe</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-07 06:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simecol-package'>
Simulation of Ecological (and Other) Dynamic Systems
</h2><span id='topic+simecol-package'></span><span id='topic+simecol'></span><span id='topic+simObj'></span><span id='topic+simObj-class'></span><span id='topic+odeModel-class'></span><span id='topic+gridModel-class'></span><span id='topic+rwalkModel-class'></span><span id='topic+indbasedModel-class'></span>

<h3>Description</h3>

<p>An object oriented framework to simulate
  ecological (and other) dynamic systems. It can be used for
  differential equations, individual-based (or agent-based) and other
  models as well. It supports structuring of simulation scenarios (to avoid copy
  and paste) and aims to improve readability and re-usability of code.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> simecol</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.8-14</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Simulation of Ecological (and Other) Dynamic Systems</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Thomas","Petzoldt", role = c("aut", "cre"),
                     email = "thomas.petzoldt@tu-dresden.de",
					 comment = c(ORCID = "0000-0002-4951-6468")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Thomas Petzoldt [aut, cre] (&lt;https://orcid.org/0000-0002-4951-6468&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.2), deSolve, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> graphics, grDevices, stats, utils, minqa</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> tcltk, FME, lattice</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Thomas Petzoldt &lt;thomas.petzoldt@tu-dresden.de&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> An object oriented framework to simulate
  ecological (and other) dynamic systems. It can be used for
  differential equations, individual-based (or agent-based) and other
  models as well. It supports structuring of simulation scenarios (to avoid copy
  and paste) and aims to improve readability and re-usability of code.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> http://www.simecol.de/</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <span class="pkg">simecol</span> package is intended to give users (scientists and
students) an interactive environment to implement, distribute,
simulate and document ecological and other dynamic models without the
need to write long simulation programs. An object oriented framework
using the S4 class system provides a consistent but still flexible
approach to implement simulation models of different types:
</p>

<ul>
<li><p> differential equation (ODE, PDE) models (class <code>odeModel</code>),
</p>
</li>
<li><p> grid-oriented individual-based models (class <code>gridModel</code>), and
</p>
</li>
<li><p> particle diffusion-type models (class <code>rwalkModel</code>),
</p>
</li>
<li><p> individual-based models (class <code>indbasedModel</code>),
</p>
</li>
<li><p> other model types by deriving a user specified subclass from
<code>simObj</code>.
</p>
</li></ul>

<p>Each simulation model is implemented as S4 object (superclass <code>simObj</code>)
with the following slots:
</p>

<ul>
<li> <p><code>main = function(time, init, parms, ...)</code>: a function
holding the main equations of the model,
</p>
</li>
<li> <p><code>equations</code>: an optional non-nested list holding
arbitrary sub-equations (sub-models) of the model. Sub-equations
can be interdependent and can be called directly from within
<code>main</code> or <code>initfunc</code>.
</p>
</li>
<li> <p><code>parms</code>: a list (or vector for some classes) with
constant model parameters,
</p>
</li>
<li>  <p><code>times</code>: vector of time steps or vector with three
named values <code>from</code>, <code>to</code>, <code>by</code> specifying the
simulation time steps. The from-to-by form can be edited with
<code>editParms</code>.
</p>
</li>
<li> <p><code>init</code>: initial state (start values) of the
simulation. This is typically a named vector (state variables in
<code>odeModel</code>s) or matrix (e.g. initial grid of
<code>gridModel</code>s).
</p>
</li>
<li> <p><code>inputs</code>: time dependend or spatially resolved external
inputs can be specified as data frame or matrix (more
efficient). Performance optimized versions of <code>approx</code> (see
<code><a href="#topic+approxTime">approxTime</a></code>) are available.
</p>
</li>
<li> <p><code>solver</code>: a function or a character string specifying the
numerical algorithm used, e.g. <code>"lsoda"</code>, <code>"rk4"</code> or
<code>"euler"</code> from package <code>deSolve</code>). In contrast to
<code>"euler"</code> that can be used for difference equations
(i.e. <code>main</code> returns derivatives), <code>"iterator"</code> is
intended for models where main returns the new state (i.e for
individual-based models).  It is also possible to reference own
algorithms (solvers) that are defined in the user workspace or to
assign solver functions directly.
</p>
</li>
<li> <p><code>observer</code>: optional slot which determines the data
stored during the simulation. A user-provided <code>observer</code>
function can also be used to write logging information to the
screen or to the hard-disk, to perform run-time visualisation, or
statistical analysis during the simulation.
</p>
<p>The <code>observer</code>-mechanism works only with
<code><a href="#topic+iteration">iteration</a></code> solvers. It is not available for
<code>odeModel</code>s.
</p>
</li>
<li> <p><code>out</code>: this slot holds the simulation results after a
simulation run as data frame (if the return value of <code>main</code>
is a vector) or as list (otherwise). The type of data stored in
<code>out</code> can be manipulated by providing a user-definded
<code>observer</code> function.
</p>
</li>
<li> <p><code>initfunc</code>: this slot can hold an optional function which
is called automatically when a new object is created by <code>new</code>
or when it is re-initialized by <code>initialize</code> or <code>sim</code>.
</p>
</li></ul>

<p><code>simObj</code> model objects should be defined and created using the
common S4 mechanisms (<code><a href="methods.html#topic+new">new</a></code>).
</p>
<p>Normally, a <code>simObj</code> object can contain all data needed to run
simulations simply by entering the model object via <code>source()</code> or
<code>data()</code> and then to run and plot the model with
<code>plot(sim(obj))</code>.
</p>
<p>Accessor functions (with names identical to the slot names) are
provided to get or set model parameters, time steps, initial values,
inputs, the solver, the main and sub-equations, an observer or an
initfunc and to extract the model outputs.  It is also possible to
modify the components of the simecol objects directly, e.g. the model
equations of a model <code><a href="#topic+lv">lv</a></code> with <code>lv@main</code>, but this is
normally not recommended as there is no guarantee that this will work in a
compatible way in future versions.
</p>
<p>Models of different type are provided as data and some more in source
code (see directory examples).
</p>
<p>The examples can be used as a starting point to write own
<code>simObj</code> objects and to distribute them to whomever you wish.
</p>
<p>The package is supplemented with several utility functions
(e.g. <code><a href="#topic+seedfill">seedfill</a></code> or <code><a href="#topic+neighbours">neighbours</a></code>), which can
be used independently from <code>simObj</code> objects.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt [aut, cre] (&lt;https://orcid.org/0000-0002-4951-6468&gt;)
</p>


<h3>References</h3>

<p>Petzoldt, T. and K. Rinke (2007) <span class="pkg">simecol</span>: An Object-Oriented
Framework for Ecological Modeling in <span class="rlang"><b>R</b></span>. <em>Journal of Statistical
Software</em>, <b>22</b>(9). doi: <a href="https://doi.org/10.18637/jss.v022.i09">10.18637/jss.v022.i09</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CA">CA</a></code>,
<code><a href="#topic+chemostat">chemostat</a></code>,
<code><a href="#topic+conway">conway</a></code>,
<code><a href="#topic+diffusion">diffusion</a></code>,
<code><a href="#topic+lv">lv</a></code>,
<code><a href="#topic+lv3">lv3</a></code>,
<code><a href="#topic+upca">upca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (1) Quick Start Examples ====================================================

data(lv)        # load basic Lotka-Volterra model

## Not run: 
require("tcltk")
lv &lt;- editParms(lv)

## End(Not run)
parms(lv)
main(lv)
lv &lt;- sim(lv)
plot(lv)
results &lt;- out(lv)

## Not run: 
data(conway)    # Conway's game of life
init(conway) &lt;- matrix(0, 10, 10)
times(conway) &lt;-  1:100
conway &lt;- editInit(conway) # enter some "1"
sim(conway, animate=TRUE, delay=100)

## End(Not run)

## (2) Define and run your own  simecol model ==========================

lv &lt;- new("odeModel",
  main = function (time, init, parms) {
    with(as.list(c(init, parms)), {
      dn1 &lt;-   k1 * N1 - k2 * N1 * N2
      dn2 &lt;- - k3 * N2 + k2 * N1 * N2
      list(c(dn1, dn2))
    })
  },
  parms  = c(k1 = 0.2, k2 = 0.2, k3 = 0.2),
  times  = c(from = 0, to = 100, by = 0.5),
  init   = c(N1 = 0.5, N2 = 1),
  solver = "lsoda"
)

lv &lt;- sim(lv)
plot(lv)

## (3) The same in matrix notation; this allows generalization      ====
##     to multi-species interaction models with &gt; 2 species.        ====

LVPP &lt;- new("odeModel",
  main = function(t, n, parms) {
    with(parms, {
      dn &lt;- r * n  + n * (A %*% n)
      list(c(dn))
    })
  },
  parms = list(
    # growth/death rates
    r = c(k1 = 0.2, k3 = -0.2),
    # interaction matrix
    A = matrix(c(0.0, -0.2,
                 0.2,  0.0),
                 nrow = 2, ncol = 2, byrow=TRUE)
  ),
  times  = c(from = 0, to = 100, by = 0.5),
  init   = c(N1 = 0.5, N2 = 1),
  solver = "lsoda"
)

plot(sim(LVPP))

</code></pre>

<hr>
<h2 id='addtoenv'>
Add Functions from a Non-nested List of Named Functions to a Common
Environment
</h2><span id='topic+addtoenv'></span>

<h3>Description</h3>

<p>Create and set an environment where elements (e.g. functions) within a
non-nested   named list of functions see each other. This function is
normally used within other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addtoenv(L, p = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addtoenv_+3A_l">L</code></td>
<td>
<p>a non-nested list of named functions.</p>
</td></tr>
<tr><td><code id="addtoenv_+3A_p">p</code></td>
<td>
<p>the environment where the functions are assigned to. Defaults
to the parent frame.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the &lsquo;solver functions&rsquo; of <code>simecol</code>.
</p>


<h3>Value</h3>

<p>The list of functions within a common environment.
</p>


<h3>Note</h3>

<p>This is a very special function that uses environment manipulations.
Its main purpose is to &lsquo;open&rsquo; the access to interdependend functions within
a common list structure (function list).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+attach">attach</a></code>,
<code><a href="base.html#topic+environment">environment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eq &lt;- list(f1 = function(x, y)    x + y,
           f2 = function(a, x, y) a * f1(x, y)
          )

fx &lt;- function(eq) {
  eq &lt;- addtoenv(eq)
  print(ls())
  print(environment(eq$f1))
  f1(3,4) + f2(1,2,3)
}

fx(eq)
## eq$f2(2,3,4)       # should give an error outside fx
environment(eq$f2)    # should return R_GlobalEnv again
</code></pre>

<hr>
<h2 id='approxTime'>Linear Interpolation with Complete Matrices or Data Frames</h2><span id='topic+approxTime'></span><span id='topic+approxTime1'></span>

<h3>Description</h3>

<p>Return a data frame, matrix or vector which linearly interpolates data
from a given matrix or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxTime(x, xout, ...)
approxTime1(x, xout, rule = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approxTime_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with numerical values giving
coordinates of points to be interpolated. The first column needs to
be in ascending order and is interpreted as independent variable
(e.g. time), the remaining columns are used as dependent variables.
</p>
</td></tr>
<tr><td><code id="approxTime_+3A_xout">xout</code></td>
<td>
<p>a vector (or single value for <code>approxTime1</code>) of
independend values specifying where interpolation has to be done.  </p>
</td></tr>
<tr><td><code id="approxTime_+3A_rule">rule</code></td>
<td>
<p>an integer describing how interpolation is to take place
outside the interval [min(x), max(x)]. If <code>rule</code> is 1 then
<code>NA</code>s are returned for such points and if it is 2, the value at
the closest data extreme is used.  </p>
</td></tr>
<tr><td><code id="approxTime_+3A_...">...</code></td>
<td>
<p>optional parameters passed to <code>approx</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions can be used for linear interpolation with a complete
matrix or data frame. This can be used for example in the main
function of an <code>odeModel</code> to get input values at a specified time
<code>xout</code>. The version <code>approxTime1</code> is less flexible (only one
single value for xout and only linear interpolation) but has increased
performance.  Both functions are faster if <code>x</code> is a matrix
instead of a data frame.
</p>


<h3>Value</h3>

<p><code>approxTime</code> returns a matrix resp. data frame of the same
structure as <code>x</code> containing data which interpolate the given data
with respect to <code>xout</code>.  <code>approxTime1</code> is a performance
optimized special version with less options than the original
<code>approx</code> function. It returns an interpolated vector.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approxfun">approxfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputs &lt;- data.frame(time = 1:10, y1 = rnorm(10), y2 = rnorm(10, mean = 50))
input  &lt;- approxTime(inputs, c(2.5, 3), rule = 2)
</code></pre>

<hr>
<h2 id='as.simObj'>Coerce simObj Objects to Lists and Vice-Versa</h2><span id='topic+as.simObj'></span><span id='topic+coerce+2CsimObj+2Clist-method'></span><span id='topic+coerce+2Clist+2CsimObj-method'></span><span id='topic+as.list+2CsimObj-method'></span><span id='topic+as.simObj+2Clist-method'></span>

<h3>Description</h3>

<p>These functions can be used to coerce (i.e. convert) <span class="pkg">simecol</span>
model objects (<code>simObj</code> objects) to ordinary lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
as.simObj(x, ...)
## S4 method for signature 'simObj'
as.list(x, ...)
## alternative usage:
# as(x, "list")
# as(x, "simObj")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.simObj_+3A_x">x</code></td>
<td>
<p>object to be coerced</p>
</td></tr>
<tr><td><code id="as.simObj_+3A_...">...</code></td>
<td>
<p>for compatibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>as.list</code> converts a <code>simObj</code> model to an ordinary
list with an additional element 'class' storing the class name of the
original object.
</p>
<p>Function <code>as.simObj</code> converts in the opposite direction where the
type of the object to be created is determined by a class name stored
in the list element 'class'. If it is missing or contains a
non-existing class name, an error message is printed. Additional list
elements which are not slot names of the corresponding S4 object are
omitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+odeModel">odeModel</a></code>,
<code><a href="methods.html#topic+new">new</a></code>,
<code><a href="methods.html#topic+as">as</a></code>,
<code><a href="base.html#topic+as.list">as.list</a></code>,
<code><a href="#topic+simecol-package">simecol-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lv3)
llv3 &lt;- as(lv3, "list")
olv3 &lt;- as(llv3, "simObj")

llv3 &lt;- as.list(lv3)
olv3 &lt;- as.simObj(llv3)

dput(as.list(lv3), control="useSource")
## Not run: 
## save human readable object representation
dput(as.list(lv3), file="lv3.R", control=c("all"))
## read it back and test it
l_lv3 &lt;- dget("lv3.R")
o_lv3 &lt;- as.simObj(l_lv3)
plot(sim(o_lv3))

## End(Not run)
</code></pre>

<hr>
<h2 id='CA'>Stochastic Cellular Automaton</h2><span id='topic+CA'></span>

<h3>Description</h3>

<p><span class="pkg">simecol</span> example: This model simulates a stochastic cellular
automaton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(conway)</code></pre>


<h3>Format</h3>

<p>An S4 object according to the <code><a href="#topic+gridModel">gridModel</a></code> specification.
The object contains the following slots:
</p>

<dl>
<dt><code>main</code></dt><dd><p>functions with the state transition rules of
Coway's Game of Life.
</p>
</dd>
<dt><code>parms</code></dt><dd><p>a list with two vector elements:
</p>

<dl>
<dt><code>pbirth</code></dt><dd><p>probability of birth,</p>
</dd>
<dt><code>pdeath</code></dt><dd><p>death probability, dependend on neighbors.</p>
</dd>
</dl>

</dd>
<dt><code>times</code></dt><dd><p>number of time steps to be simulated.</p>
</dd>
<dt><code>init</code></dt><dd><p>a matrix, giving the initial state of the
cellular grid (default: rectangle in the middle of the grid).
</p>
</dd>
</dl>
 


<h3>Details</h3>

<p>To see all details, please have a look into the implementation below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim">sim</a></code>,
<code><a href="#topic+parms">parms</a></code>,
<code><a href="#topic+init">init</a></code>,
<code><a href="#topic+times">times</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##============================================
## Basic Usage:
##   work with the example
##============================================
data(CA)
times(CA)["to"] &lt;- 10
plot(sim(CA))

set.seed(345)
times(CA)["to"] &lt;- 50
CA &lt;- sim(CA)

library(lattice)
tcol &lt;- (terrain.colors(13))[-13]
x &lt;- out(CA, last=TRUE)
x &lt;- ifelse(x == 0, NA, x)
levelplot(x,
  cuts = 11,
  col.regions = tcol,
  colorkey = list(at = seq(0, 55, 5))
)

##============================================
## Implementation:
##   The code of the CA model
##============================================
CA &lt;- new("gridModel",
  main = function(time, init, parms) {
    z     &lt;- init
    nb    &lt;- eightneighbors(z)
    pgen  &lt;- 1 - (1 - parms$pbirth)^nb
    zgen  &lt;- ifelse(z == 0 &amp;
               runif(z) &lt; pgen, 1, 0)
    zsurv &lt;- ifelse(z &gt;= 1 &amp;
               runif(z) &lt; (1 - parms$pdeath),
               z + 1, 0)
    zgen + zsurv
  },
  parms = list(pbirth = 0.02, pdeath = 0.01),
  times = c(from = 1, to = 50, by = 1),
  init = matrix(0, nrow = 40, ncol = 40),
  solver = "iteration"
)
init(CA)[18:22,18:22] &lt;- 1
##============================================
</code></pre>

<hr>
<h2 id='chemostat'>Chemostat Model</h2><span id='topic+chemostat'></span>

<h3>Description</h3>

<p><span class="pkg">simecol</span> example: Model of continuos culture of microorganisms
(chemostat).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chemostat)</code></pre>


<h3>Format</h3>

<p>An S4 object according to the <code><a href="#topic+odeModel">odeModel</a></code> specification.
The object contains the following slots:
</p>

<dl>
<dt><code>main</code></dt><dd><p>the differential equations for substrate (<code>S</code>)
and cells (<code>X</code>).
</p>
</dd>
<dt><code>parms</code></dt><dd><p>a vector with the named parameters of the model:
</p>

<dl>
<dt><code>vm</code></dt><dd><p>maximum growth rate of the cells,</p>
</dd>
<dt><code>km</code></dt><dd><p>half saturation constant,</p>
</dd>
<dt><code>Y</code></dt><dd><p>yield coefficient (conversion factor of substrate
into cells).
</p>
</dd>
<dt><code>D</code></dt><dd><p>dilution rate,</p>
</dd>
<dt><code>S0</code></dt><dd><p>substrate concentration in the inflow.</p>
</dd>          
</dl>

</dd>
<dt><code>times</code></dt><dd><p>simulation time and integration interval.</p>
</dd>
<dt><code>init</code></dt><dd><p>vector with start values for substrate (<code>S</code>)
and cells (<code>X</code>).
</p>
</dd>
</dl>
 
<p>To see all details, please have a look into the implementation below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simecol-package">simecol-package</a></code>,
<code><a href="#topic+sim">sim</a></code>,
<code><a href="#topic+parms">parms</a></code>,
<code><a href="#topic+init">init</a></code>,
<code><a href="#topic+times">times</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##============================================
## Basic Usage:
##   work with the example
##============================================
data(chemostat)
plot(sim(chemostat))

parms(chemostat)["D"] &lt;- 0.9 
plot(sim(chemostat))



##============================================
## Implementation:
##   The code of the chemostat model
##============================================
chemostat &lt;- new("odeModel",
  main = function(time, init, parms, inputs = NULL) {
    with(as.list(c(init, parms)), {
      mu  &lt;- vm * S/(km + S)              # Monod equation
      dx1 &lt;- mu * X - D * X               # cells, e.g. algae
      dx2 &lt;-  D *(S0 - S) - 1/Y * mu * X  # substrate, e.g. phosphorus
      list(c(dx1, dx2))
    })
  },
  parms = c(
    vm = 1.0,           # max growth rate, 1/d
    km = 2.0,           # half saturation constant, mumol / L
    Y  = 100,           # cells /mumol Substrate
    D  = 0.5,           # dilution rate, 1/d
    S0 = 10             # substrate in inflow, mumol / L
  ),
  times = c(from=0, to=40, by=.5),
  init  = c(X=10, S=10), # cells / L; Substrate umol / L
  solver = "lsoda"
)

</code></pre>

<hr>
<h2 id='conway'>The Classical Coway's Game of Life</h2><span id='topic+conway'></span>

<h3>Description</h3>

<p><span class="pkg">simecol</span> example: This model simulates a deterministic cellular
automaton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(conway)</code></pre>


<h3>Format</h3>

<p>An S4 object according to the <code><a href="#topic+gridModel">gridModel</a></code> specification.
The object contains the following slots:
</p>

<dl>
<dt><code>main</code></dt><dd><p>functions with the state transition rules.</p>
</dd>
<dt><code>parms</code></dt><dd><p>A list with two vector elements:
</p>

<dl>
<dt><code>srv</code></dt><dd><p>number of neighbours, necessary to survive,</p>
</dd>
<dt><code>gen</code></dt><dd><p>number of neighbours, necessary to generate a
new cell.
</p>
</dd>
</dl>

</dd>
<dt><code>times</code></dt><dd><p>number of time steps to be simulated,</p>
</dd>
<dt><code>init</code></dt><dd><p>matrix with the initial state of the cellular
grid (default: random).  </p>
</dd>
</dl>
 


<h3>Details</h3>

<p>To see all details, please have a look into the implementation below.
</p>


<h3>References</h3>

<p>Gardner, Martin (1970) The Fantastic Combinations of John Conway's New
Solitaire Game 'Life.' <em>Scientific American</em>, October 1970.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim">sim</a></code>,
<code><a href="#topic+parms">parms</a></code>,
<code><a href="#topic+init">init</a></code>,
<code><a href="#topic+times">times</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##============================================
## Basic Usage:
##   explore the example
##============================================
data(conway)
plot(sim(conway))

## more interesting start conditions
m &lt;- matrix(0, 40, 40)
m[5:35, 19:21] &lt;- 1
init(conway) &lt;- m
plot(sim(conway), col=c("white", "green"), axes = FALSE)

## change survival rules
parms(conway) &lt;- list(srv = c(3,4), gen = c(3, 4))
plot(sim(conway), col = c("white", "green"), axes = FALSE)
## Not run: 
require("tcltk")
init(conway) &lt;- matrix(0, 10, 10)
conway &lt;- editInit(conway) # enter some "1"
sim(conway, animate = TRUE, delay = 100)

##============================================
## Implementation:
##   The code of Conways Game of Life
##============================================
conway &lt;- new("gridModel",
  main = function(time, init, parms) {
    x      &lt;- init
    nb     &lt;- eightneighbours(x)
    surviv &lt;- (x &gt;  0 &amp; (nb %in% parms$srv))
    gener  &lt;- (x == 0 &amp; (nb %in% parms$gen))
    x      &lt;- (surviv + gener) &gt; 0
    return(x)
  },
  parms  = list(srv = c(2, 3), gen = 3),
  times  = 1:17,
  init   = matrix(round(runif(1000)), ncol = 40),
  solver = "iteration"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='diffusion'>A Random Walk Particle Diffusion Model</h2><span id='topic+diffusion'></span>

<h3>Description</h3>

<p><span class="pkg">simecol</span> example: This is a random walk (basic particle
diffusion) model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(diffusion)</code></pre>


<h3>Format</h3>

<p>An S4 object according to the <code><a href="#topic+rwalkModel">rwalkModel</a></code> specification. 
The object contains the following slots:
</p>

<dl>
<dt><code>main</code></dt><dd><p>A function with the movement rules for the particles.</p>
</dd>
<dt><code>parms</code></dt><dd><p>A list with the following components:
</p>

<dl>
<dt><code>ninds</code></dt><dd><p>number of simulated particles,</p>
</dd>
<dt><code>speed</code></dt><dd><p>speed of the particles,</p>
</dd>
<dt><code>area</code></dt><dd><p>vector with 4 elements giving the coordinates (left,
bottom, right, top) of the coordinate system.</p>
</dd>
</dl>
</dd>
<dt><code>times</code></dt><dd><p>Simulation time (discrete time steps, <code>by</code>-argument
ignored).</p>
</dd>
<dt><code>init</code></dt><dd><p>Data frame holding the start properties (Cartesian
coordinates <code>x</code> and <code>y</code> and movement angle <code>a</code>) of the
particles.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To see all details, please have a look into the implementation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim">sim</a></code>,
<code><a href="#topic+parms">parms</a></code>,
<code><a href="#topic+init">init</a></code>,
<code><a href="#topic+times">times</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##============================================
## Basic Usage:
##   explore the example
##============================================
## Not run: 
data(diffusion)
## (1) minimal example
plot(sim(diffusion))
## show "grid of environmental conditions"
image(inputs(diffusion))

## (2) scenario
##     with homogeneous environment (no "refuge" in the middle)
no_refuge &lt;- diffusion # Cloning of the whole model object
inputs(no_refuge) &lt;- matrix(1, 100, 100)
plot(sim(no_refuge))
  
##============================================
## Advanced Usage:
##   Assign a function to the observer-slot.
##============================================
observer(diffusion) &lt;- function(state, ...) {
  ## numerical output to the screen
  cat("mean x=", mean(state$x),
      ", mean y=", mean(state$y),
      ", sd   x=", sd(state$x),
      ", sd   y=", sd(state$y), "\n")
  ## animation
  par(mfrow=c(2,2))
  plot(state$x, state$y, xlab="x", ylab="y", pch=16, col="red", xlim=c(0, 100))
  hist(state$y)
  hist(state$x)
  ## default case: return the state --&gt; iteration stores it in "out"
  state
}

sim(diffusion)

## remove the observer and restore original behavior
observer(diffusion) &lt;- NULL
diffusion &lt;- sim(diffusion)

## End(Not run)

##============================================
## Implementation:
##   The code of the diffusion model.
##   Note the use of the "initfunc"-slot.
##============================================
diffusion &lt;- rwalkModel(
  main = function(time, init, parms, inputs = NULL) {
    speed   &lt;- parms$speed
    xleft   &lt;- parms$area[1]
    xright  &lt;- parms$area[2]
    ybottom &lt;- parms$area[3]
    ytop    &lt;- parms$area[4]

    x &lt;- init$x  # x coordinate
    y &lt;- init$y  # y coordinate
    a &lt;- init$a  # angle (in radians)
    n &lt;- length(a)

    ## Rule 1: respect environment (grid as given in "inputs")
    ## 1a) identify location on "environmental 2D grid" for each individual
    i.j &lt;- array(c(pmax(1, ceiling(x)), pmax(1, ceiling(y))), dim=c(n, 2))

    ## 1b) speed dependend on "environmental conditions"
    speed &lt;- speed * inputs[i.j]

    ## Rule 2: Random Walk
    a  &lt;- (a + 2 * pi / runif(a)) 
    dx &lt;- speed * cos(a)
    dy &lt;- speed * sin(a)
    x  &lt;- x + dx
    y  &lt;- y + dy

    ## Rule 3: Wrap Around
    x &lt;- ifelse(x &gt; xright, xleft, x)
    y &lt;- ifelse(y &gt; ytop, ybottom, y)
    x &lt;- ifelse(x &lt; xleft, xright, x)
    y &lt;- ifelse(y &lt; ybottom, ytop, y)
    data.frame(x=x, y=y, a=a)
  },
  times  = c(from=0, to=100, by=1),
  parms  = list(ninds=50, speed = 1, area = c(0, 100, 0, 100)),
  solver = "iteration",
  initfunc = function(obj) {
    ninds   &lt;- obj@parms$ninds
    xleft   &lt;- obj@parms$area[1]
    xright  &lt;- obj@parms$area[2]
    ybottom &lt;- obj@parms$area[3]
    ytop    &lt;- obj@parms$area[4]
    obj@init &lt;- data.frame(x = runif(ninds) * (xright - xleft) + xleft,
                           y = runif(ninds) * (ytop - ybottom) + ybottom,
                           a = runif(ninds) * 2 * pi)
    inp &lt;- matrix(1, nrow=100, ncol=100)
    inp[, 45:55] &lt;- 0.2
    inputs(obj) &lt;- inp
    obj
  }
)
</code></pre>

<hr>
<h2 id='editParms'>
Edit &lsquo;parms&rsquo;, &lsquo;init&rsquo; or &lsquo;times&rsquo; Slot of &lsquo;simecol&rsquo; Objects
</h2><span id='topic+editParms'></span><span id='topic+editParms-methods'></span><span id='topic+editParms+2CsimObj-method'></span><span id='topic+editInit'></span><span id='topic+editInit-methods'></span><span id='topic+editInit+2CsimObj-method'></span><span id='topic+editTimes'></span><span id='topic+editTimes-methods'></span><span id='topic+editTimes+2CsimObj-method'></span>

<h3>Description</h3>

<p>The functions invoke an editor dialog for parameters, initial
values or time steps of <code>simObj</code> objects and then assign the
new (edited) version of <code>x</code> in the user's workspace. A <b>Tcl/Tk</b>
version or spreadsheet editor is displayed if possible, depending
on the structure of the respective slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  editParms(x)
  editTimes(x)
  editInit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editParms_+3A_x">x</code></td>
<td>
<p>A valid instance of the <code>simObj</code> class.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sEdit">sEdit</a></code>, <code><a href="#topic+simObj">simObj</a></code>,
<code><a href="#topic+parms">parms</a></code>, <code><a href="#topic+times">times</a></code>, <code><a href="#topic+init">init</a></code>,
<code><a href="utils.html#topic+edit">edit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require("tcltk")
data(lv)        # load basic Lotka-Volterra model
lv &lt;- editParms(lv)
plot(sim(lv))

data(conway)    # Conway's game of life
init(conway) &lt;- matrix(0, 10, 10)
conway &lt;- editInit(conway) # enter some "1"
sim(conway, animate = TRUE, delay = 100)

## End(Not run)
</code></pre>

<hr>
<h2 id='eightneighbours'>Count Number of Neighbours in a Rectangular Cellular Grid.</h2><span id='topic+eightneighbours'></span><span id='topic+eightneighbors'></span>

<h3>Description</h3>

<p>This function returns the sum of the eight neibours of a cell within a
matrix. It can be used to simulate simple cellular automata,
e.g. Conway's Game of Life.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eightneighbours(x)
  eightneighbors(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eightneighbours_+3A_x">x</code></td>
<td>
<p>The cellular grid, which typically contains integer values of
zero (dead cell) or one (living cell).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the same structure as <code>x</code>, but with the sum of the
neighbouring cells of each cell.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seedfill">seedfill</a></code>, <code><a href="#topic+neighbours">neighbours</a></code>, <code><a href="#topic+conway">conway</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 80; m &lt;- 80
x &lt;- matrix(rep(0, m*n), nrow = n)
x[round(runif(1500, 1, m*n))] &lt;- 1
## uncomment this for another figure
#x[40, 20:60] &lt;- 1

image(x, col=c("wheat", "grey", "red"))
x2 &lt;- x
for (i in 2:10){
  nb &lt;- eightneighbours(x)

  ## survive with 2 or 3 neighbours
  xsurv &lt;- ifelse(x &gt; 0 &amp; (nb == 2 | nb ==3), 1, 0)

  ## generate for empty cells with 3 neigbours
  xgen &lt;- ifelse(x == 0 &amp; nb == 3, 1, 0)

  x  &lt;- ((xgen + xsurv)&gt;0)
  x2 &lt;- ifelse(x2&gt;1, 1, x2)
  x2 &lt;- ifelse(x&gt;0, 2, x2)

  image(x2, col=c("wheat", "grey", "red"), add=TRUE)
}
</code></pre>

<hr>
<h2 id='fitOdeModel'>Parameter Fitting for odeModel Objects</h2><span id='topic+fitOdeModel'></span>

<h3>Description</h3>

<p>Fit parameters of <code>odeModel</code> objects to measured data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitOdeModel(simObj, whichpar = names(parms(simObj)), obstime, yobs, 
  sd.yobs = as.numeric(lapply(yobs, sd)), initialize = TRUE, 
  weights = NULL, debuglevel = 0, fn = ssqOdeModel, 
  method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "PORT",
   "newuoa", "bobyqa"),
  lower = -Inf, upper = Inf, scale.par = 1,
  control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitOdeModel_+3A_simobj">simObj</code></td>
<td>
<p>a valid object of class <code><a href="#topic+odeModel">odeModel</a></code>,</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_whichpar">whichpar</code></td>
<td>
<p>character vector with names of parameters which are to
be optimized (subset of parameter names of the <code>simObj</code>),</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_obstime">obstime</code></td>
<td>
<p>vector with time steps for which observational data are
available,</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_yobs">yobs</code></td>
<td>
<p>data frame with observational data for all or a subset of
state variables. Their names must correspond exacly with existing
names of state variables in the <code><a href="#topic+odeModel">odeModel</a></code>,</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_sd.yobs">sd.yobs</code></td>
<td>
<p>vector of given standard deviations (or scale) for all
observational variables given in <code>yobs</code>.  If no standard
deviations (resp. scales) are given, these are estimated from
<code>yobs</code>,</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_initialize">initialize</code></td>
<td>
<p>optional boolean value whether the simObj should be
re-initialized after the assignment of new parameter values. This
can be necessary in certain models to assign consistent values to
initial state variables if they depend on parameters.</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_weights">weights</code></td>
<td>
<p>optional weights to be used in the fitting process.
See cost function (currently only <code><a href="#topic+ssqOdeModel">ssqOdeModel</a></code>) for
details.</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_debuglevel">debuglevel</code></td>
<td>
<p>a positive number that specifies the amount of
debugging information printed,</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_fn">fn</code></td>
<td>
<p>objective function, i.e. function that returns the quality
criterium that is minimized, defaults to <code><a href="#topic+ssqOdeModel">ssqOdeModel</a></code>,</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_method">method</code></td>
<td>
<p>optimization method, see <code><a href="stats.html#topic+nlminb">nlminb</a></code> for
the PORT algorithm, <code><a href="minqa.html#topic+newuoa">newuoa</a></code> resp.
<code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>  for the newuoa and bobyqa
algorithms, and <code><a href="stats.html#topic+optim">optim</a></code> for all other  methods,</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_lower">lower</code>, <code id="fitOdeModel_+3A_upper">upper</code></td>
<td>
<p>bounds of the parameters for method L-BFGS-B, see
<code><a href="stats.html#topic+optim">optim</a></code>, PORT see <code><a href="stats.html#topic+nlminb">nlminb</a></code>
and bobyqa <code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>.
The bounds are also respected by other optimizers
by means of an internal transformation of the parameter space (see 
<code><a href="#topic+p.constrain">p.constrain</a></code>). In this case, <em>named vectors</em> are required.</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_scale.par">scale.par</code></td>
<td>
<p>scaling of parameters for method PORT see
<code><a href="stats.html#topic+nlminb">nlminb</a></code>.  In many cases, automatic scaling
(<code>scale.par = 1</code>) does well, but sometimes (e.g. if parameter
ranges differ several orders of magnitude) manual adjustment is
required. Often you get a reasonable choice if you set
<code>scale.par = 1/upper</code>.  The parameter is ignored by all other
methods. For <code>"Nelder-Mead"</code>, <code>"BFGS"</code>, <code>"CG"</code> and
<code>"SANN"</code> parameter scaling occurs as a side effect of parameter
transformation with <code>p.constrain</code>.</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_control">control</code></td>
<td>
<p>a list of control parameters for
<code><a href="stats.html#topic+optim">optim</a></code> resp.  <code><a href="stats.html#topic+nlminb">nlminb</a></code>,</p>
</td></tr>
<tr><td><code id="fitOdeModel_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the solver method
(e.g. to <code><a href="deSolve.html#topic+lsoda">lsoda</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works currently only with <code>odeModel</code> objects where
<code>parms</code> is a vector, not a list.
</p>
<p>Note also that the control parameters of the PORT algorithm are
different from the control parameters of the other optimizers.
</p>


<h3>Value</h3>

<p>A list with the optimized parameters and other information, see
<code><a href="stats.html#topic+optim">optim</a></code> resp. <code><a href="stats.html#topic+nlminb">nlminb</a></code> for
details.
</p>


<h3>References</h3>

<p>Gay, D. M. (1990) Usage Summary for Selected Optimization Routines.
Computing Science Technical Report No. 153. AT&amp;T Bell Laboratories,
Murray Hill, NJ.
</p>
<p>Powell, M. J. D. (2009). The BOBYQA algorithm for bound constrained
optimization without derivatives. Report No. DAMTP 2009/NA06, Centre
for Mathematical Sciences, University of Cambridge, UK.
<a href="https://www.damtp.cam.ac.uk/user/na/NA_papers/NA2009_06.pdf">https://www.damtp.cam.ac.uk/user/na/NA_papers/NA2009_06.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssqOdeModel">ssqOdeModel</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>,
<code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>
</p>
<p>Note also that package <span class="pkg">FME</span> function
<code><a href="FME.html#topic+modFit">modFit</a></code> has even more flexible means to fit
model parameters.
</p>
<p>Examples are given in the package vignettes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ======== load example model =========
data(chemostat)

#source("chemostat.R")

## derive scenarios
cs1 &lt;- cs2 &lt;- chemostat

## generate some noisy data
parms(cs1)[c("vm", "km")] &lt;- c(2, 10)
times(cs1) &lt;- c(from=0, to=20, by=2)
yobs &lt;- out(sim(cs1))
obstime &lt;- yobs$time
yobs$time &lt;- NULL
yobs$S &lt;- yobs$S + rnorm(yobs$S, sd= 0.1 * sd(yobs$S))*2
yobs$X &lt;- yobs$X + rnorm(yobs$X, sd= 0.1 * sd(yobs$X))

## ======== optimize it! =========

## time steps for simulation, either small for rk4 fixed step
# times(cs2)["by"] &lt;- 0.1
# solver(cs2) &lt;- "rk4"

## or, faster: use lsoda and and return only required steps that are in the data
times(cs2) &lt;- obstime
solver(cs2) &lt;- "lsoda"

## Nelder-Mead (default)
whichpar  &lt;- c("vm", "km")

res &lt;- fitOdeModel(cs2, whichpar=whichpar, obstime, yobs,
  debuglevel=0,
  control=list(trace=TRUE))

coef(res)

## assign fitted parameters to the model, i.e. as start values for next step
parms(cs2)[whichpar] &lt;- coef(res)

## alternatively, L-BFGS-B (allows lower and upper bounds for parameters)
res &lt;- fitOdeModel(cs2, whichpar=c("vm", "km"), obstime, yobs,
  debuglevel=0, fn = ssqOdeModel,
  method = "L-BFGS-B", lower = 0,
  control=list(trace=TRUE),
  atol=1e-4, rtol=1e-4)

coef(res)

## alternative 2, transform parameters to constrain unconstrained method
## Note: lower and upper are *named* vectors
res &lt;- fitOdeModel(cs2, whichpar=c("vm", "km"), obstime, yobs,
  debuglevel=0, fn = ssqOdeModel,
  method = "BFGS", lower = c(vm=0, km=0), upper=c(vm=4, km=20),
  control=list(trace=TRUE),
  atol=1e-4, rtol=1e-4)

coef(res)


## alternative 3a, use PORT algorithm
parms(cs2)[whichpar] &lt;- c(vm=1, km=2)

lower &lt;- c(vm=0, km=0)
upper &lt;- c(vm=4, km=20)

res &lt;- fitOdeModel(cs2, whichpar=c("vm", "km"), obstime, yobs,
  debuglevel=0, fn = ssqOdeModel,
  method = "PORT", lower = lower, upper = upper,
  control=list(trace=TRUE),
  atol=1e-4, rtol=1e-4)

coef(res)

## alternative 3b, PORT algorithm with manual parameter scaling
res &lt;- fitOdeModel(cs2, whichpar=c("vm", "km"), obstime, yobs,
  debuglevel=0, fn = ssqOdeModel,
  method = "PORT", lower = lower, upper = upper, scale.par = 1/upper,
  control=list(trace=TRUE),
  atol=1e-4, rtol=1e-4)

coef(res)

## set model parameters to  fitted values and simulate again
parms(cs2)[whichpar] &lt;- coef(res)
times(cs2) &lt;- c(from=0, to=20, by=1)
ysim &lt;- out(sim(cs2))

## plot results
par(mfrow=c(2,1))
plot(obstime, yobs$X, ylim = range(yobs$X, ysim$X))
lines(ysim$time, ysim$X, col="red")
plot(obstime, yobs$S, ylim= range(yobs$S, ysim$S))
lines(ysim$time, ysim$S, col="red")

</code></pre>

<hr>
<h2 id='fromtoby'>Create Regular Sequence from 'from-to-by' Vector</h2><span id='topic+fromtoby'></span>

<h3>Description</h3>

<p>This function creates a sequence from named vectors with the 
names <code>from</code>, <code>to</code> and <code>by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromtoby(times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromtoby_+3A_times">times</code></td>
<td>
<p>A named vector with the names  <code>from</code>, <code>to</code> and
<code>by</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Named vectors with  <code>from</code>, <code>to</code> and <code>by</code> can be used
in <span class="pkg">simecol</span> to specify time steps.
</p>


<h3>Value</h3>

<p>The appropriate vector with a sequence, generated by <code>seq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+seq">seq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>times &lt;- c(from=1, to=5, by=0.1)
fromtoby(times)
</code></pre>

<hr>
<h2 id='initialize-methods'>Methods for Function &lsquo;initialize&rsquo; in Package &lsquo;simecol&rsquo;</h2><span id='topic+initialize-methods'></span><span id='topic+initialize+2CsimObj-method'></span>

<h3>Description</h3>

<p>This function is used to initialize objects derived from the
<code>simObj</code> superclass, it is by default automatically called during
object creation and by <code>sim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'simObj'
initialize(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize-methods_+3A_.object">.Object</code></td>
<td>
<p><code>simObj</code> instance which is to be
re-initialized.
</p>
</td></tr>
<tr><td><code id="initialize-methods_+3A_...">...</code></td>
<td>
<p>provided for compatibility with the default method of
<code>initialize</code>, or slots of the object which is to be created (in
case of <code><a href="methods.html#topic+new">new</a></code>).
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>.Object = &quot;ANY&quot;</dt><dd><p>Generic function: see <code><a href="methods.html#topic+new">new</a></code>.</p>
</dd>
<dt>.Object = &quot;simObj&quot;</dt><dd>
<p>The <code>initialize</code> function is normally called implicitly by
<code>new</code> to create new objects. It may also be called explicitly
to return a cloned and re-initialized object.
</p>
<p>The <span class="pkg">simecol</span> version of <code>initialize</code> provides an
additonal mechanism to call a user specified function provided in
the <code>initfun</code> slot of a <code>simObj</code> instance that can
perform computations during the object creation process. The
<code>initfunc</code> must have <code>obj</code> as its only argument and must
return the modified version of this <code>obj</code>, see examples
below. As a side effect end to ensure consistency,
<code>initialize</code> clears outputs stored in slot <code>out</code> from
former simulations.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+simObj">simObj</a></code>, <code><a href="methods.html#topic+new">new</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note: new calls initialize and initialize calls initfunc(obj)
lv_efr &lt;- new("odeModel",
  main = function (time, init, parms, ...) {
    x &lt;- init
    p &lt;- parms
    S &lt;- approxTime1(inputs, time, rule=2)["s.in"]
    dx1 &lt;-   S * p["k1"] * x[1] - p["k2"] * x[1] * x[2]
    dx2 &lt;-     - p["k3"] * x[2] + p["k2"] * x[1] * x[2]
    list(c(dx1, dx2))
  },
  parms  = c(k1=0.2, k2=0.2, k3=0.2),
  times  = c(from=0, to=100, by=0.5),
  init   = c(prey=0.5, predator=1),
  solver = "lsoda",
  initfunc = function(obj) {
    tt &lt;- fromtoby(times(obj))
    inputs(obj) &lt;- as.matrix(data.frame(
            time = tt,
            s.in = pmax(rnorm(tt, mean=1, sd=0.5), 0)
          ))
    obj
  }
)
plot(sim(lv_efr))                     # initialize called automatically
plot(sim(lv_efr))                     # automatic initialization, different figure

lv_efr&lt;- initialize(lv_efr)           # re-initialize manually
plot(sim(lv_efr, initialize = FALSE)) # simulation with that configuration
    

</code></pre>

<hr>
<h2 id='iteration'>Discrete Simulation</h2><span id='topic+iteration'></span><span id='topic+iteration-methods'></span><span id='topic+iteration+2Cnumeric-method'></span><span id='topic+iteration+2CsimObj-method'></span><span id='topic+iteration+2CgridModel-method'></span><span id='topic+iteration+2CodeModel-method'></span>

<h3>Description</h3>

<p>Solver function to simulate discrete ecological (or other) dynamic
models. It is normally called indirectly from <code>sim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  iteration(y, times=FALSE, func=FALSE, parms=FALSE, animate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iteration_+3A_y">y</code></td>
<td>
<p>the initial values for the system.  If <code>y</code> has a
name attribute, the names will be used to label the output matrix.</p>
</td></tr>
<tr><td><code id="iteration_+3A_times">times</code></td>
<td>
<p>times at which explicit estimates for <code>y</code> are
desired.  The first value in <code>times</code> must be the initial time.</p>
</td></tr>
<tr><td><code id="iteration_+3A_func">func</code></td>
<td>
<p>a user-supplied function that computes the values of the
<em>next time step</em> (not the derivatives !!!) 
in the system (the <em>model defininition</em>) at time t.
The user-supplied function  <code>func</code> must be called as:
<code>yprime = func(t, y, parms)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ode system, and <code>parms</code> is a vector of parameters (which
may have a names attribute, desirable in a large system).
</p>
<p>The return value of func should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose second element is a vector (possibly with a
<code><a href="base.html#topic+names">names</a></code> attribute) of global values that are required at
each point in <code>times</code>.</p>
</td></tr>
<tr><td><code id="iteration_+3A_parms">parms</code></td>
<td>
<p>vector or list holding the parameters used in <code>func</code> 
that should be modifiable without rewriting the function.</p>
</td></tr>
<tr><td><code id="iteration_+3A_animate">animate</code></td>
<td>
<p>Animation during the simulation (if available for the specified
class.</p>
</td></tr>
<tr><td><code id="iteration_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the <code>plot</code> function if
<code>animate=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The solver method <code>iteration</code> is used to simulate discrete event
models.  Normally, this function is run indirectly from
<code><a href="#topic+sim">sim</a></code>.
</p>
<p>In contrast to differential equation solvers, the <code>main</code> function
of the model must not return the first derivative but instead and
explicitly the new state at the specified times.
</p>
<p>The actual value of time is available in the <code>main</code> function as
<code>time</code> and the current increment as <code>parms["DELTAT"]</code> or
<code>parms$DELTAT</code>. It is element of a vector if <code>parms</code> is a
vector and it is a list if <code>parms</code> is a list.
</p>
<p>If iteration is used for difference equations (see example
<code>dlogist</code> below), it is mandatory to multiply the incremental
part with <code>DELTAT</code> to ensure that variable time steps are
correctly respected and that the first row of the simulation outputs
contains the states at <code class="reqn">t_0</code>.
</p>
<p>The default <code>iteration</code> method of class <code>simObj</code> supports
the <code>observer</code> mechanism. This means that a function stored in
slot <code>observer</code> is called during each iteration step with the
return value of <code>main</code> as its first argument. You can use this to
control the amount of data stored during each iteration step
(e.g. whole population or only mean values for individual based
models), to do run-time animation or to write log files.
</p>
<p>As an alternative for models of class <code>odeModel</code>, the
<code>iteration</code> method of package <span class="pkg">deSolve</span> may be used as a
user-defined solver function. This is slightly faster and the output
supports the extended plotting functions, but then no observers are
possible and no implicit <code>DELTAT</code> variable.
</p>


<h3>Value</h3>

<p>A list of the model outputs (states ...) for each timestep.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim">sim</a></code>, 
<code><a href="#topic+observer">observer</a></code>,
<code><a href="#topic+parms">parms</a></code>,
<code><a href="deSolve.html#topic+lsoda">lsoda</a></code>, <code><a href="deSolve.html#topic+rk4">rk4</a></code>,
<code><a href="deSolve.html#topic+rk4">euler</a></code>, <code><a href="deSolve.html#topic+rk4">iteration</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(conway)


## plot after simulation:
plot(sim(conway), delay=100)

## plot during simulation
sim(conway, animate=TRUE, delay=100)


## discrete version of logistic growth equation
## Note: function main returns the *new value*, not the derivative

dlogist &lt;- new("odeModel",
  main = function (time, init, parms, ...) {
    x &lt;- init
    with(as.list(parms), {
      x &lt;- x + r * x * (1 - x / K) * DELTAT
      #   ^^^ add to old value       ^^^^^^ special parameter with time step
      list(c(x))
    })
  },
  parms  = c(r=0.1, K=10),
  times  = seq(0, 100, 1),
  init   = c(population=0.1),
  solver = "iteration" #!!!
)

plot(sim(dlogist))

## alternative with function that returns the derivative
## discrete steps are realized with the euler method

dlogist &lt;- new("odeModel",
  main = function (time, init, parms, ...) {
    x &lt;- init
    with(as.list(parms), {
      x &lt;- r * x * (1 - x / K)
      list(c(x))
    })
  },
  parms  = c(r=0.1, K=10),
  times  = seq(0, 100, 1),
  init   = c(population=0.1),
  solver = "euler"
)

plot(sim(dlogist))

## second alternative: use of the "iteration" solver from
## package deSolve, that supports extended plotting functions

dlogist &lt;- new("odeModel",
  main = function (time, init, parms, ...) {
    x &lt;- init[1]
    with(as.list(parms), {
      x &lt;- x + r * x * (1 - x / K)
      #   ^^^ add to old value
      list(c(x))
    })
  },
  parms  = c(r=0.1, K=10),
  times  = seq(0, 100, 1),
  init   = c(population=0.1),
  solver =  function(y, times, func, parms, ...)
              ode(y, times, func, parms, ..., method="iteration")
)

plot(sim(dlogist))


</code></pre>

<hr>
<h2 id='listOrNULL-class'>Helpful Union Classes</h2><span id='topic+listOrNULL-class'></span><span id='topic+listOrdata.frame-class'></span><span id='topic+functionOrNULL-class'></span><span id='topic+numericOrlist-class'></span><span id='topic+functionOrcharacter-class'></span>

<h3>Description</h3>

<p>Classes representing either list or NULL (i.e. empty), function or
NULL, function or character vector, numeric vector or list, or list or
data.frame.
</p>


<h3>Objects from the Class</h3>

<p>These classes are virtual: No objects may
be created from it.
</p>


<h3>Methods</h3>

<p>No methods exist for these classes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simObj">simObj</a></code></p>

<hr>
<h2 id='lv'>Lotka-Volterra Predator-Prey Model</h2><span id='topic+lv'></span>

<h3>Description</h3>

<p><span class="pkg">simecol</span> example: basic Lotka-Volterra predator prey-model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lv)</code></pre>


<h3>Format</h3>

<p>An S4 object according to the <code><a href="#topic+odeModel">odeModel</a></code> specification.
The object contains the following slots:
</p>

<dl>
<dt><code>main</code></dt><dd><p>Lotka-Volterra equations for predator and prey.</p>
</dd>
<dt><code>parms</code></dt><dd><p>Vector with the named parameters of the model:
</p>

<dl>
<dt><code>k1</code></dt><dd><p>growth rate of the prey population,</p>
</dd>
<dt><code>k2</code></dt><dd><p>encounter rate of predator and prey,</p>
</dd>
<dt><code>k3</code></dt><dd><p>death rate of the predator population.</p>
</dd>
</dl>

</dd>
<dt><code>times</code></dt><dd><p>Simulation time and integration interval.</p>
</dd>
<dt><code>init</code></dt><dd><p>Vector with start values for predator and prey.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To see all details, please have a look into the implementation.
</p>


<h3>References</h3>

<p>Lotka, A. J. 1925. <em>Elements of physical biology.</em> Williams and Wilkins, Baltimore.
</p>
<p>Volterra, V. (1926). Variazionie fluttuazioni del numero d'individui in specie animali conviventi.
<em>Mem. Acad.Lincei</em>, <b>2</b>, 31-113.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simecol-package">simecol-package</a></code>,
<code><a href="#topic+sim">sim</a></code>,
<code><a href="#topic+parms">parms</a></code>,
<code><a href="#topic+init">init</a></code>,
<code><a href="#topic+times">times</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##============================================
## Basic Usage:
##   explore the example
##============================================
data(lv)
print(lv)
plot(sim(lv))

parms(lv) &lt;- c(k1=0.5, k2=0.5, k3=0.5)
plot(sim(lv))

##============================================
## Implementation:
##   The code of the Lotka-Volterra-model
##============================================
lv &lt;- new("odeModel",
  main = function (time, init, parms) {
    x &lt;- init
    p &lt;- parms
    dx1 &lt;-   p["k1"] * x[1] - p["k2"] * x[1] * x[2]
    dx2 &lt;- - p["k3"] * x[2] + p["k2"] * x[1] * x[2]
    list(c(dx1, dx2))
  },
  parms  = c(k1=0.2, k2=0.2, k3=0.2),
  times  = c(from=0, to=100, by=0.5),
  init   = c(prey=0.5, predator=1),
  solver = "rk4"
)

</code></pre>

<hr>
<h2 id='lv3'>Lotka-Volterra-Type Model with Resource, Prey and Predator</h2><span id='topic+lv3'></span>

<h3>Description</h3>

<p><span class="pkg">simecol</span> example: predator prey-model with three equations:
predator, prey and resource (e.g. nutriens, grassland).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lv3)</code></pre>


<h3>Format</h3>

<p>A valid S4 object according to the <code><a href="#topic+odeModel">odeModel</a></code>
specification.  The object contains the following slots:
</p>

<dl>
<dt><code>main</code></dt><dd><p>Lotka-Volterra equations for predator
prey and resource</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>parms</code></dt><dd><p>Vector with named parameters of the model:
</p>

<dl>
<dt><code>c</code></dt><dd><p>growth rate of the prey population,</p>
</dd>
<dt><code>d</code></dt><dd><p>encounter rate of predator and prey,</p>
</dd>
<dt><code>e</code></dt><dd><p>yield factor (allows conversion with respect to <code>d</code>),</p>
</dd>
<dt><code>f</code></dt><dd><p>death rate of the predator population,</p>
</dd>
<dt><code>g</code></dt><dd><p>recycling parameter.</p>
</dd>
</dl>

</dd>
<dt><code>inputs</code></dt><dd><p>Time series specifying external delivery of resource.</p>
</dd>
<dt><code>times</code></dt><dd><p>Simulation time and integration interval.</p>
</dd>
<dt><code>init</code></dt><dd><p>Vector with start values for <code>s</code>, <code>p</code> and <code>k</code>.
</p>

<dl>
<dt><code>s</code></dt><dd><p>Resource (e.g. grassland or phosphorus).</p>
</dd>
<dt><code>p</code></dt><dd><p>Producer (prey).</p>
</dd>
<dt><code>k</code></dt><dd><p>Consumer (predator).</p>
</dd>
</dl>

</dd>
<dt><code>solver</code></dt><dd><p>Character string specifying the integration method.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+simecol-package">simecol-package</a></code>,
<code><a href="#topic+sim">sim</a></code>,
<code><a href="#topic+parms">parms</a></code>,
<code><a href="#topic+init">init</a></code>,
<code><a href="#topic+times">times</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##============================================
## Basic Usage:
##   explore the example
##============================================
data(lv3)
plot(sim(lv3))
times(lv3)["by"] &lt;- 5    # set maximum external time step to a large value
plot(sim(lv3))           # wrong! automatic time step overlooks internal inputs
plot(sim(lv3, hmax = 1)) # integration with correct maximum internal time step

##============================================
## Implementation:
##   The code of the model
##============================================
lv3 &lt;- new("odeModel",
  main = function(time, init, parms, inputs) {
    s.in &lt;- approxTime1(inputs, time, rule = 2)["s.in"]
    with(as.list(c(init, parms)),{
      ds &lt;- s.in  - b*s*p + g*k
      dp &lt;- c*s*p - d*k*p
      dk &lt;- e*p*k - f*k
      list(c(ds, dp, dk), s.in = s.in)
    })
  },
  parms = c(b = 0.1, c = 0.1, d = 0.1, e = 0.1, f = 0.1, g = 0),
  times  = c(from = 0, to = 200, by = 1),
  inputs = as.matrix(
    data.frame(
      time = c(0,   99, 100,  101, 200),
      s.in = c(0.1, 0.1, 0.5, 0.1, 0.1)
    )
  ),
  init = c(s = 1, p = 1, k = 1), # substrate, producer, consumer
  solver = "lsoda"
)  
</code></pre>

<hr>
<h2 id='mixNamedVec'>
Mix Two Named Vectors, Resolving Name Conflicts
</h2><span id='topic+mixNamedVec'></span>

<h3>Description</h3>

<p>The function mixes two named vectors. The resulting vectors contains
all elements with unique name and only one of the two versions
of the elements which have the same name in both vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixNamedVec(x, y, resolve.conflicts = c("x", "y"), warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixNamedVec_+3A_x">x</code></td>
<td>
<p>first named vector,</p>
</td></tr>
<tr><td><code id="mixNamedVec_+3A_y">y</code></td>
<td>
<p>second named vector,</p>
</td></tr>
<tr><td><code id="mixNamedVec_+3A_resolve.conflicts">resolve.conflicts</code></td>
<td>
<p>name of the vector from which all elements
are taken,</p>
</td></tr>
<tr><td><code id="mixNamedVec_+3A_warn">warn</code></td>
<td>
<p>an indicator if a warning should be given if elements are
not unique. This argument should usually set to FALSE, but the default
is TRUE to be on the safe side.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with all elements from one vector and only these elements
of the second, that have a unique name not contained in the other vector.
</p>


<h3>Author(s)</h3>

<p>Thomas Petzoldt
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which">which</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(a=1, b=2, c=3)
y &lt;- c(a=1, b=3, d=3)

mixNamedVec(x, y)
mixNamedVec(x, y, resolve.conflicts="x")

mixNamedVec(x, y, resolve.conflicts="x", warn=FALSE)
mixNamedVec(x, y, resolve.conflicts="y", warn=FALSE)

## without names, returns vector named in "resolve conflicts"
x &lt;- as.vector(x)
y &lt;- as.vector(y)
mixNamedVec(x, y)
mixNamedVec(x, y, resolve.conflicts="y")

## names partly
x &lt;- c(4, a=1, b=2, c=3, 4, 9)
y &lt;- c(a=1, 6, b=3, d=3, 8)

mixNamedVec(x, y)
mixNamedVec(x, y, resolve.conflicts="y")
</code></pre>

<hr>
<h2 id='modelFit-class'>Class of Fitted Model Parameters</h2><span id='topic+modelFit-class'></span>

<h3>Description</h3>

<p>Class that contains parameters and other information returned by <code><a href="#topic+fitOdeModel">fitOdeModel</a></code>.
</p>


<h3>Methods</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="base.html#topic+print">print</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitOdeModel">fitOdeModel</a></code></p>

<hr>
<h2 id='modelFit-method'>Show Results of Model Fits</h2><span id='topic++24'></span><span id='topic++5B'></span><span id='topic++5B+5B'></span><span id='topic++24+2CmodelFit-method'></span><span id='topic++5B+2CmodelFit-method'></span><span id='topic++5B+5B+2CmodelFit-method'></span><span id='topic+coef+2CmodelFit-method'></span><span id='topic+deviance+2CmodelFit-method'></span><span id='topic+summary+2CmodelFit-method'></span>

<h3>Description</h3>

<p>Functions to access the results of parameter fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'modelFit'
coef(object, ...)

## S4 method for signature 'modelFit'
deviance(object, ...)

## S4 method for signature 'modelFit'
summary(object, ...)

## S4 method for signature 'modelFit'
x$name

## S4 method for signature 'modelFit'
x[i, j, ..., drop=TRUE]

## S4 method for signature 'modelFit'
x[[i, j, ...]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelFit-method_+3A_object">object</code>, <code id="modelFit-method_+3A_x">x</code></td>
<td>
<p>'modelFit' object from which to extract element(s).</p>
</td></tr>
<tr><td><code id="modelFit-method_+3A_i">i</code>, <code id="modelFit-method_+3A_j">j</code></td>
<td>
<p>indices specifying elements to extract. Indices are numeric or character vectors or empty (missing) or NULL.</p>
</td></tr>
<tr><td><code id="modelFit-method_+3A_name">name</code></td>
<td>
<p>a literal character string or a name (possibly backtick quoted). For extraction, this is normally partially matched to the names of the object.</p>
</td></tr>
<tr><td><code id="modelFit-method_+3A_drop">drop</code></td>
<td>
<p>For matrices and arrays. If TRUE the result is coerced to the lowest possible dimension.</p>
</td></tr>
<tr><td><code id="modelFit-method_+3A_...">...</code></td>
<td>
<p>other arguments pased to the methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fitOdeModel">fitOdeModel</a></code>, <code><a href="base.html#topic+Extract">Extract</a></code>
</p>

<hr>
<h2 id='neighbours'>Count Number of Neighbours on a Rectangular Grid.</h2><span id='topic+neighbours'></span><span id='topic+neighbors'></span>

<h3>Description</h3>

<p>This is the base function for the simulation
of deterministic and stochastic cellular automata on rectangular
grids.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neighbours(x, state = NULL, wdist = NULL, tol = 1e-4, bounds = 0)
  neighbors(x, state = NULL, wdist = NULL, tol = 1e-4, bounds = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbours_+3A_x">x</code></td>
<td>
<p>Matrix. The cellular grid, in which each cell can have a specific
state value, e.g. zero (dead cell) or one (living cell) or the age
of an individual.</p>
</td></tr>
<tr><td><code id="neighbours_+3A_state">state</code></td>
<td>
<p>A value, whose existence is checked within the
neighbourhood of each cell.
</p>
</td></tr>
<tr><td><code id="neighbours_+3A_wdist">wdist</code></td>
<td>
<p>The neighbourhood weight matrix. It has to be a square matrix
with an odd number of rows and columns).
</p>
</td></tr>
<tr><td><code id="neighbours_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for the comparision of <code>state</code> with the
state of each cell. If <code>tol</code> is a large value, then more than
one state can be checked simultaneously.</p>
</td></tr>
<tr><td><code id="neighbours_+3A_bounds">bounds</code></td>
<td>
<p>A vector with either one or four values specifying
the type of boundaries, where 0 means open boundaries and 1 torus-like
boundaries. The values are specified in the order bottom, left, 
top, right.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The performance of the function depends on the size of the matrices and the
type of the boundaries, where open boundaries are faster than torus like
boundaries. Function <code><a href="#topic+eightneighbours">eightneighbours</a></code> is even faster.
</p>


<h3>Value</h3>

<p>A matrix with the same structure as <code>x</code> with the weighted
sum of the neigbours with values between <code>state - tol</code> and
<code>state + tol</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seedfill">seedfill</a></code>, <code><a href="#topic+eightneighbours">eightneighbours</a></code>, <code><a href="#topic+conway">conway</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ==================================================================
## Demonstration of the neighborhood function alone
## ==================================================================

## weight matrix for neighbourhood determination
wdist &lt;- matrix(c(0.5,0.5,0.5,0.5,0.5,
                  0.5,1.0,1.0,1.0,0.5,
                  0.5,1.0,1.0,1.0,0.5,
                  0.5,1.0,1.0,1.0,0.5,
                  0.5,0.5,0.5,0.5,0.5), nrow=5)

## state matrix                  
n &lt;- 20; m &lt;- 20
x &lt;- matrix(rep(0, m * n), nrow = n)

## set state of some cells to 1
x[10, 10] &lt;- 1
x[1, 5]   &lt;- 1
x[n, 15]  &lt;- 1
x[5, 2]   &lt;- 1
x[15, m]  &lt;- 1
#x[n, 1]   &lt;- 1 # corner

opar &lt;- par(mfrow = c(2, 2))
## start population
image(x)
## open boundaries
image(matrix(neighbours(x, wdist = wdist, bounds = 0), nrow = n))
## torus (donut like)
image(matrix(neighbours(x, wdist = wdist, bounds = 1), nrow = n))
## cylinder (left and right boundaries connected)
image(matrix(neighbours(x, wdist = wdist, bounds = c(0, 1, 0, 1)), nrow = n))
par(opar) # reset graphics area                  
                  
## ==================================================================
## The following example demonstrates a "plain implementation" of a
## stochastic cellular automaton i.e. without the simecol structure.
##
## A simecol implementation of this can be found in
## the example directory of this package (file: stoch_ca.R).
## ==================================================================                  
mycolors &lt;- function(n) {
  col &lt;- c("wheat", "darkgreen")
  if (n&gt;2) col &lt;- c(col, heat.colors(n - 2))
  col
}

pj &lt;- 0.99  # survival probability of juveniles
pa &lt;- 0.99  # survival probability of adults
ps &lt;- 0.1   # survival probability of senescent
ci &lt;- 1.0   # "seeding constant"
adult &lt;- 5  # age of adolescence
old   &lt;- 10 # age of senescence

## Define a start population
n &lt;- 80
m &lt;- 80
x &lt;- rep(0, m*n)

## stochastic seed
## x[round(runif(20,1,m*n))] &lt;- adult
dim(x)&lt;- c(n, m)

## rectangangular seed in the middle
x[38:42, 38:42] &lt;- 5

## plot the start population
image(x, col = mycolors(2))

## -----------------------------------------------------------------------------
## Simulation loop (hint: increase loop count)
## -----------------------------------------------------------------------------
for (i in 1:10){

  ## rule 1: reproduction
  ## 1.1 which cells are adult? (only adults can generate)
  ad &lt;- ifelse(x &gt;= adult &amp; x &lt; old, x, 0)

  ## 1.2 how much (weighted) adult neighbours has each cell?
  nb &lt;- neighbours(ad, wdist = wdist)

  ## 1.3 a proportion of the seeds develops juveniles
  ## simplified version, you can also use probabilities
  genprob &lt;- nb * runif(nb) * ci
  xgen  &lt;- ifelse(x == 0 &amp; genprob &gt;= 1, 1, 0)

  ## rule 2: growth and survival of juveniles
  xsurvj &lt;- ifelse(x &gt;= 1 &amp; x &lt; adult &amp; runif(x) &lt;= pj, x+1, 0)
  ## rule 2: growth and survival of adults
  xsurva &lt;- ifelse(x &gt;= adult &amp; x &lt; old &amp; runif(x) &lt;= pa, x+1, 0)
  ## rule 2: growth and survival of senescent
  xsurvs &lt;- ifelse(x &gt;= old &amp; runif(x) &lt;= ps, x+1, 0)

  ## make resulting grid of complete population
  x     &lt;- xgen + xsurvj + xsurva + xsurvs

  ## plot resulting grid
  image(x, col = mycolors(max(x) + 1), add = TRUE)
  if (max(x) == 0) stop("extinction", call. = FALSE)
}

## modifications:  pa&lt;-pj&lt;-0.9

## additional statistics of population structure
## with table, hist, mean, sd, ...
</code></pre>

<hr>
<h2 id='observer'>Get or Set an Observer Functions to an &lsquo;simObj&rsquo; Object</h2><span id='topic+observer'></span><span id='topic+observer-methods'></span><span id='topic+observer+2CsimObj-method'></span><span id='topic+observer+3C-'></span><span id='topic+observer+3C--methods'></span><span id='topic+observer+3C-+2CsimObj-method'></span>

<h3>Description</h3>

<p>Get or set a user-defined observer to enable user-specified storage
of simulation results, visualisation or logging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
observer(obj, ...)
observer(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="observer_+3A_obj">obj</code></td>
<td>
<p>A valid <code>simObj</code> instance.</p>
</td></tr>
<tr><td><code id="observer_+3A_value">value</code></td>
<td>
<p>A function specifying an observer, see Details.
</p>
</td></tr>
<tr><td><code id="observer_+3A_...">...</code></td>
<td>
<p>Reserved for method consistency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The observer can be used with solver <code><a href="#topic+iteration">iteration</a></code> or a user-defined
solver function. It does not work with differential equations solvers.
</p>
<p>The observer is a function with the following arguments:
</p>
<p><code>function(state)</code>
</p>
<p>or:
</p>
<p><code>function(state, time, i, out, y)</code>
</p>
<p>Where <code>state</code> is the actual state of the system, <code>time</code> and <code>i</code>
are the simulation time and the indexof the time step respectively,
<code>out</code> is the output of the actual simulation collected so far. 
The original object used in the simulation is passed via <code>y</code> and can be used
to get access on parameter values or model equations.
</p>
<p>If available, the observer function is called for every time step in the 
iteration. It can be used for calculations &ldquo;on the fly&rdquo; to reduce memory
of saved data, for user-specified animation or for logging purposes.
</p>
<p>If the value returned by observer is a vector, than resulting <code>out</code> will be a
<code>data.frame</code>, otherwise it will be a list of all states.
</p>


<h3>Value</h3>

<p>The observer function either modifies <code>obj</code> or it returns the 
assigned observer function or <code>NULL</code> (the default).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iteration">iteration</a></code> for the iteration solver,
</p>
<p><code><a href="#topic+parms">parms</a></code> for accessor and replacement functions of other slots,
</p>
<p><code><a href="#topic+simecol-package">simecol-package</a></code> for an overview of the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load model "diffusion"
data(diffusion)

solver(diffusion) # solver is iteration, supports observer
times(diffusion) &lt;- c(from=0, to=20, by=1) # to can be increased, to e.g. 100

### == Example 1 ===============================================================

## assign an observer for visualisation
observer(diffusion) &lt;- function(state) {
  ## numerical output to the screen
  cat("mean x=", mean(state$x),
      ", mean y=", mean(state$y),
      ", sd   x=", sd(state$x),
      ", sd   y=", sd(state$y), "\n")
  ## animation
  par(mfrow = c(2, 2))
  plot(state$x, state$y, xlab = "x", ylab = "y", pch = 16, 
    col = "red", xlim = c(0, 100))
  hist(state$y)
  hist(state$x)
  
  ## default case: 
  ## return the state --&gt; iteration stores full state in "out"
  state
}

sim(diffusion)

### == Example 2 ===============================================================

## an extended observer with full argument list
observer(diffusion) &lt;- function(state, time, i, out, y) {
  ## numerical output to the screen
  cat("index =", i,
      ", time =", time,
      ", sd   x=", sd(state$x),
      ", sd   y=", sd(state$y), "\n")
  ## animation
  par(mfrow = c(2, 2))
  plot(state$x, state$y, xlab = "x", ylab = "y", pch = 16, 
    col = "red", xlim = c(0, 100))
  hist(state$y)
  hist(state$x)
  if (is.matrix(out)) # important because out may be NULL for the first call
    matplot(out[,1], out[,-1]) # dynamic graph of sd in both directions
  
  ## return a vector with summary information
  c(times = time, sdx=sd(state$x), sdy=sd(state$y))
}

diffusion &lt;- sim(diffusion)

### == Restore default =========================================================

observer(diffusion) &lt;- NULL # delete observer
diffusion &lt;- sim(diffusion)

</code></pre>

<hr>
<h2 id='odeModel'>Generating-functions (Constructors) to Create Objects of
Classes &lsquo;odeModel&rsquo;, &lsquo;rwalkModel&rsquo; and &lsquo;gridModel&rsquo;.</h2><span id='topic+odeModel'></span><span id='topic+gridModel'></span><span id='topic+rwalkModel'></span><span id='topic+indbasedModel'></span>

<h3>Description</h3>

<p>These functions can be used to create <code>simObj</code> instances without
using <code>new</code> explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odeModel(obj = NULL, main = NULL,
        equations = NULL, times = c(from = 0, to = 10, by = 1),
        init = numeric(0), parms = numeric(0),
        inputs = NULL, solver = "rk4", initfunc = NULL)

gridModel(obj = NULL, main = NULL,
        equations = NULL, times = c(from=0, to=10, by=1),
        init = matrix(0), parms = list(),
        inputs = NULL, solver = "iteration", initfunc = NULL)

rwalkModel(obj = NULL, main = NULL, 
        equations = NULL, times = c(from = 0, to = 10, by = 1),
        init = NULL, parms = list(),
        inputs = NULL, solver = "iteration", initfunc = NULL)
        
indbasedModel(obj = NULL, main = NULL, 
        equations = NULL, times = c(from = 0, to = 10, by = 1),
        init = NULL, parms = list(),
        inputs = NULL, solver = "iteration", initfunc = NULL)        
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odeModel_+3A_obj">obj</code></td>
<td>
<p>Unnamed arguments are regarded as objects of the corresponding
class. If <code>obj</code> is omitted, the new object is created from scratch.</p>
</td></tr>
<tr><td><code id="odeModel_+3A_main">main</code></td>
<td>
<p>The main equations of the model.</p>
</td></tr>
<tr><td><code id="odeModel_+3A_equations">equations</code></td>
<td>
<p>The sub-models (sub-equations and of the model).</p>
</td></tr>
<tr><td><code id="odeModel_+3A_times">times</code></td>
<td>
<p>A vector of time steps or a vector with three
named values <code>from</code>, <code>to</code>, <code>by</code> specifying the
simulation time steps. The &lsquo;from-to-by&rsquo; form can be edited with
<code>editParms</code>.</p>
</td></tr>
<tr><td><code id="odeModel_+3A_init">init</code></td>
<td>
<p>Initial values (start values) of the
state variable given as named vector.</p>
</td></tr>
<tr><td><code id="odeModel_+3A_parms">parms</code></td>
<td>
<p>A vector or list (depending on the respective class) of constant
parameters.</p>
</td></tr>
<tr><td><code id="odeModel_+3A_inputs">inputs</code></td>
<td>
<p>Optional time-dependend input
variables (matrix or data frame).</p>
</td></tr>
<tr><td><code id="odeModel_+3A_solver">solver</code></td>
<td>
<p>The solver used to integrate the model.</p>
</td></tr>
<tr><td><code id="odeModel_+3A_initfunc">initfunc</code></td>
<td>
<p>The function is called by the <code>initialize</code> mechanism
and allows direct access and manipulation of all slots
of the object in creation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide an alternative way to create
<code>simObj</code> instances in addition to the standard S4 <code>new</code>
mechanism. The functions are provided mainly for compatibility with older
versions of <span class="pkg">simecol</span>.
</p>
<p>See <code><a href="#topic+simecol-package">simecol-package</a></code> and the examples for details about the
slots.
</p>


<h3>Value</h3>

<p>The function returns an S4 object of type <code>odeModel</code>,
<code>rwalkModel</code>, <code>gridModel</code>
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+new">new</a></code>,
<code><a href="#topic+simecol-package">simecol-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## (1) Define and run your own simecol model with new ==================

lv &lt;- new("odeModel", 
  main = function (time, init, parms) {
    with(as.list(c(init, parms)), {
      dn1 &lt;-   k1 * N1 - k2 * N1 * N2
      dn2 &lt;- - k3 * N2 + k2 * N1 * N2
      list(c(dn1, dn2))
    })
  },
  parms  = c(k1 = 0.2, k2 = 0.2, k3 = 0.2),
  times  = c(from = 0, to = 100, by = 0.5),
  init   = c(N1 = 0.5, N2 = 1),
  solver = "lsoda"
)

## ... or use the generating function ----------------------------------

lv &lt;- odeModel( 
  main = function (time, init, parms) {
    with(as.list(c(init, parms)), {
      dn1 &lt;-   k1 * N1 - k2 * N1 * N2
      dn2 &lt;- - k3 * N2 + k2 * N1 * N2
      list(c(dn1, dn2))
    })
  },
  parms  = c(k1 = 0.2, k2 = 0.2, k3 = 0.2),
  times  = c(from = 0, to = 100, by = 0.5),
  init   = c(N1 = 0.5, N2 = 1),
  solver = "lsoda"
)

lv &lt;- sim(lv)
plot(lv)

## (2) Conway's Game of Life ==========================================

set.seed(23)  # to make it reproducible

conway &lt;- new("gridModel",
  main = function(time, x, parms) {
    nb     &lt;- eightneighbours(x)
    surviv &lt;- (x &gt;  0 &amp; (nb %in% parms$srv))
    gener  &lt;- (x == 0 &amp; (nb %in% parms$gen))
    x      &lt;- (surviv + gener) &gt; 0
    return(x)
  },
  parms  = list(srv = c(2, 3), gen = 3),
  times  = 1:17,
  init   = matrix(round(runif(1000)), ncol=40),
  solver = "iteration"
)

sim(conway, animate=TRUE)

</code></pre>

<hr>
<h2 id='p.constrain'>Transform Data Between Unconstrained and Box-constrained Scale</h2><span id='topic+p.constrain'></span><span id='topic+p.unconstrain'></span>

<h3>Description</h3>

<p>These functions can be used to transform a vector of data or
parameters between unconstrained [-Inf, Inf] and box-constrained
representation (interval [lower, upper]).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.constrain(p, lower = -Inf, upper = Inf, f = 1)
p.unconstrain(p, lower = -Inf, upper = Inf, f = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.constrain_+3A_p">p</code></td>
<td>
<p>vector of data (e.g. model parameters),</p>
</td></tr>
<tr><td><code id="p.constrain_+3A_lower">lower</code>, <code id="p.constrain_+3A_upper">upper</code></td>
<td>
<p>vectors with lower resp. upper bounds used for 
transformation,
</p>
</td></tr>
<tr><td><code id="p.constrain_+3A_f">f</code></td>
<td>
<p>optional scaling factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are employed by <code><a href="#topic+fitOdeModel">fitOdeModel</a></code>
<code><a href="#topic+ssqOdeModel">ssqOdeModel</a></code> in order to be able to use the unconstrained
optimizers of <code><a href="stats.html#topic+optim">optim</a></code> for constrained optimization.
</p>
<p>The transformation functions are
</p>
<p style="text-align: center;"><code class="reqn">p' = \tan(\pi/2 \cdot (2 p - upper - lower) / (upper - lower)) \cdot 1/f</code>
</p>
  
<p>and its inverse
</p>
<p style="text-align: center;"><code class="reqn">p = (upper + lower)/2 + (upper - lower) \cdot \arctan(f \cdot p')/\pi</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>vector with transformed (resp. back-transformed) values.
</p>


<h3>References</h3>

<p>This trick seems to be quite common, but in most cases it is preferred
to apply optimizers that can handle constraints internally.
</p>
<p>Reichert, T. (1998) AQUASIM 2.0 User Manual.  Computer Program for the
Identification and Simulation of Aquatic Systems. Swiss Federal
Institute for Environmental Science and Technology (EAWAG), CH - 8600
Duebendorf Switzerland,
<a href="https://www.eawag.ch/de/abteilung/siam/software/">https://www.eawag.ch/de/abteilung/siam/software/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitOdeModel">fitOdeModel</a></code>, <code><a href="#topic+ssqOdeModel">ssqOdeModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- seq(-100, 100, 2)
plot(xx, yy&lt;-p.constrain(xx, -20, 45), type="l")
points(p.unconstrain(yy, -20, 45), yy, col="red")
</code></pre>

<hr>
<h2 id='parms'>Accessor Functions for &lsquo;simObj&rsquo; Objects</h2><span id='topic+main'></span><span id='topic+main-methods'></span><span id='topic+main+2CsimObj-method'></span><span id='topic+main+3C-'></span><span id='topic+main+3C--methods'></span><span id='topic+main+3C-+2CsimObj-method'></span><span id='topic+equations'></span><span id='topic+equations-methods'></span><span id='topic+equations+2CsimObj-method'></span><span id='topic+equations+3C-'></span><span id='topic+equations+3C--methods'></span><span id='topic+equations+3C-+2CsimObj-method'></span><span id='topic+parms'></span><span id='topic+parms-methods'></span><span id='topic+parms+2CsimObj-method'></span><span id='topic+parms+3C-'></span><span id='topic+parms+3C--methods'></span><span id='topic+parms+3C-+2CsimObj-method'></span><span id='topic+init'></span><span id='topic+init-methods'></span><span id='topic+init+2CsimObj-method'></span><span id='topic+init+3C-'></span><span id='topic+init+3C--methods'></span><span id='topic+init+3C-+2CsimObj+2CANY-method'></span><span id='topic+init+3C-+2CgridModel+2Cmatrix-method'></span><span id='topic+init+3C-+2CgridModel+2CANY-method'></span><span id='topic+times'></span><span id='topic+times-methods'></span><span id='topic+times+2CsimObj-method'></span><span id='topic+times+3C-'></span><span id='topic+times+3C--methods'></span><span id='topic+times+3C-+2CsimObj-method'></span><span id='topic+inputs'></span><span id='topic+inputs-methods'></span><span id='topic+inputs+2CsimObj-method'></span><span id='topic+inputs+3C-'></span><span id='topic+inputs+3C--methods'></span><span id='topic+inputs+3C-+2CsimObj-method'></span><span id='topic+solver'></span><span id='topic+solver-methods'></span><span id='topic+solver+2CsimObj-method'></span><span id='topic+solver+3C-'></span><span id='topic+solver+3C--methods'></span><span id='topic+solver+3C-+2CsimObj-method'></span><span id='topic+initfunc'></span><span id='topic+initfunc-methods'></span><span id='topic+initfunc+2CsimObj-method'></span><span id='topic+initfunc+3C-'></span><span id='topic+initfunc+3C--methods'></span><span id='topic+initfunc+3C-+2CsimObj-method'></span><span id='topic+out'></span><span id='topic+out-methods'></span><span id='topic+out+2CsimObj-method'></span><span id='topic+out+2CgridModel-method'></span><span id='topic+out+2CodeModel-method'></span><span id='topic+out+3C-'></span><span id='topic+out+3C--methods'></span><span id='topic+out+3C-+2CsimObj-method'></span>

<h3>Description</h3>

<p>Get or set simulation model parameters, main or sub-equations, initial
values, time steps or solvers and extract simulation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parms(obj, ...)
parms(obj) &lt;- value

main(obj, ...)
main(obj) &lt;- value

equations(obj, ...)
equations(obj) &lt;- value

init(obj, ...)
init(obj) &lt;- value

inputs(obj, ...)
inputs(obj) &lt;- value

times(obj, ...)
times(obj) &lt;- value

solver(obj, ...)
solver(obj) &lt;- value

#observer(obj, ...)
#observer(obj) &lt;- value

initfunc(obj, ...)
initfunc(obj) &lt;- value

out(obj, ...)
out(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parms_+3A_obj">obj</code></td>
<td>
<p>A valid <code>simObj</code> instance.</p>
</td></tr>
<tr><td><code id="parms_+3A_value">value</code></td>
<td>
<p>Named list, vector, function or other data structure
(depending on the slot and model class) with the same structure as
the value returned by <code>parms</code>. Either all or a subset of values
(e.g. single elements of vectors or lists) can be changed at once.
</p>
</td></tr>
<tr><td><code id="parms_+3A_...">...</code></td>
<td>
<p>Reserved for method consistency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the accessing functions for <code>parms</code>, <code>times</code> etc.
</p>
<p>Please take care of the semantics of your model when changing slots.
All, element names, data structure and values have to correspond to
you model object definition. For example in <code>init</code> the applied
names must exactly correspond to the names and number (!) of state
variables. The restrictions of <code>parms</code> or <code>equations</code> are
less strict (additional values for &ldquo;future use&rdquo; are allowed).
</p>
<p>The function <code>times</code> allows either to assign or to modify a
special vector with three elements named <code>from</code>, <code>to</code> and
<code>by</code> or to overwrite <code>times</code> with an un-named sequence (e.g.
<code>seq(1, 100, 0.1)</code>.
</p>
<p>To ensure object consistency function <code>out</code> cannot assign
arbitrary values. It can only extract or delete the contents (by
assigning <code>NULL</code>) of the <code>out</code>-slot.
</p>


<h3>Value</h3>

<p>A list, named vector, matrix or function (for <code>main</code> slot) or
list of functions (<code>equation</code> slot) or other appropriate data
structure depending on the class of the model object.
</p>


<h3>See Also</h3>

<p>General explanation of the slots can be found in <code><a href="#topic+simecol-package">simecol-package</a></code>.
</p>
<p>Usage of the <code>observer</code> slot is found in the special help file 
<code><a href="#topic+observer">observer</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lv)
parms(lv)
parms(lv)       &lt;- c(k1 = 0.2, k2 = 0.5, k3 = 0.3)
parms(lv)["k2"] &lt;- 0.5

data(conway)
parms(conway)
parms(conway)$srv &lt;- c(2, 2)
parms(conway)

## add a new named parameter value
parms(lv)["dummy"] &lt;- 1
## remove dummy parameter
parms(lv) &lt;- parms(lv)[names(parms(lv)) != "dummy"]

## simulation and extraction of outputs
lv &lt;- sim(lv)
o &lt;- out(lv)

## remove outputs from object
out(lv) &lt;- NULL

## store object persistently to the disk
## Not run: 
save(lv, file = "lv.Rdata")           # in binary form
dput(as.list(lv), file = "lv-list.R") # in text form

## End(Not run)
</code></pre>

<hr>
<h2 id='pcuseries'>Generate Plackett Bivariate Random Numbers</h2><span id='topic+pcuseries'></span><span id='topic+pcu'></span><span id='topic+rho2alpha'></span><span id='topic+alpha2rho'></span>

<h3>Description</h3>

<p>Generate bivariate uniform random numbers according to the Plackett
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcu(x, alpha = rho2alpha(rho), rho)
pcuseries(n, alpha = rho2alpha(rho), rho, min = 0, max = 1)
alpha2rho(alpha)
rho2alpha(rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcuseries_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="pcuseries_+3A_x">x</code></td>
<td>
<p>vector of uniformly [0, 1] distributed real numbers.</p>
</td></tr>
<tr><td><code id="pcuseries_+3A_alpha">alpha</code></td>
<td>
<p>association coefficient of the Plackett distribution.</p>
</td></tr>
<tr><td><code id="pcuseries_+3A_rho">rho</code></td>
<td>
<p>Pearson correlation coefficient.</p>
</td></tr>
<tr><td><code id="pcuseries_+3A_min">min</code>, <code id="pcuseries_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution. Must be
finite.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions can be used to generate bivariate distributions with
uniform marginals. Function <code>pcu</code> generates a vector of uniform
random values of <code>length(x)</code> which are correlated to the
corresponding vector <code>x</code>, <code>pcuseries</code> generates an
auto-correlated series, and <code>alpha2rho</code> resp. <code>rho2alpha</code>
convert between the Pearson correlation coefficient and the association
measure of the Plackett distribution.
</p>


<h3>References</h3>

 
<p>Johnson, M., Wang, C., &amp; Ramberg, J. (1984). Generation of
multivariate distributions for statistical
applications. <em>American Journal of Mathematical and Management
Sciences</em>, <b>4</b>, 225-248.
</p>
<p>Nelsen, R. B. (2006). <em>An Introduction to Copulas</em>. Springer, New
York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+runif">runif</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(100)
y &lt;- pcu(x, rho = 0.8)
plot(x, y)
cor(x, y)

x &lt;- pcuseries(1000, rho=0.8)
plot(x, type="l")
acf(x)
pacf(x)
</code></pre>

<hr>
<h2 id='peaks'>Find Peaks Within xy-Data</h2><span id='topic+peaks'></span>

<h3>Description</h3>

<p>The function returns maxima (values which have only smaller neighbours)
and minima (values which have only larger neighbours).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks(x, y=NULL, mode="maxmin")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peaks_+3A_x">x</code>, <code id="peaks_+3A_y">y</code></td>
<td>
<p>the coordinates of given points.</p>
</td></tr>
<tr><td><code id="peaks_+3A_mode">mode</code></td>
<td>
<p>specifies if both maxima and minima (<code>mode="maxmin"</code>)
or only maxima (<code>mode="max"</code>) or minima (<code>mode="min"</code>) are
requested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with x and y coordinates of all peaks.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approx">approx</a></code>,
<code><a href="#topic+upca">upca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sin(seq(0, 10, 0.1))
plot(x)
points(peaks(x), col="red", pch=15)
</code></pre>

<hr>
<h2 id='plot-methods'>Methods for Function plot in Package &lsquo;simecol&rsquo;</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CANY+2CANY-method'></span><span id='topic+plot+2CsimObj+2Cmissing-method'></span><span id='topic+plot+2CodeModel+2CodeModel-method'></span><span id='topic+plot+2CodeModel+2Cmissing-method'></span><span id='topic+plot+2CgridModel+2Cmissing-method'></span><span id='topic+plot+2CrwalkModel+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for function <code>plot</code> in package <span class="pkg">simecol</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'simObj,missing'
plot(x, y, ...)
  ## S4 method for signature 'odeModel,missing'
plot(x, y, ...)
  ## S4 method for signature 'odeModel,odeModel'
plot(x, y, ...)
  ## S4 method for signature 'gridModel,missing'
plot(x, y, index=1:length(x@out), delay=0, ...)
  ## S4 method for signature 'rwalkModel,missing'
plot(x, y, index=1:length(x@out), delay=0, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>simObj</code>,</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p>either a second <code>odeModel</code> object or ignored,</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_index">index</code></td>
<td>
<p>index of time steps to be plotted,</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_delay">delay</code></td>
<td>
<p>delay (in ms) between consecutive images (for
<code>gridModel</code>s) or xy-plots (for <code>rwalkModel</code>s),
</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>optional plotting parameters.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;, y = &quot;ANY&quot;</dt><dd><p>Generic function: see
<code><a href="graphics.html#topic+plot">plot</a></code>.  </p>
</dd>
<dt>x = &quot;simObj&quot;, ...</dt><dd><p>template function, does nothing and
only issues a warning.</p>
</dd>
<dt>x = &quot;odeModel&quot;, ...</dt><dd><p>plots time series of the state
variables where one or more <code>odeModel</code> objects can be supplied.
Optional plotting parameters are possible, too. 
See <code><a href="deSolve.html#topic+plot.deSolve">plot.deSolve</a></code> for details.</p>
</dd>
<dt>x = &quot;gridModel&quot;, ...</dt><dd><p>displays a series of images for the
simulated grid.</p>
</dd>
<dt>x = &quot;rwalkModel&quot;, ...</dt><dd><p>displays a series of x-y plots of the
simulated individuals.</p>
</dd>
</dl>


<hr>
<h2 id='print-methods'>Methods for Function &lsquo;print&rsquo; in Package &lsquo;simecol&rsquo;</h2><span id='topic+print-methods'></span><span id='topic+print+2CANY-method'></span><span id='topic+print+2CsimObj-method'></span><span id='topic+show+2CsimObj-method'></span>

<h3>Description</h3>

<p>Methods for function <code>print</code> in Package <span class="pkg">simecol</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'simObj'
print(x, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>simObj</code> or one of its subclasses.</p>
</td></tr>
<tr><td><code id="print-methods_+3A_all">all</code></td>
<td>
<p>specifies whether all slots are printed. Default is that
only not-empty slots are printed and the contents of <code>out</code> are suppressed.</p>
</td></tr>
<tr><td><code id="print-methods_+3A_...">...</code></td>
<td>
<p>optional parameters passed to print.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;</dt><dd><p>generic function: see <code><a href="base.html#topic+print">print</a></code>.</p>
</dd>
<dt>x = &quot;simObj&quot;</dt><dd><p>prints the contents (slots) of the <code>simObj</code> object.</p>
</dd>
</dl>


<hr>
<h2 id='sEdit'>Simple editing</h2><span id='topic+sEdit'></span>

<h3>Description</h3>

<p>Simple Editing of Vectors, Lists of Vectors and Other
Objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> sEdit(x, title = "Please enter values:")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sEdit_+3A_x">x</code></td>
<td>
<p>A named object that you want to edit.</p>
</td></tr>
<tr><td><code id="sEdit_+3A_title">title</code></td>
<td>
<p>A title for the dialog box.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If called with a vector or list of vectors and if <b>Tcl/Tk</b> is
installed, a dialog box is shown in which data can be entered. If the
<code>x</code> is not of type vector or list of vectors, a default
editing method is called.
</p>


<h3>Value</h3>

<p>An object with the same type like <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+edit">edit</a></code>
<code><a href="#topic+editParms">editParms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require("tcltk")
## named vector
vec  &lt;- c(a = 1, b = 20, c = 0.03)
new  &lt;- sEdit(vec)
## unnamed vector
sEdit(numeric(10))
## list of vectors
lst &lt;- list(vec = vec, test = 1:10)
sEdit(lst)
## list with numeric and character vectors mixed
lst &lt;- list(vec = vec, test = c("a", "b", "c"))
sEdit(lst)

## End(Not run)
</code></pre>

<hr>
<h2 id='seedfill'>Color Fill Algorithm</h2><span id='topic+seedfill'></span>

<h3>Description</h3>

<p>Fills a bounded area within a numeric matrix with a given number (color).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> seedfill(z, x=1, y=1, fcol=0, bcol=1, tol=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seedfill_+3A_z">z</code></td>
<td>
<p>a matrix containing an image (double precision values are possible).</p>
</td></tr>
<tr><td><code id="seedfill_+3A_x">x</code>, <code id="seedfill_+3A_y">y</code></td>
<td>
<p>start coordinates of the filled area.</p>
</td></tr>
<tr><td><code id="seedfill_+3A_fcol">fcol</code></td>
<td>
<p>numeric value of the fill color.</p>
</td></tr>
<tr><td><code id="seedfill_+3A_bcol">bcol</code></td>
<td>
<p>numeric value of the border value.</p>
</td></tr>
<tr><td><code id="seedfill_+3A_tol">tol</code></td>
<td>
<p>numeric value of border color tolerance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements a basic color fill algorithm for use in image
manipulation or cellular automata.
</p>


<h3>Value</h3>

<p>A matrix with the same structure as <code>z</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neighbours">neighbours</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a matrix
z&lt;-matrix(0, nrow=20, ncol=20)

# draw some lines
z[10,]&lt;-z[,10] &lt;- 1
z[5,] &lt;-z[,5]  &lt;- 3

# plot matrix and filled variants
par(mfrow=c(2, 2))
image(z)
image(seedfill(z))
image(seedfill(z ,x=15, y=15, fcol=1, bcol=3))
image(seedfill(z, x=7, y=7, fcol=3, bcol=1))
</code></pre>

<hr>
<h2 id='sim-methods'>Simulation of 'simObj' model objects</h2><span id='topic+sim'></span><span id='topic+sim-methods'></span><span id='topic+sim+2CgridModel-method'></span><span id='topic+sim+2CodeModel-method'></span><span id='topic+sim+2CsimObj-method'></span>

<h3>Description</h3>

<p>This function provides the core functionality of the &lsquo;simecol&rsquo; package.
Several methods depending on the class of the model are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sim(obj, initialize=TRUE, ...)
  # sim(obj, animation=FALSE, delay=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim-methods_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>simObj</code> or one of its subclasses.</p>
</td></tr>
<tr><td><code id="sim-methods_+3A_initialize">initialize</code></td>
<td>
<p>re-initialize the object if the object contains a
user-defined initializing function (<code>initfunc</code>). Setting
<code>initialize</code> to <code>FALSE</code> can be useful to avoid
time-consuming computations during initialization or to reproduce
simulations of models which assign random values during the
initialization process.</p>
</td></tr>
<tr><td><code id="sim-methods_+3A_animation">animation</code></td>
<td>
<p>logical value to switch animation on (for classes
<code>gridModel</code> and <code>rwalkModel</code>.</p>
</td></tr>
<tr><td><code id="sim-methods_+3A_delay">delay</code></td>
<td>
<p>delay (in ms and in addition to the time needed for the
simulation) between consecutive images (for <code>gridModel</code>s) or
xy-plots (for <code>rwalkModel</code>s).</p>
</td></tr>
<tr><td><code id="sim-methods_+3A_...">...</code></td>
<td>
<p>optional parameters passed to the solver function
(e.g. <code>hmax</code> for <code>lsoda</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim</code> re-initializes the model object (if <code>initialize==TRUE</code>
and calls the appropriate solver, specified in the <code>solver</code>-slot.
Objects of class <code>rwalkModel</code> and <code>indbasedModel</code> are
simulated by the default <code>simObj</code> method. If you derive own
sublasses from <code>simObj</code> it may be neccessary to write an
appropriate <code>sim</code> method and/or solver function.
</p>


<h3>Value</h3>

<p>The function returns the complete <code>simObj</code> instance with the
simulation results in the <code>out</code> slot.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;simObj&quot;</dt><dd><p>simulates the respective model object with
optional animation.</p>
</dd>
<dt>obj = &quot;odeModel&quot;</dt><dd><p>simulates the respective model object.</p>
</dd>
<dt>obj = &quot;indbasedModel&quot;</dt><dd><p>simulates the respective model object with
optional animation.</p>
</dd>
<dt>obj = &quot;gridModel&quot;</dt><dd><p>simulates the respective model object with
optional animation.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(lv)
plot(sim(lv))

lv2 &lt;- lv
parms(lv2)["k1"] &lt;- 0.5
lv2 &lt;- sim(lv2)
plot(out(lv2))
</code></pre>

<hr>
<h2 id='ssqOdeModel'>Sum of Squares Between odeModel and Data</h2><span id='topic+ssqOdeModel'></span>

<h3>Description</h3>

<p>Compute the sum of squares between a given data and an <code>odeModel</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssqOdeModel(p, simObj, obstime, yobs, 
  sd.yobs = as.numeric(lapply(yobs, sd)), 
  initialize = TRUE, lower. = -Inf, upper. = Inf, weights = NULL,
  debuglevel = 0, ..., pnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssqOdeModel_+3A_p">p</code></td>
<td>
<p>vector of named parameter values of the model (can be a
subset),</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_simobj">simObj</code></td>
<td>
<p>a valid object of class <code><a href="#topic+odeModel">odeModel</a></code>,</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_obstime">obstime</code></td>
<td>
<p>vector with time steps for which observational data are
available,</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_yobs">yobs</code></td>
<td>
<p>data frame with observational data for all or a subset of
state variables. Their names must correspond exacly with existing
names of state variables in the <code><a href="#topic+odeModel">odeModel</a></code>.</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_sd.yobs">sd.yobs</code></td>
<td>
<p>vector of given standard deviations for all
observational variables given in <code>yobs</code>. If no standard
deviations are given, these are estimated from yobs.</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_initialize">initialize</code></td>
<td>
<p>optional boolean value whether the <code>simObj</code>
should be re-initialized after the assignment of new parameter
values. This can be necessary in certain models to assign consistent
values to initial state variables if they depend on parameters.</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_lower.">lower.</code>, <code id="ssqOdeModel_+3A_upper.">upper.</code></td>
<td>
<p>named vectors with lower and upper bounds used
in the optimisation,</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_weights">weights</code></td>
<td>
<p>optional weights to be used in the fitting process.
Should be <code>NULL</code> or a data frame with the same structure as
<code>yobs</code>.  If non-NULL, weighted least squares is used with
<code>weights</code> (that is, minimizing <code>sum(w*e^2)</code>); otherwise
ordinary least squares is used.</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_debuglevel">debuglevel</code></td>
<td>
<p>a positive number that specifies the amount of
debugging information printed,</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the solver method (e.g.
<code><a href="deSolve.html#topic+lsoda">lsoda</a></code>),</p>
</td></tr>
<tr><td><code id="ssqOdeModel_+3A_pnames">pnames</code></td>
<td>
<p>names of the parameters, optionally passed from
fitOdeModel. This argument is a workaround for <span class="rlang"><b>R</b></span> versions below
2.8.1. It may be removed in future versions of <span class="pkg">simecol</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the default function called by function
<code><a href="#topic+fitOdeModel">fitOdeModel</a></code>. The source code of this function can be
used as a starting point to develop user-defined optimization
criteria (cost functions).
</p>


<h3>Value</h3>

<p>The sum of squared differences between <code>yobs</code> and simulation,
by default weighted by the inverse of the standard deviations of the respective
variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitOdeModel">fitOdeModel</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+p.constrain">p.constrain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chemostat)
cs1 &lt;- chemostat

## generate some noisy data
parms(cs1)[c("vm", "km")] &lt;- c(2, 10)
times(cs1) &lt;- c(from = 0, to = 20, by = 2)
yobs &lt;- out(sim(cs1))
obstime &lt;- yobs$time
yobs$time &lt;- NULL
yobs$S &lt;- yobs$S + rnorm(yobs$S, sd = 0.1 * sd(yobs$S))*2
yobs$X &lt;- yobs$X + rnorm(yobs$X, sd = 0.1 * sd(yobs$X))

## SSQ between model and data
ssqOdeModel(NULL, cs1, obstime, yobs)

## SSQ between model and data, different parameter set
ssqOdeModel(p=c(vm=1, km=2), cs1, obstime, yobs)

## SSQ between model and data, downweight second observation
## (both variables)
weights &lt;- data.frame(X=rep(1, nrow(yobs)), S = rep(1, nrow=(yobs)))
ssqOdeModel(p=c(vm=1, km=2), cs1, obstime, yobs, weights=weights)

## downweight 3rd data set (row)
weights[3,] &lt;- 0.1
ssqOdeModel(p=c(vm=1, km=2), cs1, obstime, yobs, weights=weights)

## give one value double weight (e.g. 4th value of S)
weights$S[4] &lt;- 2
ssqOdeModel(p=c(vm=1, km=2), cs1, obstime, yobs, weights=weights)

</code></pre>

<hr>
<h2 id='upca'>The Uniform Period Chaotic Amplitude Model</h2><span id='topic+upca'></span>

<h3>Description</h3>

<p><span class="pkg">simecol</span> example: resource-predator-prey model, which is able to exhibit
chaotic behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(upca)
</code></pre>


<h3>Format</h3>

<p>S4 object according to the <code><a href="#topic+odeModel">odeModel</a></code> specification.
The object contains the following slots:
</p>

<dl>
<dt><code>main</code></dt><dd><p>The differential equations for predator
prey and resource with:</p>
</dd>
</dl>

<dl>
<dt><code>u</code></dt><dd><p>resource (e.g. grassland or phosphorus),</p>
</dd>
<dt><code>v</code></dt><dd><p>producer (prey),</p>
</dd>
<dt><code>w</code></dt><dd><p>consumer (predator).</p>
</dd>
</dl>

<dl>
<dt><code>equations</code></dt><dd><p>Two alternative (and switchable) equations
for the functional response.</p>
</dd>
<dt><code>parms</code></dt><dd><p>Vector with the named parameters of the model,
see references for details.</p>
</dd>
<dt><code>times</code></dt><dd><p>Simulation time and integration interval.</p>
</dd>
<dt><code>init</code></dt><dd><p>Vector with start values for <code>u</code>, <code>v</code> and <code>w</code>.</p>
</dd>
<dt><code>solver</code></dt><dd><p>Character string with the integration method.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To see all details, please have a look into the implementation below and the
original publications.
</p>


<h3>References</h3>

<p>Blasius, B., Huppert, A., and Stone, L. (1999) Complex dynamics and
phase synchronization in spatially extended ecological systems.
<em>Nature</em>, <b>399</b> 354&ndash;359.
</p>
<p>Blasius, B. and Stone, L. (2000) Chaos and phase synchronization in
ecological systems.  <em>International Journal of Bifurcation and
Chaos</em>, <b>10</b> 2361&ndash;2380.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim">sim</a></code>,
<code><a href="#topic+parms">parms</a></code>,
<code><a href="#topic+init">init</a></code>,
<code><a href="#topic+times">times</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##============================================
## Basic Usage:
##   explore the example
##============================================
data(upca)
plot(sim(upca))

# omit stabilizing parameter wstar
parms(upca)["wstar"] &lt;- 0
plot(sim(upca))

# change functional response from
# Holling II (default) to Lotka-Volterra
equations(upca)$f &lt;- function(x, y, k) x * y
plot(sim(upca))

##============================================
## Implementation:
##   The code of the UPCA model
##============================================
upca &lt;- new("odeModel",
  main = function(time, init, parms) {
    u      &lt;- init[1]
    v      &lt;- init[2]
    w      &lt;- init[3]
    with(as.list(parms), {
      du &lt;-  a * u           - alpha1 * f(u, v, k1)
      dv &lt;- -b * v           + alpha1 * f(u, v, k1) +
                             - alpha2 * f(v, w, k2)
      dw &lt;- -c * (w - wstar) + alpha2 * f(v, w, k2)
      list(c(du, dv, dw))
    })
  },
  equations  = list(
    f1 = function(x, y, k){x*y},           # Lotka-Volterra
    f2 = function(x, y, k){x*y / (1+k*x)}  # Holling II
  ),
  times  = c(from=0, to=100, by=0.1),
  parms  = c(a=1, b=1, c=10, alpha1=0.2, alpha2=1,
    k1=0.05, k2=0, wstar=0.006),
  init = c(u=10, v=5, w=0.1),
  solver = "lsoda"
)

equations(upca)$f &lt;- equations(upca)$f2

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
