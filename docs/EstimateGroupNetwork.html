<!DOCTYPE html><html lang="en"><head><title>Help for package EstimateGroupNetwork</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EstimateGroupNetwork}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BootTable'>
<p>Summary table for a bootstrapped Joint Graphical Lasso model</p></a></li>
<li><a href='#covNoBessel'>
<p>Covariance matrix without Bessel's correction</p></a></li>
<li><a href='#EstimateGroupNetwork'>
<p>Estimate Joint Graphical Lasso model on data collected on observations from different groups.</p></a></li>
<li><a href='#GroupBootPlot'>
<p>Create a plot of bootstrapped confidence intervals for all edges of a Joint Graphical Lasso model.</p></a></li>
<li><a href='#GroupNetworkBoot'>
<p>Compute bootstrap networks for a Joint Graphical Lasso model on data collected on observations from different groups.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Perform the Joint Graphical Lasso and Selects Tuning Parameters</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Giulio Costantini, Nils Kappelmann, Sacha Epskamp</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giulio Costantini &lt;giulio.costantini@unimib.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Can be used to simultaneously estimate networks (Gaussian Graphical Models) in data from different groups or classes via Joint Graphical Lasso. Tuning parameters are selected via information criteria (AIC / BIC / extended BIC) or cross validation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, igraph, qgraph, dplyr, ggplot2, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, JGL, psych</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-10 07:11:38 UTC; nkapp</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-10 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BootTable'>
Summary table for a bootstrapped Joint Graphical Lasso model 
</h2><span id='topic+BootTable'></span>

<h3>Description</h3>

<p>Create a table of bootstrapped means and confidence intervals for all edges of a bootstrapped Joint Graphical Lasso model obtained through <a href="#topic+GroupNetworkBoot">GroupNetworkBoot</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootTable(BootOut)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootTable_+3A_bootout">BootOut</code></td>
<td>

<p>The output from <a href="#topic+GroupNetworkBoot">GroupNetworkBoot</a>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summary table of the output of <a href="#topic+GroupNetworkBoot">GroupNetworkBoot</a>
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Var1</code></td>
<td>
<p>Nodes included in each edge</p>
</td></tr>
<tr><td><code>Var2</code></td>
<td>
<p>Nodes included in each edge</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>Edge identifier</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>sample value of each edge</p>
</td></tr>
<tr><td><code>boot.mean</code></td>
<td>
<p>mean of boostrapped values of each edge</p>
</td></tr>
<tr><td><code>ci.lb</code></td>
<td>
<p>lower bound of the .95 confidence interval</p>
</td></tr>
<tr><td><code>ci.ub</code></td>
<td>
<p>upper bound of the .95 confidence interval</p>
</td></tr>
<tr><td><code>boot.zero</code></td>
<td>

<p>proportion of bootstraps, in which an edge was estimated as equal to zero (i.e., 0= edge not estimated as zero throughout bootstraps; 1= edge estimated as zero in all bootstraps)
</p>
</td></tr>
<tr><td><code>boot.pos</code></td>
<td>
<p>Proportion of bootstraps in which an edge was estimated as &gt;0 (i.e., positive)</p>
</td></tr>
<tr><td><code>boot.neg</code></td>
<td>
<p>Proportion of bootstraps in which an edge was estimated as &lt;0 (i.e., negative)</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>group in which the edge was estimated</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nils Kappelmann &lt;n.kappelmann@gmail.com&gt;, Giulio Costantini
</p>


<h3>References</h3>

<p>Epskamp, S., Borsboom, D., &amp; Fried, E. I. (2018). Estimating psychological networks and their accuracy: A tutorial paper. Behavior Research Methods, 50(1), 195–212. https://doi.org/10.3758/s13428-017-0862-1
Danaher, P., Wang, P., &amp; Witten, D. M. (2014). The joint graphical lasso for inverse covariance estimation across multiple classes. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 76(2), 373–397. https://doi.org/10.1111/rssb.12033
</p>


<h3>See Also</h3>

<p><span class="pkg">JGL</span>, <span class="pkg">qgraph</span>, <span class="pkg">parcor</span>
</p>

<hr>
<h2 id='covNoBessel'>
Covariance matrix without Bessel's correction
</h2><span id='topic+covNoBessel'></span>

<h3>Description</h3>

<p>Computes the Covariance matrix without Bessel's correction, for consistency with package <span class="pkg">JGL</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covNoBessel(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covNoBessel_+3A_x">x</code></td>
<td>

<p>A dataframe of numeric values.
</p>
</td></tr>
<tr><td><code id="covNoBessel_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to <a href="stats.html#topic+cov">cov</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix
</p>


<h3>Author(s)</h3>

<p>Giulio Costantini
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(psych)
data(bfi)
covNoBessel(bfi, use = "complete.obs")
</code></pre>

<hr>
<h2 id='EstimateGroupNetwork'>
Estimate Joint Graphical Lasso model on data collected on observations from different groups.
</h2><span id='topic+EstimateGroupNetwork'></span>

<h3>Description</h3>

<p>The Joint Graphical lasso fits gaussian graphical models on data with the same variables observed on different groups or classes of interest (e.g., patients vs. controls; Danaher et al., 2014). The Joint Graphical Lasso relies on two tuning parameters, lambda1 and lambda2: This function performs tuning parameters selection relying on an information criterion (AIC / BIC / extended BIC) or k-fold cross validation and then fits the Joint Graphical Lasso model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateGroupNetwork(X,inputType = c("dataframe", "list.of.dataframes",
"list.of.covariance.matrices"),
                     n, covfun = covNoBessel, groupID, labels,
                     method = c("InformationCriterion", "crossvalidation"),
                     strategy = c("sequential", "simultaneous"),
                     nlambda1 = 100, lambda1.min.ratio = .01, logseql1 = TRUE,
                     nlambda2 = 100, lambda2.min.ratio = .01, logseql2 = TRUE,
                     k = 10, seed,
                     criterion = c("ebic", "bic", "aic"), count.unique = FALSE,
                     gamma = .5, dec = 5,
                     optimize = TRUE, optmethod = "CG",
                     penalty = c("fused", "group"), weights = c("equal", "sample.size"),
                     penalize.diagonal = FALSE, maxiter = 500, rho = 1, truncate = 1e-5,
                     ncores = 1, simplifyOutput = TRUE)
</code></pre>


<h3>Arguments</h3>

<p><b>Agruments describing input data</b>
</p>
<table role = "presentation">
<tr><td><code id="EstimateGroupNetwork_+3A_x">X</code></td>
<td>
<p>Can be one of the following.
</p>
<p>- A single dataframe including data from all groups, plus a group ID variable which must be specified as <code>groupID</code>.
</p>
<p>- A list of dataframes, one by group. Each dataframe must be structured in the same way (the same variables for each group).
</p>
<p>- A list of covariance or correlation matrices. Each matrix must be structured in the same way (the same variables for each group). For this type of input, a vector of sample sizes must be given in <code>n</code>.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_inputtype">inputType</code></td>
<td>

<p>The type of data in input. If missing, the function will attempt to guess the type of input data. Can be one of the following:
</p>
<p>- <code>"dataframe"</code>: A single dataframe including data from all groups, plus a group ID variable which must be specified as <code>groupID</code>.
</p>
<p>- <code>"list.of.dataframes"</code>: A list of dataframes, one by group.
</p>
<p>- <code>"list.of.covariance.matrices"</code>: A list of covariance or correlation matrices plus a vector of sample sizes <code>n</code>.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_n">n</code></td>
<td>
<p>Integer. Vector of sample sizes, one by group, in the same order in which the groups are included in the list of covariance matrices. This argument is relevant only if <code>inputType</code> is &quot;list.of.covariance.matrices&quot; and will be ignored otherwise (with a warning).
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_covfun">covfun</code></td>
<td>
<p>The function used for computing the sample covariance matrix. The default, <a href="#topic+covNoBessel">covNoBessel</a>, computes the covariance matrix without Bessel's correction, for consistency with package <span class="pkg">JGL</span>.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_groupid">groupID</code></td>
<td>
<p>a string. The name or number of the variable in the dataframe indicating a variable that identifies different groups. This argument is relevant only if <code>inputType</code> is &quot;dataframe&quot; and will be ignored otherwise.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_labels">labels</code></td>
<td>
<p>Optional vector of strings. Name of each variable, in the same order in which they are included in the dataframe. If missing, column names will be used. If no column names are present, the variables will be simply named &quot;V1&quot;, &quot;V2&quot;, and so on.
</p>
</td></tr>
</table>
<p><b>Arguments connected to tuning parameter selection</b>
</p>
<table role = "presentation">
<tr><td><code id="EstimateGroupNetwork_+3A_method">method</code></td>
<td>
<p>Methods for selecting tuning parameters. Can be one of the following:
</p>
<p>- &quot;InformationCriterion&quot;. Tuning parameters lambda 1 and lambda 2 are selected according to an information criterion. Argument <code>criterion</code> determines which information criterion is used. If the extended Bayes Information Criterion is used (see Foygel and Drton, 2010), the gamma parameter can be regulated through argument <code>gamma</code>. Argument <code>strategy</code> determines whether tuning parameter selection is performed simultaneously for lambda1 and lambda2, or separately for lambda 1 and lambda 2.
</p>
<p>- &quot;crossvalidation&quot;. Tuning parameters lambda 1 and lambda 2 are selected via k-fold crossvalidation. The cost function for the k-fold crossvalidation procedure is the average predictive negative loglikelihood, as defined in Guo et al. (2011, p.5). Parameter <code>k</code> regulates the number of sample splits for the crossvalidations (defaults to 10 splits), whereas parameter <code>seed</code> can be selected to ensure exact reproducibility of the results. Argument <code>strategy</code> determines whether crossvaliaditon is performed simultaneously for lambda1 and lambda2, or separately for lambda 1 and lambda 2.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_strategy">strategy</code></td>
<td>
<p>The strategy adopted for selecting tuning parameters. Can be one of the following:
</p>
<p>- <code>"sequential"</code>: Tuning parameter selection is performed by first determining lambda 1 and then selecting lambda 2. This option is faster, but can return less accurate results than the next option.
</p>
<p>- <code>"simultaneous"</code>: Tuning parameter selection is performed simultaneously for lambda 1 and lambda2. This option returns more accurate results, but it is also more computationally intensive and therefore slower.</p>
</td></tr>
</table>
<p><b>General arguments that influence tuning parameter selection for all methods</b>
</p>
<table role = "presentation">
<tr><td><code id="EstimateGroupNetwork_+3A_nlambda1">nlambda1</code></td>
<td>
<p>Integer. Number of candidate lambda 1 values. The candidate lambda 1 values will be spaced between the maximum value of lambda 1 (the one that results in at least one network being completely empty) and a minimum value, given by the maximum  multiplied by lambda1.min.ratio</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_lambda1.min.ratio">lambda1.min.ratio</code></td>
<td>
<p>Numeric. Ratio of lowest lambda 1 value compared to maximal lambda 1</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_logseql1">logseql1</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the candidate lambda 1 values are equally spaced between a minimum and a maximum value; if <code>TRUE</code> the values are logarithmically spaced.</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_nlambda2">nlambda2</code></td>
<td>
<p>Integer. Number of candidate lambda 2 values. The candidate lambda 2 values will be spaced between the maximum value of lambda 2 (the one that results in all groups having the same network) and a minimum value, given by the maximum  multiplied by lambda1.min.ratio</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_lambda2.min.ratio">lambda2.min.ratio</code></td>
<td>
<p>Numeric. Ratio of lowest lambda 2 value compared to maximal lambda 2</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_logseql2">logseql2</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the candidate lambda 2 values are equally spaced between a minimum and a maximum value; if <code>TRUE</code> the values are logarithmically spaced.
</p>
</td></tr>
</table>
<p><em>Parameters for crossvalidation. The following arguments will be ignored if argument <code>method</code> is not <code>"crossvalidation"</code>.</em>
</p>
<table role = "presentation">
<tr><td><code id="EstimateGroupNetwork_+3A_k">k</code></td>
<td>
<p>Integer. Number of splits for the k-fold cross-validation procedure.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_seed">seed</code></td>
<td>
<p>Integer. A seed for the random number generator, to include the exact reproducibility of the results obtained with the k-fold crossvalidation procedure.
</p>
</td></tr>
</table>
<p><em>Parameters for selecting tuning parameters via an information criterion. The following arguments will be ignored if argument <code>method</code> is not <code>"InformationCriterion"</code>.</em>
</p>
<table role = "presentation">
<tr><td><code id="EstimateGroupNetwork_+3A_criterion">criterion</code></td>
<td>

<p>The Information criterion used for tuning parameter selection. Can be <code>"aic"</code>, <code>"bic"</code> and <code>"ebic"</code> for Akaike information Criterion (Akaike, 1974), Bayes Information Criterion (Schwarz, 1978), and Extended Bayes Information Criterion (Foygel and Drton, 2010) respectively.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_count.unique">count.unique</code></td>
<td>
<p>Logical.
Information criteria such as AIC, BIC and extended BIC include the number of model parameters in their formula. In Danaher et al (2014) an extension of the AIC is proposed in which each network edge is counted as a single parameter each time is different from zero in each group (up to a tolerance level, by default tol = 10^5, see parameter <code>truncate</code>). Therefore, even if the value of an edge is identical in two groups, it will be counted as two parameters. This option is implemented by selecting <code>count.unique = FALSE</code>. Here we implement an alternative possibility, which can be selected by setting argument <code>count.unique = TRUE</code>: If an edge is identical in two (or more) groups (up to a tolerance leve, see parameter <code>dec</code>), it will be counted as a single parameter.</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_gamma">gamma</code></td>
<td>
<p>Numeric. Parameter gamma for the extended Bayes Information Criterion (see Foygel and Drton, 2010).
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_dec">dec</code></td>
<td>
<p>Integer. This is only relevant if <code>count.unique = TRUE</code>. Edges that are equal across groups up to the <code>dec</code> decimal place will be considered as one parameter in the information criteria.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_optimize">optimize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, after identifying the best tuning parameters (i.e., associated with the lowest value of an Information Criterion) among the candidate values, use an optimizer to try to further reduce the value of the information criterion. Since this is not a convex optimization problem, there is no guarantee that this step will lead to better results. However, it cannot do any harm either (if the optimization stage does not lead to improvements, the best value among the candidates will be returned). Be advised that setting this argument to <code>TRUE</code> results in longer computational time.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_optmethod">optmethod</code></td>
<td>

<p>If argument <code>Strategy</code> is set to <code>"simultaneous"</code> and argument <code>optimize = TRUE</code>, the optimization stage will consider simultaneous tuning parameters simultanously. Therefore, function <a href="stats.html#topic+optim">optim</a> will be used for the optimization stage. Argument <code>optmethod</code> can be used to set the optimization method. See parameter <code>method</code> in function <a href="stats.html#topic+optim">optim</a>.
</p>
</td></tr>
</table>
<p><b>Arguments that influence the Joint Graphical Lasso procedure. See also <span class="pkg">JGL</span></b>
</p>
<table role = "presentation">
<tr><td><code id="EstimateGroupNetwork_+3A_penalty">penalty</code></td>
<td>
<p>Can be one of <code>"fused"</code> for Fused Graphical Lasso and <code>"group"</code> for Group Grahical Lasso. Fused is suggested. See Danaher et al. (2014) for details.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_weights">weights</code></td>
<td>
<p>If <code>"equal"</code> all groups are equally weighted, if <code>"sample.size"</code> groups are weighted according to sample size.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_penalize.diagonal">penalize.diagonal</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the lambda 1 penalty is applied also the diagonal elements of the concentration matrix, otherwise the lambda 1 penalty is applied only to the off-diagonal elements. Notice that the lambda 2 penalty is always applied also to the diagonal elements.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer. Maximum number of iterations for the Joint Graphical Lasso procedure.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_rho">rho</code></td>
<td>
<p>Numeric. A step size parameter for the Joint Graphical Lasso procedure. Large values decrease step size.
</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_truncate">truncate</code></td>
<td>
<p>Numeric. At convergence, all values of theta below this number will be
set to zero.
</p>
</td></tr>
</table>
<p><b>Miscellaneous</b>
</p>
<table role = "presentation">
<tr><td><code id="EstimateGroupNetwork_+3A_ncores">ncores</code></td>
<td>
<p>Numeric. Number of cores to use if working on a multicore system. <code>ncores = 1</code> implies no parallel processing</p>
</td></tr>
<tr><td><code id="EstimateGroupNetwork_+3A_simplifyoutput">simplifyOutput</code></td>
<td>
<p>Logical. If <code>TRUE</code>, only the estimated network will be returned. If <code>FALSE</code>, a much richer output will be returned. See section value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code for the Joint Graphical Lasso procedure was adapted from the R package <span class="pkg">JGL</span>. Some of the code for the cross-validation procedure was adapted from package <span class="pkg">parcor</span>. Some of the code was inspired by package <span class="pkg">qgraph</span>.
</p>


<h3>Value</h3>

<p>If <code>simplifyOutput = TRUE</code>, a list corresponding to the networks estimated in each group is returned.
If <code>simplifyOutput = FALSE</code>, a list is returned that includes including
</p>
<table role = "presentation">
<tr><td><code>network</code></td>
<td>
<p>A list of matrices, each including the standardized partial correlation network for each group</p>
</td></tr>
<tr><td><code>concentrationMatrix</code></td>
<td>
<p>A list of matrices, each including the unstandardized concentration matrix for each group</p>
</td></tr>
<tr><td><code>correlationMatrix</code></td>
<td>
<p>A list of matrices, each including the correlation matrix for each group</p>
</td></tr>
<tr><td><code>InformationCriteria</code></td>
<td>
<p>A vector including he information criteria AIC, BIC and extended BIC (eBIC), plus additional parameters that were used for their computation: the gamma value for eBIC and the values of parameters dec and count.unique</p>
</td></tr>
<tr><td><code>Miscellaneous</code></td>
<td>
<p>A vector including several input parameters that could be important for replicating the results of the analysis</p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Giulio Costantini, Sacha Epskamp
</p>


<h3>References</h3>

<p>Akaike, H. (1974), &quot;A new look at the statistical model identification&quot;, IEEE Transactions on Automatic Control, 19 (6): 716-723, doi:10.1109/TAC.1974.1100705
</p>
<p>Danaher, P (2013). JGL: Performs the Joint Graphical Lasso for sparse inverse covariance estimation on multiple classes. R package version 2.3. https://CRAN.R-project.org/package=JGL
</p>
<p>Danaher, P., Wang, P., and Witten, D. M. (2014). The joint graphical lasso for inverse covariance estimation across multiple classes. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 76(2), 373-397. http://doi.org/10.1111/rssb.12033
</p>
<p>Foygel, R., &amp; Drton, M. (2010). Extended Bayesian Information Criteria for Gaussian Graphical Models. In NIPS (pp. 604-612). Chicago
</p>
<p>Guo, J., Levina, E., Michailidis, G., &amp; Zhu, J. (2011). Joint estimation of multiple graphical models. Biometrika, 98(1), 1-15. http://doi.org/10.1093/biomet/asq060
</p>
<p>Schwarz, G. (1978). &quot;Estimating the dimension of a model.&quot; The annals of statistics 6.2: 461-464.
</p>


<h3>See Also</h3>

<p><span class="pkg">JGL</span>, <span class="pkg">qgraph</span>, <span class="pkg">parcor</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Toy example, two identical networks with two nodes.
# This example is only meant to test the package. The number
# of candidate lambda1 and lambda2 values (nlambda1 and nlambda2) was
# reduced to 2 to speed up computations for CRAN checking.
Sigma &lt;- list()
Sigma[[1]] &lt;- Sigma[[2]] &lt;- matrix(c(1, .5,
                                     .5, 1), nrow = 2)
recovered &lt;- EstimateGroupNetwork(X = Sigma, n = c(100, 100),
                                  nlambda1 = 2, nlambda2 = 2, optimize = FALSE)


library("qgraph")
library("parallel")
library("psych")
library("mvtnorm")

ncores &lt;- 1
# uncomment for parallel processing
# ncores &lt;- detectCores() -1

# In this example, the BFI network of males and females are compared
# Load BFI data
data(bfi)

# remove observations with missing values
bfi2 &lt;- bfi[rowSums(is.na(bfi[,1:26])) == 0,]

# Compute correlations:
CorMales &lt;- cor_auto(bfi2[bfi2$gender == 1,1:25])
CorFemales &lt;- cor_auto(bfi2[bfi2$gender == 2,1:25])

# Estimate JGL:
Res &lt;- EstimateGroupNetwork(list(males = CorMales, females = CorFemales),
                            n = c(sum(bfi2$gender == 1),sum(bfi2$gender == 2)))

# Plot:
Layout &lt;- averageLayout(Res$males,Res$females)
layout(t(1:2))
qgraph(Res$males, layout = Layout, title = "Males (JGL)")
qgraph(Res$females, layout = Layout, title = "Females (JGL)")



# Example with simluated data
# generate three network structures, two are identical and one is different
nets &lt;- list()
nets[[1]] &lt;- matrix(c(0, .3, 0, .3,
                      .3, 0, -.3, 0,
                      0, -.3, 0, .2,
                      .3, 0, .2, 0), nrow = 4)

nets[[2]] &lt;- matrix(c(0, .3, 0, .3,
                      .3, 0, -.3, 0,
                      0, -.3, 0, .2,
                      .3, 0, .2, 0), nrow = 4)

nets[[3]] &lt;- matrix(c(0, .3, 0, 0,
                      .3, 0, -.3, 0,
                      0, -.3, 0, .2,
                      0, 0, .2, 0), nrow = 4)

# optional: plot the original netwotk structures
par(mfcol = c(3, 1))
lapply(nets, qgraph, edge.labels = TRUE)

# generate nobs = 500 observations from each of the three networks
nobs &lt;- 500
nvar &lt;- ncol(nets[[1]])
set.seed(1)
X &lt;- lapply(nets, function(x) as.data.frame(rmvnorm(nobs, sigma = cov2cor(solve(diag(nvar)-x)))))

# use EstimateGroupNetwork for recovering the original structures
recnets &lt;- list()

# using EBICglasso
recnets$glasso &lt;- list()
recnets$glasso[[1]] &lt;- EBICglasso(S = cor(X[[1]]), n = nobs)
recnets$glasso[[2]] &lt;- EBICglasso(S = cor(X[[2]]), n = nobs)
recnets$glasso[[3]] &lt;- EBICglasso(S = cor(X[[3]]), n = nobs)

# Using Akaike information criterion without count.unique option
recnets$AIC1 &lt;- EstimateGroupNetwork(X = X, method = "InformationCriterion",
criterion = "aic", ncores = ncores)
# Using Akaike information criterion with count.unique option
recnets$AIC2 &lt;- EstimateGroupNetwork(X = X, method = "InformationCriterion",
criterion = "aic", ncores = ncores, count.unique = TRUE)
# Using Bayes information criterion without count.unique option
recnets$BIC1 &lt;- EstimateGroupNetwork(X = X, method = "InformationCriterion",
criterion = "bic", ncores = ncores)
# Using Bayes information criterion with count.unique option
recnets$BIC2 &lt;- EstimateGroupNetwork(X = X, method = "InformationCriterion",
criterion = "bic", ncores = ncores, count.unique = TRUE)
# Using extended Bayes information criterion (gamma = .5 by default)
# without count.unique option
recnets$eBIC1 &lt;- EstimateGroupNetwork(X = X, method = "InformationCriterion",
ncores = ncores, criterion = "ebic")
# Using extended Bayes information criterion (gamma = .5 by default) with
# count.unique option
recnets$eBIC2 &lt;- EstimateGroupNetwork(X = X, method = "InformationCriterion",
ncores = ncores, criterion = "ebic", count.unique = TRUE)
# Use a more computationally intensive search strategy
recnets$eBIC3 &lt;- EstimateGroupNetwork(X = X, method = "InformationCriterion",
ncores = ncores, criterion = "ebic", count.unique = TRUE, strategy = "simultaneous")
# Add also the "optimization" stage, which may or may not improve the results
# (but cannot do any harm either)
recnets$eBIC3 &lt;- EstimateGroupNetwork(X = X, method = "InformationCriterion",
ncores = ncores, criterion = "ebic", count.unique = TRUE, strategy = "simultaneous",
optimize = TRUE)
# Using k-fold crossvalidation (k = 10 by default)
recnets$cv &lt;- EstimateGroupNetwork(X = X, method = "crossvalidation",
ncores = ncores, seed = 1)

# Compare each network with the data generating network using correlations
correl &lt;- data.frame(matrix(nrow = length(recnets), ncol = length(nets)))
row.names(correl) &lt;- names(recnets)

for(i in seq_along(recnets))
{
  for(j in seq_along(nets))
      {
    nt1 &lt;- nets[[j]]
    nt2 &lt;- recnets[[i]][[j]]
    correl[i, j] &lt;-  cor(nt1[lower.tri(nt1)], nt2[lower.tri(nt2)])
  }
}
correl

# sort the methods in order of performance in recovering the original network
# notice that this is not a complete simulation and is not indicative of performance
# in settings other than this one
sort(rowMeans(correl))


## End(Not run)
</code></pre>

<hr>
<h2 id='GroupBootPlot'>
Create a plot of bootstrapped confidence intervals for all edges of a Joint Graphical Lasso model.
</h2><span id='topic+GroupBootPlot'></span>

<h3>Description</h3>

<p>This function plots output from bootstrapped networks computed with <a href="#topic+GroupNetworkBoot">GroupNetworkBoot</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupBootPlot(BootOut, GroupNames, edges.x, edges.y, 
labels = TRUE, transparency = 0.15, point.size = 1.5, line.size = 1, scales = "fixed", 
legend.position = "none", GroupNamesCheck = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroupBootPlot_+3A_bootout">BootOut</code></td>
<td>
<p>The output from <a href="#topic+GroupNetworkBoot">GroupNetworkBoot</a>.
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_groupnames">GroupNames</code></td>
<td>

<p>A vector of optional group names that will be printed as facet labels in plot. By default, names of the networks are taken. If specified, GroupNames should match the alphabetical order of names of network groups. If unsure, you can check the matching of names by setting <code>GroupNamesCheck = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_edges.x">edges.x</code></td>
<td>

<p>If only a subset of edge combinations is of interest for the plot, this subset can be specified by setting <code>edges.x</code> and <code>edges.y</code>. Specifically, node names can be specified as vectors for <code>edges.x</code> and <code>edges.y</code> and all unique combinations of <code>edges.x</code> and <code>edges.y</code> will be plotted. For example, <code>edges.x = c("a", "b")</code> and <code>edges.y = "c"</code> will plot edges a-c and b-c but not a-b.
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_edges.y">edges.y</code></td>
<td>

<p>See <code>edges.x</code>.
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_labels">labels</code></td>
<td>

<p>Logical, should edge labels be included in plots. Default is <code>labels = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_transparency">transparency</code></td>
<td>

<p>Set <span class="pkg">ggplot2</span> alpha channel (transparency) for confidence interval ribbon in plot.
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_point.size">point.size</code></td>
<td>

<p>Set point size. 
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_line.size">line.size</code></td>
<td>

<p>Set line size. 
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_scales">scales</code></td>
<td>

<p>Set <span class="pkg">ggplot2</span> facet scales. Default is <code>scale = "fixed"</code>. See ?facet_grid in ggplot2 for details.
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_legend.position">legend.position</code></td>
<td>

<p>Define legend position to indicate colour for sample and bootstrap means. See ?theme in ggplot2.
</p>
</td></tr>
<tr><td><code id="GroupBootPlot_+3A_groupnamescheck">GroupNamesCheck</code></td>
<td>

<p>Option to print match of indicated GroupNames to console. Only prints if GroupNames is specified. See <code>GroupNames</code> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code for the Joint Graphical Lasso procedure was adapted from the R package <span class="pkg">JGL</span>. Some of the code for the cross-validation procedure was adapted from package <span class="pkg">parcor</span>. Some of the code was inspired by package <span class="pkg">qgraph</span>.
GroupBootPlot automatically calls <a href="#topic+BootTable">BootTable</a> to format <a href="#topic+GroupNetworkBoot">GroupNetworkBoot</a> output, so see <a href="#topic+BootTable">BootTable</a> for completely independent plotting. 
</p>


<h3>Value</h3>

<p>The output of GroupBootPlot returns a plot based on <span class="pkg">ggplot2</span> with the bootstrapped confidence intervals of edges across groups.
</p>


<h3>Author(s)</h3>

<p>Nils Kappelmann &lt;n.kappelmann@gmail.com&gt;, Giulio Costantini
</p>


<h3>References</h3>

<p>Danaher, P., Wang, P., and Witten, D. M. (2014). The joint graphical lasso for inverse covariance estimation across multiple classes. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 76(2), 373-397. http://doi.org/10.1111/rssb.12033
</p>


<h3>See Also</h3>

<p><span class="pkg">JGL</span>, <span class="pkg">qgraph</span>, <span class="pkg">parcor</span>
</p>

<hr>
<h2 id='GroupNetworkBoot'>
Compute bootstrap networks for a Joint Graphical Lasso model on data collected on observations from different groups.
</h2><span id='topic+GroupNetworkBoot'></span>

<h3>Description</h3>

<p>This bootstrapping function resamples from intial dataframes to compute bootstrapping intervals for edges estimated using EstimateGroupNetwork.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>                     
GroupNetworkBoot(data_list, groupNetwork, nboots = 100, bootSeed, ...)                  
                     
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroupNetworkBoot_+3A_data_list">data_list</code></td>
<td>
<p>A list of dataframes, one by group. Each dataframe must be structured in the same way (the same variables for each group). This needs to be the same input as was used for the original Joint Graphical Lasso network estimated with <code>EstimateGroupNetwork</code>.
</p>
</td></tr>
<tr><td><code id="GroupNetworkBoot_+3A_groupnetwork">groupNetwork</code></td>
<td>

<p>The to-be-bootstrapped network estimated with the <code>EstimateGroupNetwork</code> function. Importantly, the initial Joint Graphical Lasso needs to be estimated with <code>simplifyOutput = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="GroupNetworkBoot_+3A_nboots">nboots</code></td>
<td>

<p>The number of bootstraps to-be-conducted.
</p>
</td></tr>
<tr><td><code id="GroupNetworkBoot_+3A_bootseed">bootSeed</code></td>
<td>

<p>An optional random seed for ensuring replicability of the results.
</p>
</td></tr>
<tr><td><code id="GroupNetworkBoot_+3A_...">...</code></td>
<td>

<p>All further arguments need to be specified as done for the initial computation of the <code>EstimateGroupNetwork</code> function. Here all arguments apply and have the default values of function <code>EstimateGroupNetwork</code>, with the exceptions being the arguments <code>inputType = "list.of.dataframes"</code>, <code>simplifyOutput = FALSE</code>, and  <code>labels</code>, as node labels are taken directly from the original network. These arguments are set by default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some of the code for the cross-validation procedure was adapted from package <span class="pkg">parcor</span>. Some of the code was inspired by package <span class="pkg">qgraph</span>.
</p>


<h3>Value</h3>

<p>The output of GroupNetworkBoot returns a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The original list of dataframes supplied to the function</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>A list including the original output from <code>EstimateGroupNetwork</code></p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>A list of matrices, each including a bootstrapped network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nils Kappelmann &lt;n.kappelmann@gmail.com&gt;, Giulio Costantini
</p>


<h3>References</h3>

<p>Danaher, P (2013). JGL: Performs the Joint Graphical Lasso for sparse inverse covariance estimation on multiple classes. R package version 2.3. https://CRAN.R-project.org/package=JGL
Danaher, P., Wang, P., and Witten, D. M. (2014). The joint graphical lasso for inverse covariance estimation across multiple classes. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 76(2), 373-397. http://doi.org/10.1111/rssb.12033
</p>


<h3>See Also</h3>

<p><span class="pkg">JGL</span>, <span class="pkg">qgraph</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Load packages:
library("psych")
library("EstimateGroupNetwork")

# In this example, the BFI network of males and females are compared for the subset of
# Agreeableness items
# Load BFI data
data(bfi)

## The bfi data is subset to Agreeableness items only for the first 500 individuals to decrease
# computational time
bfi &lt;- bfi[, c(paste("A", 1:5, sep = ""), "gender")]

# remove observations with missing values on items or gender
bfi &lt;- na.omit(bfi)

# Create list split by gender
bfi_list &lt;- list(males = bfi[bfi$gender == 1, 1:5],
                 females = bfi[bfi$gender == 2, 1:5])

# Estimate JGL:
bfi_net &lt;- EstimateGroupNetwork(bfi_list, inputType = "list.of.dataframes", simplifyOutput = FALSE)

# Bootstrap network 10 times (this will take a few minutes)
boot_bfi_net &lt;- GroupNetworkBoot(data_list = bfi_list, groupNetwork = bfi_net, 
                                 nboots = 10, bootSeed = 1234, ncores = 1)

# use BootTable to obtain a table with information for each boostrapped edge
BootTable(boot_bfi_net)

## Use GroupBootPlot to obtain plots as a list with each group plot as one element
GroupBootPlot(boot_bfi_net) 

## Get plot for a subset of edges (here: all edges including A1). Also check Groupnames
GroupBootPlot(boot_bfi_net, edges.x = "A1", edges.y = c("A2", "A3", "A4", "A5"), 
              GroupNames = c("Females", "Males"), GroupNamesCheck = TRUE, legend.position = "top")


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
