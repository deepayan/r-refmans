<!DOCTYPE html><html lang="en"><head><title>Help for package HiveR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HiveR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HiveR-package'><p>2D and 3D Hive Plots for R</p></a></li>
<li><a href='#adj2HPD'><p>Process an Adjacency Graph into a HivePlotData Object</p></a></li>
<li><a href='#animateHive'><p>Animate One or More 3D Hive Plots with a Handy Controller</p></a></li>
<li><a href='#Arroyo'><p>Plant-Pollinator Data Sets in Hive Plot Data Format</p></a></li>
<li><a href='#chkHPD'><p>Verify the Integrity of a Hive Plot Data Object</p></a></li>
<li><a href='#dot2HPD'><p>Process a .dot Graph File into a Hive Plot Data Object</p></a></li>
<li><a href='#drawHiveSpline'><p>Draw a 3D Spline as Part of a 3D Hive Plot</p></a></li>
<li><a href='#edge2HPD'><p>Process an Edge List into a Hive Plot Data Object</p></a></li>
<li><a href='#HEC'><p>A HivePlotData Object of the Hair Eye Color Data Set</p></a></li>
<li><a href='#HidingAnAxis'><p>How to Hide An Axis in a Hive Plot, with Bonus 2 Plots on One Page</p></a></li>
<li><a href='#HivePlotData'><p>Hive Plot Data Objects</p></a></li>
<li><a href='#manipAxis'><p>Modify the Display of Axes and Nodes in a Hive Plot</p></a></li>
<li><a href='#mineHPD'><p>Examine (mine) a Hive Plot Data Object and Extract Information Contained</p>
Within It</a></li>
<li><a href='#plot3dHive'><p>Create (Plot) a 2D or 3D Hive Plot</p></a></li>
<li><a href='#ranHiveData'><p>Generate Random Hive Plot Data</p></a></li>
<li><a href='#rcsr'><p>Compute the Details of a 3D Spline for a Hive Plot Edge</p></a></li>
<li><a href='#sph2cart'><p>Convert Spherical to Cartesian Coordinates</p></a></li>
<li><a href='#sumHPD'><p>Summarize a Hive Plot Data Object and Optionally Run Some Checks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>2D and 3D Hive Plots for R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-17</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates and plots 2D and 3D hive plots. Hive plots are a unique method of displaying networks of many types in which node properties are mapped to axes using meaningful properties rather than being arbitrarily positioned.  The hive plot concept was invented by Martin Krzywinski at the Genome Science Center (www.hiveplot.net/).  Keywords: networks, food webs, linnet, systems biology, bioinformatics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, plyr, jpeg, png, RColorBrewer, utils, stats, rgl, tcltk,
xtable</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bipartite</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bryanhanson/HiveR">https://github.com/bryanhanson/HiveR</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bryanhanson/HiveR/issues">https://github.com/bryanhanson/HiveR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-17 15:57:01 UTC; bryanh</td>
</tr>
<tr>
<td>Author:</td>
<td>Bryan A. Hanson <a href="https://orcid.org/0000-0003-3536-8246"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Vesna Memisevic [ctb],
  Jonathan Chung [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bryan A. Hanson &lt;hanson@depauw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-18 10:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='HiveR-package'>2D and 3D Hive Plots for R</h2><span id='topic+HiveR-package'></span><span id='topic+HiveR'></span>

<h3>Description</h3>

<p>Creates and plots 2D and 3D hive plots. Hive plots are a unique method of
displaying networks of many types in which node properties are mapped to
axes using meaningful properties rather than being arbitrarily positioned.
The hive plot concept was invented by Martin Krzywinski at the Genome
Science Center (www.hiveplot.net/).  Keywords: networks, food webs, linnet,
systems biology, bioinformatics.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University, Greencastle Indiana USA
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bryanhanson/HiveR">https://github.com/bryanhanson/HiveR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bryanhanson/HiveR/issues">https://github.com/bryanhanson/HiveR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adj2HPD'>Process an Adjacency Graph into a HivePlotData Object</h2><span id='topic+adj2HPD'></span>

<h3>Description</h3>

<p>This function will take an adjacency graph and convert it into a basic
<code><a href="#topic+HivePlotData">HivePlotData</a></code> object.  Further manipulation by
<code><a href="#topic+mineHPD">mineHPD</a></code> will almost certainly be required before the data can
be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj2HPD(M = NULL, axis.cols = NULL, type = "2D", desc = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adj2HPD_+3A_m">M</code></td>
<td>
<p>A matrix with named dimensions.  The names should be the node
names.  Should not be symmetric.  If it is, only the lower triangle is used
and a message is given.</p>
</td></tr>
<tr><td><code id="adj2HPD_+3A_axis.cols">axis.cols</code></td>
<td>
<p>A character vector giving the colors desired for the axes.</p>
</td></tr>
<tr><td><code id="adj2HPD_+3A_type">type</code></td>
<td>
<p>One of <code>c("2D", "3D")</code>.  If <code>2D</code>, a
<code>HivePlotData</code> object suitable for use with <code><a href="#topic+plotHive">plotHive</a></code> will
be created and the eventual hive plot will be static and 2D.  If <code>3D</code>,
the <code>HivePlotData</code> object will be suitable for a 3D interactive plot
using <code><a href="#topic+plot3dHive">plot3dHive</a></code>.</p>
</td></tr>
<tr><td><code id="adj2HPD_+3A_desc">desc</code></td>
<td>
<p>Character.  A description of the data set.</p>
</td></tr>
<tr><td><code id="adj2HPD_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed downstream.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a &quot;bare bones&quot; <code>HivePlotData</code> object.  The names
of the dimensions of <code>M</code> are used as the node names.  All nodes are
given size 1, an id number (<code>1:number of nodes</code>), are colored black and
are assigned to axis 1.  The edges are all gray, and the weight is M[i,j].
The user will likely have to manually make some changes to the resulting
<code>HivePlotData</code> object before plotting.  Alternatively,
<code><a href="#topic+mineHPD">mineHPD</a></code> may be able to extract some information buried in the
data, but even then, the user will probably need to make some adjustments.
See the examples.
</p>


<h3>Value</h3>

<p>A <code> <a href="#topic+HivePlotData">HivePlotData</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a> Vesna
Memisevic contributed a fix that limited this function to bipartite networks
(changed in v. 0.2-12).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dot2HPD">dot2HPD</a></code> and <code><a href="#topic+adj2HPD">adj2HPD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1: a bipartite network
### Note: this first example has questionable scientific value!
### The purpose is to show how to troubleshoot and
### manipulate a HivePlotData object.

if (require("bipartite")) {
  data(Safariland, package = "bipartite") # This is a bipartite network

  # You may wish to do ?Safariland or ?Safari for background

  hive1 &lt;- adj2HPD(Safariland, desc = "Safariland data set from bipartite")
  sumHPD(hive1)

  # Note that all nodes are one axis with radius 1. Process further:

  hive2 &lt;- mineHPD(hive1, option = "rad &lt;- tot.edge.count")
  sumHPD(hive2)

  # All nodes still on 1 axis but degree has been used to set radius

  # Process further:

  hive3 &lt;- mineHPD(hive2, option = "axis &lt;- source.man.sink")
  sumHPD(hive3, chk.all = TRUE)

  # Note that mineHPD is generating some warnings, telling us
  # that the first 9 nodes were not assigned to an axis.  Direct
  # inspection of the data shows that these nodes are insects
  # that did not visit any of the flowers in this particular study.

  # Pretty up a few things, then plot:

  hive3$edges$weight &lt;- sqrt(hive3$edges$weight) * 0.5
  hive3$nodes$size &lt;- 0.5
  plotHive(hive3)

  # This is a one-sided hive plot of 2 axes, which results
  # from the curvature of the splines.  We can manually fix
 # this by reversing the ends of edges as follows:

  for (n in seq(1, length(hive3$edges$id1), by = 2)) {
    a &lt;- hive3$edges$id1[n]
    b &lt;- hive3$edges$id2[n]
    hive3$edges$id1[n] &lt;- b
    hive3$edges$id2[n] &lt;- a
  }

  plotHive(hive3)

  ### Example 2, a simple random adjacency matrix
  set.seed(31)
  nr &lt;- 20
  nc &lt;- 15
  M &lt;- matrix(floor(runif(nc * nr, 0, 10)), ncol = nc)
  colnames(M) &lt;- sample(c(letters, LETTERS), nc, replace = FALSE)
  rownames(M) &lt;- sample(c(letters, LETTERS), nr, replace = FALSE)
  hive4 &lt;- adj2HPD(M)
  sumHPD(hive4)
}

</code></pre>

<hr>
<h2 id='animateHive'>Animate One or More 3D Hive Plots with a Handy Controller</h2><span id='topic+animateHive'></span>

<h3>Description</h3>

<p>This function takes a list of <code>HivePlotData</code> objects of <code>type =
"3D"</code> and plots each in its own <code>rgl</code> window using its own arguments,
then adds a controller which handles rotation and scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animateHive(hives = list(), cmds = list(), xy = 400, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="animateHive_+3A_hives">hives</code></td>
<td>
<p>A list of <code>HivePlotData</code> objects.</p>
</td></tr>
<tr><td><code id="animateHive_+3A_cmds">cmds</code></td>
<td>
<p>A list of arguments corresponding to how you want each hive
plotted.</p>
</td></tr>
<tr><td><code id="animateHive_+3A_xy">xy</code></td>
<td>
<p>An integer giving the size of the <code>rgl</code> window in pixels.</p>
</td></tr>
<tr><td><code id="animateHive_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed downstream to <code>rgl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.  Side effect is one or more plots.
</p>


<h3>Warning</h3>

<p>If you click the 'continue rotating' box on the controller
window, be sure to unclick it and wait for the system to halt before closing
any of the windows.  If you close the controller w/o doing this, the
remaining open windows with the hive plots will continue rotating endlessly
and it seems you can't get their attention to close the windows.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require("rgl")
# Sillyness: let's draw different hives with different settings
# List of hives
t4 &lt;- ranHiveData(type = "3D", nx = 4)
t5 &lt;- ranHiveData(type = "3D", nx = 5)
t6 &lt;- ranHiveData(type = "3D", nx = 6)
myhives &lt;- list(t4, t5, t6)
# List of arguments to plot in different coordinate systems
cmd1 &lt;- list(method = "abs", LA = TRUE, dr.nodes = FALSE, ch = 10)
cmd2 &lt;- list(method = "rank", LA = TRUE, dr.nodes = FALSE, ch = 2)
cmd3 &lt;- list(method = "norm", LA = TRUE, dr.nodes = FALSE, ch = 0.1)
mycmds &lt;- list(cmd1, cmd2, cmd3)
#
animateHive(hives = myhives, cmds = mycmds)

## End(Not run)

</code></pre>

<hr>
<h2 id='Arroyo'>Plant-Pollinator Data Sets in Hive Plot Data Format</h2><span id='topic+Arroyo'></span><span id='topic+Safari'></span>

<h3>Description</h3>

<p>Plant-pollinator data sets which were derived ultimately from Vasquez and
Simberloff, 2003.  These are two-trophic level systems that have almost
exactly the same plants and pollinators.  <code>Safari</code> is from an
undisturbed area, while <code>Arroyo</code> is from a nearby location grazed by
cattle.  In the original publication, the data sets are called Safariland
and Arroyo Goye.  See Details for how the original data was converted.
</p>


<h3>Details</h3>

<p>These data sets are <code><a href="#topic+HivePlotData">HivePlotData</a></code> objects.  They were created
from the datasets <code>Safariland</code> and <code>vazarr</code> in the package
<code>bipartite</code>.  The process was the same for each: 1.  Plants were placed
on one axis, pollinators on the other.  2.  A radius was assigned by
calculating d' using function <code>dfun</code> in package <code>bipartite</code>.  d'
is an index of specialization; higher values mean the plant or pollinator is
more specialized.  3.  Edge weights were assigned proportional to the square
root of the normalized number of visits of a pollinator to a plant.  Thus
the width of the edge drawn is an indication of the visitation rate.  4.
The number of visits were divided manually into 4 groups and used to assign
edge colors ranging from white to red.  The redder colors represent greater
numbers of visits, and the color-coding is comparable for each data set.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University, Greencastle Indiana USA
</p>

<hr>
<h2 id='chkHPD'>Verify the Integrity of a Hive Plot Data Object</h2><span id='topic+chkHPD'></span>

<h3>Description</h3>

<p>This function inspects the classes of each part of a <code><a href="#topic+HPD">HPD</a></code> as a
means of verifying its integrity.  A few other characteristics are checked
as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chkHPD(HPD, confirm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chkHPD_+3A_hpd">HPD</code></td>
<td>
<p>An object of S3 class <code>HivePlotData</code>.</p>
</td></tr>
<tr><td><code id="chkHPD_+3A_confirm">confirm</code></td>
<td>
<p>Logical; if <code>TRUE</code> then a favorable result is affirmed
in the console (problems are always reported).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value; <code>TRUE</code> is there is a problem, otherwise
<code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sumHPD">sumHPD</a></code> which allows inspection (checking) of many
properties of your <code><a href="#topic+HPD">HPD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test4 &lt;- ranHiveData(nx = 4)
good &lt;- chkHPD(test4, confirm = TRUE)
# mess it up and do again
# next test is not run as it halts execution
## Not run: 
test4$nodes$color &lt;- as.factor(test4$nodes$color)
bad &lt;- chkHPD(test4)

## End(Not run)

</code></pre>

<hr>
<h2 id='dot2HPD'>Process a .dot Graph File into a Hive Plot Data Object</h2><span id='topic+dot2HPD'></span>

<h3>Description</h3>

<p>This function will read a .dot file containing a graph specification in the
DOT language, and (optionally) using two other files, convert the
information into a <code><a href="#topic+HivePlotData">HivePlotData</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dot2HPD(
  file = NULL,
  node.inst = NULL,
  edge.inst = NULL,
  axis.cols = NULL,
  type = "2D",
  desc = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dot2HPD_+3A_file">file</code></td>
<td>
<p>The path to the .dot file to be processed.</p>
</td></tr>
<tr><td><code id="dot2HPD_+3A_node.inst">node.inst</code></td>
<td>
<p>The path to a .csv file containing instructions about how
to map node tags in the .dot file to parameters in the <code>HivePlotData</code>
object. May be NULL.</p>
</td></tr>
<tr><td><code id="dot2HPD_+3A_edge.inst">edge.inst</code></td>
<td>
<p>The path to a .csv file containing instructions about how
to map edge tags in the .dot file to parameters in the <code>HivePlotData</code>
object.  May be NULL.</p>
</td></tr>
<tr><td><code id="dot2HPD_+3A_axis.cols">axis.cols</code></td>
<td>
<p>A character vector giving the colors desired for the axes.</p>
</td></tr>
<tr><td><code id="dot2HPD_+3A_type">type</code></td>
<td>
<p>One of <code>c("2D", "3D")</code>.  If <code>2D</code>, a
<code>HivePlotData</code> object suitable for use with <code><a href="#topic+plotHive">plotHive</a></code> will
be created and the eventual hive plot will be static and 2D.  If <code>3D</code>,
the <code>HivePlotData</code> object will be suitable for a 3D interactive plot
using <code><a href="#topic+plot3dHive">plot3dHive</a></code>.</p>
</td></tr>
<tr><td><code id="dot2HPD_+3A_desc">desc</code></td>
<td>
<p>Character.  A description of the data set.</p>
</td></tr>
<tr><td><code id="dot2HPD_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed downstream.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is currently agnostic with respect to whether or not the .dot
graph is directed or not.  Either type will be processed, but if the graph
is directed, this will only be indirectly stored in the <code>HivePlotData</code>
object (in that the first node of an edge in the .dot file will be in
<code>HPD$nodes$id1</code> and the second node of an edge will be in
<code>HPD$nodes$id2</code>.  This fact can be used; see the vignette and
<code><a href="#topic+mineHPD">mineHPD</a></code>.  Keep in mind the .dot standard is fairly loose.
This function has been tested to work with several .dot files, include those
with multiple tag=value attributes (in such cases, a typical line in the dot
file should be formatted like this: node_name [tag1 = value1, tag2 =
value2];).  If you have trouble, please file a issue at Github so I can
track it down.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+HivePlotData">HivePlotData</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p>See the vignette for an example of using this function.  Use
<code>browseVignettes("HiveR")</code> to produce the vignette. <br /> <br />
<code><a href="#topic+adj2HPD">adj2HPD</a></code> for a means of importing adjacency matrices.
</p>

<hr>
<h2 id='drawHiveSpline'>Draw a 3D Spline as Part of a 3D Hive Plot</h2><span id='topic+drawHiveSpline'></span>

<h3>Description</h3>

<p>This function analyzes the edges of a <code>HivePlotData</code> object in order to
draw 3D splines representing those edges.  Each pair of nodes at the ends of
an edge is identified, and a control point is computed.  This information is
passed to <code><a href="#topic+rcsr">rcsr</a></code> to work out the details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawHiveSpline(HPD, L_A = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawHiveSpline_+3A_hpd">HPD</code></td>
<td>
<p>An object of S3 class <code>HivePlotData</code>.</p>
</td></tr>
<tr><td><code id="drawHiveSpline_+3A_l_a">L_A</code></td>
<td>
<p>Logical: should splines be drawn with <code>line_antialias =
TRUE</code>?</p>
</td></tr>
<tr><td><code id="drawHiveSpline_+3A_...">...</code></td>
<td>
<p>Parameters to be passed downstream.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.  A spline is added to the 3D hive plot in progress.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3dHive">plot3dHive</a></code> which calls this function and is the user
interface.
</p>

<hr>
<h2 id='edge2HPD'>Process an Edge List into a Hive Plot Data Object</h2><span id='topic+edge2HPD'></span>

<h3>Description</h3>

<p>This function will take an edge list and convert it into a basic
<code><a href="#topic+HivePlotData">HivePlotData</a></code> object.  Further manipulation by
<code><a href="#topic+mineHPD">mineHPD</a></code> will almost certainly be required before the data can
be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge2HPD(edge_df = NULL, axis.cols = NULL, type = "2D", desc = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge2HPD_+3A_edge_df">edge_df</code></td>
<td>
<p>A data frame containing edge list information. Columns should
be node1, node2, edge weight (column names are arbitrary).  Edge weight
information is optional. If missing, edge weights will be set to 1.</p>
</td></tr>
<tr><td><code id="edge2HPD_+3A_axis.cols">axis.cols</code></td>
<td>
<p>A character vector giving the colors desired for the axes.</p>
</td></tr>
<tr><td><code id="edge2HPD_+3A_type">type</code></td>
<td>
<p>One of <code>c("2D", "3D")</code>.  If <code>2D</code>, a
<code>HivePlotData</code> object suitable for use with <code><a href="#topic+plotHive">plotHive</a></code> will
be created and the eventual hive plot will be static and 2D.  If <code>3D</code>,
the <code>HivePlotData</code> object will be suitable for a 3D interactive plot
using <code><a href="#topic+plot3dHive">plot3dHive</a></code>.</p>
</td></tr>
<tr><td><code id="edge2HPD_+3A_desc">desc</code></td>
<td>
<p>Character.  A description of the data set.</p>
</td></tr>
<tr><td><code id="edge2HPD_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed downstream.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a &quot;bare bones&quot; <code>HivePlotData</code> object.  The user
will likely have to make some changes manually to the resulting
<code>HivePlotData</code> object before plotting.  Alternatively,
<code><a href="#topic+mineHPD">mineHPD</a></code> may be able to extract some information buried in the
data, but even then, the user might need to make some adjustments.  See the
examples.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+HivePlotData">HivePlotData</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Jonathan H. Chung, with minor changes for consistency by Bryan A.
Hanson.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dot2HPD">dot2HPD</a></code> and <code><a href="#topic+adj2HPD">adj2HPD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a simple edge list &amp; process it
edges &lt;- data.frame(
  lab1 = LETTERS[c(1:8, 7)],
  lab2 = LETTERS[c(2:4, 1:3, 4, 2, 2)],
  weight = c(1, 1, 2, 2, 3, 1, 2, 3, 1)
)

td &lt;- edge2HPD(edge_df = edges, desc = "Test of edge2HPD")
td.out &lt;- sumHPD(td, plot.list = TRUE)
# compare:
edges
td.out[, c(3, 7, 8)]
</code></pre>

<hr>
<h2 id='HEC'>A HivePlotData Object of the Hair Eye Color Data Set</h2><span id='topic+HEC'></span>

<h3>Description</h3>

<p>This is an <code><a href="#topic+HPD">HPD</a></code> (<code>HivePlotData</code> object) derived from the
built-in hair eye color data set (see <code>?HairEyeColor</code>).  It serves as a
test 2D data set, and the example below shows how it was built.  While every
data set is different and will require a different approach, the example
illustrates the general approach to building a hive plot from scratch,
step-by-step.
</p>


<h3>Format</h3>

<p>The format is described in detail at <code><a href="#topic+HPD">HPD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# An example of building an HPD from scratch

### Step 0.  Get to know your data.

data(HairEyeColor) # see ?HairEyeColor for background
df &lt;- data.frame(HairEyeColor) # str(df) is useful

# Frequencies of the colors can be found with:
eyeF &lt;- aggregate(Freq ~ Eye, data = df, FUN = "sum")
hairF &lt;- aggregate(Freq ~ Hair, data = df, FUN = "sum")
es &lt;- eyeF$Freq / eyeF$Freq[4] # node sizes for eye
hs &lt;- hairF$Freq / hairF$Freq[3] # node sizes for hair

### Step 1. Assemble a data frame of the nodes.

# There are 32 rows in the data frame, but we are going to
# separate the hair color from the eye color and thus
# double the number of rows in the node data frame

nodes &lt;- data.frame(
  id = 1:64,
  lab = paste(rep(c("hair", "eye"), each = 32), 1:64, sep = "_"),
  axis = rep(1:2, each = 32),
  radius = rep(NA, 64)
)

for (n in 1:32) {
  # assign node radius based most common colors
  if (df$Hair[n] == "Black") nodes$radius[n] &lt;- 2
  if (df$Hair[n] == "Brown") nodes$radius[n] &lt;- 4
  if (df$Hair[n] == "Red") nodes$radius[n] &lt;- 1
  if (df$Hair[n] == "Blond") nodes$radius[n] &lt;- 3

  if (df$Eye[n] == "Brown") nodes$radius[n + 32] &lt;- 1
  if (df$Eye[n] == "Blue") nodes$radius[n + 32] &lt;- 2
  if (df$Eye[n] == "Hazel") nodes$radius[n + 32] &lt;- 3
  if (df$Eye[n] == "Green") nodes$radius[n + 32] &lt;- 4

  # now do node sizes
  if (df$Hair[n] == "Black") nodes$size[n] &lt;- hs[1]
  if (df$Hair[n] == "Brown") nodes$size[n] &lt;- hs[2]
  if (df$Hair[n] == "Red") nodes$size[n] &lt;- hs[3]
  if (df$Hair[n] == "Blond") nodes$size[n] &lt;- hs[4]

  if (df$Eye[n] == "Brown") nodes$size[n + 32] &lt;- es[4]
  if (df$Eye[n] == "Blue") nodes$size[n + 32] &lt;- es[3]
  if (df$Eye[n] == "Hazel") nodes$size[n + 32] &lt;- es[2]
  if (df$Eye[n] == "Green") nodes$size[n + 32] &lt;- es[1]
}

nodes$color &lt;- rep("black", 64)
nodes$lab &lt;- as.character(nodes$lab) # clean up some data types
nodes$radius &lt;- as.numeric(nodes$radius)

### Step 2. Assemble a data frame of the edges.

edges &lt;- data.frame( # There will be 32 edges, corresponding to the original 32 rows
  id1 = c(1:16, 49:64), # This will set up edges between each eye/hair pair
  id2 = c(33:48, 17:32), # &amp; put the males above and the females below
  weight = df$Freq,
  color = rep(c("lightblue", "pink"), each = 16)
)

edges$color &lt;- as.character(edges$color)

# Scale the edge weight (det'd by trial &amp; error to emphasize differences)
edges$weight &lt;- 0.25 * log(edges$weight)^2.25

### Step 3. Now assemble the HivePlotData (HPD) object.

HEC &lt;- list()
HEC$nodes &lt;- nodes
HEC$edges &lt;- edges
HEC$type &lt;- "2D"
HEC$desc &lt;- "HairEyeColor data set"
HEC$axis.cols &lt;- c("grey", "grey")
class(HEC) &lt;- "HivePlotData"

### Step 4. Check it &amp; summarize

chkHPD(HEC) # answer of FALSE means there are no problems
sumHPD(HEC)

### Step 5.  Plot it.

# A minimal plot
plotHive(HEC, ch = 0.1, bkgnd = "white")
# See ?plotHive for fancier options
</code></pre>

<hr>
<h2 id='HidingAnAxis'>How to Hide An Axis in a Hive Plot, with Bonus 2 Plots on One Page</h2><span id='topic+HidingAnAxis'></span><span id='topic+TwoPlotsOnePage'></span>

<h3>Description</h3>

<p>From time-to-time is useful to compare several hive plots based on related
data (and you might wish to plot them side-by-side to facilitate
comparison).  Depending the nature of the data set and how it changes under
the experimental design, some data sets may not have any nodes on a
particular axis (and therefore, they don't participate in edges either).
Let's say your system fundamentally has three axes, but in some data sets
one of the axes has no nodes.  When you plot them side-by-side, for visual
comparison it is nice if all the plots, including the one with an empty
axis, have the same general orientation.  In other words, even if the data
only requires two axes, you might want it plotted as if it had three axes
for consistency in overall appearance.
</p>


<h3>Details</h3>

<p>When an axis is present but doesn't have a node on it, this makes
<code>plotHive</code> unhappy, but there is a simple solution.  You simply put a
dummy or phantom node on the empty axis.  This is illustrated in the example
below.  Also demonstrated is a simple <code>grid</code>-based function for putting
more than one plot on a device.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require("grid")

# Adjacency matrix describing the connectivity in 2-butanone
# H's on a single carbon collapsed into a group.
# Matrix entry is bond order.  CH3 is coded so the
# bond order between C &amp; H is 3 (3 single C-H bonds)

dnames &lt;- c("C1", "C2", "C3", "C4", "O", "HC1", "HC3", "HC4")

#                    C1, C2, C3, C4, O, HC1, HC3, HC4
butanone &lt;- matrix(c(
  0, 1, 0, 0, 0, 3, 0, 0, # C1
  1, 0, 1, 0, 2, 0, 0, 0, # C2
  0, 1, 0, 1, 0, 0, 2, 0, # C3
  0, 0, 1, 0, 0, 0, 0, 3, # C4
  0, 2, 0, 0, 0, 0, 0, 0, # O
  3, 0, 0, 0, 0, 0, 0, 0, # HC1
  0, 0, 2, 0, 0, 0, 0, 0, # HC3
  0, 0, 0, 3, 0, 0, 0, 0
), # HC4
ncol = 8, byrow = TRUE,
dimnames = list(dnames, dnames)
)

butanoneHPD &lt;- adj2HPD(
  M = butanone, axis.col = c("black", "gray", "red"),
  desc = "2-butanone"
)

# Fix up the nodes manually (carbon is on axis 1)
butanoneHPD$nodes$axis[5] &lt;- 3L # oxygen on axis 3
butanoneHPD$nodes$axis[6:8] &lt;- 2L # hydrogen on axis 2
butanoneHPD$nodes$color[5] &lt;- "red"
butanoneHPD$nodes$color[6:8] &lt;- "gray"

# Exaggerate the edge weights, which are proportional to the number of bonds
butanoneHPD$edges$weight &lt;- butanoneHPD$edges$weight^2
butanoneHPD$edges$color &lt;- rep("wheat3", 7)

plotHive(butanoneHPD,
  method = "rank", bkgnd = "white",
  axLabs = c("carbon", "hydrogen", "oxygen"),
  axLab.pos = c(1, 1, 1), axLab.gpar =
    gpar(col = c("black", "gray", "red"))
)

# Now repeat the process for butane

dnames &lt;- c("C1", "C2", "C3", "C4", "HC1", "HC2", "HC3", "HC4")

#                  C1, C2, C3, C4, HC1, HC2, HC3, HC4
butane &lt;- matrix(c(
  0, 1, 0, 0, 3, 0, 0, 0, # C1
  1, 0, 1, 0, 0, 2, 0, 0, # C2
  0, 1, 0, 1, 0, 0, 2, 0, # C3
  0, 0, 1, 0, 0, 0, 0, 3, # C4
  3, 0, 0, 0, 0, 0, 0, 0, # HC1
  0, 2, 0, 0, 0, 0, 0, 0, # HC2
  0, 0, 2, 0, 0, 0, 0, 0, # HC3
  0, 0, 0, 3, 0, 0, 0, 0
), # HC4
ncol = 8, byrow = TRUE,
dimnames = list(dnames, dnames)
)

butaneHPD &lt;- adj2HPD(
  M = butane, axis.col = c("black", "gray"),
  desc = "butane"
)
butaneHPD$nodes$axis[5:8] &lt;- 2L # hydrogen on axis 2
butaneHPD$nodes$color[5:8] &lt;- "gray"
butaneHPD$edges$weight &lt;- butaneHPD$edges$weight^2
butaneHPD$edges$color &lt;- rep("wheat3", 7)

plotHive(butaneHPD,
  method = "rank", bkgnd = "white",
  axLabs = c("carbon", "hydrogen"),
  axLab.pos = c(1, 1), axLab.gpar = gpar(col = c("black", "gray"))
)

# butaneHPD has 2 axes.  If we wanted to compare to butanoneHPD effectively
# we should add a third dummy axis where the oxygen axis was in butanone
# You might want to look at str(butaneHPD) before beginning

dummy &lt;- c(9, "dummy", 3, 1.0, 1.0, "white") # mixed data types
# but coerced to character
butaneHPD$nodes &lt;- rbind(butaneHPD$nodes, dummy)
str(butaneHPD$nodes) # The data types are mangled from the rbind!

# Now coerce the data types to the standard of the class, and check it
butaneHPD$nodes$id &lt;- as.integer(butaneHPD$nodes$id)
butaneHPD$nodes$axis &lt;- as.integer(butaneHPD$nodes$axis)
butaneHPD$nodes$radius &lt;- as.numeric(butaneHPD$nodes$radius)
butaneHPD$nodes$size &lt;- as.numeric(butaneHPD$nodes$size)
str(butaneHPD$nodes)

chkHPD(butaneHPD) # OK! (False means there were no problems)
sumHPD(butaneHPD)

# Plot it

plotHive(butaneHPD,
  method = "rank", bkgnd = "white",
  axLabs = c("carbon", "hydrogen", "oxygen"),
  axLab.pos = c(1, 1, 1), axLab.gpar =
    gpar(col = c("black", "gray", "red"))
)

# Put 2 plots side-by-side using a little helper function

vplayout &lt;- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)

# pdf("Demo.pdf", width = 10, height = 5) # Aspect ratio better
# default screen device

grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(vplayout(1, 1)) # left plot

plotHive(butanoneHPD,
  method = "rank", bkgnd = "white",
  axLabs = c("carbon", "hydrogen", "oxygen"),
  axLab.pos = c(1, 1, 1), axLab.gpar =
    gpar(col = c("black", "gray", "red")), np = FALSE
)
grid.text("butanone",
  x = 0.5, y = 0.1, default.units = "npc",
  gp = gpar(fontsize = 14, col = "black")
)

popViewport(2)
pushViewport(vplayout(1, 2)) # right plot
grid.text("test2")

plotHive(butaneHPD,
  method = "rank", bkgnd = "white",
  axLabs = c("carbon", "hydrogen", "oxygen"),
  axLab.pos = c(1, 1, 1), axLab.gpar =
    gpar(col = c("black", "gray", "red")), np = FALSE
)
grid.text("butane",
  x = 0.5, y = 0.1, default.units = "npc",
  gp = gpar(fontsize = 14, col = "black")
)

# dev.off()
</code></pre>

<hr>
<h2 id='HivePlotData'>Hive Plot Data Objects</h2><span id='topic+HivePlotData'></span><span id='topic+HPD'></span>

<h3>Description</h3>

<p>In package <code>HiveR</code>, hive plot data sets are stored as an S3 class
called <code>HivePlotData</code>, detailed below.
</p>


<h3>Structure</h3>

<p>The structure of a <code>HivePlotData</code> object is a list
of 6 elements, some of which are data frames, and an attribute, as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <em>element</em> </td><td style="text-align: left;"> <em>(element)</em> </td><td style="text-align: left;"> <em>type</em> </td><td style="text-align: left;"> <em>description</em></td>
</tr>
<tr>
 <td style="text-align: left;">
  $nodes </td><td style="text-align: left;"> </td><td style="text-align: left;"> data frame </td><td style="text-align: left;"> Data frame of node properties </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $id </td><td style="text-align: left;"> int </td><td style="text-align: left;"> Node identifier </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $lab </td><td style="text-align: left;"> chr </td><td style="text-align: left;"> Node label </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $axis </td><td style="text-align: left;"> int </td><td style="text-align: left;"> Axis to which node is assigned </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $radius </td><td style="text-align: left;"> num </td><td style="text-align: left;"> Radius (position) of node along the axis </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $size </td><td style="text-align: left;"> num </td><td style="text-align: left;"> Node size in pixels </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $color </td><td style="text-align: left;"> chr </td><td style="text-align: left;"> Node color </td>
</tr>
<tr>
 <td style="text-align: left;">
  $edges </td><td style="text-align: left;"> </td><td style="text-align: left;"> data frame </td><td style="text-align: left;"> Data frame of edge properties </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $id1 </td><td style="text-align: left;"> int </td><td style="text-align: left;"> Starting node id </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $id2 </td><td style="text-align: left;"> int </td><td style="text-align: left;"> Ending node id </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $weight </td><td style="text-align: left;"> num </td><td style="text-align: left;"> Width of edge in pixels </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> $color </td><td style="text-align: left;"> chr </td><td style="text-align: left;"> Edge color </td>
</tr>
<tr>
 <td style="text-align: left;">
  $type </td><td style="text-align: left;"> </td><td style="text-align: left;"> chr </td><td style="text-align: left;"> Type of hive. See Note. </td>
</tr>
<tr>
 <td style="text-align: left;">
  $desc </td><td style="text-align: left;"> </td><td style="text-align: left;"> chr </td><td style="text-align: left;"> Description of data </td>
</tr>
<tr>
 <td style="text-align: left;">
  $axis.cols </td><td style="text-align: left;"> </td><td style="text-align: left;"> chr </td><td style="text-align: left;"> Colors for axes </td>
</tr>
<tr>
 <td style="text-align: left;">
  - attr </td><td style="text-align: left;"> </td><td style="text-align: left;"> chr "HivePlotData" </td><td style="text-align: left;"> The S3 class designation.</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Note</h3>

<p>While <code>$edges$id1</code> and <code>$edges$id2</code> are defined as the
starting and ending nodes of a particular edge, hive plots as currently
implemented are not directed graphs (agnostic might be a better word). <br />
<br /> <code>HPD$type</code> indicates the type of hive data: If <code>2D</code>, then the
data is intended to be plotted with <code>hivePlot</code> which is a 2D plot with
axes radially oriented, and (hopefully) no edges that cross axes.  If
<code>3D</code>, then the data is intended to be plotted with <code>plot3dHive</code>
which gives an interactive 3D plot, with axes oriented in 3D.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sumHPD">sumHPD</a></code> to summarize a <code>HivePlotData</code> object.<br />
<code><a href="#topic+chkHPD">chkHPD</a></code> to verify the integrity of a <code>HivePlotData</code>
object.<br /> <code><a href="#topic+ranHiveData">ranHiveData</a></code> to generate random <code>HivePlotData</code>
objects for testing and demonstration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test4 &lt;- ranHiveData(nx = 4)
str(test4)
sumHPD(test4)
plotHive(test4)
</code></pre>

<hr>
<h2 id='manipAxis'>Modify the Display of Axes and Nodes in a Hive Plot</h2><span id='topic+manipAxis'></span>

<h3>Description</h3>

<p>This function modifies various aspects of a <code>HivePlotData</code> object.  A
typical use is to convert the radii from the native/absolute values in the
original object to either a normalized value (0...1) or to a ranked
value.  The order of nodes on an axis can also be inverted, and an axis can
be pruned (removed) from the <code>HivePlotData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manipAxis(HPD, method, action = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manipAxis_+3A_hpd">HPD</code></td>
<td>
<p>An object of S3 class <code>HivePlotData</code>.</p>
</td></tr>
<tr><td><code id="manipAxis_+3A_method">method</code></td>
<td>
<p>One of <code>c("rank", "norm", "scale", "invert", "ranknorm",
"prune", "offset", "stretch")</code> giving the type of modification to be made.</p>
</td></tr>
<tr><td><code id="manipAxis_+3A_action">action</code></td>
<td>
<p>For <code>method = c("scale", "invert", "offset", "stretch")</code>,
a numeric vector of the same length as the number of axes.</p>
</td></tr>
<tr><td><code id="manipAxis_+3A_...">...</code></td>
<td>
<p>Arguments to be passed downstream.  Needed in this case for when
<code>plotHive</code> has arguments for <code>grid</code> that get laundered through
<code>manipAxis</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rank method uses <code>ties.method = "first"</code> so that each node gets a
unique radius.  For pruning, the nodes and edges are removed and then the
remaining axes are renumbered to start from one.  Exercise caution!
</p>
<p>For <code>"scale"</code> node radii will be multiplied by the corresponding value
in this argument.  For <code>"invert"</code> a value of -1 will cause the
corresponding axis to be inverted.  For <code>"prune"</code>, a single value
specifying the axis to be pruned should be given.  For <code>"offset"</code> the
values in <code>"action"</code> will be subtracted from the node radii.  For
<code>"stretch"</code>, node radii will first be offset so that the minimum value
is zero, then multiplied by the values in <code>"action"</code> to stretch the
axis.  Depending upon the desired effect, one might use <code>"stretch"</code>
followed by <code>"offset"</code> or perhaps other combinations.
</p>


<h3>Value</h3>

<p>A modified <code>HivePlotData</code> object.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(HEC)
# The first 3 examples take advantage of the argument '...'
# in plotHive, which passes action through to manipAxis on the fly.
# For this particular data, norm and absolute scaling appear the same.

plotHive(HEC, bkgnd = "white") # default is absolute positioning of nodes
plotHive(HEC, method = "rank", bkgnd = "white")
plotHive(HEC, method = "norm", bkgnd = "white")

# In these examples, we'll explicitly use manipAxis and then plot
# in a separate step.  This is because trying to plot on the fly in
# these cases will result in absolute scaling (which we do use here,
# but one might not want to be forced to do so).

HEC2 &lt;- manipAxis(HEC, method = "invert", action = c(-1, 1))
plotHive(HEC2, bkgnd = "white")
HEC3 &lt;- manipAxis(HEC, method = "stretch", action = c(2, 3))
plotHive(HEC3, bkgnd = "white")
HEC4 &lt;- manipAxis(HEC, method = "offset", action = c(0, 1.5))
plotHive(HEC4, bkgnd = "white")
</code></pre>

<hr>
<h2 id='mineHPD'>Examine (mine) a Hive Plot Data Object and Extract Information Contained
Within It</h2><span id='topic+mineHPD'></span>

<h3>Description</h3>

<p>A <code>HivePlotData object</code>, especially one created fresh using
<code><a href="#topic+dot2HPD">dot2HPD</a></code>, generally contains a lot of hidden information about
the network described. This function can extract this hidden information.
This function has <code>option</code>s which are quite specific as to what they
do.  The user can easily write new options and incorporate them.
This function can be called multiple times
using different options to gradually modify the <code>HivePlotData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mineHPD(HPD, option = "rad &lt;- tot.edge.count")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mineHPD_+3A_hpd">HPD</code></td>
<td>
<p>A <code><a href="#topic+HivePlotData">HivePlotData</a></code> object.</p>
</td></tr>
<tr><td><code id="mineHPD_+3A_option">option</code></td>
<td>
<p>A character string giving the option desired.  See Details for
current options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>option = "rad &lt;- tot.edge.count"</code> This option looks through the
<code>HivePlotData</code> object and determines how many edges start or end on
each node (the &quot;degree&quot;).  This value is then assigned to the radius for
that node.
</p>
<p><code>option = "axis &lt;- source.man.sink"</code> This option
examines the nodes and corresponding edges in a <code>HivePlotData</code> object
to determine if the node is a source, manager or sink.  A source node only
has outgoing edges.  A sink node only has incoming edges.  A manager has
both.  Hence, this option treats the <code>HivePlotData</code> object as if it
were directed in that the first node of an edge in will be in
<code>HPD$nodes$id1</code> and the second node of an edge will be in
<code>HPD$nodes$id2</code>.  As a result, this option produces a hive plot with 3
axes (note: sources are on axis 1, sinks on axis 2, and managers on axis 3).
This concept is similar to the idea of <code><a href="FuncMap.html#topic+FuncMap">FuncMap</a></code> but
the internals are quite different.  See also <code><a href="#topic+dot2HPD">dot2HPD</a></code> for some
details about processing .dot files in an agnostic fashion.
</p>
<p><code>option = "remove orphans"</code> removes nodes that have degree zero (no
incoming or outgoing edges).
</p>
<p><code>option = "remove zero edge"</code>
removes edges with length zero.  Such edges cause an error because
the spline cannot be drawn.  This option combines the next two options.
</p>
<p><code>option = "remove self edge"</code> removes edges that
start and end on the same node.
</p>
<p><code>option = "remove virtual edge"</code> removes virtual edges which are
edges which involve different nodes but the nodes happen to be on the
the same axis at the same radius.
</p>
<p><code>option = "remove edges same axis"</code> removes edges which start and
end on the same axis.
</p>


<h3>Value</h3>

<p>A modified <code>HivePlotData</code> object.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>See Also</h3>

<p>See the vignette for an example of using this function.  Use
<code>browseVignettes("HiveR")</code> to produce the vignette.
</p>

<hr>
<h2 id='plot3dHive'>Create (Plot) a 2D or 3D Hive Plot</h2><span id='topic+plot3dHive'></span><span id='topic+plotHive'></span>

<h3>Description</h3>

<p>These functions plot a <code>HivePlotData</code> object in either 2D or 3D,
depending upon which function is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3dHive(
  HPD,
  ch = 1,
  dr.nodes = TRUE,
  method = "abs",
  axLabs = NULL,
  axLab.pos = NULL,
  LA = FALSE,
  ...
)

plotHive(
  HPD,
  ch = 1,
  method = "abs",
  dr.nodes = TRUE,
  bkgnd = "black",
  axLabs = NULL,
  axLab.pos = NULL,
  axLab.gpar = NULL,
  anNodes = NULL,
  anNode.gpar = NULL,
  grInfo = NULL,
  arrow = NULL,
  np = TRUE,
  anCoord = "local",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot3dHive_+3A_hpd">HPD</code></td>
<td>
<p>An object of S3 class <code><a href="#topic+HivePlotData">HivePlotData</a></code>.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_ch">ch</code></td>
<td>
<p>Numeric; the size of the central hole in the hive plot.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_dr.nodes">dr.nodes</code></td>
<td>
<p>Logical; if <code>TRUE</code> nodes will be drawn.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_method">method</code></td>
<td>
<p>Character.  Passed to <code><a href="#topic+manipAxis">manipAxis</a></code> (see there for
allowed values - the default given above plots using the native or absolute
coordinates of the data).</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_axlabs">axLabs</code></td>
<td>
<p>A vector of character strings for the axis labels.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_axlab.pos">axLab.pos</code></td>
<td>
<p>Numeric; An offset from the end of the axis for label
placement.  Either a single value or a vector of values.  If a single value,
all labels are offset the same amount.  If a vector of values, there should
be a value for each axis.  This allows flexibility with long axis names.
The units depend upon the <code>method</code> employed (see Details).</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_la">LA</code></td>
<td>
<p>(Applies to <code>plot3dHive</code> only) Logical: should splines be
drawn with <code>line_antialias = TRUE</code>? See Details.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed downstream.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_bkgnd">bkgnd</code></td>
<td>
<p>Any valid color specification.  Used for the background color
for <code>plotHive</code>.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_axlab.gpar">axLab.gpar</code></td>
<td>
<p>(Applies to <code>plotHive</code> only) A list of name - value
pairs acceptable to <code><a href="grid.html#topic+gpar">gpar</a></code>.  These control the label and arrow
displays.  See the examples.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_annodes">anNodes</code></td>
<td>
<p>(Applies to <code>plotHive</code> only) The path to a csv file
containing information for labeling nodes.  If present, a line segment will
be drawn from the node to the specified text.  The text is positioned near
the end of the line segment.  The columns in the csv file must be named as
follows (description and use in parentheses): node.lab (node label from
HPD$nodes$lab), node.text (the text to be drawn on the plot), angle (polar
coordinates: angle at which to draw the segment), radius (polar coordinates:
radius at which to draw the text), offset (additional distance along the
radius vector to offset text), hjust, vjust (horizontal and vertical
justification; nominally in [0...1] but fractional and negative values
also work).  The first two values will be treated as type <code>character</code>,
the others as <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_annode.gpar">anNode.gpar</code></td>
<td>
<p>(Applies to <code>plotHive</code> only) A list of name - value
pairs acceptable to <code><a href="grid.html#topic+gpar">gpar</a></code>.  These control both the text used to
annotate the nodes and the line segments connecting that text to the node.
See the examples.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_grinfo">grInfo</code></td>
<td>
<p>(Applies to <code>plotHive</code> only) The path to a csv file
containing information for adding graphic decorations to the plot.  If
present, a line segment will be drawn from the node to the specified
location and the graphic is positioned near the end the line segment.  The
columns in the csv file must be named as follows (description and use in
parentheses): node.lab (node label from HPD$nodes$lab), angle (polar
coordinates: angle at which to position the graphic), radius (polar
coordinates: radius at which to position the graphic), offset (additional
distance along radius vector to offset the graphic), width (the width of the
graphic), path (a valid path to the graphics in jpg or png format).  The
path should include the extension is it is autodetected.  Valid extensions
are jpg, JPG, jpeg, JPEG, png, or PNG.  All image files must be of the same
type (all jpg, or all png).</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_arrow">arrow</code></td>
<td>
<p>(Applies to <code>plotHive</code> only) A vector of 5 or 6 values: a
character string to label the arrow, and 4 numeric values giving the angle
of the arrow, the radius at which to start the arrow, the radius at which to
end the arrow, and a value to offset the arrow label from the end of the
arrow.  A 5th numeric value (the 6th argument overall) can specify an offset
in the y direction for the arrow useful when <code>nx = 2</code>.  See the
examples.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_np">np</code></td>
<td>
<p>(Applies to <code>plotHive</code> only) Logical; should a new device
(page) be opened when drawing the hive plot?  If you are making multiple
plots within some sort of <code>grid</code> scheme then this should be set to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot3dHive_+3A_ancoord">anCoord</code></td>
<td>
<p>(Applies to <code>plotHive</code> only) One of <code>c("local",
"global")</code>.  Controls how the position of node labels and graphic
decorations are specified.  See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>General</strong>.  <code>plotHive</code> uses <code>grid</code> graphics to produce a 2D hive
plot in a style similar to the original concept.  For a 2D plot, axis number
1 is vertical except in the case of 2 axes in which case it is to the right.
<code>plot3dHive</code> produces a 3D hive plot using <code>rgl</code> graphics.
Functions from either package can be used to make additional modifications
after the hive plot is drawn, either via the ... argument or by
subsequent function calls.  See the examples.
</p>
<p><strong>Units and Annotations</strong>. If you add node labels, arrows or graphic decorations,
the units that you
must specify are those intrinsic to the data itself, modified by your
setting of <code>ch</code> and <code>method</code>.  These generally cannot be known
precisely ahead of time, so some experimentation will be necessary to polish
the plots.  For instance, if you have data with node radii that run from
4-23 then you have an idea of how to position your annotations if using
<code>method = "abs"</code>.  But the same data plotted with <code>method =
"norm"</code> or <code>method = "rank"</code> will require that you move your annotation
positions accordingly.  In the first case no radius is larger than 23, but
the maximum radius is 1 when the data is normed and when it is ranked, the
maximum value will depend upon which axis has the most nodes on it, and the
number of unique radii values.
</p>
<p><strong>Positioning Node Labels and Graphics</strong>.
In addition to the nuances just above, there are two ways to specify the
location of node labels and graphic decorations.  Polar coordinates are used
in both cases.  If <code>annCoord = "local"</code> then the angle, radius and
offset arguments are relative to the node to be annotated.  An angle of 0
positions the label horizontally to the right of the node. Thus the label
can be placed within a circular area around the node.  If <code>annCoord =
"global"</code> then the specifications are relative to dead center on the plot.
These two methods give one lots of flexibility in lining up labels in
different ways.  See the examples.
</p>
<p><strong>Size of Graphics</strong>.  The size of
graphic decorations is controlled by the column 'width' in <code>grInfo</code>.
The ultimate call to display the graphic is done with <code>as.raster</code>.
Specifying only the width preserves the aspect ratio of the graphic.  See
<code>?as.raster</code> for further discussion.
</p>
<p><strong>Colors</strong>.  For any of the
<code>gpar</code> arguments, watch out: In grid graphics the default color for
text and arrows is black, so if are using the default <code>bkgnd = "black"</code>
in the hive plot be sure to specify <code>col = "white"</code> (or some other
non-black color) for the labels and arrows or you won't see them.
</p>
<p><strong>Speed and 3D Hive Plots</strong>.  For most work with <code>plot3dHive</code>, use <code>LA
= FALSE</code> for speed of drawing.  <code>LA = TRUE</code> is over 20 times slower,
and is more appropriate for high quality hive plots.  These are probably
better made with <code>R CMD BATCH script.R</code> rather than interactive use.
</p>


<h3>Value</h3>

<p>None.  Side effect is a plot.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot3dHive()</code>: Create a 3D Hive Plot
</p>
</li>
<li> <p><code>plotHive()</code>: Create a 2D Hive Plot
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### 2D Hive Plots
require("grid")
# Generate some random data
test2 &lt;- ranHiveData(nx = 2)
test3 &lt;- ranHiveData(nx = 3)

# First the nx = 2 case.
# Note that gpar contains parameters that apply to both the
# axis labels and arrow. A 6th value in arrow offsets the arrow vertically:
plotHive(test2,
  ch = 5, axLabs = c("axis 1", "axis 2"), rot = c(-90, 90),
  axLab.pos = c(20, 20), axLab.gpar = gpar(col = "pink", fontsize = 14, lwd = 2),
  arrow = c("radius units", 0, 20, 60, 25, 40)
)

# Now nx = 3:
plotHive(test3) # default plot

# Add axis labels &amp; options to nx = 3 example.  Note that rot is not part of gpar
plotHive(test3,
  ch = 5, axLabs = c("axis 1", "axis 2", "axis 3"),
  axLab.pos = c(10, 15, 15), rot = c(0, 30, -30),
  axLab.gpar = gpar(col = "orange", fontsize = 14)
)

# Call up a built-in data set to illustrate some plotting tricks
data(HEC)
require("grid") # for text additions outside of HiveR (grid.text)

plotHive(HEC,
  ch = 0.1, bkgnd = "white",
  axLabs = c("hair\ncolor", "eye\ncolor"),
  axLab.pos = c(1, 1),
  axLab.gpar = gpar(fontsize = 14)
)
grid.text("males", x = 0, y = 2.3, default.units = "native")
grid.text("females", x = 0, y = -2.3, default.units = "native")
grid.text("Pairing of Eye Color with Hair Color",
  x = 0, y = 4,
  default.units = "native", gp = gpar(fontsize = 18)
)

# Add node labels and graphic decorations
# The working directory has to include
# not only the grInfo and anNodes files but also the jpgs.
# So, we are going to move to such a directory and return you home afterwards.

currDir &lt;- getwd()
setwd(system.file("extdata", "Misc", package = "HiveR"))
plotHive(HEC,
  ch = 0.1, bkgnd = "white",
  axLabs = c("hair\ncolor", "eye\ncolor"),
  axLab.pos = c(1, 1),
  axLab.gpar = gpar(fontsize = 14),
  anNodes = "HECnodes.txt",
  anNode.gpar = gpar(col = "black"),
  grInfo = "HECgraphics.txt",
  arrow = c("more\ncommon", 0.0, 2, 4, 1, -2)
)

grid.text("males", x = 0, y = 2.3, default.units = "native")
grid.text("females", x = 0, y = -2.3, default.units = "native")
grid.text("Pairing of Eye Color with Hair Color",
  x = 0, y = 3.75,
  default.units = "native", gp = gpar(fontsize = 18)
)
grid.text("A test of plotHive annotation options",
  x = 0, y = 3.25,
  default.units = "native", gp = gpar(fontsize = 12)
)
grid.text("Images from Wikipedia Commons",
  x = 0, y = -3.5,
  default.units = "native", gp = gpar(fontsize = 9)
)
setwd(currDir)

# Use the node label concept to create tick marks

currDir &lt;- getwd()
setwd(system.file("extdata", "Misc", package = "HiveR"))
plotHive(HEC,
  ch = 0.1, bkgnd = "white",
  axLabs = c("hair\ncolor", "eye\ncolor"),
  axLab.pos = c(1, 1),
  axLab.gpar = gpar(fontsize = 14),
  anNodes = "HECticks.txt",
  anNode.gpar = gpar(col = "black"),
  arrow = c("more\ncommon", 0.0, 2, 4, 1, -2),
  dr.nodes = FALSE
)

grid.text("males", x = 0, y = 2.3, default.units = "native")
grid.text("females", x = 0, y = -2.3, default.units = "native")
grid.text("Pairing of Eye Color with Hair Color",
  x = 0, y = 3.75,
  default.units = "native", gp = gpar(fontsize = 18)
)
grid.text("Adding tick marks to the nodes",
  x = 0, y = 3.25,
  default.units = "native", gp = gpar(fontsize = 12)
)
setwd(currDir)


### 3D Hive Plots. The following must be run interactively.
## Not run: 
require("rgl")
test4 &lt;- ranHiveData(nx = 4, type = "3D")
plot3dHive(test4)

## End(Not run)

</code></pre>

<hr>
<h2 id='ranHiveData'>Generate Random Hive Plot Data</h2><span id='topic+ranHiveData'></span>

<h3>Description</h3>

<p>This function generates random data sets which can be used to make a hive
plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranHiveData(
  type = "2D",
  nx = 4,
  nn = nx * 15,
  ne = nx * 15,
  rad = 1:100,
  ns = c(0.5, 1, 1.5),
  ew = 1:3,
  nc = brewer.pal(5, "Set1"),
  ec = brewer.pal(5, "Set1"),
  axis.cols = brewer.pal(nx, "Set1"),
  desc = NULL,
  allow.same = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranHiveData_+3A_type">type</code></td>
<td>
<p>The type of hive plot to be generated.  One of <code>c("2D",
"3D")</code>.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_nx">nx</code></td>
<td>
<p>An integer giving the number of axes to be created (<code>2 =&lt; nx
=&lt; 6</code>).</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_nn">nn</code></td>
<td>
<p>An integer giving the number of nodes to be created.  This is an
initial number which may be reduced during clean up.  See Details.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_ne">ne</code></td>
<td>
<p>An integer giving the number of edges to be created.  This is an
initial number which may be reduced during clean up.  See Details.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_rad">rad</code></td>
<td>
<p>Numeric; a range of values that will be used as node radius
values (the position of the node along the axis).</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_ns">ns</code></td>
<td>
<p>Numeric; a range of values that will be used as the node sizes.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_ew">ew</code></td>
<td>
<p>Numeric; a range of values that will be used as the edge weights.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_nc">nc</code></td>
<td>
<p>A vector of valid color names giving the node colors.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_ec">ec</code></td>
<td>
<p>A vector of valid color names giving the edge colors.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_axis.cols">axis.cols</code></td>
<td>
<p>A vector of valid color names to be used to color the axes;
<code>length(axis.cols) must = nx</code>.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_desc">desc</code></td>
<td>
<p>Character; a description of the data set.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_allow.same">allow.same</code></td>
<td>
<p>Logical; indicates if edges may begin and end on the same
axis. Only applies to <code>type = 2D</code>.</p>
</td></tr>
<tr><td><code id="ranHiveData_+3A_verbose">verbose</code></td>
<td>
<p>Logical; If <code>TRUE</code>, the generation, processing and final
result is reported to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>type = "2D"</code>, after the function creates an initial set of random
nodes, these are randomly chosen and connected between adjacent axes, so
that no edge crosses an axis. <br /> <br /> For <code>type = "3D"</code>, after the
function creates an initial set of random nodes and edges, these are cleaned
up by removing the following cases (which the rest of <code>HiveR</code> is not
intended to handle at this time): duplicated nodes, nodes that are not part
of any edge, edges that begin and end on the same point, edges that begin
and end on the same axis, and finally, for <code>nx = 5 or 6</code>, edges that
begin and end on colinear axes.  Most of these don't cause an error, but
produce some ugly results. <br /> <br /> For the arguments <code>rad, ns, ew, nc</code>
and <code>ec</code>, the values given are sampled randomly (with replacement) and
assigned to particular nodes or edges.
</p>


<h3>Value</h3>

<p>An object of S3 class <code><a href="#topic+HivePlotData">HivePlotData</a></code>.
</p>


<h3>Warning</h3>

<p>If you create a very small data set with few nodes, there
may be no nodes assigned to some axes which will give an error when you try
to plot the data.  It's up to the user to check for this possibility (you
can use <code>sumHPD</code>).
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test4 &lt;- ranHiveData(nx = 4)
str(test4)
sumHPD(test4)
</code></pre>

<hr>
<h2 id='rcsr'>Compute the Details of a 3D Spline for a Hive Plot Edge</h2><span id='topic+rcsr'></span>

<h3>Description</h3>

<p>This is a wild bit of trigonometry!  Three points in 3D space, two ends and
an control point, are rotated into 2D space.  Then a spline curve is
computed.  This is necessary because spline curves are only defined in
<code>R</code> as 2D objects.  The new collection of points, which is the complete
spline curve and when drawn will be the edge of a hive plot, is rotated back
into the original 3D space. <code>rcsr</code> stands for rotate, compute spline,
rotate back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcsr(p0, cp, p1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcsr_+3A_p0">p0</code></td>
<td>
<p>A triple representing one end of the final curve (x, y, z).</p>
</td></tr>
<tr><td><code id="rcsr_+3A_cp">cp</code></td>
<td>
<p>A triple representing the control point used to compute the final
curve (x, y, z).</p>
</td></tr>
<tr><td><code id="rcsr_+3A_p1">p1</code></td>
<td>
<p>A triple representing the other end of the final curve (x, y, z).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the code for exactly how the function works.  Based upon the process
described at <a href="http://www.fundza.com/mel/axis_to_vector/index.html">http://www.fundza.com/mel/axis_to_vector/index.html</a>
Timing tests show this function is fast and scales linearly (i.e. 10x more
splines to draw takes 10x more time).  Roughly 3 seconds were required to
draw 1,000 spline curves in my testing.
</p>


<h3>Value</h3>

<p>A 3 column matrix with the x, y and z coordinates to be plotted to
create a hive plot edge.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This is a lengthy example to prove it works.
# Read it and then copy the whole thing to a blank script.
# Parts of it require rgl and are interactive.
# So none of the below is run during package build/check.

### First, a helper function
## Not run: 

drawUnitCoord &lt;- function() {

  # Simple function to draw a unit 3D coordinate system

  # Draw a Coordinate System

  r &lt;- c(0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1) # in polar coordinates
  theta &lt;- c(0, 0, 0, 90, 0, 180, 0, 270, 0, 0, 0, 0) # start, end, start, end
  phi &lt;- c(0, 90, 0, 90, 0, 90, 0, 90, 0, 0, 0, 180)
  cs &lt;- data.frame(radius = r, theta, phi)
  ax.coord &lt;- sph2cart(cs)

  segments3d(ax.coord, col = "gray", line_antialias = TRUE)
  points3d(
    x = 0, y = 0, z = 0, color = "black", size = 4,
    point_antialias = TRUE
  ) # plot origin

  # Label the axes

  r &lt;- c(1.1, 1.1, 1.1, 1.1, 1.1, 1.1) # in polar coordinates
  theta &lt;- c(0, 90, 180, 270, 0, 0)
  phi &lt;- c(90, 90, 90, 90, 0, 180)
  l &lt;- data.frame(radius = r, theta, phi)
  lab.coord &lt;- sph2cart(l)
  text3d(lab.coord, texts = c("+x", "+y", "-x", "-y", "+z", "-z"))
}

###  Now, draw a reference coordinate system and demo the function in it.

drawUnitCoord()

### Draw a bounding box

box &lt;- data.frame(
  x = c(1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1),
  y = c(1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1),
  z = c(1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, -1, 1, 1, -1, -1, -1, 1, 1, 1, -1, -1)
)

segments3d(box$x, box$y, box$z, line_antialias = TRUE, col = "red")

### Draw the midlines defining planes

mid &lt;- data.frame(
  x = c(0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1),
  y = c(-1, -1, -1, 1, 1, 1, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 1, 1, 1, 1, -1),
  z = c(-1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0)
)

segments3d(mid$x, mid$y, mid$z, line_antialias = TRUE, col = "blue")

### Generate two random points

p &lt;- runif(6, -1, 1)

# Special case where p1 is on z axis
# Uncomment line below to demo
# p[4:5] &lt;- 0

p0 &lt;- c(p[1], p[2], p[3])
p1 &lt;- c(p[4], p[5], p[6])

### Draw the pts, label them, draw vectors to those pts from origin

segments3d(
  x = c(0, p[1], 0, p[4]),
  y = c(0, p[2], 0, p[5]),
  z = c(0, p[3], 0, p[6]),
  line_antialias = TRUE, col = "black", lwd = 3
)

points3d(
  x = c(p[1], p[4]),
  y = c(p[2], p[5]),
  z = c(p[3], p[6]),
  point_antialias = TRUE, col = "black", size = 8
)

text3d(
  x = c(p[1], p[4]),
  y = c(p[2], p[5]),
  z = c(p[3], p[6]),
  col = "black", texts = c("p0", "p1"), adj = c(1, 1)
)

### Locate control point
### Compute and draw net vector from origin thru cp
### Connect p0 and p1

s &lt;- p0 + p1
segments3d(
  x = c(0, s[1]), y = c(0, s[2]), z = c(0, s[3]),
  line_antialias = TRUE, col = "grey", lwd = 3
)

segments3d(
  x = c(p[1], p[4]), # connect p0 &amp; p1
  y = c(p[2], p[5]),
  z = c(p[3], p[6]),
  line_antialias = TRUE, col = "grey", lwd = 3
)

cp &lt;- 0.6 * s # Now for the control point

points3d(
  x = cp[1], # Plot the control point
  y = cp[2],
  z = cp[3],
  point_antialias = TRUE, col = "black", size = 8
)

text3d(
  x = cp[1], # Label the control point
  y = cp[2],
  z = cp[3],
  texts = c("cp"), col = "black", adj = c(1, 1)
)

### Now ready to work on the spline curve

n2 &lt;- rcsr(p0, cp, p1) # Compute the spline

lines3d(
  x = n2[, 1], y = n2[, 2], z = n2[, 3],
  line_antialias = TRUE, col = "blue", lwd = 3
)

### Ta-Da!!!!!

## End(Not run)

</code></pre>

<hr>
<h2 id='sph2cart'>Convert Spherical to Cartesian Coordinates</h2><span id='topic+sph2cart'></span>

<h3>Description</h3>

<p>This function converts spherical to Cartesian coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph2cart(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sph2cart_+3A_df">df</code></td>
<td>
<p>A data frame with columns named r, theta and phi with the radius
and angles (in spherical coordinates) to be converted to Cartesian
coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with named columns containing the converted
coordinates.
</p>


<h3>Note</h3>

<p>Cobbled together from similar functions in other packages.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>

<hr>
<h2 id='sumHPD'>Summarize a Hive Plot Data Object and Optionally Run Some Checks</h2><span id='topic+sumHPD'></span>

<h3>Description</h3>

<p>This function summarizes a <code><a href="#topic+HivePlotData">HivePlotData</a></code> object in a convenient
form. Optionally, it can run some checks for certain conditions that may be
of interest.  It can also output a summary of edges to be drawn, either as a
data frame or in a LaTeX ready form, or a data frame of orphaned nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumHPD(
  HPD,
  chk.all = FALSE,
  chk.sm.pt = FALSE,
  chk.ax.jump = FALSE,
  chk.sm.ax = FALSE,
  chk.orphan.node = FALSE,
  chk.virtual.edge = FALSE,
  plot.list = FALSE,
  tex = FALSE,
  orphan.list = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumHPD_+3A_hpd">HPD</code></td>
<td>
<p>An object of S3 class <code>HivePlotData</code>.</p>
</td></tr>
<tr><td><code id="sumHPD_+3A_chk.all">chk.all</code></td>
<td>
<p>Logical; should all the checks below be run?  See Details.</p>
</td></tr>
<tr><td><code id="sumHPD_+3A_chk.sm.pt">chk.sm.pt</code></td>
<td>
<p>Logical; should the edges be checked to see if any of them
start and end on the same axis with the same radius?  See Details.</p>
</td></tr>
<tr><td><code id="sumHPD_+3A_chk.ax.jump">chk.ax.jump</code></td>
<td>
<p>Logical; should the edges be checked to see if any of
them start and end on non-adjacent axes, e.g. axis 1 &ndash;&gt; axis 3?  See
Details.</p>
</td></tr>
<tr><td><code id="sumHPD_+3A_chk.sm.ax">chk.sm.ax</code></td>
<td>
<p>Logical; should the edges be checked to see if any of them
start and end on the same axis?</p>
</td></tr>
<tr><td><code id="sumHPD_+3A_chk.orphan.node">chk.orphan.node</code></td>
<td>
<p>Logical; should orphan nodes be identifed?  Orphan
nodes have degree 0 (no incoming or outgoing edges).</p>
</td></tr>
<tr><td><code id="sumHPD_+3A_chk.virtual.edge">chk.virtual.edge</code></td>
<td>
<p>Logical; should the edges be checked to see if any of them
start and end on different nodes which happen to be at the same radius on the
same axis? See Details.</p>
</td></tr>
<tr><td><code id="sumHPD_+3A_plot.list">plot.list</code></td>
<td>
<p>Logical; should a data frame of edges to be drawn be
returned?</p>
</td></tr>
<tr><td><code id="sumHPD_+3A_tex">tex</code></td>
<td>
<p>Logical; should the <code>plot.list</code> be formatted for LaTeX?</p>
</td></tr>
<tr><td><code id="sumHPD_+3A_orphan.list">orphan.list</code></td>
<td>
<p>Logical; should a data frame of orphaned nodes be
returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>chk.sm.pt</code> applies only to hive plots of <code>type = 2D</code>.
It checks to see if any of the edges start and end at the same node id.
These by definition exist at the same radius on the same axis, which
causes an error in <code>plotHive</code> since you are trying to draw an edge of
length zero (the actual error message is <code>Error in calcCurveGrob(x,
x$debug) : End points must not be identical</code>.  Some data sets may have such
cases intrinsically or due to data entry error, or the condition may arise
during processing.  Either way, one needs to be able to detect such cases
for removal or modification. This argument will tell you which nodes cause
the problem.
</p>
<p>Argument <code>chk.virtual.edge</code> applies only to hive plots of <code>type = 2D</code>
and is similiar to <code>chk.sm.pt</code> above except
that it checks for virtual edges.  These are edges start and end on the
same axis at the same radius but at different node id's (in other words,
two nodes have the same radius on the same axis).  This condition
gives the same error as above.  It is checked for separately as it arises
via a different problem in the construction of the data.
</p>
<p>Argument <code>chk.ax.jump</code> applies only to hive plots
of <code>type = 2D</code>.  It checks to see if any of the edges jump an axis,
e.g. axis 1 &ndash;&gt; axis 3. This argument will tell you which nodes are at
either end of the jumping edge.  Jumping should should be avoided in hive
plots as it makes the plot aesthetically unpleasing.  However, depending
upon how you process the data, this condition may arise and hence it is
useful to be able to locate jumps.
</p>


<h3>Value</h3>

<p>A summary of the <code>HivePlotData</code> object's key characteristics is
printed at the console, followed by the results of any checks set to
<code>TRUE</code>.  The format of these results is identical to that of
<code>plot.list</code> described just below, except for the orphan node check.
This is formatted the same as <code>HPD$nodes</code>; see <code>?HPD</code> for details.
</p>
<p>If <code>plot.list = TRUE</code>, a data frame containing a list of the
edges to be drawn in a format suitable for troubleshooting a plot.  If
<code>tex = TRUE</code> as well, the data frame will be in a format suitable for
pasting into a LaTeX document.  The data frame will contain rows describing
each edge to be drawn with the following columns: node 1 id, node 1 axis,
node 1 label, node 1 radius, then the same info for node 2, then the edge
weight and the edge color.
</p>
<p>If <code>orphan.list = TRUE</code> a data frame
giving the orphan nodes is returned.  If you want both <code>plot.list</code> and
<code>orphan.list</code> you have to call this function twice.
</p>


<h3>Author(s)</h3>

<p>Bryan A. Hanson, DePauw University. <a href="mailto:hanson@depauw.edu">hanson@depauw.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(55)
test &lt;- ranHiveData(nx = 4, ne = 5, desc = "Tiny 4D data set")
out &lt;- sumHPD(test, chk.all = TRUE, plot.list = TRUE)
print(out)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
