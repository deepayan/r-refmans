<!DOCTYPE html><html><head><title>Help for package kernstadapt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kernstadapt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aegiss'>
<p>Diggle et al.'s data: Non-specific gastrointestinal data</p></a></li>
<li><a href='#amazon'>
<p>Locations of fires in the Amazon biome.</p></a></li>
<li><a href='#bw.abram.temp'><p>Abramson's adaptive temporal bandwidths</p></a></li>
<li><a href='#dens.direct'><p>Direct estimation of non-separable adaptive spatio-temporal intensity estimator</p></a></li>
<li><a href='#dens.direct.sep'><p>Direct separable adaptive spatio-temporal intensity estimator</p></a></li>
<li><a href='#dens.par'><p>Non-separable adaptive spatio-temporal intensity estimator</p></a></li>
<li><a href='#dens.par.sep'><p>Separable adaptive spatio-temporal intensity estimator</p></a></li>
<li><a href='#dens.par.temp'><p>Adaptive kernel estimate of intensity of a temporal point pattern</p></a></li>
<li><a href='#lGCpp'>
<p>Simulated spatio-temporal log Gaussian Cox point pattern data</p></a></li>
<li><a href='#santander'>
<p>Santander earthquakes epicentres</p></a></li>
<li><a href='#separability.test'><p>Separability test for spatio-temporal point processes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatio-Temporal Adaptive Kernel Estimators for Intensities</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonatan A González &lt;jonathan.gonzalez@kaust.edu.sa&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Adaptive estimation of the first-order intensity function of a spatio-temporal point process using kernels and variable bandwidths. The methodology used for estimation is presented in González and Moraga (2022). &lt;<a href="https://doi.org/10.48550/arXiv.2208.12026">doi:10.48550/arXiv.2208.12026</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>misc3d, sparr, spatstat.explore, spatstat.geom,
spatstat.random, spatstat.utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-14 14:11:19 UTC; gonzalja</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonatan A González
    <a href="https://orcid.org/0000-0002-2296-5271"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Paula Moraga <a href="https://orcid.org/0000-0001-5266-0201"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-15 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aegiss'>
Diggle et al.'s data: Non-specific gastrointestinal data
</h2><span id='topic+aegiss'></span>

<h3>Description</h3>

<p>A spatio-temporal point pattern of locations and times of individuals with non-specific gastrointestinal infections in Hampshire, UK, from 2001 to 2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("aegiss")</code></pre>


<h3>Format</h3>

<p>An object of class <code>"ppp"</code>
Entries include
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>x</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">x</code>-coordinate of infection </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>y</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">y</code>-coordinate of infection </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>marks</code> </td><td style="text-align: left;"> An integer vector of values indicating </td>
</tr>
<tr>
 <td style="text-align: left;">
                      the time of infection starting in <code>1</code>
    <code>window</code> </td><td style="text-align: left;"> Cartesian coordinates of Hampshire's map
    </td>
</tr>

</table>

<p>See <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> for details of the format.
</p>


<h3>Source</h3>

<p>Diggle, P. (2015) AEGISS1. Syndromic surveillance of gastro-intestinal illness
<a href="https://www.research.lancs.ac.uk/portal/en/datasets/aegiss1-syndromic-surveillance-of-gastrointestinal-illness(e732159d-811f-44b0-b2d3-0139ebf4edee).html">https://www.research.lancs.ac.uk/portal/en/datasets/aegiss1-syndromic-surveillance-of-gastrointestinal-illness(e732159d-811f-44b0-b2d3-0139ebf4edee).html</a>
</p>


<h3>References</h3>

<p>Diggle, L. Knorr-Held, R. B, T. Su, P. Hawtin, and T. Bryant. (2003)
On-line monitoring of public health surveillance data.
In B. R. and S. D.F., editors, Monitoring the Health of Populations:
<em>Statistical Principles and Methods for Public Health Surveillance.</em> <b>233–266</b>.
Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aegiss)
head(aegiss)
plot(aegiss, bg = rainbow(250), pch = 21)
</code></pre>

<hr>
<h2 id='amazon'>
Locations of fires in the Amazon biome.
</h2><span id='topic+amazon'></span>

<h3>Description</h3>

<p>A spatio-temporal point pattern of locations and times of active deforestation fires (starting within past 24 hours) from 01/01/2021 to 10/10/2021 (284 days).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("amazon")</code></pre>


<h3>Format</h3>

<p>An object of class <code>"ppp"</code>
Entries include
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>x</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">x</code>-coordinate of fire </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>y</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">y</code>-coordinate of fire </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>marks</code> </td><td style="text-align: left;"> An integer vector of values indicating </td>
</tr>
<tr>
 <td style="text-align: left;">
                      the time of the fire starting in <code>2</code>
    <code>window</code> </td><td style="text-align: left;"> Coordinates of Amazonia biome map
    </td>
</tr>

</table>

<p>See <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> for details of the format.
</p>


<h3>Source</h3>

<p>The Amazon Dashboard (<a href="http://www.globalfiredata.org">http://www.globalfiredata.org</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(amazon)
head(amazon)
# Plot a sample
X &lt;- amazon[sample.int(amazon$n, 3000)]
plot(X, bg = rainbow(250), pch = 21, main = "Amazon fires")
</code></pre>

<hr>
<h2 id='bw.abram.temp'>Abramson's adaptive temporal bandwidths</h2><span id='topic+bw.abram.temp'></span>

<h3>Description</h3>

<p>Computes adaptive smoothing bandwidth in the temporal case according to the inverse-square-root rule of Abramson (1982).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.abram.temp(t, h0 = NULL, nt = 128, trim = NULL, at = "points")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.abram.temp_+3A_t">t</code></td>
<td>
<p>A vector (a temporal point pattern) from which the bandwidths should be computed.</p>
</td></tr>
<tr><td><code id="bw.abram.temp_+3A_h0">h0</code></td>
<td>
<p>The global smoothing bandwidth. The default is Silverman's rule of thumb (bw.nrd0).</p>
</td></tr>
<tr><td><code id="bw.abram.temp_+3A_nt">nt</code></td>
<td>
<p>The number of equally spaced points at which the temporal density is to be estimated.</p>
</td></tr>
<tr><td><code id="bw.abram.temp_+3A_trim">trim</code></td>
<td>
<p>A trimming value to cut extreme large bandwidths.</p>
</td></tr>
<tr><td><code id="bw.abram.temp_+3A_at">at</code></td>
<td>
<p>Character string specifying whether to compute bandwidths at the points (at = &quot;points&quot;, the default) or to compute bandwidths at every bin in a bin grid (at = &quot;bins&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a set of temporal adaptive smoothing bandwidths driven by the methods of Abramson (1982) and Hall and Marron (1988).
The bandwidth at location <code class="reqn">v</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">
\delta(v) = h0 * \mbox{min}\left[ \frac{1}{\gamma} \sqrt{\frac{n}{\lambda^{\mbox{t}}(v)}}, \mbox{\texttt{trim}} \right]
</code>
</p>

<p>where <code class="reqn">\lambda^{\mbox{t}}(v)</code> is a pilot estimate of the temporally varying intensity and <code class="reqn">\gamma</code> is a scaling constant depending on the pilot estimate.
</p>


<h3>Value</h3>

<p>If <code>at = "points"</code> (the default), the result is a numeric vector with one bandwidth for each data point in <code>X</code>.
If <code>at = "bins"</code>, the output is an object with class &quot;density&quot; where <code>y</code> component is a vector with the estimated intensity values (see <a href="stats.html#topic+density">density</a>).
</p>


<h3>Author(s)</h3>

<p>Jonatan A. González
</p>


<h3>References</h3>

<p>Abramson, I. (1982) On bandwidth variation in kernel estimates &mdash; a square root law.
<em>Annals of Statistics</em>, <b>10</b>(4), 1217-1223.<br />
</p>
<p>Davies, T.M. and Baddeley, A. (2018) Fast computation of spatially adaptive kernel estimates.
<em>Statistics and Computing</em>, <b>28</b>(4), 937-956.<br />
</p>
<p>Davies, T.M., Marshall, J.C., and Hazelton, M.L. (2018)
Tutorial on kernel estimation of continuous spatial and spatiotemporal relative risk.
<em>Statistics in Medicine</em>, <b>37</b>(7), 1191-1221.<br />
</p>
<p>Hall, P. and Marron, J.S. (1988) Variable window width kernel density estimates of probability
densities. <em>Probability Theory and Related Fields</em>, <b>80</b>, 37-49.<br />
</p>
<p>Silverman, B.W. (1986) <em>Density Estimation for Statistics and Data Analysis</em>.
Chapman and Hall, New York.
</p>
<p>González J.A. and Moraga P. (2018)
An adaptive kernel estimator for the intensity function of spatio-temporal point processes
<a href="https://arxiv.org/pdf/2208.12026.pdf">https://arxiv.org/pdf/2208.12026.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- 2 * rbeta(100, 1.5, 5.5, 0.2) #Simulated temporal point pattern
bw.abram.temp(t)

</code></pre>

<hr>
<h2 id='dens.direct'>Direct estimation of non-separable adaptive spatio-temporal intensity estimator</h2><span id='topic+dens.direct'></span>

<h3>Description</h3>

<p>Provides an adaptive-bandwidth kernel estimate for spatio-temporal point patterns in a non-separable fashion by calculating the classical estimator, i.e., the slowest estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens.direct(
  X,
  t = NULL,
  dimyx = 128,
  dimt = 128,
  bw.xy = NULL,
  bw.t = NULL,
  at = c("bins", "points")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens.direct_+3A_x">X</code></td>
<td>
<p>A spatial point pattern (an object of class <code>ppp</code>) with the spatial coordinates of the observations. It may contain marks representing times.</p>
</td></tr>
<tr><td><code id="dens.direct_+3A_t">t</code></td>
<td>
<p>A numeric vector of temporal coordinates with equal length to the number of points in <code>X</code>. This gives the time associated with each spatial point. This argument is not necessary if time marks are provided to the point pattern <code>X</code>.</p>
</td></tr>
<tr><td><code id="dens.direct_+3A_dimyx">dimyx</code></td>
<td>
<p>Spatial pixel resolution. The default is 128 for each axes.</p>
</td></tr>
<tr><td><code id="dens.direct_+3A_dimt">dimt</code></td>
<td>
<p>Temporal bin vector dimension. The default is 128.</p>
</td></tr>
<tr><td><code id="dens.direct_+3A_bw.xy">bw.xy</code></td>
<td>
<p>Numeric vector of spatial smoothing bandwidths for each point in <code>X</code>. By default this is computed using <a href="spatstat.explore.html#topic+bw.abram">bw.abram</a>, with <code>h0</code> given by <a href="sparr.html#topic+OS">OS</a>.</p>
</td></tr>
<tr><td><code id="dens.direct_+3A_bw.t">bw.t</code></td>
<td>
<p>Numeric vector of temporal smoothing bandwidths for each point in <code>t</code>. By default this is computed using <a href="#topic+bw.abram.temp">bw.abram.temp</a>.</p>
</td></tr>
<tr><td><code id="dens.direct_+3A_at">at</code></td>
<td>
<p>String specifying whether to estimate the intensity at a mesh (<code>at = "bins"</code>) or only at the points of <code>X</code> (<code>at = "points"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a non-separable spatio-temporal adaptive kernel estimate of the intensity. It starts from a planar point pattern <code>X</code> and a vector of times <code>t</code> and apply a non-separable kernel estimator for each of the points of <code>X</code>. The arguments <code>bw.xy</code> and <code>bw.t</code> specify the smoothing bandwidth vectors to be applied to each of the points in <code>X</code> and <code>t</code>. They should be a numeric vectors of bandwidths.
</p>


<h3>Value</h3>

<p>If <code>at = "points"</code> (the default), the result is a numeric vector with one entry for each data point in <code>X</code>. if <code>at = "bins"</code> is a list named (by time-point) list of pixel images (<a href="spatstat.geom.html#topic+im">im</a> objects) corresponding to the joint spatio-temporal intensity over space at each discretised time bin.
</p>


<h3>Author(s)</h3>

<p>Jonatan A. González
</p>


<h3>References</h3>

<p>González J.A. and Moraga P. (2018)
An adaptive kernel estimator for the intensity function of spatio-temporal point processes
<a href="https://arxiv.org/pdf/2208.12026.pdf">https://arxiv.org/pdf/2208.12026.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lGCpp)
X &lt;- lGCpp[sample.int(200)] # A random subset
stIntensity &lt;- dens.direct(X, dimyx = 16, dimt = 4)
plot(spatstat.geom::as.solist(stIntensity), ncols = 4,
     main = 'Non-separable direct example', equal.ribbon = TRUE)


data(aegiss)
X &lt;- aegiss[sample.int(500)] # A random subset
stIntensity &lt;- dens.direct(X,
                           dimyx = 32, dimt = 16,
                           at = "bins")
plot(spatstat.geom::as.imlist(stIntensity[12:15]),
     main = 'Non-separable direct example')


</code></pre>

<hr>
<h2 id='dens.direct.sep'>Direct separable adaptive spatio-temporal intensity estimator</h2><span id='topic+dens.direct.sep'></span>

<h3>Description</h3>

<p>Provides an adaptive-bandwidth kernel estimate for spatio-temporal point patterns in a separable fashion, i.e., by multiplying spatial and temporal marginals. This estimation is performed by calculating the classical estimator, i.e., the slowest estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens.direct.sep(
  X,
  t = NULL,
  dimyx = 128,
  dimt = 128,
  bw.xy = NULL,
  bw.t = NULL,
  at = c("bins", "points")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens.direct.sep_+3A_x">X</code></td>
<td>
<p>A spatial point pattern (an object of class <code>ppp</code>) with the spatial coordinates of the observations. It may contain marks representing times.</p>
</td></tr>
<tr><td><code id="dens.direct.sep_+3A_t">t</code></td>
<td>
<p>A numeric vector of temporal coordinates with equal length to the number of points in <code>X</code>. This gives the time associated with each spatial point. This argument is not necessary if time marks are provided to the point pattern <code>X</code>.</p>
</td></tr>
<tr><td><code id="dens.direct.sep_+3A_dimyx">dimyx</code></td>
<td>
<p>Spatial pixel resolution. The default is 128 for each axes.</p>
</td></tr>
<tr><td><code id="dens.direct.sep_+3A_dimt">dimt</code></td>
<td>
<p>Temporal bin vector dimension. The default is 128.</p>
</td></tr>
<tr><td><code id="dens.direct.sep_+3A_bw.xy">bw.xy</code></td>
<td>
<p>Numeric vector of spatial smoothing bandwidths for each point in <code>X</code>. By default this is computed using <a href="spatstat.explore.html#topic+bw.abram">bw.abram</a>.</p>
</td></tr>
<tr><td><code id="dens.direct.sep_+3A_bw.t">bw.t</code></td>
<td>
<p>Numeric vector of temporal smoothing bandwidths for each point in <code>t</code>. By default this is computed using <a href="#topic+bw.abram.temp">bw.abram.temp</a>.</p>
</td></tr>
<tr><td><code id="dens.direct.sep_+3A_at">at</code></td>
<td>
<p>String specifying whether to estimate the intensity at a mesh (<code>at = "bins"</code>) or only at the points of <code>X</code> (<code>at = "points"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a spatio-temporal adaptive kernel estimate of the intensity in a separable fashion. It starts from a planar point pattern <code>X</code> and a vector of times <code>t</code> and uses a direct estimator for each dimension, then it multiplies both components and normalises by the number of points to preserve the mass.
The arguments <code>bw.xy</code> and <code>bw.t</code> specify the smoothing bandwidth vectors to be applied to each of the points in <code>X</code> and <code>t</code>. They should be a numeric vectors of bandwidths.
The method partition the range of bandwidths into intervals, subdividing the points of the pattern <code>X</code> and <code>t</code> into sub-patterns according to the bandwidths, and applying fixed-bandwidth smoothing to each sub-pattern. Specifying <code>ngroups.xy = 1</code> is the same as fixed-bandwidth smoothing with bandwidth <code>sigma = median(bw.xy)</code> in the spatial case and <code>ngroups.t = 1</code> is the same as fixed-bandwidth smoothing with bandwidth <code>sigma = median(bw.xy)</code>.
</p>


<h3>Value</h3>

<p>If <code>at = "points"</code>, the result is a numeric vector with one entry for each data point in <code>X</code>. if <code>at = "bins"</code> is a list named (by time-point) list of pixel images (<a href="spatstat.geom.html#topic+im">im</a> objects) corresponding to the joint spatio-temporal intensity over space at each discretised time bin.
</p>


<h3>Author(s)</h3>

<p>Jonatan A. González
</p>


<h3>References</h3>

<p>González J.A. and Moraga P. (2018)
An adaptive kernel estimator for the intensity function of spatio-temporal point processes
<a href="https://arxiv.org/pdf/2208.12026.pdf">https://arxiv.org/pdf/2208.12026.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(santander)
X &lt;- santander[sample.int(200)]
stIntensity &lt;- dens.direct.sep(X,
                               dimyx = 32, dimt = 6,
                               at = "bins")
plot(spatstat.geom::as.solist(stIntensity[2:4]),
     main = 'Direct separable example', equal.ribbon = TRUE)

</code></pre>

<hr>
<h2 id='dens.par'>Non-separable adaptive spatio-temporal intensity estimator</h2><span id='topic+dens.par'></span>

<h3>Description</h3>

<p>Provides an adaptive-bandwidth kernel estimate for spatio-temporal point patterns in a non-separable fashion by using binning of the bandwidth values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens.par(
  X,
  t = NULL,
  dimyx = 128,
  dimt = 128,
  bw.xy = NULL,
  bw.t = NULL,
  ngroups.xy = NULL,
  ngroups.t = NULL,
  at = c("bins", "points")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens.par_+3A_x">X</code></td>
<td>
<p>A spatial point pattern (an object of class <code>ppp</code>) with the spatial coordinates of the observations. It may contain marks representing times.</p>
</td></tr>
<tr><td><code id="dens.par_+3A_t">t</code></td>
<td>
<p>A numeric vector of temporal coordinates with equal length to the number of points in <code>X</code>. This gives the time associated with each spatial point. This argument is not necessary if time marks are provided to the point pattern <code>X</code>.</p>
</td></tr>
<tr><td><code id="dens.par_+3A_dimyx">dimyx</code></td>
<td>
<p>Spatial pixel resolution. The default is 128 for each axes.</p>
</td></tr>
<tr><td><code id="dens.par_+3A_dimt">dimt</code></td>
<td>
<p>Temporal bin vector dimension. The default is 128.</p>
</td></tr>
<tr><td><code id="dens.par_+3A_bw.xy">bw.xy</code></td>
<td>
<p>Numeric vector of spatial smoothing bandwidths for each point in <code>X</code>. By default this is computed using <a href="spatstat.explore.html#topic+bw.abram">bw.abram</a>.</p>
</td></tr>
<tr><td><code id="dens.par_+3A_bw.t">bw.t</code></td>
<td>
<p>Numeric vector of temporal smoothing bandwidths for each point in <code>t</code>. By default this is computed using <a href="#topic+bw.abram.temp">bw.abram.temp</a>.</p>
</td></tr>
<tr><td><code id="dens.par_+3A_ngroups.xy">ngroups.xy</code></td>
<td>
<p>Number of groups in which the spatial bandwidths should be partitioned. If this number is 1, then a classical non-adaptive estimator will be used for the spatial part with a bandwidth selected as the median of the bw.xy vector.</p>
</td></tr>
<tr><td><code id="dens.par_+3A_ngroups.t">ngroups.t</code></td>
<td>
<p>Number of groups in which the temporal bandwidths should be partitioned. If this number is 1, then a classical non-adaptive estimator will be used for the temporal part with a bandwidth selected as the median of the bw.t vector.</p>
</td></tr>
<tr><td><code id="dens.par_+3A_at">at</code></td>
<td>
<p>String specifying whether to estimate the intensity at a mesh (<code>at = "bins"</code>) or only at the points of <code>X</code> (<code>at = "points"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a non-separable spatio-temporal adaptive kernel estimate of the intensity. It starts from a planar point pattern <code>X</code> and a vector of times <code>t</code> and partition (cells) the spatial and temporal components to apply a non-separable kernel estimator within each cell.
The arguments <code>bw.xy</code> and <code>bw.t</code> specify the smoothing bandwidth vectors to be applied to each of the points in <code>X</code> and <code>t</code>. They should be a numeric vectors of bandwidths.
The method partition the range of bandwidths into intervals, subdividing the points of the pattern <code>X</code> and <code>t</code> into sub-patterns according to the bandwidths, and applying fixed-bandwidth smoothing to each sub-pattern. Specifying <code>ngroups.xy = 1</code> is the same as fixed-bandwidth smoothing with bandwidth <code>sigma = median(bw.xy)</code> in the spatial case and <code>ngroups.t = 1</code> is the same as fixed-bandwidth smoothing with bandwidth <code>sigma = median(bw.xy)</code>.
</p>


<h3>Value</h3>

<p>If <code>at = "points"</code> (the default), the result is a numeric vector with one entry for each data point in <code>X</code>. if <code>at = "bins"</code> is a list named (by time-point) list of pixel images (<a href="spatstat.geom.html#topic+im">im</a> objects) corresponding to the joint spatio-temporal intensity over space at each discretised time bin.
</p>


<h3>Author(s)</h3>

<p>Jonatan A. González
</p>


<h3>References</h3>

<p>González J.A. and Moraga P. (2018)
An adaptive kernel estimator for the intensity function of spatio-temporal point processes
<a href="https://arxiv.org/pdf/2208.12026.pdf">https://arxiv.org/pdf/2208.12026.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lGCpp)
stIntensity &lt;- dens.par(lGCpp, dimt = 16)
plot(spatstat.geom::as.solist(stIntensity[13:16]), ncols = 4,
     main = 'Non-separable Example', equal.ribbon = TRUE)

</code></pre>

<hr>
<h2 id='dens.par.sep'>Separable adaptive spatio-temporal intensity estimator</h2><span id='topic+dens.par.sep'></span>

<h3>Description</h3>

<p>Provides an adaptive-bandwidth kernel estimate for spatio-temporal point patterns in a separable fashion, i.e., by multiplying spatial and temporal marginals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens.par.sep(
  X,
  t = NULL,
  dimyx = 128,
  dimt = 128,
  bw.xy = NULL,
  bw.t = NULL,
  ngroups.xy = NULL,
  ngroups.t = NULL,
  at = c("bins", "points")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens.par.sep_+3A_x">X</code></td>
<td>
<p>A spatial point pattern (an object of class <code>ppp</code>) with the spatial coordinates of the observations. It may contain marks representing times.</p>
</td></tr>
<tr><td><code id="dens.par.sep_+3A_t">t</code></td>
<td>
<p>A numeric vector of temporal coordinates with equal length to the number of points in <code>X</code>. This gives the time associated with each spatial point. This argument is not necessary if time marks are provided to the point pattern <code>X</code>.</p>
</td></tr>
<tr><td><code id="dens.par.sep_+3A_dimyx">dimyx</code></td>
<td>
<p>Spatial pixel resolution. The default is 128 for each axes.</p>
</td></tr>
<tr><td><code id="dens.par.sep_+3A_dimt">dimt</code></td>
<td>
<p>Temporal bin vector dimension. The default is 128.</p>
</td></tr>
<tr><td><code id="dens.par.sep_+3A_bw.xy">bw.xy</code></td>
<td>
<p>Numeric vector of spatial smoothing bandwidths for each point in <code>X</code>. By default this is computed using <a href="spatstat.explore.html#topic+bw.abram">bw.abram</a>.</p>
</td></tr>
<tr><td><code id="dens.par.sep_+3A_bw.t">bw.t</code></td>
<td>
<p>Numeric vector of temporal smoothing bandwidths for each point in <code>t</code>. By default this is computed using <a href="#topic+bw.abram.temp">bw.abram.temp</a>.</p>
</td></tr>
<tr><td><code id="dens.par.sep_+3A_ngroups.xy">ngroups.xy</code></td>
<td>
<p>Number of groups in which the spatial bandwidths should be partitioned. If this number is 1, then a classical non-adaptive estimator will be used for the spatial part with a bandwidth selected as the median of the bw.xy vector.</p>
</td></tr>
<tr><td><code id="dens.par.sep_+3A_ngroups.t">ngroups.t</code></td>
<td>
<p>Number of groups in which the temporal bandwidths should be partitioned. If this number is 1, then a classical non-adaptive estimator will be used for the temporal part with a bandwidth selected as the median of the bw.t vector.</p>
</td></tr>
<tr><td><code id="dens.par.sep_+3A_at">at</code></td>
<td>
<p>String specifying whether to estimate the intensity at a mesh (<code>at = "bins"</code>) or only at the points of <code>X</code> (<code>at = "points"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a spatio-temporal adaptive kernel estimate of the intensity in a separable fashion. It starts from a planar point pattern <code>X</code> and a vector of times <code>t</code> and uses partition techniques separately for the spatial and temporal components, then it multiplies both components and normalises by the number of points to preserve the mass.
The arguments <code>bw.xy</code> and <code>bw.t</code> specify the smoothing bandwidth vectors to be applied to each of the points in <code>X</code> and <code>t</code>. They should be a numeric vectors of bandwidths.
The method partition the range of bandwidths into intervals, subdividing the points of the pattern <code>X</code> and <code>t</code> into sub-patterns according to the bandwidths, and applying fixed-bandwidth smoothing to each sub-pattern. Specifying <code>ngroups.xy = 1</code> is the same as fixed-bandwidth smoothing with bandwidth <code>sigma = median(bw.xy)</code> in the spatial case and <code>ngroups.t = 1</code> is the same as fixed-bandwidth smoothing with bandwidth <code>sigma = median(bw.xy)</code>.
</p>


<h3>Value</h3>

<p>If <code>at = "points"</code> (the default), the result is a numeric vector with one entry for each data point in <code>X</code>. if <code>at = "bins"</code> is a list named (by time-point) list of pixel images (<a href="spatstat.geom.html#topic+im">im</a> objects) corresponding to the joint spatio-temporal intensity over space at each discretised time bin.
</p>


<h3>Author(s)</h3>

<p>Jonatan A. González
</p>


<h3>References</h3>

<p>González J.A. and Moraga P. (2018)
An adaptive kernel estimator for the intensity function of spatio-temporal point processes
<a href="https://arxiv.org/pdf/2208.12026.pdf">https://arxiv.org/pdf/2208.12026.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(santander)
stIntensity &lt;- dens.par.sep(santander,
                            dimt = 16,
                            ngroups.xy = 3, ngroups.t = 2,
                            at = "bins")
plot(spatstat.geom::as.solist(stIntensity[12:15]), ncols = 4,
     main = 'Separable Example', equal.ribbon = TRUE)

</code></pre>

<hr>
<h2 id='dens.par.temp'>Adaptive kernel estimate of intensity of a temporal point pattern</h2><span id='topic+dens.par.temp'></span>

<h3>Description</h3>

<p>Estimates the intensity of a point process with only temporal dimension by applying an adaptive (variable bandwidth) Gaussian edge-corrected kernel smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens.par.temp(
  t,
  dimt = 128,
  bw.t = NULL,
  ngroups.t = NULL,
  at = c("bins", "points")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens.par.temp_+3A_t">t</code></td>
<td>
<p>Temporal point pattern, a vector with observations.</p>
</td></tr>
<tr><td><code id="dens.par.temp_+3A_dimt">dimt</code></td>
<td>
<p>Bin vector dimension. The default is 128.</p>
</td></tr>
<tr><td><code id="dens.par.temp_+3A_bw.t">bw.t</code></td>
<td>
<p>Numeric vector of smoothing bandwidths for each point in t. The default is to compute bandwidths using <a href="#topic+bw.abram.temp">bw.abram.temp</a>.</p>
</td></tr>
<tr><td><code id="dens.par.temp_+3A_ngroups.t">ngroups.t</code></td>
<td>
<p>Number of groups into which the bandwidths should be partitioned and discretised. The default is the square root (rounded) of the number of points of <code>t</code>.</p>
</td></tr>
<tr><td><code id="dens.par.temp_+3A_at">at</code></td>
<td>
<p>String specifying whether to estimate the intensity at bins points (<code>at = "bins"</code>) or only at the points of t (<code>at = "points"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a temporally-adaptive kernel estimate of the intensity from a one-dimensional point pattern t using the partitioning technique of Davies and Baddeley (2018).
The argument bw.t specifies the smoothing bandwidths to be applied to each of the points in X. It should be a numeric vector of bandwidths.
Let the points of <code class="reqn">t</code> be <code class="reqn">t_1, ..., t_n</code> and the corresponding bandwidths <code class="reqn">\sigma_1,...,\sigma_n</code>, then the adaptive kernel estimate of intensity at a location <code class="reqn">v</code> is
</p>
<p style="text-align: center;"><code class="reqn">\lambda(v) = \sum_{i=1}^n \frac{K(v,t_i; \sigma_i)}{c(t; \sigma_i)}</code>
</p>

<p>where <code class="reqn">K()</code> is the Gaussian smoothing kernel.
The method partition the range of bandwidths into ngroups.t intervals, correspondingly subdividing the points of the pattern <code>t</code> into ngroups.t sub-patterns according to bandwidth, and applying fixed-bandwidth smoothing to each sub-pattern. Specifying <code>ngroups.t = 1</code> is the same as fixed-bandwidth smoothing with bandwidth <code>sigma = median(bw.t)</code>.
</p>


<h3>Value</h3>

<p>If <code>at = "points"</code> (the default), the result is a numeric vector with one entry for each data point in <code>t</code>. If <code>at = "bins"</code> the result is a data.frame containing the <code class="reqn">x,y</code> coordinates of the intensity function.
</p>


<h3>Author(s)</h3>

<p>Jonatan A. González
</p>


<h3>References</h3>

<p>Davies, T.M. and Baddeley, A. (2018) Fast computation of spatially adaptive kernel estimates. Statistics and Computing, 28(4), 937-956.
</p>
<p>González J.A. and Moraga P. (2018)
An adaptive kernel estimator for the intensity function of spatio-temporal point processes
<a href="https://arxiv.org/pdf/2208.12026.pdf">https://arxiv.org/pdf/2208.12026.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- rbeta(100, 1,4,0.8)
tIntensity &lt;- dens.par.temp(t, at = "bins")
plot(tIntensity$x, tIntensity$y, type = "l")

</code></pre>

<hr>
<h2 id='lGCpp'>
Simulated spatio-temporal log Gaussian Cox point pattern data
</h2><span id='topic+lGCpp'></span>

<h3>Description</h3>

<p>A simulated spatio-temporal log Gaussian Cox point pattern with a underlying non-separable Geneiting covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("lGCpp")</code></pre>


<h3>Format</h3>

<p>An object of class <code>"ppp"</code>
Entries include
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>x</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">x</code>-coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>y</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">y</code>-coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>marks</code> </td><td style="text-align: left;"> A vector of values indicating the times </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>window</code> </td><td style="text-align: left;"> Cartesian coordinates of the unit square
    </td>
</tr>

</table>

<p>See <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> for details of the format.
</p>


<h3>References</h3>

<p>Gabriel E, Rowlingson B, Diggle PJ (2013). <code>stpp:</code> An R Package for Plotting, Simulating and Analyzing Spatio-Temporal Point Patterns. <em>Journal of Statistical Software,</em> <b>(53)(2)</b>(2), 1–29. <br />
</p>
<p>González J.A. and Moraga P. (2018)
An adaptive kernel estimator for the intensity function of spatio-temporal point processes.
&lt;arXiv:2208.12026&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lGCpp)
head(lGCpp)
plot(lGCpp, bg = rainbow(250), pch = 21, cex = 1)
</code></pre>

<hr>
<h2 id='santander'>
Santander earthquakes epicentres
</h2><span id='topic+santander'></span>

<h3>Description</h3>

<p>A spatio-temporal point pattern of locations and times of earthquake epicentres in Santander-Colombia with a magnitude above 3.5ML, recorded from January 2010 to December 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("santander")</code></pre>


<h3>Format</h3>

<p>An object of class <code>"ppp"</code>
Entries include
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>x</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">x</code>-coordinate of infection </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>y</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">y</code>-coordinate of infection </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>marks</code> </td><td style="text-align: left;"> An integer vector of values indicating the time
of the earthquake starting in <code>1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>window</code> </td><td style="text-align: left;"> Cartesian coordinates of Santander's map
    </td>
</tr>

</table>

<p>See <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> for details of the format.
</p>


<h3>Source</h3>

<p>Colombian national geologic institute, <a href="https://www.sgc.gov.co/">https://www.sgc.gov.co/</a>
</p>


<h3>References</h3>

<p>González et. al., (2021) Classification of Events Using Local Pair Correlation Functions for Spatial Point Patterns. <em>Journal of Agricultural, Biological and Environmental Statistics.</em> <b>26(4)</b> 538-559.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(santander)
head(santander)
plot(santander, bg = rainbow(250), pch = 21, cex = 1)
</code></pre>

<hr>
<h2 id='separability.test'>Separability test for spatio-temporal point processes</h2><span id='topic+separability.test'></span>

<h3>Description</h3>

<p>Performs a separability test of the first-order intensity function based on a Fisher Monte Carlo test of cell counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separability.test(X, t = NULL, nx = NULL, ny = NULL, nt = NULL, nperm = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separability.test_+3A_x">X</code></td>
<td>
<p>A spatial point pattern (an object of class <code>ppp</code>) with the spatial coordinates of the observations.</p>
</td></tr>
<tr><td><code id="separability.test_+3A_t">t</code></td>
<td>
<p>A numeric vector of temporal coordinates with equal length to the number of points in <code>X</code>. This gives the time associated with each spatial point.</p>
</td></tr>
<tr><td><code id="separability.test_+3A_nx">nx</code>, <code id="separability.test_+3A_ny">ny</code>, <code id="separability.test_+3A_nt">nt</code></td>
<td>
<p>Numbers of quadrats in the <code class="reqn">x,y</code> and <code class="reqn">t</code> directions.</p>
</td></tr>
<tr><td><code id="separability.test_+3A_nperm">nperm</code></td>
<td>
<p>An integer specifying the number of replicates used in the Monte Carlo test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a basic test of the separability hypothesis in a manner similar to independence test in two-way contingency tables.
The test is conditional on the observed number of points.
It considers a regular division of the interval <code class="reqn">T</code> into disjoint sub-intervals <code class="reqn">T_1,...,T_{n_t}</code> and similarly a division of the window <code class="reqn">W</code> into disjoint subsets <code class="reqn">W_1, ..., W{n_x \times n_y}</code>.
Then the function computes Fisher's test statistic and get a p-value based on Monte Carlos approximation.
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>the approximate p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string &quot;Separability test based on Fisher's for counting data&quot;.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a fast preliminary separability test.
</p>


<h3>Author(s)</h3>

<p>Jonatan A. González
</p>


<h3>References</h3>

<p>Ghorbani et al. (2021) Testing the first-order separability hypothesis for spatio-temporal point patterns,
<em>Computational Statistics &amp; Data Analysis,</em> <b>161</b>, p.107245.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lGCpp)
separability.test(lGCpp, nx = 5, ny = 4, nt = 3, nperm = 500)


data(aegiss)
separability.test(aegiss, nx = 8, ny = 8, nt = 4)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
