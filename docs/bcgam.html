<!DOCTYPE html><html><head><title>Help for package bcgam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bcgam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bcgam'><p>Fitting Bayesian Constrained Generalised Additive Models</p></a></li>
<li><a href='#duncan'><p>Duncan's occupational prestige data</p></a></li>
<li><a href='#persp.bcgam'><p>3D plots for <span class="pkg">bcgam</span> fits</p></a></li>
<li><a href='#plot.bcgam'><p>2D plots for <span class="pkg">bcgam</span> fits</p></a></li>
<li><a href='#predict.bcgam'><p>Predict method for <span class="pkg">bcgam</span> fits</p></a></li>
<li><a href='#sm.conc'><p>Specify a smooth and concave shape-restriction in a <span class="pkg">bcgam</span> formula</p></a></li>
<li><a href='#sm.conv'><p>Specify a smooth and convex shape-restriction in a <span class="pkg">bcgam</span> formula</p></a></li>
<li><a href='#sm.decr'><p>Specify a smooth and decreasing shape-restriction in a <span class="pkg">bcgam</span> formula</p></a></li>
<li><a href='#sm.decr.conc'><p>Specify a smooth, decreasing and concave shape-restriction in a <span class="pkg">bcgam</span> formula</p></a></li>
<li><a href='#sm.decr.conv'><p>Specify a smooth, decreasing and convex shape-restriction in a <span class="pkg">bcgam</span> formula</p></a></li>
<li><a href='#sm.incr'><p>Specify a smooth and increasing shape-restriction in a <span class="pkg">bcgam</span> formula</p></a></li>
<li><a href='#sm.incr.conc'><p>Specify a smooth, increasing and concave shape-restriction in a <span class="pkg">bcgam</span> formula</p></a></li>
<li><a href='#sm.incr.conv'><p>Specify a smooth, increasing and convex shape-restriction in a <span class="pkg">bcgam</span> formula</p></a></li>
<li><a href='#summary.bcgam'><p>Summarizing <span class="pkg">bcgam</span> fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Constrained Generalised Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits generalised partial linear regression models using a Bayesian approach, where shape and
			smoothness constraints are imposed on nonparametrically modelled predictors through shape-restricted splines, and 
			no constraints are imposed on optional parametrically modelled covariates. See Meyer et al. (2011) &lt;doi/10.1080/10485252.2011.597852&gt; 
			for more details. IMPORTANT: before installing 'bcgam', you need to install 'Rtools' (Windows) or 'Xcode' (Mac OS X). These are	
			required for the correct installation of 'nimble' (<a href="https://r-nimble.org/download">https://r-nimble.org/download</a>). 			</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2), nimble (&ge; 0.6-9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, igraph, coda</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Rtools (&gt;= 3.3) for Windows, Xcode (&gt;= 9.0) for Mac
OS X</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-03-17 17:38:44 UTC; boliche</td>
</tr>
<tr>
<td>Author:</td>
<td>Cristian Oliva-Aviles [aut, cre],
  Mary C. Meyer [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cristian Oliva-Aviles &lt;coliva@colostate.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-03-18 22:06:50 UTC</td>
</tr>
</table>
<hr>
<h2 id='bcgam'>Fitting Bayesian Constrained Generalised Additive Models</h2><span id='topic+bcgam'></span>

<h3>Description</h3>

<p><code>bcgam</code> is used to fit generalised partial linear regression models using a Bayesian 
approach, where shape and smoothness constraints are imposed on nonparametrically modelled predictors 
through shape-restricted splines, and no constraints are imposed on optional parametrically modelled covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcgam(formula, family = gaussian(), data = NULL, nloop = 10000,
  burnin = trunc(nloop/10))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcgam_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> that contains a symbolic description of the model to be fitted.
It has the form &quot;response~nonparam+param&quot;, where &quot;nonparam&quot; are the predictors to be modelled
nonparametrically and &quot;param&quot; are the optional predictors to be modelled parametrically. The user
has to specify the relationship between the systematic component <code class="reqn">\eta</code> and any nonparametrically modelled
predictor <code class="reqn">x</code>. The options are:
</p>

<ul>
<li><p> sm.incr(x): <code class="reqn">x</code> is smooth and increasing in <code class="reqn">\eta</code>. See <code><a href="#topic+sm.incr">sm.incr</a></code> for more details.
</p>
</li>
<li><p> sm.decr(x): <code class="reqn">x</code> is smooth and decreasing in <code class="reqn">\eta</code>. See <code><a href="#topic+sm.decr">sm.decr</a></code> for more details.
</p>
</li>
<li><p> sm.conv(x): <code class="reqn">x</code> is smooth and convex in <code class="reqn">\eta</code>. See <code><a href="#topic+sm.conv">sm.conv</a></code> for more details.
</p>
</li>
<li><p> sm.conc(x): <code class="reqn">x</code> is smooth and concave in <code class="reqn">\eta</code>. See <code><a href="#topic+sm.conc">sm.conc</a></code> for more details.
</p>
</li>
<li><p> sm.incr.conv(x): <code class="reqn">x</code> is smooth, increasing and convex in <code class="reqn">\eta</code>. See <code><a href="#topic+sm.incr.conv">sm.incr.conv</a></code> for more details.
</p>
</li>
<li><p> sm.decr.conv(x): <code class="reqn">x</code> is smooth, decreasing and convex in <code class="reqn">\eta</code>. See <code><a href="#topic+sm.decr.conv">sm.decr.conv</a></code> for more details.
</p>
</li>
<li><p> sm.incr.conc(x): <code class="reqn">x</code> is smooth, increasing and concave in <code class="reqn">\eta</code>. See <code><a href="#topic+sm.incr.conc">sm.incr.conc</a></code> for more details.
</p>
</li>
<li><p> sm.decr.conc(x): <code class="reqn">x</code> is smooth, decreasing and concave in <code class="reqn">\eta</code>. See <code><a href="#topic+sm.decr.conc">sm.decr.conc</a></code> for more details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bcgam_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. This accepts
only the following families: <code>"gaussian"</code> (normal errors model), <code>"binomial"</code> (logistic model), and 
<code>"poisson"</code> (Poisson model). See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.</p>
</td></tr>
<tr><td><code id="bcgam_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables in the model. The default is <code>"NULL"</code>.</p>
</td></tr>
<tr><td><code id="bcgam_+3A_nloop">nloop</code></td>
<td>
<p>length of the MCMC. The default is <code>10000</code>.</p>
</td></tr>
<tr><td><code id="bcgam_+3A_burnin">burnin</code></td>
<td>
<p>a positive value, smaller than <code>nloop</code>, that indicates the amount of initial
MCMC values to be discarded. By default, it burns-in the first 10% chain values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume the additive model for each systematic component element <code class="reqn">\eta_i</code> given by
</p>
<p style="text-align: center;"><code class="reqn">\eta_i = f_1(x_{1i}) + ... + f_L(x_{Li}) + z_i'\gamma,</code>
</p>
<p> where <code class="reqn">z_i</code> is a vector
of variables to be modelled parametrically and <code class="reqn">\gamma</code> is a parameter vector. The functions
<code class="reqn">f_l</code> of the continuous predictors <code class="reqn">x_l</code> are assumed to be smooth, and shape restrictions
such as monotonicity and/or convexity might be assumed. Generally, the vector <code class="reqn">\eta=(\eta_1, ..., \eta_n)'</code>
is approximated by </p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^{m_1}\beta_{1j}\delta_{1j} + ... + \sum_{j=1}^{m_L}\beta_{Lj}\delta_{Lj} 
+ \sum_{j=1}^{p}\alpha_j\nu_j,</code>
</p>
<p> where <code class="reqn">\beta_{lj} \ge 0</code> for all <code class="reqn">l,j</code>. The <code class="reqn">\delta</code>'s represent
the basis vectors used to approximate the <code class="reqn">f</code> functions. The <code class="reqn">\nu_j</code> consists of the
one vector and the vectors of the observed values of covariates to be modelled parametrically. In addition, 
when <code class="reqn">f_l</code> is assumed to be convex, the <code class="reqn">x_l</code> vector is included as one of the <code class="reqn">\nu_j</code>.
</p>
<p>A Bayesian approach is considered for estimation and inference of the model above. As the <code class="reqn">\beta</code>
coefficients are constrained to be non-negative, then a gamma prior with hyperparameters <code class="reqn">c_{l1}</code> (shape)
and <code class="reqn">c_{l2}</code> (scale) is assumed for each <code class="reqn">\beta_{lj}</code>. The values <code class="reqn">c_{l1}</code> and <code class="reqn">c_{l2}</code> are
chosen in a way that a large variance can be combined with a small mean, so that it is close to a 
non-informative gamma prior. Further, a normal prior distribution with mean zero and large variance <code class="reqn">M</code>
is considered for the <code class="reqn">\alpha</code> coefficients.
</p>
<p><code>bcgam</code> makes use of the system &quot;nimble&quot; to set the Bayesian (hierarchical) model and compute the MCMC. Hence, 
&quot;nimble&quot; has to be loaded in <code>R</code> to be able to use <code>bcgam</code>. Information about how to download
and install &quot;nimble&quot; can be found at <a href="https://r-nimble.org">https://r-nimble.org</a>.
</p>


<h3>Value</h3>

<p><code>bcgam</code> returns an object of class &quot;bcgam&quot;.
</p>
<p>The generic routines <code>summary</code> and <code>print</code> are used to obtain and print a summary
of the results. Further, 2D and 3D plots can be created using <code>plot</code> and <code>persp</code>, respectively.
</p>
<p>An object of class &quot;bcgam&quot; is a list containing at least the following components:
</p>
<table>
<tr><td><code>coefs</code></td>
<td>
<p>a vector of posterior means of the <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> coefficients.</p>
</td></tr> 
<tr><td><code>sd.coefs</code></td>
<td>
<p>a vector of posterior standard errors of the <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> coefficients.</p>
</td></tr> 
<tr><td><code>etahat</code></td>
<td>
<p>a vector of posterior means of the systematic component <code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code>muhat</code></td>
<td>
<p>a vector of posterior means of <code class="reqn">\mu</code>. <code class="reqn">\mu</code> is obtained by 
transforming <code class="reqn">\eta</code> using the inverse of the link function.</p>
</td></tr>
<tr><td><code>alpha.sims</code></td>
<td>
<p>a matrix of posterior samples (after burn-in) of the <code class="reqn">\alpha</code> coefficients.</p>
</td></tr>
<tr><td><code>beta.sims</code></td>
<td>
<p>a matrix of posterior samples (after burn-in) of the <code class="reqn">\beta</code> coefficients.</p>
</td></tr>
<tr><td><code>sigma.sims</code></td>
<td>
<p>a matrix of posterior samples (after burn-in) of <code class="reqn">\sigma</code>. This is only
shown when <code>family="gaussian"</code>. </p>
</td></tr>
<tr><td><code>eta.sims</code></td>
<td>
<p>a matrix of posterior samples (after burn-in) of the systematic component <code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code>mu.sims</code></td>
<td>
<p>a matrix of posterior samples (after burn-in) of <code class="reqn">\mu</code>.
<code class="reqn">\mu</code> is obtained by transforming <code class="reqn">\eta</code> using the inverse of the link function.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>a matrix that contains the basis functions <code class="reqn">\delta</code> in its columns. </p>
</td></tr>
<tr><td><code>zmat</code></td>
<td>
<p>a matrix that contains the vectors <code class="reqn">\nu</code> in its columns. </p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>a list of the knots.</p>
</td></tr>
<tr><td><code>shapes</code></td>
<td>
<p>a list of numbers that indicate the shape categories.</p>
</td></tr>
<tr><td><code>sps</code></td>
<td>
<p>a character vector of the space parameter used to create the knots.</p>
</td></tr>
<tr><td><code>nloop</code></td>
<td>
<p>the length of the MCMC.</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>the burn-in value.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family parameter.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. 
<em>Annals of Applied Statistics</em> <strong>2(3)</strong>, 1013-1033.
</p>
<p>Meyer, M. C., Hackstadt, A. J., and Hoeting J. A. (2011) Bayesian estimation and inference for 
generalised partial linear models using shape-restricted splines. <em>Journal of Nonparametric
Statistics</em> <strong>23(4)</strong>, 867-884.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.bcgam">predict.bcgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1 (gaussian)
data(duncan)

bcgam.fit &lt;- bcgam(income~sm.incr(prestige, space="E")+sm.conv(education)+type, data=duncan)
print(bcgam.fit)
summary(bcgam.fit)
plot(bcgam.fit, prestige, col=4)
persp(bcgam.fit, prestige, education, level=0.90)


## Example 2 (poisson)
set.seed(2018)
n&lt;-50
x1&lt;-sqrt(1:n)
z&lt;-as.factor(rbinom(n, 1, 0.5))
log.eta&lt;-x1/7+0.2*as.numeric(z)+rnorm(50, sd=0.6)
eta&lt;-exp(log.eta)
y&lt;-rpois(n,eta)

bcgam.fit &lt;- bcgam(y~sm.conv(x1)+z, family="poisson")
summary(bcgam.fit)
predict(bcgam.fit, newdata=data.frame(x1=0.2, z="0"), interval="credible")
plot(bcgam.fit, x1, col=3, col.inter=4)

## End(Not run)
</code></pre>

<hr>
<h2 id='duncan'>Duncan's occupational prestige data</h2><span id='topic+duncan'></span>

<h3>Description</h3>

<p>The <code>duncan</code> data frame has 45 rows and columns. Data on the
prestige and other charachteristics of 45 U. S. occupations in 1950.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duncan
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<ul>
<li> <p><strong>type</strong>. Type of occupation. A factor with the following levels:
<code>prof</code>, professional and managerial; <code>wc</code>, white-collar;
<code>bc</code>, blue-collar.
</p>
</li>
<li> <p><strong>income</strong>. Percent of males in occupation earning $3500 or more in 1950.
</p>
</li>
<li> <p><strong>education</strong>. Percent of males in occupation in 1950 who where high-school graduates.
</p>
</li>
<li> <p><strong>prestige</strong>. Percent of raters in NORC study rating occupation as excellent or 
good in prestige.
</p>
</li></ul>


<h3>Source</h3>

<p>Duncan, O. D. (1961) A socioeconomic index for all occupations.
In Reiss, A. J. Jr. (Ed.) <em>Occupations and Social Status</em>. Free Press [Table VI-1].
</p>

<hr>
<h2 id='persp.bcgam'>3D plots for <span class="pkg">bcgam</span> fits</h2><span id='topic+persp.bcgam'></span>

<h3>Description</h3>

<p>3D plots of fitted surface with credible interval estimates based on a <code>bcgam</code> object and two non-parametrically
modelled predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bcgam'
persp(x, x1, x2, parameter = "mu", level = 0.95,
  x1.grid = 10, x2.grid = 10, lty = 1, lty.inter = 1,
  ticktype = "detailed", col = 4, col.inter = col, surf.inter = TRUE,
  zlim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp.bcgam_+3A_x">x</code></td>
<td>
<p>Object of class inheriting from &quot;bcgam&quot;.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_x1">x1</code></td>
<td>
<p>A non-parametrically modelled predictor in a bcgam fit. The predictor in the <code class="reqn">x</code> axis. There is no default variable.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_x2">x2</code></td>
<td>
<p>A non-parametrically modelled predictor in a bcgam fit. The predictor in the <code class="reqn">y</code> axis. There is no default variable.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_parameter">parameter</code></td>
<td>
<p>The type of parameter to be plotted. If parameter=<code>"eta"</code>, then the systematic component
<code class="reqn">\eta</code> is plotted. If parameter=<code>"mu"</code>, then the mean value <code class="reqn">\mu</code> obtained by transforming
<code class="reqn">\eta</code> using the inverse of the link function is plotted. The default is <code>"mu"</code>.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_level">level</code></td>
<td>
<p>Tolerance/credible level. The default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_x1.grid">x1.grid</code></td>
<td>
<p>A positive integer that specifies how dense the <code class="reqn">x</code> grid will be. The default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_x2.grid">x2.grid</code></td>
<td>
<p>A positive integer that specifies how dense the <code class="reqn">y</code> grid will be. The default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_lty">lty</code></td>
<td>
<p>What type of surface edges should be drawn for fitted values. The default is a solid line (<code>1</code>).</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_lty.inter">lty.inter</code></td>
<td>
<p>What type of surface edges should be drawn for interval estimates. The default is a solid line (<code>1</code>).</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_ticktype">ticktype</code></td>
<td>
<p>character: &quot;detailed&quot; draws normal ticks; &quot;simple&quot; draws just an arrow parallel to the
axis to indicate direction of increase. The default is <code>"detailed"</code>.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_col">col</code></td>
<td>
<p>Color of fitted surface. The default is blue (<code>4</code>).</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_col.inter">col.inter</code></td>
<td>
<p>Color of interval estimates. If not specified, it takes the
same value as <code>col</code>.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_surf.inter">surf.inter</code></td>
<td>
<p>Indicator to draw interval estimates (<code>"TRUE"</code>) or not (<code>"FALSE"</code>). 
The default is <code>"TRUE"</code>.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_zlim">zlim</code></td>
<td>
<p>The <code>z</code> limits of the plot. If <code>zlim=NULL</code> and <code>surf.inter="TRUE"</code>, 
then the minimum value of the lower bound estimates and the maximum value of the upper bound estimates are used.
If <code>zlim=NULL</code> and <code>surf.inter="FALSE"</code>, then the minimum and maximum values of the fitted surface are used.
The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="persp.bcgam_+3A_...">...</code></td>
<td>
<p>additional graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>persp.bcgam</code> produces 3D plots based on the <code>bcgam</code> object. Interval
estimates are based on the specified <code>level</code>. 
</p>
<p>If there are more than two non-parametrically modelled predictors,
then these will be evaluated at the largest values that are smaller than or equal 
to their median values. Categorical covariates will be evaluated at their mode. Also,
continuous covariates will be evaluated at the largest values that are smaller than
or equal to their median values.
</p>
<p>This routine creates 3D plots based on the posterior distribution in the <code>bcgam</code> object.
</p>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n&lt;-50
x1&lt;-(1:n/n)^{1/3}
x2&lt;-log(1:n/n)
z&lt;-as.factor(rbinom(n, 1, 0.6))
eta&lt;-x1+x2+0.2*as.numeric(z)+rnorm(n, sd=0.2)
mu&lt;-exp(eta)/(1+exp(eta))
y&lt;-(mu&lt;0.6)

bcgam.fit &lt;- bcgam(y~sm.incr(x1)+sm.conc(x2, numknots=8)+z, nloop=10000, family="binomial")
persp(bcgam.fit, x1, x2, parameter="eta", col.inter=2, level=0.90, theta=-55)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.bcgam'>2D plots for <span class="pkg">bcgam</span> fits</h2><span id='topic+plot.bcgam'></span>

<h3>Description</h3>

<p>2D plots of predicted values with interval estimates based on a <code>bcgam</code> object and one non-parametrically
modelled predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bcgam'
plot(x, x1, interval = "credible", parameter = "mu",
  x1.grid = 100, level = 0.95, type = "l", col = 1, col.inter = col,
  lty = 1, lty.inter = 2, lwd = 1, lwd.inter = lwd, ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bcgam_+3A_x">x</code></td>
<td>
<p>Object of class inheriting from &quot;bcgam&quot;.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_x1">x1</code></td>
<td>
<p>A non-parametrically modelled predictor in a bcgam fit. There is no default variable.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_interval">interval</code></td>
<td>
<p>Type of interval to plot. It can be either <code>"credible"</code> or <code>"prediction"</code>.
<code>interval="prediction"</code> only works for the gaussian family. In this case, the predictive posterior distribution is plotted. 
The default is <code>"credible"</code>.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_parameter">parameter</code></td>
<td>
<p>The type of parameter to be plotted. If parameter=<code>"eta"</code>, then the systematic component
<code class="reqn">\eta</code> is plotted. If parameter=<code>"mu"</code>, then the mean value <code class="reqn">\mu</code> obtained by transforming
<code class="reqn">\eta</code> using the inverse of the link function is plotted. The default is <code>"mu"</code>. 
If <code>interval="prediction"</code>, then this variable is ignored.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_x1.grid">x1.grid</code></td>
<td>
<p>A positive integer that specifies how dense the <code class="reqn">x</code> grid will be. The default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_level">level</code></td>
<td>
<p>Tolerance/credible level. The default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn. The default is for lines (<code>"l"</code>).</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_col">col</code></td>
<td>
<p>Color of fitted values. The default is black (<code>1</code>).</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_col.inter">col.inter</code></td>
<td>
<p>Color of interval estimates. If not specified, it takes the
same value as <code>col</code>.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_lty">lty</code></td>
<td>
<p>What type of line should be drawn for fitted values. Ignored when a line is not being drawn. 
The default is a solid line (<code>1</code>).</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_lty.inter">lty.inter</code></td>
<td>
<p>What type of line should be drawn for interval estimates. The default is a dotted line (<code>2</code>).</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_lwd">lwd</code></td>
<td>
<p>The line width of fitted values, a positive number, defaulting to <code>1</code>.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_lwd.inter">lwd.inter</code></td>
<td>
<p>The line width of interval estimates, a positive number, defaulting to <code>1</code>.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_ylim">ylim</code></td>
<td>
<p>The <code>y</code> limits of the plot. If <code>ylim=NULL</code>, then the minimum value
of the lower bound estimates and the maximum value of the upper bound estimates are used.
The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.bcgam_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.bcgam</code> produces 2D plots based on the <code>bcgam</code> object. Interval
estimates are based on the specified <code>level</code>. 
</p>
<p>If there are more than one non-parametrically modelled predictors,
then these will be evaluated at the largest values that are smaller than or equal 
to their median values. Categorical covariates will be evaluated at their mode. Also,
continuous covariates will be evaluated at the largest values that are smaller than
or equal to their median values.
</p>
<p>This routine creates 2D plots based on the posterior distribution in the <code>bcgam</code> object.
</p>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n&lt;-50
x1&lt;-(1:n/n)^{1/3}
x2&lt;-log(1:n/n)
z&lt;-as.factor(rbinom(n, 1, 0.6))
eta&lt;-x1+x2+0.2*as.numeric(z)+rnorm(n, sd=0.2)
mu&lt;-exp(eta)/(1+exp(eta))
y&lt;-(mu&lt;0.6)

bcgam.fit &lt;- bcgam(y~sm.incr(x1)+sm.conc(x2, numknots=8)+z, nloop=10000, family="binomial")
plot(bcgam.fit, x1, parameter="mu", col=4, level=0.90)
plot(bcgam.fit, x2, parameter="eta", col=3, col.inter=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.bcgam'>Predict method for <span class="pkg">bcgam</span> fits</h2><span id='topic+predict.bcgam'></span>

<h3>Description</h3>

<p>Predicted values based on <span class="pkg">bcgam</span> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bcgam'
predict(object, newdata, interval = c("credible"),
  level = 0.95, parameter = c("mu"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bcgam_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;bcgam&quot;.</p>
</td></tr>
<tr><td><code id="predict.bcgam_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variable with which to predict.</p>
</td></tr>
<tr><td><code id="predict.bcgam_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation. It can be either <code>"credible"</code> or <code>"prediction"</code>.
If <code>interval=prediction</code>, then a summary of the predictive posterior distribution is shown.</p>
</td></tr>
<tr><td><code id="predict.bcgam_+3A_level">level</code></td>
<td>
<p>Tolerance/credible level. The default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="predict.bcgam_+3A_parameter">parameter</code></td>
<td>
<p>The type of parameter to predict. If parameter=<code>"eta"</code>, then the systematic component
<code class="reqn">\eta</code> is predicted. If parameter=<code>"mu"</code>, then the mean value <code class="reqn">\mu</code> obtained by transforming
<code class="reqn">\eta</code> using the inverse of the link function is predicted. The default is <code class="reqn">\mu</code>. If 
<code>interval="prediction"</code>, then this variable is ignored.</p>
</td></tr>
<tr><td><code id="predict.bcgam_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.bcgam</code> produces estimated values, standard errors,
and interval estimates; obtained by the
fitted model in the frame <code>newdata</code>. Setting <code>intervals</code> 
specifies computation of credible or prediction (tolerance) intervals at the
specified <code>level</code>. 
</p>
<p>All predictions are based on the posterior distribution in the <code>bcgam</code> object.
</p>


<h3>Value</h3>

<p><code>predict.bcgam</code> produces a list of predictions, standard errors, and bounds based
on the posterior disitribution in the <code>bcgam</code> object.
</p>
<p>If <code>interval="credible"</code>, a list with the following components is returned:
</p>
<table>
<tr><td><code>cred.mean</code></td>
<td>
<p>the mean values.</p>
</td></tr>
<tr><td><code>cred.sd</code></td>
<td>
<p>standard error of mean values.</p>
</td></tr>
<tr><td><code>cred.lower</code></td>
<td>
<p>lower bound of mean values.</p>
</td></tr>
<tr><td><code>cred.upper</code></td>
<td>
<p>upper bound of mean values.</p>
</td></tr>
</table>
<p>If <code>interval="prediction"</code>, a list with the following components is returned:
</p>
<table>
<tr><td><code>pred.mean</code></td>
<td>
<p>the predicted values.</p>
</td></tr>
<tr><td><code>pred.sd</code></td>
<td>
<p>standard error of predicted values.</p>
</td></tr>
<tr><td><code>pred.lower</code></td>
<td>
<p>lower bound of predicted values.</p>
</td></tr>
<tr><td><code>pred.upper</code></td>
<td>
<p>upper bound of predicted values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n&lt;-50
x&lt;-(1:n)^{1/3}
z&lt;-as.factor(rbinom(n, 1, 0.6))
y&lt;-x+7*as.numeric(z)+rnorm(n,sd=2) 
bcgam.fit &lt;- bcgam(y~sm.incr(x)+z, nloop=100)
predict(bcgam.fit, newdata=data.frame(x=0.5, z="1"), parameter="mu", interval="prediction")

## End(Not run)
</code></pre>

<hr>
<h2 id='sm.conc'>Specify a smooth and concave shape-restriction in a <span class="pkg">bcgam</span> formula</h2><span id='topic+sm.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is
smooth and concave with respect to a predictor in a bcgam formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm.conc(x, numknots = 0, knots = 0, space = "Q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm.conc_+3A_x">x</code></td>
<td>
<p>a numeric predictor of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sm.conc_+3A_numknots">numknots</code></td>
<td>
<p>number of knots used to constrain <code>x</code>. It is ignored when the <code>knots</code>
argument is specified by the user. If neither <code>numknots</code> nor <code>knots</code> are specified by the user,
then <code>numknots</code> is <code class="reqn">floor{4+n^(1/7)}</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.conc_+3A_knots">knots</code></td>
<td>
<p>knots used to constrain <code>x</code>. If they are not specified by the user, then they will 
be automatically created based on <code>numknots</code> and <code>space</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.conc_+3A_space">space</code></td>
<td>
<p>a character specifying the method to create knots. It is ignored when the <code>knots</code>
argument is specified by the user. If <code>space="E"</code>, then equally spaced knots will be created; 
if <code>space="Q"</code>, then a vector of equal quantiles will be created based on <code>x</code>
with duplicate elements removed. The default is <code>"Q"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sm.conc</code> returns the vector <code>x</code> and assigns five attributes to it: name, shape (4 for  
&quot;smooth and concave&quot;), numknots, knots and space. 
</p>
<p>This routine does not create the splines basis vectors by itself.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The numeric predictor <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. 
<em>Annals of Applied Statistics</em> <strong>2(3)</strong>, 1013-1033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(duncan)

prestige &lt;- duncan$prestige

# specify knots
sm.conc(prestige, knots=c(3,9,30,57,86,97))

# specify number of knots
prestige.smconc &lt;- sm.conc(prestige, numknots=7)

# check attributes
attributes(prestige.smconc)
</code></pre>

<hr>
<h2 id='sm.conv'>Specify a smooth and convex shape-restriction in a <span class="pkg">bcgam</span> formula</h2><span id='topic+sm.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is
smooth and convex with respect to a predictor in a bcgam formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm.conv(x, numknots = 0, knots = 0, space = "Q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm.conv_+3A_x">x</code></td>
<td>
<p>a numeric predictor of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sm.conv_+3A_numknots">numknots</code></td>
<td>
<p>number of knots used to constrain <code>x</code>. It is ignored when the <code>knots</code>
argument is specified by the user. If neither <code>numknots</code> nor <code>knots</code> are specified by the user,
then <code>numknots</code> is <code class="reqn">floor{4+n^(1/7)}</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.conv_+3A_knots">knots</code></td>
<td>
<p>knots used to constrain <code>x</code>. If they are not specified by the user, then they will 
be automatically created based on <code>numknots</code> and <code>space</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.conv_+3A_space">space</code></td>
<td>
<p>a character specifying the method to create knots. It is ignored when the <code>knots</code>
argument is specified by the user. If <code>space="E"</code>, then equally spaced knots will be created; 
if <code>space="Q"</code>, then a vector of equal quantiles will be created based on <code>x</code>
with duplicate elements removed. The default is <code>"Q"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sm.conv</code> returns the vector <code>x</code> and assigns five attributes to it: name, shape (3 for  
&quot;smooth and convex&quot;), numknots, knots and space. 
</p>
<p>This routine does not create the splines basis vectors by itself.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>the numeric predictor <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. 
<em>Annals of Applied Statistics</em> <strong>2(3)</strong>, 1013-1033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(duncan)

prestige &lt;- duncan$prestige

# specify knots
sm.conv(prestige, knots=c(3,9,30,57,86,97))

# specify number of knots
prestige.smconv &lt;- sm.conv(prestige, numknots=7)

# check attributes
attributes(prestige.smconv)
</code></pre>

<hr>
<h2 id='sm.decr'>Specify a smooth and decreasing shape-restriction in a <span class="pkg">bcgam</span> formula</h2><span id='topic+sm.decr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is
smooth and decreasing with respect to a predictor in a bcgam formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm.decr(x, numknots = 0, knots = 0, space = "Q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm.decr_+3A_x">x</code></td>
<td>
<p>a numeric predictor of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sm.decr_+3A_numknots">numknots</code></td>
<td>
<p>number of knots used to constrain <code>x</code>. It is ignored when the <code>knots</code>
argument is specified by the user. If neither <code>numknots</code> nor <code>knots</code> are specified by the user,
then <code>numknots</code> is <code class="reqn">floor{4+n^(1/7)}</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.decr_+3A_knots">knots</code></td>
<td>
<p>knots used to constrain <code>x</code>. If they are not specified by the user, then they will 
be automatically created based on <code>numknots</code> and <code>space</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.decr_+3A_space">space</code></td>
<td>
<p>a character specifying the method to create knots. It is ignored when the <code>knots</code>
argument is specified by the user. If <code>space="E"</code>, then equally spaced knots will be created; 
if <code>space="Q"</code>, then a vector of equal quantiles will be created based on <code>x</code>
with duplicate elements removed. The default is <code>"Q"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sm.decr</code> returns the vector <code>x</code> and assigns five attributes to it: name, shape (2 for  
&quot;smooth and decreasing&quot;), numknots, knots and space. 
</p>
<p>This routine does not create the splines basis vectors by itself.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The numeric predictor <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. 
<em>Annals of Applied Statistics</em> <strong>2(3)</strong>, 1013-1033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(duncan)

prestige &lt;- duncan$prestige

# specify knots
sm.decr(prestige, knots=c(3,9,30,57,86,97))

# specify number of knots
prestige.smdecr &lt;- sm.decr(prestige, numknots=7)

# check attributes
attributes(prestige.smdecr)
</code></pre>

<hr>
<h2 id='sm.decr.conc'>Specify a smooth, decreasing and concave shape-restriction in a <span class="pkg">bcgam</span> formula</h2><span id='topic+sm.decr.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is
smooth, decreasing and concave with respect to a predictor in a bcgam formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm.decr.conc(x, numknots = 0, knots = 0, space = "Q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm.decr.conc_+3A_x">x</code></td>
<td>
<p>a numeric predictor of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sm.decr.conc_+3A_numknots">numknots</code></td>
<td>
<p>number of knots used to constrain <code>x</code>. It is ignored when the <code>knots</code>
argument is specified by the user. If neither <code>numknots</code> nor <code>knots</code> are specified by the user,
then <code>numknots</code> is <code class="reqn">floor{4+n^(1/7)}</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.decr.conc_+3A_knots">knots</code></td>
<td>
<p>knots used to constrain <code>x</code>. If they are not specified by the user, then they will 
be automatically created based on <code>numknots</code> and <code>space</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.decr.conc_+3A_space">space</code></td>
<td>
<p>a character specifying the method to create knots. It is ignored when the <code>knots</code>
argument is specified by the user. If <code>space="E"</code>, then equally spaced knots will be created; 
if <code>space="Q"</code>, then a vector of equal quantiles will be created based on <code>x</code>
with duplicate elements removed. The default is <code>"Q"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sm.decr.conc</code> returns the vector <code>x</code> and assigns five attributes to it: name, shape (8 for  
&quot;smooth, decreasing and concave&quot;), numknots, knots and space. 
</p>
<p>This routine does not create the splines basis vectors by itself.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The numeric predictor <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. 
<em>Annals of Applied Statistics</em> <strong>2(3)</strong>, 1013-1033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(duncan)

prestige &lt;- duncan$prestige

# specify knots
sm.decr.conc(prestige, knots=c(3,9,30,57,86,97))

# specify number of knots
prestige.smdecrconc &lt;- sm.decr.conc(prestige, numknots=7)

# check attributes
attributes(prestige.smdecrconc)
</code></pre>

<hr>
<h2 id='sm.decr.conv'>Specify a smooth, decreasing and convex shape-restriction in a <span class="pkg">bcgam</span> formula</h2><span id='topic+sm.decr.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is
smooth, decreasing and convex with respect to a predictor in a bcgam formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm.decr.conv(x, numknots = 0, knots = 0, space = "Q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm.decr.conv_+3A_x">x</code></td>
<td>
<p>a numeric predictor of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sm.decr.conv_+3A_numknots">numknots</code></td>
<td>
<p>number of knots used to constrain <code>x</code>. It is ignored when the <code>knots</code>
argument is specified by the user. If neither <code>numknots</code> nor <code>knots</code> are specified by the user,
then <code>numknots</code> is <code class="reqn">floor{4+n^(1/7)}</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.decr.conv_+3A_knots">knots</code></td>
<td>
<p>knots used to constrain <code>x</code>. If they are not specified by the user, then they will 
be automatically created based on <code>numknots</code> and <code>space</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.decr.conv_+3A_space">space</code></td>
<td>
<p>a character specifying the method to create knots. It is ignored when the <code>knots</code>
argument is specified by the user. If <code>space="E"</code>, then equally spaced knots will be created; 
if <code>space="Q"</code>, then a vector of equal quantiles will be created based on <code>x</code>
with duplicate elements removed. The default is <code>"Q"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sm.decr.conv</code> returns the vector <code>x</code> and assigns five attributes to it: name, shape (7 for  
&quot;smooth, decreasing and convex&quot;), numknots, knots and space. 
</p>
<p>This routine does not create the splines basis vectors by itself.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The numeric predictor <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. 
<em>Annals of Applied Statistics</em> <strong>2(3)</strong>, 1013-1033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(duncan)

prestige &lt;- duncan$prestige

# specify knots
sm.decr.conv(prestige, knots=c(3,9,30,57,86,97))

# specify number of knots
prestige.smdecrconv &lt;- sm.decr.conv(prestige, numknots=7)

# check attributes
attributes(prestige.smdecrconv)
</code></pre>

<hr>
<h2 id='sm.incr'>Specify a smooth and increasing shape-restriction in a <span class="pkg">bcgam</span> formula</h2><span id='topic+sm.incr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is
smooth and increasing with respect to a predictor in a bcgam formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm.incr(x, numknots = 0, knots = 0, space = "Q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm.incr_+3A_x">x</code></td>
<td>
<p>a numeric predictor of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sm.incr_+3A_numknots">numknots</code></td>
<td>
<p>number of knots used to constrain <code>x</code>. It is ignored when the <code>knots</code>
argument is specified by the user. If neither <code>numknots</code> nor <code>knots</code> are specified by the user,
then <code>numknots</code> is <code class="reqn">floor{4+n^(1/7)}</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.incr_+3A_knots">knots</code></td>
<td>
<p>knots used to constrain <code>x</code>. If they are not specified by the user, then they will 
be automatically created based on <code>numknots</code> and <code>space</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.incr_+3A_space">space</code></td>
<td>
<p>a character specifying the method to create knots. It is ignored when the <code>knots</code>
argument is specified by the user. If <code>space="E"</code>, then equally spaced knots will be created; 
if <code>space="Q"</code>, then a vector of equal quantiles will be created based on <code>x</code>
with duplicate elements removed. The default is <code>"Q"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sm.incr</code> returns the vector <code>x</code> and assigns five attributes to it: name, shape (1 for  
&quot;smooth and increasing&quot;), numknots, knots and space. 
</p>
<p>This routine does not create the splines basis vectors by itself.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The numeric predictor <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. 
<em>Annals of Applied Statistics</em> <strong>2(3)</strong>, 1013-1033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(duncan)

prestige &lt;- duncan$prestige

# specify knots
sm.incr(prestige, knots=c(3,9,30,57,86,97))

# specify number of knots
prestige.smincr &lt;- sm.incr(prestige, numknots=7)

# check attributes
attributes(prestige.smincr)
</code></pre>

<hr>
<h2 id='sm.incr.conc'>Specify a smooth, increasing and concave shape-restriction in a <span class="pkg">bcgam</span> formula</h2><span id='topic+sm.incr.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is
smooth, increasing and concave with respect to a predictor in a bcgam formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm.incr.conc(x, numknots = 0, knots = 0, space = "Q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm.incr.conc_+3A_x">x</code></td>
<td>
<p>a numeric predictor of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sm.incr.conc_+3A_numknots">numknots</code></td>
<td>
<p>number of knots used to constrain <code>x</code>. It is ignored when the <code>knots</code>
argument is specified by the user. If neither <code>numknots</code> nor <code>knots</code> are specified by the user,
then <code>numknots</code> is <code class="reqn">floor{4+n^(1/7)}</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.incr.conc_+3A_knots">knots</code></td>
<td>
<p>knots used to constrain <code>x</code>. If they are not specified by the user, then they will 
be automatically created based on <code>numknots</code> and <code>space</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.incr.conc_+3A_space">space</code></td>
<td>
<p>a character specifying the method to create knots. It is ignored when the <code>knots</code>
argument is specified by the user. If <code>space="E"</code>, then equally spaced knots will be created; 
if <code>space="Q"</code>, then a vector of equal quantiles will be created based on <code>x</code>
with duplicate elements removed. The default is <code>"Q"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sm.incr.conc</code> returns the vector <code>x</code> and assigns five attributes to it: name, shape (1 for  
&quot;smooth, increasing and concave&quot;), numknots, knots and space. 
</p>
<p>This routine does not create the splines basis vectors by itself.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The numeric predictor <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. 
<em>Annals of Applied Statistics</em> <strong>2(3)</strong>, 1013-1033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(duncan)

prestige &lt;- duncan$prestige

# specify knots
sm.incr.conc(prestige, knots=c(3,9,30,57,86,97))

# specify number of knots
prestige.smincrconc &lt;- sm.incr.conc(prestige, numknots=7)

# check attributes
attributes(prestige.smincrconc)
</code></pre>

<hr>
<h2 id='sm.incr.conv'>Specify a smooth, increasing and convex shape-restriction in a <span class="pkg">bcgam</span> formula</h2><span id='topic+sm.incr.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the systematic component <code class="reqn">\eta</code> is
smooth, increasing and convex with respect to a predictor in a bcgam formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm.incr.conv(x, numknots = 0, knots = 0, space = "Q")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm.incr.conv_+3A_x">x</code></td>
<td>
<p>a numeric predictor of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="sm.incr.conv_+3A_numknots">numknots</code></td>
<td>
<p>number of knots used to constrain <code>x</code>. It is ignored when the <code>knots</code>
argument is specified by the user. If neither <code>numknots</code> nor <code>knots</code> are specified by the user,
then <code>numknots</code> is <code class="reqn">floor{4+n^(1/7)}</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.incr.conv_+3A_knots">knots</code></td>
<td>
<p>knots used to constrain <code>x</code>. If they are not specified by the user, then they will 
be automatically created based on <code>numknots</code> and <code>space</code>. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="sm.incr.conv_+3A_space">space</code></td>
<td>
<p>a character specifying the method to create knots. It is ignored when the <code>knots</code>
argument is specified by the user. If <code>space="E"</code>, then equally spaced knots will be created; 
if <code>space="Q"</code>, then a vector of equal quantiles will be created based on <code>x</code>
with duplicate elements removed. The default is <code>"Q"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sm.incr.conv</code> returns the vector <code>x</code> and assigns five attributes to it: name, shape (5 for  
&quot;smooth, increasing and convex&quot;), numknots, knots and space. 
</p>
<p>This routine does not create the splines basis vectors by itself.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The numeric predictor <code>x</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008) Inference using shape-restricted regression splines. 
<em>Annals of Applied Statistics</em> <strong>2(3)</strong>, 1013-1033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(duncan)

prestige &lt;- duncan$prestige

# specify knots
sm.incr.conv(prestige, knots=c(3,9,30,57,86,97))

# specify number of knots
prestige.smincrconv &lt;- sm.incr.conv(prestige, numknots=7)

# check attributes
attributes(prestige.smincrconv)
</code></pre>

<hr>
<h2 id='summary.bcgam'>Summarizing <span class="pkg">bcgam</span> fits</h2><span id='topic+summary.bcgam'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"bcgam"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bcgam'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bcgam_+3A_object">object</code></td>
<td>
<p>an object of class <code>"bcgam"</code>.</p>
</td></tr>
<tr><td><code id="summary.bcgam_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All summary statistics are based on the posterior distribution in the <code>bcgam</code> object.
</p>


<h3>Value</h3>

<p>The function <code>summary.bcgam</code> computes and return a list of summary
statistics (estimated mean, standard error, 95% bounds, estimated median) of the fitted <code>bcgam</code> given in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Cristian Oliva-Aviles and Mary C. Meyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n&lt;-50
x&lt;-(1:n)^{1/3}
z&lt;-as.factor(rbinom(n, 1, 0.6))
y&lt;-x+7*as.numeric(z)+rnorm(n,sd=2) 
bcgam.fit &lt;- bcgam(y~sm.incr(x)+z, nloop=100)
summary(bcgam.fit)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
