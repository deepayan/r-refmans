<!DOCTYPE html><html><head><title>Help for package derivmkts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {derivmkts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arithasianmc'><p>Asian Monte Carlo option pricing</p></a></li>
<li><a href='#arithavgpricecv'><p>Control variate asian call price</p></a></li>
<li><a href='#asiangeomavg'><p>Geometric average asian options</p></a></li>
<li><a href='#barriers'><p>Barrier option pricing</p></a></li>
<li><a href='#binom'><p>Binomial option pricing</p></a></li>
<li><a href='#blksch'><p>Black-Scholes option pricing</p></a></li>
<li><a href='#bondsimple'><p>Simple Bond Functions</p></a></li>
<li><a href='#compound'><p>Compound options</p></a></li>
<li><a href='#geomasianmc'><p>Geometric Asian option prices computed by Monte Carlo</p></a></li>
<li><a href='#greeks'><p>Calculate option Greeks</p></a></li>
<li><a href='#implied'><p>Black-Scholes implied volatility and price</p></a></li>
<li><a href='#jumps'><p>Option pricing with jumps</p></a></li>
<li><a href='#perpetual'><p>Perpetual American options</p></a></li>
<li><a href='#quincunx'><p>Quincunx simulation</p></a></li>
<li><a href='#simprice'><p>Simulate asset prices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functions and R Code to Accompany Derivatives Markets</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert McDonald [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert McDonald &lt;rmcd1024@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of pricing and expository functions that should
    be useful in teaching a course on financial derivatives.</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, grDevices, mnormt</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>markdown, knitr, rmarkdown, ggplot2, dplyr, tidyr, pander,
bookdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, ggplot2, dplyr, tidyr, pander, bookdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-11 14:36:37 UTC; rmcd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-11 15:32:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='arithasianmc'>Asian Monte Carlo option pricing</h2><span id='topic+arithasianmc'></span>

<h3>Description</h3>

<p>Monte Carlo pricing calculations for European Asian
options.  <code>arithasianmc</code> and <code>geomasianmc</code> compute
Monte Carlo prices for the full range of average price and
average strike call and puts computes prices of a complete
assortment of Arithmetic Asian options (average price call and
put and average strike call and put)
</p>
<p>Arithmetic average Asian option prices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arithasianmc(s, k, v, r, tt, d, m, numsim=1000, printsds=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arithasianmc_+3A_s">s</code></td>
<td>
<p>Price of underlying asset</p>
</td></tr>
<tr><td><code id="arithasianmc_+3A_k">k</code></td>
<td>
<p>Strike price of the option. In the case of average strike
options, <code>k/s</code> is the multiplier for the average</p>
</td></tr>
<tr><td><code id="arithasianmc_+3A_v">v</code></td>
<td>
<p>Volatility of the underlygin asset price, defined as the
annualized standard deviation of the continuously-compounded
return</p>
</td></tr>
<tr><td><code id="arithasianmc_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="arithasianmc_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="arithasianmc_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="arithasianmc_+3A_m">m</code></td>
<td>
<p>Number of prices in the average calculation</p>
</td></tr>
<tr><td><code id="arithasianmc_+3A_numsim">numsim</code></td>
<td>
<p>Number of Monte Carlo iterations</p>
</td></tr>
<tr><td><code id="arithasianmc_+3A_printsds">printsds</code></td>
<td>
<p>Print standard deviation for the particular Monte
Carlo calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of arithmetic average option prices, along with
vanilla European option prices implied by the the
simulation. Optionally returns Monte Carlo standard deviations.
</p>


<h3>See Also</h3>

<p>Other Asian: 
<code><a href="#topic+arithavgpricecv">arithavgpricecv</a>()</code>,
<code><a href="#topic+asiangeomavg">asiangeomavg</a></code>,
<code><a href="#topic+geomasianmc">geomasianmc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08; tt=0.25; d=0; m=3; numsim=1e04
arithasianmc(s, k, v, r, tt, d, m, numsim, printsds=TRUE)
</code></pre>

<hr>
<h2 id='arithavgpricecv'>Control variate asian call price</h2><span id='topic+arithavgpricecv'></span>

<h3>Description</h3>

<p>Calculation of arithmetic-average Asian call price
using control variate Monte Carlo valuation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arithavgpricecv(s, k, v, r, tt, d, m, numsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arithavgpricecv_+3A_s">s</code></td>
<td>
<p>Price of underlying asset</p>
</td></tr>
<tr><td><code id="arithavgpricecv_+3A_k">k</code></td>
<td>
<p>Strike price of the option. In the case of average strike
options, <code>k/s</code> is the multiplier for the average</p>
</td></tr>
<tr><td><code id="arithavgpricecv_+3A_v">v</code></td>
<td>
<p>Volatility of the underlygin asset price, defined as the
annualized standard deviation of the continuously-compounded
return</p>
</td></tr>
<tr><td><code id="arithavgpricecv_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="arithavgpricecv_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="arithavgpricecv_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="arithavgpricecv_+3A_m">m</code></td>
<td>
<p>Number of prices in the average calculation</p>
</td></tr>
<tr><td><code id="arithavgpricecv_+3A_numsim">numsim</code></td>
<td>
<p>Number of Monte Carlo iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of the price of an arithmetic-average Asian call,
computed using a control variate Monte Carlo calculation, along
with the regression beta used for adjusting the price.
</p>


<h3>See Also</h3>

<p>Other Asian: 
<code><a href="#topic+arithasianmc">arithasianmc</a>()</code>,
<code><a href="#topic+asiangeomavg">asiangeomavg</a></code>,
<code><a href="#topic+geomasianmc">geomasianmc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08; tt=0.25; d=0; m=3; numsim=1e04
arithavgpricecv(s, k, v, r, tt, d, m, numsim)
</code></pre>

<hr>
<h2 id='asiangeomavg'>Geometric average asian options</h2><span id='topic+asiangeomavg'></span><span id='topic+geomavgprice'></span><span id='topic+geomavgpricecall'></span><span id='topic+geomavgpriceput'></span><span id='topic+geomavgstrike'></span><span id='topic+geomavgstrikecall'></span><span id='topic+geomavgstrikeput'></span>

<h3>Description</h3>

<p>Pricing functions for European Asian options based on
geometric averages. <code>geomavgpricecall</code>,
<code>geomavgpriceput</code>, <code>geomavgstrikecall</code> and
<code>geomavgstrikeput</code> compute analytical prices of geometric
Asian options using the modified Black-Scholes formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomavgprice(s, k, v, r, tt, d, m, cont=FALSE)
geomavgpricecall(s, k, v, r, tt, d, m, cont=FALSE)
geomavgpriceput(s, k, v, r, tt, d, m, cont=FALSE)
geomavgstrike(s, km, v, r, tt, d, m, cont=FALSE)
geomavgstrikecall(s, km, v, r, tt, d, m, cont=FALSE)
geomavgstrikeput(s, km, v, r, tt, d, m, cont=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asiangeomavg_+3A_s">s</code></td>
<td>
<p>Price of underlying asset</p>
</td></tr>
<tr><td><code id="asiangeomavg_+3A_k">k</code></td>
<td>
<p>Strike price of the option. In the case of average strike
options, <code>k/s</code> is the multiplier for the average</p>
</td></tr>
<tr><td><code id="asiangeomavg_+3A_v">v</code></td>
<td>
<p>Volatility of the underlygin asset price, defined as the
annualized standard deviation of the continuously-compounded
return</p>
</td></tr>
<tr><td><code id="asiangeomavg_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="asiangeomavg_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="asiangeomavg_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="asiangeomavg_+3A_m">m</code></td>
<td>
<p>Number of prices in the average calculation</p>
</td></tr>
<tr><td><code id="asiangeomavg_+3A_cont">cont</code></td>
<td>
<p>Boolean which when TRUE denotes continuous averaging</p>
</td></tr>
<tr><td><code id="asiangeomavg_+3A_km">km</code></td>
<td>
<p>The strike mutiplier, relative to the initial stock
price, for an average price payoff. If the initial stock price
is <code>s = 120</code> and <code>km = 115</code>, the payoff for an
average strike call is </p>
<p style="text-align: center;"><code class="reqn">Payoff = max(ST - km/s*SAvg, 0)</code>
</p>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Option prices as a vector
</p>


<h3>See Also</h3>

<p>Other Asian: 
<code><a href="#topic+arithasianmc">arithasianmc</a>()</code>,
<code><a href="#topic+arithavgpricecv">arithavgpricecv</a>()</code>,
<code><a href="#topic+geomasianmc">geomasianmc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08; tt=0.25; d=0; m=3;
geomavgpricecall(s, k, v, r, tt, d, m)
geomavgpricecall(s, 38:42, v, r, tt, d, m)
geomavgpricecall(s, 38:42, v, r, tt, d, m, cont=TRUE)

</code></pre>

<hr>
<h2 id='barriers'>Barrier option pricing</h2><span id='topic+barriers'></span><span id='topic+cashdicall'></span><span id='topic+callupin'></span><span id='topic+callupout'></span><span id='topic+putupin'></span><span id='topic+putupout'></span><span id='topic+calldownin'></span><span id='topic+calldownout'></span><span id='topic+putdownin'></span><span id='topic+putdownout'></span><span id='topic+uicall'></span><span id='topic+uocall'></span><span id='topic+dicall'></span><span id='topic+docall'></span><span id='topic+uiput'></span><span id='topic+uoput'></span><span id='topic+diput'></span><span id='topic+doput'></span><span id='topic+cashuicall'></span><span id='topic+cashuiput'></span><span id='topic+cashdiput'></span><span id='topic+assetuicall'></span><span id='topic+assetuiput'></span><span id='topic+assetdicall'></span><span id='topic+assetdiput'></span><span id='topic+cashuocall'></span><span id='topic+cashuoput'></span><span id='topic+cashdocall'></span><span id='topic+cashdoput'></span><span id='topic+assetuocall'></span><span id='topic+assetuoput'></span><span id='topic+assetdocall'></span><span id='topic+assetdoput'></span><span id='topic+dr'></span><span id='topic+ur'></span><span id='topic+drdeferred'></span><span id='topic+urdeferred'></span>

<h3>Description</h3>

<p>This library provides a set of barrier binary options
that are used to construct prices of barrier options. The
nomenclature is that
</p>

<ul>
<li><p> &quot;call&quot; and &quot;put&quot; refer to claims that are exercised when the
asset price is above or below the strike;
</p>
</li>
<li><p> &quot;up&quot; and &quot;down&quot; refer to claims for which the barrier is above or
below the current asset price; and
</p>
</li>
<li><p> &quot;in&quot; and &quot;out&quot; refer to claims that knock in or out
</p>
</li></ul>

<p>For example, for standard barrier options, <code>calldownin</code> refers
to a knock-in call for which the barrier is below the current
price, while <code>putdownout</code> refers to a knock-out put for which
the barrier is below the current asset price.
</p>
<p>For binary barrier options, &quot;ui&quot;, &quot;di&quot; &quot;uo&quot;, and &quot;do&quot; refer to
up-and-in, down-and-in, up-and-out, and down-and-out options.
</p>
<p>Rebate options pay \$1 if a barrier is reached. The barrier can be
reached from above (&quot;d&quot;) or below (&quot;d&quot;), and the payment can occur
immediately (&quot;ur&quot; or &quot;dr&quot;) or at expiration (&quot;drdeferred&quot; and
&quot;urdeferred&quot;)
</p>
<p><code>callupin(s, k, v, r, tt, d, H) =  
assetuicall(s, k, v, r, tt, d, H) - k*cashuicall(s, k, v, r, tt, d, H)
</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callupin(s, k, v, r, tt, d, H)
callupout(s, k, v, r, tt, d, H)
putupin(s, k, v, r, tt, d, H)
putupout(s, k, v, r, tt, d, H)
calldownin(s, k, v, r, tt, d, H)
calldownout(s, k, v, r, tt, d, H)
putdownin(s, k, v, r, tt, d, H)
putdownout(s, k, v, r, tt, d, H)
uicall(s, k, v, r, tt, d, H) ## same as callupin
uocall(s, k, v, r, tt, d, H) ## same as callupout
uiput(s, k, v, r, tt, d, H)  ## same as putupin
uoput(s, k, v, r, tt, d, H)  ## same as putupout
dicall(s, k, v, r, tt, d, H) ## same as calldownin
docall(s, k, v, r, tt, d, H) ## same as calldownout
diput(s, k, v, r, tt, d, H)  ## same as putdownin
doput(s, k, v, r, tt, d, H)  ## same as putdownout
cashuicall(s, k, v, r, tt, d, H)
cashuiput(s, k, v, r, tt, d, H)
cashdicall(s, k, v, r, tt, d, H)
cashdiput(s, k, v, r, tt, d, H)
assetuicall(s, k, v, r, tt, d, H)
assetuiput(s, k, v, r, tt, d, H)
assetdicall(s, k, v, r, tt, d, H)
assetdiput(s, k, v, r, tt, d, H)
cashuocall(s, k, v, r, tt, d, H)
cashuoput(s, k, v, r, tt, d, H)
cashdocall(s, k, v, r, tt, d, H)
cashdoput(s, k, v, r, tt, d, H)
assetuocall(s, k, v, r, tt, d, H)
assetuoput(s, k, v, r, tt, d, H)
assetdocall(s, k, v, r, tt, d, H)
assetdoput(s, k, v, r, tt, d, H)
dr(s, v, r, tt, d, H, perpetual)
ur(s, v, r, tt, d, H, perpetual)
drdeferred(s, v, r, tt, d, H)
urdeferred(s, v, r, tt, d, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barriers_+3A_s">s</code></td>
<td>
<p>Stock price</p>
</td></tr>
<tr><td><code id="barriers_+3A_k">k</code></td>
<td>
<p>Strike price of the option</p>
</td></tr>
<tr><td><code id="barriers_+3A_v">v</code></td>
<td>
<p>Volatility of the stock, defined as the annualized
standard deviation of the continuously-compounded return</p>
</td></tr>
<tr><td><code id="barriers_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="barriers_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="barriers_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="barriers_+3A_h">H</code></td>
<td>
<p>Barrier</p>
</td></tr>
<tr><td><code id="barriers_+3A_perpetual">perpetual</code></td>
<td>
<p>Boolean for the case where an up or down rebate is
infinitely lived. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a scalar or vector  of option prices, depending on
the inputs
</p>


<h3>Value</h3>

<p>The pricing functions return the price of a barrier
claim. If more than one argument is a vector, the recycling rule
determines the handling of the inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08; tt=0.25; d=0; H=44
callupin(s, k, v, r, tt, d, H)

## following returns the same price as previous
assetuicall(s, k, v, r, tt, d, H) - k*cashuicall(s, k, v, r, tt, d, H)

## return option prices for different strikes putupin(s, k=38:42,
#v, r, tt, d, H)
</code></pre>

<hr>
<h2 id='binom'>Binomial option pricing</h2><span id='topic+binom'></span><span id='topic+binomopt'></span><span id='topic+binomplot'></span><span id='topic+binomial'></span>

<h3>Description</h3>

<p><code>binomopt</code> using the binomial pricing algorithm
to compute prices of European and American calls and puts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomopt(s, k, v, r, tt, d, nstep = 10, american = TRUE,
    putopt=FALSE, specifyupdn=FALSE, crr=FALSE, jarrowrudd=FALSE,
    up=1.5, dn=0.5, returntrees=FALSE, returnparams=FALSE,
    returngreeks=FALSE)

binomplot(s, k, v, r, tt, d, nstep, putopt=FALSE, american=TRUE,
    plotvalues=FALSE, plotarrows=FALSE, drawstrike=TRUE,
    pointsize=4, ylimval=c(0,0),
    saveplot = FALSE, saveplotfn='binomialplot.pdf',
    crr=FALSE, jarrowrudd=FALSE, titles=TRUE, specifyupdn=FALSE,
    up=1.5, dn=0.5, returnprice=FALSE, logy=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binom_+3A_s">s</code></td>
<td>
<p>Stock price</p>
</td></tr>
<tr><td><code id="binom_+3A_k">k</code></td>
<td>
<p>Strike price of the option</p>
</td></tr>
<tr><td><code id="binom_+3A_v">v</code></td>
<td>
<p>Volatility of the stock, defined as the annualized
standard deviation of the continuously-compounded return</p>
</td></tr>
<tr><td><code id="binom_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="binom_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="binom_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="binom_+3A_nstep">nstep</code></td>
<td>
<p>Number of binomial steps. Default is <code>nstep = 10</code></p>
</td></tr>
<tr><td><code id="binom_+3A_american">american</code></td>
<td>
<p>Boolean indicating if option is American</p>
</td></tr>
<tr><td><code id="binom_+3A_putopt">putopt</code></td>
<td>
<p>Boolean <code>TRUE</code> is the option is a put</p>
</td></tr>
<tr><td><code id="binom_+3A_specifyupdn">specifyupdn</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, manual entry of the
binomial parameters up and down. This overrides the <code>crr</code>
and <code>jarrowrudd</code> flags</p>
</td></tr>
<tr><td><code id="binom_+3A_crr">crr</code></td>
<td>
<p><code>TRUE</code> to use the Cox-Ross-Rubinstein tree</p>
</td></tr>
<tr><td><code id="binom_+3A_jarrowrudd">jarrowrudd</code></td>
<td>
<p><code>TRUE</code> to use the Jarrow-Rudd tree</p>
</td></tr>
<tr><td><code id="binom_+3A_up">up</code>, <code id="binom_+3A_dn">dn</code></td>
<td>
<p>If <code>specifyupdn=TRUE</code>, up and down moves on the
binomial tree</p>
</td></tr>
<tr><td><code id="binom_+3A_returntrees">returntrees</code></td>
<td>
<p>If <code>returntrees=TRUE</code>, the list returned by
the function includes four trees: for the price of the
underlying asset (stree), the option price (oppricetree), where
the option is exercised (exertree), and the probability of
being at each node. This parameter has no effect if
<code>returnparams=FALSE</code>, which is the default.</p>
</td></tr>
<tr><td><code id="binom_+3A_returnparams">returnparams</code></td>
<td>
<p>Return the vector of inputs and computed
pricing parameters as well as the price</p>
</td></tr>
<tr><td><code id="binom_+3A_returngreeks">returngreeks</code></td>
<td>
<p>Return time 0 delta, gamma, and theta in the
vector <code>greeks</code></p>
</td></tr>
<tr><td><code id="binom_+3A_plotvalues">plotvalues</code></td>
<td>
<p>display asset prices at nodes</p>
</td></tr>
<tr><td><code id="binom_+3A_plotarrows">plotarrows</code></td>
<td>
<p>draw arrows connecting pricing nodes</p>
</td></tr>
<tr><td><code id="binom_+3A_drawstrike">drawstrike</code></td>
<td>
<p>draw horizontal line at the strike price</p>
</td></tr>
<tr><td><code id="binom_+3A_pointsize">pointsize</code></td>
<td>
<p>CEX parameter for nodes</p>
</td></tr>
<tr><td><code id="binom_+3A_ylimval">ylimval</code></td>
<td>
<p><code>c(low, high)</code> for ylimit of the plot</p>
</td></tr>
<tr><td><code id="binom_+3A_saveplot">saveplot</code></td>
<td>
<p>boolean; save the plot to a pdf file named
<code>saveplotfn</code></p>
</td></tr>
<tr><td><code id="binom_+3A_saveplotfn">saveplotfn</code></td>
<td>
<p>file name for saved plot</p>
</td></tr>
<tr><td><code id="binom_+3A_titles">titles</code></td>
<td>
<p>automatically supply appropriate main title and x-
and y-axis labels</p>
</td></tr>
<tr><td><code id="binom_+3A_returnprice">returnprice</code></td>
<td>
<p>if <code>TRUE</code>, the <code>binomplot</code> function
returns the option price</p>
</td></tr>
<tr><td><code id="binom_+3A_logy">logy</code></td>
<td>
<p>(FALSE). If <code>TRUE</code>, y-axis is plotted on a log
scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>binomopt</code> returns an option
price. Optionally, it returns a vector of the parameters used
to compute the price, and if <code>returntrees=TRUE</code> it can
also return the following matrices, all but but two of which
have dimensionality <code class="reqn">(\textrm{nstep}+1)\times
    (\textrm{nstep}+ 1)</code>:
</p>

<dl>
<dt>stree</dt><dd><p>the binomial tree for the price of the underlying
asset.</p>
</dd>
<dt>oppricetree</dt><dd><p>the binomial tree for the option price at each
node</p>
</dd>
<dt>exertree</dt><dd><p>the tree of boolean indicators for whether or not
the option is exercisd at each node</p>
</dd>
<dt>probtree</dt><dd><p>the probability of reaching each node</p>
</dd>
<dt>delta</dt><dd><p>at each node prior to expiration, the number of units
of the underlying asset in the replicating portfolio. The
dimensionality is <code class="reqn">(\textrm{nstep})\times
    (\textrm{nstep})</code></p>
</dd>
<dt>bond</dt><dd><p>at each node prior to expiration, the bond position in
the replicating portfolio. The dimensionality is
<code class="reqn">(\textrm{nstep})\times (\textrm{nstep})</code></p>
</dd>
</dl>

<p><code>binomplot</code> plots the stock price lattice and shows
graphically the probability of being at each node (represented as
the area of the circle at that price) and whether or not the option
is optimally exercised there (green if yes, red if no), and
optionally, ht, depending on the inputs.
</p>


<h3>Value</h3>

<p>By default, <code>binomopt</code> returns the option price. If
<code>returnparams=TRUE</code>, it returns a list where <code>$price</code>
is the binomial option price and <code>$params</code> is a vector
containing the inputs and binomial parameters used to compute
the option price. Optionally, by specifying
<code>returntrees=TRUE</code>, the list can include the complete
asset price and option price trees, along with trees
representing the replicating portfolio over time. The  current
delta, gamma, and theta are also returned. If
<code>returntrees=FALSE</code> and <code>returngreeks=TRUE</code>, only the
current price, delta, gamma, and theta are returned. The function
<code>binomplot</code> produces a visual representation of the
binomial tree.
</p>


<h3>Note</h3>

<p>By default, <code>binomopt</code> computes the binomial tree using
up and down moves of </p>
<p style="text-align: center;"><code class="reqn">u=\exp((r-d)*h + \sigma\sqrt{h})</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">d=\exp((r-d)*h -
    \sigma\sqrt{h})</code>
</p>
<p> You can use
different trees: There is a boolean variable <code>CRR</code> to use
the Cox-Ross-Rubinstein pricing tree, and you can also supply
your own up and down moves with <code>specifyupdn=TRUE</code>. It's
important to realize that if you do specify the up and down
moves, you are overriding the volatility parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08; tt=0.25; d=0; nstep=15

binomopt(s, k, v, r, tt, d, nstep, american=TRUE, putopt=TRUE)

binomopt(s, k, v, r, tt, d, nstep, american=TRUE, putopt=TRUE,
    returnparams=TRUE)

## matches Fig 10.8 in 3rd edition of Derivatives Markets
x &lt;- binomopt(110, 100, .3, .05, 1, 0.035, 3, american=TRUE,
    returntrees=TRUE, returnparams=TRUE)
print(x$oppricretree)
print(x$delta)
print(x$bond)

binomplot(s, k, v, r, tt, d, nstep, american=TRUE, putopt=TRUE)

binomplot(s, k, v, r, tt, d, nstep, american=FALSE, putopt=TRUE)


</code></pre>

<hr>
<h2 id='blksch'>Black-Scholes option pricing</h2><span id='topic+blksch'></span><span id='topic+bscall'></span><span id='topic+bsput'></span><span id='topic+assetcall'></span><span id='topic+assetput'></span><span id='topic+cashcall'></span><span id='topic+cashput'></span>

<h3>Description</h3>

<p><code>bscall</code> and <code>bsput</code> compute Black-Scholes
call and put prices. The functions <code>assetcall</code>,
<code>assetput</code>, <code>cashcall</code>, and <code>cashput</code> provide the
prices of binary options that pay one share (the asset options) or $1
(the cash options) if at expiration the asset price exceeds the
strike (the calls) or is below the strike (the puts). We have the
identities
</p>
<p><code>bscall(s, k, v, r, tt, d)
  = assetcall(s, k, v, r, tt, d) - k*cashcall(s, k, v, r, tt, d)</code>
</p>
<p><code>bsput(s, k, v, r, tt, d)
  = k*cashput(s, k, v, r, tt, d) - assetput(s, k, v, r, tt, d)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bscall(s, k, v, r, tt, d)
bsput(s, k, v, r, tt, d)
assetcall(s, k, v, r, tt, d)
cashcall(s, k, v, r, tt, d)
assetput(s, k, v, r, tt, d)
cashput(s, k, v, r, tt, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blksch_+3A_s">s</code></td>
<td>
<p>Price of the underlying asset</p>
</td></tr>
<tr><td><code id="blksch_+3A_k">k</code></td>
<td>
<p>Strike price</p>
</td></tr>
<tr><td><code id="blksch_+3A_v">v</code></td>
<td>
<p>Volatility of the asset price, defined as the annualized
standard deviation of the continuously-compounded return</p>
</td></tr>
<tr><td><code id="blksch_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="blksch_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="blksch_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a scalar or vector of option prices, depending on
the inputs
</p>


<h3>Value</h3>

<p>A Black-Scholes option price. If more than one argument is a
vector, the recycling rule determines the handling of the inputs
</p>


<h3>Note</h3>

<p>It is possible to specify the inputs either in terms of an
interest rate and a &quot;dividend yield&quot; or an interest rate and a
&quot;cost of carry&quot;. In this package, the dividend yield should be
thought of as the cash dividend received by the owner of the
underlying asset, <em>or</em> (equivalently) as the payment received
if the owner were to lend the asset.
</p>
<p>There are other option pricing packages available for R, and these
may use different conventions for specifying inputs. In fOptions,
the dividend yield is replaced by the generalized cost of carry,
which is the net payment required to fund a position in the
underlying asset. If the interest rate is 10% and the dividend
yield is 3%, the generalized cost of carry is 7% (the part of the
interest payment not funded by the dividend payment). Thus, using
the <code>GBS</code> function from fOptions, these two expressions return
the same price:
</p>
<p><code>bscall(s, k, v, r, tt, d)</code>
</p>
<p><code>fOptions::GBSOption('c', S=s, K=k, Time=tt, r=r, b=r-d, sigma=v) </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08; tt=0.25; d=0;
bscall(s, k, v, r, tt, d)

## following returns the same price as previous
assetcall(s, k, v, r, tt, d) - k*cashcall(s, k, v, r, tt, d)

## return option prices for different strikes
bsput(s, k=38:42, v, r, tt, d)
</code></pre>

<hr>
<h2 id='bondsimple'>Simple Bond Functions</h2><span id='topic+bondsimple'></span><span id='topic+bondpv'></span><span id='topic+bondyield'></span><span id='topic+duration'></span><span id='topic+convexity'></span>

<h3>Description</h3>

<p>Basic yield, pricing, duration and convexity
calculations. These functions perform simple present value
calculations assuming that all periods between payments are the
same length. Unlike bond functions in Excel, for example,
settlement and maturity dates are not used. By default,
duration is Macaulay duration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bondpv(coupon, mat, yield, principal, freq)
bondyield(price, coupon, mat, principal, freq)
duration(price, coupon, mat, principal, freq, modified)
convexity(price, coupon, mat, principal, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bondsimple_+3A_coupon">coupon</code></td>
<td>
<p>annual coupon</p>
</td></tr>
<tr><td><code id="bondsimple_+3A_mat">mat</code></td>
<td>
<p>maturity in years</p>
</td></tr>
<tr><td><code id="bondsimple_+3A_yield">yield</code></td>
<td>
<p>annual yield to maturity. If freq &gt; 1, the yield is
freq times the per period yield.</p>
</td></tr>
<tr><td><code id="bondsimple_+3A_principal">principal</code></td>
<td>
<p>maturity payment of the bond, in addition to the
final coupon. Default value is $1,000. If the instrument is an
annuity, set principal to zero.</p>
</td></tr>
<tr><td><code id="bondsimple_+3A_freq">freq</code></td>
<td>
<p>number of payments per year.</p>
</td></tr>
<tr><td><code id="bondsimple_+3A_price">price</code></td>
<td>
<p>price of the bond</p>
</td></tr>
<tr><td><code id="bondsimple_+3A_modified">modified</code></td>
<td>
<p>If true, compute modified duration, otherwise
compute Macaulay duration. FALSE by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return price, yield, or duration/convexity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coupon &lt;- 6; mat &lt;- 20; freq &lt;- 2; principal &lt;- 100; yield &lt;- 0.045;

price &lt;- bondpv(coupon, mat, yield, principal, freq) # 119.7263
bondyield(coupon, mat, price=price, principal, freq) # 0.045
duration(price, coupon, mat, principal, freq, modified=FALSE) # 12.5043
duration(price, coupon, mat, principal, freq, modified=TRUE) # 12.3928
convexity(price, coupon, mat, principal, freq) # 205.3245

</code></pre>

<hr>
<h2 id='compound'>Compound options</h2><span id='topic+compound'></span><span id='topic+binormsdist'></span><span id='topic+optionsoncall'></span><span id='topic+optionsonput'></span><span id='topic+calloncall'></span><span id='topic+callonput'></span><span id='topic+putoncall'></span><span id='topic+putonput'></span>

<h3>Description</h3>

<p>A compound option is an option for which the
underlying asset is an option. The underlying option (the
option on which there is an option) in turn has an underlying
asset. The definition of a compound option requires specifying
</p>

<ul>
<li><p>whether you have the right to buy or sell an underlying option
</p>
</li>
<li><p>whether the underlying option (the option upon which there
is an option) is a put or a call
</p>
</li>
<li><p>the price at which you can buy or sell the underlying
option (strike price <code>kco</code> &mdash; the strike on the compound
option)
</p>
</li>
<li><p>the price at which you can buy or sell the underlying
asset should you exercise the compound option (strike price
<code>kuo</code> &mdash; the strike on the underlying option)
</p>
</li>
<li><p>the date at which you have the option to buy or sell the
underlying option (first exercise date, <code>t1</code>)
</p>
</li>
<li><p>the date at which the underlying option expires, <code>t2</code>
</p>
</li></ul>

<p>Given these possibilities, you can have a call on a call, a put on
a call, a call on a put, and a put on a put. The valuation
procedure require knowing, among other things, the underlying
asset price at which it will be worthwhile to acquire the
underlying option.
</p>
<p>Given the underlying option, there is a parity relationship: If you
buy a call on a call and sell a call on a call, you have acquired
the underlying call by paying the present value of the strike,
<code>kco</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binormsdist(x1, x2, rho)
optionsoncall(s, kuo, kco, v, r, t1, t2, d)
optionsonput(s, kuo, kco, v, r, t1, t2, d)
calloncall(s, kuo, kco, v, r, t1, t2, d, returnscritical)
callonput(s, kuo, kco, v, r, t1, t2, d, returnscritical)
putoncall(s, kuo, kco, v, r, t1, t2, d, returnscritical)
putonput(s, kuo, kco, v, r, t1, t2, d, returnscritical)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compound_+3A_s">s</code></td>
<td>
<p>Price of the asset on which the underlying option is
written</p>
</td></tr>
<tr><td><code id="compound_+3A_v">v</code></td>
<td>
<p>Volatility of the underlying asset, defined as the
annualized standard deviation of the continuously-compounded
return</p>
</td></tr>
<tr><td><code id="compound_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="compound_+3A_d">d</code></td>
<td>
<p>Dividend yield of the underlying asset, annualized,
continuously-compounded</p>
</td></tr>
<tr><td><code id="compound_+3A_kuo">kuo</code></td>
<td>
<p>strike on the underlying option</p>
</td></tr>
<tr><td><code id="compound_+3A_kco">kco</code></td>
<td>
<p>strike on compound option (the price at which you would
buy or sell the underlying option at time t1)</p>
</td></tr>
<tr><td><code id="compound_+3A_t1">t1</code></td>
<td>
<p>time until exercise for the compound option</p>
</td></tr>
<tr><td><code id="compound_+3A_t2">t2</code></td>
<td>
<p>time until exercise for the underlying option</p>
</td></tr>
<tr><td><code id="compound_+3A_x1">x1</code>, <code id="compound_+3A_x2">x2</code></td>
<td>
<p>values at which the cumulative bivariate normal
distribution will be evaluated</p>
</td></tr>
<tr><td><code id="compound_+3A_rho">rho</code></td>
<td>
<p>correlation between <code>x1</code> and <code>x2</code></p>
</td></tr>
<tr><td><code id="compound_+3A_returnscritical">returnscritical</code></td>
<td>
<p>(FALSE) boolean determining whether the
function returns just the options price (the default) or the
option price along with the asset price above or below which
the compound option is exercised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The option price, and optionally, the stock price above or
below which the compound option is exercised. The compound
option functions are not vectorized, but the greeks function
should work, apart from theta.
</p>


<h3>Note</h3>

<p>The compound option formulas are not vectorized.
</p>

<hr>
<h2 id='geomasianmc'>Geometric Asian option prices computed by Monte Carlo</h2><span id='topic+geomasianmc'></span>

<h3>Description</h3>

<p>Geometric average Asian option prices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomasianmc(s, k, v, r, tt, d, m, numsim, printsds=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geomasianmc_+3A_s">s</code></td>
<td>
<p>Price of underlying asset</p>
</td></tr>
<tr><td><code id="geomasianmc_+3A_k">k</code></td>
<td>
<p>Strike price of the option. In the case of average strike
options, <code>k/s</code> is the multiplier for the average</p>
</td></tr>
<tr><td><code id="geomasianmc_+3A_v">v</code></td>
<td>
<p>Volatility of the underlygin asset price, defined as the
annualized standard deviation of the continuously-compounded
return</p>
</td></tr>
<tr><td><code id="geomasianmc_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="geomasianmc_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="geomasianmc_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="geomasianmc_+3A_m">m</code></td>
<td>
<p>Number of prices in the average calculation</p>
</td></tr>
<tr><td><code id="geomasianmc_+3A_numsim">numsim</code></td>
<td>
<p>Number of Monte Carlo iterations</p>
</td></tr>
<tr><td><code id="geomasianmc_+3A_printsds">printsds</code></td>
<td>
<p>Print standard deviation for the particular Monte
Carlo calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of geometric average option prices, along with
vanilla European option prices implied by the the
simulation. Optionally returns Monte Carlo standard
deviations. Note that exact solutions for these prices exist,
the purpose is to see how the Monte Carlo prices behave.
</p>


<h3>See Also</h3>

<p>Other Asian: 
<code><a href="#topic+arithasianmc">arithasianmc</a>()</code>,
<code><a href="#topic+arithavgpricecv">arithavgpricecv</a>()</code>,
<code><a href="#topic+asiangeomavg">asiangeomavg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08; tt=0.25; d=0; m=3; numsim=1e04
geomasianmc(s, k, v, r, tt, d, m, numsim, printsds=FALSE)
</code></pre>

<hr>
<h2 id='greeks'>Calculate option Greeks</h2><span id='topic+greeks'></span><span id='topic+bsopt'></span><span id='topic+greeks2'></span>

<h3>Description</h3>

<p>The functions <code>greeks</code> and <code>greeks2</code> provide
two different calling conventions for computing a full set of
option Greeks. <code>greeks</code> simply requires entering a pricing function
with parameters. <code>greeks2</code> requires the use of named parameter
entries. The function <code>bsopt</code> calls <code>greeks2</code> to
produce a full set of prices and greeks for calls and puts. These
functions are all vectorized, the only restriction being that the
functions will produce an error if the recycling rule can not be
used safely (that is, if parameter vector lengths are not integer
multiples of one another).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greeks(f, complete=FALSE, long=FALSE, initcaps=TRUE)
# must used named list entries:
greeks2(fn, ...)
bsopt(s, k, v, r, tt, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greeks_+3A_s">s</code></td>
<td>
<p>Price of underlying asset</p>
</td></tr>
<tr><td><code id="greeks_+3A_k">k</code></td>
<td>
<p>Option strike price</p>
</td></tr>
<tr><td><code id="greeks_+3A_v">v</code></td>
<td>
<p>Volatility of the underlying asset, defined as the
annualized standard deviation of the continuously-compounded
return</p>
</td></tr>
<tr><td><code id="greeks_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="greeks_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="greeks_+3A_d">d</code></td>
<td>
<p>Dividend yield of the underlying asset, annualized,
continuously-compounded</p>
</td></tr>
<tr><td><code id="greeks_+3A_fn">fn</code></td>
<td>
<p>Pricing function name, not in quotes</p>
</td></tr>
<tr><td><code id="greeks_+3A_f">f</code></td>
<td>
<p>Fully-specified option pricing function, including inputs
which need not be named. For example, you can enter
<code>greeks(bscall(40, 40, .3, .08, .25, 0))</code></p>
</td></tr>
<tr><td><code id="greeks_+3A_complete">complete</code></td>
<td>
<p>FALSE. If TRUE, return a data frame with columns
equal to input parameters, function name, premium, and greeks
(each greek is a column). This is experimental and the output
may change. Convert to long format using <code>long=TRUE</code>.</p>
</td></tr>
<tr><td><code id="greeks_+3A_long">long</code></td>
<td>
<p>FALSE. Setting <code>long=TRUE</code> returns a long data
frame, where each row contains input parameters, function name,
and either the premium or one of the greeks. <code>long=TRUE</code>
implies <code>complete=TRUE</code></p>
</td></tr>
<tr><td><code id="greeks_+3A_initcaps">initcaps</code></td>
<td>
<p>TRUE. If true, capitalize names (e.g. &quot;Delta&quot; vs
&quot;delta&quot;)</p>
</td></tr>
<tr><td><code id="greeks_+3A_...">...</code></td>
<td>
<p>Pricing function inputs, must be named, may either be a
list or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numerical derivatives are calculated using a simple
difference. This can create numerical problems in edge
cases. It might be good to use the package numDeriv or some
other more sophisticated calculation, but the current approach
works well with vectorization.
</p>


<h3>Value</h3>

<p>A named list of Black-Scholes option prices and Greeks, or
optionally ('complete=TRUE') a dataframe.
</p>


<h3>Note</h3>

<p>The pricing function being passed to the greeks function must
return a numeric vector. For example, <code>callperpetual</code> must
be called with the option <code>showbarrier=FALSE</code> (the
default). The pricing function call cannot contain a variable
named 'z91k25'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08; tt=0.25; d=0;
greeks(bscall(s, k, v, r, tt, d), complete=FALSE, long=FALSE, initcaps=TRUE)
greeks2(bscall, list(s=s, k=k, v=v, r=r, tt=tt, d=d))
greeks2(bscall, list(s=s, k=k, v=v, r=r, tt=tt, d=d))[c('Delta', 'Gamma'), ]
bsopt(s, k, v, r, tt, d)
bsopt(s, c(35, 40, 45), v, r, tt, d)
bsopt(s, c(35, 40, 45), v, r, tt, d)[['Call']][c('Delta', 'Gamma'), ]

## plot Greeks for calls and puts for 500 different stock prices
##
## This plot can generate a "figure margins too large" error
## in Rstudio
k &lt;- 100; v &lt;- 0.30; r &lt;- 0.08; tt &lt;- 2; d &lt;- 0
S &lt;- seq(.5, 250, by=.5)
Call &lt;- greeks(bscall(S, k, v, r, tt, d))
Put &lt;- greeks(bsput(S, k, v, r, tt, d))
y &lt;- list(Call=Call, Put=Put)
par(mfrow=c(4, 4), mar=c(2, 2, 2, 2))  ## create a 4x4 plot
for (i in names(y)) {
    for (j in rownames(y[[i]])) {  ## loop over greeks
        plot(S, y[[i]][j, ], main=paste(i, j), ylab=j, type='l')
    }
}
## Not run: 
## Using complete option for calls
call_long &lt;- greeks(bscall(S, k, v, r, tt, d), long=TRUE)
ggplot2::ggplot(call_long, aes(x=s, y=value)) +
      geom_line() + facet_wrap(~greek, scales='free')

## End(Not run)
</code></pre>

<hr>
<h2 id='implied'>Black-Scholes implied volatility and price</h2><span id='topic+implied'></span><span id='topic+bscallimpvol'></span><span id='topic+bsputimpvol'></span><span id='topic+bscallimps'></span><span id='topic+bsputimps'></span>

<h3>Description</h3>

<p><code>bscallimpvol</code> and <code>bsputimpvol</code> compute
Black-Scholes implied volatilties. The functions <code>bscallimps</code>
and <code>bsputimps</code>, compute stock prices implied by a given
option price, volatility and option characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bscallimpvol(s, k, r, tt, d, price, lowvol, highvol,
.tol=.Machine$double.eps^0.5)
bsputimpvol(s, k, r, tt, d, price, lowvol, highvol,
.tol=.Machine$double.eps^0.5)
bscallimps(s, k, v, r, tt, d, price, lower=0.0001, upper=1e06,
.tol=.Machine$double.eps^0.5)
bsputimps(s, k, v, r, tt, d, price, lower=0.0001, upper=1e06,
.tol=.Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="implied_+3A_s">s</code></td>
<td>
<p>Stock price</p>
</td></tr>
<tr><td><code id="implied_+3A_k">k</code></td>
<td>
<p>Strike price of the option</p>
</td></tr>
<tr><td><code id="implied_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="implied_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="implied_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="implied_+3A_price">price</code></td>
<td>
<p>Option price when computing an implied value</p>
</td></tr>
<tr><td><code id="implied_+3A_lowvol">lowvol</code></td>
<td>
<p>minimum implied volatility</p>
</td></tr>
<tr><td><code id="implied_+3A_highvol">highvol</code></td>
<td>
<p>maximum implied volatility</p>
</td></tr>
<tr><td><code id="implied_+3A_.tol">.tol</code></td>
<td>
<p>numerical tolerance for zero-finding function 'uniroot'</p>
</td></tr>
<tr><td><code id="implied_+3A_v">v</code></td>
<td>
<p>Volatility of the stock, defined as the annualized
standard deviation of the continuously-compounded return</p>
</td></tr>
<tr><td><code id="implied_+3A_lower">lower</code></td>
<td>
<p>minimum stock price in implied price calculation</p>
</td></tr>
<tr><td><code id="implied_+3A_upper">upper</code></td>
<td>
<p>maximum stock price in implied price calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a scalar or vector of option prices, depending on
the inputs
</p>


<h3>Value</h3>

<p>Implied volatility (for the &quot;impvol&quot; functions) or implied
stock price (for the &quot;impS&quot;) functions.
</p>


<h3>Note</h3>

<p>Implied volatilties and stock prices do not exist if the
price of the option exceeds no-arbitrage bounds. For example, if
the interest rate is non-negative, a 40 strike put cannot have a
price exceeding $40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08; tt=0.25; d=0;
bscallimpvol(s, k, r, tt, d, 4)
bsputimpvol(s, k, r, tt, d, 4)
bscallimps(s, k, v, r, tt, d, 4, )
bsputimps(s, k, v, r, tt, d, 4)

</code></pre>

<hr>
<h2 id='jumps'>Option pricing with jumps</h2><span id='topic+jumps'></span><span id='topic+cashjump'></span><span id='topic+assetjump'></span><span id='topic+mertonjump'></span>

<h3>Description</h3>

<p>The functions <code>cashjump</code>, <code>assetjump</code>, and
<code>mertonjump</code> return call and put prices, as vectors named
&quot;Call&quot; and &quot;Put&quot;, or &quot;Call1&quot;, &quot;Call2&quot;, etc. in case inputs are
vectors. The pricing model is the Merton jump model, in which
jumps are lognormally distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assetjump(s, k, v, r, tt, d, lambda, alphaj, vj, complete)
cashjump(s, k, v, r, tt, d, lambda, alphaj, vj, complete)
mertonjump(s, k, v, r, tt, d, lambda, alphaj, vj, complete)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jumps_+3A_s">s</code></td>
<td>
<p>Stock price</p>
</td></tr>
<tr><td><code id="jumps_+3A_k">k</code></td>
<td>
<p>Strike price of the option</p>
</td></tr>
<tr><td><code id="jumps_+3A_v">v</code></td>
<td>
<p>Volatility of the stock, defined as the annualized
standard deviation of the continuously-compounded return</p>
</td></tr>
<tr><td><code id="jumps_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="jumps_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="jumps_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="jumps_+3A_lambda">lambda</code></td>
<td>
<p>Poisson intensity: expected number of jumps per year</p>
</td></tr>
<tr><td><code id="jumps_+3A_alphaj">alphaj</code></td>
<td>
<p>Mean change in log price conditional on a jump</p>
</td></tr>
<tr><td><code id="jumps_+3A_vj">vj</code></td>
<td>
<p>Standard deviation of change in log price conditional on
a jump</p>
</td></tr>
<tr><td><code id="jumps_+3A_complete">complete</code></td>
<td>
<p>Return inputs along with prices, all in a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a scalar or vector of option prices, depending on
the inputs
</p>


<h3>Value</h3>

<p>A vector of call and put prices computed using the Merton
lognormal jump formula.
</p>


<h3>See Also</h3>

<p>McDonald, Robert L., <em>Derivatives Markets</em>, 3rd Edition
(2013) Chapter 24
</p>
<p>bscall bsput
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- 40; k &lt;- 40; v &lt;- 0.30; r &lt;- 0.08; tt &lt;- 2; d &lt;- 0;
lambda &lt;- 0.75; alphaj &lt;- -0.05; vj &lt;- .35;
bscall(s, k, v, r, tt, d)
bsput(s, k, v, r, tt, d)
mertonjump(s, k, v, r, tt, d, 0, 0, 0)
mertonjump(s, k, v, r, tt, d, lambda, alphaj, vj)

## following returns the same price as previous
c(1, -1)*(assetjump(s, k, v, r, tt, d, lambda, alphaj, vj) -
k*cashjump(s, k, v, r, tt, d, lambda, alphaj, vj))

## return call prices for different strikes
kseq &lt;- 35:45
cp &lt;- mertonjump(s, kseq, v, r, tt, d, lambda, alphaj,
    vj)$Call

## Implied volatilities: Compute Black-Scholes implied volatilities
## for options priced using the Merton jump model
vimp &lt;- sapply(1:length(kseq), function(i) bscallimpvol(s, kseq[i],
    r, tt, d, cp[i]))
plot(kseq, vimp, main='Implied volatilities', xlab='Strike',
    ylab='Implied volatility', ylim=c(0.30, 0.50))
</code></pre>

<hr>
<h2 id='perpetual'>Perpetual American options</h2><span id='topic+perpetual'></span><span id='topic+callperpetual'></span><span id='topic+putperpetual'></span>

<h3>Description</h3>

<p><code>callperpetual</code> and <code>putperpetual</code> compute
prices of perpetual American options. The functions optionally
return the exercise barriers (the prices at which the options
are optimally exercised).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callperpetual(s, k, v, r, d, showbarrier)
putperpetual(s, k, v, r, d, showbarrier)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perpetual_+3A_s">s</code></td>
<td>
<p>Price of the underlying asset</p>
</td></tr>
<tr><td><code id="perpetual_+3A_k">k</code></td>
<td>
<p>Strike price</p>
</td></tr>
<tr><td><code id="perpetual_+3A_v">v</code></td>
<td>
<p>Volatility of the asset price, defined as the annualized
standard deviation of the continuously-compounded return</p>
</td></tr>
<tr><td><code id="perpetual_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="perpetual_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="perpetual_+3A_showbarrier">showbarrier</code></td>
<td>
<p>Boolean (FALSE). If TRUE, the option price and
exercise barrier are returned as a list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a scalar or vector of option prices, depending on
the inputs
</p>
<p><code>callperpetual(s, k, v, r, tt, d)</code>
</p>


<h3>Value</h3>

<p>Option price, and optionally the optimal exercise barrier.
</p>


<h3>Note</h3>

<p>If the dividend yield is zero, a perpetual call is never
exercised. The pricing function in this case will return the
stock price, which is the limiting option price as the dividend
yield goes to zero.  Similarly, if the risk-free rate is zero,
a perpetual put is never exercised. The pricing function will
return the strike price in this case, which is the limiting
value of the pricing function as the interest rate approaches
zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=40; k=40; v=0.30; r=0.08;  d=0.02;
callperpetual(s, k, v, r, d)

putperpetual(s, c(35, 40, 45), v, r, d, showbarrier=TRUE)


</code></pre>

<hr>
<h2 id='quincunx'>Quincunx simulation</h2><span id='topic+quincunx'></span>

<h3>Description</h3>

<p><code>quincunx</code> simulates balls dropping down a
pegboard with a 50% chance of bouncing right or left at each
level. The balls accumulate in bins. If enough balls are dropped,
the distribution approaches normality. This device is called a
quincunx. See <a href="https://www.mathsisfun.com/data/quincunx.html">https://www.mathsisfun.com/data/quincunx.html</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quincunx(n = 3, numballs = 20, delay = 0.1, probright = 0.5, plottrue = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quincunx_+3A_n">n</code></td>
<td>
<p>Integer The number of peg levels, default is 3</p>
</td></tr>
<tr><td><code id="quincunx_+3A_numballs">numballs</code></td>
<td>
<p>Integer The number of balls dropped, default is 20</p>
</td></tr>
<tr><td><code id="quincunx_+3A_delay">delay</code></td>
<td>
<p>Numeric Number of seconds between ball drops. Set
delay &gt; 0 to see animation with <code>delay</code> seconds between
dropped balls. If <code>delay &lt; 0</code>, the simulation will run to
completion without delays. If <code>delay == 0</code>, the user must
hit &lt;return&gt; for the next ball to drop. The default is 0.1 second
and can be set with the <code>delay</code> parameter.</p>
</td></tr>
<tr><td><code id="quincunx_+3A_probright">probright</code></td>
<td>
<p>Numeric The probability the ball bounces to the
right; default is 0.5</p>
</td></tr>
<tr><td><code id="quincunx_+3A_plottrue">plottrue</code></td>
<td>
<p>Boolean If <code>TRUE</code>, the display will indicate
bin levels if the distribution were normal. Default is TRUE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## These examples will not display correctly within RStudio unless
## the plot window is large
quincunx(delay=0)
quincunx(n=10, numballs=200, delay=0)
quincunx(n=20, numballs=200, delay=0, probright=0.7)

</code></pre>

<hr>
<h2 id='simprice'>Simulate asset prices</h2><span id='topic+simprice'></span>

<h3>Description</h3>

<p><code>simprice</code> computes simulated lognormal price
paths, with or without jumps. Saves and restores random number
seed.
</p>
<p><code>simprice(s0 = 100, v = 0.3, r = .08, tt = 1, d = 0, trials =
2, periods = 3, jump = FALSE, lambda = 0, alphaj = 0, vj = 0, seed
= NULL, long = TRUE, scalar_v_is_stddev = TRUE)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simprice(s0, v, r, tt, d, trials, periods, jump, lambda,
    alphaj, vj, seed, long, scalar_v_is_stddev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simprice_+3A_s0">s0</code></td>
<td>
<p>Initial price of the underlying asset</p>
</td></tr>
<tr><td><code id="simprice_+3A_v">v</code></td>
<td>
<p>If scalar, default is volatility of the asset price,
defined as the annualized standard deviation of the
continuously-compounded return. The parameter
<code>scalar_v_is_stddev</code> controls this behavior. If <code>v</code>
is a square <code>n x n</code> matrix, it is assumed to be the
covariance matrix and <code>simprice</code> will return <code>n</code>
simulated price series.</p>
</td></tr>
<tr><td><code id="simprice_+3A_r">r</code></td>
<td>
<p>Annual continuously-compounded risk-free interest rate</p>
</td></tr>
<tr><td><code id="simprice_+3A_tt">tt</code></td>
<td>
<p>Time to maturity in years</p>
</td></tr>
<tr><td><code id="simprice_+3A_d">d</code></td>
<td>
<p>Dividend yield, annualized, continuously-compounded</p>
</td></tr>
<tr><td><code id="simprice_+3A_trials">trials</code></td>
<td>
<p>number of simulated price paths</p>
</td></tr>
<tr><td><code id="simprice_+3A_periods">periods</code></td>
<td>
<p>number of equal-length periods in each simulated
path</p>
</td></tr>
<tr><td><code id="simprice_+3A_jump">jump</code></td>
<td>
<p>boolean controlling use of jump parameters</p>
</td></tr>
<tr><td><code id="simprice_+3A_lambda">lambda</code></td>
<td>
<p>expected number of jumps in one year
(<code>lambda*tt</code>) is the Poisson parameter</p>
</td></tr>
<tr><td><code id="simprice_+3A_alphaj">alphaj</code></td>
<td>
<p>Expected continuously compounded jump percentage</p>
</td></tr>
<tr><td><code id="simprice_+3A_vj">vj</code></td>
<td>
<p>lognormal volatility of the jump amount</p>
</td></tr>
<tr><td><code id="simprice_+3A_seed">seed</code></td>
<td>
<p>random number seed</p>
</td></tr>
<tr><td><code id="simprice_+3A_long">long</code></td>
<td>
<p>if <code>TRUE</code>, return a long-form dataframe with
columns indicating the price, trial, and period. If
<code>FALSE</code>, the returned data is wide, containing only
prices: each row is a trial and each column is a period</p>
</td></tr>
<tr><td><code id="simprice_+3A_scalar_v_is_stddev">scalar_v_is_stddev</code></td>
<td>
<p>if <code>TRUE</code>, scalar v is interpreted
as the standard devaition; if <code>FALSE</code>, it is
variance. Non-scalar V is always interpreted as a covariance
matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with <code>trials</code> simulated stock price paths
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple Monte Carlo option price example. Since there are two
# periods we can compute options prices for \code{tt} and
# \code{tt/2}
s0=40; k=40; v=0.30; r=0.08; tt=0.25; d=0;
st = simprice(s0, k, v, r, tt, d,  trials=3, periods=2, jump=FALSE)
callprice1 = exp(-r*tt/2)*mean(pmax(st[st$period==1,] - k, 0))
callprice2 = exp(-r*tt)*mean(pmax(st[st$period==2,] - k, 0))


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
