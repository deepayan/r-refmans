<!DOCTYPE html><html lang="en"><head><title>Help for package systemicrisk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {systemicrisk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calibrate_ER'><p>Calibrate ER model to a given density</p></a></li>
<li><a href='#calibrate_ER.nonsquare'><p>Calibrate ER model to a given density with a nonsquare matrix</p></a></li>
<li><a href='#calibrate_FitnessEmp'><p>Calibrate empirical fitness model to a given density</p></a></li>
<li><a href='#choosethin'><p>Calibrate Thinning</p></a></li>
<li><a href='#cloneMatrix'><p>Creates a deep copy of a matrix</p></a></li>
<li><a href='#default'><p>Default of Banks</p></a></li>
<li><a href='#default_cascade'><p>Default Cascade</p></a></li>
<li><a href='#default_clearing'><p>Clearing Vector with Bankruptcy Costs</p></a></li>
<li><a href='#diagnose'><p>Outputs Effective Sample Size Diagonistics for MCMC run</p></a></li>
<li><a href='#ERE_step_cycle'><p>Does one Gibbs Step on a cycle</p></a></li>
<li><a href='#findFeasibleMatrix'><p>Finds a Nonnegative Matrix Satisfying Row and Column Sums</p></a></li>
<li><a href='#findFeasibleMatrix_targetmean'><p>Creates a feasible starting matrix with a desired mean average degree</p></a></li>
<li><a href='#genL'><p>Generate Liabilities Matrix from Prior</p></a></li>
<li><a href='#getfeasibleMatr'><p>Creates a feasible starting matrix</p></a></li>
<li><a href='#GibbsSteps_kcycle'><p>Gibbs sampling step of a matrix in the ERE model</p></a></li>
<li><a href='#Model.additivelink.exponential.fitness'><p>Fitness model for liabilities matrix</p></a></li>
<li><a href='#Model.fitness.conditionalmeandegree'><p>Mean out-degree of a node with given fitness in the fitness model</p></a></li>
<li><a href='#Model.fitness.genlambdaparprior'><p>Prior distribution for eta and zeta in the fitness model</p></a></li>
<li><a href='#Model.fitness.meandegree'><p>Mean out-degree of a random node  the fitness model</p></a></li>
<li><a href='#Model.Indep.p.lambda'><p>Combination of Independent Models for p and lambda</p></a></li>
<li><a href='#Model.lambda.constant'><p>Model for a Constant lambda</p></a></li>
<li><a href='#Model.lambda.constant.nonsquare'><p>Model for a Constant lambda and Non-Square Matrices</p></a></li>
<li><a href='#Model.lambda.GammaPrior'><p>Model with Gamma Prior on Lambda</p></a></li>
<li><a href='#Model.lambda.Gammaprior_mult'><p>Model Using Multiple Independent Components</p></a></li>
<li><a href='#Model.p.BetaPrior'><p>Model for a Random One-dimensional p</p></a></li>
<li><a href='#Model.p.Betaprior_mult'><p>Model Using Multiple Independent Components</p></a></li>
<li><a href='#Model.p.constant'><p>Model for a Constant p</p></a></li>
<li><a href='#Model.p.constant.nonsquare'><p>Model for a constant p and Non-Square Matrices</p></a></li>
<li><a href='#Model.p.Fitness.Servedio'><p>Multiplicative Fitness Model for Power Law</p></a></li>
<li><a href='#sample_ERE'><p>Sample from the ERE model with given row and column sums</p></a></li>
<li><a href='#sample_HierarchicalModel'><p>Sample from Hierarchical Model with given Row and Column Sums</p></a></li>
<li><a href='#steps_ERE'><p>Perform Steps of the Gibbs Sampler of the ERE model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Systemic Risk and Network Reconstruction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-03</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of risk through liability matrices. Contains a Gibbs sampler for network reconstruction,  where only row and column sums of the liabilities matrix as well as some other fixed entries are observed, following the methodology of Gandy&amp;Veraart (2016) &lt;<a href="https://doi.org/10.1287%2Fmnsc.2016.2546">doi:10.1287/mnsc.2016.2546</a>&gt;. It also incorporates models that use a power law distribution on the degree distribution.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>lpSolve, Rcpp (&ge; 0.11.2), stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda, testthat, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-03 16:09:45 UTC; agandy</td>
</tr>
<tr>
<td>Author:</td>
<td>Axel Gandy [aut, cre],
  Luitgard A.M. Veraart [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Axel Gandy &lt;a.gandy@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-05 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calibrate_ER'>Calibrate ER model to a given density</h2><span id='topic+calibrate_ER'></span>

<h3>Description</h3>

<p>The model is an Erdos-Renyi model for the existence of links (a
link exists independently of other links with a fixed probability)
and the weight of each existing link follows an exponential
distribution with a fixed rate parameter. This function chooses the
two parameters such that the density of the network (the average
proportion of existing links) is a certain desired value. Diagonal
elements are being set to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_ER(
  l,
  a,
  targetdensity,
  L_fixed = NA,
  nsamples_calib = 100,
  thin_calib = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrate_ER_+3A_l">l</code></td>
<td>
<p>row sums of matrix to be reconstructed</p>
</td></tr>
<tr><td><code id="calibrate_ER_+3A_a">a</code></td>
<td>
<p>column sum of matrix to be reconstructed</p>
</td></tr>
<tr><td><code id="calibrate_ER_+3A_targetdensity">targetdensity</code></td>
<td>
<p>desired proportion of reconstructed entries to be positive</p>
</td></tr>
<tr><td><code id="calibrate_ER_+3A_l_fixed">L_fixed</code></td>
<td>
<p>Matrix containing known values of L, where NA signifies that
an element is not known. If <code>L_fixed</code> equates to <code>NA</code> (the
default) then no values are assumed to be known.</p>
</td></tr>
<tr><td><code id="calibrate_ER_+3A_nsamples_calib">nsamples_calib</code></td>
<td>
<p>number of matrices to generate during calibration.</p>
</td></tr>
<tr><td><code id="calibrate_ER_+3A_thin_calib">thin_calib</code></td>
<td>
<p>amount of thinning to use during calibration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model that can be used to generate the desired samples using <code><a href="#topic+sample_HierarchicalModel">sample_HierarchicalModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## first generate a true network
n &lt;- 10 # size of network
p &lt;- 0.45
lambda &lt;- 0.1
L &lt;- matrix(nrow=n,rbinom(n*n,prob=p,size=1)*rexp(n*n,rate=lambda))

# then reconstruct with a target density of 0.55
model &lt;- calibrate_ER(l=rowSums(L),a=colSums(L),
                      targetdensity=0.55,nsamples_calib=10)
Lsamp &lt;- sample_HierarchicalModel(l=rowSums(L),a=colSums(L),model=model,
                                    nsamples=10,thin=1e2)
# check row sums
rowSums(L)
rowSums(Lsamp$L[[10]])
# check calibration
mean(Lsamp$L[[10]]&gt;0)

# now an example with some fixed entries
L_fixed &lt;- L
L_fixed[1:(n/2),] &lt;- NA
# then reconstruct with a target density of 0.9
model &lt;- calibrate_ER(l=rowSums(L),a=colSums(L),L_fixed=L_fixed,
                              targetdensity=0.9,nsamples_calib=10)
Lsamp &lt;- sample_HierarchicalModel(l=rowSums(L),a=colSums(L),L_fixed=L_fixed,
                                  model=model,nsamples=10,thin=1e2)
mean(Lsamp$L[[10]][-(1:(n/2)),]&gt;0) # known entries
mean(Lsamp$L[[10]][(1:(n/2)),]&gt;0)  #reconstructed entries
</code></pre>

<hr>
<h2 id='calibrate_ER.nonsquare'>Calibrate ER model to a given density with a nonsquare matrix</h2><span id='topic+calibrate_ER.nonsquare'></span>

<h3>Description</h3>

<p>The model is an Erdos-Renyi model for the existence of links (a
link exists independently of other links with a fixed probability)
and the weight of each existing link follows an exponential
distribution with a fixed rate parameter. This function chooses the
two parameters such that the density of the network (the average
proportion of existing links) is a certain desired value. This
function does not set diagonal values to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_ER.nonsquare(
  l,
  a,
  targetdensity,
  L_fixed = NA,
  nsamples_calib = 100,
  thin_calib = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrate_ER.nonsquare_+3A_l">l</code></td>
<td>
<p>row sums of matrix to be reconstructed</p>
</td></tr>
<tr><td><code id="calibrate_ER.nonsquare_+3A_a">a</code></td>
<td>
<p>column sum of matrix to be reconstructed</p>
</td></tr>
<tr><td><code id="calibrate_ER.nonsquare_+3A_targetdensity">targetdensity</code></td>
<td>
<p>desired proportion of reconstructed entries to be positive</p>
</td></tr>
<tr><td><code id="calibrate_ER.nonsquare_+3A_l_fixed">L_fixed</code></td>
<td>
<p>Matrix containing known values of L, where NA signifies that
an element is not known. If <code>L_fixed</code> equates to <code>NA</code> (the
default) then no values are assumed to be known.</p>
</td></tr>
<tr><td><code id="calibrate_ER.nonsquare_+3A_nsamples_calib">nsamples_calib</code></td>
<td>
<p>number of matrices to generate during calibration.</p>
</td></tr>
<tr><td><code id="calibrate_ER.nonsquare_+3A_thin_calib">thin_calib</code></td>
<td>
<p>amount of thinning to use during calibration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model that can be used to generate the desired samples using <code><a href="#topic+sample_HierarchicalModel">sample_HierarchicalModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## first generate a true network
nrow &lt;- 10 # size of network
ncol &lt;- 8 # size of network
p &lt;- 0.45
lambda &lt;- 0.1
L &lt;- matrix(nrow=nrow,rbinom(nrow*ncol,prob=p,size=1)*rexp(nrow*ncol,rate=lambda))

# then reconstruct with a target density of 0.55
model &lt;- calibrate_ER.nonsquare(l=rowSums(L),a=colSums(L),
                      targetdensity=0.55,nsamples_calib=10)
Lsamp &lt;- sample_HierarchicalModel(l=rowSums(L),a=colSums(L),model=model,
                                    nsamples=10,thin=1e2)
# check row sums
rowSums(L)
rowSums(Lsamp$L[[10]])
# check calibration
mean(Lsamp$L[[10]]&gt;0)

# now an example with some fixed entries
L_fixed &lt;- L
L_fixed[1:(nrow/2),] &lt;- NA
# then reconstruct with a target density of 0.9
model &lt;- calibrate_ER.nonsquare(l=rowSums(L),a=colSums(L),L_fixed=L_fixed,
                              targetdensity=0.9,nsamples_calib=10)
Lsamp &lt;- sample_HierarchicalModel(l=rowSums(L),a=colSums(L),L_fixed=L_fixed,
                                  model=model,nsamples=10,thin=1e2)
mean(Lsamp$L[[10]][-(1:(nrow/2)),]&gt;0) # known entries
mean(Lsamp$L[[10]][(1:(nrow/2)),]&gt;0)  #reconstructed entries
</code></pre>

<hr>
<h2 id='calibrate_FitnessEmp'>Calibrate empirical fitness model to a given density</h2><span id='topic+calibrate_FitnessEmp'></span>

<h3>Description</h3>

<p>The model is an empirical fitness based model for the existence of
links (more details below) which contains one fixed parameter and
the weight of each existing link follows an exponential
distribution with a fixed rate parameter. This function chooses the
two parameters such that the density of the network (the average
proportion of existing links) with these given row and column sums
is a certain desired value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_FitnessEmp(
  l,
  a,
  targetdensity,
  L_fixed = NA,
  nsamples_calib = 100,
  thin_calib = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrate_FitnessEmp_+3A_l">l</code></td>
<td>
<p>row sums of matrix to be reconstructed</p>
</td></tr>
<tr><td><code id="calibrate_FitnessEmp_+3A_a">a</code></td>
<td>
<p>column sum of matrix to be reconstructed</p>
</td></tr>
<tr><td><code id="calibrate_FitnessEmp_+3A_targetdensity">targetdensity</code></td>
<td>
<p>desired proportion of reconstructed entries to be positive</p>
</td></tr>
<tr><td><code id="calibrate_FitnessEmp_+3A_l_fixed">L_fixed</code></td>
<td>
<p>Matrix containing known values of L, where NA signifies that
an element is not known. If <code>L_fixed</code> equates to <code>NA</code> (the
default) then no values are assumed to be known.</p>
</td></tr>
<tr><td><code id="calibrate_FitnessEmp_+3A_nsamples_calib">nsamples_calib</code></td>
<td>
<p>number of matrices to generate during calibration.</p>
</td></tr>
<tr><td><code id="calibrate_FitnessEmp_+3A_thin_calib">thin_calib</code></td>
<td>
<p>amount of thinning to use during calibration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empirical fitness model assumes that every node
<code class="reqn">f[i]=log(l[i]+a[i])</code> has a fitness given by the observered row
and column sum and that the existence probability of a link between
node i and j is then given by
<code class="reqn">p[i,j]=1/(1+exp(-(alpha+f[i]+f[j])))</code>, where alpha is an
additional parameter.  The resulting model uses observed quantities
(the row and column sums of the matrix) as input to the model and
is thus an empirical Bayes approach.
</p>


<h3>Value</h3>

<p>Model that can be used to generate the desired samples using <code><a href="#topic+sample_HierarchicalModel">sample_HierarchicalModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## first generate a true network
n &lt;- 10 # size of network
ftrue &lt;- rnorm(n) # vector of underlying fitnesses
p &lt;- outer(ftrue,ftrue,FUN=function(x,y) 1/(1+exp(-(x+y))))
lambda &lt;- 0.1
L &lt;- matrix(nrow=n,rbinom(n*n,prob=p,size=1)*rexp(n*n,rate=lambda))

# then reconstruct with a target density of 0.7
model &lt;- calibrate_FitnessEmp(l=rowSums(L),a=colSums(L),
                              targetdensity=0.7,nsamples_calib=10,thin_calib=50)
Lsamp &lt;- sample_HierarchicalModel(l=rowSums(L),a=colSums(L),model=model,
                                    nsamples=10,thin=1e2)
# check row sums
rowSums(L)
rowSums(Lsamp$L[[10]])
# check calibration
mean(Lsamp$L[[10]]&gt;0)

# now an example with some fixed entries
L_fixed &lt;- L
L_fixed[1:(n/2),] &lt;- NA
# then reconstruct with a target density of 0.9
model &lt;- calibrate_FitnessEmp(l=rowSums(L),a=colSums(L),L_fixed=L_fixed,
                              targetdensity=0.9,nsamples_calib=10,thin_calib=50)
Lsamp &lt;- sample_HierarchicalModel(l=rowSums(L),a=colSums(L),L_fixed=L_fixed,
                                  model=model,nsamples=10,thin=1e2)
mean(Lsamp$L[[10]][-(1:(n/2)),]&gt;0) # known entries
mean(Lsamp$L[[10]][(1:(n/2)),]&gt;0)  #reconstructed entries
</code></pre>

<hr>
<h2 id='choosethin'>Calibrate Thinning</h2><span id='topic+choosethin'></span>

<h3>Description</h3>

<p>Attempts to automatically choose a thinning paramter to achieve an
overall relative effective sample size (defined as the effective
sample size divided by the number of samples) for all parameters in
the model (that do not seem to be constant). This function provides
no guarantees that the desired relative effective sample size
(rESS) will actually be achieved - it is best treated as a rough
guide for this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choosethin(
  l,
  a,
  L_fixed = NA,
  model,
  relESStarget = 0.3,
  burnin = 100,
  matrpertheta = length(l)^2,
  silent = TRUE,
  maxthin = 10000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choosethin_+3A_l">l</code></td>
<td>
<p>observed row sum</p>
</td></tr>
<tr><td><code id="choosethin_+3A_a">a</code></td>
<td>
<p>observerd column sum</p>
</td></tr>
<tr><td><code id="choosethin_+3A_l_fixed">L_fixed</code></td>
<td>
<p>Matrix containing known values of L, where NA
signifies that an element is not known. If <code>L_fixed</code> equates
to <code>NA</code> (the default) then no values are assumed to be known.</p>
</td></tr>
<tr><td><code id="choosethin_+3A_model">model</code></td>
<td>
<p>Underlying model for p and lambda.</p>
</td></tr>
<tr><td><code id="choosethin_+3A_relesstarget">relESStarget</code></td>
<td>
<p>Target for the relative effective sample size,
must be in (0,1). Default 0.3.</p>
</td></tr>
<tr><td><code id="choosethin_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations for the burnin. Defaults to 5
of the steps in the sampling part.</p>
</td></tr>
<tr><td><code id="choosethin_+3A_matrpertheta">matrpertheta</code></td>
<td>
<p>number of matrix updates per update of theta.</p>
</td></tr>
<tr><td><code id="choosethin_+3A_silent">silent</code></td>
<td>
<p>(default FALSE) suppress all output (including progress bars).</p>
</td></tr>
<tr><td><code id="choosethin_+3A_maxthin">maxthin</code></td>
<td>
<p>Upper bound on thinning to consider. Default 10000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approach used involves a pilot run of the sampler, followed by
a computation of the acf (autocorrelation function) for each
component. The acf is used only up to (and excluding) the point
used where it becomes negative for the first time. This part of the
acf is then used to approximate the rESS and to determine the
amount of thinning needed. The reported result is the thinning
needed to achieve the rESS for all components (the matrix as well
as the parameter theta). The initial pilot run may not be
sufficient and further pilot runs may have to be started.
</p>


<h3>Value</h3>

<p>An integer describing the amount of thinning required.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12689)
n &lt;- 10
m &lt;- Model.Indep.p.lambda(Model.p.BetaPrior(n),
                          Model.lambda.GammaPrior(n,scale=1e-1))
x &lt;- genL(m)
l &lt;- rowSums(x$L)
a &lt;- colSums(x$L)
choosethin(l,a,model=m)
choosethin(l,a,model=m,relESStarget=0.7)
</code></pre>

<hr>
<h2 id='cloneMatrix'>Creates a deep copy of a matrix</h2><span id='topic+cloneMatrix'></span>

<h3>Description</h3>

<p>Useful  when calling <code><a href="#topic+ERE_step_cycle">ERE_step_cycle</a></code> or
<code><a href="#topic+GibbsSteps_kcycle">GibbsSteps_kcycle</a></code> to ensure that
there are no side effects for the return values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cloneMatrix(M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cloneMatrix_+3A_m">M</code></td>
<td>
<p>A matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A deep copy of the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- matrix(0.5,nrow=2,ncol=2)
p &lt;- matrix(0.7, nrow=2,ncol=2)
L &lt;- matrix(rexp(4),nrow=2);
L
Lold &lt;- L
Lcopy &lt;- cloneMatrix(L)
ERE_step_cycle(r=c(0,1),c=c(0,1),L=L,lambda=lambda,p=p)

L     ## new value
Lold  ## equal to L !!!
Lcopy ## still has the original value
</code></pre>

<hr>
<h2 id='default'>Default of Banks</h2><span id='topic+default'></span>

<h3>Description</h3>

<p>Computes bank defaults based on a liabilities matrix and external assets and liabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default(L, ea, el = 0, method = c("clearing", "cascade"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_+3A_l">L</code></td>
<td>
<p>liability matrix</p>
</td></tr>
<tr><td><code id="default_+3A_ea">ea</code></td>
<td>
<p>vector of external assets</p>
</td></tr>
<tr><td><code id="default_+3A_el">el</code></td>
<td>
<p>vector of external liabilites.</p>
</td></tr>
<tr><td><code id="default_+3A_method">method</code></td>
<td>
<p>the method to be used. See Details.</p>
</td></tr>
<tr><td><code id="default_+3A_...">...</code></td>
<td>
<p>Additional information for the various methods. See Details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with at least one element &quot;defaultind&quot;, which is a
vector indicating which banks default (1=default, 0= no
default). Depending on the method, other results such as the
clearing vector may also be reported.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+default_cascade">default_cascade</a></code>,  <code><a href="#topic+default_clearing">default_clearing</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ea &lt;- c(1/2,5/8,3/4)
el &lt;- c(3/2,1/2,1/2)
x &lt;- 0.5
L &lt;- matrix(c(0,x,1-x,1-x,0,x,x,1-x,0),nrow=3)
default(L,ea,el)
default(L,ea,el,"cascade")

</code></pre>

<hr>
<h2 id='default_cascade'>Default Cascade</h2><span id='topic+default_cascade'></span>

<h3>Description</h3>

<p>Computes bank defaults via the default cascade algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_cascade(L, ea, el = 0, recoveryrate = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_cascade_+3A_l">L</code></td>
<td>
<p>liability matrix</p>
</td></tr>
<tr><td><code id="default_cascade_+3A_ea">ea</code></td>
<td>
<p>vector of external assets</p>
</td></tr>
<tr><td><code id="default_cascade_+3A_el">el</code></td>
<td>
<p>vector of external liabilites (default 0)</p>
</td></tr>
<tr><td><code id="default_cascade_+3A_recoveryrate">recoveryrate</code></td>
<td>
<p>recovery rate in [0,1] (defaults to 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector indicating which banks default (1=default, 0= no default)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ea &lt;- c(1/2,5/8,3/4)
el &lt;- c(3/2,1/2,1/2)
x &lt;- 0.5
L &lt;- matrix(c(0,x,1-x,1-x,0,x,x,1-x,0),nrow=3)
default_cascade(L,ea,el)
</code></pre>

<hr>
<h2 id='default_clearing'>Clearing Vector with Bankruptcy Costs</h2><span id='topic+default_clearing'></span>

<h3>Description</h3>

<p>Computes bank defaults for the clearing vector approach without and
with bankruptcy costs (Eisenberg and Noe, 2001), (Rogers and Veraart, 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_clearing(L, ea, el = 0, alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_clearing_+3A_l">L</code></td>
<td>
<p>Liabilities matrix</p>
</td></tr>
<tr><td><code id="default_clearing_+3A_ea">ea</code></td>
<td>
<p>Vector of external assets</p>
</td></tr>
<tr><td><code id="default_clearing_+3A_el">el</code></td>
<td>
<p>Vector of external liabilites  (default 0)</p>
</td></tr>
<tr><td><code id="default_clearing_+3A_alpha">alpha</code></td>
<td>
<p>1-proportional default costs on external assets in [0,
1] (default to 1).</p>
</td></tr>
<tr><td><code id="default_clearing_+3A_beta">beta</code></td>
<td>
<p>1-proportional default costs on interbank assets in [0,
1] (defaults to 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without bankruptcy costs the approach of Eisenberg and Noe (2001)
is used using a linear programme.  With bankruptcy costs, the
implementation is based on the Greatest Clearing Vector Algorithm (GA),
see Definition 3.6, Rogers &amp; Veraart (2013).
</p>


<h3>Value</h3>

<p>A list consisting of a vector indicating which banks
default (1=default, 0= no default) and the greatest clearing
vector.
</p>


<h3>References</h3>

<p>Eisenberg, L. and Noe, T.H. (2001). Systemic risk in financial
systems. Management Science 47, 236&ndash;249.
</p>
<p>Rogers, L. C. G. and Veraart, L. A. M. (2013) Failure and Rescue in
an Interbank Network, Management Science 59 (4), 882&ndash;898.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ea &lt;- c(1/2,5/8,3/4)
el &lt;- c(3/2,1/2,1/2)
x &lt;- 0.5
L &lt;- matrix(c(0,x,1-x,1-x,0,x,x,1-x,0),nrow=3)
default_clearing(L,ea,el)
default_clearing(L,ea,el, alpha=0.5, beta=0.7)
</code></pre>

<hr>
<h2 id='diagnose'>Outputs Effective Sample Size Diagonistics for MCMC run</h2><span id='topic+diagnose'></span>

<h3>Description</h3>

<p>Computes the Effective Sample Size using the method
<code>effectiveSize</code> in of the package <code>coda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose(res)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnose_+3A_res">res</code></td>
<td>
<p>output from <code><a href="#topic+sample_HierarchicalModel">sample_HierarchicalModel</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently only works with L where the diagonal is 0. The function
ignores the diagonal and tries to determine from the row and column
sums which parts of the matrix are 0.
</p>


<h3>Value</h3>

<p>No return value. Called for printing the diagnostics.
</p>

<hr>
<h2 id='ERE_step_cycle'>Does one Gibbs Step on a cycle</h2><span id='topic+ERE_step_cycle'></span>

<h3>Description</h3>

<p>Execute one Gibbs step on a cycle keeping
row and column sums fixed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ERE_step_cycle(r, c, L, lambda, p, eps = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ERE_step_cycle_+3A_r">r</code></td>
<td>
<p>Row indies of cycle, starting at 0 (vector of length k)</p>
</td></tr>
<tr><td><code id="ERE_step_cycle_+3A_c">c</code></td>
<td>
<p>Column indices of cycle, starting at 0 (vector of length k)</p>
</td></tr>
<tr><td><code id="ERE_step_cycle_+3A_l">L</code></td>
<td>
<p>nxn matrix with nonnegative values (will be modified)</p>
</td></tr>
<tr><td><code id="ERE_step_cycle_+3A_lambda">lambda</code></td>
<td>
<p>nxn matrix of intensities</p>
</td></tr>
<tr><td><code id="ERE_step_cycle_+3A_p">p</code></td>
<td>
<p>nxn matrix of probabilities (must be in [0,1] and 0 on diagonal)</p>
</td></tr>
<tr><td><code id="ERE_step_cycle_+3A_eps">eps</code></td>
<td>
<p>Threshold for values to be interpreted as equal to 0 (default = 1e-10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L=matrix(rexp(9),nrow=3)
lambda &lt;- matrix(0.5,nrow=3,ncol=3)
p &lt;- matrix(0.7, nrow=3,ncol=3)
ERE_step_cycle(r=c(0,1),c=c(1,2),L=L,lambda=lambda,p=p)
ERE_step_cycle(r=c(0,1,2),c=c(0,1,2),L=L,lambda=lambda,p=p)
ERE_step_cycle(r=c(0,1,2),c=c(2,1,0),L=L,lambda=lambda,p=p)

</code></pre>

<hr>
<h2 id='findFeasibleMatrix'>Finds a Nonnegative Matrix Satisfying Row and Column Sums</h2><span id='topic+findFeasibleMatrix'></span>

<h3>Description</h3>

<p>Given row and column sums and a matrix p which indicates which elements of the matrix can be present, this function computes a nonnegative matrix that match these row and column sums. If this is not possible then the function returns an error message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFeasibleMatrix(r, c, p, eps = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findFeasibleMatrix_+3A_r">r</code></td>
<td>
<p>vector of row sums (nonnegative</p>
</td></tr>
<tr><td><code id="findFeasibleMatrix_+3A_c">c</code></td>
<td>
<p>vector of column sums (nonnegative)</p>
</td></tr>
<tr><td><code id="findFeasibleMatrix_+3A_p">p</code></td>
<td>
<p>matrix of probabilities (must be in [0,1]), matching the dimensions of r and c. Values of p=0 are interpreted that the corresponding matrix elements have to be 0. Note: p=1 does not force the corresponding matrix element to exist.</p>
</td></tr>
<tr><td><code id="findFeasibleMatrix_+3A_eps">eps</code></td>
<td>
<p>row and col sums can at most be different by eps.  Default 1e-9.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function transforms the problem into a Maximum Flow
problem of a graph and uses the Edmonds-Karps algorithm to solve it.
If the error message &quot;Could not find feasible matrix.&quot; is produced then this could be
due to p imposing disconnected components in the graph implied
by row and column sums that are not compatible with the row and column sums..
</p>


<h3>Value</h3>

<p>A feasible matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=matrix(c(1,0,0,1),nrow=2)
findFeasibleMatrix(c(1,1),c(1,1),p=p)

n &lt;- 4
M &lt;- matrix(nrow=n,ncol=n,rexp(n*n)*(runif(n*n)&gt;0.6))
M
r &lt;- rowSums(M)
c &lt;- colSums(M)
Mnew &lt;- findFeasibleMatrix(r=r,c=c,p=(M&gt;0)*0.5)
Mnew
rowSums(M);rowSums(Mnew)
colSums(M);colSums(Mnew)
</code></pre>

<hr>
<h2 id='findFeasibleMatrix_targetmean'>Creates a feasible starting matrix with a desired mean average degree</h2><span id='topic+findFeasibleMatrix_targetmean'></span>

<h3>Description</h3>

<p>This extension of <code><a href="#topic+findFeasibleMatrix">findFeasibleMatrix</a></code> attempts to
create a feasible matrix where a certain proportion of the entries
is positive. There is no guarantee that this proportion is
achieved. If it is not possible then this matrix will report a warning
and simply return the matrix constructed by findFeasibleMatrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFeasibleMatrix_targetmean(r, c, p, eps = 1e-09, targetmean = 0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findFeasibleMatrix_targetmean_+3A_r">r</code></td>
<td>
<p>vector of row sums (nonnegative</p>
</td></tr>
<tr><td><code id="findFeasibleMatrix_targetmean_+3A_c">c</code></td>
<td>
<p>vector of column sums (nonnegative)</p>
</td></tr>
<tr><td><code id="findFeasibleMatrix_targetmean_+3A_p">p</code></td>
<td>
<p>matrix of probabilities (must be in [0,1]), matching the dimensions of r and c. Values of p=0 are interpreted that the corresponding matrix elements have to be 0. Note: p=1 does not force the corresponding matrix element to exist.</p>
</td></tr>
<tr><td><code id="findFeasibleMatrix_targetmean_+3A_eps">eps</code></td>
<td>
<p>row and col sums can at most be different by eps.  Default 1e-9.</p>
</td></tr>
<tr><td><code id="findFeasibleMatrix_targetmean_+3A_targetmean">targetmean</code></td>
<td>
<p>Average proportion of positive entries of the resulting matrix. Defaults to 0.3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feasible matrix.
</p>

<hr>
<h2 id='genL'>Generate Liabilities Matrix from Prior</h2><span id='topic+genL'></span>

<h3>Description</h3>

<p>Generates a libabilities matrix using a the prior distribution from
a given model for p and lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genL(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genL_+3A_model">model</code></td>
<td>
<p>a model for p and lambda.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of a liabilities matrix and the parameter
vector theta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
m &lt;- Model.Indep.p.lambda(Model.p.BetaPrior(n),
                          Model.lambda.GammaPrior(n,scale=1e-1))
genL(m)

</code></pre>

<hr>
<h2 id='getfeasibleMatr'>Creates a feasible starting matrix</h2><span id='topic+getfeasibleMatr'></span>

<h3>Description</h3>

<p>Creates a matrix with nonnegative entries, given row and column
sums and 0 on the diagonal. Superseeded by the more flexible findFeasibleMatrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getfeasibleMatr(L, A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getfeasibleMatr_+3A_l">L</code></td>
<td>
<p>Vector of row sums</p>
</td></tr>
<tr><td><code id="getfeasibleMatr_+3A_a">A</code></td>
<td>
<p>Vector of column sums</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with nonnegative entries and given row/column sums
and 0 on the diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getfeasibleMatr(c(0.5,1,0),c(0.5,0,1))
getfeasibleMatr(rep(1,4),rep(1,4))
getfeasibleMatr(2^(1:3),2^(3:1))
getfeasibleMatr(1:5,1:5)
getfeasibleMatr(1:5,5:1)
</code></pre>

<hr>
<h2 id='GibbsSteps_kcycle'>Gibbs sampling step of a matrix in the ERE model</h2><span id='topic+GibbsSteps_kcycle'></span>

<h3>Description</h3>

<p>The sampling is conditional on row and column sums and uses k-cycle steps. Then dimensions of L, lambda and p must match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GibbsSteps_kcycle(L, lambda, p, it = 1000L, eps = 1e-10, debug = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GibbsSteps_kcycle_+3A_l">L</code></td>
<td>
<p>Starting matrix - will be modified to contain the results.</p>
</td></tr>
<tr><td><code id="GibbsSteps_kcycle_+3A_lambda">lambda</code></td>
<td>
<p>Matrix of intensities</p>
</td></tr>
<tr><td><code id="GibbsSteps_kcycle_+3A_p">p</code></td>
<td>
<p>Matrix of probabilities (must be in [0,1])</p>
</td></tr>
<tr><td><code id="GibbsSteps_kcycle_+3A_it">it</code></td>
<td>
<p>Number of iterations (default=1000)</p>
</td></tr>
<tr><td><code id="GibbsSteps_kcycle_+3A_eps">eps</code></td>
<td>
<p>Threshold for values to be interpreted as equal to 0 (default = 1e-10)</p>
</td></tr>
<tr><td><code id="GibbsSteps_kcycle_+3A_debug">debug</code></td>
<td>
<p>Should addtional debug information be printed? (0 no output, 1 output debug information)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- matrix(c(1,2,3,4,5,6,7,8,9),nrow=3)
diag(L) &lt;- 0
lambda &lt;- matrix(0.5,nrow=3,ncol=3)
p &lt;- matrix(0.7, nrow=3,ncol=3)
diag(p) &lt;- 0
GibbsSteps_kcycle(L=L,lambda=lambda,p=p)
L
L &lt;- matrix(1:16,nrow=4)
diag(L) &lt;- 0
lambda &lt;- matrix(0.5,nrow=4,ncol=4)
p &lt;- matrix(0.25, nrow=4,ncol=4)
diag(p) &lt;- 0
GibbsSteps_kcycle(L=L,lambda=lambda,p=p)
L
</code></pre>

<hr>
<h2 id='Model.additivelink.exponential.fitness'>Fitness model for liabilities matrix</h2><span id='topic+Model.additivelink.exponential.fitness'></span>

<h3>Description</h3>

<p>Assumes a diagonal consisting of 0s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.additivelink.exponential.fitness(
  n,
  alpha,
  beta,
  gamma = 1,
  lambdaprior,
  sdpropfitness = 1/sqrt(n)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.additivelink.exponential.fitness_+3A_n">n</code></td>
<td>
<p>Number of nodes in the model.</p>
</td></tr>
<tr><td><code id="Model.additivelink.exponential.fitness_+3A_alpha">alpha</code></td>
<td>
<p>Exponent of the power law of the degree distribution. Must be &lt;0.</p>
</td></tr>
<tr><td><code id="Model.additivelink.exponential.fitness_+3A_beta">beta</code></td>
<td>
<p>Lower endpoint of the relative expected out degree
(expected out degree divided by n-1). Must be &gt;=0.</p>
</td></tr>
<tr><td><code id="Model.additivelink.exponential.fitness_+3A_gamma">gamma</code></td>
<td>
<p>Upper endpoint of the relative expected out degree
(expected out degree divided by n-1). Must be at least beta and at most 1.</p>
</td></tr>
<tr><td><code id="Model.additivelink.exponential.fitness_+3A_lambdaprior">lambdaprior</code></td>
<td>
<p>Prior on zeta and eta. For the type of object
required see <code><a href="#topic+Model.fitness.genlambdaparprior">Model.fitness.genlambdaparprior</a></code>.</p>
</td></tr>
<tr><td><code id="Model.additivelink.exponential.fitness_+3A_sdpropfitness">sdpropfitness</code></td>
<td>
<p>Standard deviation for the log-normally
distributed multiplicative proposals for Metropoli-Hastings updates
of the fitness. Defaults to <code>1/sqrt{n}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model to be used by sample_HierarchicalModel. This is a
list of functions. It includes a function accrates() that repors acceptance rates for the Metropolis-Hasting steps involved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- Model.additivelink.exponential.fitness(10,alpha=-2.5,beta=0.1,
                lambdaprior=Model.fitness.genlambdaparprior(ratescale=1e3))
theta &lt;- mod$rtheta()
L &lt;- genL(mod)
l &lt;- rowSums(L$L)
a &lt;- colSums(L$L)
## increase number of samples and thinning in real examples
res &lt;- sample_HierarchicalModel(l=l,a=a,model=mod,nsamples=4,thin=50)
mod$accrates()
</code></pre>

<hr>
<h2 id='Model.fitness.conditionalmeandegree'>Mean out-degree of a node with given fitness in the fitness model</h2><span id='topic+Model.fitness.conditionalmeandegree'></span>

<h3>Description</h3>

<p>Computes the mean out-degree of a node with given fitness <code>x</code>
in the fitness model implemented in
<code><a href="#topic+Model.additivelink.exponential.fitness">Model.additivelink.exponential.fitness</a></code>. The function
returns the mean out-degree divided by n-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.fitness.conditionalmeandegree(x, alpha, beta, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.fitness.conditionalmeandegree_+3A_x">x</code></td>
<td>
<p>Fitness of node. A nonegative number.</p>
</td></tr>
<tr><td><code id="Model.fitness.conditionalmeandegree_+3A_alpha">alpha</code></td>
<td>
<p>Exponent of the power law of the degree distribution. Must be &lt;0.</p>
</td></tr>
<tr><td><code id="Model.fitness.conditionalmeandegree_+3A_beta">beta</code></td>
<td>
<p>Lower endpoint of the relative expected out degree
(expected out degree divided by n-1). Must be &gt;=0.</p>
</td></tr>
<tr><td><code id="Model.fitness.conditionalmeandegree_+3A_gamma">gamma</code></td>
<td>
<p>Upper endpoint of the relative expected out degree
(expected out degree divided by n-1). Must be at least beta and at most 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean out-degree divided by n-1.
</p>

<hr>
<h2 id='Model.fitness.genlambdaparprior'>Prior distribution for eta and zeta in the fitness model</h2><span id='topic+Model.fitness.genlambdaparprior'></span>

<h3>Description</h3>

<p>Assumes a uniform distribution on the shape parameter <code>zeta</code> and an
exponential distribution on the scale parameter <code>eta</code>. To be used
as prior for <code><a href="#topic+Model.additivelink.exponential.fitness">Model.additivelink.exponential.fitness</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.fitness.genlambdaparprior(
  shapemin = 0.75,
  shapemax = 1.5,
  ratescale,
  sdshapeprob = 0.1,
  sdpropscale = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.fitness.genlambdaparprior_+3A_shapemin">shapemin</code></td>
<td>
<p>Minimal Value of the shape parameter. Default: 0.75.</p>
</td></tr>
<tr><td><code id="Model.fitness.genlambdaparprior_+3A_shapemax">shapemax</code></td>
<td>
<p>Maximal Value of the shape parameter. Default: 1.5.</p>
</td></tr>
<tr><td><code id="Model.fitness.genlambdaparprior_+3A_ratescale">ratescale</code></td>
<td>
<p>Rate parameter for the prior distribution of the scale parameter. In the model this is on the same scale as the entries of <code>L</code></p>
</td></tr>
<tr><td><code id="Model.fitness.genlambdaparprior_+3A_sdshapeprob">sdshapeprob</code></td>
<td>
<p>Standard deviation for the additivel normally
distributed random walk proposal for the shape parameter. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="Model.fitness.genlambdaparprior_+3A_sdpropscale">sdpropscale</code></td>
<td>
<p>Standard deviation for the multiplicative
lognormal proposals for the scale parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of functions necessary for constructing
Metropolis-Hastings updates.
</p>

<hr>
<h2 id='Model.fitness.meandegree'>Mean out-degree of a random node  the fitness model</h2><span id='topic+Model.fitness.meandegree'></span>

<h3>Description</h3>

<p>Computes the relative mean out-degree of a randomly chosen node
given fitness <code>x</code> in the fitness model implemented in
<code><a href="#topic+Model.additivelink.exponential.fitness">Model.additivelink.exponential.fitness</a></code>. The function
returns the mean out-degree divided by n-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.fitness.meandegree(alpha, beta, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.fitness.meandegree_+3A_alpha">alpha</code></td>
<td>
<p>Exponent of the power law of the degree distribution. Must be &lt;0.</p>
</td></tr>
<tr><td><code id="Model.fitness.meandegree_+3A_beta">beta</code></td>
<td>
<p>Lower endpoint of the relative expected out degree
(expected out degree divided by n-1). Must be &gt;=0.</p>
</td></tr>
<tr><td><code id="Model.fitness.meandegree_+3A_gamma">gamma</code></td>
<td>
<p>Upper endpoint of the relative expected out degree
(expected out degree divided by n-1). Must be at least beta and at most 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean out-degree divided by n-1.
</p>

<hr>
<h2 id='Model.Indep.p.lambda'>Combination of Independent Models for p and lambda</h2><span id='topic+Model.Indep.p.lambda'></span>

<h3>Description</h3>

<p>Combination of Independent Models for p and lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.Indep.p.lambda(model.p, model.lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.Indep.p.lambda_+3A_model.p">model.p</code></td>
<td>
<p>model for p.</p>
</td></tr>
<tr><td><code id="Model.Indep.p.lambda_+3A_model.lambda">model.lambda</code></td>
<td>
<p>model for lambda.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
m &lt;- Model.Indep.p.lambda(Model.p.BetaPrior(n),
                          Model.lambda.GammaPrior(n,scale=1e-1))
genL(m)

</code></pre>

<hr>
<h2 id='Model.lambda.constant'>Model for a Constant lambda</h2><span id='topic+Model.lambda.constant'></span>

<h3>Description</h3>

<p>This model assumes that the parameter lambda is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.lambda.constant(lambda, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.lambda.constant_+3A_lambda">lambda</code></td>
<td>
<p>paramer for the size of the liabilities. Either a matrix of
dimension n or a single numeric value.</p>
</td></tr>
<tr><td><code id="Model.lambda.constant_+3A_n">n</code></td>
<td>
<p>dimension of matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- Model.lambda.constant(n=5,lambda=0.25)
m$matr(m$rtheta())
lambda&lt;-matrix(c(NA,1,1,1e-4,NA,1e-4,1e4,1e4,NA),nrow=3)
m &lt;- Model.lambda.constant(n=3,lambda=lambda)
m$matr(m$rtheta())
</code></pre>

<hr>
<h2 id='Model.lambda.constant.nonsquare'>Model for a Constant lambda and Non-Square Matrices</h2><span id='topic+Model.lambda.constant.nonsquare'></span>

<h3>Description</h3>

<p>This model assumes that the parameter lambda is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.lambda.constant.nonsquare(lambda, nrow, ncol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.lambda.constant.nonsquare_+3A_lambda">lambda</code></td>
<td>
<p>paramer for the size of the liabilities. A single numeric value.</p>
</td></tr>
<tr><td><code id="Model.lambda.constant.nonsquare_+3A_nrow">nrow</code></td>
<td>
<p>number of rows of the matrix.</p>
</td></tr>
<tr><td><code id="Model.lambda.constant.nonsquare_+3A_ncol">ncol</code></td>
<td>
<p>number of columns of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- Model.lambda.constant.nonsquare(nrow=5,ncol=3,lambda=0.25)
m$matr(m$rtheta())
</code></pre>

<hr>
<h2 id='Model.lambda.GammaPrior'>Model with Gamma Prior on Lambda</h2><span id='topic+Model.lambda.GammaPrior'></span>

<h3>Description</h3>

<p>Assumes that all elements of lambda are equal to a parameter
<code class="reqn">\theta</code>, which has a Gamma prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.lambda.GammaPrior(n, shape = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.lambda.GammaPrior_+3A_n">n</code></td>
<td>
<p>dimension of matrix</p>
</td></tr>
<tr><td><code id="Model.lambda.GammaPrior_+3A_shape">shape</code></td>
<td>
<p>shape paramer for prior on
<code class="reqn">\theta</code>. Default 1.</p>
</td></tr>
<tr><td><code id="Model.lambda.GammaPrior_+3A_scale">scale</code></td>
<td>
<p>scale paramer for prior on
<code class="reqn">\theta</code>. Default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting model.
</p>

<hr>
<h2 id='Model.lambda.Gammaprior_mult'>Model Using Multiple Independent Components</h2><span id='topic+Model.lambda.Gammaprior_mult'></span>

<h3>Description</h3>

<p>Assumes a multivariate hyperparameter <code class="reqn">\theta</code> with each
component following an independent Beta distribution. A matrix
indicates which component <code class="reqn">\theta</code> is used for what
component of lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.lambda.Gammaprior_mult(Ilambda, shape = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.lambda.Gammaprior_mult_+3A_ilambda">Ilambda</code></td>
<td>
<p>matrix consisting of integers that describe which
component of <code class="reqn">theta</code> is used for a given position in the
matrix. Must consist of nonnegative integers using all integers in
the range.</p>
</td></tr>
<tr><td><code id="Model.lambda.Gammaprior_mult_+3A_shape">shape</code></td>
<td>
<p>shape paramer for prior on
<code class="reqn">\theta</code>. Default 1.</p>
</td></tr>
<tr><td><code id="Model.lambda.Gammaprior_mult_+3A_scale">scale</code></td>
<td>
<p>scale paramer for prior on
<code class="reqn">\theta</code>. Default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting model.
</p>

<hr>
<h2 id='Model.p.BetaPrior'>Model for a Random One-dimensional p</h2><span id='topic+Model.p.BetaPrior'></span>

<h3>Description</h3>

<p>Assumes a Beta prior on the one-dimensional link existence
probabilities p. This model has a one-dimensional parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.p.BetaPrior(n, shape1 = 1, shape2 = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.p.BetaPrior_+3A_n">n</code></td>
<td>
<p>dimension of matrix.</p>
</td></tr>
<tr><td><code id="Model.p.BetaPrior_+3A_shape1">shape1</code></td>
<td>
<p>first parameter of Beta prior. Default 1.</p>
</td></tr>
<tr><td><code id="Model.p.BetaPrior_+3A_shape2">shape2</code></td>
<td>
<p>second  parameter of Beta prior. Default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- Model.p.BetaPrior(5)
m$matr(m$rtheta())
</code></pre>

<hr>
<h2 id='Model.p.Betaprior_mult'>Model Using Multiple Independent Components</h2><span id='topic+Model.p.Betaprior_mult'></span>

<h3>Description</h3>

<p>Assumes a multivariate hyperparameter <code class="reqn">\theta</code> with each
component following an independent Beta distribution. A matrix
indicates which component <code class="reqn">\theta</code> is used for what
component of p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.p.Betaprior_mult(Ip, shape1 = 1, shape2 = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.p.Betaprior_mult_+3A_ip">Ip</code></td>
<td>
<p>matrix consisting of integers that describe which
component of <code class="reqn">theta</code> is used for a given position in the
matrix. Must consist of nonnegative integers (0 encoding forced 0s
in the matrix), using all integers in the range.</p>
</td></tr>
<tr><td><code id="Model.p.Betaprior_mult_+3A_shape1">shape1</code></td>
<td>
<p>first parameter of Beta prior on
<code class="reqn">theta</code>. Default 1.</p>
</td></tr>
<tr><td><code id="Model.p.Betaprior_mult_+3A_shape2">shape2</code></td>
<td>
<p>second parameter of Beta prior
<code class="reqn">theta</code>. Default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting model.
</p>

<hr>
<h2 id='Model.p.constant'>Model for a Constant p</h2><span id='topic+Model.p.constant'></span>

<h3>Description</h3>

<p>This model assumes that the link existence probabilities of the
matrix are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.p.constant(n, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.p.constant_+3A_n">n</code></td>
<td>
<p>dimension of matrix.</p>
</td></tr>
<tr><td><code id="Model.p.constant_+3A_p">p</code></td>
<td>
<p>existence probability of a link. Either a matrix of
dimension n or a single numeric value. A single numeric value leads
to a matrix of existence probabilities that has 0 on the diagonal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- Model.p.constant(5,0.25)
m$matr(m$rtheta())

p &lt;- matrix(c(0,0.99,0.99,0.5,0.5,0,0.01,0.01,0),nrow=3)
m &lt;- Model.p.constant(5,p)
m$matr(m$rtheta())
</code></pre>

<hr>
<h2 id='Model.p.constant.nonsquare'>Model for a constant p and Non-Square Matrices</h2><span id='topic+Model.p.constant.nonsquare'></span>

<h3>Description</h3>

<p>This model assumes that the link existence probabilities of the
matrix are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.p.constant.nonsquare(nrow, ncol, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.p.constant.nonsquare_+3A_nrow">nrow</code></td>
<td>
<p>number of rows of the matrix.</p>
</td></tr>
<tr><td><code id="Model.p.constant.nonsquare_+3A_ncol">ncol</code></td>
<td>
<p>number of columns of the matrix.</p>
</td></tr>
<tr><td><code id="Model.p.constant.nonsquare_+3A_p">p</code></td>
<td>
<p>existence probability of a link.  A single numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- Model.p.constant.nonsquare(5,3,0.25)
m$matr(m$rtheta())

</code></pre>

<hr>
<h2 id='Model.p.Fitness.Servedio'>Multiplicative Fitness Model for Power Law</h2><span id='topic+Model.p.Fitness.Servedio'></span>

<h3>Description</h3>

<p>This model has a power law of the degree distribution with a
parameter <code class="reqn">\alpha</code> and is tuned to a desired link
existence probability. It is based on a fitness model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.p.Fitness.Servedio(n, alpha, meandegree, sdprop = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.p.Fitness.Servedio_+3A_n">n</code></td>
<td>
<p>dimension of matrix.</p>
</td></tr>
<tr><td><code id="Model.p.Fitness.Servedio_+3A_alpha">alpha</code></td>
<td>
<p>exponent for power law. Must be &lt;=-1.</p>
</td></tr>
<tr><td><code id="Model.p.Fitness.Servedio_+3A_meandegree">meandegree</code></td>
<td>
<p>overall mean degree (expected degree divided by number of nodes). Must be in (0,1).</p>
</td></tr>
<tr><td><code id="Model.p.Fitness.Servedio_+3A_sdprop">sdprop</code></td>
<td>
<p>standard deviation of updated steps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every node <code class="reqn">i</code> has a fitness <code class="reqn">\theta_i</code> being an
independent realisation of a U[0,1] distribution.  The probability
of a link between a node with fitness x and a node with fitness y
is g(x)g(y) where g is as follows.  If <code class="reqn">\alpha=-1</code>
then </p>
<p style="text-align: center;"><code class="reqn">g(x)=g0*\exp(-\log(g0)*x)</code>
</p>

<p>Otherwise,
</p>
<p style="text-align: center;"><code class="reqn">g(x)=(g0^(\alpha+1)+(1-g0^(\alpha+1))*x)^(1/(\alpha+1))</code>
</p>

<p>where <code class="reqn">g0</code> is tuned numerically to achieve the desired
overall mean degree.
</p>
<p>Updating of the model parameters in the MCMC setup is done via a
Metropolis-Hastings step, adding independent centered normal random
variables to each node fitness in <code class="reqn">\theta</code>.
</p>


<h3>Value</h3>

<p>the resulting model.
</p>


<h3>References</h3>

<p>Servedio V. D. P. and Caldarelli G. and Butta P. (2004)
Vertex intrinsic fitness: How to produce arbitrary scale-free networks.
<em>Physical Review E</em> 70, 056126.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
mf &lt;- Model.p.Fitness.Servedio(n=n,alpha=-2.5,meandegree=0.5)
m &lt;- Model.Indep.p.lambda(model.p=mf,
                          model.lambda=Model.lambda.GammaPrior(n,scale=1e-1))
x &lt;- genL(m)
l &lt;- rowSums(x$L)
a &lt;- colSums(x$L)
res &lt;- sample_HierarchicalModel(l,a,model=m,nsamples=10,thin=10)


</code></pre>

<hr>
<h2 id='sample_ERE'>Sample from the ERE model with given row and column sums</h2><span id='topic+sample_ERE'></span>

<h3>Description</h3>

<p>Samples from the Erdos Reny model with Exponential weights and
known marginals.  Runs a Gibbs sampler to do this. A starting
liabilities is generated via <code><a href="#topic+getfeasibleMatr">getfeasibleMatr</a></code> before
<code><a href="#topic+steps_ERE">steps_ERE</a></code> is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_ERE(l, a, p, lambda, nsamples = 10000, thin = 1000, burnin = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_ERE_+3A_l">l</code></td>
<td>
<p>vector of interbank libabilities</p>
</td></tr>
<tr><td><code id="sample_ERE_+3A_a">a</code></td>
<td>
<p>vector of interbank assets</p>
</td></tr>
<tr><td><code id="sample_ERE_+3A_p">p</code></td>
<td>
<p>probability of existence of a link (either a numerical
value or a matrix). A single numerical value is converted into a
matrix with 0s on the diagonal.</p>
</td></tr>
<tr><td><code id="sample_ERE_+3A_lambda">lambda</code></td>
<td>
<p>instensity parameters - either a numerical value or a
matrix with positive entries)</p>
</td></tr>
<tr><td><code id="sample_ERE_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of samples to return.</p>
</td></tr>
<tr><td><code id="sample_ERE_+3A_thin">thin</code></td>
<td>
<p>Frequency at which samples should be generated (default=1, every step)</p>
</td></tr>
<tr><td><code id="sample_ERE_+3A_burnin">burnin</code></td>
<td>
<p>Number of initial steps to discard.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of simulation results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- c(1,2.5,3)
a &lt;- c(0.7,2.7,3.1)
L &lt;- sample_ERE(l,a,p=0.5,lambda=0.25,nsamples=5,thin=20,burnin=10)
L


</code></pre>

<hr>
<h2 id='sample_HierarchicalModel'>Sample from Hierarchical Model with given Row and Column Sums</h2><span id='topic+sample_HierarchicalModel'></span>

<h3>Description</h3>

<p>Sample from Hierarchical Model with given Row and Column Sums
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_HierarchicalModel(
  l,
  a,
  L_fixed = NA,
  model,
  nsamples = 10000,
  thin = choosethin(l = l, a = a, L_fixed = L_fixed, model = model, matrpertheta =
    matrpertheta, silent = silent),
  burnin = NA,
  matrpertheta = length(l)^2,
  silent = FALSE,
  tol = .Machine$double.eps^0.25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_HierarchicalModel_+3A_l">l</code></td>
<td>
<p>observed row sum</p>
</td></tr>
<tr><td><code id="sample_HierarchicalModel_+3A_a">a</code></td>
<td>
<p>observerd column sum</p>
</td></tr>
<tr><td><code id="sample_HierarchicalModel_+3A_l_fixed">L_fixed</code></td>
<td>
<p>Matrix containing known values of L, where NA
signifies that an element is not known. If <code>L_fixed</code> equates
to <code>NA</code> (the default) then no values are assumed to be known.</p>
</td></tr>
<tr><td><code id="sample_HierarchicalModel_+3A_model">model</code></td>
<td>
<p>Underlying model for p and lambda.</p>
</td></tr>
<tr><td><code id="sample_HierarchicalModel_+3A_nsamples">nsamples</code></td>
<td>
<p>number of samples to return.</p>
</td></tr>
<tr><td><code id="sample_HierarchicalModel_+3A_thin">thin</code></td>
<td>
<p>how many updates of theta to perform before outputting a sample.</p>
</td></tr>
<tr><td><code id="sample_HierarchicalModel_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations for the burnin. Defaults to 5
of the steps in the sampling part.</p>
</td></tr>
<tr><td><code id="sample_HierarchicalModel_+3A_matrpertheta">matrpertheta</code></td>
<td>
<p>number of matrix updates per update of theta.</p>
</td></tr>
<tr><td><code id="sample_HierarchicalModel_+3A_silent">silent</code></td>
<td>
<p>(default FALSE) suppress all output (including progress bars).</p>
</td></tr>
<tr><td><code id="sample_HierarchicalModel_+3A_tol">tol</code></td>
<td>
<p>tolerance used in checks for equality. Defaults to <code>.Machine$double.eps^0.25</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting samples. A list with the first element, L, giving the samples of matrices, and the second element, theta, giving the samples of the hyperparameter (if hyperparameters are present).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
m &lt;- Model.Indep.p.lambda(Model.p.BetaPrior(n),
                          Model.lambda.GammaPrior(n,scale=1e-1))
x &lt;- genL(m)
l &lt;- rowSums(x$L)
a &lt;- colSums(x$L)

res &lt;- sample_HierarchicalModel(l,a,model=m)

# fixing one values
L_fixed &lt;- matrix(NA,ncol=n,nrow=n)
L_fixed[1,2:5] &lt;- x$L[1,2:5]

res &lt;- sample_HierarchicalModel(l,a,model=m,L_fixed=L_fixed,
                                nsamples=1e2)
sapply(res$L,function(x)x[1,2:5])


</code></pre>

<hr>
<h2 id='steps_ERE'>Perform Steps of the Gibbs Sampler of the ERE model</h2><span id='topic+steps_ERE'></span>

<h3>Description</h3>

<p>Runs a Gibbs sampler in the Erdos Reny model with Exponential weights (ERE model)
and fixed marginals. The algorithm starts from a given matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steps_ERE(L, p, lambda, nsamples = 10000, thin = 1000, burnin = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="steps_ERE_+3A_l">L</code></td>
<td>
<p>Starting matrix for the Gibbs sampler. Implicitly defines the fixed marginals.</p>
</td></tr>
<tr><td><code id="steps_ERE_+3A_p">p</code></td>
<td>
<p>A matrix with entries in [0,1]</p>
</td></tr>
<tr><td><code id="steps_ERE_+3A_lambda">lambda</code></td>
<td>
<p>A matrix with nonnegative entries</p>
</td></tr>
<tr><td><code id="steps_ERE_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of samples to return.</p>
</td></tr>
<tr><td><code id="steps_ERE_+3A_thin">thin</code></td>
<td>
<p>Frequency at which samples should be generated (default=1, every step)</p>
</td></tr>
<tr><td><code id="steps_ERE_+3A_burnin">burnin</code></td>
<td>
<p>Number of initial steps to discard.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of simulation results
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_ERE">sample_ERE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- matrix(rexp(4*4),nrow=4,ncol=4); diag(L)=0;
p &lt;- matrix(0.5,nrow=4,ncol=4); diag(p) &lt;-0;
lambda &lt;- matrix(1,nrow=4,ncol=4); diag(lambda)&lt;-0;

L &lt;- steps_ERE(L=L,p=p,lambda=lambda,nsamples=5,thin=50,burnin=20)
L

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
