<!DOCTYPE html><html><head><title>Help for package datelife</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {datelife}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.get_ott_lineage'><p>Get the lineage of a set of taxa.</p>
<code>.get_ott_lineage</code> uses <code>rotl::taxonomy_taxon_info()</code> with <code>include_lineage = TRUE</code>.</a></li>
<li><a href='#birds_and_cats'><p>A multiPhylo object with trees resulting from a datelife search of some birds and cats species</p></a></li>
<li><a href='#build_grove_list'><p>Build grove list</p></a></li>
<li><a href='#build_grove_matrix'><p>Find the grove for a group of chronograms and build a matrix.</p></a></li>
<li><a href='#check_conflicting_calibrations'><p>Check for conflicting calibrations.</p></a></li>
<li><a href='#check_ott_input'><p>Check input for usage in other <code>datelife</code> functions</p></a></li>
<li><a href='#choose_cluster'><p>Choose an ultrametric phylo object from <code>cluster_patristicmatrix()</code> obtained</p>
with a particular clustering method, or the next best tree.
If there are no ultrametric trees, it does not force them to be ultrametric.</a></li>
<li><a href='#classification_paths_from_taxonomy'><p>Gets classification paths for a vector of taxa</p></a></li>
<li><a href='#clean_ott_chronogram'><p>Clean up some issues with Open Tree of Life chronograms</p>
For now it 1) checks unmapped taxa and maps them with tnrs_match.phylo, 2) roots the chronogram if unrooted</a></li>
<li><a href='#clean_taxon_info_children'><p>Identify, extract and clean taxonomic children names from a <code>taxonomy_taxon_info()</code></p>
output.</a></li>
<li><a href='#clean_tnrs'><p>Eliminates unmatched (NAs) and invalid taxa from a <code>rotl::tnrs_match_names()</code> or <code>tnrs_match()</code> output</p>
Useful to get ott ids to retrieve an induced synthetic Open Tree of Life.
Needed because using <code>include_suppressed = FALSE</code> in <code>rotl::tnrs_match_names()</code> does not drop all invalid taxa.</a></li>
<li><a href='#cluster_patristicmatrix'><p>Cluster a patristic matrix into a tree with various methods.</p></a></li>
<li><a href='#congruify_and_check'><p>Congruify and Check.</p></a></li>
<li><a href='#congruify_and_mrca_multiPhylo'><p>Congruify nodes of a tree topology to nodes from a source chronogram, and find the mrca nodes</p></a></li>
<li><a href='#congruify_and_mrca_phylo'><p>Congruify nodes of a tree topology to nodes from a source chronogram, and find the mrca nodes</p></a></li>
<li><a href='#contributor_cache'><p>Information on contributors, authors, study ids and clades from studies with</p>
chronograms in Open Tree of Life (Open Tree)</a></li>
<li><a href='#date_with_pbdb'><p>Date with Paleobiology Database and paleotree.</p></a></li>
<li><a href='#datelife_authors_tabulate'><p>Return the relevant authors for a set of studies.</p></a></li>
<li><a href='#datelife_result_median'><p>Get a median summary chronogram from a <code>datelifeResult</code> object.</p></a></li>
<li><a href='#datelife_result_median_matrix'><p>Compute a median matrix of a <code>datelifeResult</code> object.</p></a></li>
<li><a href='#datelife_result_MRCA'><p>Get a numeric vector of MRCAs from a <code>datelifeResult</code> object. Used in <code>summarize_datelife_result()</code>.</p></a></li>
<li><a href='#datelife_result_sdm_matrix'><p>Go from a <code>datelifeResult</code> object to a Super Distance Matrix (SDM) using weighting = &quot;flat&quot;</p></a></li>
<li><a href='#datelife_result_sdm_phylo'><p>Reconstruct a supertree from a <code>datelifeResult</code> object using the Super Distance Matrix (SDM) method.</p></a></li>
<li><a href='#datelife_result_study_index'><p>Find the index of relevant studies in a cached chronogram database.</p></a></li>
<li><a href='#datelife_result_variance_matrix'><p>Compute a variance matrix of a <code>datelifeResult</code> object.</p></a></li>
<li><a href='#datelife_search'><p>Get scientific, peer-reviewed information on time of lineage</p>
divergence openly available for a given set of taxon names</a></li>
<li><a href='#datelife_use'><p>Generate one or multiple chronograms for a set of given taxon names.</p></a></li>
<li><a href='#datelife_use_datelifequery'><p>Generate one or multiple chronograms for a set of taxon names given as a <code>datelifeQuery</code> object.</p></a></li>
<li><a href='#extract_calibrations_dateliferesult'><p>Use congruification to extract secondary calibrations from a <code>datelifeResult</code> object.</p></a></li>
<li><a href='#extract_calibrations_phylo'><p>Use congruification to extract secondary calibrations from a <code>phylo</code> or <code>multiPhylo</code></p>
object with branch lengths proportional to time.</a></li>
<li><a href='#extract_ott_ids'><p>Extract numeric OTT ids from a character vector that combines taxon names and OTT ids.</p></a></li>
<li><a href='#felid_gdr_phylo_all'><p>datelifeSummary of a datelifeResult object of all Felidae species.</p></a></li>
<li><a href='#felid_sdm'><p>SDM tree of a datelifeResult object of all Felidae species.</p></a></li>
<li><a href='#filter_for_grove'><p>Filter a <code>datelifeResult</code> object to find the largest grove.</p></a></li>
<li><a href='#force_ultrametric'><p>Force a non-ultrametric <code>phylo</code> object to be ultrametric with <code>phytools::force.ultrametric()</code>.</p></a></li>
<li><a href='#get_all_calibrations'><p>Get secondary calibrations from a chronogram database for a set of given taxon names</p></a></li>
<li><a href='#get_all_descendant_species'><p>Quickly get all species belonging to a taxon from the Open Tree of Life Taxonomy (OTT)</p></a></li>
<li><a href='#get_best_grove'><p>Get grove from a <code>datelifeResult</code> object that can be converted to phylo</p>
from a median summary matrix</a></li>
<li><a href='#get_biggest_multiphylo'><p>Get the tree with the most tips from a multiPhylo object: the biggest tree.</p></a></li>
<li><a href='#get_bold_data'><p>Get genetic data from the Barcode of Life Database (BOLD) for a set of taxon names.</p></a></li>
<li><a href='#get_calibrations_datelifequery'><p>Search and extract available secondary calibrations for taxon names in a given</p>
<code>datelifeQuery</code> object</a></li>
<li><a href='#get_calibrations_vector'><p>Search and extract secondary calibrations for a given character</p>
vector of taxon names</a></li>
<li><a href='#get_dated_otol_induced_subtree'><p>Get a dated OpenTree induced synthetic subtree from a set of given taxon names, from blackrim's FePhyFoFum service.</p></a></li>
<li><a href='#get_datelife_result'><p>Get a patristic matrix of time of lineage divergence data for a given set of taxon names</p></a></li>
<li><a href='#get_datelife_result_datelifequery'><p>Get a list of patristic matrices from a given <code>datelifeQuery</code> object</p></a></li>
<li><a href='#get_fossil_range'><p>Get the ages for a taxon from PBDB</p></a></li>
<li><a href='#get_goodmatrices'><p>Get indices of good matrices to apply Super Distance Matrix (SDM) method with <code>make_sdm()</code>.</p></a></li>
<li><a href='#get_mrbayes_node_constraints'><p>Makes a block of node constraints and node calibrations for a MrBayes run file</p>
from a list of taxa and ages, or from a dated tree</a></li>
<li><a href='#get_opentree_chronograms'><p>Get all chronograms from Open Tree of Life database</p></a></li>
<li><a href='#get_opentree_species'><p>Get all species belonging to a taxon from the Open Tree of Life Taxonomy (OTT)</p></a></li>
<li><a href='#get_otol_synthetic_tree'><p>Get an Open Tree of Life synthetic subtree of a set of given taxon names.</p></a></li>
<li><a href='#get_ott_children'><p>Use this instead of <code>rotl::tol_subtree()</code> when taxa are not in synthesis tree and</p>
you still need to get all species or an induced OpenTree subtree</a></li>
<li><a href='#get_ott_clade'><p>Get the Open Tree of Life Taxonomic identifiers (OTT ids) and name of one or</p>
several given taxonomic ranks from one or more input taxa.</a></li>
<li><a href='#get_ott_lineage'><p>Get the Open Tree of Life Taxonomic identifier (OTT id) and name of all lineages</p>
from one or more input taxa.</a></li>
<li><a href='#get_subset_array_dispatch'><p>Figure out which subset function to use.</p></a></li>
<li><a href='#get_taxon_summary'><p>Get a taxon summary of a <code>datelifeResult</code> object.</p></a></li>
<li><a href='#get_tnrs_names'><p>Process a character vector of taxon names with TNRS</p></a></li>
<li><a href='#get_valid_children'><p>Extract valid children from given taxonomic name(s) or Open Tree of Life</p>
Taxonomic identifiers (OTT ids) from a taxonomic source.</a></li>
<li><a href='#input_process'><p>Process a phylo object or a character string to determine if it's correct newick</p></a></li>
<li><a href='#is_datelife_query'><p>Check if input is a <code>datelifeQuery</code> object</p></a></li>
<li><a href='#is_datelife_result_empty'><p>Check if we obtained an empty search with the given taxon name(s).</p></a></li>
<li><a href='#is_good_chronogram'><p>Check if a tree is a valid chronogram.</p></a></li>
<li><a href='#is_n_overlap'><p>Function for computing n-overlap for two vectors of names (ie., phy1$tip.label, phy2$tip.label) and seeing if they have n overlap</p></a></li>
<li><a href='#make_all_associations'><p>Find all authors and where they have deposited their trees</p></a></li>
<li><a href='#make_bladj_tree'><p>Use the BLADJ algorithm to get a chronogram from a tree topology for which you have age data for some of its nodes.</p></a></li>
<li><a href='#make_bold_otol_tree'><p>Use genetic data from the Barcode of Life Database (BOLD) to reconstruct branch lengths on a tree.</p></a></li>
<li><a href='#make_contributor_cache'><p>Create a cache from Open Tree of Life</p></a></li>
<li><a href='#make_datelife_query'><p>Go from taxon names to a <code>datelifeQuery</code> object</p></a></li>
<li><a href='#make_datelife_query2'><p>Go from taxon names to a <code>datelifeQuery</code> object</p></a></li>
<li><a href='#make_mrbayes_runfile'><p>Make a mrBayes run block file with a constraint topology and a set of node</p>
calibrations and missing taxa</a></li>
<li><a href='#make_mrbayes_tree'><p>Take a constraint tree and use mrBayes to get node ages and branch lengths</p>
given a set of node calibrations without any data.</a></li>
<li><a href='#make_otol_associations'><p>Associate Open Tree of Life authors with studies</p></a></li>
<li><a href='#make_overlap_table'><p>Create an overlap table</p></a></li>
<li><a href='#make_sdm'><p>Make a Super Distance Matrix (SDM) from a list of good matrices obtained with <code>get_goodmatrices()</code></p></a></li>
<li><a href='#make_treebase_associations'><p>Associate TreeBase authors with studies</p></a></li>
<li><a href='#make_treebase_cache'><p>Create a cache from TreeBase</p></a></li>
<li><a href='#map_nodes_ott'><p>Add Open Tree of Life Taxonomy to tree nodes.</p></a></li>
<li><a href='#match_all_calibrations'><p>Match calibrations to nodes of a given tree</p></a></li>
<li><a href='#matrices_to_table'><p>Go from a list of patristic distance matrix to a table of node ages</p></a></li>
<li><a href='#matrix_to_table'><p>Go from a patristic distance matrix to a node ages table</p></a></li>
<li><a href='#message_multiphylo'><p>Message for a <code>multiPhylo</code> input</p></a></li>
<li><a href='#missing_taxa_check'><p>Checks that missing_taxa argument is ok to be used by make_mrbayes_runfile inside tree_add_dates functions.</p></a></li>
<li><a href='#mrca_calibrations'><p>Identify nodes of a tree topology that are most recent common ancestor (mrca)</p>
of taxon pairs from a <code>calibrations</code> object</a></li>
<li><a href='#opentree_chronograms'><p>Chronogram database</p></a></li>
<li><a href='#patristic_matrix_array_congruify'><p><code>patristic_matrix_array_congruify</code> is used for patristic_matrix_array_subset_both and patristic_matrix_array_congruify.</p></a></li>
<li><a href='#patristic_matrix_array_phylo_congruify'><p>Congruify a patristic matrix array from a given <code>phylo</code> object.</p></a></li>
<li><a href='#patristic_matrix_array_split'><p>Split a patristic matrix array</p>
Used inside: patristic_matrix_array_congruify</a></li>
<li><a href='#patristic_matrix_array_subset'><p>Subset a patristic matrix array</p></a></li>
<li><a href='#patristic_matrix_array_subset_both'><p>Are all desired taxa in the patristic matrix array?</p></a></li>
<li><a href='#patristic_matrix_list_to_array'><p>Convert list of patristic matrices to a 3D array.</p></a></li>
<li><a href='#patristic_matrix_MRCA'><p>Get time of MRCA from patristic matrix. Used in <code>datelife_result_MRCA()</code>.</p></a></li>
<li><a href='#patristic_matrix_name_order_test'><p>Test the name order of a patristic matrix so that row and column labels are in alphabetical order.</p></a></li>
<li><a href='#patristic_matrix_name_reorder'><p>Reorder a matrix so that row and column labels are in alphabetical order.</p></a></li>
<li><a href='#patristic_matrix_pad'><p>Fill in empty cells in a patristic matrix for missing taxa.</p></a></li>
<li><a href='#patristic_matrix_taxa_all_matching'><p>Are all desired taxa in the patristic matrix?</p></a></li>
<li><a href='#patristic_matrix_to_newick'><p>Convert patristic matrix to a newick string. Used inside: summarize_datelife_result.</p></a></li>
<li><a href='#patristic_matrix_to_phylo'><p>Convert a patristic matrix to a <code>phylo</code> object.</p></a></li>
<li><a href='#patristic_matrix_unpad'><p>Function to remove missing taxa from a <code>datelifeResult</code> object.</p></a></li>
<li><a href='#phylo_check'><p>Checks if <code>phy</code> is a <code>phylo</code> object and/or a chronogram.</p></a></li>
<li><a href='#phylo_congruify'><p>Congruify a reference tree and a target tree given as <code>phylo</code> objects.</p></a></li>
<li><a href='#phylo_generate_uncertainty'><p>Generate uncertainty in branch lengths using a lognormal.</p></a></li>
<li><a href='#phylo_get_node_numbers'><p>Gets node numbers from any phylogeny</p></a></li>
<li><a href='#phylo_get_subset_array'><p>Get a subset array from a <code>phylo</code> object</p></a></li>
<li><a href='#phylo_get_subset_array_congruify'><p>Get a congruified subset array from a <code>phylo</code> object</p></a></li>
<li><a href='#phylo_has_brlen'><p>Check if a tree has branch lengths</p></a></li>
<li><a href='#phylo_prune_missing_taxa'><p>Prune missing taxa from a <code>phylo</code> object</p>
Used inside phylo_get_subset_array and phylo_get_subset_array_congruify.</a></li>
<li><a href='#phylo_subset_both'><p>Subset a reference and a target tree given as <code>phylo</code> objects.</p></a></li>
<li><a href='#phylo_tiplabel_space_to_underscore'><p>Convert spaces to underscores in trees.</p></a></li>
<li><a href='#phylo_tiplabel_underscore_to_space'><p>Convert underscores to spaces in trees.</p></a></li>
<li><a href='#phylo_to_patristic_matrix'><p>Get a patristic matrix from a <code>phylo</code> object.</p></a></li>
<li><a href='#pick_grove'><p>Pick a grove in the case of multiple groves in a set of trees.</p></a></li>
<li><a href='#plant_bold_otol_tree'><p>Some plants chronogram</p></a></li>
<li><a href='#problems'><p>Problematic chronograms from Open Tree of Life.</p></a></li>
<li><a href='#recover_mrcaott'><p>Get an mrcaott tag from an OpenTree induced synthetic tree and get its name and ott id</p></a></li>
<li><a href='#relevant_curators_tabulate'><p>Return the relevant curators for a set of studies.</p></a></li>
<li><a href='#results_list_process'><p>Take results_list and process it.</p></a></li>
<li><a href='#run'><p>Core function to generate results</p></a></li>
<li><a href='#run_mrbayes'><p>Runs MrBayes from R</p></a></li>
<li><a href='#sample_trees'><p>Sample trees from a file containing multiple trees. Usually from a bayesian analysis output trees file.</p></a></li>
<li><a href='#some_ants_datelife_result'><p>datelifeResult object of some ants</p></a></li>
<li><a href='#subset2_search'><p>A list with datelifeQuery and datelifeResult objects from a search of taxon names from subset2_taxa</p></a></li>
<li><a href='#subset2_taxa'><p>Long list of &gt;2.7k virus, bacteria, plant and animal taxon names</p></a></li>
<li><a href='#summarize_congruifiedCalibrations'><p>Get summary statistics of ages in a <code>congruifiedCalibrations</code> object.</p></a></li>
<li><a href='#summarize_datelife_result'><p>Summarize a <code>datelifeResult</code> object.</p></a></li>
<li><a href='#summarize_fossil_range'><p>Summarize taxon age from PBDB to just a single min and max age</p></a></li>
<li><a href='#summarize_summary_matrix'><p>Gets all ages per taxon pair from a distance matrix</p>
Internal function used in summary_matrix_to_phylo_all().</a></li>
<li><a href='#summary_matrix_to_phylo'><p>Go from a summary matrix to an ultrametric <code>phylo</code> object.</p></a></li>
<li><a href='#summary_matrix_to_phylo_all'><p>Get minimum, median, mean, midpoint, and maximum summary chronograms from a</p>
summary matrix of a <code>datelifeResult</code> object.</a></li>
<li><a href='#summary_patristic_matrix_array'><p>Summarize patristic matrix array (by default, median). Used inside: summarize_datelife_result.</p></a></li>
<li><a href='#summary.datelifeResult'><p>Summarize a <code>datelifeResult</code> object.</p></a></li>
<li><a href='#summary.matchedCalibrations'><p>Summarize a <code>matchedCalibrations</code> object</p>
<code>summary.matchedCalibrations</code> gets the node age distribution from a <code>matchedCalibrations</code> object.</a></li>
<li><a href='#threebirds_dr'><p><code>datelifeResult</code> object of three birds &quot;Rhea americana&quot;, &quot;Pterocnemia pennata&quot;, and &quot;Struthio camelus&quot;</p></a></li>
<li><a href='#tnrs_match'><p>Taxon name resolution service (tnrs) applied to a vector of names by batches</p></a></li>
<li><a href='#tree_add_dates'><p>Add missing taxa to a dated tree and fabricate node ages for these missing taxa.</p></a></li>
<li><a href='#tree_add_nodelabels'><p>Adds labels to nodes with no assigned label</p></a></li>
<li><a href='#tree_add_outgroup'><p>Function to add an outgroup to any phylogeny, in phylo or newick format</p></a></li>
<li><a href='#tree_check'><p>Checks if a tree is a phylo class object otherwise it uses input_process.</p>
Additionally it can check if tree is a chronogram with phylo_check</a></li>
<li><a href='#tree_fix_brlen'><p>Take a tree with branch lengths and fix negative or zero length branches.</p></a></li>
<li><a href='#tree_from_taxonomy'><p>Gets a taxonomic tree from a vector of taxa</p></a></li>
<li><a href='#tree_get_node_data'><p>Get node numbers, node names, descendant tip numbers and labels of nodes from any tree, and node ages from dated trees.</p></a></li>
<li><a href='#tree_get_singleton_outgroup'><p>Identify the presence of a single lineage outgroup in a phylogeny</p></a></li>
<li><a href='#tree_node_tips'><p>To get tip numbers descending from any given node of a tree</p></a></li>
<li><a href='#treebase_cache'><p>Information on contributors, authors, study ids and clades from studies with chronograms in Open tree of Life</p></a></li>
<li><a href='#update_all_cached'><p>Update all data files as data objects for the package</p></a></li>
<li><a href='#update_datelife_cache'><p>Create an updated OpenTree chronograms database object</p></a></li>
<li><a href='#use_all_calibrations'><p>Date a given tree topology using a given set of congruified calibrations or ages</p></a></li>
<li><a href='#use_calibrations'><p>Date a given tree topology using a combined set of given calibrations</p></a></li>
<li><a href='#use_calibrations_bladj'><p>Use calibrations to date a topology with the BLADJ algorithm.</p></a></li>
<li><a href='#use_calibrations_bladj.matchedCalibrations'><p>Use calibrations to date a topology with the BLADJ algorithm.</p></a></li>
<li><a href='#use_calibrations_each'><p>Date a given tree topology by using a given list of calibrations independently,</p>
to generate multiple hypothesis of time of divergence</a></li>
<li><a href='#use_calibrations_pathd8'><p>Date a tree with secondary calibrations using PATHd8</p></a></li>
<li><a href='#use_calibrations_treePL'><p>Date a tree with initial branch lengths with treePL.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Scientific Data on Time of Lineage Divergence for Your Taxa</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luna L. Sanchez Reyes &lt;sanchez.reyes.luna@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods and workflows to get chronograms (i.e., phylogenetic trees with branch lengths
    proportional to time), using open, peer-reviewed, state-of-the-art scientific data on time of lineage divergence.
    This package constitutes the main underlying code of the DateLife web service
    at <a href="https://www.datelife.org">https://www.datelife.org</a>. To obtain a single summary chronogram from a group of
    relevant chronograms, we implement the Super Distance Matrix (SDM) method
    described in Criscuolo et al. (2006) &lt;<a href="https://doi.org/10.1080%2F10635150600969872">doi:10.1080/10635150600969872</a>&gt;.
    To find the grove of chronograms with a sufficiently overlapping set of taxa
    for summarizing, we implement theorem 1.1. from Ané et al. (2009)
    &lt;<a href="https://doi.org/10.1007%2Fs00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>&gt;.
    A given phylogenetic tree can be dated using time of lineage divergence data
    as secondary calibrations (with caution, see Schenk (2016) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0148228">doi:10.1371/journal.pone.0148228</a>&gt;).
    To obtain and apply secondary calibrations, the package implements the congruification method described
    in Eastman et al. (2013) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12051">doi:10.1111/2041-210X.12051</a>&gt;. Tree dating can be performed with different methods
    including BLADJ (Webb et al. (2008) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtn358">doi:10.1093/bioinformatics/btn358</a>&gt;), PATHd8
    (Britton et al. (2007) &lt;<a href="https://doi.org/10.1080%2F10635150701613783">doi:10.1080/10635150701613783</a>&gt;), mrBayes (Huelsenbeck
    and Ronquist (2001) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2F17.8.754">doi:10.1093/bioinformatics/17.8.754</a>&gt;), and treePL (Smith
    and O'Meara (2012) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbts492">doi:10.1093/bioinformatics/bts492</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Software</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, abind, bold, phangorn, phytools, ips, cluster, compare,
geiger, stats, stringr, rotl, paleotree, knitcitations,
phylobase, taxize, treebase, utils, httr, plyr, phylocomr,
BiocManager, data.table, curl</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, usethis, devtools, covr, msa,
Biostrings</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>PATHd8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/phylotastic/datelife">https://github.com/phylotastic/datelife</a>,
<a href="http://phylotastic.org/datelife/">http://phylotastic.org/datelife/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-19 22:49:25 UTC; luna</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian O'Meara [aut],
  Jonathan Eastman [aut],
  Tracy Heath [aut],
  April Wright [aut],
  Klaus Schliep [aut],
  Scott Chamberlain [aut],
  Peter Midford [aut],
  Luke Harmon [aut],
  Joseph Brown [aut],
  Matt Pennell [aut],
  Mike Alfaro [aut],
  Luna L. Sanchez Reyes [aut, cre],
  Emily Jane McTavish [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-19 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.get_ott_lineage'>Get the lineage of a set of taxa.
<code>.get_ott_lineage</code> uses <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> with <code>include_lineage = TRUE</code>.</h2><span id='topic+.get_ott_lineage'></span>

<h3>Description</h3>

<p>Get the lineage of a set of taxa.
<code>.get_ott_lineage</code> uses <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> with <code>include_lineage = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_ott_lineage(input_ott_match)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_ott_lineage_+3A_input_ott_match">input_ott_match</code></td>
<td>
<p>An Output of check_ott_input function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A taxonomy_taxon_info object
</p>

<hr>
<h2 id='birds_and_cats'>A multiPhylo object with trees resulting from a datelife search of some birds and cats species</h2><span id='topic+birds_and_cats'></span>

<h3>Description</h3>

<p>A multiPhylo object with trees resulting from a datelife search of some birds and cats species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>birds_and_cats
</code></pre>


<h3>Format</h3>

<p>A multiPhylo object
</p>


<h3>Details</h3>

<p>Generated with:
taxa &lt;- c(&quot;Rhea americana&quot;, &quot;Pterocnemia pennata&quot;, &quot;Struthio camelus&quot;, &quot;Gallus&quot;, &quot;Felis&quot;)
birds_and_cats &lt;- datelife_search(input = taxa, summary_format = &quot;phylo_all&quot;, get_spp_from_taxon = TRUE)
usethis::use_data(birds_and_cats)
</p>

<hr>
<h2 id='build_grove_list'>Build grove list</h2><span id='topic+build_grove_list'></span>

<h3>Description</h3>

<p>This function implements theorem 1.1 of Ané et al. (2009) <a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>
to find a grove for a given group of chronograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_grove_list(datelife_result, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_grove_list_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object.</p>
</td></tr>
<tr><td><code id="build_grove_list_+3A_n">n</code></td>
<td>
<p>The degree of taxon name overlap among input chronograms. Defaults
to <code>n = 2</code>, i.e., at least two overlapping taxon names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors; each list element is a grove.
</p>

<hr>
<h2 id='build_grove_matrix'>Find the grove for a group of chronograms and build a matrix.</h2><span id='topic+build_grove_matrix'></span>

<h3>Description</h3>

<p>This function implements theorem 1.1 of Ané et al. (2009) <a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>
to find a grove for a given group of chronograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_grove_matrix(datelife_result, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_grove_matrix_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object.</p>
</td></tr>
<tr><td><code id="build_grove_matrix_+3A_n">n</code></td>
<td>
<p>The degree of taxon name overlap among input chronograms. Defaults
to <code>n = 2</code>, i.e., at least two overlapping taxon names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Each cell shows whether n-overlap exists between a pair of inputs.
</p>


<h3>References</h3>

<p>Ané, C., Eulenstein, O., Piaggio-Talice, R., &amp; Sanderson, M. J. (2009).
&quot;Groves of phylogenetic trees&quot;. Annals of Combinatorics, 13(2), 139-167,
<a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>.
</p>

<hr>
<h2 id='check_conflicting_calibrations'>Check for conflicting calibrations.</h2><span id='topic+check_conflicting_calibrations'></span>

<h3>Description</h3>

<p><code>check_conflicting_calibrations</code> checks if calibrations are younger or older
relative to descendants and ancestors, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_conflicting_calibrations(phy, calibration_distribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_conflicting_calibrations_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="check_conflicting_calibrations_+3A_calibration_distribution">calibration_distribution</code></td>
<td>
<p>A list of node age distributions, named with <code>phy</code>'s node numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes conflicting calibrations if needed, but BLADJ works as long as it has an age for the root.
</p>

<hr>
<h2 id='check_ott_input'>Check input for usage in other <code>datelife</code> functions</h2><span id='topic+check_ott_input'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;check_ott_input is currently used in functions &#8288;</code><code><a href="#topic+get_ott_clade">get_ott_clade()</a></code>,
<code><a href="#topic+get_ott_children">get_ott_children()</a></code>, and <code><a href="#topic+get_otol_synthetic_tree">get_otol_synthetic_tree()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ott_input(input = NULL, ott_ids = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ott_input_+3A_input">input</code></td>
<td>
<p>Optional. A character vector of names or a <code>datelifeQuery</code> object.</p>
</td></tr>
<tr><td><code id="check_ott_input_+3A_ott_ids">ott_ids</code></td>
<td>
<p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</td></tr>
<tr><td><code id="check_ott_input_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+make_datelife_query">make_datelife_query</a></code>
</p>

<dl>
<dt><code>use_tnrs</code></dt><dd><p>Whether to use Open Tree of Life's Taxonomic Name Resolution Service (TNRS)
to process input taxon names. Default to <code>TRUE</code>, it corrects misspellings and
taxonomic name variations with <code><a href="#topic+tnrs_match">tnrs_match()</a></code>, a wrapper of <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code>.</p>
</dd>
<dt><code>get_spp_from_taxon</code></dt><dd><p>Whether to search ages for all species belonging to a
given taxon or not. Default to <code>FALSE</code>. If <code>TRUE</code>, it must have same length as input.
If input is a newick string with some clades it will be converted to a <code>phylo</code>
object, and the order of <code>get_spp_from_taxon</code> will match <code>phy$tip.label</code>.</p>
</dd>
<dt><code>reference_taxonomy</code></dt><dd><p>A character vector specifying the reference taxonomy to use for TNRS.
Options are &quot;ott&quot;, &quot;ncbi&quot;, &quot;gbif&quot; or &quot;irmng&quot;. The function defaults to &quot;ott&quot;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, it uses the <code>ott_id</code> argument if it is not NULL.
</p>


<h3>Value</h3>

<p>A named numeric vector of valid Open Tree Taxonomy (OTT) ids.
</p>

<hr>
<h2 id='choose_cluster'>Choose an ultrametric phylo object from <code><a href="#topic+cluster_patristicmatrix">cluster_patristicmatrix()</a></code> obtained
with a particular clustering method, or the next best tree.
If there are no ultrametric trees, it does not force them to be ultrametric.</h2><span id='topic+choose_cluster'></span>

<h3>Description</h3>

<p>Choose an ultrametric phylo object from <code><a href="#topic+cluster_patristicmatrix">cluster_patristicmatrix()</a></code> obtained
with a particular clustering method, or the next best tree.
If there are no ultrametric trees, it does not force them to be ultrametric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose_cluster(phycluster, clustering_method = "nj")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choose_cluster_+3A_phycluster">phycluster</code></td>
<td>
<p>An output from <code><a href="#topic+cluster_patristicmatrix">cluster_patristicmatrix()</a></code></p>
</td></tr>
<tr><td><code id="choose_cluster_+3A_clustering_method">clustering_method</code></td>
<td>
<p>A character vector indicating the method to construct
the tree. Options are:
</p>

<dl>
<dt>nj</dt><dd><p>Neighbor-Joining method applied with <code><a href="ape.html#topic+nj">ape::nj()</a></code>.</p>
</dd>
<dt>upgma</dt><dd><p>Unweighted Pair Group Method with Arithmetic Mean method applied
with <code><a href="phangorn.html#topic+upgma">phangorn::upgma()</a></code>.</p>
</dd>
<dt>bionj</dt><dd><p>An improved version of the Neighbor-Joining method applied with
<code><a href="ape.html#topic+bionj">ape::bionj()</a></code>.</p>
</dd>
<dt>triangle</dt><dd><p>Triangles method applied with <code><a href="ape.html#topic+triangMtd">ape::triangMtd()</a></code></p>
</dd>
<dt>mvr</dt><dd><p>Minimum Variance Reduction method applied with <code><a href="ape.html#topic+mvr">ape::mvr()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object or <code>NA</code>.
</p>

<hr>
<h2 id='classification_paths_from_taxonomy'>Gets classification paths for a vector of taxa</h2><span id='topic+classification_paths_from_taxonomy'></span>

<h3>Description</h3>

<p>This uses the taxize package's wrapper of the Global Names Resolver to get taxonomic paths for the vector of taxa you pass in. Sources is a vector of source labels in order (though it works best if everything uses the same taxonomy, so we recommend doing just one source). You can see options by doing taxize::gnr_datasources(). Our default is Catalogue of Life
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classification_paths_from_taxonomy(taxa, sources = "Catalogue of Life")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classification_paths_from_taxonomy_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names</p>
</td></tr>
<tr><td><code id="classification_paths_from_taxonomy_+3A_sources">sources</code></td>
<td>
<p>Vector of names of preferred sources; see taxize::gnr_datasources(). Currently supports 100 taxonomic resources, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taxonomies supported by taxize::gnr_datasources()
</p>

<ol>
<li><p> Catalogue of Life
</p>
</li>
<li><p> Wikispecies
</p>
</li>
<li><p> ITIS
</p>
</li>
<li><p> NCBI
</p>
</li>
<li><p> Index Fungorum
</p>
</li>
<li><p> GRIN Taxonomy for Plants
</p>
</li>
<li><p> Union 4
</p>
</li>
<li><p> The Interim Register of Marine and Nonmarine Genera
</p>
</li>
<li><p> World Register of Marine Species
</p>
</li>
<li><p> Freebase
</p>
</li>
<li><p> GBIF Backbone Taxonomy
</p>
</li>
<li><p> EOL
</p>
</li>
<li><p> Passiflora vernacular names
</p>
</li>
<li><p> Inventory of Fish Species in the Wami River Basin
</p>
</li>
<li><p> Pheasant Diversity and Conservation in the Mt. Gaoligonshan Region
</p>
</li>
<li><p> Finding Species
</p>
</li>
<li><p> Birds of Lindi Forests Plantation
</p>
</li>
<li><p> Nemertea
</p>
</li>
<li><p> Kihansi Gorge Amphibian Species Checklist
</p>
</li>
<li><p> Mushroom Observer
</p>
</li>
<li><p> TaxonConcept
</p>
</li>
<li><p> Amphibia and Reptilia of Yunnan
</p>
</li>
<li><p> Common names of Chilean Plants
</p>
</li>
<li><p> Invasive Species of Belgium
</p>
</li>
<li><p> ZooKeys
</p>
</li>
<li><p> COA Wildlife Conservation List
</p>
</li>
<li><p> AskNature
</p>
</li>
<li><p> China: Yunnan, Southern Gaoligongshan, Rapid Biological Inventories Report No. 04
</p>
</li>
<li><p> Native Orchids from Gaoligongshan Mountains, China
</p>
</li>
<li><p> Illinois Wildflowers
</p>
</li>
<li><p> Coleorrhyncha Species File
</p>
</li>
<li><p> /home/dimus/files/dwca/zoological names.zip
</p>
</li>
<li><p> Peces de la zona hidrogeográfica de la Amazonia, Colombia (Spreadsheet)
</p>
</li>
<li><p> Eastern Mediterranean Syllidae
</p>
</li>
<li><p> Gaoligong Shan Medicinal Plants Checklist
</p>
</li>
<li><p> birds_of_tanzania
</p>
</li>
<li><p> AmphibiaWeb
</p>
</li>
<li><p> tanzania_plant_sepecimens
</p>
</li>
<li><p> Papahanaumokuakea Marine National Monument
</p>
</li>
<li><p> Taiwanese IUCN species list
</p>
</li>
<li><p> BioPedia
</p>
</li>
<li><p> AnAge
</p>
</li>
<li><p> Embioptera Species File
</p>
</li>
<li><p> Global Invasive Species Database
</p>
</li>
<li><p> Sendoya S., Fernández F. AAT de hormigas (Hymenoptera: Formicidae) del Neotrópico 1.0 2004 (Spreadsheet)
</p>
</li>
<li><p> Flora of Gaoligong Mountains
</p>
</li>
<li><p> ARKive
</p>
</li>
<li><p> True Fruit Flies (Diptera, Tephritidae) of the Afrotropical Region
</p>
</li>
<li><p> 3i - Typhlocybinae Database
</p>
</li>
<li><p> CATE Sphingidae
</p>
</li>
<li><p> ZooBank
</p>
</li>
<li><p> Diatoms
</p>
</li>
<li><p> AntWeb
</p>
</li>
<li><p> Endemic species in Taiwan
</p>
</li>
<li><p> Dermaptera Species File
</p>
</li>
<li><p> Mantodea Species File
</p>
</li>
<li><p> Birds of the World: Recommended English Names
</p>
</li>
<li><p> New Zealand Animalia
</p>
</li>
<li><p> Blattodea Species File
</p>
</li>
<li><p> Plecoptera Species File
</p>
</li>
<li><p> /home/dimus/files/dwca/clemens.zip
</p>
</li>
<li><p> Coreoidea Species File
</p>
</li>
<li><p> Freshwater Animal Diversity Assessment - Normalized export
</p>
</li>
<li><p> Catalogue of Vascular Plant Species of Central and Northeastern Brazil
</p>
</li>
<li><p> Wikipedia in EOL
</p>
</li>
<li><p> Database of Vascular Plants of Canada (VASCAN)
</p>
</li>
<li><p> Phasmida Species File
</p>
</li>
<li><p> OBIS
</p>
</li>
<li><p> USDA NRCS PLANTS Database
</p>
</li>
<li><p> Catalog of Fishes
</p>
</li>
<li><p> Aphid Species File
</p>
</li>
<li><p> The National Checklist of Taiwan
</p>
</li>
<li><p> Psocodea Species File
</p>
</li>
<li><p> FishBase
</p>
</li>
<li><p> 3i - Typhlocybinae Database
</p>
</li>
<li><p> Belgian Species List
</p>
</li>
<li><p> EUNIS
</p>
</li>
<li><p> CU*STAR
</p>
</li>
<li><p> Orthoptera Species File
</p>
</li>
<li><p> Bishop Museum
</p>
</li>
<li><p> IUCN Red List of Threatened Species
</p>
</li>
<li><p> BioLib.cz
</p>
</li>
<li><p> Tropicos - Missouri Botanical Garden
</p>
</li>
<li><p> nlbif
</p>
</li>
<li><p> The International Plant Names Index
</p>
</li>
<li><p> Index to Organism Names
</p>
</li>
<li><p> uBio NameBank
</p>
</li>
<li><p> Arctos
</p>
</li>
<li><p> Checklist of Beetles (Coleoptera) of Canada and Alaska. Second Edition.
</p>
</li>
<li><p> The Paleobiology Database
</p>
</li>
<li><p> The Reptile Database
</p>
</li>
<li><p> The Mammal Species of The World
</p>
</li>
<li><p> BirdLife International
</p>
</li>
<li><p> Checklist da Flora de Portugal (Continental, Açores e Madeira)
</p>
</li>
<li><p> FishBase Cache
</p>
</li>
<li><p> Silva
</p>
</li>
<li><p> Open Tree of Life Reference Taxonomy
</p>
</li>
<li><p> iNaturalist
</p>
</li>
<li><p> The Interim Register of Marine and Nonmarine Genera
</p>
</li>
<li><p> Gymno
</p>
</li></ol>



<h3>Value</h3>

<p>A list with resolved taxa (a tibble, from taxize::gnr_resolve) and a vector of taxa not resolved
</p>

<hr>
<h2 id='clean_ott_chronogram'>Clean up some issues with Open Tree of Life chronograms
For now it 1) checks unmapped taxa and maps them with tnrs_match.phylo, 2) roots the chronogram if unrooted</h2><span id='topic+clean_ott_chronogram'></span>

<h3>Description</h3>

<p>Clean up some issues with Open Tree of Life chronograms
For now it 1) checks unmapped taxa and maps them with tnrs_match.phylo, 2) roots the chronogram if unrooted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_ott_chronogram(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_ott_chronogram_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no limit to the number of names that can be queried and matched.
</p>
<p>The output will preserve all elements from original input phylo object and will add
</p>

<dl>
<dt>phy$mapped</dt><dd><p>A character vector indicating the state of mapping of phy$tip.labels:</p>
</dd>
</dl>

<dl>
<dt>original</dt><dd><p>Tnrs matching was not attempted. Original labeling is preserved.</p>
</dd>
<dt>ott</dt><dd><p>Matching was manually made by a curator in Open Tree of Life.</p>
</dd>
<dt>tnrs</dt><dd><p>Tnrs matching was attempted and successful with no approximate matching. Original label is replaced by the matched name.</p>
</dd>
<dt>approximated</dt><dd><p>Tnrs matching was attempted and successful but with approximate matching. Original labeling is preserved.</p>
</dd>
<dt>unmatched</dt><dd><p>Tnrs matching was attempted and unsuccessful. Original labeling is preserved.</p>
</dd>
</dl>

<dl>
<dt>phy$original.tip.label</dt><dd><p>A character vector preserving all original labels.</p>
</dd>
<dt>phy$ott_ids</dt><dd><p>A numeric vector with ott id numbers of matched tips. Unmatched and original tips will be NaN.</p>
</dd>
</dl>

<p>if tips are duplicated, tnrs will only be run once (avoiding increases in function running time) but the result will be applied to all duplicated tip labels
</p>


<h3>Value</h3>

<p>An object of class  data frame or phylo, with the added class match_names.
</p>
<p><code>NULL</code>
</p>
<p><code>NULL</code>
</p>

<hr>
<h2 id='clean_taxon_info_children'>Identify, extract and clean taxonomic children names from a <code><a href="rotl.html#topic+taxonomy_taxon_info">taxonomy_taxon_info()</a></code>
output.</h2><span id='topic+clean_taxon_info_children'></span>

<h3>Description</h3>

<p><code>clean_taxon_info_children</code> eliminates all taxa that will give
problems when trying to retrieve an induced subtree from Open Tree of Life.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_taxon_info_children(
  taxon_info,
  invalid = c("barren", "extinct", "uncultured", "major_rank_conflict", "incertae_sedis",
    "unplaced", "conflict", "environmental", "not_otu", "hidden", "hybrid")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_taxon_info_children_+3A_taxon_info">taxon_info</code></td>
<td>
<p>An output of <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code>.</p>
</td></tr>
<tr><td><code id="clean_taxon_info_children_+3A_invalid">invalid</code></td>
<td>
<p>A character vector of &quot;flags&quot;, i.e., characteristics that are
used by Open Tree of Life Taxonomy to detect invalid taxon names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with valid children unique OTT names, OTT ids and taxonomic ranks.
</p>

<hr>
<h2 id='clean_tnrs'>Eliminates unmatched (NAs) and invalid taxa from a <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code> output
Useful to get ott ids to retrieve an induced synthetic Open Tree of Life.
Needed because using <code>include_suppressed = FALSE</code> in <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> does not drop all invalid taxa.</h2><span id='topic+clean_tnrs'></span>

<h3>Description</h3>

<p>Eliminates unmatched (NAs) and invalid taxa from a <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code> output
Useful to get ott ids to retrieve an induced synthetic Open Tree of Life.
Needed because using <code>include_suppressed = FALSE</code> in <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> does not drop all invalid taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_tnrs(
  tnrs,
  invalid = c("barren", "extinct", "uncultured", "major_rank_conflict", "incertae",
    "unplaced", "conflict", "environmental", "not_otu"),
  remove_nonmatches = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_tnrs_+3A_tnrs">tnrs</code></td>
<td>
<p>A data frame, usually an output from datelife::tnrs_match or rotl::tnrs_match_names functions, but see details.</p>
</td></tr>
<tr><td><code id="clean_tnrs_+3A_invalid">invalid</code></td>
<td>
<p>A character string with flags to be removed from final object.</p>
</td></tr>
<tr><td><code id="clean_tnrs_+3A_remove_nonmatches">remove_nonmatches</code></td>
<td>
<p>Boolean, whether to remove unsuccessfully matched names or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input can be any data frame or named list that relates taxa stored in an element named &quot;unique&quot; to a validity category stored in &quot;flags&quot;.
</p>


<h3>Value</h3>

<p>A data frame or named list (depending on the input) with valid taxa only.
</p>

<hr>
<h2 id='cluster_patristicmatrix'>Cluster a patristic matrix into a tree with various methods.</h2><span id='topic+cluster_patristicmatrix'></span>

<h3>Description</h3>

<p>Cluster a patristic matrix into a tree with various methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_patristicmatrix(patristic_matrix, variance_matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_patristicmatrix_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix</p>
</td></tr>
<tr><td><code id="cluster_patristicmatrix_+3A_variance_matrix">variance_matrix</code></td>
<td>
<p>A variance matrix from a <code>datelifeResult</code> object,
usually an output from <code><a href="#topic+datelife_result_variance_matrix">datelife_result_variance_matrix()</a></code>.
Only used if <code>clustering_method = "mvr"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If clustering method fails, <code>NA</code> is returned.
</p>


<h3>Value</h3>

<p>A list of trees obtained with clustering methods detailed in <code><a href="#topic+patristic_matrix_to_phylo">patristic_matrix_to_phylo()</a></code>.
</p>

<hr>
<h2 id='congruify_and_check'>Congruify and Check.</h2><span id='topic+congruify_and_check'></span>

<h3>Description</h3>

<p>Congruify and Check.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruify_and_check(
  reference,
  target,
  taxonomy = NULL,
  tol = 0.01,
  option = 2,
  scale = "pathd8",
  attempt_fix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="congruify_and_check_+3A_reference">reference</code></td>
<td>
<p>an ultrametric tree used to time-scale the <code>target</code></p>
</td></tr>
<tr><td><code id="congruify_and_check_+3A_target">target</code></td>
<td>
<p>a phylogram that is sought to be ultrametricized based on the <code>reference</code> phylogeny</p>
</td></tr>
<tr><td><code id="congruify_and_check_+3A_taxonomy">taxonomy</code></td>
<td>
<p>a linkage table between tips of the phylogeny and clades represented in the tree; rownames of 'taxonomy' should be tips found in the phylogeny</p>
</td></tr>
<tr><td><code id="congruify_and_check_+3A_tol">tol</code></td>
<td>
<p>branching time in <code>reference</code> above which secondary constraints will be applied to <code>target</code></p>
</td></tr>
<tr><td><code id="congruify_and_check_+3A_option">option</code></td>
<td>
<p>an integer (1 or 2; see details).</p>
</td></tr>
<tr><td><code id="congruify_and_check_+3A_scale">scale</code></td>
<td>
<p><code>NA</code>, <code>"PATHd8"</code> or <code>"treePL"</code> (if <code>PATHd8</code> or <code>"treePL"</code> are available in the R <code>PATH</code>)</p>
</td></tr>
<tr><td><code id="congruify_and_check_+3A_attempt_fix">attempt_fix</code></td>
<td>
<p>Default to <code>TRUE</code>. If congruification results in NA branch
lengths, it will attempt to fix them.</p>
</td></tr>
</table>

<hr>
<h2 id='congruify_and_mrca_multiPhylo'>Congruify nodes of a tree topology to nodes from a source chronogram, and find the mrca nodes</h2><span id='topic+congruify_and_mrca_multiPhylo'></span>

<h3>Description</h3>

<p><code>congruify_and_mrca_multiPhylo</code> congruifies a target tree against all
source chronograms in a <code>multiPhylo</code> object, and gets nodes of target tree
that correspond to the most recent common ancestor (mrca) of taxon pairs
in the congruified calibrations.
It calls <code><a href="#topic+congruify_and_mrca_phylo">congruify_and_mrca_phylo()</a></code>, and <code><a href="phytools.html#topic+findMRCA">phytools::findMRCA()</a></code> to get mrca nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruify_and_mrca_multiPhylo(phy, source_chronograms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="congruify_and_mrca_multiPhylo_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="congruify_and_mrca_multiPhylo_+3A_source_chronograms">source_chronograms</code></td>
<td>
<p>A <code>multiPhylo</code> object, output of <code><a href="#topic+datelife_search">datelife_search()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> of node ages from <code>source_chronograms</code> and corresponding
mrca nodes in target tree <code>phy</code>. <code>attributes(return)$phy</code> stores the congruified and mrca matched phylogeny.
</p>

<hr>
<h2 id='congruify_and_mrca_phylo'>Congruify nodes of a tree topology to nodes from a source chronogram, and find the mrca nodes</h2><span id='topic+congruify_and_mrca_phylo'></span>

<h3>Description</h3>

<p><code>congruify_and_mrca</code> congruifies a target tree against a single
source chronogram, and gets nodes of target tree that correspond to the most
recent common ancestor (mrca) of taxon pairs from the congruified calibrations.
It uses <code><a href="phytools.html#topic+findMRCA">phytools::findMRCA()</a></code> to get mrca nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruify_and_mrca_phylo(phy, source_chronogram, reference)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="congruify_and_mrca_phylo_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="congruify_and_mrca_phylo_+3A_source_chronogram">source_chronogram</code></td>
<td>
<p>A <code>phylo</code> object, output of <code><a href="#topic+datelife_search">datelife_search()</a></code>.</p>
</td></tr>
<tr><td><code id="congruify_and_mrca_phylo_+3A_reference">reference</code></td>
<td>
<p>A character string indicating the study reference that the <code>source_chronogram</code> comes from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> of node ages from <code>source_chronograms</code> and corresponding
mrca nodes in target tree <code>phy</code>.
</p>

<hr>
<h2 id='contributor_cache'>Information on contributors, authors, study ids and clades from studies with
chronograms in Open Tree of Life (Open Tree)</h2><span id='topic+contributor_cache'></span>

<h3>Description</h3>

<p>Information on contributors, authors, study ids and clades from studies with
chronograms in Open Tree of Life (Open Tree)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contributor_cache
</code></pre>


<h3>Format</h3>

<p>A list of five data sets.
</p>

<dl>
<dt>author.pretty</dt><dd><p>A character vector with the author names from studies
with chronograms that are in Open Tree.</p>
</dd>
<dt>author.results</dt><dd><p>A dataframe with three variables: authors, study ids and clades.</p>
</dd>
<dt>curator.pretty</dt><dd><p>A character vector with the names of curators of
chronograms that are in Open Tree.</p>
</dd>
<dt>curator.results</dt><dd><p>A <code>data.frame</code> with three variables: curators, study ids and clades.</p>
</dd>
<dt>missed_doi</dt><dd><p>A character vector with study ids whose &quot;doi&quot; could not be retrieved.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Generated with <code><a href="#topic+make_contributor_cache">make_contributor_cache()</a></code>.
</p>


<h3>Source</h3>

<p><a href="http://opentreeoflife.org">http://opentreeoflife.org</a>
</p>

<hr>
<h2 id='date_with_pbdb'>Date with Paleobiology Database and paleotree.</h2><span id='topic+date_with_pbdb'></span>

<h3>Description</h3>

<p>This will take a topology, look up information about fossils for taxa on the tree, and use <code><a href="paleotree.html#topic+timePaleoPhy">paleotree::timePaleoPhy()</a></code> to compute branch lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_with_pbdb(phy, recent = FALSE, assume_recent_if_missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_with_pbdb_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="date_with_pbdb_+3A_recent">recent</code></td>
<td>
<p>If <code>TRUE</code>, forces the minimum age to be zero for any taxon</p>
</td></tr>
<tr><td><code id="date_with_pbdb_+3A_assume_recent_if_missing">assume_recent_if_missing</code></td>
<td>
<p>If <code>TRUE</code>, any taxon missing from PBDB is assumed to be recent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dated tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # This is a flag for package development. You are welcome to run the example.

taxa &lt;- c(
  "Archaeopteryx", "Pinus", "Quetzalcoatlus", "Homo sapiens",
  "Tyrannosaurus rex", "Megatheriidae", "Metasequoia", "Aedes", "Panthera"
)
phy &lt;- tree_from_taxonomy(taxa, sources = "The Paleobiology Database")$phy

## End(Not run) # end dontrun
</code></pre>

<hr>
<h2 id='datelife_authors_tabulate'>Return the relevant authors for a set of studies.</h2><span id='topic+datelife_authors_tabulate'></span>

<h3>Description</h3>

<p>Return the relevant authors for a set of studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_authors_tabulate(results.index, cache = "opentree_chronograms")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_authors_tabulate_+3A_results.index">results.index</code></td>
<td>
<p>A vector from <code><a href="#topic+datelife_result_study_index">datelife_result_study_index()</a></code> with the indices of the relevant studies.</p>
</td></tr>
<tr><td><code id="datelife_authors_tabulate_+3A_cache">cache</code></td>
<td>
<p>The cached chronogram database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with counts of each author, with names equal to author names.
</p>

<hr>
<h2 id='datelife_result_median'>Get a median summary chronogram from a <code>datelifeResult</code> object.</h2><span id='topic+datelife_result_median'></span>

<h3>Description</h3>

<p>Get a median summary chronogram from a <code>datelifeResult</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_result_median(datelife_result, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_result_median_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
<tr><td><code id="datelife_result_median_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+summary_matrix_to_phylo">summary_matrix_to_phylo</a></code>
</p>

<dl>
<dt><code>summ_matrix</code></dt><dd><p>Any summary patristic distance matrix, such as the ones obtained with <code><a href="#topic+datelife_result_sdm_matrix">datelife_result_sdm_matrix()</a></code> or <code><a href="#topic+datelife_result_median_matrix">datelife_result_median_matrix()</a></code>.</p>
</dd>
<dt><code>total_distance</code></dt><dd><p>Whether the input <code>summ_matrix</code> stores total age distance
(from tip to tip) or distance from node to tip. Default to <code>TRUE</code>,
divides the matrix in half, if <code>FALSE</code> it will take it as is.</p>
</dd>
<dt><code>use</code></dt><dd><p>A character vector indicating what type of age to use for summary tree.
One of the following:
</p>

<dl>
<dt>&quot;mean&quot;</dt><dd><p>It will use the <code><a href="base.html#topic+mean">mean()</a></code> of the node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;median&quot;</dt><dd><p>It uses the <code><a href="stats.html#topic+median">stats::median()</a></code> age of node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;min&quot;</dt><dd><p>It will use the <code><a href="base.html#topic+min">min()</a></code> age from node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;max&quot;</dt><dd><p>Choose this if you wanna be conservative; it will use the <code><a href="base.html#topic+max">max()</a></code>
age from node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;midpoint&quot;</dt><dd><p>It will use the mean of minimum age and maximum age.</p>
</dd>
</dl>
</dd>
<dt><code>target_tree</code></dt><dd><p>A <code>phylo</code> object. Use this in case you want a specific
backbone for the output tree.</p>
</dd>
<dt><code>datelife_query</code></dt><dd><p>A <code>datelifeQuery</code> object, usually an output of <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object.
</p>

<hr>
<h2 id='datelife_result_median_matrix'>Compute a median matrix of a <code>datelifeResult</code> object.</h2><span id='topic+datelife_result_median_matrix'></span>

<h3>Description</h3>

<p>Compute a median matrix of a <code>datelifeResult</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_result_median_matrix(datelife_result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_result_median_matrix_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A patristic distance summary matrix from a <code>datelifeResult</code> object.
</p>

<hr>
<h2 id='datelife_result_MRCA'>Get a numeric vector of MRCAs from a <code>datelifeResult</code> object. Used in <code><a href="#topic+summarize_datelife_result">summarize_datelife_result()</a></code>.</h2><span id='topic+datelife_result_MRCA'></span>

<h3>Description</h3>

<p>Get a numeric vector of MRCAs from a <code>datelifeResult</code> object. Used in <code><a href="#topic+summarize_datelife_result">summarize_datelife_result()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_result_MRCA(datelife_result, na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_result_MRCA_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
<tr><td><code id="datelife_result_MRCA_+3A_na_rm">na_rm</code></td>
<td>
<p>If <code>TRUE</code>, it drops rows containing <code>NA</code>s from the <code>datelifeResult</code>
patristic matrix; if <code>FALSE</code>, it returns <code>NA</code> where there are missing entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector of MRCA ages for each element given in <code>datelife_result</code>.
</p>

<hr>
<h2 id='datelife_result_sdm_matrix'>Go from a <code>datelifeResult</code> object to a Super Distance Matrix (SDM) using weighting = &quot;flat&quot;</h2><span id='topic+datelife_result_sdm_matrix'></span>

<h3>Description</h3>

<p>Go from a <code>datelifeResult</code> object to a Super Distance Matrix (SDM) using weighting = &quot;flat&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_result_sdm_matrix(datelife_result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_result_sdm_matrix_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix.
</p>

<hr>
<h2 id='datelife_result_sdm_phylo'>Reconstruct a supertree from a <code>datelifeResult</code> object using the Super Distance Matrix (SDM) method.</h2><span id='topic+datelife_result_sdm_phylo'></span>

<h3>Description</h3>

<p>Reconstruct a supertree from a <code>datelifeResult</code> object using the Super Distance Matrix (SDM) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_result_sdm_phylo(datelife_result, weighting = "flat", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_result_sdm_phylo_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
<tr><td><code id="datelife_result_sdm_phylo_+3A_weighting">weighting</code></td>
<td>
<p>A character vector indicating how much weight to give to each
tree in <code>input</code> during the SDM analysis. Options are:
</p>

<dl>
<dt>weighting = &quot;flat&quot;</dt><dd><p>All trees have equal weighting.</p>
</dd>
<dt>weighting = &quot;taxa&quot;</dt><dd><p>Weight is proportional to number of taxa.</p>
</dd>
<dt>weighting = &quot;inverse&quot;</dt><dd><p>Weight is proportional to 1 / number of taxa.</p>
</dd>
</dl>

<p>Defaults to <code>weighting = "flat"</code>.</p>
</td></tr>
<tr><td><code id="datelife_result_sdm_phylo_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+summary_matrix_to_phylo">summary_matrix_to_phylo</a></code>
</p>

<dl>
<dt><code>summ_matrix</code></dt><dd><p>Any summary patristic distance matrix, such as the ones obtained with <code><a href="#topic+datelife_result_sdm_matrix">datelife_result_sdm_matrix()</a></code> or <code><a href="#topic+datelife_result_median_matrix">datelife_result_median_matrix()</a></code>.</p>
</dd>
<dt><code>total_distance</code></dt><dd><p>Whether the input <code>summ_matrix</code> stores total age distance
(from tip to tip) or distance from node to tip. Default to <code>TRUE</code>,
divides the matrix in half, if <code>FALSE</code> it will take it as is.</p>
</dd>
<dt><code>use</code></dt><dd><p>A character vector indicating what type of age to use for summary tree.
One of the following:
</p>

<dl>
<dt>&quot;mean&quot;</dt><dd><p>It will use the <code><a href="base.html#topic+mean">mean()</a></code> of the node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;median&quot;</dt><dd><p>It uses the <code><a href="stats.html#topic+median">stats::median()</a></code> age of node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;min&quot;</dt><dd><p>It will use the <code><a href="base.html#topic+min">min()</a></code> age from node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;max&quot;</dt><dd><p>Choose this if you wanna be conservative; it will use the <code><a href="base.html#topic+max">max()</a></code>
age from node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;midpoint&quot;</dt><dd><p>It will use the mean of minimum age and maximum age.</p>
</dd>
</dl>
</dd>
<dt><code>target_tree</code></dt><dd><p>A <code>phylo</code> object. Use this in case you want a specific
backbone for the output tree.</p>
</dd>
<dt><code>datelife_query</code></dt><dd><p>A <code>datelifeQuery</code> object, usually an output of <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Chronograms given as input in <code>datelife_result</code> are summarized with the Super Distance
Matrix (SDM) method described in Criscuolo et al. (2006) <a href="https://doi.org/10.1080/10635150600969872">doi:10.1080/10635150600969872</a>,
implemented with the function <code><a href="ape.html#topic+SDM">ape::SDM()</a></code>. The resulting summary SDM is
clustered with <code><a href="#topic+summary_matrix_to_phylo">summary_matrix_to_phylo()</a></code>.
</p>


<h3>Value</h3>

<p>A supertree with branch lengths proportional to time, obtained by
summarizing individual chronograms given as input in <code>datelife_result</code>.
It is returned as an object of class <code>datelifeSDM</code>, which is a <code>phylo</code> object
with an additional <code style="white-space: pre;">&#8288;$data&#8288;</code> element storing the input chronograms as a
<code>datelifeResult</code> object, and a <code style="white-space: pre;">&#8288;$citation&#8288;</code> element containing
citations of studies from input chronograms.
</p>


<h3>References</h3>

<p>Criscuolo A, Berry V, Douzery EJ, Gascuel O.
(2006) &quot;SDM: a fast distance-based approach for (super) tree building in
phylogenomics&quot; <a href="https://doi.org/10.1080/10635150600969872">doi:10.1080/10635150600969872</a>.
</p>

<hr>
<h2 id='datelife_result_study_index'>Find the index of relevant studies in a cached chronogram database.</h2><span id='topic+datelife_result_study_index'></span>

<h3>Description</h3>

<p><code>datelife_result_study_index</code> is used in <code><a href="#topic+summarize_datelife_result">summarize_datelife_result()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_result_study_index(datelife_result, cache = "opentree_chronograms")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_result_study_index_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
<tr><td><code id="datelife_result_study_index_+3A_cache">cache</code></td>
<td>
<p>The cached chronogram database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices of studies that have relevant information.
</p>

<hr>
<h2 id='datelife_result_variance_matrix'>Compute a variance matrix of a <code>datelifeResult</code> object.</h2><span id='topic+datelife_result_variance_matrix'></span>

<h3>Description</h3>

<p>Compute a variance matrix of a <code>datelifeResult</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_result_variance_matrix(datelife_result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_result_variance_matrix_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance matrix from a <code>datelifeResult</code> object.
</p>

<hr>
<h2 id='datelife_search'>Get scientific, peer-reviewed information on time of lineage
divergence openly available for a given set of taxon names</h2><span id='topic+datelife_search'></span><span id='topic+datelife'></span>

<h3>Description</h3>

<p><code>datelife_search</code> is the core DateLife function to find and
get all openly available, peer-reviewed scientific information on time of
lineage divergence for a set of <code>input</code> taxon names given as a character
vector, a newick character string, a <code>phylo</code> or <code>multiPhylo</code> object or as a
an already processed <code>datelifeQuery</code> object obtained with <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_search(
  input = c("Rhea americana", "Pterocnemia pennata", "Struthio camelus"),
  use_tnrs = FALSE,
  get_spp_from_taxon = FALSE,
  partial = TRUE,
  cache = "opentree_chronograms",
  summary_format = "phylo_all",
  na_rm = FALSE,
  summary_print = c("citations", "taxa"),
  taxon_summary = c("none", "summary", "matrix"),
  criterion = "taxa"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_search_+3A_input">input</code></td>
<td>
<p>One of the following:
</p>

<dl>
<dt>A character vector</dt><dd><p>With taxon names as a single comma separated
starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or
<code>multiPhylo</code> object, OR as a newick character string.</p>
</dd>
<dt>A <code>datelifeQuery</code> object</dt><dd><p>An output from <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="datelife_search_+3A_use_tnrs">use_tnrs</code></td>
<td>
<p>Whether to use Open Tree of Life's Taxonomic Name Resolution Service (TNRS)
to process input taxon names. Default to <code>TRUE</code>, it corrects misspellings and
taxonomic name variations with <code><a href="#topic+tnrs_match">tnrs_match()</a></code>, a wrapper of <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code>.</p>
</td></tr>
<tr><td><code id="datelife_search_+3A_get_spp_from_taxon">get_spp_from_taxon</code></td>
<td>
<p>Whether to search ages for all species belonging to a
given taxon or not. Default to <code>FALSE</code>. If <code>TRUE</code>, it must have same length as input.
If input is a newick string with some clades it will be converted to a <code>phylo</code>
object, and the order of <code>get_spp_from_taxon</code> will match <code>phy$tip.label</code>.</p>
</td></tr>
<tr><td><code id="datelife_search_+3A_partial">partial</code></td>
<td>
<p>Whether to return or exclude partially matching source chronograms,
i.e, those that match some and not all of taxa given in <code>datelife_query</code>.
Options are <code>TRUE</code> or <code>FALSE</code>. Defaults to <code>TRUE</code>: return all matching source
chronograms.</p>
</td></tr>
<tr><td><code id="datelife_search_+3A_cache">cache</code></td>
<td>
<p>A character vector of length one, with the name of the data object
to cache. Default to <code>"opentree_chronograms"</code>, a data object storing Open Tree of
Life's database chronograms and other associated information.</p>
</td></tr>
<tr><td><code id="datelife_search_+3A_summary_format">summary_format</code></td>
<td>
<p>A character vector of length one, indicating the output
format for results of the DateLife search. Available output formats are:
</p>

<dl>
<dt>&quot;citations&quot;</dt><dd><p>A character vector of references where chronograms with
some or all of the target taxa are published (source chronograms).</p>
</dd>
<dt>&quot;mrca&quot;</dt><dd><p>A named numeric vector of most recent common ancestor (mrca)
ages of target taxa defined in input, obtained from the source chronograms.
Names of mrca vector are equal to citations.</p>
</dd>
<dt>&quot;newick_all&quot;</dt><dd><p>A named character vector of newick strings corresponding
to target chronograms derived from source chronograms. Names of newick_all
vector are equal to citations.</p>
</dd>
<dt>&quot;newick_sdm&quot;</dt><dd><p>Only if multiple source chronograms are available. A
character vector with a single newick string corresponding to a target
chronogram obtained with SDM supertree method (Criscuolo et al. 2006).</p>
</dd>
<dt>&quot;newick_median&quot;</dt><dd><p>Only if multiple source chronograms are available.
A character vector with a single newick string corresponding to a target
chronogram from the median of all source chronograms.</p>
</dd>
<dt>&quot;phylo_sdm&quot;</dt><dd><p>Only if multiple source chronograms are available. A
phylo object with a single target chronogram obtained with SDM supertree
method (Criscuolo et al. 2006).</p>
</dd>
<dt>&quot;phylo_median&quot;</dt><dd><p>Only if multiple source chronograms are available. A
phylo object with a single target chronogram obtained from source
chronograms with median method.</p>
</dd>
<dt>&quot;phylo_all&quot;</dt><dd><p>A named list of phylo objects corresponding to each target
chronogram obtained from available source chronograms. Names of
phylo_all list correspond to citations.</p>
</dd>
<dt>&quot;phylo_biggest&quot;</dt><dd><p>The chronogram with the most taxa. In the case of a
tie, the chronogram with clade age closest to the median age of the
equally large trees is returned.</p>
</dd>
<dt>&quot;html&quot;</dt><dd><p>A character vector with an html string that can be saved and
then opened in any web browser. It contains a 4 column table with data on
target taxa: mrca, number of taxa, citations of source chronogram and
newick target chronogram.</p>
</dd>
<dt>&quot;data_frame&quot;</dt><dd><p>A 4 column <code>data.frame</code> with data on target taxa: mrca, number of
taxa, citations of source chronograms and newick string.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="datelife_search_+3A_na_rm">na_rm</code></td>
<td>
<p>If <code>TRUE</code>, it drops rows containing <code>NA</code>s from the <code>datelifeResult</code>
patristic matrix; if <code>FALSE</code>, it returns <code>NA</code> where there are missing entries.</p>
</td></tr>
<tr><td><code id="datelife_search_+3A_summary_print">summary_print</code></td>
<td>
<p>A character vector specifying the type of summary information
to be printed to screen. Options are:
</p>

<dl>
<dt>&quot;citations&quot;</dt><dd><p>Prints references of chronograms where target taxa are found.</p>
</dd>
<dt>&quot;taxa&quot;</dt><dd><p>Prints a summary of the number of chronograms where each target
taxon is found.</p>
</dd>
<dt>&quot;none&quot;</dt><dd><p>Nothing is printed to screen.</p>
</dd>
</dl>

<p>Defaults to <code>c("citations", "taxa")</code>, which displays both.</p>
</td></tr>
<tr><td><code id="datelife_search_+3A_taxon_summary">taxon_summary</code></td>
<td>
<p>A character vector specifying if data on target taxa missing
in source chronograms should be added to the output as a <code>"summary"</code> or as a
presence/absence <code>"matrix"</code>. Default to <code>"none"</code>, no information on taxon_summary
added to the output.</p>
</td></tr>
<tr><td><code id="datelife_search_+3A_criterion">criterion</code></td>
<td>
<p>Defaults to <code>criterion = "taxa"</code>. Used for chronogram summarizing, i.e., obtaining a single
summary chronogram from a group of input chronograms.
For summarizing approaches that return a single summary tree from a group of
phylogenetic trees, it is necessary that the latter form a grove, roughly,
a sufficiently overlapping set of taxa between trees, see Ané et al. (2009) <a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>.
In rare cases, a group of trees can have multiple groves. This argument indicates
whether to get the grove with the most trees (<code>criterion = "trees"</code>) or the
most taxa (<code>criterion = "taxa"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only one taxon name is given as <code>input</code>, <code>get_spp_from_taxon</code> is
always set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>The output is determined by the argument <code>summary_format</code>:
</p>

<dl>
<dt>If <code>summary_format = "citations"</code></dt><dd><p>The function returns a character
vector of references.</p>
</dd>
<dt>If <code>summary_format = "mrca"</code></dt><dd><p>The function returns a named numeric
vector of most recent common ancestor (mrca) ages.</p>
</dd>
<dt>If <code>summary_format = "newick_[all, sdm, or median]"</code></dt><dd><p>The function
returns output chronograms as newick strings.</p>
</dd>
<dt>If <code>summary_format = "phylo_[all, sdm, median, or biggest]"</code></dt><dd><p>The
function returns output chronograms as <code>phylo</code> or <code>multiPhylo</code> objects.</p>
</dd>
<dt>If <code style="white-space: pre;">&#8288;summary_format = "html" or "data_frame"&#8288;</code></dt><dd><p>The function returns a
4 column table with data on mrca ages, number of taxa, references, and output chronograms as newick strings.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# For this example, we will set a temp working directory, but you can set
# your working directory as needed:
# we will use the tempdir() function to get a temporary directory:
tempwd &lt;- tempdir()

# Obtain median ages from a set of source chronograms in newick format:
ages &lt;- datelife_search(c(
  "Rhea americana", "Pterocnemia pennata", "Struthio camelus",
  "Mus musculus"
), summary_format = "newick_median")

# Save the tree in the temp working directory in newick format:
write(ages, file = file.path(tempwd, "some.bird.ages.txt"))

# Obtain median ages from a set of source chronograms in phylo format
# Will produce same tree as above but in "phylo" format:
ages.again &lt;- datelife_search(c(
  "Rhea americana", "Pterocnemia pennata", "Struthio camelus",
  "Mus musculus"
), summary_format = "phylo_median")
plot(ages.again)
library(ape)
ape::axisPhylo()
mtext("Time (million years ago)", side = 1, line = 2, at = (max(get("last_plot.phylo",
  envir = .PlotPhyloEnv
)$xx) * 0.5))

# Save "phylo" object in newick format
write.tree(ages.again, file = file.path(tempwd, "some.bird.tree.again.txt"))

# Obtain MRCA ages and target chronograms from all source chronograms
# Generate an htm"l output readable in any web browser:
ages.html &lt;- datelife_search(c(
  "Rhea americana", "Pterocnemia pennata", "Struthio camelus",
  "Mus musculus"
), summary_format = "html")
write(ages.html, file = file.path(tempwd, "some.bird.trees.html"))
system(paste("open", file.path(tempwd, "some.bird.trees.html")))

## End(Not run) # end dontrun
</code></pre>

<hr>
<h2 id='datelife_use'>Generate one or multiple chronograms for a set of given taxon names.</h2><span id='topic+datelife_use'></span>

<h3>Description</h3>

<p><code>datelife_use</code> gets secondary calibrations available for any
pair of given taxon names, mined from the <a href="#topic+opentree_chronograms">opentree_chronograms</a> object,
congruifies them, and uses them to date a given tree topology with the
algorithm defined in <code>dating_method</code>. If no tree topology is provided,
it will attempt to get one for the given taxon names from Open Tree of Life
synthetic tree, using <code><a href="#topic+make_bold_otol_tree">make_bold_otol_tree()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_use(input = NULL, each = FALSE, dating_method = "bladj", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_use_+3A_input">input</code></td>
<td>
<p>One of the following:
</p>

<dl>
<dt>A character vector</dt><dd><p>With taxon names as a single comma separated
starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or
<code>multiPhylo</code> object, OR as a newick character string.</p>
</dd>
<dt>A <code>datelifeQuery</code> object</dt><dd><p>An output from <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="datelife_use_+3A_each">each</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>: all calibrations are returned in
the same <code>data.frame</code>. If <code>TRUE</code>, calibrations from each chronogram are returned
in separate data frames.</p>
</td></tr>
<tr><td><code id="datelife_use_+3A_dating_method">dating_method</code></td>
<td>
<p>Tree dating algorithm to use. Options are &quot;bladj&quot; or &quot;pathd8&quot;
(Webb et al., 2008, <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>; Britton et al., 2007,
<a href="https://doi.org/10.1080/10635150701613783">doi:10.1080/10635150701613783</a>).</p>
</td></tr>
<tr><td><code id="datelife_use_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+make_datelife_query">make_datelife_query</a></code>
</p>

<dl>
<dt><code>use_tnrs</code></dt><dd><p>Whether to use Open Tree of Life's Taxonomic Name Resolution Service (TNRS)
to process input taxon names. Default to <code>TRUE</code>, it corrects misspellings and
taxonomic name variations with <code><a href="#topic+tnrs_match">tnrs_match()</a></code>, a wrapper of <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code>.</p>
</dd>
<dt><code>get_spp_from_taxon</code></dt><dd><p>Whether to search ages for all species belonging to a
given taxon or not. Default to <code>FALSE</code>. If <code>TRUE</code>, it must have same length as input.
If input is a newick string with some clades it will be converted to a <code>phylo</code>
object, and the order of <code>get_spp_from_taxon</code> will match <code>phy$tip.label</code>.</p>
</dd>
<dt><code>reference_taxonomy</code></dt><dd><p>A character vector specifying the reference taxonomy to use for TNRS.
Options are &quot;ott&quot;, &quot;ncbi&quot;, &quot;gbif&quot; or &quot;irmng&quot;. The function defaults to &quot;ott&quot;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>input</code> is a vector of taxon names, the function will attempt to reconstruct a BOLD
tree with <code><a href="#topic+make_bold_otol_tree">make_bold_otol_tree()</a></code> to get a tree with branch lengths. If it fails,
it will get an Open Tree of Life synthetic tree topology.
The function then calls <code><a href="#topic+use_calibrations">use_calibrations()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> or <code>multiPhylo</code> object with branch lengths proportional to time.
</p>


<h3>More</h3>

<p>The output object stores the used <code>calibrations</code> and <code>dating_method</code> as
<code>attributes(output)$datelife_calibrations</code> and <code>attributes(output)$dating_method</code>.
</p>

<hr>
<h2 id='datelife_use_datelifequery'>Generate one or multiple chronograms for a set of taxon names given as a <code>datelifeQuery</code> object.</h2><span id='topic+datelife_use_datelifequery'></span>

<h3>Description</h3>

<p><code>datelife_use</code> gets secondary calibrations available for any
pair of given taxon names, mined from the <a href="#topic+opentree_chronograms">opentree_chronograms</a> object,
congruifies them, and uses them to date a given tree topology with the
algorithm defined in <code>dating_method</code>. If no tree topology is provided,
it will attempt to get one for the given taxon names from Open Tree of Life
synthetic tree, using <code><a href="#topic+make_bold_otol_tree">make_bold_otol_tree()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datelife_use_datelifequery(
  datelife_query = NULL,
  dating_method = "bladj",
  each = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datelife_use_datelifequery_+3A_datelife_query">datelife_query</code></td>
<td>
<p>A <code>datelifeQuery</code> object, usually an output of <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</td></tr>
<tr><td><code id="datelife_use_datelifequery_+3A_dating_method">dating_method</code></td>
<td>
<p>Tree dating algorithm to use. Options are &quot;bladj&quot; or &quot;pathd8&quot;
(Webb et al., 2008, <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>; Britton et al., 2007,
<a href="https://doi.org/10.1080/10635150701613783">doi:10.1080/10635150701613783</a>).</p>
</td></tr>
<tr><td><code id="datelife_use_datelifequery_+3A_each">each</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>: all calibrations are returned in
the same <code>data.frame</code>. If <code>TRUE</code>, calibrations from each chronogram are returned
in separate data frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>phy</code> has no branch lengths, <code>dating_method</code> is ignores, and the function applies secondary
calibrations to date the tree with the BLADJ algorithm. See <code><a href="#topic+make_bladj_tree">make_bladj_tree()</a></code> and <code><a href="#topic+use_calibrations_bladj">use_calibrations_bladj()</a></code>.
If <code>phy</code> has branch lengths, the function can use the PATHd8 algorithm. See <code><a href="#topic+use_calibrations_pathd8">use_calibrations_pathd8()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> or <code>multiPhylo</code> object with branch lengths proportional to time.
</p>


<h3>More</h3>

<p>The output object stores the used <code>calibrations</code> and <code>dating_method</code> as
<code>attributes(output)$datelife_calibrations</code> and <code>attributes(output)$dating_method</code>.
</p>

<hr>
<h2 id='extract_calibrations_dateliferesult'>Use congruification to extract secondary calibrations from a <code>datelifeResult</code> object.</h2><span id='topic+extract_calibrations_dateliferesult'></span>

<h3>Description</h3>

<p>This function extracts node ages for each taxon
pair given in <code>input$tip.labels</code>. It applies the congruification method
described in Eastman et al. (2013) <a href="https://doi.org/10.1111/2041-210X.12051">doi:10.1111/2041-210X.12051</a>,
implemented with the function <code><a href="geiger.html#topic+congruify.phylo">geiger::congruify.phylo()</a></code>, to create a
<code>data.frame</code> of taxon pair node ages that can be used as secondary calibrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_calibrations_dateliferesult(input = NULL, each = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_calibrations_dateliferesult_+3A_input">input</code></td>
<td>
<p>A <code>datelifeResult</code> object.</p>
</td></tr>
<tr><td><code id="extract_calibrations_dateliferesult_+3A_each">each</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>: all calibrations are returned in
the same <code>data.frame</code>. If <code>TRUE</code>, calibrations from each chronogram are returned
in separate data frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes a <code>datelifeResult</code> object and calls
<code><a href="#topic+summarize_datelife_result">summarize_datelife_result()</a></code> with <code style="white-space: pre;">&#8288;summary_format = "phylo_all". This goes from a &#8288;</code>datelifeResult<code style="white-space: pre;">&#8288;object to a&#8288;</code>phylo<code>or</code>multiPhylo' object that is
passed to <code><a href="#topic+extract_calibrations_phylo">extract_calibrations_phylo()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>calibrations</code>, which is a <code>data.frame</code> (if
<code>each = FALSE</code>) or a list of <code>data.frames</code> (if <code>each = TRUE</code>) of node
ages for each pair of taxon names. You can access the <code>input</code> data from which
the calibrations were extracted with attributes(output)$chronograms.
</p>

<hr>
<h2 id='extract_calibrations_phylo'>Use congruification to extract secondary calibrations from a <code>phylo</code> or <code>multiPhylo</code>
object with branch lengths proportional to time.</h2><span id='topic+extract_calibrations_phylo'></span>

<h3>Description</h3>

<p>This function extracts node ages for each taxon
pair given in <code>input$tip.labels</code>. It applies the congruification method
described in Eastman et al. (2013) <a href="https://doi.org/10.1111/2041-210X.12051">doi:10.1111/2041-210X.12051</a>,
implemented with the function <code><a href="geiger.html#topic+congruify.phylo">geiger::congruify.phylo()</a></code>, to create a
<code>data.frame</code> of taxon pair node ages that can be used as secondary calibrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_calibrations_phylo(input = NULL, each = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_calibrations_phylo_+3A_input">input</code></td>
<td>
<p>A <code>phylo</code> or <code>multiPhylo</code> object with branch lengths
proportional to time.</p>
</td></tr>
<tr><td><code id="extract_calibrations_phylo_+3A_each">each</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>: all calibrations are returned in
the same <code>data.frame</code>. If <code>TRUE</code>, calibrations from each chronogram are returned
in separate data frames.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>calibrations</code>, which is a <code>data.frame</code> (if
<code>each = FALSE</code>) or a list of <code>data.frames</code> (if <code>each = TRUE</code>) of node
ages for each pair of taxon names. You can access the <code>input</code> data from which
the calibrations were extracted with attributes(output)$chronograms.
</p>


<h3>References</h3>

<p>Eastman et al. (2013) &quot;Congruification: support for time scaling large
phylogenetic trees&quot;. Methods in Ecology and Evolution, 4(7), 688-691,
<a href="https://doi.org/10.1111/2041-210X.12051">doi:10.1111/2041-210X.12051</a>.
</p>

<hr>
<h2 id='extract_ott_ids'>Extract numeric OTT ids from a character vector that combines taxon names and OTT ids.</h2><span id='topic+extract_ott_ids'></span><span id='topic+extract_ott_ids.default'></span>

<h3>Description</h3>

<p>Extract numeric OTT ids from a character vector that combines taxon names and OTT ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_ott_ids(x, na.rm = TRUE)

## Default S3 method:
extract_ott_ids(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_ott_ids_+3A_x">x</code></td>
<td>
<p>A character vector of taxon names, or a phylo object with tree tip labels containing OTT ids.</p>
</td></tr>
<tr><td><code id="extract_ott_ids_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether <code>NA</code> values should be stripped from the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class numeric containing OTT ids only.
</p>
<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # This is a flag for package development. You are welcome to run the example.

canis &lt;- rotl::tnrs_match_names("canis")
canis_taxonomy &lt;- rotl::taxonomy_subtree(canis$ott_id)
my_ott_ids &lt;- extract_ott_ids(x = canis_taxonomy$tip_label)
# Get the problematic elements from input
canis_taxonomy$tip_label[attr(my_ott_ids, "na.action")]


## End(Not run) # end dontrun
</code></pre>

<hr>
<h2 id='felid_gdr_phylo_all'>datelifeSummary of a datelifeResult object of all Felidae species.</h2><span id='topic+felid_gdr_phylo_all'></span>

<h3>Description</h3>

<p>datelifeSummary of a datelifeResult object of all Felidae species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>felid_gdr_phylo_all
</code></pre>


<h3>Format</h3>

<p>A list of three elements, containing the summary of a datelifeResult object
</p>

<dl>
<dt>phylo_all</dt><dd><p>List of subset chronograms in phylo format</p>
</dd>
<dt>taxon_distribution</dt><dd><p>A data frame with taxon presence across subset chronograms</p>
</dd>
<dt>absent_taxa</dt><dd><p>A dataframe with names of taxon not found in any chronogram</p>
</dd>
</dl>



<h3>Details</h3>

<p>Generated with:
felid_spp &lt;- make_datelife_query(input = &quot;felidae&quot;, get_spp_from_taxon = TRUE)
felid_gdr &lt;- get_datelife_result(input = felid_spp, get_spp_from_taxon = TRUE)
felid_gdr_phylo_all &lt;- summarize_datelife_result(datelife_result = felid_gdr, taxon_summary = &quot;summary&quot;, summary_format = &quot;phylo_all&quot;, datelife_query = felid_spp)
usethis::use_data(felid_gdr_phylo_all)
</p>


<h3>Source</h3>

<p><a href="http://opentreeoflife.org">http://opentreeoflife.org</a>
</p>

<hr>
<h2 id='felid_sdm'>SDM tree of a datelifeResult object of all Felidae species.</h2><span id='topic+felid_sdm'></span>

<h3>Description</h3>

<p>SDM tree of a datelifeResult object of all Felidae species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>felid_sdm
</code></pre>


<h3>Format</h3>

<p>A list of two elements, containing the summary of a datelifeResult object
</p>

<dl>
<dt>phy</dt><dd><p>An ultrametric phylo object with the SDM tree.</p>
</dd>
<dt>data</dt><dd><p>A datelifeResult object with data used to construct phy</p>
</dd>
</dl>



<h3>Details</h3>

<p>Generated with:
felid_spp &lt;- make_datelife_query(input = &quot;felidae&quot;, get_spp_from_taxon = TRUE)
felid_gdr &lt;- get_datelife_result(input = felid_spp, get_spp_from_taxon = TRUE)
felid_sdm &lt;- datelife_result_sdm_phylo(felid_gdr)
usethis::use_data(felid_sdm)
</p>


<h3>Source</h3>

<p><a href="http://opentreeoflife.org">http://opentreeoflife.org</a>
</p>

<hr>
<h2 id='filter_for_grove'>Filter a <code>datelifeResult</code> object to find the largest grove.</h2><span id='topic+filter_for_grove'></span>

<h3>Description</h3>

<p>Filter a <code>datelifeResult</code> object to find the largest grove.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_for_grove(datelife_result, criterion = "taxa", n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_for_grove_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object. Only needed for <code>criterion = "taxa"</code>.</p>
</td></tr>
<tr><td><code id="filter_for_grove_+3A_criterion">criterion</code></td>
<td>
<p>Defaults to <code>criterion = "taxa"</code>. Used for chronogram summarizing, i.e., obtaining a single
summary chronogram from a group of input chronograms.
For summarizing approaches that return a single summary tree from a group of
phylogenetic trees, it is necessary that the latter form a grove, roughly,
a sufficiently overlapping set of taxa between trees, see Ané et al. (2009) <a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>.
In rare cases, a group of trees can have multiple groves. This argument indicates
whether to get the grove with the most trees (<code>criterion = "trees"</code>) or the
most taxa (<code>criterion = "taxa"</code>).</p>
</td></tr>
<tr><td><code id="filter_for_grove_+3A_n">n</code></td>
<td>
<p>The degree of taxon name overlap among input chronograms. Defaults
to <code>n = 2</code>, i.e., at least two overlapping taxon names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>datelifeResult</code> object filtered to only include one grove of trees.
</p>

<hr>
<h2 id='force_ultrametric'>Force a non-ultrametric <code>phylo</code> object to be ultrametric with <code><a href="phytools.html#topic+force.ultrametric">phytools::force.ultrametric()</a></code>.</h2><span id='topic+force_ultrametric'></span>

<h3>Description</h3>

<p>Force a non-ultrametric <code>phylo</code> object to be ultrametric with <code><a href="phytools.html#topic+force.ultrametric">phytools::force.ultrametric()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force_ultrametric(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="force_ultrametric_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object.
</p>

<hr>
<h2 id='get_all_calibrations'>Get secondary calibrations from a chronogram database for a set of given taxon names</h2><span id='topic+get_all_calibrations'></span><span id='topic+datelife_calibrations'></span>

<h3>Description</h3>

<p><code>get_all_calibrations</code> performs a <code><a href="#topic+datelife_search">datelife_search()</a></code>
and gets divergence times (i.e., secondary calibrations) from a chronogram
database for each taxon name pair given as <code>input</code>.
</p>
<p><code>get_all_calibrations</code> performs a <code><a href="#topic+datelife_search">datelife_search()</a></code>
and gets divergence times (i.e., secondary calibrations) from a chronogram
database for each taxon name pair given as <code>input</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_calibrations(input = NULL, each = FALSE)

get_all_calibrations(input = NULL, each = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_calibrations_+3A_input">input</code></td>
<td>
<p>One of the following:
</p>

<dl>
<dt>A character vector</dt><dd><p>With taxon names as a single comma separated
starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or
<code>multiPhylo</code> object, OR as a newick character string.</p>
</dd>
<dt>A <code>datelifeQuery</code> object</dt><dd><p>An output from <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_all_calibrations_+3A_each">each</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>: all calibrations are returned in
the same <code>data.frame</code>. If <code>TRUE</code>, calibrations from each chronogram are returned
in separate data frames.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>calibrations</code>, which is a <code>data.frame</code> (if
<code>each = FALSE</code>) or a list of <code>data.frames</code> (if <code>each = TRUE</code>) of node
ages for each pair of taxon names. You can access the <code>input</code> data from which
the calibrations were extracted with attributes(output)$chronograms.
</p>

<hr>
<h2 id='get_all_descendant_species'>Quickly get all species belonging to a taxon from the Open Tree of Life Taxonomy (OTT)</h2><span id='topic+get_all_descendant_species'></span>

<h3>Description</h3>

<p>This is less thorough than get_open_tree_species(), but much faster. It uses the fact
that something has just two names (genus and species) to assume that something is a
single species; if it has more than two names, it is assumed to be a subspecies so
it goes up one level in the hierarchy. It will return the subspecies and the species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_descendant_species(taxon_name, ott_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_descendant_species_+3A_taxon_name">taxon_name</code></td>
<td>
<p>A character vector providing an inclusive taxonomic name.</p>
</td></tr>
<tr><td><code id="get_all_descendant_species_+3A_ott_id">ott_id</code></td>
<td>
<p>A numeric vector providig an Open Tree Taxonomic id number for
a taxonomic name. If provided, <code>taxon_name</code> is ignored.
Used in the context of OTT to detect invalid taxon names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of unique OTT names and OTT ids of species within the provided taxon.
</p>

<hr>
<h2 id='get_best_grove'>Get grove from a <code>datelifeResult</code> object that can be converted to phylo
from a median summary matrix</h2><span id='topic+get_best_grove'></span>

<h3>Description</h3>

<p>Get grove from a <code>datelifeResult</code> object that can be converted to phylo
from a median summary matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_best_grove(datelife_result, criterion = "taxa", n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_best_grove_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object. Only needed for <code>criterion = "taxa"</code>.</p>
</td></tr>
<tr><td><code id="get_best_grove_+3A_criterion">criterion</code></td>
<td>
<p>Defaults to <code>criterion = "taxa"</code>. Used for chronogram summarizing, i.e., obtaining a single
summary chronogram from a group of input chronograms.
For summarizing approaches that return a single summary tree from a group of
phylogenetic trees, it is necessary that the latter form a grove, roughly,
a sufficiently overlapping set of taxa between trees, see Ané et al. (2009) <a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>.
In rare cases, a group of trees can have multiple groves. This argument indicates
whether to get the grove with the most trees (<code>criterion = "trees"</code>) or the
most taxa (<code>criterion = "taxa"</code>).</p>
</td></tr>
<tr><td><code id="get_best_grove_+3A_n">n</code></td>
<td>
<p>The degree of taxon name overlap among input chronograms. Defaults
to <code>n = 2</code>, i.e., at least two overlapping taxon names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements:
</p>

<dl>
<dt>best_grove</dt><dd><p>A <code>datelifeResult</code> object filtered to only include one grove of trees that can be summarized with median or sdm.
</p>
</dd>
<dt>overlap</dt><dd><p>The degree of taxon names overlap among trees in the best grove.
</p>
</dd>
</dl>


<hr>
<h2 id='get_biggest_multiphylo'>Get the tree with the most tips from a multiPhylo object: the biggest tree.</h2><span id='topic+get_biggest_multiphylo'></span>

<h3>Description</h3>

<p>Get the tree with the most tips from a multiPhylo object: the biggest tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_biggest_multiphylo(trees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_biggest_multiphylo_+3A_trees">trees</code></td>
<td>
<p>A list of trees as <code>multiPhylo</code> or as a generic <code>list</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The largest tree from those given in <code>trees</code>, as a <code>phylo</code> object with an additional <code style="white-space: pre;">&#8288;$citation&#8288;</code> element containing the reference of the original publication.
</p>

<hr>
<h2 id='get_bold_data'>Get genetic data from the Barcode of Life Database (BOLD) for a set of taxon names.</h2><span id='topic+get_bold_data'></span>

<h3>Description</h3>

<p><code>get_bold_data</code> uses taxon names from a tree topology, a character
vector of names or a <code>datelifeQuery</code> object, to search for genetic markers
in the Barcode of Life Database (BOLD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bold_data(
  input = c("Rhea americana", "Struthio camelus", "Gallus gallus"),
  marker = "COI",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_bold_data_+3A_input">input</code></td>
<td>
<p>One of the following:
</p>

<dl>
<dt>A character vector</dt><dd><p>With taxon names as a single comma separated
starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or
<code>multiPhylo</code> object, OR as a newick character string.</p>
</dd>
<dt>A <code>datelifeQuery</code> object</dt><dd><p>An output from <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_bold_data_+3A_marker">marker</code></td>
<td>
<p>A character vector indicating the gene from BOLD system to be
used for branch length estimation. It searches &quot;COI&quot; marker by default.</p>
</td></tr>
<tr><td><code id="get_bold_data_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_otol_synthetic_tree">get_otol_synthetic_tree</a></code>
</p>

<dl>
<dt><code>otol_version</code></dt><dd><p>Version of Open Tree of Life to use</p>
</dd>
<dt><code>resolve</code></dt><dd><p>Defaults to <code>TRUE</code>. Whether to resolve the tree at random or not.</p>
</dd>
<dt><code>ott_ids</code></dt><dd><p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>input</code> is a <code>phylo</code> object or a newick string, it is used as backbone topology.
If <code>input</code> is a character vector of taxon names, an induced synthetic OpenTree
subtree is used as backbone.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> object. If there are enough BOLD sequences available for the
<code>input</code> taxon names, the function returns a tree with branch lengths proportional
to relative substitution rate. If not enough BOLD sequences are available
for the <code>input</code> taxon names, the function returns the topology given as
<code>input</code>, or a synthetic Open Tree of Life for the taxon names given in
<code>input</code>, obtained with <code><a href="#topic+get_otol_synthetic_tree">get_otol_synthetic_tree()</a></code>.
</p>

<hr>
<h2 id='get_calibrations_datelifequery'>Search and extract available secondary calibrations for taxon names in a given
<code>datelifeQuery</code> object</h2><span id='topic+get_calibrations_datelifequery'></span>

<h3>Description</h3>

<p>The function searches DateLife's local
database of phylogenetic trees with branch lengths proportional to time
(chronograms) with <code><a href="#topic+datelife_search">datelife_search()</a></code>, and extracts available node ages
for each pair of given taxon names with <code><a href="#topic+extract_calibrations_phylo">extract_calibrations_phylo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_calibrations_datelifequery(datelife_query = NULL, each = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_calibrations_datelifequery_+3A_datelife_query">datelife_query</code></td>
<td>
<p>A <code>datelifeQuery</code> object.</p>
</td></tr>
<tr><td><code id="get_calibrations_datelifequery_+3A_each">each</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>: all calibrations are returned in
the same <code>data.frame</code>. If <code>TRUE</code>, calibrations from each chronogram are returned
in separate data frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls <code><a href="#topic+datelife_search">datelife_search()</a></code>
with <code>summary_format = "phylo_all"</code> to get all chronograms in the database
containing at least two taxa in <code>input</code>, and generates a <code>phylo</code>
or <code>multiPhylo</code> object object that will be passed to
<code><a href="#topic+extract_calibrations_phylo">extract_calibrations_phylo()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>calibrations</code>, which is a <code>data.frame</code> (if
<code>each = FALSE</code>) or a list of <code>data.frames</code> (if <code>each = TRUE</code>) of node
ages for each pair of taxon names. You can access the <code>input</code> data from which
the calibrations were extracted with attributes(output)$chronograms.
</p>

<hr>
<h2 id='get_calibrations_vector'>Search and extract secondary calibrations for a given character
vector of taxon names</h2><span id='topic+get_calibrations_vector'></span>

<h3>Description</h3>

<p>The function searches DateLife's local
database of phylogenetic trees with branch lengths proportional to time
(chronograms) with <code><a href="#topic+datelife_search">datelife_search()</a></code>, and extracts available node ages
for each pair of given taxon names with <code><a href="#topic+extract_calibrations_phylo">extract_calibrations_phylo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_calibrations_vector(input = NULL, each = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_calibrations_vector_+3A_input">input</code></td>
<td>
<p>A character vector of taxon names.</p>
</td></tr>
<tr><td><code id="get_calibrations_vector_+3A_each">each</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>: all calibrations are returned in
the same <code>data.frame</code>. If <code>TRUE</code>, calibrations from each chronogram are returned
in separate data frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls <code><a href="#topic+datelife_search">datelife_search()</a></code>
with <code>summary_format = "phylo_all"</code> to get all chronograms in the database
containing at least two taxa in <code>input</code>, and generates a <code>phylo</code>
or <code>multiPhylo</code> object object that will be passed to
<code><a href="#topic+extract_calibrations_phylo">extract_calibrations_phylo()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>calibrations</code>, which is a <code>data.frame</code> (if
<code>each = FALSE</code>) or a list of <code>data.frames</code> (if <code>each = TRUE</code>) of node
ages for each pair of taxon names. You can access the <code>input</code> data from which
the calibrations were extracted with attributes(output)$chronograms.
</p>

<hr>
<h2 id='get_dated_otol_induced_subtree'>Get a dated OpenTree induced synthetic subtree from a set of given taxon names, from blackrim's FePhyFoFum service.</h2><span id='topic+get_dated_otol_induced_subtree'></span>

<h3>Description</h3>

<p>Get a dated OpenTree induced synthetic subtree from a set of given taxon names, from blackrim's FePhyFoFum service.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dated_otol_induced_subtree(input = NULL, ott_ids = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dated_otol_induced_subtree_+3A_input">input</code></td>
<td>
<p>Optional. A character vector of names or a <code>datelifeQuery</code> object.</p>
</td></tr>
<tr><td><code id="get_dated_otol_induced_subtree_+3A_ott_ids">ott_ids</code></td>
<td>
<p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</td></tr>
<tr><td><code id="get_dated_otol_induced_subtree_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+check_ott_input">check_ott_input</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>OpenTree dated tree from Stephen Smith's OpenTree scaling service at
https://github.com/FePhyFoFum/gophy if you want to make an LTT plot of
a dated OpenTree tree you'll need to get rid of singleton nodes with
<code><a href="ape.html#topic+collapse.singles">ape::collapse.singles()</a></code> and also probably do <code><a href="phytools.html#topic+force.ultrametric">phytools::force.ultrametric()</a></code>.
</p>


<h3>Value</h3>

<p>A phylo object with edge length proportional to time in Myrs. It will return NA if any ott_id is invalid.
</p>

<hr>
<h2 id='get_datelife_result'>Get a patristic matrix of time of lineage divergence data for a given set of taxon names</h2><span id='topic+get_datelife_result'></span>

<h3>Description</h3>

<p><code>get_datelife_result</code> takes as input a vector of taxon names, a newick string,
a <code>phylo</code> object, or a<code>datelifeQuery</code> object. It searches the chronogram
database specified in <code>cache</code> for chronograms matching two or more given
taxon names. For each matching chronogram, it extracts time of lineage
divergence data and stores it as a patristic matrix. It then lists all
resulting patristic matrices. Each list element is named with the study
citation of the source chronogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_datelife_result(
  input = NULL,
  partial = TRUE,
  cache = "opentree_chronograms",
  update_opentree_chronograms = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_datelife_result_+3A_input">input</code></td>
<td>
<p>One of the following:
</p>

<dl>
<dt>A character vector</dt><dd><p>With taxon names as a single comma separated
starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or
<code>multiPhylo</code> object, OR as a newick character string.</p>
</dd>
<dt>A <code>datelifeQuery</code> object</dt><dd><p>An output from <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_datelife_result_+3A_partial">partial</code></td>
<td>
<p>Whether to return or exclude partially matching source chronograms,
i.e, those that match some and not all of taxa given in <code>datelife_query</code>.
Options are <code>TRUE</code> or <code>FALSE</code>. Defaults to <code>TRUE</code>: return all matching source
chronograms.</p>
</td></tr>
<tr><td><code id="get_datelife_result_+3A_cache">cache</code></td>
<td>
<p>A character vector of length one, with the name of the data object
to cache. Default to <code>"opentree_chronograms"</code>, a data object storing Open Tree of
Life's database chronograms and other associated information.</p>
</td></tr>
<tr><td><code id="get_datelife_result_+3A_update_opentree_chronograms">update_opentree_chronograms</code></td>
<td>
<p>Whether to update the chronogram database or not.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_datelife_result_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+make_datelife_query">make_datelife_query</a></code>
</p>

<dl>
<dt><code>use_tnrs</code></dt><dd><p>Whether to use Open Tree of Life's Taxonomic Name Resolution Service (TNRS)
to process input taxon names. Default to <code>TRUE</code>, it corrects misspellings and
taxonomic name variations with <code><a href="#topic+tnrs_match">tnrs_match()</a></code>, a wrapper of <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code>.</p>
</dd>
<dt><code>get_spp_from_taxon</code></dt><dd><p>Whether to search ages for all species belonging to a
given taxon or not. Default to <code>FALSE</code>. If <code>TRUE</code>, it must have same length as input.
If input is a newick string with some clades it will be converted to a <code>phylo</code>
object, and the order of <code>get_spp_from_taxon</code> will match <code>phy$tip.label</code>.</p>
</dd>
<dt><code>reference_taxonomy</code></dt><dd><p>A character vector specifying the reference taxonomy to use for TNRS.
Options are &quot;ott&quot;, &quot;ncbi&quot;, &quot;gbif&quot; or &quot;irmng&quot;. The function defaults to &quot;ott&quot;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>datelifeResult</code> object &ndash; a named list of patristic matrices.
</p>

<hr>
<h2 id='get_datelife_result_datelifequery'>Get a list of patristic matrices from a given <code>datelifeQuery</code> object</h2><span id='topic+get_datelife_result_datelifequery'></span>

<h3>Description</h3>

<p>Get a list of patristic matrices from a given <code>datelifeQuery</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_datelife_result_datelifequery(
  datelife_query = NULL,
  partial = TRUE,
  cache = "opentree_chronograms",
  update_opentree_chronograms = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_datelife_result_datelifequery_+3A_datelife_query">datelife_query</code></td>
<td>
<p>A <code>datelifeQuery</code> object, usually an output of <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</td></tr>
<tr><td><code id="get_datelife_result_datelifequery_+3A_partial">partial</code></td>
<td>
<p>Whether to return or exclude partially matching source chronograms,
i.e, those that match some and not all of taxa given in <code>datelife_query</code>.
Options are <code>TRUE</code> or <code>FALSE</code>. Defaults to <code>TRUE</code>: return all matching source
chronograms.</p>
</td></tr>
<tr><td><code id="get_datelife_result_datelifequery_+3A_cache">cache</code></td>
<td>
<p>A character vector of length one, with the name of the data object
to cache. Default to <code>"opentree_chronograms"</code>, a data object storing Open Tree of
Life's database chronograms and other associated information.</p>
</td></tr>
<tr><td><code id="get_datelife_result_datelifequery_+3A_update_opentree_chronograms">update_opentree_chronograms</code></td>
<td>
<p>Whether to update the chronogram database or not.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_datelife_result_datelifequery_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+make_datelife_query">make_datelife_query</a></code>
</p>

<dl>
<dt><code>input</code></dt><dd><p>Taxon names as one of the following:
</p>

<dl>
<dt>A character vector of taxon names</dt><dd><p>With taxon names as a single comma separated starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or <code>multiPhylo</code>
object, OR as a newick character string.</p>
</dd>
</dl>
</dd>
<dt><code>use_tnrs</code></dt><dd><p>Whether to use Open Tree of Life's Taxonomic Name Resolution Service (TNRS)
to process input taxon names. Default to <code>TRUE</code>, it corrects misspellings and
taxonomic name variations with <code><a href="#topic+tnrs_match">tnrs_match()</a></code>, a wrapper of <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code>.</p>
</dd>
<dt><code>get_spp_from_taxon</code></dt><dd><p>Whether to search ages for all species belonging to a
given taxon or not. Default to <code>FALSE</code>. If <code>TRUE</code>, it must have same length as input.
If input is a newick string with some clades it will be converted to a <code>phylo</code>
object, and the order of <code>get_spp_from_taxon</code> will match <code>phy$tip.label</code>.</p>
</dd>
<dt><code>reference_taxonomy</code></dt><dd><p>A character vector specifying the reference taxonomy to use for TNRS.
Options are &quot;ott&quot;, &quot;ncbi&quot;, &quot;gbif&quot; or &quot;irmng&quot;. The function defaults to &quot;ott&quot;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>If there is just one taxon name in <code>input$cleaned_names</code>, the
function will run <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code> setting <code>get_spp_from_taxon = TRUE</code>.
The <code>datelifeQuery</code> used as input can be accessed with <code>attributes(datelifeResult)$query</code>.
</p>


<h3>Value</h3>

<p>A <code>datelifeResult</code> object &ndash; a named list of patristic matrices.
</p>

<hr>
<h2 id='get_fossil_range'>Get the ages for a taxon from PBDB</h2><span id='topic+get_fossil_range'></span>

<h3>Description</h3>

<p>This uses the Paleobiology Database's API to gather information on the ages for all specimens of a taxon. It will also look for all descendants of the taxon. It fixes name misspellings if possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fossil_range(taxon, recent = FALSE, assume_recent_if_missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fossil_range_+3A_taxon">taxon</code></td>
<td>
<p>The scientific name of the taxon you want the range of occurrences of</p>
</td></tr>
<tr><td><code id="get_fossil_range_+3A_recent">recent</code></td>
<td>
<p>If TRUE, forces the minimum age to be zero</p>
</td></tr>
<tr><td><code id="get_fossil_range_+3A_assume_recent_if_missing">assume_recent_if_missing</code></td>
<td>
<p>If TRUE, any taxon missing from pbdb is assumed to be recent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of max_ma and min_ma for the specimens
</p>

<hr>
<h2 id='get_goodmatrices'>Get indices of good matrices to apply Super Distance Matrix (SDM) method with <code><a href="#topic+make_sdm">make_sdm()</a></code>.</h2><span id='topic+get_goodmatrices'></span>

<h3>Description</h3>

<p>Get indices of good matrices to apply Super Distance Matrix (SDM) method with <code><a href="#topic+make_sdm">make_sdm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_goodmatrices(unpadded.matrices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_goodmatrices_+3A_unpadded.matrices">unpadded.matrices</code></td>
<td>
<p>A list of patristic matrices, a <code>datelifeResult</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of good matrix indices in unpadded.matrices.
</p>

<hr>
<h2 id='get_mrbayes_node_constraints'>Makes a block of node constraints and node calibrations for a MrBayes run file
from a list of taxa and ages, or from a dated tree</h2><span id='topic+get_mrbayes_node_constraints'></span>

<h3>Description</h3>

<p>Makes a block of node constraints and node calibrations for a MrBayes run file
from a list of taxa and ages, or from a dated tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mrbayes_node_constraints(
  constraint = NULL,
  taxa = NULL,
  missing_taxa = NULL,
  ncalibration = NULL,
  age_distribution = "fixed",
  root_calibration = FALSE,
  mrbayes_constraints_file = NULL,
  clockratepr = "prset clockratepr = fixed(1);"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mrbayes_node_constraints_+3A_constraint">constraint</code></td>
<td>
<p>The constraint tree: a phylo object or a newick character string, with or without branch lengths.</p>
</td></tr>
<tr><td><code id="get_mrbayes_node_constraints_+3A_taxa">taxa</code></td>
<td>
<p>A character vector with taxon names to be maintained in tree</p>
</td></tr>
<tr><td><code id="get_mrbayes_node_constraints_+3A_missing_taxa">missing_taxa</code></td>
<td>
<p>A tree, a data frame or a vector enlisting all missing taxa you want to include.
</p>

<dl>
<dt>A tree</dt><dd><p>Either as a phylo object or as a newick character string.
It contains all taxa that you want at the end, both missing and non missing.
This tree will be used as a hard constraint.</p>
</dd>
<dt>A <code>data.frame</code></dt><dd><p>It contains two columns named &quot;taxon&quot; and &quot;clade&quot;.
The first one contains a character vector of missing taxon names.
The second one contains a character or numeric vector of nodes from a
constraint tree to which each taxon will be assigned.</p>
</dd>
<dt>A character vector</dt><dd><p>It contains the names of the missing taxa.
They will be added at random to the constraint tree.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_mrbayes_node_constraints_+3A_ncalibration">ncalibration</code></td>
<td>
<p>The node calibrations: a phylo object with branch lengths
proportional to time; in this case all nodes from ncalibration will be used
as calibration points. Alternatively, a list with two elements: the first is
a character vector with node names from phy to calibrate; the second is a numeric
vector with the corresponding ages to use as calibrations.</p>
</td></tr>
<tr><td><code id="get_mrbayes_node_constraints_+3A_age_distribution">age_distribution</code></td>
<td>
<p>A character string specifying the type of calibration.
Only &quot;fixed&quot; and &quot;uniform&quot; are implemented for now.
</p>

<dl>
<dt>fixed</dt><dd><p>The age given in ncalibration will be used as fixed age.</p>
</dd>
<dt>lognormal</dt><dd><p>The age given in ncalibration will be used as mean age.
The standard deviation can be provided. # still need to add this option.
By default, a 95 CI sd is used.</p>
</dd>
<dt>uniform</dt><dd><p>The age given in ncalibration will be used as mean age.
Where min_age = 0.9 * mean age, and max_age = 1.1 * mean age.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_mrbayes_node_constraints_+3A_root_calibration">root_calibration</code></td>
<td>
<p>Used to set a calibration at the root or not. Default
to FALSE. Only relevant if ncalibration is specified.</p>
</td></tr>
<tr><td><code id="get_mrbayes_node_constraints_+3A_mrbayes_constraints_file">mrbayes_constraints_file</code></td>
<td>
<p>NULL or a character vector indicating the name
of mrbayes constraint and/or calibration block file.</p>
</td></tr>
<tr><td><code id="get_mrbayes_node_constraints_+3A_clockratepr">clockratepr</code></td>
<td>
<p>A character vector indicating the clockrateprior to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set of MrBayes constraints and/or calibration commands printed in console
as character strings or as a text file specified in mrbayes_constraints_file.
</p>

<hr>
<h2 id='get_opentree_chronograms'>Get all chronograms from Open Tree of Life database</h2><span id='topic+get_opentree_chronograms'></span><span id='topic+get_otol_chronograms'></span>

<h3>Description</h3>

<p>Get all chronograms from Open Tree of Life database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_opentree_chronograms(max_tree_count = "all")

get_otol_chronograms(max_tree_count = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_opentree_chronograms_+3A_max_tree_count">max_tree_count</code></td>
<td>
<p>Default to &quot;all&quot;, it gets all available chronograms. For testing purposes, a numeric value indicating the max number of trees to be cached.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 4 elements:
</p>

<dl>
<dt>authors</dt><dd><p>A list of lists of author names of the original studies that
published chronograms currently stored in the Open Tree of Life database.</p>
</dd>
<dt>curators</dt><dd><p>A list of lists of curator names that uploaded chronograms
to the Open Tree of Life database.</p>
</dd>
<dt>studies</dt><dd><p>A list of study identifiers from original studies that
published chronograms currently stored in the Open Tree of Life database.</p>
</dd>
<dt>trees</dt><dd><p>A <code>multiPhylo</code> object storing the chronograms from Open Tree of
Life database.</p>
</dd>
<dt>update</dt><dd><p>A character vector indicating the time when the database object
was last updated.</p>
</dd>
<dt>version</dt><dd><p>A character vector indicating the datelife package version when the
object was last updated.</p>
</dd>
</dl>


<hr>
<h2 id='get_opentree_species'>Get all species belonging to a taxon from the Open Tree of Life Taxonomy (OTT)</h2><span id='topic+get_opentree_species'></span>

<h3>Description</h3>

<p>Get all species belonging to a taxon from the Open Tree of Life Taxonomy (OTT)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_opentree_species(taxon_name, ott_id, synth_tree_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_opentree_species_+3A_taxon_name">taxon_name</code></td>
<td>
<p>A character vector providing an inclusive taxonomic name.</p>
</td></tr>
<tr><td><code id="get_opentree_species_+3A_ott_id">ott_id</code></td>
<td>
<p>A numeric vector providig an Open Tree Taxonomic id number for
a taxonomic name. If provided, <code>taxon_name</code> is ignored.
Used in the context of OTT to detect invalid taxon names.</p>
</td></tr>
<tr><td><code id="get_opentree_species_+3A_synth_tree_only">synth_tree_only</code></td>
<td>
<p>Whether to include species that are in the synthetic Open
Tree of Life only or not. Default to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of unique OTT names and OTT ids of species within the provided taxon.
</p>

<hr>
<h2 id='get_otol_synthetic_tree'>Get an Open Tree of Life synthetic subtree of a set of given taxon names.</h2><span id='topic+get_otol_synthetic_tree'></span>

<h3>Description</h3>

<p>Get an Open Tree of Life synthetic subtree of a set of given taxon names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_otol_synthetic_tree(
  input = NULL,
  ott_ids = NULL,
  otol_version = "v3",
  resolve = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_otol_synthetic_tree_+3A_input">input</code></td>
<td>
<p>Optional. A character vector of names or a <code>datelifeQuery</code> object.</p>
</td></tr>
<tr><td><code id="get_otol_synthetic_tree_+3A_ott_ids">ott_ids</code></td>
<td>
<p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</td></tr>
<tr><td><code id="get_otol_synthetic_tree_+3A_otol_version">otol_version</code></td>
<td>
<p>Version of Open Tree of Life to use</p>
</td></tr>
<tr><td><code id="get_otol_synthetic_tree_+3A_resolve">resolve</code></td>
<td>
<p>Defaults to <code>TRUE</code>. Whether to resolve the tree at random or not.</p>
</td></tr>
<tr><td><code id="get_otol_synthetic_tree_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+check_ott_input">check_ott_input</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A phylo object
</p>

<hr>
<h2 id='get_ott_children'>Use this instead of <code><a href="rotl.html#topic+tol_subtree">rotl::tol_subtree()</a></code> when taxa are not in synthesis tree and
you still need to get all species or an induced OpenTree subtree</h2><span id='topic+get_ott_children'></span>

<h3>Description</h3>

<p>Use this instead of <code><a href="rotl.html#topic+tol_subtree">rotl::tol_subtree()</a></code> when taxa are not in synthesis tree and
you still need to get all species or an induced OpenTree subtree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ott_children(input = NULL, ott_ids = NULL, ott_rank = "species", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ott_children_+3A_input">input</code></td>
<td>
<p>Optional. A character vector of names or a <code>datelifeQuery</code> object.</p>
</td></tr>
<tr><td><code id="get_ott_children_+3A_ott_ids">ott_ids</code></td>
<td>
<p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</td></tr>
<tr><td><code id="get_ott_children_+3A_ott_rank">ott_rank</code></td>
<td>
<p>A character vector with the ranks you wanna get lineage children from.</p>
</td></tr>
<tr><td><code id="get_ott_children_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+get_valid_children">get_valid_children()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An example with the dog genus:

# It is currently not possible to get an OpenTree subtree of a taxon that is
#  missing from the OpenTree synthetic tree.
# The dog genus is not monophyletic in the OpenTree synthetic tree, so in
#  practice, it has no node to extract a subtree from.
tnrs &lt;- tnrs_match("Canis")

## Not run:  # This is a flag for package development. You are welcome to run the example.
rotl::tol_subtree(tnrs$ott_id[1])
#&gt; Error: HTTP failure: 400
#&gt; [/v3/tree_of_life/subtree] Error: node_id was not found (broken taxon).


## End(Not run) # end dontrun

ids &lt;- tnrs$ott_id[1]
names(ids) &lt;- tnrs$unique_name
children &lt;- get_ott_children(ott_ids = ids) # or
children &lt;- get_ott_children(input = "Canis")
if (!is.na(children)) {
str(children)
ids &lt;- children$Canis$ott_id
names(ids) &lt;- rownames(children$Canis)
tree_children &lt;- datelife::get_otol_synthetic_tree(ott_ids = ids)
plot(tree_children, cex = 0.3)
}

# An example with flowering plants:

## Not run:  # This is a flag for package development. You are welcome to run the example.

oo &lt;- get_ott_children(input = "magnoliophyta", ott_rank = "order")
# Get the number of orders of flowering plants that we have
sum(oo$Magnoliophyta$rank == "order")


## End(Not run) # end dontrun
</code></pre>

<hr>
<h2 id='get_ott_clade'>Get the Open Tree of Life Taxonomic identifiers (OTT ids) and name of one or
several given taxonomic ranks from one or more input taxa.</h2><span id='topic+get_ott_clade'></span>

<h3>Description</h3>

<p>Get the Open Tree of Life Taxonomic identifiers (OTT ids) and name of one or
several given taxonomic ranks from one or more input taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ott_clade(input = NULL, ott_ids = NULL, ott_rank = "family")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ott_clade_+3A_input">input</code></td>
<td>
<p>Optional. A character vector of names or a <code>datelifeQuery</code> object.</p>
</td></tr>
<tr><td><code id="get_ott_clade_+3A_ott_ids">ott_ids</code></td>
<td>
<p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</td></tr>
<tr><td><code id="get_ott_clade_+3A_ott_rank">ott_rank</code></td>
<td>
<p>A character vector with the ranks you wanna get lineage children from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named numeric vectors with OTT ids from input and all requested ranks.
</p>

<hr>
<h2 id='get_ott_lineage'>Get the Open Tree of Life Taxonomic identifier (OTT id) and name of all lineages
from one or more input taxa.</h2><span id='topic+get_ott_lineage'></span>

<h3>Description</h3>

<p>Get the Open Tree of Life Taxonomic identifier (OTT id) and name of all lineages
from one or more input taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ott_lineage(input = NULL, ott_ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ott_lineage_+3A_input">input</code></td>
<td>
<p>Optional. A character vector of names or a <code>datelifeQuery</code> object.</p>
</td></tr>
<tr><td><code id="get_ott_lineage_+3A_ott_ids">ott_ids</code></td>
<td>
<p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named numeric vectors of ott ids from input and all the clades it belongs to.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # This is a flag for package development. You are welcome to run the example.

taxa &lt;- c("Homo", "Bacillus anthracis", "Apis", "Salvia")
lin &lt;- get_ott_lineage(taxa)
lin

# Look up an unknown OTT id:
get_ott_lineage(ott_id = 454749)


## End(Not run) # end dontrun
</code></pre>

<hr>
<h2 id='get_subset_array_dispatch'>Figure out which subset function to use.</h2><span id='topic+get_subset_array_dispatch'></span>

<h3>Description</h3>

<p><code>get_subset_array_dispatch</code> is used inside <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subset_array_dispatch(
  study_element,
  taxa,
  phy = NULL,
  phy4 = NULL,
  dating_method = "PATHd8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subset_array_dispatch_+3A_study_element">study_element</code></td>
<td>
<p>The thing being passed in: an <code>array</code> or a <code>phylo</code> object
to serve as reference for congruification.</p>
</td></tr>
<tr><td><code id="get_subset_array_dispatch_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
<tr><td><code id="get_subset_array_dispatch_+3A_phy">phy</code></td>
<td>
<p>A user tree to congruify as <code>phylo</code> object (ape).</p>
</td></tr>
<tr><td><code id="get_subset_array_dispatch_+3A_phy4">phy4</code></td>
<td>
<p>A user tree to congruify in <code>phylo4</code> format (phylobase).</p>
</td></tr>
<tr><td><code id="get_subset_array_dispatch_+3A_dating_method">dating_method</code></td>
<td>
<p>The method used for tree dating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A patristic matrix with ages for the target taxa.
</p>

<hr>
<h2 id='get_taxon_summary'>Get a taxon summary of a <code>datelifeResult</code> object.</h2><span id='topic+get_taxon_summary'></span>

<h3>Description</h3>

<p>Get a taxon summary of a <code>datelifeResult</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxon_summary(datelife_result = NULL, datelife_query = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxon_summary_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
<tr><td><code id="get_taxon_summary_+3A_datelife_query">datelife_query</code></td>
<td>
<p>A <code>datelifeQuery</code> object, usually an output of <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>datelifeTaxonSummary</code> object, which is a list of 4 elements:
</p>

<dl>
<dt>$matrix</dt><dd><p>Data as a presence/absence matrix of taxon names across chronograms.</p>
</dd>
<dt>$summary</dt><dd><p>A <code>data.frame</code> with taxon names as <code><a href="base.html#topic+row.names">row.names()</a></code> and two
columns, one with the number of chronograms that contain a taxon name and
the other one with the total number of chronograms that have at least 2
taxon names.</p>
</dd>
<dt>$summary2</dt><dd><p>A <code>data.frame</code> with chronogram citations as <code><a href="base.html#topic+row.names">row.names()</a></code>
and two columns, one with the number of taxon names found in each chronogram
and the other one with the total number of taxon names.</p>
</dd>
<dt>$absent_taxa</dt><dd><p>A character vector of taxon names that are not found
in the chronogram database.</p>
</dd>
</dl>


<hr>
<h2 id='get_tnrs_names'>Process a character vector of taxon names with TNRS</h2><span id='topic+get_tnrs_names'></span>

<h3>Description</h3>

<p><code>make_datelife_query2</code> always uses TNRS (Taxonomic Name Resolution Service
to process input taxon names, to correct misspellings and
taxonomic name variations with <code><a href="#topic+tnrs_match">tnrs_match()</a></code>, a wrapper of <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tnrs_names(
  input = c("Rhea americana", "Pterocnemia pennata", "Struthio camelus"),
  reference_taxonomy = "ott",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tnrs_names_+3A_input">input</code></td>
<td>
<p>Taxon names as a character vector of taxon names. Two or more
names can be provided as a single comma separated string or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</td></tr>
<tr><td><code id="get_tnrs_names_+3A_reference_taxonomy">reference_taxonomy</code></td>
<td>
<p>A character vector specifying the reference taxonomy to use for TNRS.
Options are &quot;ott&quot;, &quot;ncbi&quot;, &quot;gbif&quot; or &quot;irmng&quot;. The function defaults to &quot;ott&quot;.</p>
</td></tr>
<tr><td><code id="get_tnrs_names_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names</a></code>
</p>

<dl>
<dt><code>context_name</code></dt><dd><p>name of the taxonomic context to be searched (length-one
character vector or <code>NULL</code>). Must match (case sensitive) one of the
values returned by <code><a href="rotl.html#topic+tnrs_contexts">tnrs_contexts</a></code>. Default to &quot;All life&quot;.</p>
</dd>
<dt><code>do_approximate_matching</code></dt><dd><p>A logical indicating whether or not to
perform approximate string (a.k.a. &ldquo;fuzzy&rdquo;) matching. Using
<code>FALSE</code> will greatly improve speed. Default, however, is <code>TRUE</code>.</p>
</dd>
<dt><code>ids</code></dt><dd><p>A vector of ids to use for identifying names. These will be
assigned to each name in the names array. If ids is provided, then ids and
names must be identical in length.</p>
</dd>
<dt><code>include_suppressed</code></dt><dd><p>Ordinarily, some quasi-taxa, such as incertae
sedis buckets and other non-OTUs, are suppressed from TNRS results. If
this parameter is true, these quasi-taxa are allowed as possible TNRS
results.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>datelifeTNRS</code> object, which is a list of three elements:
</p>

<dl>
<dt>$cleaned_names</dt><dd><p>A character vector of names provided as input.</p>
</dd>
<dt>$tnrs_names</dt><dd><p>A character vector of taxon names processed with TNRS.</p>
</dd>
<dt>$ott_ids</dt><dd><p>A numeric vector of Open Tree of Life Taxonomy (OTT) ids.</p>
</dd>
</dl>


<hr>
<h2 id='get_valid_children'>Extract valid children from given taxonomic name(s) or Open Tree of Life
Taxonomic identifiers (OTT ids) from a taxonomic source.</h2><span id='topic+get_valid_children'></span>

<h3>Description</h3>

<p>Extract valid children from given taxonomic name(s) or Open Tree of Life
Taxonomic identifiers (OTT ids) from a taxonomic source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_valid_children(input = NULL, ott_ids = NULL, reference_taxonomy = "ncbi")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_valid_children_+3A_input">input</code></td>
<td>
<p>Optional. A character vector of names or a <code>datelifeQuery</code> object.</p>
</td></tr>
<tr><td><code id="get_valid_children_+3A_ott_ids">ott_ids</code></td>
<td>
<p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</td></tr>
<tr><td><code id="get_valid_children_+3A_reference_taxonomy">reference_taxonomy</code></td>
<td>
<p>A character vector with the desired taxonomic sources.
Options are &quot;ncbi&quot;, &quot;gbif&quot; or &quot;irmng&quot;. Any other value will retrieve data
from all taxonomic sources. The function defaults to &quot;ncbi&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GBIF and other taxonomies contain deprecated taxa that are not marked as such
in the Open Tree of Life Taxonomy.
We are relying mainly in the NCBI taxonomy for now.
</p>


<h3>Value</h3>

<p>A named list containing valid taxonomic children of given taxonomic name(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># genus Dictyophyllidites with ott id = 6003921 has only extinct children
# in cases like this the same name will be returned

tti &lt;- rotl::taxonomy_taxon_info(6003921, include_children = TRUE)
gvc &lt;- get_valid_children(ott_ids = 6003921)

# More examples:

get_valid_children(ott_ids = 769681) # Psilotopsida
get_valid_children(ott_ids = 56601) # Marchantiophyta
</code></pre>

<hr>
<h2 id='input_process'>Process a phylo object or a character string to determine if it's correct newick</h2><span id='topic+input_process'></span>

<h3>Description</h3>

<p>Process a phylo object or a character string to determine if it's correct newick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input_process(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="input_process_+3A_input">input</code></td>
<td>
<p>Taxon names as one of the following:
</p>

<dl>
<dt>A character vector of taxon names</dt><dd><p>With taxon names as a single comma separated starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or <code>multiPhylo</code>
object, OR as a newick character string.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object or <code>NA</code> if input is not a tree .
</p>

<hr>
<h2 id='is_datelife_query'>Check if input is a <code>datelifeQuery</code> object</h2><span id='topic+is_datelife_query'></span>

<h3>Description</h3>

<p><code>is_datelife_query</code> checks for two things to be <code>TRUE</code> or <code>FALSE</code>.
First, that <code>input</code> is of class datelifeQuery.
Second, that <code>input</code> is a list that contains at least two elements of a <code>datelifeQuery</code> object:
</p>

<dl>
<dt>cleaned_names</dt><dd><p>A character vector of taxon names.</p>
</dd>
<dt>phy</dt><dd><p>Either NA or a <code>phylo</code> object.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>is_datelife_query(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_datelife_query_+3A_input">input</code></td>
<td>
<p>An object to be checked as an object with essential properties of a 'datelifeQuery' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object has the correct format but it has a class different than
<code>datelifeQuery</code>, the class is not modified.
</p>


<h3>Value</h3>

<p>Is determined by the second condition.
</p>

<hr>
<h2 id='is_datelife_result_empty'>Check if we obtained an empty search with the given taxon name(s).</h2><span id='topic+is_datelife_result_empty'></span>

<h3>Description</h3>

<p>Check if we obtained an empty search with the given taxon name(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_datelife_result_empty(datelife_result, use_tnrs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_datelife_result_empty_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
<tr><td><code id="is_datelife_result_empty_+3A_use_tnrs">use_tnrs</code></td>
<td>
<p>Whether to use Open Tree of Life's Taxonomic Name Resolution Service (TNRS)
to process input taxon names. Default to <code>TRUE</code>, it corrects misspellings and
taxonomic name variations with <code><a href="#topic+tnrs_match">tnrs_match()</a></code>, a wrapper of <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean. If <code>TRUE</code>, no chronograms were found for the given taxon name(s).
If <code>FALSE</code>, the chronogram search was successful.
</p>

<hr>
<h2 id='is_good_chronogram'>Check if a tree is a valid chronogram.</h2><span id='topic+is_good_chronogram'></span>

<h3>Description</h3>

<p>Check if a tree is a valid chronogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_good_chronogram(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_good_chronogram_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if it is a valid tree.
</p>

<hr>
<h2 id='is_n_overlap'>Function for computing n-overlap for two vectors of names (ie., phy1$tip.label, phy2$tip.label) and seeing if they have n overlap</h2><span id='topic+is_n_overlap'></span>

<h3>Description</h3>

<p>This function implements definition 2.8 for n-overlap from Ané
et al. (2009) <a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_n_overlap(names_1, names_2, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_n_overlap_+3A_names_1">names_1</code></td>
<td>
<p>First vector of names</p>
</td></tr>
<tr><td><code id="is_n_overlap_+3A_names_2">names_2</code></td>
<td>
<p>Second vector of names</p>
</td></tr>
<tr><td><code id="is_n_overlap_+3A_n">n</code></td>
<td>
<p>Degree of overlap required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean for whether the degree of overlap was met or not.
</p>


<h3>References</h3>

<p>Ané, C., Eulenstein, O., Piaggio-Talice, R., &amp; Sanderson, M. J. (2009).
&quot;Groves of phylogenetic trees&quot;. Annals of Combinatorics, 13(2), 139-167,
<a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>.
</p>

<hr>
<h2 id='make_all_associations'>Find all authors and where they have deposited their trees</h2><span id='topic+make_all_associations'></span>

<h3>Description</h3>

<p>Find all authors and where they have deposited their trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_all_associations(outputfile = "depositorcache.RData")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_all_associations_+3A_outputfile">outputfile</code></td>
<td>
<p>Path including file name. NULL to prevent saving.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> of &quot;person&quot; and &quot;urls&quot;.
</p>

<hr>
<h2 id='make_bladj_tree'>Use the BLADJ algorithm to get a chronogram from a tree topology for which you have age data for some of its nodes.</h2><span id='topic+make_bladj_tree'></span>

<h3>Description</h3>

<p>The function takes a tree topology and uses the BLADJ algorithm
implemented with <code><a href="phylocomr.html#topic+ph_bladj">phylocomr::ph_bladj()</a></code> to assign node ages and branch lengths, given a
set of fixed node ages and respective node names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_bladj_tree(tree = NULL, nodenames = NULL, nodeages = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_bladj_tree_+3A_tree">tree</code></td>
<td>
<p>A tree either as a newick character string or as a <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="make_bladj_tree_+3A_nodenames">nodenames</code></td>
<td>
<p>A character vector with names of nodes in tree with known ages</p>
</td></tr>
<tr><td><code id="make_bladj_tree_+3A_nodeages">nodeages</code></td>
<td>
<p>A numeric vector with the actual ages of named nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input <code>tree</code> can be dated or not, <code style="white-space: pre;">&#8288;$edge.length&#8288;</code> is ignored.
Ages given in <code>nodeages</code> are fixed on their corresponding nodes given in <code>nodenames</code>.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> object.
</p>

<hr>
<h2 id='make_bold_otol_tree'>Use genetic data from the Barcode of Life Database (BOLD) to reconstruct branch lengths on a tree.</h2><span id='topic+make_bold_otol_tree'></span>

<h3>Description</h3>

<p><code>make_bold_otol_tree</code> takes taxon names from a tree topology or
a vector of names to search for genetic markers in the Barcode of Life Database
(BOLD), create an alignment, and reconstruct branch lengths on a tree topology
with Maximum Likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_bold_otol_tree(
  input = c("Rhea americana", "Struthio camelus", "Gallus gallus"),
  marker = "COI",
  otol_version = "v3",
  chronogram = TRUE,
  doML = FALSE,
  aligner = "muscle",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_bold_otol_tree_+3A_input">input</code></td>
<td>
<p>One of the following:
</p>

<dl>
<dt>A character vector</dt><dd><p>With taxon names as a single comma separated
starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or
<code>multiPhylo</code> object, OR as a newick character string.</p>
</dd>
<dt>A <code>datelifeQuery</code> object</dt><dd><p>An output from <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="make_bold_otol_tree_+3A_marker">marker</code></td>
<td>
<p>A character vector indicating the gene from BOLD system to be
used for branch length estimation.</p>
</td></tr>
<tr><td><code id="make_bold_otol_tree_+3A_otol_version">otol_version</code></td>
<td>
<p>Version of Open Tree of Life to use</p>
</td></tr>
<tr><td><code id="make_bold_otol_tree_+3A_chronogram">chronogram</code></td>
<td>
<p>Default to <code>TRUE</code>, branch lengths returned are estimated with
<code><a href="ape.html#topic+chronoMPL">ape::chronoMPL()</a></code>. If <code>FALSE</code>, branch lengths returned are estimated with
<code><a href="phangorn.html#topic+parsimony">phangorn::acctran()</a></code> and represent relative substitution rates.</p>
</td></tr>
<tr><td><code id="make_bold_otol_tree_+3A_doml">doML</code></td>
<td>
<p>Default to <code>FALSE</code>. If <code>TRUE</code>, it does a ML branch length optimization
with <code><a href="phangorn.html#topic+pml">phangorn::optim.pml()</a></code>.</p>
</td></tr>
<tr><td><code id="make_bold_otol_tree_+3A_aligner">aligner</code></td>
<td>
<p>A character vector indicating whether to use MAFFT or MUSCLE
to align BOLD sequences. It is not case sensitive. Default to MUSCLE,
supported using the <a href="https://bioconductor.org/packages/release/bioc/html/msa.html">msa</a>
package from Bioconductor, which needs to be installed using <code><a href="BiocManager.html#topic+install">BiocManager::install()</a></code>.</p>
</td></tr>
<tr><td><code id="make_bold_otol_tree_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_otol_synthetic_tree">get_otol_synthetic_tree</a></code>
</p>

<dl>
<dt><code>resolve</code></dt><dd><p>Defaults to <code>TRUE</code>. Whether to resolve the tree at random or not.</p>
</dd>
<dt><code>ott_ids</code></dt><dd><p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>input</code> is a <code>phylo</code> object or a newick string, it is used as backbone topology.
If <code>input</code> is a character vector of taxon names, an induced synthetic OpenTree
subtree is used as backbone.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> object. If there are enough BOLD sequences available for the
<code>input</code> taxon names, the function returns a tree with branch lengths proportional
to relative substitution rate. If not enough BOLD sequences are available
for the <code>input</code> taxon names, the function returns the topology given as
<code>input</code>, or a synthetic Open Tree of Life for the taxon names given in
<code>input</code>, obtained with <code><a href="#topic+get_otol_synthetic_tree">get_otol_synthetic_tree()</a></code>.
</p>

<hr>
<h2 id='make_contributor_cache'>Create a cache from Open Tree of Life</h2><span id='topic+make_contributor_cache'></span>

<h3>Description</h3>

<p>Create a cache from Open Tree of Life
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_contributor_cache(outputfile = "contributorcache.RData")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_contributor_cache_+3A_outputfile">outputfile</code></td>
<td>
<p>Path including file name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing author and curator results
</p>

<hr>
<h2 id='make_datelife_query'>Go from taxon names to a <code>datelifeQuery</code> object</h2><span id='topic+make_datelife_query'></span>

<h3>Description</h3>

<p>Go from taxon names to a <code>datelifeQuery</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_datelife_query(
  input = c("Rhea americana", "Pterocnemia pennata", "Struthio camelus"),
  use_tnrs = TRUE,
  get_spp_from_taxon = FALSE,
  reference_taxonomy = "ott"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_datelife_query_+3A_input">input</code></td>
<td>
<p>Taxon names as one of the following:
</p>

<dl>
<dt>A character vector of taxon names</dt><dd><p>With taxon names as a single comma separated starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or <code>multiPhylo</code>
object, OR as a newick character string.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="make_datelife_query_+3A_use_tnrs">use_tnrs</code></td>
<td>
<p>Whether to use Open Tree of Life's Taxonomic Name Resolution Service (TNRS)
to process input taxon names. Default to <code>TRUE</code>, it corrects misspellings and
taxonomic name variations with <code><a href="#topic+tnrs_match">tnrs_match()</a></code>, a wrapper of <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code>.</p>
</td></tr>
<tr><td><code id="make_datelife_query_+3A_get_spp_from_taxon">get_spp_from_taxon</code></td>
<td>
<p>Whether to search ages for all species belonging to a
given taxon or not. Default to <code>FALSE</code>. If <code>TRUE</code>, it must have same length as input.
If input is a newick string with some clades it will be converted to a <code>phylo</code>
object, and the order of <code>get_spp_from_taxon</code> will match <code>phy$tip.label</code>.</p>
</td></tr>
<tr><td><code id="make_datelife_query_+3A_reference_taxonomy">reference_taxonomy</code></td>
<td>
<p>A character vector specifying the reference taxonomy to use for TNRS.
Options are &quot;ott&quot;, &quot;ncbi&quot;, &quot;gbif&quot; or &quot;irmng&quot;. The function defaults to &quot;ott&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It processes <code>phylo</code> objects and newick character string inputs
with <code><a href="#topic+input_process">input_process()</a></code>. If <code>input</code> is a <code>multiPhylo</code> object, only the first <code>phylo</code>
element will be used. Similarly, if an <code>input</code> newick character string has multiple trees,
only the first one will be used.
</p>


<h3>Value</h3>

<p>A <code>datelifeQuery</code> object, which is a list of three elements:
</p>

<dl>
<dt>$phy</dt><dd><p>A <code>phylo</code> object or <code>NA</code>, if input is not a tree.</p>
</dd>
<dt>$cleaned_names</dt><dd><p>A character vector of cleaned taxon names.</p>
</dd>
<dt>$ott_ids</dt><dd><p>A numeric vector of OTT ids if <code>use_tnrs = TRUE</code>, or <code>NULL</code> if <code>use_tnrs = FALSE</code>.</p>
</dd>
</dl>


<hr>
<h2 id='make_datelife_query2'>Go from taxon names to a <code>datelifeQuery</code> object</h2><span id='topic+make_datelife_query2'></span>

<h3>Description</h3>

<p>Go from taxon names to a <code>datelifeQuery</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_datelife_query2(
  input = c("Rhea americana", "Pterocnemia pennata", "Struthio camelus"),
  get_spp_from_taxon = FALSE,
  reference_taxonomy = "ott",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_datelife_query2_+3A_input">input</code></td>
<td>
<p>Taxon names as one of the following:
</p>

<dl>
<dt>A character vector of taxon names</dt><dd><p>With taxon names as a single comma separated starting or concatenated with <code><a href="base.html#topic+c">c()</a></code>.</p>
</dd>
<dt>A phylogenetic tree with taxon names as tip labels</dt><dd><p>As a <code>phylo</code> or <code>multiPhylo</code>
object, OR as a newick character string.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="make_datelife_query2_+3A_get_spp_from_taxon">get_spp_from_taxon</code></td>
<td>
<p>Whether to search ages for all species belonging to a
given taxon or not. Default to <code>FALSE</code>. If <code>TRUE</code>, it must have same length as input.
If input is a newick string with some clades it will be converted to a <code>phylo</code>
object, and the order of <code>get_spp_from_taxon</code> will match <code>phy$tip.label</code>.</p>
</td></tr>
<tr><td><code id="make_datelife_query2_+3A_reference_taxonomy">reference_taxonomy</code></td>
<td>
<p>A character vector specifying the reference taxonomy to use for TNRS.
Options are &quot;ott&quot;, &quot;ncbi&quot;, &quot;gbif&quot; or &quot;irmng&quot;. The function defaults to &quot;ott&quot;.</p>
</td></tr>
<tr><td><code id="make_datelife_query2_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names</a></code>
</p>

<dl>
<dt><code>context_name</code></dt><dd><p>name of the taxonomic context to be searched (length-one
character vector or <code>NULL</code>). Must match (case sensitive) one of the
values returned by <code><a href="rotl.html#topic+tnrs_contexts">tnrs_contexts</a></code>. Default to &quot;All life&quot;.</p>
</dd>
<dt><code>do_approximate_matching</code></dt><dd><p>A logical indicating whether or not to
perform approximate string (a.k.a. &ldquo;fuzzy&rdquo;) matching. Using
<code>FALSE</code> will greatly improve speed. Default, however, is <code>TRUE</code>.</p>
</dd>
<dt><code>ids</code></dt><dd><p>A vector of ids to use for identifying names. These will be
assigned to each name in the names array. If ids is provided, then ids and
names must be identical in length.</p>
</dd>
<dt><code>include_suppressed</code></dt><dd><p>Ordinarily, some quasi-taxa, such as incertae
sedis buckets and other non-OTUs, are suppressed from TNRS results. If
this parameter is true, these quasi-taxa are allowed as possible TNRS
results.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>It processes <code>phylo</code> objects and newick character string inputs
with <code><a href="#topic+input_process">input_process()</a></code>. If <code>input</code> is a <code>multiPhylo</code> object, only the first <code>phylo</code>
element will be used. Similarly, if an <code>input</code> newick character string has multiple trees,
only the first one will be used.
</p>


<h3>Value</h3>

<p>A <code>datelifeQuery</code> object, which is a list of four elements:
</p>

<dl>
<dt>$input_names</dt><dd><p>A character vector of input taxon names.</p>
</dd>
<dt>$tnrs_names</dt><dd><p>A character vector of taxon names processed with TNRS.</p>
</dd>
<dt>$ott_ids</dt><dd><p>A numeric vector of OTT ids.</p>
</dd>
<dt>$phy</dt><dd><p>A <code>phylo</code> object or <code>NA</code>, if input is not a tree.</p>
</dd>
</dl>


<hr>
<h2 id='make_mrbayes_runfile'>Make a mrBayes run block file with a constraint topology and a set of node
calibrations and missing taxa</h2><span id='topic+make_mrbayes_runfile'></span>

<h3>Description</h3>

<p>Make a mrBayes run block file with a constraint topology and a set of node
calibrations and missing taxa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mrbayes_runfile(
  constraint = NULL,
  taxa = NULL,
  ncalibration = NULL,
  missing_taxa = NULL,
  age_distribution = "fixed",
  root_calibration = FALSE,
  mrbayes_output_file = "mrbayes_run.nexus"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mrbayes_runfile_+3A_constraint">constraint</code></td>
<td>
<p>The constraint tree: a phylo object or a newick character string, with or without branch lengths.</p>
</td></tr>
<tr><td><code id="make_mrbayes_runfile_+3A_taxa">taxa</code></td>
<td>
<p>A character vector with taxon names to be maintained in tree</p>
</td></tr>
<tr><td><code id="make_mrbayes_runfile_+3A_ncalibration">ncalibration</code></td>
<td>
<p>The node calibrations: a phylo object with branch lengths
proportional to time; in this case all nodes from ncalibration will be used
as calibration points. Alternatively, a list with two elements: the first is
a character vector with node names from phy to calibrate; the second is a numeric
vector with the corresponding ages to use as calibrations.</p>
</td></tr>
<tr><td><code id="make_mrbayes_runfile_+3A_missing_taxa">missing_taxa</code></td>
<td>
<p>A tree, a data frame or a vector enlisting all missing taxa you want to include.
</p>

<dl>
<dt>A tree</dt><dd><p>Either as a phylo object or as a newick character string.
It contains all taxa that you want at the end, both missing and non missing.
This tree will be used as a hard constraint.</p>
</dd>
<dt>A <code>data.frame</code></dt><dd><p>It contains two columns named &quot;taxon&quot; and &quot;clade&quot;.
The first one contains a character vector of missing taxon names.
The second one contains a character or numeric vector of nodes from a
constraint tree to which each taxon will be assigned.</p>
</dd>
<dt>A character vector</dt><dd><p>It contains the names of the missing taxa.
They will be added at random to the constraint tree.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="make_mrbayes_runfile_+3A_age_distribution">age_distribution</code></td>
<td>
<p>A character string specifying the type of calibration.
Only &quot;fixed&quot; and &quot;uniform&quot; are implemented for now.
</p>

<dl>
<dt>fixed</dt><dd><p>The age given in ncalibration will be used as fixed age.</p>
</dd>
<dt>lognormal</dt><dd><p>The age given in ncalibration will be used as mean age.
The standard deviation can be provided. # still need to add this option.
By default, a 95 CI sd is used.</p>
</dd>
<dt>uniform</dt><dd><p>The age given in ncalibration will be used as mean age.
Where min_age = 0.9 * mean age, and max_age = 1.1 * mean age.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="make_mrbayes_runfile_+3A_root_calibration">root_calibration</code></td>
<td>
<p>Used to set a calibration at the root or not. Default
to FALSE. Only relevant if ncalibration is specified.</p>
</td></tr>
<tr><td><code id="make_mrbayes_runfile_+3A_mrbayes_output_file">mrbayes_output_file</code></td>
<td>
<p>A character vector specifying the name of mrBayes run file and outputs (can specify directory too).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MrBayes block run file in nexus format.
</p>

<hr>
<h2 id='make_mrbayes_tree'>Take a constraint tree and use mrBayes to get node ages and branch lengths
given a set of node calibrations without any data.</h2><span id='topic+make_mrbayes_tree'></span>

<h3>Description</h3>

<p>Take a constraint tree and use mrBayes to get node ages and branch lengths
given a set of node calibrations without any data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mrbayes_tree(
  constraint = NULL,
  taxa = NULL,
  ncalibration = NULL,
  missing_taxa = NULL,
  age_distribution = "fixed",
  root_calibration = FALSE,
  mrbayes_output_file = "mrbayes_run.nexus"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mrbayes_tree_+3A_constraint">constraint</code></td>
<td>
<p>The constraint tree: a phylo object or a newick character string, with or without branch lengths.</p>
</td></tr>
<tr><td><code id="make_mrbayes_tree_+3A_taxa">taxa</code></td>
<td>
<p>A character vector with taxon names to be maintained in tree</p>
</td></tr>
<tr><td><code id="make_mrbayes_tree_+3A_ncalibration">ncalibration</code></td>
<td>
<p>The node calibrations: a phylo object with branch lengths
proportional to time; in this case all nodes from ncalibration will be used
as calibration points. Alternatively, a list with two elements: the first is
a character vector with node names from phy to calibrate; the second is a numeric
vector with the corresponding ages to use as calibrations.</p>
</td></tr>
<tr><td><code id="make_mrbayes_tree_+3A_missing_taxa">missing_taxa</code></td>
<td>
<p>A tree, a data frame or a vector enlisting all missing taxa you want to include.
</p>

<dl>
<dt>A tree</dt><dd><p>Either as a phylo object or as a newick character string.
It contains all taxa that you want at the end, both missing and non missing.
This tree will be used as a hard constraint.</p>
</dd>
<dt>A <code>data.frame</code></dt><dd><p>It contains two columns named &quot;taxon&quot; and &quot;clade&quot;.
The first one contains a character vector of missing taxon names.
The second one contains a character or numeric vector of nodes from a
constraint tree to which each taxon will be assigned.</p>
</dd>
<dt>A character vector</dt><dd><p>It contains the names of the missing taxa.
They will be added at random to the constraint tree.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="make_mrbayes_tree_+3A_age_distribution">age_distribution</code></td>
<td>
<p>A character string specifying the type of calibration.
Only &quot;fixed&quot; and &quot;uniform&quot; are implemented for now.
</p>

<dl>
<dt>fixed</dt><dd><p>The age given in ncalibration will be used as fixed age.</p>
</dd>
<dt>lognormal</dt><dd><p>The age given in ncalibration will be used as mean age.
The standard deviation can be provided. # still need to add this option.
By default, a 95 CI sd is used.</p>
</dd>
<dt>uniform</dt><dd><p>The age given in ncalibration will be used as mean age.
Where min_age = 0.9 * mean age, and max_age = 1.1 * mean age.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="make_mrbayes_tree_+3A_root_calibration">root_calibration</code></td>
<td>
<p>Used to set a calibration at the root or not. Default
to FALSE. Only relevant if ncalibration is specified.</p>
</td></tr>
<tr><td><code id="make_mrbayes_tree_+3A_mrbayes_output_file">mrbayes_output_file</code></td>
<td>
<p>A character vector specifying the name of mrBayes run file and outputs (can specify directory too).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object with branch lengths proportional to time. It saves all
mrBayes outputs in the working directory.
</p>

<hr>
<h2 id='make_otol_associations'>Associate Open Tree of Life authors with studies</h2><span id='topic+make_otol_associations'></span>

<h3>Description</h3>

<p>Associate Open Tree of Life authors with studies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_otol_associations()
</code></pre>


<h3>Value</h3>

<p><code>data.frame</code> with author last name, author first and other names, and comma delimited URLs for OToL studies
</p>

<hr>
<h2 id='make_overlap_table'>Create an overlap table</h2><span id='topic+make_overlap_table'></span>

<h3>Description</h3>

<p>Create an overlap table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_overlap_table(results_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_overlap_table_+3A_results_table">results_table</code></td>
<td>
<p>An &quot;author.results&quot; or &quot;curator.results&quot; <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with information on curators and what clades they've worked on
</p>

<hr>
<h2 id='make_sdm'>Make a Super Distance Matrix (SDM) from a list of good matrices obtained with <code><a href="#topic+get_goodmatrices">get_goodmatrices()</a></code></h2><span id='topic+make_sdm'></span>

<h3>Description</h3>

<p>Make a Super Distance Matrix (SDM) from a list of good matrices obtained with <code><a href="#topic+get_goodmatrices">get_goodmatrices()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sdm(unpadded.matrices, weighting = "flat")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_sdm_+3A_unpadded.matrices">unpadded.matrices</code></td>
<td>
<p>A list of patristic matrices, a <code>datelifeResult</code> object.</p>
</td></tr>
<tr><td><code id="make_sdm_+3A_weighting">weighting</code></td>
<td>
<p>A character vector indicating how much weight to give to each
tree in <code>input</code> during the SDM analysis. Options are:
</p>

<dl>
<dt>weighting = &quot;flat&quot;</dt><dd><p>All trees have equal weighting.</p>
</dd>
<dt>weighting = &quot;taxa&quot;</dt><dd><p>Weight is proportional to number of taxa.</p>
</dd>
<dt>weighting = &quot;inverse&quot;</dt><dd><p>Weight is proportional to 1 / number of taxa.</p>
</dd>
</dl>

<p>Defaults to <code>weighting = "flat"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='make_treebase_associations'>Associate TreeBase authors with studies</h2><span id='topic+make_treebase_associations'></span>

<h3>Description</h3>

<p>Associate TreeBase authors with studies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_treebase_associations()
</code></pre>


<h3>Value</h3>

<p><code>data.frame</code> with author last name, author first and other names, and comma delimited URLs for TreeBase studies
</p>

<hr>
<h2 id='make_treebase_cache'>Create a cache from TreeBase</h2><span id='topic+make_treebase_cache'></span>

<h3>Description</h3>

<p>Create a cache from TreeBase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_treebase_cache(outputfile = "treebasecache.RData")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_treebase_cache_+3A_outputfile">outputfile</code></td>
<td>
<p>Path including file name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing author and curator results
</p>

<hr>
<h2 id='map_nodes_ott'>Add Open Tree of Life Taxonomy to tree nodes.</h2><span id='topic+map_nodes_ott'></span>

<h3>Description</h3>

<p>Add Open Tree of Life Taxonomy to tree nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_nodes_ott(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_nodes_ott_+3A_tree">tree</code></td>
<td>
<p>A tree either as a newick character string or as a <code>phylo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object with &quot;nodelabels&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # This is a flag for package development. You are welcome to run the example.

# Load the Open Tree chronograms database cached in datelife:
utils::data(opentree_chronograms)

# Get the small chronograms (i.e., chronograms with less that ten tips) to generate a pretty plot:
small &lt;- opentree_chronograms$trees[unlist(sapply(opentree_chronograms$trees, ape::Ntip)) &lt; 10]

# Now, map the Open Tree taxonomy to the nodes of the first tree
phy &lt;- map_nodes_ott(tree = small[[1]])
# and plot it:
# plot_phylo_all(phy)
library(ape)
plot(phy)
nodelabels(phy$node.label)


## End(Not run) #end dontrun
</code></pre>

<hr>
<h2 id='match_all_calibrations'>Match calibrations to nodes of a given tree</h2><span id='topic+match_all_calibrations'></span>

<h3>Description</h3>

<p><code>match_all_calibrations</code> searches a given tree for the most recent common
ancestor (mrca) of all taxon name pairs in a <code>datelifeCalibration</code>. It uses <code><a href="phytools.html#topic+findMRCA">phytools::findMRCA()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_all_calibrations(phy, calibrations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_all_calibrations_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="match_all_calibrations_+3A_calibrations">calibrations</code></td>
<td>
<p>A <code>calibrations</code> object, an output of
<code><a href="#topic+extract_calibrations_phylo">extract_calibrations_phylo()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes pairs of taxon names in a secondary calibrations data frame,
and looks for them in the vector of tip labels of the tree. If both are present,
then it gets the node that represents the most recent
common ancestor (mrca) for that pair of taxa in the tree.
Nodes of input <code>phy</code> can be named or not.
</p>


<h3>Value</h3>

<p>A list of two elements:
</p>

<dl>
<dt>phy</dt><dd><p>A <code>phylo</code> object with nodes renamed with <code><a href="#topic+tree_add_nodelabels">tree_add_nodelabels()</a></code>.</p>
</dd>
<dt>matched_calibrations</dt><dd><p>A <code>matchedCalibrations</code> object, which is the input <code>calibrations</code>
object with two additional columns storing results from the mrca search with
<code><a href="phytools.html#topic+findMRCA">phytools::findMRCA()</a></code>: <code style="white-space: pre;">&#8288;$mrca_node_number&#8288;</code> and <code style="white-space: pre;">&#8288;$mrca_node_name&#8288;</code>.</p>
</dd>
</dl>


<hr>
<h2 id='matrices_to_table'>Go from a list of patristic distance matrix to a table of node ages</h2><span id='topic+matrices_to_table'></span>

<h3>Description</h3>

<p>Go from a list of patristic distance matrix to a table of node ages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrices_to_table(matrices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrices_to_table_+3A_matrices">matrices</code></td>
<td>
<p>A names list of patristic distance matrices. Names correspond to the study reference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>data.frame</code> of &quot;taxonA&quot;, &quot;taxonB&quot;, and &quot;age&quot;.
</p>

<hr>
<h2 id='matrix_to_table'>Go from a patristic distance matrix to a node ages table</h2><span id='topic+matrix_to_table'></span>

<h3>Description</h3>

<p>Go from a patristic distance matrix to a node ages table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_table(matrix, reference)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_to_table_+3A_matrix">matrix</code></td>
<td>
<p>A patristic distance matrix.</p>
</td></tr>
<tr><td><code id="matrix_to_table_+3A_reference">reference</code></td>
<td>
<p>A character vector with the study reference from where the ages come from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of &quot;taxonA&quot;, &quot;taxonB&quot;, and &quot;age&quot;.
</p>

<hr>
<h2 id='message_multiphylo'>Message for a <code>multiPhylo</code> input</h2><span id='topic+message_multiphylo'></span>

<h3>Description</h3>

<p>Message for a <code>multiPhylo</code> input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>message_multiphylo()
</code></pre>


<h3>Value</h3>

<p>A relevant message as a character string.
</p>

<hr>
<h2 id='missing_taxa_check'>Checks that missing_taxa argument is ok to be used by make_mrbayes_runfile inside tree_add_dates functions.</h2><span id='topic+missing_taxa_check'></span>

<h3>Description</h3>

<p>Checks that missing_taxa argument is ok to be used by make_mrbayes_runfile inside tree_add_dates functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_taxa_check(missing_taxa = NULL, dated_tree = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_taxa_check_+3A_missing_taxa">missing_taxa</code></td>
<td>
<p>A tree, a data frame or a vector enlisting all missing taxa you want to include.
</p>

<dl>
<dt>A tree</dt><dd><p>Either as a phylo object or as a newick character string.
It contains all taxa that you want at the end, both missing and non missing.
This tree will be used as a hard constraint.</p>
</dd>
<dt>A <code>data.frame</code></dt><dd><p>It contains two columns named &quot;taxon&quot; and &quot;clade&quot;.
The first one contains a character vector of missing taxon names.
The second one contains a character or numeric vector of nodes from a
constraint tree to which each taxon will be assigned.</p>
</dd>
<dt>A character vector</dt><dd><p>It contains the names of the missing taxa.
They will be added at random to the constraint tree.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="missing_taxa_check_+3A_dated_tree">dated_tree</code></td>
<td>
<p>a tree (newick or phylo) with branch lengths proportional to absolute time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phylo object, a newick character string or a dataframe with taxonomic assignations
</p>

<hr>
<h2 id='mrca_calibrations'>Identify nodes of a tree topology that are most recent common ancestor (mrca)
of taxon pairs from a <code>calibrations</code> object</h2><span id='topic+mrca_calibrations'></span>

<h3>Description</h3>

<p><code>mrca_calibrations</code> get nodes of a tree topology given in
<code>phy</code> that correspond to the most recent common ancestor (mrca) of taxon
pairs given in <code>calibrations</code>. It uses <code><a href="phytools.html#topic+findMRCA">phytools::findMRCA()</a></code> to get mrca nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrca_calibrations(phy, calibrations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrca_calibrations_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="mrca_calibrations_+3A_calibrations">calibrations</code></td>
<td>
<p>A <code>calibrations</code> object, an output of
<code><a href="#topic+extract_calibrations_phylo">extract_calibrations_phylo()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes pairs of taxon names in a calibrations data frame,
and looks for them in the vector of tip labels of the tree. If both are present,
then it gets the node that represents the most recent
common ancestor (mrca) for that pair of taxa in the tree.
Nodes of input <code>phy</code> can be named or not. They will be renamed.
</p>


<h3>Value</h3>

<p>A list of two elements:
</p>

<dl>
<dt>matched_phy</dt><dd><p>A <code>phylo</code> object with nodes renamed to match results of
the mrca search. Nodes are renamed using <code><a href="#topic+tree_add_nodelabels">tree_add_nodelabels()</a></code>.</p>
</dd>
<dt>matched_calibrations</dt><dd><p>A <code>matchedCalibrations</code> object, which is the input <code>calibrations</code>
object with two additional columns storing results from the mrca search with
<code><a href="phytools.html#topic+findMRCA">phytools::findMRCA()</a></code>: <code style="white-space: pre;">&#8288;$mrca_node_number&#8288;</code> and <code style="white-space: pre;">&#8288;$mrca_node_name&#8288;</code>.</p>
</dd>
</dl>


<hr>
<h2 id='opentree_chronograms'>Chronogram database</h2><span id='topic+opentree_chronograms'></span>

<h3>Description</h3>

<p>Now storing &gt;200 chronograms from Open Tree of Life
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opentree_chronograms
</code></pre>


<h3>Format</h3>

<p>A list of four elements, containing data from Open Tree of Life chronograms
</p>

<dl>
<dt>authors</dt><dd><p>A list of lists of author names of the original studies that
published chronograms in the Open Tree of Life database.</p>
</dd>
<dt>curators</dt><dd><p>A list of lists of curator names that uploaded chronograms
to the Open Tree of Life database.</p>
</dd>
<dt>studies</dt><dd><p>A list of study identifiers.</p>
</dd>
<dt>trees</dt><dd><p>A <code>multiPhylo</code> object storing the chronograms from Open Tree of
Life database.</p>
</dd>
<dt>update</dt><dd><p>A character vector indicating the time when the database object
was last updated.</p>
</dd>
<dt>version</dt><dd><p>A character vector indicating the datelife <code><a href="utils.html#topic+packageDescription">utils::packageVersion()</a></code>
when the database was last updated.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Generated with
devtools::install_github(&quot;ropensci/rotl&quot;, ref = devtools::github_pull(&quot;137&quot;))
remotes::install_github(&quot;ROpenSci/bibtex&quot;)'
opentree_chronograms &lt;- get_opentree_chronograms()
opentree_chronograms$update &lt;- Sys.time()
opentree_chronograms$version &lt;- '2022.01.28'
usethis::use_data(opentree_chronograms, overwrite = T, compress = &quot;xz&quot;)
and updated with update_datelife_cache()
</p>


<h3>Source</h3>

<p><a href="http://opentreeoflife.org">http://opentreeoflife.org</a>
</p>

<hr>
<h2 id='patristic_matrix_array_congruify'><code>patristic_matrix_array_congruify</code> is used for patristic_matrix_array_subset_both and patristic_matrix_array_congruify.</h2><span id='topic+patristic_matrix_array_congruify'></span>

<h3>Description</h3>

<p><code>patristic_matrix_array_congruify</code> is used for patristic_matrix_array_subset_both and patristic_matrix_array_congruify.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_array_congruify(
  patristic_matrix_array,
  taxa,
  phy = NULL,
  dating_method = "PATHd8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_array_congruify_+3A_patristic_matrix_array">patristic_matrix_array</code></td>
<td>
<p>A patristic matrix array, <code>rownames</code> and <code>colnames</code> must be taxa.</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_congruify_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_congruify_+3A_phy">phy</code></td>
<td>
<p>A user tree to congruify as <code>phylo</code> object (ape).</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_congruify_+3A_dating_method">dating_method</code></td>
<td>
<p>The method used for tree dating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A patristic matrix with ages for the target taxa.
</p>

<hr>
<h2 id='patristic_matrix_array_phylo_congruify'>Congruify a patristic matrix array from a given <code>phylo</code> object.</h2><span id='topic+patristic_matrix_array_phylo_congruify'></span>

<h3>Description</h3>

<p>Congruify a patristic matrix array from a given <code>phylo</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_array_phylo_congruify(
  patristic_matrix,
  target_tree,
  dating_method = "PATHd8",
  attempt_fix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_array_phylo_congruify_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix, <code>rownames</code> and <code>colnames</code> must be taxa.</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_phylo_congruify_+3A_target_tree">target_tree</code></td>
<td>
<p>A <code>phylo</code> object. Use this in case you want a specific
backbone for the output tree.</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_phylo_congruify_+3A_dating_method">dating_method</code></td>
<td>
<p>The method used for tree dating.</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_phylo_congruify_+3A_attempt_fix">attempt_fix</code></td>
<td>
<p>Default to <code>TRUE</code>. If congruification results in NA branch
lengths, it will attempt to fix them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='patristic_matrix_array_split'>Split a patristic matrix array
Used inside: patristic_matrix_array_congruify</h2><span id='topic+patristic_matrix_array_split'></span>

<h3>Description</h3>

<p>Split a patristic matrix array
Used inside: patristic_matrix_array_congruify
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_array_split(patristic_matrix_array)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_array_split_+3A_patristic_matrix_array">patristic_matrix_array</code></td>
<td>
<p>A patristic matrix array, <code>rownames</code> and <code>colnames</code> must be taxa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A patristic matrix 3d array.
</p>

<hr>
<h2 id='patristic_matrix_array_subset'>Subset a patristic matrix array</h2><span id='topic+patristic_matrix_array_subset'></span>

<h3>Description</h3>

<p>Subset a patristic matrix array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_array_subset(patristic_matrix_array, taxa, phy4 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_array_subset_+3A_patristic_matrix_array">patristic_matrix_array</code></td>
<td>
<p>A patristic matrix array, <code>rownames</code> and <code>colnames</code> must be taxa.</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_subset_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_subset_+3A_phy4">phy4</code></td>
<td>
<p>A user tree to congruify in <code>phylo4</code> format (phylobase).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a patristic matrix array and a <code style="white-space: pre;">&#8288;$problem&#8288;</code> if any.
</p>

<hr>
<h2 id='patristic_matrix_array_subset_both'>Are all desired taxa in the patristic matrix array?</h2><span id='topic+patristic_matrix_array_subset_both'></span>

<h3>Description</h3>

<p><code>patristic_matrix_array_subset_both</code> is used inside <code><a href="#topic+get_subset_array_dispatch">get_subset_array_dispatch()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_array_subset_both(
  patristic_matrix_array,
  taxa,
  phy = NULL,
  phy4 = NULL,
  dating_method = "PATHd8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_array_subset_both_+3A_patristic_matrix_array">patristic_matrix_array</code></td>
<td>
<p>A patristic matrix array, <code>rownames</code> and <code>colnames</code> must be taxa.</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_subset_both_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_subset_both_+3A_phy">phy</code></td>
<td>
<p>A user tree to congruify as <code>phylo</code> object (ape).</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_subset_both_+3A_phy4">phy4</code></td>
<td>
<p>A user tree to congruify in <code>phylo4</code> format (phylobase).</p>
</td></tr>
<tr><td><code id="patristic_matrix_array_subset_both_+3A_dating_method">dating_method</code></td>
<td>
<p>The method used for tree dating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A patristic matrix with ages for the target taxa.
</p>

<hr>
<h2 id='patristic_matrix_list_to_array'>Convert list of patristic matrices to a 3D array.</h2><span id='topic+patristic_matrix_list_to_array'></span>

<h3>Description</h3>

<p><code>patristic_matrix_list_to_array</code> us ised inside <code><a href="#topic+summarize_datelife_result">summarize_datelife_result()</a></code>, <code><a href="#topic+patristic_matrix_array_congruify">patristic_matrix_array_congruify()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_list_to_array(patristic_matrix_list, pad = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_list_to_array_+3A_patristic_matrix_list">patristic_matrix_list</code></td>
<td>
<p>List of patristic matrices</p>
</td></tr>
<tr><td><code id="patristic_matrix_list_to_array_+3A_pad">pad</code></td>
<td>
<p>If TRUE, pad missing entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3d array of patristic matrices
</p>

<hr>
<h2 id='patristic_matrix_MRCA'>Get time of MRCA from patristic matrix. Used in <code><a href="#topic+datelife_result_MRCA">datelife_result_MRCA()</a></code>.</h2><span id='topic+patristic_matrix_MRCA'></span>

<h3>Description</h3>

<p>Get time of MRCA from patristic matrix. Used in <code><a href="#topic+datelife_result_MRCA">datelife_result_MRCA()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_MRCA(patristic_matrix, na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_MRCA_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix (aka a <code>datelifeResult</code> object of length 1)</p>
</td></tr>
<tr><td><code id="patristic_matrix_MRCA_+3A_na_rm">na_rm</code></td>
<td>
<p>If <code>TRUE</code>, it drops rows containing <code>NA</code>s from the <code>datelifeResult</code>
patristic matrix; if <code>FALSE</code>, it returns <code>NA</code> where there are missing entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The depth of the MRCA as a numeric vector.
</p>

<hr>
<h2 id='patristic_matrix_name_order_test'>Test the name order of a patristic matrix so that row and column labels are in alphabetical order.</h2><span id='topic+patristic_matrix_name_order_test'></span>

<h3>Description</h3>

<p><code>patristic_matrix_name_order_test</code> is only used in <code><a href="#topic+patristic_matrix_list_to_array">patristic_matrix_list_to_array()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_name_order_test(
  patristic_matrix,
  standard.rownames,
  standard.colnames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_name_order_test_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix, <code>rownames</code> and <code>colnames</code> must be taxa.</p>
</td></tr>
<tr><td><code id="patristic_matrix_name_order_test_+3A_standard.rownames">standard.rownames</code></td>
<td>
<p>A character vector of row names.</p>
</td></tr>
<tr><td><code id="patristic_matrix_name_order_test_+3A_standard.colnames">standard.colnames</code></td>
<td>
<p>A character vector of column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean.
</p>

<hr>
<h2 id='patristic_matrix_name_reorder'>Reorder a matrix so that row and column labels are in alphabetical order.</h2><span id='topic+patristic_matrix_name_reorder'></span>

<h3>Description</h3>

<p><code>patristic_matrix_name_reorder</code> is only used in: <code><a href="#topic+patristic_matrix_pad">patristic_matrix_pad()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_name_reorder(patristic_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_name_reorder_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix, <code>rownames</code> and <code>colnames</code> must be taxa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A patristic matrix with row and column names for taxa in alphabetical order.
</p>

<hr>
<h2 id='patristic_matrix_pad'>Fill in empty cells in a patristic matrix for missing taxa.</h2><span id='topic+patristic_matrix_pad'></span>

<h3>Description</h3>

<p>Used in: <code><a href="#topic+patristic_matrix_list_to_array">patristic_matrix_list_to_array()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_pad(patristic_matrix, all_taxa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_pad_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix, <code>rownames</code> and <code>colnames</code> must be taxa.</p>
</td></tr>
<tr><td><code id="patristic_matrix_pad_+3A_all_taxa">all_taxa</code></td>
<td>
<p>A vector of names of all taxa you want, including ones not
in the patristic matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A patristic matrix, with <code>NA</code> for entries between taxa
where at least one was not in the original patristic matrix.
</p>

<hr>
<h2 id='patristic_matrix_taxa_all_matching'>Are all desired taxa in the patristic matrix?</h2><span id='topic+patristic_matrix_taxa_all_matching'></span>

<h3>Description</h3>

<p><code>patristic_matrix_taxa_all_matching</code> is used inside: <code><a href="#topic+results_list_process">results_list_process()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_taxa_all_matching(patristic_matrix, taxa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_taxa_all_matching_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix, <code>rownames</code> and <code>colnames</code> must be taxa.</p>
</td></tr>
<tr><td><code id="patristic_matrix_taxa_all_matching_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Boolean.
</p>

<hr>
<h2 id='patristic_matrix_to_newick'>Convert patristic matrix to a newick string. Used inside: summarize_datelife_result.</h2><span id='topic+patristic_matrix_to_newick'></span>

<h3>Description</h3>

<p>Convert patristic matrix to a newick string. Used inside: summarize_datelife_result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_to_newick(patristic_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_to_newick_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A newick string
</p>

<hr>
<h2 id='patristic_matrix_to_phylo'>Convert a patristic matrix to a <code>phylo</code> object.</h2><span id='topic+patristic_matrix_to_phylo'></span>

<h3>Description</h3>

<p>Function <code>patristic_matrix_to_phylo</code> is used inside <code><a href="#topic+summarize_datelife_result">summarize_datelife_result()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_to_phylo(
  patristic_matrix,
  clustering_method = "nj",
  fix_negative_brlen = TRUE,
  fixing_method = 0,
  ultrametric = TRUE,
  variance_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_to_phylo_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix</p>
</td></tr>
<tr><td><code id="patristic_matrix_to_phylo_+3A_clustering_method">clustering_method</code></td>
<td>
<p>A character vector indicating the method to construct
the tree. Options are:
</p>

<dl>
<dt>nj</dt><dd><p>Neighbor-Joining method applied with <code><a href="ape.html#topic+nj">ape::nj()</a></code>.</p>
</dd>
<dt>upgma</dt><dd><p>Unweighted Pair Group Method with Arithmetic Mean method applied
with <code><a href="phangorn.html#topic+upgma">phangorn::upgma()</a></code>.</p>
</dd>
<dt>bionj</dt><dd><p>An improved version of the Neighbor-Joining method applied with
<code><a href="ape.html#topic+bionj">ape::bionj()</a></code>.</p>
</dd>
<dt>triangle</dt><dd><p>Triangles method applied with <code><a href="ape.html#topic+triangMtd">ape::triangMtd()</a></code></p>
</dd>
<dt>mvr</dt><dd><p>Minimum Variance Reduction method applied with <code><a href="ape.html#topic+mvr">ape::mvr()</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="patristic_matrix_to_phylo_+3A_fix_negative_brlen">fix_negative_brlen</code></td>
<td>
<p>Boolean indicating whether to fix negative branch
lengths in resulting tree or not. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="patristic_matrix_to_phylo_+3A_fixing_method">fixing_method</code></td>
<td>
<p>A character vector specifying the method to fix branch lengths: &quot;bladj&quot;, &quot;mrbayes&quot; or a number to be assigned to all branches meeting fixing_criterion</p>
</td></tr>
<tr><td><code id="patristic_matrix_to_phylo_+3A_ultrametric">ultrametric</code></td>
<td>
<p>Boolean indicating whether to force ultrametric or not.</p>
</td></tr>
<tr><td><code id="patristic_matrix_to_phylo_+3A_variance_matrix">variance_matrix</code></td>
<td>
<p>A variance matrix from a <code>datelifeResult</code> object,
usually an output from <code><a href="#topic+datelife_result_variance_matrix">datelife_result_variance_matrix()</a></code>.
Only used if <code>clustering_method = "mvr"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We might add the option to insert a function as <code>clustering_method</code> in the future.
Before, we had hard-coded the function to try Neighbor-Joining (NJ) first; if it
errors, it will try UPGMA.
Now, it uses NJ for a &quot;phylo_all&quot; summary, and we are using our own algorithm to
get a tree from a summary matrix.
</p>


<h3>Value</h3>

<p>A rooted <code>phylo</code> object.
</p>

<hr>
<h2 id='patristic_matrix_unpad'>Function to remove missing taxa from a <code>datelifeResult</code> object.</h2><span id='topic+patristic_matrix_unpad'></span>

<h3>Description</h3>

<p>Used in <code><a href="#topic+datelife_result_sdm_phylo">datelife_result_sdm_phylo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patristic_matrix_unpad(patristic_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patristic_matrix_unpad_+3A_patristic_matrix">patristic_matrix</code></td>
<td>
<p>A patristic matrix with row and column names for taxa</p>
</td></tr>
</table>


<h3>Value</h3>

<p>patristic_matrix for all_taxa
</p>

<hr>
<h2 id='phylo_check'>Checks if <code>phy</code> is a <code>phylo</code> object and/or a chronogram.</h2><span id='topic+phylo_check'></span>

<h3>Description</h3>

<p>Checks if <code>phy</code> is a <code>phylo</code> object and/or a chronogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_check(phy = NULL, brlen = FALSE, dated = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_check_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="phylo_check_+3A_brlen">brlen</code></td>
<td>
<p>Boolean. If <code>TRUE</code> it checks if <code>phylo</code> object has branch lengths.</p>
</td></tr>
<tr><td><code id="phylo_check_+3A_dated">dated</code></td>
<td>
<p>Boolean. If <code>TRUE</code> it checks if <code>phylo</code> object is ultrametric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='phylo_congruify'>Congruify a reference tree and a target tree given as <code>phylo</code> objects.</h2><span id='topic+phylo_congruify'></span>

<h3>Description</h3>

<p>Congruify a reference tree and a target tree given as <code>phylo</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_congruify(
  reference_tree,
  target_tree,
  dating_method = "PATHd8",
  attempt_fix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_congruify_+3A_reference_tree">reference_tree</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="phylo_congruify_+3A_target_tree">target_tree</code></td>
<td>
<p>A <code>phylo</code> object. Use this in case you want a specific
backbone for the output tree.</p>
</td></tr>
<tr><td><code id="phylo_congruify_+3A_dating_method">dating_method</code></td>
<td>
<p>The method used for tree dating.</p>
</td></tr>
<tr><td><code id="phylo_congruify_+3A_attempt_fix">attempt_fix</code></td>
<td>
<p>Default to <code>TRUE</code>. If congruification results in NA branch
lengths, it will attempt to fix them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='phylo_generate_uncertainty'>Generate uncertainty in branch lengths using a lognormal.</h2><span id='topic+phylo_generate_uncertainty'></span>

<h3>Description</h3>

<p>Generate uncertainty in branch lengths using a lognormal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_generate_uncertainty(
  phy,
  size = 100,
  uncertainty_method = "other",
  age_distribution = "uniform",
  age_sd = NULL,
  age_var = 0.1,
  age_scale = 0,
  alpha = 0.025,
  rescale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_generate_uncertainty_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="phylo_generate_uncertainty_+3A_size">size</code></td>
<td>
<p>A numeric vector indicating the number of samples to be generated.</p>
</td></tr>
<tr><td><code id="phylo_generate_uncertainty_+3A_uncertainty_method">uncertainty_method</code></td>
<td>
<p>A character vector specifying the method to generate uncertainty. mrbayes is default.</p>
</td></tr>
<tr><td><code id="phylo_generate_uncertainty_+3A_age_distribution">age_distribution</code></td>
<td>
<p>A character string specifying the type of calibration.
Only &quot;fixed&quot; and &quot;uniform&quot; are implemented for now.
</p>

<dl>
<dt>fixed</dt><dd><p>The age given in ncalibration will be used as fixed age.</p>
</dd>
<dt>lognormal</dt><dd><p>The age given in ncalibration will be used as mean age.
The standard deviation can be provided. # still need to add this option.
By default, a 95 CI sd is used.</p>
</dd>
<dt>uniform</dt><dd><p>The age given in ncalibration will be used as mean age.
Where min_age = 0.9 * mean age, and max_age = 1.1 * mean age.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="phylo_generate_uncertainty_+3A_age_sd">age_sd</code></td>
<td>
<p>The standard deviation around the age to use for generating the uncertainty. If not a numeric value, var will be used to calculate it.</p>
</td></tr>
<tr><td><code id="phylo_generate_uncertainty_+3A_age_var">age_var</code></td>
<td>
<p>The variance to calculate age_sd and generate uncertainty.</p>
</td></tr>
<tr><td><code id="phylo_generate_uncertainty_+3A_age_scale">age_scale</code></td>
<td>
<p>How to scale sd by the depth of the node. If 0, same sd for all. If not, older nodes have more uncertainty</p>
</td></tr>
<tr><td><code id="phylo_generate_uncertainty_+3A_alpha">alpha</code></td>
<td>
<p>The significance level on uncertainty to generate. By default 0.025</p>
</td></tr>
<tr><td><code id="phylo_generate_uncertainty_+3A_rescale">rescale</code></td>
<td>
<p>Boolean. If true, observed age will be rescaled each round.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you want to change the size of sampled trees you do not need to run mrbayes again.
Just use sample_trees(&quot;mrbayes_trees_file_directory&quot;, size = new_size) and you will get a multiPhylo object with a new tree sample.
</p>


<h3>Value</h3>

<p>A phylo or multiPhylo object with the same topology as phy but different branch lengths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate uncertainty over feline species SDM chronogram.
# Load the data:

data(felid_sdm)

# By default, generates a sample of 100 trees with var = 0.1:

unc &lt;- phylo_generate_uncertainty(felid_sdm$phy)
length(unc)

# Make an LTT plot:

max_age &lt;- max(sapply(unc, ape::branching.times))
ape::ltt.plot(phy = unc[[1]], xlim = c(-max_age, 0), col = "#cce5ff50")
for (i in 2:100) {
  ape::ltt.lines(phy = unc[[i]], col = "#cce5ff50")
}
ape::ltt.lines(felid_sdm$phy, col = "red")
title(c("fake uncertainty", "in Felidae SDM chronogram"))

## End(Not run) # end dontrun
</code></pre>

<hr>
<h2 id='phylo_get_node_numbers'>Gets node numbers from any phylogeny</h2><span id='topic+phylo_get_node_numbers'></span>

<h3>Description</h3>

<p>Gets node numbers from any phylogeny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_get_node_numbers(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_get_node_numbers_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with node numbers
</p>

<hr>
<h2 id='phylo_get_subset_array'>Get a subset array from a <code>phylo</code> object</h2><span id='topic+phylo_get_subset_array'></span>

<h3>Description</h3>

<p>Get a subset array from a <code>phylo</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_get_subset_array(
  reference_tree,
  taxa,
  phy4 = NULL,
  dating_method = "PATHd8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_get_subset_array_+3A_reference_tree">reference_tree</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="phylo_get_subset_array_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
<tr><td><code id="phylo_get_subset_array_+3A_phy4">phy4</code></td>
<td>
<p>A user tree to congruify in <code>phylo4</code> format (phylobase).</p>
</td></tr>
<tr><td><code id="phylo_get_subset_array_+3A_dating_method">dating_method</code></td>
<td>
<p>The method used for tree dating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a patristic matrix array and a <code style="white-space: pre;">&#8288;$problem&#8288;</code> if any.
</p>

<hr>
<h2 id='phylo_get_subset_array_congruify'>Get a congruified subset array from a <code>phylo</code> object</h2><span id='topic+phylo_get_subset_array_congruify'></span>

<h3>Description</h3>

<p>Get a congruified subset array from a <code>phylo</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_get_subset_array_congruify(
  reference_tree,
  taxa,
  phy = NULL,
  dating_method = "PATHd8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_get_subset_array_congruify_+3A_reference_tree">reference_tree</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="phylo_get_subset_array_congruify_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
<tr><td><code id="phylo_get_subset_array_congruify_+3A_phy">phy</code></td>
<td>
<p>A user tree to congruify as <code>phylo</code> object (ape).</p>
</td></tr>
<tr><td><code id="phylo_get_subset_array_congruify_+3A_dating_method">dating_method</code></td>
<td>
<p>The method used for tree dating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a patristic matrix array and a <code style="white-space: pre;">&#8288;$problem&#8288;</code> if any.
</p>

<hr>
<h2 id='phylo_has_brlen'>Check if a tree has branch lengths</h2><span id='topic+phylo_has_brlen'></span>

<h3>Description</h3>

<p>Check if a tree has branch lengths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_has_brlen(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_has_brlen_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A TRUE or FALSE
</p>

<hr>
<h2 id='phylo_prune_missing_taxa'>Prune missing taxa from a <code>phylo</code> object
Used inside phylo_get_subset_array and phylo_get_subset_array_congruify.</h2><span id='topic+phylo_prune_missing_taxa'></span>

<h3>Description</h3>

<p>Prune missing taxa from a <code>phylo</code> object
Used inside phylo_get_subset_array and phylo_get_subset_array_congruify.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_prune_missing_taxa(phy, taxa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_prune_missing_taxa_+3A_phy">phy</code></td>
<td>
<p>A user tree to congruify as <code>phylo</code> object (ape).</p>
</td></tr>
<tr><td><code id="phylo_prune_missing_taxa_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object.
</p>

<hr>
<h2 id='phylo_subset_both'>Subset a reference and a target tree given as <code>phylo</code> objects.</h2><span id='topic+phylo_subset_both'></span>

<h3>Description</h3>

<p>Subset a reference and a target tree given as <code>phylo</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_subset_both(
  reference_tree,
  taxa,
  phy = NULL,
  phy4 = NULL,
  dating_method = "PATHd8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_subset_both_+3A_reference_tree">reference_tree</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="phylo_subset_both_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
<tr><td><code id="phylo_subset_both_+3A_phy">phy</code></td>
<td>
<p>A user tree to congruify as <code>phylo</code> object (ape).</p>
</td></tr>
<tr><td><code id="phylo_subset_both_+3A_phy4">phy4</code></td>
<td>
<p>A user tree to congruify in <code>phylo4</code> format (phylobase).</p>
</td></tr>
<tr><td><code id="phylo_subset_both_+3A_dating_method">dating_method</code></td>
<td>
<p>The method used for tree dating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a patristic matrix array and a <code style="white-space: pre;">&#8288;$problem&#8288;</code> if any.
</p>

<hr>
<h2 id='phylo_tiplabel_space_to_underscore'>Convert spaces to underscores in trees.</h2><span id='topic+phylo_tiplabel_space_to_underscore'></span>

<h3>Description</h3>

<p><code>phylo_tiplabel_space_to_underscore</code> is used in: <code><a href="#topic+make_mrbayes_runfile">make_mrbayes_runfile()</a></code>,
<code><a href="#topic+tree_get_singleton_outgroup">tree_get_singleton_outgroup()</a></code>,
<code><a href="#topic+congruify_and_check">congruify_and_check()</a></code>, <code><a href="#topic+patristic_matrix_array_phylo_congruify">patristic_matrix_array_phylo_congruify()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_tiplabel_space_to_underscore(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_tiplabel_space_to_underscore_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object.
</p>

<hr>
<h2 id='phylo_tiplabel_underscore_to_space'>Convert underscores to spaces in trees.</h2><span id='topic+phylo_tiplabel_underscore_to_space'></span>

<h3>Description</h3>

<p><code>phylo_tiplabel_underscore_to_space</code> is used inside <code><a href="#topic+patristic_matrix_array_phylo_congruify">patristic_matrix_array_phylo_congruify()</a></code>, <code><a href="#topic+congruify_and_check">congruify_and_check()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_tiplabel_underscore_to_space(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_tiplabel_underscore_to_space_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object.
</p>

<hr>
<h2 id='phylo_to_patristic_matrix'>Get a patristic matrix from a <code>phylo</code> object.</h2><span id='topic+phylo_to_patristic_matrix'></span>

<h3>Description</h3>

<p>Get a patristic matrix from a <code>phylo</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_to_patristic_matrix(phy, test = TRUE, tol = 0.01, option = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_to_patristic_matrix_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="phylo_to_patristic_matrix_+3A_test">test</code></td>
<td>
<p>Default to <code>TRUE</code>. Whether to test if <code>phy</code> has branch lengths and is ultrametric or not.</p>
</td></tr>
<tr><td><code id="phylo_to_patristic_matrix_+3A_tol">tol</code></td>
<td>
<p>branching time in <code>reference</code> above which secondary constraints will be applied to <code>target</code></p>
</td></tr>
<tr><td><code id="phylo_to_patristic_matrix_+3A_option">option</code></td>
<td>
<p>an integer (1 or 2; see details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A patristic matrix.
</p>

<hr>
<h2 id='pick_grove'>Pick a grove in the case of multiple groves in a set of trees.</h2><span id='topic+pick_grove'></span>

<h3>Description</h3>

<p>Pick a grove in the case of multiple groves in a set of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_grove(grove_list, criterion = "taxa", datelife_result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_grove_+3A_grove_list">grove_list</code></td>
<td>
<p>A list of vectors of tree indices. Each element is a grove.</p>
</td></tr>
<tr><td><code id="pick_grove_+3A_criterion">criterion</code></td>
<td>
<p>Defaults to <code>criterion = "taxa"</code>. Used for chronogram summarizing, i.e., obtaining a single
summary chronogram from a group of input chronograms.
For summarizing approaches that return a single summary tree from a group of
phylogenetic trees, it is necessary that the latter form a grove, roughly,
a sufficiently overlapping set of taxa between trees, see Ané et al. (2009) <a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>.
In rare cases, a group of trees can have multiple groves. This argument indicates
whether to get the grove with the most trees (<code>criterion = "trees"</code>) or the
most taxa (<code>criterion = "taxa"</code>).</p>
</td></tr>
<tr><td><code id="pick_grove_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object. Only needed for <code>criterion = "taxa"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the elements of the picked grove.
</p>

<hr>
<h2 id='plant_bold_otol_tree'>Some plants chronogram</h2><span id='topic+plant_bold_otol_tree'></span>

<h3>Description</h3>

<p>Some plants chronogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plant_bold_otol_tree
</code></pre>


<h3>Format</h3>

<p>A phylo object with 6 tips and 5 internal nodes
</p>

<dl>
<dt>edge</dt><dd><p>Integer vector with edge (branch) numbers</p>
</dd>
<dt>tip.label</dt><dd><p>Character vector with species names of plants</p>
</dd>
<dt>Nnode</dt><dd><p>Integer vector with the number of nodes</p>
</dd>
<dt>node.label</dt><dd><p>Character vector with node names</p>
</dd>
<dt>edge.length</dt><dd><p>Numeric vector with edge (branch) lengths</p>
</dd>
</dl>



<h3>Details</h3>

<p>Generated with make_bold_otol_tree(input = &quot;((Zea mays,Oryza sativa),((Arabidopsis thaliana,(Glycine max,Medicago sativa)),Solanum lycopersicum)Pentapetalae);&quot;)
usethis::use_data(plant_bold_otol_tree)
</p>


<h3>Author(s)</h3>

<p>Luna L. Sanchez-Reyes <a href="mailto:lsanche7@utk.edu">lsanche7@utk.edu</a>
</p>
<p>Brian O'Meara <a href="mailto:bomeara@utk.edu">bomeara@utk.edu</a>
</p>


<h3>Source</h3>

<p><a href="http://opentreeoflife.org">http://opentreeoflife.org</a>
</p>
<p><a href="http://www.boldsystems.org">http://www.boldsystems.org</a>
</p>

<hr>
<h2 id='problems'>Problematic chronograms from Open Tree of Life.</h2><span id='topic+problems'></span>

<h3>Description</h3>

<p>Problematic chronograms from Open Tree of Life.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>problems
</code></pre>


<h3>Format</h3>

<p>A list of trees with unmapped taxa
</p>


<h3>Details</h3>

<p>Before we developed tools to clean and map tip labels for our cached trees
we found some trees that were stored with unmapped tip labels
we extracted them and saved them to be used for testing functions.
Generated with
problems &lt;- opentree_chronograms$trees[sapply(sapply(opentree_chronograms$trees, &quot;[&quot;, &quot;tip.label&quot;), function(x) any(grepl(&quot;not.mapped&quot;, x)))]
usethis::use_data(problems)
opentree_chronograms object from commit https://github.com/phylotastic/datelife/tree/be894448f6fc437241cd0916fab45e84ac3e09c6
</p>
<p>[&quot;, &quot;tip.label&quot;), function(x) any(grepl(&quot;not.mapped&quot;, x)))]: R:%22,%20%22tip.label%22),%20function(x)%20any(grepl(%22not.mapped%22,%20x)))
</p>


<h3>Source</h3>

<p><a href="http://opentreeoflife.org">http://opentreeoflife.org</a>
</p>

<hr>
<h2 id='recover_mrcaott'>Get an mrcaott tag from an OpenTree induced synthetic tree and get its name and ott id</h2><span id='topic+recover_mrcaott'></span>

<h3>Description</h3>

<p>Get an mrcaott tag from an OpenTree induced synthetic tree and get its name and ott id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recover_mrcaott(tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recover_mrcaott_+3A_tag">tag</code></td>
<td>
<p>A character vector with the mrca tag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with ott id from original taxon named with the corresponding ott name
</p>

<hr>
<h2 id='relevant_curators_tabulate'>Return the relevant curators for a set of studies.</h2><span id='topic+relevant_curators_tabulate'></span>

<h3>Description</h3>

<p>Return the relevant curators for a set of studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relevant_curators_tabulate(results.index, cache = "opentree_chronograms")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relevant_curators_tabulate_+3A_results.index">results.index</code></td>
<td>
<p>A vector from <code><a href="#topic+datelife_result_study_index">datelife_result_study_index()</a></code> with the indices of the relevant studies.</p>
</td></tr>
<tr><td><code id="relevant_curators_tabulate_+3A_cache">cache</code></td>
<td>
<p>The cached chronogram database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with counts of each curator, with names equal to curator names.
</p>

<hr>
<h2 id='results_list_process'>Take results_list and process it.</h2><span id='topic+results_list_process'></span>

<h3>Description</h3>

<p><code>results_list_process</code> is used inside: <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>results_list_process(results_list, taxa = NULL, partial = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="results_list_process_+3A_results_list">results_list</code></td>
<td>
<p>A <code>list</code> returned from using <code><a href="#topic+get_subset_array_dispatch">get_subset_array_dispatch()</a></code> on <code>opentree_chronograms$trees</code></p>
</td></tr>
<tr><td><code id="results_list_process_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names to get a subset for.</p>
</td></tr>
<tr><td><code id="results_list_process_+3A_partial">partial</code></td>
<td>
<p>If <code>TRUE</code>, return matrices that have only partial matches.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the patristic.matrices that are not <code>NA</code>.
</p>

<hr>
<h2 id='run'>Core function to generate results</h2><span id='topic+run'></span>

<h3>Description</h3>

<p>Core function to generate results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run(
  input = c("Rhea americana", "Pterocnemia pennata", "Struthio camelus"),
  format = "citations",
  partial = "yes",
  plot.width = 600,
  plot.height = 600,
  use_tnrs = "no",
  opentree_chronograms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_+3A_input">input</code></td>
<td>
<p>A newick string or vector of taxa</p>
</td></tr>
<tr><td><code id="run_+3A_format">format</code></td>
<td>
<p>The output format</p>
</td></tr>
<tr><td><code id="run_+3A_partial">partial</code></td>
<td>
<p>How to deal with trees that have a subset of taxa in the query</p>
</td></tr>
<tr><td><code id="run_+3A_plot.width">plot.width</code></td>
<td>
<p>Width in pixels for output plot</p>
</td></tr>
<tr><td><code id="run_+3A_plot.height">plot.height</code></td>
<td>
<p>Height in pixels for output plot</p>
</td></tr>
<tr><td><code id="run_+3A_use_tnrs">use_tnrs</code></td>
<td>
<p>Whether to use OpenTree's TNRS for the input</p>
</td></tr>
<tr><td><code id="run_+3A_opentree_chronograms">opentree_chronograms</code></td>
<td>
<p>The list of lists containing the input trees and other info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results in the desired format
</p>

<hr>
<h2 id='run_mrbayes'>Runs MrBayes from R</h2><span id='topic+run_mrbayes'></span>

<h3>Description</h3>

<p>Runs MrBayes from R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_mrbayes(mrbayes_output_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_mrbayes_+3A_mrbayes_output_file">mrbayes_output_file</code></td>
<td>
<p>A character vector specifying the name of mrBayes run file and outputs (can specify directory too).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phylo object with the consensus tree. MrBayes output files are stored in the working directory.
</p>

<hr>
<h2 id='sample_trees'>Sample trees from a file containing multiple trees. Usually from a bayesian analysis output trees file.</h2><span id='topic+sample_trees'></span>

<h3>Description</h3>

<p>Sample trees from a file containing multiple trees. Usually from a bayesian analysis output trees file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_trees(trees_file, trees_object = NULL, burnin = 0.25, size = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_trees_+3A_trees_file">trees_file</code></td>
<td>
<p>A character vector indicating the name and directory of file with trees to sample.</p>
</td></tr>
<tr><td><code id="sample_trees_+3A_trees_object">trees_object</code></td>
<td>
<p>An R object containing a list of trees already read into R from a tree file from a bayesian analysis output.</p>
</td></tr>
<tr><td><code id="sample_trees_+3A_burnin">burnin</code></td>
<td>
<p>A numeric vector indicating the burnin fraction. It should be a number between 0 and 1. Default to 0.25</p>
</td></tr>
<tr><td><code id="sample_trees_+3A_size">size</code></td>
<td>
<p>A numeric vector indicating the number of samples to be generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>multiPhylo</code> object with a random sample of trees.
</p>

<hr>
<h2 id='some_ants_datelife_result'>datelifeResult object of some ants</h2><span id='topic+some_ants_datelife_result'></span>

<h3>Description</h3>

<p>datelifeResult object of some ants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>some_ants_datelife_result
</code></pre>


<h3>Format</h3>

<p>A list of one element, containing a named patristic matrix
</p>


<h3>Details</h3>

<p>Generated with:
some_ants_input &lt;- &quot;(Aulacopone_relicta,(((Myrmecia_gulosa,(Aneuretus_simoni,Dolichoderus_mariae)),((Ectatomma_ruidum,Huberia_brounii),Formica_rufa)),Apomyrma_stygia),Martialis_heureka)Formicidae;&quot;
some_ants_datelife_query &lt;- make_datelife_query(input = some_ants_input)
some_ants_datelife_result &lt;- get_datelife_result(input = some_ants_datelife_query)
usethis::use_data(some_ants_datelife_result)
</p>


<h3>Source</h3>

<p><a href="http://opentreeoflife.org">http://opentreeoflife.org</a>
</p>

<hr>
<h2 id='subset2_search'>A list with datelifeQuery and datelifeResult objects from a search of taxon names from subset2_taxa</h2><span id='topic+subset2_search'></span>

<h3>Description</h3>

<p>A list with datelifeQuery and datelifeResult objects from a search of taxon names from subset2_taxa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset2_search
</code></pre>


<h3>Format</h3>

<p>A list with two named elements. datelifeResult object with 24 patristic matrices
</p>

<dl>
<dt>datelife_query</dt><dd><p>A datelifeQuery object using names_subset 2 as input.</p>
</dd>
<dt>datelife_result</dt><dd><p>A datelifeResult object resulting from a search of names in datelifeQuery</p>
</dd>
</dl>



<h3>Details</h3>

<p>Generated with:
datelife_query &lt;- make_datelife_query(subset2_taxa)
datelife_result &lt;- get_datelife_result(datelife_query)
subset2_search &lt;- list(query = datelife_query, result = datelife_result)
usethis::use_data(subset2_search, overwrite = TRUE)
</p>

<hr>
<h2 id='subset2_taxa'>Long list of &gt;2.7k virus, bacteria, plant and animal taxon names</h2><span id='topic+subset2_taxa'></span>

<h3>Description</h3>

<p>Long list of &gt;2.7k virus, bacteria, plant and animal taxon names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset2_taxa
</code></pre>


<h3>Format</h3>

<p>A character vector of length 2778
</p>


<h3>Details</h3>

<p>Generated with:
subset2_taxa &lt;- rphylotastic::url_get_scientific_names(&quot;https://github.com/phylotastic/rphylotastic/blob/master/tests/testthat/subset2.txt&quot;)
usethis::use_data(subset2_taxa)
</p>


<h3>Source</h3>

<p><a href="https://github.com/phylotastic/rphylotastic/tree/master/tests/testthat">https://github.com/phylotastic/rphylotastic/tree/master/tests/testthat</a>
</p>

<hr>
<h2 id='summarize_congruifiedCalibrations'>Get summary statistics of ages in a <code>congruifiedCalibrations</code> object.</h2><span id='topic+summarize_congruifiedCalibrations'></span>

<h3>Description</h3>

<p>Function <code>summarize_congruifiedCalibrations</code> returns a table of
summary statistics for each node in <code>congruified_calibrations</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_congruifiedCalibrations(congruified_calibrations, age_column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_congruifiedCalibrations_+3A_congruified_calibrations">congruified_calibrations</code></td>
<td>
<p>A <code>congruifiedCalibrations</code> object, output of <code><a href="#topic+congruify_and_mrca_multiPhylo">congruify_and_mrca_multiPhylo()</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_congruifiedCalibrations_+3A_age_column">age_column</code></td>
<td>
<p>A character string indicating the name of the column to be summarized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of summarized ages.
</p>

<hr>
<h2 id='summarize_datelife_result'>Summarize a <code>datelifeResult</code> object.</h2><span id='topic+summarize_datelife_result'></span>

<h3>Description</h3>

<p>Get different types of summaries from a <code>datelifeResult</code>
object, an output from <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.
This allows rapid processing of data.
If you need a list of chronograms from your <code>datelifeResult</code> object, this
is the function you are looking for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_datelife_result(
  datelife_result = NULL,
  datelife_query = NULL,
  summary_format = "phylo_all",
  na_rm = TRUE,
  summary_print = c("citations", "taxa"),
  taxon_summary = c("none", "summary", "matrix"),
  criterion = "taxa"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_datelife_result_+3A_datelife_result">datelife_result</code></td>
<td>
<p>A <code>datelifeResult</code> object, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_datelife_result_+3A_datelife_query">datelife_query</code></td>
<td>
<p>A <code>datelifeQuery</code> object, usually an output of <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_datelife_result_+3A_summary_format">summary_format</code></td>
<td>
<p>A character vector of length one, indicating the output
format for results of the DateLife search. Available output formats are:
</p>

<dl>
<dt>&quot;citations&quot;</dt><dd><p>A character vector of references where chronograms with
some or all of the target taxa are published (source chronograms).</p>
</dd>
<dt>&quot;mrca&quot;</dt><dd><p>A named numeric vector of most recent common ancestor (mrca)
ages of target taxa defined in input, obtained from the source chronograms.
Names of mrca vector are equal to citations.</p>
</dd>
<dt>&quot;newick_all&quot;</dt><dd><p>A named character vector of newick strings corresponding
to target chronograms derived from source chronograms. Names of newick_all
vector are equal to citations.</p>
</dd>
<dt>&quot;newick_sdm&quot;</dt><dd><p>Only if multiple source chronograms are available. A
character vector with a single newick string corresponding to a target
chronogram obtained with SDM supertree method (Criscuolo et al. 2006).</p>
</dd>
<dt>&quot;newick_median&quot;</dt><dd><p>Only if multiple source chronograms are available.
A character vector with a single newick string corresponding to a target
chronogram from the median of all source chronograms.</p>
</dd>
<dt>&quot;phylo_sdm&quot;</dt><dd><p>Only if multiple source chronograms are available. A
phylo object with a single target chronogram obtained with SDM supertree
method (Criscuolo et al. 2006).</p>
</dd>
<dt>&quot;phylo_median&quot;</dt><dd><p>Only if multiple source chronograms are available. A
phylo object with a single target chronogram obtained from source
chronograms with median method.</p>
</dd>
<dt>&quot;phylo_all&quot;</dt><dd><p>A named list of phylo objects corresponding to each target
chronogram obtained from available source chronograms. Names of
phylo_all list correspond to citations.</p>
</dd>
<dt>&quot;phylo_biggest&quot;</dt><dd><p>The chronogram with the most taxa. In the case of a
tie, the chronogram with clade age closest to the median age of the
equally large trees is returned.</p>
</dd>
<dt>&quot;html&quot;</dt><dd><p>A character vector with an html string that can be saved and
then opened in any web browser. It contains a 4 column table with data on
target taxa: mrca, number of taxa, citations of source chronogram and
newick target chronogram.</p>
</dd>
<dt>&quot;data_frame&quot;</dt><dd><p>A 4 column <code>data.frame</code> with data on target taxa: mrca, number of
taxa, citations of source chronograms and newick string.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="summarize_datelife_result_+3A_na_rm">na_rm</code></td>
<td>
<p>If <code>TRUE</code>, it drops rows containing <code>NA</code>s from the <code>datelifeResult</code>
patristic matrix; if <code>FALSE</code>, it returns <code>NA</code> where there are missing entries.</p>
</td></tr>
<tr><td><code id="summarize_datelife_result_+3A_summary_print">summary_print</code></td>
<td>
<p>A character vector specifying the type of summary information
to be printed to screen. Options are:
</p>

<dl>
<dt>&quot;citations&quot;</dt><dd><p>Prints references of chronograms where target taxa are found.</p>
</dd>
<dt>&quot;taxa&quot;</dt><dd><p>Prints a summary of the number of chronograms where each target
taxon is found.</p>
</dd>
<dt>&quot;none&quot;</dt><dd><p>Nothing is printed to screen.</p>
</dd>
</dl>

<p>Defaults to <code>c("citations", "taxa")</code>, which displays both.</p>
</td></tr>
<tr><td><code id="summarize_datelife_result_+3A_taxon_summary">taxon_summary</code></td>
<td>
<p>A character vector specifying if data on target taxa missing
in source chronograms should be added to the output as a <code>"summary"</code> or as a
presence/absence <code>"matrix"</code>. Default to <code>"none"</code>, no information on taxon_summary
added to the output.</p>
</td></tr>
<tr><td><code id="summarize_datelife_result_+3A_criterion">criterion</code></td>
<td>
<p>Defaults to <code>criterion = "taxa"</code>. Used for chronogram summarizing, i.e., obtaining a single
summary chronogram from a group of input chronograms.
For summarizing approaches that return a single summary tree from a group of
phylogenetic trees, it is necessary that the latter form a grove, roughly,
a sufficiently overlapping set of taxa between trees, see Ané et al. (2009) <a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>.
In rare cases, a group of trees can have multiple groves. This argument indicates
whether to get the grove with the most trees (<code>criterion = "trees"</code>) or the
most taxa (<code>criterion = "taxa"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is determined by the argument <code>summary_format</code>:
</p>

<dl>
<dt>If <code>summary_format = "citations"</code></dt><dd><p>The function returns a character
vector of references.</p>
</dd>
<dt>If <code>summary_format = "mrca"</code></dt><dd><p>The function returns a named numeric
vector of most recent common ancestor (mrca) ages.</p>
</dd>
<dt>If <code>summary_format = "newick_[all, sdm, or median]"</code></dt><dd><p>The function
returns output chronograms as newick strings.</p>
</dd>
<dt>If <code>summary_format = "phylo_[all, sdm, median, or biggest]"</code></dt><dd><p>The
function returns output chronograms as <code>phylo</code> or <code>multiPhylo</code> objects.</p>
</dd>
<dt>If <code style="white-space: pre;">&#8288;summary_format = "html" or "data_frame"&#8288;</code></dt><dd><p>The function returns a
4 column table with data on mrca ages, number of taxa, references, and output chronograms as newick strings.</p>
</dd>
</dl>



<h3>References</h3>

<p>Ané, C., Eulenstein, O., Piaggio-Talice, R., &amp; Sanderson, M. J. (2009).
&quot;Groves of phylogenetic trees&quot;. Annals of Combinatorics, 13(2), 139-167,
<a href="https://doi.org/10.1007/s00026-009-0017-x">doi:10.1007/s00026-009-0017-x</a>.
</p>

<hr>
<h2 id='summarize_fossil_range'>Summarize taxon age from PBDB to just a single min and max age</h2><span id='topic+summarize_fossil_range'></span>

<h3>Description</h3>

<p>This uses the Paleobiology Database's API to gather information on the ages for all specimens of a taxon. It will also look for all descendants of the taxon. It fixes name misspellings if possible. It is basically a wrapper for get_fossil_range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_fossil_range(taxon, recent = FALSE, assume_recent_if_missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_fossil_range_+3A_taxon">taxon</code></td>
<td>
<p>The scientific name of the taxon you want the range of occurrences of</p>
</td></tr>
<tr><td><code id="summarize_fossil_range_+3A_recent">recent</code></td>
<td>
<p>If TRUE, forces the minimum age to be zero</p>
</td></tr>
<tr><td><code id="summarize_fossil_range_+3A_assume_recent_if_missing">assume_recent_if_missing</code></td>
<td>
<p>If TRUE, any taxon missing from pbdb is assumed to be recent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single row data.frame of max_ma and min_ma for the specimens, with rowname equal to taxon input
</p>

<hr>
<h2 id='summarize_summary_matrix'>Gets all ages per taxon pair from a distance matrix
Internal function used in summary_matrix_to_phylo_all().</h2><span id='topic+summarize_summary_matrix'></span>

<h3>Description</h3>

<p>Gets all ages per taxon pair from a distance matrix
Internal function used in summary_matrix_to_phylo_all().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_summary_matrix(summ_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_summary_matrix_+3A_summ_matrix">summ_matrix</code></td>
<td>
<p>Any summary patristic distance matrix, such as the ones obtained with <code><a href="#topic+datelife_result_sdm_matrix">datelife_result_sdm_matrix()</a></code> or <code><a href="#topic+datelife_result_median_matrix">datelife_result_median_matrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of pairwise ages, with row number equal to the combinatory
of column names (or row names), estimated as <code>ncol(summ_matrix)^2 - sum(1:(ncol(summ_matrix)-1))</code>.
</p>

<hr>
<h2 id='summary_matrix_to_phylo'>Go from a summary matrix to an ultrametric <code>phylo</code> object.</h2><span id='topic+summary_matrix_to_phylo'></span>

<h3>Description</h3>

<p>Go from a summary matrix to an ultrametric <code>phylo</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_matrix_to_phylo(
  summ_matrix,
  datelife_query = NULL,
  target_tree = NULL,
  total_distance = TRUE,
  use = "mean",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_matrix_to_phylo_+3A_summ_matrix">summ_matrix</code></td>
<td>
<p>Any summary patristic distance matrix, such as the ones obtained with <code><a href="#topic+datelife_result_sdm_matrix">datelife_result_sdm_matrix()</a></code> or <code><a href="#topic+datelife_result_median_matrix">datelife_result_median_matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="summary_matrix_to_phylo_+3A_datelife_query">datelife_query</code></td>
<td>
<p>A <code>datelifeQuery</code> object, usually an output of <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</td></tr>
<tr><td><code id="summary_matrix_to_phylo_+3A_target_tree">target_tree</code></td>
<td>
<p>A <code>phylo</code> object. Use this in case you want a specific
backbone for the output tree.</p>
</td></tr>
<tr><td><code id="summary_matrix_to_phylo_+3A_total_distance">total_distance</code></td>
<td>
<p>Whether the input <code>summ_matrix</code> stores total age distance
(from tip to tip) or distance from node to tip. Default to <code>TRUE</code>,
divides the matrix in half, if <code>FALSE</code> it will take it as is.</p>
</td></tr>
<tr><td><code id="summary_matrix_to_phylo_+3A_use">use</code></td>
<td>
<p>A character vector indicating what type of age to use for summary tree.
One of the following:
</p>

<dl>
<dt>&quot;mean&quot;</dt><dd><p>It will use the <code><a href="base.html#topic+mean">mean()</a></code> of the node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;median&quot;</dt><dd><p>It uses the <code><a href="stats.html#topic+median">stats::median()</a></code> age of node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;min&quot;</dt><dd><p>It will use the <code><a href="base.html#topic+min">min()</a></code> age from node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;max&quot;</dt><dd><p>Choose this if you wanna be conservative; it will use the <code><a href="base.html#topic+max">max()</a></code>
age from node ages in <code>summ_matrix</code>.</p>
</dd>
<dt>&quot;midpoint&quot;</dt><dd><p>It will use the mean of minimum age and maximum age.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="summary_matrix_to_phylo_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+summary_matrix_to_phylo_all">summary_matrix_to_phylo_all</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>It can take a regular patristic distance matrix, but there are simpler
methods for that implemented in <code><a href="#topic+patristic_matrix_to_phylo">patristic_matrix_to_phylo()</a></code>.
</p>


<h3>Value</h3>

<p>An ultrametric phylo object.
</p>

<hr>
<h2 id='summary_matrix_to_phylo_all'>Get minimum, median, mean, midpoint, and maximum summary chronograms from a
summary matrix of a <code>datelifeResult</code> object.</h2><span id='topic+summary_matrix_to_phylo_all'></span>

<h3>Description</h3>

<p>Get minimum, median, mean, midpoint, and maximum summary chronograms from a
summary matrix of a <code>datelifeResult</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_matrix_to_phylo_all(
  summ_matrix,
  datelife_query = NULL,
  target_tree = NULL,
  total_distance = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_matrix_to_phylo_all_+3A_summ_matrix">summ_matrix</code></td>
<td>
<p>Any summary patristic distance matrix, such as the ones obtained with <code><a href="#topic+datelife_result_sdm_matrix">datelife_result_sdm_matrix()</a></code> or <code><a href="#topic+datelife_result_median_matrix">datelife_result_median_matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="summary_matrix_to_phylo_all_+3A_datelife_query">datelife_query</code></td>
<td>
<p>A <code>datelifeQuery</code> object, usually an output of <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</td></tr>
<tr><td><code id="summary_matrix_to_phylo_all_+3A_target_tree">target_tree</code></td>
<td>
<p>A <code>phylo</code> object. Use this in case you want a specific
backbone for the output tree.</p>
</td></tr>
<tr><td><code id="summary_matrix_to_phylo_all_+3A_total_distance">total_distance</code></td>
<td>
<p>Whether the input <code>summ_matrix</code> stores total age distance
(from tip to tip) or distance from node to tip. Default to <code>TRUE</code>,
divides the matrix in half, if <code>FALSE</code> it will take it as is.</p>
</td></tr>
<tr><td><code id="summary_matrix_to_phylo_all_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_otol_synthetic_tree">get_otol_synthetic_tree</a></code>
</p>

<dl>
<dt><code>otol_version</code></dt><dd><p>Version of Open Tree of Life to use</p>
</dd>
<dt><code>resolve</code></dt><dd><p>Defaults to <code>TRUE</code>. Whether to resolve the tree at random or not.</p>
</dd>
<dt><code>input</code></dt><dd><p>Optional. A character vector of names or a <code>datelifeQuery</code> object.</p>
</dd>
<dt><code>ott_ids</code></dt><dd><p>If not NULL, it takes this argument and ignores input. A
numeric vector of ott ids obtained with <code><a href="rotl.html#topic+taxonomy_taxon_info">rotl::taxonomy_taxon_info()</a></code> or
<code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names()</a></code> or <code><a href="#topic+tnrs_match">tnrs_match()</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>With this function users can choose the minimum, mean or maximum ages from
the summary matrix as calibration points to get a single summary chronogram.
Users get all three summary chronograms in a <code>multiPhylo</code> object.
</p>


<h3>Value</h3>

<p>A <code>multiPhylo</code> object of length 5. It contains min, mean, median, midpoint, and max summary chronograms.
</p>

<hr>
<h2 id='summary_patristic_matrix_array'>Summarize patristic matrix array (by default, median). Used inside: summarize_datelife_result.</h2><span id='topic+summary_patristic_matrix_array'></span>

<h3>Description</h3>

<p>Summarize patristic matrix array (by default, median). Used inside: summarize_datelife_result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_patristic_matrix_array(patristic_matrix_array, fn = stats::median)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_patristic_matrix_array_+3A_patristic_matrix_array">patristic_matrix_array</code></td>
<td>
<p>3D array of patristic matrices</p>
</td></tr>
<tr><td><code id="summary_patristic_matrix_array_+3A_fn">fn</code></td>
<td>
<p>The function to use to summarize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2d array with the median (or max, or mean, etc) of the input array
</p>

<hr>
<h2 id='summary.datelifeResult'>Summarize a <code>datelifeResult</code> object.</h2><span id='topic+summary.datelifeResult'></span>

<h3>Description</h3>

<p>Summarize a <code>datelifeResult</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datelifeResult'
summary(object, datelife_query, na_rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.datelifeResult_+3A_object">object</code></td>
<td>
<p>An object of class <code>datelifeResult</code>, usually an output of <code><a href="#topic+get_datelife_result">get_datelife_result()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.datelifeResult_+3A_datelife_query">datelife_query</code></td>
<td>
<p>A <code>datelifeQuery</code> object, usually an output of <code><a href="#topic+make_datelife_query">make_datelife_query()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.datelifeResult_+3A_na_rm">na_rm</code></td>
<td>
<p>Default to <code>TRUE</code>, whether to include partial matches or not.</p>
</td></tr>
<tr><td><code id="summary.datelifeResult_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> of 11 elements:
</p>

<dl>
<dt>&quot;citations&quot;</dt><dd><p>A character vector of references where chronograms with
some or all of the target taxa are published (source chronograms).</p>
</dd>
<dt>&quot;mrca&quot;</dt><dd><p>A named numeric vector of most recent common ancestor (mrca)
ages of target taxa defined in input, obtained from the source chronograms.
Names of mrca vector are equal to citations.</p>
</dd>
<dt>&quot;newick_all&quot;</dt><dd><p>A named character vector of newick strings corresponding
to target chronograms derived from source chronograms. Names of newick_all
vector are equal to citations.</p>
</dd>
<dt>&quot;newick_sdm&quot;</dt><dd><p>Only if multiple source chronograms are available. A
character vector with a single newick string corresponding to a target
chronogram obtained with SDM supertree method (Criscuolo et al. 2006).</p>
</dd>
<dt>&quot;newick_median&quot;</dt><dd><p>Only if multiple source chronograms are available.
A character vector with a single newick string corresponding to a target
chronogram from the median of all source chronograms.</p>
</dd>
<dt>&quot;phylo_sdm&quot;</dt><dd><p>Only if multiple source chronograms are available. A
phylo object with a single target chronogram obtained with SDM supertree
method (Criscuolo et al. 2006).</p>
</dd>
<dt>&quot;phylo_median&quot;</dt><dd><p>Only if multiple source chronograms are available. A
phylo object with a single target chronogram obtained from source
chronograms with median method.</p>
</dd>
<dt>&quot;phylo_all&quot;</dt><dd><p>A named list of phylo objects corresponding to each target
chronogram obtained from available source chronograms. Names of
phylo_all list correspond to citations.</p>
</dd>
<dt>&quot;phylo_biggest&quot;</dt><dd><p>The chronogram with the most taxa. In the case of a
tie, the chronogram with clade age closest to the median age of the
equally large trees is returned.</p>
</dd>
<dt>&quot;html&quot;</dt><dd><p>A character vector with an html string that can be saved and
then opened in any web browser. It contains a 4 column table with data on
target taxa: mrca, number of taxa, citations of source chronogram and
newick target chronogram.</p>
</dd>
<dt>&quot;data_frame&quot;</dt><dd><p>A 4 column <code>data.frame</code> with data on target taxa: mrca, number of
taxa, citations of source chronograms and newick string.</p>
</dd>
</dl>


<hr>
<h2 id='summary.matchedCalibrations'>Summarize a <code>matchedCalibrations</code> object
<code>summary.matchedCalibrations</code> gets the node age distribution from a <code>matchedCalibrations</code> object.</h2><span id='topic+summary.matchedCalibrations'></span>

<h3>Description</h3>

<p>Summarize a <code>matchedCalibrations</code> object
<code>summary.matchedCalibrations</code> gets the node age distribution from a <code>matchedCalibrations</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matchedCalibrations'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.matchedCalibrations_+3A_object">object</code></td>
<td>
<p>A <code>matchedCalibrations</code> object, usually an element of the output of <code><a href="#topic+match_all_calibrations">match_all_calibrations()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.matchedCalibrations_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns <code>in_phy$mrca_node_name</code> and <code>in_phy$reference</code> are factors.
</p>


<h3>Value</h3>

<p>A <code>summaryMatchedCalibrations</code> object, which is a list of two <code>matchedCalibrations</code> objects:
</p>

<dl>
<dt>not_in_phy</dt><dd><p>A <code>data.frame</code> subset of input <code>matchedCalibrations</code> object
containing taxon name pairs that were not present in the given tree. <code>NULL</code>
if all input taxon names are found in the given tree.</p>
</dd>
<dt>in_phy</dt><dd><p>A <code>data.frame</code> subset of input <code>matchedCalibrations</code> object
containing all taxon name pairs that were present in the given tree.</p>
</dd>
</dl>


<hr>
<h2 id='threebirds_dr'><code>datelifeResult</code> object of three birds &quot;Rhea americana&quot;, &quot;Pterocnemia pennata&quot;, and &quot;Struthio camelus&quot;</h2><span id='topic+threebirds_dr'></span>

<h3>Description</h3>

<p><code>datelifeResult</code> object of three birds &quot;Rhea americana&quot;, &quot;Pterocnemia pennata&quot;, and &quot;Struthio camelus&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threebirds_dr
</code></pre>


<h3>Format</h3>

<p>A list of 9 named patristic matrix
</p>


<h3>Details</h3>

<p>Generated with:
threebirds_dr &lt;- get_datelife_result(input=c(&quot;Rhea americana&quot;, &quot;Pterocnemia pennata&quot;, &quot;Struthio camelus&quot;),
partial = TRUE, use_tnrs = FALSE, approximate_match = TRUE, cache = &quot;opentree_chronograms&quot;)
use_data(threebirds_dr)
</p>


<h3>Source</h3>

<p><a href="http://opentreeoflife.org">http://opentreeoflife.org</a>
</p>

<hr>
<h2 id='tnrs_match'>Taxon name resolution service (tnrs) applied to a vector of names by batches</h2><span id='topic+tnrs_match'></span><span id='topic+tnrs_match.default'></span><span id='topic+tnrs_match.phylo'></span>

<h3>Description</h3>

<p>Taxon name resolution service (tnrs) applied to a vector of names by batches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnrs_match(input, reference_taxonomy, tip, ...)

## Default S3 method:
tnrs_match(input, reference_taxonomy = "ott", ...)

## S3 method for class 'phylo'
tnrs_match(input, reference_taxonomy = "ott", tip = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnrs_match_+3A_input">input</code></td>
<td>
<p>A character vector of taxon names, or a phylo object with tip names, to be matched to taxonomy.</p>
</td></tr>
<tr><td><code id="tnrs_match_+3A_reference_taxonomy">reference_taxonomy</code></td>
<td>
<p>A character vector specifying the reference taxonomy to use for TNRS.
Options are &quot;ott&quot;, &quot;ncbi&quot;, &quot;gbif&quot; or &quot;irmng&quot;. The function defaults to &quot;ott&quot;.</p>
</td></tr>
<tr><td><code id="tnrs_match_+3A_tip">tip</code></td>
<td>
<p>A vector of mode numeric or character specifying the tips to match. If left empty all tips will be matched.</p>
</td></tr>
<tr><td><code id="tnrs_match_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="rotl.html#topic+tnrs_match_names">rotl::tnrs_match_names</a></code>
</p>

<dl>
<dt><code>context_name</code></dt><dd><p>name of the taxonomic context to be searched (length-one
character vector or <code>NULL</code>). Must match (case sensitive) one of the
values returned by <code><a href="rotl.html#topic+tnrs_contexts">tnrs_contexts</a></code>. Default to &quot;All life&quot;.</p>
</dd>
<dt><code>do_approximate_matching</code></dt><dd><p>A logical indicating whether or not to
perform approximate string (a.k.a. &ldquo;fuzzy&rdquo;) matching. Using
<code>FALSE</code> will greatly improve speed. Default, however, is <code>TRUE</code>.</p>
</dd>
<dt><code>ids</code></dt><dd><p>A vector of ids to use for identifying names. These will be
assigned to each name in the names array. If ids is provided, then ids and
names must be identical in length.</p>
</dd>
<dt><code>include_suppressed</code></dt><dd><p>Ordinarily, some quasi-taxa, such as incertae
sedis buckets and other non-OTUs, are suppressed from TNRS results. If
this parameter is true, these quasi-taxa are allowed as possible TNRS
results.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no limit to the number of names that can be queried and matched.
</p>
<p>The output will preserve all elements from original input phylo object and will add
</p>

<dl>
<dt>phy$mapped</dt><dd><p>A character vector indicating the state of mapping of phy$tip.labels:</p>
</dd>
</dl>

<dl>
<dt>original</dt><dd><p>Tnrs matching was not attempted. Original labeling is preserved.</p>
</dd>
<dt>ott</dt><dd><p>Matching was manually made by a curator in Open Tree of Life.</p>
</dd>
<dt>tnrs</dt><dd><p>Tnrs matching was attempted and successful with no approximate matching. Original label is replaced by the matched name.</p>
</dd>
<dt>approximated</dt><dd><p>Tnrs matching was attempted and successful but with approximate matching. Original labeling is preserved.</p>
</dd>
<dt>unmatched</dt><dd><p>Tnrs matching was attempted and unsuccessful. Original labeling is preserved.</p>
</dd>
</dl>

<dl>
<dt>phy$original.tip.label</dt><dd><p>A character vector preserving all original labels.</p>
</dd>
<dt>phy$ott_ids</dt><dd><p>A numeric vector with ott id numbers of matched tips. Unmatched and original tips will be NaN.</p>
</dd>
</dl>

<p>if tips are duplicated, tnrs will only be run once (avoiding increases in function running time) but the result will be applied to all duplicated tip labels
</p>


<h3>Value</h3>

<p>An object of class  data frame or phylo, with the added class match_names.
</p>
<p><code>NULL</code>
</p>
<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnrs_match(input = c("Mus"))
tnrs_match(input = c("Mus", "Mus musculus"))
tnrs_match(input = c("Mus", "Echinus", "Hommo", "Mus"))
</code></pre>

<hr>
<h2 id='tree_add_dates'>Add missing taxa to a dated tree and fabricate node ages for these missing taxa.</h2><span id='topic+tree_add_dates'></span>

<h3>Description</h3>

<p>This function adds missing taxa to a chronogram given in <code>dated_tree</code>.
It is still work in progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_add_dates(
  dated_tree = NULL,
  missing_taxa = NULL,
  dating_method = "mrbayes",
  adding_criterion = "random",
  mrbayes_output_file = "mrbayes_tree_add_dates.nexus"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_add_dates_+3A_dated_tree">dated_tree</code></td>
<td>
<p>a tree (newick or phylo) with branch lengths proportional to absolute time</p>
</td></tr>
<tr><td><code id="tree_add_dates_+3A_missing_taxa">missing_taxa</code></td>
<td>
<p>A tree, a data frame or a vector enlisting all missing taxa you want to include.
</p>

<dl>
<dt>A tree</dt><dd><p>Either as a phylo object or as a newick character string.
It contains all taxa that you want at the end, both missing and non missing.
This tree will be used as a hard constraint.</p>
</dd>
<dt>A <code>data.frame</code></dt><dd><p>It contains two columns named &quot;taxon&quot; and &quot;clade&quot;.
The first one contains a character vector of missing taxon names.
The second one contains a character or numeric vector of nodes from a
constraint tree to which each taxon will be assigned.</p>
</dd>
<dt>A character vector</dt><dd><p>It contains the names of the missing taxa.
They will be added at random to the constraint tree.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="tree_add_dates_+3A_dating_method">dating_method</code></td>
<td>
<p>The method used for tree dating, options are &quot;mrbayes&quot; and &quot;bladj&quot;.</p>
</td></tr>
<tr><td><code id="tree_add_dates_+3A_adding_criterion">adding_criterion</code></td>
<td>
<p>Only used when <code>dating_method = "mrbayes"</code>. A character vector to specify how missing_taxa should be added to dated_tree.
Choose one of:
</p>

<dl>
<dt>adding_method = &quot;random&quot;</dt><dd><p>missing_taxa will be added at random to dated_tree.
</p>
</dd>
<dt>adding_method = &quot;taxonomy&quot;</dt><dd><p>taxa will be added to dated_tree following a dataframe with taxonomic assignations given in missing_taxa argument. If no dataframe is given, OpenTree's reference taxonomy will be used.
</p>
</dd>
<dt>adding_method = &quot;tree&quot;</dt><dd><p>taxa will be added to dated_tree following a tree given in missing_taxa argument. If no tree is given, OpenTree's synthetic tree will be used.
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="tree_add_dates_+3A_mrbayes_output_file">mrbayes_output_file</code></td>
<td>
<p>A character vector specifying the name of mrBayes run file and outputs (can specify directory too).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object.
</p>

<hr>
<h2 id='tree_add_nodelabels'>Adds labels to nodes with no assigned label</h2><span id='topic+tree_add_nodelabels'></span>

<h3>Description</h3>

<p>Adds labels to nodes with no assigned label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_add_nodelabels(tree = NULL, node_prefix = "n", node_index = "node_number")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_add_nodelabels_+3A_tree">tree</code></td>
<td>
<p>A tree either as a newick character string or as a <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="tree_add_nodelabels_+3A_node_prefix">node_prefix</code></td>
<td>
<p>Character vector. If length 1, it will be used to name all nodes with no labels, followed by a number which can be the node_number or consecutive, as specified in node_index.</p>
</td></tr>
<tr><td><code id="tree_add_nodelabels_+3A_node_index">node_index</code></td>
<td>
<p>Character vector. Choose between &quot;from_1&quot; and &quot;node_number&quot; as numeric index for node labels. It will use consecutive numbers from 1 to total node number in the first case and phylo node numbers in the second case (i.e, from Ntip + 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phylo object
</p>

<hr>
<h2 id='tree_add_outgroup'>Function to add an outgroup to any phylogeny, in phylo or newick format</h2><span id='topic+tree_add_outgroup'></span>

<h3>Description</h3>

<p>Function to add an outgroup to any phylogeny, in phylo or newick format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_add_outgroup(tree = NULL, outgroup = "outgroup")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_add_outgroup_+3A_tree">tree</code></td>
<td>
<p>A tree either as a newick character string or as a <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="tree_add_outgroup_+3A_outgroup">outgroup</code></td>
<td>
<p>A character vector with the name of the outgroup. If it has length&gt;1, only first element will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phylo object with no root edge.
</p>

<hr>
<h2 id='tree_check'>Checks if a tree is a phylo class object otherwise it uses input_process.
Additionally it can check if tree is a chronogram with phylo_check</h2><span id='topic+tree_check'></span>

<h3>Description</h3>

<p>Checks if a tree is a phylo class object otherwise it uses input_process.
Additionally it can check if tree is a chronogram with phylo_check
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_check(tree = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_check_+3A_tree">tree</code></td>
<td>
<p>A tree either as a newick character string or as a <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="tree_check_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+phylo_check">phylo_check</a></code>
</p>

<dl>
<dt><code>brlen</code></dt><dd><p>Boolean. If <code>TRUE</code> it checks if <code>phylo</code> object has branch lengths.</p>
</dd>
<dt><code>dated</code></dt><dd><p>Boolean. If <code>TRUE</code> it checks if <code>phylo</code> object is ultrametric.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>If tree is correctly formatted, it returns a <code>phylo</code> object.
</p>

<hr>
<h2 id='tree_fix_brlen'>Take a tree with branch lengths and fix negative or zero length branches.</h2><span id='topic+tree_fix_brlen'></span>

<h3>Description</h3>

<p>Take a tree with branch lengths and fix negative or zero length branches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_fix_brlen(
  tree = NULL,
  fixing_criterion = "negative",
  fixing_method = 0,
  ultrametric = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_fix_brlen_+3A_tree">tree</code></td>
<td>
<p>A tree either as a newick character string or as a <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="tree_fix_brlen_+3A_fixing_criterion">fixing_criterion</code></td>
<td>
<p>A character vector specifying the type of branch length to be fixed: &quot;negative&quot; or &quot;zero&quot; (the number 0 is also allowed).</p>
</td></tr>
<tr><td><code id="tree_fix_brlen_+3A_fixing_method">fixing_method</code></td>
<td>
<p>A character vector specifying the method to fix branch lengths: &quot;bladj&quot;, &quot;mrbayes&quot; or a number to be assigned to all branches meeting fixing_criterion</p>
</td></tr>
<tr><td><code id="tree_fix_brlen_+3A_ultrametric">ultrametric</code></td>
<td>
<p>Boolean indicating whether to force ultrametric or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>phylo</code> object with no negative or zero branch lengths.
</p>

<hr>
<h2 id='tree_from_taxonomy'>Gets a taxonomic tree from a vector of taxa</h2><span id='topic+tree_from_taxonomy'></span>

<h3>Description</h3>

<p>This uses the taxize package's wrapper of the Global Names Resolver to get taxonomic paths for the vector of taxa you pass in. Sources is a vector of source labels in order (though it works best if everything uses the same taxonomy, so we recommend doing just one source). You can see options by doing taxize::gnr_datasources(). Our default is Catalogue of Life. The output is a phylo object (typically with many singleton nodes if collapse_singles is FALSE: nodes with only one descendant (like &quot;Homo&quot; having &quot;Homo sapiens&quot; as its only descendant) but these singletons typically have node.labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_from_taxonomy(
  taxa,
  sources = "Catalogue of Life",
  collapse_singles = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_from_taxonomy_+3A_taxa">taxa</code></td>
<td>
<p>Vector of taxon names</p>
</td></tr>
<tr><td><code id="tree_from_taxonomy_+3A_sources">sources</code></td>
<td>
<p>Vector of names of preferred sources; see taxize::gnr_datasources(). Currently supports 100 taxonomic resources, see details.</p>
</td></tr>
<tr><td><code id="tree_from_taxonomy_+3A_collapse_singles">collapse_singles</code></td>
<td>
<p>If true, collapses singleton nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a phylo object with resolved names and a vector with unresolved names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # This is a flag for package development. You are welcome to run the example.

taxa &lt;- c(
  "Homo sapiens", "Ursus arctos", "Pan paniscus", "Tyrannosaurus rex",
  "Ginkgo biloba", "Vulcan", "Klingon"
)
results &lt;- tree_from_taxonomy(taxa)
print(results$unresolved) # The taxa that do not match
ape::plot.phylo(results$phy) # may generate warnings due to problems with singletons
ape::plot.phylo(ape::collapse.singles(results$phy), show.node.label = TRUE)
# got rid of singles, but this also removes a lot of the node.labels

## End(Not run) # end dontrun
</code></pre>

<hr>
<h2 id='tree_get_node_data'>Get node numbers, node names, descendant tip numbers and labels of nodes from any tree, and node ages from dated trees.</h2><span id='topic+tree_get_node_data'></span>

<h3>Description</h3>

<p>Get node numbers, node names, descendant tip numbers and labels of nodes from any tree, and node ages from dated trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_get_node_data(
  tree = NULL,
  nodes = NULL,
  node_data = c("node_number", "node_label", "node_age", "descendant_tips_number",
    "descendant_tips_label")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_get_node_data_+3A_tree">tree</code></td>
<td>
<p>A tree either as a newick character string or as a <code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="tree_get_node_data_+3A_nodes">nodes</code></td>
<td>
<p>Numeric vector with node numbers from which you want to obtain data. Default to NULL: obtain data for all nodes in the tree.</p>
</td></tr>
<tr><td><code id="tree_get_node_data_+3A_node_data">node_data</code></td>
<td>
<p>A character vector containing one or all from: &quot;node_number&quot;, &quot;node_label&quot;, &quot;node_age&quot;, &quot;descendant_tips_number&quot;, &quot;descendant_tips_label&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='tree_get_singleton_outgroup'>Identify the presence of a single lineage outgroup in a phylogeny</h2><span id='topic+tree_get_singleton_outgroup'></span>

<h3>Description</h3>

<p>Identify the presence of a single lineage outgroup in a phylogeny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_get_singleton_outgroup(tree = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_get_singleton_outgroup_+3A_tree">tree</code></td>
<td>
<p>A tree either as a newick character string or as a <code>phylo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the name of the single lineage outgroup.
Returns <code>NA</code> if there is none.
</p>

<hr>
<h2 id='tree_node_tips'>To get tip numbers descending from any given node of a tree</h2><span id='topic+tree_node_tips'></span>

<h3>Description</h3>

<p>To get tip numbers descending from any given node of a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_node_tips(tree = NULL, node = NULL, curr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_node_tips_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree as an object of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="tree_node_tips_+3A_node">node</code></td>
<td>
<p>an integer specifying a node number in the tree.</p>
</td></tr>
<tr><td><code id="tree_node_tips_+3A_curr">curr</code></td>
<td>
<p>the set of previously stored node numbers - used in recursive function calls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with tip numbers descending from a node
</p>

<hr>
<h2 id='treebase_cache'>Information on contributors, authors, study ids and clades from studies with chronograms in Open tree of Life</h2><span id='topic+treebase_cache'></span>

<h3>Description</h3>

<p>Information on contributors, authors, study ids and clades from studies with chronograms in Open tree of Life
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treebase_cache
</code></pre>


<h3>Format</h3>

<p>A list of five data sets
</p>

<dl>
<dt>tb.author.pretty</dt><dd><p>A dataframe with two elements: author names and number of studies in TreeBase authored by each</p>
</dd>
<dt>tb.author.results</dt><dd><p>A dataframe with two elements: author names and study identifiers</p>
</dd>
</dl>



<h3>Details</h3>

<p>Generated with make_treebase_cache()
</p>


<h3>Source</h3>

<p>TreeBASE database, no longer available online <a href="https://en.wikipedia.org/wiki/TreeBASE">https://en.wikipedia.org/wiki/TreeBASE</a>
</p>

<hr>
<h2 id='update_all_cached'>Update all data files as data objects for the package</h2><span id='topic+update_all_cached'></span>

<h3>Description</h3>

<p>This includes opentree chronograms, contributors, treebase and curators
For speed, datelife caches chronograms and other information. Running this (within the checked out version of datelife) will refresh these. Then git commit and git push them back
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_all_cached()
</code></pre>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='update_datelife_cache'>Create an updated OpenTree chronograms database object</h2><span id='topic+update_datelife_cache'></span>

<h3>Description</h3>

<p>The function calls <code><a href="#topic+get_opentree_chronograms">get_opentree_chronograms()</a></code> to update the OpenTree
chronograms database cached in datelife. It has the option to write the updated
object as an .Rdata file, that will be independent of the <code>opentree_chronograms</code>
data object that you can load with <code>data("opentree_chronograms", package = "datelife")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_datelife_cache(
  write = TRUE,
  updated_name = "opentree_chronograms_updated",
  file_path = file.path(tempdir()),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_datelife_cache_+3A_write">write</code></td>
<td>
<p>Defaults to <code>TRUE</code>, it saves an .Rdata file named indicated by argument <code>name</code>,
containing available chronograms from Open Tree of Life. Saves to path indicated by argument <code>path</code>.</p>
</td></tr>
<tr><td><code id="update_datelife_cache_+3A_updated_name">updated_name</code></td>
<td>
<p>Used if <code>write = TRUE</code>. Defaults to <code>"opentree_chronograms_updated"</code>. A character
vector of length one indicating the name to assign to both the updated OpenTree chronogram
database object and the &quot;.Rdata&quot; file. For example, if <code>name = "my_database"</code>, the
function will assign the updated chronogram database to an object named <code>my_database</code>
and will write it to a file named &quot;my_database.Rdata&quot; in the path indicated
by argument <code>file_path</code>.</p>
</td></tr>
<tr><td><code id="update_datelife_cache_+3A_file_path">file_path</code></td>
<td>
<p>Used if <code>write = TRUE</code>. A character vector of length 1 indicating
the path to write the updated database &quot;.Rdata&quot; file to, excluding file name.
Defaults to temporary directory obtained with <code><a href="base.html#topic+tempfile">base::tempdir()</a></code> and formatted with
<code><a href="base.html#topic+file.path">base::file.path()</a></code>.</p>
</td></tr>
<tr><td><code id="update_datelife_cache_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_opentree_chronograms">get_opentree_chronograms</a></code>
</p>

<dl>
<dt><code>max_tree_count</code></dt><dd><p>Default to &quot;all&quot;, it gets all available chronograms. For testing purposes, a numeric value indicating the max number of trees to be cached.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 4 elements:
</p>

<dl>
<dt>authors</dt><dd><p>A list of lists of author names of the original studies that
published chronograms currently stored in the Open Tree of Life database.</p>
</dd>
<dt>curators</dt><dd><p>A list of lists of curator names that uploaded chronograms
to the Open Tree of Life database.</p>
</dd>
<dt>studies</dt><dd><p>A list of study identifiers from original studies that
published chronograms currently stored in the Open Tree of Life database.</p>
</dd>
<dt>trees</dt><dd><p>A <code>multiPhylo</code> object storing the chronograms from Open Tree of
Life database.</p>
</dd>
<dt>update</dt><dd><p>A character vector indicating the time when the database object
was last updated.</p>
</dd>
<dt>version</dt><dd><p>A character vector indicating the datelife package version when the
object was last updated.</p>
</dd>
</dl>


<hr>
<h2 id='use_all_calibrations'>Date a given tree topology using a given set of congruified calibrations or ages</h2><span id='topic+use_all_calibrations'></span>

<h3>Description</h3>

<p><code>use_all_calibrations</code> generates one or multiple chronograms
(i.e., phylogenetic trees with branch lengths proportional to time) by dating
a tree topology given in <code>phy</code>, and secondary calibrations given in
<code>calibrations</code>, using the algorithm specified in the argument <code>dating_method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_all_calibrations(
  phy = NULL,
  calibrations = NULL,
  each = FALSE,
  dating_method = "bladj",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_all_calibrations_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object to use as tree topology.</p>
</td></tr>
<tr><td><code id="use_all_calibrations_+3A_calibrations">calibrations</code></td>
<td>
<p>A <code>calibrations</code> object, an output of <code><a href="#topic+get_all_calibrations">get_all_calibrations()</a></code>.</p>
</td></tr>
<tr><td><code id="use_all_calibrations_+3A_each">each</code></td>
<td>
<p>Boolean, default to <code>FALSE</code>: all calibrations are returned in
the same <code>data.frame</code>. If <code>TRUE</code>, calibrations from each chronogram are returned
in separate data frames.</p>
</td></tr>
<tr><td><code id="use_all_calibrations_+3A_dating_method">dating_method</code></td>
<td>
<p>Tree dating algorithm to use. Options are &quot;bladj&quot; or &quot;pathd8&quot;
(Webb et al., 2008, <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>; Britton et al., 2007,
<a href="https://doi.org/10.1080/10635150701613783">doi:10.1080/10635150701613783</a>).</p>
</td></tr>
<tr><td><code id="use_all_calibrations_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+use_calibrations">use_calibrations</a></code>
</p>

<dl>
<dt><code>type</code></dt><dd><p>The type of age to use as calibration. Options are &quot;median&quot;, &quot;mean&quot;, &quot;min&quot;, or &quot;max&quot;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>phy</code> has no branch lengths, <code>dating_method</code> is ignores, and the function applies secondary
calibrations to date the tree with the BLADJ algorithm. See <code><a href="#topic+make_bladj_tree">make_bladj_tree()</a></code> and <code><a href="#topic+use_calibrations_bladj">use_calibrations_bladj()</a></code>.
If <code>phy</code> has branch lengths, the function can use the PATHd8 algorithm. See <code><a href="#topic+use_calibrations_pathd8">use_calibrations_pathd8()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> or <code>multiPhylo</code> object with branch lengths proportional to time.
</p>


<h3>More</h3>

<p>The output object stores the used <code>calibrations</code> and <code>dating_method</code> as
<code>attributes(output)$datelife_calibrations</code> and <code>attributes(output)$dating_method</code>.
</p>


<h3>References</h3>

<p>Webb, C. O., Ackerly, D. D., &amp; Kembel, S. W. (2008). &quot;Phylocom: software for
the analysis of phylogenetic community structure and trait evolution&quot;.
Bioinformatics, 24(18), <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>.
</p>
<p>Britton, T., Anderson, C. L., Jacquet, D., Lundqvist, S., &amp; Bremer, K. (2007).
&quot;Estimating divergence times in large phylogenetic trees&quot;. Systematic biology,
56(5), 741-752. <a href="https://doi.org/10.1080/10635150701613783">doi:10.1080/10635150701613783</a>.
</p>

<hr>
<h2 id='use_calibrations'>Date a given tree topology using a combined set of given calibrations</h2><span id='topic+use_calibrations'></span>

<h3>Description</h3>

<p><code>use_calibrations</code> combines all given calibrations and uses them as
constraints to perform a dating analysis on a given tree topology, using BLADJ
if it has no branch lengths, or PATHd8 if the given tree topology has initial
branch lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_calibrations(
  phy = NULL,
  calibrations = NULL,
  dating_method = "bladj",
  type = "median",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_calibrations_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object to use as tree topology.</p>
</td></tr>
<tr><td><code id="use_calibrations_+3A_calibrations">calibrations</code></td>
<td>
<p>A <code>calibrations</code> object, an output of <code><a href="#topic+get_all_calibrations">get_all_calibrations()</a></code>.</p>
</td></tr>
<tr><td><code id="use_calibrations_+3A_dating_method">dating_method</code></td>
<td>
<p>Tree dating algorithm to use. Options are &quot;bladj&quot; or &quot;pathd8&quot;
(Webb et al., 2008, <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>; Britton et al., 2007,
<a href="https://doi.org/10.1080/10635150701613783">doi:10.1080/10635150701613783</a>).</p>
</td></tr>
<tr><td><code id="use_calibrations_+3A_type">type</code></td>
<td>
<p>The type of age to use as calibration. Options are &quot;median&quot;, &quot;mean&quot;, &quot;min&quot;, or &quot;max&quot;.</p>
</td></tr>
<tr><td><code id="use_calibrations_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+use_calibrations_pathd8">use_calibrations_pathd8</a></code>
</p>

<dl>
<dt><code>expand</code></dt><dd><p>How much to expand by each step to get consistent calibrations. Should be between 0 and 1.</p>
</dd>
<dt><code>giveup</code></dt><dd><p>How many expansions to try before giving up</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>phy</code> has no branch lengths, <code>dating_method</code> is ignores, and the function applies secondary
calibrations to date the tree with the BLADJ algorithm. See <code><a href="#topic+make_bladj_tree">make_bladj_tree()</a></code> and <code><a href="#topic+use_calibrations_bladj">use_calibrations_bladj()</a></code>.
If <code>phy</code> has branch lengths, the function can use the PATHd8 algorithm. See <code><a href="#topic+use_calibrations_pathd8">use_calibrations_pathd8()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> object with branch lengths proportional to time.
</p>


<h3>More</h3>

<p>The output object stores the used <code>calibrations</code> and <code>dating_method</code> as
<code>attributes(output)$datelife_calibrations</code> and <code>attributes(output)$dating_method</code>.
</p>

<hr>
<h2 id='use_calibrations_bladj'>Use calibrations to date a topology with the BLADJ algorithm.</h2><span id='topic+use_calibrations_bladj'></span>

<h3>Description</h3>

<p>The function <code>use_calibrations_bladj</code> prepares the input for BLADJ
and calls <code><a href="#topic+make_bladj_tree">make_bladj_tree()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_calibrations_bladj(phy = NULL, calibrations, type = "median", root_age)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_calibrations_bladj_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object with or without branch lengths.</p>
</td></tr>
<tr><td><code id="use_calibrations_bladj_+3A_calibrations">calibrations</code></td>
<td>
<p>A <code>data.frame</code> of secondary calibrations for any pair of taxon
names in <code>phy</code>, usually obtained with <code><a href="#topic+get_all_calibrations">get_all_calibrations()</a></code>.</p>
</td></tr>
<tr><td><code id="use_calibrations_bladj_+3A_type">type</code></td>
<td>
<p>The type of age to use as calibration. Options are &quot;median&quot;, &quot;mean&quot;, &quot;min&quot;, or &quot;max&quot;.</p>
</td></tr>
<tr><td><code id="use_calibrations_bladj_+3A_root_age">root_age</code></td>
<td>
<p>Numeric specifying the age of the root. Only used if there are
no ages for the root node in  <code>calibrations</code> argument.
If missing, NULL, or not numeric, the value of the oldest calibration plus one
unit of the mean differences across calibrations, will be used as root calibration.
If there is one single age point provided as <code>calibrations</code>, the root age will
be set to 10% more than the age of the single calibration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BLADJ algorithm is part of the Phylocom software, presented in Webb et al.
(2008) <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>.
</p>


<h3>Value</h3>

<p>A chronogram: a <code>phylo</code> object with branch lengths proportional to time.
</p>


<h3>References</h3>

<p>Webb, C. O., Ackerly, D. D., &amp; Kembel, S. W. (2008). &quot;Phylocom: software for
the analysis of phylogenetic community structure and trait evolution&quot;.
Bioinformatics, 24(18), <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>.
</p>

<hr>
<h2 id='use_calibrations_bladj.matchedCalibrations'>Use calibrations to date a topology with the BLADJ algorithm.</h2><span id='topic+use_calibrations_bladj.matchedCalibrations'></span>

<h3>Description</h3>

<p>The function prepares the input for BLADJ and calls <code><a href="#topic+make_bladj_tree">make_bladj_tree()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_calibrations_bladj.matchedCalibrations(
  calibrations,
  type = "mean",
  root_age = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_calibrations_bladj.matchedCalibrations_+3A_calibrations">calibrations</code></td>
<td>
<p>A <code>data.frame</code> of secondary calibrations for any pair of taxon
names in <code>phy</code>, usually obtained with <code><a href="#topic+get_all_calibrations">get_all_calibrations()</a></code>.</p>
</td></tr>
<tr><td><code id="use_calibrations_bladj.matchedCalibrations_+3A_type">type</code></td>
<td>
<p>The type of age to use as calibration. Options are &quot;median&quot;, &quot;mean&quot;, &quot;min&quot;, or &quot;max&quot;.</p>
</td></tr>
<tr><td><code id="use_calibrations_bladj.matchedCalibrations_+3A_root_age">root_age</code></td>
<td>
<p>Numeric specifying an age for the root, provided by the user.
Only used if there are no time calibrations for the root node in the chronograms database.
If <code>NULL</code> or not numeric, the maximum calibration age plus one unit of the sd
(calculated with <code><a href="stats.html#topic+sd">stats::sd()</a></code>)
of all node ages available for the tree will be used as root calibration.
If there is only one calibration available for the whole tree, the root
node age will be proportional to 1.1 of the age of that calibration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BLADJ algorithm is part of the Phylocom software, presented in Webb et al.
(2008) <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> object with branch lengths proportional to time.
</p>


<h3>References</h3>

<p>Webb, C. O., Ackerly, D. D., &amp; Kembel, S. W. (2008). &quot;Phylocom: software for
the analysis of phylogenetic community structure and trait evolution&quot;.
Bioinformatics, 24(18), <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>.
</p>

<hr>
<h2 id='use_calibrations_each'>Date a given tree topology by using a given list of calibrations independently,
to generate multiple hypothesis of time of divergence</h2><span id='topic+use_calibrations_each'></span>

<h3>Description</h3>

<p><code>use_calibrations_each</code> wraps <code>use_calibrations</code> to take each set of
given calibrations and use it independently as constraints for BLADJ or PATHd8
to date a given tree topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_calibrations_each(phy = NULL, calibrations = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_calibrations_each_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object to use as tree topology.</p>
</td></tr>
<tr><td><code id="use_calibrations_each_+3A_calibrations">calibrations</code></td>
<td>
<p>A <code>calibrations</code> object, an output of <code><a href="#topic+get_all_calibrations">get_all_calibrations()</a></code>.</p>
</td></tr>
<tr><td><code id="use_calibrations_each_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+use_calibrations">use_calibrations</a></code>
</p>

<dl>
<dt><code>dating_method</code></dt><dd><p>Tree dating algorithm to use. Options are &quot;bladj&quot; or &quot;pathd8&quot;
(Webb et al., 2008, <a href="https://doi.org/10.1093/bioinformatics/btn358">doi:10.1093/bioinformatics/btn358</a>; Britton et al., 2007,
<a href="https://doi.org/10.1080/10635150701613783">doi:10.1080/10635150701613783</a>).</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of age to use as calibration. Options are &quot;median&quot;, &quot;mean&quot;, &quot;min&quot;, or &quot;max&quot;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>phy</code> has no branch lengths, <code>dating_method</code> is ignores, and the function applies secondary
calibrations to date the tree with the BLADJ algorithm. See <code><a href="#topic+make_bladj_tree">make_bladj_tree()</a></code> and <code><a href="#topic+use_calibrations_bladj">use_calibrations_bladj()</a></code>.
If <code>phy</code> has branch lengths, the function can use the PATHd8 algorithm. See <code><a href="#topic+use_calibrations_pathd8">use_calibrations_pathd8()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>multiPhylo</code> object of trees with branch lengths proportional to time.
</p>


<h3>More</h3>

<p>The output object stores the used <code>calibrations</code> and <code>dating_method</code> as
<code>attributes(output)$datelife_calibrations</code> and <code>attributes(output)$dating_method</code>.
</p>

<hr>
<h2 id='use_calibrations_pathd8'>Date a tree with secondary calibrations using PATHd8</h2><span id='topic+use_calibrations_pathd8'></span>

<h3>Description</h3>

<p><code>use_calibrations_pathd8</code> uses secondary calibrations to date a tree with initial branch lengths using PATHd8.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_calibrations_pathd8(
  phy = NULL,
  calibrations = NULL,
  expand = 0.1,
  giveup = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_calibrations_pathd8_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object with branch lengths.</p>
</td></tr>
<tr><td><code id="use_calibrations_pathd8_+3A_calibrations">calibrations</code></td>
<td>
<p>A <code>data.frame</code> of secondary calibrations for any pair of taxon
names in <code>phy</code>, usually obtained with <code><a href="#topic+get_all_calibrations">get_all_calibrations()</a></code>.</p>
</td></tr>
<tr><td><code id="use_calibrations_pathd8_+3A_expand">expand</code></td>
<td>
<p>How much to expand by each step to get consistent calibrations. Should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="use_calibrations_pathd8_+3A_giveup">giveup</code></td>
<td>
<p>How many expansions to try before giving up</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <a href="https://www2.math.su.se/PATHd8/">PATHd8</a> algorithm
described in Britton et al. (2007) <a href="https://doi.org/10.1080/10635150701613783">doi:10.1080/10635150701613783</a>, with <code><a href="geiger.html#topic+geiger-internal">geiger::PATHd8.phylo()</a></code>.
The function first attempts to use the given calibrations as fixed ages.
If that fails (often due to conflict between calibrations), it will expand the
range of the minimum age and maximum age and try again. And repeat.
If expand = 0, it uses the summarized calibrations.
In some cases, it returns edge lengths in relative time (with maximum tree depth = 1)
instead of absolute time, as given by calibrations. In this case, the function returns NA.
This is an issue from PATHd8.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> object with branch lengths proportional to time.
</p>


<h3>References</h3>

<p>Britton, T., Anderson, C. L., Jacquet, D., Lundqvist, S., &amp; Bremer, K. (2007).
&quot;Estimating divergence times in large phylogenetic trees&quot;. Systematic biology,
56(5), 741-752. <a href="https://doi.org/10.1080/10635150701613783">doi:10.1080/10635150701613783</a>.
</p>

<hr>
<h2 id='use_calibrations_treePL'>Date a tree with initial branch lengths with treePL.</h2><span id='topic+use_calibrations_treePL'></span>

<h3>Description</h3>

<p>Date a tree with initial branch lengths with treePL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_calibrations_treePL(phy, calibrations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_calibrations_treePL_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo</code> object with or without branch lengths.</p>
</td></tr>
<tr><td><code id="use_calibrations_treePL_+3A_calibrations">calibrations</code></td>
<td>
<p>A <code>data.frame</code> of secondary calibrations for any pair of taxon
names in <code>phy</code>, usually obtained with <code><a href="#topic+get_all_calibrations">get_all_calibrations()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses treePL as described in Smith, S. A., &amp; O’Meara, B. C. (2012).
<a href="https://doi.org/10.1093/bioinformatics/bts492">doi:10.1093/bioinformatics/bts492</a>, with
the function <code>treePL.phylo</code>. It attempts to use the calibrations as fixed ages.
If that fails (often due to conflict between calibrations), it will expand the
range of the minimum age and maximum age and try again. And repeat.
If expand = 0, it uses the summarized calibrations.
In some cases, it returns edge lengths in relative time (with maximum tree depth = 1)
instead of absolute time, as given by calibrations. In this case, the function returns NA.
This is an issue from PATHd8.
</p>


<h3>Value</h3>

<p>A phylo object
</p>


<h3>References</h3>

<p>Smith, S. A., &amp; O’Meara, B. C. (2012).
&quot;treePL: divergence time estimation using penalized likelihood for large phylogenies&quot;.
Bioinformatics, 28(20), 2689-2690, <a href="https://doi.org/10.1093/bioinformatics/bts492">doi:10.1093/bioinformatics/bts492</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
