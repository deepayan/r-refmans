<!DOCTYPE html><html lang="en"><head><title>Help for package plyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#plyr'><p>plyr: the split-apply-combine paradigm for R.</p></a></li>
<li><a href='#.'><p>Quote variables to create a list of unevaluated expressions for later</p>
evaluation.</a></li>
<li><a href='#+5B.split'><p>Subset splits.</p></a></li>
<li><a href='#a_ply'><p>Split array, apply function, and discard results.</p></a></li>
<li><a href='#aaply'><p>Split array, apply function, and return results in an array.</p></a></li>
<li><a href='#adply'><p>Split array, apply function, and return results in a data frame.</p></a></li>
<li><a href='#alply'><p>Split array, apply function, and return results in a list.</p></a></li>
<li><a href='#amv_dim'><p>Dimensions.</p></a></li>
<li><a href='#amv_dimnames'><p>Dimension names.</p></a></li>
<li><a href='#arrange'><p>Order a data frame by its colums.</p></a></li>
<li><a href='#as.data.frame.function'><p>Make a function return a data frame.</p></a></li>
<li><a href='#as.list.split'><p>Convert split list to regular list.</p></a></li>
<li><a href='#as.quoted'><p>Convert input to quoted variables.</p></a></li>
<li><a href='#baseball'><p>Yearly batting records for all major league baseball players</p></a></li>
<li><a href='#colwise'><p>Column-wise function.</p></a></li>
<li><a href='#compact'><p>Compact list.</p></a></li>
<li><a href='#count'><p>Count the number of occurences.</p></a></li>
<li><a href='#create_progress_bar'><p>Create progress bar.</p></a></li>
<li><a href='#d_ply'><p>Split data frame, apply function, and discard results.</p></a></li>
<li><a href='#daply'><p>Split data frame, apply function, and return results in an array.</p></a></li>
<li><a href='#ddply'><p>Split data frame, apply function, and return results in a data frame.</p></a></li>
<li><a href='#defaults'><p>Set defaults.</p></a></li>
<li><a href='#desc'><p>Descending order.</p></a></li>
<li><a href='#dims'><p>Number of dimensions.</p></a></li>
<li><a href='#dlply'><p>Split data frame, apply function, and return results in a list.</p></a></li>
<li><a href='#each'><p>Aggregate multiple functions into a single function.</p></a></li>
<li><a href='#empty'><p>Check if a data frame is empty.</p></a></li>
<li><a href='#eval.quoted'><p>Evaluate a quoted list of variables.</p></a></li>
<li><a href='#failwith'><p>Fail with specified value.</p></a></li>
<li><a href='#here'><p>Capture current evaluation context.</p></a></li>
<li><a href='#id'><p>Compute a unique numeric id for each unique row in a data frame.</p></a></li>
<li><a href='#id_var'><p>Numeric id for a vector.</p></a></li>
<li><a href='#idata.frame'><p>Construct an immutable data frame.</p></a></li>
<li><a href='#indexed_array'><p>An indexed array.</p></a></li>
<li><a href='#indexed_df'><p>An indexed data frame.</p></a></li>
<li><a href='#is.discrete'><p>Determine if a vector is discrete.</p></a></li>
<li><a href='#is.formula'><p>Is a formula?</p>
Checks if argument is a formula</a></li>
<li><a href='#isplit2'><p>Split iterator that returns values, not indices.</p></a></li>
<li><a href='#join'><p>Join two data frames together.</p></a></li>
<li><a href='#join_all'><p>Recursively join a list of data frames.</p></a></li>
<li><a href='#join.keys'><p>Join keys.</p>
Given two data frames, create a unique key for each row.</a></li>
<li><a href='#l_ply'><p>Split list, apply function, and discard results.</p></a></li>
<li><a href='#laply'><p>Split list, apply function, and return results in an array.</p></a></li>
<li><a href='#ldply'><p>Split list, apply function, and return results in a data frame.</p></a></li>
<li><a href='#liply'><p>Experimental iterator based version of llply.</p></a></li>
<li><a href='#list_to_array'><p>List to array.</p></a></li>
<li><a href='#list_to_dataframe'><p>List to data frame.</p></a></li>
<li><a href='#list_to_vector'><p>List to vector.</p></a></li>
<li><a href='#llply'><p>Split list, apply function, and return results in a list.</p></a></li>
<li><a href='#loop_apply'><p>Loop apply</p></a></li>
<li><a href='#m_ply'><p>Call function with arguments in array or data frame, discarding results.</p></a></li>
<li><a href='#maply'><p>Call function with arguments in array or data frame, returning an array.</p></a></li>
<li><a href='#mapvalues'><p>Replace specified values with new values, in a vector or factor.</p></a></li>
<li><a href='#match_df'><p>Extract matching rows of a data frame.</p></a></li>
<li><a href='#mdply'><p>Call function with arguments in array or data frame, returning a data frame.</p></a></li>
<li><a href='#mlply'><p>Call function with arguments in array or data frame, returning a list.</p></a></li>
<li><a href='#mutate'><p>Mutate a data frame by adding new or replacing existing columns.</p></a></li>
<li><a href='#name_rows'><p>Toggle row names between explicit and implicit.</p></a></li>
<li><a href='#names.quoted'><p>Compute names of quoted variables.</p></a></li>
<li><a href='#nunique'><p>Number of unique values.</p></a></li>
<li><a href='#ozone'><p>Monthly ozone measurements over Central America.</p></a></li>
<li><a href='#plyr-deprecated'><p>Deprecated Functions in Package plyr</p></a></li>
<li><a href='#print.quoted'><p>Print quoted variables.</p></a></li>
<li><a href='#print.split'><p>Print split.</p></a></li>
<li><a href='#progress_none'><p>Null progress bar</p></a></li>
<li><a href='#progress_text'><p>Text progress bar.</p></a></li>
<li><a href='#progress_time'><p>Text progress bar with time.</p></a></li>
<li><a href='#progress_tk'><p>Graphical progress bar, powered by Tk.</p></a></li>
<li><a href='#progress_win'><p>Graphical progress bar, powered by Windows.</p></a></li>
<li><a href='#quickdf'><p>Quick data frame.</p></a></li>
<li><a href='#r_ply'><p>Replicate expression and discard results.</p></a></li>
<li><a href='#raply'><p>Replicate expression and return results in a array.</p></a></li>
<li><a href='#rbind.fill'><p>Combine data.frames by row, filling in missing columns.</p></a></li>
<li><a href='#rbind.fill.matrix'><p>Bind matrices by row, and fill missing columns with NA.</p></a></li>
<li><a href='#rdply'><p>Replicate expression and return results in a data frame.</p></a></li>
<li><a href='#reduce_dim'><p>Reduce dimensions.</p></a></li>
<li><a href='#rename'><p>Modify names by name, not position.</p></a></li>
<li><a href='#revalue'><p>Replace specified values with new values, in a factor or character vector.</p></a></li>
<li><a href='#rlply'><p>Replicate expression and return results in a list.</p></a></li>
<li><a href='#round_any'><p>Round to multiple of any number.</p></a></li>
<li><a href='#splat'><p>&lsquo;Splat&rsquo; arguments to a function.</p></a></li>
<li><a href='#split_indices'><p>Split indices.</p></a></li>
<li><a href='#split_labels'><p>Generate labels for split data frame.</p></a></li>
<li><a href='#splitter_a'><p>Split an array by .margins.</p></a></li>
<li><a href='#splitter_d'><p>Split a data frame by variables.</p></a></li>
<li><a href='#strip_splits'><p>Remove splitting variables from a data frame.</p></a></li>
<li><a href='#summarise'><p>Summarise a data frame.</p></a></li>
<li><a href='#take'><p>Take a subset along an arbitrary dimension</p></a></li>
<li><a href='#true'><p>Function that always returns true.</p></a></li>
<li><a href='#try_default'><p>Try, with default in case of error.</p></a></li>
<li><a href='#tryapply'><p>Apply with built in try.</p>
Uses compact, lapply and tryNULL</a></li>
<li><a href='#unrowname'><p>Un-rowname.</p></a></li>
<li><a href='#vaggregate'><p>Vector aggregate.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Splitting, Applying and Combining Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.9</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools that solves a common set of problems: you need
    to break a big problem down into manageable pieces, operate on each
    piece and then put all the pieces back together.  For example, you
    might want to fit a model to each spatial location or time point in
    your study, summarise data by panels or collapse high-dimensional
    arrays to simpler summary statistics. The development of 'plyr' has
    been generously supported by 'Becton Dickinson'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://had.co.nz/plyr">http://had.co.nz/plyr</a>, <a href="https://github.com/hadley/plyr">https://github.com/hadley/plyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hadley/plyr/issues">https://github.com/hadley/plyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>abind, covr, doParallel, foreach, iterators, itertools,
tcltk, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-27 13:58:04 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-02 06:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='plyr'>plyr: the split-apply-combine paradigm for R.</h2><span id='topic+plyr'></span><span id='topic+plyr-package'></span>

<h3>Description</h3>

<p>The plyr package is a set of clean and consistent tools that implement the
split-apply-combine pattern in R. This is an extremely common pattern in
data analysis: you solve a complex problem by breaking it down into small
pieces, doing something to each piece and then combining the results back
together again.
</p>


<h3>Details</h3>

<p>The plyr functions are named according to what sort of data structure they
split up and what sort of data structure they return:
</p>

<dl>
<dt>a</dt><dd><p>array</p>
</dd>
<dt>l</dt><dd><p>list</p>
</dd>
<dt>d</dt><dd><p>data.frame</p>
</dd>
<dt>m</dt><dd><p>multiple inputs</p>
</dd>
<dt>r</dt><dd><p>repeat multiple times</p>
</dd>
<dt>_</dt><dd><p>nothing</p>
</dd>
</dl>

<p>So <code><a href="#topic+ddply">ddply</a></code> takes a data frame as input and returns a data frame
as output, and <code><a href="#topic+l_ply">l_ply</a></code> takes a list as input and returns nothing
as output.
</p>


<h3>Row names</h3>

<p>By design, no plyr function will preserve row names - in general it is too
hard to know what should be done with them for many of the operations
supported by plyr. If you want to preserve row names, use
<code><a href="#topic+name_rows">name_rows</a></code> to convert them into an explicit column in your
data frame, perform the plyr operations, and then use <code><a href="#topic+name_rows">name_rows</a></code>
again to convert the column back into row names.
</p>


<h3>Helpers</h3>

<p>Plyr also provides a set of helper functions for common data analysis
problems:
</p>

<ul>
<li> <p><code><a href="#topic+arrange">arrange</a></code>: re-order the rows of a data frame by
specifying the columns to order by
</p>
</li>
<li> <p><code><a href="#topic+mutate">mutate</a></code>: add new columns or modifying existing columns,
like <code><a href="base.html#topic+transform">transform</a></code>, but new columns can refer to other columns
that you just created.
</p>
</li>
<li> <p><code><a href="#topic+summarise">summarise</a></code>: like <code><a href="#topic+mutate">mutate</a></code> but create a
new data frame, not preserving any columns in the old data frame.
</p>
</li>
<li> <p><code><a href="#topic+join">join</a></code>: an adapation of <code><a href="base.html#topic+merge">merge</a></code> which is
more similar to SQL, and has a much faster implementation if you only
want to find the first match.
</p>
</li>
<li> <p><code><a href="#topic+match_df">match_df</a></code>: a version of <code><a href="#topic+join">join</a></code> that instead
of returning the two tables combined together, only returns the rows
in the first table that match the second.
</p>
</li>
<li> <p><code><a href="#topic+colwise">colwise</a></code>: make any function work colwise on a dataframe
</p>
</li>
<li> <p><code><a href="#topic+rename">rename</a></code>: easily rename columns in a data frame
</p>
</li>
<li> <p><code><a href="#topic+round_any">round_any</a></code>: round a number to any degree of precision
</p>
</li>
<li> <p><code><a href="#topic+count">count</a></code>: quickly count unique combinations and return
return as a data frame.
</p>
</li></ul>


<hr>
<h2 id='.'>Quote variables to create a list of unevaluated expressions for later
evaluation.</h2><span id='topic+.'></span><span id='topic+quoted'></span><span id='topic+is.quoted'></span>

<h3>Description</h3>

<p>This function is similar to <code><a href="base.html#topic+~">~</a></code> in that it is used to
capture the name of variables, not their current value.  This is used
throughout plyr to specify the names of variables (or more complicated
expressions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.(..., .env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="._+3A_...">...</code></td>
<td>
<p>unevaluated expressions to be recorded.  Specify names if you
want the set the names of the resultant variables</p>
</td></tr>
<tr><td><code id="._+3A_.env">.env</code></td>
<td>
<p>environment in which unbound symbols in <code>...</code> should be
evaluated.  Defaults to the environment in which <code>.</code> was executed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar tricks can be performed with <code><a href="base.html#topic+substitute">substitute</a></code>, but when
functions can be called in multiple ways it becomes increasingly tricky
to ensure that the values are extracted from the correct frame.  Substitute
tricks also make it difficult to program against the functions that use
them, while the <code>quoted</code> class provides
<code>as.quoted.character</code> to convert strings to the appropriate
data structure.
</p>


<h3>Value</h3>

<p>list of symbol and language primitives
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.(a, b, c)
.(first = a, second = b, third = c)
.(a ^ 2, b - d, log(c))
as.quoted(~ a + b + c)
as.quoted(a ~ b + c)
as.quoted(c("a", "b", "c"))

# Some examples using ddply - look at the column names
ddply(mtcars, "cyl", each(nrow, ncol))
ddply(mtcars, ~ cyl, each(nrow, ncol))
ddply(mtcars, .(cyl), each(nrow, ncol))
ddply(mtcars, .(log(cyl)), each(nrow, ncol))
ddply(mtcars, .(logcyl = log(cyl)), each(nrow, ncol))
ddply(mtcars, .(vs + am), each(nrow, ncol))
ddply(mtcars, .(vsam = vs + am), each(nrow, ncol))
</code></pre>

<hr>
<h2 id='+5B.split'>Subset splits.</h2><span id='topic++5B.split'></span>

<h3>Description</h3>

<p>Subset splits, ensuring that labels keep matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'split'
x[i, ...]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.split_+3A_x">x</code></td>
<td>
<p>split object</p>
</td></tr>
<tr><td><code id="+2B5B.split_+3A_i">i</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id="+2B5B.split_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='a_ply'>Split array, apply function, and discard results.</h2><span id='topic+a_ply'></span>

<h3>Description</h3>

<p>For each slice of an array, apply function and discard results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_ply(
  .data,
  .margins,
  .fun = NULL,
  ...,
  .expand = TRUE,
  .progress = "none",
  .inform = FALSE,
  .print = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a_ply_+3A_.data">.data</code></td>
<td>
<p>matrix, array or data frame to be processed</p>
</td></tr>
<tr><td><code id="a_ply_+3A_.margins">.margins</code></td>
<td>
<p>a vector giving the subscripts to split up <code>data</code> by.
1 splits up by rows, 2 by columns and c(1,2) by rows and columns, and so
on for higher dimensions</p>
</td></tr>
<tr><td><code id="a_ply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="a_ply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="a_ply_+3A_.expand">.expand</code></td>
<td>
<p>if <code>.data</code> is a data frame, should output be 1d (expand
= FALSE), with an element for each row; or nd (expand = TRUE), with a
dimension for each variable.</p>
</td></tr>
<tr><td><code id="a_ply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="a_ply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="a_ply_+3A_.print">.print</code></td>
<td>
<p>automatically print each result? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="a_ply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="a_ply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Input</h3>

<p>This function splits matrices, arrays and data frames by
dimensions
</p>


<h3>Output</h3>

<p>All output is discarded. This is useful for functions that you are
calling purely for their side effects like displaying plots or
saving output.
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other array input: 
<code><a href="#topic+aaply">aaply</a>()</code>,
<code><a href="#topic+adply">adply</a>()</code>,
<code><a href="#topic+alply">alply</a>()</code>
</p>
<p>Other no output: 
<code><a href="#topic+d_ply">d_ply</a>()</code>,
<code><a href="#topic+l_ply">l_ply</a>()</code>,
<code><a href="#topic+m_ply">m_ply</a>()</code>
</p>

<hr>
<h2 id='aaply'>Split array, apply function, and return results in an array.</h2><span id='topic+aaply'></span>

<h3>Description</h3>

<p>For each slice of an array, apply function, keeping results as an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aaply(
  .data,
  .margins,
  .fun = NULL,
  ...,
  .expand = TRUE,
  .progress = "none",
  .inform = FALSE,
  .drop = TRUE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aaply_+3A_.data">.data</code></td>
<td>
<p>matrix, array or data frame to be processed</p>
</td></tr>
<tr><td><code id="aaply_+3A_.margins">.margins</code></td>
<td>
<p>a vector giving the subscripts to split up <code>data</code> by.
1 splits up by rows, 2 by columns and c(1,2) by rows and columns, and so
on for higher dimensions</p>
</td></tr>
<tr><td><code id="aaply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="aaply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="aaply_+3A_.expand">.expand</code></td>
<td>
<p>if <code>.data</code> is a data frame, should output be 1d (expand
= FALSE), with an element for each row; or nd (expand = TRUE), with a
dimension for each variable.</p>
</td></tr>
<tr><td><code id="aaply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="aaply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="aaply_+3A_.drop">.drop</code></td>
<td>
<p>should extra dimensions of length 1 in the output be
dropped, simplifying the output.  Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="aaply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="aaply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is very similar to <code><a href="base.html#topic+apply">apply</a></code>, except that it will
always return an array, and when the function returns &gt;1 d data structures,
those dimensions are added on to the highest dimensions, rather than the
lowest dimensions.  This makes <code>aaply</code> idempotent, so that
<code>aaply(input, X, identity)</code> is equivalent to <code>aperm(input, X)</code>.
</p>


<h3>Value</h3>

<p>if results are atomic with same type and dimensionality, a
vector, matrix or array; otherwise, a list-array (a list with
dimensions)
</p>


<h3>Warning</h3>

<p>Contrary to <code><a href="#topic+alply">alply</a></code> and <code><a href="#topic+adply">adply</a></code>, passing a data
frame as first argument to <code>aaply</code> may lead to unexpected results
such as huge memory allocations.
</p>


<h3>Input</h3>

<p>This function splits matrices, arrays and data frames by
dimensions
</p>


<h3>Output</h3>

<p>If there are no results, then this function will return a vector of
length 0 (<code>vector()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other array input: 
<code><a href="#topic+a_ply">a_ply</a>()</code>,
<code><a href="#topic+adply">adply</a>()</code>,
<code><a href="#topic+alply">alply</a>()</code>
</p>
<p>Other array output: 
<code><a href="#topic+daply">daply</a>()</code>,
<code><a href="#topic+laply">laply</a>()</code>,
<code><a href="#topic+maply">maply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim(ozone)
aaply(ozone, 1, mean)
aaply(ozone, 1, mean, .drop = FALSE)
aaply(ozone, 3, mean)
aaply(ozone, c(1,2), mean)

dim(aaply(ozone, c(1,2), mean))
dim(aaply(ozone, c(1,2), mean, .drop = FALSE))

aaply(ozone, 1, each(min, max))
aaply(ozone, 3, each(min, max))

standardise &lt;- function(x) (x - min(x)) / (max(x) - min(x))
aaply(ozone, 3, standardise)
aaply(ozone, 1:2, standardise)

aaply(ozone, 1:2, diff)
</code></pre>

<hr>
<h2 id='adply'>Split array, apply function, and return results in a data frame.</h2><span id='topic+adply'></span>

<h3>Description</h3>

<p>For each slice of an array, apply function then combine results into a data
frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adply(
  .data,
  .margins,
  .fun = NULL,
  ...,
  .expand = TRUE,
  .progress = "none",
  .inform = FALSE,
  .parallel = FALSE,
  .paropts = NULL,
  .id = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adply_+3A_.data">.data</code></td>
<td>
<p>matrix, array or data frame to be processed</p>
</td></tr>
<tr><td><code id="adply_+3A_.margins">.margins</code></td>
<td>
<p>a vector giving the subscripts to split up <code>data</code> by.
1 splits up by rows, 2 by columns and c(1,2) by rows and columns, and so
on for higher dimensions</p>
</td></tr>
<tr><td><code id="adply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="adply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="adply_+3A_.expand">.expand</code></td>
<td>
<p>if <code>.data</code> is a data frame, should output be 1d (expand
= FALSE), with an element for each row; or nd (expand = TRUE), with a
dimension for each variable.</p>
</td></tr>
<tr><td><code id="adply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="adply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="adply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="adply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
<tr><td><code id="adply_+3A_.id">.id</code></td>
<td>
<p>name(s) of the index column(s).
Pass <code>NULL</code> to avoid creation of the index column(s).
Omit or pass <code>NA</code> to use the default names
<code>"X1"</code>, <code>"X2"</code>, ....
Otherwise, this argument must have the same length as
<code>.margins</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, as described in the output section.
</p>


<h3>Input</h3>

<p>This function splits matrices, arrays and data frames by
dimensions
</p>


<h3>Output</h3>

<p>The most unambiguous behaviour is achieved when <code>.fun</code> returns a
data frame - in that case pieces will be combined with
<code><a href="#topic+rbind.fill">rbind.fill</a></code>.  If <code>.fun</code> returns an atomic vector of
fixed length, it will be <code>rbind</code>ed together and converted to a data
frame. Any other values will result in an error.
</p>
<p>If there are no results, then this function will return a data
frame with zero rows and columns (<code>data.frame()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other array input: 
<code><a href="#topic+a_ply">a_ply</a>()</code>,
<code><a href="#topic+aaply">aaply</a>()</code>,
<code><a href="#topic+alply">alply</a>()</code>
</p>
<p>Other data frame output: 
<code><a href="#topic+ddply">ddply</a>()</code>,
<code><a href="#topic+ldply">ldply</a>()</code>,
<code><a href="#topic+mdply">mdply</a>()</code>
</p>

<hr>
<h2 id='alply'>Split array, apply function, and return results in a list.</h2><span id='topic+alply'></span>

<h3>Description</h3>

<p>For each slice of an array, apply function then combine results into a
list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alply(
  .data,
  .margins,
  .fun = NULL,
  ...,
  .expand = TRUE,
  .progress = "none",
  .inform = FALSE,
  .parallel = FALSE,
  .paropts = NULL,
  .dims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alply_+3A_.data">.data</code></td>
<td>
<p>matrix, array or data frame to be processed</p>
</td></tr>
<tr><td><code id="alply_+3A_.margins">.margins</code></td>
<td>
<p>a vector giving the subscripts to split up <code>data</code> by.
1 splits up by rows, 2 by columns and c(1,2) by rows and columns, and so
on for higher dimensions</p>
</td></tr>
<tr><td><code id="alply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="alply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="alply_+3A_.expand">.expand</code></td>
<td>
<p>if <code>.data</code> is a data frame, should output be 1d (expand
= FALSE), with an element for each row; or nd (expand = TRUE), with a
dimension for each variable.</p>
</td></tr>
<tr><td><code id="alply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="alply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="alply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="alply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
<tr><td><code id="alply_+3A_.dims">.dims</code></td>
<td>
<p>if <code>TRUE</code>, copy over dimensions and names from input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list will have &quot;dims&quot; and &quot;dimnames&quot; corresponding to the
margins given. For instance <code>alply(x, c(3,2), ...)</code> where
<code>x</code> has dims <code>c(4,3,2)</code> will give a result with dims
<code>c(2,3)</code>.
</p>
<p><code>alply</code> is somewhat similar to <code><a href="base.html#topic+apply">apply</a></code> for cases
where the results are not atomic.
</p>


<h3>Value</h3>

<p>list of results
</p>


<h3>Input</h3>

<p>This function splits matrices, arrays and data frames by
dimensions
</p>


<h3>Output</h3>

<p>If there are no results, then this function will return
a list of length 0 (<code>list()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other array input: 
<code><a href="#topic+a_ply">a_ply</a>()</code>,
<code><a href="#topic+aaply">aaply</a>()</code>,
<code><a href="#topic+adply">adply</a>()</code>
</p>
<p>Other list output: 
<code><a href="#topic+dlply">dlply</a>()</code>,
<code><a href="#topic+llply">llply</a>()</code>,
<code><a href="#topic+mlply">mlply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alply(ozone, 3, quantile)
alply(ozone, 3, function(x) table(round(x)))
</code></pre>

<hr>
<h2 id='amv_dim'>Dimensions.</h2><span id='topic+amv_dim'></span>

<h3>Description</h3>

<p>Consistent dimensions for vectors, matrices and arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amv_dim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amv_dim_+3A_x">x</code></td>
<td>
<p>array, matrix or vector</p>
</td></tr>
</table>

<hr>
<h2 id='amv_dimnames'>Dimension names.</h2><span id='topic+amv_dimnames'></span>

<h3>Description</h3>

<p>Consistent dimnames for vectors, matrices and arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amv_dimnames(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amv_dimnames_+3A_x">x</code></td>
<td>
<p>array, matrix or vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="base.html#topic+dimnames">dimnames</a></code> no part of the output will ever be
null.  If a component of dimnames is omitted, <code>amv_dimnames</code>
will return an integer sequence of the appropriate length.
</p>

<hr>
<h2 id='arrange'>Order a data frame by its colums.</h2><span id='topic+arrange'></span>

<h3>Description</h3>

<p>This function completes the subsetting, transforming and ordering triad
with a function that works in a similar way to <code><a href="base.html#topic+subset">subset</a></code> and
<code><a href="base.html#topic+transform">transform</a></code> but for reordering a data frame by its columns.
This saves a lot of typing!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange(df, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_+3A_df">df</code></td>
<td>
<p>data frame to reorder</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>expressions evaluated in the context of <code>df</code> and then fed
to <code><a href="base.html#topic+order">order</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code> for sorting function in the base package
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sort mtcars data by cylinder and displacement
mtcars[with(mtcars, order(cyl, disp)), ]
# Same result using arrange: no need to use with(), as the context is implicit
# NOTE: plyr functions do NOT preserve row.names
arrange(mtcars, cyl, disp)
# Let's keep the row.names in this example
myCars = cbind(vehicle=row.names(mtcars), mtcars)
arrange(myCars, cyl, disp)
# Sort with displacement in descending order
arrange(myCars, cyl, desc(disp))
</code></pre>

<hr>
<h2 id='as.data.frame.function'>Make a function return a data frame.</h2><span id='topic+as.data.frame.function'></span>

<h3>Description</h3>

<p>Create a new function that returns the existing function wrapped in a
data.frame with a single column, <code>value</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
as.data.frame(x, row.names, optional, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.function_+3A_x">x</code></td>
<td>
<p>function to make return a data frame</p>
</td></tr>
<tr><td><code id="as.data.frame.function_+3A_row.names">row.names</code></td>
<td>
<p>necessary to match the generic, but not used</p>
</td></tr>
<tr><td><code id="as.data.frame.function_+3A_optional">optional</code></td>
<td>
<p>necessary to match the generic, but not used</p>
</td></tr>
<tr><td><code id="as.data.frame.function_+3A_...">...</code></td>
<td>
<p>necessary to match the generic, but not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is useful when calling <code>*dply</code> functions with a function that
returns a vector, and you want the output in rows, rather than columns.
The <code>value</code> column is always created, even for empty inputs.
</p>

<hr>
<h2 id='as.list.split'>Convert split list to regular list.</h2><span id='topic+as.list.split'></span>

<h3>Description</h3>

<p>Strip off label related attributed to make a strip list as regular list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'split'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.list.split_+3A_x">x</code></td>
<td>
<p>object to convert to a list</p>
</td></tr>
<tr><td><code id="as.list.split_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='as.quoted'>Convert input to quoted variables.</h2><span id='topic+as.quoted'></span>

<h3>Description</h3>

<p>Convert characters, formulas and calls to quoted .variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.quoted(x, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.quoted_+3A_x">x</code></td>
<td>
<p>input to quote</p>
</td></tr>
<tr><td><code id="as.quoted_+3A_env">env</code></td>
<td>
<p>environment in which unbound symbols in expression should be
evaluated. Defaults to the environment in which <code>as.quoted</code> was
executed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is called by default on all plyr functions that take a
<code>.variables</code> argument, so that equivalent forms can be used anywhere.
</p>
<p>Currently conversions exist for character vectors, formulas and
call objects.
</p>


<h3>Value</h3>

<p>a list of quoted variables
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quoted">.</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.quoted(c("a", "b", "log(d)"))
as.quoted(a ~ b + log(d))
</code></pre>

<hr>
<h2 id='baseball'>Yearly batting records for all major league baseball players</h2><span id='topic+baseball'></span>

<h3>Description</h3>

<p>This data frame contains batting statistics for a subset of players
collected from <a href="http://www.baseball-databank.org/">http://www.baseball-databank.org/</a>. There are a total
of 21,699 records, covering 1,228 players from 1871 to 2007. Only players
with more 15 seasons of play are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseball
</code></pre>


<h3>Format</h3>

<p>A 21699 x 22 data frame
</p>


<h3>Variables</h3>

<p>Variables:
</p>

<ul>
<li><p> id, unique player id
</p>
</li>
<li><p> year, year of data
</p>
</li>
<li><p> stint
</p>
</li>
<li><p> team, team played for
</p>
</li>
<li><p> lg, league
</p>
</li>
<li><p> g, number of games
</p>
</li>
<li><p> ab, number of times at bat
</p>
</li>
<li><p> r, number of runs
</p>
</li>
<li><p> h, hits, times reached base because of a batted, fair ball without
error by the defense
</p>
</li>
<li><p> X2b, hits on which the batter reached second base safely
</p>
</li>
<li><p> X3b, hits on which the batter reached third base safely
</p>
</li>
<li><p> hr, number of home runs
</p>
</li>
<li><p> rbi, runs batted in
</p>
</li>
<li><p> sb, stolen bases
</p>
</li>
<li><p> cs, caught stealing
</p>
</li>
<li><p> bb, base on balls (walk)
</p>
</li>
<li><p> so, strike outs
</p>
</li>
<li><p> ibb, intentional base on balls
</p>
</li>
<li><p> hbp, hits by pitch
</p>
</li>
<li><p> sh, sacrifice hits
</p>
</li>
<li><p> sf, sacrifice flies
</p>
</li>
<li><p> gidp, ground into double play
</p>
</li></ul>



<h3>References</h3>

<p><a href="http://www.baseball-databank.org/">http://www.baseball-databank.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>baberuth &lt;- subset(baseball, id == "ruthba01")
baberuth$cyear &lt;- baberuth$year - min(baberuth$year) + 1

calculate_cyear &lt;- function(df) {
  mutate(df,
    cyear = year - min(year),
    cpercent = cyear / (max(year) - min(year))
  )
}

baseball &lt;- ddply(baseball, .(id), calculate_cyear)
baseball &lt;- subset(baseball, ab &gt;= 25)

model &lt;- function(df) {
  lm(rbi / ab ~ cyear, data=df)
}
model(baberuth)
models &lt;- dlply(baseball, .(id), model)
</code></pre>

<hr>
<h2 id='colwise'>Column-wise function.</h2><span id='topic+colwise'></span><span id='topic+catcolwise'></span><span id='topic+numcolwise'></span>

<h3>Description</h3>

<p>Turn a function that operates on a vector into a function that operates
column-wise on a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colwise(.fun, .cols = true, ...)

catcolwise(.fun, ...)

numcolwise(.fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colwise_+3A_.fun">.fun</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="colwise_+3A_.cols">.cols</code></td>
<td>
<p>either a function that tests columns for inclusion, or a
quoted object giving which columns to process</p>
</td></tr>
<tr><td><code id="colwise_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>catcolwise</code> and <code>numcolwise</code> provide version that only operate
on discrete and numeric variables respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Count number of missing values
nmissing &lt;- function(x) sum(is.na(x))

# Apply to every column in a data frame
colwise(nmissing)(baseball)
# This syntax looks a little different.  It is shorthand for the
# the following:
f &lt;- colwise(nmissing)
f(baseball)

# This is particularly useful in conjunction with d*ply
ddply(baseball, .(year), colwise(nmissing))

# To operate only on specified columns, supply them as the second
# argument.  Many different forms are accepted.
ddply(baseball, .(year), colwise(nmissing, .(sb, cs, so)))
ddply(baseball, .(year), colwise(nmissing, c("sb", "cs", "so")))
ddply(baseball, .(year), colwise(nmissing, ~ sb + cs + so))

# Alternatively, you can specify a boolean function that determines
# whether or not a column should be included
ddply(baseball, .(year), colwise(nmissing, is.character))
ddply(baseball, .(year), colwise(nmissing, is.numeric))
ddply(baseball, .(year), colwise(nmissing, is.discrete))

# These last two cases are particularly common, so some shortcuts are
# provided:
ddply(baseball, .(year), numcolwise(nmissing))
ddply(baseball, .(year), catcolwise(nmissing))

# You can supply additional arguments to either colwise, or the function
# it generates:
numcolwise(mean)(baseball, na.rm = TRUE)
numcolwise(mean, na.rm = TRUE)(baseball)
</code></pre>

<hr>
<h2 id='compact'>Compact list.</h2><span id='topic+compact'></span>

<h3>Description</h3>

<p>Remove all NULL entries from a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact(l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compact_+3A_l">l</code></td>
<td>
<p>list</p>
</td></tr>
</table>

<hr>
<h2 id='count'>Count the number of occurences.</h2><span id='topic+count'></span>

<h3>Description</h3>

<p>Equivalent to <code>as.data.frame(table(x))</code>, but does not include
combinations with zero counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(df, vars = NULL, wt_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_+3A_df">df</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="count_+3A_vars">vars</code></td>
<td>
<p>variables to count unique values of</p>
</td></tr>
<tr><td><code id="count_+3A_wt_var">wt_var</code></td>
<td>
<p>optional variable to weight by - if this is non-NULL, count
will sum up the value of this variable for each combination of id
variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Speed-wise count is competitive with <code><a href="base.html#topic+table">table</a></code> for single
variables, but it really comes into its own when summarising multiple
dimensions because it only counts combinations that actually occur in the
data.
</p>
<p>Compared to <code><a href="base.html#topic+table">table</a></code> + <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>, <code>count</code>
also preserves the type of the identifier variables, instead of converting
them to characters/factors.
</p>


<h3>Value</h3>

<p>a data frame with label and freq columns
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code> for related functionality in the base package
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Count of each value of "id" in the first 100 cases
count(baseball[1:100,], vars = "id")
# Count of ids, weighted by their "g" loading
count(baseball[1:100,], vars = "id", wt_var = "g")
count(baseball, "id", "ab")
count(baseball, "lg")
# How many stints do players do?
count(baseball, "stint")
# Count of times each player appeared in each of the years they played
count(baseball[1:100,], c("id", "year"))
# Count of counts
count(count(baseball[1:100,], c("id", "year")), "id", "freq")
count(count(baseball, c("id", "year")), "freq")
</code></pre>

<hr>
<h2 id='create_progress_bar'>Create progress bar.</h2><span id='topic+create_progress_bar'></span>

<h3>Description</h3>

<p>Create progress bar object from text string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_progress_bar(name = "none", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_progress_bar_+3A_name">name</code></td>
<td>
<p>type of progress bar to create</p>
</td></tr>
<tr><td><code id="create_progress_bar_+3A_...">...</code></td>
<td>
<p>other arguments passed onto progress bar function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Progress bars give feedback on how apply step is proceeding.  This
is mainly useful for long running functions, as for short functions, the
time taken up by splitting and combining may be on the same order (or
longer) as the apply step.  Additionally, for short functions, the time
needed to update the progress bar can significantly slow down the process.
For the trivial examples below, using the tk progress bar slows things down
by a factor of a thousand.
</p>
<p>Note the that progress bar is approximate, and if the time taken by
individual function applications is highly non-uniform it may not be very
informative of the time left.
</p>
<p>There are currently four types of progress bar:  &quot;none&quot;, &quot;text&quot;, &quot;tk&quot;, and
&quot;win&quot;.  See the individual documentation for more details.  In plyr
functions, these can either be specified by name, or you can create the
progress bar object yourself if you want more control over its apperance.
See the examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+progress_none">progress_none</a></code>, <code><a href="#topic+progress_text">progress_text</a></code>, <code><a href="#topic+progress_tk">progress_tk</a></code>, <code><a href="#topic+progress_win">progress_win</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># No progress bar
l_ply(1:100, identity, .progress = "none")
## Not run: 
# Use the Tcl/Tk interface
l_ply(1:100, identity, .progress = "tk")

## End(Not run)
# Text-based progress (|======|)
l_ply(1:100, identity, .progress = "text")
# Choose a progress character, run a length of time you can see
l_ply(1:10000, identity, .progress = progress_text(char = "."))
</code></pre>

<hr>
<h2 id='d_ply'>Split data frame, apply function, and discard results.</h2><span id='topic+d_ply'></span>

<h3>Description</h3>

<p>For each subset of a data frame, apply function and discard results.
To apply a function for each row, use <code><a href="#topic+a_ply">a_ply</a></code> with
<code>.margins</code> set to <code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_ply(
  .data,
  .variables,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .drop = TRUE,
  .print = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d_ply_+3A_.data">.data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="d_ply_+3A_.variables">.variables</code></td>
<td>
<p>variables to split data frame by, as <code><a href="#topic+as.quoted">as.quoted</a></code>
variables, a formula or character vector</p>
</td></tr>
<tr><td><code id="d_ply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="d_ply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="d_ply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="d_ply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="d_ply_+3A_.drop">.drop</code></td>
<td>
<p>should combinations of variables that do not appear in the
input data be preserved (FALSE) or dropped (TRUE, default)</p>
</td></tr>
<tr><td><code id="d_ply_+3A_.print">.print</code></td>
<td>
<p>automatically print each result? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="d_ply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="d_ply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Input</h3>

<p>This function splits data frames by variables.
</p>


<h3>Output</h3>

<p>All output is discarded. This is useful for functions that you are
calling purely for their side effects like displaying plots or
saving output.
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other data frame input: 
<code><a href="#topic+daply">daply</a>()</code>,
<code><a href="#topic+ddply">ddply</a>()</code>,
<code><a href="#topic+dlply">dlply</a>()</code>
</p>
<p>Other no output: 
<code><a href="#topic+a_ply">a_ply</a>()</code>,
<code><a href="#topic+l_ply">l_ply</a>()</code>,
<code><a href="#topic+m_ply">m_ply</a>()</code>
</p>

<hr>
<h2 id='daply'>Split data frame, apply function, and return results in an array.</h2><span id='topic+daply'></span>

<h3>Description</h3>

<p>For each subset of data frame, apply function then combine results into
an array.  <code>daply</code> with a function that operates column-wise is
similar to <code><a href="stats.html#topic+aggregate">aggregate</a></code>.
To apply a function for each row, use <code><a href="#topic+aaply">aaply</a></code> with
<code>.margins</code> set to <code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daply(
  .data,
  .variables,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .drop_i = TRUE,
  .drop_o = TRUE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="daply_+3A_.data">.data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="daply_+3A_.variables">.variables</code></td>
<td>
<p>variables to split data frame by, as quoted
variables, a formula or character vector</p>
</td></tr>
<tr><td><code id="daply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="daply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="daply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="daply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="daply_+3A_.drop_i">.drop_i</code></td>
<td>
<p>should combinations of variables that do not appear in the
input data be preserved (FALSE) or dropped (TRUE, default)</p>
</td></tr>
<tr><td><code id="daply_+3A_.drop_o">.drop_o</code></td>
<td>
<p>should extra dimensions of length 1 in the output be
dropped, simplifying the output.  Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="daply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="daply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if results are atomic with same type and dimensionality, a
vector, matrix or array; otherwise, a list-array (a list with
dimensions)
</p>


<h3>Input</h3>

<p>This function splits data frames by variables.
</p>


<h3>Output</h3>

<p>If there are no results, then this function will return a vector of
length 0 (<code>vector()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other array output: 
<code><a href="#topic+aaply">aaply</a>()</code>,
<code><a href="#topic+laply">laply</a>()</code>,
<code><a href="#topic+maply">maply</a>()</code>
</p>
<p>Other data frame input: 
<code><a href="#topic+d_ply">d_ply</a>()</code>,
<code><a href="#topic+ddply">ddply</a>()</code>,
<code><a href="#topic+dlply">dlply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daply(baseball, .(year), nrow)

# Several different ways of summarising by variables that should not be
# included in the summary

daply(baseball[, c(2, 6:9)], .(year), colwise(mean))
daply(baseball[, 6:9], .(baseball$year), colwise(mean))
daply(baseball, .(year), function(df) colwise(mean)(df[, 6:9]))
</code></pre>

<hr>
<h2 id='ddply'>Split data frame, apply function, and return results in a data frame.</h2><span id='topic+ddply'></span>

<h3>Description</h3>

<p>For each subset of a data frame, apply function then combine results into a
data frame.
To apply a function for each row, use <code><a href="#topic+adply">adply</a></code> with
<code>.margins</code> set to <code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddply(
  .data,
  .variables,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .drop = TRUE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ddply_+3A_.data">.data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="ddply_+3A_.variables">.variables</code></td>
<td>
<p>variables to split data frame by, as <code><a href="#topic+as.quoted">as.quoted</a></code>
variables, a formula or character vector</p>
</td></tr>
<tr><td><code id="ddply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="ddply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="ddply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="ddply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="ddply_+3A_.drop">.drop</code></td>
<td>
<p>should combinations of variables that do not appear in the
input data be preserved (FALSE) or dropped (TRUE, default)</p>
</td></tr>
<tr><td><code id="ddply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="ddply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, as described in the output section.
</p>


<h3>Input</h3>

<p>This function splits data frames by variables.
</p>


<h3>Output</h3>

<p>The most unambiguous behaviour is achieved when <code>.fun</code> returns a
data frame - in that case pieces will be combined with
<code><a href="#topic+rbind.fill">rbind.fill</a></code>.  If <code>.fun</code> returns an atomic vector of
fixed length, it will be <code>rbind</code>ed together and converted to a data
frame. Any other values will result in an error.
</p>
<p>If there are no results, then this function will return a data
frame with zero rows and columns (<code>data.frame()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tapply">tapply</a></code> for similar functionality in the base package
</p>
<p>Other data frame input: 
<code><a href="#topic+d_ply">d_ply</a>()</code>,
<code><a href="#topic+daply">daply</a>()</code>,
<code><a href="#topic+dlply">dlply</a>()</code>
</p>
<p>Other data frame output: 
<code><a href="#topic+adply">adply</a>()</code>,
<code><a href="#topic+ldply">ldply</a>()</code>,
<code><a href="#topic+mdply">mdply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Summarize a dataset by two variables
dfx &lt;- data.frame(
  group = c(rep('A', 8), rep('B', 15), rep('C', 6)),
  sex = sample(c("M", "F"), size = 29, replace = TRUE),
  age = runif(n = 29, min = 18, max = 54)
)

# Note the use of the '.' function to allow
# group and sex to be used without quoting
ddply(dfx, .(group, sex), summarize,
 mean = round(mean(age), 2),
 sd = round(sd(age), 2))

# An example using a formula for .variables
ddply(baseball[1:100,], ~ year, nrow)
# Applying two functions; nrow and ncol
ddply(baseball, .(lg), c("nrow", "ncol"))

# Calculate mean runs batted in for each year
rbi &lt;- ddply(baseball, .(year), summarise,
  mean_rbi = mean(rbi, na.rm = TRUE))
# Plot a line chart of the result
plot(mean_rbi ~ year, type = "l", data = rbi)

# make new variable career_year based on the
# start year for each player (id)
base2 &lt;- ddply(baseball, .(id), mutate,
 career_year = year - min(year) + 1
)
</code></pre>

<hr>
<h2 id='defaults'>Set defaults.</h2><span id='topic+defaults'></span>

<h3>Description</h3>

<p>Convient method for combining a list of values with their defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaults(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defaults_+3A_x">x</code></td>
<td>
<p>list of values</p>
</td></tr>
<tr><td><code id="defaults_+3A_y">y</code></td>
<td>
<p>defaults</p>
</td></tr>
</table>

<hr>
<h2 id='desc'>Descending order.</h2><span id='topic+desc'></span>

<h3>Description</h3>

<p>Transform a vector into a format that will be sorted in descending order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="desc_+3A_x">x</code></td>
<td>
<p>vector to transform</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>desc(1:10)
desc(factor(letters))
first_day &lt;- seq(as.Date("1910/1/1"), as.Date("1920/1/1"), "years")
desc(first_day)
</code></pre>

<hr>
<h2 id='dims'>Number of dimensions.</h2><span id='topic+dims'></span>

<h3>Description</h3>

<p>Number of dimensions of an array or vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dims(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dims_+3A_x">x</code></td>
<td>
<p>array</p>
</td></tr>
</table>

<hr>
<h2 id='dlply'>Split data frame, apply function, and return results in a list.</h2><span id='topic+dlply'></span>

<h3>Description</h3>

<p>For each subset of a data frame, apply function then combine results into a
list. <code>dlply</code> is similar to <code><a href="base.html#topic+by">by</a></code> except that the results
are returned in a different format.
To apply a function for each row, use <code><a href="#topic+alply">alply</a></code> with
<code>.margins</code> set to <code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlply(
  .data,
  .variables,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .drop = TRUE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlply_+3A_.data">.data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="dlply_+3A_.variables">.variables</code></td>
<td>
<p>variables to split data frame by, as <code><a href="#topic+as.quoted">as.quoted</a></code>
variables, a formula or character vector</p>
</td></tr>
<tr><td><code id="dlply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="dlply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="dlply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="dlply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="dlply_+3A_.drop">.drop</code></td>
<td>
<p>should combinations of variables that do not appear in the
input data be preserved (FALSE) or dropped (TRUE, default)</p>
</td></tr>
<tr><td><code id="dlply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="dlply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of results
</p>


<h3>Input</h3>

<p>This function splits data frames by variables.
</p>


<h3>Output</h3>

<p>If there are no results, then this function will return
a list of length 0 (<code>list()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other data frame input: 
<code><a href="#topic+d_ply">d_ply</a>()</code>,
<code><a href="#topic+daply">daply</a>()</code>,
<code><a href="#topic+ddply">ddply</a>()</code>
</p>
<p>Other list output: 
<code><a href="#topic+alply">alply</a>()</code>,
<code><a href="#topic+llply">llply</a>()</code>,
<code><a href="#topic+mlply">mlply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>linmod &lt;- function(df) {
  lm(rbi ~ year, data = mutate(df, year = year - min(year)))
}
models &lt;- dlply(baseball, .(id), linmod)
models[[1]]

coef &lt;- ldply(models, coef)
with(coef, plot(`(Intercept)`, year))
qual &lt;- laply(models, function(mod) summary(mod)$r.squared)
hist(qual)
</code></pre>

<hr>
<h2 id='each'>Aggregate multiple functions into a single function.</h2><span id='topic+each'></span>

<h3>Description</h3>

<p>Combine multiple functions into a single function returning a named vector
of outputs.
Note: you cannot supply additional parameters for the summary functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>each(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="each_+3A_...">...</code></td>
<td>
<p>functions to combine. each function should produce a single
number as output</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summarise">summarise</a></code> for applying summary functions to data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Call min() and max() on the vector 1:10
each(min, max)(1:10)
# This syntax looks a little different.  It is shorthand for the
# the following:
f&lt;- each(min, max)
f(1:10)
# Three equivalent ways to call min() and max() on the vector 1:10
each("min", "max")(1:10)
each(c("min", "max"))(1:10)
each(c(min, max))(1:10)
# Call length(), min() and max() on a random normal vector
each(length, mean, var)(rnorm(100))
</code></pre>

<hr>
<h2 id='empty'>Check if a data frame is empty.</h2><span id='topic+empty'></span>

<h3>Description</h3>

<p>Empty if it's null or it has 0 rows or columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="empty_+3A_df">df</code></td>
<td>
<p>data frame to check</p>
</td></tr>
</table>

<hr>
<h2 id='eval.quoted'>Evaluate a quoted list of variables.</h2><span id='topic+eval.quoted'></span>

<h3>Description</h3>

<p>Evaluates quoted variables in specified environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.quoted(exprs, envir = NULL, enclos = NULL, try = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.quoted_+3A_exprs">exprs</code></td>
<td>
<p>quoted object to evaluate</p>
</td></tr>
<tr><td><code id="eval.quoted_+3A_try">try</code></td>
<td>
<p>if TRUE, return <code>NULL</code> if evaluation unsuccessful</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='failwith'>Fail with specified value.</h2><span id='topic+failwith'></span>

<h3>Description</h3>

<p>Modify a function so that it returns a default value when there is an
error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>failwith(default = NULL, f, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="failwith_+3A_default">default</code></td>
<td>
<p>default value</p>
</td></tr>
<tr><td><code id="failwith_+3A_f">f</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="failwith_+3A_quiet">quiet</code></td>
<td>
<p>all error messages be suppressed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+try_default">try_default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) if (x == 1) stop("Error!") else 1
## Not run: 
f(1)
f(2)

## End(Not run)

safef &lt;- failwith(NULL, f)
safef(1)
safef(2)
</code></pre>

<hr>
<h2 id='here'>Capture current evaluation context.</h2><span id='topic+here'></span>

<h3>Description</h3>

<p>This function captures the current context, making it easier
to use <code>**ply</code> with functions that do special evaluation and
need access to the environment where ddply was called from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>here(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="here_+3A_f">f</code></td>
<td>
<p>a function that does non-standard evaluation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Meilstrup, <a href="https://github.com/crowding">https://github.com/crowding</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(a = rep(c("a","b"), each = 10), b = 1:20)
f1 &lt;- function(label) {
   ddply(df, "a", mutate, label = paste(label, b))
}
## Not run: f1("name:")
# Doesn't work because mutate can't find label in the current scope

f2 &lt;- function(label) {
   ddply(df, "a", here(mutate), label = paste(label, b))
}
f2("name:")
# Works :)
</code></pre>

<hr>
<h2 id='id'>Compute a unique numeric id for each unique row in a data frame.</h2><span id='topic+id'></span><span id='topic+ninteraction'></span>

<h3>Description</h3>

<p>Properties:
</p>

<ul>
<li> <p><code>order(id)</code> is equivalent to <code>do.call(order, df)</code>
</p>
</li>
<li><p> rows containing the same data have the same value
</p>
</li>
<li><p> if <code>drop = FALSE</code> then room for all possibilites
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>id(.variables, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id_+3A_.variables">.variables</code></td>
<td>
<p>list of variables</p>
</td></tr>
<tr><td><code id="id_+3A_drop">drop</code></td>
<td>
<p>drop unusued factor levels?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with attribute n, giving total number of
possibilities
</p>


<h3>See Also</h3>

<p><code><a href="#topic+id_var">id_var</a></code>
</p>

<hr>
<h2 id='id_var'>Numeric id for a vector.</h2><span id='topic+id_var'></span>

<h3>Description</h3>

<p>Numeric id for a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_var(x, drop = FALSE)
</code></pre>

<hr>
<h2 id='idata.frame'>Construct an immutable data frame.</h2><span id='topic+idata.frame'></span>

<h3>Description</h3>

<p>An immutable data frame works like an ordinary data frame, except that when
you subset it, it returns a reference to the original data frame, not a
a copy. This makes subsetting substantially faster and has a big impact
when you are working with large datasets with many groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idata.frame(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idata.frame_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is still a little experimental, so please let me know if you
run into any problems.
</p>


<h3>Value</h3>

<p>an immutable data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.time(dlply(baseball, "id", nrow))
system.time(dlply(idata.frame(baseball), "id", nrow))
</code></pre>

<hr>
<h2 id='indexed_array'>An indexed array.</h2><span id='topic+indexed_array'></span><span id='topic++5B+5B.indexed_array'></span><span id='topic+names.indexed_array'></span><span id='topic+length.indexed_array'></span>

<h3>Description</h3>

<p>Create a indexed array, a space efficient way of indexing into a large
array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexed_array(env, index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indexed_array_+3A_env">env</code></td>
<td>
<p>environment containing data frame</p>
</td></tr>
<tr><td><code id="indexed_array_+3A_index">index</code></td>
<td>
<p>list of indices</p>
</td></tr>
</table>

<hr>
<h2 id='indexed_df'>An indexed data frame.</h2><span id='topic+indexed_df'></span>

<h3>Description</h3>

<p>Create a indexed list, a space efficient way of indexing into a large data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexed_df(data, index, vars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indexed_df_+3A_data">data</code></td>
<td>
<p>environment containing data frame</p>
</td></tr>
<tr><td><code id="indexed_df_+3A_index">index</code></td>
<td>
<p>list of indices</p>
</td></tr>
<tr><td><code id="indexed_df_+3A_vars">vars</code></td>
<td>
<p>a character vector giving the variables used for subsetting</p>
</td></tr>
</table>

<hr>
<h2 id='is.discrete'>Determine if a vector is discrete.</h2><span id='topic+is.discrete'></span>

<h3>Description</h3>

<p>A discrete vector is a factor or a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.discrete(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.discrete_+3A_x">x</code></td>
<td>
<p>vector to test</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is.discrete(1:10)
is.discrete(c("a", "b", "c"))
is.discrete(factor(c("a", "b", "c")))
</code></pre>

<hr>
<h2 id='is.formula'>Is a formula?
Checks if argument is a formula</h2><span id='topic+is.formula'></span>

<h3>Description</h3>

<p>Is a formula?
Checks if argument is a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.formula(x)
</code></pre>

<hr>
<h2 id='isplit2'>Split iterator that returns values, not indices.</h2><span id='topic+isplit2'></span>

<h3>Description</h3>

<p>Split iterator that returns values, not indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isplit2(x, f, drop = FALSE, ...)
</code></pre>


<h3>Warning</h3>

<p>Deprecated, do not use in new code.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plyr-deprecated">plyr-deprecated</a></code>
</p>

<hr>
<h2 id='join'>Join two data frames together.</h2><span id='topic+join'></span>

<h3>Description</h3>

<p>Join, like merge, is designed for the types of problems
where you would use a sql join.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(x, y, by = NULL, type = "left", match = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="join_+3A_y">y</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="join_+3A_by">by</code></td>
<td>
<p>character vector of variable names to join by. If omitted, will
match on all common variables.</p>
</td></tr>
<tr><td><code id="join_+3A_type">type</code></td>
<td>
<p>type of join: left (default), right, inner or full.  See
details for more information.</p>
</td></tr>
<tr><td><code id="join_+3A_match">match</code></td>
<td>
<p>how should duplicate ids be matched? Either match just the
<code>"first"</code> matching row, or match <code>"all"</code> matching rows. Defaults
to <code>"all"</code> for compatibility with merge, but <code>"first"</code> is
significantly faster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The four join types return:
</p>

<ul>
<li> <p><code>inner</code>:  only rows with matching keys in both x and y
</p>
</li>
<li> <p><code>left</code>:   all rows in x, adding matching columns from y
</p>
</li>
<li> <p><code>right</code>:  all rows in y, adding matching columns from x
</p>
</li>
<li> <p><code>full</code>:   all rows in x with matching columns in y, then the
rows of y that don't match x.
</p>
</li></ul>

<p>Note that from plyr 1.5, <code>join</code> will (by default) return all matches,
not just the first match, as it did previously.
</p>
<p>Unlike merge, preserves the order of x no matter what join type is used.
If needed, rows from y will be added to the bottom.  Join is often faster
than merge, although it is somewhat less featureful - it currently offers
no way to rename output or merge on different variables in the x and y
data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>first &lt;- ddply(baseball, "id", summarise, first = min(year))
system.time(b2 &lt;- merge(baseball, first, by = "id", all.x = TRUE))
system.time(b3 &lt;- join(baseball, first, by = "id"))

b2 &lt;- arrange(b2, id, year, stint)
b3 &lt;- arrange(b3, id, year, stint)
stopifnot(all.equal(b2, b3))
</code></pre>

<hr>
<h2 id='join_all'>Recursively join a list of data frames.</h2><span id='topic+join_all'></span>

<h3>Description</h3>

<p>Recursively join a list of data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_all(dfs, by = NULL, type = "left", match = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join_all_+3A_dfs">dfs</code></td>
<td>
<p>A list of data frames.</p>
</td></tr>
<tr><td><code id="join_all_+3A_by">by</code></td>
<td>
<p>character vector of variable names to join by. If omitted, will
match on all common variables.</p>
</td></tr>
<tr><td><code id="join_all_+3A_type">type</code></td>
<td>
<p>type of join: left (default), right, inner or full.  See
details for more information.</p>
</td></tr>
<tr><td><code id="join_all_+3A_match">match</code></td>
<td>
<p>how should duplicate ids be matched? Either match just the
<code>"first"</code> matching row, or match <code>"all"</code> matching rows. Defaults
to <code>"all"</code> for compatibility with merge, but <code>"first"</code> is
significantly faster.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dfs &lt;- list(
  a = data.frame(x = 1:10, a = runif(10)),
  b = data.frame(x = 1:10, b = runif(10)),
  c = data.frame(x = 1:10, c = runif(10))
)
join_all(dfs)
join_all(dfs, "x")
</code></pre>

<hr>
<h2 id='join.keys'>Join keys.
Given two data frames, create a unique key for each row.</h2><span id='topic+join.keys'></span>

<h3>Description</h3>

<p>Join keys.
Given two data frames, create a unique key for each row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join.keys(x, y, by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join.keys_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="join.keys_+3A_y">y</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="join.keys_+3A_by">by</code></td>
<td>
<p>character vector of variable names to join by</p>
</td></tr>
</table>

<hr>
<h2 id='l_ply'>Split list, apply function, and discard results.</h2><span id='topic+l_ply'></span>

<h3>Description</h3>

<p>For each element of a list, apply function and discard results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_ply(
  .data,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .print = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l_ply_+3A_.data">.data</code></td>
<td>
<p>list to be processed</p>
</td></tr>
<tr><td><code id="l_ply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="l_ply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="l_ply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="l_ply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="l_ply_+3A_.print">.print</code></td>
<td>
<p>automatically print each result? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="l_ply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="l_ply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Input</h3>

<p>This function splits lists by elements.
</p>


<h3>Output</h3>

<p>All output is discarded. This is useful for functions that you are
calling purely for their side effects like displaying plots or
saving output.
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other list input: 
<code><a href="#topic+laply">laply</a>()</code>,
<code><a href="#topic+ldply">ldply</a>()</code>,
<code><a href="#topic+llply">llply</a>()</code>
</p>
<p>Other no output: 
<code><a href="#topic+a_ply">a_ply</a>()</code>,
<code><a href="#topic+d_ply">d_ply</a>()</code>,
<code><a href="#topic+m_ply">m_ply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l_ply(llply(mtcars, round), table, .print = TRUE)
l_ply(baseball, function(x) print(summary(x)))
</code></pre>

<hr>
<h2 id='laply'>Split list, apply function, and return results in an array.</h2><span id='topic+laply'></span>

<h3>Description</h3>

<p>For each element of a list, apply function then combine results into an
array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laply(
  .data,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .drop = TRUE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="laply_+3A_.data">.data</code></td>
<td>
<p>list to be processed</p>
</td></tr>
<tr><td><code id="laply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="laply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="laply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="laply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="laply_+3A_.drop">.drop</code></td>
<td>
<p>should extra dimensions of length 1 in the output be
dropped, simplifying the output.  Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="laply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="laply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>laply</code> is similar in spirit to <code><a href="base.html#topic+sapply">sapply</a></code> except
that it will always return an array, and the output is transposed with
respect <code>sapply</code> - each element of the list corresponds to a row,
not a column.
</p>


<h3>Value</h3>

<p>if results are atomic with same type and dimensionality, a
vector, matrix or array; otherwise, a list-array (a list with
dimensions)
</p>


<h3>Input</h3>

<p>This function splits lists by elements.
</p>


<h3>Output</h3>

<p>If there are no results, then this function will return a vector of
length 0 (<code>vector()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other list input: 
<code><a href="#topic+l_ply">l_ply</a>()</code>,
<code><a href="#topic+ldply">ldply</a>()</code>,
<code><a href="#topic+llply">llply</a>()</code>
</p>
<p>Other array output: 
<code><a href="#topic+aaply">aaply</a>()</code>,
<code><a href="#topic+daply">daply</a>()</code>,
<code><a href="#topic+maply">maply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>laply(baseball, is.factor)
# cf
ldply(baseball, is.factor)
colwise(is.factor)(baseball)

laply(seq_len(10), identity)
laply(seq_len(10), rep, times = 4)
laply(seq_len(10), matrix, nrow = 2, ncol = 2)
</code></pre>

<hr>
<h2 id='ldply'>Split list, apply function, and return results in a data frame.</h2><span id='topic+ldply'></span>

<h3>Description</h3>

<p>For each element of a list, apply function then combine results into a data
frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldply(
  .data,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .parallel = FALSE,
  .paropts = NULL,
  .id = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ldply_+3A_.data">.data</code></td>
<td>
<p>list to be processed</p>
</td></tr>
<tr><td><code id="ldply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="ldply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="ldply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="ldply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="ldply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="ldply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
<tr><td><code id="ldply_+3A_.id">.id</code></td>
<td>
<p>name of the index column (used if <code>.data</code> is a named list).
Pass <code>NULL</code> to avoid creation of the index column. For compatibility,
omit this argument or pass <code>NA</code> to avoid converting the index column
to a factor; in this case, <code>".id"</code> is used as colum name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, as described in the output section.
</p>


<h3>Input</h3>

<p>This function splits lists by elements.
</p>


<h3>Output</h3>

<p>The most unambiguous behaviour is achieved when <code>.fun</code> returns a
data frame - in that case pieces will be combined with
<code><a href="#topic+rbind.fill">rbind.fill</a></code>.  If <code>.fun</code> returns an atomic vector of
fixed length, it will be <code>rbind</code>ed together and converted to a data
frame. Any other values will result in an error.
</p>
<p>If there are no results, then this function will return a data
frame with zero rows and columns (<code>data.frame()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other list input: 
<code><a href="#topic+l_ply">l_ply</a>()</code>,
<code><a href="#topic+laply">laply</a>()</code>,
<code><a href="#topic+llply">llply</a>()</code>
</p>
<p>Other data frame output: 
<code><a href="#topic+adply">adply</a>()</code>,
<code><a href="#topic+ddply">ddply</a>()</code>,
<code><a href="#topic+mdply">mdply</a>()</code>
</p>

<hr>
<h2 id='liply'>Experimental iterator based version of llply.</h2><span id='topic+liply'></span>

<h3>Description</h3>

<p>Because iterators do not have known length, <code>liply</code> starts by
allocating an output list of length 50, and then doubles that length
whenever it runs out of space.  This gives O(n ln n) performance rather
than the O(n ^ 2) performance from the naive strategy of growing the list
each time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liply(.iterator, .fun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="liply_+3A_.iterator">.iterator</code></td>
<td>
<p>iterator object</p>
</td></tr>
<tr><td><code id="liply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="liply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Deprecated, do not use in new code.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plyr-deprecated">plyr-deprecated</a></code>
</p>

<hr>
<h2 id='list_to_array'>List to array.</h2><span id='topic+list_to_array'></span>

<h3>Description</h3>

<p>Reduce/simplify a list of homogenous objects to an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_array(res, labels = NULL, .drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_to_array_+3A_res">res</code></td>
<td>
<p>list of input data</p>
</td></tr>
<tr><td><code id="list_to_array_+3A_labels">labels</code></td>
<td>
<p>a data frame of labels, one row for each element of res</p>
</td></tr>
<tr><td><code id="list_to_array_+3A_.drop">.drop</code></td>
<td>
<p>should extra dimensions be dropped (TRUE) or preserved (FALSE)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other list simplification functions: 
<code><a href="#topic+list_to_dataframe">list_to_dataframe</a>()</code>,
<code><a href="#topic+list_to_vector">list_to_vector</a>()</code>
</p>

<hr>
<h2 id='list_to_dataframe'>List to data frame.</h2><span id='topic+list_to_dataframe'></span>

<h3>Description</h3>

<p>Reduce/simplify a list of homogenous objects to a data frame. All
<code>NULL</code> entries are removed. Remaining entries must be all atomic
or all data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_dataframe(res, labels = NULL, id_name = NULL, id_as_factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_to_dataframe_+3A_res">res</code></td>
<td>
<p>list of input data</p>
</td></tr>
<tr><td><code id="list_to_dataframe_+3A_labels">labels</code></td>
<td>
<p>a data frame of labels, one row for each element of res</p>
</td></tr>
<tr><td><code id="list_to_dataframe_+3A_id_name">id_name</code></td>
<td>
<p>the name of the index column, <code>NULL</code> for no index
column</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other list simplification functions: 
<code><a href="#topic+list_to_array">list_to_array</a>()</code>,
<code><a href="#topic+list_to_vector">list_to_vector</a>()</code>
</p>

<hr>
<h2 id='list_to_vector'>List to vector.</h2><span id='topic+list_to_vector'></span>

<h3>Description</h3>

<p>Reduce/simplify a list of homogenous objects to a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_vector(res)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_to_vector_+3A_res">res</code></td>
<td>
<p>list of input data</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other list simplification functions: 
<code><a href="#topic+list_to_array">list_to_array</a>()</code>,
<code><a href="#topic+list_to_dataframe">list_to_dataframe</a>()</code>
</p>

<hr>
<h2 id='llply'>Split list, apply function, and return results in a list.</h2><span id='topic+llply'></span>

<h3>Description</h3>

<p>For each element of a list, apply function, keeping results as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llply(
  .data,
  .fun = NULL,
  ...,
  .progress = "none",
  .inform = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llply_+3A_.data">.data</code></td>
<td>
<p>list to be processed</p>
</td></tr>
<tr><td><code id="llply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="llply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="llply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="llply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="llply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="llply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>llply</code> is equivalent to <code><a href="base.html#topic+lapply">lapply</a></code> except that it will
preserve labels and can display a progress bar.
</p>


<h3>Value</h3>

<p>list of results
</p>


<h3>Input</h3>

<p>This function splits lists by elements.
</p>


<h3>Output</h3>

<p>If there are no results, then this function will return
a list of length 0 (<code>list()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other list input: 
<code><a href="#topic+l_ply">l_ply</a>()</code>,
<code><a href="#topic+laply">laply</a>()</code>,
<code><a href="#topic+ldply">ldply</a>()</code>
</p>
<p>Other list output: 
<code><a href="#topic+alply">alply</a>()</code>,
<code><a href="#topic+dlply">dlply</a>()</code>,
<code><a href="#topic+mlply">mlply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>llply(llply(mtcars, round), table)
llply(baseball, summary)
# Examples from ?lapply
x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))

llply(x, mean)
llply(x, quantile, probs = 1:3/4)
</code></pre>

<hr>
<h2 id='loop_apply'>Loop apply</h2><span id='topic+loop_apply'></span>

<h3>Description</h3>

<p>An optimised version of lapply for the special case of operating on
<code>seq_len(n)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loop_apply(n, f, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loop_apply_+3A_n">n</code></td>
<td>
<p>length of sequence</p>
</td></tr>
<tr><td><code id="loop_apply_+3A_f">f</code></td>
<td>
<p>function to apply to each integer</p>
</td></tr>
<tr><td><code id="loop_apply_+3A_env">env</code></td>
<td>
<p>environment in which to evaluate function</p>
</td></tr>
</table>

<hr>
<h2 id='m_ply'>Call function with arguments in array or data frame, discarding results.</h2><span id='topic+m_ply'></span>

<h3>Description</h3>

<p>Call a multi-argument function with values taken from columns of an
data frame or array, and discard results into a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m_ply(
  .data,
  .fun = NULL,
  ...,
  .expand = TRUE,
  .progress = "none",
  .inform = FALSE,
  .print = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="m_ply_+3A_.data">.data</code></td>
<td>
<p>matrix or data frame to use as source of arguments</p>
</td></tr>
<tr><td><code id="m_ply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="m_ply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="m_ply_+3A_.expand">.expand</code></td>
<td>
<p>should output be 1d (expand = FALSE), with an element for
each row; or nd (expand = TRUE), with a dimension for each variable.</p>
</td></tr>
<tr><td><code id="m_ply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="m_ply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="m_ply_+3A_.print">.print</code></td>
<td>
<p>automatically print each result? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="m_ply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="m_ply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>m*ply</code> functions are the <code>plyr</code> version of <code>mapply</code>,
specialised according to the type of output they produce.  These functions
are just a convenient wrapper around <code>a*ply</code> with <code>margins = 1</code>
and <code>.fun</code> wrapped in <code><a href="#topic+splat">splat</a></code>.
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Input</h3>

<p>Call a multi-argument function with values taken from
columns of an data frame or array
</p>


<h3>Output</h3>

<p>All output is discarded. This is useful for functions that you are
calling purely for their side effects like displaying plots or
saving output.
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other multiple arguments input: 
<code><a href="#topic+maply">maply</a>()</code>,
<code><a href="#topic+mdply">mdply</a>()</code>,
<code><a href="#topic+mlply">mlply</a>()</code>
</p>
<p>Other no output: 
<code><a href="#topic+a_ply">a_ply</a>()</code>,
<code><a href="#topic+d_ply">d_ply</a>()</code>,
<code><a href="#topic+l_ply">l_ply</a>()</code>
</p>

<hr>
<h2 id='maply'>Call function with arguments in array or data frame, returning an array.</h2><span id='topic+maply'></span>

<h3>Description</h3>

<p>Call a multi-argument function with values taken from columns of an
data frame or array, and combine results into an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maply(
  .data,
  .fun = NULL,
  ...,
  .expand = TRUE,
  .progress = "none",
  .inform = FALSE,
  .drop = TRUE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maply_+3A_.data">.data</code></td>
<td>
<p>matrix or data frame to use as source of arguments</p>
</td></tr>
<tr><td><code id="maply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="maply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="maply_+3A_.expand">.expand</code></td>
<td>
<p>should output be 1d (expand = FALSE), with an element for
each row; or nd (expand = TRUE), with a dimension for each variable.</p>
</td></tr>
<tr><td><code id="maply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="maply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="maply_+3A_.drop">.drop</code></td>
<td>
<p>should extra dimensions of length 1 in the output be
dropped, simplifying the output.  Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="maply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="maply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>m*ply</code> functions are the <code>plyr</code> version of <code>mapply</code>,
specialised according to the type of output they produce.  These functions
are just a convenient wrapper around <code>a*ply</code> with <code>margins = 1</code>
and <code>.fun</code> wrapped in <code><a href="#topic+splat">splat</a></code>.
</p>


<h3>Value</h3>

<p>if results are atomic with same type and dimensionality, a
vector, matrix or array; otherwise, a list-array (a list with
dimensions)
</p>


<h3>Input</h3>

<p>Call a multi-argument function with values taken from
columns of an data frame or array
</p>


<h3>Output</h3>

<p>If there are no results, then this function will return a vector of
length 0 (<code>vector()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other multiple arguments input: 
<code><a href="#topic+m_ply">m_ply</a>()</code>,
<code><a href="#topic+mdply">mdply</a>()</code>,
<code><a href="#topic+mlply">mlply</a>()</code>
</p>
<p>Other array output: 
<code><a href="#topic+aaply">aaply</a>()</code>,
<code><a href="#topic+daply">daply</a>()</code>,
<code><a href="#topic+laply">laply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maply(cbind(mean = 1:5, sd = 1:5), rnorm, n = 5)
maply(expand.grid(mean = 1:5, sd = 1:5), rnorm, n = 5)
maply(cbind(1:5, 1:5), rnorm, n = 5)
</code></pre>

<hr>
<h2 id='mapvalues'>Replace specified values with new values, in a vector or factor.</h2><span id='topic+mapvalues'></span>

<h3>Description</h3>

<p>Item in <code>x</code> that match items <code>from</code> will be replaced by
items in <code>to</code>, matched by position. For example, items in <code>x</code> that
match the first element in <code>from</code> will be replaced by the first
element of <code>to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapvalues(x, from, to, warn_missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapvalues_+3A_x">x</code></td>
<td>
<p>the factor or vector to modify</p>
</td></tr>
<tr><td><code id="mapvalues_+3A_from">from</code></td>
<td>
<p>a vector of the items to replace</p>
</td></tr>
<tr><td><code id="mapvalues_+3A_to">to</code></td>
<td>
<p>a vector of replacement values</p>
</td></tr>
<tr><td><code id="mapvalues_+3A_warn_missing">warn_missing</code></td>
<td>
<p>print a message if any of the old values are
not actually present in <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a factor, the matching levels of the factor will be
replaced with the new values.
</p>
<p>The related <code>revalue</code> function works only on character vectors
and factors, but this function works on vectors of any type and factors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+revalue">revalue</a></code> to do the same thing but with a single
named vector instead of two separate vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a", "b", "c")
mapvalues(x, c("a", "c"), c("A", "C"))

# Works on factors
y &lt;- factor(c("a", "b", "c", "a"))
mapvalues(y, c("a", "c"), c("A", "C"))

# Works on numeric vectors
z &lt;- c(1, 4, 5, 9)
mapvalues(z, from = c(1, 5, 9), to = c(10, 50, 90))
</code></pre>

<hr>
<h2 id='match_df'>Extract matching rows of a data frame.</h2><span id='topic+match_df'></span>

<h3>Description</h3>

<p>Match works in the same way as join, but instead of return the combined
dataset, it only returns the matching rows from the first dataset. This is
particularly useful when you've summarised the data in some way
and want to subset the original data by a characteristic of the subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_df(x, y, on = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_df_+3A_x">x</code></td>
<td>
<p>data frame to subset.</p>
</td></tr>
<tr><td><code id="match_df_+3A_y">y</code></td>
<td>
<p>data frame defining matching rows.</p>
</td></tr>
<tr><td><code id="match_df_+3A_on">on</code></td>
<td>
<p>variables to match on - by default will use all variables common
to both data frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>match_df</code> shares the same semantics as <code><a href="#topic+join">join</a></code>, not
<code><a href="base.html#topic+match">match</a></code>:
</p>

<ul>
<li><p> the match criterion is <code>==</code>, not <code><a href="base.html#topic+identical">identical</a></code>).
</p>
</li>
<li><p> it doesn't work for columns that are not atomic vectors
</p>
</li>
<li><p> if there are no matches, the row will be omitted'
</p>
</li></ul>



<h3>Value</h3>

<p>a data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+join">join</a></code> to combine the columns from both x and y
and <code><a href="base.html#topic+match">match</a></code> for the base function selecting matching items
</p>


<h3>Examples</h3>

<pre><code class='language-R'># count the occurrences of each id in the baseball dataframe, then get the subset with a freq &gt;25
longterm &lt;- subset(count(baseball, "id"), freq &gt; 25)
# longterm
#             id freq
# 30   ansonca01   27
# 48   baineha01   27
# ...
# Select only rows from these longterm players from the baseball dataframe
# (match would default to match on shared column names, but here was explicitly set "id")
bb_longterm &lt;- match_df(baseball, longterm, on="id")
bb_longterm[1:5,]
</code></pre>

<hr>
<h2 id='mdply'>Call function with arguments in array or data frame, returning a data frame.</h2><span id='topic+mdply'></span>

<h3>Description</h3>

<p>Call a multi-argument function with values taken from columns of an
data frame or array, and combine results into a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdply(
  .data,
  .fun = NULL,
  ...,
  .expand = TRUE,
  .progress = "none",
  .inform = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdply_+3A_.data">.data</code></td>
<td>
<p>matrix or data frame to use as source of arguments</p>
</td></tr>
<tr><td><code id="mdply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="mdply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="mdply_+3A_.expand">.expand</code></td>
<td>
<p>should output be 1d (expand = FALSE), with an element for
each row; or nd (expand = TRUE), with a dimension for each variable.</p>
</td></tr>
<tr><td><code id="mdply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="mdply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="mdply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="mdply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>m*ply</code> functions are the <code>plyr</code> version of <code>mapply</code>,
specialised according to the type of output they produce.  These functions
are just a convenient wrapper around <code>a*ply</code> with <code>margins = 1</code>
and <code>.fun</code> wrapped in <code><a href="#topic+splat">splat</a></code>.
</p>


<h3>Value</h3>

<p>A data frame, as described in the output section.
</p>


<h3>Input</h3>

<p>Call a multi-argument function with values taken from
columns of an data frame or array
</p>


<h3>Output</h3>

<p>The most unambiguous behaviour is achieved when <code>.fun</code> returns a
data frame - in that case pieces will be combined with
<code><a href="#topic+rbind.fill">rbind.fill</a></code>.  If <code>.fun</code> returns an atomic vector of
fixed length, it will be <code>rbind</code>ed together and converted to a data
frame. Any other values will result in an error.
</p>
<p>If there are no results, then this function will return a data
frame with zero rows and columns (<code>data.frame()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other multiple arguments input: 
<code><a href="#topic+m_ply">m_ply</a>()</code>,
<code><a href="#topic+maply">maply</a>()</code>,
<code><a href="#topic+mlply">mlply</a>()</code>
</p>
<p>Other data frame output: 
<code><a href="#topic+adply">adply</a>()</code>,
<code><a href="#topic+ddply">ddply</a>()</code>,
<code><a href="#topic+ldply">ldply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdply(data.frame(mean = 1:5, sd = 1:5), rnorm, n = 2)
mdply(expand.grid(mean = 1:5, sd = 1:5), rnorm, n = 2)
mdply(cbind(mean = 1:5, sd = 1:5), rnorm, n = 5)
mdply(cbind(mean = 1:5, sd = 1:5), as.data.frame(rnorm), n = 5)
</code></pre>

<hr>
<h2 id='mlply'>Call function with arguments in array or data frame, returning a list.</h2><span id='topic+mlply'></span>

<h3>Description</h3>

<p>Call a multi-argument function with values taken from columns of an
data frame or array, and combine results into a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlply(
  .data,
  .fun = NULL,
  ...,
  .expand = TRUE,
  .progress = "none",
  .inform = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlply_+3A_.data">.data</code></td>
<td>
<p>matrix or data frame to use as source of arguments</p>
</td></tr>
<tr><td><code id="mlply_+3A_.fun">.fun</code></td>
<td>
<p>function to apply to each piece</p>
</td></tr>
<tr><td><code id="mlply_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="mlply_+3A_.expand">.expand</code></td>
<td>
<p>should output be 1d (expand = FALSE), with an element for
each row; or nd (expand = TRUE), with a dimension for each variable.</p>
</td></tr>
<tr><td><code id="mlply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="mlply_+3A_.inform">.inform</code></td>
<td>
<p>produce informative error messages?  This is turned off
by default because it substantially slows processing speed, but is very
useful for debugging</p>
</td></tr>
<tr><td><code id="mlply_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel
backend provided by foreach</p>
</td></tr>
<tr><td><code id="mlply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into
the <code><a href="foreach.html#topic+foreach">foreach</a></code> function when parallel computation
is enabled.  This is important if (for example) your code relies on
external data or packages: use the <code>.export</code> and <code>.packages</code>
arguments to supply them so that all cluster nodes have the correct
environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>m*ply</code> functions are the <code>plyr</code> version of <code>mapply</code>,
specialised according to the type of output they produce.  These functions
are just a convenient wrapper around <code>a*ply</code> with <code>margins = 1</code>
and <code>.fun</code> wrapped in <code><a href="#topic+splat">splat</a></code>.
</p>


<h3>Value</h3>

<p>list of results
</p>


<h3>Input</h3>

<p>Call a multi-argument function with values taken from
columns of an data frame or array
</p>


<h3>Output</h3>

<p>If there are no results, then this function will return
a list of length 0 (<code>list()</code>).
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy
for Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>See Also</h3>

<p>Other multiple arguments input: 
<code><a href="#topic+m_ply">m_ply</a>()</code>,
<code><a href="#topic+maply">maply</a>()</code>,
<code><a href="#topic+mdply">mdply</a>()</code>
</p>
<p>Other list output: 
<code><a href="#topic+alply">alply</a>()</code>,
<code><a href="#topic+dlply">dlply</a>()</code>,
<code><a href="#topic+llply">llply</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mlply(cbind(1:4, 4:1), rep)
mlply(cbind(1:4, times = 4:1), rep)

mlply(cbind(1:4, 4:1), seq)
mlply(cbind(1:4, length = 4:1), seq)
mlply(cbind(1:4, by = 4:1), seq, to = 20)
</code></pre>

<hr>
<h2 id='mutate'>Mutate a data frame by adding new or replacing existing columns.</h2><span id='topic+mutate'></span>

<h3>Description</h3>

<p>This function is very similar to <code><a href="base.html#topic+transform">transform</a></code> but it executes
the transformations iteratively so that later transformations can use the
columns created by earlier transformations.  Like transform, unnamed
components are silently dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate_+3A_.data">.data</code></td>
<td>
<p>the data frame to transform</p>
</td></tr>
<tr><td><code id="mutate_+3A_...">...</code></td>
<td>
<p>named parameters giving definitions of new columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mutate seems to be considerably faster than transform for large data
frames.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>, <code><a href="#topic+summarise">summarise</a></code>,
<code><a href="#topic+arrange">arrange</a></code>.  For another somewhat different approach to
solving the same problem, see <code><a href="base.html#topic+within">within</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples from transform
mutate(airquality, Ozone = -Ozone)
mutate(airquality, new = -Ozone, Temp = (Temp - 32) / 1.8)

# Things transform can't do
mutate(airquality, Temp = (Temp - 32) / 1.8, OzT = Ozone / Temp)

# mutate is rather faster than transform
system.time(transform(baseball, avg_ab = ab / g))
system.time(mutate(baseball, avg_ab = ab / g))
</code></pre>

<hr>
<h2 id='name_rows'>Toggle row names between explicit and implicit.</h2><span id='topic+name_rows'></span>

<h3>Description</h3>

<p>Plyr functions ignore row names, so this function provides a way to preserve
them by converting them to an explicit column in the data frame.  After the
plyr operation, you can then apply <code>name_rows</code> again to convert back
from the explicit column to the implicit <code>rownames</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_rows(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_rows_+3A_df">df</code></td>
<td>
<p>a data.frame, with either <code>rownames</code>, or a column called
<code>.rownames</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>name_rows(mtcars)
name_rows(name_rows(mtcars))

df &lt;- data.frame(a = sample(10))
arrange(df, a)
arrange(name_rows(df), a)
name_rows(arrange(name_rows(df), a))
</code></pre>

<hr>
<h2 id='names.quoted'>Compute names of quoted variables.</h2><span id='topic+names.quoted'></span>

<h3>Description</h3>

<p>Figure out names of quoted variables, using specified names if they exist,
otherwise converting the values to character strings.  This may create
variable names that can only be accessed using <code>``</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quoted'
names(x)
</code></pre>

<hr>
<h2 id='nunique'>Number of unique values.</h2><span id='topic+nunique'></span>

<h3>Description</h3>

<p>Calculate number of unique values of a variable as efficiently as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nunique(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nunique_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
</table>

<hr>
<h2 id='ozone'>Monthly ozone measurements over Central America.</h2><span id='topic+ozone'></span>

<h3>Description</h3>

<p>This data set is a subset of the data from the 2006 ASA Data expo
challenge, <a href="https://community.amstat.org/jointscsg-section/dataexpo/dataexpo2006">https://community.amstat.org/jointscsg-section/dataexpo/dataexpo2006</a>.
The data are monthly ozone averages on a very coarse 24 by 24 grid covering Central
America, from Jan 1995 to Dec 2000. The data is stored in a 3d area with
the first two dimensions representing latitude and longitude, and the third
representing time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ozone
</code></pre>


<h3>Format</h3>

<p>A 24 x 24 x 72 numeric array
</p>


<h3>References</h3>

<p><a href="https://community.amstat.org/jointscsg-section/dataexpo/dataexpo2006">https://community.amstat.org/jointscsg-section/dataexpo/dataexpo2006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>value &lt;- ozone[1, 1, ]
time &lt;- 1:72
month.abbr &lt;- c("Jan", "Feb", "Mar", "Apr", "May",
 "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
month &lt;- factor(rep(month.abbr, length = 72), levels = month.abbr)
year &lt;- rep(1:6, each = 12)
deseasf &lt;- function(value) lm(value ~ month - 1)

models &lt;- alply(ozone, 1:2, deseasf)
coefs &lt;- laply(models, coef)
dimnames(coefs)[[3]] &lt;- month.abbr
names(dimnames(coefs))[3] &lt;- "month"

deseas &lt;- laply(models, resid)
dimnames(deseas)[[3]] &lt;- 1:72
names(dimnames(deseas))[3] &lt;- "time"

dim(coefs)
dim(deseas)
</code></pre>

<hr>
<h2 id='plyr-deprecated'>Deprecated Functions in Package plyr</h2><span id='topic+plyr-deprecated'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of
<code>plyr</code> only, and may be defunct as soon as the next release.
</p>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+liply">liply</a></code>
</p>
</li>
<li> <p><code><a href="#topic+isplit2">isplit2</a></code>
</p>
</li></ul>


<hr>
<h2 id='print.quoted'>Print quoted variables.</h2><span id='topic+print.quoted'></span>

<h3>Description</h3>

<p>Display the <code><a href="utils.html#topic+str">str</a></code>ucture of quoted variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quoted'
print(x, ...)
</code></pre>

<hr>
<h2 id='print.split'>Print split.</h2><span id='topic+print.split'></span>

<h3>Description</h3>

<p>Don't print labels, so it appears like a regular list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'split'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.split_+3A_x">x</code></td>
<td>
<p>object to print</p>
</td></tr>
<tr><td><code id="print.split_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='progress_none'>Null progress bar</h2><span id='topic+progress_none'></span>

<h3>Description</h3>

<p>A progress bar that does nothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress_none()
</code></pre>


<h3>Details</h3>

<p>This the default progress bar used by plyr functions.  It's very simple to
understand - it does nothing!
</p>


<h3>See Also</h3>

<p>Other progress bars: 
<code><a href="#topic+progress_text">progress_text</a>()</code>,
<code><a href="#topic+progress_time">progress_time</a>()</code>,
<code><a href="#topic+progress_tk">progress_tk</a>()</code>,
<code><a href="#topic+progress_win">progress_win</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l_ply(1:100, identity, .progress = "none")
</code></pre>

<hr>
<h2 id='progress_text'>Text progress bar.</h2><span id='topic+progress_text'></span>

<h3>Description</h3>

<p>A textual progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress_text(style = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="progress_text_+3A_style">style</code></td>
<td>
<p>style of text bar, see Details section of <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code></p>
</td></tr>
<tr><td><code id="progress_text_+3A_...">...</code></td>
<td>
<p>other arugments passed on to <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This progress bar displays a textual progress bar that works on all
platforms.  It is a thin wrapper around the built-in
<code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and can be customised in the same way.
</p>


<h3>See Also</h3>

<p>Other progress bars: 
<code><a href="#topic+progress_none">progress_none</a>()</code>,
<code><a href="#topic+progress_time">progress_time</a>()</code>,
<code><a href="#topic+progress_tk">progress_tk</a>()</code>,
<code><a href="#topic+progress_win">progress_win</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l_ply(1:100, identity, .progress = "text")
l_ply(1:100, identity, .progress = progress_text(char = "-"))
</code></pre>

<hr>
<h2 id='progress_time'>Text progress bar with time.</h2><span id='topic+progress_time'></span>

<h3>Description</h3>

<p>A textual progress bar that estimates time remaining. It displays the
estimated time remaining and, when finished, total duration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress_time()
</code></pre>


<h3>See Also</h3>

<p>Other progress bars: 
<code><a href="#topic+progress_none">progress_none</a>()</code>,
<code><a href="#topic+progress_text">progress_text</a>()</code>,
<code><a href="#topic+progress_tk">progress_tk</a>()</code>,
<code><a href="#topic+progress_win">progress_win</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l_ply(1:100, function(x) Sys.sleep(.01), .progress = "time")
</code></pre>

<hr>
<h2 id='progress_tk'>Graphical progress bar, powered by Tk.</h2><span id='topic+progress_tk'></span>

<h3>Description</h3>

<p>A graphical progress bar displayed in a Tk window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress_tk(title = "plyr progress", label = "Working...", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="progress_tk_+3A_title">title</code></td>
<td>
<p>window title</p>
</td></tr>
<tr><td><code id="progress_tk_+3A_label">label</code></td>
<td>
<p>progress bar label (inside window)</p>
</td></tr>
<tr><td><code id="progress_tk_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="tcltk.html#topic+tkProgressBar">tkProgressBar</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This graphical progress will appear in a separate window.
</p>


<h3>See Also</h3>

<p><code><a href="tcltk.html#topic+tkProgressBar">tkProgressBar</a></code> for the function that powers this progress bar
</p>
<p>Other progress bars: 
<code><a href="#topic+progress_none">progress_none</a>()</code>,
<code><a href="#topic+progress_text">progress_text</a>()</code>,
<code><a href="#topic+progress_time">progress_time</a>()</code>,
<code><a href="#topic+progress_win">progress_win</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
l_ply(1:100, identity, .progress = "tk")
l_ply(1:100, identity, .progress = progress_tk(width=400))
l_ply(1:100, identity, .progress = progress_tk(label=""))

## End(Not run)
</code></pre>

<hr>
<h2 id='progress_win'>Graphical progress bar, powered by Windows.</h2><span id='topic+progress_win'></span>

<h3>Description</h3>

<p>A graphical progress bar displayed in a separate window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress_win(title = "plyr progress", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="progress_win_+3A_title">title</code></td>
<td>
<p>window title</p>
</td></tr>
<tr><td><code id="progress_win_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>winProgressBar</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This graphical progress only works on Windows.
</p>


<h3>See Also</h3>

<p><code>winProgressBar</code> for the function that powers this progress bar
</p>
<p>Other progress bars: 
<code><a href="#topic+progress_none">progress_none</a>()</code>,
<code><a href="#topic+progress_text">progress_text</a>()</code>,
<code><a href="#topic+progress_time">progress_time</a>()</code>,
<code><a href="#topic+progress_tk">progress_tk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
l_ply(1:100, identity, .progress = "win")
l_ply(1:100, identity, .progress = progress_win(title="Working..."))

## End(Not run)
</code></pre>

<hr>
<h2 id='quickdf'>Quick data frame.</h2><span id='topic+quickdf'></span>

<h3>Description</h3>

<p>Experimental version of <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> that converts a
list to a data frame, but doesn't do any checks to make sure it's a
valid format.  Much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickdf(list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickdf_+3A_list">list</code></td>
<td>
<p>list to convert to data frame</p>
</td></tr>
</table>

<hr>
<h2 id='r_ply'>Replicate expression and discard results.</h2><span id='topic+r_ply'></span>

<h3>Description</h3>

<p>Evalulate expression n times then discard results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_ply(.n, .expr, .progress = "none", .print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_ply_+3A_.n">.n</code></td>
<td>
<p>number of times to evaluate the expression</p>
</td></tr>
<tr><td><code id="r_ply_+3A_.expr">.expr</code></td>
<td>
<p>expression to evaluate</p>
</td></tr>
<tr><td><code id="r_ply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see <code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="r_ply_+3A_.print">.print</code></td>
<td>
<p>automatically print each result? (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs an expression multiple times, discarding the results.
This function is equivalent to <code><a href="base.html#topic+replicate">replicate</a></code>, but never returns
anything
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy for
Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r_ply(10, plot(runif(50)))
r_ply(25, hist(runif(1000)))
</code></pre>

<hr>
<h2 id='raply'>Replicate expression and return results in a array.</h2><span id='topic+raply'></span>

<h3>Description</h3>

<p>Evalulate expression n times then combine results into an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raply(.n, .expr, .progress = "none", .drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raply_+3A_.n">.n</code></td>
<td>
<p>number of times to evaluate the expression</p>
</td></tr>
<tr><td><code id="raply_+3A_.expr">.expr</code></td>
<td>
<p>expression to evaluate</p>
</td></tr>
<tr><td><code id="raply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see <code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="raply_+3A_.drop">.drop</code></td>
<td>
<p>should extra dimensions of length 1 be dropped, simplifying the output.  Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs an expression multiple times, and combines the
result into a data frame.  If there are no results, then this function
returns a vector of length 0 (<code>vector(0)</code>).
This function is equivalent to <code><a href="base.html#topic+replicate">replicate</a></code>, but will always
return results as a vector, matrix or array.
</p>


<h3>Value</h3>

<p>if results are atomic with same type and dimensionality, a vector, matrix or array; otherwise, a list-array (a list with dimensions)
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy for
Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raply(100, mean(runif(100)))
raply(100, each(mean, var)(runif(100)))

raply(10, runif(4))
raply(10, matrix(runif(4), nrow=2))

# See the central limit theorem in action
hist(raply(1000, mean(rexp(10))))
hist(raply(1000, mean(rexp(100))))
hist(raply(1000, mean(rexp(1000))))
</code></pre>

<hr>
<h2 id='rbind.fill'>Combine data.frames by row, filling in missing columns.</h2><span id='topic+rbind.fill'></span>

<h3>Description</h3>

<p><code>rbind</code>s a list of data frames filling missing columns with NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind.fill(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbind.fill_+3A_...">...</code></td>
<td>
<p>input data frames to row bind together.  The first argument can
be a list of data frames, in which case all other arguments are ignored.
Any NULL inputs are silently dropped. If all inputs are NULL, the output
is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an enhancement to <code><a href="base.html#topic+rbind">rbind</a></code> that adds in columns
that are not present in all inputs, accepts a list of data frames, and
operates substantially faster.
</p>
<p>Column names and types in the output will appear in the order in which
they were encountered.
</p>
<p>Unordered factor columns will have their levels unified and
character data bound with factors will be converted to
character. POSIXct data will be converted to be in the same time
zone. Array and matrix columns must have identical dimensions after
the row count. Aside from these there are no general checks that
each column is of consistent data type.
</p>


<h3>Value</h3>

<p>a single data frame
</p>


<h3>See Also</h3>

<p>Other binding functions: 
<code><a href="#topic+rbind.fill.matrix">rbind.fill.matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rbind.fill(mtcars[c("mpg", "wt")], mtcars[c("wt", "cyl")])
</code></pre>

<hr>
<h2 id='rbind.fill.matrix'>Bind matrices by row, and fill missing columns with NA.</h2><span id='topic+rbind.fill.matrix'></span>

<h3>Description</h3>

<p>The matrices are bound together using their column names or the column
indices (in that order of precedence.) Numeric columns may be converted to
character beforehand, e.g. using format.  If a matrix doesn't have
colnames, the column number is used. Note that this means that a
column with name <code>"1"</code> is merged with the first column of a matrix
without name and so on. The returned matrix will always have column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind.fill.matrix(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbind.fill.matrix_+3A_...">...</code></td>
<td>
<p>the matrices to rbind. The first argument can be a list of
matrices, in which case all other arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectors are converted to 1-column matrices.
</p>
<p>Matrices of factors are not supported. (They are anyways quite
inconvenient.) You may convert them first to either numeric or character
matrices. If a matrices of different types are merged, then normal
covnersion precendence will apply.
</p>
<p>Row names are ignored.
</p>


<h3>Value</h3>

<p>a matrix with column names
</p>


<h3>Author(s)</h3>

<p>C. Beleites
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rbind">rbind</a></code>, <code><a href="base.html#topic+cbind">cbind</a></code>,
<code><a href="#topic+rbind.fill">rbind.fill</a></code>
</p>
<p>Other binding functions: 
<code><a href="#topic+rbind.fill">rbind.fill</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix (1:4, 2)
B &lt;- matrix (6:11, 2)
A
B
rbind.fill.matrix (A, B)

colnames (A) &lt;- c (3, 1)
A
rbind.fill.matrix (A, B)

rbind.fill.matrix (A, 99)
</code></pre>

<hr>
<h2 id='rdply'>Replicate expression and return results in a data frame.</h2><span id='topic+rdply'></span>

<h3>Description</h3>

<p>Evaluate expression n times then combine results into a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdply(.n, .expr, .progress = "none", .id = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdply_+3A_.n">.n</code></td>
<td>
<p>number of times to evaluate the expression</p>
</td></tr>
<tr><td><code id="rdply_+3A_.expr">.expr</code></td>
<td>
<p>expression to evaluate</p>
</td></tr>
<tr><td><code id="rdply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
<tr><td><code id="rdply_+3A_.id">.id</code></td>
<td>
<p>name of the index column. Pass <code>NULL</code> to avoid creation of
the index column. For compatibility, omit this argument or pass <code>NA</code>
to use <code>".n"</code> as column name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs an expression multiple times, and combines the result into
a data frame.  If there are no results, then this function returns a data
frame with zero rows and columns (<code>data.frame()</code>). This function is
equivalent to <code><a href="base.html#topic+replicate">replicate</a></code>, but will always return results as a
data frame.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy for Data
Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdply(20, mean(runif(100)))
rdply(20, each(mean, var)(runif(100)))
rdply(20, data.frame(x = runif(2)))
</code></pre>

<hr>
<h2 id='reduce_dim'>Reduce dimensions.</h2><span id='topic+reduce_dim'></span>

<h3>Description</h3>

<p>Remove extraneous dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_dim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_dim_+3A_x">x</code></td>
<td>
<p>array</p>
</td></tr>
</table>

<hr>
<h2 id='rename'>Modify names by name, not position.</h2><span id='topic+rename'></span>

<h3>Description</h3>

<p>Modify names by name, not position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename(x, replace, warn_missing = TRUE, warn_duplicated = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_+3A_x">x</code></td>
<td>
<p>named object to modify</p>
</td></tr>
<tr><td><code id="rename_+3A_replace">replace</code></td>
<td>
<p>named character vector, with new names as values, and
old names as names.</p>
</td></tr>
<tr><td><code id="rename_+3A_warn_missing">warn_missing</code></td>
<td>
<p>print a message if any of the old names are
not actually present in <code>x</code>.</p>
</td></tr>
<tr><td><code id="rename_+3A_warn_duplicated">warn_duplicated</code></td>
<td>
<p>print a message if any name appears more
than once in <code>x</code> after the operation.
Note: x is not altered: To save the result, you need to copy the returned
data into a variable.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a" = 1, "b" = 2, d = 3, 4)
# Rename column d to "c", updating the variable "x" with the result
x &lt;- rename(x, replace = c("d" = "c"))
x
# Rename column "disp" to "displacement"
rename(mtcars, c("disp" = "displacement"))
</code></pre>

<hr>
<h2 id='revalue'>Replace specified values with new values, in a factor or character vector.</h2><span id='topic+revalue'></span>

<h3>Description</h3>

<p>If <code>x</code> is a factor, the named levels of the factor will be
replaced with the new values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revalue(x, replace = NULL, warn_missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="revalue_+3A_x">x</code></td>
<td>
<p>factor or character vector to modify</p>
</td></tr>
<tr><td><code id="revalue_+3A_replace">replace</code></td>
<td>
<p>named character vector, with new values as values, and
old values as names.</p>
</td></tr>
<tr><td><code id="revalue_+3A_warn_missing">warn_missing</code></td>
<td>
<p>print a message if any of the old values are
not actually present in <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works only on character vectors and factors, but the
related <code>mapvalues</code> function works on vectors of any type and factors,
and instead of a named vector specifying the original and replacement values,
it takes two separate vectors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mapvalues">mapvalues</a></code> to replace values with vectors of any type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a", "b", "c")
revalue(x, c(a = "A", c = "C"))
revalue(x, c("a" = "A", "c" = "C"))

y &lt;- factor(c("a", "b", "c", "a"))
revalue(y, c(a = "A", c = "C"))
</code></pre>

<hr>
<h2 id='rlply'>Replicate expression and return results in a list.</h2><span id='topic+rlply'></span>

<h3>Description</h3>

<p>Evalulate expression n times then combine results into a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlply(.n, .expr, .progress = "none")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlply_+3A_.n">.n</code></td>
<td>
<p>number of times to evaluate the expression</p>
</td></tr>
<tr><td><code id="rlply_+3A_.expr">.expr</code></td>
<td>
<p>expression to evaluate</p>
</td></tr>
<tr><td><code id="rlply_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see <code><a href="#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs an expression multiple times, and combines the
result into a list.  If there are no results, then this function will return
a list of length 0  (<code>list()</code>). This function is equivalent to
<code><a href="base.html#topic+replicate">replicate</a></code>, but will always return results as a list.
</p>


<h3>Value</h3>

<p>list of results
</p>


<h3>References</h3>

<p>Hadley Wickham (2011). The Split-Apply-Combine Strategy for
Data Analysis. Journal of Statistical Software, 40(1), 1-29.
<a href="https://www.jstatsoft.org/v40/i01/">https://www.jstatsoft.org/v40/i01/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mods &lt;- rlply(100, lm(y ~ x, data=data.frame(x=rnorm(100), y=rnorm(100))))
hist(laply(mods, function(x) summary(x)$r.squared))
</code></pre>

<hr>
<h2 id='round_any'>Round to multiple of any number.</h2><span id='topic+round_any'></span>

<h3>Description</h3>

<p>Round to multiple of any number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_any(x, accuracy, f = round)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="round_any_+3A_x">x</code></td>
<td>
<p>numeric or date-time (POSIXct) vector to round</p>
</td></tr>
<tr><td><code id="round_any_+3A_accuracy">accuracy</code></td>
<td>
<p>number to round to; for POSIXct objects, a number of seconds</p>
</td></tr>
<tr><td><code id="round_any_+3A_f">f</code></td>
<td>
<p>rounding function: <code><a href="base.html#topic+floor">floor</a></code>, <code><a href="base.html#topic+ceiling">ceiling</a></code> or
<code><a href="base.html#topic+round">round</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>round_any(135, 10)
round_any(135, 100)
round_any(135, 25)
round_any(135, 10, floor)
round_any(135, 100, floor)
round_any(135, 25, floor)
round_any(135, 10, ceiling)
round_any(135, 100, ceiling)
round_any(135, 25, ceiling)

round_any(Sys.time() + 1:10, 5)
round_any(Sys.time() + 1:10, 5, floor)
round_any(Sys.time(), 3600)
</code></pre>

<hr>
<h2 id='splat'>&lsquo;Splat&rsquo; arguments to a function.</h2><span id='topic+splat'></span>

<h3>Description</h3>

<p>Wraps a function in do.call, so instead of taking multiple arguments, it
takes a single named list which will be interpreted as its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splat(flat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splat_+3A_flat">flat</code></td>
<td>
<p>function to splat</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is useful when you want to pass a function a row of data frame or
array, and don't want to manually pull it apart in your function.
</p>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hp_per_cyl &lt;- function(hp, cyl, ...) hp / cyl
splat(hp_per_cyl)(mtcars[1,])
splat(hp_per_cyl)(mtcars)

f &lt;- function(mpg, wt, ...) data.frame(mw = mpg / wt)
ddply(mtcars, .(cyl), splat(f))
</code></pre>

<hr>
<h2 id='split_indices'>Split indices.</h2><span id='topic+split_indices'></span>

<h3>Description</h3>

<p>An optimised version of split for the special case of splitting row
indices into groups, as used by <code><a href="#topic+splitter_d">splitter_d</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_indices(group, n = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_indices_+3A_group">group</code></td>
<td>
<p>integer indices</p>
</td></tr>
<tr><td><code id="split_indices_+3A_n">n</code></td>
<td>
<p>largest integer (may not appear in index). This is hint: if
the largest value of <code>group</code> is bigger than <code>n</code>, the output
will silently expand.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>split_indices(sample(10, 100, rep = TRUE))
split_indices(sample(10, 100, rep = TRUE), 10)
</code></pre>

<hr>
<h2 id='split_labels'>Generate labels for split data frame.</h2><span id='topic+split_labels'></span>

<h3>Description</h3>

<p>Create data frame giving labels for split data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_labels(splits, drop, id = plyr::id(splits, drop = TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_labels_+3A_splits">splits</code></td>
<td>
<p>list of variables to split up by</p>
</td></tr>
<tr><td><code id="split_labels_+3A_drop">drop</code></td>
<td>
<p>whether all possible combinations should be considered, or only those present in the data</p>
</td></tr>
</table>

<hr>
<h2 id='splitter_a'>Split an array by .margins.</h2><span id='topic+splitter_a'></span>

<h3>Description</h3>

<p>Split a 2d or higher data structure into lower-d pieces based
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitter_a(data, .margins = 1L, .expand = TRUE, .id = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitter_a_+3A_data">data</code></td>
<td>
<p>&gt;1d data structure (matrix, data.frame or array)</p>
</td></tr>
<tr><td><code id="splitter_a_+3A_.margins">.margins</code></td>
<td>
<p>a vector giving the subscripts to split up <code>data</code> by.</p>
</td></tr>
<tr><td><code id="splitter_a_+3A_.expand">.expand</code></td>
<td>
<p>if splitting a dataframe by row, should output be 1d
(expand = FALSE), with an element for each row; or nd (expand = TRUE),
with a dimension for each variable.</p>
</td></tr>
<tr><td><code id="splitter_a_+3A_.id">.id</code></td>
<td>
<p>names of the split label.
Pass <code>NULL</code> to avoid creation of split labels.
Omit or pass <code>NA</code> to use the default names
<code>"X1"</code>, <code>"X2"</code>, ....
Otherwise, this argument must have the same length as
<code>.margins</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the workhorse of the <code>a*ply</code> functions.  Given a &gt;1 d
data structure (matrix, array, data.frame), it splits it into pieces
based on the subscripts that you supply.  Each piece is a lower dimensional
slice.
</p>
<p>The margins are specified in the same way as <code><a href="base.html#topic+apply">apply</a></code>, but
<code>splitter_a</code> just splits up the data, while <code>apply</code> also
applies a function and combines the pieces back together.  This function
also includes enough information to recreate the split from attributes on
the list of pieces.
</p>


<h3>Value</h3>

<p>a list of lower-d slices, with attributes that record split details
</p>


<h3>See Also</h3>

<p>Other splitter functions: 
<code><a href="#topic+splitter_d">splitter_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plyr:::splitter_a(mtcars, 1)
plyr:::splitter_a(mtcars, 2)

plyr:::splitter_a(ozone, 2)
plyr:::splitter_a(ozone, 3)
plyr:::splitter_a(ozone, 1:2)
</code></pre>

<hr>
<h2 id='splitter_d'>Split a data frame by variables.</h2><span id='topic+splitter_d'></span>

<h3>Description</h3>

<p>Split a data frame into pieces based on variable contained in that data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitter_d(data, .variables = NULL, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitter_d_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="splitter_d_+3A_.variables">.variables</code></td>
<td>
<p>a <a href="#topic+quoted">quoted</a> list of variables</p>
</td></tr>
<tr><td><code id="splitter_d_+3A_drop">drop</code></td>
<td>
<p>drop unnused factor levels?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the workhorse of the <code>d*ply</code> functions.  Based on the variables
you supply, it breaks up a single data frame into a list of data frames,
each containing a single combination from the levels of the specified
variables.
</p>
<p>This is basically a thin wrapper around <code><a href="base.html#topic+split">split</a></code> which
evaluates the variables in the context of the data, and includes enough
information to reconstruct the labelling of the data frame after
other operations.
</p>


<h3>Value</h3>

<p>a list of data.frames, with attributes that record split details
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.">.</a></code> for quoting variables, <code><a href="base.html#topic+split">split</a></code>
</p>
<p>Other splitter functions: 
<code><a href="#topic+splitter_a">splitter_a</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plyr:::splitter_d(mtcars, .(cyl))
plyr:::splitter_d(mtcars, .(vs, am))
plyr:::splitter_d(mtcars, .(am, vs))

mtcars$cyl2 &lt;- factor(mtcars$cyl, levels = c(2, 4, 6, 8, 10))
plyr:::splitter_d(mtcars, .(cyl2), drop = TRUE)
plyr:::splitter_d(mtcars, .(cyl2), drop = FALSE)

mtcars$cyl3 &lt;- ifelse(mtcars$vs == 1, NA, mtcars$cyl)
plyr:::splitter_d(mtcars, .(cyl3))
plyr:::splitter_d(mtcars, .(cyl3, vs))
plyr:::splitter_d(mtcars, .(cyl3, vs), drop = FALSE)
</code></pre>

<hr>
<h2 id='strip_splits'>Remove splitting variables from a data frame.</h2><span id='topic+strip_splits'></span>

<h3>Description</h3>

<p>This is useful when you want to perform some operation to every column
in the data frame, except the variables that you have used to split it.
These variables will be automatically added back on to the result when
combining all results together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_splits(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_splits_+3A_df">df</code></td>
<td>
<p>data frame produced by <code>d*ply</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dlply(mtcars, c("vs", "am"))
dlply(mtcars, c("vs", "am"), strip_splits)
</code></pre>

<hr>
<h2 id='summarise'>Summarise a data frame.</h2><span id='topic+summarise'></span><span id='topic+summarize'></span>

<h3>Description</h3>

<p>Summarise works in an analogous way to <code><a href="#topic+mutate">mutate</a></code>, except
instead of adding columns to an existing data frame, it creates a new
data frame.  This is particularly useful in conjunction with
<code><a href="#topic+ddply">ddply</a></code> as it makes it easy to perform group-wise summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_+3A_.data">.data</code></td>
<td>
<p>the data frame to be summarised</p>
</td></tr>
<tr><td><code id="summarise_+3A_...">...</code></td>
<td>
<p>further arguments of the form var = value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Be careful when using existing variable names; the corresponding
columns will be immediately updated with the new data and this can affect
subsequent operations referring to those variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's extract the number of teams and total period of time
# covered by the baseball dataframe
summarise(baseball,
 duration = max(year) - min(year),
 nteams = length(unique(team)))
# Combine with ddply to do that for each separate id
ddply(baseball, "id", summarise,
 duration = max(year) - min(year),
 nteams = length(unique(team)))
</code></pre>

<hr>
<h2 id='take'>Take a subset along an arbitrary dimension</h2><span id='topic+take'></span>

<h3>Description</h3>

<p>Take a subset along an arbitrary dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>take(x, along, indices, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="take_+3A_x">x</code></td>
<td>
<p>matrix or array to subset</p>
</td></tr>
<tr><td><code id="take_+3A_along">along</code></td>
<td>
<p>dimension to subset along</p>
</td></tr>
<tr><td><code id="take_+3A_indices">indices</code></td>
<td>
<p>the indices to select</p>
</td></tr>
<tr><td><code id="take_+3A_drop">drop</code></td>
<td>
<p>should the dimensions of the array be simplified? Defaults
to <code>FALSE</code> which is the opposite of the useful R default.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(seq_len(3 * 4 * 5), c(3, 4, 5))
take(x, 3, 1)
take(x, 2, 1)
take(x, 1, 1)
take(x, 3, 1, drop = TRUE)
take(x, 2, 1, drop = TRUE)
take(x, 1, 1, drop = TRUE)
</code></pre>

<hr>
<h2 id='true'>Function that always returns true.</h2><span id='topic+true'></span>

<h3>Description</h3>

<p>Function that always returns true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>true(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="true_+3A_...">...</code></td>
<td>
<p>all input ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colwise">colwise</a></code> which uses it
</p>

<hr>
<h2 id='try_default'>Try, with default in case of error.</h2><span id='topic+try_default'></span><span id='topic+tryNULL'></span>

<h3>Description</h3>

<p><code>try_default</code> wraps try so that it returns a default value in the case of error.
<code>tryNULL</code> provides a useful special case when dealing with lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_default(expr, default, quiet = FALSE)

tryNULL(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try_default_+3A_expr">expr</code></td>
<td>
<p>expression to try</p>
</td></tr>
<tr><td><code id="try_default_+3A_default">default</code></td>
<td>
<p>default value in case of error</p>
</td></tr>
<tr><td><code id="try_default_+3A_quiet">quiet</code></td>
<td>
<p>should errors be printed (TRUE) or ignored (FALSE, default)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tryapply">tryapply</a></code>
</p>

<hr>
<h2 id='tryapply'>Apply with built in try.
Uses compact, lapply and tryNULL</h2><span id='topic+tryapply'></span>

<h3>Description</h3>

<p>Apply with built in try.
Uses compact, lapply and tryNULL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryapply(list, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tryapply_+3A_list">list</code></td>
<td>
<p>list to apply function <code>f</code> on</p>
</td></tr>
<tr><td><code id="tryapply_+3A_fun">fun</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="tryapply_+3A_...">...</code></td>
<td>
<p>further arguments to <code>f</code></p>
</td></tr>
</table>

<hr>
<h2 id='unrowname'>Un-rowname.</h2><span id='topic+unrowname'></span>

<h3>Description</h3>

<p>Strip rownames from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unrowname(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unrowname_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>

<hr>
<h2 id='vaggregate'>Vector aggregate.</h2><span id='topic+vaggregate'></span>

<h3>Description</h3>

<p>This function is somewhat similar to <code>tapply</code>, but is designed for
use in conjunction with <code>id</code>. It is simpler in that it only
accepts a single grouping vector (use <code><a href="#topic+id">id</a></code> if you have more)
and uses <code><a href="base.html#topic+vapply">vapply</a></code> internally, using the <code>.default</code> value
as the template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vaggregate(.value, .group, .fun, ..., .default = NULL, .n = nlevels(.group))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vaggregate_+3A_.value">.value</code></td>
<td>
<p>vector of values to aggregate</p>
</td></tr>
<tr><td><code id="vaggregate_+3A_.group">.group</code></td>
<td>
<p>grouping vector</p>
</td></tr>
<tr><td><code id="vaggregate_+3A_.fun">.fun</code></td>
<td>
<p>aggregation function</p>
</td></tr>
<tr><td><code id="vaggregate_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>.fun</code></p>
</td></tr>
<tr><td><code id="vaggregate_+3A_.default">.default</code></td>
<td>
<p>default value used for missing groups.  This argument is
also used as the template for function output.</p>
</td></tr>
<tr><td><code id="vaggregate_+3A_.n">.n</code></td>
<td>
<p>total number of groups</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vaggregate</code> should be faster than <code>tapply</code> in most situations
because it avoids making a copy of the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Some examples of use borrowed from ?tapply
n &lt;- 17; fac &lt;- factor(rep(1:3, length.out = n), levels = 1:5)
table(fac)
vaggregate(1:n, fac, sum)
vaggregate(1:n, fac, sum, .default = NA_integer_)
vaggregate(1:n, fac, range)
vaggregate(1:n, fac, range, .default = c(NA, NA) + 0)
vaggregate(1:n, fac, quantile)
# Unlike tapply, vaggregate does not support multi-d output:
tapply(warpbreaks$breaks, warpbreaks[,-1], sum)
vaggregate(warpbreaks$breaks, id(warpbreaks[,-1]), sum)

# But it is about 10x faster
x &lt;- rnorm(1e6)
y1 &lt;- sample.int(10, 1e6, replace = TRUE)
system.time(tapply(x, y1, mean))
system.time(vaggregate(x, y1, mean))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
